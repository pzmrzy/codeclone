commit 0a723aa03fbc82eb8949f3016a998959f09f98d2
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Fri Jun 17 07:08:29 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Fri Jun 17 07:08:29 2011 -0800

(C# 3) Move most inline grammar actions to the helper file

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 8654]

diff --git a/Antlr3/Grammars/DefineGrammarItemsWalker.g3 b/Antlr3/Grammars/DefineGrammarItemsWalker.g3
index 5fef3bf..589f598 100644
--- a/Antlr3/Grammars/DefineGrammarItemsWalker.g3
+++ b/Antlr3/Grammars/DefineGrammarItemsWalker.g3
@@ -45,7 +45,6 @@ scope AttributeScopeActions

@header
{
-using System;
using Antlr3.Tool;
}

@@ -62,10 +61,10 @@ root = $start;
{
Finish();
}
-	:	^( LEXER_GRAMMAR	{grammar.type = GrammarType.Lexer;} 		grammarSpec )
-	|	^( PARSER_GRAMMAR	{grammar.type = GrammarType.Parser;}		grammarSpec )
-	|	^( TREE_GRAMMAR		{grammar.type = GrammarType.TreeParser;}	grammarSpec )
-	|	^( COMBINED_GRAMMAR	{grammar.type = GrammarType.Combined;}		grammarSpec )
+	:	^(LEXER_GRAMMAR		grammarSpec)
+	|	^(PARSER_GRAMMAR	grammarSpec)
+	|	^(TREE_GRAMMAR		grammarSpec)
+	|	^(COMBINED_GRAMMAR	grammarSpec)
;

attrScope
@@ -75,53 +74,44 @@ scope AttributeScopeActions;
$AttributeScopeActions::actions = new Dictionary<GrammarAST, GrammarAST>();
}
:	^( 'scope' name=ID attrScopeAction* attrs=ACTION )
-		{
-			AttributeScope scope = grammar.DefineGlobalScope($name.text,$attrs.Token);
-			scope.IsDynamicGlobalScope = true;
-			scope.AddAttributes($attrs.text, ';');
-			foreach ( var action in $AttributeScopeActions::actions )
-				scope.DefineNamedAction( action.Key, action.Value );
-		}
+		{HandleAttrScope($name, $attrs, $AttributeScopeActions::actions);}
;

attrScopeAction
:	^(AMPERSAND ID ACTION)
-		{
-			$AttributeScopeActions::actions.Add( $ID, $ACTION );
-		}
+		{HandleAttrScopeAction($ID, $ACTION, $AttributeScopeActions::actions);}
;

grammarSpec
-	:	id=ID
-		(cmt=DOC_COMMENT)?
-		( optionsSpec )?
-		(delegateGrammars)?
-		(tokensSpec)?
-		(attrScope)*
-		(actions)?
+	:	ID
+		DOC_COMMENT?
+		optionsSpec?
+		delegateGrammars?
+		tokensSpec?
+		attrScope*
+		actions?
rules
;

actions
-	:	( action )+
+	:	action+
;

action
@init
{
-	string scope=null;
-	GrammarAST nameAST=null, actionAST=null;
+	string scope = null;
+	GrammarAST nameAST = null;
+	GrammarAST actionAST = null;
}
:	^(amp=AMPERSAND id1=ID
( id2=ID a1=ACTION
-			  {scope=$id1.text; nameAST=$id2; actionAST=$a1;}
+			  {scope = $id1.text; nameAST = $id2; actionAST = $a1;}
| a2=ACTION
-			  {scope=null; nameAST=$id1; actionAST=$a2;}
+			  {scope = null; nameAST = $id1; actionAST = $a2;}
)
)
-		 {
-		 grammar.DefineNamedAction($amp,scope,nameAST,actionAST);
-		 }
+		 {HandleAction(scope, $amp, nameAST, actionAST);}
;

optionsSpec
@@ -137,7 +127,7 @@ tokensSpec
;

tokenSpec
-	:	t=TOKEN_REF
+	:	TOKEN_REF
|	^(	ASSIGN
TOKEN_REF
(	STRING_LITERAL
@@ -153,62 +143,26 @@ rules
rule
@init
{
-	string name=null;
-	IDictionary<string,object> opts=null;
+	string name = null;
+	IDictionary<string, object> opts = null;
Rule r = null;
}
-	:		^( RULE id=ID {opts = $RULE.BlockOptions;}
-			(modifier)?
+	:	^(	RULE id=ID {opts = $RULE.BlockOptions;}
+			modifier?
^( ARG (args=ARG_ACTION)? )
^( RET (ret=ARG_ACTION)? )
-			(throwsSpec)?
-			(optionsSpec)?
-			{
-				name = $id.text;
-				currentRuleName = name;
-				if ( Rule.GetRuleType(name) == RuleType.Lexer && grammar.type==GrammarType.Combined )
-				{
-					// a merged grammar spec, track lexer rules and send to another grammar
-					grammar.DefineLexerRuleFoundInParser($id.Token, $start);
-				}
-				else
-				{
-					int numAlts = CountAltsForRule($start);
-					grammar.DefineRule($id.Token, $modifier.mod, opts, $start, $args, numAlts);
-					r = grammar.GetRule(name);
-					if ( $args!=null )
-					{
-						r.ParameterScope = grammar.CreateParameterScope(name,$args.Token);
-						r.ParameterScope.AddAttributes($args.text, ',');
-					}
-					if ( $ret!=null )
-					{
-						r.ReturnScope = grammar.CreateReturnScope(name,$ret.Token);
-						r.ReturnScope.AddAttributes($ret.text, ',');
-					}
-					if ( $throwsSpec.exceptions != null )
-					{
-						foreach ( string exception in $throwsSpec.exceptions )
-							r.ThrowsSpec.Add( exception );
-					}
-				}
-			}
-			(ruleScopeSpec[r])?
-			(ruleAction[r])*
-			{ this.blockLevel=0; }
+			throwsSpec?
+			optionsSpec?				{HandleRuleAfterOptionsSpec(ref name, ref r, opts, $start, $id, $modifier.mod, $args, $ret, $throwsSpec.exceptions);}
+			ruleScopeSpec[r]?
+			ruleAction[r]*				{HandleRuleAfterRuleActions();}
b=block
-			(exceptionGroup)?
-			EOR
-			{
-				// copy rule options into the block AST, which is where
-				// the analysis will look for k option etc...
-				$b.start.BlockOptions = opts;
-			}
+			exceptionGroup?
+			EOR							{HandleRuleEnd($b.start, opts);}
)
;

ruleAction[Rule r]
-	:	^(amp=AMPERSAND id=ID a=ACTION ) {if (r!=null) r.DefineNamedAction($amp,$id,$a);}
+	:	^(amp=AMPERSAND id=ID a=ACTION) {HandleRuleAction(r, $amp, $id, $a);}
;

modifier returns [string mod]
@@ -222,11 +176,7 @@ modifier returns [string mod]
|	'fragment'
;

-throwsSpec returns [HashSet<string> exceptions]
-@init
-{
-	$exceptions = new HashSet<string>();
-}
+throwsSpec returns [HashSet<string> exceptions = new HashSet<string>()]
:	^('throws' (ID {$exceptions.Add($ID.text);})+ )
;

@@ -237,28 +187,9 @@ scope AttributeScopeActions;
$AttributeScopeActions::actions = new Dictionary<GrammarAST, GrammarAST>();
}
:	^(	'scope'
-			(	attrScopeAction* attrs=ACTION
-				{
-					r.RuleScope = grammar.CreateRuleScope(r.Name,$attrs.Token);
-					r.RuleScope.IsDynamicRuleScope = true;
-					r.RuleScope.AddAttributes($attrs.text, ';');
-					foreach ( var action in $AttributeScopeActions::actions )
-						r.RuleScope.DefineNamedAction( action.Key, action.Value );
-				}
+			(	attrScopeAction* attrs=ACTION	{HandleRuleScopeSpecAction(r, $attrs, $AttributeScopeActions::actions);}
)?
-			(	uses=ID
-				{
-					if ( grammar.GetGlobalScope($uses.text)==null ) {
-					ErrorManager.GrammarError(ErrorManager.MSG_UNKNOWN_DYNAMIC_SCOPE,
-					grammar,
-					$uses.Token,
-					$uses.text);
-					}
-					else {
-					if ( r.UseScopes==null ) {r.UseScopes=new List<string>();}
-					r.UseScopes.Add($uses.text);
-					}
-				}
+			(	uses=ID							{HandleRuleScopeSpecUses(r, $uses);}
)*
)
;
@@ -287,37 +218,15 @@ finally { blockLevel--; }

// TODO: this does nothing now! subrules cannot have init actions. :(
blockAction
-	:	^(amp=AMPERSAND id=ID a=ACTION ) // {r.defineAction(#amp,#id,#a);}
+	:	^(AMPERSAND ID ACTION)
;

alternative
-//@init
-//{
-//	if ( state.backtracking == 0 )
-//	{
-//		if ( grammar.type!=GrammarType.Lexer && grammar.GetOption("output")!=null && blockLevel==1 )
-//		{
-//			GrammarAST aRewriteNode = $start.FindFirstType(REWRITE); // alt itself has rewrite?
-//			GrammarAST rewriteAST = (GrammarAST)$start.Parent.GetChild($start.ChildIndex + 1);
-//			// we have a rewrite if alt uses it inside subrule or this alt has one
-//			// but don't count -> ... rewrites, which mean "do default auto construction"
-//			if ( aRewriteNode!=null||
-//				 (firstRewriteAST!=null &&
-//				  firstRewriteAST.Type==REWRITE &&
-//				  firstRewriteAST.GetChild(0)!=null &&
-//				  firstRewriteAST.GetChild(0).Type!=ETC) )
-//			{
-//				Rule r = grammar.GetRule(currentRuleName);
-//				r.TrackAltsWithRewrites($start,this.outerAltNum);
-//			}
-//		}
-//	}
-//}
-	:	^( ALT (element)+ EOA )
+	:	^(ALT element+ EOA)
;

exceptionGroup
-	:	( exceptionHandler )+ (finallyClause)?
+	:	exceptionHandler+ finallyClause?
|	finallyClause
;

@@ -336,101 +245,35 @@ element
|   ^(NOT element)
|   ^(RANGE atom[null] atom[null])
|   ^(CHAR_RANGE atom[null] atom[null])
-	|	^(	ASSIGN id=ID el=element)
-			{
-				GrammarAST e = $el.start;
-				if ( e.Type==ANTLRParser.ROOT || e.Type==ANTLRParser.BANG )
-				{
-					e = (GrammarAST)e.GetChild(0);
-				}
-				if ( e.Type==RULE_REF)
-				{
-					grammar.DefineRuleRefLabel(currentRuleName,$id.Token,e);
-				}
-				else if ( e.Type==WILDCARD && grammar.type==GrammarType.TreeParser )
-				{
-					grammar.DefineWildcardTreeLabel(currentRuleName,$id.Token,e);
-				}
-				else
-				{
-					grammar.DefineTokenRefLabel(currentRuleName,$id.Token,e);
-				}
-			}
-	|	^(	PLUS_ASSIGN id2=ID a2=element
-			{
-				GrammarAST a = $a2.start;
-				if ( a.Type==ANTLRParser.ROOT || a.Type==ANTLRParser.BANG )
-				{
-					a = (GrammarAST)a.GetChild(0);
-				}
-				if ( a.Type==RULE_REF )
-				{
-					grammar.DefineRuleListLabel(currentRuleName,$id2.Token,a);
-				}
-				else if ( a.Type == WILDCARD && grammar.type == GrammarType.TreeParser )
-				{
-					grammar.DefineWildcardTreeListLabel( currentRuleName, $id2.Token, a );
-				}
-				else
-				{
-					grammar.DefineTokenListLabel(currentRuleName,$id2.Token,a);
-				}
-			}
-		 )
+	|	^(ASSIGN id=ID el=element)			{HandleElementAssign($id, $el.start);}
+	|	^(PLUS_ASSIGN id=ID el=element)		{HandleElementPlusAssign($id, $el.start);}
|   ebnf
|   tree_
-	|   ^( SYNPRED block )
-	|   act=ACTION
-		{
-			$act.outerAltNum = this.outerAltNum;
-			TrackInlineAction($act);
-		}
-	|   act2=FORCED_ACTION
-		{
-			$act2.outerAltNum = this.outerAltNum;
-			TrackInlineAction($act2);
-		}
-	|   SEMPRED
-		{
-			$SEMPRED.outerAltNum = this.outerAltNum;
-			TrackInlineAction($SEMPRED);
-		}
+	|   ^(SYNPRED block)
+	|   act=ACTION							{HandleInlineAction($act);}
+	|   act=FORCED_ACTION					{HandleInlineAction($act);}
+	|   act=SEMPRED							{HandleInlineAction($act);}
|   SYN_SEMPRED
|   ^(BACKTRACK_SEMPRED .*)
-	|   GATED_SEMPRED
-		{
-			$GATED_SEMPRED.outerAltNum = this.outerAltNum;
-			TrackInlineAction($GATED_SEMPRED);
-		}
+	|   act=GATED_SEMPRED					{HandleInlineAction($act);}
|   EPSILON
;

ebnf
:	(dotLoop) => dotLoop // .* or .+
|	block
-	|	^( OPTIONAL block )
-	|	^( CLOSURE block )
-	|	^( POSITIVE_CLOSURE block )
+	|	^(OPTIONAL block)
+	|	^(CLOSURE block)
+	|	^(POSITIVE_CLOSURE block)
;

/** Track the .* and .+ idioms and make them nongreedy by default.
*/
dotLoop
-	:	(	^( CLOSURE dotBlock )
-		|	^( POSITIVE_CLOSURE dotBlock )
+	:	(	^(CLOSURE dotBlock)
+		|	^(POSITIVE_CLOSURE dotBlock)
)
-		{
-			GrammarAST block = (GrammarAST)$start.GetChild(0);
-			IDictionary<string, object> opts=new Dictionary<string, object>();
-			opts["greedy"] = "false";
-			if ( grammar.type!=GrammarType.Lexer )
-			{
-				// parser grammars assume k=1 for .* loops
-				// otherwise they (analysis?) look til EOF!
-				opts["k"] = 1;
-			}
-			block.SetOptions(grammar,opts);
-		}
+		{HandleDotLoop($start);}
;

dotBlock
@@ -442,49 +285,10 @@ tree_
;

atom[GrammarAST scope_]
-	:	^( rr=RULE_REF (rarg=ARG_ACTION)? )
-		{
-			grammar.AltReferencesRule( currentRuleName, $scope_, $rr, this.outerAltNum );
-			if ( $rarg != null )
-			{
-				$rarg.outerAltNum = this.outerAltNum;
-				TrackInlineAction($rarg);
-			}
-		}
-	|	^( t=TOKEN_REF (targ=ARG_ACTION )? )
-		{
-			if ( $targ != null )
-			{
-				$targ.outerAltNum = this.outerAltNum;
-				TrackInlineAction($targ);
-			}
-			if ( grammar.type == GrammarType.Lexer )
-			{
-				grammar.AltReferencesRule( currentRuleName, $scope_, $t, this.outerAltNum );
-			}
-			else
-			{
-				grammar.AltReferencesTokenID( currentRuleName, $t, this.outerAltNum );
-			}
-		}
-	|	c=CHAR_LITERAL
-		{
-			if ( grammar.type != GrammarType.Lexer )
-			{
-				Rule rule = grammar.GetRule(currentRuleName);
-				if ( rule != null )
-					rule.TrackTokenReferenceInAlt($c, outerAltNum);
-			}
-		}
-	|	s=STRING_LITERAL
-		{
-			if ( grammar.type != GrammarType.Lexer )
-			{
-				Rule rule = grammar.GetRule(currentRuleName);
-				if ( rule!=null )
-					rule.TrackTokenReferenceInAlt($s, outerAltNum);
-			}
-		}
+	:	^( t=RULE_REF (a=ARG_ACTION)? )		{HandleRuleReferenceAtom($scope_, $t, $a);}
+	|	^( t=TOKEN_REF (a=ARG_ACTION )? )	{HandleTokenReferenceAtom($scope_, $t, $a);}
+	|	t=CHAR_LITERAL						{HandleStringLiteralAtom($t);}
+	|	t=STRING_LITERAL					{HandleStringLiteralAtom($t);}
|	WILDCARD
|	^(DOT ID atom[$ID]) // scope override on rule
;
@@ -506,14 +310,11 @@ rewrite
}
}
:	^(	REWRITES
-			(	^( REWRITE (pred=SEMPRED)? rewrite_alternative )
-				{
-					if ( $pred != null )
-					{
-						$pred.outerAltNum = this.outerAltNum;
-						TrackInlineAction($pred);
-					}
-				}
+			(	^(	REWRITE
+					(	pred=SEMPRED	{HandleInlineAction($pred);}
+					)?
+					rewrite_alternative
+				)
)*
)
//{System.out.println("-> refs = "+currentRewriteRule.rewriteRefsDeep);}
@@ -541,13 +342,12 @@ rewrite_block
foreach ( var item in currentRewriteBlock.rewriteRefsShallow )
enclosingBlock.rewriteRefsDeep.Add( item );
}
-			//currentRewriteBlock = enclosingBlock; // restore old BLOCK ptr
}
;
-finally { currentRewriteBlock = enclosingBlock; }
+finally { currentRewriteBlock = enclosingBlock; /* restore old BLOCK ptr */ }

rewrite_alternative
-	:	{grammar.BuildAST}? => ^( a=ALT ( ( rewrite_element )+ | EPSILON ) EOA )
+	:	{grammar.BuildAST}? => ^(ALT (rewrite_element+ | EPSILON) EOA)
|	{grammar.BuildTemplate}? => rewrite_template
|	ETC {this.blockLevel==1}? // only valid as outermost rewrite
;
@@ -565,83 +365,40 @@ rewrite_ebnf
;

rewrite_tree
-	:   ^(	TREE_BEGIN rewrite_atom ( rewrite_element )* )
+	:   ^(TREE_BEGIN rewrite_atom rewrite_element*)
;

rewrite_atom
@init
{
-	if ( state.backtracking == 0 )
-	{
-		Rule r = grammar.GetRule(currentRuleName);
-		var tokenRefsInAlt = r.GetTokenRefsInAlt(outerAltNum);
-		bool imaginary =
-			$start.Type==TOKEN_REF &&
-			!tokenRefsInAlt.Contains($start.Text);
-		if ( !imaginary && grammar.BuildAST &&
-			 ($start.Type==RULE_REF ||
-			  $start.Type==LABEL ||
-			  $start.Type==TOKEN_REF ||
-			  $start.Type==CHAR_LITERAL ||
-			  $start.Type==STRING_LITERAL) )
-		{
-			// track per block and for entire rewrite rule
-			if ( currentRewriteBlock!=null )
-			{
-				currentRewriteBlock.rewriteRefsShallow.Add($start);
-				currentRewriteBlock.rewriteRefsDeep.Add($start);
-			}
-
-			//System.out.println("adding "+$start.Text+" to "+currentRewriteRule.Text);
-			currentRewriteRule.rewriteRefsDeep.Add($start);
-		}
-	}
+	if (state.backtracking == 0)
+		HandleRewriteAtomStart($start);
}
:	RULE_REF
|	(	^(	TOKEN_REF
-				(	ARG_ACTION
-					{
-						$ARG_ACTION.outerAltNum = this.outerAltNum;
-						TrackInlineAction($ARG_ACTION);
-					}
+				(	ARG_ACTION	{HandleInlineAction($ARG_ACTION);}
)?
)
|	CHAR_LITERAL
|	STRING_LITERAL
)
|	LABEL
-	|	ACTION
-		{
-			$ACTION.outerAltNum = this.outerAltNum;
-			TrackInlineAction($ACTION);
-		}
+	|	ACTION					{HandleInlineAction($ACTION);}
;

rewrite_template
:	^(	ALT EPSILON EOA )
-	|	^(	TEMPLATE (id=ID|ind=ACTION)
-			^( ARGLIST
-				(	^( ARG arg=ID a=ACTION )
-					{
-						$a.outerAltNum = this.outerAltNum;
-						TrackInlineAction($a);
-					}
+	|	^(	TEMPLATE
+			(	ID
+			|	a=ACTION				{HandleInlineAction($a);}
+			)
+			^(	ARGLIST
+				(	^(ARG ID a=ACTION)	{HandleInlineAction($a);}
)*
)
-			{
-				if ( $ind!=null )
-				{
-					$ind.outerAltNum = this.outerAltNum;
-					TrackInlineAction($ind);
-				}
-			}
(	DOUBLE_QUOTE_STRING_LITERAL
|	DOUBLE_ANGLE_STRING_LITERAL
)?
)
-	|	act=ACTION
-		{
-			$act.outerAltNum = this.outerAltNum;
-			TrackInlineAction($act);
-		}
+	|	a=ACTION						{HandleInlineAction($a);}
;
diff --git a/Antlr3/Grammars/DefineGrammarItemsWalkerHelper.cs b/Antlr3/Grammars/DefineGrammarItemsWalkerHelper.cs
index f00e179..8546354 100644
--- a/Antlr3/Grammars/DefineGrammarItemsWalkerHelper.cs
+++ b/Antlr3/Grammars/DefineGrammarItemsWalkerHelper.cs
@@ -33,6 +33,7 @@
namespace Antlr3.Grammars
{
using System;
+    using System.Collections.Generic;
using System.Linq;
using Antlr.Runtime.Tree;
using Antlr3.Tool;
@@ -100,5 +101,231 @@ namespace Antlr3.Grammars
r.TrackInlineAction( actionAST );
}
}
+
+        private void HandleAttrScope(GrammarAST name, GrammarAST attrs, IDictionary<GrammarAST, GrammarAST> actions)
+        {
+            AttributeScope scope = grammar.DefineGlobalScope(name.Text, attrs.Token);
+            scope.IsDynamicGlobalScope = true;
+            scope.AddAttributes(attrs.Text, ';');
+            foreach (var action in actions)
+                scope.DefineNamedAction(action.Key, action.Value);
+        }
+
+        private void HandleAttrScopeAction(GrammarAST id, GrammarAST action, IDictionary<GrammarAST, GrammarAST> actions)
+        {
+            actions.Add(id, action);
+        }
+
+        private void HandleAction(string scope, GrammarAST amp, GrammarAST name, GrammarAST action)
+        {
+            grammar.DefineNamedAction(amp, scope, name, action);
+        }
+
+        private void HandleRuleAfterOptionsSpec(ref string name, ref Rule r, IDictionary<string, object> opts, GrammarAST start, GrammarAST id, string modifier, GrammarAST args, GrammarAST ret, HashSet<string> exceptions)
+        {
+            name = id.Text;
+            currentRuleName = name;
+            if (Rule.GetRuleType(name) == RuleType.Lexer && grammar.type == GrammarType.Combined)
+            {
+                // a merged grammar spec, track lexer rules and send to another grammar
+                grammar.DefineLexerRuleFoundInParser(id.Token, start);
+            }
+            else
+            {
+                int numAlts = CountAltsForRule(start);
+                grammar.DefineRule(id.Token, modifier, opts, start, args, numAlts);
+                r = grammar.GetRule(name);
+                if (args != null)
+                {
+                    r.ParameterScope = grammar.CreateParameterScope(name, args.Token);
+                    r.ParameterScope.AddAttributes(args.Text, ',');
+                }
+
+                if (ret != null)
+                {
+                    r.ReturnScope = grammar.CreateReturnScope(name, ret.Token);
+                    r.ReturnScope.AddAttributes(ret.Text, ',');
+                }
+
+                if (exceptions != null)
+                {
+                    foreach (string exception in exceptions)
+                        r.ThrowsSpec.Add(exception);
+                }
+            }
+        }
+
+        private void HandleRuleAfterRuleActions()
+        {
+            blockLevel = 0;
+        }
+
+        private void HandleRuleEnd(GrammarAST blockStart, IDictionary<string, object> opts)
+        {
+            // copy rule options into the block AST, which is where
+            // the analysis will look for k option etc...
+            blockStart.BlockOptions = opts;
+        }
+
+        private void HandleRuleAction(Rule r, GrammarAST amp, GrammarAST id, GrammarAST action)
+        {
+            if (r != null)
+                r.DefineNamedAction(amp, id, action);
+        }
+
+        private void HandleRuleScopeSpecAction(Rule r, GrammarAST attrs, IDictionary<GrammarAST, GrammarAST> actions)
+        {
+            r.RuleScope = grammar.CreateRuleScope(r.Name, attrs.Token);
+            r.RuleScope.IsDynamicRuleScope = true;
+            r.RuleScope.AddAttributes(attrs.Text, ';');
+            foreach (var action in actions)
+                r.RuleScope.DefineNamedAction(action.Key, action.Value);
+        }
+
+        private void HandleRuleScopeSpecUses(Rule r, GrammarAST uses)
+        {
+            if (grammar.GetGlobalScope(uses.Text) == null)
+            {
+                ErrorManager.GrammarError(ErrorManager.MSG_UNKNOWN_DYNAMIC_SCOPE, grammar, uses.Token, uses.Text);
+            }
+            else
+            {
+                if (r.UseScopes == null)
+                    r.UseScopes = new List<string>();
+
+                r.UseScopes.Add(uses.Text);
+            }
+        }
+
+        private void HandleElementAssign(GrammarAST id, GrammarAST elementStart)
+        {
+            if (elementStart.Type == ANTLRParser.ROOT || elementStart.Type == ANTLRParser.BANG)
+            {
+                elementStart = (GrammarAST)elementStart.GetChild(0);
+            }
+
+            if (elementStart.Type == RULE_REF)
+            {
+                grammar.DefineRuleRefLabel(currentRuleName, id.Token, elementStart);
+            }
+            else if (elementStart.Type == WILDCARD && grammar.type == GrammarType.TreeParser)
+            {
+                grammar.DefineWildcardTreeLabel(currentRuleName, id.Token, elementStart);
+            }
+            else
+            {
+                grammar.DefineTokenRefLabel(currentRuleName, id.Token, elementStart);
+            }
+        }
+
+        private void HandleElementPlusAssign(GrammarAST id, GrammarAST elementStart)
+        {
+            if (elementStart.Type == ANTLRParser.ROOT || elementStart.Type == ANTLRParser.BANG)
+            {
+                elementStart = (GrammarAST)elementStart.GetChild(0);
+            }
+
+            if (elementStart.Type == RULE_REF)
+            {
+                grammar.DefineRuleListLabel(currentRuleName, id.Token, elementStart);
+            }
+            else if (elementStart.Type == WILDCARD && grammar.type == GrammarType.TreeParser)
+            {
+                grammar.DefineWildcardTreeListLabel(currentRuleName, id.Token, elementStart);
+            }
+            else
+            {
+                grammar.DefineTokenListLabel(currentRuleName, id.Token, elementStart);
+            }
+        }
+
+        private void HandleInlineAction(GrammarAST action)
+        {
+            action.outerAltNum = outerAltNum;
+            TrackInlineAction(action);
+        }
+
+        private void HandleDotLoop(GrammarAST start)
+        {
+            GrammarAST block = (GrammarAST)start.GetChild(0);
+            IDictionary<string, object> opts = new Dictionary<string, object>();
+            opts["greedy"] = "false";
+            if (grammar.type != GrammarType.Lexer)
+            {
+                // parser grammars assume k=1 for .* loops otherwise they (analysis?) look til EOF!
+                opts["k"] = 1;
+            }
+
+            block.SetOptions(grammar, opts);
+        }
+
+        private void HandleRuleReferenceAtom(GrammarAST scope, GrammarAST ruleReference, GrammarAST action)
+        {
+            grammar.AltReferencesRule(currentRuleName, scope, ruleReference, this.outerAltNum);
+            if (action != null)
+            {
+                action.outerAltNum = this.outerAltNum;
+                TrackInlineAction(action);
+            }
+        }
+
+        private void HandleTokenReferenceAtom(GrammarAST scope, GrammarAST tokenReference, GrammarAST action)
+        {
+            if (action != null)
+            {
+                action.outerAltNum = this.outerAltNum;
+                TrackInlineAction(action);
+            }
+
+            if (grammar.type == GrammarType.Lexer)
+            {
+                grammar.AltReferencesRule(currentRuleName, scope, tokenReference, this.outerAltNum);
+            }
+            else
+            {
+                grammar.AltReferencesTokenID(currentRuleName, tokenReference, this.outerAltNum);
+            }
+        }
+
+        private void HandleStringLiteralAtom(GrammarAST literal)
+        {
+            if (grammar.type != GrammarType.Lexer)
+            {
+                Rule rule = grammar.GetRule(currentRuleName);
+                if (rule != null)
+                    rule.TrackTokenReferenceInAlt(literal, outerAltNum);
+            }
+        }
+
+        private void HandleRewriteAtomStart(GrammarAST start)
+        {
+            Rule r = grammar.GetRule(currentRuleName);
+            var tokenRefsInAlt = r.GetTokenRefsInAlt(outerAltNum);
+            bool imaginary = start.Type == TOKEN_REF && !tokenRefsInAlt.Contains(start.Text);
+            if (!imaginary && grammar.BuildAST)
+            {
+                switch (start.Type)
+                {
+                case RULE_REF:
+                case LABEL:
+                case TOKEN_REF:
+                case CHAR_LITERAL:
+                case STRING_LITERAL:
+                    // track per block and for entire rewrite rule
+                    if (currentRewriteBlock != null)
+                    {
+                        currentRewriteBlock.rewriteRefsShallow.Add(start);
+                        currentRewriteBlock.rewriteRefsDeep.Add(start);
+                    }
+
+                    //System.out.println("adding "+$start.Text+" to "+currentRewriteRule.Text);
+                    currentRewriteRule.rewriteRefsDeep.Add(start);
+                    break;
+
+                default:
+                    break;
+                }
+            }
+        }
}
}
diff --git a/Antlr3/Grammars/TreeToNFAConverter.g3 b/Antlr3/Grammars/TreeToNFAConverter.g3
index 2d889c5..fe1d4b2 100644
--- a/Antlr3/Grammars/TreeToNFAConverter.g3
+++ b/Antlr3/Grammars/TreeToNFAConverter.g3
@@ -59,24 +59,24 @@ grammar_
{
Finish();
}
-	:	(	^( LEXER_GRAMMAR grammarSpec )
-		|	^( PARSER_GRAMMAR grammarSpec )
-		|	^( TREE_GRAMMAR grammarSpec )
-		|	^( COMBINED_GRAMMAR grammarSpec )
+	:	(	^(LEXER_GRAMMAR grammarSpec)
+		|	^(PARSER_GRAMMAR grammarSpec)
+		|	^(TREE_GRAMMAR grammarSpec)
+		|	^(COMBINED_GRAMMAR grammarSpec)
)
;

attrScope
-	:	^( 'scope' ID ( ^(AMPERSAND .*) )* ACTION )
+	:	^('scope' ID ( ^(AMPERSAND .*) )* ACTION)
;

grammarSpec
:	ID
-		(cmt=DOC_COMMENT)?
+		DOC_COMMENT?
( ^(OPTIONS .*) )?
( ^(IMPORT .*) )?
( ^(TOKENS .*) )?
-		(attrScope)*
+		attrScope*
( ^(AMPERSAND .*) )* // skip actions
rules
;
@@ -86,52 +86,18 @@ rules
;

rule
-	:	^(	RULE id=ID
-			{
-				currentRuleName = $id.text;
-				factory.CurrentRule = grammar.GetLocallyDefinedRule( currentRuleName );
-			}
-			(modifier)?
-			^(ARG (ARG_ACTION)?)
-			^(RET (ARG_ACTION)?)
-			(throwsSpec)?
+	:	^(	RULE id=ID					{HandleRuleId($id);}
+			modifier?
+			^(ARG ARG_ACTION?)
+			^(RET ARG_ACTION?)
+			throwsSpec?
( ^(OPTIONS .*) )?
-			( ruleScopeSpec )?
+			ruleScopeSpec?
( ^(AMPERSAND .*) )*
b=block
-			(exceptionGroup)?
+			exceptionGroup?
EOR
-			{
-				StateCluster g = $b.g;
-				if ( $b.start.SetValue!=null )
-				{
-					// if block comes back as a set not BLOCK, make it
-					// a single ALT block
-					g = factory.BuildAlternativeBlockFromSet(g);
-				}
-				if (Rule.GetRuleType(currentRuleName) == RuleType.Parser || grammar.type==GrammarType.Lexer)
-				{
-					// attach start node to block for this rule
-					Rule thisR = grammar.GetLocallyDefinedRule(currentRuleName);
-					NFAState start = thisR.StartState;
-					start.associatedASTNode = $id;
-					start.AddTransition(new Transition(Label.EPSILON, g.Left));
-
-					// track decision if > 1 alts
-					if ( grammar.GetNumberOfAltsForDecisionNFA(g.Left)>1 )
-					{
-						g.Left.Description = grammar.GrammarTreeToString($start,false);
-						g.Left.SetDecisionASTNode($b.start);
-						int d = grammar.AssignDecisionNumber( g.Left );
-						grammar.SetDecisionNFA( d, g.Left );
-						grammar.SetDecisionBlockAST(d, $b.start);
-					}
-
-					// hook to end of rule node
-					NFAState end = thisR.StopState;
-					g.Right.AddTransition(new Transition(Label.EPSILON,end));
-				}
-			}
+										{HandleRule($start, $b.g, $b.start, $id);}
)
;

@@ -147,10 +113,10 @@ throwsSpec
;

ruleScopeSpec
-	:	^( 'scope' ( ^(AMPERSAND .*) )* (ACTION)? ( ID )* )
+	:	^('scope' ( ^(AMPERSAND .*) )* ACTION? ID*)
;

-block returns [StateCluster g = null]
+block returns [StateCluster g]
@init
{
List<StateCluster> alts = new List<StateCluster>();
@@ -178,20 +144,13 @@ block returns [StateCluster g = null]
;
finally { blockLevel--; }

-alternative returns [StateCluster g=null]
-	:	^( ALT (e=element {$g = factory.BuildAB($g,$e.g);} )+ EOA )
-		{
-			if ($g==null) { // if alt was a list of actions or whatever
-				$g = factory.BuildEpsilon();
-			}
-			else {
-				factory.OptimizeAlternative($g);
-			}
-		}
+alternative returns [StateCluster g]
+	:	^( ALT (e=element {$g = HandleAlternativeElement($g, $e.g);} )+ EOA )
+		{$g = HandleAlternativeEnd($g);}
;

exceptionGroup
-	:	( exceptionHandler )+ (finallyClause)?
+	:	exceptionHandler+ finallyClause?
|	finallyClause
;

@@ -219,305 +178,71 @@ rewrite
|
;

-element returns [StateCluster g=null]
-	:   ^(ROOT e=element {$g = $e.g;})
-	|   ^(BANG e=element {$g = $e.g;})
-	|	^(ASSIGN ID e=element {$g = $e.g;})
-	|	^(PLUS_ASSIGN ID e=element {$g = $e.g;})
-	|   ^(RANGE a=atom[null] b=atom[null])
-		{$g = factory.BuildRange(grammar.GetTokenType($a.text),
-								 grammar.GetTokenType($b.text));}
-	|   ^(CHAR_RANGE c1=CHAR_LITERAL c2=CHAR_LITERAL)
-		{
-		if ( grammar.type==GrammarType.Lexer ) {
-			$g = factory.BuildCharRange($c1.text, $c2.text);
-		}
-		}
-	|   atom_or_notatom {$g = $atom_or_notatom.g;}
-	|   ebnf {$g = $ebnf.g;}
-	|   tree_ {$g = $tree_.g;}
-	|   ^( SYNPRED block )
-	|   ACTION {$g = factory.BuildAction($ACTION);}
-	|   FORCED_ACTION {$g = factory.BuildAction($FORCED_ACTION);}
-	|   pred=SEMPRED {$g = factory.BuildSemanticPredicate($pred);}
-	|   spred=SYN_SEMPRED {$g = factory.BuildSemanticPredicate($spred);}
-	|   ^(bpred=BACKTRACK_SEMPRED .*) {$g = factory.BuildSemanticPredicate($bpred);}
-	|   gpred=GATED_SEMPRED {$g = factory.BuildSemanticPredicate($gpred);}
-	|   EPSILON {$g = factory.BuildEpsilon();}
+element returns [StateCluster g]
+	:	^(ROOT e=element)								{$g = $e.g;}
+	|	^(BANG e=element)								{$g = $e.g;}
+	|	^(ASSIGN ID e=element)							{$g = $e.g;}
+	|	^(PLUS_ASSIGN ID e=element)						{$g = $e.g;}
+	|	^(RANGE a=atom[null] b=atom[null])				{$g = factory.BuildRange(grammar.GetTokenType($a.text), grammar.GetTokenType($b.text));}
+	|	^(CHAR_RANGE c1=CHAR_LITERAL c2=CHAR_LITERAL)	{if (grammar.type == GrammarType.Lexer) $g = factory.BuildCharRange($c1.text, $c2.text);}
+	|	atom_or_notatom									{$g = $atom_or_notatom.g;}
+	|	ebnf											{$g = $ebnf.g;}
+	|	tree_											{$g = $tree_.g;}
+	|	^(SYNPRED block)
+	|	ACTION											{$g = factory.BuildAction($ACTION);}
+	|	FORCED_ACTION									{$g = factory.BuildAction($FORCED_ACTION);}
+	|	SEMPRED											{$g = factory.BuildSemanticPredicate($SEMPRED);}
+	|	SYN_SEMPRED										{$g = factory.BuildSemanticPredicate($SYN_SEMPRED);}
+	|	^(BACKTRACK_SEMPRED .*)							{$g = factory.BuildSemanticPredicate($BACKTRACK_SEMPRED);}
+	|	GATED_SEMPRED									{$g = factory.BuildSemanticPredicate($GATED_SEMPRED);}
+	|	EPSILON											{$g = factory.BuildEpsilon();}
;

-ebnf returns [StateCluster g=null]
+ebnf returns [StateCluster g]
@init
{
GrammarAST blk = $start;
-	if ( blk.Type!=BLOCK ) {
+	if (blk.Type != BLOCK)
blk = (GrammarAST)blk.GetChild(0);
-	}
-	GrammarAST eob = blk.LastChild;
}
-	:	{grammar.IsValidSet(this,$start)}? => set {$g = $set.g;}
-
-	|	b=block
-		{
-			// track decision if > 1 alts
-			if ( grammar.GetNumberOfAltsForDecisionNFA($b.g.Left)>1 )
-			{
-				$b.g.Left.Description = grammar.GrammarTreeToString(blk,false);
-				$b.g.Left.SetDecisionASTNode(blk);
-				int d = grammar.AssignDecisionNumber( $b.g.Left );
-				grammar.SetDecisionNFA( d, $b.g.Left );
-				grammar.SetDecisionBlockAST(d, blk);
-			}
-			$g = $b.g;
-		}
-	|	^( OPTIONAL b=block )
-		{
-			StateCluster bg = $b.g;
-			if ( blk.SetValue!=null )
-			{
-				// if block comes back SET not BLOCK, make it
-				// a single ALT block
-				bg = factory.BuildAlternativeBlockFromSet(bg);
-			}
-			$g = factory.BuildAoptional(bg);
-			$g.Left.Description = grammar.GrammarTreeToString($start,false);
-			// there is always at least one alt even if block has just 1 alt
-			int d = grammar.AssignDecisionNumber( $g.Left );
-			grammar.SetDecisionNFA(d, $g.Left);
-			grammar.SetDecisionBlockAST(d, blk);
-			$g.Left.SetDecisionASTNode($start);
-		}
-	|	^( CLOSURE b=block )
-		{
-			StateCluster bg = $b.g;
-			if ( blk.SetValue!=null )
-			{
-				bg = factory.BuildAlternativeBlockFromSet(bg);
-			}
-			$g = factory.BuildAstar(bg);
-			// track the loop back / exit decision point
-			bg.Right.Description = "()* loopback of "+grammar.GrammarTreeToString($start,false);
-			int d = grammar.AssignDecisionNumber( bg.Right );
-			grammar.SetDecisionNFA(d, bg.Right);
-			grammar.SetDecisionBlockAST(d, blk);
-			bg.Right.SetDecisionASTNode(eob);
-			// make block entry state also have same decision for interpreting grammar
-			NFAState altBlockState = (NFAState)$g.Left.GetTransition(0).Target;
-			altBlockState.SetDecisionASTNode($start);
-			altBlockState.DecisionNumber = d;
-			$g.Left.DecisionNumber = d; // this is the bypass decision (2 alts)
-			$g.Left.SetDecisionASTNode($start);
-		}
-	|	^( POSITIVE_CLOSURE b=block )
-		{
-			StateCluster bg = $b.g;
-			if ( blk.SetValue!=null )
-			{
-				bg = factory.BuildAlternativeBlockFromSet(bg);
-			}
-			$g = factory.BuildAplus(bg);
-			// don't make a decision on left edge, can reuse loop end decision
-			// track the loop back / exit decision point
-			bg.Right.Description = "()+ loopback of "+grammar.GrammarTreeToString($start,false);
-			int d = grammar.AssignDecisionNumber( bg.Right );
-			grammar.SetDecisionNFA(d, bg.Right);
-			grammar.SetDecisionBlockAST(d, blk);
-			bg.Right.SetDecisionASTNode(eob);
-			// make block entry state also have same decision for interpreting grammar
-			NFAState altBlockState = (NFAState)$g.Left.GetTransition(0).Target;
-			altBlockState.SetDecisionASTNode($start);
-			altBlockState.DecisionNumber = d;
-		}
+	:	{grammar.IsValidSet(this,$start)}? => set {$g = HandleEbnfSet($set.g);}
+	|	b=block						{$g = HandleEbnfBlock(blk, $b.g);}
+	|	^(OPTIONAL b=block)			{$g = HandleEbnfOptionalBlock($start, blk, $b.g);}
+	|	^(CLOSURE b=block)			{$g = HandleEbnfClosureBlock($start, blk, $b.g);}
+	|	^(POSITIVE_CLOSURE b=block)	{$g = HandleEbnfPositiveClosureBlock($start, blk, $b.g);}
;

-tree_ returns [StateCluster g=null]
+tree_ returns [StateCluster g]
@init
{
-	StateCluster down=null, up=null;
+	StateCluster down = null;
}
:	^(	TREE_BEGIN
-			e=element { $g = $e.g; }
-			{
-				down = factory.BuildAtom(Label.DOWN, $e.start);
-				// TODO set following states for imaginary nodes?
-				//el.followingNFAState = down.Right;
-				$g = factory.BuildAB($g,down);
-			}
-			( e=element {$g = factory.BuildAB($g,$e.g);} )*
-			{
-				up = factory.BuildAtom(Label.UP, $e.start);
-				//el.followingNFAState = up.Right;
-				$g = factory.BuildAB($g,up);
-				// tree roots point at right edge of DOWN for LOOK computation later
-				$start.NFATreeDownState = down.Left;
-			}
+			e=element		{$g = HandleTreeFirstElement($e.start, $e.g, out down);}
+			(	e=element	{$g = HandleTreeElement($g, $e.g);}
+			)*
+							{$g = HandleTreeAfterLastElement($start, $g, $e.start, down);}
)
;

atom_or_notatom returns [StateCluster g=null]
:	atom[null] {$g = $atom.g;}
|	^(	n=NOT
-			(	c=CHAR_LITERAL (ast1=ast_suffix)?
-				{
-					int ttype=0;
-					if ( grammar.type==GrammarType.Lexer )
-					{
-						ttype = Grammar.GetCharValueFromGrammarCharLiteral($c.text);
-					}
-					else
-					{
-						ttype = grammar.GetTokenType($c.text);
-					}
-					IIntSet notAtom = grammar.Complement(ttype);
-					if ( notAtom.IsNil )
-					{
-						ErrorManager.GrammarError(
-							ErrorManager.MSG_EMPTY_COMPLEMENT,
-							grammar,
-							$c.Token,
-							$c.text);
-					}
-					$g=factory.BuildSet(notAtom,$n);
-				}
-			|	t=TOKEN_REF (ast3=ast_suffix)?
-				{
-					int ttype=0;
-					IIntSet notAtom = null;
-					if ( grammar.type==GrammarType.Lexer )
-					{
-						notAtom = grammar.GetSetFromRule(this,$t.text);
-						if ( notAtom==null )
-						{
-							ErrorManager.GrammarError(
-								ErrorManager.MSG_RULE_INVALID_SET,
-								grammar,
-								$t.Token,
-								$t.text);
-						}
-						else
-						{
-							notAtom = grammar.Complement(notAtom);
-						}
-					}
-					else
-					{
-						ttype = grammar.GetTokenType($t.text);
-						notAtom = grammar.Complement(ttype);
-					}
-					if ( notAtom==null || notAtom.IsNil )
-					{
-						ErrorManager.GrammarError(
-							ErrorManager.MSG_EMPTY_COMPLEMENT,
-							grammar,
-							$t.Token,
-							$t.text);
-					}
-					$g=factory.BuildSet(notAtom,$n);
-				}
-			|	set {$g = $set.g;}
-				{
-					GrammarAST stNode = (GrammarAST)$n.GetChild(0);
-					//IIntSet notSet = grammar.Complement(stNode.SetValue);
-					// let code generator complement the sets
-					IIntSet s = stNode.SetValue;
-					stNode.SetValue = s;
-					// let code gen do the complement again; here we compute
-					// for NFA construction
-					s = grammar.Complement(s);
-					if ( s.IsNil )
-					{
-						ErrorManager.GrammarError(
-							ErrorManager.MSG_EMPTY_COMPLEMENT,
-							grammar,
-							$n.Token);
-					}
-					$g=factory.BuildSet(s,$n);
-				}
+			(	c=CHAR_LITERAL ast_suffix?		{$g = HandleNotAtomCharLiteral($n, $c);}
+			|	t=TOKEN_REF ast_suffix?			{$g = HandleNotAtomTokenReference($n, $t);}
+			|	set								{$g = HandleNotAtomSet($n, $set.start);}
)
-			{$n.followingNFAState = $g.Right;}
+			{HandleNotAtomEnd($n, $g);}
)
;

-atom[string scopeName] returns [StateCluster g=null]
-	:	^( r=RULE_REF (rarg=ARG_ACTION)? (as1=ast_suffix)? )
-		{
-			NFAState start = grammar.GetRuleStartState(scopeName,$r.text);
-			if ( start!=null )
-			{
-				Rule rr = grammar.GetRule(scopeName,$r.text);
-				$g = factory.BuildRuleRef(rr, start);
-				r.followingNFAState = $g.Right;
-				r._nfaStartState = $g.Left;
-				if ( $g.Left.GetTransition(0) is RuleClosureTransition
-					&& grammar.type!=GrammarType.Lexer )
-				{
-					AddFollowTransition($r.text, $g.Right);
-				}
-				// else rule ref got inlined to a set
-			}
-		}
-
-	|	^( t=TOKEN_REF  (targ=ARG_ACTION)? (as2=ast_suffix)? )
-		{
-			if ( grammar.type==GrammarType.Lexer )
-			{
-				NFAState start = grammar.GetRuleStartState(scopeName,$t.text);
-				if ( start!=null )
-				{
-					Rule rr = grammar.GetRule(scopeName,t.Text);
-					$g = factory.BuildRuleRef(rr, start);
-					t._nfaStartState = $g.Left;
-					// don't add FOLLOW transitions in the lexer;
-					// only exact context should be used.
-				}
-			}
-			else
-			{
-				$g = factory.BuildAtom(t);
-				t.followingNFAState = $g.Right;
-			}
-		}
-
-	|	^( c=CHAR_LITERAL  (as3=ast_suffix)? )
-		{
-			if ( grammar.type==GrammarType.Lexer )
-			{
-				$g = factory.BuildCharLiteralAtom(c);
-			}
-			else
-			{
-				$g = factory.BuildAtom(c);
-				c.followingNFAState = $g.Right;
-			}
-		}
-
-	|	^( s=STRING_LITERAL  (as4=ast_suffix)? )
-		{
-			if ( grammar.type==GrammarType.Lexer )
-			{
-				$g = factory.BuildStringLiteralAtom(s);
-			}
-			else
-			{
-				$g = factory.BuildAtom(s);
-				s.followingNFAState = $g.Right;
-			}
-		}
-
-	|	^(	w=WILDCARD (as5=ast_suffix)? )
-			{
-				if ( nfa.Grammar.type == GrammarType.TreeParser
-					&& (w.ChildIndex > 0 || w.Parent.GetChild(1).Type == EOA) )
-				{
-					$g = factory.BuildWildcardTree( $w );
-				}
-				else
-				{
-					$g = factory.BuildWildcard( $w );
-				}
-			}
-
-	|	^( DOT scope_=ID a=atom[$scope_.text] {$g = $a.g;} ) // scope override
+atom[string scopeName] returns [StateCluster g]
+	:	^(r=RULE_REF ARG_ACTION? ast_suffix?)	{$g = HandleAtomRuleReference(scopeName, $r);}
+	|	^(t=TOKEN_REF ARG_ACTION? ast_suffix?)	{$g = HandleAtomTokenReference(scopeName, $t);}
+	|	^(c=CHAR_LITERAL ast_suffix?)			{$g = HandleAtomCharLiteral($c);}
+	|	^(s=STRING_LITERAL ast_suffix?)			{$g = HandleAtomStringLiteral($s);}
+	|	^(w=WILDCARD ast_suffix?)				{$g = HandleAtomWildcard($w);}
+	|	^(DOT scope_=ID a=atom[$scope_.text])	{$g = $a.g;} // scope override
;

ast_suffix
@@ -525,7 +250,7 @@ ast_suffix
|	BANG
;

-set returns [StateCluster g=null]
+set returns [StateCluster g]
@init
{
IIntSet elements=new IntervalSet();
@@ -544,18 +269,14 @@ set returns [StateCluster g=null]
//{System.out.println("set elements="+elements.ToString(grammar));}
;

-setRule returns [IIntSet elements=new IntervalSet()]
-@init
-{
-	IIntSet s=null;
-}
-	:	^( RULE id=ID (modifier)? ARG RET ( ^(OPTIONS .*) )? ( ruleScopeSpec )?
+setRule returns [IIntSet elements = new IntervalSet()]
+	:	^(	RULE ID modifier? ARG RET ( ^(OPTIONS .*) )? ruleScopeSpec?
( ^(AMPERSAND .*) )*
-			^( BLOCK ( ^(OPTIONS .*) )?
-			   ( ^(ALT (BACKTRACK_SEMPRED)? setElement[elements] EOA) )+
-			   EOB
+			^(	BLOCK ( ^(OPTIONS .*) )?
+				( ^(ALT BACKTRACK_SEMPRED? setElement[elements] EOA) )+
+				EOB
)
-			(exceptionGroup)?
+			exceptionGroup?
EOR
)
;
@@ -564,98 +285,15 @@ catch[RecognitionException re] { re.PreserveStackTrace(); throw; }
setElement[IIntSet elements]
@init
{
-	int ttype;
-	IIntSet ns=null;
+	IIntSet ns = null;
}
-	:	c=CHAR_LITERAL
-		{
-			if ( grammar.type==GrammarType.Lexer )
-			{
-				ttype = Grammar.GetCharValueFromGrammarCharLiteral($c.text);
-			}
-			else
-			{
-				ttype = grammar.GetTokenType($c.text);
-			}
-			if ( elements.Contains(ttype) )
-			{
-				ErrorManager.GrammarError(
-					ErrorManager.MSG_DUPLICATE_SET_ENTRY,
-					grammar,
-					$c.Token,
-					$c.text);
-			}
-			elements.Add(ttype);
-		}
-	|	t=TOKEN_REF
-		{
-			if ( grammar.type==GrammarType.Lexer )
-			{
-				// recursively will invoke this rule to match elements in target rule ref
-				IIntSet ruleSet = grammar.GetSetFromRule(this,$t.text);
-				if ( ruleSet==null )
-				{
-					ErrorManager.GrammarError(
-						ErrorManager.MSG_RULE_INVALID_SET,
-						grammar,
-						$t.Token,
-						$t.text);
-				}
-				else
-				{
-					elements.AddAll(ruleSet);
-				}
-			}
-			else
-			{
-				ttype = grammar.GetTokenType($t.text);
-				if ( elements.Contains(ttype) )
-				{
-					ErrorManager.GrammarError(
-						ErrorManager.MSG_DUPLICATE_SET_ENTRY,
-						grammar,
-						$t.Token,
-						$t.text);
-				}
-				elements.Add(ttype);
-			}
-		}
-
-	|	s=STRING_LITERAL
-		{
-			ttype = grammar.GetTokenType($s.text);
-			if ( elements.Contains(ttype) )
-			{
-				ErrorManager.GrammarError(
-					ErrorManager.MSG_DUPLICATE_SET_ENTRY,
-					grammar,
-					$s.Token,
-					$s.text);
-			}
-			elements.Add(ttype);
-		}
-	|	^(CHAR_RANGE c1=CHAR_LITERAL c2=CHAR_LITERAL)
-		{
-			if ( grammar.type==GrammarType.Lexer )
-			{
-				int a = Grammar.GetCharValueFromGrammarCharLiteral($c1.text);
-				int b = Grammar.GetCharValueFromGrammarCharLiteral($c2.text);
-				elements.AddAll(IntervalSet.Of(a,b));
-			}
-		}
-
-	|	gset=set
-		{
-			Transition setTrans = $gset.g.Left.GetTransition(0);
-			elements.AddAll(setTrans.Label.Set);
-		}
-
-	|	^(	NOT {ns=new IntervalSet();}
-			setElement[ns]
-			{
-				IIntSet not = grammar.Complement(ns);
-				elements.AddAll(not);
-			}
+	:	c=CHAR_LITERAL									{HandleSetElementCharLiteral($elements, $c);}
+	|	t=TOKEN_REF										{HandleSetElementTokenReference($elements, $t);}
+	|	s=STRING_LITERAL								{HandleSetElementStringLiteral($elements, $s);}
+	|	^(CHAR_RANGE c1=CHAR_LITERAL c2=CHAR_LITERAL)	{HandleSetElementCharRange($elements, $c1, $c2);}
+	|	gset=set										{HandleSetElementSet($elements, $gset.g);}
+	|	^(	NOT											{ns=new IntervalSet();}
+			setElement[ns]								{HandleSetElementNotSetElement($elements, ns);}
)
;

@@ -673,7 +311,7 @@ options { backtrack = true; }
inTest++;
}
:	^(	BLOCK
-			(	^(ALT (BACKTRACK_SEMPRED)? testSetElement {{$alts += $testSetElement.alts;}} EOA)
+			(	^(ALT BACKTRACK_SEMPRED? testSetElement {{$alts += $testSetElement.alts;}} EOA)
)+
EOB
)
@@ -686,14 +324,14 @@ testSetRule returns [int alts=0]
{
inTest++;
}
-	:	^(	RULE id=ID (modifier)? ARG RET ( ^(OPTIONS .*) )? ( ruleScopeSpec )?
+	:	^(	RULE ID modifier? ARG RET ( ^(OPTIONS .*) )? ruleScopeSpec?
( ^(AMPERSAND .*) )*
^(	BLOCK
-				(	^(ALT (BACKTRACK_SEMPRED)? testSetElement {{$alts += $testSetElement.alts;}} EOA)
+				(	^(ALT BACKTRACK_SEMPRED? testSetElement {{$alts += $testSetElement.alts;}} EOA)
)+
EOB
)
-			(exceptionGroup)?
+			exceptionGroup?
EOR
)
;
diff --git a/Antlr3/Grammars/TreeToNFAConverterHelper.cs b/Antlr3/Grammars/TreeToNFAConverterHelper.cs
index 88c6573..cc26145 100644
--- a/Antlr3/Grammars/TreeToNFAConverterHelper.cs
+++ b/Antlr3/Grammars/TreeToNFAConverterHelper.cs
@@ -39,6 +39,7 @@ namespace Antlr3.Grammars
using ArgumentNullException = System.ArgumentNullException;
using CommonTreeNodeStream = Antlr.Runtime.Tree.CommonTreeNodeStream;
using IIntSet = Antlr3.Misc.IIntSet;
+    using IntervalSet = Antlr3.Misc.IntervalSet;
using ITreeNodeStream = Antlr.Runtime.Tree.ITreeNodeStream;

partial class TreeToNFAConverter
@@ -176,5 +177,416 @@ namespace Antlr3.Grammars

return node.terminalOptions != null && node.terminalOptions.Count > 0;
}
+
+        private void HandleRuleId(GrammarAST id)
+        {
+            currentRuleName = id.Text;
+            factory.CurrentRule = grammar.GetLocallyDefinedRule(currentRuleName);
+        }
+
+        private void HandleRule(GrammarAST start, StateCluster g, GrammarAST blockStart, GrammarAST id)
+        {
+            if (blockStart.SetValue != null)
+            {
+                // if block comes back as a set not BLOCK, make it
+                // a single ALT block
+                g = factory.BuildAlternativeBlockFromSet(g);
+            }
+
+            if (Rule.GetRuleType(currentRuleName) == RuleType.Parser || grammar.type == GrammarType.Lexer)
+            {
+                // attach start node to block for this rule
+                Rule thisR = grammar.GetLocallyDefinedRule(currentRuleName);
+                NFAState start2 = thisR.StartState;
+                start2.associatedASTNode = id;
+                start2.AddTransition(new Transition(Label.EPSILON, g.Left));
+
+                // track decision if > 1 alts
+                if (grammar.GetNumberOfAltsForDecisionNFA(g.Left) > 1)
+                {
+                    g.Left.Description = grammar.GrammarTreeToString(start, false);
+                    g.Left.SetDecisionASTNode(blockStart);
+                    int d = grammar.AssignDecisionNumber(g.Left);
+                    grammar.SetDecisionNFA(d, g.Left);
+                    grammar.SetDecisionBlockAST(d, blockStart);
+                }
+
+                // hook to end of rule node
+                NFAState end = thisR.StopState;
+                g.Right.AddTransition(new Transition(Label.EPSILON, end));
+            }
+        }
+
+        private StateCluster HandleAlternativeElement(StateCluster g, StateCluster element)
+        {
+            return factory.BuildAB(g, element);
+        }
+
+        private StateCluster HandleAlternativeEnd(StateCluster g)
+        {
+            if (g == null)
+            {
+                // if alt was a list of actions or whatever
+                g = factory.BuildEpsilon();
+            }
+            else
+            {
+                factory.OptimizeAlternative(g);
+            }
+
+            return g;
+        }
+
+        private StateCluster HandleEbnfSet(StateCluster g)
+        {
+            return g;
+        }
+
+        private StateCluster HandleEbnfBlock(GrammarAST blk, StateCluster g)
+        {
+            // track decision if > 1 alts
+            if (grammar.GetNumberOfAltsForDecisionNFA(g.Left) > 1)
+            {
+                g.Left.Description = grammar.GrammarTreeToString(blk, false);
+                g.Left.SetDecisionASTNode(blk);
+                int d = grammar.AssignDecisionNumber(g.Left);
+                grammar.SetDecisionNFA(d, g.Left);
+                grammar.SetDecisionBlockAST(d, blk);
+            }
+
+            return g;
+        }
+
+        private StateCluster HandleEbnfOptionalBlock(GrammarAST start, GrammarAST blk, StateCluster bg)
+        {
+            if (blk.SetValue != null)
+            {
+                // if block comes back SET not BLOCK, make it
+                // a single ALT block
+                bg = factory.BuildAlternativeBlockFromSet(bg);
+            }
+
+            StateCluster g = factory.BuildAoptional(bg);
+            g.Left.Description = grammar.GrammarTreeToString(start, false);
+            // there is always at least one alt even if block has just 1 alt
+            int d = grammar.AssignDecisionNumber(g.Left);
+            grammar.SetDecisionNFA(d, g.Left);
+            grammar.SetDecisionBlockAST(d, blk);
+            g.Left.SetDecisionASTNode(start);
+            return g;
+        }
+
+        private StateCluster HandleEbnfClosureBlock(GrammarAST start, GrammarAST blk, StateCluster bg)
+        {
+            GrammarAST eob = blk.LastChild;
+            if (blk.SetValue != null)
+            {
+                bg = factory.BuildAlternativeBlockFromSet(bg);
+            }
+
+            StateCluster g = factory.BuildAstar(bg);
+            // track the loop back / exit decision point
+            bg.Right.Description = "()* loopback of " + grammar.GrammarTreeToString(start, false);
+            int d = grammar.AssignDecisionNumber(bg.Right);
+            grammar.SetDecisionNFA(d, bg.Right);
+            grammar.SetDecisionBlockAST(d, blk);
+            bg.Right.SetDecisionASTNode(eob);
+            // make block entry state also have same decision for interpreting grammar
+            NFAState altBlockState = (NFAState)g.Left.GetTransition(0).Target;
+            altBlockState.SetDecisionASTNode(start);
+            altBlockState.DecisionNumber = d;
+            g.Left.DecisionNumber = d; // this is the bypass decision (2 alts)
+            g.Left.SetDecisionASTNode(start);
+            return g;
+        }
+
+        private StateCluster HandleEbnfPositiveClosureBlock(GrammarAST start, GrammarAST blk, StateCluster bg)
+        {
+            GrammarAST eob = blk.LastChild;
+            if (blk.SetValue != null)
+            {
+                bg = factory.BuildAlternativeBlockFromSet(bg);
+            }
+
+            StateCluster g = factory.BuildAplus(bg);
+            // don't make a decision on left edge, can reuse loop end decision
+            // track the loop back / exit decision point
+            bg.Right.Description = "()+ loopback of " + grammar.GrammarTreeToString(start, false);
+            int d = grammar.AssignDecisionNumber(bg.Right);
+            grammar.SetDecisionNFA(d, bg.Right);
+            grammar.SetDecisionBlockAST(d, blk);
+            bg.Right.SetDecisionASTNode(eob);
+            // make block entry state also have same decision for interpreting grammar
+            NFAState altBlockState = (NFAState)g.Left.GetTransition(0).Target;
+            altBlockState.SetDecisionASTNode(start);
+            altBlockState.DecisionNumber = d;
+            return g;
+        }
+
+        private StateCluster HandleTreeFirstElement(GrammarAST firstElementStart, StateCluster element, out StateCluster down)
+        {
+            down = factory.BuildAtom(Label.DOWN, firstElementStart);
+            // TODO set following states for imaginary nodes?
+            //el.followingNFAState = down.Right;
+            return factory.BuildAB(element, down);
+        }
+
+        private StateCluster HandleTreeElement(StateCluster g, StateCluster element)
+        {
+            return factory.BuildAB(g, element);
+        }
+
+        private StateCluster HandleTreeAfterLastElement(GrammarAST start, StateCluster g, GrammarAST lastElementStart, StateCluster down)
+        {
+            StateCluster up = factory.BuildAtom(Label.UP, lastElementStart);
+            //el.followingNFAState = up.Right;
+            g = factory.BuildAB(g, up);
+            // tree roots point at right edge of DOWN for LOOK computation later
+            start.NFATreeDownState = down.Left;
+
+            return g;
+        }
+
+        private StateCluster HandleNotAtomCharLiteral(GrammarAST notNode, GrammarAST charLiteral)
+        {
+            int ttype = 0;
+            if (grammar.type == GrammarType.Lexer)
+            {
+                ttype = Grammar.GetCharValueFromGrammarCharLiteral(charLiteral.Text);
+            }
+            else
+            {
+                ttype = grammar.GetTokenType(charLiteral.Text);
+            }
+
+            IIntSet notAtom = grammar.Complement(ttype);
+            if (notAtom.IsNil)
+            {
+                ErrorManager.GrammarError(
+                    ErrorManager.MSG_EMPTY_COMPLEMENT,
+                    grammar,
+                    charLiteral.Token,
+                    charLiteral.Text);
+            }
+
+            return factory.BuildSet(notAtom, notNode);
+        }
+
+        private StateCluster HandleNotAtomTokenReference(GrammarAST notNode, GrammarAST tokenReference)
+        {
+            int ttype = 0;
+            IIntSet notAtom = null;
+            if (grammar.type == GrammarType.Lexer)
+            {
+                notAtom = grammar.GetSetFromRule(this, tokenReference.Text);
+                if (notAtom == null)
+                {
+                    ErrorManager.GrammarError(
+                        ErrorManager.MSG_RULE_INVALID_SET,
+                        grammar,
+                        tokenReference.Token,
+                        tokenReference.Text);
+                }
+                else
+                {
+                    notAtom = grammar.Complement(notAtom);
+                }
+            }
+            else
+            {
+                ttype = grammar.GetTokenType(tokenReference.Text);
+                notAtom = grammar.Complement(ttype);
+            }
+
+            if (notAtom == null || notAtom.IsNil)
+            {
+                ErrorManager.GrammarError(
+                    ErrorManager.MSG_EMPTY_COMPLEMENT,
+                    grammar,
+                    tokenReference.Token,
+                    tokenReference.Text);
+            }
+
+            return factory.BuildSet(notAtom, notNode);
+        }
+
+        private StateCluster HandleNotAtomSet(GrammarAST notNode, GrammarAST setNode)
+        {
+            //IIntSet notSet = grammar.Complement(stNode.SetValue);
+            // let code generator complement the sets
+            IIntSet s = setNode.SetValue;
+            setNode.SetValue = s;
+            // let code gen do the complement again; here we compute
+            // for NFA construction
+            s = grammar.Complement(s);
+            if (s.IsNil)
+            {
+                ErrorManager.GrammarError(
+                    ErrorManager.MSG_EMPTY_COMPLEMENT,
+                    grammar,
+                    notNode.Token);
+            }
+
+            return factory.BuildSet(s, notNode);
+        }
+
+        private void HandleNotAtomEnd(GrammarAST notNode, StateCluster g)
+        {
+            notNode.followingNFAState = g.Right;
+        }
+
+        private StateCluster HandleAtomRuleReference(string scopeName, GrammarAST ruleReference)
+        {
+            NFAState start = grammar.GetRuleStartState(scopeName, ruleReference.Text);
+            if (start != null)
+            {
+                Rule rr = grammar.GetRule(scopeName, ruleReference.Text);
+                StateCluster g = factory.BuildRuleRef(rr, start);
+                ruleReference.followingNFAState = g.Right;
+                ruleReference._nfaStartState = g.Left;
+                if (g.Left.GetTransition(0) is RuleClosureTransition && grammar.type != GrammarType.Lexer)
+                {
+                    AddFollowTransition(ruleReference.Text, g.Right);
+                }
+                // else rule ref got inlined to a set
+
+                return g;
+            }
+
+            return null;
+        }
+
+        private StateCluster HandleAtomTokenReference(string scopeName, GrammarAST tokenReference)
+        {
+            if (grammar.type == GrammarType.Lexer)
+            {
+                NFAState start = grammar.GetRuleStartState(scopeName, tokenReference.Text);
+                if (start != null)
+                {
+                    Rule rr = grammar.GetRule(scopeName, tokenReference.Text);
+                    StateCluster g = factory.BuildRuleRef(rr, start);
+                    tokenReference._nfaStartState = g.Left;
+                    // don't add FOLLOW transitions in the lexer;
+                    // only exact context should be used.
+                    return g;
+                }
+
+                return null;
+            }
+            else
+            {
+                StateCluster g = factory.BuildAtom(tokenReference);
+                tokenReference.followingNFAState = g.Right;
+                return g;
+            }
+        }
+
+        private StateCluster HandleAtomCharLiteral(GrammarAST charLiteral)
+        {
+            if (grammar.type == GrammarType.Lexer)
+            {
+                return factory.BuildCharLiteralAtom(charLiteral);
+            }
+            else
+            {
+                StateCluster g = factory.BuildAtom(charLiteral);
+                charLiteral.followingNFAState = g.Right;
+                return g;
+            }
+        }
+
+        private StateCluster HandleAtomStringLiteral(GrammarAST stringLiteral)
+        {
+            if (grammar.type == GrammarType.Lexer)
+            {
+                return factory.BuildStringLiteralAtom(stringLiteral);
+            }
+            else
+            {
+                StateCluster g = factory.BuildAtom(stringLiteral);
+                stringLiteral.followingNFAState = g.Right;
+                return g;
+            }
+        }
+
+        private StateCluster HandleAtomWildcard(GrammarAST wildcard)
+        {
+            if (nfa.Grammar.type == GrammarType.TreeParser
+                && (wildcard.ChildIndex > 0 || wildcard.Parent.GetChild(1).Type == EOA))
+            {
+                return factory.BuildWildcardTree(wildcard);
+            }
+            else
+            {
+                return factory.BuildWildcard(wildcard);
+            }
+        }
+
+        private void HandleSetElementCharLiteral(IIntSet elements, GrammarAST c)
+        {
+            int ttype;
+            if (grammar.type == GrammarType.Lexer)
+                ttype = Grammar.GetCharValueFromGrammarCharLiteral(c.Text);
+            else
+                ttype = grammar.GetTokenType(c.Text);
+
+            if (elements.Contains(ttype))
+                ErrorManager.GrammarError(ErrorManager.MSG_DUPLICATE_SET_ENTRY, grammar, c.Token, c.Text);
+
+            elements.Add(ttype);
+        }
+
+        private void HandleSetElementTokenReference(IIntSet elements, GrammarAST t)
+        {
+            int ttype;
+            if (grammar.type == GrammarType.Lexer)
+            {
+                // recursively will invoke this rule to match elements in target rule ref
+                IIntSet ruleSet = grammar.GetSetFromRule(this, t.Text);
+                if (ruleSet == null)
+                    ErrorManager.GrammarError(ErrorManager.MSG_RULE_INVALID_SET, grammar, t.Token, t.Text);
+                else
+                    elements.AddAll(ruleSet);
+            }
+            else
+            {
+                ttype = grammar.GetTokenType(t.Text);
+                if (elements.Contains(ttype))
+                    ErrorManager.GrammarError(ErrorManager.MSG_DUPLICATE_SET_ENTRY, grammar, t.Token, t.Text);
+
+                elements.Add(ttype);
+            }
+        }
+
+        private void HandleSetElementStringLiteral(IIntSet elements, GrammarAST s)
+        {
+            int ttype = grammar.GetTokenType(s.Text);
+            if (elements.Contains(ttype))
+                ErrorManager.GrammarError(ErrorManager.MSG_DUPLICATE_SET_ENTRY, grammar, s.Token, s.Text);
+
+            elements.Add(ttype);
+        }
+
+        private void HandleSetElementCharRange(IIntSet elements, GrammarAST c1, GrammarAST c2)
+        {
+            if (grammar.type == GrammarType.Lexer)
+            {
+                int a = Grammar.GetCharValueFromGrammarCharLiteral(c1.Text);
+                int b = Grammar.GetCharValueFromGrammarCharLiteral(c2.Text);
+                elements.AddAll(IntervalSet.Of(a, b));
+            }
+        }
+
+        private void HandleSetElementSet(IIntSet elements, StateCluster g)
+        {
+            Transition setTrans = g.Left.GetTransition(0);
+            elements.AddAll(setTrans.Label.Set);
+        }
+
+        private void HandleSetElementNotSetElement(IIntSet elements, IIntSet ns)
+        {
+            IIntSet not = grammar.Complement(ns);
+            elements.AddAll(not);
+        }
}
}

