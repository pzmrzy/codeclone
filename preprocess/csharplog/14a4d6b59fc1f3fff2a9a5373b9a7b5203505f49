commit 14a4d6b59fc1f3fff2a9a5373b9a7b5203505f49
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Fri Apr 10 09:13:35 2009 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Fri Apr 10 09:13:35 2009 -0800

C# Port:
* Code cleanup, make Graph generic (now Graph<T>)

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 6007]

diff --git a/Antlr3.Test/TestTopologicalSort.cs b/Antlr3.Test/TestTopologicalSort.cs
index f025510..a0c0d16 100644
--- a/Antlr3.Test/TestTopologicalSort.cs
+++ b/Antlr3.Test/TestTopologicalSort.cs
@@ -35,7 +35,7 @@ namespace AntlrUnitTests
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Antlr.Runtime.JavaExtensions;

-    using Graph = Antlr3.Misc.Graph;
+    using Graph = Antlr3.Misc.Graph<string>;

/** Test topo sort in GraphNode. */
[TestClass]
diff --git a/Antlr3/Analysis/DFAState.cs b/Antlr3/Analysis/DFAState.cs
index 3eac4f2..8cbfa35 100644
--- a/Antlr3/Analysis/DFAState.cs
+++ b/Antlr3/Analysis/DFAState.cs
@@ -296,7 +296,7 @@ namespace Antlr3.Analysis
minAltInConfigurations = c.alt;
}

-            if ( c.semanticContext != SemanticContext.EMPTY_SEMANTIC_CONTEXT )
+            if ( c.semanticContext != SemanticContext.EmptySemanticContext )
{
atLeastOneConfigurationHasAPredicate = true;
}
@@ -859,7 +859,7 @@ namespace Antlr3.Analysis
else
{
unionOfPredicatesFromAllAlts =
-                            SemanticContext.or( unionOfPredicatesFromAllAlts, gatedPredExpr );
+                            SemanticContext.Or( unionOfPredicatesFromAllAlts, gatedPredExpr );
}
}
}
diff --git a/Antlr3/Analysis/LL1Analyzer.cs b/Antlr3/Analysis/LL1Analyzer.cs
index cb077c6..3a14f7f 100644
--- a/Antlr3/Analysis/LL1Analyzer.cs
+++ b/Antlr3/Analysis/LL1Analyzer.cs
@@ -494,7 +494,7 @@ namespace Antlr3.Analysis
}

// join this&following-right|following-down
-            return SemanticContext.and( p, SemanticContext.or( p0, p1 ) );
+            return SemanticContext.And( p, SemanticContext.Or( p0, p1 ) );
}
}
}
diff --git a/Antlr3/Analysis/NFAConfiguration.cs b/Antlr3/Analysis/NFAConfiguration.cs
index b33050e..1b9de38 100644
--- a/Antlr3/Analysis/NFAConfiguration.cs
+++ b/Antlr3/Analysis/NFAConfiguration.cs
@@ -60,7 +60,7 @@ namespace Antlr3.Analysis
*  the equals() method will correctly show {pred1,pred2} as equals()
*  to {pred2,pred1}.
*/
-        public SemanticContext semanticContext = SemanticContext.EMPTY_SEMANTIC_CONTEXT;
+        public SemanticContext semanticContext = SemanticContext.EmptySemanticContext;

/** Indicate that this configuration has been resolved and no further
*  DFA processing should occur with it.  Essentially, this is used
@@ -149,7 +149,7 @@ namespace Antlr3.Analysis
buf.Append( context );
}
if ( semanticContext != null &&
-                 semanticContext != SemanticContext.EMPTY_SEMANTIC_CONTEXT )
+                 semanticContext != SemanticContext.EmptySemanticContext )
{
buf.Append( "|" );
string escQuote = semanticContext.ToString().Replace( "\"", "\\\"" );
diff --git a/Antlr3/Analysis/NFAtoDFAConverter.cs b/Antlr3/Analysis/NFAtoDFAConverter.cs
index 97712bf..7dc73a3 100644
--- a/Antlr3/Analysis/NFAtoDFAConverter.cs
+++ b/Antlr3/Analysis/NFAtoDFAConverter.cs
@@ -177,7 +177,7 @@ namespace Antlr3.Analysis
closure( (NFAState)alt.transition[0].target,
altNum,
initialContext,
-                            SemanticContext.EMPTY_SEMANTIC_CONTEXT,
+                            SemanticContext.EmptySemanticContext,
startState,
true
);
@@ -188,7 +188,7 @@ namespace Antlr3.Analysis
closure( (NFAState)alt.transition[0].target,
altNum,
initialContext,
-                            SemanticContext.EMPTY_SEMANTIC_CONTEXT,
+                            SemanticContext.EmptySemanticContext,
startState,
true
);
@@ -270,20 +270,20 @@ namespace Antlr3.Analysis
// [Taking back out a few days later on Jan 17, 2006.  This could
//  be an option for the future, but this was wrong soluion for
//  filtering.]
-            /*
-            if ( dfa.nfa.grammar.type==Grammar.LEXER && containsEOT ) {
-                String filterOption = (String)dfa.nfa.grammar.getOption("filter");
-                boolean filterMode = filterOption!=null && filterOption.equals("true");
+#if false
+            if ( dfa.nfa.grammar.type==Antlr3.Tool.Grammar.LEXER && containsEOT ) {
+                string filterOption = (string)dfa.nfa.grammar.getOption("filter");
+                bool filterMode = filterOption!=null && filterOption.Equals("true");
if ( filterMode && d.dfa.isTokensRuleDecision() ) {
DFAState t = reach(d, EOTLabel);
-                    if ( t.getNFAConfigurations().size()>0 ) {
+                    if ( t.nfaConfigurations.size()>0 ) {
convertToEOTAcceptState(d);
//JSystem.@out.println("state "+d+" has EOT target "+t.stateNumber);
return;
}
}
}
-            */
+#endif

int numberOfEdgesEmanating = 0;
var targetToLabelMap = new Dictionary<int, Transition>();
@@ -807,7 +807,7 @@ namespace Antlr3.Analysis
{
//JSystem.@out.println("&"+labelContext+" enclosingRule="+p.enclosingRule);
newSemanticContext =
-                                SemanticContext.and( semanticContext, labelContext );
+                                SemanticContext.And( semanticContext, labelContext );
}
}
closure( (NFAState)transition0.target,
@@ -1510,7 +1510,7 @@ namespace Antlr3.Analysis
else
{
nakedAltPred =
-                            SemanticContext.not( unionOfPredicatesFromAllAlts );
+                            SemanticContext.Not( unionOfPredicatesFromAllAlts );
}
}

@@ -1629,7 +1629,7 @@ namespace Antlr3.Analysis
{
// if there is a predicate for this NFA configuration, OR in
if ( configuration.semanticContext !=
-                         SemanticContext.EMPTY_SEMANTIC_CONTEXT )
+                         SemanticContext.EmptySemanticContext )
{
HashSet<SemanticContext> predSet = altToSetOfContextsMap.get( altI );
predSet.Add( configuration.semanticContext );
@@ -1683,7 +1683,7 @@ namespace Antlr3.Analysis
SemanticContext combinedContext = null;
foreach ( SemanticContext ctx in contextsForThisAlt )
{
-                    combinedContext = SemanticContext.or( combinedContext, ctx );
+                    combinedContext = SemanticContext.Or( combinedContext, ctx );
}
altToPredicateContextMap[altI] = combinedContext;
}
@@ -1706,7 +1706,7 @@ namespace Antlr3.Analysis
NFAConfiguration configuration = (NFAConfiguration)d.nfaConfigurations.get( i );
int altI = configuration.alt;
if ( incompletelyCoveredAlts.Contains( altI ) &&
-                         configuration.semanticContext == SemanticContext.EMPTY_SEMANTIC_CONTEXT )
+                         configuration.semanticContext == SemanticContext.EmptySemanticContext )
{
NFAState s = dfa.nfa.getState( configuration.state );
/*
@@ -1760,7 +1760,7 @@ namespace Antlr3.Analysis
else
{
unionOfPredicatesFromAllAlts =
-                            SemanticContext.or( unionOfPredicatesFromAllAlts, semCtx );
+                            SemanticContext.Or( unionOfPredicatesFromAllAlts, semCtx );
}
}
return unionOfPredicatesFromAllAlts;
diff --git a/Antlr3/Analysis/SemanticContext.cs b/Antlr3/Analysis/SemanticContext.cs
index c2d0bf0..03f3841 100644
--- a/Antlr3/Analysis/SemanticContext.cs
+++ b/Antlr3/Analysis/SemanticContext.cs
@@ -70,7 +70,7 @@ namespace Antlr3.Analysis
*  This prevents lots of if!=null type checks all over; it represents
*  just an empty set of predicates.
*/
-        public static readonly SemanticContext EMPTY_SEMANTIC_CONTEXT = new Predicate();
+        public static readonly SemanticContext EmptySemanticContext = new Predicate();

/** Given a semantic context expression tree, return a tree with all
*  nongated predicates set to true and then reduced.  So p&&(q||r) would
@@ -98,7 +98,7 @@ namespace Antlr3.Analysis
{
}

-        public /*static*/ class Predicate : SemanticContext
+        public class Predicate : SemanticContext
{
/** The AST node in tree created from the grammar holding the predicate */
public GrammarAST predicateAST;
@@ -117,15 +117,15 @@ namespace Antlr3.Analysis
*/
protected bool synpred = false;

-            public const int INVALID_PRED_VALUE = -1;
-            public const int FALSE_PRED = 0;
-            public const int TRUE_PRED = 1;
+            public const int InvalidPredValue = -1;
+            public const int FalsePred = 0;
+            public const int TruePred = 1;

/** sometimes predicates are known to be true or false; we need
*  a way to represent this without resorting to a target language
*  value like true or TRUE.
*/
-            protected int constantValue = INVALID_PRED_VALUE;
+            protected int constantValue = InvalidPredValue;

public Predicate()
{
@@ -262,11 +262,11 @@ namespace Antlr3.Analysis
}
}

-        public /*static*/ class TruePredicate : Predicate
+        public class TruePredicate : Predicate
{
public TruePredicate()
{
-                this.constantValue = TRUE_PRED;
+                this.constantValue = TruePred;
}

public override StringTemplate genExpr( CodeGenerator generator,
@@ -286,28 +286,31 @@ namespace Antlr3.Analysis
}
}

-        /*
-        public static class FalsePredicate extends Predicate {
-            public FalsePredicate() {
-                super();
-                this.constantValue = FALSE_PRED;
+#if false
+        public class FalsePredicate : Predicate
+        {
+            public FalsePredicate()
+            {
+                this.constantValue = FalsePred;
}
-            public StringTemplate genExpr(CodeGenerator generator,
+            public StringTemplate genExpr( CodeGenerator generator,
StringTemplateGroup templates,
-                                          DFA dfa)
+                                          DFA dfa )
{
-                if ( templates!=null ) {
-                    return templates.getInstanceOf("false");
+                if ( templates != null )
+                {
+                    return templates.GetInstanceOf( "false" );
}
-                return new StringTemplate("false");
+                return new StringTemplate( "false" );
}
-            public String toString() {
+            public override string ToString()
+            {
return "false"; // not used for code gen, just DOT and print outs
}
}
-        */
+#endif

-        public /*static*/ class AND : SemanticContext
+        public class AND : SemanticContext
{
protected SemanticContext left, right;
public AND( SemanticContext a, SemanticContext b )
@@ -367,7 +370,7 @@ namespace Antlr3.Analysis
}
}

-        public /*static*/ class OR : SemanticContext
+        public class OR : SemanticContext
{
protected HashSet<object> operands;
public OR( SemanticContext a, SemanticContext b )
@@ -419,7 +422,7 @@ namespace Antlr3.Analysis
SemanticContext gatedPred = semctx.GatedPredicateContext;
if ( gatedPred != null )
{
-                            result = or( result, gatedPred );
+                            result = Or( result, gatedPred );
// result = new OR(result, gatedPred);
}
}
@@ -466,7 +469,7 @@ namespace Antlr3.Analysis
}
}

-        public /*static*/ class NOT : SemanticContext
+        public class NOT : SemanticContext
{
protected internal SemanticContext ctx;
public NOT( SemanticContext ctx )
@@ -533,14 +536,14 @@ namespace Antlr3.Analysis
}
}

-        public static SemanticContext and( SemanticContext a, SemanticContext b )
+        public static SemanticContext And( SemanticContext a, SemanticContext b )
{
-            //JSystem.@out.println("AND: "+a+"&&"+b);
-            if ( a == EMPTY_SEMANTIC_CONTEXT || a == null )
+            //System.Console.Out.WriteLine( "AND: " + a + "&&" + b );
+            if ( a == EmptySemanticContext || a == null )
{
return b;
}
-            if ( b == EMPTY_SEMANTIC_CONTEXT || b == null )
+            if ( b == EmptySemanticContext || b == null )
{
return a;
}
@@ -548,18 +551,18 @@ namespace Antlr3.Analysis
{
return a; // if same, just return left one
}
-            //JSystem.@out.println("## have to AND");
+            //System.Console.Out.WriteLine( "## have to AND" );
return new AND( a, b );
}

-        public static SemanticContext or( SemanticContext a, SemanticContext b )
+        public static SemanticContext Or( SemanticContext a, SemanticContext b )
{
-            //JSystem.@out.println("OR: "+a+"||"+b);
-            if ( a == EMPTY_SEMANTIC_CONTEXT || a == null )
+            //System.Console.Out.WriteLine( "OR: " + a + "||" + b );
+            if ( a == EmptySemanticContext || a == null )
{
return b;
}
-            if ( b == EMPTY_SEMANTIC_CONTEXT || b == null )
+            if ( b == EmptySemanticContext || b == null )
{
return a;
}
@@ -593,12 +596,16 @@ namespace Antlr3.Analysis
{
return a;
}
-            //JSystem.@out.println("## have to OR");
+            //System.Console.Out.WriteLine( "## have to OR" );
return new OR( a, b );
}

-        public static SemanticContext not( SemanticContext a )
+        public static SemanticContext Not( SemanticContext a )
{
+            NOT nota = a as NOT;
+            if ( nota != null )
+                return nota.ctx;
+
return new NOT( a );
}

diff --git a/Antlr3/AntlrTool.cs b/Antlr3/AntlrTool.cs
index 389b1da..4f9375b 100644
--- a/Antlr3/AntlrTool.cs
+++ b/Antlr3/AntlrTool.cs
@@ -38,11 +38,11 @@ namespace Antlr3
using Antlr.Runtime.JavaExtensions;
using Antlr3.Analysis;
using Antlr3.Codegen;
+    using Antlr3.Misc;
using Antlr3.Tool;

using File = System.IO.File;
using FileInfo = System.IO.FileInfo;
-    using Graph = Antlr3.Misc.Graph;
using IList = System.Collections.IList;
using IOException = System.IO.IOException;
using Path = System.IO.Path;
@@ -586,7 +586,7 @@ namespace Antlr3
public virtual void sortGrammarFiles()
{
//Console.Out.WriteLine( "Grammar names " + GrammarFileNames );
-            Graph g = new Graph();
+            Graph<string> g = new Graph<string>();
foreach ( string gfile in GrammarFileNames )
{
GrammarSpelunker grammar = new GrammarSpelunker( inputDirectory, gfile );
@@ -599,7 +599,7 @@ namespace Antlr3
// Make all generated tokens files depend on their grammars
g.AddEdge( grammarName + CodeGenerator.VOCAB_FILE_EXTENSION, gfile );
}
-            List<object> sorted = g.Sort();
+            List<string> sorted = g.Sort();
//Console.Out.WriteLine( "sorted=" + sorted );
GrammarFileNames.Clear(); // wipe so we can give new ordered list
for ( int i = 0; i < sorted.Count; i++ )
diff --git a/Antlr3/Misc/Graph.cs b/Antlr3/Misc/Graph.cs
index 1c89af1..c122874 100644
--- a/Antlr3/Misc/Graph.cs
+++ b/Antlr3/Misc/Graph.cs
@@ -34,14 +34,14 @@ namespace Antlr3.Misc
{
using System.Collections.Generic;

-    public class Graph
+    public class Graph<T>
{
public class Node
{
-            internal object _payload;
+            internal T _payload;
internal List<Node> _edges; // points at which nodes?

-            public Node( object payload )
+            public Node( T payload )
{
_payload = payload;
}
@@ -63,7 +63,7 @@ namespace Antlr3.Misc
/** Map from node payload to node containing it */
protected Dictionary<object, Node> nodes = new Dictionary<object, Node>();

-        public virtual void AddEdge( object a, object b )
+        public virtual void AddEdge( T a, T b )
{
//System.Console.Out.WriteLine( "add edge " + a + " to " + b );
Node a_node = GetNode( a );
@@ -71,7 +71,7 @@ namespace Antlr3.Misc
a_node.AddEdge( b_node );
}

-        protected virtual Node GetNode( object a )
+        protected virtual Node GetNode( T a )
{
Node existing;
if ( nodes.TryGetValue( a, out existing ) && existing != null )
@@ -92,10 +92,10 @@ namespace Antlr3.Misc
*  So if this gives nonreversed postorder traversal, I get the order
*  I want.
*/
-        public virtual List<object> Sort()
+        public virtual List<T> Sort()
{
HashSet<Node> visited = new HashSet<Node>();
-            List<object> sorted = new List<object>();
+            List<T> sorted = new List<T>();
while ( visited.Count < nodes.Count )
{
// pick any unvisited node, n
@@ -111,7 +111,7 @@ namespace Antlr3.Misc
return sorted;
}

-        public virtual void DFS( Node n, HashSet<Node> visited, List<object> sorted )
+        public virtual void DFS( Node n, HashSet<Node> visited, List<T> sorted )
{
if ( visited.Contains( n ) )
return;

