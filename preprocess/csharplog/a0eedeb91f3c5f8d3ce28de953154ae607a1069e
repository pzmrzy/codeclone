commit a0eedeb91f3c5f8d3ce28de953154ae607a1069e
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Mon Dec 13 14:43:16 2010 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Mon Dec 13 14:43:16 2010 -0800

(C# 3) Added type proxies to StringTemplate
Added TypeRegistry<T>, used for attribute renderers and type proxies so a registered item gets applied to derived types and/or interface implementations in a consistent manner

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 7307]

diff --git a/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj b/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj
index 5a1c611..478e8e5 100644
--- a/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj
+++ b/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj
@@ -61,6 +61,7 @@
</ItemGroup>
<ItemGroup>
<Antlr3 Include="Language\AngleBracketTemplateLexer.g3" />
+    <Compile Include="ITypeProxyFactory.cs" />
<Compile Include="JavaExtensions\AntlrJavaExtensions.cs" />
<Compile Include="JavaExtensions\DictionaryExtensions.cs" />
<Compile Include="JavaExtensions\ListExtensions.cs" />
@@ -111,6 +112,7 @@
<Compile Include="Language\ActionEvaluatorHelper.cs">
<DependentUpon>ActionEvaluator.g3</DependentUpon>
</Compile>
+    <Compile Include="TypeRegistry`1.cs" />
</ItemGroup>
<ItemGroup>
<ProjectReference Include="..\..\..\antlr\main\runtime\CSharp3\Sources\Antlr3.Runtime.Debug\Antlr3.Runtime.Debug.csproj">
diff --git a/Antlr3.StringTemplate/ITypeProxyFactory.cs b/Antlr3.StringTemplate/ITypeProxyFactory.cs
new file mode 100644
index 0000000..c9d3143
--- /dev/null
+++ b/Antlr3.StringTemplate/ITypeProxyFactory.cs
@@ -0,0 +1,39 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2003-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2010 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST
+{
+    public interface ITypeProxyFactory
+    {
+        object CreateProxy(object obj);
+    }
+}
diff --git a/Antlr3.StringTemplate/Language/ASTExpr.cs b/Antlr3.StringTemplate/Language/ASTExpr.cs
index 54d83ba..703ebc5 100644
--- a/Antlr3.StringTemplate/Language/ASTExpr.cs
+++ b/Antlr3.StringTemplate/Language/ASTExpr.cs
@@ -43,13 +43,9 @@ namespace Antlr3.ST.Language
using IDictionary = System.Collections.IDictionary;
using IEnumerable = System.Collections.IEnumerable;
using IList = System.Collections.IList;
-    using IndexerNameAttribute = System.Runtime.CompilerServices.IndexerNameAttribute;
using InvalidOperationException = System.InvalidOperationException;
using IOException = System.IO.IOException;
using ITree = Antlr.Runtime.Tree.ITree;
-    using MemberInfo = System.Reflection.MemberInfo;
-    using MethodImpl = System.Runtime.CompilerServices.MethodImplAttribute;
-    using MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;
using MethodInfo = System.Reflection.MethodInfo;
using PropertyInfo = System.Reflection.PropertyInfo;
using RecognitionException = Antlr.Runtime.RecognitionException;
@@ -616,6 +612,10 @@ namespace Antlr3.ST.Language
if ( o == null )
return null;

+            ITypeProxyFactory proxyFactory = self.GetProxy(o.GetType());
+            if (proxyFactory != null)
+                o = proxyFactory.CreateProxy(o);
+
if ( propertyName == null )
{
IDictionary dictionary = o as IDictionary;
@@ -1006,6 +1006,13 @@ namespace Antlr3.ST.Language
o = _nullValue; // continue with null option if specified
}

+            if (o != null)
+            {
+                ITypeProxyFactory proxyFactory = self.GetProxy(o.GetType());
+                if (proxyFactory != null)
+                    o = proxyFactory.CreateProxy(o);
+            }
+
try
{
StringTemplate stToWrite = o as StringTemplate;
diff --git a/Antlr3.StringTemplate/StringTemplate.cs b/Antlr3.StringTemplate/StringTemplate.cs
index 7ff1b1b..39491b3 100644
--- a/Antlr3.StringTemplate/StringTemplate.cs
+++ b/Antlr3.StringTemplate/StringTemplate.cs
@@ -4,7 +4,7 @@
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2008-2010 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -41,7 +41,6 @@ namespace Antlr3.ST
using CommonToken = Antlr.Runtime.CommonToken;
using CommonTokenStream = Antlr.Runtime.CommonTokenStream;
using CommonTree = Antlr.Runtime.Tree.CommonTree;
-    using ConstructorInfo = System.Reflection.ConstructorInfo;
using DebuggerDisplay = System.Diagnostics.DebuggerDisplayAttribute;
using ICollection = System.Collections.ICollection;
using IDictionary = System.Collections.IDictionary;
@@ -54,7 +53,6 @@ namespace Antlr3.ST
using StringReader = System.IO.StringReader;
using StringWriter = System.IO.StringWriter;
using TargetInvocationException = System.Reflection.TargetInvocationException;
-    using TextReader = System.IO.TextReader;

/** <summary>
*  A <tt>StringTemplate</tt> is a "document" with holes in it where you can stick
@@ -306,7 +304,7 @@ namespace Antlr3.ST
IDictionary<string, object> _attributes;

/** <summary>
-         *  A Map&lt;Class,Object> that allows people to register a renderer for
+         *  A TypeRegistry&lt;IAttributeRenderer&gt; that allows people to register a renderer for
*  a particular kind of object to be displayed in this template.  This
*  overrides any renderer set for this template's group.
*  </summary>
@@ -317,9 +315,9 @@ namespace Antlr3.ST
*  Sometimes though you want to override the group's renderers.
*  </remarks>
*/
-        Dictionary<Type, IAttributeRenderer> _attributeRenderers;
+        private TypeRegistry<IAttributeRenderer> _attributeRenderers;

-        Dictionary<Type, IAttributeRenderer> _interfaceRenderers;
+        private TypeRegistry<ITypeProxyFactory> _proxyFactories;

/** <summary>
*  A list of alternating string and ASTExpr references.
@@ -648,7 +646,7 @@ namespace Antlr3.ST
protected virtual void Dup( StringTemplate from, StringTemplate to )
{
to._attributeRenderers = from._attributeRenderers;
-            to._interfaceRenderers = from._interfaceRenderers;
+            to._proxyFactories = from._proxyFactories;
to._pattern = from._pattern;
to._chunks = from._chunks;
to._formalArguments = from._formalArguments;
@@ -1365,26 +1363,12 @@ namespace Antlr3.ST
*  overrides any renderer set in the group for this class type.
*  </summary>
*/
-        public virtual void RegisterRenderer( Type attributeClassType, IAttributeRenderer renderer )
+        public virtual void RegisterRenderer( Type objectType, IAttributeRenderer renderer )
{
-            Dictionary<Type, IAttributeRenderer> renderers;
-            // renderers for interface types are kept separately due to their performance implications
-            if (!attributeClassType.IsInterface)
-            {
-                if (_attributeRenderers == null)
-                    _attributeRenderers = new Dictionary<Type, IAttributeRenderer>();
-
-                renderers = _attributeRenderers;
-            }
-            else
-            {
-                if (_interfaceRenderers == null)
-                    _interfaceRenderers = new Dictionary<Type, IAttributeRenderer>();
-
-                renderers = _interfaceRenderers;
-            }
+            if (_attributeRenderers == null)
+                _attributeRenderers = new TypeRegistry<IAttributeRenderer>();

-            renderers[attributeClassType] = renderer;
+            _attributeRenderers[objectType] = renderer;
}

/** <summary>
@@ -1392,37 +1376,39 @@ namespace Antlr3.ST
*  this template.  If not found, the template's group is queried.
*  </summary>
*/
-        public virtual IAttributeRenderer GetAttributeRenderer( Type attributeClassType )
+        public virtual IAttributeRenderer GetAttributeRenderer( Type objectType )
{
-            IAttributeRenderer renderer = null;
-            if ( _attributeRenderers != null )
-            {
-                if ( !_attributeRenderers.TryGetValue( attributeClassType, out renderer ) )
-                    renderer = null;
-            }
+            IAttributeRenderer renderer;
+            if (_attributeRenderers != null && _attributeRenderers.TryGetValue(objectType, out renderer))
+                return renderer;

-            // Only need to perform the expensive interface checks if the user registered a renderer for an interface type
-            if (renderer == null && _interfaceRenderers != null)
-            {
-                renderer = _interfaceRenderers.FirstOrDefault(pair => pair.Key.IsAssignableFrom(attributeClassType)).Value;
-            }
+            if (_enclosingInstance != null)
+                return _enclosingInstance.GetAttributeRenderer(objectType);

-            if ( renderer != null )
-            {
-                // found it!
-                return renderer;
-            }
+            return _group.GetAttributeRenderer(objectType);
+        }

-            // we have no renderer overrides for the template or none for class arg
-            // check parent template if we are embedded
-            if ( _enclosingInstance != null )
-            {
-                return _enclosingInstance.GetAttributeRenderer( attributeClassType );
-            }
-            // else check group
-            return _group.GetAttributeRenderer( attributeClassType );
+        public virtual void RegisterProxy(Type originalObjectType, ITypeProxyFactory proxyFactory)
+        {
+            if (_proxyFactories == null)
+                _proxyFactories = new TypeRegistry<ITypeProxyFactory>();
+
+            _proxyFactories[originalObjectType] = proxyFactory;
}

+        public virtual ITypeProxyFactory GetProxy(Type originalObjectType)
+        {
+            ITypeProxyFactory proxyFactory;
+            if (_proxyFactories != null && _proxyFactories.TryGetValue(originalObjectType, out proxyFactory))
+                return proxyFactory;
+
+            if (_enclosingInstance != null)
+                return _enclosingInstance.GetProxy(originalObjectType);
+
+            return _group.GetProxy(originalObjectType);
+        }
+
+
#region Utility routines

public virtual void Error( string msg )
diff --git a/Antlr3.StringTemplate/StringTemplateGroup.cs b/Antlr3.StringTemplate/StringTemplateGroup.cs
index f4bb8a8..d7119ab 100644
--- a/Antlr3.StringTemplate/StringTemplateGroup.cs
+++ b/Antlr3.StringTemplate/StringTemplateGroup.cs
@@ -4,7 +4,7 @@
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2010 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -35,6 +35,7 @@ namespace Antlr3.ST
using System;
using System.Collections.Generic;
using System.Linq;
+    using System.Linq.Expressions;
using Antlr.Runtime.JavaExtensions;

using AngleBracketTemplateLexer = Antlr3.ST.Language.AngleBracketTemplateLexer;
@@ -58,7 +59,6 @@ namespace Antlr3.ST
using StringBuilder = System.Text.StringBuilder;
using TextReader = System.IO.TextReader;
using TextWriter = System.IO.TextWriter;
-    using System.Linq.Expressions;

/** <summary>
*  Manages a group of named mutually-referential StringTemplate objects.
@@ -184,7 +184,9 @@ namespace Antlr3.ST
*  Synchronized at creation time.
*  </remarks>
*/
-        Dictionary<Type, IAttributeRenderer> _attributeRenderers;
+        private TypeRegistry<IAttributeRenderer> _attributeRenderers;
+
+        private TypeRegistry<ITypeProxyFactory> _proxyFactories;

/** <summary>
*  If a group file indicates it derives from a supergroup, how do we
@@ -1191,28 +1193,16 @@ namespace Antlr3.ST
}

/** <summary>
-         *  Specify a complete map of what object classes should map to which
-         *  renderer objects for every template in this group (that doesn't
-         *  override it per template).
-         *  </summary>
-         */
-        public virtual void SetAttributeRenderers( Dictionary<Type, IAttributeRenderer> renderers )
-        {
-            this._attributeRenderers = renderers;
-        }
-
-        /** <summary>
*  Register a renderer for all objects of a particular type for all
*  templates in this group.
*  </summary>
*/
-        public virtual void RegisterRenderer( Type attributeClassType, IAttributeRenderer renderer )
+        public virtual void RegisterRenderer( Type objectType, IAttributeRenderer renderer )
{
-            if ( _attributeRenderers == null )
-            {
-                _attributeRenderers = new Dictionary<Type, IAttributeRenderer>();
-            }
-            _attributeRenderers[attributeClassType] = renderer;
+            if (_attributeRenderers == null)
+                _attributeRenderers = new TypeRegistry<IAttributeRenderer>();
+
+            _attributeRenderers[objectType] = renderer;
}

/** <summary>
@@ -1220,28 +1210,36 @@ namespace Antlr3.ST
*  this group?  If not found, as superGroup if it has one.
*  </summary>
*/
-        public virtual IAttributeRenderer GetAttributeRenderer( Type attributeClassType )
+        public virtual IAttributeRenderer GetAttributeRenderer( Type objectType )
{
-            if ( _attributeRenderers == null )
-            {
-                if ( _superGroup == null )
-                {
-                    return null; // no renderers and no parent?  Stop.
-                }
-                // no renderers; consult super group
-                return _superGroup.GetAttributeRenderer( attributeClassType );
-            }
-
IAttributeRenderer renderer;
-            if ( !_attributeRenderers.TryGetValue( attributeClassType, out renderer ) || renderer == null )
-            {
-                if ( _superGroup != null )
-                {
-                    // no renderer registered for this class, check super group
-                    renderer = _superGroup.GetAttributeRenderer( attributeClassType );
-                }
-            }
-            return renderer;
+            if (_attributeRenderers != null && _attributeRenderers.TryGetValue(objectType, out renderer))
+                return renderer;
+
+            if (_superGroup != null)
+                return _superGroup.GetAttributeRenderer(objectType);
+
+            return null;
+        }
+
+        public virtual void RegisterProxy(Type originalObjectType, ITypeProxyFactory proxyFactory)
+        {
+            if (_proxyFactories == null)
+                _proxyFactories = new TypeRegistry<ITypeProxyFactory>();
+
+            _proxyFactories[originalObjectType] = proxyFactory;
+        }
+
+        public virtual ITypeProxyFactory GetProxy(Type originalObjectType)
+        {
+            ITypeProxyFactory proxyFactory;
+            if (_proxyFactories != null && _proxyFactories.TryGetValue(originalObjectType, out proxyFactory))
+                return proxyFactory;
+
+            if (_superGroup != null)
+                return _superGroup.GetProxy(originalObjectType);
+
+            return null;
}

public virtual IDictionary GetMap( string name )
diff --git a/Antlr3.StringTemplate/TypeRegistry`1.cs b/Antlr3.StringTemplate/TypeRegistry`1.cs
new file mode 100644
index 0000000..e533268
--- /dev/null
+++ b/Antlr3.StringTemplate/TypeRegistry`1.cs
@@ -0,0 +1,373 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2003-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2010 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST
+{
+    using System.Collections.Generic;
+    using System.Linq;
+    using AmbiguousMatchException = System.Reflection.AmbiguousMatchException;
+    using Array = System.Array;
+    using ICollection = System.Collections.ICollection;
+    using IDictionary = System.Collections.IDictionary;
+    using IDictionaryEnumerator = System.Collections.IDictionaryEnumerator;
+    using IEnumerable = System.Collections.IEnumerable;
+    using IEnumerator = System.Collections.IEnumerator;
+    using NotSupportedException = System.NotSupportedException;
+    using StringBuilder = System.Text.StringBuilder;
+    using Type = System.Type;
+
+    public class TypeRegistry<T> : IDictionary<Type, T>, IDictionary
+    {
+        private readonly Dictionary<Type, T> _backingStore = new Dictionary<Type, T>();
+        private readonly Dictionary<Type, Type> _cache = new Dictionary<Type, Type>();
+
+        ICollection<Type> IDictionary<Type, T>.Keys
+        {
+            get
+            {
+                return _backingStore.Keys;
+            }
+        }
+
+        ICollection<T> IDictionary<Type, T>.Values
+        {
+            get
+            {
+                return _backingStore.Values;
+            }
+        }
+
+        int ICollection<KeyValuePair<Type, T>>.Count
+        {
+            get
+            {
+                return _backingStore.Count;
+            }
+        }
+
+        int ICollection.Count
+        {
+            get
+            {
+                return _backingStore.Count;
+            }
+        }
+
+        bool ICollection<KeyValuePair<Type, T>>.IsReadOnly
+        {
+            get
+            {
+                return false;
+            }
+        }
+
+        bool IDictionary.IsFixedSize
+        {
+            get
+            {
+                return false;
+            }
+        }
+
+        bool IDictionary.IsReadOnly
+        {
+            get
+            {
+                return false;
+            }
+        }
+
+        ICollection IDictionary.Keys
+        {
+            get
+            {
+                return _backingStore.Keys;
+            }
+        }
+
+        ICollection IDictionary.Values
+        {
+            get
+            {
+                return _backingStore.Values;
+            }
+        }
+
+        bool ICollection.IsSynchronized
+        {
+            get
+            {
+                return false;
+            }
+        }
+
+        object ICollection.SyncRoot
+        {
+            get
+            {
+                throw new NotSupportedException();
+            }
+        }
+
+        public T this[Type key]
+        {
+            get
+            {
+                T value;
+                if (!TryGetValue(key, out value))
+                    throw new KeyNotFoundException();
+
+                return value;
+            }
+
+            set
+            {
+                _backingStore[key] = value;
+                HandleAlteration(key);
+            }
+        }
+
+        object IDictionary.this[object key]
+        {
+            get
+            {
+                Type t = key as Type;
+                if (t == null && key != null)
+                    return null;
+
+                T value;
+                if (!TryGetValue(t, out value))
+                    return null;
+
+                return value;
+            }
+
+            set
+            {
+                this[(Type)key] = (T)value;
+            }
+        }
+
+        public void Add(Type key, T value)
+        {
+            _backingStore.Add(key, value);
+            HandleAlteration(key);
+        }
+
+        public bool ContainsKey(Type key)
+        {
+            if (_cache.ContainsKey(key))
+                return true;
+
+            T value;
+            return TryGetValue(key, out value);
+        }
+
+        public bool Remove(Type key)
+        {
+            if (_backingStore.Remove(key))
+            {
+                HandleAlteration(key);
+                return true;
+            }
+
+            return false;
+        }
+
+        public bool TryGetValue(Type key, out T value)
+        {
+            if (_backingStore.TryGetValue(key, out value))
+                return true;
+
+            Type redirect;
+            if (_cache.TryGetValue(key, out redirect))
+            {
+                if (redirect == null)
+                {
+                    value = default(T);
+                    return false;
+                }
+                else
+                {
+                    return _backingStore.TryGetValue(redirect, out value);
+                }
+            }
+
+            List<Type> candidates = _backingStore.Keys.Where(i => i.IsAssignableFrom(key)).ToList();
+            if (candidates.Count == 0)
+            {
+                _cache[key] = null;
+                value = default(T);
+                return false;
+            }
+            else if (candidates.Count == 1)
+            {
+                _cache[key] = candidates[0];
+                return _backingStore.TryGetValue(candidates[0], out value);
+            }
+            else
+            {
+                for (int i = 0; i < candidates.Count - 1; i++)
+                {
+                    if (candidates[i] == null)
+                        continue;
+
+                    for (int j = i + 1; j < candidates.Count; j++)
+                    {
+                        if (candidates[i].IsAssignableFrom(candidates[j]))
+                        {
+                            candidates[i] = null;
+                            break;
+                        }
+                        else if (candidates[j].IsAssignableFrom(candidates[i]))
+                        {
+                            candidates[j] = null;
+                        }
+                    }
+                }
+
+                candidates.RemoveAll(i => i == null);
+                if (candidates.Count != 1)
+                {
+                    StringBuilder builder = new StringBuilder();
+                    builder.AppendFormat("The type '{0}' does not match a single item in the registry. The {1} ambiguous matches are:", key.FullName, candidates.Count);
+                    foreach (var candidate in candidates)
+                    {
+                        builder.AppendLine();
+                        builder.AppendFormat("    {0}", candidate.FullName);
+                    }
+
+                    throw new AmbiguousMatchException(builder.ToString());
+                }
+
+                _cache[key] = candidates[0];
+                return _backingStore.TryGetValue(candidates[0], out value);
+            }
+        }
+
+        public void Clear()
+        {
+            _backingStore.Clear();
+            _cache.Clear();
+        }
+
+        public IEnumerator<KeyValuePair<Type, T>> GetEnumerator()
+        {
+            return _backingStore.GetEnumerator();
+        }
+
+        void ICollection<KeyValuePair<Type, T>>.Add(KeyValuePair<Type, T> item)
+        {
+            Add(item.Key, item.Value);
+        }
+
+        bool ICollection<KeyValuePair<Type, T>>.Contains(KeyValuePair<Type, T> item)
+        {
+            T value;
+            if (_backingStore.TryGetValue(item.Key, out value))
+            {
+                if (EqualityComparer<T>.Default.Equals(value, item.Value))
+                    return true;
+            }
+
+            return false;
+        }
+
+        void ICollection<KeyValuePair<Type, T>>.CopyTo(KeyValuePair<Type, T>[] array, int arrayIndex)
+        {
+            ((ICollection<KeyValuePair<Type, T>>)_backingStore).CopyTo(array, arrayIndex);
+        }
+
+        bool ICollection<KeyValuePair<Type, T>>.Remove(KeyValuePair<Type, T> item)
+        {
+            T value;
+            if (_backingStore.TryGetValue(item.Key, out value))
+            {
+                if (EqualityComparer<T>.Default.Equals(value, item.Value))
+                    return _backingStore.Remove(item.Key);
+            }
+
+            return false;
+        }
+
+        IEnumerator IEnumerable.GetEnumerator()
+        {
+            return GetEnumerator();
+        }
+
+        void IDictionary.Add(object key, object value)
+        {
+            Add((Type)key, (T)value);
+        }
+
+        void IDictionary.Clear()
+        {
+            Clear();
+        }
+
+        bool IDictionary.Contains(object key)
+        {
+            if (key == null)
+                return ContainsKey(null);
+
+            Type t = key as Type;
+            if (t == null)
+                return false;
+
+            return ContainsKey(t);
+        }
+
+        IDictionaryEnumerator IDictionary.GetEnumerator()
+        {
+            return _backingStore.GetEnumerator();
+        }
+
+        void IDictionary.Remove(object key)
+        {
+            Type t = key as Type;
+            if (t != null || key == null)
+                Remove(t);
+        }
+
+        void ICollection.CopyTo(Array array, int index)
+        {
+            ((ICollection)_backingStore).CopyTo(array, index);
+        }
+
+        private void HandleAlteration(Type type)
+        {
+            Type[] altered = _cache.Where(i => type.IsAssignableFrom(i.Key)).Select(i => i.Key).ToArray();
+            foreach (var t in altered)
+                _cache.Remove(t);
+        }
+    }
+}

