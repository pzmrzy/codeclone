commit cf2af7c5d67df89c0a7729b2305cfbec2f65f789
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Wed Jan 20 18:00:23 2010 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Wed Jan 20 18:00:23 2010 -0800

C# Port:
* Merge 6487

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 6590]

diff --git a/Antlr3.Test/Antlr3.Test.csproj b/Antlr3.Test/Antlr3.Test.csproj
index 8471cde..ee9933b 100644
--- a/Antlr3.Test/Antlr3.Test.csproj
+++ b/Antlr3.Test/Antlr3.Test.csproj
@@ -58,6 +58,7 @@
<Compile Include="ST4\TestImports.cs" />
<Compile Include="ST4\TestIndentation.cs" />
<Compile Include="ST4\TestIndirectionAndEarlyEvaluation.cs" />
+    <Compile Include="ST4\TestInterptimeErrors.cs" />
<Compile Include="ST4\TestLexer.cs" />
<Compile Include="ST4\TestLineWrap.cs" />
<Compile Include="ST4\TestLists.cs" />
@@ -65,7 +66,6 @@
<Compile Include="ST4\TestOptions.cs" />
<Compile Include="ST4\TestRegions.cs" />
<Compile Include="ST4\TestRenderers.cs" />
-    <Compile Include="ST4\TestRuntimeErrors.cs" />
<Compile Include="ST4\TestSubtemplates.cs" />
<Compile Include="ST4\TestSyntaxErrors.cs" />
<Compile Include="ST4\TestWhitespace.cs" />
diff --git a/Antlr3.Test/ST4/TestCoreBasics.cs b/Antlr3.Test/ST4/TestCoreBasics.cs
index b6154f8..532f31c 100644
--- a/Antlr3.Test/ST4/TestCoreBasics.cs
+++ b/Antlr3.Test/ST4/TestCoreBasics.cs
@@ -33,6 +33,27 @@
}

[TestMethod]
+        public void TestSetUnknownAttr()
+        {
+            string templates =
+                "t() ::= <<hi <name>!>>\n";
+            ErrorBuffer errors = new ErrorBuffer();
+            ErrorManager.ErrorListener = errors;
+            WriteFile(tmpdir, "t.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
+            var st = group.GetInstanceOf("t");
+            st.Add("name", "Ter");
+            string expected = "hi Ter!";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+
+            // check error now
+            expected = "context [t]  can't set attribute name; template t has no such attribute" + newline;
+            result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
public void TestMultiAttr()
{
string template = "hi <name>!";
diff --git a/Antlr3.Test/ST4/TestGroupSyntaxErrors.cs b/Antlr3.Test/ST4/TestGroupSyntaxErrors.cs
index 0b0432e..d0e5927 100644
--- a/Antlr3.Test/ST4/TestGroupSyntaxErrors.cs
+++ b/Antlr3.Test/ST4/TestGroupSyntaxErrors.cs
@@ -243,7 +243,9 @@ namespace AntlrUnitTests.ST4
group = new STGroupFile(tmpdir + "/" + "t.stg");
ErrorManager.ErrorListener = errors;
group.Load(); // force load
-            String expected = "t.stg 1:9: unterminated string, t.stg 1:9: missing template at '<EOF>'" + newline;
+            String expected =
+                "t.stg 1:9: unterminated string" + newline +
+                "t.stg 1:9: missing template at '<EOF>'" + newline;
String result = errors.ToString();
Assert.AreEqual(expected, result);
}
diff --git a/Antlr3.Test/ST4/TestInterptimeErrors.cs b/Antlr3.Test/ST4/TestInterptimeErrors.cs
new file mode 100644
index 0000000..af0eb1e
--- /dev/null
+++ b/Antlr3.Test/ST4/TestInterptimeErrors.cs
@@ -0,0 +1,301 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace AntlrUnitTests.ST4
+{
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using ST = StringTemplate.Template;
+    using STErrorListener = StringTemplate.ITemplateErrorListener;
+    using STGroup = StringTemplate.TemplateGroup;
+    using STGroupDir = StringTemplate.TemplateGroupDirectory;
+    using STGroupFile = StringTemplate.TemplateGroupFile;
+    using String = System.String;
+    using Path = System.IO.Path;
+    using StringTemplate;
+
+    [TestClass]
+    public class TestInterptimeErrors : StringTemplateTestBase
+    {
+        public class UserHiddenName
+        {
+            private string name;
+
+            public UserHiddenName(string name)
+            {
+                this.name = name;
+            }
+
+            protected string Name
+            {
+                get
+                {
+                    return name;
+                }
+            }
+        }
+
+        public class UserHiddenNameField
+        {
+            private string name;
+
+            public UserHiddenNameField(string name)
+            {
+                this.name = name;
+            }
+        }
+
+        [TestMethod]
+        public void TestMissingEmbeddedTemplate()
+        {
+            ErrorBuffer errors = new ErrorBuffer();
+            ErrorManager.ErrorListener = errors;
+
+            String templates =
+                "t() ::= \"<foo()>\"" + newline;
+
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            ST st = group.GetInstanceOf("t");
+            st.Render();
+            String expected = "context [t] 1:0 no such template: foo" + newline;
+            String result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestMissingSuperTemplate()
+        {
+            ErrorBuffer errors = new ErrorBuffer();
+            ErrorManager.ErrorListener = errors;
+
+            String templates =
+                "t() ::= \"<super.t()>\"" + newline;
+
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            String templates2 =
+                "u() ::= \"blech\"" + newline;
+
+            WriteFile(tmpdir, "t2.stg", templates2);
+            STGroup group2 = new STGroupFile(Path.Combine(tmpdir, "t2.stg"));
+            group.ImportTemplates(group2);
+            ST st = group.GetInstanceOf("t");
+            st.Render();
+            String expected = "context [t] 1:1 no such template: super.t" + newline;
+            String result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestNoPropertyNotError()
+        {
+            ErrorBuffer errors = new ErrorBuffer();
+            ErrorManager.ErrorListener = errors;
+
+            String templates =
+                "t(u) ::= \"<u.x>\"" + newline;
+
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            ST st = group.GetInstanceOf("t");
+            st.Add("u", new User(32, "parrt"));
+            st.Render();
+            String expected = "";
+            String result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestHiddenPropertyNotError()
+        {
+            ErrorBuffer errors = new ErrorBuffer();
+            ErrorManager.ErrorListener = errors;
+
+            String templates =
+                "t(u) ::= \"<u.name>\"" + newline;
+
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            ST st = group.GetInstanceOf("t");
+            st.Add("u", new UserHiddenName("parrt"));
+            st.Render();
+            String expected = "";
+            String result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestHiddenFieldNotError()
+        {
+            ErrorBuffer errors = new ErrorBuffer();
+            ErrorManager.ErrorListener = errors;
+
+            String templates =
+                "t(u) ::= \"<u.name>\"" + newline;
+
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            ST st = group.GetInstanceOf("t");
+            st.Add("u", new UserHiddenNameField("parrt"));
+            st.Render();
+            String expected = "";
+            String result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSoleArg()
+        {
+            ErrorBuffer errors = new ErrorBuffer();
+            ErrorManager.ErrorListener = errors;
+
+            string templates =
+                "t() ::= \"<u({9})>\"\n" +
+                "u(x,y) ::= \"<x>\"\n";
+
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            ST st = group.GetInstanceOf("t");
+            st.Render();
+            string expected = "context [t] 1:3 expecting single arg in template reference u() (not 2 args)" + newline;
+            string result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestUndefinedArg()
+        {
+            ErrorBuffer errors = new ErrorBuffer();
+            ErrorManager.ErrorListener = errors;
+
+            string templates =
+                "t() ::= \"<u()>\"\n" +
+                "u() ::= \"<x>\"\n";
+
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            group.Debug = true;
+            ST st = group.GetInstanceOf("t");
+            st.Render();
+            String expected = "context [t, u] 1:1 attribute x isn't defined" + newline;
+            String result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestUndefinedArgNoProblemInCompatibilityMode()
+        {
+            ErrorBuffer errors = new ErrorBuffer();
+            ErrorManager.ErrorListener = errors;
+            ErrorManager.CompatibilityMode = true;
+
+            try
+            {
+                string templates =
+                    "t() ::= \"<u()>\"\n" +
+                    "u() ::= \"<x>\"\n";
+
+                WriteFile(tmpdir, "t.stg", templates);
+                STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+                ST st = group.GetInstanceOf("t");
+                st.Render();
+                String expected = "";
+                String result = errors.ToString();
+                Assert.AreEqual(expected, result);
+            }
+            finally
+            {
+                ErrorManager.CompatibilityMode = false;
+            }
+        }
+
+        [TestMethod]
+        public void TestParallelAttributeIterationWithMismatchArgListSizes()
+        {
+            ErrorBuffer errors = new ErrorBuffer();
+            ErrorManager.ErrorListener = errors;
+            Template e = new Template(
+                    "<names,phones,salaries:{n,p | <n>@<p>}; separator=\", \">"
+                );
+            e.Add("names", "Ter");
+            e.Add("names", "Tom");
+            e.Add("phones", "1");
+            e.Add("phones", "2");
+            e.Add("salaries", "big");
+            e.Render();
+            string errorExpecting = "context [anonymous] 1:1 iterating through 3 arguments but parallel map has 2 formal arguments" + newline;
+            Assert.AreEqual(errorExpecting, errors.ToString());
+            string expecting = "Ter@1, Tom@2";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestParallelAttributeIterationWithMissingArgs()
+        {
+            ErrorBuffer errors = new ErrorBuffer();
+            ErrorManager.ErrorListener = errors;
+            Template e = new Template(
+                    "<names,phones,salaries:{<n>@<p>}; separator=\", \">"
+                );
+            e.Add("names", "Tom");
+            e.Add("phones", "2");
+            e.Add("salaries", "big");
+            e.Render(); // generate the error
+            string errorExpecting = "context [anonymous] 1:1 missing argument definitions" + newline;
+            Assert.AreEqual(errorExpecting, errors.ToString());
+        }
+
+        [TestMethod]
+        public void TestStringTypeMismatch()
+        {
+            ErrorBuffer errors = new ErrorBuffer();
+            ErrorManager.ErrorListener = errors;
+            ST e = new ST("<trim(s)>");
+            e.Add("s", 34);
+            e.Render(); // generate the error
+            String errorExpecting = "context [anonymous] 1:1 function trim expects a string not System.Int32" + newline;
+            Assert.AreEqual(errorExpecting, errors.ToString());
+        }
+
+        [TestMethod]
+        public void TestStringTypeMismatch2()
+        {
+            ErrorBuffer errors = new ErrorBuffer();
+            ErrorManager.ErrorListener = errors;
+            ST e = new ST("<strlen(s)>");
+            e.Add("s", 34);
+            e.Render(); // generate the error
+            String errorExpecting = "context [anonymous] 1:1 function strlen expects a string not System.Int32" + newline;
+            Assert.AreEqual(errorExpecting, errors.ToString());
+        }
+    }
+}
diff --git a/Antlr3.Test/ST4/TestLineWrap.cs b/Antlr3.Test/ST4/TestLineWrap.cs
index f3820d0..1c59978 100644
--- a/Antlr3.Test/ST4/TestLineWrap.cs
+++ b/Antlr3.Test/ST4/TestLineWrap.cs
@@ -103,7 +103,8 @@ namespace AntlrUnitTests.ST4
WriteFile(tmpdir, "t.stg", templates);
STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));

-            ST x = new ST(group, "<\\n>{ <stuff; anchor, separator=\",\\n\"> }<\\n>");
+            ST x = new ST("<\\n>{ <stuff; anchor, separator=\",\\n\"> }<\\n>");
+            x.groupThatCreatedThisInstance = group;
x.Add("stuff", "1");
x.Add("stuff", "2");
x.Add("stuff", "3");
diff --git a/Antlr3.Test/ST4/TestRenderers.cs b/Antlr3.Test/ST4/TestRenderers.cs
index 3ae725b..7453f83 100644
--- a/Antlr3.Test/ST4/TestRenderers.cs
+++ b/Antlr3.Test/ST4/TestRenderers.cs
@@ -195,7 +195,8 @@ namespace AntlrUnitTests.ST4
"The names: <names; format=\"upper\">";
TemplateGroup group = new TemplateGroup();
group.RegisterRenderer(typeof(string), new StringRenderer());
-            Template st = new Template(group, template);
+            Template st = new Template(template);
+            st.groupThatCreatedThisInstance = group;
st.Add("names", "ter");
st.Add("names", "tom");
st.Add("names", "sriram");
@@ -211,7 +212,8 @@ namespace AntlrUnitTests.ST4
"The names: <names; separator=\" and \", format=\"upper\">";
TemplateGroup group = new TemplateGroup();
group.RegisterRenderer(typeof(string), new StringRenderer());
-            Template st = new Template(group, template);
+            Template st = new Template(template);
+            st.groupThatCreatedThisInstance = group;
st.Add("names", "ter");
st.Add("names", "tom");
st.Add("names", "sriram");
@@ -227,7 +229,8 @@ namespace AntlrUnitTests.ST4
"The names: <names; separator=\" and \", null=\"n/a\", format=\"upper\">";
TemplateGroup group = new TemplateGroup();
group.RegisterRenderer(typeof(string), new StringRenderer());
-            Template st = new Template(group, template);
+            Template st = new Template(template);
+            st.groupThatCreatedThisInstance = group;
IList names = new ArrayList();
names.Add("ter");
names.Add(null);
diff --git a/Antlr3.Test/ST4/TestRuntimeErrors.cs b/Antlr3.Test/ST4/TestRuntimeErrors.cs
deleted file mode 100644
index e16b088..0000000
--- a/Antlr3.Test/ST4/TestRuntimeErrors.cs
+++ /dev/null
@@ -1,301 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace AntlrUnitTests.ST4
-{
-    using Microsoft.VisualStudio.TestTools.UnitTesting;
-    using ST = StringTemplate.Template;
-    using STErrorListener = StringTemplate.ITemplateErrorListener;
-    using STGroup = StringTemplate.TemplateGroup;
-    using STGroupDir = StringTemplate.TemplateGroupDirectory;
-    using STGroupFile = StringTemplate.TemplateGroupFile;
-    using String = System.String;
-    using Path = System.IO.Path;
-    using StringTemplate;
-
-    [TestClass]
-    public class TestRuntimeErrors : StringTemplateTestBase
-    {
-        public class UserHiddenName
-        {
-            private string name;
-
-            public UserHiddenName(string name)
-            {
-                this.name = name;
-            }
-
-            protected string Name
-            {
-                get
-                {
-                    return name;
-                }
-            }
-        }
-
-        public class UserHiddenNameField
-        {
-            private string name;
-
-            public UserHiddenNameField(string name)
-            {
-                this.name = name;
-            }
-        }
-
-        [TestMethod]
-        public void TestMissingEmbeddedTemplate()
-        {
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-
-            String templates =
-                "t() ::= \"<foo()>\"" + newline;
-
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ST st = group.GetInstanceOf("t");
-            st.Render();
-            String expected = "context [t] 1:0 no such template: foo" + newline;
-            String result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestMissingSuperTemplate()
-        {
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-
-            String templates =
-                "t() ::= \"<super.t()>\"" + newline;
-
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            String templates2 =
-                "u() ::= \"blech\"" + newline;
-
-            WriteFile(tmpdir, "t2.stg", templates2);
-            STGroup group2 = new STGroupFile(Path.Combine(tmpdir, "t2.stg"));
-            group.ImportTemplates(group2);
-            ST st = group.GetInstanceOf("t");
-            st.Render();
-            String expected = "context [t] 1:1 no such template: super.t" + newline;
-            String result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestNoPropertyNotError()
-        {
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-
-            String templates =
-                "t(u) ::= \"<u.x>\"" + newline;
-
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ST st = group.GetInstanceOf("t");
-            st.Add("u", new User(32, "parrt"));
-            st.Render();
-            String expected = "";
-            String result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestHiddenPropertyNotError()
-        {
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-
-            String templates =
-                "t(u) ::= \"<u.name>\"" + newline;
-
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ST st = group.GetInstanceOf("t");
-            st.Add("u", new UserHiddenName("parrt"));
-            st.Render();
-            String expected = "";
-            String result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestHiddenFieldNotError()
-        {
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-
-            String templates =
-                "t(u) ::= \"<u.name>\"" + newline;
-
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ST st = group.GetInstanceOf("t");
-            st.Add("u", new UserHiddenNameField("parrt"));
-            st.Render();
-            String expected = "";
-            String result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestSoleArg()
-        {
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-
-            string templates =
-                "t() ::= \"<u({9})>\"\n" +
-                "u(x,y) ::= \"<x>\"\n";
-
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ST st = group.GetInstanceOf("t");
-            st.Render();
-            string expected = "context [t] 1:3 expecting single arg in template reference u() (not 2 args)" + newline;
-            string result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestUndefinedArg()
-        {
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-
-            string templates =
-                "t() ::= \"<u()>\"\n" +
-                "u() ::= \"<x>\"\n";
-
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            group.Debug = true;
-            ST st = group.GetInstanceOf("t");
-            st.Render();
-            String expected = "context [t, u] 1:1 attribute x isn't defined" + newline;
-            String result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestUndefinedArgNoProblemInCompatibilityMode()
-        {
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-            ErrorManager.CompatibilityMode = true;
-
-            try
-            {
-                string templates =
-                    "t() ::= \"<u()>\"\n" +
-                    "u() ::= \"<x>\"\n";
-
-                WriteFile(tmpdir, "t.stg", templates);
-                STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
-                ST st = group.GetInstanceOf("t");
-                st.Render();
-                String expected = "";
-                String result = errors.ToString();
-                Assert.AreEqual(expected, result);
-            }
-            finally
-            {
-                ErrorManager.CompatibilityMode = false;
-            }
-        }
-
-        [TestMethod]
-        public void TestParallelAttributeIterationWithMismatchArgListSizes()
-        {
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-            Template e = new Template(
-                    "<names,phones,salaries:{n,p | <n>@<p>}; separator=\", \">"
-                );
-            e.Add("names", "Ter");
-            e.Add("names", "Tom");
-            e.Add("phones", "1");
-            e.Add("phones", "2");
-            e.Add("salaries", "big");
-            e.Render();
-            string errorExpecting = "context [anonymous] 1:1 iterating through 3 arguments but parallel map has 2 formal arguments" + newline;
-            Assert.AreEqual(errorExpecting, errors.ToString());
-            string expecting = "Ter@1, Tom@2";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestParallelAttributeIterationWithMissingArgs()
-        {
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-            Template e = new Template(
-                    "<names,phones,salaries:{<n>@<p>}; separator=\", \">"
-                );
-            e.Add("names", "Tom");
-            e.Add("phones", "2");
-            e.Add("salaries", "big");
-            e.Render(); // generate the error
-            string errorExpecting = "context [anonymous] 1:1 missing argument definitions" + newline;
-            Assert.AreEqual(errorExpecting, errors.ToString());
-        }
-
-        [TestMethod]
-        public void TestStringTypeMismatch()
-        {
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-            ST e = new ST("<trim(s)>");
-            e.Add("s", 34);
-            e.Render(); // generate the error
-            String errorExpecting = "context [anonymous] 1:1 function trim expects a string not System.Int32" + newline;
-            Assert.AreEqual(errorExpecting, errors.ToString());
-        }
-
-        [TestMethod]
-        public void TestStringTypeMismatch2()
-        {
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-            ST e = new ST("<strlen(s)>");
-            e.Add("s", 34);
-            e.Render(); // generate the error
-            String errorExpecting = "context [anonymous] 1:1 function strlen expects a string not System.Int32" + newline;
-            Assert.AreEqual(errorExpecting, errors.ToString());
-        }
-    }
-}
diff --git a/Antlr3.vsmdi b/Antlr3.vsmdi
index 829e5f9..153aadd 100644
--- a/Antlr3.vsmdi
+++ b/Antlr3.vsmdi
@@ -389,10 +389,11 @@
<TestLink id="26e2e0d1-fb3b-73ca-dba8-647efacf954a" name="TestTrueCondWithElse" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="e90ee746-3fa4-735a-77da-e354bf42d4d3" name="TestAnd" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="8a8893e8-9fb4-2c63-f22b-15d21ea6228c" name="TestElseIfNoElseAllFalse" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8f3aa7c8-1732-2084-4c1c-2bf4d57b9d58" name="TestSetUnknownAttr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="0a2b816e-1f0c-6dbe-3f06-831fa6b17792" name="TestAttrIsArray" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="12d223ea-db40-f1ea-3f8c-c7a683fed984" name="TestDefineTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="0038a163-7465-af4e-7fc8-8b89065aac81" name="TestFalseCondWithElse" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="4fb407b3-0764-f58a-055f-684342c289d7" name="TestInclude" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="eef4dbce-cb52-f4c0-ceff-00a7047ee3bb" name="TestRoundRobinMap" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="d15cf9f0-6a4e-499e-a489-5797893efe0d" name="TestFalseCond" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="dc00a846-0057-f22e-2d03-f69b1293af62" name="TestTrueCond" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="71a8fed5-11ff-82a7-c6aa-b70060fef1ab" name="TestIncludeWithSingleUnnamedArg" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
@@ -409,7 +410,7 @@
<TestLink id="3b9f0a90-6020-0ea4-6de3-3b3fcf2b8c47" name="TestIncludeWithNestedArgs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="325dd9bd-89a2-db20-de62-6cb3a7c602a3" name="TestElseIfAllExprFalse" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="185817fd-5818-8eee-5712-571bd9dada8d" name="TestParallelMap" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="eef4dbce-cb52-f4c0-ceff-00a7047ee3bb" name="TestRoundRobinMap" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4fb407b3-0764-f58a-055f-684342c289d7" name="TestInclude" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="e93abbf8-dd37-49c0-8bc8-430b78d4ab74" name="TestUnicodeLiterals" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="035d62d1-8c9e-2c14-bb45-b6e9f46036f6" name="TestNotTrueCond" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
</TestLinks>
@@ -763,20 +764,20 @@
<TestLink id="b25970d5-2ada-ab8b-956e-265a3695b54f" name="TestRefToTokenInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
</TestLinks>
</TestList>
-  <TestList name="Runtime Errors" id="85574747-5efc-491e-bbfb-7051dc2e7261" parentListId="4adbb104-d28d-4362-8420-a9fefe69c167">
+  <TestList name="Interptime Errors" id="85574747-5efc-491e-bbfb-7051dc2e7261" parentListId="4adbb104-d28d-4362-8420-a9fefe69c167">
<TestLinks>
-      <TestLink id="1933f795-d15c-aebb-1fc1-f6c851a512eb" name="TestParallelAttributeIterationWithMissingArgs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="199270e2-749c-b8ab-24b7-9c7b650dac1f" name="TestSoleArg" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="d321253b-e20d-2abb-d187-8a1187f2f10f" name="TestParallelAttributeIterationWithMismatchArgListSizes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="e4984e88-ca6b-8e47-fd5c-443cc9b96662" name="TestUndefinedArgNoProblemInCompatibilityMode" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="e04a252b-ed72-e5b2-a243-751d00c8beeb" name="TestMissingSuperTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="ed357d13-e7b2-12a8-d367-2b477f5d4da1" name="TestNoPropertyNotError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="b57929fb-5d73-8a82-7afe-c98de47b60e7" name="TestMissingEmbeddedTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="6a517b77-7ea2-da7e-e203-6e9340d38f04" name="TestHiddenPropertyNotError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="55baca98-ac28-2c1b-1f7e-d2151642cdeb" name="TestStringTypeMismatch" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="9b5bb87d-4f29-66ae-ce19-882685f19d56" name="TestStringTypeMismatch2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="b81f02f0-235c-f927-cba6-4f7ec7cc26c4" name="TestHiddenFieldNotError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="d848433a-1ca8-09bb-17f6-d6e60b9c1ebe" name="TestUndefinedArg" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0f4199bb-ac2f-44d2-06a6-2db2b49ee855" name="TestParallelAttributeIterationWithMissingArgs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="92ee7045-5199-7c37-32e5-98ac7bfe7540" name="TestStringTypeMismatch2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8abfaaf3-3ca5-944a-9200-25268558f952" name="TestHiddenFieldNotError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7b8810e3-0af7-a2e4-fdf0-b41b8ae635ac" name="TestParallelAttributeIterationWithMismatchArgListSizes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="384cd1ed-a801-929e-28e2-dd6664bf0ebd" name="TestHiddenPropertyNotError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1b10d453-ae23-af27-51f5-f3d59b2b98e2" name="TestMissingEmbeddedTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a64737d9-209c-c4fe-e2ab-0bd55b6a1f5d" name="TestUndefinedArg" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="aed1c1e7-29f4-3742-d9b0-a0d033c3345f" name="TestStringTypeMismatch" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8590099e-9776-bb69-d042-cd4ced293815" name="TestUndefinedArgNoProblemInCompatibilityMode" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1176685d-ebd0-44cc-00de-f74cd74f114c" name="TestNoPropertyNotError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="98e0aed8-8f07-e829-7703-9ee5bbc63c6e" name="TestMissingSuperTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="746147eb-c844-cb14-bb5c-a83226aebcf9" name="TestSoleArg" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
</TestLinks>
</TestList>
<TestList name="Interpreted lexing" id="8863002f-5b85-4a70-b1bf-bf68c57c9fee" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
diff --git a/StringTemplate4/BlankTemplate.cs b/StringTemplate4/BlankTemplate.cs
index d0448db..ff2dbd0 100644
--- a/StringTemplate4/BlankTemplate.cs
+++ b/StringTemplate4/BlankTemplate.cs
@@ -50,11 +50,11 @@ namespace StringTemplate
{
}

-        public string Name
+        public override TemplateName Name
{
get
{
-                return "blank";
+                return new TemplateName("blank");
}
}

diff --git a/StringTemplate4/Compiler/CompiledTemplate.cs b/StringTemplate4/Compiler/CompiledTemplate.cs
index 97301c5..df5b936 100644
--- a/StringTemplate4/Compiler/CompiledTemplate.cs
+++ b/StringTemplate4/Compiler/CompiledTemplate.cs
@@ -48,7 +48,7 @@ namespace StringTemplate.Compiler
public int embeddedStart = -1;
public int embeddedStop = -1;

-        protected internal IDictionary<string, FormalArgument> formalArguments;
+        protected internal IDictionary<string, FormalArgument> formalArguments = FormalArgument.Unknown;

protected internal List<CompiledTemplate> implicitlyDefinedTemplates;

diff --git a/StringTemplate4/Compiler/FormalArgument.cs b/StringTemplate4/Compiler/FormalArgument.cs
index beb9d30..9203816 100644
--- a/StringTemplate4/Compiler/FormalArgument.cs
+++ b/StringTemplate4/Compiler/FormalArgument.cs
@@ -33,10 +33,12 @@
namespace StringTemplate.Compiler
{
using Antlr.Runtime;
+    using System.Collections.Generic;

public class FormalArgument
{
// the following represent bit positions emulating a cardinality bitset.
+#if false
public static readonly int OPTIONAL = 1;     // a?
public static readonly int REQUIRED = 2;     // a
public static readonly int ZERO_OR_MORE = 4; // a*
@@ -53,9 +55,17 @@ namespace StringTemplate.Compiler
null,
"+"
};
+        //protected int cardinality = REQUIRED;
+#endif
+
+        /** When template arguments are not available such as when the user
+         *  uses "new ST(...)", then the list of formal arguments
+         *  must be distinguished from the case where a template can specify
+         *  args and there just aren't any such as the t() template above.
+         */
+        public static readonly IDictionary<string, FormalArgument> Unknown = new Dictionary<string, FormalArgument>();

public string name;
-        //protected int cardinality = REQUIRED;

/** If they specified name="value", store the template here */
public IToken defaultValueToken;
diff --git a/StringTemplate4/ErrorType.cs b/StringTemplate4/ErrorType.cs
index 3ef44d7..259d129 100644
--- a/StringTemplate4/ErrorType.cs
+++ b/StringTemplate4/ErrorType.cs
@@ -36,6 +36,7 @@ namespace StringTemplate
{
// RUNTIME SEMANTIC ERRORS
public static readonly ErrorType NoSuchTemplate = new ErrorType("no such template: {0}");
+        public static readonly ErrorType CantSetAttribute = new ErrorType("can't set attribute {0}; template {1} has no such attribute");
public static readonly ErrorType NoImportedTemplate = new ErrorType("no such template: super.{0}");
public static readonly ErrorType NO_ATTRIBUTE_DEFINITION = new ErrorType("attribute {0} isn't defined");
public static readonly ErrorType ExpectingSingleArgument = new ErrorType("expecting single arg in template reference {0} (not {1} args)");
diff --git a/StringTemplate4/Interpreter.cs b/StringTemplate4/Interpreter.cs
index cc587d9..963ec17 100644
--- a/StringTemplate4/Interpreter.cs
+++ b/StringTemplate4/Interpreter.cs
@@ -218,26 +218,14 @@ namespace StringTemplate
ip += 2;
o = operands[sp--];    // value to store
st = (Template)operands[sp]; // store arg in Template on top of stack
+                    st.CheckAttributeExists(name);
st.RawSetAttribute(name, o);
break;
case Bytecode.INSTR_STORE_SOLE_ARG:
// unnamed arg, set to sole arg (or first if multiple)
o = operands[sp--];    // value to store
st = (Template)operands[sp]; // store arg in Template on top of stack
-                    int nargs = 0;
-                    if (st.code.formalArguments != null)
-                    {
-                        nargs = st.code.formalArguments.Count;
-                    }
-                    if (nargs != 1)
-                    {
-                        ErrorManager.RuntimeError(self, current_ip, ErrorType.ExpectingSingleArgument, st, nargs);
-                    }
-                    else
-                    {
-                        name = st.code.formalArguments.Keys.First();
-                        st.RawSetAttribute(name, o);
-                    }
+                    SetSoleArgument(self, st, o);
break;
case Bytecode.INSTR_SET_PASS_THRU:
st = (Template)operands[sp]; // Template on top of stack
@@ -605,7 +593,7 @@ namespace StringTemplate
ti++;
TemplateName name = templates[templateIndex];
Template st = group.GetEmbeddedInstanceOf(self, current_ip, name);
-                    SetSoleArgument(st, iterValue);
+                    SetSoleArgument(self, st, iterValue);
st.RawSetAttribute("i0", i0);
st.RawSetAttribute("i", i);
mapped.Add(st);
@@ -620,7 +608,7 @@ namespace StringTemplate
Template st = group.GetInstanceOf(templates[0]);
if (st != null)
{
-                    SetSoleArgument(st, attr);
+                    SetSoleArgument(self, st, attr);
st.RawSetAttribute("i0", 0);
st.RawSetAttribute("i", 1);
operands[++sp] = st;
@@ -691,6 +679,7 @@ namespace StringTemplate
{
string argName = (string)formalArgumentNames[a];
object iteratedValue = it.Current;
+                            embedded.CheckAttributeExists(argName);
embedded.RawSetAttribute(argName, iteratedValue);
}
else
@@ -707,17 +696,24 @@ namespace StringTemplate
}
}

-        protected void SetSoleArgument(Template st, object attr)
+        protected void SetSoleArgument(Template self, Template st, object attr)
{
+            string name = "it";
+            int nargs = 0;
if (st.code.formalArguments != null)
{
-                string arg = st.code.formalArguments.Keys.First();
-                st.RawSetAttribute(arg, attr);
+                nargs = st.code.formalArguments.Count;
}
-            else
+
+            if (nargs > 0)
{
-                st.RawSetAttribute("it", attr);
+                if (nargs != 1)
+                    ErrorManager.RuntimeError(self, current_ip, ErrorType.ExpectingSingleArgument, st, nargs);
+
+                name = st.code.formalArguments.Keys.First();
}
+
+            st.RawSetAttribute(name, attr);
}

protected void AddToList(List<object> list, object o)
@@ -1167,11 +1163,11 @@ namespace StringTemplate
*  the formal parameters up the enclosing chain to see if it exists;
*  if it exists all is well, but if not, record an error.
*
-         *  Don't do the check unless debugging and only if not tombu mode.
+         *  Don't generate error if template has no formal arguments.
*/
protected void CheckNullAttributeAgainstFormalArguments(Template self, string name)
{
-            if (!group.Debug || ErrorManager.CompatibilityMode)
+            if (self.code.formalArguments == FormalArgument.Unknown)
return; // ignore unknown args in tombu mode

Template p = self;
diff --git a/StringTemplate4/Template.cs b/StringTemplate4/Template.cs
index 79a09f7..ec90128 100644
--- a/StringTemplate4/Template.cs
+++ b/StringTemplate4/Template.cs
@@ -98,15 +98,22 @@ namespace StringTemplate
}

public Template(string template)
-            : this(TemplateGroup.defaultGroup, template)
+            //: this(TemplateGroup.defaultGroup, template)
{
+            //code = TemplateGroup.defaultGroup.DefineTemplate(UnknownName, template);
+            groupThatCreatedThisInstance = TemplateGroup.defaultGroup;
+            code = groupThatCreatedThisInstance.Compile(TemplateName.Root, null, template);
+            code.Name = UnknownName;
+            groupThatCreatedThisInstance.DefineImplicitlyDefinedTemplates(code);
}

+#if false
public Template(TemplateGroup nativeGroup, string template)
{
code = nativeGroup.DefineTemplate(UnknownName, template);
groupThatCreatedThisInstance = nativeGroup;
}
+#endif

public IDictionary<string, object> Attributes
{
@@ -141,7 +148,7 @@ namespace StringTemplate
}
}

-        public TemplateName Name
+        public virtual TemplateName Name
{
get
{
@@ -164,7 +171,9 @@ namespace StringTemplate

object curvalue = null;
if (attributes == null || !attributes.ContainsKey(name))
-            { // new attribute
+            {
+                // new attribute
+                CheckAttributeExists(name);
RawSetAttribute(name, value);
return;
}
@@ -201,6 +210,15 @@ namespace StringTemplate
attributes[name] = value;
}

+        protected internal void CheckAttributeExists(string name)
+        {
+            if (code.formalArguments == FormalArgument.Unknown)
+                return;
+
+            if (code.formalArguments == null || !code.formalArguments.ContainsKey(name))
+                ErrorManager.RuntimeError(this, -1, ErrorType.CantSetAttribute, name, Name);
+        }
+
/** Find an attr with dynamic scoping up enclosing ST chain.
*  If not found, look for a map.  So attributes sent in to a template
*  override dictionary names.
@@ -289,7 +307,7 @@ namespace StringTemplate
foreach (var st in templates)
{
if (i > 0)
-                    builder.Append(", ");
+                    builder.Append(" ");

builder.Append(st.Name);
i++;
diff --git a/StringTemplate4/TemplateGroup.cs b/StringTemplate4/TemplateGroup.cs
index 072e086..4f6fea8 100644
--- a/StringTemplate4/TemplateGroup.cs
+++ b/StringTemplate4/TemplateGroup.cs
@@ -212,17 +212,17 @@ namespace StringTemplate
// TODO: send in start/stop char or line/col so errors can be relative
public CompiledTemplate DefineTemplate(TemplateName name, string template)
{
-            return DefineTemplate(TemplateName.Root, name, null, template);
+            return DefineTemplate(TemplateName.Root, name, FormalArgument.Unknown, template);
}

public virtual CompiledTemplate DefineTemplate(TemplateName name,
List<string> args,
string template)
{
-            IDictionary<string, FormalArgument> margs =
-                new Dictionary<string, FormalArgument>();
-            foreach (string a in args)
-                margs[a] = new FormalArgument(a);
+            IDictionary<string, FormalArgument> margs = null;
+            if (args != null)
+                margs = args.ToDictionary(arg => arg, arg => new FormalArgument(arg));
+
return DefineTemplate(TemplateName.Root, name, margs, template);
}

@@ -230,10 +230,10 @@ namespace StringTemplate
string[] args,
string template)
{
-            IDictionary<string, FormalArgument> margs =
-                new Dictionary<string, FormalArgument>();
-            foreach (string a in args)
-                margs[a] = new FormalArgument(a);
+            IDictionary<string, FormalArgument> margs = null;
+            if (args != null)
+                margs = args.ToDictionary(arg => arg, arg => new FormalArgument(arg));
+
return DefineTemplate(TemplateName.Root, name, margs, template);
}

@@ -281,7 +281,7 @@ namespace StringTemplate
return code;
}

-        protected void DefineImplicitlyDefinedTemplates(CompiledTemplate code)
+        protected internal void DefineImplicitlyDefinedTemplates(CompiledTemplate code)
{
if (code.implicitlyDefinedTemplates != null)
{
@@ -317,7 +317,7 @@ namespace StringTemplate
templates[name] = code;
}

-        protected CompiledTemplate Compile(TemplateName prefix, TemplateName enclosingTemplateName, string template)
+        protected internal CompiledTemplate Compile(TemplateName prefix, TemplateName enclosingTemplateName, string template)
{
TemplateCompiler c = new TemplateCompiler(prefix, enclosingTemplateName);
CompiledTemplate code = c.Compile(template);
diff --git a/StringTemplate4/TemplateRuntimeMessage.cs b/StringTemplate4/TemplateRuntimeMessage.cs
index 5308e41..b3ce3fd 100644
--- a/StringTemplate4/TemplateRuntimeMessage.cs
+++ b/StringTemplate4/TemplateRuntimeMessage.cs
@@ -39,7 +39,7 @@ namespace StringTemplate
public class TemplateRuntimeMessage : TemplateMessage
{
/** Where error occurred in bytecode memory */
-        private int ip;
+        private int ip = -1;

public TemplateRuntimeMessage(ErrorType error, int ip)
: this(error, ip, null)
@@ -72,6 +72,9 @@ namespace StringTemplate
*/
public string GetSourceLocation()
{
+            if (ip < 0)
+                return string.Empty;
+
Interval I = Template.code.sourceMap[ip];
if (I == null)
return null;

