commit f94ce8057adeadb9eaeca602bdf8efc36708c545
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Fri Jan 21 08:09:38 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Fri Jan 21 08:09:38 2011 -0800

(C# 3) Re-ported StringTemplate 4 to C# now that the code is in beta (initial conversion, many bugs remain)

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 7485]

diff --git a/Antlr3.sln b/Antlr3.sln
index f71a713..405cc96 100644
--- a/Antlr3.sln
+++ b/Antlr3.sln
@@ -64,22 +64,26 @@ Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Antlr3.Runtime.Test", "..\.
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AntlrBuildTask", "AntlrBuildTask\AntlrBuildTask.csproj", "{60F8B554-5C53-4DE2-B868-A0BFEF4EF80E}"
EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Antlr4.StringTemplate", "Antlr4.StringTemplate\Antlr4.StringTemplate.csproj", "{DE9B7DA2-35DD-46CC-B768-DAEE3C298660}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Antlr4.Test.StringTemplate", "Antlr4.Test.StringTemplate\Antlr4.Test.StringTemplate.csproj", "{1B70CBF4-B592-4A9C-B7B3-AD1A087F4B9C}"
+EndProject
Global
GlobalSection(TestCaseManagementSettings) = postSolution
CategoryFile = Antlr3.vsmdi
EndGlobalSection
GlobalSection(SourceCodeControl) = preSolution
-		SccNumberOfProjects = 21
-		SccProjectUniqueName0 = Antlr3\\Antlr3.csproj
+		SccNumberOfProjects = 23
+		SccProjectName0 = Perforce\u0020Project
SccLocalPath0 = ..\\..
-		SccProjectFilePathRelativizedFromConnection0 = antlrcs\\main\\Antlr3\\
-		SccProjectUniqueName1 = AntlrBuildTask\\AntlrBuildTask.csproj
+		SccProvider0 = MSSCCI:Perforce\u0020SCM
+		SccProjectFilePathRelativizedFromConnection0 = antlrcs\\main\\
+		SccProjectUniqueName1 = Antlr3\\Antlr3.csproj
SccLocalPath1 = ..\\..
-		SccProjectFilePathRelativizedFromConnection1 = antlrcs\\main\\AntlrBuildTask\\
-		SccProjectName2 = Perforce\u0020Project
+		SccProjectFilePathRelativizedFromConnection1 = antlrcs\\main\\Antlr3\\
+		SccProjectUniqueName2 = AntlrBuildTask\\AntlrBuildTask.csproj
SccLocalPath2 = ..\\..
-		SccProvider2 = MSSCCI:Perforce\u0020SCM
-		SccProjectFilePathRelativizedFromConnection2 = antlrcs\\main\\
+		SccProjectFilePathRelativizedFromConnection2 = antlrcs\\main\\AntlrBuildTask\\
SccProjectUniqueName3 = Antlr3.StringTemplate\\Antlr3.StringTemplate.csproj
SccLocalPath3 = ..\\..
SccProjectFilePathRelativizedFromConnection3 = antlrcs\\main\\Antlr3.StringTemplate\\
@@ -146,6 +150,12 @@ Global
SccProjectUniqueName20 = ..\\..\\antlr\\main\\runtime\\CSharp3\\Sources\\Antlr3.Runtime.Test\\Antlr3.Runtime.Test.csproj
SccLocalPath20 = ..\\..
SccProjectFilePathRelativizedFromConnection20 = antlr\\main\\runtime\\CSharp3\\Sources\\Antlr3.Runtime.Test\\
+		SccProjectUniqueName21 = Antlr4.StringTemplate\\Antlr4.StringTemplate.csproj
+		SccLocalPath21 = ..\\..
+		SccProjectFilePathRelativizedFromConnection21 = antlrcs\\main\\Antlr4.StringTemplate\\
+		SccProjectUniqueName22 = Antlr4.Test.StringTemplate\\Antlr4.Test.StringTemplate.csproj
+		SccLocalPath22 = ..\\..
+		SccProjectFilePathRelativizedFromConnection22 = antlrcs\\main\\Antlr4.Test.StringTemplate\\
EndGlobalSection
GlobalSection(SolutionConfigurationPlatforms) = preSolution
Debug|Any CPU = Debug|Any CPU
@@ -231,6 +241,14 @@ Global
{60F8B554-5C53-4DE2-B868-A0BFEF4EF80E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
{60F8B554-5C53-4DE2-B868-A0BFEF4EF80E}.Release|Any CPU.ActiveCfg = Release|Any CPU
{60F8B554-5C53-4DE2-B868-A0BFEF4EF80E}.Release|Any CPU.Build.0 = Release|Any CPU
+		{DE9B7DA2-35DD-46CC-B768-DAEE3C298660}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{DE9B7DA2-35DD-46CC-B768-DAEE3C298660}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{DE9B7DA2-35DD-46CC-B768-DAEE3C298660}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{DE9B7DA2-35DD-46CC-B768-DAEE3C298660}.Release|Any CPU.Build.0 = Release|Any CPU
+		{1B70CBF4-B592-4A9C-B7B3-AD1A087F4B9C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{1B70CBF4-B592-4A9C-B7B3-AD1A087F4B9C}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{1B70CBF4-B592-4A9C-B7B3-AD1A087F4B9C}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{1B70CBF4-B592-4A9C-B7B3-AD1A087F4B9C}.Release|Any CPU.Build.0 = Release|Any CPU
EndGlobalSection
GlobalSection(SolutionProperties) = preSolution
HideSolutionNode = FALSE
diff --git a/Antlr4.StringTemplate/Antlr4.StringTemplate.csproj b/Antlr4.StringTemplate/Antlr4.StringTemplate.csproj
new file mode 100644
index 0000000..df3da1f
--- /dev/null
+++ b/Antlr4.StringTemplate/Antlr4.StringTemplate.csproj
@@ -0,0 +1,156 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>8.0.30703</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{DE9B7DA2-35DD-46CC-B768-DAEE3C298660}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>Antlr4.StringTemplate</RootNamespace>
+    <AssemblyName>Antlr4.StringTemplate</AssemblyName>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <SccProjectName>SAK</SccProjectName>
+    <SccLocalPath>SAK</SccLocalPath>
+    <SccAuxPath>SAK</SccAuxPath>
+    <SccProvider>SAK</SccProvider>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>bin\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>bin\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core" />
+    <Reference Include="System.Xml.Linq" />
+    <Reference Include="System.Data.DataSetExtensions" />
+    <Reference Include="System.Data" />
+    <Reference Include="System.Xml" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="IAttributeRenderer.cs" />
+    <Compile Include="AutoIndentWriter.cs" />
+    <None Include="..\Antlr3\Key.snk">
+      <Link>Key.snk</Link>
+    </None>
+    <None Include="DateRenderer.cs" />
+    <Compile Include="Misc\TypeRegistry`1.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="Compiler\Bytecode.cs" />
+    <Compile Include="Compiler\BytecodeDisassembler.cs" />
+    <Compile Include="Compiler\CompilationState.cs" />
+    <Compile Include="Compiler\CompiledTemplate.cs" />
+    <Compile Include="Compiler\TemplateCompiler.cs" />
+    <Compile Include="Compiler\FormalArgument.cs" />
+    <Compile Include="Compiler\TemplateException.cs" />
+    <Compile Include="Compiler\TemplateLexer.cs" />
+    <Compile Include="Compiler\StringTable.cs" />
+    <Compile Include="Compiler\TestNewStuff.cs" />
+    <Compile Include="Debug\AddAttributeEvent.cs" />
+    <Compile Include="Debug\ConstructionEvent.cs" />
+    <Compile Include="Debug\DebugTemplate.cs" />
+    <Compile Include="Debug\EvalExprEvent.cs" />
+    <Compile Include="Debug\EvalTemplateEvent.cs" />
+    <Compile Include="Debug\InterpEvent.cs" />
+    <Compile Include="Interpreter.cs" />
+    <Compile Include="Misc\Coordinate.cs" />
+    <Compile Include="Misc\ErrorBuffer.cs" />
+    <Compile Include="Misc\ErrorManager.cs" />
+    <Compile Include="Misc\ErrorType.cs" />
+    <Compile Include="Misc\Interval.cs" />
+    <Compile Include="Misc\MapModelAdaptor.cs" />
+    <Compile Include="Misc\Utility.cs" />
+    <Compile Include="Misc\MultiMap.cs" />
+    <Compile Include="Misc\ObjectModelAdaptor.cs" />
+    <Compile Include="Misc\TemplateCompileTimeMessage.cs" />
+    <Compile Include="Misc\TemplateDump.cs" />
+    <Compile Include="Misc\TemplateGroupCompiletimeMessage.cs" />
+    <Compile Include="Misc\TemplateLexerMessage.cs" />
+    <Compile Include="Misc\TemplateMessage.cs" />
+    <Compile Include="Misc\TemplateModelAdaptor.cs" />
+    <Compile Include="Misc\TemplateNoSuchPropertyException.cs" />
+    <Compile Include="Misc\TemplateRuntimeMessage.cs" />
+    <Compile Include="IModelAdaptor.cs" />
+    <Compile Include="NoIndentWriter.cs" />
+    <None Include="NumberRenderer.cs" />
+    <Compile Include="Template.cs" />
+    <Compile Include="ITemplateErrorListener.cs" />
+    <Compile Include="TemplateGroup.cs" />
+    <Compile Include="TemplateGroupDirectory.cs" />
+    <Compile Include="TemplateGroupFile.cs" />
+    <Compile Include="StringRenderer.cs" />
+    <Compile Include="ITemplateWriter.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <Antlr3 Include="Compiler\CodeGenerator.g3">
+      <Generator>MSBuild:Compile</Generator>
+    </Antlr3>
+    <Compile Include="Compiler\CodeGenerator.g3.cs">
+      <DependentUpon>CodeGenerator.g3</DependentUpon>
+    </Compile>
+    <Antlr3 Include="Compiler\Group.g3">
+      <Generator>MSBuild:Compile</Generator>
+    </Antlr3>
+    <Compile Include="Compiler\Group.g3.parser.cs">
+      <DependentUpon>Group.g3</DependentUpon>
+    </Compile>
+    <Compile Include="Compiler\Group.g3.lexer.cs">
+      <DependentUpon>Group.g3</DependentUpon>
+    </Compile>
+    <AntlrTokens Include="Compiler\TemplateLexer.tokens" />
+    <Antlr3 Include="Compiler\TemplateParser.g3">
+      <Generator>MSBuild:Compile</Generator>
+    </Antlr3>
+    <Compile Include="Compiler\TemplateParser.g3.cs">
+      <DependentUpon>TemplateParser.g3</DependentUpon>
+    </Compile>
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\..\antlr\main\runtime\CSharp3\Sources\Antlr3.Runtime.Debug\Antlr3.Runtime.Debug.csproj">
+      <Project>{5EE27A90-B023-42C9-AAF1-52B0424C5D0B}</Project>
+      <Name>Antlr3.Runtime.Debug</Name>
+    </ProjectReference>
+    <ProjectReference Include="..\..\..\antlr\main\runtime\CSharp3\Sources\Antlr3.Runtime\Antlr3.Runtime.csproj">
+      <Project>{8FDC0A87-9005-4D5A-AB75-E55CEB575559}</Project>
+      <Name>Antlr3.Runtime</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <PropertyGroup>
+    <!-- Folder containing AntlrBuildTask.dll -->
+    <AntlrBuildTaskPath>$(SolutionDir)bin\Bootstrap</AntlrBuildTaskPath>
+    <!-- Path to the ANTLR Tool itself. -->
+    <AntlrToolPath>$(SolutionDir)bin\Bootstrap\Antlr3.exe</AntlrToolPath>
+  </PropertyGroup>
+  <PropertyGroup>
+    <SignAssembly>true</SignAssembly>
+  </PropertyGroup>
+  <PropertyGroup>
+    <AssemblyOriginatorKeyFile>..\Antlr3\Key.snk</AssemblyOriginatorKeyFile>
+  </PropertyGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <Import Project="$(ProjectDir)..\bin\Bootstrap\Antlr3.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
\ No newline at end of file
diff --git a/Antlr4.StringTemplate/Antlr4.StringTemplate.csproj.vspscc b/Antlr4.StringTemplate/Antlr4.StringTemplate.csproj.vspscc
new file mode 100644
index 0000000..093668c
--- /dev/null
+++ b/Antlr4.StringTemplate/Antlr4.StringTemplate.csproj.vspscc
@@ -0,0 +1,10 @@
+﻿""
+{
+"FILE_VERSION" = "9237"
+"ENLISTMENT_CHOICE" = "NEVER"
+"PROJECT_FILE_RELATIVE_PATH" = "relative:antlrcs\\main\\Antlr4.StringTemplate"
+"NUMBER_OF_EXCLUDED_FILES" = "0"
+"ORIGINAL_PROJECT_FILE_PATH" = ""
+"NUMBER_OF_NESTED_PROJECTS" = "0"
+"SOURCE_CONTROL_SETTINGS_PROVIDER" = "PROVIDER"
+}
diff --git a/Antlr4.StringTemplate/AutoIndentWriter.cs b/Antlr4.StringTemplate/AutoIndentWriter.cs
new file mode 100644
index 0000000..72ac292
--- /dev/null
+++ b/Antlr4.StringTemplate/AutoIndentWriter.cs
@@ -0,0 +1,256 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate
+{
+    using Environment = System.Environment;
+    using Array = System.Array;
+    using System.Collections.Generic;
+    using TextWriter = System.IO.TextWriter;
+
+    /** Essentially a char filter that knows how to auto-indent output
+     *  by maintaining a stack of indent levels.
+     *
+     *  The indent stack is a stack of strings so we can repeat original indent
+     *  not just the same number of columns (don't have to worry about tabs vs
+     *  spaces then).
+     *
+     *  Anchors are char positions (tabs won't work) that indicate where all
+     *  future wraps should justify to.  The wrap position is actually the
+     *  larger of either the last anchor or the indentation level.
+     *
+     *  This is a filter on a Writer.
+     *
+     *  \n is the proper way to say newline for options and templates.
+     *  Templates can mix \r\n and \n them but use \n for sure in options like
+     *  wrap="\n". ST will generate the right thing. Override the default (locale)
+     *  newline by passing in a string to the constructor.
+     */
+    public class AutoIndentWriter : STWriter
+    {
+        public const int NO_WRAP = -1;
+
+        /** stack of indents; use List as it's much faster than Stack. Grows
+         *  from 0..n-1.
+         */
+        protected readonly Stack<string> indents = new Stack<string>();
+
+        /** Stack of integer anchors (char positions in line); avoid Integer
+         *  creation overhead.
+         */
+        protected int[] anchors = new int[10];
+        protected int anchors_sp = -1;
+
+        /** \n or \r\n? */
+        protected string newline;
+
+        protected TextWriter @out = null;
+        protected bool atStartOfLine = true;
+
+        /** Track char position in the line (later we can think about tabs).
+         *  Indexed from 0.  We want to keep charPosition <= lineWidth.
+         *  This is the position we are *about* to write not the position
+         *  last written to.
+         */
+        protected int charPosition = 0;
+
+        /** The absolute char index into the output of the next char to be written. */
+        protected int charIndex = 0;
+
+        protected int lineWidth = NO_WRAP;
+
+        public AutoIndentWriter(TextWriter @out, string newline)
+        {
+            this.@out = @out;
+            indents.Push(null); // s oftart with no indent
+            this.newline = newline;
+        }
+
+        public AutoIndentWriter(TextWriter @out)
+            : this(@out, Environment.NewLine)
+        {
+        }
+
+        public virtual void setLineWidth(int lineWidth)
+        {
+            this.lineWidth = lineWidth;
+        }
+
+        public virtual void pushIndentation(string indent)
+        {
+            indents.Push(indent);
+        }
+
+        public virtual string popIndentation()
+        {
+            return indents.Pop();
+        }
+
+        public virtual void pushAnchorPoint()
+        {
+            if ((anchors_sp + 1) >= anchors.Length)
+            {
+                int[] a = new int[anchors.Length * 2];
+                Array.Copy(anchors, 0, a, 0, anchors.Length - 1);
+                anchors = a;
+            }
+            anchors_sp++;
+            anchors[anchors_sp] = charPosition;
+        }
+
+        public virtual void popAnchorPoint()
+        {
+            anchors_sp--;
+        }
+
+        public virtual int index()
+        {
+            return charIndex;
+        }
+
+        /** Write out a string literal or attribute expression or expression element.*/
+        public virtual int write(string str)
+        {
+            int n = 0;
+            for (int i = 0; i < str.Length; i++)
+            {
+                char c = str[i];
+                // found \n or \r\n newline?
+                if (c == '\r')
+                    continue;
+                if (c == '\n')
+                {
+                    atStartOfLine = true;
+                    charPosition = -1; // set so the write below sets to 0
+                    @out.Write(newline);
+                    n += newline.Length;
+                    charIndex += newline.Length;
+                    charPosition += n; // wrote n more char
+                    continue;
+                }
+                // normal character
+                // check to see if we are at the start of a line; need indent if so
+                if (atStartOfLine)
+                {
+                    n += indent();
+                    atStartOfLine = false;
+                }
+                n++;
+                @out.Write(c);
+                charPosition++;
+                charIndex++;
+            }
+            return n;
+        }
+
+        public virtual int writeSeparator(string str)
+        {
+            return write(str);
+        }
+
+        /** Write out a string literal or attribute expression or expression element.
+         *
+         *  If doing line wrap, then check wrap before emitting this str.  If
+         *  at or beyond desired line width then emit a \n and any indentation
+         *  before spitting out this str.
+         */
+        public virtual int write(string str, string wrap)
+        {
+            int n = writeWrap(wrap);
+            return n + write(str);
+        }
+
+        public virtual int writeWrap(string wrap)
+        {
+            int n = 0;
+            // if want wrap and not already at start of line (last char was \n)
+            // and we have hit or exceeded the threshold
+            if (lineWidth != NO_WRAP && wrap != null && !atStartOfLine &&
+                 charPosition >= lineWidth)
+            {
+                // ok to wrap
+                // Walk wrap string and look for A\nB.  Spit out A\n
+                // then spit indent or anchor, whichever is larger
+                // then spit out B.
+                for (int i = 0; i < wrap.Length; i++)
+                {
+                    char c = wrap[i];
+                    if (c == '\n')
+                    {
+                        @out.Write(newline);
+                        n += newline.Length;
+                        charPosition = 0;
+                        charIndex += newline.Length;
+                        n += indent();
+                        // continue writing any chars out
+                    }
+                    else
+                    {  // write A or B part
+                        n++;
+                        @out.Write(c);
+                        charPosition++;
+                        charIndex++;
+                    }
+                }
+            }
+            return n;
+        }
+
+        public virtual int indent()
+        {
+            int n = 0;
+            foreach (string ind in indents)
+            {
+                if (ind != null)
+                {
+                    n += ind.Length;
+                    @out.Write(ind);
+                }
+            }
+
+            // If current anchor is beyond current indent width, indent to anchor
+            // *after* doing indents (might tabs in there or whatever)
+            int indentWidth = n;
+            if (anchors_sp >= 0 && anchors[anchors_sp] > indentWidth)
+            {
+                int remainder = anchors[anchors_sp] - indentWidth;
+                for (int i = 1; i <= remainder; i++)
+                    @out.Write(' ');
+                n += remainder;
+            }
+
+            charPosition += n;
+            charIndex += n;
+            return n;
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Compiler/Bytecode.cs b/Antlr4.StringTemplate/Compiler/Bytecode.cs
new file mode 100644
index 0000000..d652b7b
--- /dev/null
+++ b/Antlr4.StringTemplate/Compiler/Bytecode.cs
@@ -0,0 +1,176 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Compiler
+{
+    public class Bytecode
+    {
+        public const int MAX_OPNDS = 2;
+        public const int OPND_SIZE_IN_BYTES = 2;
+
+        public enum OperandType
+        {
+            NONE,
+            STRING,
+            ADDR,
+            INT
+        }
+
+        public class Instruction
+        {
+            internal readonly string name; // E.g., "load_str", "new"
+            internal readonly OperandType[] type = new OperandType[MAX_OPNDS];
+            internal readonly int nopnds = 0;
+
+            public Instruction(string name)
+                : this(name, OperandType.NONE, OperandType.NONE)
+            {
+                nopnds = 0;
+            }
+
+            public Instruction(string name, OperandType a)
+                : this(name, a, OperandType.NONE)
+            {
+                nopnds = 1;
+            }
+
+            public Instruction(string name, OperandType a, OperandType b)
+            {
+                this.name = name;
+                type[0] = a;
+                type[1] = b;
+                nopnds = MAX_OPNDS;
+            }
+        }
+
+        // don't use enum for efficiency; don't want CompiledST.instrs to
+        // be an array of objects (Bytecode[]). We want it to be byte[].
+
+        // INSTRUCTION BYTECODES (byte is signed; use a short to keep 0..255)
+        public const short INSTR_LOAD_STR = 1;
+        public const short INSTR_LOAD_ATTR = 2;
+        public const short INSTR_LOAD_LOCAL = 3; // load stuff like it, i, i0
+        public const short INSTR_LOAD_PROP = 4;
+        public const short INSTR_LOAD_PROP_IND = 5;
+        public const short INSTR_STORE_OPTION = 6;
+        public const short INSTR_STORE_ARG = 7;
+        public const short INSTR_NEW = 8;  // create new template instance
+        public const short INSTR_NEW_IND = 9;  // create new instance using value on stack
+        public const short INSTR_NEW_BOX_ARGS = 10; // create new instance using args in Map on stack
+        public const short INSTR_SUPER_NEW = 11;  // create new instance using value on stack
+        public const short INSTR_SUPER_NEW_BOX_ARGS = 12; // create new instance using args in Map on stack
+        public const short INSTR_WRITE = 13;
+        public const short INSTR_WRITE_OPT = 14;
+        public const short INSTR_MAP = 15;  // <a:b()>, <a:b():c()>, <a:{...}>
+        public const short INSTR_ROT_MAP = 16;  // <a:b(),c()>
+        public const short INSTR_ZIP_MAP = 17;  // <names,phones:{n,p | ...}>
+        public const short INSTR_BR = 18;
+        public const short INSTR_BRF = 19;
+        public const short INSTR_OPTIONS = 20;  // push options map
+        public const short INSTR_ARGS = 21;  // push args map
+        public const short INSTR_LIST = 22;
+        public const short INSTR_ADD = 23;
+        public const short INSTR_TOSTR = 24;
+
+        // Predefined functions
+        public const short INSTR_FIRST = 25;
+        public const short INSTR_LAST = 26;
+        public const short INSTR_REST = 27;
+        public const short INSTR_TRUNC = 28;
+        public const short INSTR_STRIP = 29;
+        public const short INSTR_TRIM = 30;
+        public const short INSTR_LENGTH = 31;
+        public const short INSTR_STRLEN = 32;
+        public const short INSTR_REVERSE = 33;
+
+        public const short INSTR_NOT = 34;
+        public const short INSTR_OR = 35;
+        public const short INSTR_AND = 36;
+
+        public const short INSTR_INDENT = 37;
+        public const short INSTR_DEDENT = 38;
+        public const short INSTR_NEWLINE = 39;
+
+        public const short INSTR_NOOP = 40; // do nothing
+        public const short INSTR_POP = 41;
+        public const short INSTR_NULL = 42; // push null value
+
+        /** Used for assembly/disassembly; describes instruction set */
+        public static Instruction[] instructions =
+            new Instruction[]
+            {
+                null, // <INVALID>
+                new Instruction("load_str",OperandType.STRING), // index is the opcode
+                new Instruction("load_attr",OperandType.STRING),
+                new Instruction("load_local",OperandType.INT),
+                new Instruction("load_prop",OperandType.STRING),
+                new Instruction("load_prop_ind"),
+                new Instruction("store_option",OperandType.INT),
+                new Instruction("store_arg",OperandType.STRING),
+                new Instruction("new",OperandType.STRING,OperandType.INT),
+                new Instruction("new_ind",OperandType.INT),
+                new Instruction("new_box_args",OperandType.STRING),
+                new Instruction("super_new",OperandType.STRING,OperandType.INT),
+                new Instruction("super_new_box_args",OperandType.STRING),
+                new Instruction("write"),
+                new Instruction("write_opt"),
+                new Instruction("map"),
+                new Instruction("rot_map", OperandType.INT),
+                new Instruction("zip_map", OperandType.INT),
+                new Instruction("br", OperandType.ADDR),
+                new Instruction("brf", OperandType.ADDR),
+                new Instruction("options"),
+                new Instruction("args"),
+                new Instruction("list"),
+                new Instruction("add"),
+                new Instruction("tostr"),
+                new Instruction("first"),
+                new Instruction("last"),
+                new Instruction("rest"),
+                new Instruction("trunc"),
+                new Instruction("strip"),
+                new Instruction("trim"),
+                new Instruction("length"),
+                new Instruction("strlen"),
+                new Instruction("reverse"),
+                new Instruction("not"),
+                new Instruction("or"),
+                new Instruction("and"),
+                new Instruction("indent", OperandType.STRING),
+                new Instruction("dedent"),
+                new Instruction("newline"),
+                new Instruction("noop"),
+                new Instruction("pop"),
+                new Instruction("null")
+            };
+    }
+}
diff --git a/Antlr4.StringTemplate/Compiler/BytecodeDisassembler.cs b/Antlr4.StringTemplate/Compiler/BytecodeDisassembler.cs
new file mode 100644
index 0000000..becc68a
--- /dev/null
+++ b/Antlr4.StringTemplate/Compiler/BytecodeDisassembler.cs
@@ -0,0 +1,212 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Compiler
+{
+    using System.Collections.Generic;
+    using StringBuilder = System.Text.StringBuilder;
+    using Antlr4.StringTemplate.Misc;
+    using ArgumentException = System.ArgumentException;
+
+    public class BytecodeDisassembler
+    {
+        private readonly CompiledST code;
+
+        public BytecodeDisassembler(CompiledST code)
+        {
+            this.code = code;
+        }
+
+        public virtual string instrs()
+        {
+            StringBuilder buf = new StringBuilder();
+            int ip = 0;
+            while (ip < code.codeSize)
+            {
+                if (ip > 0)
+                    buf.Append(", ");
+                int opcode = code.instrs[ip];
+                Bytecode.Instruction I = Bytecode.instructions[opcode];
+                buf.Append(I.name);
+                ip++;
+                for (int opnd = 0; opnd < I.nopnds; opnd++)
+                {
+                    buf.Append(' ');
+                    buf.Append(getShort(code.instrs, ip));
+                    ip += Bytecode.OPND_SIZE_IN_BYTES;
+                }
+            }
+            return buf.ToString();
+        }
+
+        public virtual string disassemble()
+        {
+            StringBuilder buf = new StringBuilder();
+            int i = 0;
+            while (i < code.codeSize)
+            {
+                i = disassembleInstruction(buf, i);
+                buf.AppendLine();
+            }
+            return buf.ToString();
+        }
+
+        public virtual int disassembleInstruction(StringBuilder buf, int ip)
+        {
+            int opcode = code.instrs[ip];
+            if (ip >= code.codeSize)
+            {
+                throw new ArgumentException("ip out of range: " + ip);
+            }
+            Bytecode.Instruction I =
+                Bytecode.instructions[opcode];
+            if (I == null)
+            {
+                throw new ArgumentException("no such instruction " + opcode + " at address " + ip);
+            }
+            string instrName = I.name;
+            buf.Append(string.Format("{0:0000}:\t{1,-14}", ip, instrName));
+            ip++;
+            if (I.nopnds == 0)
+            {
+                buf.Append("  ");
+                return ip;
+            }
+
+            List<string> operands = new List<string>();
+            for (int i = 0; i < I.nopnds; i++)
+            {
+                int opnd = getShort(code.instrs, ip);
+                ip += Bytecode.OPND_SIZE_IN_BYTES;
+                switch (I.type[i])
+                {
+                case Bytecode.OperandType.STRING:
+                    operands.Add(showConstPoolOperand(opnd));
+                    break;
+
+                case Bytecode.OperandType.ADDR:
+                case Bytecode.OperandType.INT:
+                    operands.Add(opnd.ToString());
+                    break;
+
+                default:
+                    operands.Add(opnd.ToString());
+                    break;
+                }
+            }
+
+            for (int i = 0; i < operands.Count; i++)
+            {
+                string s = operands[i];
+                if (i > 0)
+                    buf.Append(", ");
+
+                buf.Append(s);
+            }
+            return ip;
+        }
+
+        private string showConstPoolOperand(int poolIndex)
+        {
+            StringBuilder buf = new StringBuilder();
+            buf.Append("#");
+            buf.Append(poolIndex);
+            string s = "<bad string index>";
+            if (poolIndex < code.strings.Length)
+            {
+                if (code.strings[poolIndex] == null)
+                    s = "null";
+                else
+                {
+                    s = code.strings[poolIndex].ToString();
+                    if (code.strings[poolIndex] is string)
+                    {
+                        s = Utility.replaceEscapes(s);
+                        s = '"' + s + '"';
+                    }
+                }
+            }
+            buf.Append(":");
+            buf.Append(s);
+            return buf.ToString();
+        }
+
+        public static int getShort(byte[] memory, int index)
+        {
+            int b1 = memory[index] & 0xFF; // mask off sign-extended bits
+            int b2 = memory[index + 1] & 0xFF;
+            int word = b1 << (8 * 1) | b2;
+            return word;
+        }
+
+        public virtual string strings()
+        {
+            StringBuilder buf = new StringBuilder();
+            int addr = 0;
+            if (code.strings != null)
+            {
+                foreach (object o in code.strings)
+                {
+                    if (o is string)
+                    {
+                        string s = (string)o;
+                        s = Utility.replaceEscapes(s);
+                        buf.AppendLine(string.Format("{0:0000}: \"{1}\"", addr, s));
+                    }
+                    else
+                    {
+                        buf.AppendLine(string.Format("{0:0000}: {1}", addr, o));
+                    }
+                    addr++;
+                }
+            }
+            return buf.ToString();
+        }
+
+        public virtual string sourceMap()
+        {
+            StringBuilder buf = new StringBuilder();
+            int addr = 0;
+            foreach (Interval I in code.sourceMap)
+            {
+                if (I != null)
+                {
+                    string chunk = code.template.Substring(I.A, I.B + 1 - I.A);
+                    buf.AppendLine(string.Format("{0:0000}: {1}\t\"{2}\"", addr, I, chunk));
+                }
+                addr++;
+            }
+
+            return buf.ToString();
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Compiler/CodeGenerator.g3 b/Antlr4.StringTemplate/Compiler/CodeGenerator.g3
new file mode 100644
index 0000000..0300a5a
--- /dev/null
+++ b/Antlr4.StringTemplate/Compiler/CodeGenerator.g3
@@ -0,0 +1,305 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+tree grammar CodeGenerator;
+
+options {
+	language=CSharp3;
+	tokenVocab=TemplateParser;
+	ASTLabelType=CommonTree;
+}
+
+@header{
+using Antlr4.StringTemplate.Misc;
+}
+
+@namespace{Antlr4.StringTemplate.Compiler}
+
+templateAndEOF : template[null,null] EOF; // hush warning; ignore
+
+public
+template[string name, List<FormalArgument> args] returns [CompiledST impl]
+scope {
+    CompilationState state; // automatically get a new state pointer per invocation
+}
+@init {
+ 	$template::state = new CompilationState(errMgr, name, input.TokenStream);
+	$impl = $template::state.impl;
+ 	if ($template.Count == 1) outermostImpl = $impl;
+	$impl.defineFormalArgs($args); // make sure args are defined prior to compilation
+	if ( name!=null && name.StartsWith(Compiler.SUBTEMPLATE_PREFIX) ) {
+	    $impl.addArg(new FormalArgument("i"));
+	    $impl.addArg(new FormalArgument("i0"));
+    }
+	$impl.template = _template; // always forget the entire template; char indexes are relative to it
+}
+	:	chunk
+		{ // finish off the CompiledST result
+        if ( $template::state.stringtable!=null ) $impl.strings = $template::state.stringtable.ToArray();
+        $impl.codeSize = $template::state.ip;
+		}
+	;
+
+chunk
+	:	element*
+	;
+
+element
+	:	^(INDENT {$template::state.indent($INDENT.text);} element {$template::state.emit(Bytecode.INSTR_DEDENT);})
+	|	ifstat
+	|	exprElement
+	|	TEXT
+		{
+		if ($TEXT.text.Length > 0) {
+			emit1($TEXT, Bytecode.INSTR_LOAD_STR, $TEXT.text);
+			emit($TEXT, Bytecode.INSTR_WRITE);
+		}
+		}
+	|	region
+		{
+		emit2($region.start, Bytecode.INSTR_NEW, $region.name, 0);
+		emit($region.start, Bytecode.INSTR_WRITE);
+		}
+	|	NEWLINE {emit(Bytecode.INSTR_NEWLINE);}
+	;
+
+exprElement
+@init { short op = Bytecode.INSTR_WRITE; }
+	:	^( EXPR expr (exprOptions {op=Bytecode.INSTR_WRITE_OPT;})? )
+		{emit($EXPR, op);}
+	;
+
+region returns [string name]
+	:	^(	REGION ID
+			{$name = STGroup.getMangledRegionName(outermostTemplateName, $ID.text);}
+			template[$name,null]
+			{
+			CompiledST sub = $template.impl;
+	        sub.isRegion = true;
+	        sub.regionDefType = ST.RegionType.EMBEDDED;
+			sub.dump();
+			outermostImpl.addImplicitlyDefinedTemplate(sub);
+			}
+		 )
+	;
+
+subtemplate returns [string name, int nargs]
+@init {
+    $name = Compiler.getNewSubtemplateName();
+	List<FormalArgument> args = new List<FormalArgument>();
+}
+	:	^(	SUBTEMPLATE
+			(^(ARGS (ID {args.Add(new FormalArgument($ID.text));})+))*
+			{$nargs = args.Count;}
+			template[$name,args]
+			{
+			CompiledST sub = $template.impl;
+			sub.isAnonSubtemplate = true;
+			if ( STGroup.debug ) {
+				sub.ast = $SUBTEMPLATE;
+				sub.ast.SetUnknownTokenBoundaries();
+				sub.tokens = input.TokenStream;
+			}
+			sub.dump();
+			outermostImpl.addImplicitlyDefinedTemplate(sub);
+			}
+		 )
+	;
+
+ifstat
+@init {
+	///** Tracks address of branch operand (in code block).  It's how
+	//	*  we backpatch forward references when generating code for IFs.
+	//	*/
+	int prevBranchOperand = -1;
+	///** Branch instruction operands that are forward refs to end of IF.
+	//	*  We need to update them once we see the endif.
+	//	*/
+	List<int> endRefs = new List<int>();
+}
+	:	^(	i='if' conditional
+			{
+	        prevBranchOperand = address()+1;
+	        emit1($i,Bytecode.INSTR_BRF, -1); // write placeholder as branch target
+			}
+			chunk
+			(	^(eif='elseif'
+				{
+				endRefs.Add(address()+1);
+				emit1($eif,Bytecode.INSTR_BR, -1); // br end
+				// update previous branch instruction
+				write(prevBranchOperand, (short)address());
+				prevBranchOperand = -1;
+				}
+				ec=conditional
+				{
+		       	prevBranchOperand = address()+1;
+		       	// write placeholder as branch target
+		       	emit1($ec.start, Bytecode.INSTR_BRF, -1);
+				}
+				chunk
+				)
+			)*
+			(	^(	el='else'
+					{
+					endRefs.Add(address()+1);
+					emit1($el, Bytecode.INSTR_BR, -1); // br end
+					// update previous branch instruction
+					write(prevBranchOperand, (short)address());
+					prevBranchOperand = -1;
+					}
+					chunk
+				 )
+			)?
+		 )
+		{
+		if ( prevBranchOperand>=0 ) {
+			write(prevBranchOperand, (short)address());
+		}
+        foreach (int opnd in endRefs) write(opnd, (short)address());
+		}
+	;
+
+conditional
+	:	^('||' conditional conditional)		{emit(Bytecode.INSTR_OR);}
+	|	^('&&' conditional conditional)		{emit(Bytecode.INSTR_AND);}
+	|	^('!' conditional)					{emit(Bytecode.INSTR_NOT);}
+	|	expr // not all expr are valid, but reuse code gen (parser restricts syntax)
+	;
+
+exprOptions : {emit(Bytecode.INSTR_OPTIONS);} ^(OPTIONS option*) ;
+
+option : ^('=' ID expr) {setOption($ID);} ;
+
+expr
+@init {int nt = 0, ne = 0;}
+	:	^(ZIP ^(ELEMENTS (expr {ne++;})+) mapTemplateRef[ne])
+		{emit1($ZIP, Bytecode.INSTR_ZIP_MAP, ne);}
+	|	^(MAP expr (mapTemplateRef[1] {nt++;})+)
+		{
+		if ( nt>1 ) emit1($MAP, nt>1?Bytecode.INSTR_ROT_MAP:Bytecode.INSTR_MAP, nt);
+		else emit($MAP, Bytecode.INSTR_MAP);
+		}
+	|	prop
+	|	includeExpr
+	;
+
+prop:	^(PROP expr ID)						{emit1($PROP, Bytecode.INSTR_LOAD_PROP, $ID.text);}
+	|	^(PROP_IND expr expr)				{emit($PROP_IND, Bytecode.INSTR_LOAD_PROP_IND);}
+	;
+
+mapTemplateRef[int num_exprs]
+	:	^(	INCLUDE ID
+			{for (int i=1; i<=$num_exprs; i++) emit($INCLUDE,Bytecode.INSTR_NULL);}
+			args
+		)
+		{
+		if ( $args.namedArgs ) emit1($INCLUDE, Bytecode.INSTR_NEW_BOX_ARGS, $ID.text);
+		else emit2($INCLUDE, Bytecode.INSTR_NEW, $ID.text, $args.n+$num_exprs);
+		}
+	|	subtemplate
+		{
+		if ($subtemplate.nargs != $num_exprs) {
+            errMgr.compileTimeError(ErrorType.ANON_ARGUMENT_MISMATCH, templateToken, $subtemplate.start.token, $subtemplate.nargs, $num_exprs);
+		}
+		for (int i=1; i<=$num_exprs; i++) emit($subtemplate.start,Bytecode.INSTR_NULL);
+        emit2($subtemplate.start, Bytecode.INSTR_NEW,
+	              $subtemplate.name,
+	              $num_exprs);
+		}
+
+	|	^(	INCLUDE_IND expr
+			{
+			emit($INCLUDE_IND,Bytecode.INSTR_TOSTR);
+			for (int i=1; i<=$num_exprs; i++) emit($INCLUDE_IND,Bytecode.INSTR_NULL);
+			}
+			args
+			{emit1($INCLUDE_IND, Bytecode.INSTR_NEW_IND, $args.n+$num_exprs);}
+		 )
+	;
+
+includeExpr
+	:	^(EXEC_FUNC ID expr?)		{func($ID);}
+	|	^(INCLUDE ID args)
+		{
+		if ( $args.namedArgs ) emit1($INCLUDE, Bytecode.INSTR_NEW_BOX_ARGS, $ID.text);
+		else emit2($INCLUDE, Bytecode.INSTR_NEW, $ID.text, $args.n);
+		}
+	|	^(INCLUDE_SUPER ID args)
+		{
+		if ( $args.namedArgs ) emit1($INCLUDE_SUPER, Bytecode.INSTR_SUPER_NEW_BOX_ARGS, $ID.text);
+		else emit2($INCLUDE_SUPER, Bytecode.INSTR_SUPER_NEW, $ID.text, $args.n);
+		}
+	|	^(INCLUDE_REGION ID)		{
+									CompiledST impl =
+										Compiler.defineBlankRegion(outermostImpl, $ID.text);
+									impl.dump();
+									emit2($INCLUDE_REGION,Bytecode.INSTR_NEW,impl.name,0);
+									}
+	|	^(INCLUDE_SUPER_REGION ID)	{
+									CompiledST impl =
+										Compiler.defineBlankRegion(outermostImpl, $ID.text);
+									impl.dump();
+									emit2($INCLUDE_SUPER_REGION,Bytecode.INSTR_SUPER_NEW,impl.name,0);
+									}
+	|	primary
+	;
+
+primary
+	:	ID				{refAttr($ID);}
+	|	STRING			{emit1($STRING,Bytecode.INSTR_LOAD_STR, Utility.strip($STRING.text,1));}
+	|	subtemplate		// push a subtemplate but ignore args since we can't pass any to it here
+		                {emit2($start,Bytecode.INSTR_NEW, $subtemplate.name, 0);}
+	|	list
+	|	^(	INCLUDE_IND
+			expr 		{emit($INCLUDE_IND, Bytecode.INSTR_TOSTR);}
+			args		{emit1($INCLUDE_IND, Bytecode.INSTR_NEW_IND, $args.n);}
+		 )
+	|	^(TO_STR expr)	{emit($TO_STR, Bytecode.INSTR_TOSTR);}
+	;
+
+arg : expr ;
+
+args returns [int n=0, bool namedArgs=false]
+	:	( arg {$n++;} )+
+	|	{emit($args.start, Bytecode.INSTR_ARGS); $namedArgs=true;}
+		(	^(eq='=' ID expr)
+			{$n++; emit1($eq, Bytecode.INSTR_STORE_ARG, defineString($ID.text));}
+		)+
+	|
+ 	;
+
+list:	{emit(Bytecode.INSTR_LIST);}
+		^(LIST (listElement {emit($listElement.start, Bytecode.INSTR_ADD);})* )
+	;
+
+listElement : expr | NULL {emit($NULL,Bytecode.INSTR_NULL);} ;
diff --git a/Antlr4.StringTemplate/Compiler/CodeGenerator.g3.cs b/Antlr4.StringTemplate/Compiler/CodeGenerator.g3.cs
new file mode 100644
index 0000000..ff9c424
--- /dev/null
+++ b/Antlr4.StringTemplate/Compiler/CodeGenerator.g3.cs
@@ -0,0 +1,124 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Compiler
+{
+    using Antlr.Runtime;
+    using Antlr4.StringTemplate.Misc;
+    using Antlr.Runtime.Tree;
+
+    partial class CodeGenerator
+    {
+        string outermostTemplateName;	// name of overall template
+        CompiledST outermostImpl;
+        IToken templateToken;			// overall template token
+        string _template;  				// overall template text
+        ErrorManager errMgr;
+
+        public CodeGenerator(ITreeNodeStream input, ErrorManager errMgr, string name, string template, IToken templateToken)
+            : this(input, new RecognizerSharedState())
+        {
+            this.errMgr = errMgr;
+            this.outermostTemplateName = name;
+            this._template = template;
+            this.templateToken = templateToken;
+        }
+
+        // convience funcs to hide offensive sending of emit messages to
+        // CompilationState temp data object.
+
+        public void emit1(CommonTree opAST, short opcode, int arg)
+        {
+            template_stack.Peek().state.emit1(opAST, opcode, arg);
+        }
+
+        public void emit1(CommonTree opAST, short opcode, string arg)
+        {
+            template_stack.Peek().state.emit1(opAST, opcode, arg);
+        }
+
+        public void emit2(CommonTree opAST, short opcode, int arg, int arg2)
+        {
+            template_stack.Peek().state.emit2(opAST, opcode, arg, arg2);
+        }
+
+        public void emit2(CommonTree opAST, short opcode, string s, int arg2)
+        {
+            template_stack.Peek().state.emit2(opAST, opcode, s, arg2);
+        }
+
+        public void emit(short opcode)
+        {
+            template_stack.Peek().state.emit(opcode);
+        }
+
+        public void emit(CommonTree opAST, short opcode)
+        {
+            template_stack.Peek().state.emit(opAST, opcode);
+        }
+
+        public void insert(int addr, short opcode, string s)
+        {
+            template_stack.Peek().state.insert(addr, opcode, s);
+        }
+
+        public void setOption(CommonTree id)
+        {
+            template_stack.Peek().state.setOption(id);
+        }
+
+        public void write(int addr, short value)
+        {
+            template_stack.Peek().state.write(addr, value);
+        }
+
+        public int address()
+        {
+            return template_stack.Peek().state.ip;
+        }
+
+        public void func(CommonTree id)
+        {
+            template_stack.Peek().state.func(templateToken, id);
+        }
+
+        public void refAttr(CommonTree id)
+        {
+            template_stack.Peek().state.refAttr(templateToken, id);
+        }
+
+        public int defineString(string s)
+        {
+            return template_stack.Peek().state.defineString(s);
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Compiler/CompilationState.cs b/Antlr4.StringTemplate/Compiler/CompilationState.cs
new file mode 100644
index 0000000..52c7366
--- /dev/null
+++ b/Antlr4.StringTemplate/Compiler/CompilationState.cs
@@ -0,0 +1,225 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Compiler
+{
+    using Array = System.Array;
+    using Antlr.Runtime;
+    using Antlr.Runtime.Tree;
+    using Antlr4.StringTemplate.Misc;
+
+    /** temp data used during construction and functions that fill it / use it.
+     *  Result is impl CompiledST object.
+     */
+    public class CompilationState
+    {
+        /** The compiled code implementation to fill in. */
+        internal CompiledST impl = new CompiledST();
+
+        /** Track unique strings; copy into CompiledST's String[] after compilation */
+        internal StringTable stringtable = new StringTable();
+
+        /** Track instruction location within code.instrs array; this is
+         *  next address to write to.  Byte-addressable memory.
+         */
+        internal int ip = 0;
+
+        internal ITokenStream tokens;
+
+        internal ErrorManager errMgr;
+
+        public CompilationState(ErrorManager errMgr, string name, ITokenStream tokens)
+        {
+            this.errMgr = errMgr;
+            this.tokens = tokens;
+            impl.name = name;
+        }
+
+        public virtual int defineString(string s)
+        {
+            return stringtable.Add(s);
+        }
+
+        public virtual void refAttr(IToken templateToken, CommonTree id)
+        {
+            string name = id.Text;
+            FormalArgument arg;
+            if (impl.formalArguments != null && impl.formalArguments.TryGetValue(name, out arg) && arg != null)
+            {
+                int index = arg.index;
+                emit1(id, Bytecode.INSTR_LOAD_LOCAL, index);
+            }
+            else
+            {
+                if (Interpreter.predefinedAnonSubtemplateAttributes.Contains(name))
+                {
+                    errMgr.compileTimeError(ErrorType.NO_SUCH_ATTRIBUTE, templateToken, id.token);
+                    emit(id, Bytecode.INSTR_NULL);
+                }
+                else
+                {
+                    emit1(id, Bytecode.INSTR_LOAD_ATTR, name);
+                }
+            }
+        }
+
+        public virtual void setOption(CommonTree id)
+        {
+            Interpreter.Option O = Compiler.supportedOptions[id.Text];
+            emit1(id, Bytecode.INSTR_STORE_OPTION, (int)O);
+        }
+
+        public virtual void func(IToken templateToken, CommonTree id)
+        {
+            short funcBytecode;
+            if (!Compiler.funcs.TryGetValue(id.Text, out funcBytecode))
+            {
+                errMgr.compileTimeError(ErrorType.NO_SUCH_FUNCTION, templateToken, id.token);
+                emit(id, Bytecode.INSTR_POP);
+            }
+            else
+            {
+                emit(id, funcBytecode);
+            }
+        }
+
+        public virtual void emit(short opcode)
+        {
+            emit(null, opcode);
+        }
+
+        public virtual void emit(CommonTree opAST, short opcode)
+        {
+            ensureCapacity(1);
+            if (opAST != null)
+            {
+                int i = opAST.TokenStartIndex;
+                int j = opAST.TokenStopIndex;
+                int p = tokens.Get(i).StartIndex;
+                int q = tokens.Get(j).StopIndex;
+                if (!(p < 0 || q < 0))
+                    impl.sourceMap[ip] = new Interval(p, q);
+            }
+            impl.instrs[ip++] = (byte)opcode;
+        }
+
+        public virtual void emit1(CommonTree opAST, short opcode, int arg)
+        {
+            emit(opAST, opcode);
+            ensureCapacity(Bytecode.OPND_SIZE_IN_BYTES);
+            writeShort(impl.instrs, ip, (short)arg);
+            ip += Bytecode.OPND_SIZE_IN_BYTES;
+        }
+
+        public virtual void emit2(CommonTree opAST, short opcode, int arg, int arg2)
+        {
+            emit(opAST, opcode);
+            ensureCapacity(Bytecode.OPND_SIZE_IN_BYTES * 2);
+            writeShort(impl.instrs, ip, (short)arg);
+            ip += Bytecode.OPND_SIZE_IN_BYTES;
+            writeShort(impl.instrs, ip, (short)arg2);
+            ip += Bytecode.OPND_SIZE_IN_BYTES;
+        }
+
+        public virtual void emit2(CommonTree opAST, short opcode, string s, int arg2)
+        {
+            int i = defineString(s);
+            emit2(opAST, opcode, i, arg2);
+        }
+
+        public virtual void emit1(CommonTree opAST, short opcode, string s)
+        {
+            int i = defineString(s);
+            emit1(opAST, opcode, i);
+        }
+
+        public virtual void insert(int addr, short opcode, string s)
+        {
+            //System.out.println("before insert of "+opcode+"("+s+"):"+ Arrays.toString(impl.instrs));
+            ensureCapacity(1 + Bytecode.OPND_SIZE_IN_BYTES);
+            int instrSize = 1 + Bytecode.OPND_SIZE_IN_BYTES;
+            // make room for opcode, opnd
+            Array.Copy(impl.instrs, addr, impl.instrs, addr + instrSize, ip - addr);
+            int save = ip;
+            ip = addr;
+            emit1(null, opcode, s);
+            ip = save + instrSize;
+            //System.out.println("after  insert of "+opcode+"("+s+"):"+ Arrays.toString(impl.instrs));
+            // adjust addresses for BR and BRF
+            int a = addr + instrSize;
+            while (a < ip)
+            {
+                byte op = impl.instrs[a];
+                Bytecode.Instruction I = Bytecode.instructions[op];
+                if (op == Bytecode.INSTR_BR || op == Bytecode.INSTR_BRF)
+                {
+                    int opnd = BytecodeDisassembler.getShort(impl.instrs, a + 1);
+                    writeShort(impl.instrs, a + 1, (short)(opnd + instrSize));
+                }
+                a += I.nopnds * Bytecode.OPND_SIZE_IN_BYTES + 1;
+            }
+            //System.out.println("after  insert of "+opcode+"("+s+"):"+ Arrays.toString(impl.instrs));
+        }
+
+        public virtual void write(int addr, short value)
+        {
+            writeShort(impl.instrs, addr, value);
+        }
+
+        protected virtual void ensureCapacity(int n)
+        {
+            if ((ip + n) >= impl.instrs.Length)
+            { // ensure room for full instruction
+                byte[] c = new byte[impl.instrs.Length * 2];
+                Array.Copy(impl.instrs, 0, c, 0, impl.instrs.Length);
+                impl.instrs = c;
+                Interval[] sm = new Interval[impl.sourceMap.Length * 2];
+                Array.Copy(impl.sourceMap, 0, sm, 0, impl.sourceMap.Length);
+                impl.sourceMap = sm;
+            }
+        }
+
+        public virtual void indent(string indent)
+        {
+            emit1(null, Bytecode.INSTR_INDENT, indent);
+        }
+
+        /** Write value at index into a byte array highest to lowest byte,
+         *  left to right.
+         */
+        public static void writeShort(byte[] memory, int index, short value)
+        {
+            memory[index + 0] = (byte)((value >> (8 * 1)) & 0xFF);
+            memory[index + 1] = (byte)(value & 0xFF);
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Compiler/CompiledTemplate.cs b/Antlr4.StringTemplate/Compiler/CompiledTemplate.cs
new file mode 100644
index 0000000..ca988c6
--- /dev/null
+++ b/Antlr4.StringTemplate/Compiler/CompiledTemplate.cs
@@ -0,0 +1,243 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Compiler
+{
+    using System.Collections.Generic;
+    using Antlr.Runtime.Tree;
+    using Antlr.Runtime;
+    using Antlr4.StringTemplate.Misc;
+    using StringWriter = System.IO.StringWriter;
+    using Console = System.Console;
+
+    /** The result of compiling an ST.  Contains all the bytecode instructions,
+     *  string table, bytecode address to source code map, and other bookkeeping
+     *  info.  It's the implementation of an ST you might say.  All instances
+     *  of the same template share a single implementation (impl field).
+     */
+    public class CompiledST
+    {
+        public string name;
+
+        /** The original, immutable pattern (not really used again after
+         *  initial "compilation"). Useful for debugging.  Even for
+         *  subtemplates, this is entire overall template.
+         */
+        public string template;
+
+        /** Overall token stream for template (debug only) */
+        public ITokenStream tokens;
+
+        /** How do we interpret syntax of template? (debug only) */
+        public CommonTree ast;
+
+        /** Must be non null map if !noFormalArgs */
+        public IDictionary<string, FormalArgument> formalArguments;
+
+        public bool hasFormalArgs;
+
+        /** A list of all regions and subtemplates */
+        public List<CompiledST> implicitlyDefinedTemplates;
+
+        /** The group that physically defines this ST definition.  We use it to initiate
+         *  interpretation via ST.toString().  From there, it becomes field 'group'
+         *  in interpreter and is fixed until rendering completes.
+         */
+        public STGroup nativeGroup = STGroup.defaultGroup;
+
+        /** Does this template come from a <@region>...<@end> embedded in
+         *  another template?
+         */
+        public bool isRegion;
+
+        /** If someone refs <@r()> in template t, an implicit
+         *
+         *   @t.r() ::= ""
+         *
+         *  is defined, but you can overwrite this def by defining your
+         *  own.  We need to prevent more than one manual def though.  Between
+         *  this var and isEmbeddedRegion we can determine these cases.
+         */
+        public ST.RegionType regionDefType;
+
+        public bool isAnonSubtemplate; // {...}
+
+        public string[] strings;     // string operands of instructions
+        public byte[] instrs;        // byte-addressable code memory.
+        public int codeSize;
+        public Interval[] sourceMap; // maps IP to range in template pattern
+
+        public CompiledST()
+        {
+            instrs = new byte[Compiler.TEMPLATE_INITIAL_CODE_SIZE];
+            sourceMap = new Interval[Compiler.TEMPLATE_INITIAL_CODE_SIZE];
+            template = "";
+        }
+
+        public virtual void addImplicitlyDefinedTemplate(CompiledST sub)
+        {
+            if (implicitlyDefinedTemplates == null)
+                implicitlyDefinedTemplates = new List<CompiledST>();
+
+            implicitlyDefinedTemplates.Add(sub);
+        }
+
+        public virtual int getNumberOfArgsWithDefaultValues()
+        {
+            if (formalArguments == null)
+                return 0;
+
+            int n = 0;
+            foreach (string arg in formalArguments.Keys)
+            {
+                if (formalArguments[arg].defaultValueToken != null)
+                    n++;
+            }
+
+            return n;
+        }
+
+        public virtual void defineArgDefaultValueTemplates(STGroup group)
+        {
+            if (formalArguments == null)
+                return;
+
+            foreach (string a in formalArguments.Keys)
+            {
+                FormalArgument fa = formalArguments[a];
+                if (fa.defaultValueToken != null)
+                {
+                    string argSTname = fa.name + "_default_value";
+                    Compiler c2 = new Compiler(group.errMgr, group.delimiterStartChar, group.delimiterStopChar);
+                    string defArgTemplate = Utility.strip(fa.defaultValueToken.Text, 1);
+                    fa.compiledDefaultValue = c2.compile(nativeGroup.getFileName(), argSTname, null, defArgTemplate, fa.defaultValueToken);
+                    fa.compiledDefaultValue.name = argSTname;
+                }
+            }
+        }
+
+        public virtual void defineFormalArgs(List<FormalArgument> args)
+        {
+            hasFormalArgs = true; // even if no args; it's formally defined
+            if (args == null)
+            {
+                formalArguments = null;
+            }
+            else
+            {
+                foreach (FormalArgument a in args)
+                    addArg(a);
+            }
+        }
+
+        /** Used by ST.add() to add args one by one w/o turning on full formal args definition signal */
+        public virtual void addArg(FormalArgument a)
+        {
+            if (formalArguments == null)
+                formalArguments = new Dictionary<string, FormalArgument>();
+
+            a.index = formalArguments.Count;
+            formalArguments[a.name] = a;
+        }
+
+        public virtual void defineImplicitlyDefinedTemplates(STGroup group)
+        {
+            if (implicitlyDefinedTemplates != null)
+            {
+                foreach (CompiledST sub in implicitlyDefinedTemplates)
+                {
+                    group.rawDefineTemplate(sub.name, sub, null);
+                    sub.defineImplicitlyDefinedTemplates(group);
+                }
+            }
+        }
+
+        public virtual string getTemplateSource()
+        {
+            Interval r = getTemplateRange();
+            return template.Substring(r.A, r.B + 1 - r.A);
+        }
+
+        public virtual Interval getTemplateRange()
+        {
+            if (isAnonSubtemplate)
+            {
+                Interval start = sourceMap[0];
+                Interval stop = null;
+                for (int i = sourceMap.Length - 1; i > 0; i--)
+                {
+                    Interval I = sourceMap[i];
+                    if (I != null)
+                    {
+                        stop = I;
+                        break;
+                    }
+                }
+
+                if (template != null)
+                    return new Interval(start.A, stop.B);
+            }
+            return new Interval(0, template.Length - 1);
+        }
+
+        public virtual string Instrs()
+        {
+            BytecodeDisassembler dis = new BytecodeDisassembler(this);
+            return dis.instrs();
+        }
+
+        public virtual void dump()
+        {
+            BytecodeDisassembler dis = new BytecodeDisassembler(this);
+            Console.WriteLine(name + ":");
+            Console.WriteLine(dis.disassemble());
+            Console.WriteLine("Strings:");
+            Console.WriteLine(dis.strings());
+            Console.WriteLine("Bytecode to template map:");
+            Console.WriteLine(dis.sourceMap());
+        }
+
+        public virtual string disasm()
+        {
+            BytecodeDisassembler dis = new BytecodeDisassembler(this);
+            using (StringWriter sw = new StringWriter())
+            {
+                sw.WriteLine(dis.disassemble());
+                sw.WriteLine("Strings:");
+                sw.WriteLine(dis.strings());
+                sw.WriteLine("Bytecode to template map:");
+                sw.WriteLine(dis.sourceMap());
+                return sw.ToString();
+            }
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Compiler/FormalArgument.cs b/Antlr4.StringTemplate/Compiler/FormalArgument.cs
new file mode 100644
index 0000000..b8ad4ca
--- /dev/null
+++ b/Antlr4.StringTemplate/Compiler/FormalArgument.cs
@@ -0,0 +1,141 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Compiler
+{
+    using Antlr.Runtime;
+
+    /** Represents the name of a formal argument defined in a template:
+     *
+     *  test(a,b) ::= "<a> <n>"
+     *
+     *  Each template has a set of these formal arguments or uses
+     *  a placeholder object: UNKNOWN (indicating that no arguments
+     *  were specified such as when we create a template with "new ST(...)").
+     *
+     *  Note: originally, I tracked cardinality as well as the name of an
+     *  attribute.  I'm leaving the code here as I suspect something may come
+     *  of it later.  Currently, though, cardinality is not used.
+     */
+    public class FormalArgument
+    {
+        /*
+            // the following represent bit positions emulating a cardinality bitset.
+            public static final int OPTIONAL = 1;     // a?
+            public static final int REQUIRED = 2;     // a
+            public static final int ZERO_OR_MORE = 4; // a*
+            public static final int ONE_OR_MORE = 8;  // a+
+            public static final String[] suffixes = {
+                null,
+                "?",
+                "",
+                null,
+                "*",
+                null,
+                null,
+                null,
+                "+"
+            };
+            protected int cardinality = REQUIRED;
+             */
+
+        /** When template arguments are not available, when the user
+         *  uses "new ST(...)", then the list of formal arguments
+         *  must be distinguished from the case where a template can specify
+         *  args and there just aren't any such as the t() template above.
+         */
+        //    public static final LinkedHashMap<String, FormalArgument> UNKNOWN =
+        //        new LinkedHashMap<String, FormalArgument>();
+
+        public string name;
+
+        public int index; // which argument is it? from 0..n-1
+
+        /** If they specified name="value", store the template here */
+        public IToken defaultValueToken;
+        public CompiledST compiledDefaultValue;
+
+        public FormalArgument(string name)
+        {
+            this.name = name;
+        }
+
+        public FormalArgument(string name, IToken defaultValueToken)
+        {
+            this.name = name;
+            this.defaultValueToken = defaultValueToken;
+        }
+
+        /*
+        public static String getCardinalityName(int cardinality) {
+            switch (cardinality) {
+                case OPTIONAL : return "optional";
+                case REQUIRED : return "exactly one";
+                case ZERO_OR_MORE : return "zero-or-more";
+                case ONE_OR_MORE : return "one-or-more";
+                default : return "unknown";
+            }
+        }
+        */
+
+        public override bool Equals(object o)
+        {
+            if (o == null || !(o is FormalArgument))
+            {
+                return false;
+            }
+
+            FormalArgument other = (FormalArgument)o;
+            if (!this.name.Equals(other.name))
+            {
+                return false;
+            }
+
+            // only check if there is a default value; that's all
+            return !((this.defaultValueToken != null && other.defaultValueToken == null) ||
+                   (this.defaultValueToken == null && other.defaultValueToken != null));
+        }
+
+        public override int GetHashCode()
+        {
+            return name.GetHashCode() + defaultValueToken.GetHashCode();
+        }
+
+        public override string ToString()
+        {
+            if (defaultValueToken != null)
+                return name + "=" + defaultValueToken.Text;
+
+            return name;
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Compiler/Group.g3 b/Antlr4.StringTemplate/Compiler/Group.g3
new file mode 100644
index 0000000..11f50e7
--- /dev/null
+++ b/Antlr4.StringTemplate/Compiler/Group.g3
@@ -0,0 +1,248 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+grammar Group;
+
+options {
+	language=CSharp3;
+}
+
+@lexer::namespace{Antlr4.StringTemplate.Compiler}
+@parser::namespace{Antlr4.StringTemplate.Compiler}
+
+@lexer::header{
+using Antlr4.StringTemplate.Misc;
+}
+
+@parser::header{
+using Antlr4.StringTemplate.Misc;
+using StringBuilder = System.Text.StringBuilder;
+// The variable 'name' is declared but never used
+#pragma warning disable 168
+}
+
+public
+group[STGroup group, string prefix]
+@init {
+GroupLexer lexer = (GroupLexer)input.TokenSource;
+this._group = lexer.group = $group;
+}
+	:	(	'import' STRING {_group.importTemplates($STRING);}
+		|	'import' // common error: name not in string
+			{
+			MismatchedTokenException e = new MismatchedTokenException(STRING, input);
+			ReportError(e);
+			}
+			ID ('.' ID)* // might be a.b.c.d
+		)*
+        def[prefix]+
+    ;
+
+groupName returns [string name]
+@init {StringBuilder buf = new StringBuilder();}
+	:	a=ID {buf.Append($a.text);} ('.' a=ID {buf.Append($a.text);})*
+	;
+
+/** Match template and dictionary defs outside of (...)+ loop in group.
+ *  The key is catching while still in the loop; must keep prediction of
+ *  elements separate from "stay in loop" prediction.
+ */
+def[string prefix] : templateDef[prefix] | dictDef ;
+	catch[RecognitionException re] {
+		// pretend we already saw an error here
+		state.lastErrorIndex = input.Index;
+		error("garbled template definition starting at '"+input.LT(1).Text+"'");
+	}
+
+public
+templateDef[string prefix]
+@init {
+    string template=null;
+    int n=0; // num char to strip from left, right of template def
+}
+	:	(	'@' enclosing=ID '.' name=ID '(' ')'
+		|	name=ID '(' formalArgs ')'
+		)
+	    '::='
+	    {IToken templateToken = input.LT(1);}
+	    (	STRING     {template=$STRING.text; n=1;}
+	    |	BIGSTRING  {template=$BIGSTRING.text; n=2;}
+	    |	{
+	    	template = "";
+	    	string msg = "missing template at '"+input.LT(1).Text+"'";
+            NoViableAltException e = new NoViableAltException("", 0, 0, input);
+    	    _group.errMgr.groupSyntaxError(ErrorType.SYNTAX_ERROR, SourceName, e, msg);
+    	    }
+	    )
+	    {
+        template = Utility.strip(template, n);
+        string templateName = $name.text;
+        if (prefix.Length > 0) templateName = prefix+"/"+$name.text;
+	    _group.defineTemplateOrRegion(templateName, $enclosing.text, templateToken,
+	    							 template, $name, $formalArgs.args);
+	    }
+	|   alias=ID '::=' target=ID  {_group.defineTemplateAlias($alias, $target);}
+	;
+
+formalArgs returns[List<FormalArgument> args]
+@init {$args = new List<FormalArgument>();}
+    :	formalArg[$args]
+    	( ',' formalArg[$args] )*
+    	( ',' formalArgWithDefaultValue[$args] )*
+    |	formalArgWithDefaultValue[$args] ( ',' formalArgWithDefaultValue[$args] )*
+    |
+	;
+
+formalArg[List<FormalArgument> args]
+	:	ID
+		{$args.Add(new FormalArgument($ID.text));}
+    ;
+
+formalArgWithDefaultValue[List<FormalArgument> args]
+	:	ID
+		(	'=' a=STRING
+		|	'=' a=ANONYMOUS_TEMPLATE
+		)
+		{$args.Add(new FormalArgument($ID.text, $a));}
+    ;
+
+/*
+suffix returns [int cardinality=FormalArgument.REQUIRED]
+    :   OPTIONAL
+    |   STAR
+    |   PLUS
+	|
+    ;
+        */
+
+dictDef
+	:	ID '::=' dict
+        {
+        if ( _group.rawGetDictionary($ID.text)!=null ) {
+			_group.errMgr.compileTimeError(ErrorType.MAP_REDEFINITION, null, $ID);
+        }
+        else if ( _group.rawGetTemplate($ID.text)!=null ) {
+			_group.errMgr.compileTimeError(ErrorType.TEMPLATE_REDEFINITION_AS_MAP, null, $ID);
+        }
+        else {
+            _group.defineDictionary($ID.text, $dict.mapping);
+        }
+        }
+	;
+
+dict returns [IDictionary<string,object> mapping]
+@init {mapping=new Dictionary<string,object>();}
+	:   '[' dictPairs[mapping] ']'
+	;
+
+dictPairs[IDictionary<string,object> mapping]
+    :	keyValuePair[mapping]
+    	(',' keyValuePair[mapping])* (',' defaultValuePair[mapping])?
+    |	defaultValuePair[mapping]
+    ;
+ 	catch[RecognitionException re] {
+		error("missing dictionary entry at '"+input.LT(1).Text+"'");
+	}
+
+defaultValuePair[IDictionary<string,object> mapping]
+	:	'default' ':' keyValue {mapping[STGroup.DEFAULT_KEY] = $keyValue.value;}
+	;
+
+keyValuePair[IDictionary<string,object> mapping]
+	:	STRING ':' keyValue {mapping[Utility.replaceEscapes(Utility.strip($STRING.text, 1))] = $keyValue.value;}
+	;
+
+keyValue returns [object value]
+	:	BIGSTRING			{$value = _group.createSingleton($BIGSTRING);}
+	|	ANONYMOUS_TEMPLATE	{$value = _group.createSingleton($ANONYMOUS_TEMPLATE);}
+	|	STRING				{$value = Utility.replaceEscapes(Utility.strip($STRING.text, 1));}
+	|	{input.LT(1).Text.Equals("key")}?=> ID
+							{$value = STGroup.DICT_KEY;}
+	;
+ 	catch[RecognitionException re] {
+		error("missing value for key at '"+input.LT(1).Text+"'");
+	}
+
+ID	:	('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'0'..'9'|'-'|'_')*
+	;
+
+STRING
+	:	'"'
+		(	'\\' '"'
+		|	'\\' ~'"'
+		|	{
+			string msg = "\\n in string";
+    		NoViableAltException e = new NoViableAltException("", 0, 0, input);
+			group.errMgr.groupLexerError(ErrorType.SYNTAX_ERROR, SourceName, e, msg);
+			}
+			'\n'
+		|	~('\\'|'"'|'\n')
+		)*
+		'"'
+	;
+
+BIGSTRING
+	:	'<<'
+		(	options {greedy=false;}
+		:	'\\' '>'  // \> escape
+		|	'\\' ~'>'
+		|	~'\\'
+		)*
+        '>>'
+        {Text = Text.Replace("\\\\>",">");}
+	;
+
+ANONYMOUS_TEMPLATE
+    :	'{'
+    	{
+		IToken templateToken = new CommonToken(input, ANONYMOUS_TEMPLATE, 0, CharIndex, CharIndex);
+		STLexer lexer = new STLexer(group.errMgr, input, templateToken, group.delimiterStartChar, group.delimiterStopChar);
+		lexer.subtemplateDepth = 1;
+		IToken t = lexer.NextToken();
+		while ( lexer.subtemplateDepth>=1 || t.Type!=STLexer.RCURLY )
+			t = lexer.NextToken();
+		}
+    	// don't match '}' here; our little {...} scanner loop matches it
+    	// to terminate.
+    ;
+
+COMMENT
+    :   '/*' .* '*/' {Skip();}
+    ;
+
+LINE_COMMENT
+    :	'//' ~('\n'|'\r')* '\r'? '\n' {Skip();}
+    ;
+
+WS
+	:	(' '|'\r'|'\t'|'\n') {Skip();}
+	;
diff --git a/Antlr4.StringTemplate/Compiler/Group.g3.lexer.cs b/Antlr4.StringTemplate/Compiler/Group.g3.lexer.cs
new file mode 100644
index 0000000..7b2a6de
--- /dev/null
+++ b/Antlr4.StringTemplate/Compiler/Group.g3.lexer.cs
@@ -0,0 +1,72 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Compiler
+{
+    using Path = System.IO.Path;
+    using Antlr.Runtime;
+    using Antlr4.StringTemplate.Misc;
+
+    partial class GroupLexer
+    {
+        public STGroup group;
+
+        public void reportError(RecognitionException e)
+        {
+            string msg = null;
+            if (e is NoViableAltException)
+            {
+                msg = "invalid character '" + (char)input.LA(1) + "'";
+            }
+            else if (e is MismatchedTokenException && ((MismatchedTokenException)e).Expecting == '"')
+            {
+                msg = "unterminated string";
+            }
+            else
+            {
+                msg = GetErrorMessage(e, TokenNames);
+            }
+
+            group.errMgr.groupSyntaxError(ErrorType.SYNTAX_ERROR, SourceName, e, msg);
+        }
+
+        public override string SourceName
+        {
+            get
+            {
+                string fullFileName = base.SourceName;
+                // strip to simple name
+                return Path.GetFileName(fullFileName);
+            }
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Compiler/Group.g3.parser.cs b/Antlr4.StringTemplate/Compiler/Group.g3.parser.cs
new file mode 100644
index 0000000..0e76ac9
--- /dev/null
+++ b/Antlr4.StringTemplate/Compiler/Group.g3.parser.cs
@@ -0,0 +1,79 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Compiler
+{
+    using Antlr4.StringTemplate.Misc;
+    using Antlr.Runtime;
+    using Path = System.IO.Path;
+
+    partial class GroupParser
+    {
+        private STGroup _group;
+
+        public STGroup Group
+        {
+            get
+            {
+                return _group;
+            }
+
+            internal set
+            {
+                _group = value;
+            }
+        }
+
+        public override void DisplayRecognitionError(string[] tokenNames, RecognitionException e)
+        {
+            string msg = GetErrorMessage(e, tokenNames);
+            _group.errMgr.groupSyntaxError(ErrorType.SYNTAX_ERROR, SourceName, e, msg);
+        }
+
+        public override string SourceName
+        {
+            get
+            {
+                string fullFileName = base.SourceName;
+                // strip to simple name
+                return Path.GetFileName(fullFileName);
+            }
+        }
+
+        public virtual void error(string msg)
+        {
+            NoViableAltException e = new NoViableAltException("", 0, 0, input);
+            _group.errMgr.groupSyntaxError(ErrorType.SYNTAX_ERROR, SourceName, e, msg);
+            Recover(input, null);
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Compiler/StringTable.cs b/Antlr4.StringTemplate/Compiler/StringTable.cs
new file mode 100644
index 0000000..b5aa006
--- /dev/null
+++ b/Antlr4.StringTemplate/Compiler/StringTable.cs
@@ -0,0 +1,66 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Compiler
+{
+    using System.Collections.Generic;
+
+    /** A unique set of strings where we can get a string's index.
+     *  We can also get them back out in original order.
+     */
+    public class StringTable
+    {
+        private readonly Dictionary<string, int> table = new Dictionary<string, int>();
+        private int i = -1;
+
+        public virtual int Add(string s)
+        {
+            int I;
+            if (table.TryGetValue(s, out I))
+                return I;
+
+            i++;
+            table[s] = i;
+            return i;
+        }
+
+        public virtual string[] ToArray()
+        {
+            string[] a = new string[table.Count];
+            int i = 0;
+            foreach (string s in table.Keys)
+                a[i++] = s;
+
+            return a;
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Compiler/TemplateCompiler.cs b/Antlr4.StringTemplate/Compiler/TemplateCompiler.cs
new file mode 100644
index 0000000..645001e
--- /dev/null
+++ b/Antlr4.StringTemplate/Compiler/TemplateCompiler.cs
@@ -0,0 +1,231 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Compiler
+{
+    using System.Collections.Generic;
+    using Antlr4.StringTemplate.Misc;
+    using Antlr.Runtime;
+    using Antlr.Runtime.Tree;
+
+    /** A compiler for a single template. */
+    public class Compiler
+    {
+        public static readonly string SUBTEMPLATE_PREFIX = "_sub";
+
+        public const int TEMPLATE_INITIAL_CODE_SIZE = 15;
+
+        public static readonly IDictionary<string, Interpreter.Option> supportedOptions =
+            new Dictionary<string, Interpreter.Option>()
+        {
+            {"anchor",       Interpreter.Option.ANCHOR},
+            {"format",       Interpreter.Option.FORMAT},
+            {"null",         Interpreter.Option.NULL},
+            {"separator",    Interpreter.Option.SEPARATOR},
+            {"wrap",         Interpreter.Option.WRAP},
+        };
+
+        public static readonly int NUM_OPTIONS = supportedOptions.Count;
+
+        public static readonly IDictionary<string, string> defaultOptionValues =
+            new Dictionary<string, string>()
+        {
+            {"anchor", "true"},
+            {"wrap",   "\n"},
+        };
+
+        public static IDictionary<string, short> funcs =
+            new Dictionary<string, short>()
+        {
+            {"first", Bytecode.INSTR_FIRST},
+            {"last", Bytecode.INSTR_LAST},
+            {"rest", Bytecode.INSTR_REST},
+            {"trunc", Bytecode.INSTR_TRUNC},
+            {"strip", Bytecode.INSTR_STRIP},
+            {"trim", Bytecode.INSTR_TRIM},
+            {"length", Bytecode.INSTR_LENGTH},
+            {"strlen", Bytecode.INSTR_STRLEN},
+            {"reverse", Bytecode.INSTR_REVERSE},
+        };
+
+        /** Name subtemplates _sub1, _sub2, ... */
+        public static int subtemplateCount = 0;
+
+        /** The compiler needs to know how to delimit expressions.
+         *  The STGroup normally passes in this information, but we
+         *  can set some defaults.
+         */
+        public char delimiterStartChar = '<'; // Use <expr> by default
+        public char delimiterStopChar = '>';
+
+        public ErrorManager errMgr;
+
+        public Compiler()
+            : this(STGroup.DEFAULT_ERR_MGR)
+        {
+        }
+
+        public Compiler(ErrorManager errMgr)
+            : this(errMgr, '<', '>')
+        {
+        }
+
+        public Compiler(char delimiterStartChar, char delimiterStopChar)
+            : this(STGroup.DEFAULT_ERR_MGR, delimiterStartChar, delimiterStopChar)
+        {
+        }
+
+        /** To compile a template, we need to know what the
+         *  enclosing template is (if any) in case of regions.
+         */
+        public Compiler(ErrorManager errMgr, char delimiterStartChar, char delimiterStopChar)
+        {
+            this.errMgr = errMgr;
+            this.delimiterStartChar = delimiterStartChar;
+            this.delimiterStopChar = delimiterStopChar;
+        }
+
+        public virtual CompiledST compile(string template)
+        {
+            CompiledST code = compile(null, null, null, template, null);
+            code.hasFormalArgs = false;
+            return code;
+        }
+
+        /** Compile full template with unknown formal args. */
+        public virtual CompiledST compile(string name, string template)
+        {
+            CompiledST code = compile(null, name, null, template, null);
+            code.hasFormalArgs = false;
+            return code;
+        }
+
+        /** Compile full template with respect to a list of formal args. */
+        public virtual CompiledST compile(string srcName, string name, List<FormalArgument> args, string template, IToken templateToken)
+        {
+            ANTLRStringStream @is = new ANTLRStringStream(template);
+            @is.name = srcName != null ? srcName : name;
+            STLexer lexer = new STLexer(errMgr, @is, templateToken, delimiterStartChar, delimiterStopChar);
+            CommonTokenStream tokens = new CommonTokenStream(lexer);
+            TemplateParser p = new TemplateParser(tokens, errMgr, templateToken);
+            TemplateParser.templateAndEOF_return r = null;
+            try
+            {
+                r = p.templateAndEOF();
+            }
+            catch (RecognitionException re)
+            {
+                reportMessageAndThrowSTException(tokens, templateToken, p, re);
+                return null;
+            }
+            if (p.NumberOfSyntaxErrors > 0 || r.Tree == null)
+            {
+                CompiledST impl = new CompiledST();
+                impl.defineFormalArgs(args);
+                return impl;
+            }
+
+            //System.out.println(((CommonTree)r.getTree()).toStringTree());
+            CommonTreeNodeStream nodes = new CommonTreeNodeStream(r.Tree);
+            nodes.TokenStream = tokens;
+            CodeGenerator gen = new CodeGenerator(nodes, errMgr, name, template, templateToken);
+
+            CompiledST impl2 = null;
+            try
+            {
+                impl2 = gen.template(name, args);
+                // only save tree/token stream when debugging
+                if (STGroup.debug)
+                {
+                    impl2.ast = (CommonTree)r.Tree;
+                    impl2.ast.SetUnknownTokenBoundaries();
+                    impl2.tokens = tokens;
+                }
+            }
+            catch (RecognitionException re)
+            {
+                errMgr.internalError(null, "bad tree structure", re);
+            }
+
+            return impl2;
+        }
+
+        public static CompiledST defineBlankRegion(CompiledST outermostImpl, string name)
+        {
+            string outermostTemplateName = outermostImpl.name;
+            string mangled = STGroup.getMangledRegionName(outermostTemplateName, name);
+            CompiledST blank = new CompiledST();
+            blank.isRegion = true;
+            blank.regionDefType = ST.RegionType.IMPLICIT;
+            blank.name = mangled;
+            outermostImpl.addImplicitlyDefinedTemplate(blank);
+            return blank;
+        }
+
+        public static string getNewSubtemplateName()
+        {
+            subtemplateCount++;
+            return SUBTEMPLATE_PREFIX + subtemplateCount;
+        }
+
+        protected virtual void reportMessageAndThrowSTException(ITokenStream tokens, IToken templateToken, Parser parser, RecognitionException re)
+        {
+            if (re.Token.Type == STLexer.EOF_TYPE)
+            {
+                string msg = "premature EOF";
+                errMgr.compileTimeError(ErrorType.SYNTAX_ERROR, templateToken, re.Token, msg);
+            }
+            else if (re is NoViableAltException)
+            {
+                string msg = "'" + re.Token.Text + "' came as a complete surprise to me";
+                errMgr.compileTimeError(ErrorType.SYNTAX_ERROR, templateToken, re.Token, msg);
+            }
+            else if (tokens.Index == 0)
+            { // couldn't parse anything
+                string msg = "this doesn't look like a template: \"" + tokens + "\"";
+                errMgr.compileTimeError(ErrorType.SYNTAX_ERROR, templateToken, re.Token, msg);
+            }
+            else if (tokens.LA(1) == STLexer.LDELIM)
+            { // couldn't parse expr
+                string msg = "doesn't look like an expression";
+                errMgr.compileTimeError(ErrorType.SYNTAX_ERROR, templateToken, re.Token, msg);
+            }
+            else
+            {
+                string msg = parser.GetErrorMessage(re, parser.TokenNames);
+                errMgr.compileTimeError(ErrorType.SYNTAX_ERROR, templateToken, re.Token, msg);
+            }
+
+            throw new STException();
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Compiler/TemplateException.cs b/Antlr4.StringTemplate/Compiler/TemplateException.cs
new file mode 100644
index 0000000..195285f
--- /dev/null
+++ b/Antlr4.StringTemplate/Compiler/TemplateException.cs
@@ -0,0 +1,48 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Compiler
+{
+    using Exception = System.Exception;
+
+    public class STException : Exception
+    {
+        public STException()
+        {
+        }
+
+        public STException(string message, Exception innerException)
+            : base(message, innerException)
+        {
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Compiler/TemplateLexer.cs b/Antlr4.StringTemplate/Compiler/TemplateLexer.cs
new file mode 100644
index 0000000..f508eb7
--- /dev/null
+++ b/Antlr4.StringTemplate/Compiler/TemplateLexer.cs
@@ -0,0 +1,770 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Compiler
+{
+    using Antlr.Runtime;
+    using Antlr4.StringTemplate.Misc;
+    using System.Collections.Generic;
+    using StringBuilder = System.Text.StringBuilder;
+    using StringComparison = System.StringComparison;
+    using Exception = System.Exception;
+    using NotImplementedException = System.NotImplementedException;
+    using NumberStyles = System.Globalization.NumberStyles;
+
+    /** This class represents the tokenizer for templates. It operates in two modes:
+     *  inside and outside of expressions. It behaves like an ANTLR TokenSource,
+     *  implementing nextToken().  Outside of expressions, we can return these
+     *  token types: TEXT, INDENT, LDELIM (start of expr), RCURLY (end of subtemplate),
+     *  and NEWLINE.  Inside of an expression, this lexer returns all of the tokens
+     *  needed by the STParser. From the parser's point of view, it can treat a
+     *  template as a simple stream of elements.
+     *
+     *  This class defines the token types and communicates these values to STParser.g
+     *  via STLexer.tokens file (which must remain consistent).
+     */
+    public class STLexer : ITokenSource
+    {
+        public const char EOF = char.MaxValue;            // EOF char
+        public const int EOF_TYPE = CharStreamConstants.EndOfFile;  // EOF token type
+
+        /** We build STToken tokens instead of relying on CommonToken so we
+         *  can override toString(). It just converts token types to
+         *  token names like 23 to LDELIM.
+         */
+        public class STToken : CommonToken
+        {
+            public STToken(ICharStream input, int type, int start, int stop)
+                : base(input, type, TokenChannels.Default, start, stop)
+            {
+            }
+
+            public STToken(int type, string text)
+                : base(type, text)
+            {
+            }
+
+            public override string ToString()
+            {
+                string channelStr = "";
+                if (Channel > 0)
+                    channelStr = ",channel=" + Channel;
+
+                string txt = Text;
+                if (txt != null)
+                    txt = Utility.replaceEscapes(txt);
+                else
+                    txt = "<no text>";
+
+                return "[@" + TokenIndex + "," + StartIndex + ":" + StopIndex + "='" + txt + "',<" + TemplateParser.tokenNames[Type] + ">" + channelStr + "," + Line + ":" + CharPositionInLine + "]";
+            }
+        }
+
+        public static readonly IToken SKIP = new STToken(-1, "<skip>");
+
+        // must follow STLexer.tokens file that STParser.g loads
+        public const int RBRACK = 17;
+        public const int LBRACK = 16;
+        public const int ELSE = 5;
+        public const int ELLIPSIS = 11;
+        public const int LCURLY = 20;
+        public const int BANG = 10;
+        public const int EQUALS = 12;
+        public const int TEXT = 22;
+        public const int ID = 25;
+        public const int SEMI = 9;
+        public const int LPAREN = 14;
+        public const int IF = 4;
+        public const int ELSEIF = 6;
+        public const int COLON = 13;
+        public const int RPAREN = 15;
+        public const int COMMA = 18;
+        public const int RCURLY = 21;
+        public const int ENDIF = 7;
+        public const int RDELIM = 24;
+        public const int SUPER = 8;
+        public const int DOT = 19;
+        public const int LDELIM = 23;
+        public const int STRING = 26;
+        public const int PIPE = 28;
+        public const int OR = 29;
+        public const int AND = 30;
+        public const int INDENT = 31;
+        public const int NEWLINE = 32;
+        public const int AT = 33;
+        public const int REGION_END = 34;
+
+        /** What char starts an expression? */
+        char delimiterStartChar = '<';
+        char delimiterStopChar = '>';
+
+        /** This keep track of the mode of the lexer. Are we inside or outside
+         *  an ST expression?
+         */
+        bool scanningInsideExpr = false;
+
+        /** To be able to properly track the inside/outside mode, we need to
+         *  track how deeply nested we are in some templates. Otherwise, we
+         *  know whether a '}' and the outermost subtemplate to send this back to
+         *  outside mode.
+         */
+        public int subtemplateDepth = 0; // start out *not* in a {...} subtemplate
+
+        ErrorManager errMgr;
+
+        IToken templateToken; // template embedded in a group file? this is the template
+
+        ICharStream input;
+        char c;        // current character
+
+        /** When we started token, track initial coordinates so we can properly
+         *  build token objects.
+         */
+        int startCharIndex;
+        int startLine;
+        int startCharPositionInLine;
+
+        /** Our lexer routines might have to emit more than a single token. We
+         *  buffer everything through this list.
+         */
+        private readonly Queue<IToken> tokens = new Queue<IToken>();
+
+        public STLexer(ICharStream input) : this(STGroup.DEFAULT_ERR_MGR, input, null, '<', '>')
+        {
+        }
+
+        public STLexer(ErrorManager errMgr, ICharStream input, IToken templateToken)
+            : this(errMgr, input, templateToken, '<', '>')
+        {
+        }
+
+        public STLexer(ErrorManager errMgr,
+                       ICharStream input,
+                       IToken templateToken,
+                       char delimiterStartChar,
+                       char delimiterStopChar)
+        {
+            this.errMgr = errMgr;
+            this.input = input;
+            c = (char)input.LA(1); // prime lookahead
+            this.templateToken = templateToken;
+            this.delimiterStartChar = delimiterStartChar;
+            this.delimiterStopChar = delimiterStopChar;
+        }
+
+        public virtual IToken NextToken()
+        {
+            if (tokens.Count > 0)
+                return tokens.Dequeue();
+
+            return _nextToken();
+        }
+
+        /** Ensure x is next character on the input stream */
+        public virtual void match(char x)
+        {
+            if (c == x)
+                consume();
+            else
+                throw new Exception(getErrorHeader() + ": expecting " + x + "; found " + c);
+        }
+
+        protected virtual void consume()
+        {
+            input.Consume();
+            c = (char)input.LA(1);
+        }
+
+        public virtual void emit(IToken token)
+        {
+            tokens.Enqueue(token);
+        }
+
+        public virtual IToken _nextToken()
+        {
+            //System.out.println("nextToken: c="+(char)c+"@"+input.index());
+            while (true)
+            { // lets us avoid recursion when skipping stuff
+                startCharIndex = input.Index;
+                startLine = input.Line;
+                startCharPositionInLine = input.CharPositionInLine;
+
+                if (c == EOF)
+                    return newToken(EOF_TYPE);
+
+                IToken t;
+                if (scanningInsideExpr)
+                    t = inside();
+                else
+                    t = outside();
+
+                if (t != SKIP)
+                    return t;
+            }
+        }
+
+        protected virtual IToken outside()
+        {
+            if (input.CharPositionInLine == 0 && (c == ' ' || c == '\t'))
+            {
+                while (c == ' ' || c == '\t')
+                    consume(); // scarf indent
+
+                if (c != EOF)
+                    return newToken(INDENT);
+
+                return newToken(TEXT);
+            }
+
+            if (c == delimiterStartChar)
+            {
+                consume();
+                if (c == '!')
+                {
+                    COMMENT();
+                    return SKIP;
+                }
+
+                if (c == '\\')
+                    return ESCAPE(); // <\\> <\uFFFF> <\n> etc...
+
+                scanningInsideExpr = true;
+                return newToken(LDELIM);
+            }
+
+            if (c == '\r')
+            {
+                consume();
+                consume();
+                return newToken(NEWLINE);
+            } // \r\n -> \n
+
+            if (c == '\n')
+            {
+                consume();
+                return newToken(NEWLINE);
+            }
+
+            if (c == '}' && subtemplateDepth > 0)
+            {
+                scanningInsideExpr = true;
+                subtemplateDepth--;
+                consume();
+                return newTokenFromPreviousChar(RCURLY);
+            }
+
+            return mTEXT();
+        }
+
+        protected virtual IToken inside()
+        {
+            while (true)
+            {
+                switch (c)
+                {
+                case ' ':
+                case '\t':
+                case '\n':
+                case '\r':
+                    consume();
+                    continue;
+
+                case '.':
+                    consume();
+                    if (input.LA(1) == '.' && input.LA(2) == '.')
+                    {
+                        consume();
+                        match('.');
+                        return newToken(ELLIPSIS);
+                    }
+                    return newToken(DOT);
+
+                case ',':
+                    consume();
+                    return newToken(COMMA);
+
+                case ':':
+                    consume();
+                    return newToken(COLON);
+
+                case ';':
+                    consume();
+                    return newToken(SEMI);
+
+                case '(':
+                    consume();
+                    return newToken(LPAREN);
+
+                case ')':
+                    consume();
+                    return newToken(RPAREN);
+
+                case '[':
+                    consume();
+                    return newToken(LBRACK);
+
+                case ']':
+                    consume();
+                    return newToken(RBRACK);
+
+                case '=':
+                    consume();
+                    return newToken(EQUALS);
+
+                case '!':
+                    consume();
+                    return newToken(BANG);
+
+                case '@':
+                    consume();
+                    if (c == 'e' && input.LA(2) == 'n' && input.LA(3) == 'd')
+                    {
+                        consume();
+                        consume();
+                        consume();
+                        return newToken(REGION_END);
+                    }
+                    return newToken(AT);
+
+                case '"':
+                    return mSTRING();
+
+                case '&':
+                    consume();
+                    match('&');
+                    return newToken(AND); // &&
+
+                case '|':
+                    consume();
+                    match('|');
+                    return newToken(OR); // ||
+
+                case '{':
+                    return subTemplate();
+
+                default:
+                    if (c == delimiterStopChar)
+                    {
+                        consume();
+                        scanningInsideExpr = false;
+                        return newToken(RDELIM);
+                    }
+
+                    if (isIDStartLetter(c))
+                    {
+                        IToken id = mID();
+                        string name = id.Text;
+
+                        if (name.Equals("if", StringComparison.Ordinal))
+                            return newToken(IF);
+                        else if (name.Equals("endif", StringComparison.Ordinal))
+                            return newToken(ENDIF);
+                        else if (name.Equals("else", StringComparison.Ordinal))
+                            return newToken(ELSE);
+                        else if (name.Equals("elseif", StringComparison.Ordinal))
+                            return newToken(ELSEIF);
+                        else if (name.Equals("super", StringComparison.Ordinal))
+                            return newToken(SUPER);
+
+                        return id;
+                    }
+
+                    RecognitionException re = new NoViableAltException("", 0, 0, input);
+                    re.Line = startLine;
+                    re.CharPositionInLine = startCharPositionInLine;
+                    if (c == EOF)
+                    {
+                        throw new STException("EOF inside ST expression at " + re.Line + ":" + re.CharPositionInLine, re);
+                    }
+
+                    errMgr.lexerError(input.SourceName, "invalid character '" + c + "'", templateToken, re);
+                    consume();
+                    break;
+                }
+            }
+        }
+
+        private IToken subTemplate()
+        {
+            // look for "{ args ID (',' ID)* '|' ..."
+            subtemplateDepth++;
+            int m = input.Mark();
+            int curlyStartChar = startCharIndex;
+            int curlyLine = startLine;
+            int curlyPos = startCharPositionInLine;
+            List<IToken> argTokens = new List<IToken>();
+            consume();
+            IToken curly = newTokenFromPreviousChar(LCURLY);
+            WS();
+            argTokens.Add(mID());
+            WS();
+            while (c == ',')
+            {
+                consume();
+                argTokens.Add(newTokenFromPreviousChar(COMMA));
+                WS();
+                argTokens.Add(mID());
+                WS();
+            }
+
+            WS();
+            if (c == '|')
+            {
+                consume();
+                argTokens.Add(newTokenFromPreviousChar(PIPE));
+                if (isWS(c))
+                    consume(); // ignore a single whitespace after |
+
+                //System.out.println("matched args: "+argTokens);
+                foreach (IToken t in argTokens)
+                    emit(t);
+
+                input.Release(m);
+                scanningInsideExpr = false;
+                startCharIndex = curlyStartChar; // reset state
+                startLine = curlyLine;
+                startCharPositionInLine = curlyPos;
+                return curly;
+            }
+
+            input.Rewind(m);
+            startCharIndex = curlyStartChar; // reset state
+            startLine = curlyLine;
+            startCharPositionInLine = curlyPos;
+            consume();
+            scanningInsideExpr = false;
+            return curly;
+        }
+
+        private IToken ESCAPE()
+        {
+            consume(); // kill \\
+            IToken t = null;
+            switch (c)
+            {
+            case '\\':
+                LINEBREAK();
+                return SKIP;
+
+            case 'n':
+                t = newToken(TEXT, "\n", input.CharPositionInLine - 2);
+                break;
+
+            case 't':
+                t = newToken(TEXT, "\t", input.CharPositionInLine - 2);
+                break;
+
+            case ' ':
+                t = newToken(TEXT, " ", input.CharPositionInLine - 2);
+                break;
+
+            case 'u':
+                t = UNICODE();
+                break;
+
+            default:
+                NoViableAltException e = new NoViableAltException("", 0, 0, input);
+                errMgr.lexerError(input.SourceName, "invalid escaped char: '" + c + "'", templateToken, e);
+                break;
+            }
+            consume();
+            match(delimiterStopChar);
+            return t;
+        }
+
+        private IToken UNICODE()
+        {
+            consume();
+            char[] chars = new char[4];
+            if (!isUnicodeLetter(c))
+            {
+                NoViableAltException e = new NoViableAltException("", 0, 0, input);
+                errMgr.lexerError(input.SourceName, "invalid unicode char: '" + c + "'", templateToken, e);
+            }
+
+            chars[0] = c;
+            consume();
+            if (!isUnicodeLetter(c))
+            {
+                NoViableAltException e = new NoViableAltException("", 0, 0, input);
+                errMgr.lexerError(input.SourceName, "invalid unicode char: '" + c + "'", templateToken, e);
+            }
+
+            chars[1] = c;
+            consume();
+            if (!isUnicodeLetter(c))
+            {
+                NoViableAltException e = new NoViableAltException("", 0, 0, input);
+                errMgr.lexerError(input.SourceName, "invalid unicode char: '" + c + "'", templateToken, e);
+            }
+
+            chars[2] = c;
+            consume();
+            if (!isUnicodeLetter(c))
+            {
+                NoViableAltException e = new NoViableAltException("", 0, 0, input);
+                errMgr.lexerError(input.SourceName, "invalid unicode char: '" + c + "'", templateToken, e);
+            }
+
+            chars[3] = c;
+            // ESCAPE kills final char and >
+            char uc = (char)int.Parse(new string(chars), NumberStyles.HexNumber);
+            return newToken(TEXT, uc.ToString(), input.CharPositionInLine - 6);
+        }
+
+        private IToken mTEXT()
+        {
+            bool modifiedText = false;
+            StringBuilder buf = new StringBuilder();
+            while (c != EOF && c != delimiterStartChar)
+            {
+                if (c == '\r' || c == '\n')
+                    break;
+
+                if (c == '}' && subtemplateDepth > 0)
+                    break;
+
+                if (c == '\\')
+                {
+                    if (input.LA(2) == '\\')
+                    {
+                        // convert \\ to \
+                        consume();
+                        consume();
+                        buf.Append('\\');
+                        modifiedText = true;
+                        continue;
+                    }
+
+                    if (input.LA(2) == delimiterStartChar || input.LA(2) == '}')
+                    {
+                        modifiedText = true;
+                        // toss out \ char
+                        consume();
+                        buf.Append(c);
+                        consume();
+                    }
+                    else
+                    {
+                        buf.Append(c);
+                        consume();
+                    }
+
+                    continue;
+                }
+
+                buf.Append(c);
+                consume();
+            }
+
+            if (modifiedText)
+                return newToken(TEXT, buf.ToString());
+            else
+                return newToken(TEXT);
+        }
+
+        /** ID  :   ('a'..'z'|'A'..'Z'|'_'|'/') ('a'..'z'|'A'..'Z'|'0'..'9'|'_'|'/')* ; */
+        private IToken mID()
+        {
+            // called from subTemplate; so keep resetting position during speculation
+            startCharIndex = input.Index;
+            startLine = input.Line;
+            startCharPositionInLine = input.CharPositionInLine;
+            consume();
+            while (isIDLetter(c))
+            {
+                consume();
+            }
+            return newToken(ID);
+        }
+
+        /** STRING : '"' ( '\\' '"' | '\\' ~'"' | ~('\\'|'"') )* '"' ; */
+        private IToken mSTRING()
+        {
+            //{setText(getText().substring(1, getText().length()-1));}
+            bool sawEscape = false;
+            StringBuilder buf = new StringBuilder();
+            buf.Append(c);
+            consume();
+            while (c != '"')
+            {
+                if (c == '\\')
+                {
+                    sawEscape = true;
+                    consume();
+                    switch (c)
+                    {
+                    case 'n':
+                        buf.Append('\n');
+                        break;
+
+                    case 'r':
+                        buf.Append('\r');
+                        break;
+
+                    case 't':
+                        buf.Append('\t');
+                        break;
+
+                    default:
+                        buf.Append(c);
+                        break;
+                    }
+
+                    consume();
+                    continue;
+                }
+
+                buf.Append(c);
+                consume();
+                if (c == EOF)
+                {
+                    RecognitionException re = new MismatchedTokenException((int)'"', input);
+                    re.Line = input.Line;
+                    re.CharPositionInLine = input.CharPositionInLine;
+                    throw new STException("EOF inside string/template at " + startLine + ":" + startCharPositionInLine, re);
+                }
+            }
+
+            buf.Append(c);
+            consume();
+
+            if (sawEscape)
+                return newToken(STRING, buf.ToString());
+            else
+                return newToken(STRING);
+        }
+
+        private void WS()
+        {
+            while (c == ' ' || c == '\t' || c == '\n' || c == '\r')
+                consume();
+        }
+
+        private void COMMENT()
+        {
+            match('!');
+            while (!(c == '!' && input.LA(2) == delimiterStopChar))
+                consume();
+            consume();
+            consume(); // kill !>
+        }
+
+        private void LINEBREAK()
+        {
+            match('\\'); // only kill 2nd \ as outside() kills first one
+            match(delimiterStopChar);
+            while (c == ' ' || c == '\t')
+                consume(); // scarf WS after <\\>
+            if (c == '\r')
+                consume();
+            match('\n');
+            while (c == ' ' || c == '\t')
+                consume(); // scarf any indent
+        }
+
+        public static bool isIDStartLetter(char c)
+        {
+            return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c == '_';
+        }
+
+        public static bool isIDLetter(char c)
+        {
+            return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c >= '0' && c <= '9' || c == '_' || c == '/';
+        }
+
+        public static bool isWS(char c)
+        {
+            return c == ' ' || c == '\t' || c == '\n' || c == '\r';
+        }
+
+        public static bool isUnicodeLetter(char c)
+        {
+            return c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F' || c >= '0' && c <= '9';
+        }
+
+        public virtual IToken newToken(int ttype)
+        {
+            STToken t = new STToken(input, ttype, startCharIndex, input.Index - 1);
+            t.Line = startLine;
+            t.CharPositionInLine = startCharPositionInLine;
+            return t;
+        }
+
+        public virtual IToken newTokenFromPreviousChar(int ttype)
+        {
+            STToken t = new STToken(input, ttype, input.Index - 1, input.Index - 1);
+            t.Line = input.Line;
+            t.CharPositionInLine = input.CharPositionInLine - 1;
+            return t;
+        }
+
+        public virtual IToken newToken(int ttype, string text, int pos)
+        {
+            STToken t = new STToken(ttype, text);
+            t.Line = input.Line;
+            t.CharPositionInLine = pos;
+            return t;
+        }
+
+        public virtual IToken newToken(int ttype, string text)
+        {
+            STToken t = new STToken(ttype, text);
+            t.StartIndex = startCharIndex;
+            t.StopIndex = input.Index - 1;
+            t.Line = startLine;
+            t.CharPositionInLine = startCharPositionInLine;
+            return t;
+        }
+
+        public virtual string getErrorHeader()
+        {
+            return startLine + ":" + startCharPositionInLine;
+        }
+
+        public virtual string SourceName
+        {
+            get
+            {
+                return "no idea";
+            }
+        }
+
+        public string[] TokenNames
+        {
+            get
+            {
+                throw new NotImplementedException();
+            }
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Compiler/TemplateLexer.tokens b/Antlr4.StringTemplate/Compiler/TemplateLexer.tokens
new file mode 100644
index 0000000..0ed133e
--- /dev/null
+++ b/Antlr4.StringTemplate/Compiler/TemplateLexer.tokens
@@ -0,0 +1,54 @@
+RBRACK=17
+LBRACK=16
+ELSE=5
+ELLIPSIS=11
+LCURLY=20
+BANG=10
+EQUALS=12
+TEXT=22
+ID=25
+SEMI=9
+LPAREN=14
+IF=4
+ELSEIF=6
+COLON=13
+RPAREN=15
+WS=27
+COMMA=18
+RCURLY=21
+ENDIF=7
+RDELIM=24
+SUPER=8
+DOT=19
+LDELIM=23
+STRING=26
+PIPE=28
+OR=29
+AND=30
+INDENT=31
+NEWLINE=32
+AT=33
+END=34
+'super'=8
+'|'=28
+'!'=10
+'}'=21
+'else'=5
+'if'=4
+'{'=20
+'...'=11
+'elseif'=6
+';'=9
+'='=12
+':'=13
+'('=14
+'['=16
+','=18
+'.'=19
+'endif'=7
+')'=15
+']'=17
+'||'=29
+'&&'=30
+'@'=33
+'@end'=34
diff --git a/Antlr4.StringTemplate/Compiler/TemplateParser.g3 b/Antlr4.StringTemplate/Compiler/TemplateParser.g3
new file mode 100644
index 0000000..5a20f71
--- /dev/null
+++ b/Antlr4.StringTemplate/Compiler/TemplateParser.g3
@@ -0,0 +1,224 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** Build an AST from a single StringTemplate template */
+parser grammar TemplateParser;
+
+options {
+	language=CSharp3;
+	tokenVocab=TemplateLexer;
+	TokenLabelType=CommonToken;
+	output=AST;
+	ASTLabelType=CommonTree;
+}
+
+tokens {
+	EXPR; OPTIONS; PROP; PROP_IND; INCLUDE; INCLUDE_IND; EXEC_FUNC; INCLUDE_SUPER;
+	INCLUDE_SUPER_REGION; INCLUDE_REGION; TO_STR; LIST; MAP; ZIP; SUBTEMPLATE; ARGS;
+	ELEMENTS; REGION; NULL;
+	}
+
+@namespace{Antlr4.StringTemplate.Compiler}
+
+@header{
+using Antlr4.StringTemplate.Misc;
+// The variable 'name' is declared but never used
+#pragma warning disable 168
+}
+
+@rulecatch {
+   catch (RecognitionException re) { throw; }
+}
+
+public
+templateAndEOF : template EOF -> template? ;
+
+template : element* ;
+
+element
+	:	INDENT element -> ^(INDENT element)
+	|	ifstat
+	|	exprTag
+	|	text
+	|	region
+	|	NEWLINE
+	;
+
+text : TEXT ;
+
+exprTag
+	:	LDELIM expr ( ';' exprOptions )? RDELIM
+		-> ^(EXPR[$LDELIM,"EXPR"] expr exprOptions?)
+	;
+
+region : LDELIM '@' ID RDELIM template LDELIM '@end' RDELIM -> ^(REGION ID template) ;
+
+subtemplate
+	:	lc='{' (ids+= ID ( ',' ids+= ID )* '|' )? template INDENT? '}'
+		// ignore final INDENT before } as it's not part of outer indent
+		-> ^(SUBTEMPLATE[$lc,"SUBTEMPLATE"] ^(ARGS $ids)* template)
+	;
+
+ifstat // ignore INDENTs in front of elseif ...
+	:	LDELIM 'if' '(' c1=conditional ')' RDELIM
+			t1=template
+			( INDENT? LDELIM 'elseif' '(' c2+=conditional ')' RDELIM t2+=template )*
+			( INDENT? LDELIM 'else' RDELIM t3=template )?
+			INDENT? endif= LDELIM 'endif'
+		RDELIM
+		// kill \n for <endif> on line by itself if multi-line IF
+		({$ifstat.start.Line!=input.LT(1).Line}?=> NEWLINE)?
+		-> ^('if' $c1 $t1? ^('elseif' $c2 $t2?)* ^('else' $t3?)?)
+	;
+
+conditional : andConditional ( '||'^ andConditional )* ;
+
+andConditional : notConditional ( '&&'^ notConditional )* ;
+
+notConditional : ( '!'^ notConditionalExpr | '!'^ '('! conditional ')'! | memberExpr );
+
+notConditionalExpr
+	:	(ID->ID)
+		(	p='.' prop=ID						-> ^(PROP[$p,"PROP"] $notConditionalExpr $prop)
+		|	p='.' '(' mapExpr ')'				-> ^(PROP_IND[$p,"PROP_IND"] $notConditionalExpr mapExpr)
+		)*
+	;
+
+exprOptions : option ( ',' option )* -> ^(OPTIONS option*) ;
+
+option
+@init {
+	string id = input.LT(1).Text;
+	string defVal;
+	Compiler.defaultOptionValues.TryGetValue(id, out defVal);
+	Interpreter.Option supportedOption;
+	bool validOption = Compiler.supportedOptions.TryGetValue(id, out supportedOption);
+}
+	:	ID
+		{
+		if ( !validOption ) {
+            errMgr.compileTimeError(ErrorType.NO_SUCH_OPTION, templateToken, $ID, $ID.text);
+		}
+		}
+		(	'=' exprNoComma 					-> {validOption}? ^('=' ID exprNoComma)
+												->
+		|	{
+			if ( defVal==null ) {
+				errMgr.compileTimeError(ErrorType.NO_DEFAULT_VALUE, templateToken, $ID);
+			}
+			}
+												-> {validOption&&defVal!=null}?
+												   ^(EQUALS["="] ID STRING[$ID,'"'+defVal+'"'])
+												->
+		)
+	;
+
+exprNoComma
+	:	memberExpr
+		( ':' mapTemplateRef					-> ^(MAP memberExpr mapTemplateRef)
+		|										-> memberExpr
+		)
+	;
+
+expr : mapExpr ;
+
+// more complicated than necessary to avoid backtracking, which ruins
+// error handling
+mapExpr
+	:	memberExpr
+		( (c=',' memberExpr)+ col=':' mapTemplateRef
+												-> ^(ZIP[$col] ^(ELEMENTS memberExpr+) mapTemplateRef)
+		|										-> memberExpr
+		)
+		(	{if ($x!=null) $x.Clear();} // don't keep queueing x; new list for each iteration
+			col=':' x+=mapTemplateRef ({$c==null}?=> ',' x+=mapTemplateRef )*
+												-> ^(MAP[$col] $mapExpr $x+)
+		)*
+	;
+
+/**
+expr:template(args)  apply template to expr
+expr:{arg | ...}     apply subtemplate to expr
+expr:(e)(args)       convert e to a string template name and apply to expr
+*/
+mapTemplateRef
+	:	ID '(' args ')'							-> ^(INCLUDE ID args?)
+	|	subtemplate
+	|	lp='(' mapExpr rp=')' '(' argExprList? ')'-> ^(INCLUDE_IND mapExpr argExprList?)
+	;
+
+memberExpr
+	:	(includeExpr->includeExpr)
+		(	p='.' ID							-> ^(PROP[$p,"PROP"] $memberExpr ID)
+		|	p='.' '(' mapExpr ')'				-> ^(PROP_IND[$p,"PROP_IND"] $memberExpr mapExpr)
+		)*
+	;
+
+includeExpr
+options {k=2;} // prevent full LL(*), which fails, falling back on k=1; need k=2
+	:	{Compiler.funcs.ContainsKey(input.LT(1).Text)}? // predefined function
+		ID '(' expr? ')'						-> ^(EXEC_FUNC ID expr?)
+	|	'super' '.' ID '(' args ')'				-> ^(INCLUDE_SUPER ID args?)
+	|	ID '(' args ')'							-> ^(INCLUDE ID args?)
+	|	'@' 'super' '.' ID '(' rp=')'			-> ^(INCLUDE_SUPER_REGION ID)
+	|	'@' ID '(' rp=')'						-> ^(INCLUDE_REGION ID)
+	|	primary
+	;
+
+primary
+	:	ID
+	|	STRING
+	|	subtemplate
+	|	list
+	|	lp='(' expr ')'
+		(	'(' argExprList? ')'				-> ^(INCLUDE_IND[$lp] expr argExprList?)
+		|										-> ^(TO_STR[$lp] expr)
+		)
+	;
+
+args:	argExprList
+	|	namedArg ( ',' namedArg )* -> namedArg+
+	|
+	;
+
+argExprList : arg ( ',' arg )* -> arg+ ;
+
+arg : exprNoComma ;
+
+namedArg : ID '=' arg -> ^('=' ID arg) ;
+
+list:	{input.LA(2)==RBRACK}? // hush warning; [] special case
+		lb='[' ']' -> LIST[$lb]
+	|	lb='[' listElement ( ',' listElement )* ']' -> ^(LIST[$lb] listElement*)
+	;
+
+listElement : exprNoComma | -> NULL ;
diff --git a/Antlr4.StringTemplate/Compiler/TemplateParser.g3.cs b/Antlr4.StringTemplate/Compiler/TemplateParser.g3.cs
new file mode 100644
index 0000000..e7d708c
--- /dev/null
+++ b/Antlr4.StringTemplate/Compiler/TemplateParser.g3.cs
@@ -0,0 +1,55 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Compiler
+{
+    using Antlr4.StringTemplate.Misc;
+    using Antlr.Runtime;
+
+    partial class TemplateParser
+    {
+        ErrorManager errMgr;
+        IToken templateToken;
+
+        public TemplateParser(ITokenStream input, ErrorManager errMgr, IToken templateToken)
+            : this(input)
+        {
+            this.errMgr = errMgr;
+            this.templateToken = templateToken;
+        }
+
+        protected object recoverFromMismatchedToken(IIntStream input, int ttype, BitSet follow)
+        {
+            throw new MismatchedTokenException(ttype, input);
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Compiler/TestNewStuff.cs b/Antlr4.StringTemplate/Compiler/TestNewStuff.cs
new file mode 100644
index 0000000..3571799
--- /dev/null
+++ b/Antlr4.StringTemplate/Compiler/TestNewStuff.cs
@@ -0,0 +1,52 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Compiler
+{
+    using File = System.IO.File;
+    using System.Collections.Generic;
+    using Path = System.IO.Path;
+
+    public class TestNewStuff
+    {
+        public static void main(string[] args)
+        {
+            Compiler c = new Compiler();
+
+            string template = File.ReadAllText(args[0]);
+            List<FormalArgument> a = new List<FormalArgument>();
+            a.Add(new FormalArgument("x"));
+            string n = Path.GetFileNameWithoutExtension(args[0]);
+            c.compile(args[0], n, a, template, null);
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/DateRenderer.cs b/Antlr4.StringTemplate/DateRenderer.cs
new file mode 100644
index 0000000..1dd8b4e
--- /dev/null
+++ b/Antlr4.StringTemplate/DateRenderer.cs
@@ -0,0 +1,83 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate
+{
+    using System.Collections.Generic;
+    using CultureInfo = System.Globalization.CultureInfo;
+
+/** A renderer for java.util.Date and Calendar objects. It understands a
+ *  variety of format names as shown in formatToInt field.  By default
+ *  it assumes "short" format.  A prefix of date: or time: shows only
+ *  those components of the time object.
+ */
+public class DateRenderer : AttributeRenderer {
+#if false
+    public static readonly IDictionary<string,int> formatToInt =
+        new Dictionary<string,int>() {
+            {
+                put("short", DateFormat.SHORT);
+                put("medium", DateFormat.MEDIUM);
+                put("long", DateFormat.LONG);
+                put("full", DateFormat.FULL);
+
+                put("date:short", DateFormat.SHORT);
+                put("date:medium", DateFormat.MEDIUM);
+                put("date:long", DateFormat.LONG);
+                put("date:full", DateFormat.FULL);
+
+                put("time:short", DateFormat.SHORT);
+                put("time:medium", DateFormat.MEDIUM);
+                put("time:long", DateFormat.LONG);
+                put("time:full", DateFormat.FULL);
+            }
+        };
+#endif
+
+    public virtual string toString(object o, string formatString, CultureInfo locale) {
+        Date d;
+        if ( formatString==null ) formatString = "short";
+        if ( o is Calendar ) d = ((Calendar)o).getTime();
+        else d = (Date)o;
+        Integer styleI = formatToInt.get(formatString);
+        DateFormat f;
+        if ( styleI==null ) f = new SimpleDateFormat(formatString);
+        else {
+            int style = styleI.intValue();
+            if ( formatString.startsWith("date:") ) f = DateFormat.getDateInstance(style);
+            else if ( formatString.startsWith("time:") ) f = DateFormat.getTimeInstance(style);
+            else f = DateFormat.getDateTimeInstance(style, style);
+        }
+        return f.format(d);
+    }
+}
+}
diff --git a/Antlr4.StringTemplate/Debug/AddAttributeEvent.cs b/Antlr4.StringTemplate/Debug/AddAttributeEvent.cs
new file mode 100644
index 0000000..5bda754
--- /dev/null
+++ b/Antlr4.StringTemplate/Debug/AddAttributeEvent.cs
@@ -0,0 +1,71 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Debug
+{
+    public class AddAttributeEvent : ConstructionEvent
+    {
+        private readonly string name;
+        private readonly object value; // unused really; leave for future
+
+        public AddAttributeEvent(string name, object value)
+        {
+            this.name = name;
+            this.value = value;
+        }
+
+        public string Name
+        {
+            get
+            {
+                return name;
+            }
+        }
+
+        public object Value
+        {
+            get
+            {
+                return value;
+            }
+        }
+
+        public override string ToString()
+        {
+            return "addEvent{" +
+                ", name='" + name + '\'' +
+                ", value=" + value +
+                ", location=" + getFileName() + ":" + getLine() +
+                '}';
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Debug/ConstructionEvent.cs b/Antlr4.StringTemplate/Debug/ConstructionEvent.cs
new file mode 100644
index 0000000..3301415
--- /dev/null
+++ b/Antlr4.StringTemplate/Debug/ConstructionEvent.cs
@@ -0,0 +1,74 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Debug
+{
+    using System.Diagnostics;
+    using Environment = System.Environment;
+
+    /** An event that happens when building ST trees, adding attributes etc... */
+    public class ConstructionEvent
+    {
+        private readonly StackTrace stack;
+
+        public ConstructionEvent()
+        {
+            stack = new StackTrace(true);
+        }
+
+        public virtual string getFileName()
+        {
+            return getSTEntryPoint().GetFileName();
+        }
+
+        public virtual int getLine()
+        {
+            return getSTEntryPoint().GetFileLineNumber();
+        }
+
+        public virtual StackFrame getSTEntryPoint()
+        {
+            StackFrame[] trace = stack.GetFrames();
+            foreach (StackFrame e in trace)
+            {
+                string name = e.ToString();
+                // TODO: remove special after testing
+                if (name.IndexOf("main(") > 0)
+                    return e;
+
+                if (!name.StartsWith("org.stringtemplate"))
+                    return e;
+            }
+            return trace[0];
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Debug/DebugTemplate.cs b/Antlr4.StringTemplate/Debug/DebugTemplate.cs
new file mode 100644
index 0000000..8d37dac
--- /dev/null
+++ b/Antlr4.StringTemplate/Debug/DebugTemplate.cs
@@ -0,0 +1,134 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Debug
+{
+    using System.Collections.Generic;
+    using Antlr4.StringTemplate.Misc;
+    using CultureInfo = System.Globalization.CultureInfo;
+    using StringWriter = System.IO.StringWriter;
+
+    /** To avoid polluting ST instances with debug info when not debugging.
+     *  Setting debug mode in STGroup makes it create these instead of STs.
+     */
+    public class DebugST : ST
+    {
+        public class State
+        {
+            /** Track all events that occur during rendering. */
+            public List<InterpEvent> interpEvents = new List<InterpEvent>();
+        }
+
+        /** Record who made us? ConstructionEvent creates Exception to grab stack */
+        public ConstructionEvent newSTEvent = new ConstructionEvent();
+
+        /** Track construction-time add attribute "events"; used for ST user-level debugging */
+        public MultiMap<string, AddAttributeEvent> addAttrEvents = new MultiMap<string, AddAttributeEvent>();
+
+        //public Interpreter interp; // set when we start interpreter in inspect()
+
+        public DebugST()
+        {
+        }
+
+        public DebugST(ST proto) : base(proto)
+        {
+        }
+
+        public override void add(string name, object value)
+        {
+            if (STGroup.debug)
+                addAttrEvents.map(name, new AddAttributeEvent(name, value));
+
+            base.add(name, value);
+        }
+
+        // LAUNCH A WINDOW TO INSPECT TEMPLATE HIERARCHY
+
+        public virtual List<InterpEvent> inspect()
+        {
+            return inspect(CultureInfo.CurrentCulture);
+        }
+
+        public virtual List<InterpEvent> inspect(int lineWidth)
+        {
+            return inspect(impl.nativeGroup.errMgr, CultureInfo.CurrentCulture, lineWidth);
+        }
+
+        public virtual List<InterpEvent> inspect(CultureInfo locale)
+        {
+            return inspect(impl.nativeGroup.errMgr, locale, AutoIndentWriter.NO_WRAP);
+        }
+
+        public virtual List<InterpEvent> inspect(ErrorManager errMgr, CultureInfo locale, int lineWidth)
+        {
+            ErrorBuffer errors = new ErrorBuffer();
+            impl.nativeGroup.setListener(errors);
+            StringWriter @out = new StringWriter();
+            STWriter wr = new AutoIndentWriter(@out);
+            wr.setLineWidth(lineWidth);
+            Interpreter interp = new Interpreter(groupThatCreatedThisInstance, locale);
+            interp.exec(wr, this); // render and track events
+#if false
+            new STViz(errMgr, this, @out.ToString(), interp, interp.getExecutionTrace(), errors.Errors);
+#endif
+            return interp.getEvents();
+        }
+
+        // TESTING SUPPORT
+
+        public virtual List<InterpEvent> getEvents()
+        {
+            return getEvents(CultureInfo.CurrentCulture);
+        }
+
+        public virtual List<InterpEvent> getEvents(int lineWidth)
+        {
+            return getEvents(CultureInfo.CurrentCulture, lineWidth);
+        }
+
+        public virtual List<InterpEvent> getEvents(CultureInfo locale)
+        {
+            return getEvents(locale, AutoIndentWriter.NO_WRAP);
+        }
+
+        public virtual List<InterpEvent> getEvents(CultureInfo locale, int lineWidth)
+        {
+            StringWriter @out = new StringWriter();
+            STWriter wr = new AutoIndentWriter(@out);
+            wr.setLineWidth(lineWidth);
+            Interpreter interp = new Interpreter(groupThatCreatedThisInstance, locale);
+            interp.exec(wr, this); // render and track events
+            return interp.getEvents();
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Debug/EvalExprEvent.cs b/Antlr4.StringTemplate/Debug/EvalExprEvent.cs
new file mode 100644
index 0000000..e071541
--- /dev/null
+++ b/Antlr4.StringTemplate/Debug/EvalExprEvent.cs
@@ -0,0 +1,88 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Debug
+{
+    public class EvalExprEvent : InterpEvent
+    {
+        // template pattern location
+        private readonly int exprStart;
+        private readonly int exprStop;
+        private readonly string expr;
+
+        public EvalExprEvent(DebugST self, int start, int stop, int exprStart, int exprStop)
+            : base(self, start, stop)
+        {
+            this.exprStart = exprStart;
+            this.exprStop = exprStop;
+            if (exprStart >= 0 && exprStop >= 0)
+            {
+                expr = self.impl.template.Substring(exprStart, exprStop + 1 - exprStart);
+            }
+        }
+
+        public int ExprStart
+        {
+            get
+            {
+                return exprStart;
+            }
+        }
+
+        public int ExprStop
+        {
+            get
+            {
+                return exprStop;
+            }
+        }
+
+        public string Expr
+        {
+            get
+            {
+                return expr;
+            }
+        }
+
+        public override string ToString()
+        {
+            return GetType().Name + "{" +
+                   "self=" + Self +
+                 //", attr=" + self.attributes +
+                   ", start=" + Start +
+                   ", stop=" + Stop +
+                   ", expr=" + expr +
+                   '}';
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Debug/EvalTemplateEvent.cs b/Antlr4.StringTemplate/Debug/EvalTemplateEvent.cs
new file mode 100644
index 0000000..06d0dd5
--- /dev/null
+++ b/Antlr4.StringTemplate/Debug/EvalTemplateEvent.cs
@@ -0,0 +1,42 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Debug
+{
+    public class EvalTemplateEvent : InterpEvent
+    {
+        public EvalTemplateEvent(DebugST self, int start, int stop)
+            : base(self, start, stop)
+        {
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Debug/InterpEvent.cs b/Antlr4.StringTemplate/Debug/InterpEvent.cs
new file mode 100644
index 0000000..1720e13
--- /dev/null
+++ b/Antlr4.StringTemplate/Debug/InterpEvent.cs
@@ -0,0 +1,83 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Debug
+{
+    public class InterpEvent
+    {
+        private readonly DebugST self;
+        // output location
+        private readonly int start;
+        private readonly int stop;
+
+        public InterpEvent(DebugST self, int start, int stop)
+        {
+            this.self = self;
+            this.start = start;
+            this.stop = stop;
+        }
+
+        public DebugST Self
+        {
+            get
+            {
+                return self;
+            }
+        }
+
+        public int Start
+        {
+            get
+            {
+                return start;
+            }
+        }
+
+        public int Stop
+        {
+            get
+            {
+                return stop;
+            }
+        }
+
+        public override string ToString()
+        {
+            return GetType().Name + "{" +
+                   "self=" + self +
+                    //", attr=" + self.attributes +
+                   ", start=" + start +
+                   ", stop=" + stop +
+                   '}';
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/IAttributeRenderer.cs b/Antlr4.StringTemplate/IAttributeRenderer.cs
new file mode 100644
index 0000000..dc1306f
--- /dev/null
+++ b/Antlr4.StringTemplate/IAttributeRenderer.cs
@@ -0,0 +1,50 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate
+{
+    using CultureInfo = System.Globalization.CultureInfo;
+
+    /** This interface describes an object that knows how to format or otherwise
+     *  render an object appropriately.  There is one renderer registered per
+     *  group for a given Java type.
+     *
+     *  If the format string passed to the renderer is not recognized then simply
+     *  call toString().
+     *
+     *  formatString can be null but locale will at least be Locale.getDefault()
+     */
+    public interface AttributeRenderer
+    {
+        string toString(object o, string formatString, CultureInfo culture);
+    }
+}
diff --git a/Antlr4.StringTemplate/IModelAdaptor.cs b/Antlr4.StringTemplate/IModelAdaptor.cs
new file mode 100644
index 0000000..80c09e8
--- /dev/null
+++ b/Antlr4.StringTemplate/IModelAdaptor.cs
@@ -0,0 +1,58 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate
+{
+    /** An object that knows how to convert property references to appropriate
+     *  actions on a model object.  Some models, like JDBC, are interface based
+     *  (we aren't supposed to care about implementation classes). Some other
+     *  models don't follow getter method naming convention.  So, if we have
+     *  an object of type M with property method foo() (not getFoo()), we
+     *  register a model adaptor object, adap, that converts foo lookup to foo().
+     *
+     *  Given <a.foo>, we look up foo via the adaptor if "a instanceof(M)".
+     *
+     *  See unit tests.
+     */
+    public interface ModelAdaptor
+    {
+        /** Lookup property name in o and return its value.  It's a good
+         *  idea to cache a Method or Field reflection object to make
+         *  this fast after the first look up.
+         *
+         *  property is normally a String but doesn't have to be. E.g.,
+         *  if o is Map, property could be any key type.  If we need to convert
+         *  to string, then it's done by ST and passed in here.
+         */
+        object getProperty(ST self, object o, object property, string propertyName);
+    }
+}
diff --git a/Antlr4.StringTemplate/ITemplateErrorListener.cs b/Antlr4.StringTemplate/ITemplateErrorListener.cs
new file mode 100644
index 0000000..03fb560
--- /dev/null
+++ b/Antlr4.StringTemplate/ITemplateErrorListener.cs
@@ -0,0 +1,45 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate
+{
+    using Antlr4.StringTemplate.Misc;
+
+    /** How to handle messages */
+    public interface STErrorListener
+    {
+        void compileTimeError(STMessage msg);
+        void runTimeError(STMessage msg);
+        void IOError(STMessage msg);
+        void internalError(STMessage msg);
+    }
+}
diff --git a/Antlr4.StringTemplate/ITemplateWriter.cs b/Antlr4.StringTemplate/ITemplateWriter.cs
new file mode 100644
index 0000000..7a0bdb3
--- /dev/null
+++ b/Antlr4.StringTemplate/ITemplateWriter.cs
@@ -0,0 +1,89 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate
+{
+    /** Generic StringTemplate output writer filter.
+     *
+     *  Literals and the elements of expressions are emitted via write().
+     *  Separators are emitted via writeSeparator() because they must be
+     *  handled specially when wrapping lines (we don't want to wrap
+     *  in between an element and it's separator).
+     */
+    public interface STWriter
+    {
+        void pushIndentation(string indent);
+
+        string popIndentation();
+
+        void pushAnchorPoint();
+
+        void popAnchorPoint();
+
+        void setLineWidth(int lineWidth);
+
+        /** Write the string and return how many actual chars were written.
+         *  With autoindentation and wrapping, more chars than length(str)
+         *  can be emitted.  No wrapping is done.
+         */
+        int write(string str);
+
+        /** Same as write, but wrap lines using the indicated string as the
+         *  wrap character (such as "\n").
+         */
+        int write(string str, string wrap);
+
+        /** Because we evaluate ST instance by invoking exec() again, we
+         *  can't pass options in.  So the WRITE instruction of an applied
+         *  template (such as when we wrap in between template applications
+         *  like &lt;data:{v|[&lt;v&gt;]}; wrap&gt;) we need to write the wrap string
+         *  before calling exec().  We expose just like for the separator.
+         *  See Interpreter.writeObject where it checks for ST instance.
+         *  If POJO, writePOJO passes wrap to STWriter's
+         *
+         *     write(String str, String wrap)
+         *
+         *  method.  Can't pass to exec().
+         */
+        int writeWrap(string wrap);
+
+        /** Write a separator.  Same as write() except that a \n cannot
+         *  be inserted before emitting a separator.
+         */
+        int writeSeparator(string str);
+
+        /** Return the absolute char index into the output of the char
+         *  we're about to write.  Returns 0 if no char written yet.
+         */
+        int index();
+    }
+}
diff --git a/Antlr4.StringTemplate/Interpreter.cs b/Antlr4.StringTemplate/Interpreter.cs
new file mode 100644
index 0000000..81ef197
--- /dev/null
+++ b/Antlr4.StringTemplate/Interpreter.cs
@@ -0,0 +1,1384 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate
+{
+    using CultureInfo = System.Globalization.CultureInfo;
+    using System.Collections.Generic;
+    using Antlr4.StringTemplate.Debug;
+    using Antlr4.StringTemplate.Misc;
+    using Antlr4.StringTemplate.Compiler;
+    using Environment = System.Environment;
+    using IOException = System.IO.IOException;
+    using Console = System.Console;
+    using StringBuilder = System.Text.StringBuilder;
+    using Math = System.Math;
+    using StringWriter = System.IO.StringWriter;
+    using Array = System.Array;
+    using System.Linq;
+    using IList = System.Collections.IList;
+    using IDictionary = System.Collections.IDictionary;
+    using ICollection = System.Collections.ICollection;
+    using IEnumerable = System.Collections.IEnumerable;
+    using Antlr.Runtime.JavaExtensions;
+
+    /** This class knows how to execute template bytecodes relative to a
+     *  particular STGroup. To execute the byte codes, we need an output stream
+     *  and a reference to an ST an instance. That instance's impl field points at
+     *  a CompiledST, which contains all of the byte codes and other information
+     *  relevant to execution.
+     *
+     *  This interpreter is a stack-based bytecode interpreter.  All operands
+     *  go onto an operand stack.
+     *
+     *  If the group that we're executing relative to has debug set, we track
+     *  interpreter events. For now, I am only tracking instance creation events.
+     *  These are used by STViz to pair up output chunks with the template
+     *  expressions that generate them.
+     *
+     *  We create a new interpreter for each ST.render(), DebugST.inspect, or
+     *  DebugST.getEvents() invocation.
+     */
+    public class Interpreter
+    {
+        public enum Option
+        {
+            ANCHOR,
+            FORMAT,
+            NULL,
+            SEPARATOR,
+            WRAP
+        }
+
+        public const int DEFAULT_OPERAND_STACK_SIZE = 100;
+
+        public static readonly HashSet<string> predefinedAnonSubtemplateAttributes = new HashSet<string>() { "i", "i0" };
+
+        /** Operand stack, grows upwards */
+        object[] operands = new object[DEFAULT_OPERAND_STACK_SIZE];
+        int sp = -1;        // stack pointer register
+        int current_ip = 0; // mirrors ip in exec(), but visible to all methods
+        int nwline = 0;     // how many char written on this template LINE so far?
+
+        /** Exec st with respect to this group. Once set in ST.toString(),
+         *  it should be fixed. ST has group also.
+         */
+        STGroup group;
+
+        /** For renderers, we have to pass in the locale */
+        CultureInfo locale;
+
+        ErrorManager errMgr;
+
+        /** Dump bytecode instructions as we execute them? */
+        public static bool trace = false;
+
+        /** Track everything happening in interp if debug across all templates */
+        protected List<InterpEvent> events;
+
+        /** If debug mode, track trace here */
+        // TODO: track the pieces not a string and track what it contributes to output
+        protected List<string> executeTrace;
+
+        IDictionary<ST, List<InterpEvent>> debugInfo;
+
+        public Interpreter(STGroup group)
+            : this(group, CultureInfo.CurrentCulture, group.errMgr)
+        {
+        }
+
+        public Interpreter(STGroup group, CultureInfo locale)
+            : this(group, locale, group.errMgr)
+        {
+        }
+
+        public Interpreter(STGroup group, ErrorManager errMgr)
+            : this(group, CultureInfo.CurrentCulture, errMgr)
+        {
+        }
+
+        public Interpreter(STGroup group, CultureInfo locale, ErrorManager errMgr)
+        {
+            this.group = group;
+            this.locale = locale;
+            this.errMgr = errMgr;
+            if (STGroup.debug)
+            {
+                events = new List<InterpEvent>();
+                executeTrace = new List<string>();
+                debugInfo = new Dictionary<ST, List<InterpEvent>>();
+            }
+        }
+
+        /** Execute template self and return how many characters it wrote to out */
+        public virtual int exec(STWriter @out, ST self)
+        {
+            int start = @out.index(); // track char we're about to write
+            int prevOpcode = 0;
+            int n = 0; // how many char we write out
+            int nargs;
+            int nameIndex;
+            int addr;
+            string name;
+            object o, left, right;
+            ST st;
+            object[] options;
+            byte[] code = self.impl.instrs;        // which code block are we executing
+            int ip = 0;
+            while (ip < self.impl.codeSize)
+            {
+                if (trace || STGroup.debug)
+                    Trace(self, ip);
+
+                short opcode = code[ip];
+                current_ip = ip;
+                ip++; //jump to next instruction or first byte of operand
+                switch (opcode)
+                {
+                case Bytecode.INSTR_LOAD_STR:
+                    int strIndex = getShort(code, ip);
+                    ip += Bytecode.OPND_SIZE_IN_BYTES;
+                    operands[++sp] = self.impl.strings[strIndex];
+                    break;
+
+                case Bytecode.INSTR_LOAD_ATTR:
+                    nameIndex = getShort(code, ip);
+                    ip += Bytecode.OPND_SIZE_IN_BYTES;
+                    name = self.impl.strings[nameIndex];
+                    try
+                    {
+                        o = self.getAttribute(name);
+                    }
+                    catch (STNoSuchPropertyException)
+                    {
+                        errMgr.runTimeError(self, current_ip, ErrorType.NO_SUCH_ATTRIBUTE, name);
+                        o = null;
+                    }
+                    operands[++sp] = o;
+                    break;
+
+                case Bytecode.INSTR_LOAD_LOCAL:
+                    int valueIndex = getShort(code, ip);
+                    ip += Bytecode.OPND_SIZE_IN_BYTES;
+                    o = self.locals[valueIndex];
+                    if (o == ST.EMPTY_ATTR)
+                        o = null;
+                    operands[++sp] = o;
+                    break;
+
+                case Bytecode.INSTR_LOAD_PROP:
+                    nameIndex = getShort(code, ip);
+                    ip += Bytecode.OPND_SIZE_IN_BYTES;
+                    o = operands[sp--];
+                    name = self.impl.strings[nameIndex];
+                    operands[++sp] = getObjectProperty(self, o, name);
+                    break;
+
+                case Bytecode.INSTR_LOAD_PROP_IND:
+                    object propName = operands[sp--];
+                    o = operands[sp];
+                    operands[sp] = getObjectProperty(self, o, propName);
+                    break;
+
+                case Bytecode.INSTR_NEW:
+                    nameIndex = getShort(code, ip);
+                    ip += Bytecode.OPND_SIZE_IN_BYTES;
+                    name = self.impl.strings[nameIndex];
+                    nargs = getShort(code, ip);
+                    ip += Bytecode.OPND_SIZE_IN_BYTES;
+                    // look up in original hierarchy not enclosing template (variable group)
+                    // see TestSubtemplates.testEvalSTFromAnotherGroup()
+                    st = self.groupThatCreatedThisInstance.getEmbeddedInstanceOf(self, ip, name);
+                    // get n args and store into st's attr list
+                    storeArgs(self, nargs, st);
+                    sp -= nargs;
+                    operands[++sp] = st;
+                    break;
+
+                case Bytecode.INSTR_NEW_IND:
+                    nargs = getShort(code, ip);
+                    ip += Bytecode.OPND_SIZE_IN_BYTES;
+                    name = (string)operands[sp - nargs];
+                    st = self.groupThatCreatedThisInstance.getEmbeddedInstanceOf(self, ip, name);
+                    storeArgs(self, nargs, st);
+                    sp -= nargs;
+                    sp--; // pop template name
+                    operands[++sp] = st;
+                    break;
+
+                case Bytecode.INSTR_NEW_BOX_ARGS:
+                    nameIndex = getShort(code, ip);
+                    ip += Bytecode.OPND_SIZE_IN_BYTES;
+                    name = self.impl.strings[nameIndex];
+                    IDictionary<string, object> attrs = (IDictionary<string, object>)operands[sp--];
+                    // look up in original hierarchy not enclosing template (variable group)
+                    // see TestSubtemplates.testEvalSTFromAnotherGroup()
+                    st = self.groupThatCreatedThisInstance.getEmbeddedInstanceOf(self, ip, name);
+                    // get n args and store into st's attr list
+                    storeArgs(self, attrs, st);
+                    operands[++sp] = st;
+                    break;
+
+                case Bytecode.INSTR_SUPER_NEW:
+                    nameIndex = getShort(code, ip);
+                    ip += Bytecode.OPND_SIZE_IN_BYTES;
+                    name = self.impl.strings[nameIndex];
+                    nargs = getShort(code, ip);
+                    ip += Bytecode.OPND_SIZE_IN_BYTES;
+                    super_new(self, name, nargs);
+                    break;
+
+                case Bytecode.INSTR_SUPER_NEW_BOX_ARGS:
+                    nameIndex = getShort(code, ip);
+                    ip += Bytecode.OPND_SIZE_IN_BYTES;
+                    name = self.impl.strings[nameIndex];
+                    attrs = (IDictionary<string, object>)operands[sp--];
+                    super_new(self, name, attrs);
+                    break;
+
+                case Bytecode.INSTR_STORE_OPTION:
+                    int optionIndex = getShort(code, ip);
+                    ip += Bytecode.OPND_SIZE_IN_BYTES;
+                    o = operands[sp--];    // value to store
+                    options = (object[])operands[sp]; // get options
+                    options[optionIndex] = o; // store value into options on stack
+                    break;
+
+                case Bytecode.INSTR_STORE_ARG:
+                    nameIndex = getShort(code, ip);
+                    name = self.impl.strings[nameIndex];
+                    ip += Bytecode.OPND_SIZE_IN_BYTES;
+                    o = operands[sp--];
+                    attrs = (IDictionary<string, object>)operands[sp];
+                    attrs[name] = o; // leave attrs on stack
+                    break;
+
+                case Bytecode.INSTR_WRITE:
+                    o = operands[sp--];
+                    int n1 = writeObjectNoOptions(@out, self, o);
+                    n += n1;
+                    nwline += n1;
+                    break;
+
+                case Bytecode.INSTR_WRITE_OPT:
+                    options = (object[])operands[sp--]; // get options
+                    o = operands[sp--];                 // get option to write
+                    int n2 = writeObjectWithOptions(@out, self, o, options);
+                    n += n2;
+                    nwline += n2;
+                    break;
+
+                case Bytecode.INSTR_MAP:
+                    st = (ST)operands[sp--]; // get prototype off stack
+                    o = operands[sp--];		 // get object to map prototype across
+                    map(self, o, st);
+                    break;
+
+                case Bytecode.INSTR_ROT_MAP:
+                    int nmaps = getShort(code, ip);
+                    ip += Bytecode.OPND_SIZE_IN_BYTES;
+                    List<ST> templates = new List<ST>();
+                    for (int i = nmaps - 1; i >= 0; i--)
+                        templates.Add((ST)operands[sp - i]);
+                    sp -= nmaps;
+                    o = operands[sp--];
+                    if (o != null)
+                        rot_map(self, o, templates);
+                    break;
+
+                case Bytecode.INSTR_ZIP_MAP:
+                    st = (ST)operands[sp--];
+                    nmaps = getShort(code, ip);
+                    ip += Bytecode.OPND_SIZE_IN_BYTES;
+                    List<object> exprs = new List<object>();
+                    for (int i = nmaps - 1; i >= 0; i--)
+                        exprs.Add(operands[sp - i]);
+
+                    sp -= nmaps;
+                    operands[++sp] = zip_map(self, exprs, st);
+                    break;
+
+                case Bytecode.INSTR_BR:
+                    ip = getShort(code, ip);
+                    break;
+
+                case Bytecode.INSTR_BRF:
+                    addr = getShort(code, ip);
+                    ip += Bytecode.OPND_SIZE_IN_BYTES;
+                    o = operands[sp--]; // <if(expr)>...<endif>
+                    if (!testAttributeTrue(o))
+                        ip = addr; // jump
+
+                    break;
+
+                case Bytecode.INSTR_OPTIONS:
+                    operands[++sp] = new object[Compiler.Compiler.NUM_OPTIONS];
+                    break;
+
+                case Bytecode.INSTR_ARGS:
+                    operands[++sp] = new Dictionary<string, object>();
+                    break;
+
+                case Bytecode.INSTR_LIST:
+                    operands[++sp] = new List<object>();
+                    break;
+
+                case Bytecode.INSTR_ADD:
+                    o = operands[sp--];             // pop value
+                    List<object> list = (List<object>)operands[sp]; // don't pop list
+                    addToList(list, o);
+                    break;
+
+                case Bytecode.INSTR_TOSTR:
+                    // replace with string value; early eval
+                    operands[sp] = toString(self, operands[sp]);
+                    break;
+
+                case Bytecode.INSTR_FIRST:
+                    operands[sp] = first(operands[sp]);
+                    break;
+
+                case Bytecode.INSTR_LAST:
+                    operands[sp] = last(operands[sp]);
+                    break;
+
+                case Bytecode.INSTR_REST:
+                    operands[sp] = rest(operands[sp]);
+                    break;
+
+                case Bytecode.INSTR_TRUNC:
+                    operands[sp] = trunc(operands[sp]);
+                    break;
+
+                case Bytecode.INSTR_STRIP:
+                    operands[sp] = strip(operands[sp]);
+                    break;
+
+                case Bytecode.INSTR_TRIM:
+                    o = operands[sp--];
+                    if (o.GetType() == typeof(string))
+                    {
+                        operands[++sp] = ((string)o).Trim();
+                    }
+                    else
+                    {
+                        errMgr.runTimeError(self, current_ip, ErrorType.EXPECTING_STRING, "trim", o.GetType());
+                        operands[++sp] = o;
+                    }
+                    break;
+
+                case Bytecode.INSTR_LENGTH:
+                    operands[sp] = length(operands[sp]);
+                    break;
+
+                case Bytecode.INSTR_STRLEN:
+                    o = operands[sp--];
+                    if (o.GetType() == typeof(string))
+                    {
+                        operands[++sp] = ((string)o).Length;
+                    }
+                    else
+                    {
+                        errMgr.runTimeError(self, current_ip, ErrorType.EXPECTING_STRING, "strlen", o.GetType());
+                        operands[++sp] = 0;
+                    }
+                    break;
+
+                case Bytecode.INSTR_REVERSE:
+                    operands[sp] = reverse(operands[sp]);
+                    break;
+
+                case Bytecode.INSTR_NOT:
+                    operands[sp] = !testAttributeTrue(operands[sp]);
+                    break;
+
+                case Bytecode.INSTR_OR:
+                    right = operands[sp--];
+                    left = operands[sp--];
+                    operands[++sp] = testAttributeTrue(left) || testAttributeTrue(right);
+                    break;
+
+                case Bytecode.INSTR_AND:
+                    right = operands[sp--];
+                    left = operands[sp--];
+                    operands[++sp] = testAttributeTrue(left) && testAttributeTrue(right);
+                    break;
+
+                case Bytecode.INSTR_INDENT:
+                    strIndex = getShort(code, ip);
+                    ip += Bytecode.OPND_SIZE_IN_BYTES;
+                    @out.pushIndentation(self.impl.strings[strIndex]);
+                    break;
+
+                case Bytecode.INSTR_DEDENT:
+                    @out.popIndentation();
+                    break;
+
+                case Bytecode.INSTR_NEWLINE:
+                    try
+                    {
+                        if (prevOpcode == Bytecode.INSTR_NEWLINE ||
+                            prevOpcode == Bytecode.INSTR_INDENT ||
+                            nwline > 0)
+                        {
+                            @out.write(Environment.NewLine);
+                        }
+                        nwline = 0;
+                    }
+                    catch (IOException ioe)
+                    {
+                        errMgr.IOError(self, ErrorType.WRITE_IO_ERROR, ioe);
+                    }
+                    break;
+
+                case Bytecode.INSTR_NOOP:
+                    break;
+
+                case Bytecode.INSTR_POP:
+                    sp--; // throw away top of stack
+                    break;
+
+                case Bytecode.INSTR_NULL:
+                    operands[++sp] = null;
+                    break;
+
+                default:
+                    errMgr.internalError(self, "invalid bytecode @ " + (ip - 1) + ": " + opcode, null);
+                    self.impl.dump();
+                    break;
+                }
+                prevOpcode = opcode;
+            }
+            if (STGroup.debug)
+            {
+                int stop = @out.index() - 1;
+                EvalTemplateEvent e = new EvalTemplateEvent((DebugST)self, start, stop);
+                //System.out.println("eval template "+self+": "+e);
+                events.Add(e);
+                if (self.enclosingInstance != null)
+                {
+                    DebugST parent = (DebugST)self.enclosingInstance;
+                    getEvents(parent).Add(e);
+                }
+            }
+            return n;
+        }
+
+        // TODO: refactor to remove dup'd code
+
+        internal virtual void super_new(ST self, string name, int nargs)
+        {
+            ST st = null;
+            CompiledST imported = self.impl.nativeGroup.lookupImportedTemplate(name);
+            if (imported == null)
+            {
+                errMgr.runTimeError(self, current_ip, ErrorType.NO_IMPORTED_TEMPLATE,
+                                    name);
+                st = self.groupThatCreatedThisInstance.createStringTemplate();
+                st.impl = new CompiledST();
+                sp -= nargs;
+                operands[++sp] = st;
+                return;
+            }
+
+            st = imported.nativeGroup.createStringTemplate();
+            st.enclosingInstance = self; // self invoked super.name()
+            st.groupThatCreatedThisInstance = group;
+            st.impl = imported;
+
+            // get n args and store into st's attr list
+            storeArgs(self, nargs, st);
+            sp -= nargs;
+            operands[++sp] = st;
+        }
+
+        internal virtual void super_new(ST self, string name, IDictionary<string, object> attrs)
+        {
+            ST st = null;
+            CompiledST imported = self.impl.nativeGroup.lookupImportedTemplate(name);
+            if (imported == null)
+            {
+                errMgr.runTimeError(self, current_ip, ErrorType.NO_IMPORTED_TEMPLATE, name);
+                st = self.groupThatCreatedThisInstance.createStringTemplate();
+                st.impl = new CompiledST();
+                operands[++sp] = st;
+                return;
+            }
+
+            st = imported.nativeGroup.createStringTemplate();
+            st.enclosingInstance = self; // self invoked super.name()
+            st.groupThatCreatedThisInstance = group;
+            st.impl = imported;
+
+            // get n args and store into st's attr list
+            storeArgs(self, attrs, st);
+            operands[++sp] = st;
+        }
+
+        internal virtual void storeArgs(ST self, IDictionary<string, object> attrs, ST st)
+        {
+            int nformalArgs = 0;
+            if (st.impl.formalArguments != null)
+                nformalArgs = st.impl.formalArguments.Count;
+            int nargs = 0;
+            if (attrs != null)
+                nargs = attrs.Count;
+
+            if (nargs < (nformalArgs - st.impl.getNumberOfArgsWithDefaultValues()) || nargs > nformalArgs)
+            {
+                errMgr.runTimeError(self,
+                                    current_ip,
+                                    ErrorType.ARGUMENT_COUNT_MISMATCH,
+                                    nargs,
+                                    st.impl.name,
+                                    nformalArgs);
+            }
+
+            foreach (string argName in attrs.Keys)
+            {
+                // don't let it throw an exception in rawSetAttribute
+                if (!st.impl.formalArguments.ContainsKey(argName))
+                {
+                    errMgr.runTimeError(self, current_ip, ErrorType.NO_SUCH_ATTRIBUTE, argName);
+                    continue;
+                }
+
+                object o = attrs[argName];
+                st.rawSetAttribute(argName, o);
+            }
+        }
+
+        internal virtual void storeArgs(ST self, int nargs, ST st)
+        {
+            int nformalArgs = 0;
+            if (st.impl.formalArguments != null)
+                nformalArgs = st.impl.formalArguments.Count;
+            int firstArg = sp - (nargs - 1);
+            int numToStore = Math.Min(nargs, nformalArgs);
+            if (st.impl.isAnonSubtemplate)
+                nformalArgs -= predefinedAnonSubtemplateAttributes.Count;
+
+            if (nargs < (nformalArgs - st.impl.getNumberOfArgsWithDefaultValues()) ||
+                 nargs > nformalArgs)
+            {
+                errMgr.runTimeError(self,
+                                    current_ip,
+                                    ErrorType.ARGUMENT_COUNT_MISMATCH,
+                                    nargs,
+                                    st.impl.name,
+                                    nformalArgs);
+            }
+
+            if (st.impl.formalArguments == null)
+                return;
+
+            Iterator argNames = st.impl.formalArguments.Keys.iterator();
+            for (int i = 0; i < numToStore; i++)
+            {
+                // value to store
+                object o = operands[firstArg + i];
+                string argName = (string)argNames.next();
+                st.rawSetAttribute(argName, o);
+            }
+        }
+
+        /** Write out an expression result that doesn't use expression options.
+         *  E.g., <name>
+         */
+        protected virtual int writeObjectNoOptions(STWriter @out, ST self, object o)
+        {
+            int start = @out.index(); // track char we're about to write
+            int n = writeObject(@out, self, o, null);
+            if (STGroup.debug)
+            {
+                Interval templateLocation = self.impl.sourceMap[current_ip];
+                int exprStart = -1;
+                int exprStop = -1;
+                if (templateLocation != null)
+                {
+                    exprStart = templateLocation.A;
+                    exprStop = templateLocation.B;
+                }
+
+                EvalExprEvent e = new EvalExprEvent((DebugST)self, start, @out.index() - 1, exprStart, exprStop);
+                Console.WriteLine(e);
+                events.Add(e);
+            }
+            return n;
+        }
+
+        /** Write out an expression result that uses expression options.
+         *  E.g., <names; separator=", ">
+         */
+        protected virtual int writeObjectWithOptions(STWriter @out, ST self, object o,
+                                             object[] options)
+        {
+            int start = @out.index(); // track char we're about to write
+            // precompute all option values (render all the way to strings)
+            string[] optionStrings = null;
+            if (options != null)
+            {
+                optionStrings = new string[options.Length];
+                for (int i = 0; i < Compiler.Compiler.NUM_OPTIONS; i++)
+                {
+                    optionStrings[i] = toString(self, options[i]);
+                }
+            }
+            if (options != null && options[(int)Option.ANCHOR] != null)
+            {
+                @out.pushAnchorPoint();
+            }
+
+            int n = writeObject(@out, self, o, optionStrings);
+
+            if (options != null && options[(int)Option.ANCHOR] != null)
+            {
+                @out.popAnchorPoint();
+            }
+            if (STGroup.debug)
+            {
+                Interval templateLocation = self.impl.sourceMap[current_ip];
+                int exprStart = templateLocation.A, exprStop = templateLocation.B;
+                EvalExprEvent e = new EvalExprEvent((DebugST)self,
+                                                    start, @out.index() - 1,
+                                                    exprStart, exprStop);
+                Console.WriteLine(e);
+                events.Add(e);
+            }
+            return n;
+        }
+
+        /** Generic method to emit text for an object. It differentiates
+         *  between templates, iterable objects, and plain old Java objects (POJOs)
+         */
+        protected virtual int writeObject(STWriter @out, ST self, object o, string[] options)
+        {
+            int n = 0;
+            if (o == null)
+            {
+                if (options != null && options[(int)Option.NULL] != null)
+                {
+                    o = options[(int)Option.NULL];
+                }
+                else
+                    return 0;
+            }
+            if (o is ST)
+            {
+                ((ST)o).enclosingInstance = self;
+                setDefaultArguments((ST)o);
+                if (options != null && options[(int)Option.WRAP] != null)
+                {
+                    // if we have a wrap string, then inform writer it
+                    // might need to wrap
+                    try
+                    {
+                        @out.writeWrap(options[(int)Option.WRAP]);
+                    }
+                    catch (IOException ioe)
+                    {
+                        errMgr.IOError(self, ErrorType.WRITE_IO_ERROR, ioe);
+                    }
+                }
+                n = exec(@out, (ST)o);
+            }
+            else
+            {
+                o = convertAnythingIteratableToIterator(o); // normalize
+                try
+                {
+                    if (o is Iterator)
+                        n = writeIterator(@out, self, o, options);
+                    else
+                        n = writePOJO(@out, o, options);
+                }
+                catch (IOException ioe)
+                {
+                    errMgr.IOError(self, ErrorType.WRITE_IO_ERROR, ioe, o);
+                }
+            }
+            return n;
+        }
+
+        protected virtual int writeIterator(STWriter @out, ST self, object o, string[] options)
+        {
+            if (o == null)
+                return 0;
+            int n = 0;
+            Iterator it = (Iterator)o;
+            string separator = null;
+            if (options != null)
+                separator = options[(int)Option.SEPARATOR];
+            bool seenAValue = false;
+            while (it.hasNext())
+            {
+                object iterValue = it.next();
+                // Emit separator if we're beyond first value
+                bool needSeparator = seenAValue &&
+                    separator != null &&            // we have a separator and
+                    (iterValue != null ||           // either we have a value
+                        options[(int)Option.NULL] != null); // or no value but null option
+                if (needSeparator)
+                    n += @out.writeSeparator(separator);
+                int nw = writeObject(@out, self, iterValue, options);
+                if (nw > 0)
+                    seenAValue = true;
+                n += nw;
+            }
+            return n;
+        }
+
+        protected virtual int writePOJO(STWriter @out, object o, string[] options)
+        {
+            string formatString = null;
+            if (options != null)
+                formatString = options[(int)Option.FORMAT];
+            AttributeRenderer r = group.getAttributeRenderer(o.GetType());
+            string v;
+            if (r != null)
+                v = r.toString(o, formatString, locale);
+            else
+                v = o.ToString();
+            int n;
+            if (options != null && options[(int)Option.WRAP] != null)
+            {
+                n = @out.write(v, options[(int)Option.WRAP]);
+            }
+            else
+            {
+                n = @out.write(v);
+            }
+            return n;
+        }
+
+        protected virtual void map(ST self, object attr, ST st)
+        {
+            rot_map(self, attr, new List<ST>() { st });
+        }
+
+        // <names:a> or <names:a,b>
+        protected virtual void rot_map(ST self, object attr, List<ST> prototypes)
+        {
+            if (attr == null)
+            {
+                operands[++sp] = null;
+                return;
+            }
+            attr = convertAnythingIteratableToIterator(attr);
+            if (attr is Iterator)
+            {
+                List<ST> mapped = new List<ST>();
+                Iterator iter = (Iterator)attr;
+                int i0 = 0;
+                int i = 1;
+                int ti = 0;
+                while (iter.hasNext())
+                {
+                    object iterValue = iter.next();
+                    if (iterValue == null)
+                    {
+                        mapped.Add(null);
+                        continue;
+                    }
+
+                    int templateIndex = ti % prototypes.Count; // rotate through
+                    ti++;
+                    ST proto = prototypes[templateIndex];
+                    ST st = group.createStringTemplate(proto);
+                    setFirstArgument(self, st, iterValue);
+                    if (st.impl.isAnonSubtemplate)
+                    {
+                        st.rawSetAttribute("i0", i0);
+                        st.rawSetAttribute("i", i);
+                    }
+                    mapped.Add(st);
+                    i0++;
+                    i++;
+                }
+                operands[++sp] = mapped;
+            }
+            else
+            { // if only single value, just apply first template to sole value
+                ST proto = prototypes[0];
+                ST st = group.createStringTemplate(proto);
+                if (st != null)
+                {
+                    setFirstArgument(self, st, attr);
+                    if (st.impl.isAnonSubtemplate)
+                    {
+                        st.rawSetAttribute("i0", 0);
+                        st.rawSetAttribute("i", 1);
+                    }
+                    operands[++sp] = st;
+                }
+                else
+                {
+                    operands[++sp] = null;
+                }
+            }
+        }
+
+        // <names,phones:{n,p | ...}> or <a,b:t()>
+        // todo: i, i0 not set unless mentioned? map:{k,v | ..}?
+        protected virtual ST.AttributeList zip_map(ST self, List<object> exprs, ST prototype)
+        {
+            if (exprs == null || prototype == null || exprs.Count == 0)
+            {
+                return null; // do not apply if missing templates or empty values
+            }
+            // make everything iterable
+            for (int i = 0; i < exprs.Count; i++)
+            {
+                object attr = exprs[i];
+                if (attr != null)
+                    exprs[i] = convertAnythingToIterator(attr);
+            }
+
+            // ensure arguments line up
+            int numExprs = exprs.Count;
+            CompiledST code = prototype.impl;
+            IDictionary<string, FormalArgument> formalArguments = code.formalArguments;
+            if (!code.hasFormalArgs || formalArguments == null)
+            {
+                errMgr.runTimeError(self, current_ip, ErrorType.MISSING_FORMAL_ARGUMENTS);
+                return null;
+            }
+
+            // todo: track formal args not names for efficient filling of locals
+            object[] formalArgumentNames = formalArguments.Keys.ToArray();
+            int nformalArgs = formalArgumentNames.Length;
+            if (prototype.isAnonSubtemplate())
+                nformalArgs -= predefinedAnonSubtemplateAttributes.Count;
+
+            if (nformalArgs != numExprs)
+            {
+                errMgr.runTimeError(self, current_ip, ErrorType.MAP_ARGUMENT_COUNT_MISMATCH, numExprs, nformalArgs);
+                // TODO just fill first n
+                // truncate arg list to match smaller size
+                int shorterSize = Math.Min(formalArgumentNames.Length, numExprs);
+                numExprs = shorterSize;
+                object[] newFormalArgumentNames = new object[shorterSize];
+                Array.Copy(formalArgumentNames, 0, newFormalArgumentNames, 0, shorterSize);
+                formalArgumentNames = newFormalArgumentNames;
+            }
+
+            // keep walking while at least one attribute has values
+
+            ST.AttributeList results = new ST.AttributeList();
+            int i2 = 0; // iteration number from 0
+            while (true)
+            {
+                // get a value for each attribute in list; put into ST instance
+                int numEmpty = 0;
+                ST embedded = group.createStringTemplate(prototype);
+                embedded.rawSetAttribute("i0", i2);
+                embedded.rawSetAttribute("i", i2 + 1);
+                for (int a = 0; a < numExprs; a++)
+                {
+                    Iterator it = (Iterator)exprs[a];
+                    if (it != null && it.hasNext())
+                    {
+                        string argName = (string)formalArgumentNames[a];
+                        object iteratedValue = it.next();
+                        embedded.rawSetAttribute(argName, iteratedValue);
+                    }
+                    else
+                    {
+                        numEmpty++;
+                    }
+                }
+
+                if (numEmpty == numExprs)
+                    break;
+
+                results.Add(embedded);
+                i2++;
+            }
+            return results;
+        }
+
+        protected virtual void setFirstArgument(ST self, ST st, object attr)
+        {
+            if (st.impl.formalArguments == null)
+            {
+                errMgr.runTimeError(self, current_ip, ErrorType.ARGUMENT_COUNT_MISMATCH, 1, st.impl.name, 0);
+                return;
+            }
+
+            st.locals[0] = attr;
+        }
+
+        protected virtual void addToList(List<object> list, object o)
+        {
+            o = Interpreter.convertAnythingIteratableToIterator(o);
+            if (o is Iterator)
+            {
+                // copy of elements into our temp list
+                Iterator it = (Iterator)o;
+                while (it.hasNext())
+                    list.Add(it.next());
+            }
+            else
+            {
+                list.Add(o);
+            }
+        }
+
+        /** Return the first attribute if multiple valued or the attribute
+         *  itself if single-valued.  Used in <names:first()>
+         */
+        public virtual object first(object v)
+        {
+            if (v == null)
+                return null;
+            object r = v;
+            v = convertAnythingIteratableToIterator(v);
+            if (v is Iterator)
+            {
+                Iterator it = (Iterator)v;
+                if (it.hasNext())
+                {
+                    r = it.next();
+                }
+            }
+            return r;
+        }
+
+        /** Return the last attribute if multiple valued or the attribute
+         *  itself if single-valued. Unless it's a list or array, this is pretty
+         *  slow as it iterates until the last element.
+         */
+        public virtual object last(object v)
+        {
+            if (v == null)
+                return null;
+
+            IList list = v as IList;
+            if (list != null)
+                return list[list.Count - 1];
+
+            object last = v;
+            v = convertAnythingIteratableToIterator(v);
+            Iterator it = v as Iterator;
+            if (it != null)
+            {
+                while (it.hasNext())
+                    last = it.next();
+            }
+
+            return last;
+        }
+
+        /** Return everything but the first attribute if multiple valued
+         *  or null if single-valued.
+         */
+        public virtual object rest(object v)
+        {
+            if (v == null)
+                return null;
+
+            v = convertAnythingIteratableToIterator(v);
+            Iterator it = v as Iterator;
+            if (it != null)
+            {
+                if (!it.hasNext())
+                    return null; // if not even one value return null
+
+                List<object> a = new List<object>();
+                it.next(); // ignore first value
+                while (it.hasNext())
+                {
+                    object o = it.next();
+                    if (o != null)
+                        a.Add(o);
+                }
+
+                return a;
+            }
+
+            // rest of single-valued attribute is null
+            return null;
+        }
+
+        /** Return all but the last element.  trunc(x)=null if x is single-valued. */
+        public virtual object trunc(object v)
+        {
+            if (v == null)
+                return null;
+
+            v = convertAnythingIteratableToIterator(v);
+            if (v is Iterator)
+            {
+                List<object> a = new List<object>();
+                Iterator it = (Iterator)v;
+                while (it.hasNext())
+                {
+                    object o = it.next();
+                    if (it.hasNext())
+                        a.Add(o); // only add if not last one
+                }
+
+                return a;
+            }
+
+            // trunc(x)==null when x single-valued attribute
+            return null;
+        }
+
+        /** Return a new list w/o null values. */
+        public virtual object strip(object v)
+        {
+            if (v == null)
+                return null;
+
+            v = convertAnythingIteratableToIterator(v);
+            if (v is Iterator)
+            {
+                List<object> a = new List<object>();
+                Iterator it = (Iterator)v;
+                while (it.hasNext())
+                {
+                    object o = it.next();
+                    if (o != null)
+                        a.Add(o);
+                }
+
+                return a;
+            }
+
+            return v; // strip(x)==x when x single-valued attribute
+        }
+
+        /** Return a list with the same elements as v but in reverse order. null
+         *  values are NOT stripped out. use reverse(strip(v)) to do that.
+         */
+        public virtual object reverse(object v)
+        {
+            if (v == null)
+                return null;
+
+            v = convertAnythingIteratableToIterator(v);
+            Iterator it = v as Iterator;
+            if (it != null)
+            {
+                List<object> a = new List<object>();
+                while (it.hasNext())
+                    a.Add(it.next());
+
+                a.Reverse();
+                return a;
+            }
+
+            return v;
+        }
+
+        /** Return the length of a mult-valued attribute or 1 if it is a
+         *  single attribute. If attribute is null return 0.
+         *  Special case several common collections and primitive arrays for
+         *  speed. This method by Kay Roepke from v3.
+         */
+        public virtual object length(object v)
+        {
+            if (v == null)
+                return 0;
+
+            string str = v as string;
+            if (str != null)
+                return 1;
+
+            ICollection collection = v as ICollection;
+            if (collection != null)
+                return collection.Count;
+
+            IDictionary dictionary = v as IDictionary;
+            if (dictionary != null)
+                return dictionary.Count;
+
+            IEnumerable enumerable = v as IEnumerable;
+            if (enumerable != null)
+                return enumerable.Cast<object>().Count();
+
+            Iterator iterator = v as Iterator;
+            if (iterator != null)
+            {
+                int i = 0;
+                while (iterator.hasNext())
+                {
+                    iterator.next();
+                    i++;
+                }
+                return i;
+            }
+
+            return 1;
+        }
+
+        protected virtual string toString(ST self, object value)
+        {
+            if (value != null)
+            {
+                if (value.GetType() == typeof(string))
+                    return (string)value;
+                // if ST, make sure it evaluates with enclosing template as self
+                if (value is ST)
+                    ((ST)value).enclosingInstance = self;
+                // if not string already, must evaluate it
+                StringWriter sw = new StringWriter();
+                /*
+                            Interpreter interp = new Interpreter(group, new NoIndentWriter(sw), locale);
+                            interp.writeObjectNoOptions(self, value, -1, -1);
+                            */
+                writeObjectNoOptions(new NoIndentWriter(sw), self, value);
+
+                return sw.ToString();
+            }
+            return null;
+        }
+
+        public static object convertAnythingIteratableToIterator(object o)
+        {
+            if (o == null)
+                return null;
+
+            string str = o as string;
+            if (str != null)
+                return str;
+
+            IDictionary dictionary = o as IDictionary;
+            if (dictionary != null)
+                return dictionary.Keys.iterator();
+
+            ICollection collection = o as ICollection;
+            if (collection != null)
+                return collection.iterator();
+
+            IEnumerable enumerable = o as IEnumerable;
+            if (enumerable != null)
+                return enumerable.Cast<object>().iterator();
+
+            //// This code is implied in the last line
+            //Iterator iterator = o as Iterator;
+            //if ( iterator != null )
+            //    return iterator;
+
+            return o;
+        }
+
+        public static Iterator convertAnythingToIterator(object o)
+        {
+            o = convertAnythingIteratableToIterator(o);
+
+            Iterator iter = o as Iterator;
+            if (iter != null)
+                return iter;
+
+            ST.AttributeList singleton = new ST.AttributeList(1);
+            singleton.Add(o);
+            return singleton.iterator();
+        }
+
+        protected virtual bool testAttributeTrue(object a)
+        {
+            if (a == null)
+                return false;
+
+            if (a is bool)
+                return (bool)a;
+
+            string str = a as string;
+            if (str != null)
+                return true;
+
+            ICollection collection = a as ICollection;
+            if (collection != null)
+                return collection.Count > 0;
+
+            IDictionary dictionary = a as IDictionary;
+            if (dictionary != null)
+                return dictionary.Count > 0;
+
+            IEnumerable enumerable = a as IEnumerable;
+            if (enumerable != null)
+                return enumerable.Cast<object>().Any();
+
+            Iterator iterator = a as Iterator;
+            if (iterator != null)
+                return iterator.hasNext();
+
+            // any other non-null object, return true--it's present
+            return true;
+        }
+
+        protected virtual object getObjectProperty(ST self, object o, object property)
+        {
+            if (o == null)
+            {
+                errMgr.runTimeError(self, current_ip, ErrorType.NO_SUCH_PROPERTY,
+                                          "null attribute");
+                return null;
+            }
+
+            try
+            {
+                ModelAdaptor adap = self.groupThatCreatedThisInstance.getModelAdaptor(o.GetType());
+                return adap.getProperty(self, o, property, toString(self, property));
+            }
+            catch (STNoSuchPropertyException e)
+            {
+                errMgr.runTimeError(self, current_ip, ErrorType.NO_SUCH_PROPERTY,
+                                          e, o.GetType().Name + "." + property);
+            }
+            return null;
+        }
+
+        /** Set any default argument values that were not set by the
+         *  invoking template or by setAttribute directly.  Note
+         *  that the default values may be templates.
+         *
+         *  The evaluation context is the template enclosing invokedST.
+         */
+        public virtual void setDefaultArguments(ST invokedST)
+        {
+            if (invokedST.impl.formalArguments == null)
+                return;
+            foreach (FormalArgument arg in invokedST.impl.formalArguments.Values)
+            {
+                // if no value for attribute and default arg, inject default arg into self
+                if (invokedST.locals[arg.index] == ST.EMPTY_ATTR && arg.compiledDefaultValue != null)
+                {
+                    ST defaultArgST = group.createStringTemplate();
+                    defaultArgST.enclosingInstance = invokedST.enclosingInstance;
+                    defaultArgST.groupThatCreatedThisInstance = group;
+                    defaultArgST.impl = arg.compiledDefaultValue;
+                    Console.WriteLine("setting def arg " + arg.name + " to " + defaultArgST);
+                    // If default arg is template with single expression
+                    // wrapped in parens, x={<(...)>}, then eval to string
+                    // rather than setting x to the template for later
+                    // eval.
+                    string defArgTemplate = arg.defaultValueToken.Text;
+                    if (defArgTemplate.StartsWith("{<(") && defArgTemplate.EndsWith(")>}"))
+                    {
+                        invokedST.rawSetAttribute(arg.name, toString(invokedST, defaultArgST));
+                    }
+                    else
+                    {
+                        invokedST.rawSetAttribute(arg.name, defaultArgST);
+                    }
+                }
+            }
+        }
+
+        protected virtual void Trace(ST self, int ip)
+        {
+            StringBuilder tr = new StringBuilder();
+            BytecodeDisassembler dis = new BytecodeDisassembler(self.impl);
+            StringBuilder buf = new StringBuilder();
+            dis.disassembleInstruction(buf, ip);
+            string name = self.impl.name + ":";
+            if (self.impl.name == ST.UNKNOWN_NAME)
+                name = "";
+
+            tr.Append(string.Format("{0,-40}", name + buf));
+            tr.Append("\tstack=[");
+            for (int i = 0; i <= sp; i++)
+            {
+                object o = operands[i];
+                printForTrace(tr, o);
+            }
+
+            tr.Append(" ], calls=");
+            tr.Append(self.getEnclosingInstanceStackString());
+            tr.Append(", sp=" + sp + ", nw=" + nwline);
+            string s = tr.ToString();
+
+            if (STGroup.debug)
+                executeTrace.Add(s);
+
+            if (trace)
+                Console.WriteLine(s);
+        }
+
+        protected virtual void printForTrace(StringBuilder tr, object o)
+        {
+            if (o is ST)
+            {
+                if (((ST)o).impl == null)
+                    tr.Append("bad-template()");
+                else
+                    tr.Append(" " + ((ST)o).impl.name + "()");
+                return;
+            }
+            o = convertAnythingIteratableToIterator(o);
+            if (o is Iterator)
+            {
+                Iterator it = (Iterator)o;
+                tr.Append(" [");
+                while (it.hasNext())
+                {
+                    object iterValue = it.next();
+                    printForTrace(tr, iterValue);
+                }
+                tr.Append(" ]");
+            }
+            else
+            {
+                tr.Append(" " + o);
+            }
+        }
+
+        public virtual List<InterpEvent> getEvents()
+        {
+            return events;
+        }
+
+        public virtual List<InterpEvent> getEvents(ST st)
+        {
+            if (debugInfo.get(st) == null)
+                debugInfo[st] = new List<InterpEvent>();
+
+            return debugInfo.get(st);
+        }
+
+        public virtual List<string> getExecutionTrace()
+        {
+            return executeTrace;
+        }
+
+        public static int getShort(byte[] memory, int index)
+        {
+            int b1 = memory[index] & 0xFF; // mask off sign-extended bits
+            int b2 = memory[index + 1] & 0xFF;
+            return b1 << (8 * 1) | b2;
+        }
+
+    }
+}
diff --git a/Antlr4.StringTemplate/Misc/Coordinate.cs b/Antlr4.StringTemplate/Misc/Coordinate.cs
new file mode 100644
index 0000000..18a91d0
--- /dev/null
+++ b/Antlr4.StringTemplate/Misc/Coordinate.cs
@@ -0,0 +1,73 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Misc
+{
+    using System.Diagnostics;
+
+    /** A line number and char position within a line.  Used by the source
+     *  mapping stuff to map address to range within a template.
+     */
+    [DebuggerDisplay("({_line},{_charPosition})")]
+    public struct Coordinate
+    {
+        private readonly int _line;
+        private readonly int _charPosition;
+
+        public Coordinate(int line, int charPosition)
+        {
+            this._line = line;
+            this._charPosition = charPosition;
+        }
+
+        public int Line
+        {
+            get
+            {
+                return _line;
+            }
+        }
+
+        public int CharPosition
+        {
+            get
+            {
+                return _charPosition;
+            }
+        }
+
+        public override string ToString()
+        {
+            return _line + ":" + _charPosition;
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Misc/ErrorBuffer.cs b/Antlr4.StringTemplate/Misc/ErrorBuffer.cs
new file mode 100644
index 0000000..6f2a64f
--- /dev/null
+++ b/Antlr4.StringTemplate/Misc/ErrorBuffer.cs
@@ -0,0 +1,92 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Misc
+{
+    using System.Collections.Generic;
+    using Environment = System.Environment;
+    using StringBuilder = System.Text.StringBuilder;
+    using System.Collections.ObjectModel;
+
+    /** Used during tests to track all errors */
+    public class ErrorBuffer : STErrorListener
+    {
+        private readonly List<STMessage> errors = new List<STMessage>();
+
+        public ReadOnlyCollection<STMessage> Errors
+        {
+            get
+            {
+                return errors.AsReadOnly();
+            }
+        }
+
+        protected List<STMessage> ErrorList
+        {
+            get
+            {
+                return errors;
+            }
+        }
+
+        public virtual void compileTimeError(STMessage msg)
+        {
+            errors.Add(msg);
+        }
+
+        public virtual void runTimeError(STMessage msg)
+        {
+            // ignore these
+            if (msg.Error != ErrorType.NO_SUCH_PROPERTY)
+                errors.Add(msg);
+        }
+
+        public virtual void IOError(STMessage msg)
+        {
+            errors.Add(msg);
+        }
+
+        public virtual void internalError(STMessage msg)
+        {
+            errors.Add(msg);
+        }
+
+        public override string ToString()
+        {
+            StringBuilder buf = new StringBuilder();
+            foreach (STMessage m in errors)
+                buf.AppendLine(m.ToString());
+
+            return buf.ToString();
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Misc/ErrorManager.cs b/Antlr4.StringTemplate/Misc/ErrorManager.cs
new file mode 100644
index 0000000..b05c1f5
--- /dev/null
+++ b/Antlr4.StringTemplate/Misc/ErrorManager.cs
@@ -0,0 +1,204 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Misc
+{
+    using Antlr.Runtime;
+    using Exception = System.Exception;
+    using Path = System.IO.Path;
+    using Console = System.Console;
+
+    /** Track errors per thread; e.g., one server transaction's errors
+     *  will go in one grouping since each has it's own thread.
+     */
+    public class ErrorManager
+    {
+        public static STErrorListener DEFAULT_ERROR_LISTENER = new DefaultErrorListener();
+
+        private class DefaultErrorListener : STErrorListener
+        {
+            public virtual void compileTimeError(STMessage msg)
+            {
+                Console.Error.WriteLine(msg);
+            }
+
+            public virtual void runTimeError(STMessage msg)
+            {
+                if (msg.Error != ErrorType.NO_SUCH_PROPERTY)
+                { // ignore these
+                    Console.Error.WriteLine(msg);
+                }
+            }
+
+            public virtual void IOError(STMessage msg)
+            {
+                Console.Error.WriteLine(msg);
+            }
+
+            public virtual void internalError(STMessage msg)
+            {
+                Console.Error.WriteLine(msg);
+                // throw new Error("internal error", msg.cause);
+            }
+
+            public virtual void error(string s)
+            {
+                error(s, null);
+            }
+
+            public virtual void error(string s, Exception e)
+            {
+                Console.Error.WriteLine(s);
+                if (e != null)
+                    Console.Error.WriteLine(e.StackTrace);
+            }
+        }
+
+        /** As we parse group file, there is no embedded context.
+         *  We read entire templates (e.g., <<...>>) as single
+         *  tokens and so errors can use the line/charPos of the
+         *  GroupLexer.  To parse templates during CodeGenerator pass,
+         *  we must assume templates start at charPos=0 even when they
+         *  start in middle of line:
+         *
+         *  t() ::= <<foo>>
+         *
+         *  Here, the template starts at charPos 10, but the STLexer
+         *  thinks that the charPos is 0.  If we want to get correct
+         *  error info, we push the template token onto the context
+         *  stack and then all errors are relative to that.  Should
+         *  only be 0 or 1 deep, but it's general.
+         */
+        //public Stack<Token> context = new Stack<Token>();
+
+        private readonly STErrorListener listener;
+
+        public ErrorManager()
+            : this(DEFAULT_ERROR_LISTENER)
+        {
+        }
+
+        public ErrorManager(STErrorListener listener)
+        {
+            this.listener = listener;
+        }
+
+        public STErrorListener Listener
+        {
+            get
+            {
+                return listener;
+            }
+        }
+
+        public virtual void compileTimeError(ErrorType error, IToken templateToken, IToken t)
+        {
+            string srcName = t.InputStream.SourceName;
+            if (srcName != null)
+                srcName = Path.GetFileName(srcName);
+
+            listener.compileTimeError(new STCompiletimeMessage(error, srcName, templateToken, t, null, t.Text));
+        }
+
+        public virtual void lexerError(string srcName, string msg, IToken templateToken, RecognitionException e)
+        {
+            listener.compileTimeError(new STLexerMessage(srcName, msg, templateToken, e));
+        }
+
+        public virtual void compileTimeError(ErrorType error, IToken templateToken, IToken t, object arg)
+        {
+            string srcName = t.InputStream.SourceName;
+            srcName = Path.GetFileName(srcName);
+            listener.compileTimeError(new STCompiletimeMessage(error, srcName, templateToken, t, null, arg));
+        }
+
+        public virtual void compileTimeError(ErrorType error, IToken templateToken, IToken t, object arg, object arg2)
+        {
+            string srcName = t.InputStream.SourceName;
+            if (srcName != null)
+                srcName = Path.GetFileName(srcName);
+
+            listener.compileTimeError(new STCompiletimeMessage(error, srcName, templateToken, t, null, arg, arg2));
+        }
+
+        public virtual void groupSyntaxError(ErrorType error, string srcName, RecognitionException e, string msg)
+        {
+            IToken t = e.Token;
+            listener.compileTimeError(new STGroupCompiletimeMessage(error, srcName, e.Token, e, msg));
+        }
+
+        public virtual void groupLexerError(ErrorType error, string srcName, RecognitionException e, string msg)
+        {
+            listener.compileTimeError(new STGroupCompiletimeMessage(error, srcName, e.Token, e, msg));
+        }
+
+        public virtual void runTimeError(ST self, int ip, ErrorType error)
+        {
+            listener.runTimeError(new STRuntimeMessage(error, ip, self));
+        }
+
+        public virtual void runTimeError(ST self, int ip, ErrorType error, object arg)
+        {
+            listener.runTimeError(new STRuntimeMessage(error, ip, self, arg));
+        }
+
+        public virtual void runTimeError(ST self, int ip, ErrorType error, Exception e, object arg)
+        {
+            listener.runTimeError(new STRuntimeMessage(error, ip, self, e, arg));
+        }
+
+        public virtual void runTimeError(ST self, int ip, ErrorType error, object arg, object arg2)
+        {
+            listener.runTimeError(new STRuntimeMessage(error, ip, self, null, arg, arg2));
+        }
+
+        public virtual void runTimeError(ST self, int ip, ErrorType error, object arg, object arg2, object arg3)
+        {
+            listener.runTimeError(new STRuntimeMessage(error, ip, self, null, arg, arg2, arg3));
+        }
+
+        public virtual void IOError(ST self, ErrorType error, Exception e)
+        {
+            listener.IOError(new STMessage(error, self, e));
+        }
+
+        public virtual void IOError(ST self, ErrorType error, Exception e, object arg)
+        {
+            listener.IOError(new STMessage(error, self, e, arg));
+        }
+
+        public virtual void internalError(ST self, string msg, Exception e)
+        {
+            listener.internalError(new STMessage(ErrorType.INTERNAL_ERROR, self, e, msg));
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Misc/ErrorType.cs b/Antlr4.StringTemplate/Misc/ErrorType.cs
new file mode 100644
index 0000000..cf9c1f1
--- /dev/null
+++ b/Antlr4.StringTemplate/Misc/ErrorType.cs
@@ -0,0 +1,85 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Misc
+{
+    /** All the errors that can happen and how to generate a message */
+    public sealed class ErrorType
+    {
+        // RUNTIME SEMANTIC ERRORS
+        public static readonly ErrorType NO_SUCH_TEMPLATE = new ErrorType("no such template: {0}");
+        public static readonly ErrorType CANT_SET_ATTRIBUTE = new ErrorType("can't set attribute {0}; template {1} has no such attribute");
+        public static readonly ErrorType NO_IMPORTED_TEMPLATE = new ErrorType("no such template: super.{0}");
+        public static readonly ErrorType NO_SUCH_ATTRIBUTE = new ErrorType("attribute {0} isn't defined");
+        public static readonly ErrorType MISSING_FORMAL_ARGUMENTS = new ErrorType("missing argument definitions");
+        public static readonly ErrorType NO_SUCH_PROPERTY = new ErrorType("no such property or can't access: {0}");
+        public static readonly ErrorType MAP_ARGUMENT_COUNT_MISMATCH = new ErrorType("iterating through {0} values in zip map but template has {1} declared arguments");
+        public static readonly ErrorType ARGUMENT_COUNT_MISMATCH = new ErrorType("passed {0} arg(s) to template {1} with {2} declared arg(s)");
+        public static readonly ErrorType EXPECTING_STRING = new ErrorType("function {0} expects a string not {1}");
+
+        // COMPILE-TIME SYNTAX/SEMANTIC ERRORS
+        public static readonly ErrorType SYNTAX_ERROR = new ErrorType("{0}");
+        public static readonly ErrorType TEMPLATE_REDEFINITION = new ErrorType("redefinition of template {0}");
+        public static readonly ErrorType EMBEDDED_REGION_REDEFINITION = new ErrorType("region {0} is embedded and thus already implicitly defined");
+        public static readonly ErrorType REGION_REDEFINITION = new ErrorType("redefinition of region {0}");
+        public static readonly ErrorType MAP_REDEFINITION = new ErrorType("redefinition of dictionary {0}");
+        public static readonly ErrorType ALIAS_TARGET_UNDEFINED = new ErrorType("cannot alias {0} to undefined template: {1}");
+        public static readonly ErrorType TEMPLATE_REDEFINITION_AS_MAP = new ErrorType("redefinition of template {0} as a map");
+        public static readonly ErrorType LEXER_ERROR = new ErrorType("{0}");
+        public static readonly ErrorType NO_DEFAULT_VALUE = new ErrorType("missing dictionary default value");
+        public static readonly ErrorType NO_SUCH_FUNCTION = new ErrorType("no such function: {0}");
+        public static readonly ErrorType NO_SUCH_REGION = new ErrorType("template {0} doesn't have a region called {1}");
+        public static readonly ErrorType NO_SUCH_OPTION = new ErrorType("no such option: {0}");
+        public static readonly ErrorType INVALID_TEMPLATE_NAME = new ErrorType("invalid template name or path: {0}");
+        public static readonly ErrorType ANON_ARGUMENT_MISMATCH = new ErrorType("anonymous template has {0} arg(s) but mapped across {1} value(s)");
+
+        // INTERNAL ERRORS
+        public static readonly ErrorType INTERNAL_ERROR = new ErrorType("{0}");
+        public static readonly ErrorType WRITE_IO_ERROR = new ErrorType("error writing output caused by");
+        public static readonly ErrorType CANT_LOAD_GROUP_FILE = new ErrorType("can't load group file {0}");
+
+        private readonly string _message;
+
+        private ErrorType(string m)
+        {
+            _message = m;
+        }
+
+        public string Message
+        {
+            get
+            {
+                return _message;
+            }
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Misc/Interval.cs b/Antlr4.StringTemplate/Misc/Interval.cs
new file mode 100644
index 0000000..49efd3e
--- /dev/null
+++ b/Antlr4.StringTemplate/Misc/Interval.cs
@@ -0,0 +1,73 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Misc
+{
+    using System.Diagnostics;
+
+    /** An inclusive interval a..b.  Used to track ranges in output and
+     *  template patterns (for debugging).
+     */
+    [DebuggerDisplay("[{_a}..{_b}]")]
+    public sealed class Interval
+    {
+        private readonly int _a;
+        private readonly int _b;
+
+        public Interval(int a, int b)
+        {
+            this._a = a;
+            this._b = b;
+        }
+
+        public int A
+        {
+            get
+            {
+                return _a;
+            }
+        }
+
+        public int B
+        {
+            get
+            {
+                return _b;
+            }
+        }
+
+        public override string ToString()
+        {
+            return _a + ".." + _b;
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Misc/MapModelAdaptor.cs b/Antlr4.StringTemplate/Misc/MapModelAdaptor.cs
new file mode 100644
index 0000000..c1b7b11
--- /dev/null
+++ b/Antlr4.StringTemplate/Misc/MapModelAdaptor.cs
@@ -0,0 +1,67 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Misc
+{
+    using IDictionary = System.Collections.IDictionary;
+    using Antlr.Runtime.JavaExtensions;
+
+    public class MapModelAdaptor : ModelAdaptor
+    {
+        public virtual object getProperty(ST self, object o, object property, string propertyName)
+        {
+            object value;
+            IDictionary map = (IDictionary)o;
+
+            if (property == null)
+                value = map[STGroup.DEFAULT_KEY];
+            else if (property.Equals("keys"))
+                value = map.Keys;
+            else if (property.Equals("values"))
+                value = map.Values;
+            else if (map.Contains(property))
+                value = map[property];
+            else if (map.Contains(propertyName))
+                value = map[propertyName]; // if can't find the key, try toString version
+            else
+                value = map[STGroup.DEFAULT_KEY]; // not found, use default
+
+            string valueString = value as string;
+            if (valueString == STGroup.DICT_KEY)
+            {
+                value = property;
+            }
+
+            return value;
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Misc/MultiMap.cs b/Antlr4.StringTemplate/Misc/MultiMap.cs
new file mode 100644
index 0000000..f5f5176
--- /dev/null
+++ b/Antlr4.StringTemplate/Misc/MultiMap.cs
@@ -0,0 +1,52 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Misc
+{
+    using System.Collections.Generic;
+
+    /** A hash table that maps a key to a list of elements not just a single. */
+    public class MultiMap<TKey, TValue> : Dictionary<TKey, List<TValue>>
+    {
+        public virtual void map(TKey key, TValue value)
+        {
+            List<TValue> elementsForKey;
+            if (!TryGetValue(key, out elementsForKey))
+            {
+                elementsForKey = new List<TValue>();
+                base.Add(key, elementsForKey);
+            }
+
+            elementsForKey.Add(value);
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Misc/ObjectModelAdaptor.cs b/Antlr4.StringTemplate/Misc/ObjectModelAdaptor.cs
new file mode 100644
index 0000000..de8f004
--- /dev/null
+++ b/Antlr4.StringTemplate/Misc/ObjectModelAdaptor.cs
@@ -0,0 +1,208 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Misc
+{
+    using Type = System.Type;
+    using MemberInfo = System.Reflection.MemberInfo;
+    using MethodInfo = System.Reflection.MethodInfo;
+    using FieldInfo = System.Reflection.FieldInfo;
+    using Exception = System.Exception;
+    using ArgumentNullException = System.ArgumentNullException;
+    using System.Collections.Generic;
+    using System.Linq;
+    using PropertyInfo = System.Reflection.PropertyInfo;
+    using System.Linq.Expressions;
+
+    public class ObjectModelAdaptor : ModelAdaptor
+    {
+        private static readonly Dictionary<Type, Dictionary<string, System.Func<object, object>>> _memberAccessors =
+            new Dictionary<Type, Dictionary<string, System.Func<object, object>>>();
+
+        public virtual object getProperty(ST self, object o, object property, string propertyName)
+        {
+            if (property == null)
+                throw new ArgumentNullException("property");
+
+            object value = null;
+            Type c = o.GetType();
+            var accessor = FindMember(c, propertyName);
+            if (accessor != null)
+            {
+                value = accessor(o);
+            }
+            else
+            {
+                throw new STNoSuchPropertyException(string.Format("{0}.{1}", c.Name, propertyName));
+            }
+
+            return value;
+        }
+
+        private static System.Func<object, object> FindMember(Type type, string name)
+        {
+            if (type == null)
+                throw new ArgumentNullException("type");
+            if (name == null)
+                throw new ArgumentNullException("name");
+
+            lock (_memberAccessors)
+            {
+                Dictionary<string, System.Func<object, object>> members;
+                System.Func<object, object> accessor = null;
+
+                if (_memberAccessors.TryGetValue(type, out members))
+                {
+                    if (members.TryGetValue(name, out accessor))
+                        return accessor;
+                }
+                else
+                {
+                    members = new Dictionary<string, System.Func<object, object>>();
+                    _memberAccessors[type] = members;
+                }
+
+                // must look up using reflection
+                string methodSuffix = char.ToUpperInvariant(name[0]) + name.Substring(1);
+
+                MethodInfo method = null;
+                if (method == null)
+                {
+                    System.Reflection.PropertyInfo p = type.GetProperty(methodSuffix);
+                    if (p != null)
+                        method = p.GetGetMethod();
+                }
+                if (method == null)
+                {
+                    method = type.GetMethod("Get" + methodSuffix, Type.EmptyTypes);
+                }
+                if (method == null)
+                {
+                    method = type.GetMethod("Is" + methodSuffix, Type.EmptyTypes);
+                }
+
+                if (method != null)
+                {
+                    accessor = BuildAccessor(method);
+                }
+                else
+                {
+                    // try for an indexer
+                    method = type.GetMethod("get_Item", new Type[] { typeof(string) });
+                    if (method == null)
+                    {
+                        var property = type.GetProperties().FirstOrDefault(IsIndexer);
+                        if (property != null)
+                            method = property.GetGetMethod();
+                    }
+
+                    if (method != null)
+                    {
+                        accessor = BuildAccessor(method, name);
+                    }
+                    else
+                    {
+                        // try for a visible field
+                        FieldInfo field = type.GetField(name);
+                        // also check .NET naming convention for fields
+                        if (field == null)
+                            field = type.GetField("_" + name);
+
+                        if (field != null)
+                            accessor = BuildAccessor(field);
+                    }
+                }
+
+                members[name] = accessor;
+
+                return accessor;
+            }
+        }
+
+        private static bool IsIndexer(PropertyInfo propertyInfo)
+        {
+            if (propertyInfo == null)
+                throw new ArgumentNullException("propertyInfo");
+
+            var indexParameters = propertyInfo.GetIndexParameters();
+            return indexParameters != null
+                && indexParameters.Length > 0
+                && indexParameters[0].ParameterType == typeof(string);
+        }
+
+        private static System.Func<object, object> BuildAccessor(MethodInfo method)
+        {
+            ParameterExpression obj = Expression.Parameter(typeof(object), "obj");
+            Expression<System.Func<object, object>> expr = Expression.Lambda<System.Func<object, object>>(
+                Expression.Convert(
+                    Expression.Call(
+                        Expression.Convert(obj, method.DeclaringType),
+                        method),
+                    typeof(object)),
+                obj);
+
+            return expr.Compile();
+        }
+
+        /// <summary>
+        /// Builds an accessor for an indexer property that returns a takes a string argument.
+        /// </summary>
+        private static System.Func<object, object> BuildAccessor(MethodInfo method, string argument)
+        {
+            ParameterExpression obj = Expression.Parameter(typeof(object), "obj");
+            Expression<System.Func<object, object>> expr = Expression.Lambda<System.Func<object, object>>(
+                Expression.Convert(
+                    Expression.Call(
+                        Expression.Convert(obj, method.DeclaringType),
+                        method,
+                        Expression.Constant(argument)),
+                    typeof(object)),
+                obj);
+
+            return expr.Compile();
+        }
+
+        private static System.Func<object, object> BuildAccessor(FieldInfo field)
+        {
+            ParameterExpression obj = Expression.Parameter(typeof(object), "obj");
+            Expression<System.Func<object, object>> expr = Expression.Lambda<System.Func<object, object>>(
+                Expression.Convert(
+                    Expression.Field(
+                        Expression.Convert(obj, field.DeclaringType),
+                        field),
+                    typeof(object)),
+                obj);
+
+            return expr.Compile();
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Misc/TemplateCompileTimeMessage.cs b/Antlr4.StringTemplate/Misc/TemplateCompileTimeMessage.cs
new file mode 100644
index 0000000..b259ceb
--- /dev/null
+++ b/Antlr4.StringTemplate/Misc/TemplateCompileTimeMessage.cs
@@ -0,0 +1,100 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Misc
+{
+    using IToken = Antlr.Runtime.IToken;
+    using Exception = System.Exception;
+    using RecognitionException = Antlr.Runtime.RecognitionException;
+    using Antlr4.StringTemplate.Compiler;
+
+    /** Used for semantic errors that occur at compile time not during
+     *  interpretation. For ST parsing ONLY not group parsing.
+     */
+    public class STCompiletimeMessage : STMessage
+    {
+        private readonly IToken templateToken; // overall token pulled from group file
+        private readonly IToken token;         // token inside template
+        private readonly string srcName;
+
+        public STCompiletimeMessage(ErrorType error, string srcName, IToken templateToken, IToken t)
+            : this(error, srcName, templateToken, t, null)
+        {
+        }
+
+        public STCompiletimeMessage(ErrorType error, string srcName, IToken templateToken, IToken t, Exception cause)
+            : this(error, srcName, templateToken, t, cause, null)
+        {
+        }
+
+        public STCompiletimeMessage(ErrorType error, string srcName, IToken templateToken, IToken t, Exception cause, object arg)
+            : this(error, srcName, templateToken, t, cause, arg, null)
+        {
+        }
+
+        public STCompiletimeMessage(ErrorType error, string srcName, IToken templateToken, IToken t, Exception cause, object arg, object arg2)
+            : base(error, null, cause, arg, arg2)
+        {
+            this.templateToken = templateToken;
+            this.token = t;
+            this.srcName = srcName;
+        }
+
+        public override string ToString()
+        {
+            RecognitionException re = (RecognitionException)Cause;
+            int line = 0;
+            int charPos = -1;
+            if (token != null)
+            {
+                line = token.Line;
+                charPos = token.CharPositionInLine;
+                if (templateToken != null)
+                {
+                    int templateDelimiterSize = 1;
+                    if (templateToken.Type == GroupParser.BIGSTRING)
+                    {
+                        templateDelimiterSize = 2;
+                    }
+                    line += templateToken.Line - 1;
+                    charPos += templateToken.CharPositionInLine + templateDelimiterSize;
+                }
+            }
+
+            string filepos = string.Format("{0}:{1}", line, charPos);
+            if (srcName != null)
+                return string.Format("{0} {1}: {2}", srcName, filepos, string.Format(Error.Message, Arg, Arg2));
+
+            return string.Format("{0}: {1}", filepos, string.Format(Error.Message, Arg, Arg2));
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Misc/TemplateDump.cs b/Antlr4.StringTemplate/Misc/TemplateDump.cs
new file mode 100644
index 0000000..9c291da
--- /dev/null
+++ b/Antlr4.StringTemplate/Misc/TemplateDump.cs
@@ -0,0 +1,148 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Misc
+{
+    using System.Collections.Generic;
+    using StringBuilder = System.Text.StringBuilder;
+    using System.Linq;
+    using StringComparer = System.StringComparer;
+    using Environment = System.Environment;
+    using Antlr.Runtime.JavaExtensions;
+
+    /** This class dumps out a hierarchy of templates in text form, indented
+     *  to show the nested relationship.  Usage:
+     *
+     *     ST st = ...;
+     *     STDump d = new STDump(st);
+     *     System.out.println(d.toString());
+     */
+    public class STDump
+    {
+        private readonly ST self;
+
+        public STDump(ST self)
+        {
+            this.self = self;
+        }
+
+        public static string toString(ST self)
+        {
+            STDump d = new STDump(self);
+            return d.ToString();
+        }
+
+        public override string ToString()
+        {
+            return toString(0);
+        }
+
+        protected virtual string toString(int n)
+        {
+            StringBuilder buf = new StringBuilder();
+            buf.Append(getTemplateDeclaratorString() + ":");
+            n++;
+            if (self.getAttributes() != null)
+            {
+                List<string> attrNames = new List<string>(self.getAttributes().Keys);
+                attrNames.Sort(StringComparer.Ordinal);
+                string longestName = attrNames.OrderBy(i => i.Length).Last();
+                int w = longestName.Length;
+                foreach (object attrName in attrNames)
+                {
+                    string name = (string)attrName;
+                    buf.Append(Environment.NewLine);
+                    indent(buf, n);
+                    buf.Append(string.Format("%-" + w + "s = ", name));
+                    buf.Append(string.Format(string.Format("{{0,-{0}}} = ", w), name));
+                    object value;
+                    self.getAttributes().TryGetValue(name, out value);
+                    buf.Append(getValueDebugString(value, n));
+                }
+            }
+            buf.Append(Environment.NewLine);
+            n--;
+            indent(buf, n);
+            buf.Append("]");
+            return buf.ToString();
+        }
+
+        protected virtual string getValueDebugString(object value, int n)
+        {
+            StringBuilder buf = new StringBuilder();
+            value = Interpreter.convertAnythingIteratableToIterator(value);
+            if (value is ST)
+            {
+                STDump d = new STDump((ST)value);
+                buf.Append(d.toString(n));
+            }
+            else if (value is Iterator)
+            {
+                Iterator it = (Iterator)value;
+                int na = 0;
+                while (it.hasNext())
+                {
+                    string v = getValueDebugString(it.next(), n);
+                    if (na > 0)
+                        buf.Append(", ");
+                    buf.Append(v);
+                    na++;
+                }
+            }
+            else
+            {
+                buf.Append(value);
+            }
+            return buf.ToString();
+        }
+
+        protected virtual string getTemplateDeclaratorString()
+        {
+            StringBuilder buf = new StringBuilder();
+            buf.Append("<");
+            buf.Append(self.getName());
+            buf.Append("(");
+            if (self.impl.formalArguments != null)
+                buf.Append(string.Join(",", self.impl.formalArguments.Keys.ToArray()));
+            buf.Append(")@");
+            buf.Append(GetHashCode());
+            buf.Append(">");
+            return buf.ToString();
+        }
+
+        protected virtual void indent(StringBuilder buf, int n)
+        {
+            for (int i = 1; i <= n; i++)
+                buf.Append("   ");
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Misc/TemplateGroupCompiletimeMessage.cs b/Antlr4.StringTemplate/Misc/TemplateGroupCompiletimeMessage.cs
new file mode 100644
index 0000000..60211f6
--- /dev/null
+++ b/Antlr4.StringTemplate/Misc/TemplateGroupCompiletimeMessage.cs
@@ -0,0 +1,89 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Misc
+{
+    using Exception = System.Exception;
+    using RecognitionException = Antlr.Runtime.RecognitionException;
+    using IToken = Antlr.Runtime.IToken;
+
+    public class STGroupCompiletimeMessage : STMessage
+    {
+        /// <summary>
+        /// token inside group file
+        /// </summary>
+        private readonly IToken token;
+        private readonly string srcName;
+
+        public STGroupCompiletimeMessage(ErrorType error, string srcName, IToken t, Exception cause)
+            : this(error, srcName, t, cause, null)
+        {
+        }
+
+        public STGroupCompiletimeMessage(ErrorType error, string srcName, IToken t, Exception cause, object arg)
+            : this(error, srcName, t, cause, arg, null)
+        {
+        }
+
+        public STGroupCompiletimeMessage(ErrorType error, string srcName, IToken t, Exception cause, object arg, object arg2)
+            : base(error, null, cause, arg, arg2)
+        {
+            this.token = t;
+            this.srcName = srcName;
+        }
+
+        public override string ToString()
+        {
+            RecognitionException re = (RecognitionException)Cause;
+            int line = 0;
+            int charPos = -1;
+            if (token != null)
+            {
+                line = token.Line;
+                charPos = token.CharPositionInLine;
+            }
+            else if (re != null)
+            {
+                line = re.Line;
+                charPos = re.CharPositionInLine;
+            }
+
+            string filepos = line + ":" + charPos;
+            if (srcName != null)
+            {
+                return srcName + " " + filepos + ": " + string.Format(Error.Message, Arg, Arg2);
+            }
+
+            return filepos + ": " + string.Format(Error.Message, Arg, Arg2);
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Misc/TemplateLexerMessage.cs b/Antlr4.StringTemplate/Misc/TemplateLexerMessage.cs
new file mode 100644
index 0000000..5a70ab7
--- /dev/null
+++ b/Antlr4.StringTemplate/Misc/TemplateLexerMessage.cs
@@ -0,0 +1,80 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Misc
+{
+    using Exception = System.Exception;
+    using IToken = Antlr.Runtime.IToken;
+    using RecognitionException = Antlr.Runtime.RecognitionException;
+    using Antlr4.StringTemplate.Compiler;
+
+    /** */
+    public class STLexerMessage : STMessage
+    {
+        string msg;
+        IToken templateToken; // overall token pulled from group file
+        string srcName;
+
+        public STLexerMessage(string srcName, string msg, IToken templateToken, Exception cause)
+            : base(ErrorType.LEXER_ERROR, null, cause, null)
+        {
+            this.msg = msg;
+            this.templateToken = templateToken;
+            this.srcName = srcName;
+        }
+
+        public override string ToString()
+        {
+            RecognitionException re = (RecognitionException)Cause;
+            int line = re.Line;
+            int charPos = re.CharPositionInLine;
+            if (templateToken != null)
+            {
+                int templateDelimiterSize = 1;
+                if (templateToken.Type == GroupParser.BIGSTRING)
+                {
+                    templateDelimiterSize = 2;
+                }
+                line += templateToken.Line - 1;
+                charPos += templateToken.CharPositionInLine + templateDelimiterSize;
+            }
+
+            string filepos = line + ":" + charPos;
+            if (srcName != null)
+            {
+                return srcName + " " + filepos + ": " + string.Format(Error.Message, msg);
+            }
+
+            return filepos + ": " + string.Format(Error.Message, msg);
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Misc/TemplateMessage.cs b/Antlr4.StringTemplate/Misc/TemplateMessage.cs
new file mode 100644
index 0000000..bf6bf8b
--- /dev/null
+++ b/Antlr4.StringTemplate/Misc/TemplateMessage.cs
@@ -0,0 +1,160 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Misc
+{
+    using Exception = System.Exception;
+    using IToken = Antlr.Runtime.IToken;
+    using StringWriter = System.IO.StringWriter;
+
+    /** Upon error, ST creates an STMessage or subclass instance and notifies
+     *  the listener.  This root class is used for IO and internal errors.
+     *
+     *  @see STRuntimeMessage
+     *  @see STCompiletimeMessage
+     */
+    public class STMessage
+    {
+        /** if in debug mode, has created instance, add attr events and eval
+         *  template events.
+         */
+        private readonly ST self;
+        private readonly ErrorType error;
+        private readonly object arg;
+        private readonly object arg2;
+        private readonly object arg3;
+        private readonly Exception cause;
+
+        public STMessage(ErrorType error)
+        {
+            this.error = error;
+        }
+
+        public STMessage(ErrorType error, ST self)
+            : this(error)
+        {
+            this.self = self;
+        }
+
+        public STMessage(ErrorType error, ST self, Exception cause)
+            : this(error, self)
+        {
+            this.cause = cause;
+        }
+
+        public STMessage(ErrorType error, ST self, Exception cause, object arg)
+            : this(error, self, cause)
+        {
+            this.arg = arg;
+        }
+
+        public STMessage(ErrorType error, ST self, Exception cause, IToken where, object arg)
+            : this(error, self, cause, where)
+        {
+            this.arg = arg;
+        }
+
+        public STMessage(ErrorType error, ST self, Exception cause, object arg, object arg2)
+            : this(error, self, cause, arg)
+        {
+            this.arg2 = arg2;
+        }
+
+        public STMessage(ErrorType error, ST self, Exception cause, object arg, object arg2, object arg3)
+            : this(error, self, cause, arg, arg2)
+        {
+            this.arg3 = arg3;
+        }
+
+        public ST Self
+        {
+            get
+            {
+                return self;
+            }
+        }
+
+        public ErrorType Error
+        {
+            get
+            {
+                return error;
+            }
+        }
+
+        public object Arg
+        {
+            get
+            {
+                return arg;
+            }
+        }
+
+        public object Arg2
+        {
+            get
+            {
+                return arg;
+            }
+        }
+
+        public object Arg3
+        {
+            get
+            {
+                return arg;
+            }
+        }
+
+        public Exception Cause
+        {
+            get
+            {
+                return cause;
+            }
+        }
+
+        public override string ToString()
+        {
+            StringWriter sw = new StringWriter();
+            string msg = string.Format(error.Message, arg, arg2, arg3);
+            sw.Write(msg);
+            if (cause != null)
+            {
+                sw.WriteLine();
+                sw.Write("Caused by: ");
+                sw.Write(cause.StackTrace);
+            }
+            return sw.ToString();
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Misc/TemplateModelAdaptor.cs b/Antlr4.StringTemplate/Misc/TemplateModelAdaptor.cs
new file mode 100644
index 0000000..2c559c3
--- /dev/null
+++ b/Antlr4.StringTemplate/Misc/TemplateModelAdaptor.cs
@@ -0,0 +1,43 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Misc
+{
+    public class STModelAdaptor : ModelAdaptor
+    {
+        public virtual object getProperty(ST self, object o, object property, string propertyName)
+        {
+            ST st = (ST)o;
+            return st.getAttribute(propertyName);
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Misc/TemplateNoSuchPropertyException.cs b/Antlr4.StringTemplate/Misc/TemplateNoSuchPropertyException.cs
new file mode 100644
index 0000000..d437da3
--- /dev/null
+++ b/Antlr4.StringTemplate/Misc/TemplateNoSuchPropertyException.cs
@@ -0,0 +1,65 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Misc
+{
+    using Exception = System.Exception;
+    using Antlr4.StringTemplate.Compiler;
+
+    public class STNoSuchPropertyException : STException
+    {
+        private readonly string propertyName;
+
+        public STNoSuchPropertyException()
+        {
+        }
+
+        public STNoSuchPropertyException(string propertyName)
+        {
+            this.propertyName = propertyName;
+        }
+
+        public STNoSuchPropertyException(Exception e, string propertyName)
+            : base(null, e)
+        {
+            this.propertyName = propertyName;
+        }
+
+        public string PropertyName
+        {
+            get
+            {
+                return propertyName;
+            }
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Misc/TemplateRuntimeMessage.cs b/Antlr4.StringTemplate/Misc/TemplateRuntimeMessage.cs
new file mode 100644
index 0000000..552a77f
--- /dev/null
+++ b/Antlr4.StringTemplate/Misc/TemplateRuntimeMessage.cs
@@ -0,0 +1,111 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Misc
+{
+    using Exception = System.Exception;
+    using StringBuilder = System.Text.StringBuilder;
+
+    /** Used to track errors that occur in the ST interpreter. */
+    public class STRuntimeMessage : STMessage
+    {
+        /** Where error occurred in bytecode memory */
+        private readonly int ip = -1;
+
+        public STRuntimeMessage(ErrorType error, int ip)
+            : this(error, ip, null)
+        {
+        }
+
+        public STRuntimeMessage(ErrorType error, int ip, ST self)
+            : this(error, ip, self, null)
+        {
+        }
+
+        public STRuntimeMessage(ErrorType error, int ip, ST self, object arg)
+            : this(error, ip, self, null, arg, null)
+        {
+        }
+
+        public STRuntimeMessage(ErrorType error, int ip, ST self, Exception e, object arg)
+            : this(error, ip, self, e, arg, null)
+        {
+        }
+
+        public STRuntimeMessage(ErrorType error, int ip, ST self, Exception e, object arg, object arg2)
+            : base(error, self, e, arg, arg2)
+        {
+            this.ip = ip;
+        }
+
+        public STRuntimeMessage(ErrorType error, int ip, ST self, Exception e, object arg, object arg2, object arg3)
+            : base(error, self, e, arg, arg2, arg3)
+        {
+            this.ip = ip;
+        }
+
+
+        /** Given an ip (code location), get it's range in source template then
+         *  return it's template line:col.
+         */
+        public virtual string getSourceLocation()
+        {
+            if (ip < 0)
+                return null;
+
+            Interval I = Self.impl.sourceMap[ip];
+            if (I == null)
+                return null;
+
+            // get left edge and get line/col
+            int i = I.A;
+            Coordinate loc = Utility.getLineCharPosition(Self.impl.template, i);
+            return loc.ToString();
+        }
+
+        public override string ToString()
+        {
+            StringBuilder buf = new StringBuilder();
+            string loc = getSourceLocation();
+            if (Self != null)
+            {
+                buf.Append("context [");
+                buf.Append(Self.getEnclosingInstanceStackString());
+                buf.Append("]");
+            }
+            if (loc != null)
+                buf.Append(" " + loc);
+            buf.Append(" " + base.ToString());
+            return buf.ToString();
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Misc/TypeRegistry`1.cs b/Antlr4.StringTemplate/Misc/TypeRegistry`1.cs
new file mode 100644
index 0000000..b2e6571
--- /dev/null
+++ b/Antlr4.StringTemplate/Misc/TypeRegistry`1.cs
@@ -0,0 +1,373 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Misc
+{
+    using System.Collections.Generic;
+    using System.Linq;
+    using AmbiguousMatchException = System.Reflection.AmbiguousMatchException;
+    using Array = System.Array;
+    using ICollection = System.Collections.ICollection;
+    using IDictionary = System.Collections.IDictionary;
+    using IDictionaryEnumerator = System.Collections.IDictionaryEnumerator;
+    using IEnumerable = System.Collections.IEnumerable;
+    using IEnumerator = System.Collections.IEnumerator;
+    using NotSupportedException = System.NotSupportedException;
+    using StringBuilder = System.Text.StringBuilder;
+    using Type = System.Type;
+
+    public class TypeRegistry<T> : IDictionary<Type, T>, IDictionary
+    {
+        private readonly Dictionary<Type, T> _backingStore = new Dictionary<Type, T>();
+        private readonly Dictionary<Type, Type> _cache = new Dictionary<Type, Type>();
+
+        ICollection<Type> IDictionary<Type, T>.Keys
+        {
+            get
+            {
+                return _backingStore.Keys;
+            }
+        }
+
+        ICollection<T> IDictionary<Type, T>.Values
+        {
+            get
+            {
+                return _backingStore.Values;
+            }
+        }
+
+        int ICollection<KeyValuePair<Type, T>>.Count
+        {
+            get
+            {
+                return _backingStore.Count;
+            }
+        }
+
+        int ICollection.Count
+        {
+            get
+            {
+                return _backingStore.Count;
+            }
+        }
+
+        bool ICollection<KeyValuePair<Type, T>>.IsReadOnly
+        {
+            get
+            {
+                return false;
+            }
+        }
+
+        bool IDictionary.IsFixedSize
+        {
+            get
+            {
+                return false;
+            }
+        }
+
+        bool IDictionary.IsReadOnly
+        {
+            get
+            {
+                return false;
+            }
+        }
+
+        ICollection IDictionary.Keys
+        {
+            get
+            {
+                return _backingStore.Keys;
+            }
+        }
+
+        ICollection IDictionary.Values
+        {
+            get
+            {
+                return _backingStore.Values;
+            }
+        }
+
+        bool ICollection.IsSynchronized
+        {
+            get
+            {
+                return false;
+            }
+        }
+
+        object ICollection.SyncRoot
+        {
+            get
+            {
+                throw new NotSupportedException();
+            }
+        }
+
+        public T this[Type key]
+        {
+            get
+            {
+                T value;
+                if (!TryGetValue(key, out value))
+                    throw new KeyNotFoundException();
+
+                return value;
+            }
+
+            set
+            {
+                _backingStore[key] = value;
+                HandleAlteration(key);
+            }
+        }
+
+        object IDictionary.this[object key]
+        {
+            get
+            {
+                Type t = key as Type;
+                if (t == null && key != null)
+                    return null;
+
+                T value;
+                if (!TryGetValue(t, out value))
+                    return null;
+
+                return value;
+            }
+
+            set
+            {
+                this[(Type)key] = (T)value;
+            }
+        }
+
+        public void Add(Type key, T value)
+        {
+            _backingStore.Add(key, value);
+            HandleAlteration(key);
+        }
+
+        public bool ContainsKey(Type key)
+        {
+            if (_cache.ContainsKey(key))
+                return true;
+
+            T value;
+            return TryGetValue(key, out value);
+        }
+
+        public bool Remove(Type key)
+        {
+            if (_backingStore.Remove(key))
+            {
+                HandleAlteration(key);
+                return true;
+            }
+
+            return false;
+        }
+
+        public bool TryGetValue(Type key, out T value)
+        {
+            if (_backingStore.TryGetValue(key, out value))
+                return true;
+
+            Type redirect;
+            if (_cache.TryGetValue(key, out redirect))
+            {
+                if (redirect == null)
+                {
+                    value = default(T);
+                    return false;
+                }
+                else
+                {
+                    return _backingStore.TryGetValue(redirect, out value);
+                }
+            }
+
+            List<Type> candidates = _backingStore.Keys.Where(i => i.IsAssignableFrom(key)).ToList();
+            if (candidates.Count == 0)
+            {
+                _cache[key] = null;
+                value = default(T);
+                return false;
+            }
+            else if (candidates.Count == 1)
+            {
+                _cache[key] = candidates[0];
+                return _backingStore.TryGetValue(candidates[0], out value);
+            }
+            else
+            {
+                for (int i = 0; i < candidates.Count - 1; i++)
+                {
+                    if (candidates[i] == null)
+                        continue;
+
+                    for (int j = i + 1; j < candidates.Count; j++)
+                    {
+                        if (candidates[i].IsAssignableFrom(candidates[j]))
+                        {
+                            candidates[i] = null;
+                            break;
+                        }
+                        else if (candidates[j].IsAssignableFrom(candidates[i]))
+                        {
+                            candidates[j] = null;
+                        }
+                    }
+                }
+
+                candidates.RemoveAll(i => i == null);
+                if (candidates.Count != 1)
+                {
+                    StringBuilder builder = new StringBuilder();
+                    builder.AppendFormat("The type '{0}' does not match a single item in the registry. The {1} ambiguous matches are:", key.FullName, candidates.Count);
+                    foreach (var candidate in candidates)
+                    {
+                        builder.AppendLine();
+                        builder.AppendFormat("    {0}", candidate.FullName);
+                    }
+
+                    throw new AmbiguousMatchException(builder.ToString());
+                }
+
+                _cache[key] = candidates[0];
+                return _backingStore.TryGetValue(candidates[0], out value);
+            }
+        }
+
+        public void Clear()
+        {
+            _backingStore.Clear();
+            _cache.Clear();
+        }
+
+        public IEnumerator<KeyValuePair<Type, T>> GetEnumerator()
+        {
+            return _backingStore.GetEnumerator();
+        }
+
+        void ICollection<KeyValuePair<Type, T>>.Add(KeyValuePair<Type, T> item)
+        {
+            Add(item.Key, item.Value);
+        }
+
+        bool ICollection<KeyValuePair<Type, T>>.Contains(KeyValuePair<Type, T> item)
+        {
+            T value;
+            if (_backingStore.TryGetValue(item.Key, out value))
+            {
+                if (EqualityComparer<T>.Default.Equals(value, item.Value))
+                    return true;
+            }
+
+            return false;
+        }
+
+        void ICollection<KeyValuePair<Type, T>>.CopyTo(KeyValuePair<Type, T>[] array, int arrayIndex)
+        {
+            ((ICollection<KeyValuePair<Type, T>>)_backingStore).CopyTo(array, arrayIndex);
+        }
+
+        bool ICollection<KeyValuePair<Type, T>>.Remove(KeyValuePair<Type, T> item)
+        {
+            T value;
+            if (_backingStore.TryGetValue(item.Key, out value))
+            {
+                if (EqualityComparer<T>.Default.Equals(value, item.Value))
+                    return _backingStore.Remove(item.Key);
+            }
+
+            return false;
+        }
+
+        IEnumerator IEnumerable.GetEnumerator()
+        {
+            return GetEnumerator();
+        }
+
+        void IDictionary.Add(object key, object value)
+        {
+            Add((Type)key, (T)value);
+        }
+
+        void IDictionary.Clear()
+        {
+            Clear();
+        }
+
+        bool IDictionary.Contains(object key)
+        {
+            if (key == null)
+                return ContainsKey(null);
+
+            Type t = key as Type;
+            if (t == null)
+                return false;
+
+            return ContainsKey(t);
+        }
+
+        IDictionaryEnumerator IDictionary.GetEnumerator()
+        {
+            return _backingStore.GetEnumerator();
+        }
+
+        void IDictionary.Remove(object key)
+        {
+            Type t = key as Type;
+            if (t != null || key == null)
+                Remove(t);
+        }
+
+        void ICollection.CopyTo(Array array, int index)
+        {
+            ((ICollection)_backingStore).CopyTo(array, index);
+        }
+
+        private void HandleAlteration(Type type)
+        {
+            Type[] altered = _cache.Where(i => type.IsAssignableFrom(i.Key)).Select(i => i.Key).ToArray();
+            foreach (var t in altered)
+                _cache.Remove(t);
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Misc/Utility.cs b/Antlr4.StringTemplate/Misc/Utility.cs
new file mode 100644
index 0000000..237bf88
--- /dev/null
+++ b/Antlr4.StringTemplate/Misc/Utility.cs
@@ -0,0 +1,132 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Misc
+{
+    using MethodInfo = System.Reflection.MethodInfo;
+    using FieldInfo = System.Reflection.FieldInfo;
+    using Type = System.Type;
+
+    public static class Utility
+    {
+        public static string strip(string s, int n)
+        {
+            return s.Substring(n, s.Length - 2 * n);
+        }
+
+        //    public static String stripRight(String s, int n) {
+        //        return s.substring(0, s.length()-n);
+        //    }
+
+        // strip newline from front but just one
+        public static string trimOneStartingNewline(string s)
+        {
+            if (s.StartsWith("\r\n"))
+                s = s.Substring(2);
+            else if (s.StartsWith("\n"))
+                s = s.Substring(1);
+            return s;
+        }
+
+        // strip newline from end but just one
+        public static string trimOneTrailingNewline(string s)
+        {
+            if (s.EndsWith("\r\n"))
+                s = s.Substring(0, s.Length - 2);
+            else if (s.EndsWith("\n"))
+                s = s.Substring(0, s.Length - 1);
+            return s;
+        }
+
+        public static string getPrefix(string name)
+        {
+            //System.out.println("getParent("+name+")="+p);
+            if (name == null)
+                return null;
+
+            int lastSlash = name.LastIndexOf('/');
+            if (lastSlash > 0)
+                return name.Substring(0, lastSlash);
+
+            //System.out.println("getPrefix("+name+")="+p);
+            return "";
+        }
+
+        public static string replaceEscapes(string s)
+        {
+            s = s.Replace("\n", "\\\\n");
+            s = s.Replace("\r", "\\\\r");
+            s = s.Replace("\t", "\\\\t");
+            return s;
+        }
+
+        /** Given index into string, compute the line and char position in line */
+        public static Coordinate getLineCharPosition(string s, int index)
+        {
+            int line = 1;
+            int charPos = 0;
+            int p = 0;
+            while (p < index)
+            {
+                // don't care about s[index] itself; count before
+                if (s[p] == '\n')
+                {
+                    line++;
+                    charPos = 0;
+                }
+                else
+                {
+                    charPos++;
+                }
+
+                p++;
+            }
+
+            return new Coordinate(line, charPos);
+        }
+
+        public static object accessField(FieldInfo f, object obj)
+        {
+            return f.GetValue(obj);
+        }
+
+        public static object invokeMethod(MethodInfo m, object obj)
+        {
+            return m.Invoke(obj, null);
+        }
+
+        public static MethodInfo getMethod(Type c, string methodName)
+        {
+            return c.GetMethod(methodName, Type.EmptyTypes);
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/NoIndentWriter.cs b/Antlr4.StringTemplate/NoIndentWriter.cs
new file mode 100644
index 0000000..38404f2
--- /dev/null
+++ b/Antlr4.StringTemplate/NoIndentWriter.cs
@@ -0,0 +1,51 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate
+{
+    using TextWriter = System.IO.TextWriter;
+
+    /** Just pass through the text */
+    public class NoIndentWriter : AutoIndentWriter
+    {
+        public NoIndentWriter(TextWriter @out)
+            : base(@out)
+        {
+        }
+
+        public override int write(string str)
+        {
+            @out.Write(str);
+            return str.Length;
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/NumberRenderer.cs b/Antlr4.StringTemplate/NumberRenderer.cs
new file mode 100644
index 0000000..13f6c98
--- /dev/null
+++ b/Antlr4.StringTemplate/NumberRenderer.cs
@@ -0,0 +1,59 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate
+{
+    using CultureInfo = System.Globalization.CultureInfo;
+
+    /** Works with Byte, Short, Integer, Long, and BigInteger as well as
+     *  Float, Double, and BigDecimal.  You pass in a format string suitable
+     *  for Formatter object:
+     *
+     *  http://java.sun.com/j2se/1.5.0/docs/api/java/util/Formatter.html
+     *
+     *  For example, "%10d" emits a number as a decimal int padding to 10 char.
+     *  This can even do long to date conversions using the format string.
+     */
+    public class NumberRenderer : AttributeRenderer
+    {
+        public virtual string toString(object o, string formatString, CultureInfo locale)
+        {
+            // o will be instanceof Number
+            if (formatString == null)
+                return o.ToString();
+
+            Formatter f = new Formatter(locale);
+            f.format(formatString, o);
+            return f.toString();
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Properties/AssemblyInfo.cs b/Antlr4.StringTemplate/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..20e7e30
--- /dev/null
+++ b/Antlr4.StringTemplate/Properties/AssemblyInfo.cs
@@ -0,0 +1,70 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Labs, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Reflection;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("Antlr4.StringTemplate")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("Tunnel Vision Laboratories, LLC")]
+[assembly: AssemblyProduct("Antlr4.StringTemplate")]
+[assembly: AssemblyCopyright("Copyright © Sam Harwell 2010")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+[assembly: CLSCompliant(false)]
+
+// Setting ComVisible to false makes the types in this assembly not visible
+// to COM components.  If you need to access a type in this assembly from
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("a4b023e1-07a4-48c5-b095-1e1beb854b3d")]
+
+/* Version information for an assembly consists of four values in the following order:
+ *
+ *   Major.Minor.Build.Revision
+ *
+ * These values are updated according to the following:
+ *   1. Major.Minor follows the ANTLR release schedule
+ *   2. Build is incremented each time the C# port is packaged for release (regardless
+ *      of whether it's an incremental or nightly). The value resets to zero whenever
+ *      the Major or Minor version is incremented.
+ *   3. Revision is the Perforce changelist number associated with the release.
+ */
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/Antlr4.StringTemplate/StringRenderer.cs b/Antlr4.StringTemplate/StringRenderer.cs
new file mode 100644
index 0000000..fea3f24
--- /dev/null
+++ b/Antlr4.StringTemplate/StringRenderer.cs
@@ -0,0 +1,123 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate
+{
+    using StringBuilder = System.Text.StringBuilder;
+    using CultureInfo = System.Globalization.CultureInfo;
+    using NotImplementedException = System.NotImplementedException;
+
+    /** This render knows to perform a few operations on String objects:
+     *  upper, lower, cap, url-encode, xml-encode.
+     */
+    public class StringRenderer : AttributeRenderer
+    {
+        // trim(s) and strlen(s) built-in funcs; these are format options
+        public virtual string toString(object o, string formatString, CultureInfo locale)
+        {
+            string s = (string)o;
+            if (formatString == null)
+                return s;
+
+            if (formatString.Equals("upper"))
+                return s.ToUpper(locale);
+
+            if (formatString.Equals("lower"))
+                return s.ToLower(locale);
+
+            if (formatString.Equals("cap"))
+                return char.ToUpper(s[0], locale) + s.Substring(1);
+
+            if (formatString.Equals("url-encode"))
+                throw new NotImplementedException();
+#if false
+            if (formatString.Equals("url-encode"))
+                return URLEncoder.encode(s);
+#endif
+
+            if (formatString.Equals("xml-encode"))
+                return escapeHTML(s);
+
+            return string.Format(formatString, s);
+        }
+
+        public static string escapeHTML(string s)
+        {
+            if (s == null)
+                return null;
+
+            StringBuilder buf = new StringBuilder(s.Length);
+            int len = s.Length;
+            for (int i = 0; i < len; i++)
+            {
+                char c = s[i];
+                switch (c)
+                {
+                case '&':
+                    buf.Append("&amp;");
+                    break;
+
+                case '<':
+                    buf.Append("&lt;");
+                    break;
+
+                case '>':
+                    buf.Append("&gt;");
+                    break;
+
+                case '\r':
+                case '\n':
+                case '\t':
+                    buf.Append(c);
+                    break;
+
+                default:
+                    bool control = c < ' '; // 32
+                    bool aboveASCII = c > 126;
+                    if (control || aboveASCII)
+                    {
+                        buf.Append("&#");
+                        buf.Append((int)c);
+                        buf.Append(";");
+                    }
+                    else
+                    {
+                        buf.Append(c);
+                    }
+                    break;
+                }
+            }
+
+            return buf.ToString();
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Template.cs b/Antlr4.StringTemplate/Template.cs
new file mode 100644
index 0000000..08c1664
--- /dev/null
+++ b/Antlr4.StringTemplate/Template.cs
@@ -0,0 +1,497 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate
+{
+    using System.Linq;
+    using System.Collections.Generic;
+    using System.Runtime.CompilerServices;
+    using Antlr4.StringTemplate.Misc;
+    using Antlr4.StringTemplate.Compiler;
+    using ArgumentException = System.ArgumentException;
+    using StringBuilder = System.Text.StringBuilder;
+    using CultureInfo = System.Globalization.CultureInfo;
+    using StringWriter = System.IO.StringWriter;
+    using Console = System.Console;
+    using IList = System.Collections.IList;
+    using System.Text.RegularExpressions;
+    using Array = System.Array;
+
+    /** An instance of the StringTemplate. It consists primarily of
+     *  a reference to its implementation (shared among all instances)
+     *  and a hash table of attributes.  Because of dynamic scoping,
+     *  we also need a reference to any enclosing instance. For example,
+     *  in a deeply nested template for an HTML page body, we could still reference
+     *  the title attribute defined in the outermost page template.
+     *
+     *  To use templates, you create one (usually via STGroup) and then inject
+     *  attributes using add(). To render its attacks, use render().
+     */
+    public class ST
+    {
+        /** <@r()>, <@r>...<@end>, and @t.r() ::= "..." defined manually by coder */
+        public enum RegionType
+        {
+            IMPLICIT,
+            EMBEDDED,
+            EXPLICIT
+        }
+
+        public static readonly string UNKNOWN_NAME = "anonymous";
+        public static readonly object EMPTY_ATTR = new object();
+
+        /** The implementation for this template among all instances of same tmpelate . */
+        public CompiledST impl;
+
+        /** Safe to simultaneously write via add, which is synchronized.  Reading
+         *  during exec is, however, NOT synchronized.  So, not thread safe to
+         *  add attributes while it is being evaluated.  Initialized to EMPTY_ATTR
+         *  to distinguish null from empty.
+         */
+        protected internal object[] locals;
+
+        /** Enclosing instance if I'm embedded within another template.
+         *  IF-subtemplates are considered embedded as well. We look up
+         *  dynamically scoped attributes with this ptr.
+         */
+        public ST enclosingInstance; // who's your daddy?
+
+        /** Created as instance of which group? We need this to init interpreter
+         *  via render.  So, we create st and then it needs to know which
+         *  group created it for sake of polymorphism:
+         *
+         *  st = skin1.getInstanceOf("searchbox");
+         *  result = st.render(); // knows skin1 created it
+         *
+         *  Say we have a group, g1, with template t and import t and u templates from
+         *  another group, g2.  g1.getInstanceOf("u") finds u in g2 but remembers
+         *  that g1 created it.  If u includes t, it should create g1.t not g2.t.
+         *
+         *   g1 = {t(), u()}
+         *   |
+         *   v
+         *   g2 = {t()}
+         */
+        public STGroup groupThatCreatedThisInstance;
+
+        /** Just an alias for ArrayList, but this way I can track whether a
+         *  list is something ST created or it's an incoming list.
+         */
+        public sealed class AttributeList : List<object>
+        {
+            public AttributeList(int capacity)
+                : base(capacity)
+            {
+            }
+
+            public AttributeList()
+            {
+            }
+        }
+
+        /** Used by group creation routine, not by users */
+        public ST()
+        {
+        }
+
+        /** Used to make templates inline in code for simple things like SQL or log records.
+         *  No formal args are set and there is no enclosing instance.
+         */
+        public ST(string template)
+            : this(STGroup.defaultGroup, template)
+        {
+        }
+
+        /** Create ST using non-default delimiters; each one of these will live
+         *  in it's own group since you're overriding a default; don't want to
+         *  alter STGroup.defaultGroup.
+         */
+        public ST(string template, char delimiterStartChar, char delimiterStopChar)
+            : this(new STGroup(delimiterStartChar, delimiterStopChar), template)
+        {
+        }
+
+        public ST(STGroup group, string template)
+        {
+            groupThatCreatedThisInstance = group;
+            impl = groupThatCreatedThisInstance.compile(group.getFileName(), null,
+                                                        null, template, null);
+            impl.hasFormalArgs = false;
+            impl.name = UNKNOWN_NAME;
+            impl.defineImplicitlyDefinedTemplates(groupThatCreatedThisInstance);
+        }
+
+        /** Clone a prototype template for application in MAP operations; copy all fields */
+        public ST(ST proto)
+        {
+            this.impl = proto.impl;
+            if (proto.locals != null)
+                this.locals = (object[])proto.locals.Clone();
+
+            this.enclosingInstance = proto.enclosingInstance;
+            this.groupThatCreatedThisInstance = proto.groupThatCreatedThisInstance;
+        }
+
+        /** Inject an attribute (name/value pair). If there is already an
+         *  attribute with that name, this method turns the attribute into an
+         *  AttributeList with both the previous and the new attribute as elements.
+         *  This method will never alter a List that you inject.  If you send
+         *  in a List and then inject a single value element, add() copies
+         *  original list and adds the new value.
+         */
+        [MethodImpl(MethodImplOptions.Synchronized)]
+        public virtual void add(string name, object value)
+        {
+            if (name == null)
+                return; // allow null value
+
+            if (name.IndexOf('.') >= 0)
+            {
+                throw new ArgumentException("cannot have '.' in attribute names");
+            }
+
+            FormalArgument arg = null;
+            if (impl.hasFormalArgs)
+            {
+                if (impl.formalArguments != null)
+                    impl.formalArguments.TryGetValue(name, out arg);
+
+                if (arg == null)
+                    throw new ArgumentException("no such attribute: " + name);
+            }
+            else
+            {
+                // define and make room in locals (a hack to make new ST("simple template") work.)
+                if (impl.formalArguments != null)
+                    impl.formalArguments.TryGetValue(name, out arg);
+
+                if (arg == null)
+                {
+                    // not defined
+                    arg = new FormalArgument(name);
+                    impl.addArg(arg);
+                    if (locals == null)
+                        locals = new object[1];
+                    else
+                        Array.Resize(ref locals, impl.formalArguments.Count);
+
+                    locals[arg.index] = EMPTY_ATTR;
+                }
+            }
+
+            if (value is ST)
+                ((ST)value).enclosingInstance = this;
+
+            object curvalue = locals[arg.index];
+            if (curvalue == EMPTY_ATTR)
+            {
+                // new attribute
+                locals[arg.index] = value;
+                return;
+            }
+
+            // attribute will be multi-valued for sure now
+            // convert current attribute to list if not already
+            // copy-on-write semantics; copy a list injected by user to add new value
+            AttributeList multi = convertToAttributeList(curvalue);
+            locals[arg.index] = multi; // replace with list
+
+            // now, add incoming value to multi-valued attribute
+            if (value is IList)
+            {
+                // flatten incoming list into existing list
+                multi.AddRange(((IList)value).Cast<object>());
+            }
+            else if (value != null && value.GetType().IsArray)
+            {
+                multi.AddRange(((Array)value).Cast<object>());
+            }
+            else
+            {
+                multi.Add(value);
+            }
+        }
+
+        /** Remove an attribute value entirely (can't remove attribute definitions). */
+        public virtual void remove(string name)
+        {
+            if (impl.formalArguments == null)
+            {
+                if (impl.hasFormalArgs)
+                    throw new ArgumentException("no such attribute: " + name);
+
+                return;
+            }
+
+            FormalArgument arg;
+            impl.formalArguments.TryGetValue(name, out arg);
+            if (arg == null)
+                throw new ArgumentException("no such attribute: " + name);
+
+            locals[arg.index] = EMPTY_ATTR; // reset value
+        }
+
+        /** Set this.locals attr value when you only know the name, not the index.
+         *  This is ultimately invoked by calling ST.add() from outside so toss
+         *  an exception to notify them.
+         */
+        protected internal virtual void rawSetAttribute(string name, object value)
+        {
+            if (impl.formalArguments == null)
+                throw new ArgumentException("no such attribute: " + name);
+
+            FormalArgument arg;
+            impl.formalArguments.TryGetValue(name, out arg);
+            if (arg == null)
+                throw new ArgumentException("no such attribute: " + name);
+
+            locals[arg.index] = value;
+        }
+
+        /** Find an attr via dynamic scoping up enclosing ST chain.
+         *  If not found, look for a map.  So attributes sent in to a template
+         *  override dictionary names.
+         */
+        public virtual object getAttribute(string name)
+        {
+            ST p = this;
+            while (p != null)
+            {
+                FormalArgument localArg = null;
+                if (p.impl.formalArguments != null)
+                    p.impl.formalArguments.TryGetValue(name, out localArg);
+
+                if (localArg != null)
+                {
+                    object o = p.locals[localArg.index];
+                    if (o == ST.EMPTY_ATTR)
+                        o = null;
+                    return o;
+                }
+
+                p = p.enclosingInstance;
+            }
+            // got to root template and no definition, try dictionaries in group
+            if (impl.nativeGroup.isDictionary(name))
+            {
+                return impl.nativeGroup.rawGetDictionary(name);
+            }
+
+            throw new STNoSuchPropertyException(name);
+        }
+
+        public virtual IDictionary<string, object> getAttributes()
+        {
+            if (impl.formalArguments == null)
+                return null;
+
+            IDictionary<string, object> attributes = new Dictionary<string, object>();
+            foreach (FormalArgument a in impl.formalArguments.Values)
+            {
+                object o = locals[a.index];
+                if (o == ST.EMPTY_ATTR)
+                    o = null;
+
+                attributes[a.name] = o;
+            }
+
+            return attributes;
+        }
+
+        protected static AttributeList convertToAttributeList(object curvalue)
+        {
+            AttributeList multi;
+            if (curvalue == null)
+            {
+                multi = new AttributeList(); // make list to hold multiple values
+                multi.Add(curvalue);                 // add previous single-valued attribute
+            }
+            else if (curvalue.GetType() == typeof(AttributeList))
+            {
+                // already a list made by ST
+                multi = (AttributeList)curvalue;
+            }
+            else if (curvalue is IList)
+            {
+                // existing attribute is non-ST List
+                // must copy to an ST-managed list before adding new attribute
+                // (can't alter incoming attributes)
+                IList listAttr = (IList)curvalue;
+                multi = new AttributeList(listAttr.Count);
+                multi.AddRange(listAttr.Cast<object>());
+            }
+            else if (curvalue.GetType().IsArray)
+            { // copy array to list
+                object[] a = (object[])curvalue;
+                multi = new AttributeList(a.Length);
+                multi.AddRange(a); // asList doesn't copy as far as I can tell
+            }
+            else
+            {
+                // curvalue nonlist and we want to add an attribute
+                // must convert curvalue existing to list
+                multi = new AttributeList(); // make list to hold multiple values
+                multi.Add(curvalue);                 // add previous single-valued attribute
+            }
+            return multi;
+        }
+
+        /** If an instance of x is enclosed in a y which is in a z, return
+         *  a String of these instance names in order from topmost to lowest;
+         *  here that would be "[z y x]".
+         */
+        public virtual string getEnclosingInstanceStackString()
+        {
+            List<ST> templates = getEnclosingInstanceStack(true);
+            StringBuilder buf = new StringBuilder();
+            int i = 0;
+            foreach (ST st in templates)
+            {
+                if (i > 0)
+                    buf.Append(" ");
+                buf.Append(st.getName());
+                i++;
+            }
+
+            return buf.ToString();
+        }
+
+        public virtual List<ST> getEnclosingInstanceStack(bool topdown)
+        {
+            List<ST> stack = new List<ST>();
+            ST p = this;
+            while (p != null)
+            {
+                if (topdown)
+                    stack.Insert(0, p);
+                else
+                    stack.Add(p);
+
+                p = p.enclosingInstance;
+            }
+            return stack;
+        }
+
+        public virtual string getName()
+        {
+            return impl.name;
+        }
+
+        public virtual bool isAnonSubtemplate()
+        {
+            return impl.isAnonSubtemplate;
+        }
+
+        public virtual int write(STWriter @out)
+        {
+            Interpreter interp = new Interpreter(groupThatCreatedThisInstance, impl.nativeGroup.errMgr);
+            interp.setDefaultArguments(this);
+            return interp.exec(@out, this);
+        }
+
+        public virtual int write(STWriter @out, CultureInfo locale)
+        {
+            Interpreter interp = new Interpreter(groupThatCreatedThisInstance, locale, impl.nativeGroup.errMgr);
+            interp.setDefaultArguments(this);
+            return interp.exec(@out, this);
+        }
+
+        public virtual int write(STWriter @out, STErrorListener listener)
+        {
+            Interpreter interp = new Interpreter(groupThatCreatedThisInstance, new ErrorManager(listener));
+            interp.setDefaultArguments(this);
+            return interp.exec(@out, this);
+        }
+
+        public virtual int write(STWriter @out, CultureInfo locale, STErrorListener listener)
+        {
+            Interpreter interp = new Interpreter(groupThatCreatedThisInstance, locale, new ErrorManager(listener));
+            interp.setDefaultArguments(this);
+            return interp.exec(@out, this);
+        }
+
+        public virtual string render()
+        {
+            return render(CultureInfo.CurrentCulture);
+        }
+
+        public virtual string render(int lineWidth)
+        {
+            return render(CultureInfo.CurrentCulture, lineWidth);
+        }
+
+        public virtual string render(CultureInfo locale)
+        {
+            return render(locale, AutoIndentWriter.NO_WRAP);
+        }
+
+        public virtual string render(CultureInfo locale, int lineWidth)
+        {
+            StringWriter @out = new StringWriter();
+            STWriter wr = new AutoIndentWriter(@out);
+            wr.setLineWidth(lineWidth);
+            write(wr, locale);
+            return @out.ToString();
+        }
+
+        public override string ToString()
+        {
+            if (impl == null)
+                return "bad-template()";
+
+            return impl.name + "()";
+        }
+
+        // ST.format("name, phone | <name>:<phone>", n, p);
+        // ST.format("<%1>:<%2>", n, p);
+        // ST.format("<name>:<phone>", "name", x, "phone", y);
+        public static string format(string template, params object[] attributes)
+        {
+            return format(AutoIndentWriter.NO_WRAP, template, attributes);
+        }
+
+        public static string format(int lineWidth, string template, params object[] attributes)
+        {
+            template = Regex.Replace(template, "[0-9]+", @"arg\0");
+            Console.WriteLine(template);
+
+            ST st = new ST(template);
+            int i = 1;
+            foreach (object a in attributes)
+            {
+                st.add("arg" + i, a);
+                i++;
+            }
+            return st.render(lineWidth);
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/TemplateGroup.cs b/Antlr4.StringTemplate/TemplateGroup.cs
new file mode 100644
index 0000000..79b17f2
--- /dev/null
+++ b/Antlr4.StringTemplate/TemplateGroup.cs
@@ -0,0 +1,655 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate
+{
+    using System.Collections.Generic;
+    using Antlr4.StringTemplate.Compiler;
+    using Type = System.Type;
+    using Antlr4.StringTemplate.Misc;
+    using Antlr.Runtime;
+    using System.Runtime.CompilerServices;
+    using ArgumentException = System.ArgumentException;
+    using Console = System.Console;
+    using Environment = System.Environment;
+    using System.Linq;
+    using Antlr4.StringTemplate.Debug;
+    using Uri = System.Uri;
+    using IDictionary = System.Collections.IDictionary;
+    using StringBuilder = System.Text.StringBuilder;
+    using File=System.IO.File;
+    using Exception = System.Exception;
+    using System.Text;
+
+    /** A directory or directory tree of .st template files and/or group files.
+     *  Individual template files contain formal template definitions. In a sense,
+     *  it's like a single group file broken into multiple files, one for each template.
+     *  ST v3 had just the pure template inside, not the template name and header.
+     *  Name inside must match filename (minus suffix).
+     */
+    public class STGroup
+    {
+        /** When we use key as a value in a dictionary, this is how we signify. */
+        public static readonly string DICT_KEY = "key";
+        public static readonly string DEFAULT_KEY = "default";
+
+        /** Load files using what encoding? */
+        public Encoding encoding;
+
+        /** Every group can import templates/dictionaries from other groups.
+         *  The list must be synchronized (see importTemplates).
+         */
+        protected List<STGroup> imports;
+
+        public char delimiterStartChar = '<'; // Use <expr> by default
+        public char delimiterStopChar = '>';
+
+        /** Maps template name to StringTemplate object. synchronized. */
+        protected IDictionary<string, CompiledST> templates = new Dictionary<string, CompiledST>();
+
+        /** Maps dict names to HashMap objects.  This is the list of dictionaries
+         *  defined by the user like typeInitMap ::= ["int":"0"]
+         */
+        protected IDictionary<string, IDictionary<string, object>> dictionaries = new Dictionary<string, IDictionary<string, object>>();
+
+        /** A dictionary that allows people to register a renderer for
+         *  a particular kind of object for any template evaluated relative to this
+         *  group.  For example, a date should be formatted differently depending
+         *  on the locale.  You can set Date.class to an object whose
+         *  toString(Object) method properly formats a Date attribute
+         *  according to locale.  Or you can have a different renderer object
+         *  for each locale.
+         *
+         *  Order of addition is recorded and matters.  If more than one
+         *  renderer works for an object, the first registered has priority.
+         *
+         *  Renderer associated with type t works for object o if
+         *
+         * 		t.isAssignableFrom(o.getClass()) // would assignment t = o work?
+         *
+         *  So it works if o is subclass or implements t.
+         *
+         *  This structure is synchronized.
+         */
+        protected TypeRegistry<AttributeRenderer> renderers;
+
+        /** A dictionary that allows people to register a model adaptor for
+         *  a particular kind of object (subclass or implementation). Applies
+         *  for any template evaluated relative to this group.
+         *
+         *  ST initializes with model adaptors that know how to pull
+         *  properties out of Objects, Maps, and STs.
+         */
+        protected TypeRegistry<ModelAdaptor> adaptors =
+            new TypeRegistry<ModelAdaptor>()
+            {
+                {typeof(object), new ObjectModelAdaptor()},
+                {typeof(ST), new STModelAdaptor()},
+                {typeof(IDictionary), new MapModelAdaptor()},
+            };
+
+        public static STGroup defaultGroup = new STGroup();
+
+        /** Used to indicate that the template doesn't exist.
+         *  Prevents duplicate group file loads and unnecessary file checks.
+         */
+        protected static readonly CompiledST NOT_FOUND_ST = new CompiledST();
+
+        public static readonly ErrorManager DEFAULT_ERR_MGR = new ErrorManager();
+
+        public static bool debug = false;
+
+        /** The errMgr for entire group; all compilations and executions.
+         *  This gets copied to parsers, walkers, and interpreters.
+         */
+        public ErrorManager errMgr = STGroup.DEFAULT_ERR_MGR;
+
+        public STGroup()
+        {
+        }
+
+        public STGroup(char delimiterStartChar, char delimiterStopChar)
+        {
+            this.delimiterStartChar = delimiterStartChar;
+            this.delimiterStopChar = delimiterStopChar;
+        }
+
+        /** The primary means of getting an instance of a template from this
+         *  group. Names must be absolute, fully-qualified names like a/b
+         */
+        public virtual ST getInstanceOf(string name)
+        {
+            if (name == null)
+                return null;
+            //System.out.println("getInstanceOf("+name+")");
+            CompiledST c = lookupTemplate(name);
+            if (c != null)
+            {
+                ST instanceST = createStringTemplate();
+                instanceST.groupThatCreatedThisInstance = this;
+                instanceST.impl = c;
+                if (instanceST.impl.formalArguments != null)
+                {
+                    instanceST.locals = new object[instanceST.impl.formalArguments.Count];
+                    for (int i = 0; i < instanceST.locals.Length; i++)
+                        instanceST.locals[i] = ST.EMPTY_ATTR;
+                }
+                return instanceST;
+            }
+            return null;
+        }
+
+        protected internal virtual ST getEmbeddedInstanceOf(ST enclosingInstance, int ip, string name)
+        {
+            ST st = getInstanceOf(name);
+            if (st == null)
+            {
+                errMgr.runTimeError(enclosingInstance, ip, ErrorType.NO_SUCH_TEMPLATE, name);
+                st = createStringTemplate();
+                st.impl = new CompiledST();
+                return st;
+            }
+            st.enclosingInstance = enclosingInstance;
+            return st;
+        }
+
+        /** Create singleton template for use with dictionary values */
+        public virtual ST createSingleton(IToken templateToken)
+        {
+            string template;
+            if (templateToken.Type == GroupParser.BIGSTRING)
+            {
+                template = Utility.strip(templateToken.Text, 2);
+            }
+            else
+            {
+                template = Utility.strip(templateToken.Text, 1);
+            }
+            ST st = createStringTemplate();
+            st.groupThatCreatedThisInstance = this;
+            st.impl = compile(getFileName(), null, null, template, templateToken);
+            st.impl.hasFormalArgs = false;
+            st.impl.name = ST.UNKNOWN_NAME;
+            st.impl.defineImplicitlyDefinedTemplates(this);
+            return st;
+        }
+
+        /** Is this template defined in this group or from this group below?
+         *  Names must be absolute, fully-qualified names like /a/b
+         */
+        public virtual bool isDefined(string name)
+        {
+            return lookupTemplate(name) != null;
+        }
+
+        /** Look up a fully-qualified name */
+        public virtual CompiledST lookupTemplate(string name)
+        {
+            CompiledST code;
+            templates.TryGetValue(name, out code);
+            if (code == NOT_FOUND_ST)
+                return null;
+
+            // try to load from disk and look up again
+            if (code == null)
+                code = load(name);
+
+            if (code == null)
+                code = lookupImportedTemplate(name);
+
+            if (code == null)
+                templates[name] = NOT_FOUND_ST;
+
+            return code;
+        }
+
+        /** "unload" all templates and dictionaries but leave renderers, adaptors,
+         *  and import relationships.  This essentially forces next getInstanceOf
+         *  to reload templates.
+         */
+        [MethodImpl(MethodImplOptions.Synchronized)]
+        public virtual void unload()
+        {
+            templates.Clear();
+            dictionaries.Clear();
+        }
+
+        /** Load st from disk if dir or load whole group file if .stg file (then
+         *  return just one template). name is fully-qualified.
+         */
+        protected virtual CompiledST load(string name)
+        {
+            return null;
+        }
+
+        /** Force a load if it makes sense for the group */
+        public virtual void load()
+        {
+        }
+
+        protected internal virtual CompiledST lookupImportedTemplate(string name)
+        {
+            //System.out.println("look for "+name+" in "+imports);
+            if (imports == null)
+                return null;
+            foreach (STGroup g in imports)
+            {
+                CompiledST code = g.lookupTemplate(name);
+                if (code != null)
+                    return code;
+            }
+            return null;
+        }
+
+        public virtual CompiledST rawGetTemplate(string name)
+        {
+            CompiledST template;
+            templates.TryGetValue(name, out template);
+            return template;
+        }
+
+        public virtual IDictionary<string, object> rawGetDictionary(string name)
+        {
+            IDictionary<string, object> dictionary;
+            dictionaries.TryGetValue(name, out dictionary);
+            return dictionary;
+        }
+
+        public virtual bool isDictionary(string name)
+        {
+            return rawGetDictionary(name) != null;
+        }
+
+        // for testing
+        public virtual CompiledST defineTemplate(string templateName, string template)
+        {
+            try
+            {
+                CompiledST impl = defineTemplate(templateName, new CommonToken(GroupParser.ID, templateName), null, template, null);
+                return impl;
+            }
+            catch (STException)
+            {
+                Console.Error.WriteLine("eh?");
+            }
+
+            return null;
+        }
+
+        // for testing
+        public virtual CompiledST defineTemplate(string name, string argsS, string template)
+        {
+            string[] args = argsS.Split(',');
+            List<FormalArgument> a = new List<FormalArgument>();
+            foreach (string arg in args)
+                a.Add(new FormalArgument(arg));
+
+            return defineTemplate(name, new CommonToken(GroupParser.ID, name), a, template, null);
+        }
+
+        public virtual CompiledST defineTemplate(string templateName,
+                                         IToken nameT,
+                                         List<FormalArgument> args,
+                                         string template,
+                                         IToken templateToken)
+        {
+            if (templateName == null || templateName.Length == 0)
+                throw new ArgumentException("empty template name");
+            if (templateName.IndexOf('.') >= 0)
+                throw new ArgumentException("cannot have '.' in template names");
+
+            template = Utility.trimOneStartingNewline(template);
+            template = Utility.trimOneTrailingNewline(template);
+            // compile, passing in templateName as enclosing name for any embedded regions
+            CompiledST code = compile(getFileName(), templateName, args, template, templateToken);
+            code.name = templateName;
+            rawDefineTemplate(templateName, code, nameT);
+            code.defineArgDefaultValueTemplates(this);
+            code.defineImplicitlyDefinedTemplates(this); // define any anonymous subtemplates
+
+            return code;
+        }
+
+        /** Make name and alias for target.  Replace any previous def of name */
+        public virtual CompiledST defineTemplateAlias(IToken aliasT, IToken targetT)
+        {
+            string alias = aliasT.Text;
+            string target = targetT.Text;
+            CompiledST targetCode;
+            templates.TryGetValue(target, out targetCode);
+            if (targetCode == null)
+            {
+                errMgr.compileTimeError(ErrorType.ALIAS_TARGET_UNDEFINED, null, aliasT, alias, target);
+                return null;
+            }
+
+            templates[alias] = targetCode;
+            return targetCode;
+        }
+
+        public virtual CompiledST defineRegion(string enclosingTemplateName,
+                                       IToken regionT,
+                                       string template)
+        {
+            string name = regionT.Text;
+            CompiledST code = compile(getFileName(), enclosingTemplateName, null, template, regionT);
+            string mangled = getMangledRegionName(enclosingTemplateName, name);
+
+            if (lookupTemplate(mangled) == null)
+            {
+                errMgr.compileTimeError(ErrorType.NO_SUCH_REGION, null, regionT, enclosingTemplateName, name);
+                return new CompiledST();
+            }
+
+            code.name = mangled;
+            code.isRegion = true;
+            code.regionDefType = ST.RegionType.EXPLICIT;
+
+            rawDefineTemplate(mangled, code, regionT);
+            return code;
+        }
+
+        public virtual void defineTemplateOrRegion(
+            string templateName,
+            string regionSurroundingTemplateName,
+            IToken templateToken,
+            string template,
+            IToken nameToken,
+            List<FormalArgument> args)
+        {
+            //int n = 1; // num char to strip from left, right of template def token text "" <<>>
+            //if (templateToken.Type == GroupLexer.BIGSTRING)
+            //    n = 2;
+            try
+            {
+                if (regionSurroundingTemplateName != null)
+                {
+                    defineRegion(regionSurroundingTemplateName, nameToken, template);
+                }
+                else
+                {
+                    defineTemplate(templateName, nameToken, args, template, templateToken);
+                }
+            }
+            catch (STException)
+            {
+                // after getting syntax error in a template, we emit msg
+                // and throw exception to blast all the way out here.
+            }
+        }
+
+        public virtual void rawDefineTemplate(string name, CompiledST code, IToken defT)
+        {
+            CompiledST prev;
+            templates.TryGetValue(name, out prev);
+            if (prev != null)
+            {
+                if (!prev.isRegion)
+                {
+                    errMgr.compileTimeError(ErrorType.TEMPLATE_REDEFINITION, null, defT);
+                    return;
+                }
+                if (prev.isRegion && prev.regionDefType == ST.RegionType.EMBEDDED)
+                {
+                    errMgr.compileTimeError(ErrorType.EMBEDDED_REGION_REDEFINITION, null, defT, getUnMangledTemplateName(name));
+                    return;
+                }
+                else if (prev.isRegion && prev.regionDefType == ST.RegionType.EXPLICIT)
+                {
+                    errMgr.compileTimeError(ErrorType.REGION_REDEFINITION, null, defT, getUnMangledTemplateName(name));
+                    return;
+                }
+            }
+
+            templates[name] = code;
+        }
+
+        public virtual void undefineTemplate(string name)
+        {
+            templates.Remove(name);
+        }
+
+        /** Compile a template */
+        public virtual CompiledST compile(string srcName,
+                                  string name,
+                                  List<FormalArgument> args,
+                                  string template,
+                                  IToken templateToken) // for error location
+        {
+            //System.out.println("STGroup.compile: "+enclosingTemplateName);
+            Compiler.Compiler c = new Compiler.Compiler(errMgr, delimiterStartChar, delimiterStopChar);
+            CompiledST code = c.compile(srcName, name, args, template, templateToken);
+            code.nativeGroup = this;
+            code.template = template;
+            return code;
+        }
+
+        /** The "foo" of t() ::= "<@foo()>" is mangled to "region#t#foo" */
+        public static string getMangledRegionName(string enclosingTemplateName, string name)
+        {
+            return "region__" + enclosingTemplateName + "__" + name;
+        }
+
+        /** Return "t.foo" from "region__t__foo" */
+        public static string getUnMangledTemplateName(string mangledName)
+        {
+            string t = mangledName.Substring("region__".Length, mangledName.LastIndexOf("__") - "region__".Length);
+            string r = mangledName.Substring(mangledName.LastIndexOf("__") + 2, mangledName.Length - mangledName.LastIndexOf("__") - 2);
+            return t + '.' + r;
+        }
+
+        /** Define a map for this group; not thread safe...do not keep adding
+         *  these while you reference them.
+         */
+        public virtual void defineDictionary(string name, IDictionary<string, object> mapping)
+        {
+            dictionaries[name] = mapping;
+        }
+
+        /** Make this group import templates/dictionaries from g. */
+        public virtual void importTemplates(STGroup g)
+        {
+            if (g == null)
+                return;
+
+            if (imports == null)
+                imports = new List<STGroup>();
+
+            imports.Add(g);
+        }
+
+        /** Load group dir or file (if .stg suffix) and then import templates. Don't hold
+         *  an independent ref to the "supergroup".
+         *
+         *  Override this if you want to look for groups elsewhere (database maybe?)
+         *
+         *  importTemplates("org.foo.proj.G.stg") will try to find file org/foo/proj/G.stg
+         *  relative to current dir or in CLASSPATH. The name is not relative to this group.
+         *  Can use "/a/b/c/myfile.stg" also or "/a/b/c/mydir".
+         *
+         *  Pass token so you can give good error if you want.
+         */
+        public virtual void importTemplates(IToken fileNameToken)
+        {
+            string fileName = fileNameToken.Text;
+            // do nothing upon syntax error
+            if (fileName == null || fileName.Equals("<missing STRING>"))
+                return;
+            fileName = Utility.strip(fileName, 1);
+            STGroup g = null;
+            if (fileName.EndsWith(".stg"))
+            {
+                g = new STGroupFile(fileName, delimiterStartChar, delimiterStopChar);
+            }
+            else
+            {
+                g = new STGroupDir(fileName, delimiterStartChar, delimiterStopChar);
+            }
+            importTemplates(g);
+        }
+
+        /** Load a group file with full path fileName; it's relative to root by prefix. */
+        public virtual void loadGroupFile(string prefix, string fileName)
+        {
+            //System.out.println("load group file prefix="+prefix+", fileName="+fileName);
+            GroupParser parser = null;
+            try
+            {
+                Uri f = new Uri(fileName);
+                ANTLRReaderStream fs = new ANTLRReaderStream(new System.IO.StreamReader(f.LocalPath, encoding ?? Encoding.UTF8));
+                GroupLexer lexer = new GroupLexer(fs);
+                fs.name = fileName;
+                CommonTokenStream tokens = new CommonTokenStream(lexer);
+                parser = new GroupParser(tokens);
+                parser.group(this, prefix);
+            }
+            catch (Exception e)
+            {
+                errMgr.IOError(null, ErrorType.CANT_LOAD_GROUP_FILE, e, fileName);
+            }
+        }
+
+        /** Add an adaptor for a kind of object so ST knows how to pull properties
+         *  from them. Add adaptors in increasing order of specificity.  ST adds Object,
+         *  Map, and ST model adaptors for you first. Adaptors you add have
+         *  priority over default adaptors.
+         *
+         *  If an adaptor for type T already exists, it is replaced by the adaptor arg.
+         *
+         *  This must invalidate cache entries, so set your adaptors up before
+         *  render()ing your templates for efficiency.
+         */
+        public virtual void registerModelAdaptor(Type attributeType, ModelAdaptor adaptor)
+        {
+            adaptors[attributeType] = adaptor;
+        }
+
+        public virtual ModelAdaptor getModelAdaptor(Type attributeType)
+        {
+            ModelAdaptor adaptor;
+            adaptors.TryGetValue(attributeType, out adaptor);
+            return adaptor;
+        }
+
+        /** Register a renderer for all objects of a particular "kind" for all
+         *  templates evaluated relative to this group.  Use r to render if
+         *  object in question is instanceof(attributeType).
+         */
+        public virtual void registerRenderer(Type attributeType, AttributeRenderer r)
+        {
+            renderers = renderers ?? new TypeRegistry<AttributeRenderer>();
+            renderers[attributeType] = r;
+        }
+
+        public virtual AttributeRenderer getAttributeRenderer(Type attributeType)
+        {
+            if (renderers == null)
+                return null;
+
+            AttributeRenderer renderer;
+            renderers.TryGetValue(attributeType, out renderer);
+            return renderer;
+        }
+
+        /** StringTemplate object factory; each group can have its own. */
+        public virtual ST createStringTemplate()
+        {
+            // TODO: try making a mem pool?
+            if (debug)
+                return new DebugST();
+
+            return new ST();
+        }
+
+        public virtual ST createStringTemplate(ST proto)
+        {
+            if (debug)
+                return new DebugST(proto);
+
+            return new ST(proto);
+        }
+
+        public virtual string getName()
+        {
+            return "<no name>;";
+        }
+
+        public virtual string getFileName()
+        {
+            return null;
+        }
+
+        public virtual string toString()
+        {
+            return getName();
+        }
+
+        public virtual string show()
+        {
+            StringBuilder buf = new StringBuilder();
+            if (imports != null)
+                buf.Append(" : " + imports);
+
+            foreach (string n in templates.Keys)
+            {
+                string name = n;
+                CompiledST c = templates[name];
+                if (c.isAnonSubtemplate || c == NOT_FOUND_ST)
+                    continue;
+
+                int slash = name.LastIndexOf('/');
+                name = name.Substring(slash + 1, name.Length - slash - 1);
+                buf.Append(name);
+                buf.Append('(');
+                if (c.formalArguments != null)
+                    buf.Append(string.Join(",", c.formalArguments.Values.Select(i => i.ToString()).ToArray()));
+
+                buf.Append(')');
+                buf.Append(" ::= <<" + Environment.NewLine);
+                buf.Append(c.template + Environment.NewLine);
+                buf.Append(">>" + Environment.NewLine);
+            }
+
+            return buf.ToString();
+        }
+
+        public virtual STErrorListener getListener()
+        {
+            return errMgr.Listener;
+        }
+
+        public virtual void setListener(STErrorListener listener)
+        {
+            errMgr = new ErrorManager(listener);
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/TemplateGroupDirectory.cs b/Antlr4.StringTemplate/TemplateGroupDirectory.cs
new file mode 100644
index 0000000..3e77a89
--- /dev/null
+++ b/Antlr4.StringTemplate/TemplateGroupDirectory.cs
@@ -0,0 +1,232 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate
+{
+    using Antlr4.StringTemplate.Compiler;
+    using IOException = System.IO.IOException;
+    using ArgumentException = System.ArgumentException;
+    using Exception = System.Exception;
+    using Thread = System.Threading.Thread;
+    using Directory = System.IO.Directory;
+    using Uri = System.Uri;
+    using Path = System.IO.Path;
+    using FileNotFoundException = System.IO.FileNotFoundException;
+    using Antlr4.StringTemplate.Misc;
+    using UriFormatException = System.UriFormatException;
+    using Antlr.Runtime;
+    using Encoding = System.Text.Encoding;
+    using NotImplementedException = System.NotImplementedException;
+    using StreamReader = System.IO.StreamReader;
+
+    // TODO: caching?
+
+    /** A directory or directory tree full of templates and/or group files.
+     *  We load files on-demand. If we fail to find a file, we look for it via
+     *  the CLASSPATH as a resource.  I track everything with URLs not file names.
+     */
+    public class STGroupDir : STGroup
+    {
+        public string groupDirName;
+        public Uri root;
+
+        public STGroupDir(string dirName)
+            : this(dirName, '<', '>')
+        {
+        }
+
+        public STGroupDir(string dirName, char delimiterStartChar, char delimiterStopChar)
+            : base(delimiterStartChar, delimiterStopChar)
+        {
+            this.groupDirName = dirName;
+            try
+            {
+                throw new NotImplementedException();
+#if false
+                //File dir = new File(dirName);
+                if (Directory.Exists(dirName))
+                {
+                    // we found the directory and it'll be file based
+                    root = dir.toURI().toURL();
+                }
+                else
+                {
+                    ClassLoader cl = Thread.CurrentThread.getContextClassLoader();
+                    root = cl.getResource(dirName);
+                    if (root == null)
+                    {
+                        cl = this.GetType().getClassLoader();
+                        root = cl.getResource(dirName);
+                    }
+                    if (root == null)
+                    {
+                        throw new ArgumentException("No such directory: " + dirName);
+                    }
+                }
+#endif
+            }
+            catch (Exception e)
+            {
+                errMgr.internalError(null, "can't load group dir " + dirName, e);
+            }
+        }
+
+        public STGroupDir(string dirName, Encoding encoding)
+            : this(dirName, encoding, '<', '>')
+        {
+        }
+
+        public STGroupDir(string dirName, Encoding encoding, char delimiterStartChar, char delimiterStopChar)
+            : this(dirName, delimiterStartChar, delimiterStopChar)
+        {
+            this.encoding = encoding;
+        }
+
+        public STGroupDir(Uri root, Encoding encoding, char delimiterStartChar, char delimiterStopChar)
+            : base(delimiterStartChar, delimiterStopChar)
+        {
+            this.root = root;
+            this.encoding = encoding;
+        }
+
+        /** Load a template from dir or group file.  Group file is given
+         *  precedence over dir with same name.
+         */
+        protected override CompiledST load(string name)
+        {
+            string parent = Utility.getPrefix(name);
+
+            Uri groupFileURL = null;
+            try
+            { // see if parent of template name is a group file
+                groupFileURL = new Uri(root + parent + ".stg");
+            }
+            catch (UriFormatException e)
+            {
+                errMgr.internalError(null, "bad URL: " + root + parent + ".stg", e);
+                return null;
+            }
+
+            throw new NotImplementedException();
+#if false
+            InputStream @is = null;
+            try
+            {
+                @is = groupFileURL.openStream();
+            }
+            catch (FileNotFoundException fnfe)
+            {
+                // must not be in a group file
+                return loadTemplateFile(parent, name + ".st"); // load t.st file
+            }
+            catch (IOException ioe)
+            {
+                errMgr.internalError(null, "can't load template file " + name, ioe);
+            }
+
+            try
+            {
+                // clean up
+                if (@is != null)
+                    @is.close();
+            }
+            catch (IOException ioe)
+            {
+                errMgr.internalError(null, "can't close template file stream " + name, ioe);
+            }
+
+            loadGroupFile(parent, root + parent + ".stg");
+
+            CompiledST template;
+            templates.TryGetValue(name, out template);
+            return template;
+#endif
+        }
+
+        /** Load full path name .st file relative to root by prefix */
+        public virtual CompiledST loadTemplateFile(string prefix, string fileName)
+        {
+            //System.out.println("load "+fileName+" from "+root+" prefix="+prefix);
+            string templateName = Path.GetFileNameWithoutExtension(fileName);
+            Uri f = null;
+            try
+            {
+                f = new Uri(root + fileName);
+            }
+            catch (UriFormatException me)
+            {
+                errMgr.runTimeError(null, 0, ErrorType.INVALID_TEMPLATE_NAME, me, root + fileName);
+                return null;
+            }
+
+            ANTLRReaderStream fs = null;
+            try
+            {
+                fs = new ANTLRReaderStream(new StreamReader(f.LocalPath, encoding ?? Encoding.UTF8));
+            }
+            catch (IOException)
+            {
+                // doesn't exist; just return null to say not found
+                return null;
+            }
+
+            GroupLexer lexer = new GroupLexer(fs);
+            fs.name = fileName;
+            CommonTokenStream tokens = new CommonTokenStream(lexer);
+            GroupParser parser = new GroupParser(tokens);
+            parser.Group = this;
+            lexer.group = this;
+            try
+            {
+                parser.templateDef(prefix);
+            }
+            catch (RecognitionException re)
+            {
+                errMgr.groupSyntaxError(ErrorType.SYNTAX_ERROR, Path.GetFileName(f.LocalPath), re, re.Message);
+            }
+
+            CompiledST template;
+            templates.TryGetValue(templateName, out template);
+            return template;
+        }
+
+        public override string getName()
+        {
+            return groupDirName;
+        }
+
+        public override string getFileName()
+        {
+            return Path.GetFileName(root.LocalPath);
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/TemplateGroupFile.cs b/Antlr4.StringTemplate/TemplateGroupFile.cs
new file mode 100644
index 0000000..52b8ed4
--- /dev/null
+++ b/Antlr4.StringTemplate/TemplateGroupFile.cs
@@ -0,0 +1,175 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate
+{
+    using System.Runtime.CompilerServices;
+    using ArgumentException = System.ArgumentException;
+    using Exception = System.Exception;
+    using Antlr4.StringTemplate.Compiler;
+    using Antlr4.StringTemplate.Misc;
+    using Path = System.IO.Path;
+    using File = System.IO.File;
+    using NotImplementedException = System.NotImplementedException;
+    using Uri = System.Uri;
+    using Encoding = System.Text.Encoding;
+
+    /** The internal representation of a single group file (which must end in
+     *  ".stg").  If we fail to find a group file, look for it via the
+     *  CLASSPATH as a resource.
+     */
+    public class STGroupFile : STGroup
+    {
+        public string fileName;
+        public Uri url;
+
+        protected bool alreadyLoaded = false;
+
+        /** Load a file relative to current dir or from root or via CLASSPATH. */
+        public STGroupFile(string fileName)
+            : this(fileName, '<', '>')
+        {
+        }
+
+        public STGroupFile(string fileName, char delimiterStartChar, char delimiterStopChar)
+            : base(delimiterStartChar, delimiterStopChar)
+        {
+            if (!fileName.EndsWith(".stg"))
+                throw new ArgumentException("Group file names must end in .stg: " + fileName);
+
+            try
+            {
+                //File f = new File(fileName);
+                if (File.Exists(fileName))
+                {
+                    url = new Uri(fileName);
+                }
+                else
+                {
+                    throw new NotImplementedException();
+#if false
+                    // try in classpath
+                    ClassLoader cl = Thread.currentThread().getContextClassLoader();
+                    url = cl.getResource(fileName);
+                    if (url == null)
+                    {
+                        cl = this.GetType().getClassLoader();
+                        url = cl.getResource(fileName);
+                    }
+
+                    if (url == null)
+                    {
+                        throw new ArgumentException("No such group file: " + fileName);
+                    }
+#endif
+                }
+            }
+            catch (Exception e)
+            {
+                errMgr.internalError(null, "can't load group file " + fileName, e);
+            }
+
+            this.fileName = fileName;
+        }
+
+        public STGroupFile(string fullyQualifiedFileName, Encoding encoding)
+            : this(fullyQualifiedFileName, encoding, '<', '>')
+        {
+        }
+
+        public STGroupFile(string fullyQualifiedFileName, Encoding encoding, char delimiterStartChar, char delimiterStopChar)
+            : this(fullyQualifiedFileName, delimiterStartChar, delimiterStopChar)
+        {
+            this.encoding = encoding;
+        }
+
+        public STGroupFile(Uri url, Encoding encoding, char delimiterStartChar, char delimiterStopChar)
+            : base(delimiterStartChar, delimiterStopChar)
+        {
+            this.url = url;
+            this.encoding = encoding;
+        }
+
+        public override bool isDefined(string name)
+        {
+            if (!alreadyLoaded)
+                load();
+            return base.isDefined(name);
+        }
+
+        [MethodImpl(MethodImplOptions.Synchronized)]
+        public override void unload()
+        {
+            base.unload();
+            alreadyLoaded = false;
+        }
+
+        protected override CompiledST load(string name)
+        {
+            if (!alreadyLoaded)
+                load();
+
+            CompiledST template;
+            templates.TryGetValue(name, out template);
+            return template;
+        }
+
+        public override void load()
+        {
+            if (alreadyLoaded)
+                return;
+
+            alreadyLoaded = true; // do before actual load to say we're doing it
+            // no prefix since this group file is the entire group, nothing lives
+            // beneath it.
+            loadGroupFile("", url.ToString());
+        }
+
+        public override string show()
+        {
+            if (!alreadyLoaded)
+                load();
+
+            return base.show();
+        }
+
+        public override string getName()
+        {
+            return Path.GetFileNameWithoutExtension(fileName);
+        }
+
+        public override string getFileName()
+        {
+            return fileName;
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/Antlr4.Test.StringTemplate.csproj b/Antlr4.Test.StringTemplate/Antlr4.Test.StringTemplate.csproj
new file mode 100644
index 0000000..4229041
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/Antlr4.Test.StringTemplate.csproj
@@ -0,0 +1,103 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>
+    </ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{1B70CBF4-B592-4A9C-B7B3-AD1A087F4B9C}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>Antlr4.Test.StringTemplate</RootNamespace>
+    <AssemblyName>Antlr4.Test.StringTemplate</AssemblyName>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <ProjectTypeGuids>{3AC096D0-A1C2-E12C-1390-A8335801FDAB};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
+    <SccProjectName>SAK</SccProjectName>
+    <SccLocalPath>SAK</SccLocalPath>
+    <SccAuxPath>SAK</SccAuxPath>
+    <SccProvider>SAK</SccProvider>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>bin\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>bin\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="Microsoft.VisualStudio.QualityTools.UnitTestFramework, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL" />
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+  </ItemGroup>
+  <ItemGroup>
+    <CodeAnalysisDependentAssemblyPaths Condition=" '$(VS100COMNTOOLS)' != '' " Include="$(VS100COMNTOOLS)..\IDE\PrivateAssemblies">
+      <Visible>False</Visible>
+    </CodeAnalysisDependentAssemblyPaths>
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="Extensions\ListExtensions.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="BaseTest.cs" />
+    <Compile Include="ErrorBufferAllErrors.cs" />
+    <Compile Include="TestCompiler.cs" />
+    <Compile Include="TestCoreBasics.cs" />
+    <Compile Include="TestDebugEvents.cs" />
+    <Compile Include="TestDictionaries.cs" />
+    <Compile Include="TestDollarDelimiters.cs" />
+    <Compile Include="TestFunctions.cs" />
+    <Compile Include="TestGroups.cs" />
+    <Compile Include="TestGroupSyntax.cs" />
+    <Compile Include="TestGroupSyntaxErrors.cs" />
+    <Compile Include="TestImports.cs" />
+    <Compile Include="TestIndentation.cs" />
+    <Compile Include="TestIndirectionAndEarlyEval.cs" />
+    <Compile Include="TestInterptimeErrors.cs" />
+    <Compile Include="TestLexer.cs" />
+    <Compile Include="TestLineWrap.cs" />
+    <Compile Include="TestLists.cs" />
+    <Compile Include="TestModelAdaptors.cs" />
+    <Compile Include="TestNullAndEmptyValues.cs" />
+    <Compile Include="TestOptions.cs" />
+    <Compile Include="TestRegions.cs" />
+    <Compile Include="TestRenderers.cs" />
+    <Compile Include="TestScopes.cs" />
+    <Compile Include="TestSubtemplates.cs" />
+    <Compile Include="TestSyntaxErrors.cs" />
+    <Compile Include="TestTokensForDollarDelimiters.cs" />
+    <Compile Include="TestWhitespace.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\..\antlr\main\runtime\CSharp3\Sources\Antlr3.Runtime\Antlr3.Runtime.csproj">
+      <Project>{8FDC0A87-9005-4D5A-AB75-E55CEB575559}</Project>
+      <Name>Antlr3.Runtime</Name>
+    </ProjectReference>
+    <ProjectReference Include="..\Antlr4.StringTemplate\Antlr4.StringTemplate.csproj">
+      <Project>{DE9B7DA2-35DD-46CC-B768-DAEE3C298660}</Project>
+      <Name>Antlr4.StringTemplate</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
\ No newline at end of file
diff --git a/Antlr4.Test.StringTemplate/Antlr4.Test.StringTemplate.csproj.vspscc b/Antlr4.Test.StringTemplate/Antlr4.Test.StringTemplate.csproj.vspscc
new file mode 100644
index 0000000..0c2d3f3
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/Antlr4.Test.StringTemplate.csproj.vspscc
@@ -0,0 +1,10 @@
+﻿""
+{
+"FILE_VERSION" = "9237"
+"ENLISTMENT_CHOICE" = "NEVER"
+"PROJECT_FILE_RELATIVE_PATH" = "relative:antlrcs\\main\\Antlr4.Test.StringTemplate"
+"NUMBER_OF_EXCLUDED_FILES" = "0"
+"ORIGINAL_PROJECT_FILE_PATH" = ""
+"NUMBER_OF_NESTED_PROJECTS" = "0"
+"SOURCE_CONTROL_SETTINGS_PROVIDER" = "PROVIDER"
+}
diff --git a/Antlr4.Test.StringTemplate/BaseTest.cs b/Antlr4.Test.StringTemplate/BaseTest.cs
new file mode 100644
index 0000000..a7d3fa7
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/BaseTest.cs
@@ -0,0 +1,186 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using Antlr4.StringTemplate.Compiler;
+    using Path = System.IO.Path;
+    using File = System.IO.File;
+    using Directory = System.IO.Directory;
+    using Environment = System.Environment;
+    using Antlr.Runtime;
+    using DateTime = System.DateTime;
+    using StringBuilder = System.Text.StringBuilder;
+
+    [TestClass]
+    public abstract class BaseTest
+    {
+        public static string tmpdir;
+        public static readonly string newline = Environment.NewLine;
+
+        public TestContext TestContext
+        {
+            get;
+            set;
+        }
+
+        [TestInitialize]
+        public virtual void setUp()
+        {
+            STGroup.defaultGroup = new STGroup();
+            Compiler.subtemplateCount = 0;
+            STGroup.debug = false;
+
+            // new output dir for each test
+            tmpdir = Path.GetFullPath(Path.Combine(Path.GetTempPath(), "st4-" + currentTimeMillis()));
+        }
+
+        [TestCleanup]
+        public void tearDown()
+        {
+            // remove tmpdir if no error. how?
+            if (TestContext != null && TestContext.CurrentTestOutcome == UnitTestOutcome.Passed)
+                eraseTempDir();
+        }
+
+        protected virtual void eraseTempDir()
+        {
+            if (Directory.Exists(tmpdir))
+                Directory.Delete(tmpdir, true);
+        }
+
+        public static long currentTimeMillis()
+        {
+            return DateTime.Now.ToFileTime() / 10000;
+        }
+
+        public static void writeFile(string dir, string fileName, string content)
+        {
+            if (!Directory.Exists(dir))
+                Directory.CreateDirectory(dir);
+
+            File.WriteAllText(Path.Combine(dir, fileName), content);
+        }
+
+        public void checkTokens(string template, string expected)
+        {
+            checkTokens(template, expected, '<', '>');
+        }
+
+
+        public void checkTokens(string template, string expected, char delimiterStartChar, char delimiterStopChar)
+        {
+            STLexer lexer =
+                new STLexer(STGroup.DEFAULT_ERR_MGR,
+                            new ANTLRStringStream(template),
+                            null,
+                            delimiterStartChar,
+                            delimiterStopChar);
+            CommonTokenStream tokens = new CommonTokenStream(lexer);
+            StringBuilder buf = new StringBuilder();
+            buf.Append("[");
+            int i = 1;
+            IToken t = tokens.LT(i);
+            while (t.Type != CharStreamConstants.EndOfFile)
+            {
+                if (i > 1)
+                    buf.Append(", ");
+                buf.Append(t);
+                i++;
+                t = tokens.LT(i);
+            }
+            buf.Append("]");
+            string result = buf.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        public class User
+        {
+            public int id;
+            public string name;
+
+            public User(int id, string name)
+            {
+                this.id = id;
+                this.name = name;
+            }
+
+            public virtual bool isManager()
+            {
+                return true;
+            }
+
+            public virtual bool hasParkingSpot()
+            {
+                return true;
+            }
+
+            public virtual string getName()
+            {
+                return name;
+            }
+        }
+
+        public class HashableUser : User
+        {
+            public HashableUser(int id, string name) : base(id, name)
+            {
+            }
+
+            public override int GetHashCode()
+            {
+                return id;
+            }
+
+            public override bool Equals(object o)
+            {
+                HashableUser hu = o as HashableUser;
+                if (hu != null)
+                    return this.id == hu.id && string.Equals(this.name, hu.name);
+
+                return false;
+            }
+        }
+
+#if false
+        public static string getRandomDir()
+        {
+            string randomDir = tmpdir + "dir" + String.valueOf((int)(Math.random() * 100000));
+            File f = new File(randomDir);
+            f.mkdirs();
+            return randomDir;
+        }
+#endif
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/ErrorBufferAllErrors.cs b/Antlr4.Test.StringTemplate/ErrorBufferAllErrors.cs
new file mode 100644
index 0000000..bf2c033
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/ErrorBufferAllErrors.cs
@@ -0,0 +1,46 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using Antlr4.StringTemplate.Misc;
+
+    public class ErrorBufferAllErrors : ErrorBuffer
+    {
+        public override void runTimeError(STMessage msg)
+        {
+            ErrorList.Add(msg);
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/Extensions/ListExtensions.cs b/Antlr4.Test.StringTemplate/Extensions/ListExtensions.cs
new file mode 100644
index 0000000..c6c0b8e
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/Extensions/ListExtensions.cs
@@ -0,0 +1,63 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate.Extensions
+{
+    using System;
+    using System.Collections.Generic;
+    using System.Linq;
+    using System.Text;
+    using Antlr4.StringTemplate;
+    using IList = System.Collections.IList;
+    using CultureInfo = System.Globalization.CultureInfo;
+
+    internal static class ListExtensions
+    {
+        public static string ToListString(this IList list)
+        {
+            STGroup group = new STGroup('$', '$');
+            group.defineTemplate("listTemplate", "list", "[$list:{x|$x$}; separator=\", \"$]");
+            group.registerRenderer(typeof(IList), new CollectionRenderer());
+            ST st = group.getInstanceOf("listTemplate");
+            st.add("list", list);
+            return st.render();
+        }
+
+        private class CollectionRenderer : AttributeRenderer
+        {
+            public string toString(object o, string formatString, CultureInfo culture)
+            {
+                return ((IList)o).ToListString();
+            }
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/Properties/AssemblyInfo.cs b/Antlr4.Test.StringTemplate/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..3e43c26
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/Properties/AssemblyInfo.cs
@@ -0,0 +1,68 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Reflection;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("Antlr4.Test.StringTemplate")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("Tunnel Vision Laboratories, LLC")]
+[assembly: AssemblyProduct("Antlr4.Test.StringTemplate")]
+[assembly: AssemblyCopyright("Copyright © Sam Harwell 2011")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+[assembly: CLSCompliant(false)]
+
+// Setting ComVisible to false makes the types in this assembly not visible
+// to COM components.  If you need to access a type in this assembly from
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("b9f5baf7-993e-434d-a217-1c8a4e2337a9")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers
+// by using the '*' as shown below:
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/Antlr4.Test.StringTemplate/TestCompiler.cs b/Antlr4.Test.StringTemplate/TestCompiler.cs
new file mode 100644
index 0000000..d23b847
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/TestCompiler.cs
@@ -0,0 +1,591 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using Antlr4.StringTemplate.Compiler;
+    using Antlr4.Test.StringTemplate.Extensions;
+    using Antlr4.StringTemplate.Misc;
+
+    [TestClass]
+    public class TestCompiler : BaseTest
+    {
+        public override void setUp()
+        {
+            Compiler.subtemplateCount = 0;
+            base.setUp();
+        }
+
+        [TestMethod]
+        public void TestAttr()
+        {
+            string template = "hi <name>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "load_str 0, " +
+                "write, " +
+                "load_attr 1, " +
+                "write";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[hi , name]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestInclude()
+        {
+            string template = "hi <foo()>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "load_str 0, write, new 1 0, write";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[hi , foo]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestSuperInclude()
+        {
+            string template = "<super.foo()>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "super_new 0 0, write";
+            code.dump();
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[foo]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestSuperIncludeWithArgs()
+        {
+            string template = "<super.foo(a,{b})>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "load_attr 0, new 1 0, super_new 2 2, write";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[a, _sub1, foo]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestSuperIncludeWithNamedArgs()
+        {
+            string template = "<super.foo(x=a,y={b})>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "args, load_attr 0, store_arg 1, new 2 0, store_arg 3, super_new_box_args 4, write";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[a, x, _sub1, y, foo]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestIncludeWithArgs()
+        {
+            string template = "hi <foo(a,b)>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "load_str 0, write, load_attr 1, load_attr 2, new 3 2, write";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[hi , a, b, foo]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestAnonIncludeArgs()
+        {
+            string template = "<({ a, b | <a><b>})>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "new 0 0, tostr, write";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[_sub1]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestAnonIncludeArgMismatch()
+        {
+            STErrorListener errors = new ErrorBuffer();
+            string template = "<a:{foo}>";
+            CompiledST code = new Compiler(new ErrorManager(errors)).compile(template);
+            string expected = "1:3: anonymous template has 0 arg(s) but mapped across 1 value(s)" + newline;
+            Assert.AreEqual(expected, errors.ToString());
+        }
+
+        [TestMethod]
+        public void TestAnonIncludeArgMismatch2()
+        {
+            STErrorListener errors = new ErrorBuffer();
+            string template = "<a,b:{x|foo}>";
+            CompiledST code = new Compiler(new ErrorManager(errors)).compile(template);
+            string expected = "1:5: anonymous template has 1 arg(s) but mapped across 2 value(s)" + newline;
+            Assert.AreEqual(expected, errors.ToString());
+        }
+
+        [TestMethod]
+        public void TestAnonIncludeArgMismatch3()
+        {
+            STErrorListener errors = new ErrorBuffer();
+            string template = "<a:{x|foo},{bar}>";
+            CompiledST code = new Compiler(new ErrorManager(errors)).compile(template);
+            string expected = "1:11: anonymous template has 0 arg(s) but mapped across 1 value(s)" + newline;
+            Assert.AreEqual(expected, errors.ToString());
+        }
+
+        [TestMethod]
+        public void TestIndirectIncludeWitArgs()
+        {
+            string template = "hi <(foo)(a,b)>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "load_str 0, write, load_attr 1, tostr, load_attr 2, load_attr 3, new_ind 2, write";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[hi , foo, a, b]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestProp()
+        {
+            string template = "hi <a.b>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "load_str 0, write, load_attr 1, load_prop 2, write";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[hi , a, b]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestProp2()
+        {
+            string template = "<u.id>: <u.name>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "load_attr 0, load_prop 1, write, load_str 2, write, " +
+                "load_attr 0, load_prop 3, write";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[u, id, : , name]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestMap()
+        {
+            string template = "<name:bold()>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "load_attr 0, null, new 1 1, map, write";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[name, bold]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestMapAsOption()
+        {
+            string template = "<a; wrap=name:bold()>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "load_attr 0, options, load_attr 1, null, new 2 1, map, " +
+                "store_option 4, write_opt";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[a, name, bold]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestMapArg()
+        {
+            string template = "<name:bold(x)>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "load_attr 0, null, load_attr 1, new 2 2, map, write";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[name, x, bold]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestIndirectMapArg()
+        {
+            string template = "<name:(t)(x)>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "load_attr 0, load_attr 1, tostr, null, load_attr 2, new_ind 2, map, write";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[name, t, x]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestRepeatedMap()
+        {
+            string template = "<name:bold():italics()>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "load_attr 0, null, new 1 1, map, null, new 2 1, map, write";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[name, bold, italics]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestRepeatedMapArg()
+        {
+            string template = "<name:bold(x):italics(x,y)>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "load_attr 0, null, load_attr 1, new 2 2, map, " +
+                "null, load_attr 1, load_attr 3, new 4 3, map, write";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[name, x, bold, y, italics]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestRotMap()
+        {
+            string template = "<name:bold(),italics()>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "load_attr 0, null, new 1 1, null, new 2 1, rot_map 2, write";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[name, bold, italics]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestRotMapArg()
+        {
+            string template = "<name:bold(x),italics()>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "load_attr 0, null, load_attr 1, new 2 2, null, new 3 1, rot_map 2, write";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[name, x, bold, italics]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestZipMap()
+        {
+            string template = "<names,phones:bold()>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "load_attr 0, load_attr 1, null, null, new 2 2, zip_map 2, write";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[names, phones, bold]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestZipMapArg()
+        {
+            string template = "<names,phones:bold(x)>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "load_attr 0, load_attr 1, null, null, load_attr 2, new 3 3, zip_map 2, write";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[names, phones, x, bold]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestAnonMap()
+        {
+            string template = "<name:{n | <n>}>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "load_attr 0, null, new 1 1, map, write";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[name, _sub1]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestAnonZipMap()
+        {
+            string template = "<a,b:{x,y | <x><y>}>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "load_attr 0, load_attr 1, null, null, new 2 2, zip_map 2, write";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[a, b, _sub1]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestIf()
+        {
+            string template = "go: <if(name)>hi, foo<endif>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "load_str 0, write, load_attr 1, brf 14, load_str 2, write";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[go: , name, hi, foo]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestIfElse()
+        {
+            string template = "go: <if(name)>hi, foo<else>bye<endif>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "load_str 0, " +
+                "write, " +
+                "load_attr 1, " +
+                "brf 17, " +
+                "load_str 2, " +
+                "write, " +
+                "br 21, " +
+                "load_str 3, " +
+                "write";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[go: , name, hi, foo, bye]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestElseIf()
+        {
+            string template = "go: <if(name)>hi, foo<elseif(user)>a user<endif>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "load_str 0, " +
+                "write, " +
+                "load_attr 1, " +
+                "brf 17, " +
+                "load_str 2, " +
+                "write, " +
+                "br 27, " +
+                "load_attr 3, " +
+                "brf 27, " +
+                "load_str 4, " +
+                "write";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[go: , name, hi, foo, user, a user]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestElseIfElse()
+        {
+            string template = "go: <if(name)>hi, foo<elseif(user)>a user<else>bye<endif>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "load_str 0, " +
+                "write, " +
+                "load_attr 1, " +
+                "brf 17, " +
+                "load_str 2, " +
+                "write, " +
+                "br 34, " +
+                "load_attr 3, " +
+                "brf 30, " +
+                "load_str 4, " +
+                "write, " +
+                "br 34, " +
+                "load_str 5, " +
+                "write";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[go: , name, hi, foo, user, a user, bye]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestOption()
+        {
+            string template = "hi <name; separator=\"x\">";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "load_str 0, write, load_attr 1, options, load_str 2, store_option 3, write_opt";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[hi , name, x]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestOptionAsTemplate()
+        {
+            string template = "hi <name; separator={, }>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "load_str 0, write, load_attr 1, options, new 2 0, store_option 3, write_opt";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[hi , name, _sub1]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestOptions()
+        {
+            string template = "hi <name; anchor, wrap=foo(), separator=\", \">";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected =
+                "load_str 0, " +
+                "write, " +
+                "load_attr 1, " +
+                "options, " +
+                "load_str 2, " +
+                "store_option 0, " +
+                "new 3 0, " +
+                "store_option 4, " +
+                "load_str 4, " +
+                "store_option 3, " +
+                "write_opt";
+            string stringsExpected = // the ", , ," is the ", " separator string
+                "[hi , name, true, foo, , ]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+        }
+
+        [TestMethod]
+        public void TestEmptyList()
+        {
+            string template = "<[]>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected = "list, write";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestList()
+        {
+            string template = "<[a,b]>";
+            CompiledST code = new Compiler().compile(template);
+            string asmExpected = "list, load_attr 0, add, load_attr 1, add, write";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[a, b]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestEmbeddedRegion()
+        {
+            string template = "<@r>foo<@end>";
+            // compile as if in root dir and in template 'a'
+            CompiledST code = new Compiler('<', '>').compile("a", template);
+            string asmExpected =
+                "new 0 0, write";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[region__a__r]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestRegion()
+        {
+            string template = "x:<@r()>";
+            // compile as if in root dir and in template 'a'
+            CompiledST code = new Compiler('<', '>').compile("a", template);
+            string asmExpected =
+                "load_str 0, write, new 1 0, write";
+            string asmResult = code.Instrs();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[x:, region__a__r]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/TestCoreBasics.cs b/Antlr4.Test.StringTemplate/TestCoreBasics.cs
new file mode 100644
index 0000000..43ad485
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/TestCoreBasics.cs
@@ -0,0 +1,822 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using StringWriter = System.IO.StringWriter;
+    using Antlr4.StringTemplate.Misc;
+    using ArgumentException = System.ArgumentException;
+    using System.Collections.Generic;
+
+    [TestClass]
+    public class TestCoreBasics : BaseTest
+    {
+        [TestMethod]
+        public void TestNullAttr()
+        {
+            string template = "hi <name>!";
+            ST st = new ST(template);
+            string expected =
+                "hi !";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestAttr()
+        {
+            string template = "hi <name>!";
+            ST st = new ST(template);
+            st.add("name", "Ter");
+            string expected = "hi Ter!";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSetUnknownAttr()
+        {
+            string templates =
+                "t() ::= <<hi <name>!>>\n";
+            ErrorBuffer errors = new ErrorBuffer();
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            ST st = group.getInstanceOf("t");
+            string result = null;
+            try
+            {
+                st.add("name", "Ter");
+            }
+            catch (ArgumentException iae)
+            {
+                result = iae.Message;
+            }
+            string expected = "no such attribute: name";
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestMultiAttr()
+        {
+            string template = "hi <name>!";
+            ST st = new ST(template);
+            st.add("name", "Ter");
+            st.add("name", "Tom");
+            string expected =
+                "hi TerTom!";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestAttrIsList()
+        {
+            string template = "hi <name>!";
+            ST st = new ST(template);
+            List<string> names = new List<string>() { "Ter", "Tom" };
+            st.add("name", names);
+            st.add("name", "Sumana"); // shouldn't alter my version of names list!
+            string expected =
+                "hi TerTomSumana!";  // ST sees 3 names
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+
+            Assert.IsTrue(names.Count == 2); // my names list is still just 2
+        }
+
+        [TestMethod]
+        public void TestAttrIsArray()
+        {
+            string template = "hi <name>!";
+            ST st = new ST(template);
+            string[] names = new string[] { "Ter", "Tom" };
+            st.add("name", names);
+            st.add("name", "Sumana"); // shouldn't alter my version of names list!
+            string expected =
+                "hi TerTomSumana!";  // ST sees 3 names
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestProp()
+        {
+            string template = "<u.id>: <u.name>"; // checks field and method getter
+            ST st = new ST(template);
+            st.add("u", new User(1, "parrt"));
+            string expected = "1: parrt";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSTProp()
+        {
+            string template = "<t.x>"; // get x attr of template t
+            ST st = new ST(template);
+            ST t = new ST("<x>");
+            t.add("x", "Ter");
+            st.add("t", t);
+            string expected = "Ter";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestBooleanISProp()
+        {
+            string template = "<t.manager>"; // call isManager
+            ST st = new ST(template);
+            st.add("t", new User(32, "Ter"));
+            string expected = "true";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestBooleanHASProp()
+        {
+            string template = "<t.parkingSpot>"; // call hasParkingSpot
+            ST st = new ST(template);
+            st.add("t", new User(32, "Ter"));
+            string expected = "true";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestNullAttrProp()
+        {
+            string template = "<u.id>: <u.name>";
+            ST st = new ST(template);
+            string expected = ": ";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestNoSuchProp()
+        {
+            ErrorBufferAllErrors errors = new ErrorBufferAllErrors();
+            string template = "<u.qqq>";
+            STGroup group = new STGroup();
+            group.setListener(errors);
+            ST st = new ST(group, template);
+            st.add("u", new User(1, "parrt"));
+            string expected = "";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+            STRuntimeMessage msg = (STRuntimeMessage)errors.Errors[0];
+            STNoSuchPropertyException e = (STNoSuchPropertyException)msg.Cause;
+            Assert.AreEqual("org.stringtemplate.v4.test.BaseTest$User.qqq", e.PropertyName);
+        }
+
+        [TestMethod]
+        public void TestNullIndirectProp()
+        {
+            ErrorBufferAllErrors errors = new ErrorBufferAllErrors();
+            STGroup group = new STGroup();
+            group.setListener(errors);
+            string template = "<u.(qqq)>";
+            ST st = new ST(group, template);
+            st.add("u", new User(1, "parrt"));
+            st.add("qqq", null);
+            string expected = "";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+            STRuntimeMessage msg = (STRuntimeMessage)errors.Errors[0];
+            STNoSuchPropertyException e = (STNoSuchPropertyException)msg.Cause;
+            Assert.AreEqual("org.stringtemplate.v4.test.BaseTest$User.null", e.PropertyName);
+        }
+
+        [TestMethod]
+        public void TestPropConvertsToString()
+        {
+            ErrorBufferAllErrors errors = new ErrorBufferAllErrors();
+            STGroup group = new STGroup();
+            group.setListener(errors);
+            string template = "<u.(name)>";
+            ST st = new ST(group, template);
+            st.add("u", new User(1, "parrt"));
+            st.add("name", 100);
+            string expected = "";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+            STRuntimeMessage msg = (STRuntimeMessage)errors.Errors[0];
+            STNoSuchPropertyException e = (STNoSuchPropertyException)msg.Cause;
+            Assert.AreEqual("org.stringtemplate.v4.test.BaseTest$User.100", e.PropertyName);
+        }
+
+        [TestMethod]
+        public void TestInclude()
+        {
+            string template = "load <box()>;";
+            ST st = new ST(template);
+            st.impl.nativeGroup.defineTemplate("box", "kewl\ndaddy");
+            string expected =
+                "load kewl\n" +
+                "daddy;";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestIncludeWithArg()
+        {
+            string template = "load <box(\"arg\")>;";
+            ST st = new ST(template);
+            st.impl.nativeGroup.defineTemplate("box", "x", "kewl <x> daddy");
+            st.impl.dump();
+            st.add("name", "Ter");
+            string expected = "load kewl arg daddy;";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestIncludeWithArg2()
+        {
+            string template = "load <box(\"arg\", foo())>;";
+            ST st = new ST(template);
+            st.impl.nativeGroup.defineTemplate("box", "x,y", "kewl <x> <y> daddy");
+            st.impl.nativeGroup.defineTemplate("foo", "blech");
+            st.add("name", "Ter");
+            string expected = "load kewl arg blech daddy;";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestIncludeWithNestedArgs()
+        {
+            string template = "load <box(foo(\"arg\"))>;";
+            ST st = new ST(template);
+            st.impl.nativeGroup.defineTemplate("box", "y", "kewl <y> daddy");
+            st.impl.nativeGroup.defineTemplate("foo", "x", "blech <x>");
+            st.add("name", "Ter");
+            string expected = "load kewl blech arg daddy;";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestDefineTemplate()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("inc", "x", "<x>+1");
+            group.defineTemplate("test", "name", "hi <name>!");
+            ST st = group.getInstanceOf("test");
+            st.add("name", "Ter");
+            st.add("name", "Tom");
+            st.add("name", "Sumana");
+            string expected =
+                "hi TerTomSumana!";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestMap()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("inc", "x", "[<x>]");
+            group.defineTemplate("test", "name", "hi <name:inc()>!");
+            ST st = group.getInstanceOf("test");
+            st.add("name", "Ter");
+            st.add("name", "Tom");
+            st.add("name", "Sumana");
+            string expected =
+                "hi [Ter][Tom][Sumana]!";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestIndirectMap()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("inc", "x", "[<x>]");
+            group.defineTemplate("test", "t,name", "<name:(t)()>!");
+            ST st = group.getInstanceOf("test");
+            st.add("t", "inc");
+            st.add("name", "Ter");
+            st.add("name", "Tom");
+            st.add("name", "Sumana");
+            string expected =
+                "[Ter][Tom][Sumana]!";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestMapWithExprAsTemplateName()
+        {
+            string templates =
+                "d ::= [\"foo\":\"bold\"]\n" +
+                "test(name) ::= \"<name:(d.foo)()>\"\n" +
+                "bold(x) ::= <<*<x>*>>\n";
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            ST st = group.getInstanceOf("test");
+            st.add("name", "Ter");
+            st.add("name", "Tom");
+            st.add("name", "Sumana");
+            string expected = "*Ter**Tom**Sumana*";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestParallelMap()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "names,phones", "hi <names,phones:{n,p | <n>:<p>;}>");
+            ST st = group.getInstanceOf("test");
+            st.add("names", "Ter");
+            st.add("names", "Tom");
+            st.add("names", "Sumana");
+            st.add("phones", "x5001");
+            st.add("phones", "x5002");
+            st.add("phones", "x5003");
+            string expected =
+                "hi Ter:x5001;Tom:x5002;Sumana:x5003;";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestParallelMapWith3Versus2Elements()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "names,phones", "hi <names,phones:{n,p | <n>:<p>;}>");
+            ST st = group.getInstanceOf("test");
+            st.add("names", "Ter");
+            st.add("names", "Tom");
+            st.add("names", "Sumana");
+            st.add("phones", "x5001");
+            st.add("phones", "x5002");
+            string expected =
+                "hi Ter:x5001;Tom:x5002;Sumana:;";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestParallelMapThenMap()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("bold", "x", "[<x>]");
+            group.defineTemplate("test", "names,phones",
+                                 "hi <names,phones:{n,p | <n>:<p>;}:bold()>");
+            ST st = group.getInstanceOf("test");
+            st.add("names", "Ter");
+            st.add("names", "Tom");
+            st.add("names", "Sumana");
+            st.add("phones", "x5001");
+            st.add("phones", "x5002");
+            string expected =
+                "hi [Ter:x5001;][Tom:x5002;][Sumana:;]";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestMapThenParallelMap()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("bold", "x", "[<x>]");
+            group.defineTemplate("test", "names,phones",
+                                 "hi <[names:bold()],phones:{n,p | <n>:<p>;}>");
+            ST st = group.getInstanceOf("test");
+            st.add("names", "Ter");
+            st.add("names", "Tom");
+            st.add("names", "Sumana");
+            st.add("phones", "x5001");
+            st.add("phones", "x5002");
+            string expected =
+                "hi [Ter]:x5001;[Tom]:x5002;[Sumana]:;";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestMapIndexes()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("inc", "x,i", "<i>:<x>");
+            group.defineTemplate("test", "name", "<name:{n|<inc(n,i)>}; separator=\", \">");
+            ST st = group.getInstanceOf("test");
+            st.add("name", "Ter");
+            st.add("name", "Tom");
+            st.add("name", null); // don't count this one
+            st.add("name", "Sumana");
+            string expected =
+                "1:Ter, 2:Tom, 3:Sumana";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestMapIndexes2()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "name", "<name:{n | <i>:<n>}; separator=\", \">");
+            ST st = group.getInstanceOf("test");
+            st.add("name", "Ter");
+            st.add("name", "Tom");
+            st.add("name", null); // don't count this one. still can't apply subtemplate to null value
+            st.add("name", "Sumana");
+            string expected =
+                "1:Ter, 2:Tom, 3:Sumana";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestMapSingleValue()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("a", "x", "[<x>]");
+            group.defineTemplate("test", "name", "hi <name:a()>!");
+            ST st = group.getInstanceOf("test");
+            st.add("name", "Ter");
+            string expected = "hi [Ter]!";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestMapNullValue()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("a", "x", "[<x>]");
+            group.defineTemplate("test", "name", "hi <name:a()>!");
+            ST st = group.getInstanceOf("test");
+            string expected = "hi !";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestMapNullValueInList()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "name", "<name; separator=\", \">");
+            ST st = group.getInstanceOf("test");
+            st.add("name", "Ter");
+            st.add("name", "Tom");
+            st.add("name", null); // don't print this one
+            st.add("name", "Sumana");
+            string expected =
+                "Ter, Tom, Sumana";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestRepeatedMap()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("a", "x", "[<x>]");
+            group.defineTemplate("b", "x", "(<x>)");
+            group.defineTemplate("test", "name", "hi <name:a():b()>!");
+            ST st = group.getInstanceOf("test");
+            st.add("name", "Ter");
+            st.add("name", "Tom");
+            st.add("name", "Sumana");
+            string expected =
+                "hi ([Ter])([Tom])([Sumana])!";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestRoundRobinMap()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("a", "x", "[<x>]");
+            group.defineTemplate("b", "x", "(<x>)");
+            group.defineTemplate("test", "name", "hi <name:a(),b()>!");
+            ST st = group.getInstanceOf("test");
+            st.add("name", "Ter");
+            st.add("name", "Tom");
+            st.add("name", "Sumana");
+            string expected =
+                "hi [Ter](Tom)[Sumana]!";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestTrueCond()
+        {
+            string template = "<if(name)>works<endif>";
+            ST st = new ST(template);
+            st.add("name", "Ter");
+            string expected = "works";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestCondParens()
+        {
+            string template = "<if(!(x||y)&&!z)>works<endif>";
+            ST st = new ST(template);
+            string expected = "works";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestFalseCond()
+        {
+            string template = "<if(name)>works<endif>";
+            ST st = new ST(template);
+            string expected = "";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestFalseCond2()
+        {
+            string template = "<if(name)>works<endif>";
+            ST st = new ST(template);
+            st.add("name", null);
+            string expected = "";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestFalseCondWithFormalArgs()
+        {
+            // insert of indent instr was not working; ok now
+            string dir = tmpdir;
+            string groupFile =
+                "a(scope) ::= <<\n" +
+                "foo\n" +
+                "    <if(scope)>oops<endif>\n" +
+                "bar\n" +
+                ">>\n";
+            writeFile(dir, "group.stg", groupFile);
+            STGroupFile group = new STGroupFile(dir + "/group.stg");
+            ST st = group.getInstanceOf("a");
+            st.impl.dump();
+            string expected = "foo\n" +
+                              "bar";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestNotTrueCond()
+        {
+            string template = "<if(!name)>works<endif>";
+            ST st = new ST(template);
+            st.add("name", "Ter");
+            string expected = "";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestNotFalseCond()
+        {
+            string template = "<if(!name)>works<endif>";
+            ST st = new ST(template);
+            string expected = "works";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestTrueCondWithElse()
+        {
+            string template = "<if(name)>works<else>fail<endif>";
+            ST st = new ST(template);
+            st.add("name", "Ter");
+            string expected = "works";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestFalseCondWithElse()
+        {
+            string template = "<if(name)>fail<else>works<endif>";
+            ST st = new ST(template);
+            string expected = "works";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestElseIf()
+        {
+            string template = "<if(name)>fail<elseif(id)>works<else>fail<endif>";
+            ST st = new ST(template);
+            st.add("id", "2DF3DF");
+            string expected = "works";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestElseIfNoElseAllFalse()
+        {
+            string template = "<if(name)>fail<elseif(id)>fail<endif>";
+            ST st = new ST(template);
+            string expected = "";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestElseIfAllExprFalse()
+        {
+            string template = "<if(name)>fail<elseif(id)>fail<else>works<endif>";
+            ST st = new ST(template);
+            string expected = "works";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestOr()
+        {
+            string template = "<if(name||notThere)>works<else>fail<endif>";
+            ST st = new ST(template);
+            st.add("name", "Ter");
+            string expected = "works";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestMapConditionAndEscapeInside()
+        {
+            string template = "<if(m.name)>works \\\\<endif>";
+            ST st = new ST(template);
+            IDictionary<string, string> m = new Dictionary<string, string>();
+            m["name"] = "Ter";
+            st.add("m", m);
+            string expected = "works \\";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestAnd()
+        {
+            string template = "<if(name&&notThere)>fail<else>works<endif>";
+            ST st = new ST(template);
+            st.add("name", "Ter");
+            string expected = "works";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestAndNot()
+        {
+            string template = "<if(name&&!notThere)>works<else>fail<endif>";
+            ST st = new ST(template);
+            st.add("name", "Ter");
+            string expected = "works";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestCharLiterals()
+        {
+            ST st = new ST(
+                    "Foo <\\n><\\n><\\t> bar\n"
+                    );
+            StringWriter sw = new StringWriter();
+            st.write(new AutoIndentWriter(sw, "\n")); // force \n as newline
+            string result = sw.ToString();
+            string expecting = "Foo \n\n\t bar\n";     // expect \n in output
+            Assert.AreEqual(expecting, result);
+
+            st = new ST(
+                    "Foo <\\n><\\t> bar" + newline);
+            sw = new StringWriter();
+            st.write(new AutoIndentWriter(sw, "\n")); // force \n as newline
+            expecting = "Foo \n\t bar\n";     // expect \n in output
+            result = sw.ToString();
+            Assert.AreEqual(expecting, result);
+
+            st = new ST(
+                    "Foo<\\ >bar<\\n>");
+            sw = new StringWriter();
+            st.write(new AutoIndentWriter(sw, "\n")); // force \n as newline
+            result = sw.ToString();
+            expecting = "Foo bar\n"; // forced \n
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestUnicodeLiterals()
+        {
+            ST st = new ST(
+                    "Foo <\\uFEA5><\\n><\\u00C2> bar\n"
+                    );
+            string expecting = "Foo \ufea5" + newline + "\u00C2 bar" + newline;
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+
+            st = new ST(
+                    "Foo <\\uFEA5><\\n><\\u00C2> bar" + newline);
+            expecting = "Foo \ufea5" + newline + "\u00C2 bar" + newline;
+            result = st.render();
+            Assert.AreEqual(expecting, result);
+
+            st = new ST(
+                    "Foo<\\ >bar<\\n>");
+            expecting = "Foo bar" + newline;
+            result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestSubtemplateExpr()
+        {
+            string template = "<{name\n}>";
+            ST st = new ST(template);
+            string expected =
+                "name" + newline;
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSeparator()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "names", "<names:{n | case <n>}; separator=\", \">");
+            ST st = group.getInstanceOf("test");
+            st.add("names", "Ter");
+            st.add("names", "Tom");
+            string expected =
+                "case Ter, case Tom";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSeparatorInList()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "names", "<names:{n | case <n>}; separator=\", \">");
+            ST st = group.getInstanceOf("test");
+            st.add("names", new List<string>() { "Ter", "Tom" });
+            string expected =
+                "case Ter, case Tom";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void Playing()
+        {
+            string template = "<a:t(x,y),u()>";
+            ST st = new ST(template);
+            st.impl.dump();
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/TestDebugEvents.cs b/Antlr4.Test.StringTemplate/TestDebugEvents.cs
new file mode 100644
index 0000000..9bf4276
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/TestDebugEvents.cs
@@ -0,0 +1,106 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using Environment = System.Environment;
+    using Antlr4.StringTemplate.Debug;
+    using Antlr4.Test.StringTemplate.Extensions;
+    using System.Collections.Generic;
+
+    [TestClass]
+    public class TestDebugEvents : BaseTest
+    {
+        [TestMethod]
+        public void TestString()
+        {
+            string templates =
+                "t() ::= <<foo>>" + Environment.NewLine;
+
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            STGroup.debug = true;
+            DebugST st = (DebugST)group.getInstanceOf("t");
+            List<InterpEvent> events = st.getEvents();
+            string expected =
+                "[EvalExprEvent{self=t(), start=0, stop=2, expr=foo}," +
+                " EvalTemplateEvent{self=t(), start=0, stop=2}]";
+            string result = events.ToListString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestAttribute()
+        {
+            string templates =
+                "t(x) ::= << <x> >>" + Environment.NewLine;
+
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            STGroup.debug = true;
+            DebugST st = (DebugST)group.getInstanceOf("t");
+            List<InterpEvent> events = st.getEvents();
+            string expected =
+                "[EvalExprEvent{self=t(), start=0, stop=-1, expr=<x>}," +
+                " EvalExprEvent{self=t(), start=0, stop=0, expr= }," +
+                " EvalTemplateEvent{self=t(), start=0, stop=0}]";
+            string result = events.ToListString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestTemplateCall()
+        {
+            string templates =
+                "t(x) ::= <<[<u()>]>>\n" +
+                "u() ::= << <x> >>\n";
+
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            STGroup.debug = true;
+            DebugST st = (DebugST)group.getInstanceOf("t");
+            List<InterpEvent> events = st.getEvents();
+            string expected =
+                "[EvalExprEvent{self=t(), start=0, stop=0, expr=[}," +
+                " EvalExprEvent{self=u(), start=1, stop=0, expr=<x>}," +
+                " EvalExprEvent{self=u(), start=1, stop=1, expr= }," +
+                " EvalTemplateEvent{self=u(), start=1, stop=1}," +
+                " EvalExprEvent{self=t(), start=1, stop=1, expr=<u()>}," +
+                " EvalExprEvent{self=t(), start=2, stop=2, expr=]}," +
+                " EvalTemplateEvent{self=t(), start=0, stop=2}]";
+            string result = events.ToListString();
+            Assert.AreEqual(expected, result);
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/TestDictionaries.cs b/Antlr4.Test.StringTemplate/TestDictionaries.cs
new file mode 100644
index 0000000..37596d8
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/TestDictionaries.cs
@@ -0,0 +1,333 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using System.Collections.Generic;
+    using Antlr4.StringTemplate.Misc;
+
+    [TestClass]
+    public class TestDictionaries : BaseTest
+    {
+        [TestMethod]
+        public void TestDict()
+        {
+            string templates =
+                    "typeInit ::= [\"int\":\"0\", \"float\":\"0.0\"] " + newline +
+                    "var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
+                    ;
+            writeFile(tmpdir, "test.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
+            ST st = group.getInstanceOf("var");
+            st.add("type", "int");
+            st.add("name", "x");
+            string expecting = "int x = 0;";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDictValuesAreTemplates()
+        {
+            string templates =
+                    "typeInit ::= [\"int\":{0<w>}, \"float\":{0.0<w>}] " + newline +
+                    "var(type,w,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
+                    ;
+            writeFile(tmpdir, "test.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
+            ST st = group.getInstanceOf("var");
+            st.impl.dump();
+            st.add("w", "L");
+            st.add("type", "int");
+            st.add("name", "x");
+            string expecting = "int x = 0L;";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDictKeyLookupViaTemplate()
+        {
+            // Make sure we try rendering stuff to string if not found as regular object
+            string templates =
+                    "typeInit ::= [\"int\":{0<w>}, \"float\":{0.0<w>}] " + newline +
+                    "var(type,w,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
+                    ;
+            writeFile(tmpdir, "test.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
+            ST st = group.getInstanceOf("var");
+            st.add("w", "L");
+            st.add("type", new ST("int"));
+            st.add("name", "x");
+            string expecting = "int x = 0L;";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDictKeyLookupAsNonToStringableObject()
+        {
+            // Make sure we try rendering stuff to string if not found as regular object
+            string templates =
+                    "foo(m,k) ::= \"<m.(k)>\"" + newline
+                    ;
+            writeFile(tmpdir, "test.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
+            ST st = group.getInstanceOf("foo");
+            IDictionary<HashableUser, string> m = new Dictionary<HashableUser, string>();
+            m[new HashableUser(99, "parrt")] = "first";
+            m[new HashableUser(172036, "tombu")] = "second";
+            m[new HashableUser(391, "sriram")] = "third";
+            st.add("m", m);
+            st.add("k", new HashableUser(172036, "tombu"));
+            string expecting = "second";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDictMissingDefaultValueIsEmpty()
+        {
+            string templates =
+                    "typeInit ::= [\"int\":\"0\", \"float\":\"0.0\"] " + newline +
+                    "var(type,w,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
+                    ;
+            writeFile(tmpdir, "test.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
+            ST st = group.getInstanceOf("var");
+            st.add("w", "L");
+            st.add("type", "double"); // double not in typeInit map
+            st.add("name", "x");
+            string expecting = "double x = ;";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDictMissingDefaultValueIsEmptyForNullKey()
+        {
+            string templates =
+                    "typeInit ::= [\"int\":\"0\", \"float\":\"0.0\"] " + newline +
+                    "var(type,w,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
+                    ;
+            writeFile(tmpdir, "test.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
+            ST st = group.getInstanceOf("var");
+            st.add("w", "L");
+            st.add("type", null); // double not in typeInit map
+            st.add("name", "x");
+            string expecting = " x = ;";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDictHiddenByFormalArg()
+        {
+            string templates =
+                    "typeInit ::= [\"int\":\"0\", \"float\":\"0.0\"] " + newline +
+                    "var(typeInit,type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
+                    ;
+            writeFile(tmpdir, "test.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
+            ST st = group.getInstanceOf("var");
+            st.add("type", "int");
+            st.add("name", "x");
+            string expecting = "int x = ;";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDictEmptyValueAndAngleBracketStrings()
+        {
+            string templates =
+                    "typeInit ::= [\"int\":\"0\", \"float\":, \"double\":<<0.0L>>] " + newline +
+                    "var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
+                    ;
+            writeFile(tmpdir, "test.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
+            ST st = group.getInstanceOf("var");
+            st.add("type", "float");
+            st.add("name", "x");
+            string expecting = "float x = ;";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDictDefaultValue()
+        {
+            string templates =
+                    "typeInit ::= [\"int\":\"0\", default:\"null\"] " + newline +
+                    "var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
+                    ;
+            writeFile(tmpdir, "test.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
+            ST st = group.getInstanceOf("var");
+            st.add("type", "UserRecord");
+            st.add("name", "x");
+            string expecting = "UserRecord x = null;";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDictNullKeyGetsDefaultValue()
+        {
+            string templates =
+                    "typeInit ::= [\"int\":\"0\", default:\"null\"] " + newline +
+                    "var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
+                    ;
+            writeFile(tmpdir, "test.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
+            ST st = group.getInstanceOf("var");
+            // missing or set to null: st.add("type", null);
+            st.add("name", "x");
+            string expecting = " x = null;";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDictEmptyDefaultValue()
+        {
+            string templates =
+                    "typeInit ::= [\"int\":\"0\", default:] " + newline +
+                    "var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
+                    ;
+            writeFile(tmpdir, "test.stg", templates);
+            ErrorBuffer errors = new ErrorBuffer();
+            STGroupFile group = new STGroupFile(tmpdir + "/" + "test.stg");
+            group.setListener(errors);
+            group.load();
+            string expected = "[test.stg 1:33: missing value for key at ']']";
+            string result = errors.Errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestDictDefaultValueIsKey()
+        {
+            string templates =
+                    "typeInit ::= [\"int\":\"0\", default:key] " + newline +
+                    "var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
+                    ;
+            writeFile(tmpdir, "test.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
+            ST st = group.getInstanceOf("var");
+            st.add("type", "UserRecord");
+            st.add("name", "x");
+            string expecting = "UserRecord x = UserRecord;";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        /**
+         * Test that a map can have only the default entry.
+         */
+        [TestMethod]
+        public void TestDictDefaultStringAsKey()
+        {
+            string templates =
+                    "typeInit ::= [\"default\":\"foo\"] " + newline +
+                    "var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
+                    ;
+            writeFile(tmpdir, "test.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
+            ST st = group.getInstanceOf("var");
+            st.add("type", "default");
+            st.add("name", "x");
+            string expecting = "default x = foo;";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        /**
+         * Test that a map can return a <b>string</b> with the word: default.
+         */
+        [TestMethod]
+        public void TestDictDefaultIsDefaultString()
+        {
+            string templates =
+                    "map ::= [default: \"default\"] " + newline +
+                    "t() ::= << <map.(\"1\")> >>" + newline
+                    ;
+            writeFile(tmpdir, "test.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
+            ST st = group.getInstanceOf("t");
+            string expecting = " default ";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDictViaEnclosingTemplates()
+        {
+            string templates =
+                    "typeInit ::= [\"int\":\"0\", \"float\":\"0.0\"] " + newline +
+                    "intermediate(type,name) ::= \"<var(type,name)>\"" + newline +
+                    "var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
+                    ;
+            writeFile(tmpdir, "test.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
+            ST st = group.getInstanceOf("intermediate");
+            st.add("type", "int");
+            st.add("name", "x");
+            string expecting = "int x = 0;";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDictViaEnclosingTemplates2()
+        {
+            string templates =
+                    "typeInit ::= [\"int\":\"0\", \"float\":\"0.0\"] " + newline +
+                    "intermediate(stuff) ::= \"<stuff>\"" + newline +
+                    "var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
+                    ;
+            writeFile(tmpdir, "test.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
+            ST interm = group.getInstanceOf("intermediate");
+            ST var = group.getInstanceOf("var");
+            var.add("type", "int");
+            var.add("name", "x");
+            interm.add("stuff", var);
+            string expecting = "int x = 0;";
+            string result = interm.render();
+            Assert.AreEqual(expecting, result);
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/TestDollarDelimiters.cs b/Antlr4.Test.StringTemplate/TestDollarDelimiters.cs
new file mode 100644
index 0000000..25bcacf
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/TestDollarDelimiters.cs
@@ -0,0 +1,103 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+
+    [TestClass]
+    public class TestDollarDelimiters : BaseTest
+    {
+        [TestMethod]
+        public void TestAttr()
+        {
+            string template = "hi $name$!";
+            ST st = new ST(template, '$', '$');
+            st.add("name", "Ter");
+            string expected = "hi Ter!";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestParallelMap()
+        {
+            STGroup group = new STGroup('$', '$');
+            group.defineTemplate("test", "names,phones", "hi $names,phones:{n,p | $n$:$p$;}$");
+            ST st = group.getInstanceOf("test");
+            st.add("names", "Ter");
+            st.add("names", "Tom");
+            st.add("names", "Sumana");
+            st.add("phones", "x5001");
+            st.add("phones", "x5002");
+            st.add("phones", "x5003");
+            string expected =
+                "hi Ter:x5001;Tom:x5002;Sumana:x5003;";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestRefToAnotherTemplateInSameGroup()
+        {
+            string dir = tmpdir;
+            string a = "a() ::= << $b()$ >>\n";
+            string b = "b() ::= <<bar>>\n";
+            writeFile(dir, "a.st", a);
+            writeFile(dir, "b.st", b);
+            STGroup group = new STGroupDir(dir, '$', '$');
+            ST st = group.getInstanceOf("a");
+            string expected = " bar ";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestDefaultArgument()
+        {
+            string templates =
+                    "method(name) ::= <<" + newline +
+                    "$stat(name)$" + newline +
+                    ">>" + newline +
+                    "stat(name,value=\"99\") ::= \"x=$value$; // $name$\"" + newline
+                    ;
+            writeFile(tmpdir, "group.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/group.stg", '$', '$');
+            ST b = group.getInstanceOf("method");
+            b.add("name", "foo");
+            string expecting = "x=99; // foo";
+            string result = b.render();
+            Assert.AreEqual(expecting, result);
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/TestFunctions.cs b/Antlr4.Test.StringTemplate/TestFunctions.cs
new file mode 100644
index 0000000..26124d7
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/TestFunctions.cs
@@ -0,0 +1,443 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using System.Collections.Generic;
+
+    [TestClass]
+    public class TestFunctions : BaseTest
+    {
+        [TestMethod]
+        public void TestFirst()
+        {
+            string template = "<first(names)>";
+            ST st = new ST(template);
+            List<string> names = new List<string>() { "Ter", "Tom" };
+            st.add("names", names);
+            string expected = "Ter";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestLength()
+        {
+            string template = "<length(names)>";
+            ST st = new ST(template);
+            List<string> names = new List<string>() { "Ter", "Tom" };
+            st.add("names", names);
+            string expected = "2";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestLengthWithNullValues()
+        {
+            string template = "<length(names)>";
+            ST st = new ST(template);
+            List<string> names = new List<string>() { "Ter", null, "Tom", null };
+            st.add("names", names);
+            string expected = "4";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestFirstOp()
+        {
+            ST e = new ST(
+                    "<first(names)>"
+                );
+            e.add("names", "Ter");
+            e.add("names", "Tom");
+            e.add("names", "Sriram");
+            string expecting = "Ter";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestTruncOp()
+        {
+            ST e = new ST(
+                    "<trunc(names); separator=\", \">"
+                );
+            e.add("names", "Ter");
+            e.add("names", "Tom");
+            e.add("names", "Sriram");
+            string expecting = "Ter, Tom";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestRestOp()
+        {
+            ST e = new ST(
+                    "<rest(names); separator=\", \">"
+                );
+            e.add("names", "Ter");
+            e.add("names", "Tom");
+            e.add("names", "Sriram");
+            string expecting = "Tom, Sriram";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestRestOpEmptyList()
+        {
+            ST e = new ST(
+                    "<rest(names); separator=\", \">"
+                );
+            e.add("names", new List<string>());
+            string expecting = "";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestReUseOfRestResult()
+        {
+            string templates =
+                "a(names) ::= \"<b(rest(names))>\"" + newline +
+                "b(x) ::= \"<x>, <x>\"" + newline
+                ;
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            ST e = group.getInstanceOf("a");
+            List<string> names = new List<string>();
+            names.Add("Ter");
+            names.Add("Tom");
+            e.add("names", names);
+            string expecting = "Tom, Tom";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestLastOp()
+        {
+            ST e = new ST(
+                    "<last(names)>"
+                );
+            e.add("names", "Ter");
+            e.add("names", "Tom");
+            e.add("names", "Sriram");
+            string expecting = "Sriram";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestStripOp()
+        {
+            ST e = new ST(
+                    "<strip(names); null=\"n/a\">"
+                );
+            e.add("names", null);
+            e.add("names", "Tom");
+            e.add("names", null);
+            e.add("names", null);
+            e.add("names", "Sriram");
+            e.add("names", null);
+            string expecting = "TomSriram";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestLengthStrip()
+        {
+            ST e = new ST(
+                    "<length(strip(names))>"
+                );
+            e.add("names", null);
+            e.add("names", "Tom");
+            e.add("names", null);
+            e.add("names", null);
+            e.add("names", "Sriram");
+            e.add("names", null);
+            string expecting = "2";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestCombinedOp()
+        {
+            // replace first of yours with first of mine
+            ST e = new ST(
+                    "<[first(mine),rest(yours)]; separator=\", \">"
+                );
+            e.add("mine", "1");
+            e.add("mine", "2");
+            e.add("mine", "3");
+            e.add("yours", "a");
+            e.add("yours", "b");
+            string expecting = "1, b";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestCatListAndSingleAttribute()
+        {
+            // replace first of yours with first of mine
+            ST e = new ST(
+                    "<[mine,yours]; separator=\", \">"
+                );
+            e.add("mine", "1");
+            e.add("mine", "2");
+            e.add("mine", "3");
+            e.add("yours", "a");
+            string expecting = "1, 2, 3, a";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestReUseOfCat()
+        {
+            string templates =
+                "a(mine,yours) ::= \"<b([mine,yours])>\"" + newline +
+                "b(x) ::= \"<x>, <x>\"" + newline
+                ;
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            ST e = group.getInstanceOf("a");
+            List<string> mine = new List<string>();
+            mine.Add("Ter");
+            mine.Add("Tom");
+            e.add("mine", mine);
+            List<string> yours = new List<string>();
+            yours.Add("Foo");
+            e.add("yours", yours);
+            string expecting = "TerTomFoo, TerTomFoo";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestCatListAndEmptyAttributes()
+        {
+            // + is overloaded to be cat strings and cat lists so the
+            // two operands (from left to right) determine which way it
+            // goes.  In this case, x+mine is a list so everything from their
+            // to the right becomes list cat.
+            ST e = new ST(
+                    "<[x,mine,y,yours,z]; separator=\", \">"
+                );
+            e.add("mine", "1");
+            e.add("mine", "2");
+            e.add("mine", "3");
+            e.add("yours", "a");
+            string expecting = "1, 2, 3, a";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestNestedOp()
+        {
+            ST e = new ST(
+                    "<first(rest(names))>" // gets 2nd element
+                );
+            e.add("names", "Ter");
+            e.add("names", "Tom");
+            e.add("names", "Sriram");
+            string expecting = "Tom";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestFirstWithOneAttributeOp()
+        {
+            ST e = new ST(
+                    "<first(names)>"
+                );
+            e.add("names", "Ter");
+            string expecting = "Ter";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestLastWithOneAttributeOp()
+        {
+            ST e = new ST(
+                    "<last(names)>"
+                );
+            e.add("names", "Ter");
+            string expecting = "Ter";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestLastWithLengthOneListAttributeOp()
+        {
+            ST e = new ST(
+                    "<last(names)>"
+                );
+            e.add("names", new List<string>() { "Ter" });
+            string expecting = "Ter";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestRestWithOneAttributeOp()
+        {
+            ST e = new ST(
+                    "<rest(names)>"
+                );
+            e.add("names", "Ter");
+            string expecting = "";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestRestWithLengthOneListAttributeOp()
+        {
+            ST e = new ST(
+                    "<rest(names)>"
+                );
+            e.add("names", new List<string>() { "Ter" });
+            string expecting = "";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestRepeatedRestOp()
+        {
+            ST e = new ST(
+                    "<rest(names)>, <rest(names)>" // gets 2nd element
+                );
+            e.add("names", "Ter");
+            e.add("names", "Tom");
+            string expecting = "Tom, Tom";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestIncomingLists()
+        {
+            ST e = new ST(
+                    "<rest(names)>, <rest(names)>" // gets 2nd element
+                );
+            e.add("names", "Ter");
+            e.add("names", "Tom");
+            string expecting = "Tom, Tom";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestFirstWithCatAttribute()
+        {
+            ST e = new ST(
+                    "<first([names,phones])>"
+                );
+            e.add("names", "Ter");
+            e.add("names", "Tom");
+            e.add("phones", "1");
+            e.add("phones", "2");
+            string expecting = "Ter";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestFirstWithListOfMaps()
+        {
+            ST e = new ST(
+                    "<first(maps).Ter>"
+                );
+            IDictionary<string, string> m1 = new Dictionary<string, string>();
+            IDictionary<string, string> m2 = new Dictionary<string, string>();
+            m1["Ter"] = "x5707";
+            e.add("maps", m1);
+            m2["Tom"] = "x5332";
+            e.add("maps", m2);
+            string expecting = "x5707";
+            Assert.AreEqual(expecting, e.render());
+
+            List<IDictionary<string, string>> list = new List<IDictionary<string, string>>() { m1, m2 };
+            e.add("maps", list);
+            expecting = "x5707";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestFirstWithListOfMaps2()
+        {
+            ST e = new ST(
+                    "<first(maps):{ m | <m>!}>"
+                );
+            IDictionary<string, string> m1 = new Dictionary<string, string>();
+            IDictionary<string, string> m2 = new Dictionary<string, string>();
+            m1["Ter"] = "x5707";
+            e.add("maps", m1);
+            m2["Tom"] = "x5332";
+            e.add("maps", m2);
+            string expecting = "Ter!";
+            Assert.AreEqual(expecting, e.render());
+            List<IDictionary<string, string>> list = new List<IDictionary<string, string>>() { m1, m2 };
+            e.add("maps", list);
+            expecting = "Ter!";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestTrim()
+        {
+            ST e = new ST(
+                    "<trim(name)>"
+                );
+            e.add("name", " Ter  \n");
+            string expecting = "Ter";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestStrlen()
+        {
+            ST e = new ST(
+                    "<strlen(name)>"
+                );
+            e.add("name", "012345");
+            string expecting = "6";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestReverse()
+        {
+            ST e = new ST(
+                    "<reverse(names); separator=\", \">"
+                );
+            e.add("names", "Ter");
+            e.add("names", "Tom");
+            e.add("names", "Sriram");
+            string expecting = "Sriram, Tom, Ter";
+            Assert.AreEqual(expecting, e.render());
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/TestGroupSyntax.cs b/Antlr4.Test.StringTemplate/TestGroupSyntax.cs
new file mode 100644
index 0000000..4ce72e5
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/TestGroupSyntax.cs
@@ -0,0 +1,179 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using Environment = System.Environment;
+
+    [TestClass]
+    public class TestGroupSyntax : BaseTest
+    {
+        [TestMethod]
+        public void TestSimpleGroup()
+        {
+            string templates =
+                "t() ::= <<foo>>" + Environment.NewLine;
+
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            string expected =
+                "t() ::= <<" + Environment.NewLine +
+                "foo" + Environment.NewLine +
+                ">>" + Environment.NewLine;
+            string result = group.show();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestMultiTemplates()
+        {
+            string templates =
+                "ta(x) ::= \"[<x>]\"" + Environment.NewLine +
+                "duh() ::= <<hi there>>" + Environment.NewLine +
+                "wow() ::= <<last>>" + Environment.NewLine;
+
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            string expected =
+                "ta(x) ::= <<" + Environment.NewLine +
+                "[<x>]" + Environment.NewLine +
+                ">>" + Environment.NewLine +
+                "duh() ::= <<" + Environment.NewLine +
+                "hi there" + Environment.NewLine +
+                ">>" + Environment.NewLine +
+                "wow() ::= <<" + Environment.NewLine +
+                "last" + Environment.NewLine +
+                ">>" + Environment.NewLine;
+            string result = group.show();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSingleTemplateWithArgs()
+        {
+            string templates =
+                "t(a,b) ::= \"[<a>]\"" + Environment.NewLine;
+
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            string expected =
+                "t(a,b) ::= <<" + Environment.NewLine +
+                "[<a>]" + Environment.NewLine +
+                ">>" + Environment.NewLine;
+            string result = group.show();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestDefaultValues()
+        {
+            string templates =
+                "t(a={def1},b=\"def2\") ::= \"[<a>]\"" + Environment.NewLine;
+
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            string expected =
+                "t(a={def1},b=\"def2\") ::= <<" + Environment.NewLine +
+                "[<a>]" + Environment.NewLine +
+                ">>" + Environment.NewLine;
+            string result = group.show();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestDefaultValueTemplateWithArg()
+        {
+            string templates =
+                "t(a={x | 2*<x>}) ::= \"[<a>]\"" + Environment.NewLine;
+
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            string expected =
+                "t(a={x | 2*<x>}) ::= <<" + Environment.NewLine +
+                "[<a>]" + Environment.NewLine +
+                ">>" + Environment.NewLine;
+            string result = group.show();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestNestedTemplateInGroupFile()
+        {
+            string templates =
+                "t(a) ::= \"<a:{x | <x:{y | <y>}>}>\"" + Environment.NewLine;
+
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            string expected =
+                "t(a) ::= <<" + Environment.NewLine +
+                "<a:{x | <x:{y | <y>}>}>" + Environment.NewLine +
+                ">>" + Environment.NewLine;
+            string result = group.show();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestNestedDefaultValueTemplate()
+        {
+            string templates =
+                "t(a={x | <x:{y|<y>}>}) ::= \"ick\"" + Environment.NewLine;
+
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.load();
+            string expected =
+                "t(a={x | <x:{y|<y>}>}) ::= <<" + Environment.NewLine +
+                "ick" + Environment.NewLine +
+                ">>" + Environment.NewLine;
+            string result = group.show();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestNestedDefaultValueTemplateWithEscapes()
+        {
+            string templates =
+                "t(a={x | \\< <x:{y|<y>\\}}>}) ::= \"[<a>]\"" + Environment.NewLine;
+
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            string expected =
+                "t(a={x | \\< <x:{y|<y>\\}}>}) ::= <<" + Environment.NewLine +
+                "[<a>]" + Environment.NewLine +
+                ">>" + Environment.NewLine;
+            string result = group.show();
+            Assert.AreEqual(expected, result);
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/TestGroupSyntaxErrors.cs b/Antlr4.Test.StringTemplate/TestGroupSyntaxErrors.cs
new file mode 100644
index 0000000..b9d6b7c
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/TestGroupSyntaxErrors.cs
@@ -0,0 +1,287 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using Antlr4.StringTemplate.Misc;
+    using Antlr4.Test.StringTemplate.Extensions;
+
+    [TestClass]
+    public class TestGroupSyntaxErrors : BaseTest
+    {
+        [TestMethod]
+        public void TestMissingImportString()
+        {
+            string templates =
+                "import\n" +
+                "foo() ::= <<>>\n";
+            writeFile(tmpdir, "t.stg", templates);
+
+            STErrorListener errors = new ErrorBuffer();
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            group.load(); // force load
+            string expected = "t.stg 2:0: mismatched input 'foo' expecting STRING" + newline +
+                "t.stg 2:3: required (...)+ loop did not match anything at input '('" + newline;
+            string result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestImportNotString()
+        {
+            string templates =
+                "import Super.stg\n" +
+                "foo() ::= <<>>\n";
+            writeFile(tmpdir, "t.stg", templates);
+
+            STErrorListener errors = new ErrorBuffer();
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            group.load(); // force load
+            string expected = "t.stg 1:7: mismatched input 'Super' expecting STRING" + newline;
+            string result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestMissingTemplate()
+        {
+            string templates =
+                "foo() ::= \n";
+            writeFile(tmpdir, "t.stg", templates);
+
+            STGroupFile group = null;
+            STErrorListener errors = new ErrorBuffer();
+            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            group.load(); // force load
+            string expected = "t.stg 2:0: missing template at '<EOF>'" + newline;
+            string result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestParen()
+        {
+            string templates =
+                "foo( ::= << >>\n";
+            writeFile(tmpdir, "t.stg", templates);
+
+            STGroupFile group = null;
+            STErrorListener errors = new ErrorBuffer();
+            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            group.load(); // force load
+            string expected = "t.stg 1:5: no viable alternative at input '::='" + newline;
+            string result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestNewlineInString()
+        {
+            string templates =
+                "foo() ::= \"\nfoo\"\n";
+            writeFile(tmpdir, "t.stg", templates);
+
+            STGroupFile group = null;
+            STErrorListener errors = new ErrorBuffer();
+            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            group.load(); // force load
+            string expected = "t.stg 1:11: \\n in string" + newline;
+            string result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestParen2()
+        {
+            string templates =
+                "foo) ::= << >>\n" +
+                "bar() ::= <<bar>>\n";
+            writeFile(tmpdir, "t.stg", templates);
+
+            STGroupFile group = null;
+            STErrorListener errors = new ErrorBuffer();
+            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            group.load(); // force load
+            string expected = "t.stg 1:0: garbled template definition starting at 'foo'" + newline;
+            string result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestArg()
+        {
+            string templates =
+                "foo(a,) ::= << >>\n";
+            writeFile(tmpdir, "t.stg", templates);
+
+            STGroupFile group = null;
+            STErrorListener errors = new ErrorBuffer();
+            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            group.load(); // force load
+            string expected = "t.stg 1:6: mismatched input ')' expecting ID" + newline;
+            string result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestArg2()
+        {
+            string templates =
+                "foo(a,,) ::= << >>\n";
+            writeFile(tmpdir, "t.stg", templates);
+
+            STGroupFile group = null;
+            ErrorBuffer errors = new ErrorBuffer();
+            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            group.load(); // force load
+            string expected =
+                "[t.stg 1:6: mismatched input ',' expecting ID, " +
+                "t.stg 1:7: mismatched input ')' expecting ID]";
+            string result = errors.Errors.ToListString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestArg3()
+        {
+            string templates =
+                "foo(a b) ::= << >>\n";
+            writeFile(tmpdir, "t.stg", templates);
+
+            STGroupFile group = null;
+            ErrorBuffer errors = new ErrorBuffer();
+            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            group.load(); // force load
+            string expected =
+                "[t.stg 1:4: no viable alternative at input 'a', " +
+                "t.stg 1:6: garbled template definition starting at 'b']";
+            string result = errors.Errors.ToListString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestErrorWithinTemplate()
+        {
+            string templates =
+                "foo(a) ::= \"<a b>\"\n";
+            writeFile(tmpdir, "t.stg", templates);
+
+            STGroupFile group = null;
+            ErrorBuffer errors = new ErrorBuffer();
+            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            group.load(); // force load
+            string expected = "[t.stg 1:15: 'b' came as a complete surprise to me]";
+            string result = errors.Errors.ToListString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestMap()
+        {
+            string templates =
+                "d ::= []\n";
+            writeFile(tmpdir, "t.stg", templates);
+
+            STGroupFile group = null;
+            ErrorBuffer errors = new ErrorBuffer();
+            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            group.load(); // force load
+            string expected = "[t.stg 1:7: missing dictionary entry at ']']";
+            string result = errors.Errors.ToListString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestMap2()
+        {
+            string templates =
+                "d ::= [\"k\":]\n";
+            writeFile(tmpdir, "t.stg", templates);
+
+            STGroupFile group = null;
+            ErrorBuffer errors = new ErrorBuffer();
+            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            group.load(); // force load
+            string expected = "[t.stg 1:11: missing value for key at ']']";
+            string result = errors.Errors.ToListString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestMap3()
+        {
+            string templates =
+                "d ::= [\"k\":{dfkj}}]\n"; // extra }
+            writeFile(tmpdir, "t.stg", templates);
+
+            STGroupFile group = null;
+            ErrorBuffer errors = new ErrorBuffer();
+            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            group.load(); // force load
+            string expected = "[t.stg 1:17: invalid character '}']";
+            string result = errors.Errors.ToListString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestUnterminatedString()
+        {
+            string templates =
+                "f() ::= \""; // extra }
+            writeFile(tmpdir, "t.stg", templates);
+
+            STGroupFile group = null;
+            ErrorBuffer errors = new ErrorBuffer();
+            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            group.load(); // force load
+            string expected = "[t.stg 1:9: unterminated string, t.stg 1:9: missing template at '<EOF>']";
+            string result = errors.Errors.ToListString();
+            Assert.AreEqual(expected, result);
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/TestGroups.cs b/Antlr4.Test.StringTemplate/TestGroups.cs
new file mode 100644
index 0000000..640703c
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/TestGroups.cs
@@ -0,0 +1,693 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using Antlr4.StringTemplate.Misc;
+    using System.Runtime.CompilerServices;
+
+    [TestClass]
+    public class TestGroups : BaseTest
+    {
+        [TestMethod]
+        public void TestSimpleGroup()
+        {
+            string dir = tmpdir;
+            string a =
+                "a(x) ::= <<" + newline +
+                "foo" + newline +
+                ">>" + newline;
+            writeFile(dir, "a.st", a);
+            STGroup group = new STGroupDir(dir);
+            ST st = group.getInstanceOf("a");
+            string expected = "foo";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestGroupWithTwoTemplates()
+        {
+            string dir = tmpdir;
+            string a =
+                "a(x) ::= <<" + newline +
+                "foo" + newline +
+                ">>" + newline;
+            writeFile(dir, "a.st", a);
+            string b =
+                "b() ::= \"bar\"" + newline;
+            writeFile(dir, "b.st", b);
+            STGroup group = new STGroupDir(dir);
+            ST st1 = group.getInstanceOf("a");
+            ST st2 = group.getInstanceOf("b");
+            string expected = "foobar";
+            string result = st1.render() + st2.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSubdir()
+        {
+            // /randomdir/a and /randomdir/subdir/b
+            string dir = tmpdir;
+            string a =
+                "a(x) ::= <<" + newline +
+                "foo" + newline +
+                ">>" + newline;
+            writeFile(dir, "a.st", a);
+            string b =
+                "b() ::= \"bar\"" + newline;
+            writeFile(dir + "/subdir", "b.st", b);
+            STGroup group = new STGroupDir(dir);
+            ST st1 = group.getInstanceOf("a");
+            ST st2 = group.getInstanceOf("subdir/b");
+            string expected = "foobar";
+            string result = st1.render() + st2.render();
+            Assert.AreEqual(expected, result);
+            st2 = group.getInstanceOf("subdir/b"); // should work with / in front too
+            expected = "bar";
+            result = st2.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestAbsoluteTemplateRef()
+        {
+            // /randomdir/a and /randomdir/subdir/b
+            string dir = tmpdir;
+            string a =
+                "a(x) ::= << <subdir/b()> >>\n";
+            writeFile(dir, "a.st", a);
+            string b =
+                "b() ::= <<bar>>\n";
+            writeFile(dir + "/subdir", "b.st", b);
+            STGroup group = new STGroupDir(dir);
+            ST st = group.getInstanceOf("a");
+            string expected = " bar ";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestGroupFileInDir()
+        {
+            // /randomdir/a and /randomdir/group.stg with b and c templates
+            string dir = tmpdir;
+            string a =
+                "a(x) ::= <<\n" +
+                "foo\n" +
+                ">>\n";
+            writeFile(dir, "a.st", a);
+            string groupFile =
+                "b() ::= \"bar\"\n" +
+                "c() ::= \"duh\"\n";
+            writeFile(dir, "group.stg", groupFile);
+            STGroup group = new STGroupDir(dir);
+            ST st1 = group.getInstanceOf("a");
+            ST st2 = group.getInstanceOf("group/b");
+            ST st3 = group.getInstanceOf("group/c");
+            string expected = "foobarduh";
+            string result = st1.render() + st2.render() + st3.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSubSubdir()
+        {
+            // /randomdir/a and /randomdir/subdir/b
+            string dir = tmpdir;
+            string a =
+                "a(x) ::= <<" + newline +
+                "foo" + newline +
+                ">>" + newline;
+            writeFile(dir, "a.st", a);
+            string b =
+                "b() ::= \"bar\"" + newline;
+            writeFile(dir + "/sub1/sub2", "b.st", b);
+            STGroup group = new STGroupDir(dir);
+            ST st1 = group.getInstanceOf("a");
+            ST st2 = group.getInstanceOf("sub1/sub2/b");
+            string expected = "foobar";
+            string result = st1.render() + st2.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestGroupFileInSubDir()
+        {
+            // /randomdir/a and /randomdir/group.stg with b and c templates
+            string dir = tmpdir;
+            string a =
+                "a(x) ::= <<\n" +
+                "foo\n" +
+                ">>\n";
+            writeFile(dir, "a.st", a);
+            string groupFile =
+                "b() ::= \"bar\"\n" +
+                "c() ::= \"duh\"\n";
+            writeFile(dir, "subdir/group.stg", groupFile);
+            STGroup group = new STGroupDir(dir);
+            ST st1 = group.getInstanceOf("a");
+            ST st2 = group.getInstanceOf("subdir/group/b");
+            ST st3 = group.getInstanceOf("subdir/group/c");
+            string expected = "foobarduh";
+            string result = st1.render() + st2.render() + st3.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestRefToAnotherTemplateInSameGroup()
+        {
+            string dir = tmpdir;
+            string a = "a() ::= << <b()> >>\n";
+            string b = "b() ::= <<bar>>\n";
+            writeFile(dir, "a.st", a);
+            writeFile(dir, "b.st", b);
+            STGroup group = new STGroupDir(dir);
+            ST st = group.getInstanceOf("a");
+            string expected = " bar ";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestRefToAnotherTemplateInSameSubdir()
+        {
+            // /randomdir/a and /randomdir/subdir/b
+            string dir = tmpdir;
+            string a = "a() ::= << <subdir/b()> >>\n";
+            string b = "b() ::= <<bar>>\n";
+            writeFile(dir + "/subdir", "a.st", a);
+            writeFile(dir + "/subdir", "b.st", b);
+            STGroup group = new STGroupDir(dir);
+            ST st = group.getInstanceOf("subdir/a");
+            st.impl.dump();
+            string expected = " bar ";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestDupDef()
+        {
+            string dir = tmpdir;
+            string groupFile =
+                "b() ::= \"bar\"\n" +
+                "b() ::= \"duh\"\n";
+            writeFile(dir, "group.stg", groupFile);
+            STErrorListener errors = new ErrorBuffer();
+            STGroupFile group = new STGroupFile(dir + "/group.stg");
+            group.setListener(errors);
+            group.load();
+            string expected = "group.stg 2:0: redefinition of template b" + newline;
+            string result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestAlias()
+        {
+            string dir = tmpdir;
+            string groupFile =
+                "a() ::= \"bar\"\n" +
+                "b ::= a\n";
+            writeFile(dir, "group.stg", groupFile);
+            STGroupFile group = new STGroupFile(dir + "/group.stg");
+            ST st = group.getInstanceOf("b");
+            string expected = "bar";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestAliasWithArgs()
+        {
+            string dir = tmpdir;
+            string groupFile =
+                "a(x,y) ::= \"<x><y>\"\n" +
+                "b ::= a\n";
+            writeFile(dir, "group.stg", groupFile);
+            STGroupFile group = new STGroupFile(dir + "/group.stg");
+            ST st = group.getInstanceOf("b");
+            st.add("x", 1);
+            st.add("y", 2);
+            string expected = "12";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSimpleDefaultArg()
+        {
+            string dir = tmpdir;
+            string a = "a() ::= << <b()> >>\n";
+            string b = "b(x=\"foo\") ::= \"<x>\"\n";
+            writeFile(dir, "a.st", a);
+            writeFile(dir, "b.st", b);
+            STGroup group = new STGroupDir(dir);
+            ST st = group.getInstanceOf("a");
+            string expected = " foo ";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestDefaultArgument()
+        {
+            string templates =
+                    "method(name) ::= <<" + newline +
+                    "<stat(name)>" + newline +
+                    ">>" + newline +
+                    "stat(name,value=\"99\") ::= \"x=<value>; // <name>\"" + newline
+                    ;
+            writeFile(tmpdir, "group.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/group.stg");
+            ST b = group.getInstanceOf("method");
+            b.add("name", "foo");
+            string expecting = "x=99; // foo";
+            string result = b.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDefaultArgument2()
+        {
+            string templates =
+                    "stat(name,value=\"99\") ::= \"x=<value>; // <name>\"" + newline
+                    ;
+            writeFile(tmpdir, "group.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/group.stg");
+            ST b = group.getInstanceOf("stat");
+            b.add("name", "foo");
+            string expecting = "x=99; // foo";
+            string result = b.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDefaultArgumentAsSimpleTemplate()
+        {
+            string templates =
+                    "stat(name,value={99}) ::= \"x=<value>; // <name>\"" + newline
+                    ;
+            writeFile(tmpdir, "group.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/group.stg");
+            ST b = group.getInstanceOf("stat");
+            b.add("name", "foo");
+            string expecting = "x=99; // foo";
+            string result = b.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        private class Field
+        {
+            public string name = "parrt";
+            public int n = 0;
+
+            public override string ToString()
+            {
+                return "Field";
+            }
+        }
+
+        [TestMethod]
+        public void TestDefaultArgumentManuallySet()
+        {
+            // set arg f manually for stat(f=f)
+            string templates =
+                    "method(fields) ::= <<" + newline +
+                    "<fields:{f | <stat(f)>}>" + newline +
+                    ">>" + newline +
+                    "stat(f,value={<f.name>}) ::= \"x=<value>; // <f.name>\"" + newline
+                    ;
+            writeFile(tmpdir, "group.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/group.stg");
+            ST m = group.getInstanceOf("method");
+            m.add("fields", new Field());
+            string expecting = "x=parrt; // parrt";
+            string result = m.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDefaultArgumentSeesVarFromDynamicScoping()
+        {
+            string templates =
+                    "method(fields) ::= <<" + newline +
+                    "<fields:{f | <stat()>}>" + newline +
+                    ">>" + newline +
+                    "stat(value={<f.name>}) ::= \"x=<value>; // <f.name>\"" + newline
+                    ;
+            writeFile(tmpdir, "group.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/group.stg");
+            ST m = group.getInstanceOf("method");
+            m.add("fields", new Field());
+            string expecting = "x=parrt; // parrt";
+            string result = m.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDefaultArgumentImplicitlySet2()
+        {
+            // f of stat is implicit first arg
+            string templates =
+                    "method(fields) ::= <<" + newline +
+                    "<fields:{f | <f:stat()>}>" + newline +
+                    ">>" + newline +
+                    "stat(f,value={<f.name>}) ::= \"x=<value>; // <f.name>\"" + newline
+                    ;
+            writeFile(tmpdir, "group.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/group.stg");
+            ST m = group.getInstanceOf("method");
+            m.add("fields", new Field());
+            string expecting = "x=parrt; // parrt";
+            string result = m.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDefaultArgumentAsTemplate()
+        {
+            string templates =
+                    "method(name,size) ::= <<" + newline +
+                    "<stat(name)>" + newline +
+                    ">>" + newline +
+                    "stat(name,value={<name>}) ::= \"x=<value>; // <name>\"" + newline
+                    ;
+            writeFile(tmpdir, "group.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/group.stg");
+            ST b = group.getInstanceOf("method");
+            b.add("name", "foo");
+            b.add("size", "2");
+            string expecting = "x=foo; // foo";
+            string result = b.render();
+            //System.err.println("result='"+result+"'");
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDefaultArgumentAsTemplate2()
+        {
+            string templates =
+                    "method(name,size) ::= <<" + newline +
+                    "<stat(name)>" + newline +
+                    ">>" + newline +
+                    "stat(name,value={ [<name>] }) ::= \"x=<value>; // <name>\"" + newline
+                    ;
+            writeFile(tmpdir, "group.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/group.stg");
+            ST b = group.getInstanceOf("method");
+            b.add("name", "foo");
+            b.add("size", "2");
+            string expecting = "x=[foo] ; // foo"; // won't see ' ' after '=' since it's an indent not simple string
+            string result = b.render();
+            //System.err.println("result='"+result+"'");
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDoNotUseDefaultArgument()
+        {
+            string templates =
+                    "method(name) ::= <<" + newline +
+                    "<stat(name,\"34\")>" + newline +
+                    ">>" + newline +
+                    "stat(name,value=\"99\") ::= \"x=<value>; // <name>\"" + newline
+                    ;
+            writeFile(tmpdir, "group.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/group.stg");
+            ST b = group.getInstanceOf("method");
+            b.add("name", "foo");
+            string expecting = "x=34; // foo";
+            string result = b.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        private class Counter
+        {
+            int n = 0;
+            public override string ToString()
+            {
+                return (n++).ToString();
+            }
+        }
+
+        [TestMethod]
+        public void TestDefaultArgumentInParensToEvalEarly()
+        {
+            string templates =
+                    "A(x) ::= \"<B()>\"" + newline +
+                    "B(y={<(x)>}) ::= \"<y> <x> <x> <y>\"" + newline
+                    ;
+            writeFile(tmpdir, "group.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/group.stg");
+            ST a = group.getInstanceOf("A");
+            a.add("x", new Counter());
+            string expecting = "0 1 2 0"; // trace must be false to get these numbers
+            string result = a.render();
+            //System.err.println("result='"+result+"'");
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestNamedArgsInOrder()
+        {
+            string dir = tmpdir;
+            string groupFile =
+                "f(x,y) ::= \"<x><y>\"\n" +
+                "g() ::= \"<f(x={a},y={b})>\"";
+            writeFile(dir, "group.stg", groupFile);
+            STGroupFile group = new STGroupFile(dir + "/group.stg");
+            ST st = group.getInstanceOf("g");
+            string expected = "ab";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestNamedArgsOutOfOrder()
+        {
+            string dir = tmpdir;
+            string groupFile =
+                "f(x,y) ::= \"<x><y>\"\n" +
+                "g() ::= \"<f(y={b},x={a})>\"";
+            writeFile(dir, "group.stg", groupFile);
+            STGroupFile group = new STGroupFile(dir + "/group.stg");
+            ST st = group.getInstanceOf("g");
+            string expected = "ab";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestUnknownNamedArg()
+        {
+            string dir = tmpdir;
+            string groupFile =
+                "f(x,y) ::= \"<x><y>\"\n" +
+                "g() ::= \"<f(x={a},z={b})>\"";
+            //012345678901234567
+
+            writeFile(dir, "group.stg", groupFile);
+            STGroupFile group = new STGroupFile(dir + "/group.stg");
+            ErrorBuffer errors = new ErrorBuffer();
+            group.setListener(errors);
+            ST st = group.getInstanceOf("g");
+            st.render();
+            string expected = "context [g] 1:1 attribute z isn't defined" + newline;
+            string result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestMissingNamedArg()
+        {
+            string dir = tmpdir;
+            string groupFile =
+                "f(x,y) ::= \"<x><y>\"\n" +
+                "g() ::= \"<f(x={a},{b})>\"";
+            //012345678901234567
+
+            writeFile(dir, "group.stg", groupFile);
+            STGroupFile group = new STGroupFile(dir + "/group.stg");
+            ErrorBuffer errors = new ErrorBuffer();
+            group.setListener(errors);
+            group.load();
+            string expected = "group.stg 2:28: mismatched input '{' expecting ID" + newline;
+            string result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestNamedArgsNotAllowInIndirectInclude()
+        {
+            string dir = tmpdir;
+            string groupFile =
+                "f(x,y) ::= \"<x><y>\"\n" +
+                "g(name) ::= \"<(name)(x={a},y={b})>\"";
+            //0123456789012345678901234567890
+            writeFile(dir, "group.stg", groupFile);
+            STGroupFile group = new STGroupFile(dir + "/group.stg");
+            ErrorBuffer errors = new ErrorBuffer();
+            group.setListener(errors);
+            group.load();
+            string expected = "group.stg 2:22: '=' came as a complete surprise to me" + newline;
+            string result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestCantSeeGroupDirIfGroupFileOfSameName()
+        {
+            string dir = tmpdir;
+            string a = "a() ::= <<dir1 a>>\n";
+            writeFile(dir, "group/a.st", a); // can't see this file
+
+            string groupFile =
+                "b() ::= \"group file b\"\n";
+            writeFile(dir, "group.stg", groupFile);
+
+            STGroup group1 = new STGroupDir(dir);
+            ST st = group1.getInstanceOf("group/a"); // can't see
+            Assert.AreEqual(null, st);
+        }
+
+        // test fully-qualified template refs
+
+        [TestMethod]
+        public void TestFullyQualifiedGetInstanceOf()
+        {
+            string dir = tmpdir;
+            string a =
+                "a(x) ::= <<" + newline +
+                "foo" + newline +
+                ">>" + newline;
+            writeFile(dir, "a.st", a);
+            STGroup group = new STGroupDir(dir);
+            ST st = group.getInstanceOf("a");
+            string expected = "foo";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestFullyQualifiedTemplateRef()
+        {
+            // /randomdir/a and /randomdir/subdir/b
+            string dir = tmpdir;
+            string a = "a() ::= << <subdir/b()> >>\n";
+            string b = "b() ::= <<bar>>\n";
+            writeFile(dir + "/subdir", "a.st", a);
+            writeFile(dir + "/subdir", "b.st", b);
+            STGroup group = new STGroupDir(dir);
+            ST st = group.getInstanceOf("subdir/a");
+            string expected = " bar ";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestFullyQualifiedTemplateRef2()
+        {
+            // /randomdir/a and /randomdir/group.stg with b and c templates
+            string dir = tmpdir;
+            string a =
+                "a(x) ::= << <group/b()> >>\n";
+            writeFile(dir, "a.st", a);
+            string groupFile =
+                "b() ::= \"bar\"\n" +
+                "c() ::= \"<a()>\"\n";
+            writeFile(dir, "group.stg", groupFile);
+            STGroup group = new STGroupDir(dir);
+            ST st1 = group.getInstanceOf("a");
+            ST st2 = group.getInstanceOf("group/c"); // invokes /a
+            string expected = " bar  bar ";
+            string result = st1.render() + st2.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestUnloadingSimpleGroup()
+        {
+            string dir = tmpdir;
+            string a =
+                "a(x) ::= <<foo>>\n";
+            string b =
+                "b() ::= <<bar>>\n";
+            writeFile(dir, "a.st", a);
+            writeFile(dir, "b.st", b);
+            STGroup group = new STGroupDir(dir);
+            group.load(); // force load
+            ST st = group.getInstanceOf("a");
+            int originalHashCode = RuntimeHelpers.GetHashCode(st);
+            group.unload(); // blast cache
+            st = group.getInstanceOf("a");
+            int newHashCode = RuntimeHelpers.GetHashCode(st);
+            Assert.AreEqual(originalHashCode == newHashCode, false); // diff objects
+            string expected = "foo";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+            st = group.getInstanceOf("b");
+            expected = "bar";
+            result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestUnloadingGroupFile()
+        {
+            string dir = tmpdir;
+            string a =
+                "a(x) ::= <<foo>>\n" +
+                "b() ::= <<bar>>\n";
+            writeFile(dir, "a.stg", a);
+            STGroup group = new STGroupFile(dir + "/a.stg");
+            group.load(); // force load
+            ST st = group.getInstanceOf("a");
+            int originalHashCode = RuntimeHelpers.GetHashCode(st);
+            group.unload(); // blast cache
+            st = group.getInstanceOf("a");
+            int newHashCode = RuntimeHelpers.GetHashCode(st);
+            Assert.AreEqual(originalHashCode == newHashCode, false); // diff objects
+            string expected = "foo";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+            st = group.getInstanceOf("b");
+            expected = "bar";
+            result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/TestImports.cs b/Antlr4.Test.StringTemplate/TestImports.cs
new file mode 100644
index 0000000..135f689
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/TestImports.cs
@@ -0,0 +1,285 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using System.Runtime.CompilerServices;
+
+    [TestClass]
+    public class TestImports : BaseTest
+    {
+        [TestMethod]
+        public void TestImportTemplate()
+        {
+            string dir1 = tmpdir;
+            string a = "a() ::= <<dir1 a>>\n";
+            string b = "b() ::= <<dir1 b>>\n";
+            writeFile(dir1, "a.st", a);
+            writeFile(dir1, "b.st", b);
+            string dir2 = tmpdir;
+            a = "a() ::= << <b()> >>\n";
+            writeFile(dir2, "a.st", a);
+
+            STGroup group1 = new STGroupDir(dir1);
+            STGroup group2 = new STGroupDir(dir2);
+            group2.importTemplates(group1);
+            ST st = group2.getInstanceOf("b");
+            string expected = "dir1 b";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+
+            // do it again, but make a template ref imported template
+            st = group2.getInstanceOf("a");
+            expected = " dir1 b ";
+            result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestImportStatementWithDir()
+        {
+            string dir1 = tmpdir + "/dir1";
+            string dir2 = tmpdir + "/dir2";
+            string a =
+                "import \"" + dir2 + "\"\n" +
+                "a() ::= <<dir1 a>>\n";
+            writeFile(dir1, "a.stg", a);
+
+            a = "a() ::= <<dir2 a>>\n";
+            string b = "b() ::= <<dir2 b>>\n";
+            writeFile(dir2, "a.st", a);
+            writeFile(dir2, "b.st", b);
+
+            STGroup group = new STGroupFile(dir1 + "/a.stg");
+            ST st = group.getInstanceOf("b"); // visible only if import worked
+            string expected = "dir2 b";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestImportStatementWithFile()
+        {
+            string dir = tmpdir;
+            string groupFile =
+                "import \"" + dir + "/group2.stg\"\n" +
+                "a() ::= \"g1 a\"\n" +
+                "b() ::= \"<c()>\"\n";
+            writeFile(dir, "group1.stg", groupFile);
+
+            groupFile =
+                "c() ::= \"g2 c\"\n";
+            writeFile(dir, "group2.stg", groupFile);
+
+            STGroup group1 = new STGroupFile(dir + "/group1.stg");
+            ST st = group1.getInstanceOf("c"); // should see c()
+            string expected = "g2 c";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestImportTemplateInGroupFileFromDir()
+        {
+            string dir = tmpdir;
+            string a = "a() ::= << <b()> >>\n";
+            writeFile(dir, "x/a.st", a);
+
+            string groupFile =
+                "b() ::= \"group file b\"\n" +
+                "c() ::= \"group file c\"\n";
+            writeFile(dir, "y/group.stg", groupFile);
+
+            STGroup group1 = new STGroupDir(dir + "/x");
+            STGroup group2 = new STGroupFile(dir + "/y/group.stg");
+            group1.importTemplates(group2);
+            ST st = group1.getInstanceOf("a");
+            st.impl.dump();
+            string expected = " group file b ";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestImportTemplateInGroupFileFromGroupFile()
+        {
+            string dir = tmpdir;
+            string groupFile =
+                "a() ::= \"g1 a\"\n" +
+                "b() ::= \"<c()>\"\n";
+            writeFile(dir, "x/group.stg", groupFile);
+
+            groupFile =
+                "b() ::= \"g2 b\"\n" +
+                "c() ::= \"g2 c\"\n";
+            writeFile(dir, "y/group.stg", groupFile);
+
+            STGroup group1 = new STGroupFile(dir + "/x/group.stg");
+            STGroup group2 = new STGroupFile(dir + "/y/group.stg");
+            group1.importTemplates(group2);
+            ST st = group1.getInstanceOf("b");
+            string expected = "g2 c";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestImportTemplateFromSubdir()
+        {
+            // /randomdir/x/subdir/a and /randomdir/y/subdir/b
+            string dir = tmpdir;
+            string a = "a() ::= << <subdir/b()> >>\n";
+            string b = "b() ::= <<x's subdir/b>>\n";
+            writeFile(dir, "x/subdir/a.st", a);
+            writeFile(dir, "y/subdir/b.st", b);
+
+            STGroup group1 = new STGroupDir(dir + "/x");
+            STGroup group2 = new STGroupDir(dir + "/y");
+            group1.importTemplates(group2);
+            ST st = group1.getInstanceOf("subdir/a");
+            string expected = " x's subdir/b ";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestImportTemplateFromGroupFile()
+        {
+            // /randomdir/x/subdir/a and /randomdir/y/subdir.stg which has a and b
+            string dir = tmpdir;
+            string a = "a() ::= << <subdir/b()> >>\n"; // get b imported from subdir.stg
+            writeFile(dir, "x/subdir/a.st", a);
+
+            string groupFile =
+                "a() ::= \"group file: a\"\n" +
+                "b() ::= \"group file: b\"\n";
+            writeFile(dir, "y/subdir.stg", groupFile);
+
+            STGroup group1 = new STGroupDir(dir + "/x");
+            STGroup group2 = new STGroupDir(dir + "/y");
+            group1.importTemplates(group2);
+            ST st = group1.getInstanceOf("subdir/a");
+            string expected = " group file: b ";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestPolymorphicTemplateReference()
+        {
+            string dir1 = tmpdir;
+            string b = "b() ::= <<dir1 b>>\n";
+            writeFile(dir1, "b.st", b);
+            string dir2 = tmpdir;
+            string a = "a() ::= << <b()> >>\n";
+            b = "b() ::= <<dir2 b>>\n";
+            writeFile(dir2, "a.st", a);
+            writeFile(dir2, "b.st", b);
+
+            STGroup group1 = new STGroupDir(dir1);
+            STGroup group2 = new STGroupDir(dir2);
+            group1.importTemplates(group2);
+
+            // normal lookup; a created from dir2 calls dir2.b
+            ST st = group2.getInstanceOf("a");
+            string expected = " dir2 b ";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+
+            // polymorphic lookup; a created from dir1 calls dir2.a which calls dir1.b
+            st = group1.getInstanceOf("a");
+            expected = " dir1 b ";
+            result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSuper()
+        {
+            string dir1 = tmpdir;
+            string a = "a() ::= <<dir1 a>>\n";
+            string b = "b() ::= <<dir1 b>>\n";
+            writeFile(dir1, "a.st", a);
+            writeFile(dir1, "b.st", b);
+            string dir2 = tmpdir;
+            a = "a() ::= << [<super.a()>] >>\n";
+            writeFile(dir2, "a.st", a);
+
+            STGroup group1 = new STGroupDir(dir1);
+            STGroup group2 = new STGroupDir(dir2);
+            group2.importTemplates(group1);
+            ST st = group2.getInstanceOf("a");
+            string expected = " [dir1 a] ";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestUnloadImportedTemplate()
+        {
+            string dir1 = tmpdir;
+            string a = "a() ::= <<dir1 a>>\n";
+            string b = "b() ::= <<dir1 b>>\n";
+            writeFile(dir1, "a.st", a);
+            writeFile(dir1, "b.st", b);
+            string dir2 = tmpdir;
+            a = "a() ::= << <b()> >>\n";
+            writeFile(dir2, "a.st", a);
+
+            STGroup group1 = new STGroupDir(dir1);
+            STGroup group2 = new STGroupDir(dir2);
+            group2.importTemplates(group1);
+
+            ST st = group2.getInstanceOf("a");
+            ST st2 = group2.getInstanceOf("b");
+            int originalHashCode = RuntimeHelpers.GetHashCode(st);
+            int originalHashCode2 = RuntimeHelpers.GetHashCode(st2);
+            group1.unload(); // blast cache
+            st = group2.getInstanceOf("a");
+            int newHashCode = RuntimeHelpers.GetHashCode(st);
+            Assert.AreEqual(originalHashCode == newHashCode, false); // diff objects
+
+            string expected = " dir1 b ";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+
+            st = group2.getInstanceOf("b");
+            int newHashCode2 = RuntimeHelpers.GetHashCode(st);
+            Assert.AreEqual(originalHashCode2 == newHashCode2, false); // diff objects
+            result = st.render();
+            expected = "dir1 b";
+            Assert.AreEqual(expected, result);
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/TestIndentation.cs b/Antlr4.Test.StringTemplate/TestIndentation.cs
new file mode 100644
index 0000000..e92cf3a
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/TestIndentation.cs
@@ -0,0 +1,297 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+
+    [TestClass]
+    public class TestIndentation : BaseTest
+    {
+        [TestMethod]
+        public void TestIndentInFrontOfTwoExpr()
+        {
+            string templates =
+                    "list(a,b) ::= <<" +
+                    "  <a><b>" + newline +
+                    ">>" + newline;
+
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            ST t = group.getInstanceOf("list");
+            t.impl.dump();
+            t.add("a", "Terence");
+            t.add("b", "Jim");
+            string expecting =
+                    "  TerenceJim";
+            Assert.AreEqual(expecting, t.render());
+        }
+
+        [TestMethod]
+        public void TestSimpleIndentOfAttributeList()
+        {
+            string templates =
+                    "list(names) ::= <<" +
+                    "  <names; separator=\"\\n\">" + newline +
+                    ">>" + newline;
+
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            ST t = group.getInstanceOf("list");
+            t.add("names", "Terence");
+            t.add("names", "Jim");
+            t.add("names", "Sriram");
+            string expecting =
+                    "  Terence" + newline +
+                    "  Jim" + newline +
+                    "  Sriram";
+            Assert.AreEqual(expecting, t.render());
+        }
+
+        [TestMethod]
+        public void TestIndentOfMultilineAttributes()
+        {
+            string templates =
+                    "list(names) ::= <<" +
+                    "  <names; separator=\"\n\">" + newline +
+                    ">>" + newline;
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            ST t = group.getInstanceOf("list");
+            t.add("names", "Terence\nis\na\nmaniac");
+            t.add("names", "Jim");
+            t.add("names", "Sriram\nis\ncool");
+            string expecting =
+                    "  Terence" + newline +
+                    "  is" + newline +
+                    "  a" + newline +
+                    "  maniac" + newline +
+                    "  Jim" + newline +
+                    "  Sriram" + newline +
+                    "  is" + newline +
+                    "  cool";
+            Assert.AreEqual(expecting, t.render());
+        }
+
+        [TestMethod]
+        public void TestIndentOfMultipleBlankLines()
+        {
+            string templates =
+                    "list(names) ::= <<" +
+                    "  <names>" + newline +
+                    ">>" + newline;
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            ST t = group.getInstanceOf("list");
+            t.add("names", "Terence\n\nis a maniac");
+            string expecting =
+                    "  Terence" + newline +
+                    "" + newline + // no indent on blank line
+                    "  is a maniac";
+            Assert.AreEqual(expecting, t.render());
+        }
+
+        [TestMethod]
+        public void TestIndentBetweenLeftJustifiedLiterals()
+        {
+            string templates =
+                    "list(names) ::= <<" +
+                    "Before:" + newline +
+                    "  <names; separator=\"\\n\">" + newline +
+                    "after" + newline +
+                    ">>" + newline;
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            ST t = group.getInstanceOf("list");
+            t.add("names", "Terence");
+            t.add("names", "Jim");
+            t.add("names", "Sriram");
+            string expecting =
+                    "Before:" + newline +
+                    "  Terence" + newline +
+                    "  Jim" + newline +
+                    "  Sriram" + newline +
+                    "after";
+            Assert.AreEqual(expecting, t.render());
+        }
+
+        [TestMethod]
+        public void TestNestedIndent()
+        {
+            string templates =
+                    "method(name,stats) ::= <<" +
+                    "void <name>() {" + newline +
+                    "\t<stats; separator=\"\\n\">" + newline +
+                    "}" + newline +
+                    ">>" + newline +
+                    "ifstat(expr,stats) ::= <<" + newline +
+                    "if (<expr>) {" + newline +
+                    "  <stats; separator=\"\\n\">" + newline +
+                    "}" +
+                    ">>" + newline +
+                    "assign(lhs,expr) ::= <<<lhs>=<expr>;>>" + newline
+                    ;
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            ST t = group.getInstanceOf("method");
+            t.add("name", "foo");
+            ST s1 = group.getInstanceOf("assign");
+            s1.add("lhs", "x");
+            s1.add("expr", "0");
+            ST s2 = group.getInstanceOf("ifstat");
+            s2.add("expr", "x>0");
+            ST s2a = group.getInstanceOf("assign");
+            s2a.add("lhs", "y");
+            s2a.add("expr", "x+y");
+            ST s2b = group.getInstanceOf("assign");
+            s2b.add("lhs", "z");
+            s2b.add("expr", "4");
+            s2.add("stats", s2a);
+            s2.add("stats", s2b);
+            t.add("stats", s1);
+            t.add("stats", s2);
+            string expecting =
+                    "void foo() {" + newline +
+                    "\tx=0;" + newline +
+                    "\tif (x>0) {" + newline +
+                    "\t  y=x+y;" + newline +
+                    "\t  z=4;" + newline +
+                    "\t}" + newline +
+                    "}";
+            Assert.AreEqual(expecting, t.render());
+        }
+
+        [TestMethod]
+        public void TestIndentedIFWithValueExpr()
+        {
+            ST t = new ST(
+                "begin" + newline +
+                "    <if(x)>foo<endif>" + newline +
+                "end" + newline);
+            t.add("x", "x");
+            string expecting = "begin" + newline + "    foo" + newline + "end" + newline;
+            string result = t.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestIFWithIndentOnMultipleLines()
+        {
+            ST t = new ST(
+                "begin" + newline +
+                "   <if(x)>" + newline +
+                "   foo" + newline +
+                "   <else>" + newline +
+                "   bar" + newline +
+                "   <endif>" + newline +
+                "end" + newline);
+            string expecting = "begin" + newline + "   bar" + newline + "end" + newline;
+            string result = t.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestIFWithIndentAndExprOnMultipleLines()
+        {
+            ST t = new ST(
+                "begin" + newline +
+                "   <if(x)>" + newline +
+                "   <x>" + newline +
+                "   <else>" + newline +
+                "   <y>" + newline +
+                "   <endif>" + newline +
+                "end" + newline);
+            t.add("y", "y");
+            string expecting = "begin" + newline + "   y" + newline + "end" + newline;
+            string result = t.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestIFWithIndentAndExprWithIndentOnMultipleLines()
+        {
+            ST t = new ST(
+                "begin" + newline +
+                "   <if(x)>" + newline +
+                "     <x>" + newline +
+                "   <else>" + newline +
+                "     <y>" + newline +
+                "   <endif>" + newline +
+                "end" + newline);
+            t.add("y", "y");
+            string expecting = "begin" + newline + "     y" + newline + "end" + newline;
+            string result = t.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestNestedIFWithIndentOnMultipleLines()
+        {
+            ST t = new ST(
+                "begin" + newline +
+                "   <if(x)>" + newline +
+                "      <if(y)>" + newline +
+                "      foo" + newline +
+                "      <endif>" + newline +
+                "   <else>" + newline +
+                "      <if(z)>" + newline +
+                "      foo" + newline +
+                "      <endif>" + newline +
+                "   <endif>" + newline +
+                "end" + newline);
+            t.add("x", "x");
+            t.add("y", "y");
+            string expecting = "begin" + newline + "      foo" + newline + "end" + newline; // no indent
+            string result = t.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestIFInSubtemplate()
+        {
+            ST t = new ST(
+                "<names:{n |" + newline +
+                "   <if(x)>" + newline +
+                "   <x>" + newline +
+                "   <else>" + newline +
+                "   <y>" + newline +
+                "   <endif>" + newline +
+                "}>" + newline);
+            t.add("names", "Ter");
+            t.add("y", "y");
+            string expecting = "   y" + newline + newline;
+            string result = t.render();
+            Assert.AreEqual(expecting, result);
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/TestIndirectionAndEarlyEval.cs b/Antlr4.Test.StringTemplate/TestIndirectionAndEarlyEval.cs
new file mode 100644
index 0000000..3863a58
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/TestIndirectionAndEarlyEval.cs
@@ -0,0 +1,138 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using System.Collections.Generic;
+
+    [TestClass]
+    public class TestIndirectionAndEarlyEval : BaseTest
+    {
+        [TestMethod]
+        public void TestEarlyEval()
+        {
+            string template = "<(name)>";
+            ST st = new ST(template);
+            st.add("name", "Ter");
+            string expected = "Ter";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestIndirectTemplateInclude()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("foo", "bar");
+            string template = "<(name)()>";
+            group.defineTemplate("test", "name", template);
+            ST st = group.getInstanceOf("test");
+            st.add("name", "foo");
+            string expected = "bar";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestIndirectTemplateIncludeWithArgs()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("foo", "x,y", "<x><y>");
+            string template = "<(name)({1},{2})>";
+            group.defineTemplate("test", "name", template);
+            ST st = group.getInstanceOf("test");
+            st.add("name", "foo");
+            string expected = "12";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestIndirectTemplateIncludeViaTemplate()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("foo", "bar");
+            group.defineTemplate("tname", "foo");
+            string template = "<(tname())()>";
+            group.defineTemplate("test", "name", template);
+            ST st = group.getInstanceOf("test");
+            string expected = "bar";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestIndirectProp()
+        {
+            string template = "<u.(propname)>: <u.name>";
+            ST st = new ST(template);
+            st.add("u", new TestCoreBasics.User(1, "parrt"));
+            st.add("propname", "id");
+            string expected = "1: parrt";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestIndirectMap()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("a", "x", "[<x>]");
+            group.defineTemplate("test", "names,templateName", "hi <names:(templateName)()>!");
+            ST st = group.getInstanceOf("test");
+            st.add("names", "Ter");
+            st.add("names", "Tom");
+            st.add("names", "Sumana");
+            st.add("templateName", "a");
+            string expected =
+                "hi [Ter][Tom][Sumana]!";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestNonStringDictLookup()
+        {
+            string template = "<m.(intkey)>";
+            ST st = new ST(template);
+            IDictionary<int, string> m = new Dictionary<int, string>();
+            m[36] = "foo";
+            st.add("m", m);
+            st.add("intkey", 36);
+            string expected = "foo";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/TestInterptimeErrors.cs b/Antlr4.Test.StringTemplate/TestInterptimeErrors.cs
new file mode 100644
index 0000000..449705d
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/TestInterptimeErrors.cs
@@ -0,0 +1,275 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using Antlr4.StringTemplate.Misc;
+    using Environment = System.Environment;
+
+    [TestClass]
+    public class TestInterptimeErrors : BaseTest
+    {
+        public class UserHiddenName
+        {
+            protected string name;
+            public UserHiddenName(string name)
+            {
+                this.name = name;
+            }
+            protected string getName()
+            {
+                return name;
+            }
+        }
+
+        public class UserHiddenNameField
+        {
+            protected string name;
+            public UserHiddenNameField(string name)
+            {
+                this.name = name;
+            }
+        }
+
+        [TestMethod]
+        public void TestMissingEmbeddedTemplate()
+        {
+            ErrorBuffer errors = new ErrorBuffer();
+
+            string templates =
+                "t() ::= \"<foo()>\"" + Environment.NewLine;
+
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            ST st = group.getInstanceOf("t");
+            st.render();
+            string expected = "context [t] 1:0 no such template: foo" + newline;
+            string result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestMissingSuperTemplate()
+        {
+            ErrorBuffer errors = new ErrorBuffer();
+
+            string templates =
+                "t() ::= \"<super.t()>\"" + Environment.NewLine;
+
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            string templates2 =
+                "u() ::= \"blech\"" + Environment.NewLine;
+
+            writeFile(tmpdir, "t2.stg", templates2);
+            STGroup group2 = new STGroupFile(tmpdir + "/" + "t2.stg");
+            group.importTemplates(group2);
+            ST st = group.getInstanceOf("t");
+            st.render();
+            string expected = "context [t] 1:1 no such template: super.t" + newline;
+            string result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestNoPropertyNotError()
+        {
+            ErrorBuffer errors = new ErrorBuffer();
+
+            string templates =
+                "t(u) ::= \"<u.x>\"" + Environment.NewLine;
+
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            ST st = group.getInstanceOf("t");
+            st.add("u", new User(32, "parrt"));
+            st.render();
+            string expected = "";
+            string result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestHiddenPropertyNotError()
+        {
+            ErrorBuffer errors = new ErrorBuffer();
+
+            string templates =
+                "t(u) ::= \"<u.name>\"" + Environment.NewLine;
+
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            ST st = group.getInstanceOf("t");
+            st.add("u", new UserHiddenName("parrt"));
+            st.render();
+            string expected = "";
+            string result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestHiddenFieldNotError()
+        {
+            ErrorBuffer errors = new ErrorBuffer();
+
+            string templates =
+                "t(u) ::= \"<u.name>\"" + Environment.NewLine;
+
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            ST st = group.getInstanceOf("t");
+            st.add("u", new UserHiddenNameField("parrt"));
+            st.render();
+            string expected = "";
+            string result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSoleArg()
+        {
+            ErrorBuffer errors = new ErrorBuffer();
+
+            string templates =
+                "t() ::= \"<u({9})>\"\n" +
+                "u(x,y) ::= \"<x>\"\n";
+
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            ST st = group.getInstanceOf("t");
+            st.render();
+            string expected = "context [t] 1:1 passed 1 arg(s) to template u with 2 declared arg(s)" + newline;
+            string result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSoleArgUsingApplySyntax()
+        {
+            ErrorBuffer errors = new ErrorBuffer();
+
+            string templates =
+                "t() ::= \"<{9}:u()>\"\n" +
+                "u(x,y) ::= \"<x>\"\n";
+
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            ST st = group.getInstanceOf("t");
+            string expected = "9";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+
+            expected = "context [t] 1:5 passed 1 arg(s) to template u with 2 declared arg(s)" + newline;
+            result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestUndefinedAttr()
+        {
+            ErrorBuffer errors = new ErrorBuffer();
+
+            string templates =
+                "t() ::= \"<u()>\"\n" +
+                "u() ::= \"<x>\"\n";
+
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            STGroup.debug = true;
+            ST st = group.getInstanceOf("t");
+            st.render();
+            string expected = "context [t u] 1:1 attribute x isn't defined" + newline;
+            string result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestParallelAttributeIterationWithMissingArgs()
+        {
+            ErrorBuffer errors = new ErrorBuffer();
+            STGroup group = new STGroup();
+            group.setListener(errors);
+            ST e = new ST(group,
+                    "<names,phones,salaries:{n,p | <n>@<p>}; separator=\", \">"
+                );
+            e.add("names", "Ter");
+            e.add("names", "Tom");
+            e.add("phones", "1");
+            e.add("phones", "2");
+            e.add("salaries", "big");
+            e.render();
+            string errorExpecting =
+                "1:23: anonymous template has 2 arg(s) but mapped across 3 value(s)" + newline +
+                "context [anonymous] 1:23 passed 3 arg(s) to template _sub1 with 2 declared arg(s)" + newline +
+                "context [anonymous] 1:1 iterating through 3 values in zip map but template has 2 declared arguments" + newline;
+            Assert.AreEqual(errorExpecting, errors.ToString());
+            string expecting = "Ter@1, Tom@2";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestStringTypeMismatch()
+        {
+            ErrorBuffer errors = new ErrorBuffer();
+            STGroup group = new STGroup();
+            group.setListener(errors);
+            ST e = new ST(group, "<trim(s)>");
+            e.add("s", 34);
+            e.render(); // generate the error
+            string errorExpecting = "context [anonymous] 1:1 function trim expects a string not System.Int32" + newline;
+            Assert.AreEqual(errorExpecting, errors.ToString());
+        }
+
+        [TestMethod]
+        public void TestStringTypeMismatch2()
+        {
+            ErrorBuffer errors = new ErrorBuffer();
+            STGroup group = new STGroup();
+            group.setListener(errors);
+            ST e = new ST(group, "<strlen(s)>");
+            e.add("s", 34);
+            e.render(); // generate the error
+            string errorExpecting = "context [anonymous] 1:1 function strlen expects a string not System.Int32" + newline;
+            Assert.AreEqual(errorExpecting, errors.ToString());
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/TestLexer.cs b/Antlr4.Test.StringTemplate/TestLexer.cs
new file mode 100644
index 0000000..e880b5a
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/TestLexer.cs
@@ -0,0 +1,247 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+
+    [TestClass]
+    public class TestLexer : BaseTest
+    {
+        [TestMethod]
+        public void TestOneExpr()
+        {
+            string template = "<name>";
+            string expected = "[[@0,0:0='<',<LDELIM>,1:0], [@1,1:4='name',<ID>,1:1], " +
+                              "[@2,5:5='>',<RDELIM>,1:5]]";
+            checkTokens(template, expected);
+        }
+
+        [TestMethod]
+        public void TestOneExprSurrounded()
+        {
+            string template = "hi <name> mom";
+            string expected = "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='<',<LDELIM>,1:3], " +
+                              "[@2,4:7='name',<ID>,1:4], [@3,8:8='>',<RDELIM>,1:8], " +
+                              "[@4,9:12=' mom',<TEXT>,1:9]]";
+            checkTokens(template, expected);
+        }
+
+        [TestMethod]
+        public void TestEscDelim()
+        {
+            string template = "hi \\<name>";
+            string expected = "[[@0,0:9='hi <name>',<TEXT>,1:0]]";
+            checkTokens(template, expected);
+        }
+
+        /*
+    \signature{Laleh Shahideh, Ed.D. \\ Associate~Dean \\ Student Academic~Services \\ College of Arts and Sciences
+    }
+    */
+        [TestMethod]
+        public void TestEscEsc()
+        {
+            string template = "hi \\\\ foo";
+            string expected = "[[@0,0:8='hi \\ foo',<TEXT>,1:0]]";
+            checkTokens(template, expected);
+        }
+
+        [TestMethod]
+        public void TestEscDelimHasCorrectStartChar()
+        {
+            string template = "<a>\\<dog";
+            string expected =
+                "[[@0,0:0='<',<LDELIM>,1:0], [@1,1:1='a',<ID>,1:1], [@2,2:2='>',<RDELIM>,1:2], " +
+                "[@3,3:7='<dog',<TEXT>,1:3]]";
+            checkTokens(template, expected);
+        }
+
+        [TestMethod]
+        public void TestEscChar()
+        {
+            string template = "hi \\x";
+            string expected = "[[@0,0:4='hi \\x',<TEXT>,1:0]]";
+            checkTokens(template, expected);
+        }
+
+        [TestMethod]
+        public void TestString()
+        {
+            string template = "hi <foo(a=\">\")>";
+            string expected = "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='<',<LDELIM>,1:3], " +
+                              "[@2,4:6='foo',<ID>,1:4], [@3,7:7='(',<LPAREN>,1:7], " +
+                              "[@4,8:8='a',<ID>,1:8], [@5,9:9='=',<EQUALS>,1:9], " +
+                              "[@6,10:12='\">\"',<STRING>,1:10], [@7,13:13=')',<RPAREN>,1:13], " +
+                              "[@8,14:14='>',<RDELIM>,1:14]]";
+            checkTokens(template, expected);
+        }
+
+        [TestMethod]
+        public void TestEscInString()
+        {
+            string template = "hi <foo(a=\">\\\"\")>";
+            string expected =
+                "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='<',<LDELIM>,1:3], [@2,4:6='foo',<ID>,1:4], " +
+                "[@3,7:7='(',<LPAREN>,1:7], [@4,8:8='a',<ID>,1:8], [@5,9:9='=',<EQUALS>,1:9], " +
+                "[@6,10:14='\">\"\"',<STRING>,1:10], [@7,15:15=')',<RPAREN>,1:15], " +
+                "[@8,16:16='>',<RDELIM>,1:16]]";
+            checkTokens(template, expected);
+        }
+
+        [TestMethod]
+        public void TestSubtemplate()
+        {
+            string template = "hi <names:{n | <n>}>";
+            string expected =
+                "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='<',<LDELIM>,1:3], [@2,4:8='names',<ID>,1:4], [@3,9:9=':',<COLON>,1:9], [@4,10:10='{',<LCURLY>,1:10], [@5,11:11='n',<ID>,1:11], [@6,13:13='|',<PIPE>,1:13], [@7,15:15='<',<LDELIM>,1:15], [@8,16:16='n',<ID>,1:16], [@9,17:17='>',<RDELIM>,1:17], [@10,18:18='}',<RCURLY>,1:18], [@11,19:19='>',<RDELIM>,1:19]]";
+            checkTokens(template, expected);
+        }
+
+        [TestMethod]
+        public void TestSubtemplateNoArg()
+        {
+            string template = "hi <names:{n | <n>}>";
+            string expected =
+                "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='<',<LDELIM>,1:3], [@2,4:8='names',<ID>,1:4], [@3,9:9=':',<COLON>,1:9], [@4,10:10='{',<LCURLY>,1:10], [@5,11:11='n',<ID>,1:11], [@6,13:13='|',<PIPE>,1:13], [@7,15:15='<',<LDELIM>,1:15], [@8,16:16='n',<ID>,1:16], [@9,17:17='>',<RDELIM>,1:17], [@10,18:18='}',<RCURLY>,1:18], [@11,19:19='>',<RDELIM>,1:19]]";
+            checkTokens(template, expected);
+        }
+
+        [TestMethod]
+        public void TestSubtemplateMultiArgs()
+        {
+            string template = "hi <names:{x,y | <x><y>}>"; // semantically bogus
+            string expected =
+                "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='<',<LDELIM>,1:3], [@2,4:8='names',<ID>,1:4], [@3,9:9=':',<COLON>,1:9], [@4,10:10='{',<LCURLY>,1:10], [@5,11:11='x',<ID>,1:11], [@6,12:12=',',<COMMA>,1:12], [@7,13:13='y',<ID>,1:13], [@8,15:15='|',<PIPE>,1:15], [@9,17:17='<',<LDELIM>,1:17], [@10,18:18='x',<ID>,1:18], [@11,19:19='>',<RDELIM>,1:19], [@12,20:20='<',<LDELIM>,1:20], [@13,21:21='y',<ID>,1:21], [@14,22:22='>',<RDELIM>,1:22], [@15,23:23='}',<RCURLY>,1:23], [@16,24:24='>',<RDELIM>,1:24]]";
+            checkTokens(template, expected);
+        }
+
+        [TestMethod]
+        public void TestNestedSubtemplate()
+        {
+            string template = "hi <names:{n | <n:{x|<x>}>}>";
+            string expected =
+                "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='<',<LDELIM>,1:3], [@2,4:8='names',<ID>,1:4], [@3,9:9=':',<COLON>,1:9], [@4,10:10='{',<LCURLY>,1:10], [@5,11:11='n',<ID>,1:11], [@6,13:13='|',<PIPE>,1:13], [@7,15:15='<',<LDELIM>,1:15], [@8,16:16='n',<ID>,1:16], [@9,17:17=':',<COLON>,1:17], [@10,18:18='{',<LCURLY>,1:18], [@11,19:19='x',<ID>,1:19], [@12,20:20='|',<PIPE>,1:20], [@13,21:21='<',<LDELIM>,1:21], [@14,22:22='x',<ID>,1:22], [@15,23:23='>',<RDELIM>,1:23], [@16,24:24='}',<RCURLY>,1:24], [@17,25:25='>',<RDELIM>,1:25], [@18,26:26='}',<RCURLY>,1:26], [@19,27:27='>',<RDELIM>,1:27]]";
+            checkTokens(template, expected);
+        }
+
+        [TestMethod]
+        public void TestNestedList()
+        {
+            string template =
+                "*<[names, [\"foo\",\"bar\"]:{x|<x>!},phones]; separator=\", \">*";
+            string expected =
+                "[[@0,0:0='*',<TEXT>,1:0], [@1,1:1='<',<LDELIM>,1:1], [@2,2:2='[',<LBRACK>,1:2], [@3,3:7='names',<ID>,1:3], [@4,8:8=',',<COMMA>,1:8], [@5,9:10=' [',<LBRACK>,1:9], [@6,11:15='\"foo\"',<STRING>,1:11], [@7,16:16=',',<COMMA>,1:16], [@8,17:21='\"bar\"',<STRING>,1:17], [@9,22:22=']',<RBRACK>,1:22], [@10,23:23=':',<COLON>,1:23], [@11,24:24='{',<LCURLY>,1:24], [@12,25:25='x',<ID>,1:25], [@13,26:26='|',<PIPE>,1:26], [@14,27:27='<',<LDELIM>,1:27], [@15,28:28='x',<ID>,1:28], [@16,29:29='>',<RDELIM>,1:29], [@17,30:30='!',<TEXT>,1:30], [@18,31:31='}',<RCURLY>,1:31], [@19,32:32=',',<COMMA>,1:32], [@20,33:38='phones',<ID>,1:33], [@21,39:39=']',<RBRACK>,1:39], [@22,40:40=';',<SEMI>,1:40], [@23,42:50='separator',<ID>,1:42], [@24,51:51='=',<EQUALS>,1:51], [@25,52:55='\", \"',<STRING>,1:52], [@26,56:56='>',<RDELIM>,1:56], [@27,57:57='*',<TEXT>,1:57]]";
+            checkTokens(template, expected);
+        }
+
+        [TestMethod]
+        public void TestIF()
+        {
+            string template = "<if(!name)>works<endif>";
+            string expected =
+                "[[@0,0:0='<',<LDELIM>,1:0], [@1,1:2='if',<IF>,1:1], [@2,3:3='(',<LPAREN>,1:3], " +
+                "[@3,4:4='!',<BANG>,1:4], [@4,5:8='name',<ID>,1:5], [@5,9:9=')',<RPAREN>,1:9], " +
+                "[@6,10:10='>',<RDELIM>,1:10], [@7,11:15='works',<TEXT>,1:11], " +
+                "[@8,16:16='<',<LDELIM>,1:16], [@9,17:21='endif',<ENDIF>,1:17], " +
+                "[@10,22:22='>',<RDELIM>,1:22]]";
+            checkTokens(template, expected);
+        }
+
+        [TestMethod]
+        public void TestIFNot()
+        {
+            string template = "<if(!name)>works<endif>";
+            string expected =
+                "[[@0,0:0='<',<LDELIM>,1:0], [@1,1:2='if',<IF>,1:1], [@2,3:3='(',<LPAREN>,1:3], " +
+                "[@3,4:4='!',<BANG>,1:4], [@4,5:8='name',<ID>,1:5], [@5,9:9=')',<RPAREN>,1:9], " +
+                "[@6,10:10='>',<RDELIM>,1:10], [@7,11:15='works',<TEXT>,1:11], " +
+                "[@8,16:16='<',<LDELIM>,1:16], [@9,17:21='endif',<ENDIF>,1:17], " +
+                "[@10,22:22='>',<RDELIM>,1:22]]";
+            checkTokens(template, expected);
+        }
+
+        [TestMethod]
+        public void TestIFELSE()
+        {
+            string template = "<if(name)>works<else>fail<endif>";
+            string expected =
+                "[[@0,0:0='<',<LDELIM>,1:0], [@1,1:2='if',<IF>,1:1], [@2,3:3='(',<LPAREN>,1:3], " +
+                "[@3,4:7='name',<ID>,1:4], [@4,8:8=')',<RPAREN>,1:8], [@5,9:9='>',<RDELIM>,1:9], " +
+                "[@6,10:14='works',<TEXT>,1:10], [@7,15:15='<',<LDELIM>,1:15], " +
+                "[@8,16:19='else',<ELSE>,1:16], [@9,20:20='>',<RDELIM>,1:20], " +
+                "[@10,21:24='fail',<TEXT>,1:21], [@11,25:25='<',<LDELIM>,1:25], " +
+                "[@12,26:30='endif',<ENDIF>,1:26], [@13,31:31='>',<RDELIM>,1:31]]";
+            checkTokens(template, expected);
+        }
+
+        [TestMethod]
+        public void TestELSEIF()
+        {
+            string template = "<if(name)>fail<elseif(id)>works<else>fail<endif>";
+            string expected =
+                "[[@0,0:0='<',<LDELIM>,1:0], [@1,1:2='if',<IF>,1:1], [@2,3:3='(',<LPAREN>,1:3], " +
+                "[@3,4:7='name',<ID>,1:4], [@4,8:8=')',<RPAREN>,1:8], [@5,9:9='>',<RDELIM>,1:9], " +
+                "[@6,10:13='fail',<TEXT>,1:10], [@7,14:14='<',<LDELIM>,1:14], " +
+                "[@8,15:20='elseif',<ELSEIF>,1:15], [@9,21:21='(',<LPAREN>,1:21], " +
+                "[@10,22:23='id',<ID>,1:22], [@11,24:24=')',<RPAREN>,1:24], " +
+                "[@12,25:25='>',<RDELIM>,1:25], [@13,26:30='works',<TEXT>,1:26], " +
+                "[@14,31:31='<',<LDELIM>,1:31], [@15,32:35='else',<ELSE>,1:32], " +
+                "[@16,36:36='>',<RDELIM>,1:36], [@17,37:40='fail',<TEXT>,1:37], " +
+                "[@18,41:41='<',<LDELIM>,1:41], [@19,42:46='endif',<ENDIF>,1:42], " +
+                "[@20,47:47='>',<RDELIM>,1:47]]";
+            checkTokens(template, expected);
+        }
+
+        [TestMethod]
+        public void TestEmbeddedRegion()
+        {
+            string template = "<@r>foo<@end>";
+            string expected =
+                "[[@0,0:0='<',<LDELIM>,1:0], [@1,1:1='@',<AT>,1:1], [@2,2:2='r',<ID>,1:2], " +
+                "[@3,3:3='>',<RDELIM>,1:3], [@4,4:6='foo',<TEXT>,1:4], [@5,7:7='<',<LDELIM>,1:7], " +
+                "[@6,8:11='@end',<END>,1:8], [@7,12:12='>',<RDELIM>,1:12]]";
+            checkTokens(template, expected);
+        }
+
+        [TestMethod]
+        public void TestRegion()
+        {
+            string template = "<@r()>";
+            string expected =
+                "[[@0,0:0='<',<LDELIM>,1:0], [@1,1:1='@',<AT>,1:1], [@2,2:2='r',<ID>,1:2], " +
+                 "[@3,3:3='(',<LPAREN>,1:3], [@4,4:4=')',<RPAREN>,1:4], [@5,5:5='>',<RDELIM>,1:5]]";
+            checkTokens(template, expected);
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/TestLineWrap.cs b/Antlr4.Test.StringTemplate/TestLineWrap.cs
new file mode 100644
index 0000000..2498cd5
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/TestLineWrap.cs
@@ -0,0 +1,433 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using StringWriter = System.IO.StringWriter;
+    using System.Collections.Generic;
+    using Environment = System.Environment;
+
+    [TestClass]
+    public class TestLineWrap : BaseTest
+    {
+        [TestMethod]
+        public void TestLineWrap1()
+        {
+            string templates =
+                    "array(values) ::= <<int[] a = { <values; wrap=\"\\n\", separator=\",\"> };>>" + newline;
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST a = group.getInstanceOf("array");
+            a.add("values",
+                           new int[] {3,9,20,2,1,4,6,32,5,6,77,888,2,1,6,32,5,6,77,
+						4,9,20,2,1,4,63,9,20,2,1,4,6,32,5,6,77,6,32,5,6,77,
+					    3,9,20,2,1,4,6,32,5,6,77,888,1,6,32,5});
+            string expecting =
+                "int[] a = { 3,9,20,2,1,4,6,32,5,6,77,888,\n" +
+                "2,1,6,32,5,6,77,4,9,20,2,1,4,63,9,20,2,1,\n" +
+                "4,6,32,5,6,77,6,32,5,6,77,3,9,20,2,1,4,6,\n" +
+                "32,5,6,77,888,1,6,32,5 };";
+
+            StringWriter sw = new StringWriter();
+            STWriter stw = new AutoIndentWriter(sw, "\n"); // force \n as newline
+            stw.setLineWidth(40);
+            a.write(stw);
+            string result = sw.ToString();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestLineWrapAnchored()
+        {
+            string templates =
+                "array(values) ::= <<int[] a = { <values; anchor, wrap, separator=\",\"> };>>" + newline;
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST a = group.getInstanceOf("array");
+            a.add("values",
+                new int[] {3,9,20,2,1,4,6,32,5,6,77,888,2,1,6,32,5,6,77,
+            4,9,20,2,1,4,63,9,20,2,1,4,6,32,5,6,77,6,32,5,6,77,
+            3,9,20,2,1,4,6,32,5,6,77,888,1,6,32,5});
+            string expecting =
+                "int[] a = { 3,9,20,2,1,4,6,32,5,6,77,888," + Environment.NewLine +
+                "            2,1,6,32,5,6,77,4,9,20,2,1,4," + Environment.NewLine +
+                "            63,9,20,2,1,4,6,32,5,6,77,6," + Environment.NewLine +
+                "            32,5,6,77,3,9,20,2,1,4,6,32," + Environment.NewLine +
+                "            5,6,77,888,1,6,32,5 };";
+            Assert.AreEqual(expecting, a.render(40));
+        }
+
+        [TestMethod]
+        public void TestSubtemplatesAnchorToo()
+        {
+            string templates =
+                    "array(values) ::= <<{ <values; anchor, separator=\", \"> }>>" + newline;
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST x = new ST("<\\n>{ <stuff; anchor, separator=\",\\n\"> }<\\n>");
+            x.groupThatCreatedThisInstance = group;
+            x.add("stuff", "1");
+            x.add("stuff", "2");
+            x.add("stuff", "3");
+            ST a = group.getInstanceOf("array");
+            a.add("values", new List<object>() { "a", x, "b" });
+            string expecting =
+                "{ a, " + Environment.NewLine +
+                "  { 1," + Environment.NewLine +
+                "    2," + Environment.NewLine +
+                "    3 }" + Environment.NewLine +
+                "  , b }";
+            Assert.AreEqual(expecting, a.render(40));
+        }
+
+        [TestMethod]
+        public void TestFortranLineWrap()
+        {
+            string templates =
+                    "func(args) ::= <<       FUNCTION line( <args; wrap=\"\\n      c\", separator=\",\"> )>>" + newline;
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST a = group.getInstanceOf("func");
+            a.add("args",
+                           new string[] { "a", "b", "c", "d", "e", "f" });
+            string expecting =
+                "       FUNCTION line( a,b,c,d," + Environment.NewLine +
+                "      ce,f )";
+            Assert.AreEqual(expecting, a.render(30));
+        }
+
+        [TestMethod]
+        public void TestLineWrapWithDiffAnchor()
+        {
+            string templates =
+                    "array(values) ::= <<int[] a = { <{1,9,2,<values; wrap, separator=\",\">}; anchor> };>>" + newline;
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST a = group.getInstanceOf("array");
+            a.add("values",
+                           new int[] {3,9,20,2,1,4,6,32,5,6,77,888,2,1,6,32,5,6,77,
+						4,9,20,2,1,4,63,9,20,2,1,4,6});
+            string expecting =
+                "int[] a = { 1,9,2,3,9,20,2,1,4," + Environment.NewLine +
+                "            6,32,5,6,77,888,2," + Environment.NewLine +
+                "            1,6,32,5,6,77,4,9," + Environment.NewLine +
+                "            20,2,1,4,63,9,20,2," + Environment.NewLine +
+                "            1,4,6 };";
+            Assert.AreEqual(expecting, a.render(30));
+        }
+
+        [TestMethod]
+        public void TestLineWrapEdgeCase()
+        {
+            string templates =
+                    "duh(chars) ::= <<<chars; wrap=\"\\n\"\\>>>" + newline;
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST a = group.getInstanceOf("duh");
+            a.add("chars", new string[] { "a", "b", "c", "d", "e" });
+            // lineWidth==3 implies that we can have 3 characters at most
+            string expecting =
+                "abc" + Environment.NewLine +
+                "de";
+            Assert.AreEqual(expecting, a.render(3));
+        }
+
+        [TestMethod]
+        public void TestLineWrapLastCharIsNewline()
+        {
+            string templates =
+                    "duh(chars) ::= <<<chars; wrap=\"\\n\"\\>>>" + newline;
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST a = group.getInstanceOf("duh");
+            a.add("chars", new string[] { "a", "b", "\n", "d", "e" });
+            // don't do \n if it's last element anyway
+            string expecting =
+                "ab" + Environment.NewLine +
+                "de";
+            Assert.AreEqual(expecting, a.render(3));
+        }
+
+        [TestMethod]
+        public void TestLineWrapCharAfterWrapIsNewline()
+        {
+            string templates =
+                    "duh(chars) ::= <<<chars; wrap=\"\\n\"\\>>>" + newline;
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST a = group.getInstanceOf("duh");
+            a.add("chars", new string[] { "a", "b", "c", "\n", "d", "e" });
+            // Once we wrap, we must dump chars as we see them.  A newline right
+            // after a wrap is just an "unfortunate" event.  People will expect
+            // a newline if it's in the data.
+            string expecting =
+                "abc" + Environment.NewLine +
+                "" + Environment.NewLine +
+                "de";
+            Assert.AreEqual(expecting, a.render(3));
+        }
+
+        [TestMethod]
+        public void TestLineWrapForList()
+        {
+            string templates =
+                    "duh(data) ::= <<!<data; wrap>!>>" + newline;
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST a = group.getInstanceOf("duh");
+            a.add("data", new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 });
+            string expecting =
+                "!123" + Environment.NewLine +
+                "4567" + Environment.NewLine +
+                "89!";
+            Assert.AreEqual(expecting, a.render(4));
+        }
+
+        [TestMethod]
+        public void TestLineWrapForAnonTemplate()
+        {
+            string templates =
+                    "duh(data) ::= <<!<data:{v|[<v>]}; wrap>!>>" + newline;
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST a = group.getInstanceOf("duh");
+            a.add("data", new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 });
+            string expecting =
+                "![1][2][3]" + Environment.NewLine + // width=9 is the 3 char; don't break til after ]
+                "[4][5][6]" + Environment.NewLine +
+                "[7][8][9]!";
+            Assert.AreEqual(expecting, a.render(9));
+        }
+
+        [TestMethod]
+        public void TestLineWrapForAnonTemplateAnchored()
+        {
+            string templates =
+                    "duh(data) ::= <<!<data:{v|[<v>]}; anchor, wrap>!>>" + newline;
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST a = group.getInstanceOf("duh");
+            a.add("data", new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 });
+            string expecting =
+                "![1][2][3]" + Environment.NewLine +
+                " [4][5][6]" + Environment.NewLine +
+                " [7][8][9]!";
+            Assert.AreEqual(expecting, a.render(9));
+        }
+
+        [TestMethod]
+        public void TestLineWrapForAnonTemplateComplicatedWrap()
+        {
+            string templates =
+                    "top(s) ::= <<  <s>.>>" +
+                    "str(data) ::= <<!<data:{v|[<v>]}; wrap=\"!+\\n!\">!>>" + newline;
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST t = group.getInstanceOf("top");
+            ST s = group.getInstanceOf("str");
+            s.add("data", new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 });
+            t.add("s", s);
+            string expecting =
+                "  ![1][2]!+" + Environment.NewLine +
+                "  ![3][4]!+" + Environment.NewLine +
+                "  ![5][6]!+" + Environment.NewLine +
+                "  ![7][8]!+" + Environment.NewLine +
+                "  ![9]!.";
+            Assert.AreEqual(expecting, t.render(9));
+        }
+
+        [TestMethod]
+        public void TestIndentBeyondLineWidth()
+        {
+            string templates =
+                    "duh(chars) ::= <<    <chars; wrap=\"\\n\"\\>>>" + newline;
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST a = group.getInstanceOf("duh");
+            a.add("chars", new string[] { "a", "b", "c", "d", "e" });
+            //
+            string expecting =
+                "    a" + Environment.NewLine +
+                "    b" + Environment.NewLine +
+                "    c" + Environment.NewLine +
+                "    d" + Environment.NewLine +
+                "    e";
+            Assert.AreEqual(expecting, a.render(2));
+        }
+
+        [TestMethod]
+        public void TestIndentedExpr()
+        {
+            string templates =
+                    "duh(chars) ::= <<    <chars; wrap=\"\\n\"\\>>>" + newline;
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST a = group.getInstanceOf("duh");
+            a.add("chars", new string[] { "a", "b", "c", "d", "e" });
+            //
+            string expecting =
+                "    ab" + Environment.NewLine +
+                "    cd" + Environment.NewLine +
+                "    e";
+            // width=4 spaces + 2 char.
+            Assert.AreEqual(expecting, a.render(6));
+        }
+
+        [TestMethod]
+        public void TestNestedIndentedExpr()
+        {
+            string templates =
+                    "top(d) ::= <<  <d>!>>" + newline +
+                    "duh(chars) ::= <<  <chars; wrap=\"\\n\"\\>>>" + newline;
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST top = group.getInstanceOf("top");
+            ST duh = group.getInstanceOf("duh");
+            duh.add("chars", new string[] { "a", "b", "c", "d", "e" });
+            top.add("d", duh);
+            string expecting =
+                "    ab" + Environment.NewLine +
+                "    cd" + Environment.NewLine +
+                "    e!";
+            // width=4 spaces + 2 char.
+            Assert.AreEqual(expecting, top.render(6));
+        }
+
+        [TestMethod]
+        public void TestNestedWithIndentAndTrackStartOfExpr()
+        {
+            string templates =
+                    "top(d) ::= <<  <d>!>>" + newline +
+                    "duh(chars) ::= <<x: <chars; anchor, wrap=\"\\n\"\\>>>" + newline;
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST top = group.getInstanceOf("top");
+            ST duh = group.getInstanceOf("duh");
+            duh.add("chars", new string[] { "a", "b", "c", "d", "e" });
+            top.add("d", duh);
+            //
+            string expecting =
+                "  x: ab" + Environment.NewLine +
+                "     cd" + Environment.NewLine +
+                "     e!";
+            Assert.AreEqual(expecting, top.render(7));
+        }
+
+        [TestMethod]
+        public void TestLineDoesNotWrapDueToLiteral()
+        {
+            string templates =
+                    "m(args,body) ::= <<[TestMethod] public voidfoo(<args; wrap=\"\\n\",separator=\", \">) throws Ick { <body> }>>" + newline;
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST a = group.getInstanceOf("m");
+            a.add("args",
+                           new string[] { "a", "b", "c" });
+            a.add("body", "i=3;");
+            // make it wrap because of ") throws Ick { " literal
+            int n = "[TestMethod] public voidfoo(a, b, c".Length;
+            string expecting =
+                "[TestMethod] public voidfoo(a, b, c) throws Ick { i=3; }";
+            Assert.AreEqual(expecting, a.render(n));
+        }
+
+        [TestMethod]
+        public void TestSingleValueWrap()
+        {
+            string templates =
+                    "m(args,body) ::= <<{ <body; anchor, wrap=\"\\n\"> }>>" + newline;
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST m = group.getInstanceOf("m");
+            m.add("body", "i=3;");
+            // make it wrap because of ") throws Ick { " literal
+            string expecting =
+                "{ " + Environment.NewLine +
+                "  i=3; }";
+            Assert.AreEqual(expecting, m.render(2));
+        }
+
+        [TestMethod]
+        public void TestLineWrapInNestedExpr()
+        {
+            string templates =
+                    "top(arrays) ::= <<Arrays: <arrays>done>>" + newline +
+                    "array(values) ::= <<int[] a = { <values; anchor, wrap=\"\\n\", separator=\",\"> };<\\n\\>>>" + newline;
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST top = group.getInstanceOf("top");
+            ST a = group.getInstanceOf("array");
+            a.add("values",
+                           new int[] {3,9,20,2,1,4,6,32,5,6,77,888,2,1,6,32,5,6,77,
+						4,9,20,2,1,4,63,9,20,2,1,4,6,32,5,6,77,6,32,5,6,77,
+					    3,9,20,2,1,4,6,32,5,6,77,888,1,6,32,5});
+            top.add("arrays", a);
+            top.add("arrays", a); // add twice
+            string expecting =
+                "Arrays: int[] a = { 3,9,20,2,1,4,6,32,5," + Environment.NewLine +
+                "                    6,77,888,2,1,6,32,5," + Environment.NewLine +
+                "                    6,77,4,9,20,2,1,4,63," + Environment.NewLine +
+                "                    9,20,2,1,4,6,32,5,6," + Environment.NewLine +
+                "                    77,6,32,5,6,77,3,9,20," + Environment.NewLine +
+                "                    2,1,4,6,32,5,6,77,888," + Environment.NewLine +
+                "                    1,6,32,5 };" + Environment.NewLine +
+                "int[] a = { 3,9,20,2,1,4,6,32,5,6,77,888," + Environment.NewLine +
+                "            2,1,6,32,5,6,77,4,9,20,2,1,4," + Environment.NewLine +
+                "            63,9,20,2,1,4,6,32,5,6,77,6," + Environment.NewLine +
+                "            32,5,6,77,3,9,20,2,1,4,6,32," + Environment.NewLine +
+                "            5,6,77,888,1,6,32,5 };" + Environment.NewLine +
+                "done";
+            Assert.AreEqual(expecting, top.render(40));
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/TestLists.cs b/Antlr4.Test.StringTemplate/TestLists.cs
new file mode 100644
index 0000000..357429e
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/TestLists.cs
@@ -0,0 +1,220 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+
+    [TestClass]
+    public class TestLists : BaseTest
+    {
+        [TestMethod]
+        public void TestJustCat()
+        {
+            ST e = new ST(
+                    "<[names,phones]>"
+                );
+            e.add("names", "Ter");
+            e.add("names", "Tom");
+            e.add("phones", "1");
+            e.add("phones", "2");
+            string expecting = "TerTom12";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestListLiteralWithEmptyElements()
+        {
+            ST e = new ST(
+                "<[\"Ter\",,\"Jesse\"]:{n | <i>:<n>}; separator=\", \", null={foo}>"
+            );
+            string expecting = "1:Ter, foo, 2:Jesse";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestListLiteralWithEmptyFirstElement()
+        {
+            ST e = new ST(
+                "<[,\"Ter\",\"Jesse\"]:{n | <i>:<n>}; separator=\", \", null={foo}>"
+            );
+            string expecting = "foo, 1:Ter, 2:Jesse";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestLength()
+        {
+            ST e = new ST(
+                    "<length([names,phones])>"
+                );
+            e.add("names", "Ter");
+            e.add("names", "Tom");
+            e.add("phones", "1");
+            e.add("phones", "2");
+            string expecting = "4";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestCat2Attributes()
+        {
+            ST e = new ST(
+                    "<[names,phones]; separator=\", \">"
+                );
+            e.add("names", "Ter");
+            e.add("names", "Tom");
+            e.add("phones", "1");
+            e.add("phones", "2");
+            string expecting = "Ter, Tom, 1, 2";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestCat2AttributesWithApply()
+        {
+            ST e = new ST(
+                    "<[names,phones]:{a|<a>.}>"
+                );
+            e.add("names", "Ter");
+            e.add("names", "Tom");
+            e.add("phones", "1");
+            e.add("phones", "2");
+            string expecting = "Ter.Tom.1.2.";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestCat3Attributes()
+        {
+            ST e = new ST(
+                    "<[names,phones,salaries]; separator=\", \">"
+                );
+            e.add("names", "Ter");
+            e.add("names", "Tom");
+            e.add("phones", "1");
+            e.add("phones", "2");
+            e.add("salaries", "big");
+            e.add("salaries", "huge");
+            string expecting = "Ter, Tom, 1, 2, big, huge";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestCatWithTemplateApplicationAsElement()
+        {
+            ST e = new ST(
+                    "<[names:{n|<n>!},phones]; separator=\", \">"
+                );
+            e.add("names", "Ter");
+            e.add("names", "Tom");
+            e.add("phones", "1");
+            e.add("phones", "2");
+            string expecting = "Ter!, Tom!, 1, 2";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestCatWithIFAsElement()
+        {
+            ST e = new ST(
+                    "<[{<if(names)>doh<endif>},phones]; separator=\", \">"
+                );
+            e.add("names", "Ter");
+            e.add("names", "Tom");
+            e.add("phones", "1");
+            e.add("phones", "2");
+            string expecting = "doh, 1, 2";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestCatNullValues()
+        {
+            // [a, b] must behave like <a><b>; if a==b==null, blank output
+            // unless null argument.
+            ST e = new ST(
+                    "<[no,go]; null=\"foo\", separator=\", \">"
+                );
+            e.add("phones", "1");
+            e.add("phones", "2");
+            string expecting = "foo, foo";  // only one since template application gives nothing
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestCatWithNullTemplateApplicationAsElement()
+        {
+            ST e = new ST(
+                    "<[names:{n|<n>!},\"foo\"]:{a|x}; separator=\", \">"
+                );
+            e.add("phones", "1");
+            e.add("phones", "2");
+            string expecting = "x";  // only one since template application gives nothing
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestCatWithNestedTemplateApplicationAsElement()
+        {
+            ST e = new ST(
+                    "<[names, [\"foo\",\"bar\"]:{x | <x>!},phones]; separator=\", \">"
+                );
+            e.add("names", "Ter");
+            e.add("names", "Tom");
+            e.add("phones", "1");
+            e.add("phones", "2");
+            string expecting = "Ter, Tom, foo!, bar!, 1, 2";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestListAsTemplateArgument()
+        {
+            string templates =
+                    "test(names,phones) ::= \"<foo([names,phones])>\"" + newline +
+                    "foo(items) ::= \"<items:{a | *<a>*}>\"" + newline
+                    ;
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            ST e = group.getInstanceOf("test");
+            e.add("names", "Ter");
+            e.add("names", "Tom");
+            e.add("phones", "1");
+            e.add("phones", "2");
+            string expecting = "*Ter**Tom**1**2*";
+            string result = e.render();
+            Assert.AreEqual(expecting, result);
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/TestModelAdaptors.cs b/Antlr4.Test.StringTemplate/TestModelAdaptors.cs
new file mode 100644
index 0000000..e1b3a7e
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/TestModelAdaptors.cs
@@ -0,0 +1,175 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using Antlr4.StringTemplate.Misc;
+
+    [TestClass]
+    public class TestModelAdaptors : BaseTest
+    {
+        private class UserAdaptor : ModelAdaptor
+        {
+            public object getProperty(ST self, object o, object property, string propertyName)
+            {
+                if (propertyName.Equals("id"))
+                    return ((User)o).id;
+                if (propertyName.Equals("name"))
+                    return ((User)o).getName();
+                throw new STNoSuchPropertyException(null, "User." + propertyName);
+            }
+        }
+
+        private class UserAdaptorConst : ModelAdaptor
+        {
+            public object getProperty(ST self, object o, object property, string propertyName)
+            {
+                if (propertyName.Equals("id"))
+                    return "const id value";
+                if (propertyName.Equals("name"))
+                    return "const name value";
+                throw new STNoSuchPropertyException(null, "User." + propertyName);
+            }
+        }
+
+        private class SuperUser : User
+        {
+            int bitmask;
+
+            public SuperUser(int id, string name)
+                : base(id, name)
+            {
+                bitmask = 0x8080;
+            }
+
+            public override string getName()
+            {
+                return "super " + base.getName();
+            }
+        }
+
+        [TestMethod]
+        public void TestSimpleAdaptor()
+        {
+            string templates =
+                    "foo(x) ::= \"<x.id>: <x.name>\"\n";
+            writeFile(tmpdir, "foo.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/foo.stg");
+            group.registerModelAdaptor(typeof(User), new UserAdaptor());
+            ST st = group.getInstanceOf("foo");
+            st.add("x", new User(100, "parrt"));
+            string expecting = "100: parrt";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestAdaptorAndBadProp()
+        {
+            ErrorBufferAllErrors errors = new ErrorBufferAllErrors();
+            string templates =
+                    "foo(x) ::= \"<x.qqq>\"\n";
+            writeFile(tmpdir, "foo.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/foo.stg");
+            group.setListener(errors);
+            group.registerModelAdaptor(typeof(User), new UserAdaptor());
+            ST st = group.getInstanceOf("foo");
+            st.add("x", new User(100, "parrt"));
+            string expecting = "";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+
+            STRuntimeMessage msg = (STRuntimeMessage)errors.Errors[0];
+            STNoSuchPropertyException e = (STNoSuchPropertyException)msg.Cause;
+            Assert.AreEqual("User.qqq", e.PropertyName);
+        }
+
+        [TestMethod]
+        public void TestAdaptorCoversSubclass()
+        {
+            string templates =
+                    "foo(x) ::= \"<x.id>: <x.name>\"\n";
+            writeFile(tmpdir, "foo.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/foo.stg");
+            group.registerModelAdaptor(typeof(User), new UserAdaptor());
+            ST st = group.getInstanceOf("foo");
+            st.add("x", new SuperUser(100, "parrt")); // create subclass of User
+            string expecting = "100: super parrt";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestWeCanResetAdaptorCacheInvalidatedUponAdaptorReset()
+        {
+            string templates =
+                    "foo(x) ::= \"<x.id>: <x.name>\"\n";
+            writeFile(tmpdir, "foo.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/foo.stg");
+            group.registerModelAdaptor(typeof(User), new UserAdaptor());
+            group.getModelAdaptor(typeof(User)); // get User, SuperUser into cache
+            group.getModelAdaptor(typeof(SuperUser));
+
+            group.registerModelAdaptor(typeof(User), new UserAdaptorConst());
+            // cache should be reset so we see new adaptor
+            ST st = group.getInstanceOf("foo");
+            st.add("x", new User(100, "parrt"));
+            string expecting = "const id value: const name value"; // sees UserAdaptorConst
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestSeesMostSpecificAdaptor()
+        {
+            string templates =
+                    "foo(x) ::= \"<x.id>: <x.name>\"\n";
+            writeFile(tmpdir, "foo.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/foo.stg");
+            group.registerModelAdaptor(typeof(User), new UserAdaptor());
+            group.registerModelAdaptor(typeof(SuperUser), new UserAdaptorConst()); // most specific
+            ST st = group.getInstanceOf("foo");
+            st.add("x", new User(100, "parrt"));
+            string expecting = "100: parrt";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+
+            st.remove("x");
+            st.add("x", new SuperUser(100, "parrt"));
+            expecting = "const id value: const name value"; // sees UserAdaptorConst
+            result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/TestNullAndEmptyValues.cs b/Antlr4.Test.StringTemplate/TestNullAndEmptyValues.cs
new file mode 100644
index 0000000..14d2ee6
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/TestNullAndEmptyValues.cs
@@ -0,0 +1,233 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using System.Collections.Generic;
+
+    [TestClass]
+    public class TestNullAndEmptyValues : BaseTest
+    {
+        [TestMethod]
+        public void TestSeparatorWithNullFirstValue()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "name", "hi <name; separator=\", \">!");
+            ST st = group.getInstanceOf("test");
+            st.add("name", null); // null is added to list, but ignored in iteration
+            st.add("name", "Tom");
+            st.add("name", "Sumana");
+            string expected = "hi Tom, Sumana!";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestTemplateAppliedToNullIsEmpty()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "name", "<name:t()>");
+            group.defineTemplate("t", "x", "<x>");
+            ST st = group.getInstanceOf("test");
+            st.add("name", null); // null is added to list, but ignored in iteration
+            string expected = "";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestTemplateAppliedToMissingValueIsEmpty()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "name", "<name:t()>");
+            group.defineTemplate("t", "x", "<x>");
+            ST st = group.getInstanceOf("test");
+            string expected = "";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSeparatorWithNull2ndValue()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "name", "hi <name; separator=\", \">!");
+            ST st = group.getInstanceOf("test");
+            st.add("name", "Ter");
+            st.add("name", null);
+            st.add("name", "Sumana");
+            string expected = "hi Ter, Sumana!";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSeparatorWithNullLastValue()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "name", "hi <name; separator=\", \">!");
+            ST st = group.getInstanceOf("test");
+            st.add("name", "Ter");
+            st.add("name", "Tom");
+            st.add("name", null);
+            string expected = "hi Ter, Tom!";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSeparatorWithTwoNullValuesInRow()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "name", "hi <name; separator=\", \">!");
+            ST st = group.getInstanceOf("test");
+            st.add("name", "Ter");
+            st.add("name", "Tom");
+            st.add("name", null);
+            st.add("name", null);
+            st.add("name", "Sri");
+            string expected = "hi Ter, Tom, Sri!";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestTwoNullValues()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "name", "hi <name; null=\"x\">!");
+            ST st = group.getInstanceOf("test");
+            st.add("name", null);
+            st.add("name", null);
+            string expected = "hi xx!";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestNullListItemNotCountedForIteratorIndex()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "name", "<name:{n | <i>:<n>}>");
+            ST st = group.getInstanceOf("test");
+            st.add("name", "Ter");
+            st.add("name", null);
+            st.add("name", null);
+            st.add("name", "Jesse");
+            string expected = "1:Ter2:Jesse";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSizeZeroButNonNullListGetsNoOutput()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "users",
+                "begin\n" +
+                "<users>\n" +
+                "end\n");
+            ST t = group.getInstanceOf("test");
+            t.add("users", null);
+            string expecting = "begin" + newline + "end";
+            string result = t.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestNullListGetsNoOutput()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "users",
+                "begin\n" +
+                "<users:{u | name: <u>}; separator=\", \">\n" +
+                "end\n");
+            ST t = group.getInstanceOf("test");
+            string expecting = "begin" + newline + "end";
+            string result = t.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestEmptyListGetsNoOutput()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "users",
+                "begin\n" +
+                "<users:{u | name: <u>}; separator=\", \">\n" +
+                "end\n");
+            ST t = group.getInstanceOf("test");
+            t.add("users", new List<string>());
+            string expecting = "begin" + newline + "end";
+            string result = t.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestMissingDictionaryValue()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "m", "<m.foo>");
+            ST t = group.getInstanceOf("test");
+            t.add("m", new Dictionary<string, string>());
+            string expecting = "";
+            string result = t.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestMissingDictionaryValue2()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "m", "<if(m.foo)>[<m.foo>]<endif>");
+            ST t = group.getInstanceOf("test");
+            t.add("m", new Dictionary<string, string>());
+            string expecting = "";
+            string result = t.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestMissingDictionaryValue3()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "m", "<if(m.foo)>[<m.foo>]<endif>");
+            ST t = group.getInstanceOf("test");
+            t.add("m", new Dictionary<string, string>() { { "foo", null } });
+            string expecting = "";
+            string result = t.render();
+            Assert.AreEqual(expecting, result);
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/TestOptions.cs b/Antlr4.Test.StringTemplate/TestOptions.cs
new file mode 100644
index 0000000..df3857c
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/TestOptions.cs
@@ -0,0 +1,215 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using Antlr4.StringTemplate.Misc;
+    using Antlr4.Test.StringTemplate.Extensions;
+
+    [TestClass]
+    public class TestOptions : BaseTest
+    {
+        [TestMethod]
+        public void TestSeparator()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "name", "hi <name; separator=\", \">!");
+            ST st = group.getInstanceOf("test");
+            st.add("name", "Ter");
+            st.add("name", "Tom");
+            st.add("name", "Sumana");
+            string expected = "hi Ter, Tom, Sumana!";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestAttrSeparator()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "name,sep", "hi <name; separator=sep>!");
+            ST st = group.getInstanceOf("test");
+            st.add("sep", ", ");
+            st.add("name", "Ter");
+            st.add("name", "Tom");
+            st.add("name", "Sumana");
+            string expected = "hi Ter, Tom, Sumana!";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestIncludeSeparator()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("foo", "|");
+            group.defineTemplate("test", "name,sep", "hi <name; separator=foo()>!");
+            ST st = group.getInstanceOf("test");
+            st.add("sep", ", ");
+            st.add("name", "Ter");
+            st.add("name", "Tom");
+            st.add("name", "Sumana");
+            string expected = "hi Ter|Tom|Sumana!";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSubtemplateSeparator()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "name,sep", "hi <name; separator={<sep> _}>!");
+            ST st = group.getInstanceOf("test");
+            st.add("sep", ",");
+            st.add("name", "Ter");
+            st.add("name", "Tom");
+            st.add("name", "Sumana");
+            string expected = "hi Ter, _Tom, _Sumana!";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSeparatorWithNullFirstValueAndNullOption()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "name", "hi <name; null=\"n/a\", separator=\", \">!");
+            ST st = group.getInstanceOf("test");
+            st.add("name", null);
+            st.add("name", "Tom");
+            st.add("name", "Sumana");
+            string expected = "hi n/a, Tom, Sumana!";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSeparatorWithNull2ndValueAndNullOption()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "name", "hi <name; null=\"n/a\", separator=\", \">!");
+            ST st = group.getInstanceOf("test");
+            st.impl.dump();
+            st.add("name", "Ter");
+            st.add("name", null);
+            st.add("name", "Sumana");
+            string expected = "hi Ter, n/a, Sumana!";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestNullValueAndNullOption()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "name", "<name; null=\"n/a\">");
+            ST st = group.getInstanceOf("test");
+            st.add("name", null);
+            string expected = "n/a";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestListApplyWithNullValueAndNullOption()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "name", "<name:{n | <n>}; null=\"n/a\">");
+            ST st = group.getInstanceOf("test");
+            st.add("name", "Ter");
+            st.add("name", null);
+            st.add("name", "Sumana");
+            string expected = "Tern/aSumana";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestDoubleListApplyWithNullValueAndNullOption()
+        {
+            // first apply sends [ST, null, ST] to second apply, which puts [] around
+            // the value.  This verifies that null not blank comes out of first apply
+            // since we don't get [null].
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "name", "<name:{n | <n>}:{n | [<n>]}; null=\"n/a\">");
+            ST st = group.getInstanceOf("test");
+            st.add("name", "Ter");
+            st.add("name", null);
+            st.add("name", "Sumana");
+            string expected = "[Ter]n/a[Sumana]";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestMissingValueAndNullOption()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "name", "<name; null=\"n/a\">");
+            ST st = group.getInstanceOf("test");
+            string expected = "n/a";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestOptionDoesntApplyToNestedTemplate()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("foo", "<zippo>");
+            group.defineTemplate("test", "zippo", "<foo(); null=\"n/a\">");
+            ST st = group.getInstanceOf("test");
+            st.add("zippo", null);
+            string expected = "";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestIllegalOption()
+        {
+            ErrorBuffer errors = new ErrorBuffer();
+            STGroup group = new STGroup();
+            group.setListener(errors);
+            group.defineTemplate("test", "name", "<name; bad=\"ugly\">");
+            ST st = group.getInstanceOf("test");
+            st.add("name", "Ter");
+            string expected = "Ter";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+            expected = "[test 1:7: no such option: bad]";
+            Assert.AreEqual(expected, errors.Errors.ToListString());
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/TestRegions.cs b/Antlr4.Test.StringTemplate/TestRegions.cs
new file mode 100644
index 0000000..1fa984b
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/TestRegions.cs
@@ -0,0 +1,291 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using Antlr4.StringTemplate.Misc;
+
+    [TestClass]
+    public class TestRegions : BaseTest
+    {
+        [TestMethod]
+        public void TestEmbeddedRegion()
+        {
+            string dir = tmpdir;
+            string groupFile =
+                "a() ::= <<\n" +
+                "[<@r>bar<@end>]\n" +
+                ">>\n";
+            writeFile(dir, "group.stg", groupFile);
+            STGroup group = new STGroupFile(dir + "/group.stg");
+            ST st = group.getInstanceOf("a");
+            string expected = "[bar]";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestRegion()
+        {
+            string dir = tmpdir;
+            string groupFile =
+                "a() ::= <<\n" +
+                "[<@r()>]\n" +
+                ">>\n";
+            writeFile(dir, "group.stg", groupFile);
+            STGroup group = new STGroupFile(dir + "/group.stg");
+            ST st = group.getInstanceOf("a");
+            string expected = "[]";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestDefineRegionInSubgroup()
+        {
+            string dir = tmpdir;
+            string g1 = "a() ::= <<[<@r()>]>>\n";
+            writeFile(dir, "g1.stg", g1);
+            string g2 = "@a.r() ::= <<foo>>\n";
+            writeFile(dir, "g2.stg", g2);
+
+            STGroup group1 = new STGroupFile(dir + "/g1.stg");
+            STGroup group2 = new STGroupFile(dir + "/g2.stg");
+            group2.importTemplates(group1); // define r in g2
+            ST st = group2.getInstanceOf("a");
+            string expected = "[foo]";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestDefineRegionInSubgroupThatRefsSuper()
+        {
+            string dir = tmpdir;
+            string g1 = "a() ::= <<[<@r>foo<@end>]>>\n";
+            writeFile(dir, "g1.stg", g1);
+            string g2 = "@a.r() ::= <<(<@super.r()>)>>\n";
+            writeFile(dir, "g2.stg", g2);
+
+            STGroup group1 = new STGroupFile(dir + "/g1.stg");
+            STGroup group2 = new STGroupFile(dir + "/g2.stg");
+            group2.importTemplates(group1); // define r in g2
+            ST st = group2.getInstanceOf("a");
+            string expected = "[(foo)]";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestDefineRegionInSubgroup2()
+        {
+            string dir = tmpdir;
+            string g1 = "a() ::= <<[<@r()>]>>\n";
+            writeFile(dir, "g1.stg", g1);
+            string g2 = "@a.r() ::= <<foo>>>\n";
+            writeFile(dir, "g2.stg", g2);
+
+            STGroup group1 = new STGroupFile(dir + "/g1.stg");
+            STGroup group2 = new STGroupFile(dir + "/g2.stg");
+            group1.importTemplates(group2); // opposite of previous; g1 imports g2
+            ST st = group1.getInstanceOf("a");
+            string expected = "[]"; // @a.r implicitly defined in g1; can't see g2's
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestDefineRegionInSameGroup()
+        {
+            string dir = tmpdir;
+            string g = "a() ::= <<[<@r()>]>>\n" +
+                       "@a.r() ::= <<foo>>\n";
+            writeFile(dir, "g.stg", g);
+
+            STGroup group = new STGroupFile(dir + "/g.stg");
+            ST st = group.getInstanceOf("a");
+            string expected = "[foo]";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestCantDefineEmbeddedRegionAgain()
+        {
+            string dir = tmpdir;
+            string g = "a() ::= <<[<@r>foo<@end>]>>\n" +
+                       "@a.r() ::= <<bar>>\n"; // error; dup
+            writeFile(dir, "g.stg", g);
+
+            STGroupFile group = new STGroupFile(dir + "/g.stg");
+            ErrorBuffer errors = new ErrorBuffer();
+            group.setListener(errors);
+            group.load();
+            string expected = "g.stg 2:3: region a.r is embedded and thus already implicitly defined" + newline;
+            string result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        //
+
+        [TestMethod]
+        public void TestRegionOverrideRefSuperRegion()
+        {
+            string dir = tmpdir;
+            string g =
+                    "a() ::= \"X<@r()>Y\"" +
+                    "@a.r() ::= \"foo\"" + newline;
+            writeFile(dir, "g.stg", g);
+            STGroupFile group = new STGroupFile(dir + "/g.stg");
+
+            string sub =
+                    "@a.r() ::= \"A<@super.r()>B\"" + newline;
+            writeFile(dir, "sub.stg", sub);
+            STGroupFile subGroup = new STGroupFile(dir + "/sub.stg");
+            subGroup.importTemplates(group);
+
+            ST st = subGroup.getInstanceOf("a");
+            string result = st.render();
+            string expecting = "XAfooBY";
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestRegionOverrideRefSuperRegion3Levels()
+        {
+            string dir = tmpdir;
+            // Bug: This was causing infinite recursion:
+            // getInstanceOf(super::a)
+            // getInstanceOf(sub::a)
+            // getInstanceOf(subsub::a)
+            // getInstanceOf(subsub::region__a__r)
+            // getInstanceOf(subsub::super.region__a__r)
+            // getInstanceOf(subsub::super.region__a__r)
+            // getInstanceOf(subsub::super.region__a__r)
+            // ...
+            // Somehow, the ref to super in subsub is not moving up the chain
+            // to the @super.r(); oh, i introduced a bug when i put setGroup
+            // into STG.getInstanceOf()!
+
+            string g =
+                    "a() ::= \"X<@r()>Y\"" +
+                    "@a.r() ::= \"foo\"" + newline;
+            writeFile(dir, "g.stg", g);
+            STGroupFile group = new STGroupFile(dir + "/g.stg");
+
+            string sub =
+                    "@a.r() ::= \"<@super.r()>2\"" + newline;
+            writeFile(dir, "sub.stg", sub);
+            STGroupFile subGroup = new STGroupFile(dir + "/sub.stg");
+            subGroup.importTemplates(group);
+
+            string subsub =
+                    "@a.r() ::= \"<@super.r()>3\"" + newline;
+            writeFile(dir, "subsub.stg", subsub);
+            STGroupFile subSubGroup = new STGroupFile(dir + "/subsub.stg");
+            subSubGroup.importTemplates(subGroup);
+
+            ST st = subSubGroup.getInstanceOf("a");
+
+            string result = st.render();
+            string expecting = "Xfoo23Y";
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestRegionOverrideRefSuperImplicitRegion()
+        {
+            string dir = tmpdir;
+            string g =
+                    "a() ::= \"X<@r>foo<@end>Y\"" + newline;
+            writeFile(dir, "g.stg", g);
+            STGroupFile group = new STGroupFile(dir + "/g.stg");
+
+            string sub =
+                    "@a.r() ::= \"A<@super.r()>\"" + newline;
+            writeFile(dir, "sub.stg", sub);
+            STGroupFile subGroup = new STGroupFile(dir + "/sub.stg");
+            subGroup.importTemplates(group);
+
+            ST st = subGroup.getInstanceOf("a");
+            string result = st.render();
+            string expecting = "XAfooY";
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestUnknownRegionDefError()
+        {
+            string dir = tmpdir;
+            string g =
+                    "a() ::= <<\n" +
+                    "X<@r()>Y" +
+                    ">>\n" +
+                    "@a.q() ::= \"foo\"" + newline;
+            STErrorListener errors = new ErrorBuffer();
+            writeFile(dir, "g.stg", g);
+            STGroupFile group = new STGroupFile(dir + "/g.stg");
+            group.setListener(errors);
+            ST st = group.getInstanceOf("a");
+            st.render();
+            string result = errors.ToString();
+            string expecting = "g.stg 3:3: template a doesn't have a region called q" + newline;
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestSuperRegionRefMissingOk()
+        {
+            string dir = tmpdir;
+            string g =
+                "a() ::= \"X<@r()>Y\"" +
+                "@a.r() ::= \"foo\"" + newline;
+            writeFile(dir, "g.stg", g);
+            STGroupFile group = new STGroupFile(dir + "/g.stg");
+
+            string sub =
+                "@a.r() ::= \"A<@super.q()>B\"" + newline; // allow this; trap at runtime
+            STErrorListener errors = new ErrorBuffer();
+            group.setListener(errors);
+            writeFile(dir, "sub.stg", sub);
+            STGroupFile subGroup = new STGroupFile(dir + "/sub.stg");
+            subGroup.importTemplates(group);
+
+            ST st = subGroup.getInstanceOf("a");
+            string result = st.render();
+            string expecting = "XABY";
+            Assert.AreEqual(expecting, result);
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/TestRenderers.cs b/Antlr4.Test.StringTemplate/TestRenderers.cs
new file mode 100644
index 0000000..de81911
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/TestRenderers.cs
@@ -0,0 +1,264 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using CultureInfo = System.Globalization.CultureInfo;
+    using System.Collections.Generic;
+
+    [TestClass]
+    public class TestRenderers : BaseTest
+    {
+#if false // date renderer
+        [TestMethod]
+        public void TestRendererForGroup()
+        {
+            string templates =
+                    "dateThing(created) ::= \"datetime: <created>\"\n";
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/t.stg");
+            group.registerRenderer(typeof(GregorianCalendar), new DateRenderer());
+            ST st = group.getInstanceOf("dateThing");
+            st.add("created", new GregorianCalendar(2005, 07 - 1, 05));
+            string expecting = "datetime: 7/5/05 12:00 AM";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestRendererWithFormat()
+        {
+            string templates =
+                    "dateThing(created) ::= << date: <created; format=\"yyyy.MM.dd\"> >>\n";
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/t.stg");
+            group.registerRenderer(typeof(GregorianCalendar), new DateRenderer());
+            ST st = group.getInstanceOf("dateThing");
+            st.add("created", new GregorianCalendar(2005, 07 - 1, 05));
+            string expecting = " date: 2005.07.05 ";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestRendererWithPredefinedFormat()
+        {
+            string templates =
+                    "dateThing(created) ::= << datetime: <created; format=\"short\"> >>\n";
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/t.stg");
+            group.registerRenderer(typeof(GregorianCalendar), new DateRenderer());
+            ST st = group.getInstanceOf("dateThing");
+            st.add("created", new GregorianCalendar(2005, 07 - 1, 05));
+            string expecting = " datetime: 7/5/05 12:00 AM ";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestRendererWithPredefinedFormat2()
+        {
+            string templates =
+                    "dateThing(created) ::= << datetime: <created; format=\"full\"> >>\n";
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/t.stg");
+            group.registerRenderer(typeof(GregorianCalendar), new DateRenderer());
+            ST st = group.getInstanceOf("dateThing");
+            st.add("created", new GregorianCalendar(2005, 07 - 1, 05));
+            string expecting = " datetime: Tuesday, July 5, 2005 12:00:00 AM PDT ";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestRendererWithPredefinedFormat3()
+        {
+            string templates =
+                    "dateThing(created) ::= << date: <created; format=\"date:medium\"> >>\n";
+
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/t.stg");
+            group.registerRenderer(typeof(GregorianCalendar), new DateRenderer());
+            ST st = group.getInstanceOf("dateThing");
+            st.add("created", new GregorianCalendar(2005, 07 - 1, 05));
+            string expecting = " date: Jul 5, 2005 ";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestRendererWithPredefinedFormat4()
+        {
+            string templates =
+                    "dateThing(created) ::= << time: <created; format=\"time:medium\"> >>\n";
+
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/t.stg");
+            group.registerRenderer(typeof(GregorianCalendar), new DateRenderer());
+            ST st = group.getInstanceOf("dateThing");
+            st.add("created", new GregorianCalendar(2005, 07 - 1, 05));
+            string expecting = " time: 12:00:00 AM ";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+#endif
+
+#if false
+        [TestMethod]
+        public void TestStringRendererWithPrintfFormat()
+        {
+            string templates =
+                    "foo(x) ::= << <x; format=\"%6s\"> >>\n";
+
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/t.stg");
+            group.registerRenderer(typeof(string), new StringRenderer());
+            ST st = group.getInstanceOf("foo");
+            st.add("x", "hi");
+            string expecting = "     hi ";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestRendererWithFormatAndList()
+        {
+            string template =
+                    "The names: <names; format=\"upper\">";
+            STGroup group = new STGroup();
+            group.registerRenderer(typeof(string), new StringRenderer());
+            ST st = new ST(template);
+            st.groupThatCreatedThisInstance = group;
+            st.add("names", "ter");
+            st.add("names", "tom");
+            st.add("names", "sriram");
+            string expecting = "The names: TERTOMSRIRAM";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestRendererWithFormatAndSeparator()
+        {
+            string template =
+                    "The names: <names; separator=\" and \", format=\"upper\">";
+            STGroup group = new STGroup();
+            group.registerRenderer(typeof(string), new StringRenderer());
+            ST st = new ST(template);
+            st.groupThatCreatedThisInstance = group;
+            st.add("names", "ter");
+            st.add("names", "tom");
+            st.add("names", "sriram");
+            string expecting = "The names: TER and TOM and SRIRAM";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestRendererWithFormatAndSeparatorAndNull()
+        {
+            string template =
+                    "The names: <names; separator=\" and \", null=\"n/a\", format=\"upper\">";
+            STGroup group = new STGroup();
+            group.registerRenderer(typeof(string), new StringRenderer());
+            ST st = new ST(template);
+            st.groupThatCreatedThisInstance = group;
+            List<string> names = new List<string>();
+            names.Add("ter");
+            names.Add(null);
+            names.Add("sriram");
+            st.add("names", names);
+            string expecting = "The names: TER and N/A and SRIRAM";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+#endif
+
+#if false // number renderer
+        [TestMethod]
+        public void TestNumberRendererWithPrintfFormat()
+        {
+            string templates =
+                    "foo(x,y) ::= << <x; format=\"%d\"> <y; format=\"%2.3f\"> >>\n";
+
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/t.stg");
+            group.registerRenderer(typeof(int), new NumberRenderer());
+            group.registerRenderer(typeof(double), new NumberRenderer());
+            ST st = group.getInstanceOf("foo");
+            st.add("x", -2100);
+            st.add("y", 3.14159);
+            string expecting = " -2100 3.142 ";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestInstanceofRenderer()
+        {
+            string templates =
+                    "numberThing(x,y,z) ::= \"numbers: <x>, <y>; <z>\"\n";
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/t.stg");
+            group.registerRenderer(typeof(Number), new NumberRenderer());
+            ST st = group.getInstanceOf("numberThing");
+            st.add("x", -2100);
+            st.add("y", 3.14159);
+            st.add("z", "hi");
+            string expecting = "numbers: -2100, 3.14159; hi";
+            string result = st.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestLocaleWithNumberRenderer()
+        {
+            string templates =
+                    "foo(x,y) ::= << <x; format=\"%,d\"> <y; format=\"%,2.3f\"> >>\n";
+
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/t.stg");
+            group.registerRenderer(typeof(int), new NumberRenderer());
+            group.registerRenderer(typeof(double), new NumberRenderer());
+            ST st = group.getInstanceOf("foo");
+            st.add("x", -2100);
+            st.add("y", 3.14159);
+            // Polish uses ' ' for ',' and ',' for '.'
+            string expecting = " -2?00 3,142 ";
+            string result = st.render(new CultureInfo("pl"));
+            Assert.AreEqual(expecting, result);
+        }
+#endif
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/TestScopes.cs b/Antlr4.Test.StringTemplate/TestScopes.cs
new file mode 100644
index 0000000..a56c7d0
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/TestScopes.cs
@@ -0,0 +1,143 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using Antlr4.StringTemplate.Misc;
+
+    [TestClass]
+    public class TestScopes : BaseTest
+    {
+        [TestMethod]
+        public void TestSeesEnclosingAttr()
+        {
+            string templates =
+                "t(x,y) ::= \"<u()>\"\n" +
+                "u() ::= \"<x><y>\"";
+            ErrorBuffer errors = new ErrorBuffer();
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            ST st = group.getInstanceOf("t");
+            st.add("x", "x");
+            st.add("y", "y");
+            string result = st.render();
+
+            string expectedError = "";
+            Assert.AreEqual(expectedError, errors.ToString());
+
+            string expected = "xy";
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestMissingArg()
+        {
+            string templates =
+                "t() ::= \"<u()>\"\n" +
+                "u(z) ::= \"\"";
+            ErrorBuffer errors = new ErrorBuffer();
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            ST st = group.getInstanceOf("t");
+            string result = st.render();
+
+            string expectedError = "context [t] 1:1 passed 0 arg(s) to template u with 1 declared arg(s)" + newline;
+            Assert.AreEqual(expectedError, errors.ToString());
+        }
+
+        [TestMethod]
+        public void TestUnknownAttr()
+        {
+            string templates =
+                "t() ::= \"<x>\"\n";
+            ErrorBuffer errors = new ErrorBuffer();
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            ST st = group.getInstanceOf("t");
+            string result = st.render();
+
+            string expectedError = "context [t] 1:1 attribute x isn't defined" + newline;
+            Assert.AreEqual(expectedError, errors.ToString());
+        }
+
+        [TestMethod]
+        public void TestArgWithSameNameAsEnclosing()
+        {
+            string templates =
+                "t(x,y) ::= \"<u(x)>\"\n" +
+                "u(y) ::= \"<x><y>\"";
+            ErrorBuffer errors = new ErrorBuffer();
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            ST st = group.getInstanceOf("t");
+            st.add("x", "x");
+            st.add("y", "y");
+            string result = st.render();
+
+            string expectedError = "";
+            Assert.AreEqual(expectedError, errors.ToString());
+
+            string expected = "xx";
+            Assert.AreEqual(expected, result);
+            group.setListener(ErrorManager.DEFAULT_ERROR_LISTENER);
+        }
+
+        [TestMethod]
+        public void TestIndexAttrVisibleLocallyOnly()
+        {
+            string templates =
+                "t(names) ::= \"<names:{n | <u(n)>}>\"\n" +
+                "u(x) ::= \"<i>:<x>\"";
+            ErrorBuffer errors = new ErrorBuffer();
+            writeFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            ST st = group.getInstanceOf("t");
+            st.add("names", "Ter");
+            string result = st.render();
+            group.getInstanceOf("u").impl.dump();
+
+            string expectedError = "t.stg 2:11: attribute i isn't defined" + newline;
+            Assert.AreEqual(expectedError, errors.ToString());
+
+            string expected = ":Ter";
+            Assert.AreEqual(expected, result);
+            group.setListener(ErrorManager.DEFAULT_ERROR_LISTENER);
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/TestSubtemplates.cs b/Antlr4.Test.StringTemplate/TestSubtemplates.cs
new file mode 100644
index 0000000..017d677
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/TestSubtemplates.cs
@@ -0,0 +1,276 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using System.Collections.Generic;
+    using Antlr4.StringTemplate.Misc;
+
+    [TestClass]
+    public class TestSubtemplates : BaseTest
+    {
+        [TestMethod]
+        public void TestSimpleIteration()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "names", "<names:{n|<n>}>!");
+            ST st = group.getInstanceOf("test");
+            st.add("names", "Ter");
+            st.add("names", "Tom");
+            st.add("names", "Sumana");
+            string expected = "TerTomSumana!";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestMapIterationIsByKeys()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "emails", "<emails:{n|<n>}>!");
+            ST st = group.getInstanceOf("test");
+            IDictionary<string, string> emails = new Dictionary<string, string>();
+            emails["parrt"] = "Ter";
+            emails["tombu"] = "Tom";
+            emails["dmose"] = "Dan";
+            st.add("emails", emails);
+            string expected = "parrttombudmose!";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSimpleIterationWithArg()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "names", "<names:{n | <n>}>!");
+            ST st = group.getInstanceOf("test");
+            st.add("names", "Ter");
+            st.add("names", "Tom");
+            st.add("names", "Sumana");
+            string expected = "TerTomSumana!";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestNestedIterationWithArg()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "users", "<users:{u | <u.id:{id | <id>=}><u.name>}>!");
+            ST st = group.getInstanceOf("test");
+            st.add("users", new TestCoreBasics.User(1, "parrt"));
+            st.add("users", new TestCoreBasics.User(2, "tombu"));
+            st.add("users", new TestCoreBasics.User(3, "sri"));
+            string expected = "1=parrt2=tombu3=sri!";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestParallelAttributeIteration()
+        {
+            ST e = new ST(
+                    "<names,phones,salaries:{n,p,s | <n>@<p>: <s>\n}>"
+                );
+            e.add("names", "Ter");
+            e.add("names", "Tom");
+            e.add("phones", "1");
+            e.add("phones", "2");
+            e.add("salaries", "big");
+            e.add("salaries", "huge");
+            string expecting = "Ter@1: big" + newline + "Tom@2: huge" + newline;
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestParallelAttributeIterationWithNullValue()
+        {
+            ST e = new ST(
+                    "<names,phones,salaries:{n,p,s | <n>@<p>: <s>\n}>"
+                );
+            e.add("names", "Ter");
+            e.add("names", "Tom");
+            e.add("names", "Sriram");
+            e.add("phones", new List<string>() { "1", null, "3" });
+            e.add("salaries", "big");
+            e.add("salaries", "huge");
+            e.add("salaries", "enormous");
+            string expecting = "Ter@1: big" + newline +
+                               "Tom@: huge" + newline +
+                               "Sriram@3: enormous" + newline;
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestParallelAttributeIterationHasI()
+        {
+            ST e = new ST(
+                    "<names,phones,salaries:{n,p,s | <i0>. <n>@<p>: <s>\n}>"
+                );
+            e.add("names", "Ter");
+            e.add("names", "Tom");
+            e.add("phones", "1");
+            e.add("phones", "2");
+            e.add("salaries", "big");
+            e.add("salaries", "huge");
+            string expecting =
+                "0. Ter@1: big" + newline +
+                "1. Tom@2: huge" + newline;
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestParallelAttributeIterationWithDifferentSizes()
+        {
+            ST e = new ST(
+                    "<names,phones,salaries:{n,p,s | <n>@<p>: <s>}; separator=\", \">"
+                );
+            e.add("names", "Ter");
+            e.add("names", "Tom");
+            e.add("names", "Sriram");
+            e.add("phones", "1");
+            e.add("phones", "2");
+            e.add("salaries", "big");
+            string expecting = "Ter@1: big, Tom@2: , Sriram@: ";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestParallelAttributeIterationWithSingletons()
+        {
+            ST e = new ST(
+                    "<names,phones,salaries:{n,p,s | <n>@<p>: <s>}; separator=\", \">"
+                );
+            e.add("names", "Ter");
+            e.add("phones", "1");
+            e.add("salaries", "big");
+            string expecting = "Ter@1: big";
+            Assert.AreEqual(expecting, e.render());
+        }
+
+        [TestMethod]
+        public void TestParallelAttributeIterationWithDifferentSizesTemplateRefInsideToo()
+        {
+            string templates =
+                    "page(names,phones,salaries) ::= " + newline +
+                    "	<< <names,phones,salaries:{n,p,s | <value(n)>@<value(p)>: <value(s)>}; separator=\", \"> >>" + newline +
+                    "value(x) ::= \"<if(!x)>n/a<else><x><endif>\"" + newline;
+            writeFile(tmpdir, "g.stg", templates);
+
+            STGroup group = new STGroupFile(tmpdir + "/g.stg");
+            ST p = group.getInstanceOf("page");
+            p.add("names", "Ter");
+            p.add("names", "Tom");
+            p.add("names", "Sriram");
+            p.add("phones", "1");
+            p.add("phones", "2");
+            p.add("salaries", "big");
+            string expecting = " Ter@1: big, Tom@2: n/a, Sriram@n/a: n/a ";
+            Assert.AreEqual(expecting, p.render());
+        }
+
+        [TestMethod]
+        public void TestEvalSTIteratingSubtemplateInSTFromAnotherGroup()
+        {
+            ErrorBuffer errors = new ErrorBuffer();
+            STGroup innerGroup = new STGroup();
+            innerGroup.setListener(errors);
+            innerGroup.defineTemplate("test", "m", "<m:samegroup()>");
+            innerGroup.defineTemplate("samegroup", "x", "hi ");
+            ST st = innerGroup.getInstanceOf("test");
+            st.add("m", new int[] { 1, 2, 3 });
+
+            STGroup outerGroup = new STGroup();
+            outerGroup.defineTemplate("errorMessage", "x", "<x>");
+            ST outerST = outerGroup.getInstanceOf("errorMessage");
+            outerST.add("x", st);
+
+            string expected = "hi hi hi ";
+            string result = outerST.render();
+
+            Assert.AreEqual(errors.Errors.Count, 0); // ignores no such prop errors
+
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestEvalSTIteratingSubtemplateInSTFromAnotherGroupSingleValue()
+        {
+            ErrorBuffer errors = new ErrorBuffer();
+            STGroup innerGroup = new STGroup();
+            innerGroup.setListener(errors);
+            innerGroup.defineTemplate("test", "m", "<m:samegroup()>");
+            innerGroup.defineTemplate("samegroup", "x", "hi ");
+            ST st = innerGroup.getInstanceOf("test");
+            st.add("m", 10);
+
+            STGroup outerGroup = new STGroup();
+            outerGroup.defineTemplate("errorMessage", "x", "<x>");
+            ST outerST = outerGroup.getInstanceOf("errorMessage");
+            outerST.add("x", st);
+
+            string expected = "hi ";
+            string result = outerST.render();
+
+            Assert.AreEqual(errors.Errors.Count, 0); // ignores no such prop errors
+
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestEvalSTFromAnotherGroup()
+        {
+            ErrorBuffer errors = new ErrorBuffer();
+            STGroup innerGroup = new STGroup();
+            innerGroup.setListener(errors);
+            innerGroup.defineTemplate("bob", "inner");
+            ST st = innerGroup.getInstanceOf("bob");
+
+            STGroup outerGroup = new STGroup();
+            outerGroup.setListener(errors);
+            outerGroup.defineTemplate("errorMessage", "x", "<x>");
+            outerGroup.defineTemplate("bob", "outer"); // should not be visible to test() in innerGroup
+            ST outerST = outerGroup.getInstanceOf("errorMessage");
+            outerST.add("x", st);
+
+            string expected = "inner";
+            string result = outerST.render();
+
+            Assert.AreEqual(errors.Errors.Count, 0); // ignores no such prop errors
+
+            Assert.AreEqual(expected, result);
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/TestSyntaxErrors.cs b/Antlr4.Test.StringTemplate/TestSyntaxErrors.cs
new file mode 100644
index 0000000..bf86e50
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/TestSyntaxErrors.cs
@@ -0,0 +1,200 @@
+/*
+ [The "BSD license"]
+ Copyright (c) 2009 Terence Parr
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+    notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+    derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Antlr4.Test.StringTemplate.Extensions;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using Antlr4.StringTemplate.Misc;
+    using Antlr4.StringTemplate.Compiler;
+
+    [TestClass]
+    public class TestSyntaxErrors : BaseTest
+    {
+        [TestMethod]
+        public void TestEmptyExpr()
+        {
+            string template = " <> ";
+            STGroup group = new STGroup();
+            ErrorBuffer errors = new ErrorBuffer();
+            group.setListener(errors);
+            try
+            {
+                group.defineTemplate("test", template);
+            }
+            catch (STException se)
+            {
+                ;
+            }
+            string result = errors.ToString();
+            string expected = "test 1:0: this doesn't look like a template: \" <> \"" + newline;
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestEmptyExpr2()
+        {
+            string template = "hi <> ";
+            STGroup group = new STGroup();
+            ErrorBuffer errors = new ErrorBuffer();
+            group.setListener(errors);
+            try
+            {
+                group.defineTemplate("test", template);
+            }
+            catch (STException se)
+            {
+                ;
+            }
+            string result = errors.ToString();
+            string expected = "test 1:3: doesn't look like an expression" + newline;
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestWeirdChar()
+        {
+            string template = "   <*>";
+            STGroup group = new STGroup();
+            ErrorBuffer errors = new ErrorBuffer();
+            group.setListener(errors);
+            try
+            {
+                group.defineTemplate("test", template);
+            }
+            catch (STException)
+            {
+            }
+            string result = errors.ToString();
+            string expected = "test 1:4: invalid character '*'" + newline +
+                              "test 1:0: this doesn't look like a template: \"   <*>\"" + newline;
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestValidButOutOfPlaceChar()
+        {
+            string templates =
+                "foo() ::= <<hi <.> mom>>\n";
+            writeFile(tmpdir, "t.stg", templates);
+
+            STErrorListener errors = new ErrorBuffer();
+            STGroupFile group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            group.load(); // force load
+            string expected = "t.stg 1:15: doesn't look like an expression" + newline;
+            string result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestValidButOutOfPlaceCharOnDifferentLine()
+        {
+            string templates =
+                    "foo() ::= \"hi <\n" +
+                    ".> mom\"\n";
+            writeFile(tmpdir, "t.stg", templates);
+
+            ErrorBuffer errors = new ErrorBuffer();
+            STGroupFile group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            group.load(); // force load
+            string expected = "[t.stg 1:15: \\n in string, t.stg 1:14: doesn't look like an expression]";
+            string result = errors.Errors.ToListString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestErrorInNestedTemplate()
+        {
+            string templates =
+                "foo() ::= \"hi <name:{[<aaa.bb!>]}> mom\"\n";
+            writeFile(tmpdir, "t.stg", templates);
+
+            STGroupFile group = null;
+            STErrorListener errors = new ErrorBuffer();
+            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            group.load(); // force load
+            string expected = "t.stg 1:29: '!' came as a complete surprise to me" + newline;
+            string result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestEOFInExpr()
+        {
+            string templates =
+                "foo() ::= \"hi <name:{x|[<aaa.bb>]}\"\n";
+            writeFile(tmpdir, "t.stg", templates);
+
+            STGroupFile group = null;
+            STErrorListener errors = new ErrorBuffer();
+            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            group.load(); // force load
+            string expected = "t.stg 1:34: premature EOF" + newline;
+            string result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestMissingRPAREN()
+        {
+            string templates =
+                "foo() ::= \"hi <foo(>\"\n";
+            writeFile(tmpdir, "t.stg", templates);
+
+            STGroupFile group = null;
+            STErrorListener errors = new ErrorBuffer();
+            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            group.load(); // force load
+            string expected = "t.stg 1:19: '>' came as a complete surprise to me" + newline;
+            string result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestRotPar()
+        {
+            string templates =
+                "foo() ::= \"<a,b:t(),u()>\"\n";
+            writeFile(tmpdir, "t.stg", templates);
+
+            STGroupFile group = null;
+            STErrorListener errors = new ErrorBuffer();
+            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group.setListener(errors);
+            group.load(); // force load
+            string expected = "t.stg 1:19: mismatched input ',' expecting RDELIM" + newline;
+            string result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/TestTokensForDollarDelimiters.cs b/Antlr4.Test.StringTemplate/TestTokensForDollarDelimiters.cs
new file mode 100644
index 0000000..071e51f
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/TestTokensForDollarDelimiters.cs
@@ -0,0 +1,85 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+
+    [TestClass]
+    public class TestTokensForDollarDelimiters : BaseTest
+    {
+        [TestMethod]
+        public void TestSimpleAttr()
+        {
+            string template = "hi $name$";
+            string expected = "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='$',<LDELIM>,1:3], [@2,4:7='name',<ID>,1:4], [@3,8:8='$',<RDELIM>,1:8]]";
+            checkTokens(template, expected, '$', '$');
+        }
+
+        [TestMethod]
+        public void TestString()
+        {
+            string template = "hi $foo(a=\"$\")$";
+            string expected = "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='$',<LDELIM>,1:3], [@2,4:6='foo',<ID>,1:4], [@3,7:7='(',<LPAREN>,1:7], [@4,8:8='a',<ID>,1:8], [@5,9:9='=',<EQUALS>,1:9], [@6,10:12='\"$\"',<STRING>,1:10], [@7,13:13=')',<RPAREN>,1:13], [@8,14:14='$',<RDELIM>,1:14]]";
+            checkTokens(template, expected, '$', '$');
+        }
+
+        [TestMethod]
+        public void TestEscInString()
+        {
+            string template = "hi $foo(a=\"$\\\"\")$"; // "hi $foo(a="$\"")$"
+            string expected = "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='$',<LDELIM>,1:3], [@2,4:6='foo',<ID>,1:4], [@3,7:7='(',<LPAREN>,1:7], [@4,8:8='a',<ID>,1:8], [@5,9:9='=',<EQUALS>,1:9], [@6,10:14='\"$\"\"',<STRING>,1:10], [@7,15:15=')',<RPAREN>,1:15], [@8,16:16='$',<RDELIM>,1:16]]";
+            checkTokens(template, expected, '$', '$');
+        }
+
+        [TestMethod]
+        public void TestSubtemplate()
+        {
+            string template = "hi $names:{n | $n$}$";
+            string expected =
+                "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='$',<LDELIM>,1:3], [@2,4:8='names',<ID>,1:4], " +
+                "[@3,9:9=':',<COLON>,1:9], [@4,10:10='{',<LCURLY>,1:10], [@5,11:11='n',<ID>,1:11], " +
+                "[@6,13:13='|',<PIPE>,1:13], [@7,15:15='$',<LDELIM>,1:15], [@8,16:16='n',<ID>,1:16], " +
+                "[@9,17:17='$',<RDELIM>,1:17], [@10,18:18='}',<RCURLY>,1:18], [@11,19:19='$',<RDELIM>,1:19]]";
+            checkTokens(template, expected, '$', '$');
+        }
+
+        [TestMethod]
+        public void TestNestedSubtemplate()
+        {
+            string template = "hi $names:{n | $n:{$it$}$}$";
+            string expected = "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='$',<LDELIM>,1:3], [@2,4:8='names',<ID>,1:4], [@3,9:9=':',<COLON>,1:9], [@4,10:10='{',<LCURLY>,1:10], [@5,11:11='n',<ID>,1:11], [@6,13:13='|',<PIPE>,1:13], [@7,15:15='$',<LDELIM>,1:15], [@8,16:16='n',<ID>,1:16], [@9,17:17=':',<COLON>,1:17], [@10,18:18='{',<LCURLY>,1:18], [@11,19:19='$',<LDELIM>,1:19], [@12,20:21='it',<ID>,1:20], [@13,22:22='$',<RDELIM>,1:22], [@14,23:23='}',<RCURLY>,1:23], [@15,24:24='$',<RDELIM>,1:24], [@16,25:25='}',<RCURLY>,1:25], [@17,26:26='$',<RDELIM>,1:26]]";
+            checkTokens(template, expected, '$', '$');
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/TestWhitespace.cs b/Antlr4.Test.StringTemplate/TestWhitespace.cs
new file mode 100644
index 0000000..f5e145d
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/TestWhitespace.cs
@@ -0,0 +1,378 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using StringWriter = System.IO.StringWriter;
+    using Environment = System.Environment;
+
+    [TestClass]
+    public class TestWhitespace : BaseTest
+    {
+        [TestMethod]
+        public void TestTrimmedSubtemplates()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "names", "<names:{n | <n>}>!");
+            ST st = group.getInstanceOf("test");
+            st.add("names", "Ter");
+            st.add("names", "Tom");
+            st.add("names", "Sumana");
+            string expected = "TerTomSumana!";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestTrimmedSubtemplatesNoArgs()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "[<foo({ foo })>]");
+            group.defineTemplate("foo", "x", "<x>");
+            ST st = group.getInstanceOf("test");
+            string expected = "[ foo ]";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestTrimmedSubtemplatesArgs()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "names", "<names:{x|  foo }>");
+            ST st = group.getInstanceOf("test");
+            st.add("names", "Ter");
+            st.add("names", "Tom");
+            st.add("names", "Sumana");
+            string expected = " foo  foo  foo ";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestTrimJustOneWSInSubtemplates()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "names", "<names:{n |  <n> }>!");
+            ST st = group.getInstanceOf("test");
+            st.add("names", "Ter");
+            st.add("names", "Tom");
+            st.add("names", "Sumana");
+            string expected = " Ter  Tom  Sumana !";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestTrimNewlineInSubtemplates()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "names", "<names:{n |\n" +
+                                         "<n>}>!");
+            ST st = group.getInstanceOf("test");
+            st.add("names", "Ter");
+            st.add("names", "Tom");
+            st.add("names", "Sumana");
+            string expected = "TerTomSumana!";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestLeaveNewlineOnEndInSubtemplates()
+        {
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "names", "<names:{n |\n" +
+                                         "<n>\n" +
+                                         "}>!");
+            ST st = group.getInstanceOf("test");
+            st.add("names", "Ter");
+            st.add("names", "Tom");
+            st.add("names", "Sumana");
+            string expected = "Ter" + newline + "Tom" + newline + "Sumana" + newline + "!";
+            string result = st.render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestTabBeforeEndInSubtemplates()
+        {
+            // fails since it counts indent from outer too
+            STGroup group = new STGroup();
+            group.defineTemplate("test", "names", "  <names:{n |\n" +
+                                         "    <n>\n" +
+                                         "  }>!");
+            ST st = group.getInstanceOf("test");
+            st.add("names", "Ter");
+            st.add("names", "Tom");
+            st.add("names", "Sumana");
+            string expected = "    Ter" + newline + "    Tom" + newline + "    Sumana" + newline + "!";
+            string result = st.render();
+            st.impl.dump();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestEmptyExprAsFirstLineGetsNoOutput()
+        {
+            ST t = new ST(
+                "<users>\n" +
+                "end\n");
+            string expecting = "end" + newline;
+            string result = t.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestEmptyLineWithIndent()
+        {
+            ST t = new ST(
+                "begin\n" +
+                "    \n" +
+                "end\n");
+            string expecting = "begin" + newline + newline + "end" + newline;
+            string result = t.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestEmptyLine()
+        {
+            ST t = new ST(
+                "begin\n" +
+                "\n" +
+                "end\n");
+            string expecting = "begin" + newline + newline + "end" + newline;
+            string result = t.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestSizeZeroOnLineByItselfGetsNoOutput()
+        {
+            ST t = new ST(
+                "begin\n" +
+                "<name>\n" +
+                "<users>\n" +
+                "<users>\n" +
+                "end\n");
+            string expecting = "begin" + Environment.NewLine + "end" + newline;
+            string result = t.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestSizeZeroOnLineWithIndentGetsNoOutput()
+        {
+            ST t = new ST(
+                "begin\n" +
+                "  <name>\n" +
+                "	<users>\n" +
+                "	<users>\n" +
+                "end\n");
+            string expecting = "begin" + newline + "end" + newline;
+            string result = t.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestSizeZeroOnLineWithMultipleExpr()
+        {
+            ST t = new ST(
+                "begin\n" +
+                "  <name>\n" +
+                "	<users><users>\n" +
+                "end\n");
+            string expecting = "begin" + newline + "end" + newline;
+            string result = t.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestIFExpr()
+        {
+            ST t = new ST(
+                "begin\n" +
+                "<if(x)><endif>\n" +
+                "end\n");
+            string expecting = "begin" + newline + "end" + newline;
+            string result = t.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestIndentedIFExpr()
+        {
+            ST t = new ST(
+                "begin\n" +
+                "    <if(x)><endif>\n" +
+                "end\n");
+            string expecting = "begin" + newline + "end" + newline;
+            string result = t.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestIFElseExpr()
+        {
+            ST t = new ST(
+                "begin\n" +
+                "<if(users)><else><endif>\n" +
+                "end\n");
+            string expecting = "begin" + newline + "end" + newline;
+            string result = t.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestIFOnMultipleLines()
+        {
+            ST t = new ST(
+                "begin\n" +
+                "<if(users)>\n" +
+                "foo\n" +
+                "<else>\n" +
+                "bar\n" +
+                "<endif>\n" +
+                "end\n");
+            string expecting = "begin" + newline + "bar" + newline + "end" + newline;
+            string result = t.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestNestedIFOnMultipleLines()
+        {
+            ST t = new ST(
+                "begin\n" +
+                "<if(x)>\n" +
+                "<if(y)>\n" +
+                "foo\n" +
+                "<else>\n" +
+                "bar\n" +
+                "<endif>\n" +
+                "<endif>\n" +
+                "end\n");
+            t.add("x", "x");
+            string expecting = "begin" + newline + "bar" + newline + "end" + newline;
+            string result = t.render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestLineBreak()
+        {
+            ST st = new ST(
+                    "Foo <\\\\>" + newline +
+                    "  \t  bar" + newline
+                    );
+            StringWriter sw = new StringWriter();
+            st.write(new AutoIndentWriter(sw, "\n")); // force \n as newline
+            string result = sw.ToString();
+            string expecting = "Foo bar\n";     // expect \n in output
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestLineBreak2()
+        {
+            ST st = new ST(
+                    "Foo <\\\\>       " + newline +
+                    "  \t  bar" + newline
+                    );
+            StringWriter sw = new StringWriter();
+            st.write(new AutoIndentWriter(sw, "\n")); // force \n as newline
+            string result = sw.ToString();
+            string expecting = "Foo bar\n";
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestLineBreakNoWhiteSpace()
+        {
+            ST st = new ST(
+                    "Foo <\\\\>" + newline +
+                    "bar\n"
+                    );
+            StringWriter sw = new StringWriter();
+            st.write(new AutoIndentWriter(sw, "\n")); // force \n as newline
+            string result = sw.ToString();
+            string expecting = "Foo bar\n";
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestNewlineNormalizationInTemplateString()
+        {
+            ST st = new ST(
+                    "Foo\r\n" +
+                    "Bar\n"
+                    );
+            StringWriter sw = new StringWriter();
+            st.write(new AutoIndentWriter(sw, "\n")); // force \n as newline
+            string result = sw.ToString();
+            string expecting = "Foo\nBar\n";     // expect \n in output
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestNewlineNormalizationInTemplateStringPC()
+        {
+            ST st = new ST(
+                    "Foo\r\n" +
+                    "Bar\n"
+                    );
+            StringWriter sw = new StringWriter();
+            st.write(new AutoIndentWriter(sw, "\r\n")); // force \r\n as newline
+            string result = sw.ToString();
+            string expecting = "Foo\r\nBar\r\n";     // expect \r\n in output
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestNewlineNormalizationInAttribute()
+        {
+            ST st = new ST(
+                    "Foo\r\n" +
+                    "<name>\n"
+                    );
+            st.add("name", "a\nb\r\nc");
+            StringWriter sw = new StringWriter();
+            st.write(new AutoIndentWriter(sw, "\n")); // force \n as newline
+            string result = sw.ToString();
+            string expecting = "Foo\na\nb\nc\n";     // expect \n in output
+            Assert.AreEqual(expecting, result);
+        }
+    }
+}

