commit 14c9f43ac8177a7f4d7dbbfb6dac6a89ba0f6d53
Author:     Sam Harwell <sam@tunnelvisionlabs.com>
AuthorDate: Tue Jan 29 10:46:50 2013 -0600
Commit:     Sam Harwell <sam@tunnelvisionlabs.com>
CommitDate: Tue Jan 29 23:01:07 2013 -0600

Update C# port to latest reference code

diff --git a/Antlr3.Runtime.Visualizer/Properties/AssemblyInfo.cs b/Antlr3.Runtime.Visualizer/Properties/AssemblyInfo.cs
index 8666dfc..5cee049 100644
--- a/Antlr3.Runtime.Visualizer/Properties/AssemblyInfo.cs
+++ b/Antlr3.Runtime.Visualizer/Properties/AssemblyInfo.cs
@@ -83,5 +83,5 @@ using System.Windows;
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
-[assembly: AssemblyVersion("3.4.1.9004")]
-[assembly: AssemblyFileVersion("3.4.1.9004")]
+[assembly: AssemblyVersion("3.5.0.0")]
+[assembly: AssemblyFileVersion("3.5.0.0")]
diff --git a/Antlr3.StringTemplate/Properties/AssemblyInfo.cs b/Antlr3.StringTemplate/Properties/AssemblyInfo.cs
index 74b6040..fb4fca7 100644
--- a/Antlr3.StringTemplate/Properties/AssemblyInfo.cs
+++ b/Antlr3.StringTemplate/Properties/AssemblyInfo.cs
@@ -66,5 +66,5 @@ using System.Runtime.InteropServices;
*      the Major or Minor version is incremented.
*   3. Revision is the Perforce changelist number associated with the release.
*/
-[assembly: AssemblyVersion("3.4.1.9004")]
-[assembly: AssemblyFileVersion("3.4.1.9004")]
+[assembly: AssemblyVersion("3.5.0.0")]
+[assembly: AssemblyFileVersion("3.5.0.0")]
diff --git a/Antlr3.Targets/Antlr3.Targets.ActionScript/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.ActionScript/Properties/AssemblyInfo.cs
index ccd693b..a13fdf2 100644
--- a/Antlr3.Targets/Antlr3.Targets.ActionScript/Properties/AssemblyInfo.cs
+++ b/Antlr3.Targets/Antlr3.Targets.ActionScript/Properties/AssemblyInfo.cs
@@ -66,5 +66,5 @@ using System.Runtime.InteropServices;
*      the Major or Minor version is incremented.
*   3. Revision is the Perforce changelist number associated with the release.
*/
-[assembly: AssemblyVersion("3.4.1.9004")]
-[assembly: AssemblyFileVersion("3.4.1.9004")]
+[assembly: AssemblyVersion("3.5.0.0")]
+[assembly: AssemblyFileVersion("3.5.0.0")]
diff --git a/Antlr3.Targets/Antlr3.Targets.C/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.C/Properties/AssemblyInfo.cs
index ea6f7de..6b2884a 100644
--- a/Antlr3.Targets/Antlr3.Targets.C/Properties/AssemblyInfo.cs
+++ b/Antlr3.Targets/Antlr3.Targets.C/Properties/AssemblyInfo.cs
@@ -66,5 +66,5 @@ using System.Runtime.InteropServices;
*      the Major or Minor version is incremented.
*   3. Revision is the Perforce changelist number associated with the release.
*/
-[assembly: AssemblyVersion("3.4.1.9004")]
-[assembly: AssemblyFileVersion("3.4.1.9004")]
+[assembly: AssemblyVersion("3.5.0.0")]
+[assembly: AssemblyFileVersion("3.5.0.0")]
diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp2/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.CSharp2/Properties/AssemblyInfo.cs
index a233b0b..eff1f0b 100644
--- a/Antlr3.Targets/Antlr3.Targets.CSharp2/Properties/AssemblyInfo.cs
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp2/Properties/AssemblyInfo.cs
@@ -66,5 +66,5 @@ using System.Runtime.InteropServices;
*      the Major or Minor version is incremented.
*   3. Revision is the Perforce changelist number associated with the release.
*/
-[assembly: AssemblyVersion("3.4.1.9004")]
-[assembly: AssemblyFileVersion("3.4.1.9004")]
+[assembly: AssemblyVersion("3.5.0.0")]
+[assembly: AssemblyFileVersion("3.5.0.0")]
diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp3/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.CSharp3/Properties/AssemblyInfo.cs
index 36d63f6..674dbcc 100644
--- a/Antlr3.Targets/Antlr3.Targets.CSharp3/Properties/AssemblyInfo.cs
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp3/Properties/AssemblyInfo.cs
@@ -66,5 +66,5 @@ using System.Runtime.InteropServices;
*      the Major or Minor version is incremented.
*   3. Revision is the Perforce changelist number associated with the release.
*/
-[assembly: AssemblyVersion("3.4.1.9004")]
-[assembly: AssemblyFileVersion("3.4.1.9004")]
+[assembly: AssemblyVersion("3.5.0.0")]
+[assembly: AssemblyFileVersion("3.5.0.0")]
diff --git a/Antlr3.Targets/Antlr3.Targets.Cpp/CPPTarget.cs b/Antlr3.Targets/Antlr3.Targets.Cpp/CPPTarget.cs
index 507ad3a..7c34a5e 100644
--- a/Antlr3.Targets/Antlr3.Targets.Cpp/CPPTarget.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Cpp/CPPTarget.cs
@@ -31,127 +31,383 @@
*/
namespace Antlr3.Targets
{
+    using System.Collections.Generic;
+    using Aggregate = Antlr4.StringTemplate.Misc.Aggregate;
using CodeGenerator = Antlr3.Codegen.CodeGenerator;
using Grammar = Antlr3.Tool.Grammar;
+    using GrammarType = Antlr3.Tool.GrammarType;
using StringBuilder = System.Text.StringBuilder;
using StringTemplate = Antlr4.StringTemplate.Template;
-    using StringTemplateGroup = Antlr4.StringTemplate.TemplateGroup;
using Target = Antlr3.Codegen.Target;

public class CPPTarget : Target
{
-        public string EscapeChar( int c )
+        List<string> strings = new List<string>();
+
+        protected override void GenRecognizerFile(AntlrTool tool,
+                CodeGenerator generator,
+                Grammar grammar,
+                StringTemplate outputFileST)
+        {
+
+            // Before we write this, and cause it to generate its string,
+            // we need to add all the string literals that we are going to match
+            //
+            outputFileST.Add("literals", strings);
+            string fileName = generator.GetRecognizerFileName(grammar.name, grammar.type);
+            generator.Write(outputFileST, fileName);
+        }
+
+        protected override void GenRecognizerHeaderFile(AntlrTool tool,
+                CodeGenerator generator,
+                Grammar grammar,
+                StringTemplate headerFileST,
+                string extName)
{
-            // System.out.println("CPPTarget.escapeChar("+c+")");
-            switch ( c )
+
+            //Its better we remove the EOF Token, as it would have been defined everywhere in C.
+            //we define it later as "EOF_TOKEN" instead of "EOF"
+            IList<object> tokens = (IList<object>)headerFileST.GetAttribute("tokens");
+            for (int i = 0; i < tokens.Count; ++i)
{
-            case '\n':
-                return "\\n";
-            case '\t':
-                return "\\t";
-            case '\r':
-                return "\\r";
-            case '\\':
-                return "\\\\";
-            case '\'':
-                return "\\'";
-            case '"':
-                return "\\\"";
-            default:
-                if ( c < ' ' || c > 126 )
-                {
-                    if ( c > 255 )
-                    {
-                        string s = c.ToString( "x" );
-                        // put leading zeroes in front of the thing..
-                        while ( s.Length < 4 )
-                            s = '0' + s;
-                        return "\\u" + s;
-                    }
-                    else
+                bool can_break = false;
+                object tok = tokens[i];
+                if (tok is Aggregate)
+                {
+                    Aggregate atok = (Aggregate)tok;
+                    foreach (var pair in atok.Properties)
{
-                        return "\\" + c.ToString( "8" );
+                        if (pair.Value.Equals("EOF"))
+                        {
+                            tokens.RemoveAt(i);
+                            can_break = true;
+                            break;
+                        }
}
}
-                else
-                {
-                    return ( (char)c ).ToString();
-                }
+
+                if (can_break)
+                    break;
}
+
+            // Pick up the file name we are generating. This method will return a
+            // a file suffixed with .c, so we must substring and add the extName
+            // to it as we cannot assign into strings in Java.
+            ///
+            string fileName = generator.GetRecognizerFileName(grammar.name, grammar.type);
+            fileName = fileName.Substring(0, fileName.Length - 4) + extName;
+
+            generator.Write(headerFileST, fileName);
}

-        /** Converts a String into a representation that can be use as a literal
-         * when surrounded by double-quotes.
-         *
-         * Used for escaping semantic predicate strings for exceptions.
-         *
-         * @param s The String to be changed into a literal
+        protected StringTemplate chooseWhereCyclicDFAsGo(AntlrTool tool,
+                CodeGenerator generator,
+                Grammar grammar,
+                StringTemplate recognizerST,
+                StringTemplate cyclicDFAST)
+        {
+            return recognizerST;
+        }
+
+        /** Is scope in @scope::name {action} valid for this kind of grammar?
+         *  Targets like C++ may want to allow new scopes like headerfile or
+         *  some such.  The action names themselves are not policed at the
+         *  moment so targets can add template actions w/o having to recompile
+         *  ANTLR.
*/
-        public string EscapeString( string s )
+        public override bool IsValidActionScope(GrammarType grammarType, string scope)
{
-            StringBuilder retval = new StringBuilder();
-            for ( int i = 0; i < s.Length; i++ )
+            switch (grammarType)
{
-                retval.Append( EscapeChar( s[i] ) );
-            }
+            case GrammarType.Lexer:
+                if (scope == "lexer")
+                {
+                    return true;
+                }
+                if (scope == "header")
+                {
+                    return true;
+                }
+                if (scope == "includes")
+                {
+                    return true;
+                }
+                if (scope == "preincludes")
+                {
+                    return true;
+                }
+                if (scope == "overrides")
+                {
+                    return true;
+                }
+                if (scope == "namespace")
+                {
+                    return true;
+                }

-            return retval.ToString();
-        }
+                break;
+            case GrammarType.Parser:
+                if (scope == "parser")
+                {
+                    return true;
+                }
+                if (scope == "header")
+                {
+                    return true;
+                }
+                if (scope == "includes")
+                {
+                    return true;
+                }
+                if (scope == "preincludes")
+                {
+                    return true;
+                }
+                if (scope == "overrides")
+                {
+                    return true;
+                }
+                if (scope == "namespace")
+                {
+                    return true;
+                }

-        protected override void GenRecognizerHeaderFile( AntlrTool tool,
-                                               CodeGenerator generator,
-                                               Grammar grammar,
-                                               StringTemplate headerFileST,
-                                               string extName )
-        {
-            generator.Write( headerFileST, grammar.name + extName );
+                break;
+            case GrammarType.Combined:
+                if (scope == "parser")
+                {
+                    return true;
+                }
+                if (scope == "lexer")
+                {
+                    return true;
+                }
+                if (scope == "header")
+                {
+                    return true;
+                }
+                if (scope == "includes")
+                {
+                    return true;
+                }
+                if (scope == "preincludes")
+                {
+                    return true;
+                }
+                if (scope == "overrides")
+                {
+                    return true;
+                }
+                if (scope == "namespace")
+                {
+                    return true;
+                }
+
+                break;
+            case GrammarType.TreeParser:
+                if (scope == "treeparser")
+                {
+                    return true;
+                }
+                if (scope == "header")
+                {
+                    return true;
+                }
+                if (scope == "includes")
+                {
+                    return true;
+                }
+                if (scope == "preincludes")
+                {
+                    return true;
+                }
+                if (scope == "overrides")
+                {
+                    return true;
+                }
+                if (scope == "namespace")
+                {
+                    return true;
+                }
+                break;
+            }
+            return false;
}

-        /** Convert from an ANTLR char literal found in a grammar file to
-         *  an equivalent char literal in the target language.  For Java, this
-         *  is the identify translation; i.e., '\n' -> '\n'.  Most languages
-         *  will be able to use this 1-to-1 mapping.  Expect single quotes
-         *  around the incoming literal.
-         *  Depending on the charvocabulary the charliteral should be prefixed with a 'L'
-         */
-        public override string GetTargetCharLiteralFromANTLRCharLiteral( CodeGenerator codegen, string literal )
+        public override string GetTargetCharLiteralFromANTLRCharLiteral(
+                CodeGenerator generator,
+                string literal)
{
-            int c = Grammar.GetCharValueFromGrammarCharLiteral( literal );
-            string prefix = "'";
-            if ( codegen.Grammar.MaxCharValue > 255 )
-                prefix = "L'";
-            else if ( ( c & 0x80 ) != 0 )	// if in char mode prevent sign extensions
-                return "" + c;
-            return prefix + EscapeChar( c ) + "'";
+
+            if (literal.StartsWith("'\\u"))
+            {
+                literal = "0x" + literal.Substring(3, 4);
+            }
+            else
+            {
+                int c = literal[1];
+
+                if (c < 32 || c > 127)
+                {
+                    literal = "0x" + c.ToString("X");
+                }
+            }
+
+            return literal;
}

/** Convert from an ANTLR string literal found in a grammar file to
-         *  an equivalent string literal in the target language.  For Java, this
-         *  is the identify translation; i.e., "\"\n" -> "\"\n".  Most languages
-         *  will be able to use this 1-to-1 mapping.  Expect double quotes
-         *  around the incoming literal.
-         *  Depending on the charvocabulary the string should be prefixed with a 'L'
+         *  an equivalent string literal in the C target.
+         *  Because we must support Unicode character sets and have chosen
+         *  to have the lexer match UTF32 characters, then we must encode
+         *  string matches to use 32 bit character arrays. Here then we
+         *  must produce the C array and cater for the case where the
+         *  lexer has been encoded with a string such as 'xyz\n',
*/
-        public override string GetTargetStringLiteralFromANTLRStringLiteral( CodeGenerator codegen, string literal )
+        public override string GetTargetStringLiteralFromANTLRStringLiteral(
+                CodeGenerator generator,
+                string literal)
{
-            StringBuilder buf = Grammar.GetUnescapedStringFromGrammarStringLiteral( literal );
-            string prefix = "\"";
-            if ( codegen.Grammar.MaxCharValue > 255 )
-                prefix = "L\"";
-            return prefix + EscapeString( buf.ToString() ) + "\"";
+            int index;
+            string bytes;
+            StringBuilder buf = new StringBuilder();
+
+            buf.Append("{ ");
+
+            // We need ot lose any escaped characters of the form \x and just
+            // replace them with their actual values as well as lose the surrounding
+            // quote marks.
+            //
+            for (int i = 1; i < literal.Length - 1; i++)
+            {
+                buf.Append("0x");
+
+                if (literal[i] == '\\')
+                {
+                    i++; // Assume that there is a next character, this will just yield
+                    // invalid strings if not, which is what the input would be of course - invalid
+                    switch (literal[i])
+                    {
+                    case 'u':
+                    case 'U':
+                        buf.Append(literal.Substring(i + 1, 4));  // Already a hex string
+                        i = i + 5;                                // Move to next string/char/escape
+                        break;
+
+                    case 'n':
+                    case 'N':
+
+                        buf.Append("0A");
+                        break;
+
+                    case 'r':
+                    case 'R':
+
+                        buf.Append("0D");
+                        break;
+
+                    case 't':
+                    case 'T':
+
+                        buf.Append("09");
+                        break;
+
+                    case 'b':
+                    case 'B':
+
+                        buf.Append("08");
+                        break;
+
+                    case 'f':
+                    case 'F':
+
+                        buf.Append("0C");
+                        break;
+
+                    default:
+
+                        // Anything else is what it is!
+                        //
+                        buf.Append(((int)literal[i]).ToString("X"));
+                        break;
+                    }
+                }
+                else
+                {
+                    buf.Append(((int)literal[i]).ToString("X"));
+                }
+                buf.Append(", ");
+            }
+            buf.Append(" antlr3::ANTLR_STRING_TERMINATOR}");
+
+            bytes = buf.ToString();
+            index = strings.IndexOf(bytes);
+
+            if (index == -1)
+            {
+                strings.Add(bytes);
+                index = strings.IndexOf(bytes);
+            }
+
+            string strref = "lit_" + (index + 1);
+            return strref;
}
-        /** Character constants get truncated to this value.
-         * TODO: This should be derived from the charVocabulary. Depending on it
-         * being 255 or 0xFFFF the templates should generate normal character
-         * constants or multibyte ones.
+
+        /**
+         * Overrides the standard grammar analysis so we can prepare the analyser
+         * a little differently from the other targets.
+         *
+         * In particular we want to influence the way the code generator makes assumptions about
+         * switchs vs ifs, vs table driven DFAs. In general, C code should be generated that
+         * has the minimum use of tables, and tha meximum use of large switch statements. This
+         * allows the optimizers to generate very efficient code, it can reduce object code size
+         * by about 30% and give about a 20% performance improvement over not doing this. Hence,
+         * for the C target only, we change the defaults here, but only if they are still set to the
+         * defaults.
+         *
+         * @param generator An instance of the generic code generator class.
+         * @param grammar The grammar that we are currently analyzing
*/
-        public override int GetMaxCharValue( CodeGenerator codegen )
+        protected override void PerformGrammarAnalysis(CodeGenerator generator, Grammar grammar)
{
-            int maxval = 255; // codegen.grammar.get????();
-            if ( maxval <= 255 )
-                return 255;
-            else
-                return maxval;
+
+            // Check to see if the maximum inline DFA states is still set to
+            // the default size. If it is then whack it all the way up to the maximum that
+            // we can sensibly get away with.
+            //
+            if (CodeGenerator.MaxAcyclicDfaStatesInline == CodeGenerator.MaxAcyclicDfaStatesInline)
+            {
+
+                CodeGenerator.MaxAcyclicDfaStatesInline = 65535;
+            }
+
+            // Check to see if the maximum switch size is still set to the default
+            // and bring it up much higher if it is. Modern C compilers can handle
+            // much bigger switch statements than say Java can and if anyone finds a compiler
+            // that cannot deal with such big switches, all the need do is generate the
+            // code with a reduced -Xmaxswitchcaselabels nnn
+            //
+            if (CodeGenerator.MaxSwitchCaseLabels == CodeGenerator.DefaultMaxSwitchCaseLabels)
+            {
+
+                CodeGenerator.MaxSwitchCaseLabels = 3000;
+            }
+
+            // Check to see if the number of transitions considered a miminum for using
+            // a switch is still at the default. Because a switch is still generally faster than
+            // an if even with small sets, and given that the optimizer will do the best thing with it
+            // anyway, then we simply want to generate a switch for any number of states.
+            //
+            if (CodeGenerator.MinSwitchAlts == CodeGenerator.DefaultMinSwitchAlts)
+            {
+
+                CodeGenerator.MinSwitchAlts = 1;
+            }
+
+            // Now we allow the superclass implementation to do whatever it feels it
+            // must do.
+            //
+            base.PerformGrammarAnalysis(generator, grammar);
}
}
}
diff --git a/Antlr3.Targets/Antlr3.Targets.Cpp/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.Cpp/Properties/AssemblyInfo.cs
index 16bc1ab..b5e0f5a 100644
--- a/Antlr3.Targets/Antlr3.Targets.Cpp/Properties/AssemblyInfo.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Cpp/Properties/AssemblyInfo.cs
@@ -66,5 +66,5 @@ using System.Runtime.InteropServices;
*      the Major or Minor version is incremented.
*   3. Revision is the Perforce changelist number associated with the release.
*/
-[assembly: AssemblyVersion("3.4.1.9004")]
-[assembly: AssemblyFileVersion("3.4.1.9004")]
+[assembly: AssemblyVersion("3.5.0.0")]
+[assembly: AssemblyFileVersion("3.5.0.0")]
diff --git a/Antlr3.Targets/Antlr3.Targets.Delphi/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.Delphi/Properties/AssemblyInfo.cs
index 6dec6a9..6045039 100644
--- a/Antlr3.Targets/Antlr3.Targets.Delphi/Properties/AssemblyInfo.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Delphi/Properties/AssemblyInfo.cs
@@ -66,5 +66,5 @@ using System.Runtime.InteropServices;
*      the Major or Minor version is incremented.
*   3. Revision is the Perforce changelist number associated with the release.
*/
-[assembly: AssemblyVersion("3.4.1.9004")]
-[assembly: AssemblyFileVersion("3.4.1.9004")]
+[assembly: AssemblyVersion("3.5.0.0")]
+[assembly: AssemblyFileVersion("3.5.0.0")]
diff --git a/Antlr3.Targets/Antlr3.Targets.Java/JavaTarget.cs b/Antlr3.Targets/Antlr3.Targets.Java/JavaTarget.cs
index 2e55672..5ba47f2 100644
--- a/Antlr3.Targets/Antlr3.Targets.Java/JavaTarget.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Java/JavaTarget.cs
@@ -40,6 +40,14 @@ namespace Antlr3.Targets

public class JavaTarget : Target
{
+        public override bool UseBaseTemplatesForSynPredFragments
+        {
+            get
+            {
+                return false;
+            }
+        }
+
protected override void PerformGrammarAnalysis(CodeGenerator generator, Grammar grammar)
{
base.PerformGrammarAnalysis(generator, grammar);
diff --git a/Antlr3.Targets/Antlr3.Targets.Java/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.Java/Properties/AssemblyInfo.cs
index b635db1..2744476 100644
--- a/Antlr3.Targets/Antlr3.Targets.Java/Properties/AssemblyInfo.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Java/Properties/AssemblyInfo.cs
@@ -66,5 +66,5 @@ using System.Runtime.InteropServices;
*      the Major or Minor version is incremented.
*   3. Revision is the Perforce changelist number associated with the release.
*/
-[assembly: AssemblyVersion("3.4.1.9004")]
-[assembly: AssemblyFileVersion("3.4.1.9004")]
+[assembly: AssemblyVersion("3.5.0.0")]
+[assembly: AssemblyFileVersion("3.5.0.0")]
diff --git a/Antlr3.Targets/Antlr3.Targets.JavaScript/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.JavaScript/Properties/AssemblyInfo.cs
index aa52bef..84a7e24 100644
--- a/Antlr3.Targets/Antlr3.Targets.JavaScript/Properties/AssemblyInfo.cs
+++ b/Antlr3.Targets/Antlr3.Targets.JavaScript/Properties/AssemblyInfo.cs
@@ -66,5 +66,5 @@ using System.Runtime.InteropServices;
*      the Major or Minor version is incremented.
*   3. Revision is the Perforce changelist number associated with the release.
*/
-[assembly: AssemblyVersion("3.4.1.9004")]
-[assembly: AssemblyFileVersion("3.4.1.9004")]
+[assembly: AssemblyVersion("3.5.0.0")]
+[assembly: AssemblyFileVersion("3.5.0.0")]
diff --git a/Antlr3.Targets/Antlr3.Targets.ObjC/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.ObjC/Properties/AssemblyInfo.cs
index c024c38..9a8dbbf 100644
--- a/Antlr3.Targets/Antlr3.Targets.ObjC/Properties/AssemblyInfo.cs
+++ b/Antlr3.Targets/Antlr3.Targets.ObjC/Properties/AssemblyInfo.cs
@@ -66,5 +66,5 @@ using System.Runtime.InteropServices;
*      the Major or Minor version is incremented.
*   3. Revision is the Perforce changelist number associated with the release.
*/
-[assembly: AssemblyVersion("3.4.1.9004")]
-[assembly: AssemblyFileVersion("3.4.1.9004")]
+[assembly: AssemblyVersion("3.5.0.0")]
+[assembly: AssemblyFileVersion("3.5.0.0")]
diff --git a/Antlr3.Targets/Antlr3.Targets.Perl5/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.Perl5/Properties/AssemblyInfo.cs
index 2f45c83..0fc4a62 100644
--- a/Antlr3.Targets/Antlr3.Targets.Perl5/Properties/AssemblyInfo.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Perl5/Properties/AssemblyInfo.cs
@@ -66,5 +66,5 @@ using System.Runtime.InteropServices;
*      the Major or Minor version is incremented.
*   3. Revision is the Perforce changelist number associated with the release.
*/
-[assembly: AssemblyVersion("3.4.1.9004")]
-[assembly: AssemblyFileVersion("3.4.1.9004")]
+[assembly: AssemblyVersion("3.5.0.0")]
+[assembly: AssemblyFileVersion("3.5.0.0")]
diff --git a/Antlr3.Targets/Antlr3.Targets.Python/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.Python/Properties/AssemblyInfo.cs
index ba93f11..7846f4a 100644
--- a/Antlr3.Targets/Antlr3.Targets.Python/Properties/AssemblyInfo.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Python/Properties/AssemblyInfo.cs
@@ -66,5 +66,5 @@ using System.Runtime.InteropServices;
*      the Major or Minor version is incremented.
*   3. Revision is the Perforce changelist number associated with the release.
*/
-[assembly: AssemblyVersion("3.4.1.9004")]
-[assembly: AssemblyFileVersion("3.4.1.9004")]
+[assembly: AssemblyVersion("3.5.0.0")]
+[assembly: AssemblyFileVersion("3.5.0.0")]
diff --git a/Antlr3.Targets/Antlr3.Targets.Python/PythonTarget.cs b/Antlr3.Targets/Antlr3.Targets.Python/PythonTarget.cs
index 7ef4148..0d82169 100644
--- a/Antlr3.Targets/Antlr3.Targets.Python/PythonTarget.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Python/PythonTarget.cs
@@ -50,6 +50,14 @@ namespace Antlr3.Targets

public class PythonTarget : Target
{
+        public override bool UseBaseTemplatesForSynPredFragments
+        {
+            get
+            {
+                return false;
+            }
+        }
+
/** Target must be able to override the labels used for token types */
public override string GetTokenTypeAsTargetLabel( CodeGenerator generator,
int ttype )
diff --git a/Antlr3.Targets/Antlr3.Targets.Python3/Antlr3.Targets.Python3.csproj b/Antlr3.Targets/Antlr3.Targets.Python3/Antlr3.Targets.Python3.csproj
new file mode 100644
index 0000000..12f373a
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Python3/Antlr3.Targets.Python3.csproj
@@ -0,0 +1,71 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{5B7F1199-FB67-4AC1-A482-6BF1DA6CCDC5}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>Antlr3.Targets</RootNamespace>
+    <AssemblyName>Antlr3.Targets.Python3</AssemblyName>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <SignAssembly>true</SignAssembly>
+    <AssemblyOriginatorKeyFile>..\..\..\..\..\keys\antlr\Key.snk</AssemblyOriginatorKeyFile>
+    <TargetFrameworkProfile>Client</TargetFrameworkProfile>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\bin\Debug\Targets\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\bin\Release\Targets\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="Properties\AssemblyInfo.cs" />
+    <Compile Include="Python3Target.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\..\antlr3\runtime\CSharp3\Sources\Antlr3.Runtime\Antlr3.Runtime.csproj">
+      <Project>{8FDC0A87-9005-4D5A-AB75-E55CEB575559}</Project>
+      <Name>Antlr3.Runtime</Name>
+      <Private>False</Private>
+    </ProjectReference>
+    <ProjectReference Include="..\..\Antlr3\Antlr3.csproj">
+      <Project>{2AB8CAED-C046-4F05-8B18-6948100D2FE7}</Project>
+      <Name>Antlr3</Name>
+      <Private>False</Private>
+    </ProjectReference>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="..\..\..\..\..\keys\antlr\Key.snk">
+      <Link>Key.snk</Link>
+    </None>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
\ No newline at end of file
diff --git a/Antlr3.Targets/Antlr3.Targets.Python3/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.Python3/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..7846f4a
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Python3/Properties/AssemblyInfo.cs
@@ -0,0 +1,70 @@
+﻿/*
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Reflection;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle( "Antlr3.Targets.Python" )]
+[assembly: AssemblyDescription( "" )]
+[assembly: AssemblyConfiguration( "" )]
+[assembly: AssemblyCompany( "Tunnel Vision Laboratories, LLC" )]
+[assembly: AssemblyProduct( "Antlr3.Targets.Python" )]
+[assembly: AssemblyCopyright("Copyright © Sam Harwell 2011")]
+[assembly: AssemblyTrademark( "" )]
+[assembly: AssemblyCulture( "" )]
+[assembly: CLSCompliant(true)]
+
+// Setting ComVisible to false makes the types in this assembly not visible
+// to COM components.  If you need to access a type in this assembly from
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible( false )]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid( "e40e91d9-3120-4442-86d8-33571ee23495" )]
+
+/* Version information for an assembly consists of four values in the following order:
+ *
+ *   Major.Minor.Build.Revision
+ *
+ * These values are updated according to the following:
+ *   1. Major.Minor follows the ANTLR release schedule
+ *   2. Build is incremented each time the C# port is packaged for release (regardless
+ *      of whether it's an incremental or nightly). The value resets to zero whenever
+ *      the Major or Minor version is incremented.
+ *   3. Revision is the Perforce changelist number associated with the release.
+ */
+[assembly: AssemblyVersion("3.5.0.0")]
+[assembly: AssemblyFileVersion("3.5.0.0")]
diff --git a/Antlr3.Targets/Antlr3.Targets.Python3/Python3Target.cs b/Antlr3.Targets/Antlr3.Targets.Python3/Python3Target.cs
new file mode 100644
index 0000000..9eb8116
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Python3/Python3Target.cs
@@ -0,0 +1,238 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005 Martin Traverso
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+
+Please excuse my obvious lack of Java experience. The code here is probably
+full of WTFs - though IMHO Java is the Real WTF(TM) here...
+
+ */
+
+namespace Antlr3.Targets
+{
+    using System.Collections.Generic;
+
+    using CodeGenerator = Antlr3.Codegen.CodeGenerator;
+    using Console = System.Console;
+    using Grammar = Antlr3.Tool.Grammar;
+    using IList = System.Collections.IList;
+    using IToken = Antlr.Runtime.IToken;
+    using Target = Antlr3.Codegen.Target;
+
+    public class Python3Target : Target
+    {
+        public override bool UseBaseTemplatesForSynPredFragments
+        {
+            get
+            {
+                return false;
+            }
+        }
+
+        /** Target must be able to override the labels used for token types */
+        public override string GetTokenTypeAsTargetLabel( CodeGenerator generator,
+                            int ttype )
+        {
+            // use ints for predefined types;
+            // <invalid> <EOR> <DOWN> <UP>
+            if ( ttype >= 0 && ttype <= 3 )
+            {
+                return ttype.ToString();
+            }
+
+            string name = generator.Grammar.GetTokenDisplayName( ttype );
+
+            // If name is a literal, return the token type instead
+            if ( name[0] == '\'' )
+            {
+                return ttype.ToString();
+            }
+
+            return name;
+        }
+
+        public override string GetTargetCharLiteralFromANTLRCharLiteral(
+                CodeGenerator generator,
+                string literal )
+        {
+            int c = Grammar.GetCharValueFromGrammarCharLiteral( literal );
+            return ( (char)c ).ToString();
+        }
+
+        private IList<string> SplitLines( string text )
+        {
+            return text.Split( '\n' );
+        }
+
+        public override IList<object> PostProcessAction( IList<object> chunks, IToken actionToken )
+        {
+            /* TODO
+               - check for and report TAB usage
+             */
+
+            //System.out.println("\n*** Action at " + actionToken.getLine() + ":" + actionToken.getColumn());
+
+            /* First I create a new list of chunks. String chunks are splitted into
+               lines and some whitespace my be added at the beginning.
+
+               As a result I get a list of chunks
+               - where the first line starts at column 0
+               - where every LF is at the end of a string chunk
+            */
+
+            List<object> nChunks = new List<object>();
+            for ( int i = 0; i < chunks.Count; i++ )
+            {
+                object chunk = chunks[i];
+
+                string text = chunk as string;
+                if ( text != null )
+                {
+                    if ( nChunks.Count == 0 && actionToken.CharPositionInLine > 0 )
+                    {
+                        // first chunk and some 'virtual' WS at beginning
+                        // prepend to this chunk
+                        string ws = new string( ' ', actionToken.CharPositionInLine );
+                        text = ws + text;
+                    }
+
+                    nChunks.AddRange( text.Split( '\n' ) );
+                }
+                else
+                {
+                    if ( nChunks.Count == 0 && actionToken.CharPositionInLine > 0 )
+                    {
+                        // first chunk and some 'virtual' WS at beginning
+                        // add as a chunk of its own
+                        string ws = new string( ' ', actionToken.CharPositionInLine );
+                        nChunks.Add( ws );
+                    }
+
+                    nChunks.Add( chunk );
+                }
+            }
+
+            int lineNo = actionToken.Line;
+            int col = 0;
+
+            // strip trailing empty lines
+            int lastChunk = nChunks.Count - 1;
+            while ( lastChunk > 0
+                    && nChunks[lastChunk] is string
+                    && ( (string)nChunks[lastChunk] ).Trim().Length == 0 )
+            {
+                lastChunk--;
+            }
+
+            // string leading empty lines
+            int firstChunk = 0;
+            while ( firstChunk <= lastChunk
+                    && nChunks[firstChunk] is string
+                    && ( (string)nChunks[firstChunk] ).Trim().Length == 0
+                    && ( (string)nChunks[firstChunk] ).EndsWith( "\n" ) )
+            {
+                lineNo++;
+                firstChunk++;
+            }
+
+            int indent = -1;
+            for ( int i = firstChunk; i <= lastChunk; i++ )
+            {
+                object chunk = nChunks[i];
+
+                //System.out.println(lineNo + ":" + col + " " + quote(chunk.toString()));
+
+                string text = chunk as string;
+                if ( text != null )
+                {
+                    if ( col == 0 )
+                    {
+                        if ( indent == -1 )
+                        {
+                            // first non-blank line
+                            // count number of leading whitespaces
+
+                            indent = 0;
+                            for ( int j = 0; j < text.Length; j++ )
+                            {
+                                if ( !char.IsWhiteSpace( text[j] ) )
+                                    break;
+
+                                indent++;
+                            }
+                        }
+
+                        if ( text.Length >= indent )
+                        {
+                            int j;
+                            for ( j = 0; j < indent; j++ )
+                            {
+                                if ( !char.IsWhiteSpace( text[j] ) )
+                                {
+                                    // should do real error reporting here...
+                                    Console.Error.WriteLine( "Warning: badly indented line " + lineNo + " in action:" );
+                                    Console.Error.WriteLine( text );
+                                    break;
+                                }
+                            }
+
+                            nChunks[i] = text.Substring( j );
+                        }
+                        else if ( text.Trim().Length > 0 )
+                        {
+                            // should do real error reporting here...
+                            Console.Error.WriteLine( "Warning: badly indented line " + lineNo + " in action:" );
+                            Console.Error.WriteLine( text );
+                        }
+                    }
+
+                    if ( text.EndsWith( "\n" ) )
+                    {
+                        lineNo++;
+                        col = 0;
+                    }
+                    else
+                    {
+                        col += text.Length;
+                    }
+                }
+                else
+                {
+                    // not really correct, but all I need is col to increment...
+                    col += 1;
+                }
+            }
+
+            return nChunks;
+        }
+    }
+}
diff --git a/Antlr3.Targets/Antlr3.Targets.Ruby/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.Ruby/Properties/AssemblyInfo.cs
index a1906de..fc92911 100644
--- a/Antlr3.Targets/Antlr3.Targets.Ruby/Properties/AssemblyInfo.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Ruby/Properties/AssemblyInfo.cs
@@ -66,5 +66,5 @@ using System.Runtime.InteropServices;
*      the Major or Minor version is incremented.
*   3. Revision is the Perforce changelist number associated with the release.
*/
-[assembly: AssemblyVersion("3.4.1.9004")]
-[assembly: AssemblyFileVersion("3.4.1.9004")]
+[assembly: AssemblyVersion("3.5.0.0")]
+[assembly: AssemblyFileVersion("3.5.0.0")]
diff --git a/Antlr3.Test/Antlr3.Test.csproj b/Antlr3.Test/Antlr3.Test.csproj
index 68bc8c3..3d4d266 100644
--- a/Antlr3.Test/Antlr3.Test.csproj
+++ b/Antlr3.Test/Antlr3.Test.csproj
@@ -60,6 +60,7 @@
<Compile Include="TestJavaCodeGeneration.cs" />
<Compile Include="TestLeftRecursion.cs" />
<Compile Include="TestLexer.cs" />
+    <Compile Include="TestLookaheadStream.cs" />
<Compile Include="TestMessages.cs" />
<Compile Include="TestNFAConstruction.cs" />
<Compile Include="TestRewriteAST.cs" />
diff --git a/Antlr3.Test/BaseTest.cs b/Antlr3.Test/BaseTest.cs
index c18fdc8..7e4066c 100644
--- a/Antlr3.Test/BaseTest.cs
+++ b/Antlr3.Test/BaseTest.cs
@@ -416,12 +416,14 @@ namespace AntlrUnitTests
string input,
bool debug )
{
-            rawGenerateAndBuildRecognizer( grammarFileName,
+            bool compiled = rawGenerateAndBuildRecognizer( grammarFileName,
grammarStr,
null,
lexerName,
debug );
-            writeFile( tmpdir, "input", input );
+            Assert.IsTrue(compiled);
+
+            writeFile(tmpdir, "input", input);
return rawExecRecognizer( null,
null,
lexerName,
@@ -440,12 +442,14 @@ namespace AntlrUnitTests
string startRuleName,
string input, bool debug )
{
-            rawGenerateAndBuildRecognizer( grammarFileName,
+            bool compiled = rawGenerateAndBuildRecognizer( grammarFileName,
grammarStr,
parserName,
lexerName,
debug );
-            writeFile( tmpdir, "input", input );
+            Assert.IsTrue(compiled);
+
+            writeFile(tmpdir, "input", input);
bool parserBuildsTrees =
grammarStr.IndexOf( "output=AST" ) >= 0 ||
grammarStr.IndexOf( "output = AST" ) >= 0;
@@ -500,18 +504,20 @@ namespace AntlrUnitTests
bool debug )
{
// build the parser
-            rawGenerateAndBuildRecognizer( parserGrammarFileName,
+            bool compiled = rawGenerateAndBuildRecognizer( parserGrammarFileName,
parserGrammarStr,
parserName,
lexerName,
debug );
+            Assert.IsTrue(compiled);

// build the tree parser
-            rawGenerateAndBuildRecognizer( treeParserGrammarFileName,
+            compiled = rawGenerateAndBuildRecognizer( treeParserGrammarFileName,
treeParserGrammarStr,
treeParserName,
lexerName,
debug );
+            Assert.IsTrue(compiled);

writeFile( tmpdir, "input", input );

@@ -545,6 +551,9 @@ namespace AntlrUnitTests
{
bool allIsWell =
antlr( grammarFileName, grammarFileName, grammarStr, debug );
+            if (!allIsWell)
+                return false;
+
if ( lexerName != null )
{
bool ok;
diff --git a/Antlr3.Test/Properties/AssemblyInfo.cs b/Antlr3.Test/Properties/AssemblyInfo.cs
index 4df99ce..6c1e37b 100644
--- a/Antlr3.Test/Properties/AssemblyInfo.cs
+++ b/Antlr3.Test/Properties/AssemblyInfo.cs
@@ -63,5 +63,5 @@ using System.Runtime.InteropServices;
//
// You can specify all the values or you can default the Revision and Build Numbers
// by using the '*' as shown below:
-[assembly: AssemblyVersion("3.4.1.9004")]
-[assembly: AssemblyFileVersion("3.4.1.9004")]
+[assembly: AssemblyVersion("3.5.0.0")]
+[assembly: AssemblyFileVersion("3.5.0.0")]
diff --git a/Antlr3.Test/TestAttributes.cs b/Antlr3.Test/TestAttributes.cs
index 676b40d..48219c8 100644
--- a/Antlr3.Test/TestAttributes.cs
+++ b/Antlr3.Test/TestAttributes.cs
@@ -684,8 +684,8 @@ namespace AntlrUnitTests
public void TestRuleLabels() /*throws Exception*/ {
string action = "$r.x; $r.start;\n $r.stop;\n $r.tree; $a.x; $a.stop;";
string expecting = "(r!=null?r.x:0); (r!=null?((Token)r.start):null);" + NewLine +
-                               "             (r!=null?((Token)r.stop):null);" + NewLine +
-                               "             (r!=null?((Object)r.tree):null); (r!=null?r.x:0); (r!=null?((Token)r.stop):null);";
+                               "\t\t\t (r!=null?((Token)r.stop):null);" + NewLine +
+                               "\t\t\t (r!=null?((Object)r.tree):null); (r!=null?r.x:0); (r!=null?((Token)r.stop):null);";

ErrorQueue equeue = new ErrorQueue();
ErrorManager.SetErrorListener( equeue );
diff --git a/Antlr3.Test/TestDFAConversion.cs b/Antlr3.Test/TestDFAConversion.cs
index e3f2ab6..c667e9a 100644
--- a/Antlr3.Test/TestDFAConversion.cs
+++ b/Antlr3.Test/TestDFAConversion.cs
@@ -1662,8 +1662,7 @@ namespace AntlrUnitTests
}
NonRegularDecisionMessage msg = getNonRegularDecisionMessage( equeue.errors );
Assert.IsNotNull(msg, "expected fatal non-LL(*) msg");
-            List<int> alts = new List<int>();
-            alts.AddRange( msg.altsWithRecursion );
+            List<int> alts = new List<int>(msg.altsWithRecursion);
alts.Sort();
//Collections.sort( alts );
//Assert.AreEqual( expectedBadAlts, alts );
diff --git a/Antlr3.Test/TestJavaCodeGeneration.cs b/Antlr3.Test/TestJavaCodeGeneration.cs
index 47a2e92..3740c71 100644
--- a/Antlr3.Test/TestJavaCodeGeneration.cs
+++ b/Antlr3.Test/TestJavaCodeGeneration.cs
@@ -173,5 +173,25 @@ namespace AntlrUnitTests
bool expecting = true; // should be ok
Assert.AreEqual(expecting, found);
}
+
+        /**
+         * This is a regression test for antlr/antlr3#20: StackOverflow error when
+         * compiling grammar with backtracking.
+         * https://github.com/antlr/antlr3/issues/20
+         */
+        [TestMethod]
+        public void TestSemanticPredicateAnalysisStackOverflow()
+        {
+            string grammar =
+                "grammar T;\n"
+                + "\n"
+                + "options {\n"
+                + "  backtrack=true;\n"
+                + "}\n"
+                + "\n"
+                + "main : ('x'*)*;\n";
+            bool success = rawGenerateAndBuildRecognizer("T.g", grammar, "TParser", "TLexer", false);
+            Assert.IsTrue(success);
+        }
}
}
diff --git a/Antlr3.Test/TestLookaheadStream.cs b/Antlr3.Test/TestLookaheadStream.cs
new file mode 100644
index 0000000..86b52b4
--- /dev/null
+++ b/Antlr3.Test/TestLookaheadStream.cs
@@ -0,0 +1,94 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace AntlrUnitTests
+{
+    using Antlr.Runtime;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using NotImplementedException = System.NotImplementedException;
+
+    [TestClass]
+    public class TestLookaheadStream
+    {
+        [TestMethod]
+        public void TestSeek()
+        {
+            UnbufferedTokenStream stream = new UnbufferedTokenStream(new TokenSource());
+
+            stream.Consume();
+            Assert.AreEqual(0, stream.LA(-1));
+            Assert.AreEqual(1, stream.LA(1));
+
+            stream.Mark();
+
+            stream.Consume();
+            Assert.AreEqual(1, stream.LA(-1));
+            Assert.AreEqual(2, stream.LA(1));
+
+            int index = stream.Index;
+            stream.Rewind();
+            Assert.AreEqual(0, stream.LA(-1));
+            Assert.AreEqual(1, stream.LA(1));
+
+            stream.Seek(index);
+            Assert.AreEqual(1, stream.LA(-1));
+            Assert.AreEqual(2, stream.LA(1));
+        }
+
+        private class TokenSource : ITokenSource
+        {
+            int count = 0;
+
+            public string SourceName
+            {
+                get
+                {
+                    return "test";
+                }
+            }
+
+            public IToken NextToken()
+            {
+                return new CommonToken(count++);
+            }
+
+
+            public string[] TokenNames
+            {
+                get
+                {
+                    throw new NotImplementedException();
+                }
+            }
+        }
+    }
+}
diff --git a/Antlr3.Test/TestRewriteAST.cs b/Antlr3.Test/TestRewriteAST.cs
index f93ba0f..5ae064c 100644
--- a/Antlr3.Test/TestRewriteAST.cs
+++ b/Antlr3.Test/TestRewriteAST.cs
@@ -1094,10 +1094,7 @@ namespace AntlrUnitTests
}

[TestMethod]
-        [Ignore]
public void TestSetWithLabel() /*throws Exception*/ {
-            // FAILS. The should probably generate a warning from antlr
-            // See http://www.antlr.org:8888/browse/ANTLR-162
string grammar =
"grammar T;\n" +
"options { output = AST; } \n" +
diff --git a/Antlr3.Test/TestSyntaxErrors.cs b/Antlr3.Test/TestSyntaxErrors.cs
index 9eb2032..ac9f838 100644
--- a/Antlr3.Test/TestSyntaxErrors.cs
+++ b/Antlr3.Test/TestSyntaxErrors.cs
@@ -33,8 +33,9 @@
namespace AntlrUnitTests
{
using Microsoft.VisualStudio.TestTools.UnitTesting;
-
using Console = System.Console;
+    using ErrorManager = Antlr3.Tool.ErrorManager;
+    using Path = System.IO.Path;
using Regex = System.Text.RegularExpressions.Regex;

[TestClass]
@@ -127,5 +128,57 @@ namespace AntlrUnitTests
string expecting = "{HARDWARE,SOFTWARE}" + NewLine;
Assert.AreEqual(expecting, result);
}
+
+        [TestMethod]
+        public void TestStrayBracketRecovery()
+        {
+            string grammar =
+                "grammar T;\n" +
+                "options {output = AST;}\n" +
+                "tokens{NODE;}\n" +
+                "s : a=ID INT -> ^(NODE[$a]] INT);\n" +
+                "ID: 'a'..'z'+;\n" +
+                "INT: '0'..'9'+;\n";
+
+            ErrorQueue errorQueue = new ErrorQueue();
+            ErrorManager.SetErrorListener(errorQueue);
+
+            bool found =
+                rawGenerateAndBuildRecognizer(
+                    "T.g", grammar, "TParser", "TLexer", false);
+
+            Assert.IsFalse(found);
+            Assert.AreEqual(
+                "[error(100): :4:27: syntax error: antlr: dangling ']'? make sure to escape with \\]]",
+                errorQueue.errors.ToString());
+        }
+
+        /**
+         * This is a regression test for antlr/antlr3#61.
+         * https://github.com/antlr/antlr3/issues/61
+         */
+        [TestMethod]
+        public void TestMissingAttributeAccessPreventsCodeGeneration()
+        {
+            string grammar =
+                "grammar T;\n" +
+                "options {\n" +
+                "    backtrack = true; \n" +
+                "}\n" +
+                "// if b is rule ref, gens bad void x=null code\n" +
+                "a : x=b {Object o = $x; System.out.println(\"alt1\");}\n" +
+                "  | y=b\n" +
+                "  ;\n" +
+                "\n" +
+                "b : 'a' ;\n";
+
+            ErrorQueue errorQueue = new ErrorQueue();
+            ErrorManager.SetErrorListener(errorQueue);
+            bool success = rawGenerateAndBuildRecognizer("T.g", grammar, "TParser", "TLexer", false);
+            Assert.IsFalse(success);
+            Assert.AreEqual(
+                "[error(117): " + tmpdir.ToString() + Path.DirectorySeparatorChar + "T.g:6:9: missing attribute access on rule scope: x]",
+                errorQueue.errors.ToString());
+        }
}
}
diff --git a/Antlr3.Test/TestTreeWizard.cs b/Antlr3.Test/TestTreeWizard.cs
index 0943862..3d3fe9a 100644
--- a/Antlr3.Test/TestTreeWizard.cs
+++ b/Antlr3.Test/TestTreeWizard.cs
@@ -95,7 +95,7 @@ namespace AntlrUnitTests
public void TestInvalidListTree() /*throws Exception*/ {
TreeWizard wiz = new TreeWizard( adaptor, tokens );
CommonTree t = (CommonTree)wiz.Create( "A B C" );
-            Assert.IsTrue( t == null );
+            Assert.IsNull(t);
}

[TestMethod]
diff --git a/Antlr3.Test/TestTrees.cs b/Antlr3.Test/TestTrees.cs
index b859c1b..6f90b20 100644
--- a/Antlr3.Test/TestTrees.cs
+++ b/Antlr3.Test/TestTrees.cs
@@ -270,19 +270,11 @@ namespace AntlrUnitTests
// Test replaceChildren

[TestMethod]
+        [ExpectedException(typeof(ArgumentException))]
public void TestReplaceWithNoChildren() /*throws Exception*/ {
CommonTree t = new CommonTree( new CommonToken( 101 ) );
CommonTree newChild = new CommonTree( new CommonToken( 5 ) );
-            bool error = false;
-            try
-            {
-                t.ReplaceChildren( 0, 0, newChild );
-            }
-            catch ( ArgumentException /*iae*/ )
-            {
-                error = true;
-            }
-            Assert.IsTrue( error );
+            t.ReplaceChildren( 0, 0, newChild );
}

[TestMethod]
diff --git a/Antlr3.sln b/Antlr3.sln
index 85bd9ae..fc579ab 100644
--- a/Antlr3.sln
+++ b/Antlr3.sln
@@ -72,6 +72,8 @@ Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Antlr4.StringTemplate.Visua
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Antlr3.Runtime.Visualizer", "Antlr3.Runtime.Visualizer\Antlr3.Runtime.Visualizer.csproj", "{2F59DA1C-A502-440C-ABE8-240BDE2D0664}"
EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Antlr3.Targets.Python3", "Antlr3.Targets\Antlr3.Targets.Python3\Antlr3.Targets.Python3.csproj", "{5B7F1199-FB67-4AC1-A482-6BF1DA6CCDC5}"
+EndProject
Global
GlobalSection(TestCaseManagementSettings) = postSolution
CategoryFile = Antlr3.vsmdi
@@ -177,6 +179,10 @@ Global
{2F59DA1C-A502-440C-ABE8-240BDE2D0664}.Debug|Any CPU.Build.0 = Debug|Any CPU
{2F59DA1C-A502-440C-ABE8-240BDE2D0664}.Release|Any CPU.ActiveCfg = Release|Any CPU
{2F59DA1C-A502-440C-ABE8-240BDE2D0664}.Release|Any CPU.Build.0 = Release|Any CPU
+		{5B7F1199-FB67-4AC1-A482-6BF1DA6CCDC5}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{5B7F1199-FB67-4AC1-A482-6BF1DA6CCDC5}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{5B7F1199-FB67-4AC1-A482-6BF1DA6CCDC5}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{5B7F1199-FB67-4AC1-A482-6BF1DA6CCDC5}.Release|Any CPU.Build.0 = Release|Any CPU
EndGlobalSection
GlobalSection(SolutionProperties) = preSolution
HideSolutionNode = FALSE
@@ -194,5 +200,6 @@ Global
{9444ACEF-784D-47B0-B317-F374782FA511} = {3A92893D-7810-4D8B-80D8-E1E8D151FA73}
{1DEA6EB4-2288-4B6C-B5F4-1D102B8745BB} = {3A92893D-7810-4D8B-80D8-E1E8D151FA73}
{64418260-E75A-4556-BB7E-8BDAAFC2EFB9} = {3A92893D-7810-4D8B-80D8-E1E8D151FA73}
+		{5B7F1199-FB67-4AC1-A482-6BF1DA6CCDC5} = {3A92893D-7810-4D8B-80D8-E1E8D151FA73}
EndGlobalSection
EndGlobal
diff --git a/Antlr3/Analysis/SemanticContext.cs b/Antlr3/Analysis/SemanticContext.cs
index b4ee207..6a44bfa 100644
--- a/Antlr3/Analysis/SemanticContext.cs
+++ b/Antlr3/Analysis/SemanticContext.cs
@@ -577,7 +577,7 @@ namespace Antlr3.Analysis
if (templates != null)
eST = templates.GetInstanceOf("orPredicates");
else
-                    eST = new StringTemplate("(<first(operands)><rest(operands):{o | ||<o>}>)");
+                    eST = new StringTemplate("(<operands; separator=\"||\">)");

foreach (SemanticContext semctx in Operands)
{
@@ -704,7 +704,11 @@ namespace Antlr3.Analysis
//    return a;

//System.Console.Out.WriteLine( "## have to AND" );
-            return new AND(a, b);
+            AND result = new AND(a, b);
+            if (result.Operands.Count == 1)
+                return result.Operands.First();
+
+            return result;
}

[CLSCompliant(false)]
diff --git a/Antlr3/Antlr3.csproj b/Antlr3/Antlr3.csproj
index a7aff96..70f18f6 100644
--- a/Antlr3/Antlr3.csproj
+++ b/Antlr3/Antlr3.csproj
@@ -92,6 +92,7 @@
<Compile Include="Tool\Message.cs" />
<Compile Include="Tool\Rule.cs" />
<Compile Include="Tool\ToolMessage.cs" />
+    <Compile Include="Tool\ToolTemplateGroupFile.cs" />
</ItemGroup>
<ItemGroup>
<Antlr3 Include="Grammars\ActionTranslator.g3">
diff --git a/Antlr3/AntlrTool.cs b/Antlr3/AntlrTool.cs
index 8fb386f..8b02d35 100644
--- a/Antlr3/AntlrTool.cs
+++ b/Antlr3/AntlrTool.cs
@@ -525,6 +525,14 @@ namespace Antlr3
if ( !File.Exists( outputFile ) || grammarLastModified > File.GetLastWriteTime( outputFile ) )
{
// One of the output files does not exist or is out of date, so we must build it
+                    if (Verbose)
+                    {
+                        if (!File.Exists(outputFile))
+                            Console.Out.WriteLine("Output file " + outputFile + " does not exist: must build " + grammarFileName);
+                        else
+                            Console.Out.WriteLine("Output file " + outputFile + " is not up-to-date: must build " + grammarFileName);
+                    }
+
return true;
}

@@ -537,6 +545,9 @@ namespace Antlr3
if ( File.GetLastWriteTime( inputFile ) > File.GetLastWriteTime( outputFile ) )
{
// One of the imported grammar files has been updated so we must build
+                            if (Verbose)
+                                Console.Out.WriteLine("Input file " + inputFile + " is newer than output: must rebuild " + grammarFileName);
+
return true;
}
}
diff --git a/Antlr3/Codegen/CodeGenerator.cs b/Antlr3/Codegen/CodeGenerator.cs
index 8c980fd..c3b9f68 100644
--- a/Antlr3/Codegen/CodeGenerator.cs
+++ b/Antlr3/Codegen/CodeGenerator.cs
@@ -77,9 +77,10 @@ namespace Antlr3.Codegen
using Stopwatch = System.Diagnostics.Stopwatch;
using StringTemplate = Antlr4.StringTemplate.Template;
using TemplateGroup = Antlr4.StringTemplate.TemplateGroup;
-    using TemplateGroupFile = Antlr4.StringTemplate.TemplateGroupFile;
+    using ToolTemplateGroupFile = Antlr3.Tool.ToolTemplateGroupFile;
using TextWriter = System.IO.TextWriter;
using TimeSpan = System.TimeSpan;
+    using Antlr3.Misc;

/** ANTLR's code generator.
*
@@ -413,13 +414,6 @@ namespace Antlr3.Codegen
// first load main language template
TemplateGroup coreTemplates = GetOrCacheTemplateGroup(tool, language, null, null);
baseTemplates = coreTemplates;
-            if (coreTemplates == null)
-            {
-                ErrorManager.Error(ErrorManager.MSG_MISSING_CODE_GEN_TEMPLATES, language);
-                baseTemplates = null;
-                templates = null;
-                return;
-            }

outputOption = outputOption ?? string.Empty;
// dynamically add subgroups that act like filters to apply to
@@ -568,7 +562,7 @@ namespace Antlr3.Codegen

if (string.IsNullOrEmpty(name))
{
-                TemplateGroup group = new TemplateGroupFile(groupFileName);
+                TemplateGroup group = new ToolTemplateGroupFile(groupFileName);
group.TrackCreationEvents = CodeGenerator.LaunchTemplateInspector;
group.IterateAcrossValues = true;
_coreTemplates[language] = group;
@@ -576,7 +570,7 @@ namespace Antlr3.Codegen
}
else
{
-                TemplateGroup group = new TemplateGroupFile(groupFileName);
+                TemplateGroup group = new ToolTemplateGroupFile(groupFileName);
group.TrackCreationEvents = CodeGenerator.LaunchTemplateInspector;
group.IterateAcrossValues = true;

@@ -602,7 +596,7 @@ namespace Antlr3.Codegen

if (string.IsNullOrEmpty(name) && superGroup == null)
{
-                TemplateGroup group = new TemplateGroupFile(groupFileName);
+                TemplateGroup group = new ToolTemplateGroupFile(groupFileName);
group.TrackCreationEvents = CodeGenerator.LaunchTemplateInspector;
group.IterateAcrossValues = true;
_coreTemplates[language] = group;
@@ -610,7 +604,7 @@ namespace Antlr3.Codegen
}
else
{
-                TemplateGroup group = new TemplateGroupFile(groupFileName);
+                TemplateGroup group = new ToolTemplateGroupFile(groupFileName);
group.TrackCreationEvents = CodeGenerator.LaunchTemplateInspector;
group.IterateAcrossValues = true;
group.ImportTemplates(superGroup);
@@ -837,6 +831,10 @@ namespace Antlr3.Codegen
// all recognizers can see Grammar object
recognizerST.SetAttribute( "grammar", _grammar );

+            // do not render templates to disk if errors occurred
+            if (ErrorManager.GetErrorState().errors > 0)
+                return null;
+
if (CodeGenerator.LaunchTemplateInspector)
{
outputFileST.Visualize();
@@ -920,11 +918,11 @@ namespace Antlr3.Codegen
{
ruleName = r.Name;
}
-            ICollection<string> actionNameSet = scopeActions.Keys.ToArray();
-            foreach ( string name in actionNameSet )
+
+            foreach ( var scopeAction in scopeActions.ToArray() )
{
-                object action;
-                scopeActions.TryGetValue(name, out action);
+                string name = scopeAction.Key;
+                object action = scopeAction.Value;
GrammarAST actionAST = action as GrammarAST;
IList<object> chunks = TranslateAction( ruleName, actionAST );
scopeActions[name] = chunks; // replace with translation
@@ -1191,12 +1189,60 @@ namespace Antlr3.Codegen
}
string testSTName = "lookaheadTest";
string testRangeSTName = "lookaheadRangeTest";
-            if ( !partOfDFA )
+            string testSetSTName = "lookaheadSetTest";
+            string varSTName = "lookaheadVarName";
+            if (!partOfDFA)
{
testSTName = "isolatedLookaheadTest";
testRangeSTName = "isolatedLookaheadRangeTest";
+                testSetSTName = "isolatedLookaheadSetTest";
+                varSTName = "isolatedLookaheadVarName";
}
+
StringTemplate setST = templates.GetInstanceOf( "setTest" );
+            // If the SetTest template exists, separate the ranges:
+            // flatten the small ones into one list and make that a range,
+            // and leave the others as they are.
+            if (templates.IsDefined(testSetSTName))
+            {
+                // Flatten the IntervalSet into a list of integers.
+                StringTemplate sST = templates.GetInstanceOf(testSetSTName);
+                int rangeNumber2 = 1;
+                foreach (Interval I in iset.Intervals)
+                {
+                    int a = I.a;
+                    int b = I.b;
+                    // Not flattening the large ranges helps us avoid making a
+                    // set that contains 90% of Unicode when we could just use
+                    // a simple range like (LA(1)>=123 && LA(1)<=65535).
+                    // This flattens all ranges of length 4 or less.
+                    if (b - a < 4)
+                    {
+                        for (int i = a; i <= b; i++)
+                        {
+                            sST.Add("values", GetTokenTypeAsTargetLabel(i));
+                            sST.Add("valuesAsInt", i);
+                        }
+                    }
+                    else
+                    {
+                        StringTemplate eST = templates.GetInstanceOf(testRangeSTName);
+                        eST.Add("lower", GetTokenTypeAsTargetLabel(a));
+                        eST.Add("lowerAsInt", a);
+                        eST.Add("upper", GetTokenTypeAsTargetLabel(b));
+                        eST.Add("upperAsInt", b);
+                        eST.Add("rangeNumber", rangeNumber2);
+                        eST.Add("k", k);
+                        setST.Add("ranges", eST);
+                        rangeNumber2++;
+                    }
+                }
+
+                sST.Add("k", k);
+                setST.Add("ranges", sST);
+                return setST;
+            }
+
int rangeNumber = 1;
foreach ( Interval I in iset.Intervals )
{
diff --git a/Antlr3/Grammars/ANTLR.g3 b/Antlr3/Grammars/ANTLR.g3
index fd0539d..cd2f242 100644
--- a/Antlr3/Grammars/ANTLR.g3
+++ b/Antlr3/Grammars/ANTLR.g3
@@ -402,10 +402,11 @@ elementNoOptionSpec
{
IntSet elements=null;
}
-	:	(	id (ASSIGN^|PLUS_ASSIGN^) (atom|block)
+	:	(	id (ASSIGN^|PLUS_ASSIGN^)
+			(	atom (ebnfSuffix[root_0,false]! {root_0 = $ebnfSuffix.tree;})?
+			|	ebnf
+			)
)
-		(	ebnfSuffix[root_0,false]! {root_0 = $ebnfSuffix.tree;}
-		)?
|	atom
(	ebnfSuffix[$atom.tree,false]! {root_0 = $ebnfSuffix.tree;}
)?
@@ -481,8 +482,19 @@ ebnf
)
;

-range
-	:	CHAR_LITERAL RANGE<type=CHAR_RANGE;text="..">^ CHAR_LITERAL
+range!
+	:	{Rule.GetRuleType(currentRuleName) == RuleType.Lexer}?=>
+	 	CHAR_LITERAL RANGE<type=CHAR_RANGE;text="..">^ CHAR_LITERAL
+	|	// range elsewhere is an error
+		(	// have to generate something for surrounding code, just return first token
+			TOKEN_REF r=RANGE! TOKEN_REF!
+		|	STRING_LITERAL r=RANGE! STRING_LITERAL!
+		|	CHAR_LITERAL r=RANGE! CHAR_LITERAL!
+		)
+		{
+		ErrorManager.SyntaxError(
+			ErrorManager.MSG_RANGE_OP_ILLEGAL,Grammar,$r,null,null);
+		}
;

terminal
@@ -813,14 +825,6 @@ DOLLAR : '$' ;

STRAY_BRACKET
:	']'
-		{
-			ErrorManager.SyntaxError(
-				ErrorManager.MSG_SYNTAX_ERROR,
-				null,
-				state.token,
-				"antlr: dangling ']'? make sure to escape with \\]",
-				null);
-		}
;

CHAR_LITERAL
diff --git a/Antlr3/Grammars/ANTLRLexerHelper.cs b/Antlr3/Grammars/ANTLRLexerHelper.cs
index ce1c16c..dfb2d9a 100644
--- a/Antlr3/Grammars/ANTLRLexerHelper.cs
+++ b/Antlr3/Grammars/ANTLRLexerHelper.cs
@@ -32,6 +32,9 @@

namespace Antlr3.Grammars
{
+    using ErrorManager = Antlr3.Tool.ErrorManager;
+    using IToken = Antlr.Runtime.IToken;
+
partial class ANTLRLexer
{
public bool hasASTOperator = false;
@@ -49,5 +52,24 @@ namespace Antlr3.Grammars
return ANTLRParser.tokenNames;
}
}
+
+        public override IToken NextToken()
+        {
+            IToken token = base.NextToken();
+            while (token.Type == STRAY_BRACKET)
+            {
+                ErrorManager.SyntaxError(
+                    ErrorManager.MSG_SYNTAX_ERROR,
+                    null,
+                    token,
+                    "antlr: dangling ']'? make sure to escape with \\]",
+                    null);
+
+                // skip this token
+                token = base.NextToken();
+            }
+
+            return token;
+        }
}
}
diff --git a/Antlr3/Grammars/ANTLRParserHelper.cs b/Antlr3/Grammars/ANTLRParserHelper.cs
index 60352a0..3465993 100644
--- a/Antlr3/Grammars/ANTLRParserHelper.cs
+++ b/Antlr3/Grammars/ANTLRParserHelper.cs
@@ -92,26 +92,22 @@ namespace Antlr3.Grammars
get
{
string badText = null;
-                    if ( start is IToken )
+                    if ( start != null )
{
-                        int i = ( (IToken)start ).TokenIndex;
-                        int j = ( (IToken)stop ).TokenIndex;
-                        if ( ( (IToken)stop ).Type == TokenTypes.EndOfFile )
-                        {
-                            j = ( (ITokenStream)input ).Count;
-                        }
+                        int i = start.TokenIndex;
+                        int j = stop.TokenIndex;
+                        if ( stop.Type == TokenTypes.EndOfFile )
+                            j = input.Count;
+
badText = ( (ITokenStream)input ).ToString( i, j );
}
-                    else if ( start is ITree )
-                    {
-                        badText = ( (ITreeNodeStream)input ).ToString( start, stop );
-                    }
else
{
// people should subclass if they alter the tree type so this
// next one is for sure correct.
badText = "<unknown>";
}
+
return badText;
}
set
diff --git a/Antlr3/Grammars/CodeGenTreeWalker.g3 b/Antlr3/Grammars/CodeGenTreeWalker.g3
index 889fc2e..c56d6ac 100644
--- a/Antlr3/Grammars/CodeGenTreeWalker.g3
+++ b/Antlr3/Grammars/CodeGenTreeWalker.g3
@@ -136,7 +136,7 @@ if (ruleDescr.IsSynPred && generator.Target.UseBaseTemplatesForSynPredFragments)
( ^(OPTIONS .*) )?
(ruleScopeSpec)?
( ^(AMPERSAND .*) )*
-			b=block["ruleBlock", dfa]		{HandleRuleAfterBlock(out $code, $start, block2, ruleDescr, description, $b.code);}
+			b=block["ruleBlock", dfa, null]		{HandleRuleAfterBlock(out $code, $start, block2, ruleDescr, description, $b.code);}

(exceptionGroup[$code])?
EOR
@@ -160,7 +160,7 @@ ruleScopeSpec
:	^('scope' ( ^(AMPERSAND .*) )* ACTION? ID*)
;

-block[string blockTemplateName, Antlr3.Analysis.DFA dfa]
+block[string blockTemplateName, Antlr3.Analysis.DFA dfa, GrammarAST label]
returns [Template code]
options { k=1; }
@init
@@ -172,7 +172,7 @@ options { k=1; }

|	^(  BLOCK
( ^(OPTIONS .*) )? // ignore
-			( alt=alternative rew=rewrite								{HandleBlockAlternative($code, ref altNum, $alt.code, $rew.start, $rew.code);}
+			( alt=alternative[$label] rew=rewrite								{HandleBlockAlternative($code, ref altNum, $alt.code, $rew.start, $rew.code);}
)+
EOB
)
@@ -200,13 +200,13 @@ finallyClause[Template ruleST]
:	^('finally' ACTION)						{HandleFinallyClause($ruleST, $ACTION);}
;

-alternative returns [Template code]
+alternative[GrammarAST label] returns [Template code]
@init
{
HandleAlternativeInit(out $code, $start);
}
:	^(	ALT
-			(	e=element[null,null]			{HandleAlternativeElement($code, $e.start, $e.code);}
+			(	e=element[$label,null]			{HandleAlternativeElement($code, $e.start, $e.code);}
)+
EOA
)
@@ -214,13 +214,13 @@ HandleAlternativeInit(out $code, $start);

element[GrammarAST label, GrammarAST astSuffix] returns [Template code]
options { k=1; }
-	:	^(ROOT e=element[label,$ROOT])							{$code = $e.code;}
-	|	^(BANG e=element[label,$BANG])							{$code = $e.code;}
+	:	^(ROOT e=element[$label,$ROOT])							{$code = $e.code;}
+	|	^(BANG e=element[$label,$BANG])							{$code = $e.code;}
|	^(n=NOT notElement[$n, $label, $astSuffix])				{$code = $notElement.code;}
|	^(ASSIGN alabel=ID e=element[$alabel,$astSuffix])		{$code = $e.code;}
|	^(PLUS_ASSIGN label2=ID e=element[$label2,$astSuffix])	{$code = $e.code;}
|	^(CHAR_RANGE a=CHAR_LITERAL b=CHAR_LITERAL)				{HandleElementCharRange($label, out $code, $a, $b);}
-	|	{$start.SetValue == null}? ebnf							{$code = $ebnf.code;}
+	|	{$start.SetValue == null}? ebnf[$label]					{$code = $ebnf.code;}
|	atom[null, $label, $astSuffix]							{$code = $atom.code;}
|	tree_													{$code = $tree_.code;}
|	element_action											{$code = $element_action.code;}
@@ -249,16 +249,16 @@ notElement[GrammarAST n, GrammarAST label, GrammarAST astSuffix] returns [Templa
{HandleNotElementEnd($n, $label, $astSuffix, out $code, elements, $start);}
;

-ebnf returns [Template code=null]
+ebnf[GrammarAST label] returns [Template code=null]
@init
{
GrammarAST b = (GrammarAST)$start.GetChild(0);
GrammarAST eob = (GrammarAST)b.LastChild; // loops will use EOB DFA
}
-	:	(	blk=block["block", $start.LookaheadDFA]										{$code = $blk.code;}
-		|	^(OPTIONAL blk=block["optionalBlock", $start.LookaheadDFA])					{$code = $blk.code;}
-		|	^(CLOSURE blk=block["closureBlock", eob.LookaheadDFA])						{$code = $blk.code;}
-		|	^(POSITIVE_CLOSURE blk=block["positiveClosureBlock", eob.LookaheadDFA])		{$code = $blk.code;}
+	:	(	blk=block["block", $start.LookaheadDFA, $label]										{$code = $blk.code;}
+		|	^(OPTIONAL blk=block["optionalBlock", $start.LookaheadDFA, $label])					{$code = $blk.code;}
+		|	^(CLOSURE blk=block["closureBlock", eob.LookaheadDFA, $label])						{$code = $blk.code;}
+		|	^(POSITIVE_CLOSURE blk=block["positiveClosureBlock", eob.LookaheadDFA, $label])		{$code = $blk.code;}
)
{
string description = grammar.GrammarTreeToString($start, false);
diff --git a/Antlr3/Grammars/CodeGenTreeWalkerHelper.cs b/Antlr3/Grammars/CodeGenTreeWalkerHelper.cs
index 8463334..2b3ce10 100644
--- a/Antlr3/Grammars/CodeGenTreeWalkerHelper.cs
+++ b/Antlr3/Grammars/CodeGenTreeWalkerHelper.cs
@@ -1016,7 +1016,9 @@ namespace Antlr3.Grammars
stName += "Root";

code = templates.GetInstanceOf(stName);
-            code.SetAttribute("terminalOptions", term.terminalOptions);
+            if (term.terminalOptions != null)
+                code.SetAttribute("terminalOptions", term.terminalOptions);
+
if (arg != null)
{
IList<object> args = generator.TranslateAction(currentRuleName, arg);
diff --git a/Antlr3/Misc/IntervalSet.cs b/Antlr3/Misc/IntervalSet.cs
index 16e7348..6d4f45e 100644
--- a/Antlr3/Misc/IntervalSet.cs
+++ b/Antlr3/Misc/IntervalSet.cs
@@ -691,11 +691,10 @@ namespace Antlr3.Misc
*/
public override bool Equals( object obj )
{
-            if ( obj == null || !( obj is IntervalSet ) )
-            {
+            IntervalSet other = obj as IntervalSet;
+            if (other == null)
return false;
-            }
-            IntervalSet other = (IntervalSet)obj;
+
return intervals.SequenceEqual( other.intervals );
}

diff --git a/Antlr3/Properties/AssemblyInfo.cs b/Antlr3/Properties/AssemblyInfo.cs
index a4b720d..0063e6b 100644
--- a/Antlr3/Properties/AssemblyInfo.cs
+++ b/Antlr3/Properties/AssemblyInfo.cs
@@ -66,5 +66,5 @@ using System.Runtime.InteropServices;
*      the Major or Minor version is incremented.
*   3. Revision is the Perforce changelist number associated with the release.
*/
-[assembly: AssemblyVersion("3.4.1.9004")]
-[assembly: AssemblyFileVersion("3.4.1.9004")]
+[assembly: AssemblyVersion("3.5.0.0")]
+[assembly: AssemblyFileVersion("3.5.0.0")]
diff --git a/Antlr3/Tool/BuildDependencyGenerator.cs b/Antlr3/Tool/BuildDependencyGenerator.cs
index a154dfb..6a8a607 100644
--- a/Antlr3/Tool/BuildDependencyGenerator.cs
+++ b/Antlr3/Tool/BuildDependencyGenerator.cs
@@ -127,7 +127,7 @@ namespace Antlr3.Tool
System.IO.DirectoryInfo outputDir = tool.GetOutputDirectory( grammarFileName );
if ( outputDir.Name.Equals( "." ) )
{
-                outputDir = null;
+                outputDir = outputDir.Parent;
}
else if ( outputDir.Name.IndexOf( ' ' ) >= 0 )
{ // has spaces?
diff --git a/Antlr3/Tool/ErrorManager.cs b/Antlr3/Tool/ErrorManager.cs
index 3330e61..7eff8ff 100644
--- a/Antlr3/Tool/ErrorManager.cs
+++ b/Antlr3/Tool/ErrorManager.cs
@@ -156,6 +156,7 @@ namespace Antlr3.Tool
public const int MSG_CONFLICTING_OPTION_IN_TREE_FILTER = 167;
public const int MSG_ILLEGAL_OPTION_VALUE = 168;
public const int MSG_ALL_OPS_NEED_SAME_ASSOC = 169;
+        public const int MSG_RANGE_OP_ILLEGAL = 170;

// GRAMMAR WARNINGS
public const int MSG_GRAMMAR_NONDETERMINISM = 200; // A predicts alts 1,2
@@ -218,7 +219,8 @@ namespace Antlr3.Tool
/** Each thread might need it's own error listener; e.g., a GUI with
*  multiple window frames holding multiple grammars.
*/
-        private static Dictionary<Thread, IANTLRErrorListener> threadToListenerMap = new Dictionary<Thread, IANTLRErrorListener>();
+        [ThreadStatic]
+        private static IANTLRErrorListener _listener;

public class ErrorState
{
@@ -233,13 +235,15 @@ namespace Antlr3.Tool
/** Track the number of errors regardless of the listener but track
*  per thread.
*/
-        private static IDictionary<Thread, ErrorState> threadToErrorStateMap = new Dictionary<Thread, ErrorState>();
+        [ThreadStatic]
+        private static ErrorState _errorState;

/** Each thread has its own ptr to a Tool object, which knows how
*  to panic, for example.  In a GUI, the thread might just throw an Error
*  to exit rather than the suicide System.exit.
*/
-        private static IDictionary<Thread, Tool> threadToToolMap = new Dictionary<Thread, Tool>();
+        [ThreadStatic]
+        private static Tool _tool;

/** The group of templates that represent all possible ANTLR errors. */
private static TemplateGroup messages;
@@ -249,7 +253,7 @@ namespace Antlr3.Tool
/** From a msgID how can I get the name of the template that describes
*  the error or warning?
*/
-        private static String[] idToMessageTemplateName = new String[MAX_MESSAGE_NUMBER + 1];
+        private static readonly String[] idToMessageTemplateName = new String[MAX_MESSAGE_NUMBER + 1];

static ErrorManager()
{
@@ -550,22 +554,22 @@ namespace Antlr3.Tool
*/
public static void SetErrorListener( IANTLRErrorListener listener )
{
-            threadToListenerMap[Thread.CurrentThread] = listener;
+            ErrorManager._listener = listener;
}

public static void RemoveErrorListener()
{
-            threadToListenerMap.Remove( Thread.CurrentThread );
+            ErrorManager._listener = null;
}

public static Tool GetTool()
{
-            return threadToToolMap[Thread.CurrentThread];
+            return _tool;
}

public static void SetTool( Tool tool )
{
-            threadToToolMap[Thread.CurrentThread] = tool;
+            _tool = tool;
}

/** Given a message ID, return a StringTemplate that somebody can fill
@@ -613,24 +617,22 @@ namespace Antlr3.Tool

public static IANTLRErrorListener GetErrorListener()
{
-            IANTLRErrorListener el;
-            threadToListenerMap.TryGetValue(Thread.CurrentThread, out el);
+            IANTLRErrorListener el = _listener;
if ( el == null )
-            {
return theDefaultErrorListener;
-            }
+
return el;
}

public static ErrorState GetErrorState()
{
-            ErrorState ec;
-            threadToErrorStateMap.TryGetValue(Thread.CurrentThread, out ec);
+            ErrorState ec = _errorState;
if ( ec == null )
{
ec = new ErrorState();
-                threadToErrorStateMap[Thread.CurrentThread] = ec;
+                _errorState = ec;
}
+
return ec;
}

@@ -641,9 +643,7 @@ namespace Antlr3.Tool

public static void ResetErrorState()
{
-            threadToListenerMap = new Dictionary<Thread, IANTLRErrorListener>();
-            ErrorState ec = new ErrorState();
-            threadToErrorStateMap[Thread.CurrentThread] = ec;
+            _errorState = new ErrorState();
}

public static void Info( String msg )
@@ -1028,8 +1028,7 @@ namespace Antlr3.Tool
*/
public static void Panic()
{
-            Tool tool;
-            threadToToolMap.TryGetValue(Thread.CurrentThread, out tool);
+            Tool tool = _tool;
if ( tool == null )
{
// no tool registered, exit
diff --git a/Antlr3/Tool/Grammar.cs b/Antlr3/Tool/Grammar.cs
index 48d06aa..9365fe1 100644
--- a/Antlr3/Tool/Grammar.cs
+++ b/Antlr3/Tool/Grammar.cs
@@ -1119,10 +1119,9 @@ namespace Antlr3.Tool
grammarTree.SetUnknownTokenBoundaries();

FileName = lexer.Filename; // the lexer #src might change name
-            if ( grammarTree == null || grammarTree.FindFirstType( ANTLRParser.RULE ) == null )
+            if ( grammarTree.FindFirstType( ANTLRParser.RULE ) == null )
{
ErrorManager.Error( ErrorManager.MSG_NO_RULES, FileName );
-                return;
}
}

@@ -2665,23 +2664,33 @@ namespace Antlr3.Tool
*/
public virtual bool IsEmptyRule( GrammarAST block )
{
-            foreach ( ITree node in GrammarAST.Descendants(block) )
-            {
-                switch ( node.Type )
-                {
-                case ANTLRParser.TOKEN_REF:
-                case ANTLRParser.STRING_LITERAL:
-                case ANTLRParser.CHAR_LITERAL:
-                case ANTLRParser.WILDCARD:
-                case ANTLRParser.RULE_REF:
-                    return false;
+            BitSet nonEmptyTerminals = new BitSet();
+            nonEmptyTerminals.Add(ANTLRParser.TOKEN_REF);
+            nonEmptyTerminals.Add(ANTLRParser.STRING_LITERAL);
+            nonEmptyTerminals.Add(ANTLRParser.CHAR_LITERAL);
+            nonEmptyTerminals.Add(ANTLRParser.WILDCARD);
+            nonEmptyTerminals.Add(ANTLRParser.RULE_REF);
+            return FindFirstTypeOutsideRewrite(block, nonEmptyTerminals) == null;
+        }

-                default:
+        protected virtual GrammarAST FindFirstTypeOutsideRewrite(GrammarAST block, BitSet types)
+        {
+            List<GrammarAST> worklist = new List<GrammarAST>();
+            worklist.Add(block);
+            while (worklist.Count > 0)
+            {
+                GrammarAST current = worklist[worklist.Count - 1];
+                worklist.RemoveAt(worklist.Count - 1);
+                if (current.Type == ANTLRParser.REWRITE)
continue;
-                }
+
+                if (current.Type >= 0 && types.Contains(current.Type))
+                    return current;
+
+                worklist.AddRange(current.GetChildrenAsArray());
}

-            return true;
+            return null;
}

public virtual bool IsAtomTokenType( int ttype )
diff --git a/Antlr3/Tool/Interpreter.cs b/Antlr3/Tool/Interpreter.cs
index 13f6ad2..978f07b 100644
--- a/Antlr3/Tool/Interpreter.cs
+++ b/Antlr3/Tool/Interpreter.cs
@@ -158,7 +158,7 @@ namespace Antlr3.Tool
{
return;
}
-            ICharStream @in = (ICharStream)this.input;
+
//Console.Out.WriteLine( "scan(" + startRule + ",'" + @in.substring( @in.Index, @in.Size() - 1 ) + "')" );
// Build NFAs/DFAs from the grammar AST if NFAs haven't been built yet
if ( grammar.GetRuleStartState( startRule ) == null )
@@ -176,7 +176,7 @@ namespace Antlr3.Tool
Stack<object> ruleInvocationStack = new Stack<object>();
NFAState start = grammar.GetRuleStartState( startRule );
NFAState stop = grammar.GetRuleStopState( startRule );
-            ParseEngine( startRule, start, stop, @in, ruleInvocationStack,
+            ParseEngine( startRule, start, stop, input, ruleInvocationStack,
actions, visitedStates );
}

diff --git a/Antlr3/Tool/LeftRecursiveRuleAnalyzer.cs b/Antlr3/Tool/LeftRecursiveRuleAnalyzer.cs
index 97b10dd..201315d 100644
--- a/Antlr3/Tool/LeftRecursiveRuleAnalyzer.cs
+++ b/Antlr3/Tool/LeftRecursiveRuleAnalyzer.cs
@@ -90,7 +90,7 @@ namespace Antlr3.Tool
if (!recRuleTemplatesCache.TryGetValue(templateDirs, out group))
{
string fileName = CodeGenerator.FindTemplateFile(templateDirs.Split(':'), "LeftRecursiveRules.stg");
-                group = new TemplateGroupFile(fileName);
+                group = new ToolTemplateGroupFile(fileName);
if (!group.IsDefined("recRuleName"))
{
recRuleTemplatesCache[templateDirs] = group;
@@ -267,10 +267,10 @@ namespace Antlr3.Tool
ruleST.SetAttribute("setResultAction", setResultST);

IDictionary<int, string> opPrecRuleAlts = binaryAlts.Concat(ternaryAlts).Concat(suffixAlts).ToDictionary(i => i.Key, i => i.Value);
-            foreach (int alt in opPrecRuleAlts.Keys)
+            foreach (var pair in opPrecRuleAlts)
{
-                string altText;
-                opPrecRuleAlts.TryGetValue(alt, out altText);
+                int alt = pair.Key;
+                string altText = pair.Value;
StringTemplate altST = recRuleTemplates.GetInstanceOf("recRuleAlt");
StringTemplate predST =
generator.Templates.GetInstanceOf("recRuleAltPredicate");
diff --git a/Antlr3/Tool/Rule.cs b/Antlr3/Tool/Rule.cs
index dc89319..93bd921 100644
--- a/Antlr3/Tool/Rule.cs
+++ b/Antlr3/Tool/Rule.cs
@@ -1033,7 +1033,7 @@ namespace Antlr3.Tool
}
if ( key.Equals( "memoize" ) && value.ToString().Equals( "true" ) )
{
-                Grammar.atLeastOneRuleMemoizes = true;
+                Grammar.composite.RootGrammar.atLeastOneRuleMemoizes = true;
}
if ( key == "backtrack" && value.ToString() == "true" )
{
diff --git a/Antlr3/Tool/ToolTemplateGroupFile.cs b/Antlr3/Tool/ToolTemplateGroupFile.cs
new file mode 100644
index 0000000..5a42f6c
--- /dev/null
+++ b/Antlr3/Tool/ToolTemplateGroupFile.cs
@@ -0,0 +1,42 @@
+﻿/*
+ * [The "BSD license"]
+ *  Copyright (c) 2012 Terence Parr
+ *  Copyright (c) 2012 Sam Harwell
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *  1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *  3. The name of the author may not be used to endorse or promote products
+ *      derived from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using TemplateGroupFile = Antlr4.StringTemplate.TemplateGroupFile;
+
+    public class ToolTemplateGroupFile : TemplateGroupFile
+    {
+        public ToolTemplateGroupFile(string fileName)
+            : base(fileName)
+        {
+            Listener = ErrorManager.Listener;
+        }
+    }
+}
diff --git a/AntlrBuildTask/Properties/AssemblyInfo.cs b/AntlrBuildTask/Properties/AssemblyInfo.cs
index 412569b..0491c7e 100644
--- a/AntlrBuildTask/Properties/AssemblyInfo.cs
+++ b/AntlrBuildTask/Properties/AssemblyInfo.cs
@@ -66,5 +66,5 @@ using System.Runtime.InteropServices;
*      the Major or Minor version is incremented.
*   3. Revision is the Perforce changelist number associated with the release.
*/
-[assembly: AssemblyVersion("3.4.1.9004")]
-[assembly: AssemblyFileVersion("3.4.1.9004")]
+[assembly: AssemblyVersion("3.5.0.0")]
+[assembly: AssemblyFileVersion("3.5.0.0")]
diff --git a/Reference/antlr3 b/Reference/antlr3
index 747dc08..d36002b 160000
--- a/Reference/antlr3
+++ b/Reference/antlr3
@@ -1 +1 @@
-Subproject commit 747dc08c4ef30f2430dbbdfca04375421367320e
+Subproject commit d36002b9d871e25b379509dd639a61bd05cf4793

