commit 1f09fbdb85ba3ba634d31b97131f4f56c6113af8
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Fri Apr 10 09:34:23 2009 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Fri Apr 10 09:34:23 2009 -0800

C# Port:
* Code cleanup in StringTemplate
* StringTemplateGroup.LoadTemplateFromBeneathRootDirOrCLASSPATH: improved locating templates under the rootDir

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 6012]

diff --git a/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj b/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj
index e49eedf..87c5401 100644
--- a/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj
+++ b/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj
@@ -20,7 +20,7 @@
<SccProvider>SAK</SccProvider>
<TargetFrameworkSubset>Client</TargetFrameworkSubset>
<SignAssembly>true</SignAssembly>
-    <AssemblyOriginatorKeyFile>Key.snk</AssemblyOriginatorKeyFile>
+    <AssemblyOriginatorKeyFile>..\Antlr3\Key.snk</AssemblyOriginatorKeyFile>
</PropertyGroup>
<PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
<DebugSymbols>true</DebugSymbols>
@@ -84,6 +84,7 @@
<Compile Include="Language\Expr.cs" />
<Compile Include="Language\FormalArgument.cs" />
<Compile Include="Language\NewlineRef.cs" />
+    <Compile Include="Language\RegionType.cs" />
<Compile Include="Language\StringRef.cs" />
<Compile Include="Language\StringTemplateAST.cs" />
<Compile Include="Language\StringTemplateToken.cs" />
@@ -175,9 +176,6 @@
<Compile Include="Runtime.Tree\DOTTreeGenerator.cs" />
</ItemGroup>
<ItemGroup>
-    <None Include="Key.snk" />
-  </ItemGroup>
-  <ItemGroup>
<ProjectReference Include="..\..\..\antlr\main\runtime\CSharp3\Sources\Antlr3.Runtime.Debug\Antlr3.Runtime.Debug.csproj">
<Project>{5EE27A90-B023-42C9-AAF1-52B0424C5D0B}</Project>
<Name>Antlr3.Runtime.Debug</Name>
@@ -187,6 +185,11 @@
<Name>Antlr3.Runtime</Name>
</ProjectReference>
</ItemGroup>
+  <ItemGroup>
+    <None Include="..\Antlr3\Key.snk">
+      <Link>Key.snk</Link>
+    </None>
+  </ItemGroup>
<PropertyGroup>
<UseHostCompilerIfAvailable>False</UseHostCompilerIfAvailable>
</PropertyGroup>
diff --git a/Antlr3.StringTemplate/Language/Group.g3 b/Antlr3.StringTemplate/Language/Group.g3
index 15a64aa..277bc9a 100644
--- a/Antlr3.StringTemplate/Language/Group.g3
+++ b/Antlr3.StringTemplate/Language/Group.g3
@@ -179,7 +179,7 @@ template[StringTemplateGroup g]
st = g.DefineRegionTemplate($scope2.text,
$region.text,
null,
-													StringTemplate.REGION_EXPLICIT);
+													RegionType.Explicit);
}
}
}
diff --git a/Antlr3.StringTemplate/Language/GroupParser.cs b/Antlr3.StringTemplate/Language/GroupParser.cs
index 849104e..e5f963e 100644
--- a/Antlr3.StringTemplate/Language/GroupParser.cs
+++ b/Antlr3.StringTemplate/Language/GroupParser.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Language\\Group.g3 2009-03-20 14:32:36
+// $ANTLR 3.1.2 Language\\Group.g3 2009-03-23 20:35:09

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -413,7 +413,7 @@ public partial class GroupParser : Parser
st = g.DefineRegionTemplate((scope2!=null?scope2.Text:null),
(region!=null?region.Text:null),
null,
-																		StringTemplate.REGION_EXPLICIT);
+																		RegionType.Explicit);
}
}

diff --git a/Antlr3.StringTemplate/Language/RegionType.cs b/Antlr3.StringTemplate/Language/RegionType.cs
new file mode 100644
index 0000000..6769b22
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/RegionType.cs
@@ -0,0 +1,44 @@
+ï»¿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2003-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST.Language
+{
+    public enum RegionType
+    {
+        /// <summary>&lt;@r()&gt;</summary>
+        Implicit = 1,
+        /// <summary>&lt;@r&gt;...&lt;@end&gt;</summary>
+        Embedded = 2,
+        /// <summary>@t.r() ::= "..." defined manually by coder</summary>
+        Explicit = 3
+    }
+}
diff --git a/Antlr3.StringTemplate/Language/Template.g3 b/Antlr3.StringTemplate/Language/Template.g3
index d223d2a..9c3c379 100644
--- a/Antlr3.StringTemplate/Language/Template.g3
+++ b/Antlr3.StringTemplate/Language/Template.g3
@@ -235,7 +235,7 @@ action[StringTemplate self]
{
string regionName = combinedNameTemplateStr.substring(0,indexOfDefSymbol);
string template = combinedNameTemplateStr.substring(indexOfDefSymbol+3, combinedNameTemplateStr.Length);
-				StringTemplate regionST = self.Group.DefineRegionTemplate(self,regionName,template,StringTemplate.REGION_EMBEDDED);
+				StringTemplate regionST = self.Group.DefineRegionTemplate(self,regionName,template,RegionType.Embedded);
// treat as regular action: mangled template include
string indent = ((ChunkToken)$rd).Indentation;
ASTExpr c = self.ParseAction(regionST.Name+"()");
diff --git a/Antlr3.StringTemplate/Language/TemplateParser.cs b/Antlr3.StringTemplate/Language/TemplateParser.cs
index 816541b..60b0853 100644
--- a/Antlr3.StringTemplate/Language/TemplateParser.cs
+++ b/Antlr3.StringTemplate/Language/TemplateParser.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Language\\Template.g3 2009-03-20 14:32:33
+// $ANTLR 3.1.2 Language\\Template.g3 2009-03-23 20:35:08

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -438,7 +438,7 @@ public partial class TemplateParser : Parser
{
string regionName = combinedNameTemplateStr.substring(0,indexOfDefSymbol);
string template = combinedNameTemplateStr.substring(indexOfDefSymbol+3, combinedNameTemplateStr.Length);
-								StringTemplate regionST = self.Group.DefineRegionTemplate(self,regionName,template,StringTemplate.REGION_EMBEDDED);
+								StringTemplate regionST = self.Group.DefineRegionTemplate(self,regionName,template,RegionType.Embedded);
// treat as regular action: mangled template include
string indent = ((ChunkToken)rd).Indentation;
ASTExpr c = self.ParseAction(regionST.Name+"()");
diff --git a/Antlr3.StringTemplate/StringTemplate.cs b/Antlr3.StringTemplate/StringTemplate.cs
index 77ff6c0..bb13c1e 100644
--- a/Antlr3.StringTemplate/StringTemplate.cs
+++ b/Antlr3.StringTemplate/StringTemplate.cs
@@ -67,13 +67,6 @@ namespace Antlr3.ST
{
public const string VERSION = "3.3a"; // August 11, 2008

-        /** <summary>&lt;@r()&gt;</summary> */
-        public const int REGION_IMPLICIT = 1;
-        /** <summary>&lt;@r&gt;...&lt;@end&gt;</summary> */
-        public const int REGION_EMBEDDED = 2;
-        /** <summary>@t.r() ::= "..." defined manually by coder</summary> */
-        public const int REGION_EXPLICIT = 3;
-
/** <summary>An automatically created aggregate of properties.</summary>
*
*  <remarks>
@@ -308,7 +301,7 @@ namespace Antlr3.ST
*  You can have multiple
*  </summary>
*/
-        protected internal IDictionary<string, object> attributes;
+        IDictionary<string, object> _attributes;

/** <summary>
*  A Map&lt;Class,Object> that allows people to register a renderer for
@@ -341,7 +334,7 @@ namespace Antlr3.ST
*  this var and isEmbeddedRegion we can determine these cases.
*  </summary>
*/
-        int _regionDefType;
+        RegionType _regionDefType;

/** <summary>
*  Does this template come from a &lt;@region>...&lt;@end> embedded in
@@ -351,7 +344,7 @@ namespace Antlr3.ST
bool _isRegion;

/** <summary>Set of implicit and embedded regions for this template</summary> */
-        HashSet<object> _regions;
+        HashSet<string> _regions;

public static StringTemplateGroup defaultGroup =
new StringTemplateGroup( "defaultGroup", "." );
@@ -395,7 +388,7 @@ namespace Antlr3.ST
IDictionary<string, object> attributes )
: this( group, template )
{
-            this.attributes = attributes;
+            this._attributes = attributes;
}

#region PIXEL MINE ADDED
@@ -428,11 +421,11 @@ namespace Antlr3.ST
{
get
{
-                return attributes;
+                return _attributes;
}
set
{
-                attributes = value;
+                _attributes = value;
}
}

@@ -596,7 +589,7 @@ namespace Antlr3.ST
}
}

-        public int RegionDefType
+        public RegionType RegionDefType
{
get
{
@@ -691,7 +684,7 @@ namespace Antlr3.ST

public virtual void Reset()
{
-            attributes = new Dictionary<string, object>(); // just throw out table and make new one
+            _attributes = new Dictionary<string, object>(); // just throw out table and make new one
}

public virtual void SetPredefinedAttributes()
@@ -704,8 +697,8 @@ namespace Antlr3.ST

public virtual void RemoveAttribute( string name )
{
-            if ( attributes != null )
-                attributes.Remove( name );
+            if ( _attributes != null )
+                _attributes.Remove( name );
}

/** <summary>
@@ -735,9 +728,9 @@ namespace Antlr3.ST
{
throw new ArgumentException( "cannot have '.' in attribute names" );
}
-            if ( attributes == null )
+            if ( _attributes == null )
{
-                attributes = new Dictionary<string, object>();
+                _attributes = new Dictionary<string, object>();
}

if ( value is StringTemplate )
@@ -756,10 +749,10 @@ namespace Antlr3.ST

// convert plain collections
// get exactly in this scope (no enclosing)
-            object o = this.attributes.get( name );
+            object o = this._attributes.get( name );
if ( o == null )
{ // new attribute
-                RawSetAttribute( this.attributes, name, value );
+                RawSetAttribute( this._attributes, name, value );
return;
}
// it will be a multi-value attribute
@@ -775,14 +768,14 @@ namespace Antlr3.ST
IList listAttr = (IList)o;
v = new STAttributeList( listAttr.Count );
v.AddRange( listAttr.Cast<object>() );
-                RawSetAttribute( this.attributes, name, v ); // replace attribute w/list
+                RawSetAttribute( this._attributes, name, v ); // replace attribute w/list
}
else
{
// non-list second attribute, must convert existing to ArrayList
v = new STAttributeList(); // make list to hold multiple values
// make it point to list now
-                RawSetAttribute( this.attributes, name, v ); // replace attribute w/list
+                RawSetAttribute( this._attributes, name, v ); // replace attribute w/list
v.Add( o );  // add previous single-valued attribute
}
if ( value is IList )
@@ -1055,8 +1048,8 @@ namespace Antlr3.ST
*/
public virtual object Get( StringTemplate self, string attribute )
{
-            //System.out.println("### get("+self.getEnclosingInstanceStackString()+", "+attribute+")");
-            //System.out.println("attributes="+(self.attributes!=null?self.attributes.keySet().toString():"none"));
+            //Console.Out.WriteLine( "### get(" + self.GetEnclosingInstanceStackString() + ", " + attribute + ")" );
+            //Console.Out.WriteLine( "attributes=" + ( self.Attributes != null ? self.Attributes.keySet().ToString() : "none" ) );
if ( self == null )
{
return null;
@@ -1069,9 +1062,9 @@ namespace Antlr3.ST

// is it here?
object o = null;
-            if ( self.attributes != null )
+            if ( self._attributes != null )
{
-                self.attributes.TryGetValue( attribute, out o );
+                self._attributes.TryGetValue( attribute, out o );
}

// nope, check argument context in case embedded
@@ -1098,7 +1091,7 @@ namespace Antlr3.ST
// not locally defined, check enclosingInstance if embedded
if ( o == null && self._enclosingInstance != null )
{
-                //System.Console.Out.WriteLine( "looking for " + Name + "." + attribute + " in super=" + _enclosingInstance.Name );
+                //Console.Out.WriteLine( "looking for " + Name + "." + attribute + " in super=" + _enclosingInstance.Name );
object valueFromEnclosing = Get( self._enclosingInstance, attribute );
if ( valueFromEnclosing == null )
{
@@ -1124,7 +1117,7 @@ namespace Antlr3.ST
*/
protected virtual void BreakTemplateIntoChunks()
{
-            //System.out.println("parsing template: "+pattern);
+            //Console.Out.WriteLine( "parsing template: " + _pattern );
if ( _pattern == null )
{
return;
@@ -1139,7 +1132,7 @@ namespace Antlr3.ST
Lexer chunkStream = _group.CreateLexer( this, new StringReader( _pattern ) );
TemplateParser chunkifier = new TemplateParser( new CommonTokenStream( chunkStream ) );
chunkifier.template( this );
-                //System.out.println("chunks="+chunks);
+                //Console.Out.WriteLine( "chunks=" + _chunks );
}
catch ( Exception e )
{
@@ -1281,15 +1274,14 @@ namespace Antlr3.ST
DefineFormalArgument( name, null );
}

-        public virtual void DefineFormalArguments( IList names )
+        public virtual void DefineFormalArguments( IList<string> names )
{
if ( names == null )
{
return;
}
-            for ( int i = 0; i < names.Count; i++ )
+            foreach ( string name in names )
{
-                string name = (string)names[i];
DefineFormalArgument( name );
}
}
@@ -1475,19 +1467,19 @@ namespace Antlr3.ST
}
seen.Add( p );
buf.Append( p.GetTemplateDeclaratorString() );
-                if ( p.attributes != null )
+                if ( p._attributes != null )
{
buf.Append( ", attributes=[" );
int i = 0;
-                    foreach ( string attrName in p.attributes.Keys )
+                    foreach ( var attr in p._attributes )
{
if ( i > 0 )
{
buf.Append( ", " );
}
i++;
-                        buf.Append( attrName );
-                        object o = p.attributes.get( attrName );
+                        buf.Append( attr.Key );
+                        object o = attr.Value;
if ( o is StringTemplate )
{
StringTemplate st = (StringTemplate)o;
@@ -1534,11 +1526,10 @@ namespace Antlr3.ST
buf.Append( ">" + _newline );
p = p._enclosingInstance;
}
-            /*
-                    if ( enclosingInstance!=null ) {
-                    buf.append(enclosingInstance.getEnclosingInstanceStackTrace());
-                    }
-                    */
+            //if ( _enclosingInstance != null )
+            //{
+            //    buf.Append( _enclosingInstance.GetEnclosingInstanceStackTrace() );
+            //}
return buf.ToString();
}

@@ -1561,9 +1552,9 @@ namespace Antlr3.ST
{
StringBuilder buf = new StringBuilder();
buf.Append( Name );
-                if ( attributes != null )
+                if ( _attributes != null )
{
-                    buf.Append( "[" + string.Join( ", ", attributes.Keys.Cast<object>().Select( o => o.ToString() ).ToArray() ) + "]" );
+                    buf.Append( "[" + string.Join( ", ", _attributes.Keys.Cast<object>().Select( o => o.ToString() ).ToArray() ) + "]" );
}
return buf.ToString();
}
@@ -1652,12 +1643,12 @@ namespace Antlr3.ST
{
// we have table of set values and list of values referenced
// compare, looking for SET BUT NOT REFERENCED ATTRIBUTES
-            if ( attributes == null )
+            if ( _attributes == null )
{
return;
}
// if in names and not in referenced attributes, trouble
-            foreach ( string name in attributes.Keys )
+            foreach ( string name in _attributes.Keys )
{
if ( _referencedAttributes != null &&
!_referencedAttributes.Contains( name ) )
@@ -1691,7 +1682,7 @@ namespace Antlr3.ST
{
if ( _regions == null )
{
-                _regions = new HashSet<object>();
+                _regions = new HashSet<string>();
}
_regions.Add( name );
}
@@ -1716,17 +1707,17 @@ namespace Antlr3.ST
buf.Append( _chunks.ToString() );
}
buf.Append( "attributes=[" );
-            if ( attributes != null )
+            if ( _attributes != null )
{
int n = 0;
-                foreach ( string name in attributes.Keys )
+                foreach ( string name in _attributes.Keys )
{
if ( n > 0 )
{
buf.Append( ',' );
}
buf.Append( name + "=" );
-                    object value = attributes.get( name );
+                    object value = _attributes.get( name );
if ( value is StringTemplate )
{
buf.Append( ( (StringTemplate)value ).ToDebugString() );
@@ -1760,11 +1751,11 @@ namespace Antlr3.ST
buf.Append( "  " );
}
buf.Append( Name );
-            buf.Append( attributes.Keys );
+            buf.Append( _attributes.Keys );
buf.Append( ":" + _newline );
-            if ( attributes != null )
+            if ( _attributes != null )
{
-                foreach ( var attr in attributes )
+                foreach ( var attr in _attributes )
{
string name = attr.Key;
object value = attr.Value;
@@ -1804,34 +1795,6 @@ namespace Antlr3.ST
return buf.ToString();
}

-#if false
-        public String GetDOTForDependencyGraph(bool showAttributes) {
-            StringBuffer buf = new StringBuffer();
-            buf.append("digraph prof {\n");
-            HashMap edges = new HashMap();
-            this.getDependencyGraph(edges, showAttributes);
-            Set sourceNodes = edges.keySet();
-            // for each source template
-            for (Iterator it = sourceNodes.iterator(); it.hasNext();) {
-                String src = (String) it.next();
-                Set targetNodes = (Set)edges.get(src);
-                // for each target template
-                for (Iterator it2 = targetNodes.iterator(); it2.hasNext();) {
-                    String trg = (String) it2.next();
-                    buf.append('"');
-                    buf.append(src);
-                    buf.append('"');
-                    buf.append("->");
-                    buf.append('"');
-                    buf.append(trg);
-                    buf.append("\"\n");
-                }
-            }
-            buf.append("}");
-            return buf.toString();
-        }
-#endif
-
/** <summary>
*  Generate a DOT file for displaying the template enclosure graph.
*  </summary>
@@ -1855,13 +1818,13 @@ namespace Antlr3.ST
"$edges:{e|\"$e.src$\" -> \"$e.trg$\"" + _newline + "}$" +
"}" + _newline;
StringTemplate graphST = new StringTemplate( structure );
-            Dictionary<object, object> edges = new Dictionary<object, object>();
+            Dictionary<string, HashSet<string>> edges = new Dictionary<string, HashSet<string>>();
this.GetDependencyGraph( edges, showAttributes );
var sourceNodes = edges.Keys;
// for each source template
foreach ( string src in sourceNodes )
{
-                HashSet<object> targetNodes = (HashSet<object>)edges.get( src );
+                var targetNodes = edges[src];
// for each target template
foreach ( string trg in targetNodes )
{
@@ -1890,12 +1853,12 @@ namespace Antlr3.ST
*  because we are static like method and method[...] with args.
*  </remarks>
*/
-        public virtual void GetDependencyGraph( IDictionary edges, bool showAttributes )
+        public virtual void GetDependencyGraph( IDictionary<string, HashSet<string>> edges, bool showAttributes )
{
string srcNode = this.GetTemplateHeaderString( showAttributes );
-            if ( attributes != null )
+            if ( _attributes != null )
{
-                foreach ( var attr in attributes )
+                foreach ( var attr in _attributes )
{
string name = attr.Key;
object value = attr.Value;
@@ -1970,12 +1933,12 @@ namespace Antlr3.ST
}

/** <summary>Manage a hash table like it has multiple unique values.  Map&lt;Object,Set>.</summary> */
-        protected virtual void PutToMultiValuedMap( IDictionary map, object key, object value )
+        protected virtual void PutToMultiValuedMap( IDictionary<string, HashSet<string>> map, string key, string value )
{
-            HashSet<object> bag = (HashSet<object>)map[key];
+            HashSet<string> bag = map[key];
if ( bag == null )
{
-                bag = new HashSet<object>();
+                bag = new HashSet<string>();
map[key] = bag;
}
bag.Add( value );
@@ -1986,13 +1949,13 @@ namespace Antlr3.ST
Console.Out.WriteLine( "template-" + Name + ":" );
Console.Out.Write( "chunks=" );
Console.Out.WriteLine( _chunks.ToString() );
-            if ( attributes == null )
+            if ( _attributes == null )
{
return;
}
Console.Out.Write( "attributes=[" );
int n = 0;
-            foreach ( var attr in attributes )
+            foreach ( var attr in _attributes )
{
if ( n > 0 )
{
@@ -2007,16 +1970,17 @@ namespace Antlr3.ST
}
else
{
-                    if ( value is IList )
+                    IList alist = value as IList;
+                    if ( alist != null )
{
-                        List<object> alist = (List<object>)value;
for ( int i = 0; i < alist.Count; i++ )
{
-                            object o = (object)alist[i];
+                            object o = alist[i];
Console.Out.Write( name + "[" + i + "] is " + o.GetType().Name + "=" );
-                            if ( o is StringTemplate )
+                            StringTemplate template = o as StringTemplate;
+                            if ( template != null )
{
-                                ( (StringTemplate)o ).PrintDebugString();
+                                template.PrintDebugString();
}
else
{
diff --git a/Antlr3.StringTemplate/StringTemplateGroup.cs b/Antlr3.StringTemplate/StringTemplateGroup.cs
index 8242ad6..e1627e8 100644
--- a/Antlr3.StringTemplate/StringTemplateGroup.cs
+++ b/Antlr3.StringTemplate/StringTemplateGroup.cs
@@ -51,6 +51,7 @@ namespace Antlr3.ST
using IOException = System.IO.IOException;
using MethodImpl = System.Runtime.CompilerServices.MethodImplAttribute;
using MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;
+    using RegionType = Antlr3.ST.Language.RegionType;
using Stream = System.IO.Stream;
using StreamReader = System.IO.StreamReader;
using StringBuilder = System.Text.StringBuilder;
@@ -624,7 +625,7 @@ namespace Antlr3.ST
public virtual StringTemplate GetInstanceOf( string name, IDictionary<string, object> attributes )
{
StringTemplate st = GetInstanceOf( name );
-            st.attributes = attributes;
+            st.Attributes = attributes;
return st;
}

@@ -800,7 +801,7 @@ namespace Antlr3.ST
{
StringTemplate template = null;
string name = GetTemplateNameFromFileName( fileName );
-            // if no rootDir, try to load as a resource in CLASSPATH
+            // if no RootDir, try to load as a resource in CLASSPATH
if ( RootDir == null )
{
string resourceName = GetFileNameFromTemplateName( name.Replace( '/', '.' ) );
@@ -811,46 +812,43 @@ namespace Antlr3.ST
assembly = this.GetType().Assembly;
@is = assembly.GetManifestResourceStream( resourceName );
}
-#if false
-			ClassLoader cl = Thread.currentThread().getContextClassLoader();
-			InputStream @is = cl.getResourceAsStream(fileName);
-			if ( @is==null ) {
-				cl = this.getClass().getClassLoader();
-				@is = cl.getResourceAsStream(fileName);
-			}
-#endif
-                if ( @is == null )
-                {
-                    return null;
-                }
-                TextReader br = null;
-                try
-                {
-                    br = GetInputStreamReader( new System.IO.BufferedStream( @is ) );
-                    template = LoadTemplate( name, br );
-                }
-                catch ( IOException ioe )
-                {
-                    Error( "Problem reading template file: " + fileName, ioe );
-                }
-                finally
+
+                if ( @is != null )
{
-                    if ( br != null )
+                    TextReader br = null;
+                    try
{
-                        try
-                        {
-                            br.Close();
-                        }
-                        catch ( IOException ioe2 )
+                        br = GetInputStreamReader( new System.IO.BufferedStream( @is ) );
+                        template = LoadTemplate( name, br );
+                    }
+                    catch ( IOException ioe )
+                    {
+                        Error( "Problem reading template file: " + fileName, ioe );
+                    }
+                    finally
+                    {
+                        if ( br != null )
{
-                            Error( "Cannot close template file: " + fileName, ioe2 );
+                            try
+                            {
+                                br.Close();
+                            }
+                            catch ( IOException ioe2 )
+                            {
+                                Error( "Cannot close template file: " + fileName, ioe2 );
+                            }
}
}
+                    return template;
}
-                return template;
}
+
// load via rootDir
-            template = LoadTemplate( name, RootDir + "/" + fileName );
+            if ( System.IO.Path.IsPathRooted( fileName ) )
+                template = LoadTemplate( name, fileName );
+            else if ( RootDir != null )
+                template = LoadTemplate( name, System.IO.Path.Combine( RootDir, fileName ) );
+
return template;
}

@@ -952,7 +950,7 @@ namespace Antlr3.ST
public virtual StringTemplate DefineRegionTemplate( string enclosingTemplateName,
string regionName,
string template,
-                                                   int type )
+                                                   RegionType type )
{
string mangledName =
GetMangledRegionName( enclosingTemplateName, regionName );
@@ -966,7 +964,7 @@ namespace Antlr3.ST
public virtual StringTemplate DefineRegionTemplate( StringTemplate enclosingTemplate,
string regionName,
string template,
-                                                   int type )
+                                                   RegionType type )
{
StringTemplate regionST =
DefineRegionTemplate( enclosingTemplate.OutermostName,
@@ -994,7 +992,7 @@ namespace Antlr3.ST
return DefineRegionTemplate( enclosingTemplate,
name,
"",
-                                        StringTemplate.REGION_IMPLICIT );
+                                        RegionType.Implicit );

}

@@ -1035,7 +1033,7 @@ namespace Antlr3.ST
if ( st.IsRegion )
{
// don't allow redef of @t.r() ::= "..." or <@r>...<@end>
-                    if ( st.RegionDefType == StringTemplate.REGION_IMPLICIT )
+                    if ( st.RegionDefType == RegionType.Implicit )
{
return false;
}

