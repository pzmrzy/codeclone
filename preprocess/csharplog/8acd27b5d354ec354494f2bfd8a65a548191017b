commit 8acd27b5d354ec354494f2bfd8a65a548191017b
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Mon Mar 16 10:30:14 2009 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Mon Mar 16 10:30:14 2009 -0800

C# Port:
* Updated bootstrap reference executables

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 5885]

diff --git a/bin/Bootstrap/Antlr3.Runtime.Debug.dll b/bin/Bootstrap/Antlr3.Runtime.Debug.dll
index efac74f..df811ab 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.Debug.dll and b/bin/Bootstrap/Antlr3.Runtime.Debug.dll differ
diff --git a/bin/Bootstrap/Antlr3.Runtime.Debug.pdb b/bin/Bootstrap/Antlr3.Runtime.Debug.pdb
index adcdc3b..e807aa0 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.Debug.pdb and b/bin/Bootstrap/Antlr3.Runtime.Debug.pdb differ
diff --git a/bin/Bootstrap/Antlr3.Runtime.dll b/bin/Bootstrap/Antlr3.Runtime.dll
index 143a0a3..7749b1b 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.dll and b/bin/Bootstrap/Antlr3.Runtime.dll differ
diff --git a/bin/Bootstrap/Antlr3.Runtime.pdb b/bin/Bootstrap/Antlr3.Runtime.pdb
index a79e6cd..f497dfb 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.pdb and b/bin/Bootstrap/Antlr3.Runtime.pdb differ
diff --git a/bin/Bootstrap/Antlr3.StringTemplate.dll b/bin/Bootstrap/Antlr3.StringTemplate.dll
index b6c939d..0ec64d2 100644
Binary files a/bin/Bootstrap/Antlr3.StringTemplate.dll and b/bin/Bootstrap/Antlr3.StringTemplate.dll differ
diff --git a/bin/Bootstrap/Antlr3.StringTemplate.pdb b/bin/Bootstrap/Antlr3.StringTemplate.pdb
index 636afee..693abeb 100644
Binary files a/bin/Bootstrap/Antlr3.StringTemplate.pdb and b/bin/Bootstrap/Antlr3.StringTemplate.pdb differ
diff --git a/bin/Bootstrap/Antlr3.exe b/bin/Bootstrap/Antlr3.exe
index cc062ed..307a6ec 100755
Binary files a/bin/Bootstrap/Antlr3.exe and b/bin/Bootstrap/Antlr3.exe differ
diff --git a/bin/Bootstrap/Antlr3.pdb b/bin/Bootstrap/Antlr3.pdb
index 6cf82b3..4fdf23e 100644
Binary files a/bin/Bootstrap/Antlr3.pdb and b/bin/Bootstrap/Antlr3.pdb differ
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg
index a677445..4e731de 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg
@@ -29,7 +29,6 @@
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
-
group AST;

@outputFile.imports() ::= <<
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTDbg.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTDbg.stg
index fb623f7..4a261c7 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTDbg.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTDbg.stg
@@ -36,7 +36,7 @@
group ASTDbg;

parserMembers() ::= <<
-protected ITreeAdaptor adaptor;
+protected DebugTreeAdaptor adaptor;
public ITreeAdaptor TreeAdaptor
{
get
@@ -45,12 +45,11 @@ public ITreeAdaptor TreeAdaptor
}
set
{
-<!<if(grammar.grammarIsRoot)>
-		this.adaptor = new DebugTreeAdaptor( dbg, value );
+<if(grammar.grammarIsRoot)>
+		this.adaptor = new DebugTreeAdaptor(dbg,adaptor);
<else>
-		this.adaptor = (DebugTreeAdaptor)value; // delegator sends dbg adaptor
-<endif><\n>!>
-		this.adaptor = value;
+		this.adaptor = (DebugTreeAdaptor)adaptor; // delegator sends dbg adaptor
+<endif><\n>
<grammar.directDelegates:{g|<g:delegateName()>.TreeAdaptor = this.adaptor;}>
}
}<\n>
@@ -63,10 +62,10 @@ parserCtorBody() ::= <<
createListenerAndHandshake() ::= <<
DebugEventSocketProxy proxy = new DebugEventSocketProxy( this, port, <if(TREE_PARSER)>input.TreeAdaptor<else>adaptor<endif> );
DebugListener = proxy;
-set<inputStreamType>( new Debug<inputStreamType>( input, proxy ) );
+<inputStreamType> = new Debug<inputStreamType>( input, proxy );
try
{
-	proxy.handshake();
+	proxy.Handshake();
}
catch ( IOException ioe )
{
@@ -75,23 +74,23 @@ catch ( IOException ioe )
>>

@ctorForRootGrammar.finally() ::= <<
-if ( TreeAdaptor == null )
-	TreeAdaptor = new CommonTreeAdaptor();
-<!proxy.TreeAdaptor = adap;!>
+ITreeAdaptor adap = new CommonTreeAdaptor();
+TreeAdaptor = adap;
+proxy.TreeAdaptor = adap;
>>

@ctorForProfilingRootGrammar.finally() ::=<<
-if ( TreeAdaptor == null )
-	TreeAdaptor = new CommonTreeAdaptor();
-<!proxy.TreeAdaptor = adap;!>
+ITreeAdaptor adap = new CommonTreeAdaptor();
+TreeAdaptor = adap;
+proxy.TreeAdaptor = adap;
>>

@ctorForPredefinedListener.superClassRef() ::= ": base( input, dbg )"

@ctorForPredefinedListener.finally() ::=<<
<if(grammar.grammarIsRoot)><! don't create new adaptor for delegates !>
-if ( TreeAdaptor == null )
-	TreeAdaptor = new CommonTreeAdaptor();<\n>
+ITreeAdaptor adap = new CommonTreeAdaptor();
+TreeAdaptor = adap;<\n>
<endif>
>>

diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
index 0583488..34c9055 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
@@ -29,7 +29,6 @@
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
-
group CSharp3 implements ANTLRCore;

csharpVisibilityMap ::= [
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/Dbg.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/Dbg.stg
index 663b2fd..9f5f5d9 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/Dbg.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/Dbg.stg
@@ -29,7 +29,6 @@
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
-
/** Template overrides to add debugging to normal Java output;
*  If ASTs are built, then you'll also get ASTDbg.stg loaded.
*/
@@ -37,8 +36,8 @@ group Dbg;

@outputFile.imports() ::= <<
<@super.imports()>
-using Antlr.Runtime.Debug;<!import org.antlr.runtime.debug.*;!>
-using IOException = System.IO.IOException;<!import java.io.IOException;!>
+using Antlr.Runtime.Debug;
+using IOException = System.IO.IOException;
>>

@genericParser.members() ::= <<
@@ -50,44 +49,37 @@ public static readonly string[] ruleNames =
};<\n>
<endif>
<if(grammar.grammarIsRoot)><! grammar imports other grammar(s) !>
-<!
-public int ruleLevel = 0;
-public virtual int getRuleLevel() { return ruleLevel; }
-public virtual void incRuleLevel() { ruleLevel++; }
-public virtual void decRuleLevel() { ruleLevel--; }
-!>
+	int ruleLevel = 0;
+	public virtual int RuleLevel { get { return ruleLevel; } }
+	public virtual void IncRuleLevel() { ruleLevel++; }
+	public virtual void DecRuleLevel() { ruleLevel--; }
<if(profile)>
-<ctorForProfilingRootGrammar()>
+	<ctorForProfilingRootGrammar()>
<else>
-<ctorForRootGrammar()>
+	<ctorForRootGrammar()>
<endif>
-<!<ctorForPredefinedListener()>!>
+<ctorForPredefinedListener()>
<else><! imported grammar !>
-public virtual int getRuleLevel() { return <grammar.delegators:{g| <g:delegateName()>}>.getRuleLevel(); }
-public virtual void incRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.incRuleLevel(); }
-public virtual void decRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.decRuleLevel(); }
-<ctorForDelegateGrammar()>
+	public int RuleLevel { get { return <grammar.delegators:{g| <g:delegateName()>}>.RuleLevel; } }
+	public void IncRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.IncRuleLevel(); }
+	public void DecRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.DecRuleLevel(); }
+	<ctorForDelegateGrammar()>
<endif>
<if(profile)>
-public virtual bool alreadyParsedRule( IIntStream input, int ruleIndex )
+public virtual bool AlreadyParsedRule( IIntStream input, int ruleIndex )
{
-	((Profiler)dbg).examineRuleMemoization(input, ruleIndex, <grammar.composite.rootGrammar.recognizerName>.ruleNames[ruleIndex]);
-	return super.alreadyParsedRule(input, ruleIndex);
+	((Profiler)dbg).ExamineRuleMemoization(input, ruleIndex, <grammar.composite.rootGrammar.recognizerName>.ruleNames[ruleIndex]);
+	return super.AlreadyParsedRule(input, ruleIndex);
}<\n>
-public virtual void memoize( IIntStream input, int ruleIndex, int ruleStartIndex )
+public virtual void Memoize( IIntStream input, int ruleIndex, int ruleStartIndex )
{
-	((Profiler)dbg).memoize(input, ruleIndex, ruleStartIndex, <grammar.composite.rootGrammar.recognizerName>.ruleNames[ruleIndex]);
-	super.memoize(input, ruleIndex, ruleStartIndex);
+	((Profiler)dbg).Memoize(input, ruleIndex, ruleStartIndex, <grammar.composite.rootGrammar.recognizerName>.ruleNames[ruleIndex]);
+	super.Memoize(input, ruleIndex, ruleStartIndex);
}<\n>
<endif>
-public override IDebugEventListener DebugListener
-{
-	get;
-	set;
-}
-static bool EvalPredicate( bool result, string predicate )
+protected virtual bool EvalPredicate( bool result, string predicate )
{
-	DebugSemanticPredicate( dbg, result, predicate );
+	dbg.SemanticPredicate( result, predicate );
return result;
}<\n>
>>
@@ -96,15 +88,15 @@ ctorForRootGrammar() ::= <<
<! bug: can't use <@super.members()> cut-n-paste instead !>
<! Same except we add port number and profile stuff if root grammar !>
public <name>( <inputStreamType> input )
-	: this( input, <!DebugEventSocketProxy.DEFAULT_DEBUGGER_PORT, !>new RecognizerSharedState() )
+	: this( input, DebugEventSocketProxy.DEFAULT_DEBUGGER_PORT, new RecognizerSharedState() )
{
}
-public <name>( <inputStreamType> input, <!int port, !>RecognizerSharedState state )
+public <name>( <inputStreamType> input, int port, RecognizerSharedState state )
: base( input, state )
{
<parserCtorBody()>
-<!	<createListenerAndHandshake()>!>
-	<grammar.directDelegates:{g|<g:delegateName()> = new <g.recognizerName>( input, <!dbg, !>this.state, this<grammar.delegators:{g|, <g:delegateName()>}> );}; separator="\n">
+	<createListenerAndHandshake()>
+	<grammar.directDelegates:{g|<g:delegateName()> = new <g.recognizerName>( input, dbg, this.state, this<grammar.delegators:{g|, <g:delegateName()>}> );}; separator="\n">
<@finally()>
}<\n>
>>
@@ -159,10 +151,10 @@ DebugEventSocketProxy proxy = new DebugEventSocketProxy( this, port, input.TreeA
<else>
DebugEventSocketProxy proxy = new DebugEventSocketProxy( this, port, null );<\n>
<endif>
-setDebugListener( proxy );
+DebugListener = proxy;
try
{
-	proxy.handshake();
+	proxy.Handshake();
}
catch ( IOException ioe )
{
@@ -170,88 +162,69 @@ catch ( IOException ioe )
}
>>

-//@genericParser.superClassName() ::= "Debug<@super.superClassName()>"
+@genericParser.superClassName() ::= "Debug<@super.superClassName()>"

@rule.preamble() ::= <<
-<!
try
{
dbg.EnterRule( GrammarFileName, "<ruleName>" );
-	if ( getRuleLevel() == 0 )
+	if ( RuleLevel == 0 )
+	{
dbg.Commence();
-	incRuleLevel();
-	dbg.Location( <ruleDescriptor.tree.line>, <ruleDescriptor.tree.charPositionInLine> );
-!>
-DebugEnterRule( DebugListener, GrammarFileName, "<ruleName>" );
-DebugLocation( DebugListener, <ruleDescriptor.tree.line>, <ruleDescriptor.tree.charPositionInLine> );<\n>
+	}
+	IncRuleLevel();
+	dbg.Location( <ruleDescriptor.tree.line>, <ruleDescriptor.tree.charPositionInLine> );<\n>
>>

@rule.postamble() ::= <<
-<!
-	dbg.Location( <ruleDescriptor.EORNode.line>, <ruleDescriptor.EORNode.charPositionInLine> );
+dbg.Location(<ruleDescriptor.EORNode.line>, <ruleDescriptor.EORNode.charPositionInLine>);<\n>
}
finally
{
dbg.ExitRule( GrammarFileName, "<ruleName>" );
-	decRuleLevel();
-	if ( getRuleLevel() == 0 )
+	DecRuleLevel();
+	if ( RuleLevel == 0 )
+	{
dbg.Terminate();
-}
-!>
-DebugLocation( DebugListener, <ruleDescriptor.EORNode.line>, <ruleDescriptor.EORNode.charPositionInLine> );
-DebugExitRule( DebugListener, GrammarFileName, "<ruleName>" );<\n>
+	}
+}<\n>
>>

-@synpred.start() ::= "DebugBeginBacktrack( DebugListener, state.backtracking );"
-//@synpred.start() ::= "dbg.beginBacktrack( state.backtracking );"
+@synpred.start() ::= "dbg.BeginBacktrack( state.backtracking );"

-@synpred.stop() ::= "DebugEndBacktrack( DebugListener, state.backtracking, success );"
-//@synpred.stop() ::= "dbg.endBacktrack( state.backtracking, success );"
+@synpred.stop() ::= "dbg.EndBacktrack( state.backtracking, success );"

// Common debug event triggers used by region overrides below

enterSubRule() ::= <<
-<!
try
{
-	dbg.EnterSubRule( <decisionNumber> );
-!>
-DebugEnterSubRule( DebugListener, <decisionNumber> );<\n>
+	dbg.EnterSubRule( <decisionNumber> );<\n>
>>

exitSubRule() ::= <<
-<!
}
finally
{
dbg.ExitSubRule( <decisionNumber> );
-}
-!>
-DebugExitSubRule( DebugListener, <decisionNumber> );<\n>
+}<\n>
>>

enterDecision() ::= <<
-<!
try
{
-	dbg.EnterDecision( <decisionNumber> );
-!>
-DebugEnterDecision( DebugListener, <decisionNumber> );<\n>
+	dbg.EnterDecision( <decisionNumber> );<\n>
>>

exitDecision() ::= <<
-<!
}
finally
{
dbg.ExitDecision( <decisionNumber> );
-}
-!>
-DebugExitDecision( DebugListener, <decisionNumber> );<\n>
+}<\n>
>>

-enterAlt(n) ::= "DebugEnterAlt( DebugListener, <n> );<\n>"
-//enterAlt(n) ::= "dbg.enterAlt(<n>);<\n>"
+enterAlt(n) ::= "dbg.EnterAlt( <n> );<\n>"

// Region overrides that tell various constructs to add debugging triggers

@@ -278,9 +251,7 @@ enterAlt(n) ::= "DebugEnterAlt( DebugListener, <n> );<\n>"
@positiveClosureBlock.postdecision() ::= "<exitDecision()>"

@positiveClosureBlock.earlyExitException() ::=
-    "DebugRecognitionException( DebugListener, eee<decisionNumber> );<\n>"
-//@positiveClosureBlock.earlyExitException() ::=
-//    "dbg.recognitionException( eee );<\n>"
+	"dbg.RecognitionException( eee<decisionNumber> );<\n>"

@closureBlock.preloop() ::= "<enterSubRule()>"

@@ -293,20 +264,14 @@ enterAlt(n) ::= "DebugEnterAlt( DebugListener, <n> );<\n>"
@altSwitchCase.prealt() ::= "<enterAlt(n=i)>"

@element.prematch() ::=
-    "DebugLocation( DebugListener, <it.line>,<it.pos> );"
-//@element.prematch() ::=
-//    "dbg.location( <it.line>,<it.pos> );"
+	"dbg.Location( <it.line>, <it.pos> );"

@matchSet.mismatchedSetException() ::=
-    "DebugRecognitionException( DebugListener, mse );"
-//@matchSet.mismatchedSetException() ::=
-//    "dbg.recognitionException( mse );"
+	"dbg.RecognitionException( mse );"

-@dfaState.noViableAltException() ::= "DebugRecognitionException( DebugListener, nvae );"
-//@dfaState.noViableAltException() ::= "dbg.recognitionException( nvae );"
+@dfaState.noViableAltException() ::= "dbg.RecognitionException( nvae );"

-@dfaStateSwitch.noViableAltException() ::= "DebugRecognitionException( DebugListener, nvae );"
-//@dfaStateSwitch.noViableAltException() ::= "dbg.recognitionException( nvae );"
+@dfaStateSwitch.noViableAltException() ::= "dbg.RecognitionException( nvae );"

dfaDecision(decisionNumber,description) ::= <<
try
@@ -316,19 +281,19 @@ try
}
catch ( NoViableAltException nvae )
{
-	DebugRecognitionException( DebugListener, nvae );
+	dbg.RecognitionException( nvae );
throw nvae;
}
>>

@cyclicDFA.errorMethod() ::= <<
-public virtual void Error( NoViableAltException nvae )
+public override void Error( NoViableAltException nvae )
{
-	DebugRecognitionException( DebugListener, nvae );
+	((DebugParser)recognizer).dbg.RecognitionException( nvae );
}
>>

/** Force predicate validation to trigger an event */
evalPredicate(pred,description) ::= <<
-evalPredicate( <pred>, "<description>" )
+EvalPredicate( <pred>, "<description>" )
>>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/ST.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/ST.stg
index 6dad49f..1453d76 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/ST.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/ST.stg
@@ -29,7 +29,6 @@
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
-
/** Template subgroup to add template rewrite output
*  If debugging, then you'll also get STDbg.stg loaded.
*/

