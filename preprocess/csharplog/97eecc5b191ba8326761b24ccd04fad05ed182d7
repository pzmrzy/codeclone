commit 97eecc5b191ba8326761b24ccd04fad05ed182d7
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Fri Jul 29 17:55:30 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Fri Jul 29 17:55:30 2011 -0800

(C# 3) Merge CL8859, 8873

[git-p4: depot-paths = "//depot/code/antlr/antlr3-main/": change = 8940]

diff --git a/Antlr3.Runtime/Tree/BaseTree.cs b/Antlr3.Runtime/Tree/BaseTree.cs
index 79f3d97..9327860 100644
--- a/Antlr3.Runtime/Tree/BaseTree.cs
+++ b/Antlr3.Runtime/Tree/BaseTree.cs
@@ -1,10 +1,10 @@
/*
- * [The "BSD licence"]
+ * [The "BSD license"]
* Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -286,6 +286,30 @@ namespace Antlr.Runtime.Tree
t.ChildIndex = i;
}

+        /** Insert child t at child position i (0..n-1) by shifting children
+         *  i+1..n-1 to the right one position. Set parent / indexes properly
+         *  but does NOT collapse nil-rooted t's that come in here like addChild.
+         */
+        public virtual void InsertChild(int i, ITree t)
+        {
+            if (i < 0)
+                throw new ArgumentOutOfRangeException("i");
+            if (i > ChildCount)
+                throw new ArgumentException();
+
+            if (i == ChildCount)
+            {
+                AddChild(t);
+                return;
+            }
+
+            Children.Insert(i, t);
+
+            // walk others to increment their child indexes
+            // set index, parent of this one too
+            this.FreshenParentAndChildIndexes(i);
+        }
+
public virtual object DeleteChild( int i )
{
if (i < 0)
@@ -428,6 +452,25 @@ namespace Antlr.Runtime.Tree
}
}

+        public virtual void FreshenParentAndChildIndexesDeeply()
+        {
+            FreshenParentAndChildIndexesDeeply(0);
+        }
+
+        public virtual void FreshenParentAndChildIndexesDeeply(int offset)
+        {
+            int n = ChildCount;
+            for (int c = offset; c < n; c++)
+            {
+                ITree child = GetChild(c);
+                child.ChildIndex = c;
+                child.Parent = this;
+                BaseTree baseTree = child as BaseTree;
+                if (baseTree != null)
+                    baseTree.FreshenParentAndChildIndexesDeeply();
+            }
+        }
+
public virtual void SanityCheckParentAndChildIndexes()
{
SanityCheckParentAndChildIndexes( null, -1 );

