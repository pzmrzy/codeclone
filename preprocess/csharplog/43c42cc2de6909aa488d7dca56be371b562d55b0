commit 43c42cc2de6909aa488d7dca56be371b562d55b0
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Mon Mar 16 13:29:10 2009 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Mon Mar 16 13:29:10 2009 -0800

C# Port:
* StringTemplate optimizations: cache member accessors and indentation width

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 5887]

diff --git a/Antlr3.StringTemplate/AutoIndentWriter.cs b/Antlr3.StringTemplate/AutoIndentWriter.cs
index 6b20d5d..1678ee7 100644
--- a/Antlr3.StringTemplate/AutoIndentWriter.cs
+++ b/Antlr3.StringTemplate/AutoIndentWriter.cs
@@ -71,6 +71,7 @@ namespace Antlr3.ST
*  </summary>
*/
List<string> _indents = new List<string>();
+        int _indentationWidth;

/** <summary>
*  Stack of integer anchors (char positions in line); avoid Integer
@@ -137,7 +138,7 @@ namespace Antlr3.ST
public virtual void pushIndentation( string indent )
{
int lastAnchor = 0;
-            int indentWidth = getIndentationWidth();
+            int indentWidth = IndentationWidth;
// If current anchor is beyond current indent width, add in difference
if ( _anchors_sp >= 0 && _anchors[_anchors_sp] > indentWidth )
{
@@ -146,9 +147,12 @@ namespace Antlr3.ST
if ( indent != null )
buf.Append( indent ); // don't add if null
_indents.Add( buf.ToString() );
+                _indentationWidth += buf.Length;
return;
}
_indents.Add( indent ?? string.Empty );
+            if ( indent != null )
+                _indentationWidth += indent.Length;
}

/// <exception cref="System.ArgumentOutOfRangeException" />
@@ -156,6 +160,7 @@ namespace Antlr3.ST
{
string value = _indents[_indents.Count - 1];
_indents.RemoveAt( _indents.Count - 1 );
+            _indentationWidth -= value.Length;
return value;
}

@@ -182,11 +187,12 @@ namespace Antlr3.ST
_anchors_sp--;
}

-        /// <exception cref="System.ArgumentNullException" />
-        /// <exception cref="System.OverflowException" />
-        public virtual int getIndentationWidth()
+        public int IndentationWidth
{
-            return _indents.Sum( s => s.Length );
+            get
+            {
+                return _indentationWidth;
+            }
}

/// <summary>Write out a string literal or attribute expression or expression element.</summary>
diff --git a/Antlr3.StringTemplate/Language/ASTExpr.cs b/Antlr3.StringTemplate/Language/ASTExpr.cs
index 25f9156..36547b4 100644
--- a/Antlr3.StringTemplate/Language/ASTExpr.cs
+++ b/Antlr3.StringTemplate/Language/ASTExpr.cs
@@ -44,6 +44,9 @@ namespace Antlr3.ST.Language
using InvalidOperationException = System.InvalidOperationException;
using IOException = System.IO.IOException;
using ITree = Antlr.Runtime.Tree.ITree;
+    using MemberInfo = System.Reflection.MemberInfo;
+    using MethodImpl = System.Runtime.CompilerServices.MethodImplAttribute;
+    using MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;
using MethodInfo = System.Reflection.MethodInfo;
using RecognitionException = Antlr.Runtime.RecognitionException;
using StringWriter = System.IO.StringWriter;
@@ -90,6 +93,8 @@ namespace Antlr3.ST.Language
"wrap"
};

+        static readonly Dictionary<Type, Dictionary<string, MemberInfo>> _memberAccessors = new Dictionary<Type, Dictionary<string, MemberInfo>>();
+
protected internal ITree exprTree = null;

/** <summary>store separator etc...</summary> */
@@ -170,7 +175,7 @@ namespace Antlr3.ST.Language
{ // any non-empty expr means true; check presence
@out.pushAnchorPoint();
}
-            @out.pushIndentation( getIndentation() );
+            @out.pushIndentation( Indentation );
handleExprOptions( self );
//System.out.println("evaluating tree: "+exprTree.toStringList());
ActionEvaluator eval =
@@ -498,6 +503,63 @@ namespace Antlr3.ST.Language
return value;
}

+        [MethodImpl( MethodImplOptions.Synchronized )]
+        static MemberInfo FindMember( Type type, string name )
+        {
+            if ( type == null || name == null )
+                throw new ArgumentNullException();
+
+            Dictionary<string, MemberInfo> members;
+            MemberInfo member = null;
+
+            if ( _memberAccessors.TryGetValue( type, out members ) )
+            {
+                if ( members.TryGetValue( name, out member ) )
+                    return member;
+            }
+            else
+            {
+                members = new Dictionary<string, MemberInfo>();
+                _memberAccessors[type] = members;
+            }
+
+            // must look up using reflection
+            string methodSuffix = char.ToUpperInvariant( name[0] ) + name.Substring( 1 );
+
+            // BEGIN ADDED FOR C#
+            if ( member == null )
+            {
+                System.Reflection.PropertyInfo p = type.GetProperty( methodSuffix );
+                if ( p != null )
+                    member = p.GetGetMethod();
+            }
+            if ( member == null )
+            {
+                member = GetMethod( type, "Get" + methodSuffix );
+            }
+            if ( member == null )
+            {
+                member = GetMethod( type, "Is" + methodSuffix );
+            }
+            // END ADDED
+            if ( member == null )
+            {
+                member = GetMethod( type, "get" + methodSuffix );
+            }
+            if ( member == null )
+            {
+                member = GetMethod( type, "is" + methodSuffix );
+            }
+            if ( member == null )
+            {
+                // try for a visible field
+                member = type.GetField( name );
+            }
+
+            members[name] = member;
+            return member;
+        }
+
protected virtual object rawGetObjectProperty( StringTemplate self, object o, object property )
{
Type c = o.GetType();
@@ -565,7 +627,6 @@ namespace Antlr3.ST.Language
// try getXXX and isXXX properties

// check cache
-            MethodInfo m = null;
/*
Member cachedMember =
self.getGroup().getCachedClassProperty(c,propertyName);
@@ -589,59 +650,33 @@ namespace Antlr3.ST.Language
}
*/

-            // must look up using reflection
string propertyName = (string)property;
-            string methodSuffix = Char.ToUpperInvariant( propertyName[0] ) +
-                propertyName.Substring( 1 );
-            m = getMethod( c, "get" + methodSuffix );
-            if ( m == null )
-            {
-                m = getMethod( c, "is" + methodSuffix );
-            }
-            // BEGIN ADDED FOR C#
-            if ( m == null )
-            {
-                System.Reflection.PropertyInfo p = c.GetProperty( methodSuffix );
-                if ( p != null )
-                    m = p.GetGetMethod();
-            }
-            if ( m == null )
+            MemberInfo member = FindMember( c, propertyName );
+            MethodInfo method = member as MethodInfo;
+            if ( method != null )
{
-                m = getMethod( c, "Get" + methodSuffix );
-            }
-            if ( m == null )
-            {
-                m = getMethod( c, "Is" + methodSuffix );
-            }
-            // END ADDED
-            if ( m != null )
-            {
-                // save to avoid lookup later
-                //self.getGroup().cacheClassProperty(c,propertyName,m);
try
{
-                    value = invokeMethod( m, o, value );
+                    value = InvokeMethod( method, o, value );
}
catch ( Exception e )
{
-                    self.error( "Can't get property " + propertyName + " using method get/is" + methodSuffix +
+                    self.error( "Can't get property " + propertyName + " using method get/is" + propertyName +
" from " + c.Name + " instance", e );
}
}
else
{
-                // try for a visible field
-                FieldInfo f = c.GetField( propertyName );
-                if ( f != null )
+                FieldInfo field = member as FieldInfo;
+                if ( field != null )
{
-                    //self.getGroup().cacheClassProperty(c,propertyName,f);
try
{
-                        value = accessField( f, o, value );
+                        value = AccessField( field, o, value );
}
catch ( FieldAccessException iae )
{
-                        self.error( "Can't access property " + propertyName + " using method get/is" + methodSuffix +
+                        self.error( "Can't access property " + propertyName + " using method get/is" + propertyName +
" or direct field access from " + c.Name + " instance", iae );
}
}
@@ -655,41 +690,19 @@ namespace Antlr3.ST.Language
return value;
}

-        protected virtual object accessField( FieldInfo f, object o, object value )
+        protected static object AccessField( FieldInfo f, object o, object value )
{
-#if false
-            try
-            {
-                // make sure it's accessible (stupid java)
-                f.setAccessible( true );
-            }
-            catch ( SecurityException se )
-            {
-                ; // oh well; security won't let us
-            }
-#endif
value = f.GetValue( o );
return value;
}

-        protected virtual object invokeMethod( MethodInfo m, object o, object value )
+        protected static object InvokeMethod( MethodInfo m, object o, object value )
{
-#if false
-            try
-            {
-                // make sure it's accessible (stupid java)
-                m.setAccessible( true );
-            }
-            catch ( SecurityException se )
-            {
-                ; // oh well; security won't let us
-            }
-#endif
value = m.Invoke( o, null );
return value;
}

-        protected virtual MethodInfo getMethod( Type c, string methodName )
+        protected static MethodInfo GetMethod( Type c, string methodName )
{
// we want a getter method
return c.GetMethod( methodName, new Type[0] );
@@ -746,10 +759,6 @@ namespace Antlr3.ST.Language
*  Strings then cat.
*  </summary>
*/
-        public object add( object a, object b )
-        {
-            return Add( a, b );
-        }
public virtual object Add( object a, object b )
{
if ( a == null )
diff --git a/Antlr3.StringTemplate/Language/Expr.cs b/Antlr3.StringTemplate/Language/Expr.cs
index 1503aba..6a3ef98 100644
--- a/Antlr3.StringTemplate/Language/Expr.cs
+++ b/Antlr3.StringTemplate/Language/Expr.cs
@@ -43,13 +43,13 @@ namespace Antlr3.ST.Language
*  evaluator.
*  </remarks>
*/
-    abstract public class Expr
+    public abstract class Expr
{
/** <summary>The StringTemplate object surrounding this expr</summary> */
-        protected StringTemplate enclosingTemplate;
+        StringTemplate _enclosingTemplate;

/** <summary>
-         *  Any thing spit out as a chunk (even plain text) must be indented
+         *  Anything spit out as a chunk (even plain text) must be indented
*  according to whitespace before the action that generated it.  So,
*  plain text in the outermost template is never indented, but the
*  text and attribute references in a nested template will all be
@@ -57,30 +57,34 @@ namespace Antlr3.ST.Language
*  reference that initiates construction of the nested template.
*  </summary>
*/
-        protected string indentation = null;
+        string _indentation;

public Expr( StringTemplate enclosingTemplate )
{
-            this.enclosingTemplate = enclosingTemplate;
+            _enclosingTemplate = enclosingTemplate;
}

/** <summary>How to write this node to output; return how many char written</summary> */
abstract public int write( StringTemplate self, IStringTemplateWriter writer );

-        public virtual StringTemplate getEnclosingTemplate()
+        public StringTemplate EnclosingTemplate
{
-            return enclosingTemplate;
+            get
+            {
+                return _enclosingTemplate;
+            }
}

-        public virtual string getIndentation()
+        public string Indentation
{
-            return indentation;
-        }
-
-        public virtual void setIndentation( string indentation )
-        {
-            this.indentation = indentation;
+            get
+            {
+                return _indentation;
+            }
+            set
+            {
+                _indentation = value;
+            }
}
}
-
}
diff --git a/Antlr3.StringTemplate/Language/Template.g3 b/Antlr3.StringTemplate/Language/Template.g3
index bdb083e..3a226c0 100644
--- a/Antlr3.StringTemplate/Language/Template.g3
+++ b/Antlr3.StringTemplate/Language/Template.g3
@@ -134,7 +134,7 @@ action[StringTemplate self]
{
string indent = ((ChunkToken)a).Indentation;
ASTExpr c = self.parseAction($a.text);
-			c.setIndentation(indent);
+			c.Indentation = indent;
self.addChunk(c);
}

@@ -221,7 +221,7 @@ action[StringTemplate self]
// treat as regular action: mangled template include
string indent = ((ChunkToken)$rr).Indentation;
ASTExpr c = self.parseAction(mangledRef+"()");
-				c.setIndentation(indent);
+				c.Indentation = indent;
self.addChunk(c);
}
}
@@ -238,7 +238,7 @@ action[StringTemplate self]
// treat as regular action: mangled template include
string indent = ((ChunkToken)$rd).Indentation;
ASTExpr c = self.parseAction(regionST.getName()+"()");
-				c.setIndentation(indent);
+				c.Indentation = indent;
self.addChunk(c);
}
else
diff --git a/Antlr3.StringTemplate/Language/TemplateParser.cs b/Antlr3.StringTemplate/Language/TemplateParser.cs
index 0243dde..0238896 100644
--- a/Antlr3.StringTemplate/Language/TemplateParser.cs
+++ b/Antlr3.StringTemplate/Language/TemplateParser.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Language\\Template.g3 2009-03-07 08:52:37
+// $ANTLR 3.1.2 Language\\Template.g3 2009-03-16 15:51:02

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -269,7 +269,7 @@ public partial class TemplateParser : Parser

string indent = ((ChunkToken)a).Indentation;
ASTExpr c = self.parseAction((a!=null?a.Text:null));
-							c.setIndentation(indent);
+							c.Indentation = indent;
self.addChunk(c);


@@ -419,7 +419,7 @@ public partial class TemplateParser : Parser
// treat as regular action: mangled template include
string indent = ((ChunkToken)rr).Indentation;
ASTExpr c = self.parseAction(mangledRef+"()");
-								c.setIndentation(indent);
+								c.Indentation = indent;
self.addChunk(c);
}

@@ -441,7 +441,7 @@ public partial class TemplateParser : Parser
// treat as regular action: mangled template include
string indent = ((ChunkToken)rd).Indentation;
ASTExpr c = self.parseAction(regionST.getName()+"()");
-								c.setIndentation(indent);
+								c.Indentation = indent;
self.addChunk(c);
}
else
diff --git a/Antlr3.Test/StringTemplateTests.cs b/Antlr3.Test/StringTemplateTests.cs
index 21e391d..c6ffb76 100644
--- a/Antlr3.Test/StringTemplateTests.cs
+++ b/Antlr3.Test/StringTemplateTests.cs
@@ -2887,20 +2887,26 @@ namespace AntlrUnitTests

public class Decl
{
-            string name;
-            string type;
+            string _name;
+            string _type;
public Decl( string name, string type )
{
-                this.name = name;
-                this.type = type;
+                _name = name;
+                _type = type;
}
-            public string getName()
+            public string Name
{
-                return name;
+                get
+                {
+                    return _name;
+                }
}
-            public string getType()
+            public string Type
{
-                return type;
+                get
+                {
+                    return _type;
+                }
}
}


