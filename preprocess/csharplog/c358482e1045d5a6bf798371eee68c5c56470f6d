commit c358482e1045d5a6bf798371eee68c5c56470f6d
Author:     Sam Harwell <sam@tunnelvisionlabs.com>
AuthorDate: Fri Feb 1 10:48:23 2013 -0600
Commit:     Sam Harwell <sam@tunnelvisionlabs.com>
CommitDate: Fri Feb 1 10:48:23 2013 -0600

Remove Antlr3.exe dependency on Antlr3.Runtime.JavaExtensions assembly

diff --git a/Antlr3/Analysis/DFA.cs b/Antlr3/Analysis/DFA.cs
index 616a529..27be570 100644
--- a/Antlr3/Analysis/DFA.cs
+++ b/Antlr3/Analysis/DFA.cs
@@ -34,7 +34,7 @@ namespace Antlr3.Analysis
{
using System.Collections.Generic;
using System.Linq;
-    using Antlr.Runtime.JavaExtensions;
+    using Antlr3.Misc;
using Antlr3.Tool;

using CodeGenerator = Antlr3.Codegen.CodeGenerator;
@@ -887,7 +887,7 @@ namespace Antlr3.Analysis
_transition = new int[NumberOfStates][]; // Vector<Vector<int>>
//transition.setSize( this.NumberOfStates );
_transitionEdgeTables = new List<int?>( this.NumberOfStates ); // Vector<Vector<int>>
-            _transitionEdgeTables.setSize( this.NumberOfStates );
+            _transitionEdgeTables.Resize( this.NumberOfStates );

// for each state in the DFA, fill relevant tables.
IEnumerable<DFAState> it = null;
@@ -1449,7 +1449,7 @@ namespace Antlr3.Analysis
DFAState n = new DFAState( this );
n.StateNumber = _stateCounter;
_stateCounter++;
-            _states.setSize( n.StateNumber + 1 );
+            _states.Resize( n.StateNumber + 1 );
_states[n.StateNumber] = n; // track state num to state
return n;
}
diff --git a/Antlr3/Antlr3.csproj b/Antlr3/Antlr3.csproj
index baebcaf..aa44832 100644
--- a/Antlr3/Antlr3.csproj
+++ b/Antlr3/Antlr3.csproj
@@ -492,10 +492,6 @@
<Project>{5EE27A90-B023-42C9-AAF1-52B0424C5D0B}</Project>
<Name>Antlr3.Runtime.Debug</Name>
</ProjectReference>
-    <ProjectReference Include="..\Reference\antlr3\runtime\CSharp3\Sources\Antlr3.Runtime.JavaExtensions\Antlr3.Runtime.JavaExtensions.csproj">
-      <Project>{A7EEC557-EB14-451C-9616-B7A61F4ECE69}</Project>
-      <Name>Antlr3.Runtime.JavaExtensions</Name>
-    </ProjectReference>
<ProjectReference Include="..\Reference\antlr3\runtime\CSharp3\Sources\Antlr3.Runtime\Antlr3.Runtime.csproj">
<Project>{8FDC0A87-9005-4D5A-AB75-E55CEB575559}</Project>
<Name>Antlr3.Runtime</Name>
diff --git a/Antlr3/Misc/Utils.cs b/Antlr3/Misc/Utils.cs
index 67acd55..9a31728 100644
--- a/Antlr3/Misc/Utils.cs
+++ b/Antlr3/Misc/Utils.cs
@@ -30,20 +30,22 @@
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

-#if DEBUG
-
namespace Antlr3.Misc
{
-    using System;
+    using System.Collections.Generic;
+
+    using ArgumentNullException = System.ArgumentNullException;
+    using ArgumentOutOfRangeException = System.ArgumentOutOfRangeException;

public static class Utils
{
+#if DEBUG
/** Integer objects are immutable so share all Integers with the
*  same value up to some max size.  Use an array as a perfect hash.
*  Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new
*  Integer object with x in it.
*/
-        [Obsolete]
+        [System.Obsolete]
public static int integer( int x )
{
//if ( x<0 || x>INTEGER_POOL_MAX_VALUE ) {
@@ -65,12 +67,41 @@ namespace Antlr3.Misc
This should be faster than Java's String.replaceAll as that one
uses regex (I only want to play with strings anyway).
*/
-        [Obsolete]
+        [System.Obsolete]
public static string replace( string src, string replacee, string replacer )
{
return src.Replace( replacee, replacer );
}
+#endif
+
+        public static void Resize<T>(this IList<T> list, int size)
+        {
+            if (list == null)
+                throw new ArgumentNullException("list");
+            if (size < 0)
+                throw new ArgumentOutOfRangeException("size");
+
+            if (size == list.Count)
+                return;
+
+            if (size < list.Count)
+            {
+                List<T> asList = list as List<T>;
+                if (asList != null)
+                {
+                    asList.RemoveRange(size, asList.Count);
+                }
+                else
+                {
+                    while (list.Count > size)
+                        list.RemoveAt(list.Count - 1);
+                }
+            }
+            else
+            {
+                while (list.Count < size)
+                    list.Add(default(T));
+            }
+        }
}
}
-
-#endif
diff --git a/Antlr3/Tool/CompositeGrammar.cs b/Antlr3/Tool/CompositeGrammar.cs
index eb3793e..4588a6e 100644
--- a/Antlr3/Tool/CompositeGrammar.cs
+++ b/Antlr3/Tool/CompositeGrammar.cs
@@ -34,8 +34,8 @@ namespace Antlr3.Tool
{
using System.Collections.Generic;
using System.Linq;
-    using Antlr.Runtime.JavaExtensions;
using Antlr3.Grammars;
+    using Antlr3.Misc;

using Label = Antlr3.Analysis.Label;
using NFAState = Antlr3.Analysis.NFAState;
@@ -127,7 +127,7 @@ namespace Antlr3.Tool
// the faux token types take first NUM_FAUX_LABELS positions
// then we must have room for the predefined runtime token types
// like DOWN/UP used for tree parsing.
-            typeToTokenList.setSize( Label.NUM_FAUX_LABELS + Label.MIN_TOKEN_TYPE - 1 );
+            typeToTokenList.Resize( Label.NUM_FAUX_LABELS + Label.MIN_TOKEN_TYPE - 1 );
typeToTokenList[Label.NUM_FAUX_LABELS + Label.INVALID] = "<INVALID>";
typeToTokenList[Label.NUM_FAUX_LABELS + Label.EOT] = "<EOT>";
typeToTokenList[Label.NUM_FAUX_LABELS + Label.SEMPRED] = "<SEMPRED>";
@@ -475,7 +475,7 @@ namespace Antlr3.Tool

public virtual void AddState( NFAState state )
{
-            numberToStateList.setSize( state.StateNumber + 1 ); // make sure we have room
+            numberToStateList.Resize( state.StateNumber + 1 ); // make sure we have room
numberToStateList[state.StateNumber] = state;
}

diff --git a/Antlr3/Tool/Grammar.cs b/Antlr3/Tool/Grammar.cs
index 9365fe1..98a9f15 100644
--- a/Antlr3/Tool/Grammar.cs
+++ b/Antlr3/Tool/Grammar.cs
@@ -35,7 +35,6 @@ namespace Antlr3.Tool
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
-    using Antlr.Runtime.JavaExtensions;
using Antlr3.Analysis;
using Antlr3.Extensions;
using Antlr3.Grammars;
@@ -50,7 +49,6 @@ namespace Antlr3.Tool
using File = System.IO.File;
using IOException = System.IO.IOException;
using IToken = Antlr.Runtime.IToken;
-    using ITree = Antlr.Runtime.Tree.ITree;
using Math = System.Math;
using Path = System.IO.Path;
using RecognitionException = Antlr.Runtime.RecognitionException;
@@ -1940,7 +1938,7 @@ namespace Antlr3.Tool
// track in reverse index too
if ( tokenType >= composite.TypeToStringLiteralList.Count )
{
-                    composite.TypeToStringLiteralList.setSize( tokenType + 1 );
+                    composite.TypeToStringLiteralList.Resize( tokenType + 1 );
}
composite.TypeToStringLiteralList[tokenType] = text;
}
@@ -1954,7 +1952,7 @@ namespace Antlr3.Tool
composite.MaxTokenType = Math.Max( composite.MaxTokenType, tokenType );
if ( index >= composite.TypeToTokenList.Count )
{
-                composite.TypeToTokenList.setSize( index + 1 );
+                composite.TypeToTokenList.Resize( index + 1 );
}
string prevToken = (string)composite.TypeToTokenList[index];
if ( prevToken == null || prevToken[0] == '\'' )
@@ -2000,7 +1998,7 @@ namespace Antlr3.Tool
SetRuleAST( ruleName, tree );
r.SetOptions( options, ruleToken );
r.ArgActionAST = argActionAST;
-            composite.RuleIndexToRuleList.setSize( composite.RuleIndex + 1 );
+            composite.RuleIndexToRuleList.Resize( composite.RuleIndex + 1 );
composite.RuleIndexToRuleList[composite.RuleIndex] = r;
composite.RuleIndex++;
if ( ruleName.StartsWith( SynpredRulePrefix ) )
@@ -3392,7 +3390,7 @@ namespace Antlr3.Tool
Decision d = new Decision();
d.decision = decision;
d.grammar = this;
-            indexToDecision.setSize( NumberOfDecisions );
+            indexToDecision.Resize( NumberOfDecisions );
indexToDecision[index] = d;
return d;
}

