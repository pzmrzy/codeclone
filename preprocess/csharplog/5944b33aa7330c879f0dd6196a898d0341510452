commit 5944b33aa7330c879f0dd6196a898d0341510452
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Thu Aug 4 15:24:34 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Thu Aug 4 15:24:34 2011 -0800

(C# 3) Updated build script and bootstrap binaries

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 9007]

diff --git a/bin/Bootstrap/Antlr3.Runtime.Debug.dll b/bin/Bootstrap/Antlr3.Runtime.Debug.dll
index f893f5c..2937899 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.Debug.dll and b/bin/Bootstrap/Antlr3.Runtime.Debug.dll differ
diff --git a/bin/Bootstrap/Antlr3.Runtime.JavaExtensions.dll b/bin/Bootstrap/Antlr3.Runtime.JavaExtensions.dll
index 6c71bb4..7ff67dc 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.JavaExtensions.dll and b/bin/Bootstrap/Antlr3.Runtime.JavaExtensions.dll differ
diff --git a/bin/Bootstrap/Antlr3.Runtime.dll b/bin/Bootstrap/Antlr3.Runtime.dll
index 8180652..34bd478 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.dll and b/bin/Bootstrap/Antlr3.Runtime.dll differ
diff --git a/bin/Bootstrap/Antlr3.exe b/bin/Bootstrap/Antlr3.exe
index 6b32fd5..89e1f73 100755
Binary files a/bin/Bootstrap/Antlr3.exe and b/bin/Bootstrap/Antlr3.exe differ
diff --git a/bin/Bootstrap/Antlr4.StringTemplate.Visualizer.dll b/bin/Bootstrap/Antlr4.StringTemplate.Visualizer.dll
index ec72842..ba49dbc 100644
Binary files a/bin/Bootstrap/Antlr4.StringTemplate.Visualizer.dll and b/bin/Bootstrap/Antlr4.StringTemplate.Visualizer.dll differ
diff --git a/bin/Bootstrap/Antlr4.StringTemplate.dll b/bin/Bootstrap/Antlr4.StringTemplate.dll
index 8a4198d..e24622e 100644
Binary files a/bin/Bootstrap/Antlr4.StringTemplate.dll and b/bin/Bootstrap/Antlr4.StringTemplate.dll differ
diff --git a/bin/Bootstrap/AntlrBuildTask.dll b/bin/Bootstrap/AntlrBuildTask.dll
index f0f5682..7be3707 100644
Binary files a/bin/Bootstrap/AntlrBuildTask.dll and b/bin/Bootstrap/AntlrBuildTask.dll differ
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp2/CSharp2.stg b/bin/Bootstrap/Codegen/Templates/CSharp2/CSharp2.stg
index b4c7e54..c5e1fd8 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp2/CSharp2.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp2/CSharp2.stg
@@ -1174,7 +1174,7 @@ if (!(<evalPredicate(...)>))
// F i x e d  D F A  (if-then-else)

dfaState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
-int LA<decisionNumber>_<stateNumber> = input.LA(<k>);<\n>
+int LA<decisionNumber>_<k> = input.LA(<k>);<\n>
<edges; separator="\nelse ">
else
{
@@ -1196,7 +1196,7 @@ else
*  expect "if ( LA(1)==X ) match(X);" and that's it.
*/
dfaOptionalBlockState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
-int LA<decisionNumber>_<stateNumber> = input.LA(<k>);<\n>
+int LA<decisionNumber>_<k> = input.LA(<k>);<\n>
<edges; separator="\nelse ">
>>

@@ -1207,7 +1207,7 @@ int LA<decisionNumber>_<stateNumber> = input.LA(<k>);<\n>
*  anything other than 'a' predicts exiting.
*/
dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
-int LA<decisionNumber>_<stateNumber> = input.LA(<k>);<\n>
+int LA<decisionNumber>_<k> = input.LA(<k>);<\n>
<edges; separator="\nelse "><\n>
<if(eotPredictsAlt)>
<if(!edges)>
@@ -1387,12 +1387,22 @@ private int SpecialStateTransition<dfa.decisionNumber>(DFA dfa, int s, IIntStrea
ITreeNodeStream input = (ITreeNodeStream)_input;
<endif>
int _s = s;
-	switch (s)
+	s = -1;
+	<! pull these outside the switch cases to save space on locals !>
+	int LA<dfa.decisionNumber>_1 = input.LA(1);
+	int index<dfa.decisionNumber>_1 = input.Index;
+	switch (_s)
{
-	<dfa.specialStateSTs:{state |
-	case <i0>:<! compressed special state numbers 0..n-1 !>
-		<state>}; separator="\n">
+	<dfa.specialStateSTs:{state |case <i0>:<! compressed special state numbers 0..n-1 !>
+	<state>}; separator="\n">
+
+	default:
+		break;
}
+
+	if (s >= 0)
+		return s;
+
<if(backtracking)>
if (state.backtracking > 0) {state.failed=true; return -1;}
<endif>
@@ -1407,20 +1417,18 @@ private int SpecialStateTransition<dfa.decisionNumber>(DFA dfa, int s, IIntStrea
*  state.
*/
cyclicDFAState(decisionNumber,stateNumber,edges,needErrorClause,semPredState) ::= <<
-int LA<decisionNumber>_<stateNumber> = input.LA(1);<\n>
+{
<if(semPredState)>
-<! get next lookahead symbol to test edges, then rewind !>
-<\n>int index<decisionNumber>_<stateNumber> = input.Index;
-input.Rewind();
+	<! get next lookahead symbol to test edges, then rewind !>
+	input.Rewind();
<endif>
-s = -1;
-<edges; separator="\nelse ">
+	<edges; separator="\nelse ">
<if(semPredState)>
-<! return input cursor to state before we rewound !>
-<\n>input.Seek(index<decisionNumber>_<stateNumber>);
+	<! return input cursor to state before we rewound !>
+	input.Seek(index<decisionNumber>_1);
<endif>
-if (s >= 0) return s;
-break;
+	break;
+}
>>

/** Just like a fixed DFA edge, test the lookahead and indicate what
@@ -1450,7 +1458,7 @@ evalPredicate(pred,description) ::= "(<pred>)"

evalSynPredicate(pred,description) ::= "EvaluatePredicate(<pred>_fragment)"

-lookaheadTest(atom,k,atomAsInt) ::= "LA<decisionNumber>_<stateNumber>==<atom>"
+lookaheadTest(atom,k,atomAsInt) ::= "LA<decisionNumber>_<k>==<atom>"

/** Sometimes a lookahead test cannot assume that LA(k) is in a temp variable
*  somewhere.  Must ask for the lookahead directly.
@@ -1458,7 +1466,7 @@ lookaheadTest(atom,k,atomAsInt) ::= "LA<decisionNumber>_<stateNumber>==<atom>"
isolatedLookaheadTest(atom,k,atomAsInt) ::= "input.LA(<k>)==<atom>"

lookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= <%
-(LA<decisionNumber>_<stateNumber><ge()><lower> && LA<decisionNumber>_<stateNumber><le()><upper>)
+(LA<decisionNumber>_<k><ge()><lower> && LA<decisionNumber>_<k><le()><upper>)
%>

isolatedLookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= "(input.LA(<k>)<ge()><lower> && input.LA(<k>)<le()><upper>)"
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
index a789e8a..bf7ca36 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
@@ -1153,7 +1153,7 @@ if (!(<evalPredicate(...)>))
// F i x e d  D F A  (if-then-else)

dfaState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
-int LA<decisionNumber>_<stateNumber> = input.LA(<k>);<\n>
+int LA<decisionNumber>_<k> = input.LA(<k>);<\n>
<edges; separator="\nelse ">
else
{
@@ -1175,7 +1175,7 @@ else
*  expect "if ( LA(1)==X ) match(X);" and that's it.
*/
dfaOptionalBlockState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
-int LA<decisionNumber>_<stateNumber> = input.LA(<k>);<\n>
+int LA<decisionNumber>_<k> = input.LA(<k>);<\n>
<edges; separator="\nelse ">
>>

@@ -1186,7 +1186,7 @@ int LA<decisionNumber>_<stateNumber> = input.LA(<k>);<\n>
*  anything other than 'a' predicts exiting.
*/
dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
-int LA<decisionNumber>_<stateNumber> = input.LA(<k>);<\n>
+int LA<decisionNumber>_<k> = input.LA(<k>);<\n>
<edges; separator="\nelse "><\n>
<if(eotPredictsAlt)>
<if(!edges)>
@@ -1366,12 +1366,22 @@ private int SpecialStateTransition<dfa.decisionNumber>(DFA dfa, int s, IIntStrea
ITreeNodeStream input = (ITreeNodeStream)_input;
<endif>
int _s = s;
-	switch (s)
+	s = -1;
+	<! pull these outside the switch cases to save space on locals !>
+	int LA<dfa.decisionNumber>_1 = input.LA(1);
+	int index<dfa.decisionNumber>_1 = input.Index;
+	switch (_s)
{
-	<dfa.specialStateSTs:{state |
-	case <i0>:<! compressed special state numbers 0..n-1 !>
-		<state>}; separator="\n">
+	<dfa.specialStateSTs:{state |case <i0>:<! compressed special state numbers 0..n-1 !>
+	<state>}; separator="\n">
+
+	default:
+		break;
}
+
+	if (s >= 0)
+		return s;
+
<if(backtracking)>
if (state.backtracking > 0) {state.failed=true; return -1;}
<endif>
@@ -1386,20 +1396,18 @@ private int SpecialStateTransition<dfa.decisionNumber>(DFA dfa, int s, IIntStrea
*  state.
*/
cyclicDFAState(decisionNumber,stateNumber,edges,needErrorClause,semPredState) ::= <<
-int LA<decisionNumber>_<stateNumber> = input.LA(1);<\n>
+{
<if(semPredState)>
-<! get next lookahead symbol to test edges, then rewind !>
-<\n>int index<decisionNumber>_<stateNumber> = input.Index;
-input.Rewind();
+	<! get next lookahead symbol to test edges, then rewind !>
+	input.Rewind();
<endif>
-s = -1;
-<edges; separator="\nelse ">
+	<edges; separator="\nelse ">
<if(semPredState)>
-<! return input cursor to state before we rewound !>
-<\n>input.Seek(index<decisionNumber>_<stateNumber>);
+	<! return input cursor to state before we rewound !>
+	input.Seek(index<decisionNumber>_1);
<endif>
-if (s >= 0) return s;
-break;
+	break;
+}
>>

/** Just like a fixed DFA edge, test the lookahead and indicate what
@@ -1429,7 +1437,7 @@ evalPredicate(pred,description) ::= "(<pred>)"

evalSynPredicate(pred,description) ::= "EvaluatePredicate(<pred>_fragment)"

-lookaheadTest(atom,k,atomAsInt) ::= "LA<decisionNumber>_<stateNumber>==<atom>"
+lookaheadTest(atom,k,atomAsInt) ::= "LA<decisionNumber>_<k>==<atom>"

/** Sometimes a lookahead test cannot assume that LA(k) is in a temp variable
*  somewhere.  Must ask for the lookahead directly.
@@ -1437,7 +1445,7 @@ lookaheadTest(atom,k,atomAsInt) ::= "LA<decisionNumber>_<stateNumber>==<atom>"
isolatedLookaheadTest(atom,k,atomAsInt) ::= "input.LA(<k>)==<atom>"

lookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= <%
-(LA<decisionNumber>_<stateNumber><ge()><lower> && LA<decisionNumber>_<stateNumber><le()><upper>)
+(LA<decisionNumber>_<k><ge()><lower> && LA<decisionNumber>_<k><le()><upper>)
%>

isolatedLookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= "(input.LA(<k>)<ge()><lower> && input.LA(<k>)<le()><upper>)"
diff --git a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp2.dll b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp2.dll
index 3f6e08c..4091db6 100644
Binary files a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp2.dll and b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp2.dll differ
diff --git a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll
index 904f68f..d661e00 100644
Binary files a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll and b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll differ
diff --git a/bin/prep/prepare.ps1 b/bin/prep/prepare.ps1
index c5577d7..f87b78a 100644
--- a/bin/prep/prepare.ps1
+++ b/bin/prep/prepare.ps1
@@ -167,8 +167,8 @@ copy "..\$BuildConfig\Antlr4.StringTemplate.Visualizer.pdb" ".\ST4"
copy "LICENSE.txt" ".\ST4"

# compress the distributable packages
-$AntlrVersion = "special-3.4.1.8995"
-$STVersion = "special-4.0.5.8995"
+$AntlrVersion = "special-3.4.1.9004"
+$STVersion = "special-4.0.5.9004"

$ArchivePath = ".\dist\antlr-dotnet-csharpbootstrap-" + $AntlrVersion + ".7z"
.\7z.exe a -r -mx9 $ArchivePath ".\Bootstrap\*"

