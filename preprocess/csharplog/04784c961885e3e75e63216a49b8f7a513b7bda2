commit 04784c961885e3e75e63216a49b8f7a513b7bda2
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Mon Apr 5 17:31:20 2010 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Mon Apr 5 17:31:20 2010 -0800

C# Port: Added the RuleType enumeration to clean up the littered char.IsUpper and char.IsLower tests

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 6804]

diff --git a/Antlr3.Test/TestDFAConversion.cs b/Antlr3.Test/TestDFAConversion.cs
index 20f1fee..3ef706f 100644
--- a/Antlr3.Test/TestDFAConversion.cs
+++ b/Antlr3.Test/TestDFAConversion.cs
@@ -1806,7 +1806,7 @@ namespace AntlrUnitTests
HashSet<string> x = new HashSet<string>();
foreach ( Rule r in rules )
{
-                x.Add( r.name );
+                x.Add( r.Name );
}
return x;
}
diff --git a/Antlr3/Analysis/DFAState.cs b/Antlr3/Analysis/DFAState.cs
index 20b039f..ced758e 100644
--- a/Antlr3/Analysis/DFAState.cs
+++ b/Antlr3/Analysis/DFAState.cs
@@ -718,7 +718,7 @@ namespace Antlr3.Analysis
// meaning input "ab" would test preds to decide what to
// do but it should match rule C w/o testing preds.
if ( dfa.nfa.grammar.type != GrammarType.Lexer ||
-                             !dfa.NFADecisionStartState.enclosingRule.name.Equals( Grammar.ArtificialTokensRuleName ) )
+                             !dfa.NFADecisionStartState.enclosingRule.Name.Equals( Grammar.ArtificialTokensRuleName ) )
{
numPotentialConflicts++;
thisStateHasPotentialProblem = true;
diff --git a/Antlr3/Analysis/DecisionProbe.cs b/Antlr3/Analysis/DecisionProbe.cs
index 43b10bc..0bf8dfc 100644
--- a/Antlr3/Analysis/DecisionProbe.cs
+++ b/Antlr3/Analysis/DecisionProbe.cs
@@ -680,7 +680,7 @@ namespace Antlr3.Analysis
NFAState ruleInvocationState = dfa.nfa.GetState( c.state );
Transition transition0 = ruleInvocationState.transition[0];
RuleClosureTransition @ref = (RuleClosureTransition)transition0;
-                    String targetRule = ( (NFAState)@ref.target ).enclosingRule.name;
+                    String targetRule = ( (NFAState)@ref.target ).enclosingRule.Name;
int altI = c.alt;
IDictionary<string, ICollection<NFAState>> targetToCallSiteMap =
altToTargetToCallSitesMap.get( altI );
@@ -1046,7 +1046,7 @@ namespace Antlr3.Analysis
(RuleClosureTransition)decisionLeft.transition[0];
NFAState ruleStartState = (NFAState)ruleCallEdge.target;
//JSystem.@out.println("alt = "+decisionLeft.getEnclosingRule());
-            return ruleStartState.enclosingRule.name;
+            return ruleStartState.enclosingRule.Name;
}

public virtual void Reset()
diff --git a/Antlr3/Analysis/NFAtoDFAConverter.cs b/Antlr3/Analysis/NFAtoDFAConverter.cs
index 74d31c0..f63c47a 100644
--- a/Antlr3/Analysis/NFAtoDFAConverter.cs
+++ b/Antlr3/Analysis/NFAtoDFAConverter.cs
@@ -637,7 +637,7 @@ namespace Antlr3.Analysis
{
if ( debug )
{
-                Console.Out.WriteLine( "closure at " + p.enclosingRule.name + " state " + p.stateNumber + "|" +
+                Console.Out.WriteLine( "closure at " + p.enclosingRule.Name + " state " + p.stateNumber + "|" +
alt + " filling DFA state " + d.stateNumber + " with context " + context
);
}
@@ -662,7 +662,7 @@ namespace Antlr3.Analysis
if ( debug )
{
Console.Out.WriteLine( "avoid visiting exact closure computation NFA config: " +
-                                       proposedNFAConfiguration + " in " + p.enclosingRule.name );
+                                       proposedNFAConfiguration + " in " + p.enclosingRule.Name );
Console.Out.WriteLine( "state is " + d.dfa.decisionNumber + "." + d.stateNumber );
}
return;
diff --git a/Antlr3/Antlr3.csproj b/Antlr3/Antlr3.csproj
index 315042a..4344e8e 100644
--- a/Antlr3/Antlr3.csproj
+++ b/Antlr3/Antlr3.csproj
@@ -172,6 +172,7 @@
<Compile Include="Grammars\TreeToNFAConverterHelper.cs">
<DependentUpon>TreeToNFAConverter.g3</DependentUpon>
</Compile>
+    <Compile Include="Tool\RuleType.cs" />
<Compile Include="Tool\Strip.cs" />
</ItemGroup>
<ItemGroup>
diff --git a/Antlr3/AntlrTool.cs b/Antlr3/AntlrTool.cs
index f86d920..c8a7d76 100644
--- a/Antlr3/AntlrTool.cs
+++ b/Antlr3/AntlrTool.cs
@@ -581,7 +581,7 @@ namespace Antlr3
w.Write( lexerGrammarStr );
w.Close();
}
-                        catch ( IOException e )
+                        catch (IOException)
{
// emit different error message when creating the implicit lexer fails
// due to write permission error
@@ -824,7 +824,7 @@ namespace Antlr3

protected virtual void WriteDOTFile( Grammar g, Rule r, string dot )
{
-            WriteDOTFile( g, r.grammar.name + "." + r.name, dot );
+            WriteDOTFile( g, r.grammar.name + "." + r.Name, dot );
}

protected virtual void WriteDOTFile( Grammar g, string name, string dot )
diff --git a/Antlr3/Codegen/CodeGenerator.cs b/Antlr3/Codegen/CodeGenerator.cs
index 4a5d04e..83a75fc 100644
--- a/Antlr3/Codegen/CodeGenerator.cs
+++ b/Antlr3/Codegen/CodeGenerator.cs
@@ -708,7 +708,7 @@ namespace Antlr3.Codegen
string ruleName = null;
if ( r != null )
{
-                ruleName = r.name;
+                ruleName = r.Name;
}
ICollection<string> actionNameSet = scopeActions.Keys.ToArray();
foreach ( string name in actionNameSet )
@@ -1442,7 +1442,7 @@ namespace Antlr3.Codegen

if ( label != null ||
enclosingRule.GetRuleRefsInAlt( x, outerAltNum ) != null ||
-                 enclosingRule.name.Equals( x ) )
+                 enclosingRule.Name.Equals( x ) )
{
ErrorManager.GrammarError( ErrorManager.MSG_ISOLATED_RULE_SCOPE,
grammar,
diff --git a/Antlr3/Grammars/ANTLR.g3 b/Antlr3/Grammars/ANTLR.g3
index 506d5b9..00bb8c6 100644
--- a/Antlr3/Grammars/ANTLR.g3
+++ b/Antlr3/Grammars/ANTLR.g3
@@ -183,6 +183,8 @@ using Grammar = Antlr3.Tool.Grammar;
using GrammarAST = Antlr3.Tool.GrammarAST;
using GrammarType = Antlr3.Tool.GrammarType;
using IntSet = Antlr3.Misc.IIntSet;
+using Rule = Antlr3.Tool.Rule;
+using RuleType = Antlr3.Tool.RuleType;
using StringBuffer = System.Text.StringBuilder;
using TokenWithIndex = Antlr.Runtime.CommonToken;
}
@@ -537,7 +539,7 @@ ebnf
-> ^(POSITIVE_CLOSURE[$start,"+"] block)
|	IMPLIES // syntactic predicate
// ignore for lexer rules in combined
-			-> {GrammarType == GrammarType.Combined && char.IsUpper(currentRuleName[0])}? ^(SYNPRED[$start,"=>"] block)
+			-> {GrammarType == GrammarType.Combined && Rule.GetRuleType(currentRuleName) == RuleType.Lexer}? ^(SYNPRED[$start,"=>"] block)
// create manually specified (...)=> predicate; convert to sempred
-> {CreateSynSemPredFromBlock($block.tree, SYN_SEMPRED)}
|	ROOT
diff --git a/Antlr3/Grammars/ANTLRParserHelper.cs b/Antlr3/Grammars/ANTLRParserHelper.cs
index dd68cfb..a9e6d77 100644
--- a/Antlr3/Grammars/ANTLRParserHelper.cs
+++ b/Antlr3/Grammars/ANTLRParserHelper.cs
@@ -43,6 +43,8 @@ namespace Antlr3.Grammars
using GrammarType = Antlr3.Tool.GrammarType;
using IToken = Antlr.Runtime.IToken;
using RecognitionException = Antlr.Runtime.RecognitionException;
+    using Rule = Antlr3.Tool.Rule;
+    using RuleType = Antlr3.Tool.RuleType;

partial class ANTLRParser
{
@@ -265,7 +267,7 @@ namespace Antlr3.Grammars
}
if ( autoBacktrack != null && autoBacktrack.Equals( "true" ) &&
!( GrammarType == GrammarType.Combined &&
-                 char.IsUpper( currentRuleName[0] ) ) &&
+                 Rule.GetRuleType(currentRuleName) == RuleType.Lexer) &&
alt.GetChild( 0 ).Type != SYN_SEMPRED )
{
// duplicate alt and make a synpred block around that dup'd alt
diff --git a/Antlr3/Grammars/ActionAnalysisLexer.g3 b/Antlr3/Grammars/ActionAnalysisLexer.g3
index 0a28e6c..63f61f0 100644
--- a/Antlr3/Grammars/ActionAnalysisLexer.g3
+++ b/Antlr3/Grammars/ActionAnalysisLexer.g3
@@ -93,7 +93,7 @@ X_Y
{
AttributeScope scope = null;
string refdRuleName = null;
-			if ( $x.text.Equals(enclosingRule.name) )
+			if ( $x.text.Equals(enclosingRule.Name) )
{
// ref to enclosing rule.
refdRuleName = $x.text;
@@ -147,7 +147,7 @@ Y
if ( scope!=null &&
(scope.isPredefinedRuleScope||scope.isPredefinedLexerRuleScope) )
{
-				grammar.ReferenceRuleLabelPredefinedAttribute(enclosingRule.name);
+				grammar.ReferenceRuleLabelPredefinedAttribute(enclosingRule.Name);
//System.out.println("referenceRuleLabelPredefinedAttribute for "+$ID.text);
}
}
diff --git a/Antlr3/Grammars/ActionTranslator.g3 b/Antlr3/Grammars/ActionTranslator.g3
index 68ae676..f736cee 100644
--- a/Antlr3/Grammars/ActionTranslator.g3
+++ b/Antlr3/Grammars/ActionTranslator.g3
@@ -90,7 +90,7 @@ using StringTemplate = Antlr3.ST.StringTemplate;
SET_ENCLOSING_RULE_SCOPE_ATTR
:	'$' x=ID '.' y=ID WS? '=' expr=ATTR_VALUE_EXPR ';'
{enclosingRule!=null &&
-	                         $x.text.Equals(enclosingRule.name) &&
+	                         $x.text.Equals(enclosingRule.Name) &&
enclosingRule.GetLocalAttributeScope($y.text)!=null}?
//{JSystem.@out.println("found \$rule.attr");}
{
@@ -141,7 +141,7 @@ SET_ENCLOSING_RULE_SCOPE_ATTR
;
ENCLOSING_RULE_SCOPE_ATTR
:	'$' x=ID '.' y=ID	{enclosingRule!=null &&
-	                         $x.text.Equals(enclosingRule.name) &&
+	                         $x.text.Equals(enclosingRule.Name) &&
enclosingRule.GetLocalAttributeScope($y.text)!=null}?
//{JSystem.@out.println("found \$rule.attr");}
{
@@ -431,8 +431,8 @@ SET_LOCAL_ATTR
if ($ID.text.Equals("tree") || $ID.text.Equals("st"))
{
st = Template("ruleSetPropertyRef_"+$ID.text);
-					grammar.ReferenceRuleLabelPredefinedAttribute(enclosingRule.name);
-					st.SetAttribute("scope", enclosingRule.name);
+					grammar.ReferenceRuleLabelPredefinedAttribute(enclosingRule.Name);
+					st.SetAttribute("scope", enclosingRule.Name);
st.SetAttribute("attr", $ID.text);
st.SetAttribute("expr", TranslateAction($expr.text));
}
@@ -469,14 +469,14 @@ LOCAL_ATTR
if ( scope.isPredefinedRuleScope )
{
st = Template("rulePropertyRef_"+$ID.text);
-				grammar.ReferenceRuleLabelPredefinedAttribute(enclosingRule.name);
-				st.SetAttribute("scope", enclosingRule.name);
+				grammar.ReferenceRuleLabelPredefinedAttribute(enclosingRule.Name);
+				st.SetAttribute("scope", enclosingRule.Name);
st.SetAttribute("attr", $ID.text);
}
else if ( scope.isPredefinedLexerRuleScope )
{
st = Template("lexerRulePropertyRef_"+$ID.text);
-				st.SetAttribute("scope", enclosingRule.name);
+				st.SetAttribute("scope", enclosingRule.Name);
st.SetAttribute("attr", $ID.text);
}
else if ( scope.isParameterScope )
@@ -618,7 +618,7 @@ TEMPLATE_INSTANCE
string ruleName = "<outside-of-rule>";
if ( enclosingRule!=null )
{
-				ruleName = enclosingRule.name;
+				ruleName = enclosingRule.Name;
}
StringTemplate st =
generator.TranslateTemplateConstructor(ruleName,
@@ -639,7 +639,7 @@ INDIRECT_TEMPLATE_INSTANCE
{
string action = $text.Substring( 1, $text.Length - 1 );
StringTemplate st =
-				generator.TranslateTemplateConstructor(enclosingRule.name,
+				generator.TranslateTemplateConstructor(enclosingRule.Name,
outerAltNum,
actionToken,
action);
diff --git a/Antlr3/Grammars/ActionTranslatorHelper.cs b/Antlr3/Grammars/ActionTranslatorHelper.cs
index 3836143..2a60a49 100644
--- a/Antlr3/Grammars/ActionTranslatorHelper.cs
+++ b/Antlr3/Grammars/ActionTranslatorHelper.cs
@@ -116,7 +116,7 @@ namespace Antlr3.Grammars
string rname = null;
if ( enclosingRule != null )
{
-                rname = enclosingRule.name;
+                rname = enclosingRule.Name;
}
ActionTranslator translator =
new ActionTranslator( generator,
diff --git a/Antlr3/Grammars/CodeGenTreeWalker.g3 b/Antlr3/Grammars/CodeGenTreeWalker.g3
index 8d9dbee..68157c4 100644
--- a/Antlr3/Grammars/CodeGenTreeWalker.g3
+++ b/Antlr3/Grammars/CodeGenTreeWalker.g3
@@ -250,7 +250,7 @@ rule returns [StringTemplate code=null]
else
{
if ( !(grammar.type==GrammarType.Combined &&
-						 char.IsUpper(currentRuleName[0])) )
+						 Rule.GetRuleType(currentRuleName) == RuleType.Lexer) )
{
stName = "rule";
}
diff --git a/Antlr3/Grammars/CodeGenTreeWalkerHelper.cs b/Antlr3/Grammars/CodeGenTreeWalkerHelper.cs
index 3ec0b19..94ce7da 100644
--- a/Antlr3/Grammars/CodeGenTreeWalkerHelper.cs
+++ b/Antlr3/Grammars/CodeGenTreeWalkerHelper.cs
@@ -48,6 +48,7 @@ namespace Antlr3.Grammars
using NoViableAltException = Antlr.Runtime.NoViableAltException;
using RecognitionException = Antlr.Runtime.RecognitionException;
using Rule = Antlr3.Tool.Rule;
+    using RuleType = Antlr3.Tool.RuleType;
using StringTemplate = Antlr3.ST.StringTemplate;
using StringTemplateGroup = Antlr3.ST.StringTemplateGroup;

@@ -147,7 +148,7 @@ namespace Antlr3.Grammars
string label )
{
bool tryUnchecked = false;
-            if ( name == "matchSet" && !string.IsNullOrEmpty( elementAST.enclosingRuleName ) && char.IsUpper( elementAST.enclosingRuleName[0] ) )
+            if (name == "matchSet" && !string.IsNullOrEmpty(elementAST.enclosingRuleName) && Rule.GetRuleType(elementAST.enclosingRuleName) == RuleType.Lexer)
{
if ( ( elementAST.Parent.Type == ANTLRLexer.ALT && elementAST.Parent.Parent.Parent.Type == RULE && elementAST.Parent.Parent.ChildCount == 2 )
|| ( elementAST.Parent.Type == ANTLRLexer.NOT && elementAST.Parent.Parent.Parent.Parent.Type == RULE && elementAST.Parent.Parent.Parent.ChildCount == 2 ) )
diff --git a/Antlr3/Grammars/DefineGrammarItemsWalker.g3 b/Antlr3/Grammars/DefineGrammarItemsWalker.g3
index 66f4718..ef46ed5 100644
--- a/Antlr3/Grammars/DefineGrammarItemsWalker.g3
+++ b/Antlr3/Grammars/DefineGrammarItemsWalker.g3
@@ -202,7 +202,7 @@ rule
{
name = $id.text;
currentRuleName = name;
-				if ( char.IsUpper(name[0]) && grammar.type==GrammarType.Combined )
+				if ( Rule.GetRuleType(name) == RuleType.Lexer && grammar.type==GrammarType.Combined )
{
// a merged grammar spec, track lexer rules and send to another grammar
grammar.DefineLexerRuleFoundInParser($id.token, $start);
@@ -275,7 +275,7 @@ scope AttributeScopeActions;
:	^(	'scope'
(	attrScopeAction* attrs=ACTION
{
-					r.ruleScope = grammar.CreateRuleScope(r.name,$attrs.token);
+					r.ruleScope = grammar.CreateRuleScope(r.Name,$attrs.token);
r.ruleScope.isDynamicRuleScope = true;
r.ruleScope.AddAttributes($attrs.text, ';');
foreach ( var action in $AttributeScopeActions::actions )
diff --git a/Antlr3/Grammars/DefineGrammarItemsWalkerHelper.cs b/Antlr3/Grammars/DefineGrammarItemsWalkerHelper.cs
index 73fa4ec..ee982cd 100644
--- a/Antlr3/Grammars/DefineGrammarItemsWalkerHelper.cs
+++ b/Antlr3/Grammars/DefineGrammarItemsWalkerHelper.cs
@@ -91,7 +91,7 @@ namespace Antlr3.Grammars

string ruleName = p.GetChild( i ).GetChild( 0 ).Text;
//Console.Out.WriteLine( "rule " + ruleName + " prev=" + prev.getText() );
-                if ( char.IsUpper( ruleName[0] ) )
+                if (Rule.GetRuleType(ruleName) == RuleType.Lexer)
{
// remove lexer rule
p.DeleteChild( i );
diff --git a/Antlr3/Grammars/TreeToNFAConverter.g3 b/Antlr3/Grammars/TreeToNFAConverter.g3
index 750c433..390069b 100644
--- a/Antlr3/Grammars/TreeToNFAConverter.g3
+++ b/Antlr3/Grammars/TreeToNFAConverter.g3
@@ -140,8 +140,7 @@ rule
// a single ALT block
g = factory.BuildAlternativeBlockFromSet(g);
}
-				if ( char.IsLower(currentRuleName[0]) ||
-					 grammar.type==GrammarType.Lexer )
+				if (Rule.GetRuleType(currentRuleName) == RuleType.Parser || grammar.type==GrammarType.Lexer)
{
// attach start node to block for this rule
Rule thisR = grammar.GetLocallyDefinedRule(currentRuleName);
diff --git a/Antlr3/Tool/AssignTokenTypesBehavior.cs b/Antlr3/Tool/AssignTokenTypesBehavior.cs
index 70164c4..a57a915 100644
--- a/Antlr3/Tool/AssignTokenTypesBehavior.cs
+++ b/Antlr3/Tool/AssignTokenTypesBehavior.cs
@@ -107,7 +107,7 @@ namespace Antlr3.Tool
// otherwise add literal to token types if referenced from parser rule
// or in the tokens{} section
if ( ( currentRuleName == null ||
-                  char.IsLower( currentRuleName[0] ) ) &&
+                  Rule.GetRuleType(currentRuleName) == RuleType.Parser) &&
grammar.GetTokenType( t.Text ) == Label.INVALID )
{
stringLiterals[t.Text] = UnassignedInParserRule;
@@ -133,7 +133,7 @@ namespace Antlr3.Tool
// imported token names might exist, only add if new
if ( grammar.type == GrammarType.Lexer || grammar.type == GrammarType.Combined )
{
-                if ( !char.IsUpper( t.Text[0] ) )
+                if (Rule.GetRuleType(t.Text) == RuleType.Parser)
{
return;
}
diff --git a/Antlr3/Tool/CompositeGrammar.cs b/Antlr3/Tool/CompositeGrammar.cs
index 374a7b9..8b70013 100644
--- a/Antlr3/Tool/CompositeGrammar.cs
+++ b/Antlr3/Tool/CompositeGrammar.cs
@@ -308,7 +308,7 @@ namespace Antlr3.Tool
HashSet<Rule> rules = GetAllImportedRules( g );
foreach ( Rule r in rules.ToArray() )
{
-                Rule localRule = g.GetLocallyDefinedRule( r.name );
+                Rule localRule = g.GetLocallyDefinedRule( r.Name );
// if locally defined or it's not local but synpred, don't make a delegation method
if ( localRule != null || r.isSynPred )
{
@@ -335,9 +335,9 @@ namespace Antlr3.Tool
// name as been seen.  (can't use removeAll; wrong hashcode/equals on Rule)
foreach ( Rule r in grammar.Rules )
{
-                    if ( !ruleNames.Contains( r.name ) )
+                    if ( !ruleNames.Contains( r.Name ) )
{
-                        ruleNames.Add( r.name ); // track that we've seen this
+                        ruleNames.Add( r.Name ); // track that we've seen this
rules.Add( r );
}
}
@@ -466,14 +466,14 @@ namespace Antlr3.Tool
// compute set of non-overridden rules for this delegate
foreach ( Rule r in p.grammar.Rules )
{
-                if ( !ruleDefs.Contains( r.name ) )
+                if ( !ruleDefs.Contains( r.Name ) )
{
-                    localRuleDefs.Add( r.name );
+                    localRuleDefs.Add( r.Name );
}
-                else if ( !r.name.Equals( Grammar.ArtificialTokensRuleName ) )
+                else if ( !r.Name.Equals( Grammar.ArtificialTokensRuleName ) )
{
// record any overridden rule 'cept tokens rule
-                    overrides.Add( r.name );
+                    overrides.Add( r.Name );
}
}
//System.Console.Out.WriteLine( "rule defs for " + p.grammar.name + ": " + localRuleDefs );
diff --git a/Antlr3/Tool/DOTGenerator.cs b/Antlr3/Tool/DOTGenerator.cs
index 4054142..55bf392 100644
--- a/Antlr3/Tool/DOTGenerator.cs
+++ b/Antlr3/Tool/DOTGenerator.cs
@@ -273,11 +273,11 @@ namespace Antlr3.Tool
edgeST = stlib.GetInstanceOf( Path.Combine( dfaTemplateDirectoryName, "edge" ) );
if ( rr.rule.grammar != grammar )
{
-                        edgeST.SetAttribute( "label", "<" + rr.rule.grammar.name + "." + rr.rule.name + ">" );
+                        edgeST.SetAttribute( "label", "<" + rr.rule.grammar.name + "." + rr.rule.Name + ">" );
}
else
{
-                        edgeST.SetAttribute( "label", "<" + rr.rule.name + ">" );
+                        edgeST.SetAttribute( "label", "<" + rr.rule.Name + ">" );
}
edgeST.SetAttribute( "src", GetStateLabel( s ) );
edgeST.SetAttribute( "target", GetStateLabel( rr.followState ) );
diff --git a/Antlr3/Tool/Grammar.cs b/Antlr3/Tool/Grammar.cs
index d7c9c58..42ee63a 100644
--- a/Antlr3/Tool/Grammar.cs
+++ b/Antlr3/Tool/Grammar.cs
@@ -1374,7 +1374,7 @@ namespace Antlr3.Tool

foreach ( Rule r in Rules )
{
-                string ruleName = r.name;
+                string ruleName = r.Name;
NFAState ruleBeginState = factory.NewState();
ruleBeginState.Description = "rule " + ruleName + " start";
ruleBeginState.enclosingRule = r;
@@ -1467,14 +1467,14 @@ namespace Antlr3.Tool
if ( composite.watchNFAConversion )
{
Console.Out.WriteLine( "ignoring decision " + decision +
-                                               " within left-recursive rule " + decisionStartState.enclosingRule.name );
+                                               " within left-recursive rule " + decisionStartState.enclosingRule.Name );
}
continue;
}
if ( !externalAnalysisAbort && decisionStartState.NumberOfTransitions > 1 )
{
Rule r = decisionStartState.enclosingRule;
-                        if ( r.isSynPred && !synPredNamesUsedInDFA.Contains( r.name ) )
+                        if ( r.isSynPred && !synPredNamesUsedInDFA.Contains( r.Name ) )
{
continue;
}
@@ -1553,7 +1553,7 @@ namespace Antlr3.Tool
public virtual DFA CreateLL_1_LookaheadDFA( int decision )
{
Decision d = GetDecision( decision );
-            string enclosingRule = d.startState.enclosingRule.name;
+            string enclosingRule = d.startState.enclosingRule.Name;
Rule r = d.startState.enclosingRule;
NFAState decisionStartState = GetDecisionNFAStartState( decision );

@@ -1749,7 +1749,7 @@ namespace Antlr3.Tool
public virtual DFA CreateLookaheadDFA( int decision, bool wackTempStructures )
{
Decision d = GetDecision( decision );
-            string enclosingRule = d.startState.enclosingRule.name;
+            string enclosingRule = d.startState.enclosingRule.Name;
Rule r = d.startState.enclosingRule;

//JSystem.@out.println("createLookaheadDFA(): "+enclosingRule+" dec "+decision+"; synprednames prev used "+synPredNamesUsedInDFA);
@@ -1900,7 +1900,7 @@ namespace Antlr3.Tool
}

if ( ( type == GrammarType.Parser || type == GrammarType.TreeParser ) &&
-                 char.IsUpper( ruleName[0] ) )
+                 Rule.GetRuleType(ruleName) == RuleType.Lexer)
{
ErrorManager.GrammarError( ErrorManager.MSG_LEXER_RULES_NOT_ALLOWED,
this, ruleToken, ruleName );
@@ -2192,7 +2192,7 @@ namespace Antlr3.Tool
Rule r = composite.ruleIndexToRuleList[ruleIndex];
if ( r != null )
{
-                return r.name;
+                return r.Name;
}
return null;
}
@@ -2401,14 +2401,14 @@ namespace Antlr3.Tool
var actions = r.InlineActions;
foreach ( GrammarAST actionAST in actions )
{
-                    ActionAnalysisLexer sniffer = new ActionAnalysisLexer( this, r.name, actionAST );
+                    ActionAnalysisLexer sniffer = new ActionAnalysisLexer( this, r.Name, actionAST );
sniffer.Analyze();
}
// walk any named actions like @init, @after
IEnumerable<GrammarAST> namedActions = r.Actions.Values.Cast<GrammarAST>();
foreach ( GrammarAST actionAST in namedActions )
{
-                    ActionAnalysisLexer sniffer = new ActionAnalysisLexer( this, r.name, actionAST );
+                    ActionAnalysisLexer sniffer = new ActionAnalysisLexer( this, r.Name, actionAST );
sniffer.Analyze();
}
}
@@ -2433,12 +2433,12 @@ namespace Antlr3.Tool
/** A label on a rule is useless if the rule has no return value, no
*  tree or template output, and it is not referenced in an action.
*/
-        protected virtual void RemoveUselessLabels( IDictionary ruleToElementLabelPairMap )
+        protected virtual void RemoveUselessLabels( IDictionary<string, LabelElementPair> ruleToElementLabelPairMap )
{
if ( ruleToElementLabelPairMap == null )
return;

-            var tokill = from pair in ruleToElementLabelPairMap.Values.Cast<LabelElementPair>()
+            var tokill = from pair in ruleToElementLabelPairMap.Values
let rule = GetRule( pair.elementRef.Text )
where rule != null && !rule.HasReturnValue && !pair.actionReferencesLabel
select pair.label.Text;
diff --git a/Antlr3/Tool/GrammarAnalysisAbortedMessage.cs b/Antlr3/Tool/GrammarAnalysisAbortedMessage.cs
index 1250c3b..7434074 100644
--- a/Antlr3/Tool/GrammarAnalysisAbortedMessage.cs
+++ b/Antlr3/Tool/GrammarAnalysisAbortedMessage.cs
@@ -60,7 +60,7 @@ namespace Antlr3.Tool
}
StringTemplate st = GetMessageTemplate();
st.SetAttribute( "enclosingRule",
-                            probe.dfa.NFADecisionStartState.enclosingRule.name );
+                            probe.dfa.NFADecisionStartState.enclosingRule.Name );

return base.ToString( st );
}
diff --git a/Antlr3/Tool/GrammarReport.cs b/Antlr3/Tool/GrammarReport.cs
index 31a2926..2ed8b26 100644
--- a/Antlr3/Tool/GrammarReport.cs
+++ b/Antlr3/Tool/GrammarReport.cs
@@ -39,6 +39,7 @@ namespace Antlr3.Tool
using DFA = Antlr3.Analysis.DFA;
using Stats = Antlr.Runtime.Misc.Stats;
using StringBuilder = System.Text.StringBuilder;
+    using StringComparison = System.StringComparison;

public class GrammarReport
{
@@ -75,8 +76,7 @@ namespace Antlr3.Tool
int totalNonSynPredRules = 0;
foreach ( Rule r in grammar.Rules )
{
-                if ( !r.name.ToUpperInvariant()
-                    .StartsWith( Grammar.SynpredRulePrefix.ToUpperInvariant() ) )
+                if ( !r.Name.StartsWith( Grammar.SynpredRulePrefix, StringComparison.InvariantCultureIgnoreCase ) )
{
totalNonSynPredProductions += r.numberOfAlts;
totalNonSynPredRules++;
@@ -247,7 +247,7 @@ namespace Antlr3.Tool
}
decisions.Add( dfa.decisionNumber );
buf.Append( "Rule " );
-                buf.Append( dfa.NFADecisionStartState.enclosingRule.name );
+                buf.Append( dfa.NFADecisionStartState.enclosingRule.Name );
buf.Append( " decision " );
buf.Append( dfa.decisionNumber );
buf.Append( " location " );
diff --git a/Antlr3/Tool/GrammarSanity.cs b/Antlr3/Tool/GrammarSanity.cs
index da4b484..86828fc 100644
--- a/Antlr3/Tool/GrammarSanity.cs
+++ b/Antlr3/Tool/GrammarSanity.cs
@@ -220,7 +220,7 @@ namespace Antlr3.Tool
ErrorManager.MSG_RULE_HAS_NO_ARGS,
grammar,
argsAST.Token,
-                            r.name );
+                            r.Name );
}
}
else
@@ -233,7 +233,7 @@ namespace Antlr3.Tool
ErrorManager.MSG_MISSING_RULE_ARGS,
grammar,
refAST.Token,
-                            r.name );
+                            r.Name );
}
}
}
@@ -262,7 +262,7 @@ namespace Antlr3.Tool
ErrorManager.MSG_RULE_HAS_NO_ARGS,
grammar,
argsAST.Token,
-                            r.name );
+                            r.Name );
}
}
else
@@ -275,7 +275,7 @@ namespace Antlr3.Tool
ErrorManager.MSG_MISSING_RULE_ARGS,
grammar,
refAST.Token,
-                            r.name );
+                            r.Name );
}
}
}
diff --git a/Antlr3/Tool/Interpreter.cs b/Antlr3/Tool/Interpreter.cs
index 9582985..f526dfd 100644
--- a/Antlr3/Tool/Interpreter.cs
+++ b/Antlr3/Tool/Interpreter.cs
@@ -251,7 +251,7 @@ namespace Antlr3.Tool
NFAState s = start;
if ( actions != null )
{
-                actions.EnterRule( s.nfa.grammar.FileName, start.enclosingRule.name );
+                actions.EnterRule( s.nfa.grammar.FileName, start.enclosingRule.Name );
}
int t = input.LA( 1 );
while ( s != stop )
@@ -315,7 +315,7 @@ namespace Antlr3.Tool
{ // end of rule node
if ( actions != null )
{
-                        actions.ExitRule( s.nfa.grammar.FileName, s.enclosingRule.name );
+                        actions.ExitRule( s.nfa.grammar.FileName, s.enclosingRule.Name );
}
if ( ruleInvocationStack.Count == 0 )
{
@@ -338,7 +338,7 @@ namespace Antlr3.Tool
{
FailedPredicateException fpe =
new FailedPredicateException( input,
-                                                     s.enclosingRule.name,
+                                                     s.enclosingRule.Name,
"can't deal with predicates yet" );
if ( actions != null )
{
@@ -357,7 +357,7 @@ namespace Antlr3.Tool
//Console.Out.WriteLine( "call " + s.enclosingRule.name + " from " + s.nfa.grammar.getFileName() );
if ( actions != null )
{
-                            actions.EnterRule( s.nfa.grammar.FileName, s.enclosingRule.name );
+                            actions.EnterRule( s.nfa.grammar.FileName, s.enclosingRule.Name );
}
// could be jumping to new grammar, make sure DFA created
if ( !s.nfa.grammar.AllDecisionDFAHaveBeenCreated )
@@ -418,7 +418,7 @@ namespace Antlr3.Tool
{
FailedPredicateException fpe =
new FailedPredicateException( input,
-                                                         s.enclosingRule.name,
+                                                         s.enclosingRule.Name,
label.SemanticContext.ToString() );
if ( actions != null )
{
@@ -436,7 +436,7 @@ namespace Antlr3.Tool
//Console.Out.WriteLine( "hit stop state for " + stop.enclosingRule );
if ( actions != null )
{
-                actions.ExitRule( s.nfa.grammar.FileName, stop.enclosingRule.name );
+                actions.ExitRule( s.nfa.grammar.FileName, stop.enclosingRule.Name );
}
}

diff --git a/Antlr3/Tool/NameSpaceChecker.cs b/Antlr3/Tool/NameSpaceChecker.cs
index 0ab369e..7ee7819 100644
--- a/Antlr3/Tool/NameSpaceChecker.cs
+++ b/Antlr3/Tool/NameSpaceChecker.cs
@@ -101,7 +101,7 @@ namespace Antlr3.Tool
grammar,
r.tree.Token,
key,
-                            r.name );
+                            r.Name );
}
}
}
@@ -109,16 +109,16 @@ namespace Antlr3.Tool

protected virtual void CheckForRuleDefinitionProblems( Rule r )
{
-            string ruleName = r.name;
+            string ruleName = r.Name;
IToken ruleToken = r.tree.Token;
int msgID = 0;
if ( ( grammar.type == GrammarType.Parser || grammar.type == GrammarType.TreeParser ) &&
-                 char.IsUpper( ruleName[0] ) )
+                 Rule.GetRuleType(ruleName) == RuleType.Lexer)
{
msgID = ErrorManager.MSG_LEXER_RULES_NOT_ALLOWED;
}
else if ( grammar.type == GrammarType.Lexer &&
-                      char.IsLower( ruleName[0] ) &&
+                      Rule.GetRuleType(ruleName) == RuleType.Parser &&
!r.isSynPred )
{
msgID = ErrorManager.MSG_PARSER_RULES_NOT_ALLOWED;
@@ -226,16 +226,16 @@ namespace Antlr3.Tool
int msgID = 0;
object arg2 = null;
string attrName = attribute.Name;
-            if ( r.name.Equals( attrName ) )
+            if ( r.Name.Equals( attrName ) )
{
msgID = ErrorManager.MSG_ATTRIBUTE_CONFLICTS_WITH_RULE;
-                arg2 = r.name;
+                arg2 = r.Name;
}
else if ( ( r.returnScope != null && r.returnScope.GetAttribute( attrName ) != null ) ||
( r.parameterScope != null && r.parameterScope.GetAttribute( attrName ) != null ) )
{
msgID = ErrorManager.MSG_ATTRIBUTE_CONFLICTS_WITH_RULE_ARG_RETVAL;
-                arg2 = r.name;
+                arg2 = r.Name;
}
if ( msgID != 0 )
{
@@ -267,13 +267,13 @@ namespace Antlr3.Tool
else if ( r.ruleScope != null && r.ruleScope.GetAttribute( label.Text ) != null )
{
msgID = ErrorManager.MSG_LABEL_CONFLICTS_WITH_RULE_SCOPE_ATTRIBUTE;
-                arg2 = r.name;
+                arg2 = r.Name;
}
else if ( ( r.returnScope != null && r.returnScope.GetAttribute( label.Text ) != null ) ||
( r.parameterScope != null && r.parameterScope.GetAttribute( label.Text ) != null ) )
{
msgID = ErrorManager.MSG_LABEL_CONFLICTS_WITH_RULE_ARG_RETVAL;
-                arg2 = r.name;
+                arg2 = r.Name;
}
if ( msgID != 0 )
{
diff --git a/Antlr3/Tool/NonRegularDecisionMessage.cs b/Antlr3/Tool/NonRegularDecisionMessage.cs
index ba2f8e9..c0003bf 100644
--- a/Antlr3/Tool/NonRegularDecisionMessage.cs
+++ b/Antlr3/Tool/NonRegularDecisionMessage.cs
@@ -63,7 +63,7 @@ namespace Antlr3.Tool
}

StringTemplate st = GetMessageTemplate();
-            string ruleName = probe.dfa.NFADecisionStartState.enclosingRule.name;
+            string ruleName = probe.dfa.NFADecisionStartState.enclosingRule.Name;
st.SetAttribute( "ruleName", ruleName );
List<int> sortedAlts = new List<int>();
sortedAlts.addAll( altsWithRecursion );
diff --git a/Antlr3/Tool/Rule.cs b/Antlr3/Tool/Rule.cs
index 2805d84..84f3bf4 100644
--- a/Antlr3/Tool/Rule.cs
+++ b/Antlr3/Tool/Rule.cs
@@ -49,7 +49,7 @@ namespace Antlr3.Tool
/** Combine the info associated with a rule. */
public class Rule
{
-        public string name;
+        private readonly string _name;
public int index;
public string modifier;
public NFAState startState;
@@ -131,14 +131,14 @@ namespace Antlr3.Tool
*  for errors.  A better name is probably namedActions, but I don't
*  want everyone to have to change their code gen templates now.
*/
-        IDictionary<string, object> actions = new Dictionary<string, object>();
+        private IDictionary<string, object> actions = new Dictionary<string, object>();

/** Track all executable actions other than named actions like @init.
*  Also tracks exception handlers, predicates, and rewrite rewrites.
*  We need to examine these actions before code generation so
*  that we can detect refs to $rule.attr etc...
*/
-        IList<GrammarAST> inlineActions = new List<GrammarAST>();
+        private IList<GrammarAST> inlineActions = new List<GrammarAST>();

public int numberOfAlts;

@@ -153,7 +153,7 @@ namespace Antlr3.Tool
*
*  Rewrite rules force tracking of all tokens.
*/
-        IDictionary<string, IList<GrammarAST>>[] altToTokenRefMap;
+        private IDictionary<string, IList<GrammarAST>>[] altToTokenRefMap;

/** Each alt has a Map&lt;ruleRefName,List&lt;ruleRefAST&gt;&gt;; range 1..numberOfAlts
*  So, if there are 3 expr refs in a rule's alt number 2, you'll have
@@ -163,10 +163,10 @@ namespace Antlr3.Tool
*
*  Rewrite rules force tracking of all rule result ASTs. 1..n
*/
-        IDictionary<string, IList<GrammarAST>>[] altToRuleRefMap;
+        private IDictionary<string, IList<GrammarAST>>[] altToRuleRefMap;

/** Track which alts have rewrite rules associated with them. 1..n */
-        bool[] altsWithRewrites;
+        private bool[] altsWithRewrites;

/** Do not generate start, stop etc... in a return value struct unless
*  somebody references $r.start somewhere.
@@ -182,7 +182,7 @@ namespace Antlr3.Tool
int ruleIndex,
int numberOfAlts )
{
-            this.name = ruleName;
+            this._name = ruleName;
this.index = ruleIndex;
this.numberOfAlts = numberOfAlts;
this.grammar = grammar;
@@ -198,6 +198,7 @@ namespace Antlr3.Tool
}

#region Properties
+
public IDictionary<string, object> Actions
{
get
@@ -205,6 +206,7 @@ namespace Antlr3.Tool
return actions;
}
}
+
public bool HasMultipleReturnValues
{
get
@@ -212,6 +214,7 @@ namespace Antlr3.Tool
return GetHasMultipleReturnValues();
}
}
+
public bool HasReturnValue
{
get
@@ -219,6 +222,7 @@ namespace Antlr3.Tool
return GetHasReturnValue();
}
}
+
public bool HasSingleReturnValue
{
get
@@ -226,6 +230,7 @@ namespace Antlr3.Tool
return GetHasSingleReturnValue();
}
}
+
public ICollection<GrammarAST> InlineActions
{
get
@@ -233,22 +238,41 @@ namespace Antlr3.Tool
return GetInlineActions();
}
}
+
+        public string Name
+        {
+            get
+            {
+                return _name;
+            }
+        }
+
[CLSCompliant(false)]
-        public IDictionary RuleLabels
+        public IDictionary<string, Grammar.LabelElementPair> RuleLabels
{
get
{
return GetRuleLabels();
}
}
+
[CLSCompliant(false)]
-        public IDictionary RuleListLabels
+        public IDictionary<string, Grammar.LabelElementPair> RuleListLabels
{
get
{
return GetRuleListLabels();
}
}
+
+        public RuleType RuleType
+        {
+            get
+            {
+                return GetRuleType(Name);
+            }
+        }
+
public string SingleValueReturnName
{
get
@@ -256,6 +280,7 @@ namespace Antlr3.Tool
return GetSingleValueReturnName();
}
}
+
public string SingleValueReturnType
{
get
@@ -263,8 +288,14 @@ namespace Antlr3.Tool
return GetSingleValueReturnType();
}
}
+
#endregion

+        public static RuleType GetRuleType(string name)
+        {
+            return char.IsUpper(name[0]) ? RuleType.Lexer : RuleType.Parser;
+        }
+
public virtual void DefineLabel( IToken label, GrammarAST elementRef, LabelType type )
{
Grammar.LabelElementPair pair = new Grammar.LabelElementPair( grammar, label, elementRef );
@@ -338,12 +369,12 @@ namespace Antlr3.Tool
return pair;
}

-        public virtual IDictionary GetRuleLabels()
+        public virtual IDictionary<string, Grammar.LabelElementPair> GetRuleLabels()
{
return ruleLabels;
}

-        public virtual IDictionary GetRuleListLabels()
+        public virtual IDictionary<string, Grammar.LabelElementPair> GetRuleListLabels()
{
return ruleListLabels;
}
@@ -488,7 +519,7 @@ namespace Antlr3.Tool
{
if ( i >= altsWithRewrites.Length )
{
-                ErrorManager.InternalError( "alt " + i + " exceeds number of " + name +
+                ErrorManager.InternalError( "alt " + i + " exceeds number of " + Name +
"'s alts (" + altsWithRewrites.Length + ")" );
return false;
}
@@ -597,11 +628,11 @@ namespace Antlr3.Tool
if ( grammar.type != GrammarType.Lexer &&
char.IsUpper( refdSymbol[0] ) )
{
-                    grammar.DefineTokenRefLabel( name, label, uniqueRefAST );
+                    grammar.DefineTokenRefLabel( Name, label, uniqueRefAST );
}
else
{
-                    grammar.DefineRuleRefLabel( name, label, uniqueRefAST );
+                    grammar.DefineRuleRefLabel( Name, label, uniqueRefAST );
}
uniqueRefAST.code.SetAttribute( "label", labelName );
}
@@ -757,7 +788,7 @@ namespace Antlr3.Tool
public override string ToString()
{
// used for testing
-            return "[" + grammar.name + "." + name + ",index=" + index + ",line=" + tree.Token.Line + "]";
+            return "[" + grammar.name + "." + Name + ",index=" + index + ",line=" + tree.Token.Line + "]";
}
}
}
diff --git a/Antlr3/Tool/RuleLabelScope.cs b/Antlr3/Tool/RuleLabelScope.cs
index 312f881..d3cd365 100644
--- a/Antlr3/Tool/RuleLabelScope.cs
+++ b/Antlr3/Tool/RuleLabelScope.cs
@@ -91,7 +91,7 @@ namespace Antlr3.Tool
public Rule referencedRule;

public RuleLabelScope( Rule referencedRule, IToken actionToken )
-            : base( "ref_" + referencedRule.name, actionToken )
+            : base( "ref_" + referencedRule.Name, actionToken )
{
this.referencedRule = referencedRule;
}
diff --git a/Antlr3/Tool/RuleType.cs b/Antlr3/Tool/RuleType.cs
new file mode 100644
index 0000000..b2510b4
--- /dev/null
+++ b/Antlr3/Tool/RuleType.cs
@@ -0,0 +1,41 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2010 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    [System.Serializable]
+    public enum RuleType
+    {
+        Lexer,
+        Parser
+    }
+}

