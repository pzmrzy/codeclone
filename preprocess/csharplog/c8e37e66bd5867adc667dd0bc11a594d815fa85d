commit c8e37e66bd5867adc667dd0bc11a594d815fa85d
Author:     Sam Harwell <sam@tunnelvisionlabs.com>
AuthorDate: Tue Jan 29 23:10:44 2013 -0600
Commit:     Sam Harwell <sam@tunnelvisionlabs.com>
CommitDate: Tue Jan 29 23:11:47 2013 -0600

CSharp2 and CSharp3: runtime and template updates to synchronize with changes in Java version

diff --git a/Antlr3.Runtime.Debug/ParseTreeBuilder.cs b/Antlr3.Runtime.Debug/ParseTreeBuilder.cs
index deeaf3b..cb5f678 100644
--- a/Antlr3.Runtime.Debug/ParseTreeBuilder.cs
+++ b/Antlr3.Runtime.Debug/ParseTreeBuilder.cs
@@ -58,7 +58,8 @@ namespace Antlr.Runtime.Debug
{
get
{
-                return callStack.Peek();
+                ParseTree[] stack = callStack.ToArray();
+                return stack[stack.Length - 1];
}
}

diff --git a/Antlr3.Runtime.Debug/Properties/AssemblyInfo.cs b/Antlr3.Runtime.Debug/Properties/AssemblyInfo.cs
index 5cc7429..dd6db55 100644
--- a/Antlr3.Runtime.Debug/Properties/AssemblyInfo.cs
+++ b/Antlr3.Runtime.Debug/Properties/AssemblyInfo.cs
@@ -66,5 +66,5 @@ using System.Runtime.InteropServices;
*      the Major or Minor version is incremented.
*   3. Revision is the Perforce changelist number associated with the release.
*/
-[assembly: AssemblyVersion("3.4.1.9004")]
-[assembly: AssemblyFileVersion("3.4.1.9004")]
+[assembly: AssemblyVersion("3.5.0.0")]
+[assembly: AssemblyFileVersion("3.5.0.0")]
diff --git a/Antlr3.Runtime.JavaExtensions/Properties/AssemblyInfo.cs b/Antlr3.Runtime.JavaExtensions/Properties/AssemblyInfo.cs
index d936148..596e4af 100644
--- a/Antlr3.Runtime.JavaExtensions/Properties/AssemblyInfo.cs
+++ b/Antlr3.Runtime.JavaExtensions/Properties/AssemblyInfo.cs
@@ -66,5 +66,5 @@ using System.Runtime.InteropServices;
*      the Major or Minor version is incremented.
*   3. Revision is the Perforce changelist number associated with the release.
*/
-[assembly: AssemblyVersion("3.4.1.9004")]
-[assembly: AssemblyFileVersion("3.4.1.9004")]
+[assembly: AssemblyVersion("3.5.0.0")]
+[assembly: AssemblyFileVersion("3.5.0.0")]
diff --git a/Antlr3.Runtime.Test/Properties/AssemblyInfo.cs b/Antlr3.Runtime.Test/Properties/AssemblyInfo.cs
index 478f623..d4f63a4 100644
--- a/Antlr3.Runtime.Test/Properties/AssemblyInfo.cs
+++ b/Antlr3.Runtime.Test/Properties/AssemblyInfo.cs
@@ -66,5 +66,5 @@ using System.Runtime.InteropServices;
*      the Major or Minor version is incremented.
*   3. Revision is the Perforce changelist number associated with the release.
*/
-[assembly: AssemblyVersion("3.4.1.9004")]
-[assembly: AssemblyFileVersion("3.4.1.9004")]
+[assembly: AssemblyVersion("3.5.0.0")]
+[assembly: AssemblyFileVersion("3.5.0.0")]
diff --git a/Antlr3.Runtime/Antlr3.Runtime.csproj b/Antlr3.Runtime/Antlr3.Runtime.csproj
index 4afc0d0..2188cc0 100644
--- a/Antlr3.Runtime/Antlr3.Runtime.csproj
+++ b/Antlr3.Runtime/Antlr3.Runtime.csproj
@@ -99,6 +99,7 @@
<Compile Include="Tree\CommonTreeAdaptor.cs" />
<Compile Include="Tree\CommonTreeNodeStream.cs" />
<Compile Include="Tree\DotTreeGenerator.cs" />
+    <Compile Include="Tree\IPositionTrackingStream.cs" />
<Compile Include="Tree\ITree.cs" />
<Compile Include="Tree\ITreeAdaptor.cs" />
<Compile Include="Tree\ITreeNodeStream.cs" />
diff --git a/Antlr3.Runtime/Lexer.cs b/Antlr3.Runtime/Lexer.cs
index cf478c6..daf530d 100644
--- a/Antlr3.Runtime/Lexer.cs
+++ b/Antlr3.Runtime/Lexer.cs
@@ -137,10 +137,7 @@ namespace Antlr.Runtime
state.text = null;
if ( input.LA( 1 ) == CharStreamConstants.EndOfFile )
{
-                    IToken eof = new CommonToken((ICharStream)input, CharStreamConstants.EndOfFile, TokenChannels.Default, input.Index, input.Index);
-                    eof.Line = Line;
-                    eof.CharPositionInLine = CharPositionInLine;
-                    return eof;
+                    return GetEndOfFileToken();
}
try
{
@@ -173,6 +170,17 @@ namespace Antlr.Runtime
}
}

+        /** Returns the EOF token (default), if you need
+         *  to return a custom token instead override this method.
+         */
+        public virtual IToken GetEndOfFileToken()
+        {
+            IToken eof = new CommonToken((ICharStream)input, CharStreamConstants.EndOfFile, TokenChannels.Default, input.Index, input.Index);
+            eof.Line = Line;
+            eof.CharPositionInLine = CharPositionInLine;
+            return eof;
+        }
+
/** <summary>
*  Instruct the lexer to skip creating a token for current lexer rule
*  and look for another token.  nextToken() knows to keep looking when
diff --git a/Antlr3.Runtime/Misc/FastQueue.cs b/Antlr3.Runtime/Misc/FastQueue.cs
index 2dc5bfc..af975d7 100644
--- a/Antlr3.Runtime/Misc/FastQueue.cs
+++ b/Antlr3.Runtime/Misc/FastQueue.cs
@@ -71,9 +71,9 @@ namespace Antlr.Runtime.Misc
}

/** <summary>
-         *  Return element i elements ahead of current element.  i==0 gets
-         *  current element.  This is not an absolute index into the data list
-         *  since p defines the start of the real list.
+         * Return element {@code i} elements ahead of current element. {@code i==0}
+         * gets current element. This is not an absolute index into {@link #data}
+         * since {@code p} defines the start of the real list.
*  </summary>
*/
public virtual T this[int i]
diff --git a/Antlr3.Runtime/Misc/LookaheadStream.cs b/Antlr3.Runtime/Misc/LookaheadStream.cs
index 24dc0cb..38c26a8 100644
--- a/Antlr3.Runtime/Misc/LookaheadStream.cs
+++ b/Antlr3.Runtime/Misc/LookaheadStream.cs
@@ -33,13 +33,16 @@
namespace Antlr.Runtime.Misc
{
using ArgumentException = System.ArgumentException;
+    using Debug = System.Diagnostics.Debug;
using InvalidOperationException = System.InvalidOperationException;
+    using NotSupportedException = System.NotSupportedException;
+    using ArgumentOutOfRangeException = System.ArgumentOutOfRangeException;

/** <summary>
-     *  A lookahead queue that knows how to mark/release locations
-     *  in the buffer for backtracking purposes. Any markers force the FastQueue
-     *  superclass to keep all tokens until no more markers; then can reset
-     *  to avoid growing a huge buffer.
+     * A lookahead queue that knows how to mark/release locations in the buffer for
+     * backtracking purposes. Any markers force the {@link FastQueue} superclass to
+     * keep all elements until no more markers; then can reset to avoid growing a
+     * huge buffer.
*  </summary>
*/
public abstract class LookaheadStream<T>
@@ -47,10 +50,13 @@ namespace Antlr.Runtime.Misc
where T : class
{
/** Absolute token index. It's the index of the symbol about to be
-         *  read via LT(1). Goes from 0 to numtokens.
+         *  read via {@code LT(1)}. Goes from 0 to numtokens.
*/
private int _currentElementIndex = 0;

+        /**
+         * This is the {@code LT(-1)} element for the first element in {@link #data}.
+         */
private T _previousElement;

/** Track object returned by nextElement upon end of stream;
@@ -94,14 +100,17 @@ namespace Antlr.Runtime.Misc

/** <summary>
*  Implement nextElement to supply a stream of elements to this
-         *  lookahead buffer.  Return eof upon end of the stream we're pulling from.
+         *  lookahead buffer.  Return EOF upon end of the stream we're pulling from.
*  </summary>
*/
public abstract T NextElement();

public abstract bool IsEndOfFile(T o);

-        /** <summary>Get and remove first element in queue; override FastQueue.remove()</summary> */
+        /** <summary>
+         * Get and remove first element in queue; override
+         * {@link FastQueue#remove()}; it's the same, just checks for backtracking.
+         * </summary> */
public override T Dequeue()
{
T o = this[0];
@@ -109,6 +118,7 @@ namespace Antlr.Runtime.Misc
// have we hit end of buffer and not backtracking?
if ( _p == _data.Count && _markDepth == 0 )
{
+                _previousElement = o;
// if so, it's an opportunity to start filling at index 0 again
Clear(); // size goes to 0, but retains memory
}
@@ -119,7 +129,7 @@ namespace Antlr.Runtime.Misc
public virtual void Consume()
{
SyncAhead(1);
-            _previousElement = Dequeue();
+            Dequeue();
_currentElementIndex++;
}

@@ -201,34 +211,61 @@ namespace Antlr.Runtime.Misc

public virtual void Rewind( int marker )
{
-            Seek( marker );
-            Release( marker );
+            _markDepth--;
+            int delta = _p - marker;
+            _currentElementIndex -= delta;
+            _p = marker;
}

public virtual void Rewind()
{
-            Rewind( _lastMarker );
+            // rewind but do not release marker
+            int delta = _p - _lastMarker;
+            _currentElementIndex -= delta;
+            _p = _lastMarker;
}

/** <summary>
-         *  Seek to a 0-indexed position within data buffer.  Can't handle
-         *  case where you seek beyond end of existing buffer.  Normally used
-         *  to seek backwards in the buffer. Does not force loading of nodes.
-         *  Doesn't see to absolute position in input stream since this stream
-         *  is unbuffered. Seeks only into our moving window of elements.
+         * Seek to a 0-indexed absolute token index. Normally used to seek backwards
+         * in the buffer. Does not force loading of nodes.
*  </summary>
+         *  <remarks>
+         * To preserve backward compatibility, this method allows seeking past the
+         * end of the currently buffered data. In this case, the input pointer will
+         * be moved but the data will only actually be loaded upon the next call to
+         * {@link #consume} or {@link #LT} for {@code k>0}.
+         *  </remarks>
*/
public virtual void Seek( int index )
{
-            _p = index;
+            if (index < 0)
+                throw new ArgumentOutOfRangeException("index");
+
+            int delta = _currentElementIndex - index;
+            if (_p - delta < 0)
+                throw new NotSupportedException("can't seek before the beginning of this stream's buffer");
+
+            _p -= delta;
+            _currentElementIndex = index;
}

protected virtual T LB(int k)
{
-            if (k == 1)
+            Debug.Assert(k > 0);
+
+            int index = _p - k;
+            if (index == -1)
return _previousElement;

-            throw new ArgumentException("can't look backwards more than one token in this stream");
+            // if k>0 then we know index < data.size(). avoid the double-check for
+            // performance.
+            if (index >= 0 /*&& index < data.size()*/)
+                return _data[index];
+
+            if (index < -1)
+                throw new NotSupportedException("can't look more than one token before the beginning of this stream's buffer");
+
+            throw new NotSupportedException("can't look past the end of this stream's buffer using LB(int)");
}
}
}
diff --git a/Antlr3.Runtime/Properties/AssemblyInfo.cs b/Antlr3.Runtime/Properties/AssemblyInfo.cs
index a20bacc..24f7daf 100644
--- a/Antlr3.Runtime/Properties/AssemblyInfo.cs
+++ b/Antlr3.Runtime/Properties/AssemblyInfo.cs
@@ -68,5 +68,5 @@ using System.Security;
*      the Major or Minor version is incremented.
*   3. Revision is the Perforce changelist number associated with the release.
*/
-[assembly: AssemblyVersion("3.4.1.9004")]
-[assembly: AssemblyFileVersion("3.4.1.9004")]
+[assembly: AssemblyVersion("3.5.0.0")]
+[assembly: AssemblyFileVersion("3.5.0.0")]
diff --git a/Antlr3.Runtime/RecognitionException.cs b/Antlr3.Runtime/RecognitionException.cs
index 861769f..007560d 100644
--- a/Antlr3.Runtime/RecognitionException.cs
+++ b/Antlr3.Runtime/RecognitionException.cs
@@ -34,9 +34,9 @@ namespace Antlr.Runtime
{
using Antlr.Runtime.Tree;

-    using ArgumentException = System.ArgumentException;
using ArgumentNullException = System.ArgumentNullException;
using Exception = System.Exception;
+    using NotSupportedException = System.NotSupportedException;
using SerializationInfo = System.Runtime.Serialization.SerializationInfo;
using StreamingContext = System.Runtime.Serialization.StreamingContext;

@@ -369,6 +369,19 @@ namespace Antlr.Runtime
protected virtual void ExtractInformationFromTreeNodeStream(ITreeNodeStream input)
{
this._node = input.LT(1);
+
+            object positionNode = null;
+            IPositionTrackingStream positionTrackingStream = input as IPositionTrackingStream;
+            if (positionTrackingStream != null)
+            {
+                positionNode = positionTrackingStream.GetKnownPositionElement(false);
+                if (positionNode == null)
+                {
+                    positionNode = positionTrackingStream.GetKnownPositionElement(true);
+                    this._approximateLineInfo = positionNode != null;
+                }
+            }
+
ITokenStreamInformation streamInformation = input as ITokenStreamInformation;
if (streamInformation != null)
{
@@ -385,7 +398,7 @@ namespace Antlr.Runtime
else
{
ITreeAdaptor adaptor = input.TreeAdaptor;
-                IToken payload = adaptor.GetToken(_node);
+                IToken payload = adaptor.GetToken(positionNode ?? _node);
if (payload != null)
{
this._token = payload;
@@ -405,12 +418,13 @@ namespace Antlr.Runtime
this._approximateLineInfo = true;
break;
}
+
--i;
try
{
priorNode = input.LT(i);
}
-                            catch (ArgumentException)
+                            catch (NotSupportedException)
{
priorNode = null;
}
diff --git a/Antlr3.Runtime/Tree/CommonTreeNodeStream.cs b/Antlr3.Runtime/Tree/CommonTreeNodeStream.cs
index 4f8e069..1764d1e 100644
--- a/Antlr3.Runtime/Tree/CommonTreeNodeStream.cs
+++ b/Antlr3.Runtime/Tree/CommonTreeNodeStream.cs
@@ -38,7 +38,7 @@ namespace Antlr.Runtime.Tree
using StringBuilder = System.Text.StringBuilder;

[System.Serializable]
-    public class CommonTreeNodeStream : LookaheadStream<object>, ITreeNodeStream
+    public class CommonTreeNodeStream : LookaheadStream<object>, ITreeNodeStream, IPositionTrackingStream
{
public const int DEFAULT_INITIAL_BUFFER_SIZE = 100;
public const int INITIAL_CALL_STACK_SIZE = 10;
@@ -65,6 +65,17 @@ namespace Antlr.Runtime.Tree
/** <summary>Tracks tree depth.  Level=0 means we're at root node level.</summary> */
private int _level = 0;

+        /**
+         * Tracks the last node before the start of {@link #data} which contains
+         * position information to provide information for error reporting. This is
+         * tracked in addition to {@link #prevElement} which may or may not contain
+         * position information.
+         *
+         * @see #hasPositionInformation
+         * @see RecognitionException#extractInformationFromTreeNodeStream
+         */
+        private object _previousLocationElement;
+
public CommonTreeNodeStream( object tree )
: this( new CommonTreeAdaptor(), tree )
{
@@ -144,6 +155,7 @@ namespace Antlr.Runtime.Tree
_it.Reset();
_hasNilRoot = false;
_level = 0;
+            _previousLocationElement = null;
if ( _calls != null )
_calls.Clear();
}
@@ -181,6 +193,15 @@ namespace Antlr.Runtime.Tree
return t;
}

+        public override object Dequeue()
+        {
+            object result = base.Dequeue();
+            if (_p == 0 && HasPositionInformation(PreviousElement))
+                _previousLocationElement = PreviousElement;
+
+            return result;
+        }
+
public override bool IsEndOfFile(object o)
{
return TreeAdaptor.GetType(o) == CharStreamConstants.EndOfFile;
@@ -213,6 +234,44 @@ namespace Antlr.Runtime.Tree
return ret;
}

+        /**
+         * Returns an element containing position information. If {@code allowApproximateLocation} is {@code false}, then
+         * this method will return the {@code LT(1)} element if it contains position information, and otherwise return {@code null}.
+         * If {@code allowApproximateLocation} is {@code true}, then this method will return the last known element containing position information.
+         *
+         * @see #hasPositionInformation
+         */
+        public object GetKnownPositionElement(bool allowApproximateLocation)
+        {
+            object node = _data[_p];
+            if (HasPositionInformation(node))
+                return node;
+
+            if (!allowApproximateLocation)
+                return null;
+
+            for (int index = _p - 1; index >= 0; index--)
+            {
+                node = _data[index];
+                if (HasPositionInformation(node))
+                    return node;
+            }
+
+            return _previousLocationElement;
+        }
+
+        public bool HasPositionInformation(object node)
+        {
+            IToken token = TreeAdaptor.GetToken(node);
+            if (token == null)
+                return false;
+
+            if (token.Line <= 0)
+                return false;
+
+            return true;
+        }
+
#region Tree rewrite interface

public virtual void ReplaceChildren( object parent, int startChildIndex, int stopChildIndex, object t )
diff --git a/Antlr3.Runtime/Tree/IPositionTrackingStream.cs b/Antlr3.Runtime/Tree/IPositionTrackingStream.cs
new file mode 100644
index 0000000..8bc8945
--- /dev/null
+++ b/Antlr3.Runtime/Tree/IPositionTrackingStream.cs
@@ -0,0 +1,59 @@
+ï»¿/*
+ [The "BSD license"]
+ Copyright (c) 2012 Terence Parr
+ Copyright (c) 2012 Sam Harwell
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+     derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr.Runtime.Tree
+{
+    /**
+     *
+     * @author Sam Harwell
+     */
+    public interface IPositionTrackingStream
+    {
+        /**
+         * Returns an element containing concrete information about the current
+         * position in the stream.
+         *
+         * @param allowApproximateLocation if {@code false}, this method returns
+         * {@code null} if an element containing exact information about the current
+         * position is not available
+         */
+        object GetKnownPositionElement(bool allowApproximateLocation);
+
+        /**
+         * Determines if the specified {@code element} contains concrete position
+         * information.
+         *
+         * @param element the element to check
+         * @return {@code true} if {@code element} contains concrete position
+         * information, otherwise {@code false}
+         */
+        bool HasPositionInformation(object element);
+
+    }
+}
diff --git a/Antlr3.Runtime/Tree/ITreeNodeStream.cs b/Antlr3.Runtime/Tree/ITreeNodeStream.cs
index b133f39..8f3f30a 100644
--- a/Antlr3.Runtime/Tree/ITreeNodeStream.cs
+++ b/Antlr3.Runtime/Tree/ITreeNodeStream.cs
@@ -47,18 +47,18 @@ namespace Antlr.Runtime.Tree
}

/** <summary>
-         *  Get tree node at current input pointer + i ahead where i=1 is next node.
-         *  i&lt;0 indicates nodes in the past.  So LT(-1) is previous node, but
-         *  implementations are not required to provide results for k &lt; -1.
-         *  LT(0) is undefined.  For i&gt;=n, return null.
-         *  Return null for LT(0) and any index that results in an absolute address
-         *  that is negative.
+         * Get tree node at current input pointer + {@code k} ahead where
+         * {@code k==1} is next node. {@code k<0} indicates nodes in the past. So
+         * {@code LT(-1)} is previous node, but implementations are not required to
+         * provide results for {@code k < -1}. {@code LT(0)} is undefined. For
+         * {@code k<=n}, return {@code null}. Return {@code null} for {@code LT(0)}
+         * and any index that results in an absolute address that is negative.
*  </summary>
*
*  <remarks>
-         *  This is analogus to the LT() method of the TokenStream, but this
-         *  returns a tree node instead of a token.  Makes code gen identical
-         *  for both parser and tree grammars. :)
+         * This is analogous to {@link TokenStream#LT}, but this returns a tree node
+         * instead of a {@link Token}. Makes code generation identical for both
+         * parser and tree grammars.
*  </remarks>
*/
object LT( int k );
@@ -74,10 +74,11 @@ namespace Antlr.Runtime.Tree
}

/** <summary>
-         *  If the tree associated with this stream was created from a TokenStream,
-         *  you can specify it here.  Used to do rule $text attribute in tree
-         *  parser.  Optional unless you use tree parser rule text attribute
-         *  or output=template and rewrite=true options.
+         * If the tree associated with this stream was created from a
+         * {@link TokenStream}, you can specify it here. Used to do rule
+         * {@code $text} attribute in tree parser. Optional unless you use tree
+         * parser rule {@code $text} attribute or {@code output=template} and
+         * {@code rewrite=true} options.
*  </summary>
*/
ITokenStream TokenStream
@@ -96,11 +97,11 @@ namespace Antlr.Runtime.Tree
}

/** <summary>
-         *  As we flatten the tree, we use UP, DOWN nodes to represent
-         *  the tree structure.  When debugging we need unique nodes
-         *  so we have to instantiate new ones.  When doing normal tree
-         *  parsing, it's slow and a waste of memory to create unique
-         *  navigation nodes.  Default should be false;
+         * As we flatten the tree, we use {@link Token#UP}, {@link Token#DOWN} nodes
+         * to represent the tree structure. When debugging we need unique nodes so
+         * we have to instantiate new ones. When doing normal tree parsing, it's
+         * slow and a waste of memory to create unique navigation nodes. Default
+         * should be {@code false}.
*  </summary>
*/
bool UniqueNavigationNodes
@@ -110,11 +111,11 @@ namespace Antlr.Runtime.Tree
}

/** <summary>
-         *  Return the text of all nodes from start to stop, inclusive.
-         *  If the stream does not buffer all the nodes then it can still
-         *  walk recursively from start until stop.  You can always return
-         *  null or "" too, but users should not access $ruleLabel.text in
-         *  an action of course in that case.
+         * Return the text of all nodes from {@code start} to {@code stop},
+         * inclusive. If the stream does not buffer all the nodes then it can still
+         * walk recursively from start until stop. You can always return
+         * {@code null} or {@code ""} too, but users should not access
+         * {@code $ruleLabel.text} in an action of course in that case.
*  </summary>
*/
string ToString( object start, object stop );
@@ -123,17 +124,18 @@ namespace Antlr.Runtime.Tree
#region REWRITING TREES (used by tree parser)

/** <summary>
-         *  Replace from start to stop child index of parent with t, which might
-         *  be a list.  Number of children may be different
-         *  after this call.  The stream is notified because it is walking the
-         *  tree and might need to know you are monkeying with the underlying
-         *  tree.  Also, it might be able to modify the node stream to avoid
-         *  restreaming for future phases.
+         * Replace children of {@code parent} from index {@code startChildIndex} to
+         * {@code stopChildIndex} with {@code t}, which might be a list. Number of
+         * children may be different after this call. The stream is notified because
+         * it is walking the tree and might need to know you are monkeying with the
+         * underlying tree. Also, it might be able to modify the node stream to
+         * avoid restreaming for future phases.
*  </summary>
*
*  <remarks>
-         *  If parent is null, don't do anything; must be at root of overall tree.
-         *  Can't replace whatever points to the parent externally.  Do nothing.
+         * If {@code parent} is {@code null}, don't do anything; must be at root of
+         * overall tree. Can't replace whatever points to the parent externally. Do
+         * nothing.
*  </remarks>
*/
void ReplaceChildren( object parent, int startChildIndex, int stopChildIndex, object t );

