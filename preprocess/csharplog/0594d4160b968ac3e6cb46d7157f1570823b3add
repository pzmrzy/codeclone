commit 0594d4160b968ac3e6cb46d7157f1570823b3add
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Thu Jan 20 09:27:34 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Thu Jan 20 09:27:34 2011 -0800

(C# 3) Updated bootstrap binaries

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 7464]

diff --git a/bin/Bootstrap/Antlr3.Runtime.Debug.dll b/bin/Bootstrap/Antlr3.Runtime.Debug.dll
index 4fb7b1d..efaaa23 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.Debug.dll and b/bin/Bootstrap/Antlr3.Runtime.Debug.dll differ
diff --git a/bin/Bootstrap/Antlr3.Runtime.dll b/bin/Bootstrap/Antlr3.Runtime.dll
index 69ac47b..87cbbe1 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.dll and b/bin/Bootstrap/Antlr3.Runtime.dll differ
diff --git a/bin/Bootstrap/Antlr3.StringTemplate.dll b/bin/Bootstrap/Antlr3.StringTemplate.dll
index b9b1ddd..aa5b866 100644
Binary files a/bin/Bootstrap/Antlr3.StringTemplate.dll and b/bin/Bootstrap/Antlr3.StringTemplate.dll differ
diff --git a/bin/Bootstrap/Antlr3.exe b/bin/Bootstrap/Antlr3.exe
index 3d3d1a5..558854c 100755
Binary files a/bin/Bootstrap/Antlr3.exe and b/bin/Bootstrap/Antlr3.exe differ
diff --git a/bin/Bootstrap/Antlr3.exe.config b/bin/Bootstrap/Antlr3.exe.config
index a8afe94..0df7832 100644
--- a/bin/Bootstrap/Antlr3.exe.config
+++ b/bin/Bootstrap/Antlr3.exe.config
@@ -1,3 +1,3 @@
-﻿<?xml version="1.0"?>
+<?xml version="1.0"?>
<configuration>
-<startup><supportedRuntime version="v2.0.50727" sku="Client"/></startup></configuration>
+	<startup/></configuration>
diff --git a/bin/Bootstrap/Antlr3.targets b/bin/Bootstrap/Antlr3.targets
index 211cf7f..b57c5e0 100644
--- a/bin/Bootstrap/Antlr3.targets
+++ b/bin/Bootstrap/Antlr3.targets
@@ -1,6 +1,6 @@
﻿<!--
[The "BSD licence"]
-   Copyright (c) 2009 Sam Harwell
+   Copyright (c) 2011 Sam Harwell
All rights reserved.

Redistribution and use in source and binary forms, with or without
@@ -28,12 +28,12 @@
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
<PropertyGroup>
<BuildSystem>MSBuild</BuildSystem>
-    <TaskVersion>3.2.0.0</TaskVersion>
+    <TaskVersion>3.3.0.7239</TaskVersion>
<TaskKeyToken>eb42632606e9261f</TaskKeyToken>
<AntlrBuildTaskAssemblyName Condition="'$(AntlrBuildTaskAssemblyName)'==''">AntlrBuildTask, Version=$(TaskVersion), Culture=neutral, PublicKeyToken=$(TaskKeyToken)</AntlrBuildTaskAssemblyName>
</PropertyGroup>

-  <PropertyGroup>
+  <!--<PropertyGroup>
<LoadTimeSensitiveTargets>
$(LoadTimeSensitiveTargets);
AntlrCompile;
@@ -48,7 +48,7 @@
AntlrCompile;
$(PrepareResourcesDependsOn)
</PrepareResourcesDependsOn>
-  </PropertyGroup>
+  </PropertyGroup>-->

<PropertyGroup>
<AntlrBuildTaskLocation Condition="'$(AntlrBuildTaskPath)'==''">$(MSBuildBinPath)</AntlrBuildTaskLocation>
@@ -84,12 +84,26 @@
</ItemGroup>

<Target Name="AntlrCompileReadGeneratedFileList">
-
<ReadLinesFromFile File="$(IntermediateOutputPath)$(AntlrGenCodeFileNames)">
<Output TaskParameter="Lines" ItemName="AntlrOutputCodeFilesList"/>
</ReadLinesFromFile>
</Target>

+  <PropertyGroup>
+    <!-- Add grammar compilation to the CoreCompileDependsOn so that the IDE inproc compilers (particularly VB)
+         can "see" the generated source files. -->
+    <CoreCompileDependsOn Condition="'$(BuildingInsideVisualStudio)' == 'true' ">
+      DesignTimeGrammarCompilation;
+      $(CoreCompileDependsOn)
+    </CoreCompileDependsOn>
+  </PropertyGroup>
+
+  <Target Name="DesignTimeGrammarCompilation">
+    <!-- Only if we are not actually performing a compile i.e. we are in design mode -->
+    <CallTarget Condition="'$(BuildingProject)' != 'true'"
+                Targets="AntlrCompile" />
+  </Target>
+
<Target Name="AntlrCompile"
DependsOnTargets="$(AntlrCompileDependsOn)"
Condition="'@(Antlr3)' != ''"
@@ -101,18 +115,25 @@
<AntlrGeneratedCodeFiles Remove="@(AntlrGeneratedCodeFiles)" />
</ItemGroup>

+    <PropertyGroup>
+      <_IntellisenseOnlyCompile>false</_IntellisenseOnlyCompile>
+      <_IntellisenseOnlyCompile Condition="'$(BuildingProject)' != 'true'">true</_IntellisenseOnlyCompile>
+    </PropertyGroup>
<AntlrClassGenerationTask
AntlrToolPath="$(AntlrToolLocation)"
BuildTaskPath="$(AntlrBuildTaskLocation)"
OutputPath="$(IntermediateOutputPath)"
Language="$(Language)"
SourceCodeFiles="@(Antlr3)"
+      ContinueOnError="$(_IntellisenseOnlyCompile)"
TokensFiles="@(AntlrTokens)">

<Output ItemName="AntlrGeneratedCodeFiles" TaskParameter="GeneratedCodeFiles" />
+      <Output ItemName="Compile" TaskParameter="GeneratedCodeFiles" />
</AntlrClassGenerationTask>

<WriteLinesToFile
+      Condition="'$(_IntellisenseOnlyCompile)' != 'true'"
File="$(IntermediateOutputPath)$(AntlrGenCodeFileNames)"
Lines="@(AntlrGeneratedCodeFiles)"
Overwrite="true"/>
@@ -123,17 +144,17 @@
Condition="'@(Antlr3)' != ''">

<ItemGroup>
-      <AntlrGeneratedCodeFiles Condition="'@(AntlrGeneratedCodeFiles)' == ''"
-                               Include="@(AntlrOutputCodeFilesList)" />
+      <Compile Condition="'@(AntlrGeneratedCodeFiles)' == ''" Include="@(AntlrOutputCodeFilesList)" />
</ItemGroup>

<ItemGroup>
-      <FileWrites Include="@(AntlrGeneratedCodeFiles);
-                           $(IntermediateOutputPath)$(AntlrGenCodeFileNames);" />
+      <_AntlrCodeGenFileWrites Condition="'@(AntlrGeneratedCodeFiles)' != ''" Include="@(AntlrGeneratedCodeFiles)" />
+      <_AntlrCodeGenFileWrites Condition="'@(AntlrGeneratedCodeFiles)' == ''" Include="@(AntlrOutputCodeFilesList)" />
</ItemGroup>

<ItemGroup>
-      <Compile Include="@(AntlrGeneratedCodeFiles)" />
+      <FileWrites Include="@(_AntlrCodeGenFileWrites);
+                           $(IntermediateOutputPath)$(AntlrGenCodeFileNames);" />
</ItemGroup>

</Target>
diff --git a/bin/Bootstrap/AntlrBuildTask.dll b/bin/Bootstrap/AntlrBuildTask.dll
index 516c4fc..99c72c7 100644
Binary files a/bin/Bootstrap/AntlrBuildTask.dll and b/bin/Bootstrap/AntlrBuildTask.dll differ
diff --git a/bin/Bootstrap/Codegen/Templates/ANTLRCore.sti b/bin/Bootstrap/Codegen/Templates/ANTLRCore.sti
index 308ba6c..4776e31 100644
--- a/bin/Bootstrap/Codegen/Templates/ANTLRCore.sti
+++ b/bin/Bootstrap/Codegen/Templates/ANTLRCore.sti
@@ -127,10 +127,10 @@ alt(elements,altNum,description,autoAST,outerAlt,treeLevel,rew);
// E L E M E N T S

/** match a token optionally with a label in front */
-tokenRef(token,label,elementIndex,hetero);
+tokenRef(token,label,elementIndex,terminalOptions);

/** ids+=ID */
-tokenRefAndListLabel(token,label,elementIndex,hetero);
+tokenRefAndListLabel(token,label,elementIndex,terminalOptions);

listLabel(label,elem);

diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg
index eb723e8..a1dae9a 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg
@@ -1,10 +1,10 @@
/*
* [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -46,24 +46,27 @@ using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;<\n>

parserCtorBody() ::= <<
<super.parserCtorBody()>
-ITreeAdaptor treeAdaptor = null;
+<treeAdaptorType()> treeAdaptor = default(<treeAdaptorType()>);
CreateTreeAdaptor(ref treeAdaptor);
-TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
+
+TreeAdaptor = treeAdaptor<if(!actions.(actionScope).treeAdaptorType)> ?? new CommonTreeAdaptor()<endif>;
+
>>

/** Add an adaptor property that knows how to build trees */
parserMembers() ::= <<
// Implement this function in your helper file to use a custom tree adaptor
-partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);
+partial void CreateTreeAdaptor(ref <treeAdaptorType()> adaptor);

-private ITreeAdaptor adaptor;
+private <treeAdaptorType()> adaptor;

-public ITreeAdaptor TreeAdaptor
+public <treeAdaptorType()> TreeAdaptor
{
get
{
return adaptor;
}
+
set
{
this.adaptor = value;
@@ -72,26 +75,32 @@ public ITreeAdaptor TreeAdaptor
}
>>

+treeAdaptorType() ::= <<
+<actions.(actionScope).treeAdaptorType; null="ITreeAdaptor">
+>>
+
@returnScope.ruleReturnInterfaces() ::= <<
-, IAstRuleReturnScope\<<ASTLabelType>\>
+, IAstRuleReturnScope\<<ASTLabelType>\>, IAstRuleReturnScope
>>

@returnScope.ruleReturnMembers() ::= <<
private <ASTLabelType> _tree;
public <ASTLabelType> Tree { get { return _tree; } set { _tree = value; } }
+object IAstRuleReturnScope.Tree { get { return Tree; } }
+<@super.ruleReturnMembers()>
>>

/** Add a variable to track rule's return AST */
ruleDeclarations() ::= <<
<super.ruleDeclarations()>
-<ASTLabelType> root_0 = null;<\n>
+<ASTLabelType> root_0 = default(<ASTLabelType>);<\n>
>>

ruleLabelDefs() ::= <<
<super.ruleLabelDefs()>
<[ruleDescriptor.tokenLabels,ruleDescriptor.wildcardTreeLabels,ruleDescriptor.wildcardTreeListLabels]
-	:{<ASTLabelType> <it.label.text>_tree=null;}; separator="\n">
-<ruleDescriptor.tokenListLabels:{<ASTLabelType> <it.label.text>_tree=null;}; separator="\n">
+	:{<ASTLabelType> <it.label.text>_tree = default(<ASTLabelType>);}; separator="\n">
+<ruleDescriptor.tokenListLabels:{<ASTLabelType> <it.label.text>_tree = default(<ASTLabelType>);}; separator="\n">
<ruleDescriptor.allTokenRefsInAltsWithRewrites
:{RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>");}; separator="\n">
<ruleDescriptor.allRuleRefsInAltsWithRewrites
@@ -116,27 +125,27 @@ root_0 = (<ASTLabelType>)adaptor.Nil();<\n>
// T r a c k i n g  R u l e  E l e m e n t s

/** ID and track it for use in a rewrite rule */
-tokenRefTrack(token,label,elementIndex,hetero) ::= <<
+tokenRefTrack(token,label,elementIndex,terminalOptions) ::= <<
<tokenRefBang(...)> <! Track implies no auto AST construction!>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>stream_<token>.Add(<label>);<\n>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<token>.Add(<label>);<\n>
>>

/** ids+=ID and track it for use in a rewrite rule; adds to ids *and*
*  to the tracking list stream_ID for use in the rewrite.
*/
-tokenRefTrackAndListLabel(token,label,elementIndex,hetero) ::= <<
+tokenRefTrackAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
<tokenRefTrack(...)>
<listLabel(elem=label,...)>
>>

/** ^(ID ...) track for rewrite */
-tokenRefRuleRootTrack(token,label,elementIndex,hetero) ::= <<
+tokenRefRuleRootTrack(token,label,elementIndex,terminalOptions) ::= <<
<tokenRefBang(...)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>stream_<token>.Add(<label>);<\n>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<token>.Add(<label>);<\n>
>>

/** Match ^(label+=TOKEN ...) track for rewrite */
-tokenRefRuleRootTrackAndListLabel(token,label,elementIndex,hetero) ::= <<
+tokenRefRuleRootTrackAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
<tokenRefRuleRootTrack(...)>
<listLabel(elem=label,...)>
>>
@@ -144,7 +153,7 @@ tokenRefRuleRootTrackAndListLabel(token,label,elementIndex,hetero) ::= <<
/** rule when output=AST and tracking for rewrite */
ruleRefTrack(rule,label,elementIndex,args,scope) ::= <<
<super.ruleRef(...)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>stream_<rule.name>.Add(<label>.Tree);
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<rule.name>.Add(<label>.Tree);
>>

/** x+=rule when output=AST and tracking for rewrite */
@@ -156,7 +165,7 @@ ruleRefTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
/** ^(rule ...) rewrite */
ruleRefRuleRootTrack(rule,label,elementIndex,args,scope) ::= <<
<ruleRefRuleRoot(...)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>stream_<rule>.Add(<label>.Tree);
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<rule>.Add(<label>.Tree);
>>

/** ^(x+=rule ...) rewrite */
@@ -188,7 +197,7 @@ rewriteCode(
// rule list labels: <referencedRuleListLabels; separator=", ">
// wildcard labels: <[referencedWildcardLabels,referencedWildcardListLabels]; separator=", ">
<if(backtracking)>
-if ( <actions.(actionScope).synpredgate> ) {<\n>
+if (<actions.(actionScope).synpredgate>) {<\n>
<endif>
<prevRuleRootRef()>.Tree = root_0;
<rewriteCodeLabels()>
@@ -256,7 +265,7 @@ rewriteOptionalBlock(
description) ::=
<<
// <fileName>:<description>
-if ( <referencedElementsDeep:{el | stream_<el>.HasNext}; separator="||"> )
+if (<referencedElementsDeep:{el | stream_<el>.HasNext}; separator="||">)
{
<alt>
}
@@ -283,7 +292,7 @@ rewritePositiveClosureBlock(
referencedElements, // elements in immediately block; no nested blocks
description) ::=
<<
-if ( !(<referencedElements:{el | stream_<el>.HasNext}; separator="||">) )
+if (!(<referencedElements:{el | stream_<el>.HasNext}; separator="||">))
{
throw new RewriteEarlyExitException();
}
@@ -330,7 +339,7 @@ DebugLocation(<e.line>, <e.pos>);
>>

/** Gen ID or ID[args] */
-rewriteTokenRef(token,elementIndex,hetero,args) ::= <<
+rewriteTokenRef(token,elementIndex,terminalOptions,args) ::= <<
adaptor.AddChild(root_<treeLevel>, <createRewriteNodeFromElement(...)>);<\n>
>>

@@ -353,15 +362,15 @@ root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(stream_<label>.NextNode(),
rewriteTokenListLabelRefRoot ::= rewriteTokenLabelRefRoot

/** Gen ^(ID ...) or ^(ID[args] ...) */
-rewriteTokenRefRoot(token,elementIndex,hetero,args) ::= <<
+rewriteTokenRefRoot(token,elementIndex,terminalOptions,args) ::= <<
root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<createRewriteNodeFromElement(...)>, root_<treeLevel>);<\n>
>>

-rewriteImaginaryTokenRef(args,token,hetero,elementIndex) ::= <<
+rewriteImaginaryTokenRef(args,token,terminalOptions,elementIndex) ::= <<
adaptor.AddChild(root_<treeLevel>, <createImaginaryNode(tokenType=token, ...)>);<\n>
>>

-rewriteImaginaryTokenRefRoot(args,token,hetero,elementIndex) ::= <<
+rewriteImaginaryTokenRefRoot(args,token,terminalOptions,elementIndex) ::= <<
root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<createImaginaryNode(tokenType=token, ...)>, root_<treeLevel>);<\n>
>>

@@ -417,18 +426,18 @@ rewriteWildcardLabelRef(label) ::= <<
adaptor.AddChild(root_<treeLevel>, stream_<label>.NextTree());<\n>
>>

-createImaginaryNode(tokenType,hetero,args) ::= <<
-<if(hetero)>
+createImaginaryNode(tokenType,terminalOptions,args) ::= <<
+<if(terminalOptions.class)>
<! new MethodNode(IDLabel, args) !>
-new <hetero>(<tokenType><if(args)>, <args; separator=", "><endif>)
+new <terminalOptions.class>(<tokenType><if(args)>, <args; separator=", "><endif>)
<else>
(<ASTLabelType>)adaptor.Create(<tokenType>, <args; separator=", "><if(!args)>"<tokenType>"<endif>)
<endif>
>>

-createRewriteNodeFromElement(token,hetero,args) ::= <<
-<if(hetero)>
-new <hetero>(stream_<token>.NextToken()<if(args)>, <args; separator=", "><endif>)
+createRewriteNodeFromElement(token,terminalOptions,args) ::= <<
+<if(terminalOptions.class)>
+new <terminalOptions.class>(stream_<token>.NextToken()<if(args)>, <args; separator=", "><endif>)
<else>
<if(args)> <! must create new node from old !>
adaptor.Create(<token>, <args; separator=", ">)
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTParser.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTParser.stg
index c624a2d..ccb854c 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTParser.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTParser.stg
@@ -1,10 +1,10 @@
/*
* [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -51,9 +51,9 @@ retval.Tree = (<ASTLabelType>)adaptor.ErrorNode(input, retval.Start, input.LT(-1
// TOKEN AST STUFF

/** ID and output=AST */
-tokenRef(token,label,elementIndex,hetero) ::= <<
+tokenRef(token,label,elementIndex,terminalOptions) ::= <<
<super.tokenRef(...)>
-<if(backtracking)>if ( state.backtracking==0 ) {<endif>
+<if(backtracking)>if (state.backtracking == 0) {<endif>
<label>_tree = <createNodeFromToken(...)>;
adaptor.AddChild(root_0, <label>_tree);
<if(backtracking)>}<endif>
@@ -63,28 +63,28 @@ adaptor.AddChild(root_0, <label>_tree);
tokenRefBang(token,label,elementIndex) ::= "<super.tokenRef(...)>"

/** ID^ and output=AST */
-tokenRefRuleRoot(token,label,elementIndex,hetero) ::= <<
+tokenRefRuleRoot(token,label,elementIndex,terminalOptions) ::= <<
<super.tokenRef(...)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<label>_tree = <createNodeFromToken(...)>;
root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_0);
<if(backtracking)>}<endif>
>>

/** ids+=ID! and output=AST */
-tokenRefBangAndListLabel(token,label,elementIndex,hetero) ::= <<
+tokenRefBangAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
<tokenRefBang(...)>
<listLabel(elem=label,...)>
>>

/** label+=TOKEN when output=AST but not rewrite alt */
-tokenRefAndListLabel(token,label,elementIndex,hetero) ::= <<
+tokenRefAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
<tokenRef(...)>
<listLabel(elem=label,...)>
>>

/** Match label+=TOKEN^ when output=AST but not rewrite alt */
-tokenRefRuleRootAndListLabel(token,label,hetero,elementIndex) ::= <<
+tokenRefRuleRootAndListLabel(token,label,terminalOptions,elementIndex) ::= <<
<tokenRefRuleRoot(...)>
<listLabel(elem=label,...)>
>>
@@ -102,11 +102,11 @@ tokenRefRuleRootAndListLabel(token,label,hetero,elementIndex) ::= <<
// rather than just added on code.  Investigate that refactoring when
// I have more time.

-matchSet(s,label,hetero,elementIndex,postmatchCode) ::= <<
-<super.matchSet(..., postmatchCode={<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>adaptor.AddChild(root_0, <createNodeFromToken(...)>);})>
+matchSet(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
+<super.matchSet(..., postmatchCode={<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>adaptor.AddChild(root_0, <createNodeFromToken(...)>);})>
>>

-matchRuleBlockSet(s,label,hetero,elementIndex,postmatchCode,treeLevel="0") ::= <<
+matchRuleBlockSet(s,label,terminalOptions,elementIndex,postmatchCode,treeLevel="0") ::= <<
<matchSet(...)>
>>

@@ -115,11 +115,11 @@ matchSetBang(s,label,elementIndex,postmatchCode) ::= "<super.matchSet(...)>"
// note there is no matchSetTrack because -> rewrites force sets to be
// plain old blocks of alts: (A|B|...|C)

-matchSetRuleRoot(s,label,hetero,elementIndex,debug) ::= <<
+matchSetRuleRoot(s,label,terminalOptions,elementIndex,debug) ::= <<
<if(label)>
<label>=(<labelType>)input.LT(1);<\n>
<endif>
-<super.matchSet(..., postmatchCode={<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<createNodeFromToken(...)>, root_0);})>
+<super.matchSet(..., postmatchCode={<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<createNodeFromToken(...)>, root_0);})>
>>

// RULE REF AST
@@ -127,7 +127,7 @@ matchSetRuleRoot(s,label,hetero,elementIndex,debug) ::= <<
/** rule when output=AST */
ruleRef(rule,label,elementIndex,args,scope) ::= <<
<super.ruleRef(...)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>adaptor.AddChild(root_0, <label>.Tree);
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>adaptor.AddChild(root_0, <label>.Tree);
>>

/** rule! is same as normal rule ref */
@@ -136,7 +136,7 @@ ruleRefBang(rule,label,elementIndex,args,scope) ::= "<super.ruleRef(...)>"
/** rule^ */
ruleRefRuleRoot(rule,label,elementIndex,args,scope) ::= <<
<super.ruleRef(...)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>.Tree, root_0);
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>.Tree, root_0);
>>

/** x+=rule when output=AST */
@@ -161,7 +161,7 @@ ruleRefRuleRootAndListLabel(rule,label,elementIndex,args,scope) ::= <<

wildcard(label,elementIndex) ::= <<
<super.wildcard(...)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<label>_tree = (<ASTLabelType>)adaptor.Create(<label>);
adaptor.AddChild(root_0, <label>_tree);
<if(backtracking)>}<endif>
@@ -171,23 +171,23 @@ wildcardBang(label,elementIndex) ::= "<super.wildcard(...)>"

wildcardRuleRoot(label,elementIndex) ::= <<
<super.wildcard(...)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<label>_tree = (<ASTLabelType>)adaptor.Create(<label>);
root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_0);
<if(backtracking)>}<endif>
>>

-createNodeFromToken(label,hetero) ::= <<
-<if(hetero)>
-new <hetero>(<label>) <! new MethodNode(IDLabel) !>
+createNodeFromToken(label,terminalOptions) ::= <<
+<if(terminalOptions.class)>
+new <terminalOptions.class>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text><endif>)
<else>
-(<ASTLabelType>)adaptor.Create(<label>)
+(<ASTLabelType>)adaptor.Create(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text><endif>)
<endif>
>>

ruleCleanUp() ::= <<
<super.ruleCleanUp()>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<\n><endif>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
retval.Tree = (<ASTLabelType>)adaptor.RulePostProcessing(root_0);
adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
<if(backtracking)>}<endif>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg
index a06edb5..f9cc460 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg
@@ -1,10 +1,10 @@
/*
* [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -46,15 +46,15 @@ group ASTTreeParser;
/** Add a variable to track last element matched */
ruleDeclarations() ::= <<
<super.ruleDeclarations()>
-<ASTLabelType> _first_0 = null;
-<ASTLabelType> _last = null;<\n>
+<ASTLabelType> _first_0 = default(<ASTLabelType>);
+<ASTLabelType> _last = default(<ASTLabelType>);<\n>
>>

/** What to emit when there is no rewrite rule.  For auto build
*  mode, does nothing.
*/
noRewrite(rewriteBlockLevel, treeLevel) ::= <<
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<if(rewriteMode)>
retval.Tree = (<ASTLabelType>)_first_0;
if (adaptor.GetParent(retval.Tree)!=null && adaptor.IsNil(adaptor.GetParent(retval.Tree)))
@@ -71,22 +71,22 @@ tree(root, actionsAfterRoot, children, nullableChildList,
_last = (<ASTLabelType>)input.LT(1);
{
<ASTLabelType> _save_last_<treeLevel> = _last;
-<ASTLabelType> _first_<treeLevel> = null;
+<ASTLabelType> _first_<treeLevel> = default(<ASTLabelType>);
<if(!rewriteMode)>
<ASTLabelType> root_<treeLevel> = (<ASTLabelType>)adaptor.Nil();
<endif>
<root:element()>
<if(rewriteMode)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> )<endif>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
<if(root.el.rule)>
-if ( _first_<enclosingTreeLevel>==null ) _first_<enclosingTreeLevel> = <root.el.label>.Tree;
+if (_first_<enclosingTreeLevel> == null) _first_<enclosingTreeLevel> = <root.el.label>.Tree;
<else>
-if ( _first_<enclosingTreeLevel>==null ) _first_<enclosingTreeLevel> = <root.el.label>;
+if (_first_<enclosingTreeLevel> == null) _first_<enclosingTreeLevel> = <root.el.label>;
<endif>
<endif>
<actionsAfterRoot:element()>
<if(nullableChildList)>
-if ( input.LA(1)==TokenTypes.Down ) {
+if (input.LA(1) == TokenTypes.Down) {
Match(input, TokenTypes.Down, null); <checkRuleBacktrackFailure()>
<children:element()>
Match(input, TokenTypes.Up, null); <checkRuleBacktrackFailure()>
@@ -114,40 +114,40 @@ _last = (<ASTLabelType>)input.LT(1);
>>

/** ID auto construct */
-tokenRef(token,label,elementIndex,hetero) ::= <<
+tokenRef(token,label,elementIndex,terminalOptions) ::= <<
_last = (<ASTLabelType>)input.LT(1);
<super.tokenRef(...)>
<if(!rewriteMode)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
-<if(hetero)>
-<label>_tree = new <hetero>(<label>);
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<if(terminalOptions.class)>
+<label>_tree = new <terminalOptions.class>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text><endif>);
<else>
-<label>_tree = (<ASTLabelType>)adaptor.DupNode(<label>);
+<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text><endif>);
<endif><\n>
adaptor.AddChild(root_<treeLevel>, <label>_tree);
<if(backtracking)>}<endif>
<else> <! rewrite mode !>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> )<endif>
-if ( _first_<treeLevel>==null ) _first_<treeLevel> = <label>;
+<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
+if (_first_<treeLevel> == null) _first_<treeLevel> = <label>;
<endif>
>>

/** label+=TOKEN auto construct */
-tokenRefAndListLabel(token,label,elementIndex,hetero) ::= <<
+tokenRefAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
<tokenRef(...)>
<listLabel(elem=label,...)>
>>

/** ^(ID ...) auto construct */
-tokenRefRuleRoot(token,label,elementIndex,hetero) ::= <<
+tokenRefRuleRoot(token,label,elementIndex,terminalOptions) ::= <<
_last = (<ASTLabelType>)input.LT(1);
<super.tokenRef(...)>
<if(!rewriteMode)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
-<if(hetero)>
-<label>_tree = new <hetero>(<label>);
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<if(terminalOptions.class)>
+<label>_tree = new <terminalOptions.class>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text><endif>);
<else>
-<label>_tree = (<ASTLabelType>)adaptor.DupNode(<label>);
+<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text><endif>);
<endif><\n>
root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_<treeLevel>);
<if(backtracking)>}<endif>
@@ -155,37 +155,37 @@ root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_<treeLe
>>

/** Match ^(label+=TOKEN ...) auto construct */
-tokenRefRuleRootAndListLabel(token,label,elementIndex,hetero) ::= <<
+tokenRefRuleRootAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
<tokenRefRuleRoot(...)>
<listLabel(elem=label,...)>
>>

/** Match . wildcard and auto dup the node/subtree */
-wildcard(token,label,elementIndex,hetero) ::= <<
+wildcard(token,label,elementIndex,terminalOptions) ::= <<
_last = (<ASTLabelType>)input.LT(1);
<super.wildcard(...)>
<if(!rewriteMode)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<label>_tree = (<ASTLabelType>)adaptor.DupTree(<label>);
adaptor.AddChild(root_<treeLevel>, <label>_tree);
<if(backtracking)>}<endif>
<else> <! rewrite mode !>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> )<endif>
-if ( _first_<treeLevel>==null ) _first_<treeLevel> = <label>;
+<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
+if (_first_<treeLevel> == null) _first_<treeLevel> = <label>;
<endif>
>>

// SET AST

-matchSet(s,label,hetero,elementIndex,postmatchCode) ::= <<
+matchSet(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
_last = (<ASTLabelType>)input.LT(1);
<super.matchSet(..., postmatchCode={
<if(!rewriteMode)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
-<if(hetero)>
-<label>_tree = new <hetero>(<label>);
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<if(terminalOptions.class)>
+<label>_tree = new <terminalOptions.class>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text><endif>);
<else>
-<label>_tree = (<ASTLabelType>)adaptor.DupNode(<label>);
+<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text><endif>);
<endif><\n>
adaptor.AddChild(root_<treeLevel>, <label>_tree);
<if(backtracking)>}<endif>
@@ -194,7 +194,7 @@ adaptor.AddChild(root_<treeLevel>, <label>_tree);
)>
>>

-matchRuleBlockSet(s,label,hetero,elementIndex,postmatchCode,treeLevel="0") ::= <<
+matchRuleBlockSet(s,label,terminalOptions,elementIndex,postmatchCode,treeLevel="0") ::= <<
<matchSet(...)>
<noRewrite()> <! set return tree !>
>>
@@ -204,14 +204,14 @@ _last = (<ASTLabelType>)input.LT(1);
<super.matchSet(...)>
>>

-matchSetRuleRoot(s,label,hetero,elementIndex,debug) ::= <<
+matchSetRuleRoot(s,label,terminalOptions,elementIndex,debug) ::= <<
<super.matchSet(..., postmatchCode={
<if(!rewriteMode)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
-<if(hetero)>
-<label>_tree = new <hetero>(<label>);
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<if(terminalOptions.class)>
+<label>_tree = new <terminalOptions.class>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text><endif>);
<else>
-<label>_tree = (<ASTLabelType>)adaptor.DupNode(<label>);
+<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text><endif>);
<endif><\n>
root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_<treeLevel>);
<if(backtracking)>}<endif>
@@ -226,11 +226,11 @@ root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_<treeLe
ruleRef(rule,label,elementIndex,args,scope) ::= <<
_last = (<ASTLabelType>)input.LT(1);
<super.ruleRef(...)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
<if(!rewriteMode)>
adaptor.AddChild(root_<treeLevel>, <label>.Tree);
<else> <! rewrite mode !>
-if ( _first_<treeLevel>==null ) _first_<treeLevel> = <label>.Tree;
+if (_first_<treeLevel> == null) _first_<treeLevel> = <label>.Tree;
<endif>
>>

@@ -245,7 +245,7 @@ ruleRefRuleRoot(rule,label,elementIndex,args,scope) ::= <<
_last = (<ASTLabelType>)input.LT(1);
<super.ruleRef(...)>
<if(!rewriteMode)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>.Tree, root_<treeLevel>);
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>.Tree, root_<treeLevel>);
<endif>
>>

@@ -282,9 +282,9 @@ _last = (<ASTLabelType>)input.LT(1);
/** Streams for token refs are tree nodes now; override to
*  change NextToken to NextNode.
*/
-createRewriteNodeFromElement(token,hetero,scope) ::= <<
-<if(hetero)>
-new <hetero>(stream_<token>.NextNode())
+createRewriteNodeFromElement(token,terminalOptions,scope) ::= <<
+<if(terminalOptions.class)>
+new <terminalOptions.class>(<if(terminalOptions.type)><terminalOptions.type>,<endif>stream_<token>.NextNode())
<else>
stream_<token>.NextNode()
<endif>
@@ -293,7 +293,7 @@ stream_<token>.NextNode()
ruleCleanUp() ::= <<
<super.ruleCleanUp()>
<if(!rewriteMode)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<\n><endif>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
retval.Tree = (<ASTLabelType>)adaptor.RulePostProcessing(root_0);
<if(backtracking)>}<endif>
<endif>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
index baa8da9..0763048 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
@@ -1,10 +1,10 @@
/*
* [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -60,6 +60,16 @@ outputFile(	LEXER,PARSER,TREE_PARSER, actionScope, actions,
fileName, ANTLRVersion, generatedTimestamp, trace,
scopes, superClass, literals) ::=
<<
+//------------------------------------------------------------------------------
+// \<auto-generated>
+//     This code was generated by a tool.
+//     ANTLR Version: <ANTLRVersion>
+//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// \</auto-generated>
+//------------------------------------------------------------------------------
+
// $ANTLR <ANTLRVersion> <fileName> <generatedTimestamp>

// The variable 'variable' is assigned but its value is never used.
@@ -76,13 +86,6 @@ using Antlr.Runtime;
using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;
<endif>
-using Stack = System.Collections.Generic.Stack\<object>;
-using List = System.Collections.IList;
-using ArrayList = System.Collections.Generic.List\<object>;
-<if(backtracking)>
-using Map = System.Collections.IDictionary;
-using HashMap = System.Collections.Generic.Dictionary\<object, object>;
-<endif>
<@end>

<if(actions.(actionScope).namespace)>
@@ -99,6 +102,10 @@ namespace <actions.(actionScope).namespace>
<endif>
>>

+lexerInputStreamType() ::= <<
+<actions.(actionScope).inputStreamType; null="ICharStream">
+>>
+
lexer(grammar, name, tokens, scopes, rules, numRules, labelType="CommonToken",
filterMode, superClass={<if(actions.(actionScope).superClass)><actions.(actionScope).superClass><else>Antlr.Runtime.Lexer<endif>}) ::= <<
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "<ANTLRVersion>")]
@@ -122,12 +129,12 @@ public partial class <grammar.recognizerName> : <@superClassName><superClass><@e
OnCreated();
}

-	public <grammar.recognizerName>(ICharStream input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}> )
+	public <grammar.recognizerName>(<lexerInputStreamType()> input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}> )
: this(input, new RecognizerSharedState()<grammar.delegators:{g|, <g:delegateName()>}>)
{
}

-	public <grammar.recognizerName>(ICharStream input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
+	public <grammar.recognizerName>(<lexerInputStreamType()> input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
: base(input, state)
{
<if(memoize)>
@@ -145,10 +152,8 @@ public partial class <grammar.recognizerName> : <@superClassName><superClass><@e
}
public override string GrammarFileName { get { return "<fileName>"; } }

-	private static readonly bool[] decisionCanBacktrack = new bool[0];
-
<if(grammar.hasDelegates)>
-	public override ICharStream CharStream
+	public override <lexerInputStreamType()> CharStream
{
get
{
@@ -263,7 +268,7 @@ public override bool AlreadyParsedRule(IIntStream input, int ruleIndex)

actionGate() ::= "state.backtracking == 0"

-filteringActionGate() ::= "state.backtracking==1"
+filteringActionGate() ::= "state.backtracking == 1"

/** How to generate a parser */
genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
@@ -291,16 +296,6 @@ public partial class <grammar.recognizerName> : <@superClassName><superClass><@e

<scopes:{<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>
<@members>
-#if ANTLR_DEBUG
-	private static readonly bool[] decisionCanBacktrack =
-		new bool[]
-		{
-			false, // invalid decision
-			<grammar.decisions:{d | <booleanLiteral.(d.dfa.hasSynPred)>}; wrap="\n", separator=", ">
-		};
-#else
-	private static readonly bool[] decisionCanBacktrack = new bool[0];
-#endif
<! WARNING. bug in ST: this is cut-n-paste into Dbg.stg !>
public <grammar.recognizerName>( <inputStreamType> input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}> )
: this( input, new RecognizerSharedState()<grammar.delegators:{g|, <g:delegateName()>}> )
@@ -345,7 +340,7 @@ public <grammar.recognizerName>(<inputStreamType> input, RecognizerSharedState s

<if(cyclicDFAs)>
#region DFA
-	<cyclicDFAs:{dfa | DFA<dfa.decisionNumber> dfa<dfa.decisionNumber>;}; separator="\n">
+	<cyclicDFAs:{dfa | private DFA<dfa.decisionNumber> dfa<dfa.decisionNumber>;}; separator="\n">

protected override void InitDFAs()
{
@@ -405,14 +400,14 @@ treeParser(grammar, name, scopes, tokens, tokenNames, globalAction, rules,
*/
synpredRule(ruleName, ruleDescriptor, block, description, nakedBlock) ::=
<<
-partial void Enter_<ruleName>_fragment();
-partial void Leave_<ruleName>_fragment();
+partial void EnterRule_<ruleName>_fragment();
+partial void LeaveRule_<ruleName>_fragment();

// $ANTLR start <ruleName>
public <!final !>void <ruleName>_fragment(<ruleDescriptor.parameterScope:parameterScope(scope=it)>)
{
<ruleLabelDefs()>
-	Enter_<ruleName>_fragment();
+	EnterRule_<ruleName>_fragment();
EnterRule("<ruleName>_fragment", <ruleDescriptor.index>);
TraceIn("<ruleName>_fragment", <ruleDescriptor.index>);
try
@@ -423,7 +418,7 @@ public <!final !>void <ruleName>_fragment(<ruleDescriptor.parameterScope:paramet
{
TraceOut("<ruleName>_fragment", <ruleDescriptor.index>);
LeaveRule("<ruleName>_fragment", <ruleDescriptor.index>);
-		Leave_<ruleName>_fragment();
+		LeaveRule_<ruleName>_fragment();
}
}
// $ANTLR end <ruleName>
@@ -486,15 +481,15 @@ rule(ruleName,ruleDescriptor,block,emptyRule,description,exceptions,finally,memo
<ruleAttributeScope(scope=ruleDescriptor.ruleScope)>
<returnScope(scope=ruleDescriptor.returnScope)>

-partial void Enter_<ruleName>();
-partial void Leave_<ruleName>();
+partial void EnterRule_<ruleName>();
+partial void LeaveRule_<ruleName>();

// $ANTLR start "<ruleName>"
// <fileName>:<description>
[GrammarRule("<ruleName>")]
<csharpVisibilityMap.(ruleDescriptor.modifier); null="private"> <returnType()> <ruleName>(<ruleDescriptor.parameterScope:parameterScope(scope=it)>)
{
-	Enter_<ruleName>();
+	EnterRule_<ruleName>();
EnterRule("<ruleName>", <ruleDescriptor.index>);
TraceIn("<ruleName>", <ruleDescriptor.index>);
<ruleScopeSetUp()>
@@ -531,7 +526,7 @@ partial void Leave_<ruleName>();
{
TraceOut("<ruleName>", <ruleDescriptor.index>);
LeaveRule("<ruleName>", <ruleDescriptor.index>);
-		Leave_<ruleName>();
+		LeaveRule_<ruleName>();
<memoize()>
<ruleScopeCleanUp()>
<finally>
@@ -553,7 +548,7 @@ catch (<e.decl>)

ruleDeclarations() ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
-<returnType()> retval = new <returnType()>();
+<returnType()> retval = new <returnType()>(this);
retval.Start = (<labelType>)input.LT(1);<\n>
<else>
<ruleDescriptor.returnScope.attributes:{ a |
@@ -566,8 +561,8 @@ int <ruleDescriptor.name>_StartIndex = input.Index;
>>

ruleScopeSetUp() ::= <<
-<ruleDescriptor.useScopes:{<it>_stack.Push(new <it>_scope());<it>_scopeInit(<it>_stack.Peek());}; separator="\n">
-<ruleDescriptor.ruleScope:{<it.name>_stack.Push(new <it.name>_scope());<it.name>_scopeInit(<it.name>_stack.Peek());}; separator="\n">
+<ruleDescriptor.useScopes:{<it>_stack.Push(new <it>_scope(this));<it>_scopeInit(<it>_stack.Peek());}; separator="\n">
+<ruleDescriptor.ruleScope:{<it.name>_stack.Push(new <it.name>_scope(this));<it.name>_scopeInit(<it.name>_stack.Peek());}; separator="\n">
>>

ruleScopeCleanUp() ::= <<
@@ -577,10 +572,10 @@ ruleScopeCleanUp() ::= <<

ruleLabelDefs() ::= <<
<[ruleDescriptor.tokenLabels,ruleDescriptor.tokenListLabels,ruleDescriptor.wildcardTreeLabels,ruleDescriptor.wildcardTreeListLabels]
-    :{<labelType> <it.label.text>=null;}; separator="\n"
+    :{<labelType> <it.label.text> = default(<labelType>);}; separator="\n"
>
<[ruleDescriptor.tokenListLabels,ruleDescriptor.ruleListLabels,ruleDescriptor.wildcardTreeListLabels]
-    :{List list_<it.label.text>=null;}; separator="\n"
+    :{List\<<ASTLabelType>\> list_<it.label.text> = null;}; separator="\n"
>
<ruleDescriptor.ruleLabels:ruleLabelDef(label=it); separator="\n">
<ruleDescriptor.ruleListLabels:ruleLabelDef(label=it); separator="\n">
@@ -590,12 +585,17 @@ lexerRuleLabelDefs() ::= <<
<[ruleDescriptor.tokenLabels,
ruleDescriptor.tokenListLabels,
ruleDescriptor.ruleLabels]
-    :{<labelType> <it.label.text>=null;}; separator="\n"
+    :{<labelType> <it.label.text> = default(<labelType>);}; separator="\n"
+>
+<[ruleDescriptor.charListLabels,
+  ruleDescriptor.charLabels]
+	:{int <it.label.text> = 0;}; separator="\n"
>
-<ruleDescriptor.charLabels:{int <it.label.text>;}; separator="\n">
<[ruleDescriptor.tokenListLabels,
ruleDescriptor.ruleListLabels]
-    :{List list_<it.label.text>=null;}; separator="\n"
+    :{List\<<labelType>\> list_<it.label.text> = null;}; separator="\n"
+>
+<ruleDescriptor.charListLabels:{List\<int\> list_<it.label.text> = null;}; separator="\n"
>
>>

@@ -633,14 +633,14 @@ if (state.backtracking > 0) { Memoize(input, <ruleDescriptor.index>, <ruleDescri
*  fragment rules.
*/
lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) ::= <<
-partial void Enter_<ruleName>();
-partial void Leave_<ruleName>();
+partial void EnterRule_<ruleName>();
+partial void LeaveRule_<ruleName>();

// $ANTLR start "<ruleName>"
[GrammarRule("<ruleName>")]
<csharpVisibilityMap.(ruleDescriptor.modifier); null="private"> void m<ruleName>(<ruleDescriptor.parameterScope:parameterScope(scope=it)>)
{
-	Enter_<ruleName>();
+	EnterRule_<ruleName>();
EnterRule("<ruleName>", <ruleDescriptor.index>);
TraceIn("<ruleName>", <ruleDescriptor.index>);
<ruleScopeSetUp()>
@@ -669,7 +669,7 @@ partial void Leave_<ruleName>();
{
TraceOut("<ruleName>", <ruleDescriptor.index>);
LeaveRule("<ruleName>", <ruleDescriptor.index>);
-		Leave_<ruleName>();
+		LeaveRule_<ruleName>();
<ruleScopeCleanUp()>
<memoize()>
}
@@ -696,7 +696,7 @@ int alt<decisionNumber>=<maxAlt>;
<decls>
<@predecision()>
try { DebugEnterSubRule(<decisionNumber>);
-try { DebugEnterDecision(<decisionNumber>, decisionCanBacktrack[<decisionNumber>]);
+try { DebugEnterDecision(<decisionNumber>, <booleanLiteral.(decision.dfa.hasSynPred)>);
<decision>
} finally { DebugExitDecision(<decisionNumber>); }
<@postdecision()>
@@ -715,7 +715,7 @@ ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK
int alt<decisionNumber>=<maxAlt>;
<decls>
<@predecision()>
-try { DebugEnterDecision(<decisionNumber>, decisionCanBacktrack[<decisionNumber>]);
+try { DebugEnterDecision(<decisionNumber>, <booleanLiteral.(decision.dfa.hasSynPred)>);
<decision>
} finally { DebugExitDecision(<decisionNumber>); }
<@postdecision()>
@@ -755,7 +755,7 @@ while (true)
{
int alt<decisionNumber>=<maxAlt>;
<@predecision()>
-	try { DebugEnterDecision(<decisionNumber>, decisionCanBacktrack[<decisionNumber>]);
+	try { DebugEnterDecision(<decisionNumber>, <booleanLiteral.(decision.dfa.hasSynPred)>);
<decision>
} finally { DebugExitDecision(<decisionNumber>); }
<@postdecision()>
@@ -793,7 +793,7 @@ while (true)
{
int alt<decisionNumber>=<maxAlt>;
<@predecision()>
-	try { DebugEnterDecision(<decisionNumber>, decisionCanBacktrack[<decisionNumber>]);
+	try { DebugEnterDecision(<decisionNumber>, <booleanLiteral.(decision.dfa.hasSynPred)>);
<decision>
} finally { DebugExitDecision(<decisionNumber>); }
<@postdecision()>
@@ -859,18 +859,18 @@ DebugLocation(<it.line>, <it.pos>);
>>

/** match a token optionally with a label in front */
-tokenRef(token,label,elementIndex,hetero) ::= <<
+tokenRef(token,label,elementIndex,terminalOptions) ::= <<
<if(label)><label>=(<labelType>)<endif>Match(input,<token>,Follow._<token>_in_<ruleName><elementIndex>); <checkRuleBacktrackFailure()>
>>

/** ids+=ID */
-tokenRefAndListLabel(token,label,elementIndex,hetero) ::= <<
+tokenRefAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
<tokenRef(...)>
<listLabel(elem=label,...)>
>>

listLabel(label,elem) ::= <<
-if (list_<label>==null) list_<label>=new ArrayList();
+if (list_<label>==null) list_<label>=new List\<<labelType>\>();
list_<label>.Add(<elem>);<\n>
>>

@@ -1087,10 +1087,10 @@ int LA<decisionNumber>_<stateNumber> = input.LA(<k>);<\n>
else
{
<if(eotPredictsAlt)>
-	alt<decisionNumber>=<eotPredictsAlt>;
+	alt<decisionNumber> = <eotPredictsAlt>;
<else>
<ruleBacktrackFailure()>
-	NoViableAltException nvae = new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input);<\n>
+	NoViableAltException nvae = new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input);
DebugRecognitionException(nvae);
<@noViableAltException()>
throw nvae;<\n>
@@ -1119,18 +1119,18 @@ int LA<decisionNumber>_<stateNumber> = input.LA(<k>);<\n>
<edges; separator="\nelse "><\n>
<if(eotPredictsAlt)>
<if(!edges)>
-alt<decisionNumber>=<eotPredictsAlt>; <! if no edges, don't gen ELSE !>
+alt<decisionNumber> = <eotPredictsAlt>;<! if no edges, don't gen ELSE !>
<else>
else
{
-	alt<decisionNumber>=<eotPredictsAlt>;
+	alt<decisionNumber> = <eotPredictsAlt>;
}<\n>
<endif>
<endif>
>>

/** An accept state indicates a unique alternative has been predicted */
-dfaAcceptState(alt) ::= "alt<decisionNumber>=<alt>;"
+dfaAcceptState(alt) ::= "alt<decisionNumber> = <alt>;"

/** A simple edge with an expression.  If the expression is satisfied,
*  enter to the target state.  To handle gated productions, we may
@@ -1159,7 +1159,7 @@ default:
<else>
{
<ruleBacktrackFailure()>
-		NoViableAltException nvae = new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input);<\n>
+		NoViableAltException nvae = new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input);
DebugRecognitionException(nvae);
<@noViableAltException()>
throw nvae;
@@ -1325,7 +1325,7 @@ s = -1;
<if(semPredState)><! return input cursor to state before we rewound !>
input.Seek(index<decisionNumber>_<stateNumber>);<\n>
<endif>
-if ( s>=0 ) return s;
+if (s >= 0) return s;
break;
>>

@@ -1333,7 +1333,7 @@ break;
*  state to jump to next if successful.
*/
cyclicDFAEdge(labelExpr, targetStateNumber, edgeNumber, predicates) ::= <<
-if ( (<labelExpr>) <if(predicates)>&& (<predicates>)<endif>) {s = <targetStateNumber>;}<\n>
+if ((<labelExpr>)<if(predicates)> && (<predicates>)<endif>) {s = <targetStateNumber>;}<\n>
>>

/** An edge pointing at end-of-token; essentially matches any char;
@@ -1375,9 +1375,12 @@ setTest(ranges) ::= "<ranges; separator=\"||\">"

attributeScope(scope) ::= <<
<if(scope.attributes)>
-protected class <scope.name>_scope
+protected sealed partial class <scope.name>_scope
{
<scope.attributes:{public <it.decl>;}; separator="\n">
+
+	public <scope.name>_scope(<grammar.recognizerName> grammar) { OnCreated(grammar); }
+	partial void OnCreated(<grammar.recognizerName> grammar);
}
<if(scope.actions.scopeinit)>
protected void <scope.name>_scopeInit( <scope.name>_scope scope )
@@ -1395,7 +1398,7 @@ protected void <scope.name>_scopeAfter( <scope.name>_scope scope )
<else>
partial void <scope.name>_scopeAfter( <scope.name>_scope scope );<\n>
<endif>
-protected Stack\<<scope.name>_scope\> <scope.name>_stack = new Stack\<<scope.name>_scope\>();<\n>
+protected readonly Stack\<<scope.name>_scope\> <scope.name>_stack = new Stack\<<scope.name>_scope\>();<\n>
<endif>
>>

@@ -1458,7 +1461,7 @@ ruleLabelDef(label) ::= <<
*/
returnScope(scope) ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
-public class <ruleDescriptor:returnStructName()> : <if(TREE_PARSER)>Tree<else>Parser<endif>RuleReturnScope\<<labelType>\><@ruleReturnInterfaces()>
+<csharpVisibilityMap.(ruleDescriptor.modifier); null="private"> sealed partial class <ruleDescriptor:returnStructName()> : <if(TREE_PARSER)>Tree<else>Parser<endif>RuleReturnScope\<<labelType>\><@ruleReturnInterfaces()>
{
<scope.attributes:{public <it.decl>;}; separator="\n">
<@ruleReturnMembers()>
@@ -1466,6 +1469,11 @@ public class <ruleDescriptor:returnStructName()> : <if(TREE_PARSER)>Tree<else>Pa
<endif>
>>

+@returnScope.ruleReturnMembers() ::= <<
+public <ruleDescriptor:returnStructName()>(<grammar.recognizerName> grammar) {OnCreated(grammar);}
+partial void OnCreated(<grammar.recognizerName> grammar);
+>>
+
parameterScope(scope) ::= <<
<scope.attributes:{<it.decl>}; separator=", ">
>>
@@ -1546,9 +1554,9 @@ tokenLabelPropertyRef_index(scope,attr) ::= "(<scope>!=null?<scope>.TokenIndex:0
tokenLabelPropertyRef_tree(scope,attr) ::= "<scope>_tree"
tokenLabelPropertyRef_int(scope,attr) ::= "(<scope>!=null?int.Parse(<scope>.Text):0)"

-ruleLabelPropertyRef_start(scope,attr) ::= "(<scope>!=null?((<labelType>)<scope>.Start):null)"
-ruleLabelPropertyRef_stop(scope,attr) ::= "(<scope>!=null?((<labelType>)<scope>.Stop):null)"
-ruleLabelPropertyRef_tree(scope,attr) ::= "(<scope>!=null?((<ASTLabelType>)<scope>.Tree):null)"
+ruleLabelPropertyRef_start(scope,attr) ::= "(<scope>!=null?((<labelType>)<scope>.Start):default(<labelType>))"
+ruleLabelPropertyRef_stop(scope,attr) ::= "(<scope>!=null?((<labelType>)<scope>.Stop):default(<labelType>))"
+ruleLabelPropertyRef_tree(scope,attr) ::= "(<scope>!=null?((<ASTLabelType>)<scope>.Tree):default(<ASTLabelType>))"
ruleLabelPropertyRef_text(scope,attr) ::= <<
<if(TREE_PARSER)>
(<scope>!=null?(input.TokenStream.ToString(
@@ -1618,7 +1626,7 @@ ruleSetPropertyRef_st(scope,attr,expr) ::= "retval.Template =<expr>;"
/** How to execute an action (only when not backtracking) */
execAction(action) ::= <<
<if(backtracking)>
-if ( <actions.(actionScope).synpredgate> )
+if (<actions.(actionScope).synpredgate>)
{
<action>
}
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/ST.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/ST.stg
index 7475a43..46de225 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/ST.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/ST.stg
@@ -1,10 +1,10 @@
/*
* [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -45,6 +45,7 @@ using Antlr3.ST.Language;
private StringTemplate _st;
public StringTemplate Template { get { return _st; } set { _st = value; } }
public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
+<@super.ruleReturnMembers()>
>>

@genericParser.members() ::= <<
@@ -68,7 +69,7 @@ rewriteTemplate(alts) ::= <<

// TEMPLATE REWRITE
<if(backtracking)>
-if ( <actions.(actionScope).synpredgate> )
+if (<actions.(actionScope).synpredgate>)
{
<alts:rewriteTemplateAlt(); separator="else ">
<if(rewriteMode)><replaceTextInLine()><endif>
diff --git a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll
index 3ad6d75..923b254 100644
Binary files a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll and b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll differ

