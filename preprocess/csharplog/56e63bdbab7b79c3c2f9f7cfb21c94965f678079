commit 56e63bdbab7b79c3c2f9f7cfb21c94965f678079
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Sun Apr 10 12:12:12 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Sun Apr 10 12:12:12 2011 -0800

(C# 3) Merge CL8112: Add '...' pass through back in

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 8136]

diff --git a/Antlr4.StringTemplate/Compiler/Bytecode.cs b/Antlr4.StringTemplate/Compiler/Bytecode.cs
index 72b59c8..a24bb01 100644
--- a/Antlr4.StringTemplate/Compiler/Bytecode.cs
+++ b/Antlr4.StringTemplate/Compiler/Bytecode.cs
@@ -37,59 +37,61 @@ namespace Antlr4.StringTemplate.Compiler
Invalid = 0,

// INSTRUCTION BYTECODES (byte is signed; use a short to keep 0..255)
-        INSTR_LOAD_STR = 1,
-        INSTR_LOAD_ATTR = 2,
-        INSTR_LOAD_LOCAL = 3, // load stuff like it, i, i0
-        INSTR_LOAD_PROP = 4,
-        INSTR_LOAD_PROP_IND = 5,
-        INSTR_STORE_OPTION = 6,
-        INSTR_STORE_ARG = 7,
-        INSTR_NEW = 8,  // create new template instance
-        INSTR_NEW_IND = 9,  // create new instance using value on stack
-        INSTR_NEW_BOX_ARGS = 10, // create new instance using args in Map on stack
-        INSTR_SUPER_NEW = 11,  // create new instance using value on stack
-        INSTR_SUPER_NEW_BOX_ARGS = 12, // create new instance using args in Map on stack
-        INSTR_WRITE = 13,
-        INSTR_WRITE_OPT = 14,
-        INSTR_MAP = 15,  // <a:b()>, <a:b():c()>, <a:{...}>
-        INSTR_ROT_MAP = 16,  // <a:b(),c()>
-        INSTR_ZIP_MAP = 17,  // <names,phones:{n,p | ...}>
-        INSTR_BR = 18,
-        INSTR_BRF = 19,
-        INSTR_OPTIONS = 20,  // push options map
-        INSTR_ARGS = 21,  // push args map
-        INSTR_LIST = 22,
-        INSTR_ADD = 23,
-        INSTR_TOSTR = 24,
+        INSTR_LOAD_STR,
+        INSTR_LOAD_ATTR,
+        INSTR_LOAD_LOCAL, // load stuff like it, i, i0
+        INSTR_LOAD_PROP,
+        INSTR_LOAD_PROP_IND,
+        INSTR_STORE_OPTION,
+        INSTR_STORE_ARG,
+        INSTR_NEW,  // create new template instance
+        INSTR_NEW_IND,  // create new instance using value on stack
+        INSTR_NEW_BOX_ARGS, // create new instance using args in Map on stack
+        INSTR_SUPER_NEW,  // create new instance using value on stack
+        INSTR_SUPER_NEW_BOX_ARGS, // create new instance using args in Map on stack
+        INSTR_WRITE,
+        INSTR_WRITE_OPT,
+        INSTR_MAP,  // <a:b()>, <a:b():c()>, <a:{...}>
+        INSTR_ROT_MAP,  // <a:b(),c()>
+        INSTR_ZIP_MAP,  // <names,phones:{n,p | ...}>
+        INSTR_BR,
+        INSTR_BRF,
+        INSTR_OPTIONS,  // push options map
+        INSTR_ARGS,  // push args map
+        INSTR_PASSTHRU,
+        //INSTR_PASSTHRU_IND,
+        INSTR_LIST,
+        INSTR_ADD,
+        INSTR_TOSTR,

// Predefined functions
-        INSTR_FIRST = 25,
-        INSTR_LAST = 26,
-        INSTR_REST = 27,
-        INSTR_TRUNC = 28,
-        INSTR_STRIP = 29,
-        INSTR_TRIM = 30,
-        INSTR_LENGTH = 31,
-        INSTR_STRLEN = 32,
-        INSTR_REVERSE = 33,
+        INSTR_FIRST,
+        INSTR_LAST,
+        INSTR_REST,
+        INSTR_TRUNC,
+        INSTR_STRIP,
+        INSTR_TRIM,
+        INSTR_LENGTH,
+        INSTR_STRLEN,
+        INSTR_REVERSE,

-        INSTR_NOT = 34,
-        INSTR_OR = 35,
-        INSTR_AND = 36,
+        INSTR_NOT,
+        INSTR_OR,
+        INSTR_AND,

-        INSTR_INDENT = 37,
-        INSTR_DEDENT = 38,
-        INSTR_NEWLINE = 39,
+        INSTR_INDENT,
+        INSTR_DEDENT,
+        INSTR_NEWLINE,

-        INSTR_NOOP = 40, // do nothing
-        INSTR_POP = 41,
-        INSTR_NULL = 42, // push null value
-        INSTR_TRUE = 43, // push true
-        INSTR_FALSE = 44,
+        INSTR_NOOP, // do nothing
+        INSTR_POP,
+        INSTR_NULL, // push null value
+        INSTR_TRUE, // push true
+        INSTR_FALSE,

// Combined instructions

-        INSTR_WRITE_STR = 45,
-        INSTR_WRITE_LOCAL = 46,
+        INSTR_WRITE_STR, // load_str n, write
+        INSTR_WRITE_LOCAL, // TODO load_local n, write
}
}
diff --git a/Antlr4.StringTemplate/Compiler/CodeGenerator.g3 b/Antlr4.StringTemplate/Compiler/CodeGenerator.g3
index e83634a..6179d38 100644
--- a/Antlr4.StringTemplate/Compiler/CodeGenerator.g3
+++ b/Antlr4.StringTemplate/Compiler/CodeGenerator.g3
@@ -232,6 +232,7 @@ mapTemplateRef[int num_exprs]
args
)
{
+		if ( $args.passThru ) emit1($start, Bytecode.INSTR_PASSTHRU, $ID.text);
if ( $args.namedArgs ) emit1($INCLUDE, Bytecode.INSTR_NEW_BOX_ARGS, $ID.text);
else emit2($INCLUDE, Bytecode.INSTR_NEW, $ID.text, $args.n+$num_exprs);
}
@@ -260,11 +261,13 @@ includeExpr
:	^(EXEC_FUNC ID expr?)		{func($ID);}
|	^(INCLUDE ID args)
{
+		if ( $args.passThru ) emit1($start, Bytecode.INSTR_PASSTHRU, $ID.text);
if ( $args.namedArgs ) emit1($INCLUDE, Bytecode.INSTR_NEW_BOX_ARGS, $ID.text);
else emit2($INCLUDE, Bytecode.INSTR_NEW, $ID.text, $args.n);
}
|	^(INCLUDE_SUPER ID args)
{
+		if ( $args.passThru ) emit1($start, Bytecode.INSTR_PASSTHRU, $ID.text);
if ( $args.namedArgs ) emit1($INCLUDE_SUPER, Bytecode.INSTR_SUPER_NEW_BOX_ARGS, $ID.text);
else emit2($INCLUDE_SUPER, Bytecode.INSTR_SUPER_NEW, $ID.text, $args.n);
}
@@ -298,12 +301,14 @@ primary

arg : expr ;

-args returns [int n=0, bool namedArgs=false]
+args returns [int n=0, bool namedArgs=false, bool passThru]
:	( arg {$n++;} )+
|	{emit($args.start, Bytecode.INSTR_ARGS); $namedArgs=true;}
(	^(eq='=' ID expr)
{$n++; emit1($eq, Bytecode.INSTR_STORE_ARG, defineString($ID.text));}
)+
+		('...' {$passThru=true;})?
+	|	'...' {$passThru=true; emit($args.start, Bytecode.INSTR_ARGS); $namedArgs=true;}
|
;

diff --git a/Antlr4.StringTemplate/Compiler/Instruction.cs b/Antlr4.StringTemplate/Compiler/Instruction.cs
index 99115d9..881fffa 100644
--- a/Antlr4.StringTemplate/Compiler/Instruction.cs
+++ b/Antlr4.StringTemplate/Compiler/Instruction.cs
@@ -46,6 +46,8 @@
instructions[(int)Bytecode.INSTR_BRF] = new Instruction("brf", OperandType.Address);
instructions[(int)Bytecode.INSTR_OPTIONS] = new Instruction("options");
instructions[(int)Bytecode.INSTR_ARGS] = new Instruction("args");
+            instructions[(int)Bytecode.INSTR_PASSTHRU] = new Instruction("passthru", OperandType.String);
+            //instructions[(int)Bytecode.INSTR_PASSTHRU_IND] = new Instruction("passthru_ind", OperandType.Int);
instructions[(int)Bytecode.INSTR_LIST] = new Instruction("list");
instructions[(int)Bytecode.INSTR_ADD] = new Instruction("add");
instructions[(int)Bytecode.INSTR_TOSTR] = new Instruction("tostr");
diff --git a/Antlr4.StringTemplate/Compiler/TemplateLexer.tokens b/Antlr4.StringTemplate/Compiler/TemplateLexer.tokens
index 163edb3..90a98aa 100644
--- a/Antlr4.StringTemplate/Compiler/TemplateLexer.tokens
+++ b/Antlr4.StringTemplate/Compiler/TemplateLexer.tokens
@@ -32,6 +32,7 @@ END=34
TRUE=35
FALSE=36
COMMENT=37
+'...'=11
'super'=8
'|'=28
'!'=10
diff --git a/Antlr4.StringTemplate/Compiler/TemplateParser.g3 b/Antlr4.StringTemplate/Compiler/TemplateParser.g3
index 5bf6a30..e665056 100644
--- a/Antlr4.StringTemplate/Compiler/TemplateParser.g3
+++ b/Antlr4.StringTemplate/Compiler/TemplateParser.g3
@@ -249,7 +249,8 @@ primary

args
:	argExprList
-	|	namedArg (','! namedArg)*
+	|	namedArg (','! namedArg)* (','! '...')?
+	|	'...'
|
;

diff --git a/Antlr4.StringTemplate/Interpreter.cs b/Antlr4.StringTemplate/Interpreter.cs
index 4ba5f0d..197cf7c 100644
--- a/Antlr4.StringTemplate/Interpreter.cs
+++ b/Antlr4.StringTemplate/Interpreter.cs
@@ -36,8 +36,8 @@ namespace Antlr4.StringTemplate
using System.Linq;
using Antlr.Runtime.JavaExtensions;
using Antlr4.StringTemplate.Compiler;
-    using Antlr4.StringTemplate.Extensions;
using Antlr4.StringTemplate.Debug;
+    using Antlr4.StringTemplate.Extensions;
using Antlr4.StringTemplate.Misc;
using ArgumentNullException = System.ArgumentNullException;
using Array = System.Array;
@@ -45,6 +45,7 @@ namespace Antlr4.StringTemplate
using Console = System.Console;
using CultureInfo = System.Globalization.CultureInfo;
using Environment = System.Environment;
+    using Exception = System.Exception;
using ICollection = System.Collections.ICollection;
using IDictionary = System.Collections.IDictionary;
using IEnumerable = System.Collections.IEnumerable;
@@ -53,7 +54,6 @@ namespace Antlr4.StringTemplate
using Math = System.Math;
using StringBuilder = System.Text.StringBuilder;
using StringWriter = System.IO.StringWriter;
-    using Exception = System.Exception;

/** This class knows how to execute template bytecodes relative to a
*  particular TemplateGroup. To execute the byte codes, we need an output stream
@@ -206,6 +206,8 @@ namespace Antlr4.StringTemplate
try
{
o = GetAttribute(frame, name);
+                        if (o == Template.EmptyAttribute)
+                            o = null;
}
catch (TemplateNoSuchPropertyException)
{
@@ -377,6 +379,14 @@ namespace Antlr4.StringTemplate
operands[++sp] = new Dictionary<string, object>();
break;

+                case Bytecode.INSTR_PASSTHRU:
+                    nameIndex = GetShort(code, ip);
+                    ip += Instruction.OperandSizeInBytes;
+                    name = self.impl.strings[nameIndex];
+                    attrs = (IDictionary<string, object>)operands[sp];
+                    PassThrough(frame, name, attrs);
+                    break;
+
case Bytecode.INSTR_LIST:
operands[++sp] = new List<object>();
break;
@@ -597,6 +607,24 @@ namespace Antlr4.StringTemplate
operands[++sp] = st;
}

+        internal virtual void PassThrough(TemplateFrame frame, string templateName, IDictionary<string, object> attrs)
+        {
+            CompiledTemplate c = group.LookupTemplate(templateName);
+            if (c == null)
+                return; // will get error later
+
+            foreach (FormalArgument arg in c.FormalArguments)
+            {
+                if (!attrs.ContainsKey(arg.Name))
+                {
+                    //System.out.println("arg "+arg.name+" missing");
+                    object o = GetAttribute(frame, arg.Name);
+                    //System.out.println("setting to "+o);
+                    attrs[arg.Name] = o;
+                }
+            }
+        }
+
internal virtual void StoreArguments(TemplateFrame frame, IDictionary<string, object> attrs, Template st)
{
int nformalArgs = 0;
@@ -1354,8 +1382,6 @@ namespace Antlr4.StringTemplate
if (arg != null)
{
object o = template.locals[arg.Index];
-                    if (o == Template.EmptyAttribute)
-                        o = null;
return o;
}
scope = scope.Parent;
diff --git a/Antlr4.StringTemplate/TemplateFrame.cs b/Antlr4.StringTemplate/TemplateFrame.cs
index ca72851..c278c26 100644
--- a/Antlr4.StringTemplate/TemplateFrame.cs
+++ b/Antlr4.StringTemplate/TemplateFrame.cs
@@ -105,5 +105,32 @@ namespace Antlr4.StringTemplate
}
return stack;
}
+
+        public List<TemplateFrame> GetFrameStack(bool topdown)
+        {
+            List<TemplateFrame> stack = new List<TemplateFrame>();
+            for (TemplateFrame p = this; p != null; p = p.Parent)
+                stack.Add(p);
+
+            if (topdown)
+                stack.Reverse();
+
+            return stack;
+        }
+
+        public List<EvalTemplateEvent> GetEvalTemplateEventStack(bool topdown)
+        {
+            List<EvalTemplateEvent> stack = new List<EvalTemplateEvent>();
+            for (TemplateFrame p = this; p != null; p = p.Parent)
+            {
+                EvalTemplateEvent eval = (EvalTemplateEvent)p.GetDebugState().Events[p.GetDebugState().Events.Count - 1];
+                stack.Add(eval);
+            }
+
+            if (topdown)
+                stack.Reverse();
+
+            return stack;
+        }
}
}
diff --git a/Antlr4.Test.StringTemplate/TestCompiler.cs b/Antlr4.Test.StringTemplate/TestCompiler.cs
index c6c3d84..66d2402 100644
--- a/Antlr4.Test.StringTemplate/TestCompiler.cs
+++ b/Antlr4.Test.StringTemplate/TestCompiler.cs
@@ -33,10 +33,10 @@
namespace Antlr4.Test.StringTemplate
{
using Antlr4.StringTemplate;
-    using Microsoft.VisualStudio.TestTools.UnitTesting;
using Antlr4.StringTemplate.Compiler;
-    using Antlr4.Test.StringTemplate.Extensions;
using Antlr4.StringTemplate.Misc;
+    using Antlr4.Test.StringTemplate.Extensions;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;

[TestClass]
public class TestCompiler : BaseTest
@@ -78,6 +78,34 @@ namespace Antlr4.Test.StringTemplate
}

[TestMethod]
+        public void TestIncludeWithPassThrough()
+        {
+            string template = "hi <foo(...)>";
+            CompiledTemplate code = new TemplateCompiler(new TemplateGroup()).Compile(template);
+            string asmExpected =
+                "write_str 0, args, passthru 1, new_box_args 1, write";
+            string asmResult = code.GetInstructions();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[hi , foo]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestIncludeWithPartialPassThrough()
+        {
+            string template = "hi <foo(x=y,...)>";
+            CompiledTemplate code = new TemplateCompiler(new TemplateGroup()).Compile(template);
+            string asmExpected =
+                "write_str 0, args, load_attr 1, store_arg 2, passthru 3, new_box_args 3, write";
+            string asmResult = code.GetInstructions();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[hi , y, x, foo]";
+            string stringsResult = code.strings.ToListString();
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
public void TestSuperInclude()
{
string template = "<super.foo()>";
diff --git a/Antlr4.Test.StringTemplate/TestCoreBasics.cs b/Antlr4.Test.StringTemplate/TestCoreBasics.cs
index 3ae90dc..814aa97 100644
--- a/Antlr4.Test.StringTemplate/TestCoreBasics.cs
+++ b/Antlr4.Test.StringTemplate/TestCoreBasics.cs
@@ -326,6 +326,51 @@ namespace Antlr4.Test.StringTemplate
}

[TestMethod]
+        public void TestPassThru()
+        {
+            string templates =
+                "a(x,y) ::= \"<b(...)>\"\n" +
+                "b(x,y) ::= \"<x><y>\"\n";
+            TemplateGroup group = new TemplateGroupString(templates);
+            Template a = group.GetInstanceOf("a");
+            a.Add("x", "x");
+            a.Add("y", "y");
+            string expected = "xy";
+            string result = a.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestPassThruPartialArgs()
+        {
+            string templates =
+                "a(x,y) ::= \"<b(y={99},...)>\"\n" +
+                "b(x,y) ::= \"<x><y>\"\n";
+            TemplateGroup group = new TemplateGroupString(templates);
+            Template a = group.GetInstanceOf("a");
+            a.Add("x", "x");
+            a.Add("y", "y");
+            string expected = "x99";
+            string result = a.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestPassThruNoMissingArgs()
+        {
+            string templates =
+                "a(x,y) ::= \"<b(y={99},x={1},...)>\"\n" +
+                "b(x,y) ::= \"<x><y>\"\n";
+            TemplateGroup group = new TemplateGroupString(templates);
+            Template a = group.GetInstanceOf("a");
+            a.Add("x", "x");
+            a.Add("y", "y");
+            string expected = "199";
+            string result = a.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
public void TestDefineTemplate()
{
TemplateGroup group = new TemplateGroup();

