commit 590e3a17ba00a829fbab6545c443d780dda707d2
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Sun May 15 13:09:28 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Sun May 15 13:09:28 2011 -0800

(C# 3) Move nearly all extension methods from Antlr3.Runtime.Debug to Antlr3.Runtime.JavaExtensions
Modify the Antlr3.Runtime and Antlr3.Runtime.Debug libraries to target .NET 2.0 (without removing any features from the CSharp3 target)

[git-p4: depot-paths = "//depot/code/antlr/antlr3-main/": change = 8499]

diff --git a/Antlr3.Runtime.Debug/Antlr3.Runtime.Debug.csproj b/Antlr3.Runtime.Debug/Antlr3.Runtime.Debug.csproj
index 2f7087d..5ca19d8 100644
--- a/Antlr3.Runtime.Debug/Antlr3.Runtime.Debug.csproj
+++ b/Antlr3.Runtime.Debug/Antlr3.Runtime.Debug.csproj
@@ -10,7 +10,7 @@
<AppDesignerFolder>Properties</AppDesignerFolder>
<RootNamespace>Antlr.Runtime.Debug</RootNamespace>
<AssemblyName>Antlr3.Runtime.Debug</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
<FileAlignment>512</FileAlignment>
<SccProjectName>Perforce Project</SccProjectName>
<SccLocalPath>..\..\..\..\..\..</SccLocalPath>
@@ -19,7 +19,8 @@
<SccProvider>MSSCCI:Perforce SCM</SccProvider>
<SignAssembly>true</SignAssembly>
<AssemblyOriginatorKeyFile>..\..\..\..\..\..\..\keys\antlr\Key.snk</AssemblyOriginatorKeyFile>
-    <TargetFrameworkProfile>Client</TargetFrameworkProfile>
+    <TargetFrameworkProfile>
+    </TargetFrameworkProfile>
</PropertyGroup>
<PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
<DebugSymbols>true</DebugSymbols>
@@ -40,9 +41,6 @@
</PropertyGroup>
<ItemGroup>
<Reference Include="System" />
-    <Reference Include="System.Core">
-      <RequiredTargetFramework>3.5</RequiredTargetFramework>
-    </Reference>
</ItemGroup>
<ItemGroup>
<Compile Include="BlankDebugEventListener.cs" />
@@ -55,20 +53,7 @@
<Compile Include="DebugTreeAdaptor.cs" />
<Compile Include="DebugTreeNodeStream.cs" />
<Compile Include="DebugTreeParser.cs" />
-    <Compile Include="JavaExtensions\DictionaryExtensions.cs" />
<Compile Include="JavaExtensions\ExceptionExtensions.cs" />
-    <Compile Include="JavaExtensions\IOExtensions.cs" />
-    <Compile Include="JavaExtensions\JSystem.cs" />
-    <Compile Include="JavaExtensions\ListExtensions.cs" />
-    <Compile Include="JavaExtensions\ObjectExtensions.cs" />
-    <Compile Include="JavaExtensions\SetExtensions.cs" />
-    <Compile Include="JavaExtensions\StackExtensions.cs" />
-    <Compile Include="JavaExtensions\StringBuilderExtensions.cs" />
-    <Compile Include="JavaExtensions\StringExtensions.cs" />
-    <Compile Include="JavaExtensions\StringTokenizer.cs" />
-    <Compile Include="JavaExtensions\SubList.cs" />
-    <Compile Include="JavaExtensions\TreeExtensions.cs" />
-    <Compile Include="JavaExtensions\TypeExtensions.cs" />
<Compile Include="Misc\DoubleKeyMap`3.cs" />
<Compile Include="Misc\Stats.cs" />
<None Include="..\..\..\..\..\..\..\keys\antlr\Key.snk">
diff --git a/Antlr3.Runtime.Debug/DebugEventSocketProxy.cs b/Antlr3.Runtime.Debug/DebugEventSocketProxy.cs
index 789bcc8..64b0fd2 100644
--- a/Antlr3.Runtime.Debug/DebugEventSocketProxy.cs
+++ b/Antlr3.Runtime.Debug/DebugEventSocketProxy.cs
@@ -142,7 +142,7 @@ namespace Antlr.Runtime.Debug
}
catch ( IOException ioe )
{
-                ioe.PrintStackTrace( Console.Error );
+                ExceptionExtensions.PrintStackTrace( ioe, Console.Error );
}
}

@@ -155,7 +155,7 @@ namespace Antlr.Runtime.Debug
}
catch ( IOException ioe )
{
-                ioe.PrintStackTrace( Console.Error );
+                ExceptionExtensions.PrintStackTrace( ioe, Console.Error );
}
}

@@ -434,9 +434,9 @@ namespace Antlr.Runtime.Debug

protected virtual string EscapeNewlines( string txt )
{
-            txt = txt.replaceAll( "%", "%25" );   // escape all escape char ;)
-            txt = txt.replaceAll( "\n", "%0A" );  // escape \n
-            txt = txt.replaceAll( "\r", "%0D" );  // escape \r
+            txt = txt.Replace( "%", "%25" );   // escape all escape char ;)
+            txt = txt.Replace( "\n", "%0A" );  // escape \n
+            txt = txt.Replace( "\r", "%0D" );  // escape \r
return txt;
}

diff --git a/Antlr3.Runtime.Debug/DebugParser.cs b/Antlr3.Runtime.Debug/DebugParser.cs
index ca64113..18d8db8 100644
--- a/Antlr3.Runtime.Debug/DebugParser.cs
+++ b/Antlr3.Runtime.Debug/DebugParser.cs
@@ -95,7 +95,7 @@ namespace Antlr.Runtime.Debug
public virtual void ReportError( IOException e )
{
Console.Error.WriteLine( e );
-            e.PrintStackTrace( Console.Error );
+            ExceptionExtensions.PrintStackTrace( e, Console.Error );
}

public override void BeginResync()
diff --git a/Antlr3.Runtime.Debug/DebugTreeParser.cs b/Antlr3.Runtime.Debug/DebugTreeParser.cs
index 9c4510d..6461387 100644
--- a/Antlr3.Runtime.Debug/DebugTreeParser.cs
+++ b/Antlr3.Runtime.Debug/DebugTreeParser.cs
@@ -96,7 +96,7 @@ namespace Antlr.Runtime.Debug
public virtual void ReportError( IOException e )
{
Console.Error.WriteLine( e );
-            e.PrintStackTrace( Console.Error );
+            ExceptionExtensions.PrintStackTrace( e, Console.Error );
}

public override void ReportError( RecognitionException e )
diff --git a/Antlr3.Runtime.Debug/JavaExtensions/DictionaryExtensions.cs b/Antlr3.Runtime.Debug/JavaExtensions/DictionaryExtensions.cs
deleted file mode 100644
index 68a7a8d..0000000
--- a/Antlr3.Runtime.Debug/JavaExtensions/DictionaryExtensions.cs
+++ /dev/null
@@ -1,141 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System.Collections.Generic;
-using IDictionary = System.Collections.IDictionary;
-using ObsoleteAttribute = System.ObsoleteAttribute;
-
-#if DEBUG
-using System.Linq;
-#endif
-
-namespace Antlr.Runtime.JavaExtensions
-{
-    public static class DictionaryExtensions
-    {
-#if DEBUG
-        [Obsolete]
-        public static bool containsKey( this IDictionary map, object key )
-        {
-            return map.Contains( key );
-        }
-
-        [Obsolete]
-        public static object get( this IDictionary map, object key )
-        {
-            return map[key];
-        }
-#endif
-
-        public static TValue get<TKey, TValue>( this IDictionary<TKey, TValue> map, TKey key )
-        {
-            TValue value;
-            if ( map.TryGetValue( key, out value ) )
-                return value;
-
-            if ( typeof( TValue ).IsValueType )
-                throw new KeyNotFoundException();
-
-            return default( TValue );
-        }
-
-        // disambiguates
-        public static TValue get<TKey, TValue>( this Dictionary<TKey, TValue> map, TKey key )
-        {
-            TValue value;
-            if ( map.TryGetValue( key, out value ) )
-                return value;
-
-            if ( typeof( TValue ).IsValueType )
-                throw new KeyNotFoundException();
-
-            return default( TValue );
-        }
-
-        public static TValue get<TKey, TValue>( this SortedList<TKey, TValue> map, TKey key )
-        {
-            TValue value;
-            if ( map.TryGetValue( key, out value ) )
-                return value;
-
-            if ( typeof( TValue ).IsValueType )
-                throw new KeyNotFoundException();
-
-            return default( TValue );
-        }
-
-#if DEBUG
-        [Obsolete]
-        public static void put( this IDictionary map, object key, object value )
-        {
-            map[key] = value;
-        }
-
-        [Obsolete]
-        public static void put<TKey, TValue>( this IDictionary<TKey, TValue> map, TKey key, TValue value )
-        {
-            map[key] = value;
-        }
-
-        [Obsolete]
-        public static void put<TKey, TValue>( this Dictionary<TKey, TValue> map, TKey key, TValue value )
-        {
-            map[key] = value;
-        }
-
-        [Obsolete]
-        public static HashSet<object> keySet( this IDictionary map )
-        {
-            return new HashSet<object>( map.Keys.Cast<object>() );
-        }
-
-        [Obsolete]
-        public static HashSet<TKey> keySet<TKey, TValue>( this IDictionary<TKey, TValue> map )
-        {
-            return new HashSet<TKey>( map.Keys );
-        }
-
-        // disambiguates for Dictionary, which implements both IDictionary<T,K> and IDictionary
-        [Obsolete]
-        public static HashSet<TKey> keySet<TKey, TValue>( this Dictionary<TKey, TValue> map )
-        {
-            return new HashSet<TKey>( map.Keys );
-        }
-
-        [Obsolete]
-        public static HashSet<object> keySet<TKey, TValue>( this SortedList<TKey, TValue> map )
-        {
-            return new HashSet<object>( map.Keys.Cast<object>() );
-        }
-#endif
-    }
-}
diff --git a/Antlr3.Runtime.Debug/JavaExtensions/ExceptionExtensions.cs b/Antlr3.Runtime.Debug/JavaExtensions/ExceptionExtensions.cs
index 65696c8..0776cfe 100644
--- a/Antlr3.Runtime.Debug/JavaExtensions/ExceptionExtensions.cs
+++ b/Antlr3.Runtime.Debug/JavaExtensions/ExceptionExtensions.cs
@@ -1,10 +1,10 @@
﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -30,55 +30,14 @@
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

-using System;
-using System.Diagnostics;
-using System.Linq;
-
-using TargetInvocationException = System.Reflection.TargetInvocationException;
-
namespace Antlr.Runtime.JavaExtensions
{
-    public static class ExceptionExtensions
-    {
-#if DEBUG
-        [Obsolete]
-        public static string getMessage( this Exception e )
-        {
-            return e.Message;
-        }
-#endif
-
-        public static StackFrame[] getStackTrace( this Exception e )
-        {
-            StackTrace trace = new StackTrace( e, true );
-            StackFrame[] frames = trace.GetFrames();
-            if ( frames == null )
-            {
-                // don't include this helper function in the trace
-                frames = new StackTrace( true ).GetFrames().Skip( 1 ).ToArray();
-            }
-            return frames;
-        }
-
-#if DEBUG
-        [Obsolete]
-        public static string getMethodName( this StackFrame frame )
-        {
-            return frame.GetMethod().Name;
-        }
-
-        [Obsolete]
-        public static string getClassName( this StackFrame frame )
-        {
-            return frame.GetMethod().DeclaringType.Name;
-        }
-#endif
+    using Exception = System.Exception;
+    using TextWriter = System.IO.TextWriter;

-        public static void PrintStackTrace( this Exception e )
-        {
-            e.PrintStackTrace( Console.Out );
-        }
-        public static void PrintStackTrace( this Exception e, System.IO.TextWriter writer )
+    internal static class ExceptionExtensions
+    {
+        public static void PrintStackTrace( Exception e, TextWriter writer )
{
writer.WriteLine( e.ToString() );
string trace = e.StackTrace ?? string.Empty;
@@ -88,13 +47,5 @@ namespace Antlr.Runtime.JavaExtensions
writer.WriteLine( "        " + line );
}
}
-
-#if DEBUG
-        [Obsolete]
-        public static Exception getTargetException( this TargetInvocationException e )
-        {
-            return e.InnerException ?? e;
-        }
-#endif
}
}
diff --git a/Antlr3.Runtime.Debug/JavaExtensions/IOExtensions.cs b/Antlr3.Runtime.Debug/JavaExtensions/IOExtensions.cs
deleted file mode 100644
index c1fe293..0000000
--- a/Antlr3.Runtime.Debug/JavaExtensions/IOExtensions.cs
+++ /dev/null
@@ -1,94 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#if DEBUG
-
-using System;
-
-using TextReader = System.IO.TextReader;
-using TextWriter = System.IO.TextWriter;
-
-namespace Antlr.Runtime.JavaExtensions
-{
-    public static class IOExtensions
-    {
-        [Obsolete]
-        public static void close( this TextReader reader )
-        {
-            reader.Close();
-        }
-
-        [Obsolete]
-        public static void close( this TextWriter writer )
-        {
-            writer.Close();
-        }
-
-        [Obsolete]
-        public static void print<T>( this TextWriter writer, T value )
-        {
-            writer.Write( value );
-        }
-
-        [Obsolete]
-        public static void println( this TextWriter writer )
-        {
-            writer.WriteLine();
-        }
-
-        [Obsolete]
-        public static void println<T>( this TextWriter writer, T value )
-        {
-            writer.WriteLine( value );
-        }
-
-        [Obsolete]
-        public static void write<T>( this TextWriter writer, T value )
-        {
-            writer.Write( value );
-        }
-
-        [Obsolete]
-        public static int read( this TextReader reader, char[] buffer, int index, int count )
-        {
-            return reader.Read( buffer, index, count );
-        }
-
-        [Obsolete]
-        public static string readLine( this TextReader reader )
-        {
-            return reader.ReadLine();
-        }
-    }
-}
-
-#endif
diff --git a/Antlr3.Runtime.Debug/JavaExtensions/JSystem.cs b/Antlr3.Runtime.Debug/JavaExtensions/JSystem.cs
deleted file mode 100644
index d2bc2c0..0000000
--- a/Antlr3.Runtime.Debug/JavaExtensions/JSystem.cs
+++ /dev/null
@@ -1,89 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#if DEBUG
-namespace Antlr.Runtime.JavaExtensions
-{
-    using System;
-    using System.IO;
-
-    public static class JSystem
-    {
-        [Obsolete]
-        public static TextWriter err
-        {
-            get
-            {
-                return Console.Error;
-            }
-        }
-
-        [Obsolete]
-        public static TextWriter @out
-        {
-            get
-            {
-                return Console.Out;
-            }
-        }
-
-        [Obsolete]
-        public static void arraycopy<T>( T[] sourceArray, int sourceIndex, T[] destinationArray, int destinationIndex, int length )
-        {
-            Array.Copy( sourceArray, sourceIndex, destinationArray, destinationIndex, length );
-        }
-
-        [Obsolete]
-        public static string getProperty( string name )
-        {
-            switch ( name )
-            {
-            case "file.encoding":
-                return System.Text.Encoding.Default.WebName;
-
-            case "line.separator":
-                return Environment.NewLine;
-
-            case "java.io.tmpdir":
-                return System.IO.Path.GetTempPath();
-
-            case "user.home":
-                return Environment.GetFolderPath( Environment.SpecialFolder.Personal );
-
-            default:
-                throw new ArgumentException( string.Format( "Unknown system property: '{0}'", name ) );
-            }
-        }
-
-    }
-}
-#endif
diff --git a/Antlr3.Runtime.Debug/JavaExtensions/ListExtensions.cs b/Antlr3.Runtime.Debug/JavaExtensions/ListExtensions.cs
deleted file mode 100644
index 51c16bc..0000000
--- a/Antlr3.Runtime.Debug/JavaExtensions/ListExtensions.cs
+++ /dev/null
@@ -1,237 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Collections.Generic;
-using System.Linq;
-
-using ICollection = System.Collections.ICollection;
-using IEnumerable = System.Collections.IEnumerable;
-using IList = System.Collections.IList;
-
-namespace Antlr.Runtime.JavaExtensions
-{
-    public static class ListExtensions
-    {
-#if DEBUG
-        [Obsolete]
-        public static bool add( this IList list, object value )
-        {
-            int count = list.Count;
-            list.Add( value );
-            return list.Count == count + 1;
-        }
-
-        [Obsolete]
-        public static void add<T>( this ICollection<T> list, T value )
-        {
-            list.Add( value );
-        }
-
-        [Obsolete]
-        public static void add<T>( this List<T> list, T value )
-        {
-            list.Add( value );
-        }
-
-        [Obsolete]
-        public static void add( this IList list, int index, object value )
-        {
-            list.Insert( index, value );
-        }
-
-        [Obsolete]
-        public static void addAll( this List<object> list, IEnumerable items )
-        {
-            list.AddRange( items.Cast<object>() );
-        }
-#endif
-
-        public static void addAll( this IList list, IEnumerable items )
-        {
-            foreach ( object item in items )
-                list.Add( item );
-        }
-
-        public static void addAll<T>( this ICollection<T> list, IEnumerable<T> items )
-        {
-            foreach ( T item in items )
-                list.Add( item );
-        }
-
-#if DEBUG
-        [Obsolete]
-        public static void addElement( this List<object> list, object value )
-        {
-            list.Add( value );
-        }
-
-        [Obsolete]
-        public static void clear( this IList list )
-        {
-            list.Clear();
-        }
-
-        [Obsolete]
-        public static bool contains( this IList list, object value )
-        {
-            return list.Contains( value );
-        }
-
-        [Obsolete]
-        public static bool contains<T>( this ICollection<T> list, T value )
-        {
-            return list.Contains( value );
-        }
-
-        [Obsolete]
-        public static T elementAt<T>( this IList<T> list, int index )
-        {
-            return list[index];
-        }
-
-        [Obsolete]
-        public static object get( this IList list, int index )
-        {
-            return list[index];
-        }
-
-        [Obsolete]
-        public static T get<T>( this IList<T> list, int index )
-        {
-            return list[index];
-        }
-
-        // disambiguate
-        [Obsolete]
-        public static T get<T>( this List<T> list, int index )
-        {
-            return list[index];
-        }
-
-        [Obsolete]
-        public static object remove( this IList list, int index )
-        {
-            object o = list[index];
-            list.RemoveAt( index );
-            return o;
-        }
-
-        [Obsolete]
-        public static void remove<T>( this IList<T> list, T item )
-        {
-            list.Remove( item );
-        }
-
-        [Obsolete]
-        public static void set( this IList list, int index, object value )
-        {
-            list[index] = value;
-        }
-
-        [Obsolete]
-        public static void set<T>( this IList<T> list, int index, T value )
-        {
-            list[index] = value;
-        }
-
-        [Obsolete]
-        public static void set<T>( this List<T> list, int index, T value )
-        {
-            list[index] = value;
-        }
-#endif
-
-        public static void setSize<T>( this List<T> list, int size )
-        {
-            if ( list.Count < size )
-            {
-                list.AddRange( Enumerable.Repeat( default( T ), size - list.Count ) );
-            }
-            else if ( list.Count > size )
-            {
-                list.RemoveRange(size, list.Count - size);
-            }
-        }
-
-#if DEBUG
-        [Obsolete]
-        public static int size( this ICollection collection )
-        {
-            return collection.Count;
-        }
-
-        [Obsolete]
-        public static int size<T>( this ICollection<T> collection )
-        {
-            return collection.Count;
-        }
-
-        [Obsolete]
-        public static int size<T>( this List<T> list )
-        {
-            return list.Count;
-        }
-#endif
-
-        public static IList subList( this IList list, int fromIndex, int toIndex )
-        {
-            return new SubList( list, fromIndex, toIndex );
-            //return
-            //    list
-            //    .Cast<object>()
-            //    .Skip( fromIndex )
-            //    .Take( toIndex - fromIndex + 1 )
-            //    .ToList();
-        }
-
-        public static IList<T> subList<T>( this IList<T> list, int fromIndex, int toIndex )
-        {
-            return new SubList<T>( list, fromIndex, toIndex );
-            //return
-            //    list
-            //    .Skip( fromIndex )
-            //    .Take( toIndex - fromIndex + 1 )
-            //    .ToList();
-        }
-
-        public static IList<T> subList<T>( this List<T> list, int fromIndex, int toIndex )
-        {
-            return new SubList<T>( list, fromIndex, toIndex );
-            //return
-            //    list
-            //    .Skip( fromIndex )
-            //    .Take( toIndex - fromIndex + 1 )
-            //    .ToList();
-        }
-    }
-}
diff --git a/Antlr3.Runtime.Debug/JavaExtensions/ObjectExtensions.cs b/Antlr3.Runtime.Debug/JavaExtensions/ObjectExtensions.cs
deleted file mode 100644
index fe6a274..0000000
--- a/Antlr3.Runtime.Debug/JavaExtensions/ObjectExtensions.cs
+++ /dev/null
@@ -1,123 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-
-namespace Antlr.Runtime.JavaExtensions
-{
-    public static class ObjectExtensions
-    {
-#if DEBUG
-        [Obsolete]
-        public static bool booleanValue( this bool value )
-        {
-            return value;
-        }
-
-        [Obsolete]
-        public static Type getClass( this object o )
-        {
-            return o.GetType();
-        }
-#endif
-
-        public static int ShiftPrimeXOR( int a, int b )
-        {
-            int hash = 23;
-            hash = ( ( hash << 5 ) * 37 ) ^ a;
-            hash = ( ( hash << 5 ) * 37 ) ^ b;
-            return hash;
-        }
-
-        public static int ShiftPrimeXOR( int a, int b, int c )
-        {
-            int hash = 23;
-            hash = ( ( hash << 5 ) * 37 ) ^ a;
-            hash = ( ( hash << 5 ) * 37 ) ^ b;
-            hash = ( ( hash << 5 ) * 37 ) ^ c;
-            return hash;
-        }
-
-        public static int ShiftPrimeXOR( int a, int b, int c, int d )
-        {
-            int hash = 23;
-            hash = ( ( hash << 5 ) * 37 ) ^ a;
-            hash = ( ( hash << 5 ) * 37 ) ^ b;
-            hash = ( ( hash << 5 ) * 37 ) ^ c;
-            hash = ( ( hash << 5 ) * 37 ) ^ d;
-            return hash;
-        }
-
-        public static int ShiftPrimeXOR( params int[] a )
-        {
-            int hash = 23;
-            foreach ( int i in a )
-                hash = ( ( hash << 5 ) * 37 ) ^ i;
-            return hash;
-        }
-
-        public static int ShiftPrimeAdd( int a, int b )
-        {
-            int hash = 23;
-            hash = ( ( hash << 5 ) * 37 ) + a;
-            hash = ( ( hash << 5 ) * 37 ) + b;
-            return hash;
-        }
-
-        public static int ShiftPrimeAdd( int a, int b, int c )
-        {
-            int hash = 23;
-            hash = ( ( hash << 5 ) * 37 ) + a;
-            hash = ( ( hash << 5 ) * 37 ) + b;
-            hash = ( ( hash << 5 ) * 37 ) + c;
-            return hash;
-        }
-
-        public static int ShiftPrimeAdd( int a, int b, int c, int d )
-        {
-            int hash = 23;
-            hash = ( ( hash << 5 ) * 37 ) + a;
-            hash = ( ( hash << 5 ) * 37 ) + b;
-            hash = ( ( hash << 5 ) * 37 ) + c;
-            hash = ( ( hash << 5 ) * 37 ) + d;
-            return hash;
-        }
-
-        public static int ShiftPrimeAdd( params int[] a )
-        {
-            int hash = 23;
-            foreach ( int i in a )
-                hash = ( ( hash << 5 ) * 37 ) + i;
-            return hash;
-        }
-    }
-}
diff --git a/Antlr3.Runtime.Debug/JavaExtensions/SetExtensions.cs b/Antlr3.Runtime.Debug/JavaExtensions/SetExtensions.cs
deleted file mode 100644
index 881326e..0000000
--- a/Antlr3.Runtime.Debug/JavaExtensions/SetExtensions.cs
+++ /dev/null
@@ -1,89 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Collections.Generic;
-#if DEBUG
-using System.Linq;
-#endif
-
-namespace Antlr.Runtime.JavaExtensions
-{
-    public static class SetExtensions
-    {
-#if DEBUG
-        [Obsolete]
-        public static bool add<T>( this HashSet<T> set, T item )
-        {
-            return set.Add( item );
-        }
-#endif
-
-        public static void addAll<T>( this HashSet<T> set, IEnumerable<T> items )
-        {
-            foreach ( T item in items )
-                set.Add( item );
-        }
-
-#if DEBUG
-        [Obsolete]
-        public static void clear<T>( this HashSet<T> set )
-        {
-            set.Clear();
-        }
-
-        [Obsolete]
-        public static bool contains<T>( this HashSet<T> set, T value )
-        {
-            return set.Contains( value );
-        }
-
-        [Obsolete]
-        public static bool remove<T>( this HashSet<T> set, T item )
-        {
-            return set.Remove( item );
-        }
-
-        [Obsolete]
-        public static int size<T>( this HashSet<T> set )
-        {
-            return set.Count;
-        }
-
-        [Obsolete]
-        public static T[] toArray<T>( this HashSet<T> set )
-        {
-            return set.ToArray();
-        }
-#endif
-    }
-}
diff --git a/Antlr3.Runtime.Debug/JavaExtensions/StackExtensions.cs b/Antlr3.Runtime.Debug/JavaExtensions/StackExtensions.cs
deleted file mode 100644
index ab9ec71..0000000
--- a/Antlr3.Runtime.Debug/JavaExtensions/StackExtensions.cs
+++ /dev/null
@@ -1,84 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Collections.Generic;
-#if DEBUG
-using System.Linq;
-#endif
-
-namespace Antlr.Runtime.JavaExtensions
-{
-    public static class StackExtensions
-    {
-#if DEBUG
-        [Obsolete]
-        public static T elementAt<T>( this Stack<T> stack, int index )
-        {
-            return stack.ElementAt( index );
-        }
-
-        [Obsolete]
-        public static T peek<T>( this Stack<T> stack )
-        {
-            return stack.Peek();
-        }
-
-        [Obsolete]
-        public static T pop<T>( this Stack<T> stack )
-        {
-            return stack.Pop();
-        }
-
-        [Obsolete]
-        public static void push<T>( this Stack<T> stack, T obj )
-        {
-            stack.Push( obj );
-        }
-
-        [Obsolete]
-        public static int size<T>( this Stack<T> stack )
-        {
-            return stack.Count;
-        }
-#endif
-
-        public static void setSize<T>( this Stack<T> stack, int size )
-        {
-            if ( size > stack.Count )
-                throw new ArgumentException();
-
-            while ( stack.Count > size )
-                stack.Pop();
-        }
-    }
-}
diff --git a/Antlr3.Runtime.Debug/JavaExtensions/StringBuilderExtensions.cs b/Antlr3.Runtime.Debug/JavaExtensions/StringBuilderExtensions.cs
deleted file mode 100644
index 6ef6f27..0000000
--- a/Antlr3.Runtime.Debug/JavaExtensions/StringBuilderExtensions.cs
+++ /dev/null
@@ -1,75 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-
-using StringBuilder = System.Text.StringBuilder;
-
-#if DEBUG
-
-namespace Antlr.Runtime.JavaExtensions
-{
-    public static class StringBuilderExtensions
-    {
-        [Obsolete]
-        public static void append<T>( this StringBuilder buffer, T value )
-        {
-            buffer.Append( value );
-        }
-
-        [Obsolete]
-        public static char charAt( this StringBuilder buffer, int index )
-        {
-            return buffer[index];
-        }
-
-        [Obsolete]
-        public static int length( this StringBuilder buffer )
-        {
-            return buffer.Length;
-        }
-
-        [Obsolete]
-        public static void setCharAt( this StringBuilder buffer, int index, char c )
-        {
-            buffer[index] = c;
-        }
-
-        [Obsolete]
-        public static void setLength( this StringBuilder buffer, int length )
-        {
-            buffer.Length = length;
-        }
-    }
-}
-
-#endif
diff --git a/Antlr3.Runtime.Debug/JavaExtensions/StringExtensions.cs b/Antlr3.Runtime.Debug/JavaExtensions/StringExtensions.cs
deleted file mode 100644
index 8432512..0000000
--- a/Antlr3.Runtime.Debug/JavaExtensions/StringExtensions.cs
+++ /dev/null
@@ -1,151 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace Antlr.Runtime.JavaExtensions
-{
-    using ObsoleteAttribute = System.ObsoleteAttribute;
-    using Regex = System.Text.RegularExpressions.Regex;
-    using StringBuilder = System.Text.StringBuilder;
-
-    public static class StringExtensions
-    {
-#if DEBUG
-        [Obsolete]
-        public static char charAt( this string str, int index )
-        {
-            return str[index];
-        }
-
-        [Obsolete]
-        public static bool endsWith( this string str, string value )
-        {
-            return str.EndsWith( value );
-        }
-
-        [Obsolete]
-        public static int indexOf( this string str, char value )
-        {
-            return str.IndexOf( value );
-        }
-
-        [Obsolete]
-        public static int indexOf( this string str, char value, int startIndex )
-        {
-            return str.IndexOf( value, startIndex );
-        }
-
-        [Obsolete]
-        public static int indexOf( this string str, string value )
-        {
-            return str.IndexOf( value );
-        }
-
-        [Obsolete]
-        public static int indexOf( this string str, string value, int startIndex )
-        {
-            return str.IndexOf( value, startIndex );
-        }
-
-        [Obsolete]
-        public static int lastIndexOf( this string str, char value )
-        {
-            return str.LastIndexOf( value );
-        }
-
-        [Obsolete]
-        public static int lastIndexOf( this string str, string value )
-        {
-            return str.LastIndexOf( value );
-        }
-
-        [Obsolete]
-        public static int length( this string str )
-        {
-            return str.Length;
-        }
-
-        [Obsolete]
-        public static string replace(this string str, char oldValue, char newValue)
-        {
-            return str.Replace(oldValue, newValue);
-        }
-#endif
-
-        public static string replaceAll( this string str, string regex, string newValue )
-        {
-            return Regex.Replace( str, regex, newValue );
-        }
-
-        public static string replaceFirst( this string str, string regex, string replacement )
-        {
-            return Regex.Replace( str, regex, replacement );
-        }
-
-#if DEBUG
-        [Obsolete]
-        public static bool startsWith( this string str, string value )
-        {
-            return str.StartsWith( value );
-        }
-
-        [Obsolete]
-        public static string substring( this string str, int startOffset )
-        {
-            return str.Substring( startOffset );
-        }
-
-        [Obsolete]
-        public static string substring(this string str, int startOffset, int endOffset)
-        {
-            return str.Substring( startOffset, endOffset - startOffset );
-        }
-
-        [Obsolete]
-        public static char[] toCharArray( this string str )
-        {
-            return str.ToCharArray();
-        }
-
-        [Obsolete]
-        public static string toUpperCase( this string str )
-        {
-            return str.ToUpperInvariant();
-        }
-
-        [Obsolete]
-        public static string trim( this string str )
-        {
-            return str.Trim();
-        }
-#endif
-    }
-}
diff --git a/Antlr3.Runtime.Debug/JavaExtensions/StringTokenizer.cs b/Antlr3.Runtime.Debug/JavaExtensions/StringTokenizer.cs
deleted file mode 100644
index 0145df5..0000000
--- a/Antlr3.Runtime.Debug/JavaExtensions/StringTokenizer.cs
+++ /dev/null
@@ -1,87 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Linq;
-
-namespace Antlr.Runtime.JavaExtensions
-{
-    public class StringTokenizer
-    {
-        string[] _tokens;
-        int _current;
-
-        public StringTokenizer( string str, string separator )
-            : this( str, separator, false )
-        {
-        }
-        public StringTokenizer( string str, string separator, bool returnDelims )
-        {
-            _tokens = str.Split( separator.ToCharArray(), StringSplitOptions.None );
-            if ( returnDelims )
-            {
-                char[] delims = separator.ToCharArray();
-                _tokens = _tokens.SelectMany( ( token, i ) =>
-                {
-                    if ( i == _tokens.Length - 1 )
-                    {
-                        if ( delims.Contains( str[str.Length - 1] ) )
-                            return new string[0];
-                        else
-                            return new string[] { token };
-                    }
-                    else if ( i == 0 )
-                    {
-                        if ( delims.Contains( str[0] ) )
-                            return new string[] { str[0].ToString() };
-                        else
-                            return new string[] { token };
-                    }
-                    else
-                    {
-                        return new string[] { token, str[_tokens.Take( i + 1 ).Select( t => t.Length + 1 ).Sum() - 1].ToString() };
-                    }
-                } ).ToArray();
-            }
-        }
-
-        public bool hasMoreTokens()
-        {
-            return _current < _tokens.Length;
-        }
-
-        public string nextToken()
-        {
-            return _tokens[_current++];
-        }
-    }
-}
diff --git a/Antlr3.Runtime.Debug/JavaExtensions/SubList.cs b/Antlr3.Runtime.Debug/JavaExtensions/SubList.cs
deleted file mode 100644
index 97025bf..0000000
--- a/Antlr3.Runtime.Debug/JavaExtensions/SubList.cs
+++ /dev/null
@@ -1,423 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Collections;
-
-namespace Antlr.Runtime.JavaExtensions
-{
-    public class SubList
-        : IList
-    {
-        IList _source;
-        int _startIndex;
-        int _endIndex;
-
-        public SubList( IList source, int startIndex, int endIndex )
-        {
-            if ( source == null )
-                throw new ArgumentNullException( "source" );
-            if ( startIndex < 0 || endIndex < 0 )
-                throw new ArgumentOutOfRangeException();
-            if ( startIndex > endIndex || endIndex >= source.Count )
-                throw new ArgumentException();
-
-            _source = source;
-            _startIndex = startIndex;
-            _endIndex = endIndex;
-        }
-
-        #region IList Members
-
-        public int Add( object value )
-        {
-            throw new NotSupportedException();
-        }
-
-        public void Clear()
-        {
-            throw new NotSupportedException();
-        }
-
-        public bool Contains( object value )
-        {
-            return _source
-                .Cast<object>()
-                .Skip( _startIndex )
-                .Take( _endIndex - _startIndex + 1 )
-                .Contains( value );
-        }
-
-        public int IndexOf( object value )
-        {
-            for ( int i = 0; i < Count; i++ )
-            {
-                if ( object.Equals( this[i], value ) )
-                    return i;
-            }
-
-            return -1;
-        }
-
-        public void Insert( int index, object value )
-        {
-            throw new NotSupportedException();
-        }
-
-        public bool IsFixedSize
-        {
-            get
-            {
-                return true;
-            }
-        }
-
-        public bool IsReadOnly
-        {
-            get
-            {
-                return true;
-            }
-        }
-
-        public void Remove( object value )
-        {
-            throw new NotSupportedException();
-        }
-
-        public void RemoveAt( int index )
-        {
-            throw new NotSupportedException();
-        }
-
-        public object this[int index]
-        {
-            get
-            {
-                if ( index < 0 || index >= Count )
-                    throw new ArgumentOutOfRangeException();
-
-                return _source[index + _startIndex];
-            }
-            set
-            {
-                if ( index < 0 || index >= Count )
-                    throw new ArgumentOutOfRangeException();
-
-                _source[index + _startIndex] = value;
-            }
-        }
-
-        #endregion
-
-        #region ICollection Members
-
-        public void CopyTo( Array array, int index )
-        {
-            if ( array == null )
-                throw new ArgumentNullException( "array" );
-
-            if ( index < 0 )
-                throw new ArgumentOutOfRangeException();
-
-            if ( index + Count > array.Length )
-                throw new ArgumentException();
-
-            for ( int i = 0; i < Count; i++ )
-            {
-                array.SetValue( this[i], index + i );
-            }
-        }
-
-        public int Count
-        {
-            get
-            {
-                return _endIndex - _startIndex + 1;
-            }
-        }
-
-        public bool IsSynchronized
-        {
-            get
-            {
-                return false;
-            }
-        }
-
-        public object SyncRoot
-        {
-            get
-            {
-                return _source.SyncRoot;
-            }
-        }
-
-        #endregion
-
-        #region IEnumerable Members
-
-        public System.Collections.IEnumerator GetEnumerator()
-        {
-            return _source.Cast<object>()
-                .Skip( _startIndex )
-                .Take( _endIndex - _startIndex + 1 )
-                .GetEnumerator();
-        }
-
-        #endregion
-    }
-
-    public class SubList<T> : IList<T>, ICollection<T>, IEnumerable<T>, IList, ICollection, IEnumerable
-    {
-        IList<T> _source;
-        int _startIndex;
-        int _endIndex;
-
-        public SubList( IList<T> source, int startIndex, int endIndex )
-        {
-            if ( source == null )
-                throw new ArgumentNullException( "source" );
-            if ( startIndex < 0 || endIndex < 0 )
-                throw new ArgumentOutOfRangeException();
-            if ( startIndex > endIndex || endIndex >= source.Count )
-                throw new ArgumentException();
-
-            _source = source;
-            _startIndex = startIndex;
-            _endIndex = endIndex;
-        }
-
-        #region IEnumerable Members
-
-        IEnumerator IEnumerable.GetEnumerator()
-        {
-            return GetEnumerator();
-        }
-
-        #endregion
-
-        #region ICollection Members
-
-        void ICollection.CopyTo( Array array, int index )
-        {
-            if ( array == null )
-                throw new ArgumentNullException( "array" );
-
-            if ( index < 0 )
-                throw new ArgumentOutOfRangeException();
-
-            if ( index + Count > array.Length )
-                throw new ArgumentException();
-
-            for ( int i = 0; i < Count; i++ )
-            {
-                array.SetValue( this[i], index + i );
-            }
-        }
-
-        public int Count
-        {
-            get
-            {
-                return _endIndex - _startIndex + 1;
-            }
-        }
-
-        public bool IsSynchronized
-        {
-            get
-            {
-                ICollection sourceCollection = _source as ICollection;
-                if ( sourceCollection != null )
-                    return sourceCollection.IsSynchronized;
-
-                return false;
-            }
-        }
-
-        public object SyncRoot
-        {
-            get
-            {
-                ICollection sourceCollection = _source as ICollection;
-                if ( sourceCollection != null )
-                    return sourceCollection.SyncRoot;
-
-                return _source;
-            }
-        }
-
-        #endregion
-
-        #region IList Members
-
-        int IList.Add( object value )
-        {
-            throw new NotSupportedException();
-        }
-
-        void IList.Clear()
-        {
-            throw new NotSupportedException();
-        }
-
-        public bool Contains( object value )
-        {
-            return _source.Cast<object>().Skip( _startIndex ).Take( Count ).Contains( value );
-        }
-
-        public int IndexOf( object value )
-        {
-            for ( int i = _startIndex; i <= _endIndex; i++ )
-            {
-                if ( object.Equals( _source[i], value ) )
-                    return i - _startIndex;
-            }
-
-            return -1;
-        }
-
-        void IList.Insert( int index, object value )
-        {
-            throw new NotSupportedException();
-        }
-
-        public bool IsFixedSize
-        {
-            get
-            {
-                var sourceCollection = _source as IList;
-                if ( sourceCollection != null )
-                    return sourceCollection.IsFixedSize;
-
-                return false;
-            }
-        }
-
-        public bool IsReadOnly
-        {
-            get
-            {
-                return true;
-            }
-        }
-
-        void IList.Remove( object value )
-        {
-            throw new NotSupportedException();
-        }
-
-        void IList.RemoveAt( int index )
-        {
-            throw new NotSupportedException();
-        }
-
-        object IList.this[int index]
-        {
-            get
-            {
-                return this[index];
-            }
-            set
-            {
-                this[index] = (T)value;
-            }
-        }
-
-        #endregion
-
-        #region IEnumerable<T> Members
-
-        public IEnumerator<T> GetEnumerator()
-        {
-            return _source.Skip( _startIndex ).Take( Count ).GetEnumerator();
-        }
-
-        #endregion
-
-        #region ICollection<T> Members
-
-        void ICollection<T>.Add( T item )
-        {
-            throw new NotSupportedException();
-        }
-
-        void ICollection<T>.Clear()
-        {
-            throw new NotSupportedException();
-        }
-
-        public bool Contains( T item )
-        {
-            return _source.Skip( _startIndex ).Take( Count ).Contains( item );
-        }
-
-        public void CopyTo( T[] array, int arrayIndex )
-        {
-            if ( array == null )
-                throw new ArgumentNullException( "array" );
-
-            if ( arrayIndex < 0 )
-                throw new ArgumentOutOfRangeException();
-
-            if ( arrayIndex + Count > array.Length )
-                throw new ArgumentException();
-
-            for ( int i = 0; i < Count; i++ )
-            {
-                array[arrayIndex + i] = this[i];
-            }
-        }
-
-        bool ICollection<T>.Remove( T item )
-        {
-            throw new NotSupportedException();
-        }
-
-        #endregion
-
-        #region IList<T> Members
-
-        public int IndexOf( T item )
-        {
-            for ( int i = 0; i < Count; i++ )
-            {
-                if ( object.Equals( this[i], item ) )
-                    return i;
-            }
-
-            return -1;
-        }
-
-        void IList<T>.Insert( int index, T item )
-        {
-            throw new NotSupportedException();
-        }
-
-        void IList<T>.RemoveAt( int index )
-        {
-            throw new NotSupportedException();
-        }
-
-        public T this[int index]
-        {
-            get
-            {
-                if ( index < 0 || index >= Count )
-                    throw new ArgumentOutOfRangeException();
-
-                return _source[index + _startIndex];
-            }
-            set
-            {
-                if ( index < 0 || index >= Count )
-                    throw new ArgumentOutOfRangeException();
-
-                _source[index + _startIndex] = value;
-            }
-        }
-
-        #endregion
-    }
-}
diff --git a/Antlr3.Runtime.Debug/JavaExtensions/TreeExtensions.cs b/Antlr3.Runtime.Debug/JavaExtensions/TreeExtensions.cs
deleted file mode 100644
index 6f7182f..0000000
--- a/Antlr3.Runtime.Debug/JavaExtensions/TreeExtensions.cs
+++ /dev/null
@@ -1,53 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-using ITree = Antlr.Runtime.Tree.ITree;
-
-namespace Antlr.Runtime.JavaExtensions
-{
-    public static class TreeExtensions
-    {
-        public static ITree getNextSibling( this ITree tree )
-        {
-            return tree.Parent.GetChild( tree.ChildIndex + 1 );
-            //throw new NotImplementedException();
-        }
-
-        public static void setFirstChild( this ITree tree, ITree child )
-        {
-            if ( tree.ChildCount == 0 )
-                tree.AddChild( child );
-            else
-                tree.SetChild( 0, child );
-        }
-    }
-}
diff --git a/Antlr3.Runtime.Debug/JavaExtensions/TypeExtensions.cs b/Antlr3.Runtime.Debug/JavaExtensions/TypeExtensions.cs
deleted file mode 100644
index 42c0368..0000000
--- a/Antlr3.Runtime.Debug/JavaExtensions/TypeExtensions.cs
+++ /dev/null
@@ -1,102 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Reflection;
-
-#if DEBUG
-
-namespace Antlr.Runtime.JavaExtensions
-{
-    public static class TypeExtensions
-    {
-        [Obsolete]
-        public static object get( this FieldInfo field, object obj )
-        {
-            return field.GetValue( obj );
-        }
-
-        [Obsolete]
-        public static Type getComponentType( this Type type )
-        {
-            return type.GetElementType();
-        }
-
-        [Obsolete]
-        public static ConstructorInfo getConstructor( this Type type, Type[] argumentTypes )
-        {
-            return type.GetConstructor( argumentTypes );
-        }
-
-        [Obsolete]
-        public static FieldInfo getField( this Type type, string name )
-        {
-            FieldInfo field = type.GetField( name );
-            if ( field == null )
-                throw new TargetException();
-
-            return field;
-        }
-
-        [Obsolete]
-        public static string getName( this Type type )
-        {
-            return type.Name;
-        }
-
-        [Obsolete]
-        public static object invoke( this MethodInfo method, object obj, params object[] parameters )
-        {
-            return method.Invoke( obj, parameters );
-        }
-
-        [Obsolete]
-        public static bool isArray( this Type type )
-        {
-            return type.IsArray;
-        }
-
-        [Obsolete]
-        public static bool isPrimitive( this Type type )
-        {
-            return type.IsPrimitive;
-        }
-
-        [Obsolete]
-        public static object newInstance( this Type type )
-        {
-            return type.GetConstructor( new Type[0] ).Invoke( new object[0] );
-        }
-    }
-}
-
-#endif
diff --git a/Antlr3.Runtime.Debug/Misc/DoubleKeyMap`3.cs b/Antlr3.Runtime.Debug/Misc/DoubleKeyMap`3.cs
index 99e7bfd..16cfc26 100644
--- a/Antlr3.Runtime.Debug/Misc/DoubleKeyMap`3.cs
+++ b/Antlr3.Runtime.Debug/Misc/DoubleKeyMap`3.cs
@@ -73,15 +73,14 @@

public virtual ICollection<TValue> Values()
{
-            HashSet<TValue> s = new HashSet<TValue>();
+            Dictionary<TValue, bool> s = new Dictionary<TValue, bool>();
foreach (IDictionary<TKey2, TValue> k2 in data.Values)
{
foreach (TValue v in k2.Values)
-                {
-                    s.Add(v);
-                }
+                    s[v] = true;
}
-            return s;
+
+            return s.Keys;
}
}
}
diff --git a/Antlr3.Runtime.Debug/Misc/Stats.cs b/Antlr3.Runtime.Debug/Misc/Stats.cs
index 60e0782..6a465f7 100644
--- a/Antlr3.Runtime.Debug/Misc/Stats.cs
+++ b/Antlr3.Runtime.Debug/Misc/Stats.cs
@@ -33,7 +33,6 @@
namespace Antlr.Runtime.Misc
{
using System.Collections.Generic;
-    using System.Linq;

using Directory = System.IO.Directory;
using Environment = System.Environment;
@@ -41,10 +40,6 @@ namespace Antlr.Runtime.Misc
using Math = System.Math;
using Path = System.IO.Path;

-#if DEBUG
-    using ObsoleteAttribute = System.ObsoleteAttribute;
-#endif
-
/** <summary>Stats routines needed by profiler etc...</summary>
*
*  <remarks>
@@ -78,7 +73,7 @@ namespace Antlr.Runtime.Misc
{
return 0;
}
-            double xbar = X.Average();
+            double xbar = Average(X);
double s2 = 0.0;
for ( int i = 0; i < m; i++ )
{
@@ -94,7 +89,7 @@ namespace Antlr.Runtime.Misc
{
return 0;
}
-            double xbar = X.Average();
+            double xbar = Average(X);
double s2 = 0.0;
for ( int i = 0; i < m; i++ )
{
@@ -104,32 +99,18 @@ namespace Antlr.Runtime.Misc
return Math.Sqrt( s2 );
}

-#if DEBUG
/** <summary>Compute the sample mean</summary> */
-        [Obsolete]
-        public static double avg( IList<int> X )
-        {
-            return X.DefaultIfEmpty( 0 ).Average();
-        }
-
-        [Obsolete]
-        public static int min( IList<int> X )
+        public static double Average(ICollection<int> X)
{
-            return X.DefaultIfEmpty( int.MaxValue ).Min();
-        }
+            if (X.Count == 0)
+                return 0.0;

-        [Obsolete]
-        public static int max( IList<int> X )
-        {
-            return X.DefaultIfEmpty( int.MinValue ).Max();
-        }
+            double sum = 0.0;
+            foreach (int i in X)
+                sum += i;

-        [Obsolete]
-        public static int sum( IList<int> X )
-        {
-            return X.Sum();
+            return sum / X.Count;
}
-#endif

public static void WriteReport( string filename, string data )
{
diff --git a/Antlr3.Runtime.Debug/ParseTreeBuilder.cs b/Antlr3.Runtime.Debug/ParseTreeBuilder.cs
index a2b1a4d..deeaf3b 100644
--- a/Antlr3.Runtime.Debug/ParseTreeBuilder.cs
+++ b/Antlr3.Runtime.Debug/ParseTreeBuilder.cs
@@ -33,7 +33,6 @@
namespace Antlr.Runtime.Debug
{
using System.Collections.Generic;
-    using System.Linq;
using ParseTree = Antlr.Runtime.Tree.ParseTree;

/** <summary>
@@ -59,7 +58,7 @@ namespace Antlr.Runtime.Debug
{
get
{
-                return callStack.First();
+                return callStack.Peek();
}
}

diff --git a/Antlr3.Runtime.Debug/Profiler.cs b/Antlr3.Runtime.Debug/Profiler.cs
index 5048eea..54caac8 100644
--- a/Antlr3.Runtime.Debug/Profiler.cs
+++ b/Antlr3.Runtime.Debug/Profiler.cs
@@ -71,7 +71,7 @@ namespace Antlr.Runtime.Debug
protected int ruleLevel = 0;
//protected int decisionLevel = 0;
protected IToken lastRealTokenTouchedInDecision;
-        protected HashSet<string> uniqueRules = new HashSet<string>();
+        protected Dictionary<string, bool> uniqueRules = new Dictionary<string, bool>();
protected Stack<string> currentGrammarFileName = new Stack<string>();
protected Stack<string> currentRuleName = new Stack<string>();
protected Stack<int> currentLine = new Stack<int>();
@@ -103,7 +103,7 @@ namespace Antlr.Runtime.Debug
//System.out.println("enterRule "+grammarFileName+":"+ruleName);
ruleLevel++;
stats.numRuleInvocations++;
-            uniqueRules.Add(grammarFileName + ":" + ruleName);
+            uniqueRules.Add(grammarFileName + ":" + ruleName, true);
stats.maxRuleInvocationDepth = Math.Max(stats.maxRuleInvocationDepth, ruleLevel);
currentGrammarFileName.Push(grammarFileName);
currentRuleName.Push(ruleName);
diff --git a/Antlr3.Runtime.Debug/RemoteDebugEventSocketListener.cs b/Antlr3.Runtime.Debug/RemoteDebugEventSocketListener.cs
index 5e79aae..e390065 100644
--- a/Antlr3.Runtime.Debug/RemoteDebugEventSocketListener.cs
+++ b/Antlr3.Runtime.Debug/RemoteDebugEventSocketListener.cs
@@ -33,11 +33,14 @@
namespace Antlr.Runtime.Debug
{
using Antlr.Runtime.JavaExtensions;
+
+    using Array = System.Array;
using BaseTree = Antlr.Runtime.Tree.BaseTree;
using Console = System.Console;
using Exception = System.Exception;
using IOException = System.IO.IOException;
using ITree = Antlr.Runtime.Tree.ITree;
+    using Math = System.Math;
using Socket = System.Net.Sockets.Socket;
using SocketException = System.Net.Sockets.SocketException;
using TextReader = System.IO.TextReader;
@@ -314,7 +317,7 @@ namespace Antlr.Runtime.Debug
catch ( Exception e )
{
Console.Error.WriteLine( e );
-                e.PrintStackTrace( Console.Error );
+                ExceptionExtensions.PrintStackTrace( e, Console.Error );
}
finally
{
@@ -359,7 +362,7 @@ namespace Antlr.Runtime.Debug
catch ( Exception e )
{
Console.Error.WriteLine( e );
-                e.PrintStackTrace( Console.Error );
+                ExceptionExtensions.PrintStackTrace( e, Console.Error );
}
finally
{
@@ -703,26 +706,20 @@ namespace Antlr.Runtime.Debug
str = @event.Substring( firstQuoteIndex + 1 );
@event = eventWithoutString;
}
-                StringTokenizer st = new StringTokenizer( @event, "\t", false );
-                int i = 0;
-                while ( st.hasMoreTokens() )
-                {
-                    if ( i >= MAX_EVENT_ELEMENTS )
-                    {
-                        // ErrorManager.internalError("event has more than "+MAX_EVENT_ELEMENTS+" args: "+event);
-                        return elements;
-                    }
-                    elements[i] = st.nextToken();
-                    i++;
-                }
+
+                string[] tokens = @event.Split('\t');
+                Array.Copy(tokens, elements, Math.Min(tokens.Length, MAX_EVENT_ELEMENTS));
+                if (tokens.Length >= MAX_EVENT_ELEMENTS)
+                    return elements;
+
if ( str != null )
{
-                    elements[i] = str;
+                    elements[tokens.Length] = str;
}
}
catch ( Exception e )
{
-                e.PrintStackTrace( Console.Error );
+                ExceptionExtensions.PrintStackTrace( e, Console.Error );
}
return elements;
}
@@ -730,16 +727,15 @@ namespace Antlr.Runtime.Debug
protected virtual string UnEscapeNewlines( string txt )
{
// this unescape is slow but easy to understand
-            txt = txt.replaceAll( "%0A", "\n" );  // unescape \n
-            txt = txt.replaceAll( "%0D", "\r" );  // unescape \r
-            txt = txt.replaceAll( "%25", "%" );   // undo escaped escape chars
+            txt = txt.Replace( "%0A", "\n" );  // unescape \n
+            txt = txt.Replace( "%0D", "\r" );  // unescape \r
+            txt = txt.Replace( "%25", "%" );   // undo escaped escape chars
return txt;
}

public virtual bool TokenIndexesAreInvalid()
{
-            return false;
-            //return tokenIndexesInvalid;
+            return tokenIndexesInvalid;
}

#endregion
diff --git a/Antlr3.Runtime.JavaExtensions/Antlr3.Runtime.JavaExtensions.csproj b/Antlr3.Runtime.JavaExtensions/Antlr3.Runtime.JavaExtensions.csproj
index 0934e85..959a9f9 100644
--- a/Antlr3.Runtime.JavaExtensions/Antlr3.Runtime.JavaExtensions.csproj
+++ b/Antlr3.Runtime.JavaExtensions/Antlr3.Runtime.JavaExtensions.csproj
@@ -35,6 +35,12 @@
<ErrorReport>prompt</ErrorReport>
<WarningLevel>4</WarningLevel>
</PropertyGroup>
+  <PropertyGroup>
+    <SignAssembly>true</SignAssembly>
+  </PropertyGroup>
+  <PropertyGroup>
+    <AssemblyOriginatorKeyFile>..\..\..\..\..\..\..\keys\antlr\Key.snk</AssemblyOriginatorKeyFile>
+  </PropertyGroup>
<ItemGroup>
<Reference Include="System" />
<Reference Include="System.Core">
@@ -51,10 +57,21 @@
</ItemGroup>
<ItemGroup>
<Compile Include="DictionaryExtensions.cs" />
+    <Compile Include="ExceptionExtensions.cs" />
<Compile Include="IOExtensions.cs" />
<Compile Include="LexerExtensions.cs" />
<Compile Include="JSystem.cs" />
+    <Compile Include="ListExtensions.cs" />
+    <Compile Include="ObjectExtensions.cs" />
<Compile Include="Properties\AssemblyInfo.cs" />
+    <Compile Include="SetExtensions.cs" />
+    <Compile Include="StackExtensions.cs" />
+    <Compile Include="StringBuilderExtensions.cs" />
+    <Compile Include="StringExtensions.cs" />
+    <Compile Include="StringTokenizer.cs" />
+    <Compile Include="SubList.cs" />
+    <Compile Include="TreeExtensions.cs" />
+    <Compile Include="TypeExtensions.cs" />
</ItemGroup>
<ItemGroup>
<ProjectReference Include="..\Antlr3.Runtime\Antlr3.Runtime.csproj">
@@ -62,6 +79,11 @@
<Name>Antlr3.Runtime</Name>
</ProjectReference>
</ItemGroup>
+  <ItemGroup>
+    <None Include="..\..\..\..\..\..\..\keys\antlr\Key.snk">
+      <Link>Key.snk</Link>
+    </None>
+  </ItemGroup>
<Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
<!-- To modify your build process, add your task inside one of the targets below and uncomment it.
Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/Antlr3.Runtime.JavaExtensions/DictionaryExtensions.cs b/Antlr3.Runtime.JavaExtensions/DictionaryExtensions.cs
index f2f8f84..cd32ce9 100644
--- a/Antlr3.Runtime.JavaExtensions/DictionaryExtensions.cs
+++ b/Antlr3.Runtime.JavaExtensions/DictionaryExtensions.cs
@@ -4,7 +4,7 @@
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -30,17 +30,15 @@
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

-#if !DEBUG
-
-using System;
-using System.Collections.Generic;
-using System.Linq;
-
-using IDictionary = System.Collections.IDictionary;
-
namespace Antlr.Runtime.JavaExtensions
{
-    public static class DictionaryExtensions2
+    using System.Collections.Generic;
+    using System.Linq;
+
+    using IDictionary = System.Collections.IDictionary;
+    using ObsoleteAttribute = System.ObsoleteAttribute;
+
+    public static class DictionaryExtensions
{
[Obsolete]
public static bool containsKey( this IDictionary map, object key )
@@ -54,6 +52,43 @@ namespace Antlr.Runtime.JavaExtensions
return map[key];
}

+        public static TValue get<TKey, TValue>( this IDictionary<TKey, TValue> map, TKey key )
+        {
+            TValue value;
+            if ( map.TryGetValue( key, out value ) )
+                return value;
+
+            if ( typeof( TValue ).IsValueType )
+                throw new KeyNotFoundException();
+
+            return default( TValue );
+        }
+
+        // disambiguates
+        public static TValue get<TKey, TValue>( this Dictionary<TKey, TValue> map, TKey key )
+        {
+            TValue value;
+            if ( map.TryGetValue( key, out value ) )
+                return value;
+
+            if ( typeof( TValue ).IsValueType )
+                throw new KeyNotFoundException();
+
+            return default( TValue );
+        }
+
+        public static TValue get<TKey, TValue>( this SortedList<TKey, TValue> map, TKey key )
+        {
+            TValue value;
+            if ( map.TryGetValue( key, out value ) )
+                return value;
+
+            if ( typeof( TValue ).IsValueType )
+                throw new KeyNotFoundException();
+
+            return default( TValue );
+        }
+
[Obsolete]
public static void put( this IDictionary map, object key, object value )
{
@@ -98,5 +133,3 @@ namespace Antlr.Runtime.JavaExtensions
}
}
}
-
-#endif
diff --git a/Antlr3.Runtime.JavaExtensions/ExceptionExtensions.cs b/Antlr3.Runtime.JavaExtensions/ExceptionExtensions.cs
new file mode 100644
index 0000000..65696c8
--- /dev/null
+++ b/Antlr3.Runtime.JavaExtensions/ExceptionExtensions.cs
@@ -0,0 +1,100 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Diagnostics;
+using System.Linq;
+
+using TargetInvocationException = System.Reflection.TargetInvocationException;
+
+namespace Antlr.Runtime.JavaExtensions
+{
+    public static class ExceptionExtensions
+    {
+#if DEBUG
+        [Obsolete]
+        public static string getMessage( this Exception e )
+        {
+            return e.Message;
+        }
+#endif
+
+        public static StackFrame[] getStackTrace( this Exception e )
+        {
+            StackTrace trace = new StackTrace( e, true );
+            StackFrame[] frames = trace.GetFrames();
+            if ( frames == null )
+            {
+                // don't include this helper function in the trace
+                frames = new StackTrace( true ).GetFrames().Skip( 1 ).ToArray();
+            }
+            return frames;
+        }
+
+#if DEBUG
+        [Obsolete]
+        public static string getMethodName( this StackFrame frame )
+        {
+            return frame.GetMethod().Name;
+        }
+
+        [Obsolete]
+        public static string getClassName( this StackFrame frame )
+        {
+            return frame.GetMethod().DeclaringType.Name;
+        }
+#endif
+
+        public static void PrintStackTrace( this Exception e )
+        {
+            e.PrintStackTrace( Console.Out );
+        }
+        public static void PrintStackTrace( this Exception e, System.IO.TextWriter writer )
+        {
+            writer.WriteLine( e.ToString() );
+            string trace = e.StackTrace ?? string.Empty;
+            foreach ( string line in trace.Split( '\n', '\r' ) )
+            {
+                if ( !string.IsNullOrEmpty( line ) )
+                    writer.WriteLine( "        " + line );
+            }
+        }
+
+#if DEBUG
+        [Obsolete]
+        public static Exception getTargetException( this TargetInvocationException e )
+        {
+            return e.InnerException ?? e;
+        }
+#endif
+    }
+}
diff --git a/Antlr3.Runtime.JavaExtensions/IOExtensions.cs b/Antlr3.Runtime.JavaExtensions/IOExtensions.cs
index 540af55..52b529c 100644
--- a/Antlr3.Runtime.JavaExtensions/IOExtensions.cs
+++ b/Antlr3.Runtime.JavaExtensions/IOExtensions.cs
@@ -30,15 +30,13 @@
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

-#if !DEBUG
-
-using System;
-
-using TextReader = System.IO.TextReader;
-using TextWriter = System.IO.TextWriter;
-
namespace Antlr.Runtime.JavaExtensions
{
+    using System;
+
+    using TextReader = System.IO.TextReader;
+    using TextWriter = System.IO.TextWriter;
+
public static class IOExtensions
{
[Obsolete]
@@ -90,5 +88,3 @@ namespace Antlr.Runtime.JavaExtensions
}
}
}
-
-#endif
diff --git a/Antlr3.Runtime.JavaExtensions/JSystem.cs b/Antlr3.Runtime.JavaExtensions/JSystem.cs
index 2c27987..1574937 100644
--- a/Antlr3.Runtime.JavaExtensions/JSystem.cs
+++ b/Antlr3.Runtime.JavaExtensions/JSystem.cs
@@ -30,7 +30,6 @@
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

-#if !DEBUG
namespace Antlr.Runtime.JavaExtensions
{
using System;
@@ -86,4 +85,3 @@ namespace Antlr.Runtime.JavaExtensions

}
}
-#endif
diff --git a/Antlr3.Runtime.JavaExtensions/ListExtensions.cs b/Antlr3.Runtime.JavaExtensions/ListExtensions.cs
new file mode 100644
index 0000000..51c16bc
--- /dev/null
+++ b/Antlr3.Runtime.JavaExtensions/ListExtensions.cs
@@ -0,0 +1,237 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+
+using ICollection = System.Collections.ICollection;
+using IEnumerable = System.Collections.IEnumerable;
+using IList = System.Collections.IList;
+
+namespace Antlr.Runtime.JavaExtensions
+{
+    public static class ListExtensions
+    {
+#if DEBUG
+        [Obsolete]
+        public static bool add( this IList list, object value )
+        {
+            int count = list.Count;
+            list.Add( value );
+            return list.Count == count + 1;
+        }
+
+        [Obsolete]
+        public static void add<T>( this ICollection<T> list, T value )
+        {
+            list.Add( value );
+        }
+
+        [Obsolete]
+        public static void add<T>( this List<T> list, T value )
+        {
+            list.Add( value );
+        }
+
+        [Obsolete]
+        public static void add( this IList list, int index, object value )
+        {
+            list.Insert( index, value );
+        }
+
+        [Obsolete]
+        public static void addAll( this List<object> list, IEnumerable items )
+        {
+            list.AddRange( items.Cast<object>() );
+        }
+#endif
+
+        public static void addAll( this IList list, IEnumerable items )
+        {
+            foreach ( object item in items )
+                list.Add( item );
+        }
+
+        public static void addAll<T>( this ICollection<T> list, IEnumerable<T> items )
+        {
+            foreach ( T item in items )
+                list.Add( item );
+        }
+
+#if DEBUG
+        [Obsolete]
+        public static void addElement( this List<object> list, object value )
+        {
+            list.Add( value );
+        }
+
+        [Obsolete]
+        public static void clear( this IList list )
+        {
+            list.Clear();
+        }
+
+        [Obsolete]
+        public static bool contains( this IList list, object value )
+        {
+            return list.Contains( value );
+        }
+
+        [Obsolete]
+        public static bool contains<T>( this ICollection<T> list, T value )
+        {
+            return list.Contains( value );
+        }
+
+        [Obsolete]
+        public static T elementAt<T>( this IList<T> list, int index )
+        {
+            return list[index];
+        }
+
+        [Obsolete]
+        public static object get( this IList list, int index )
+        {
+            return list[index];
+        }
+
+        [Obsolete]
+        public static T get<T>( this IList<T> list, int index )
+        {
+            return list[index];
+        }
+
+        // disambiguate
+        [Obsolete]
+        public static T get<T>( this List<T> list, int index )
+        {
+            return list[index];
+        }
+
+        [Obsolete]
+        public static object remove( this IList list, int index )
+        {
+            object o = list[index];
+            list.RemoveAt( index );
+            return o;
+        }
+
+        [Obsolete]
+        public static void remove<T>( this IList<T> list, T item )
+        {
+            list.Remove( item );
+        }
+
+        [Obsolete]
+        public static void set( this IList list, int index, object value )
+        {
+            list[index] = value;
+        }
+
+        [Obsolete]
+        public static void set<T>( this IList<T> list, int index, T value )
+        {
+            list[index] = value;
+        }
+
+        [Obsolete]
+        public static void set<T>( this List<T> list, int index, T value )
+        {
+            list[index] = value;
+        }
+#endif
+
+        public static void setSize<T>( this List<T> list, int size )
+        {
+            if ( list.Count < size )
+            {
+                list.AddRange( Enumerable.Repeat( default( T ), size - list.Count ) );
+            }
+            else if ( list.Count > size )
+            {
+                list.RemoveRange(size, list.Count - size);
+            }
+        }
+
+#if DEBUG
+        [Obsolete]
+        public static int size( this ICollection collection )
+        {
+            return collection.Count;
+        }
+
+        [Obsolete]
+        public static int size<T>( this ICollection<T> collection )
+        {
+            return collection.Count;
+        }
+
+        [Obsolete]
+        public static int size<T>( this List<T> list )
+        {
+            return list.Count;
+        }
+#endif
+
+        public static IList subList( this IList list, int fromIndex, int toIndex )
+        {
+            return new SubList( list, fromIndex, toIndex );
+            //return
+            //    list
+            //    .Cast<object>()
+            //    .Skip( fromIndex )
+            //    .Take( toIndex - fromIndex + 1 )
+            //    .ToList();
+        }
+
+        public static IList<T> subList<T>( this IList<T> list, int fromIndex, int toIndex )
+        {
+            return new SubList<T>( list, fromIndex, toIndex );
+            //return
+            //    list
+            //    .Skip( fromIndex )
+            //    .Take( toIndex - fromIndex + 1 )
+            //    .ToList();
+        }
+
+        public static IList<T> subList<T>( this List<T> list, int fromIndex, int toIndex )
+        {
+            return new SubList<T>( list, fromIndex, toIndex );
+            //return
+            //    list
+            //    .Skip( fromIndex )
+            //    .Take( toIndex - fromIndex + 1 )
+            //    .ToList();
+        }
+    }
+}
diff --git a/Antlr3.Runtime.JavaExtensions/ObjectExtensions.cs b/Antlr3.Runtime.JavaExtensions/ObjectExtensions.cs
new file mode 100644
index 0000000..fe6a274
--- /dev/null
+++ b/Antlr3.Runtime.JavaExtensions/ObjectExtensions.cs
@@ -0,0 +1,123 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+
+namespace Antlr.Runtime.JavaExtensions
+{
+    public static class ObjectExtensions
+    {
+#if DEBUG
+        [Obsolete]
+        public static bool booleanValue( this bool value )
+        {
+            return value;
+        }
+
+        [Obsolete]
+        public static Type getClass( this object o )
+        {
+            return o.GetType();
+        }
+#endif
+
+        public static int ShiftPrimeXOR( int a, int b )
+        {
+            int hash = 23;
+            hash = ( ( hash << 5 ) * 37 ) ^ a;
+            hash = ( ( hash << 5 ) * 37 ) ^ b;
+            return hash;
+        }
+
+        public static int ShiftPrimeXOR( int a, int b, int c )
+        {
+            int hash = 23;
+            hash = ( ( hash << 5 ) * 37 ) ^ a;
+            hash = ( ( hash << 5 ) * 37 ) ^ b;
+            hash = ( ( hash << 5 ) * 37 ) ^ c;
+            return hash;
+        }
+
+        public static int ShiftPrimeXOR( int a, int b, int c, int d )
+        {
+            int hash = 23;
+            hash = ( ( hash << 5 ) * 37 ) ^ a;
+            hash = ( ( hash << 5 ) * 37 ) ^ b;
+            hash = ( ( hash << 5 ) * 37 ) ^ c;
+            hash = ( ( hash << 5 ) * 37 ) ^ d;
+            return hash;
+        }
+
+        public static int ShiftPrimeXOR( params int[] a )
+        {
+            int hash = 23;
+            foreach ( int i in a )
+                hash = ( ( hash << 5 ) * 37 ) ^ i;
+            return hash;
+        }
+
+        public static int ShiftPrimeAdd( int a, int b )
+        {
+            int hash = 23;
+            hash = ( ( hash << 5 ) * 37 ) + a;
+            hash = ( ( hash << 5 ) * 37 ) + b;
+            return hash;
+        }
+
+        public static int ShiftPrimeAdd( int a, int b, int c )
+        {
+            int hash = 23;
+            hash = ( ( hash << 5 ) * 37 ) + a;
+            hash = ( ( hash << 5 ) * 37 ) + b;
+            hash = ( ( hash << 5 ) * 37 ) + c;
+            return hash;
+        }
+
+        public static int ShiftPrimeAdd( int a, int b, int c, int d )
+        {
+            int hash = 23;
+            hash = ( ( hash << 5 ) * 37 ) + a;
+            hash = ( ( hash << 5 ) * 37 ) + b;
+            hash = ( ( hash << 5 ) * 37 ) + c;
+            hash = ( ( hash << 5 ) * 37 ) + d;
+            return hash;
+        }
+
+        public static int ShiftPrimeAdd( params int[] a )
+        {
+            int hash = 23;
+            foreach ( int i in a )
+                hash = ( ( hash << 5 ) * 37 ) + i;
+            return hash;
+        }
+    }
+}
diff --git a/Antlr3.Runtime.JavaExtensions/SetExtensions.cs b/Antlr3.Runtime.JavaExtensions/SetExtensions.cs
new file mode 100644
index 0000000..881326e
--- /dev/null
+++ b/Antlr3.Runtime.JavaExtensions/SetExtensions.cs
@@ -0,0 +1,89 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Collections.Generic;
+#if DEBUG
+using System.Linq;
+#endif
+
+namespace Antlr.Runtime.JavaExtensions
+{
+    public static class SetExtensions
+    {
+#if DEBUG
+        [Obsolete]
+        public static bool add<T>( this HashSet<T> set, T item )
+        {
+            return set.Add( item );
+        }
+#endif
+
+        public static void addAll<T>( this HashSet<T> set, IEnumerable<T> items )
+        {
+            foreach ( T item in items )
+                set.Add( item );
+        }
+
+#if DEBUG
+        [Obsolete]
+        public static void clear<T>( this HashSet<T> set )
+        {
+            set.Clear();
+        }
+
+        [Obsolete]
+        public static bool contains<T>( this HashSet<T> set, T value )
+        {
+            return set.Contains( value );
+        }
+
+        [Obsolete]
+        public static bool remove<T>( this HashSet<T> set, T item )
+        {
+            return set.Remove( item );
+        }
+
+        [Obsolete]
+        public static int size<T>( this HashSet<T> set )
+        {
+            return set.Count;
+        }
+
+        [Obsolete]
+        public static T[] toArray<T>( this HashSet<T> set )
+        {
+            return set.ToArray();
+        }
+#endif
+    }
+}
diff --git a/Antlr3.Runtime.JavaExtensions/StackExtensions.cs b/Antlr3.Runtime.JavaExtensions/StackExtensions.cs
new file mode 100644
index 0000000..ab9ec71
--- /dev/null
+++ b/Antlr3.Runtime.JavaExtensions/StackExtensions.cs
@@ -0,0 +1,84 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Collections.Generic;
+#if DEBUG
+using System.Linq;
+#endif
+
+namespace Antlr.Runtime.JavaExtensions
+{
+    public static class StackExtensions
+    {
+#if DEBUG
+        [Obsolete]
+        public static T elementAt<T>( this Stack<T> stack, int index )
+        {
+            return stack.ElementAt( index );
+        }
+
+        [Obsolete]
+        public static T peek<T>( this Stack<T> stack )
+        {
+            return stack.Peek();
+        }
+
+        [Obsolete]
+        public static T pop<T>( this Stack<T> stack )
+        {
+            return stack.Pop();
+        }
+
+        [Obsolete]
+        public static void push<T>( this Stack<T> stack, T obj )
+        {
+            stack.Push( obj );
+        }
+
+        [Obsolete]
+        public static int size<T>( this Stack<T> stack )
+        {
+            return stack.Count;
+        }
+#endif
+
+        public static void setSize<T>( this Stack<T> stack, int size )
+        {
+            if ( size > stack.Count )
+                throw new ArgumentException();
+
+            while ( stack.Count > size )
+                stack.Pop();
+        }
+    }
+}
diff --git a/Antlr3.Runtime.JavaExtensions/StringBuilderExtensions.cs b/Antlr3.Runtime.JavaExtensions/StringBuilderExtensions.cs
new file mode 100644
index 0000000..6ef6f27
--- /dev/null
+++ b/Antlr3.Runtime.JavaExtensions/StringBuilderExtensions.cs
@@ -0,0 +1,75 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+
+using StringBuilder = System.Text.StringBuilder;
+
+#if DEBUG
+
+namespace Antlr.Runtime.JavaExtensions
+{
+    public static class StringBuilderExtensions
+    {
+        [Obsolete]
+        public static void append<T>( this StringBuilder buffer, T value )
+        {
+            buffer.Append( value );
+        }
+
+        [Obsolete]
+        public static char charAt( this StringBuilder buffer, int index )
+        {
+            return buffer[index];
+        }
+
+        [Obsolete]
+        public static int length( this StringBuilder buffer )
+        {
+            return buffer.Length;
+        }
+
+        [Obsolete]
+        public static void setCharAt( this StringBuilder buffer, int index, char c )
+        {
+            buffer[index] = c;
+        }
+
+        [Obsolete]
+        public static void setLength( this StringBuilder buffer, int length )
+        {
+            buffer.Length = length;
+        }
+    }
+}
+
+#endif
diff --git a/Antlr3.Runtime.JavaExtensions/StringExtensions.cs b/Antlr3.Runtime.JavaExtensions/StringExtensions.cs
new file mode 100644
index 0000000..8432512
--- /dev/null
+++ b/Antlr3.Runtime.JavaExtensions/StringExtensions.cs
@@ -0,0 +1,151 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr.Runtime.JavaExtensions
+{
+    using ObsoleteAttribute = System.ObsoleteAttribute;
+    using Regex = System.Text.RegularExpressions.Regex;
+    using StringBuilder = System.Text.StringBuilder;
+
+    public static class StringExtensions
+    {
+#if DEBUG
+        [Obsolete]
+        public static char charAt( this string str, int index )
+        {
+            return str[index];
+        }
+
+        [Obsolete]
+        public static bool endsWith( this string str, string value )
+        {
+            return str.EndsWith( value );
+        }
+
+        [Obsolete]
+        public static int indexOf( this string str, char value )
+        {
+            return str.IndexOf( value );
+        }
+
+        [Obsolete]
+        public static int indexOf( this string str, char value, int startIndex )
+        {
+            return str.IndexOf( value, startIndex );
+        }
+
+        [Obsolete]
+        public static int indexOf( this string str, string value )
+        {
+            return str.IndexOf( value );
+        }
+
+        [Obsolete]
+        public static int indexOf( this string str, string value, int startIndex )
+        {
+            return str.IndexOf( value, startIndex );
+        }
+
+        [Obsolete]
+        public static int lastIndexOf( this string str, char value )
+        {
+            return str.LastIndexOf( value );
+        }
+
+        [Obsolete]
+        public static int lastIndexOf( this string str, string value )
+        {
+            return str.LastIndexOf( value );
+        }
+
+        [Obsolete]
+        public static int length( this string str )
+        {
+            return str.Length;
+        }
+
+        [Obsolete]
+        public static string replace(this string str, char oldValue, char newValue)
+        {
+            return str.Replace(oldValue, newValue);
+        }
+#endif
+
+        public static string replaceAll( this string str, string regex, string newValue )
+        {
+            return Regex.Replace( str, regex, newValue );
+        }
+
+        public static string replaceFirst( this string str, string regex, string replacement )
+        {
+            return Regex.Replace( str, regex, replacement );
+        }
+
+#if DEBUG
+        [Obsolete]
+        public static bool startsWith( this string str, string value )
+        {
+            return str.StartsWith( value );
+        }
+
+        [Obsolete]
+        public static string substring( this string str, int startOffset )
+        {
+            return str.Substring( startOffset );
+        }
+
+        [Obsolete]
+        public static string substring(this string str, int startOffset, int endOffset)
+        {
+            return str.Substring( startOffset, endOffset - startOffset );
+        }
+
+        [Obsolete]
+        public static char[] toCharArray( this string str )
+        {
+            return str.ToCharArray();
+        }
+
+        [Obsolete]
+        public static string toUpperCase( this string str )
+        {
+            return str.ToUpperInvariant();
+        }
+
+        [Obsolete]
+        public static string trim( this string str )
+        {
+            return str.Trim();
+        }
+#endif
+    }
+}
diff --git a/Antlr3.Runtime.JavaExtensions/StringTokenizer.cs b/Antlr3.Runtime.JavaExtensions/StringTokenizer.cs
new file mode 100644
index 0000000..0145df5
--- /dev/null
+++ b/Antlr3.Runtime.JavaExtensions/StringTokenizer.cs
@@ -0,0 +1,87 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Linq;
+
+namespace Antlr.Runtime.JavaExtensions
+{
+    public class StringTokenizer
+    {
+        string[] _tokens;
+        int _current;
+
+        public StringTokenizer( string str, string separator )
+            : this( str, separator, false )
+        {
+        }
+        public StringTokenizer( string str, string separator, bool returnDelims )
+        {
+            _tokens = str.Split( separator.ToCharArray(), StringSplitOptions.None );
+            if ( returnDelims )
+            {
+                char[] delims = separator.ToCharArray();
+                _tokens = _tokens.SelectMany( ( token, i ) =>
+                {
+                    if ( i == _tokens.Length - 1 )
+                    {
+                        if ( delims.Contains( str[str.Length - 1] ) )
+                            return new string[0];
+                        else
+                            return new string[] { token };
+                    }
+                    else if ( i == 0 )
+                    {
+                        if ( delims.Contains( str[0] ) )
+                            return new string[] { str[0].ToString() };
+                        else
+                            return new string[] { token };
+                    }
+                    else
+                    {
+                        return new string[] { token, str[_tokens.Take( i + 1 ).Select( t => t.Length + 1 ).Sum() - 1].ToString() };
+                    }
+                } ).ToArray();
+            }
+        }
+
+        public bool hasMoreTokens()
+        {
+            return _current < _tokens.Length;
+        }
+
+        public string nextToken()
+        {
+            return _tokens[_current++];
+        }
+    }
+}
diff --git a/Antlr3.Runtime.JavaExtensions/SubList.cs b/Antlr3.Runtime.JavaExtensions/SubList.cs
new file mode 100644
index 0000000..97025bf
--- /dev/null
+++ b/Antlr3.Runtime.JavaExtensions/SubList.cs
@@ -0,0 +1,423 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Collections;
+
+namespace Antlr.Runtime.JavaExtensions
+{
+    public class SubList
+        : IList
+    {
+        IList _source;
+        int _startIndex;
+        int _endIndex;
+
+        public SubList( IList source, int startIndex, int endIndex )
+        {
+            if ( source == null )
+                throw new ArgumentNullException( "source" );
+            if ( startIndex < 0 || endIndex < 0 )
+                throw new ArgumentOutOfRangeException();
+            if ( startIndex > endIndex || endIndex >= source.Count )
+                throw new ArgumentException();
+
+            _source = source;
+            _startIndex = startIndex;
+            _endIndex = endIndex;
+        }
+
+        #region IList Members
+
+        public int Add( object value )
+        {
+            throw new NotSupportedException();
+        }
+
+        public void Clear()
+        {
+            throw new NotSupportedException();
+        }
+
+        public bool Contains( object value )
+        {
+            return _source
+                .Cast<object>()
+                .Skip( _startIndex )
+                .Take( _endIndex - _startIndex + 1 )
+                .Contains( value );
+        }
+
+        public int IndexOf( object value )
+        {
+            for ( int i = 0; i < Count; i++ )
+            {
+                if ( object.Equals( this[i], value ) )
+                    return i;
+            }
+
+            return -1;
+        }
+
+        public void Insert( int index, object value )
+        {
+            throw new NotSupportedException();
+        }
+
+        public bool IsFixedSize
+        {
+            get
+            {
+                return true;
+            }
+        }
+
+        public bool IsReadOnly
+        {
+            get
+            {
+                return true;
+            }
+        }
+
+        public void Remove( object value )
+        {
+            throw new NotSupportedException();
+        }
+
+        public void RemoveAt( int index )
+        {
+            throw new NotSupportedException();
+        }
+
+        public object this[int index]
+        {
+            get
+            {
+                if ( index < 0 || index >= Count )
+                    throw new ArgumentOutOfRangeException();
+
+                return _source[index + _startIndex];
+            }
+            set
+            {
+                if ( index < 0 || index >= Count )
+                    throw new ArgumentOutOfRangeException();
+
+                _source[index + _startIndex] = value;
+            }
+        }
+
+        #endregion
+
+        #region ICollection Members
+
+        public void CopyTo( Array array, int index )
+        {
+            if ( array == null )
+                throw new ArgumentNullException( "array" );
+
+            if ( index < 0 )
+                throw new ArgumentOutOfRangeException();
+
+            if ( index + Count > array.Length )
+                throw new ArgumentException();
+
+            for ( int i = 0; i < Count; i++ )
+            {
+                array.SetValue( this[i], index + i );
+            }
+        }
+
+        public int Count
+        {
+            get
+            {
+                return _endIndex - _startIndex + 1;
+            }
+        }
+
+        public bool IsSynchronized
+        {
+            get
+            {
+                return false;
+            }
+        }
+
+        public object SyncRoot
+        {
+            get
+            {
+                return _source.SyncRoot;
+            }
+        }
+
+        #endregion
+
+        #region IEnumerable Members
+
+        public System.Collections.IEnumerator GetEnumerator()
+        {
+            return _source.Cast<object>()
+                .Skip( _startIndex )
+                .Take( _endIndex - _startIndex + 1 )
+                .GetEnumerator();
+        }
+
+        #endregion
+    }
+
+    public class SubList<T> : IList<T>, ICollection<T>, IEnumerable<T>, IList, ICollection, IEnumerable
+    {
+        IList<T> _source;
+        int _startIndex;
+        int _endIndex;
+
+        public SubList( IList<T> source, int startIndex, int endIndex )
+        {
+            if ( source == null )
+                throw new ArgumentNullException( "source" );
+            if ( startIndex < 0 || endIndex < 0 )
+                throw new ArgumentOutOfRangeException();
+            if ( startIndex > endIndex || endIndex >= source.Count )
+                throw new ArgumentException();
+
+            _source = source;
+            _startIndex = startIndex;
+            _endIndex = endIndex;
+        }
+
+        #region IEnumerable Members
+
+        IEnumerator IEnumerable.GetEnumerator()
+        {
+            return GetEnumerator();
+        }
+
+        #endregion
+
+        #region ICollection Members
+
+        void ICollection.CopyTo( Array array, int index )
+        {
+            if ( array == null )
+                throw new ArgumentNullException( "array" );
+
+            if ( index < 0 )
+                throw new ArgumentOutOfRangeException();
+
+            if ( index + Count > array.Length )
+                throw new ArgumentException();
+
+            for ( int i = 0; i < Count; i++ )
+            {
+                array.SetValue( this[i], index + i );
+            }
+        }
+
+        public int Count
+        {
+            get
+            {
+                return _endIndex - _startIndex + 1;
+            }
+        }
+
+        public bool IsSynchronized
+        {
+            get
+            {
+                ICollection sourceCollection = _source as ICollection;
+                if ( sourceCollection != null )
+                    return sourceCollection.IsSynchronized;
+
+                return false;
+            }
+        }
+
+        public object SyncRoot
+        {
+            get
+            {
+                ICollection sourceCollection = _source as ICollection;
+                if ( sourceCollection != null )
+                    return sourceCollection.SyncRoot;
+
+                return _source;
+            }
+        }
+
+        #endregion
+
+        #region IList Members
+
+        int IList.Add( object value )
+        {
+            throw new NotSupportedException();
+        }
+
+        void IList.Clear()
+        {
+            throw new NotSupportedException();
+        }
+
+        public bool Contains( object value )
+        {
+            return _source.Cast<object>().Skip( _startIndex ).Take( Count ).Contains( value );
+        }
+
+        public int IndexOf( object value )
+        {
+            for ( int i = _startIndex; i <= _endIndex; i++ )
+            {
+                if ( object.Equals( _source[i], value ) )
+                    return i - _startIndex;
+            }
+
+            return -1;
+        }
+
+        void IList.Insert( int index, object value )
+        {
+            throw new NotSupportedException();
+        }
+
+        public bool IsFixedSize
+        {
+            get
+            {
+                var sourceCollection = _source as IList;
+                if ( sourceCollection != null )
+                    return sourceCollection.IsFixedSize;
+
+                return false;
+            }
+        }
+
+        public bool IsReadOnly
+        {
+            get
+            {
+                return true;
+            }
+        }
+
+        void IList.Remove( object value )
+        {
+            throw new NotSupportedException();
+        }
+
+        void IList.RemoveAt( int index )
+        {
+            throw new NotSupportedException();
+        }
+
+        object IList.this[int index]
+        {
+            get
+            {
+                return this[index];
+            }
+            set
+            {
+                this[index] = (T)value;
+            }
+        }
+
+        #endregion
+
+        #region IEnumerable<T> Members
+
+        public IEnumerator<T> GetEnumerator()
+        {
+            return _source.Skip( _startIndex ).Take( Count ).GetEnumerator();
+        }
+
+        #endregion
+
+        #region ICollection<T> Members
+
+        void ICollection<T>.Add( T item )
+        {
+            throw new NotSupportedException();
+        }
+
+        void ICollection<T>.Clear()
+        {
+            throw new NotSupportedException();
+        }
+
+        public bool Contains( T item )
+        {
+            return _source.Skip( _startIndex ).Take( Count ).Contains( item );
+        }
+
+        public void CopyTo( T[] array, int arrayIndex )
+        {
+            if ( array == null )
+                throw new ArgumentNullException( "array" );
+
+            if ( arrayIndex < 0 )
+                throw new ArgumentOutOfRangeException();
+
+            if ( arrayIndex + Count > array.Length )
+                throw new ArgumentException();
+
+            for ( int i = 0; i < Count; i++ )
+            {
+                array[arrayIndex + i] = this[i];
+            }
+        }
+
+        bool ICollection<T>.Remove( T item )
+        {
+            throw new NotSupportedException();
+        }
+
+        #endregion
+
+        #region IList<T> Members
+
+        public int IndexOf( T item )
+        {
+            for ( int i = 0; i < Count; i++ )
+            {
+                if ( object.Equals( this[i], item ) )
+                    return i;
+            }
+
+            return -1;
+        }
+
+        void IList<T>.Insert( int index, T item )
+        {
+            throw new NotSupportedException();
+        }
+
+        void IList<T>.RemoveAt( int index )
+        {
+            throw new NotSupportedException();
+        }
+
+        public T this[int index]
+        {
+            get
+            {
+                if ( index < 0 || index >= Count )
+                    throw new ArgumentOutOfRangeException();
+
+                return _source[index + _startIndex];
+            }
+            set
+            {
+                if ( index < 0 || index >= Count )
+                    throw new ArgumentOutOfRangeException();
+
+                _source[index + _startIndex] = value;
+            }
+        }
+
+        #endregion
+    }
+}
diff --git a/Antlr3.Runtime.JavaExtensions/TreeExtensions.cs b/Antlr3.Runtime.JavaExtensions/TreeExtensions.cs
new file mode 100644
index 0000000..6f7182f
--- /dev/null
+++ b/Antlr3.Runtime.JavaExtensions/TreeExtensions.cs
@@ -0,0 +1,53 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using ITree = Antlr.Runtime.Tree.ITree;
+
+namespace Antlr.Runtime.JavaExtensions
+{
+    public static class TreeExtensions
+    {
+        public static ITree getNextSibling( this ITree tree )
+        {
+            return tree.Parent.GetChild( tree.ChildIndex + 1 );
+            //throw new NotImplementedException();
+        }
+
+        public static void setFirstChild( this ITree tree, ITree child )
+        {
+            if ( tree.ChildCount == 0 )
+                tree.AddChild( child );
+            else
+                tree.SetChild( 0, child );
+        }
+    }
+}
diff --git a/Antlr3.Runtime.JavaExtensions/TypeExtensions.cs b/Antlr3.Runtime.JavaExtensions/TypeExtensions.cs
new file mode 100644
index 0000000..42c0368
--- /dev/null
+++ b/Antlr3.Runtime.JavaExtensions/TypeExtensions.cs
@@ -0,0 +1,102 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Reflection;
+
+#if DEBUG
+
+namespace Antlr.Runtime.JavaExtensions
+{
+    public static class TypeExtensions
+    {
+        [Obsolete]
+        public static object get( this FieldInfo field, object obj )
+        {
+            return field.GetValue( obj );
+        }
+
+        [Obsolete]
+        public static Type getComponentType( this Type type )
+        {
+            return type.GetElementType();
+        }
+
+        [Obsolete]
+        public static ConstructorInfo getConstructor( this Type type, Type[] argumentTypes )
+        {
+            return type.GetConstructor( argumentTypes );
+        }
+
+        [Obsolete]
+        public static FieldInfo getField( this Type type, string name )
+        {
+            FieldInfo field = type.GetField( name );
+            if ( field == null )
+                throw new TargetException();
+
+            return field;
+        }
+
+        [Obsolete]
+        public static string getName( this Type type )
+        {
+            return type.Name;
+        }
+
+        [Obsolete]
+        public static object invoke( this MethodInfo method, object obj, params object[] parameters )
+        {
+            return method.Invoke( obj, parameters );
+        }
+
+        [Obsolete]
+        public static bool isArray( this Type type )
+        {
+            return type.IsArray;
+        }
+
+        [Obsolete]
+        public static bool isPrimitive( this Type type )
+        {
+            return type.IsPrimitive;
+        }
+
+        [Obsolete]
+        public static object newInstance( this Type type )
+        {
+            return type.GetConstructor( new Type[0] ).Invoke( new object[0] );
+        }
+    }
+}
+
+#endif
diff --git a/Antlr3.Runtime/Antlr3.Runtime.csproj b/Antlr3.Runtime/Antlr3.Runtime.csproj
index b2bdc5d..a311d92 100644
--- a/Antlr3.Runtime/Antlr3.Runtime.csproj
+++ b/Antlr3.Runtime/Antlr3.Runtime.csproj
@@ -10,7 +10,7 @@
<AppDesignerFolder>Properties</AppDesignerFolder>
<RootNamespace>Antlr.Runtime</RootNamespace>
<AssemblyName>Antlr3.Runtime</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
<FileAlignment>512</FileAlignment>
<SccProjectName>SAK</SccProjectName>
<SccLocalPath>SAK</SccLocalPath>
@@ -18,7 +18,8 @@
<SccProvider>SAK</SccProvider>
<SignAssembly>true</SignAssembly>
<AssemblyOriginatorKeyFile>..\..\..\..\..\..\..\keys\antlr\Key.snk</AssemblyOriginatorKeyFile>
-    <TargetFrameworkProfile>Client</TargetFrameworkProfile>
+    <TargetFrameworkProfile>
+    </TargetFrameworkProfile>
</PropertyGroup>
<PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
<DebugSymbols>true</DebugSymbols>
@@ -39,9 +40,6 @@
</PropertyGroup>
<ItemGroup>
<Reference Include="System" />
-    <Reference Include="System.Core">
-      <RequiredTargetFramework>3.5</RequiredTargetFramework>
-    </Reference>
</ItemGroup>
<ItemGroup>
<Compile Include="ANTLRFileStream.cs" />
@@ -77,6 +75,7 @@
<Compile Include="LegacyCommonTokenStream.cs" />
<Compile Include="Lexer.cs" />
<Compile Include="Misc\FastQueue.cs" />
+    <Compile Include="Misc\FunctionDelegates.cs" />
<Compile Include="Misc\LookaheadStream.cs" />
<Compile Include="MismatchedNotSetException.cs" />
<Compile Include="MismatchedRangeException.cs" />
diff --git a/Antlr3.Runtime/LegacyCommonTokenStream.cs b/Antlr3.Runtime/LegacyCommonTokenStream.cs
index cfdb570..936f586 100644
--- a/Antlr3.Runtime/LegacyCommonTokenStream.cs
+++ b/Antlr3.Runtime/LegacyCommonTokenStream.cs
@@ -33,9 +33,7 @@
namespace Antlr.Runtime
{
using System.Collections.Generic;
-    using System.Linq;

-    using ArgumentOutOfRangeException = System.ArgumentOutOfRangeException;
using InvalidOperationException = System.InvalidOperationException;
using StringBuilder = System.Text.StringBuilder;

@@ -65,7 +63,7 @@ namespace Antlr.Runtime
protected IDictionary<int, int> channelOverrideMap;

/** <summary>Set<tokentype>; discard any tokens with this type</summary> */
-        protected HashSet<int> discardSet;
+        protected List<int> discardSet;

/** <summary>Skip tokens on any channel but this one; this is how we skip whitespace...</summary> */
protected int channel = TokenChannels.Default;
@@ -239,7 +237,7 @@ namespace Antlr.Runtime
{
if ( discardSet == null )
{
-                discardSet = new HashSet<int>();
+                discardSet = new List<int>();
}
discardSet.Add( ttype );
}
diff --git a/Antlr3.Runtime/Misc/FunctionDelegates.cs b/Antlr3.Runtime/Misc/FunctionDelegates.cs
new file mode 100644
index 0000000..4fb91bf
--- /dev/null
+++ b/Antlr3.Runtime/Misc/FunctionDelegates.cs
@@ -0,0 +1,40 @@
+﻿/*
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr.Runtime.Misc
+{
+    public delegate void Action();
+
+    public delegate TResult Func<TResult>();
+
+    public delegate TResult Func<T, TResult>(T arg);
+}
diff --git a/Antlr3.Runtime/MismatchedTokenException.cs b/Antlr3.Runtime/MismatchedTokenException.cs
index 8af8255..55c9aab 100644
--- a/Antlr3.Runtime/MismatchedTokenException.cs
+++ b/Antlr3.Runtime/MismatchedTokenException.cs
@@ -34,7 +34,6 @@ namespace Antlr.Runtime
{
using System.Collections.Generic;
using System.Collections.ObjectModel;
-    using System.Linq;
using ArgumentNullException = System.ArgumentNullException;
using Exception = System.Exception;
using SerializationInfo = System.Runtime.Serialization.SerializationInfo;
@@ -72,7 +71,7 @@ namespace Antlr.Runtime
this._expecting = expecting;

if (tokenNames != null)
-                this._tokenNames = tokenNames.ToList().AsReadOnly();
+                this._tokenNames = new List<string>(tokenNames).AsReadOnly();
}

public MismatchedTokenException(string message, int expecting, IIntStream input, IList<string> tokenNames)
@@ -81,7 +80,7 @@ namespace Antlr.Runtime
this._expecting = expecting;

if (tokenNames != null)
-                this._tokenNames = tokenNames.ToList().AsReadOnly();
+                this._tokenNames = new List<string>(tokenNames).AsReadOnly();
}

public MismatchedTokenException(string message, int expecting, IIntStream input, IList<string> tokenNames, Exception innerException)
@@ -90,7 +89,7 @@ namespace Antlr.Runtime
this._expecting = expecting;

if (tokenNames != null)
-                this._tokenNames = tokenNames.ToList().AsReadOnly();
+                this._tokenNames = new List<string>(tokenNames).AsReadOnly();
}

protected MismatchedTokenException(SerializationInfo info, StreamingContext context)
@@ -126,7 +125,7 @@ namespace Antlr.Runtime

base.GetObjectData(info, context);
info.AddValue("Expecting", _expecting);
-            info.AddValue("TokenNames", (_tokenNames != null) ? _tokenNames.ToArray() : default(string[]));
+            info.AddValue("TokenNames", (_tokenNames != null) ? new List<string>(_tokenNames).ToArray() : default(string[]));
}

public override string ToString()
diff --git a/Antlr3.Runtime/Tree/CommonTree.cs b/Antlr3.Runtime/Tree/CommonTree.cs
index 40745bc..33f9bda 100644
--- a/Antlr3.Runtime/Tree/CommonTree.cs
+++ b/Antlr3.Runtime/Tree/CommonTree.cs
@@ -1,10 +1,10 @@
/*
* [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -32,10 +32,7 @@

namespace Antlr.Runtime.Tree
{
-    using System.Linq;
-
using ArgumentNullException = System.ArgumentNullException;
-    using CLSCompliant = System.CLSCompliantAttribute;

/** <summary>
*  A tree node that is wrapper for a Token object.  After 3.0 release
@@ -261,8 +258,14 @@ namespace Antlr.Runtime.Tree
return;
}

-            foreach (var child in Children.OfType<CommonTree>())
-                child.SetUnknownTokenBoundaries();
+            foreach (ITree childTree in Children)
+            {
+                CommonTree commonTree = childTree as CommonTree;
+                if (commonTree == null)
+                    continue;
+
+                commonTree.SetUnknownTokenBoundaries();
+            }

if ( startIndex >= 0 && stopIndex >= 0 )
return; // already set
diff --git a/Antlr3.Runtime/Tree/ITreeVisitorAction.cs b/Antlr3.Runtime/Tree/ITreeVisitorAction.cs
index 826f6be..bcf0156 100644
--- a/Antlr3.Runtime/Tree/ITreeVisitorAction.cs
+++ b/Antlr3.Runtime/Tree/ITreeVisitorAction.cs
@@ -32,6 +32,8 @@

namespace Antlr.Runtime.Tree
{
+    using Antlr.Runtime.Misc;
+
/** <summary>
*  How to execute code for node t when a visitor visits node t.  Execute
*  pre() before visiting children and execute post() after visiting children.
@@ -60,10 +62,10 @@ namespace Antlr.Runtime.Tree
public class TreeVisitorAction
: ITreeVisitorAction
{
-        System.Func<object, object> _preAction;
-        System.Func<object, object> _postAction;
+        private readonly Func<object, object> _preAction;
+        private readonly Func<object, object> _postAction;

-        public TreeVisitorAction( System.Func<object, object> preAction, System.Func<object, object> postAction )
+        public TreeVisitorAction( Func<object, object> preAction, Func<object, object> postAction )
{
_preAction = preAction;
_postAction = postAction;
diff --git a/Antlr3.Runtime/Tree/TreeFilter.cs b/Antlr3.Runtime/Tree/TreeFilter.cs
index 9128d70..ef7b412 100644
--- a/Antlr3.Runtime/Tree/TreeFilter.cs
+++ b/Antlr3.Runtime/Tree/TreeFilter.cs
@@ -32,6 +32,8 @@

namespace Antlr.Runtime.Tree
{
+    using Antlr.Runtime.Misc;
+
public class TreeFilter : TreeParser
{
protected ITokenStream originalTokenStream;
@@ -48,7 +50,7 @@ namespace Antlr.Runtime.Tree
originalTokenStream = input.TokenStream;
}

-        public virtual void ApplyOnce( object t, System.Action whichRule )
+        public virtual void ApplyOnce( object t, Action whichRule )
{
if ( t == null )
return;
@@ -71,12 +73,12 @@ namespace Antlr.Runtime.Tree
public virtual void Downup( object t )
{
TreeVisitor v = new TreeVisitor( new CommonTreeAdaptor() );
-            System.Func<object, object> pre = ( o ) =>
+            Func<object, object> pre = ( o ) =>
{
ApplyOnce( o, Topdown );
return o;
};
-            System.Func<object, object> post = ( o ) =>
+            Func<object, object> post = ( o ) =>
{
ApplyOnce( o, Bottomup );
return o;
diff --git a/Antlr3.Runtime/Tree/TreeRewriter.cs b/Antlr3.Runtime/Tree/TreeRewriter.cs
index 50fc8bc..b610c2c 100644
--- a/Antlr3.Runtime/Tree/TreeRewriter.cs
+++ b/Antlr3.Runtime/Tree/TreeRewriter.cs
@@ -32,6 +32,8 @@

namespace Antlr.Runtime.Tree
{
+    using Antlr.Runtime.Misc;
+
using Console = System.Console;

public class TreeRewriter : TreeParser
@@ -41,8 +43,8 @@ namespace Antlr.Runtime.Tree
protected ITokenStream originalTokenStream;
protected ITreeAdaptor originalAdaptor;

-        System.Func<IAstRuleReturnScope> topdown_func;
-        System.Func<IAstRuleReturnScope> bottomup_func;
+        Func<IAstRuleReturnScope> topdown_func;
+        Func<IAstRuleReturnScope> bottomup_func;

public TreeRewriter( ITreeNodeStream input )
: this( input, new RecognizerSharedState() )
@@ -57,7 +59,7 @@ namespace Antlr.Runtime.Tree
bottomup_func = () => Bottomup();
}

-        public virtual object ApplyOnce( object t, System.Func<IAstRuleReturnScope> whichRule )
+        public virtual object ApplyOnce( object t, Func<IAstRuleReturnScope> whichRule )
{
if ( t == null )
return null;
@@ -89,7 +91,7 @@ namespace Antlr.Runtime.Tree
return t;
}

-        public virtual object ApplyRepeatedly( object t, System.Func<IAstRuleReturnScope> whichRule )
+        public virtual object ApplyRepeatedly( object t, Func<IAstRuleReturnScope> whichRule )
{
bool treeChanged = true;
while ( treeChanged )
diff --git a/Antlr3.Runtime/Tree/TreeVisitor.cs b/Antlr3.Runtime/Tree/TreeVisitor.cs
index 883062a..f6e49ea 100644
--- a/Antlr3.Runtime/Tree/TreeVisitor.cs
+++ b/Antlr3.Runtime/Tree/TreeVisitor.cs
@@ -32,6 +32,8 @@

namespace Antlr.Runtime.Tree
{
+    using Antlr.Runtime.Misc;
+
/** <summary>Do a depth first walk of a tree, applying pre() and post() actions as we go.</summary> */
public class TreeVisitor
{
@@ -73,7 +75,7 @@ namespace Antlr.Runtime.Tree
return t;
}

-        public object Visit( object t, System.Func<object, object> preAction, System.Func<object, object> postAction )
+        public object Visit( object t, Func<object, object> preAction, Func<object, object> postAction )
{
return Visit( t, new TreeVisitorAction( preAction, postAction ) );
}

