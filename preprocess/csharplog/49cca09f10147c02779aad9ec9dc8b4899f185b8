commit 49cca09f10147c02779aad9ec9dc8b4899f185b8
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Sun May 15 13:31:09 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Sun May 15 13:31:09 2011 -0800

(C# 2) CSharp2 target now works for everything except "output=template" and targets the shared runtime from the CSharp3 target

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 8516]

diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp2/Antlr3.Targets.CSharp2.csproj b/Antlr3.Targets/Antlr3.Targets.CSharp2/Antlr3.Targets.CSharp2.csproj
index 235edf5..eb91b52 100644
--- a/Antlr3.Targets/Antlr3.Targets.CSharp2/Antlr3.Targets.CSharp2.csproj
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp2/Antlr3.Targets.CSharp2.csproj
@@ -54,6 +54,11 @@
<Name>Antlr3</Name>
<Private>False</Private>
</ProjectReference>
+    <ProjectReference Include="..\..\Antlr4.StringTemplate\Antlr4.StringTemplate.csproj">
+      <Project>{DE9B7DA2-35DD-46CC-B768-DAEE3C298660}</Project>
+      <Name>Antlr4.StringTemplate</Name>
+      <Private>False</Private>
+    </ProjectReference>
</ItemGroup>
<ItemGroup>
<None Include="..\..\..\..\..\keys\antlr\Key.snk">
diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp2/CSharp2Target.cs b/Antlr3.Targets/Antlr3.Targets.CSharp2/CSharp2Target.cs
index 99f1145..cb35e72 100644
--- a/Antlr3.Targets/Antlr3.Targets.CSharp2/CSharp2Target.cs
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp2/CSharp2Target.cs
@@ -32,13 +32,117 @@
*/
namespace Antlr3.Targets
{
+    using System.Collections.Generic;
+
+    using ArgumentException = System.ArgumentException;
+    using CLSCompliantAttribute = System.CLSCompliantAttribute;
+    using CodeGenerator = Antlr3.Codegen.CodeGenerator;
+    using CultureInfo = System.Globalization.CultureInfo;
+    using Grammar = Antlr3.Tool.Grammar;
+    using IAttributeRenderer = Antlr4.StringTemplate.IAttributeRenderer;
+    using Template = Antlr4.StringTemplate.Template;
using Target = Antlr3.Codegen.Target;

public class CSharp2Target : Target
{
-        public override string EncodeIntAsCharEscape( int v )
+        private static readonly HashSet<string> _languageKeywords = new HashSet<string>()
+            {
+                "abstract", "event", "new", "struct",
+                "as", "explicit", "null", "switch",
+                "base", "extern", "object", "this",
+                "bool", "false", "operator", "throw",
+                "break", "finally", "out", "true",
+                "byte", "fixed", "override", "try",
+                "case", "float", "params", "typeof",
+                "catch", "for", "private", "uint",
+                "char", "foreach", "protected", "ulong",
+                "checked", "goto", "public", "unchecked",
+                "class", "if", "readonly", "unsafe",
+                "const", "implicit", "ref", "ushort",
+                "continue", "in", "return", "using",
+                "decimal", "int", "sbyte", "virtual",
+                "default", "interface", "sealed", "volatile",
+                "delegate", "internal", "short", "void",
+                "do", "is", "sizeof", "while",
+                "double", "lock", "stackalloc",
+                "else", "long", "static",
+                "enum", "namespace", "string",
+            };
+
+        public override string EncodeIntAsCharEscape(int v)
+        {
+            return "\\x" + v.ToString("X");
+        }
+
+        [CLSCompliant(false)]
+        public override string GetTarget64BitStringFromValue(ulong word)
{
-            return "\\x" + v.ToString( "X" );
+            return "0x" + word.ToString("X");
+        }
+
+        protected override void GenRecognizerFile(AntlrTool tool, CodeGenerator generator, Grammar grammar, Template outputFileST)
+        {
+            if (!grammar.IsRoot)
+            {
+                Grammar rootGrammar = grammar.composite.RootGrammar;
+                string actionScope = grammar.GetDefaultActionScope(grammar.type);
+                IDictionary<string, object> actions;
+                object rootNamespace;
+                if (rootGrammar.Actions.TryGetValue(actionScope, out actions) && actions.TryGetValue("namespace", out rootNamespace))
+                {
+                    if (!grammar.Actions.TryGetValue(actionScope, out actions))
+                    {
+                        actions = new Dictionary<string, object>();
+                        grammar.Actions[actionScope] = actions;
+                    }
+
+                    actions["namespace"] = rootNamespace;
+                }
+            }
+
+            generator.Templates.RegisterRenderer(typeof(string), new StringRenderer(generator, this));
+            base.GenRecognizerFile(tool, generator, grammar, outputFileST);
+        }
+
+        public class StringRenderer : IAttributeRenderer
+        {
+            private readonly CodeGenerator _generator;
+            private readonly CSharp2Target _target;
+
+            public StringRenderer(CodeGenerator generator, CSharp2Target target)
+            {
+                _generator = generator;
+                _target = target;
+            }
+
+            public string ToString(string value, string formatName, CultureInfo culture)
+            {
+                if (string.IsNullOrEmpty(value) || string.IsNullOrEmpty(formatName))
+                    return value;
+
+                switch (formatName)
+                {
+                case "id":
+                    if (_languageKeywords.Contains(value))
+                        return "@" + value;
+
+                    return value;
+
+                case "cap":
+                    return char.ToUpper(value[0], CultureInfo.CurrentCulture) + value.Substring(1);
+
+                case "string":
+                    return _target.GetTargetStringLiteralFromString(value, true);
+
+                default:
+                    throw new ArgumentException(string.Format("Unsupported format name: '{0}'", formatName), "formatName");
+                }
+            }
+
+            string IAttributeRenderer.ToString(object o, string formatName, CultureInfo culture)
+            {
+                return ToString((string)o, formatName, culture);
+            }
}
}
}

