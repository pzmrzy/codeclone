commit 8027bd942bef854db14522f7a778854fe15ccaa9
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Thu Dec 10 11:36:46 2009 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Thu Dec 10 11:36:46 2009 -0800

C# Port:
* Code formatting - also I was mistaken before. This is synced only to CL6335

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 6468]

diff --git a/StringTemplate4/Interpreter.cs b/StringTemplate4/Interpreter.cs
index c026731..dde73f7 100644
--- a/StringTemplate4/Interpreter.cs
+++ b/StringTemplate4/Interpreter.cs
@@ -338,17 +338,20 @@ namespace StringTemplate
return n;
}

-        protected int WriteObject(ITemplateWriter @out, Template self, object o, object[] options) {
-        // precompute all option values (render all the way to strings)
-        string[] optionStrings = null;
-        if ( options!=null ) {
-            optionStrings = new string[options.Length];
-            for (int i=0; i<Compiler.NUM_OPTIONS; i++) {
-                optionStrings[i] = ToString(self, options[i]);
+        protected int WriteObject(ITemplateWriter @out, Template self, object o, object[] options)
+        {
+            // precompute all option values (render all the way to strings)
+            string[] optionStrings = null;
+            if (options != null)
+            {
+                optionStrings = new string[options.Length];
+                for (int i = 0; i < Compiler.NUM_OPTIONS; i++)
+                {
+                    optionStrings[i] = ToString(self, options[i]);
+                }
}
+            return WriteObject(@out, self, o, optionStrings);
}
-        return WriteObject(@out, self, o, optionStrings);
-    }

protected int WriteObject(ITemplateWriter @out, Template self, object o, string[] options)
{
diff --git a/StringTemplate4/TemplateGroup.cs b/StringTemplate4/TemplateGroup.cs
index 4f7574a..b76493b 100644
--- a/StringTemplate4/TemplateGroup.cs
+++ b/StringTemplate4/TemplateGroup.cs
@@ -42,252 +42,267 @@ namespace StringTemplate

public class TemplateGroup
{
-    /** When we use key as a value in a dictionary, this is how we signify. */
-    public static readonly string DICT_KEY = "key";
-    public static readonly string DEFAULT_KEY = "default";
+        /** When we use key as a value in a dictionary, this is how we signify. */
+        public static readonly string DICT_KEY = "key";
+        public static readonly string DEFAULT_KEY = "default";

-    private class DefaultErrorListenerImpl : ITemplateErrorListener
-    {
-        public void Error(string message, Exception e)
+        private class DefaultErrorListenerImpl : ITemplateErrorListener
{
-            Console.Error.WriteLine(message);
-            if (e != null)
-                Console.Error.WriteLine(e.StackTrace);
-        }
+            public void Error(string message, Exception e)
+            {
+                Console.Error.WriteLine(message);
+                if (e != null)
+                    Console.Error.WriteLine(e.StackTrace);
+            }

-        public void Error(string message)
-        {
-            Error(message, null);
-        }
+            public void Error(string message)
+            {
+                Error(message, null);
+            }

-        public void Warning(string message)
-        {
-            Console.WriteLine(message);
+            public void Warning(string message)
+            {
+                Console.WriteLine(message);
+            }
}
-    }

-    public static readonly ITemplateErrorListener DefaultErrorListener = new DefaultErrorListenerImpl();
+        public static readonly ITemplateErrorListener DefaultErrorListener = new DefaultErrorListenerImpl();

-    /** The topmost group of templates in the template tree.
-     *  If null, implies this is the root
-     */
-    public TemplateGroup root;
+        /** The topmost group of templates in the template tree.
+         *  If null, implies this is the root
+         */
+        public TemplateGroup root;

-    /** Load files using what encoding? */
-    public Encoding encoding;
+        /** Load files using what encoding? */
+        public Encoding encoding;

-    //public String supergroup;
+        //public String supergroup;

-    public List<string> interfaces;
+        public List<string> interfaces;

-    public char delimiterStartChar = '<'; // Use <expr> by default
-    public char delimiterStopChar = '>';
+        public char delimiterStartChar = '<'; // Use <expr> by default
+        public char delimiterStopChar = '>';

-    /** Maps template name to StringTemplate object */
-    protected internal IDictionary<string, CompiledTemplate> templates =
-        new Dictionary<string,CompiledTemplate>();
+        /** Maps template name to StringTemplate object */
+        protected internal IDictionary<string, CompiledTemplate> templates =
+            new Dictionary<string, CompiledTemplate>();

-    /** Maps dict names to HashMap objects.  This is the list of dictionaries
-     *  defined by the user like typeInitMap ::= ["int":"0"]
-     */
-    protected internal IDictionary<string, IDictionary<string,object>> dictionaries =
-        new Dictionary<string, IDictionary<string,object>>();
+        /** Maps dict names to HashMap objects.  This is the list of dictionaries
+         *  defined by the user like typeInitMap ::= ["int":"0"]
+         */
+        protected internal IDictionary<string, IDictionary<string, object>> dictionaries =
+            new Dictionary<string, IDictionary<string, object>>();

-    protected bool alreadyLoaded = false;
-
-    /** Where to report errors.  All string templates in this group
-     *  use this error handler by default.
-     */
-    public ITemplateErrorListener listener = DefaultErrorListener;
-
-	public static ErrorTolerance DEFAULT_ERROR_TOLERANCE = new ErrorTolerance();
-	public ErrorTolerance tolerance = DEFAULT_ERROR_TOLERANCE;
+        protected bool alreadyLoaded = false;

-	public static TemplateGroup defaultGroup = new TemplateGroup();
+        /** Where to report errors.  All string templates in this group
+         *  use this error handler by default.
+         */
+        public ITemplateErrorListener listener = DefaultErrorListener;

-    public TemplateGroup()
-    {
-    }
+        public static ErrorTolerance DEFAULT_ERROR_TOLERANCE = new ErrorTolerance();
+        public ErrorTolerance tolerance = DEFAULT_ERROR_TOLERANCE;

-    /*
-    public TemplateGroup(String name) {
-        this.name = name;
-    }
-    */
+        public static TemplateGroup defaultGroup = new TemplateGroup();

-    // TODO: for dirs, should this load everything in dir and below?
-    public virtual void Load()
-    {
-    } // nothing to do unless it's a group file
-
-    /** The primary means of getting an instance of a template from this
-     *  group.
-     */
-    public virtual Template GetInstanceOf(string name)
-    {
-        CompiledTemplate c = LookupTemplate(name);
-        if ( c!=null ) {
-            Template instanceST = CreateStringTemplate();
-            //instanceST.group = this;  leave it as nativeGroup
-            instanceST.name = name;
-            instanceST.code = c;
-            return instanceST;
+        public TemplateGroup()
+        {
}
-        return null;
-    }

-    public virtual Template GetEmbeddedInstanceOf(Template enclosingInstance, string name)
-    {
-        Template st = GetInstanceOf(name);
-        if ( st==null ) {
-            Console.Error.WriteLine("no such template: "+name);
-            return Template.Blank;
+        /*
+        public TemplateGroup(String name) {
+            this.name = name;
}
-        st.enclosingInstance = enclosingInstance;
-        return st;
-    }
+        */

-    public virtual CompiledTemplate LookupTemplate(string name)
-    {
-        CompiledTemplate template;
-        if (!templates.TryGetValue(name, out template))
+        // TODO: for dirs, should this load everything in dir and below?
+        public virtual void Load()
+        {
+        } // nothing to do unless it's a group file
+
+        /** The primary means of getting an instance of a template from this
+         *  group.
+         */
+        public virtual Template GetInstanceOf(string name)
+        {
+            CompiledTemplate c = LookupTemplate(name);
+            if (c != null)
+            {
+                Template instanceST = CreateStringTemplate();
+                //instanceST.group = this;  leave it as nativeGroup
+                instanceST.name = name;
+                instanceST.code = c;
+                return instanceST;
+            }
return null;
+        }

-        return template;
-    }
+        public virtual Template GetEmbeddedInstanceOf(Template enclosingInstance, string name)
+        {
+            Template st = GetInstanceOf(name);
+            if (st == null)
+            {
+                Console.Error.WriteLine("no such template: " + name);
+                return Template.Blank;
+            }
+            st.enclosingInstance = enclosingInstance;
+            return st;
+        }

-    // TODO: send in start/stop char or line/col so errors can be relative
-    public CompiledTemplate DefineTemplate(string name, string template) {
-        return DefineTemplate(name, (IDictionary<string,FormalArgument>)null, template);
-    }
+        public virtual CompiledTemplate LookupTemplate(string name)
+        {
+            CompiledTemplate template;
+            if (!templates.TryGetValue(name, out template))
+                return null;

-    public virtual CompiledTemplate DefineTemplate(string name,
-                                     List<string> args,
-                                     string template)
-    {
-        IDictionary<string,FormalArgument> margs =
-            new Dictionary<string,FormalArgument>();
-        foreach (string a in args) margs[a] = new FormalArgument(a);
-        return DefineTemplate(name, margs, template);
-    }
+            return template;
+        }

-    public virtual CompiledTemplate DefineTemplate(string name,
-                                     string[] args,
-                                     string template)
-    {
-        IDictionary<string,FormalArgument> margs =
-            new Dictionary<string,FormalArgument>();
-        foreach (string a in args) margs[a] = new FormalArgument(a);
-        return DefineTemplate(name, margs, template);
-    }
+        // TODO: send in start/stop char or line/col so errors can be relative
+        public CompiledTemplate DefineTemplate(string name, string template)
+        {
+            return DefineTemplate(name, (IDictionary<string, FormalArgument>)null, template);
+        }

-	// can't trap recog errors here; don't know where in file template is defined
-    public virtual CompiledTemplate DefineTemplate(string name,
-                                     IDictionary<string,FormalArgument> args,
-                                     string template)
-    {
-        if ( name!=null && (name.Length==0 || name.IndexOf('.')>=0) ) {
-            throw new ArgumentException("cannot have '.' in template names");
+        public virtual CompiledTemplate DefineTemplate(string name,
+                                         List<string> args,
+                                         string template)
+        {
+            IDictionary<string, FormalArgument> margs =
+                new Dictionary<string, FormalArgument>();
+            foreach (string a in args)
+                margs[a] = new FormalArgument(a);
+            return DefineTemplate(name, margs, template);
}
-        Compiler c = new Compiler();
-		//template = Misc.trimOneStartingWS(template);
-		CompiledTemplate code = c.Compile(template);
-        code.name = name;
-        code.formalArguments = args;
-        code.nativeGroup = this;
-        templates[name] = code;
-        if ( args!=null ) { // compile any default args
-            foreach (string a in args.Keys) {
-                FormalArgument fa = args[a];
-                if ( fa.defaultValue!=null ) {
-                    Compiler c2 = new Compiler();
-                    fa.compiledDefaultValue = c2.Compile(template);
+
+        public virtual CompiledTemplate DefineTemplate(string name,
+                                         string[] args,
+                                         string template)
+        {
+            IDictionary<string, FormalArgument> margs =
+                new Dictionary<string, FormalArgument>();
+            foreach (string a in args)
+                margs[a] = new FormalArgument(a);
+            return DefineTemplate(name, margs, template);
+        }
+
+        // can't trap recog errors here; don't know where in file template is defined
+        public virtual CompiledTemplate DefineTemplate(string name,
+                                         IDictionary<string, FormalArgument> args,
+                                         string template)
+        {
+            if (name != null && (name.Length == 0 || name.IndexOf('.') >= 0))
+            {
+                throw new ArgumentException("cannot have '.' in template names");
+            }
+            Compiler c = new Compiler();
+            //template = Misc.trimOneStartingWS(template);
+            CompiledTemplate code = c.Compile(template);
+            code.name = name;
+            code.formalArguments = args;
+            code.nativeGroup = this;
+            templates[name] = code;
+            if (args != null)
+            { // compile any default args
+                foreach (string a in args.Keys)
+                {
+                    FormalArgument fa = args[a];
+                    if (fa.defaultValue != null)
+                    {
+                        Compiler c2 = new Compiler();
+                        fa.compiledDefaultValue = c2.Compile(template);
+                    }
}
}
-        }
-        // define any anonymous subtemplates
-        DefineAnonSubtemplates(code);
+            // define any anonymous subtemplates
+            DefineAnonSubtemplates(code);

-        return code;
-    }
+            return code;
+        }

-    public virtual void DefineAnonSubtemplates(CompiledTemplate code)
-    {
-        if ( code.compiledSubtemplates!=null ) {
-            foreach (CompiledTemplate sub in code.compiledSubtemplates) {
-                templates[sub.name] = sub;
-                DefineAnonSubtemplates(sub);
+        public virtual void DefineAnonSubtemplates(CompiledTemplate code)
+        {
+            if (code.compiledSubtemplates != null)
+            {
+                foreach (CompiledTemplate sub in code.compiledSubtemplates)
+                {
+                    templates[sub.name] = sub;
+                    DefineAnonSubtemplates(sub);
+                }
}
}
-    }
-
-    /** Define a map for this group; not thread safe...do not keep adding
-     *  these while you reference them.
-     */
-    public virtual void DefineDictionary(string name, IDictionary<string, object> mapping)
-    {
-        dictionaries[name] = mapping;
-    }

-    /** StringTemplate object factory; each group can have its own. */
-    public virtual Template CreateStringTemplate()
-    {
-        Template st = new Template();
-        return st;
-    }
+        /** Define a map for this group; not thread safe...do not keep adding
+         *  these while you reference them.
+         */
+        public virtual void DefineDictionary(string name, IDictionary<string, object> mapping)
+        {
+            dictionaries[name] = mapping;
+        }

-    public virtual string GetName()
-    {
-        return "<no name>;";
-    }
+        /** StringTemplate object factory; each group can have its own. */
+        public virtual Template CreateStringTemplate()
+        {
+            Template st = new Template();
+            return st;
+        }

-    public override string ToString()
-    {
-        return Show();
-    }
+        public virtual string GetName()
+        {
+            return "<no name>;";
+        }
+
+        public override string ToString()
+        {
+            return Show();
+        }

-    public virtual string Show() {
-        StringBuilder buf = new StringBuilder();
-        //if ( supergroup!=null ) buf.append(" : "+supergroup);
-        foreach (string name in templates.Keys) {
-			if ( name.StartsWith("_") ) continue;
-            CompiledTemplate c = templates[name];
-            buf.Append(name);
-            buf.Append('(');
-            if ( c.formalArguments!=null ) {
-                buf.Append( string.Join(",", c.formalArguments.Values.Select(value => value.ToString()).ToArray()) );
+        public virtual string Show()
+        {
+            StringBuilder buf = new StringBuilder();
+            //if ( supergroup!=null ) buf.append(" : "+supergroup);
+            foreach (string name in templates.Keys)
+            {
+                if (name.StartsWith("_"))
+                    continue;
+                CompiledTemplate c = templates[name];
+                buf.Append(name);
+                buf.Append('(');
+                if (c.formalArguments != null)
+                {
+                    buf.Append(string.Join(",", c.formalArguments.Values.Select(value => value.ToString()).ToArray()));
+                }
+                buf.Append(')');
+                buf.AppendLine(" ::= <<");
+                buf.AppendLine(c.template);
+                buf.AppendLine(">>");
}
-            buf.Append(')');
-            buf.AppendLine(" ::= <<");
-            buf.AppendLine(c.template);
-            buf.AppendLine(">>");
+            return buf.ToString();
}
-        return buf.ToString();
-    }

-    public virtual void SetErrorListener(ITemplateErrorListener listener)
-    {
-        this.listener = listener;
-    }
+        public virtual void SetErrorListener(ITemplateErrorListener listener)
+        {
+            this.listener = listener;
+        }

-    public virtual void SetErrorTolerance(ErrorTolerance errors)
-    {
-        this.tolerance = errors;
-    }
+        public virtual void SetErrorTolerance(ErrorTolerance errors)
+        {
+            this.tolerance = errors;
+        }

-    public virtual bool Detects(int x)
-    {
-        return tolerance.Detects(x);
-    }
+        public virtual bool Detects(int x)
+        {
+            return tolerance.Detects(x);
+        }

-    public virtual void Detect(int x)
-    {
-        tolerance.Detect(x);
-    }
+        public virtual void Detect(int x)
+        {
+            tolerance.Detect(x);
+        }

-    public virtual void Ignore(int x)
-    {
-        tolerance.Ignore(x);
-    }
+        public virtual void Ignore(int x)
+        {
+            tolerance.Ignore(x);
+        }
}
}

