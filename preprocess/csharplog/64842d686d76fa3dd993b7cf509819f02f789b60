commit 64842d686d76fa3dd993b7cf509819f02f789b60
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Sun Apr 3 11:25:09 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Sun Apr 3 11:25:09 2011 -0800

(C# 3) Merge CL8009

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 8035]

diff --git a/Antlr4.StringTemplate.Visualizer/Extensions/TemplateExtensions.cs b/Antlr4.StringTemplate.Visualizer/Extensions/TemplateExtensions.cs
index e42f318..7a52683 100644
--- a/Antlr4.StringTemplate.Visualizer/Extensions/TemplateExtensions.cs
+++ b/Antlr4.StringTemplate.Visualizer/Extensions/TemplateExtensions.cs
@@ -39,22 +39,22 @@ namespace Antlr4.StringTemplate.Visualizer.Extensions

public static class TemplateExtensions
{
-        public static void Visualize(this DebugTemplate template)
+        public static TemplateVisualizer Visualize(this DebugTemplate template)
{
-            Visualize(template, CultureInfo.CurrentCulture);
+            return Visualize(template, CultureInfo.CurrentCulture);
}

-        public static void Visualize(this DebugTemplate template, int lineWidth)
+        public static TemplateVisualizer Visualize(this DebugTemplate template, int lineWidth)
{
-            Visualize(template, template.impl.NativeGroup.ErrorManager, CultureInfo.CurrentCulture, lineWidth);
+            return Visualize(template, template.impl.NativeGroup.ErrorManager, CultureInfo.CurrentCulture, lineWidth);
}

-        public static void Visualize(this DebugTemplate template, CultureInfo culture)
+        public static TemplateVisualizer Visualize(this DebugTemplate template, CultureInfo culture)
{
-            Visualize(template, template.impl.NativeGroup.ErrorManager, culture, AutoIndentWriter.NoWrap);
+            return Visualize(template, template.impl.NativeGroup.ErrorManager, culture, AutoIndentWriter.NoWrap);
}

-        public static void Visualize(this DebugTemplate template, ErrorManager errorManager, CultureInfo culture, int lineWidth)
+        public static TemplateVisualizer Visualize(this DebugTemplate template, ErrorManager errorManager, CultureInfo culture, int lineWidth)
{
ErrorBuffer errors = new ErrorBuffer();
template.impl.NativeGroup.Listener = errors;
@@ -65,6 +65,7 @@ namespace Antlr4.StringTemplate.Visualizer.Extensions
interp.Execute(wr, template); // Render and track events
TemplateVisualizer visualizer = new TemplateVisualizer(errorManager, template, @out.ToString(), interp, interp.GetExecutionTrace(), errors.Errors);
visualizer.Show();
+            return visualizer;
}
}
}
diff --git a/Antlr4.StringTemplate/Antlr4.StringTemplate.csproj b/Antlr4.StringTemplate/Antlr4.StringTemplate.csproj
index 6f06c84..6a42190 100644
--- a/Antlr4.StringTemplate/Antlr4.StringTemplate.csproj
+++ b/Antlr4.StringTemplate/Antlr4.StringTemplate.csproj
@@ -48,6 +48,8 @@
<Compile Include="Extensions\ExceptionExtensions.cs" />
<Compile Include="IAttributeRenderer.cs" />
<Compile Include="AutoIndentWriter.cs" />
+    <Compile Include="Misc\Aggregate.cs" />
+    <Compile Include="Misc\AggregateModelAdaptor.cs" />
<Compile Include="TemplateGroupString.cs" />
<None Include="..\Antlr3\Key.snk">
<Link>Key.snk</Link>
diff --git a/Antlr4.StringTemplate/Interpreter.cs b/Antlr4.StringTemplate/Interpreter.cs
index b8f33a5..d5aeb8e 100644
--- a/Antlr4.StringTemplate/Interpreter.cs
+++ b/Antlr4.StringTemplate/Interpreter.cs
@@ -523,7 +523,7 @@ namespace Antlr4.StringTemplate
prevOpcode = opcode;
}

-            if (group.Debug)
+            if (group.Debug && self is DebugTemplate)
{
EvalTemplateEvent e = new EvalTemplateEvent((DebugTemplate)self, Interval.FromBounds(start, @out.Index));
//Console.WriteLine(e);
@@ -656,7 +656,7 @@ namespace Antlr4.StringTemplate
protected void Indent(ITemplateWriter @out, Template self, int strIndex)
{
string indent = self.impl.strings[strIndex];
-            if (group.Debug)
+            if (group.Debug && self is DebugTemplate)
{
int start = @out.Index; // track char we're about to write
EvalExprEvent e = new IndentEvent((DebugTemplate)self, new Interval(start, indent.Length), GetExpressionInterval(self));
@@ -674,7 +674,7 @@ namespace Antlr4.StringTemplate
{
int start = @out.Index; // track char we're about to Write
int n = WriteObject(@out, self, o, null);
-            if (group.Debug)
+            if (group.Debug && self is DebugTemplate)
{
Interval templateLocation = self.impl.sourceMap[current_ip];
EvalExprEvent e = new EvalExprEvent((DebugTemplate)self, Interval.FromBounds(start, @out.Index), templateLocation);
@@ -714,7 +714,7 @@ namespace Antlr4.StringTemplate
@out.PopAnchorPoint();
}

-            if (group.Debug)
+            if (group.Debug && self is DebugTemplate)
{
Interval templateLocation = self.impl.sourceMap[current_ip];
EvalExprEvent e = new EvalExprEvent((DebugTemplate)self, Interval.FromBounds(start, @out.Index), templateLocation);
diff --git a/Antlr4.StringTemplate/Misc/Aggregate.cs b/Antlr4.StringTemplate/Misc/Aggregate.cs
new file mode 100644
index 0000000..38c72a8
--- /dev/null
+++ b/Antlr4.StringTemplate/Misc/Aggregate.cs
@@ -0,0 +1,110 @@
+﻿/*
+ * [The "BSD license"]
+ *  Copyright (c) 2011 Terence Parr
+ *  All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *  1. Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *  3. The name of the author may not be used to endorse or promote products
+ *     derived from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Misc
+{
+    using System.Collections.Generic;
+
+    /** An automatically created aggregate of properties.
+     *
+     *  I often have lists of things that need to be formatted, but the list
+     *  items are actually pieces of data that are not already in an object.  I
+     *  need ST to do something like:
+     *
+     *  Ter=3432
+     *  Tom=32234
+     *  ....
+     *
+     *  using template:
+     *
+     *  $items:{it.name$=$it.type$}$
+     *
+     *  This example will call getName() on the objects in items attribute, but
+     *  what if they aren't objects?  I have perhaps two parallel arrays
+     *  instead of a single array of objects containing two fields.  One
+     *  solution is allow Maps to be handled like properties so that it.name
+     *  would fail getName() but then see that it's a Map and do
+     *  it.get("name") instead.
+     *
+     *  This very clean approach is espoused by some, but the problem is that
+     *  it's a hole in my separation rules.  People can put the logic in the
+     *  view because you could say: "go get bob's data" in the view:
+     *
+     *  Bob's Phone: $db.bob.phone$
+     *
+     *  A view should not be part of the program and hence should never be able
+     *  to go ask for a specific person's data.
+     *
+     *  After much thought, I finally decided on a simple solution.  I've
+     *  added setAttribute variants that pass in multiple property values,
+     *  with the property names specified as part of the name using a special
+     *  attribute name syntax: "name.{propName1,propName2,...}".  This
+     *  object is a special kind of HashMap that hopefully prevents people
+     *  from passing a subclass or other variant that they have created as
+     *  it would be a loophole.  Anyway, the ASTExpr.getObjectProperty()
+     *  method looks for Aggregate as a special case and does a get() instead
+     *  of getPropertyName.
+     */
+    public class Aggregate
+    {
+        private readonly Dictionary<string, object> _properties = new Dictionary<string, object>();
+
+        internal IDictionary<string, object> Properties
+        {
+            get
+            {
+                return _properties;
+            }
+        }
+
+        /** Allow StringTemplate to add values, but prevent the end
+         *  user from doing so.
+         */
+        public object this[string propertyName]
+        {
+            get
+            {
+                return _properties[propertyName];
+            }
+
+            internal set
+            {
+                _properties[propertyName] = value;
+            }
+        }
+
+        public bool TryGetValue(string propertyName, out object value)
+        {
+            return _properties.TryGetValue(propertyName, out value);
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Misc/AggregateModelAdaptor.cs b/Antlr4.StringTemplate/Misc/AggregateModelAdaptor.cs
new file mode 100644
index 0000000..c47b142
--- /dev/null
+++ b/Antlr4.StringTemplate/Misc/AggregateModelAdaptor.cs
@@ -0,0 +1,49 @@
+﻿/*
+ * [The "BSD license"]
+ *  Copyright (c) 2011 Terence Parr
+ *  All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *  1. Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *  3. The name of the author may not be used to endorse or promote products
+ *     derived from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Misc
+{
+    using ArgumentException = System.ArgumentException;
+
+    /** Deal with structs created via ST.add("structname.{prop1, prop2}", ...); */
+    public class AggregateModelAdaptor : MapModelAdaptor
+    {
+        public override object GetProperty(Template self, object o, object property, string propertyName)
+        {
+            Aggregate aggregate = o as Aggregate;
+            if (aggregate == null)
+                throw new ArgumentException();
+
+            return base.GetProperty(self, aggregate.Properties, property, propertyName);
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Template.cs b/Antlr4.StringTemplate/Template.cs
index e6d40ad..421b1bf 100644
--- a/Antlr4.StringTemplate/Template.cs
+++ b/Antlr4.StringTemplate/Template.cs
@@ -261,6 +261,44 @@ namespace Antlr4.StringTemplate
return this;
}

+        /** Split "aggrName.{propName1,propName2}" into list [propName1,propName2]
+         *  and the aggrName. Spaces are allowed around ','.
+         */
+        [MethodImpl(MethodImplOptions.Synchronized)]
+        public Template AddMany(string aggrSpec, params object[] values)
+        {
+            if (aggrSpec == null)
+                throw new ArgumentNullException("aggrSpec");
+            if (values == null)
+                throw new ArgumentNullException("values");
+
+            if (values.Length == 0)
+                throw new ArgumentException(string.Format("missing values for aggregate attribute format: {0}", aggrSpec), "aggrSpec");
+
+            int dot = aggrSpec.IndexOf(".{");
+            int finalCurly = aggrSpec.IndexOf('}');
+            if (dot < 0 || finalCurly < 0)
+                throw new ArgumentException(string.Format("invalid aggregate attribute format: {0}", aggrSpec), "aggrSpec");
+
+            string aggrName = aggrSpec.Substring(0, dot);
+            string propString = aggrSpec.Substring(dot + 2, aggrSpec.Length - dot - 3);
+            propString = propString.Trim();
+            string[] propNames = Array.ConvertAll(propString.Split(','), p => p.Trim());
+            if (propNames == null || propNames.Length == 0)
+                throw new ArgumentException(string.Format("invalid aggregate attribute format: {0}", aggrSpec), "aggrSpec");
+
+            if (values.Length != propNames.Length)
+                throw new ArgumentException(string.Format("number of properties and values mismatch for aggregate attribute format: {0}", aggrSpec), "aggrSpec");
+
+            int i = 0;
+            Aggregate aggr = new Aggregate();
+            foreach (string p in propNames)
+                aggr[p] = values[i++];
+
+            Add(aggrName, aggr); // now add as usual
+            return this;
+        }
+
/** Remove an attribute value entirely (can't Remove attribute definitions). */
public virtual void Remove(string name)
{
diff --git a/Antlr4.StringTemplate/TemplateGroup.cs b/Antlr4.StringTemplate/TemplateGroup.cs
index f174e7c..4285dfb 100644
--- a/Antlr4.StringTemplate/TemplateGroup.cs
+++ b/Antlr4.StringTemplate/TemplateGroup.cs
@@ -116,6 +116,7 @@ namespace Antlr4.StringTemplate
{typeof(object), new ObjectModelAdaptor()},
{typeof(Template), new TemplateModelAdaptor()},
{typeof(IDictionary), new MapModelAdaptor()},
+                {typeof(Aggregate), new AggregateModelAdaptor()},
};

public static TemplateGroup defaultGroup = new TemplateGroup();
diff --git a/Antlr4.Test.StringTemplate/Antlr4.Test.StringTemplate.csproj b/Antlr4.Test.StringTemplate/Antlr4.Test.StringTemplate.csproj
index f4cad7e..9f2524c 100644
--- a/Antlr4.Test.StringTemplate/Antlr4.Test.StringTemplate.csproj
+++ b/Antlr4.Test.StringTemplate/Antlr4.Test.StringTemplate.csproj
@@ -51,6 +51,7 @@
<ItemGroup>
<Compile Include="Extensions\ListExtensions.cs" />
<Compile Include="Properties\AssemblyInfo.cs" />
+    <Compile Include="TestAggregates.cs" />
<Compile Include="TestVisualizer.cs" />
</ItemGroup>
<ItemGroup>
diff --git a/Antlr4.Test.StringTemplate/TestAggregates.cs b/Antlr4.Test.StringTemplate/TestAggregates.cs
new file mode 100644
index 0000000..9d6dd25
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/TestAggregates.cs
@@ -0,0 +1,104 @@
+﻿/*
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBTemplateITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, TemplateRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+
+    [TestClass]
+    public class TestAggregates : BaseTest
+    {
+        [TestMethod]
+        public void TestApplyAnonymousTemplateToAggregateAttribute()
+        {
+            Template st = new Template("<items:{it|<it.id>: <it.lastName>, <it.firstName>\n}>");
+            // also testing wacky spaces in aggregate spec
+            st.AddMany("items.{ firstName ,lastName, id }", "Ter", "Parr", 99);
+            st.AddMany("items.{firstName, lastName ,id}", "Tom", "Burns", 34);
+            string expecting =
+                "99: Parr, Ter" + newline +
+                "34: Burns, Tom" + newline;
+            Assert.AreEqual(expecting, st.Render());
+        }
+
+        public class Decl
+        {
+            private readonly string name;
+            private readonly string type;
+
+            public Decl(string name, string type)
+            {
+                this.name = name;
+                this.type = type;
+            }
+
+            public string Name
+            {
+                get
+                {
+                    return name;
+                }
+            }
+
+            public string Type
+            {
+                get
+                {
+                    return type;
+                }
+            }
+        }
+
+        [TestMethod]
+        public void TestComplicatedIndirectTemplateApplication()
+        {
+            string templates =
+                "group Java;" + newline +
+                "" + newline +
+                "file(variables) ::= <<" +
+                "<variables:{ v | <v.decl:(v.format)()>}; separator=\"\\n\">" + newline +
+                ">>" + newline +
+                "intdecl(decl) ::= \"int <decl.name> = 0;\"" + newline +
+                "intarray(decl) ::= \"int[] <decl.name> = null;\"" + newline
+                ;
+            TemplateGroup group = new TemplateGroupString(templates);
+            Template f = group.GetInstanceOf("file");
+            f.AddMany("variables.{ decl,format }", new Decl("i", "int"), "intdecl");
+            f.AddMany("variables.{decl ,  format}", new Decl("a", "int-array"), "intarray");
+            //System.out.println("f='"+f+"'");
+            string expecting = "int i = 0;" + newline +
+                               "int[] a = null;";
+            Assert.AreEqual(expecting, f.Render());
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/TestCoreBasics.cs b/Antlr4.Test.StringTemplate/TestCoreBasics.cs
index 3b5c857..3ae90dc 100644
--- a/Antlr4.Test.StringTemplate/TestCoreBasics.cs
+++ b/Antlr4.Test.StringTemplate/TestCoreBasics.cs
@@ -156,7 +156,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestPropWithNoAttr()
{
-            string template = "<foo.a>: <ick>"; // checks field and method getter
+            string template = "<foo.a>: <ick>";
Template st = new Template(template);
st.Add("foo", new Dictionary<string, string>() { { "a", "b" } });
string expected = "b: ";

