commit c1df699f8e2e86b6524ef39f712bd8dd71ff5a8e
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Thu Dec 10 22:59:23 2009 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Thu Dec 10 22:59:23 2009 -0800

C# Port:
* Merge CL6370

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 6483]

diff --git a/Antlr3.Test/ST4/TestCompiler.cs b/Antlr3.Test/ST4/TestCompiler.cs
index a327eba..943ea05 100644
--- a/Antlr3.Test/ST4/TestCompiler.cs
+++ b/Antlr3.Test/ST4/TestCompiler.cs
@@ -16,7 +16,7 @@
public void TestAttr()
{
string template = "hi <name>";
-            CompiledTemplate code = new Compiler().Compile(template);
+            CompiledTemplate code = new Compiler().Compile(null, template);
string asmExpected =
"load_str 0, " +
"write, " +
@@ -33,7 +33,7 @@
public void TestInclude()
{
string template = "hi <foo()>";
-            CompiledTemplate code = new Compiler().Compile(template);
+            CompiledTemplate code = new Compiler().Compile(null, template);
string asmExpected =
"load_str 0, write, new 1, write";
string asmResult = code.Instructions();
@@ -47,7 +47,7 @@
public void TestProp()
{
string template = "hi <a.b>";
-            CompiledTemplate code = new Compiler().Compile(template);
+            CompiledTemplate code = new Compiler().Compile(null, template);
string asmExpected =
"load_str 0, write, load_attr 1, load_prop 2, write";
string asmResult = code.Instructions();
@@ -61,7 +61,7 @@
public void TestProp2()
{
string template = "<u.id>: <u.name>";
-            CompiledTemplate code = new Compiler().Compile(template);
+            CompiledTemplate code = new Compiler().Compile(null, template);
string asmExpected =
"load_attr 0, load_prop 1, write, load_str 2, write, " +
"load_attr 0, load_prop 3, write";
@@ -76,7 +76,7 @@
public void TestMap()
{
string template = "hi <name:bold>";
-            CompiledTemplate code = new Compiler().Compile(template);
+            CompiledTemplate code = new Compiler().Compile(null, template);
string asmExpected =
"load_str 0, write, load_attr 1, load_str 2, map, write";
string asmResult = code.Instructions();
@@ -90,7 +90,7 @@
public void TestRepeatedMap()
{
string template = "hi <name:bold:italics>";
-            CompiledTemplate code = new Compiler().Compile(template);
+            CompiledTemplate code = new Compiler().Compile(null, template);
string asmExpected =
"load_str 0, " +
"write, " +
@@ -111,7 +111,7 @@
public void TestRotMap()
{
string template = "hi <name:bold,italics>";
-            CompiledTemplate code = new Compiler().Compile(template);
+            CompiledTemplate code = new Compiler().Compile(null, template);
string asmExpected =
"load_str 0, write, load_attr 1, load_str 2, load_str 3, rot_map 2, write";
string asmResult = code.Instructions();
@@ -125,7 +125,7 @@
public void TestAnonMap()
{
string template = "hi <name:{n | <n>}>";
-            CompiledTemplate code = new Compiler().Compile(template);
+            CompiledTemplate code = new Compiler().Compile(null, template);
string asmExpected =
"load_str 0, write, load_attr 1, load_str 2, map, write";
string asmResult = code.Instructions();
@@ -139,7 +139,7 @@
public void TestIf()
{
string template = "go: <if(name)>hi, foo<endif>";
-            CompiledTemplate code = new Compiler().Compile(template);
+            CompiledTemplate code = new Compiler().Compile(null, template);
string asmExpected =
"load_str 0, write, load_attr 1, brf 14, load_str 2, write";
string asmResult = code.Instructions();
@@ -153,7 +153,7 @@
public void TestIfElse()
{
string template = "go: <if(name)>hi, foo<else>bye<endif>";
-            CompiledTemplate code = new Compiler().Compile(template);
+            CompiledTemplate code = new Compiler().Compile(null, template);
string asmExpected =
"load_str 0, " +
"write, " +
@@ -175,7 +175,7 @@
public void TestElseIf()
{
string template = "go: <if(name)>hi, foo<elseif(user)>a user<endif>";
-            CompiledTemplate code = new Compiler().Compile(template);
+            CompiledTemplate code = new Compiler().Compile(null, template);
string asmExpected =
"load_str 0, " +
"write, " +
@@ -199,7 +199,7 @@
public void TestElseIfElse()
{
string template = "go: <if(name)>hi, foo<elseif(user)>a user<else>bye<endif>";
-            CompiledTemplate code = new Compiler().Compile(template);
+            CompiledTemplate code = new Compiler().Compile(null, template);
string asmExpected =
"load_str 0, " +
"write, " +
@@ -226,7 +226,7 @@
public void TestOption()
{
string template = "hi <name; separator=\"x\">";
-            CompiledTemplate code = new Compiler().Compile(template);
+            CompiledTemplate code = new Compiler().Compile(null, template);
string asmExpected =
"load_str 0, write, load_attr 1, options, load_str 2, store_option 3, write_opt";
string asmResult = code.Instructions();
@@ -240,7 +240,7 @@
public void TestOptionAsTemplate()
{
string template = "hi <name; separator={, }>";
-            CompiledTemplate code = new Compiler().Compile(template);
+            CompiledTemplate code = new Compiler().Compile(null, template);
string asmExpected =
"load_str 0, write, load_attr 1, options, new 2, store_option 3, write_opt";
string asmResult = code.Instructions();
@@ -254,7 +254,7 @@
public void TestOptions()
{
string template = "hi <name; anchor, wrap=foo(), separator=\", \">";
-            CompiledTemplate code = new Compiler().Compile(template);
+            CompiledTemplate code = new Compiler().Compile(null, template);
string asmExpected =
"load_str 0, write, load_attr 1, options, load_str 2, " +
"store_option 0, new 3, store_option 4, load_str 4, " +
@@ -271,7 +271,7 @@
public void TestEmptyList()
{
string template = "<[]>";
-            CompiledTemplate code = new Compiler().Compile(template);
+            CompiledTemplate code = new Compiler().Compile(null, template);
string asmExpected = "list, write";
string asmResult = code.Instructions();
Assert.AreEqual(asmExpected, asmResult);
@@ -284,7 +284,7 @@
public void TestList()
{
string template = "<[a,b]>";
-            CompiledTemplate code = new Compiler().Compile(template);
+            CompiledTemplate code = new Compiler().Compile(null, template);
string asmExpected = "list, load_attr 0, add, load_attr 1, add, write";
string asmResult = code.Instructions();
Assert.AreEqual(asmExpected, asmResult);
diff --git a/StringTemplate4/Bytecode.cs b/StringTemplate4/Bytecode.cs
index 7f45b11..06dfd48 100644
--- a/StringTemplate4/Bytecode.cs
+++ b/StringTemplate4/Bytecode.cs
@@ -73,6 +73,8 @@ namespace StringTemplate
}
}

+        // TODO: try an enum here
+
// INSTRUCTION BYTECODES (byte is signed; use a short to keep 0..255)
public const short INSTR_LOAD_STR = 1;
public const short INSTR_LOAD_ATTR = 2;
diff --git a/StringTemplate4/CompiledTemplate.cs b/StringTemplate4/CompiledTemplate.cs
index a9b8a7e..ee8a6e1 100644
--- a/StringTemplate4/CompiledTemplate.cs
+++ b/StringTemplate4/CompiledTemplate.cs
@@ -46,7 +46,7 @@ namespace StringTemplate

protected internal IDictionary<string, FormalArgument> formalArguments;

-        internal List<CompiledTemplate> compiledSubtemplates;
+        internal List<CompiledTemplate> implicitlyDefinedTemplates;

/** The group that holds this ST definition.  We use it to initiate
*  interpretation via ST.toString().  From there, it becomes field 'group'
@@ -54,6 +54,21 @@ namespace StringTemplate
*/
public TemplateGroup nativeGroup = TemplateGroup.defaultGroup;

+        /** Does this template come from a <@region>...<@end> embedded in
+         *  another template?
+         */
+        protected internal bool isRegion;
+
+        /** If someone refs <@r()> in template t, an implicit
+         *
+         *   @t.r() ::= ""
+         *
+         *  is defined, but you can overwrite this def by defining your
+         *  own.  We need to prevent more than one manual def though.  Between
+         *  this var and isEmbeddedRegion we can determine these cases.
+         */
+        protected internal Template.RegionType regionDefType;
+
public string[] strings;
public byte[] instrs;        // byte-addressable code memory.
public int codeSize;
diff --git a/StringTemplate4/Compiler.cs b/StringTemplate4/Compiler.cs
index 0653dcf..b22d2c0 100644
--- a/StringTemplate4/Compiler.cs
+++ b/StringTemplate4/Compiler.cs
@@ -110,14 +110,15 @@ namespace StringTemplate
}
}

-        public CompiledTemplate Compile(string template)
+        public CompiledTemplate Compile(string enclosingTemplateName, string template)
{
-            return Compile(template, '<', '>');
+            return Compile(enclosingTemplateName, template, '<', '>');
}

-        public CompiledTemplate Compile(string template,
-                                  char delimiterStartChar,
-                                  char delimiterStopChar)
+        public CompiledTemplate Compile(string enclosingTemplateName,
+                                        string template,
+                                        char delimiterStartChar,
+                                        char delimiterStopChar)
{
int initialSize = Math.Max(5, (int)(template.Length / CODE_SIZE_FACTOR));
instrs = new byte[initialSize];
@@ -125,7 +126,7 @@ namespace StringTemplate

TemplateLexer lexer = new TemplateLexer(new ANTLRStringStream(template), delimiterStartChar, delimiterStopChar);
UnbufferedTokenStream tokens = new UnbufferedTokenStream(lexer);
-            TemplateParser parser = new TemplateParser(tokens, this);
+            TemplateParser parser = new TemplateParser(tokens, this, enclosingTemplateName);
try
{
parser.templateAndEOF(); // parse, trigger compile actions for single expr
@@ -144,10 +145,10 @@ namespace StringTemplate
return code;
}

-        public CompiledTemplate Compile(ITokenStream tokens, RecognizerSharedState state)
+        public CompiledTemplate Compile(string enclosingTemplateName, ITokenStream tokens, RecognizerSharedState state)
{
instrs = new byte[SUBTEMPLATE_INITIAL_CODE_SIZE];
-            TemplateParser parser = new TemplateParser(tokens, state, this);
+            TemplateParser parser = new TemplateParser(tokens, state, this, enclosingTemplateName);
try
{
parser.template(); // parse, trigger compile actions for single expr
@@ -203,14 +204,18 @@ namespace StringTemplate
return ip;
}

-        public string CompileAnonTemplate(ITokenStream input,
-                                   IList ids,
-                                   RecognizerSharedState state)
+        public string CompileAnonTemplate(string enclosingTemplateName,
+                                          ITokenStream input,
+                                          IList<IToken> ids,
+                                          RecognizerSharedState state)
{
subtemplateCount++;
string name = prefix + "_sub" + subtemplateCount;
Compiler c = new Compiler(prefix);
-            CompiledTemplate sub = c.Compile(input, state);
+            CompiledTemplate sub = c.Compile(enclosingTemplateName, input, state);
+            if (code.implicitlyDefinedTemplates == null)
+                code.implicitlyDefinedTemplates = new List<CompiledTemplate>();
+            code.implicitlyDefinedTemplates.Add(sub);
sub.name = name;
if (ids != null)
{
@@ -221,12 +226,22 @@ namespace StringTemplate
sub.formalArguments[argName] = new FormalArgument(argName);
}
}
-            if (code.compiledSubtemplates == null)
+            return name;
+        }
+
+        public void CompileRegion(string enclosingTemplateName,
+                                  string regionName,
+                                  ITokenStream input,
+                                  RecognizerSharedState state)
+        {
+            Compiler c = new Compiler(prefix);
+            CompiledTemplate sub = c.Compile(enclosingTemplateName, input, state);
+            sub.name = regionName;
+            if (code.implicitlyDefinedTemplates == null)
{
-                code.compiledSubtemplates = new List<CompiledTemplate>();
+                code.implicitlyDefinedTemplates = new List<CompiledTemplate>();
}
-            code.compiledSubtemplates.Add(sub);
-            return name;
+            code.implicitlyDefinedTemplates.Add(sub);
}

protected void EnsureCapacity()
diff --git a/StringTemplate4/Group.g3 b/StringTemplate4/Group.g3
index 3874be4..e144f3d 100644
--- a/StringTemplate4/Group.g3
+++ b/StringTemplate4/Group.g3
@@ -91,6 +91,8 @@ templateDef[string prefix]
}
try {
this._group.DefineTemplate(prefix, $name.text, $formalArgs.args, template);
+		    GroupLexer lexer = (GroupLexer)input.TokenSource;
+		    lexer._enclosingTemplateName = $name.text;
}
catch (TemplateRecognitionException e) {
RecognitionException re = (RecognitionException)e.InnerException;
@@ -194,7 +196,7 @@ ANONYMOUS_TEMPLATE
new TemplateLexer(input, this._group.delimiterStartChar, this._group.delimiterStopChar);
lexer.subtemplateDepth = 1;
UnbufferedTokenStream tokens = new UnbufferedTokenStream(lexer);
-        TemplateParser parser = new TemplateParser(tokens, (ICodeGenerator)null);
+        TemplateParser parser = new TemplateParser(tokens, (ICodeGenerator)null, this._enclosingTemplateName);
parser.template();
}
// don't match '}' here; subparser matches it to terminate
diff --git a/StringTemplate4/GroupLexerHelper.cs b/StringTemplate4/GroupLexerHelper.cs
index af29d5e..baccd8f 100644
--- a/StringTemplate4/GroupLexerHelper.cs
+++ b/StringTemplate4/GroupLexerHelper.cs
@@ -34,6 +34,7 @@ namespace StringTemplate
{
partial class GroupLexer
{
+        protected internal string _enclosingTemplateName;
protected internal TemplateGroup _group;
}
}
diff --git a/StringTemplate4/ICodeGenerator.cs b/StringTemplate4/ICodeGenerator.cs
index b2ee58e..73376de 100644
--- a/StringTemplate4/ICodeGenerator.cs
+++ b/StringTemplate4/ICodeGenerator.cs
@@ -32,9 +32,11 @@

namespace StringTemplate
{
+    using System.Collections.Generic;
using Antlr.Runtime;
using IList = System.Collections.IList;

+    // TODO: maybe rename; more than code gen now; break into two interfaces?
public interface ICodeGenerator
{
/// <summary>
@@ -52,8 +54,12 @@ namespace StringTemplate
/** Return address where next instruction will be written */
int Address();

-        string CompileAnonTemplate(ITokenStream input,
-                                   IList ids,
+        /** Compile a subtemplate. It's the '...' in this &lt;names:{p | ...}&gt; */
+        string CompileAnonTemplate(string enclosingTemplateName,
+                                   ITokenStream input,
+                                   IList<IToken> ids,
RecognizerSharedState state);
+
+        void CompileRegion(string enclosingTemplateName, string regionName, ITokenStream input, RecognizerSharedState state);
}
}
diff --git a/StringTemplate4/Template.cs b/StringTemplate4/Template.cs
index e75f692..68cce8a 100644
--- a/StringTemplate4/Template.cs
+++ b/StringTemplate4/Template.cs
@@ -329,5 +329,13 @@ namespace StringTemplate
{
return code.name + "()";
}
+
+        /** &lt;@r()&gt;, &lt;@r&gt;...&lt;@end&gt;, and @t.r() ::= "..." defined manually by coder */
+        public enum RegionType
+        {
+            Implicit,
+            Embedded,
+            Explicit
+        }
}
}
diff --git a/StringTemplate4/TemplateGroup.cs b/StringTemplate4/TemplateGroup.cs
index 26a1eca..1e292d8 100644
--- a/StringTemplate4/TemplateGroup.cs
+++ b/StringTemplate4/TemplateGroup.cs
@@ -230,7 +230,7 @@ namespace StringTemplate
throw new ArgumentException("cannot have '.' in template names");
}
Compiler c = new Compiler(prefix);
-            CompiledTemplate code = c.Compile(template);
+            CompiledTemplate code = c.Compile(name, template);
code.name = name;
code.formalArguments = args;
code.nativeGroup = this;
@@ -243,7 +243,7 @@ namespace StringTemplate
if (fa.defaultValue != null)
{
Compiler c2 = new Compiler(prefix);
-                        fa.compiledDefaultValue = c2.Compile(template);
+                        fa.compiledDefaultValue = c2.Compile(null, template);
}
}
}
@@ -255,9 +255,9 @@ namespace StringTemplate

protected virtual void DefineAnonSubtemplates(CompiledTemplate code)
{
-            if (code.compiledSubtemplates != null)
+            if (code.implicitlyDefinedTemplates != null)
{
-                foreach (CompiledTemplate sub in code.compiledSubtemplates)
+                foreach (CompiledTemplate sub in code.implicitlyDefinedTemplates)
{
templates[sub.name] = sub;
DefineAnonSubtemplates(sub);
@@ -265,6 +265,35 @@ namespace StringTemplate
}
}

+        /** Track all references to regions &lt;@foo&gt;...&lt;@end&gt; or &lt;@foo()&gt;.  */
+        public CompiledTemplate DefineRegionTemplate(string enclosingTemplateName,
+                                               string regionName,
+                                               string template,
+                                               Template.RegionType type)
+        {
+            string mangledName =
+                GetMangledRegionName(enclosingTemplateName, regionName);
+            CompiledTemplate regionST = DefineTemplate(mangledName, template);
+            regionST.isRegion = true;
+            regionST.regionDefType = type;
+            return regionST;
+        }
+
+        /** The "foo" of t() ::= "&lt;@foo()&gt;" is mangled to "region#t#foo" */
+        public static string GetMangledRegionName(string enclosingTemplateName,
+                                                  string name)
+        {
+            return "region__" + enclosingTemplateName + "__" + name;
+        }
+
+        /** Return "t" from "region__t__foo" */
+        public static string getUnMangledTemplateName(string mangledName)
+        {
+            int start = "region__".Length;
+            int end = mangledName.LastIndexOf("__");
+            return mangledName.Substring(start, end - start);
+        }
+
/** Define a map for this group; not thread safe...do not keep adding
*  these while you reference them.
*/
diff --git a/StringTemplate4/TemplateLexer.cs b/StringTemplate4/TemplateLexer.cs
index 318dcd6..4d8eb72 100644
--- a/StringTemplate4/TemplateLexer.cs
+++ b/StringTemplate4/TemplateLexer.cs
@@ -110,6 +110,8 @@ namespace StringTemplate
public const int AND = 30;
public const int INDENT = 31;
public const int NEWLINE = 32;
+        public const int AT = 33;
+        public const int REGION_END = 34;

char delimiterStartChar = '<';
char delimiterStopChar = '>';
@@ -280,6 +282,16 @@ namespace StringTemplate
case '!':
Consume();
return NewToken(BANG);
+                case '@':
+                    Consume();
+                    if (c == 'e' && input.LA(2) == 'n' && input.LA(3) == 'd')
+                    {
+                        Consume();
+                        Consume();
+                        Consume();
+                        return NewToken(REGION_END);
+                    }
+                    return NewToken(AT);
case '"':
return mSTRING();
case '&':
diff --git a/StringTemplate4/TemplateLexer.tokens b/StringTemplate4/TemplateLexer.tokens
index 94b924c..d4491a0 100644
--- a/StringTemplate4/TemplateLexer.tokens
+++ b/StringTemplate4/TemplateLexer.tokens
@@ -27,6 +27,8 @@ OR=29
AND=30
INDENT=31
NEWLINE=32
+AT=33
+END=34
'super'=8
'|'=28
'!'=10
@@ -48,3 +50,5 @@ NEWLINE=32
']'=17
'||'=29
'&&'=30
+'@'=33
+'@end'=34
\ No newline at end of file
diff --git a/StringTemplate4/TemplateParser.g3 b/StringTemplate4/TemplateParser.g3
index 0c32bdf..4050161 100644
--- a/StringTemplate4/TemplateParser.g3
+++ b/StringTemplate4/TemplateParser.g3
@@ -35,6 +35,7 @@ options {
}

@namespace{StringTemplate}
+@header{using System.Linq;}

@rulecatch {
catch (RecognitionException) { throw; }
@@ -45,6 +46,7 @@ templateAndEOF
:	template EOF
;

+// TODO: remove backtracking
public
template
:	(	options {backtrack=true; k=2;}
@@ -58,6 +60,7 @@ template
|	i=INDENT         {Indent($i.text);}
text             {gen.Emit(Bytecode.INSTR_DEDENT);}
|	text
+		|   (i=INDENT {Indent($i.text);})? region
|	i=INDENT         {Indent($i.text);}
NEWLINE          {gen.Emit(Bytecode.INSTR_NEWLINE);}
{gen.Emit(Bytecode.INSTR_DEDENT);}
@@ -83,10 +86,21 @@ exprTag
RDELIM
;

+region // match $@foo$...$@end$
+	:	'@' ID
+		{{ // force exec even when backtracking
+		gen.CompileRegion(_enclosingTemplateName, $ID.text, input, state);
+        }}
+		'@end'
+	;
+
subtemplate returns [string name]
:	'{' ( ids+=ID (',' ids+=ID)* '|' )?
{{ // force exec even when backtracking
-		$name = gen.CompileAnonTemplate(input, $ids, state);
+		List<IToken> idTokens = null;
+		if ($ids != null)
+			idTokens = new List<IToken>($ids.Cast<IToken>());
+		$name = gen.CompileAnonTemplate(_enclosingTemplateName, input, idTokens, state);
}}
'}'
;
@@ -287,8 +301,13 @@ templateRef
:	ID			{gen.Emit(Bytecode.INSTR_LOAD_STR, PrefixedName($ID.text));}
|	subtemplate {gen.Emit(Bytecode.INSTR_LOAD_STR, PrefixedName($subtemplate.name));}
|	'(' mapExpr ')' {gen.Emit(Bytecode.INSTR_TOSTR);}
+	|	'@' ID '(' ')'	// convert <@r()> to <region__enclosingTemplate__r()>
+		{
+		string mangled = TemplateGroup.GetMangledRegionName(_enclosingTemplateName, $ID.text);
+		gen.Emit(Bytecode.INSTR_LOAD_STR, PrefixedName(mangled));
+		}
;
-
+
list:	{gen.Emit(Bytecode.INSTR_LIST);} '[' listElement (',' listElement)* ']'
|	{gen.Emit(Bytecode.INSTR_LIST);} '[' ']'
;
diff --git a/StringTemplate4/TemplateParserHelper.cs b/StringTemplate4/TemplateParserHelper.cs
index eb614f3..2e50c14 100644
--- a/StringTemplate4/TemplateParserHelper.cs
+++ b/StringTemplate4/TemplateParserHelper.cs
@@ -40,21 +40,24 @@ namespace StringTemplate
partial class TemplateParser
{
List<string> IFindents = new List<string>();
+        /** Is this template a subtemplate or region of an enclosing template? */
+        private string _enclosingTemplateName;

ICodeGenerator gen = new CodeGenerator();

-        public TemplateParser(ITokenStream input, ICodeGenerator gen)
-            : this(input, new RecognizerSharedState(), gen)
+        public TemplateParser(ITokenStream input, ICodeGenerator gen, string enclosingTemplateName)
+            : this(input, new RecognizerSharedState(), gen, enclosingTemplateName)
{
}

-        public TemplateParser(ITokenStream input, RecognizerSharedState state, ICodeGenerator gen)
+        public TemplateParser(ITokenStream input, RecognizerSharedState state, ICodeGenerator gen, string enclosingTemplateName)
: base(null, null) // overcome bug in ANTLR 3.2
{
this.input = input;
this.state = state;
if (gen != null)
this.gen = gen;
+            this._enclosingTemplateName = enclosingTemplateName;
}
protected override object RecoverFromMismatchedToken(IIntStream input, int ttype, BitSet follow)
{
@@ -173,12 +176,16 @@ namespace StringTemplate
return 0;
}

-            public string CompileAnonTemplate(ITokenStream input, IList ids, RecognizerSharedState state)
+            public string CompileAnonTemplate(string enclosingTemplateName, ITokenStream input, IList<IToken> ids, RecognizerSharedState state)
{
Compiler c = new Compiler();
-                c.Compile(input, state);
+                c.Compile(null, input, state);
return null;
}
+
+            public void CompileRegion(string enclosingTemplateName, string regionName, ITokenStream input, RecognizerSharedState state)
+            {
+            }
}
}
}

