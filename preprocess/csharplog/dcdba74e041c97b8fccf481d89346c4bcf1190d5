commit dcdba74e041c97b8fccf481d89346c4bcf1190d5
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Sun Mar 15 17:20:45 2009 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Sun Mar 15 17:20:45 2009 -0800

C# Port:
* Add CSharp3 runtime (beta)
* Add C# ports of the Tool and StringTemplate (beta)

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 5868]

diff --git a/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj b/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj
new file mode 100644
index 0000000..e49eedf
--- /dev/null
+++ b/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj
@@ -0,0 +1,218 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{B5910BE2-DE21-4AA9-95C1-486F42B9E794}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>Antlr.ST</RootNamespace>
+    <AssemblyName>Antlr3.StringTemplate</AssemblyName>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <StartupObject>
+    </StartupObject>
+    <SccProjectName>SAK</SccProjectName>
+    <SccLocalPath>SAK</SccLocalPath>
+    <SccAuxPath>SAK</SccAuxPath>
+    <SccProvider>SAK</SccProvider>
+    <TargetFrameworkSubset>Client</TargetFrameworkSubset>
+    <SignAssembly>true</SignAssembly>
+    <AssemblyOriginatorKeyFile>Key.snk</AssemblyOriginatorKeyFile>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>bin\Debug\</OutputPath>
+    <DefineConstants>TRACE;DEBUG</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>bin\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="AttributeRenderer.cs" />
+    <Compile Include="AutoIndentWriter.cs" />
+    <Compile Include="CommonGroupLoader.cs" />
+    <Compile Include="NoIndentWriter.cs" />
+    <Compile Include="PathGroupLoader.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+    <Compile Include="StringTemplate.cs" />
+    <Compile Include="StringTemplateErrorListener.cs" />
+    <Compile Include="StringTemplateGroup.cs" />
+    <Compile Include="StringTemplateGroupInterface.cs" />
+    <Compile Include="StringTemplateGroupLoader.cs" />
+    <Compile Include="StringTemplateWriter.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <Antlr3 Include="Language\AngleBracketTemplateLexer.g3">
+      <OutputFiles>Language\AngleBracketTemplateLexer.cs;Language\AngleBracketTemplateLexer.tokens</OutputFiles>
+    </Antlr3>
+    <Compile Include="JavaExtensions\AntlrJavaExtensions.cs" />
+    <Compile Include="JavaExtensions\DictionaryExtensions.cs" />
+    <Compile Include="JavaExtensions\ListExtensions.cs" />
+    <Compile Include="Language\AngleBracketTemplateLexer.cs">
+      <AutoGen>True</AutoGen>
+      <DesignTime>True</DesignTime>
+      <DependentUpon>AngleBracketTemplateLexer.g3</DependentUpon>
+    </Compile>
+    <Compile Include="Language\AngleBracketTemplateLexerHelper.cs">
+      <DependentUpon>AngleBracketTemplateLexer.g3</DependentUpon>
+    </Compile>
+    <Antlr3 Include="Language\Template.g3">
+      <OutputFiles>Language\TemplateLexer.cs;Language\TemplateParser.cs;Language\Template.tokens</OutputFiles>
+    </Antlr3>
+    <Compile Include="Language\ASTExpr.cs" />
+    <Compile Include="Language\Cat.cs" />
+    <Compile Include="Language\ChunkToken.cs" />
+    <Compile Include="Language\ConditionalExpr.cs" />
+    <Compile Include="Language\Expr.cs" />
+    <Compile Include="Language\FormalArgument.cs" />
+    <Compile Include="Language\NewlineRef.cs" />
+    <Compile Include="Language\StringRef.cs" />
+    <Compile Include="Language\StringTemplateAST.cs" />
+    <Compile Include="Language\StringTemplateToken.cs" />
+    <Compile Include="Language\StringTemplateTreeAdaptor.cs" />
+    <Compile Include="Language\TemplateLexer.cs">
+      <AutoGen>True</AutoGen>
+      <DesignTime>True</DesignTime>
+      <DependentUpon>Template.g3</DependentUpon>
+    </Compile>
+    <Compile Include="Language\TemplateLexerHelper.cs">
+      <DependentUpon>Template.g3</DependentUpon>
+    </Compile>
+    <Compile Include="Language\TemplateParser.cs">
+      <AutoGen>True</AutoGen>
+      <DesignTime>True</DesignTime>
+      <DependentUpon>Template.g3</DependentUpon>
+    </Compile>
+    <Compile Include="Language\TemplateParserHelper.cs">
+      <DependentUpon>Template.g3</DependentUpon>
+    </Compile>
+    <Antlr3 Include="Language\Interface.g3">
+      <OutputFiles>Language\InterfaceLexer.cs;Language\InterfaceParser.cs;Language\Interface.tokens</OutputFiles>
+    </Antlr3>
+    <Compile Include="Language\InterfaceLexer.cs">
+      <AutoGen>True</AutoGen>
+      <DesignTime>True</DesignTime>
+      <DependentUpon>Interface.g3</DependentUpon>
+    </Compile>
+    <Compile Include="Language\InterfaceLexerHelper.cs">
+      <DependentUpon>Interface.g3</DependentUpon>
+    </Compile>
+    <Compile Include="Language\InterfaceParser.cs">
+      <AutoGen>True</AutoGen>
+      <DesignTime>True</DesignTime>
+      <DependentUpon>Interface.g3</DependentUpon>
+    </Compile>
+    <Compile Include="Language\InterfaceParserHelper.cs">
+      <DependentUpon>Interface.g3</DependentUpon>
+    </Compile>
+    <Antlr3 Include="Language\Group.g3">
+      <OutputFiles>Language\GroupLexer.cs;Language\GroupParser.cs;Language\Group.tokens</OutputFiles>
+    </Antlr3>
+    <Compile Include="Language\GroupLexer.cs">
+      <AutoGen>True</AutoGen>
+      <DesignTime>True</DesignTime>
+      <DependentUpon>Group.g3</DependentUpon>
+    </Compile>
+    <Compile Include="Language\GroupLexerHelper.cs">
+      <DependentUpon>Group.g3</DependentUpon>
+    </Compile>
+    <Compile Include="Language\GroupParser.cs">
+      <AutoGen>True</AutoGen>
+      <DesignTime>True</DesignTime>
+      <DependentUpon>Group.g3</DependentUpon>
+    </Compile>
+    <Compile Include="Language\GroupParserHelper.cs">
+      <DependentUpon>Group.g3</DependentUpon>
+    </Compile>
+    <Antlr3 Include="Language\Action.g3">
+      <OutputFiles>Language\ActionLexer.cs;Language\ActionParser.cs;Language\Action.tokens</OutputFiles>
+    </Antlr3>
+    <Compile Include="Language\ActionLexer.cs">
+      <AutoGen>True</AutoGen>
+      <DesignTime>True</DesignTime>
+      <DependentUpon>Action.g3</DependentUpon>
+    </Compile>
+    <Compile Include="Language\ActionLexerHelper.cs">
+      <DependentUpon>Action.g3</DependentUpon>
+    </Compile>
+    <Compile Include="Language\ActionParser.cs">
+      <AutoGen>True</AutoGen>
+      <DesignTime>True</DesignTime>
+      <DependentUpon>Action.g3</DependentUpon>
+    </Compile>
+    <Compile Include="Language\ActionParserHelper.cs">
+      <DependentUpon>Action.g3</DependentUpon>
+    </Compile>
+    <Antlr3 Include="Language\ActionEvaluator.g3">
+      <OutputFiles>Language\ActionEvaluator.cs;Language\ActionEvaluator.tokens</OutputFiles>
+    </Antlr3>
+    <Compile Include="Language\ActionEvaluator.cs">
+      <AutoGen>True</AutoGen>
+      <DesignTime>True</DesignTime>
+      <DependentUpon>ActionEvaluator.g3</DependentUpon>
+    </Compile>
+    <Compile Include="Language\ActionEvaluatorHelper.cs">
+      <DependentUpon>ActionEvaluator.g3</DependentUpon>
+    </Compile>
+    <Compile Include="Runtime.Tree\DOTTreeGenerator.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="Key.snk" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\..\antlr\main\runtime\CSharp3\Sources\Antlr3.Runtime.Debug\Antlr3.Runtime.Debug.csproj">
+      <Project>{5EE27A90-B023-42C9-AAF1-52B0424C5D0B}</Project>
+      <Name>Antlr3.Runtime.Debug</Name>
+    </ProjectReference>
+    <ProjectReference Include="..\..\..\antlr\main\runtime\CSharp3\Sources\Antlr3.Runtime\Antlr3.Runtime.csproj">
+      <Project>{8FDC0A87-9005-4D5A-AB75-E55CEB575559}</Project>
+      <Name>Antlr3.Runtime</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <PropertyGroup>
+    <UseHostCompilerIfAvailable>False</UseHostCompilerIfAvailable>
+  </PropertyGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <PropertyGroup>
+    <Antlr3ToolPath>$(MSBuildProjectDirectory)\..\bin\Bootstrap</Antlr3ToolPath>
+    <CoreCompileDependsOn>$(CoreCompileDependsOn);GenerateAntlrCode</CoreCompileDependsOn>
+    <CoreCleanDependsOn>$(CoreCleanDependsOn);CleanAntlrCode</CoreCleanDependsOn>
+  </PropertyGroup>
+  <Target Name="GenerateAntlrCode" Inputs="@(Antlr3)" Outputs="%(OutputFiles)">
+    <Message Importance="normal" Text="Antlr: Transforming '@(Antlr3)' to '%(Antlr3.OutputFiles)'" />
+    <!--<Exec Command="java -cp %22$(Antlr3ToolPath)\antlr3.jar;$(Antlr3ToolPath)\antlr-2.7.7.jar;$(Antlr3ToolPath)\stringtemplate-3.1b1.jar%22 org.antlr.Tool -lib %22%(RootDir)%(Directory).%22 -message-format vs2005 @(Antlr3)" Outputs="%(OutputFiles)" />-->
+    <Exec Command="%22$(Antlr3ToolPath)\Antlr3.exe%22 -Xconversiontimeout 60000 -lib %22%(RootDir)%(Directory).%22 -message-format vs2005 @(Antlr3)" Outputs="%(OutputFiles)" />
+  </Target>
+  <Target Name="CleanAntlrCode">
+    <ItemGroup>
+      <_CleanAntlrFileWrites Include="@(Antlr3->'%(RelativeDir)%(Filename).tokens')" />
+    </ItemGroup>
+    <Message Importance="normal" Text="Antlr: Deleting output files '@(_CleanAntlrFileWrites)'" />
+    <!--<Delete Files="@(_CleanAntlrFileWrites)" />-->
+  </Target>
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
\ No newline at end of file
diff --git a/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj.vspscc b/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj.vspscc
new file mode 100644
index 0000000..9b79d35
--- /dev/null
+++ b/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj.vspscc
@@ -0,0 +1,10 @@
+﻿""
+{
+"FILE_VERSION" = "9237"
+"ENLISTMENT_CHOICE" = "NEVER"
+"PROJECT_FILE_RELATIVE_PATH" = "relative:Reference\\Antlr\\source\\lib\\Antlr3.StringTemplate"
+"NUMBER_OF_EXCLUDED_FILES" = "0"
+"ORIGINAL_PROJECT_FILE_PATH" = ""
+"NUMBER_OF_NESTED_PROJECTS" = "0"
+"SOURCE_CONTROL_SETTINGS_PROVIDER" = "PROVIDER"
+}
diff --git a/Antlr3.StringTemplate/AttributeRenderer.cs b/Antlr3.StringTemplate/AttributeRenderer.cs
new file mode 100644
index 0000000..8ff8bf1
--- /dev/null
+++ b/Antlr3.StringTemplate/AttributeRenderer.cs
@@ -0,0 +1,59 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2003-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST
+{
+    /** <summary>
+     *  This interface describes an object that knows how to format or otherwise
+     *  render an object appropriately.  Usually this is used for locale changes
+     *  for objects such as Date and floating point numbers...  You can either
+     *  have an object that is sensitive to the locale or have a different object
+     *  per locale.
+     *  </summary>
+     *
+     *  <remarks>
+     *  Each template may have a renderer for each object type or can default
+     *  to the group's renderer or the super group's renderer if the group doesn't
+     *  have one.
+     *
+     *  The toString(Object,String) method is used when the user uses the
+     *  format option: $o; format="f"$.  It checks the formatName and applies the
+     *  appropriate formatting.  If the format string passed to the renderer is
+     *  not recognized then simply call toString().  @since 3.1
+     *  </remarks>
+     */
+    public interface IAttributeRenderer
+    {
+        string ToString( object o );
+        string ToString( object o, string formatName );
+    }
+}
diff --git a/Antlr3.StringTemplate/AutoIndentWriter.cs b/Antlr3.StringTemplate/AutoIndentWriter.cs
new file mode 100644
index 0000000..6b20d5d
--- /dev/null
+++ b/Antlr3.StringTemplate/AutoIndentWriter.cs
@@ -0,0 +1,334 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2003-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST
+{
+    using System;
+    using System.Collections.Generic;
+    using System.Linq;
+
+    using StringBuilder = System.Text.StringBuilder;
+    using TextWriter = System.IO.TextWriter;
+
+    /** <summary>
+     *  Essentially a char filter that knows how to auto-indent output
+     *  by maintaining a stack of indent levels.  I set a flag upon newline
+     *  and then next nonwhitespace char resets flag and spits out indention.
+     *  The indent stack is a stack of strings so we can repeat original indent
+     *  not just the same number of columns (don't have to worry about tabs vs
+     *  spaces then).
+     *  </summary>
+     *
+     *  <remarks>
+     *  Anchors are char positions (tabs won't work) that indicate where all
+     *  future wraps should justify to.  The wrap position is actually the
+     *  larger of either the last anchor or the indentation level.
+     *
+     *  This is a filter on a Writer.
+     *
+     *  \n is the proper way to say newline for options and templates.
+     *  Templates can mix them but use \n for sure and options like
+     *  wrap="\n". ST will generate the right thing. Override the default (locale)
+     *  newline by passing in a string to the constructor.
+     *  </remarks>
+     */
+    public class AutoIndentWriter : IStringTemplateWriter
+    {
+        const int NO_WRAP = -1;
+
+        /** <summary>
+         *  stack of indents; use List as it's much faster than Stack. Grows
+         *  from 0..n-1.  List&lt;String&gt;
+         *  </summary>
+         */
+        List<string> _indents = new List<string>();
+
+        /** <summary>
+         *  Stack of integer anchors (char positions in line); avoid Integer
+         *  creation overhead.
+         *  </summary>
+         */
+        int[] _anchors = new int[10];
+        int _anchors_sp = -1;
+
+        /** <summary>\n or \r\n?</summary> */
+        string _newline;
+
+        TextWriter _writer = null;
+        bool _atStartOfLine = true;
+
+        /** <summary>
+         *  Track char position in the line (later we can think about tabs).
+         *  Indexed from 0.  We want to keep charPosition &lt;= lineWidth.
+         *  This is the position we are *about* to write not the position
+         *  last written to.
+         *  </summary>
+         */
+        int _charPosition = 0;
+        int _lineWidth = NO_WRAP;
+
+        public AutoIndentWriter( TextWriter writer, string newline )
+        {
+            _writer = writer;
+            _indents.Add( string.Empty ); // start with no indent
+            _newline = newline;
+        }
+
+        public AutoIndentWriter( TextWriter writer )
+            : this( writer, Environment.NewLine )
+        {
+        }
+
+        public TextWriter Writer
+        {
+            get
+            {
+                return _writer;
+            }
+        }
+
+        public virtual void setLineWidth( int lineWidth )
+        {
+            _lineWidth = lineWidth;
+        }
+
+        /** <summary>
+         *  Push even blank (null) indents as they are like scopes; must
+         *  be able to pop them back off stack.
+         *  </summary>
+         *
+         *  <remarks>
+         *  To deal with combined anchors and indentation, force indents to
+         *  include any current anchor point.  If current anchor is beyond
+         *  current indent width, add the difference to the indent to be added.
+         *
+         *  This prevents a check later to deal with anchors when starting new line.
+         *  </remarks>
+         */
+        public virtual void pushIndentation( string indent )
+        {
+            int lastAnchor = 0;
+            int indentWidth = getIndentationWidth();
+            // If current anchor is beyond current indent width, add in difference
+            if ( _anchors_sp >= 0 && _anchors[_anchors_sp] > indentWidth )
+            {
+                lastAnchor = _anchors[_anchors_sp];
+                StringBuilder buf = getIndentString( lastAnchor - indentWidth );
+                if ( indent != null )
+                    buf.Append( indent ); // don't add if null
+                _indents.Add( buf.ToString() );
+                return;
+            }
+            _indents.Add( indent ?? string.Empty );
+        }
+
+        /// <exception cref="System.ArgumentOutOfRangeException" />
+        public virtual string popIndentation()
+        {
+            string value = _indents[_indents.Count - 1];
+            _indents.RemoveAt( _indents.Count - 1 );
+            return value;
+        }
+
+        /// <exception cref="System.ArgumentNullException" />
+        /// <exception cref="System.RankException" />
+        /// <exception cref="System.ArrayTypeMismatchException" />
+        /// <exception cref="System.InvalidCastException" />
+        /// <exception cref="System.ArgumentOutOfRangeException" />
+        /// <exception cref="System.ArgumentException" />
+        public virtual void pushAnchorPoint()
+        {
+            if ( ( _anchors_sp + 1 ) >= _anchors.Length )
+            {
+                int[] a = new int[_anchors.Length * 2];
+                Array.Copy( _anchors, 0, a, 0, _anchors.Length );
+                _anchors = a;
+            }
+            _anchors_sp++;
+            _anchors[_anchors_sp] = _charPosition;
+        }
+
+        public virtual void popAnchorPoint()
+        {
+            _anchors_sp--;
+        }
+
+        /// <exception cref="System.ArgumentNullException" />
+        /// <exception cref="System.OverflowException" />
+        public virtual int getIndentationWidth()
+        {
+            return _indents.Sum( s => s.Length );
+        }
+
+        /// <summary>Write out a string literal or attribute expression or expression element.</summary>
+        /// <exception cref="System.ObjectDisposedException" />
+        /// <exception cref="System.IO.IOException" />
+        public virtual int write( string str )
+        {
+            int n = 0;
+            for ( int i = 0; i < str.Length; i++ )
+            {
+                char c = str[i];
+                // found \n or \r\n newline?
+                if ( c == '\r' || c == '\n' )
+                {
+                    _atStartOfLine = true;
+                    n += _newline.Length; // wrote n more char
+                    _writer.Write( _newline );
+                    _charPosition = 0;
+                    // skip an extra char upon \r\n
+                    if ( ( c == '\r' && ( i + 1 ) < str.Length && str[i+1] == '\n' ) )
+                    {
+                        i++; // loop iteration i++ takes care of skipping 2nd char
+                    }
+                    continue;
+                }
+                // normal character
+                // check to see if we are at the start of a line; need indent if so
+                if ( _atStartOfLine )
+                {
+                    n += indent();
+                    _atStartOfLine = false;
+                }
+                n++;
+                _writer.Write( c );
+                _charPosition++;
+            }
+            return n;
+        }
+
+        /// <exception cref="System.ObjectDisposedException" />
+        /// <exception cref="System.IO.IOException" />
+        public virtual int writeSeparator( string str )
+        {
+            return write( str );
+        }
+
+        /** <summary>Write out a string literal or attribute expression or expression element.</summary>
+         *
+         *  <remarks>
+         *  If doing line wrap, then check wrap before emitting this str.  If
+         *  at or beyond desired line width then emit a \n and any indentation
+         *  before spitting out this str.
+         *  </remarks>
+         *
+         *  <exception cref="System.ArgumentNullException" />
+         *  <exception cref="System.ObjectDisposedException" />
+         *  <exception cref="System.OverflowException" />
+         *  <exception cref="System.IO.IOException" />
+         */
+        public virtual int write( string str, string wrap )
+        {
+            int n = writeWrapSeparator( wrap );
+            return n + write( str );
+        }
+
+        /// <exception cref="System.ArgumentNullException" />
+        /// <exception cref="System.ObjectDisposedException" />
+        /// <exception cref="System.OverflowException" />
+        /// <exception cref="System.IO.IOException" />
+        public virtual int writeWrapSeparator( string wrap )
+        {
+            int n = 0;
+            // if want wrap and not already at start of line (last char was \n)
+            // and we have hit or exceeded the threshold
+            if ( _lineWidth != NO_WRAP && wrap != null && !_atStartOfLine &&
+                 _charPosition >= _lineWidth )
+            {
+                // ok to wrap
+                // Walk wrap string and look for A\nB.  Spit out A\n
+                // then spit indent or anchor, whichever is larger
+                // then spit out B.
+                for ( int i = 0; i < wrap.Length; i++ )
+                {
+                    char c = wrap[i];
+                    if ( c == '\r' || c == '\n' )
+                    {
+                        n += _newline.Length;
+                        _writer.Write( _newline );
+                        _charPosition = 0;
+                        n += indent();
+
+                        // handle \r\n in the wrap string
+                        if ( (c == '\r') && (i < wrap.Length - 1) && (wrap[i + 1] == '\n') )
+                            i++;
+
+                        // continue writing any chars out
+                    }
+                    else
+                    {  // write A or B part
+                        n++;
+                        _writer.Write( c );
+                        _charPosition++;
+                    }
+                }
+            }
+            return n;
+        }
+
+        /// <exception cref="System.ObjectDisposedException" />
+        /// <exception cref="System.IO.IOException" />
+        public virtual int indent()
+        {
+            int n = 0;
+            for ( int i = 0; i < _indents.Count; i++ )
+            {
+                string ind = _indents[i];
+                if ( ind != null )
+                {
+                    n += ind.Length;
+                    _writer.Write( ind );
+                }
+            }
+            _charPosition += n;
+            return n;
+        }
+
+        /// <exception cref="System.ArgumentException" />
+        /// <exception cref="System.ObjectDisposedException" />
+        /// <exception cref="System.IO.IOException" />
+        public virtual int indent( int spaces )
+        {
+            if ( spaces < 0 )
+                throw new ArgumentException( "spaces cannot be negative", "spaces" );
+
+            _writer.Write( new string( ' ', spaces ) );
+            _charPosition += spaces;
+            return spaces;
+        }
+
+        protected virtual StringBuilder getIndentString( int spaces )
+        {
+            return new StringBuilder( new string( ' ', spaces ) );
+        }
+    }
+}
diff --git a/Antlr3.StringTemplate/CommonGroupLoader.cs b/Antlr3.StringTemplate/CommonGroupLoader.cs
new file mode 100644
index 0000000..92c5520
--- /dev/null
+++ b/Antlr3.StringTemplate/CommonGroupLoader.cs
@@ -0,0 +1,113 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2003-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST
+{
+    using System;
+    using System.Linq;
+
+    using TextReader = System.IO.TextReader;
+
+    /** <summary>
+     *  A simple loader that looks only in the directory(ies) you
+     *  specify in the ctor, but it uses the classpath rather than
+     *  absolute dirs so it can be used when the ST application is jar'd up.
+     *  You may specify the char encoding.
+     *  </summary>
+     */
+    public class CommonGroupLoader : PathGroupLoader
+    {
+
+        public CommonGroupLoader( IStringTemplateErrorListener errors )
+            : base( errors )
+        {
+        }
+
+        /** <summary>
+         *  Pass a single dir or multiple dirs separated by colons from which
+         *  to load groups/interfaces.  These are interpreted as relative
+         *  paths to be used with CLASSPATH to locate groups.  E.g.,
+         *  If you pass in "org/antlr/codegen/templates" and ask to load
+         *  group "foo" it will try to load via classpath as
+         *  "org/antlr/codegen/templates/foo".
+         *  </summary>
+         */
+        public CommonGroupLoader( string dirStr, IStringTemplateErrorListener errors )
+            : base( dirStr, errors )
+        {
+        }
+
+        /** <summary>
+         *  Look in each relative directory for the file called 'name'.
+         *  </summary>
+         */
+        protected override TextReader locate( string name )
+        {
+            // check for templates on disk first
+            foreach ( string dir in _dirs )
+            {
+                string fileName = System.IO.Path.Combine( dir, name );
+                if ( System.IO.File.Exists( fileName ) )
+                    return new System.IO.StreamReader( fileName );
+            }
+
+            var assemblies = ( from frame in ( new System.Diagnostics.StackTrace().GetFrames() )
+                               select frame.GetMethod().DeclaringType.Assembly )
+                             .Distinct();
+
+            for ( int i = 0; i < _dirs.Length; i++ )
+            {
+                string dir = _dirs[i];
+                string fileName = dir + "." + name;
+
+                System.IO.Stream @is =
+                    assemblies
+                    .Select( assembly => assembly.GetManifestResourceStream( fileName ) )
+                    .Where( stream => stream != null )
+                    .FirstOrDefault();
+
+                if ( @is == null )
+                {
+                    @is = GetType().Assembly.GetManifestResourceStream( fileName );
+                }
+
+                if ( @is != null )
+                {
+                    return new System.IO.StreamReader( new System.IO.BufferedStream( @is ) );
+                }
+            }
+
+            return null;
+        }
+
+    }
+}
diff --git a/Antlr3.StringTemplate/JavaExtensions/AntlrJavaExtensions.cs b/Antlr3.StringTemplate/JavaExtensions/AntlrJavaExtensions.cs
new file mode 100644
index 0000000..c73d46e
--- /dev/null
+++ b/Antlr3.StringTemplate/JavaExtensions/AntlrJavaExtensions.cs
@@ -0,0 +1,146 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2003-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Collections.Generic;
+
+using ITree = Antlr.Runtime.Tree.ITree;
+
+namespace Antlr.Runtime.JavaExtensions
+{
+    public static class AntlrJavaExtensions
+    {
+        /** Walk the tree looking for all subtrees.  Return
+         *  an enumeration that lets the caller walk the list
+         *  of subtree roots found herein.
+         */
+        public static IEnumerable<ITree> findAllPartial( this ITree tree, ITree node )
+        {
+            return DoWorkForFindAll( tree, node, true );
+        }
+
+        #region Helper functions
+
+        private static bool equals( this ITree tree, ITree target )
+        {
+            if ( tree == null || target == null )
+                return false;
+
+            string treeText = tree.Text;
+            string targetText = target.Text;
+
+            if ( ( treeText == null ) != ( targetText == null ) )
+                return false;
+
+            if ( treeText == null )
+                return tree.Type == target.Type;
+
+            return ( treeText == targetText ) && ( tree.Type == target.Type );
+        }
+
+        private static bool equalsTree( this ITree tree, ITree target )
+        {
+            // if either tree is nil, then they are equal only if both are nil
+            bool treeNil = ( ( tree == null ) || ( tree.IsNil && tree.ChildCount == 0 ) );
+            bool targetNil = ( ( target == null ) || ( target.IsNil && target.ChildCount == 0 ) );
+            if ( treeNil || targetNil )
+                return ( treeNil == targetNil );
+
+            if ( tree.ChildCount != target.ChildCount )
+                return false;
+
+            // check roots first
+            if ( !tree.equals( target ) )
+                return false;
+
+            // if roots match, do a full list match on children.
+            // we know tree and target have the same ChildCount.
+            int childCount = tree.ChildCount;
+            for ( int i = 0; i < childCount; i++ )
+            {
+                if ( !tree.GetChild( i ).equalsTree( target.GetChild( i ) ) )
+                {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+
+        private static bool equalsTreePartial( this ITree tree, ITree target )
+        {
+            // an empty tree is always a subset of any tree
+            if ( target == null || target.IsNil )
+                return true;
+
+            if ( target.ChildCount > tree.ChildCount )
+                return false;
+
+            // check roots first
+            if ( !tree.equals( target ) )
+                return false;
+
+            // if roots match, do a full list partial test on children
+            int childCount = Math.Min( tree.ChildCount, target.ChildCount );
+            for ( int i = 0; i < childCount; i++ )
+            {
+                if ( !tree.GetChild( i ).equalsTreePartial( target.GetChild( i ) ) )
+                {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+
+        private static IEnumerable<ITree> DoWorkForFindAll( ITree nodeToSearch, ITree target, bool partialMatch )
+        {
+            if ( ( partialMatch && nodeToSearch.equalsTreePartial( target ) )
+                || ( !partialMatch && nodeToSearch.equalsTree( target ) ) )
+            {
+                yield return nodeToSearch;
+            }
+
+            for ( int i = 0; i < nodeToSearch.ChildCount; i++ )
+            {
+                ITree child = nodeToSearch.GetChild( i );
+                if ( child != null )
+                {
+                    foreach ( ITree tree in DoWorkForFindAll( child, target, partialMatch ) )
+                        yield return tree;
+                }
+            }
+        }
+
+        #endregion
+    }
+}
diff --git a/Antlr3.StringTemplate/JavaExtensions/DictionaryExtensions.cs b/Antlr3.StringTemplate/JavaExtensions/DictionaryExtensions.cs
new file mode 100644
index 0000000..7f7185b
--- /dev/null
+++ b/Antlr3.StringTemplate/JavaExtensions/DictionaryExtensions.cs
@@ -0,0 +1,57 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr.Runtime.JavaExtensions
+{
+    using System;
+    using System.Collections.Generic;
+    using System.Linq;
+
+    using IDictionary = System.Collections.IDictionary;
+    using IList = System.Collections.IList;
+
+    public static class DictionaryExtensions
+    {
+        public static string ToElementString<TKey, TValue>( this IDictionary<TKey, TValue> map )
+        {
+            return "{" + string.Join( ", ", map.Select( i => i.Key.ToString() + "=" + ToElementStringHelper( i.Value ) ).ToArray() ) + "}";
+        }
+
+        static string ToElementStringHelper( object o )
+        {
+            if ( o is IList )
+                return ( (IList)o ).ToElementString();
+
+            return o.ToString();
+        }
+    }
+}
diff --git a/Antlr3.StringTemplate/JavaExtensions/ListExtensions.cs b/Antlr3.StringTemplate/JavaExtensions/ListExtensions.cs
new file mode 100644
index 0000000..b2dbecc
--- /dev/null
+++ b/Antlr3.StringTemplate/JavaExtensions/ListExtensions.cs
@@ -0,0 +1,46 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr.Runtime.JavaExtensions
+{
+    using System.Linq;
+
+    using IList = System.Collections.IList;
+
+    public static class ListExtensions
+    {
+        public static string ToElementString( this IList list )
+        {
+            return "[" + string.Join( ", ", list.Cast<object>().Select( o => o.ToString() ).ToArray() ) + "]";
+        }
+    }
+}
diff --git a/Antlr3.StringTemplate/Language/ASTExpr.cs b/Antlr3.StringTemplate/Language/ASTExpr.cs
new file mode 100644
index 0000000..25f9156
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/ASTExpr.cs
@@ -0,0 +1,1335 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2003-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST.Language
+{
+    using System;
+    using System.Collections.Generic;
+    using System.Linq;
+    using Antlr.Runtime.JavaExtensions;
+
+    using FieldInfo = System.Reflection.FieldInfo;
+    using ICollection = System.Collections.ICollection;
+    using IDictionary = System.Collections.IDictionary;
+    using IList = System.Collections.IList;
+    using InvalidOperationException = System.InvalidOperationException;
+    using IOException = System.IO.IOException;
+    using ITree = Antlr.Runtime.Tree.ITree;
+    using MethodInfo = System.Reflection.MethodInfo;
+    using RecognitionException = Antlr.Runtime.RecognitionException;
+    using StringWriter = System.IO.StringWriter;
+
+    /** <summary>
+     *  A single string template expression enclosed in $...; separator=...$
+     *  parsed into an AST chunk to be evaluated.
+     *  </summary>
+     */
+    public class ASTExpr : Expr
+    {
+        public const string DEFAULT_ATTRIBUTE_NAME = "it";
+        public const string DEFAULT_ATTRIBUTE_NAME_DEPRECATED = "attr";
+        public const string DEFAULT_INDEX_VARIABLE_NAME = "i";
+        public const string DEFAULT_INDEX0_VARIABLE_NAME = "i0";
+        public const string DEFAULT_MAP_VALUE_NAME = "_default_";
+        public const string DEFAULT_MAP_KEY_NAME = "key";
+
+        /** <summary>Used to indicate "default:key" in maps within groups</summary> */
+        public static readonly StringTemplate MAP_KEY_VALUE = new StringTemplate();
+
+        /** <summary>
+         *  Using an expr option w/o value, makes options table hold EMPTY_OPTION
+         *  value for that key.
+         *  </summary>
+         */
+        public const string EMPTY_OPTION = "empty expr option";
+
+        public static readonly IDictionary<string, StringTemplateAST> defaultOptionValues =
+            new Dictionary<string, StringTemplateAST>()
+            {
+                { "anchor", new StringTemplateAST( ActionEvaluator.STRING, "true" ) },
+                { "wrap", new StringTemplateAST( ActionEvaluator.STRING, Environment.NewLine ) },
+            };
+
+        /** <summary>John Snyders gave me an example implementation for this checking</summary> */
+        public static readonly HashSet<string> supportedOptions =
+            new HashSet<string>()
+            {
+                "anchor",
+                "format",
+                "null",
+                "separator",
+                "wrap"
+            };
+
+        protected internal ITree exprTree = null;
+
+        /** <summary>store separator etc...</summary> */
+        IDictionary<string, object> options = null;
+
+        /** <summary>
+         *  A cached value of wrap=expr from the &lt;...> expression.
+         *  Computed in write(StringTemplate, StringTemplateWriter) and used
+         *  in writeAttribute.
+         *  </summary>
+         */
+        string wrapString = null;
+
+        /** <summary>
+         *  For null values in iterated attributes and single attributes that
+         *  are null, use this value instead of skipping.  For single valued
+         *  attributes like &lt;name; null="n/a"> it's a shorthand for
+         *  &lt;if(name)>&lt;name>&lt;else>n/a&lt;endif>
+         *  For iterated values &lt;values; null="0", separator=",">, you get 0 for
+         *  for null list values.  Works for template application like:
+         *  &lt;values:{v| &lt;v>}; null="0"> also.
+         *  </summary>
+         */
+        string nullValue = null;
+
+        /** <summary>
+         *  A cached value of separator=expr from the &lt;...> expression.
+         *  Computed in write(StringTemplate, StringTemplateWriter) and used
+         *  in writeAttribute.
+         *  </summary>
+         */
+        string separatorString = null;
+
+        /** <summary>A cached value of option format=expr</summary> */
+        string formatString = null;
+
+        public ASTExpr( StringTemplate enclosingTemplate, ITree exprTree, IDictionary<string, object> options ) :
+            base( enclosingTemplate )
+        {
+            this.exprTree = exprTree;
+            this.options = options;
+        }
+
+        #region Properties
+        /** <summary>Return the tree interpreted when this template is written out.</summary> */
+        public virtual ITree AST
+        {
+            get
+            {
+                return exprTree;
+            }
+        }
+        #endregion
+
+        /** <summary>
+         *  To write out the value of an ASTExpr, invoke the evaluator in eval.g
+         *  to walk the tree writing out the values.  For efficiency, don't
+         *  compute a bunch of strings and then pack them together.  Write out directly.
+         *  </summary>
+         *
+         *  <remarks>
+         *  Compute separator and wrap expressions, save as strings so we don't
+         *  recompute for each value in a multi-valued attribute or expression.
+         *
+         *  If they set anchor option, then inform the writer to push current
+         *  char position.
+         *  </remarks>
+         */
+        public override int write( StringTemplate self, IStringTemplateWriter @out )
+        {
+            if ( exprTree == null || self == null || @out == null )
+            {
+                return 0;
+            }
+            // handle options, anchor, wrap, separator...
+            StringTemplateAST anchorAST = (StringTemplateAST)getOption( "anchor" );
+            if ( anchorAST != null )
+            { // any non-empty expr means true; check presence
+                @out.pushAnchorPoint();
+            }
+            @out.pushIndentation( getIndentation() );
+            handleExprOptions( self );
+            //System.out.println("evaluating tree: "+exprTree.toStringList());
+            ActionEvaluator eval =
+                    new ActionEvaluator( self, this, @out, exprTree );
+            int n = 0;
+            try
+            {
+                n = eval.action();
+                //n = eval.action( exprTree ); // eval and write out tree
+            }
+            catch ( RecognitionException re )
+            {
+                self.error( "can't evaluate tree: " + exprTree.ToStringTree(), re );
+            }
+            @out.popIndentation();
+            if ( anchorAST != null )
+            {
+                @out.popAnchorPoint();
+            }
+            return n;
+        }
+
+        /** <summary>Grab and cache options; verify options are valid</summary> */
+        protected virtual void handleExprOptions( StringTemplate self )
+        {
+            // make sure options don't use format / renderer.  They are usually
+            // strings which might invoke a string renderer etc...
+            formatString = null;
+            StringTemplateAST wrapAST = (StringTemplateAST)getOption( "wrap" );
+            if ( wrapAST != null )
+            {
+                wrapString = evaluateExpression( self, wrapAST );
+            }
+            StringTemplateAST nullValueAST = (StringTemplateAST)getOption( "null" );
+            if ( nullValueAST != null )
+            {
+                nullValue = evaluateExpression( self, nullValueAST );
+            }
+            StringTemplateAST separatorAST = (StringTemplateAST)getOption( "separator" );
+            if ( separatorAST != null )
+            {
+                separatorString = evaluateExpression( self, separatorAST );
+            }
+            // following addition inspired by John Snyders
+            StringTemplateAST formatAST =
+                (StringTemplateAST)getOption( "format" );
+            if ( formatAST != null )
+            {
+                formatString = evaluateExpression( self, formatAST );
+            }
+
+            // Check that option is valid
+            if ( options != null )
+            {
+                foreach ( string option in options.Keys )
+                {
+                    if ( !supportedOptions.Contains( option ) )
+                        self.warning( "ignoring unsupported option: " + option );
+                }
+            }
+        }
+
+        #region Help routines called by the tree walker
+
+        /** <summary>
+         *  For &lt;names,phones:{n,p | ...}> treat the names, phones as lists
+         *  to be walked in lock step as n=names[i], p=phones[i].
+         *  </summary>
+         */
+        public virtual object applyTemplateToListOfAttributes( StringTemplate self,
+                                                      IList attributes,
+                                                      StringTemplate templateToApply )
+        {
+            if ( attributes == null || templateToApply == null || attributes.Count == 0 )
+            {
+                return null; // do not apply if missing templates or empty values
+            }
+            Dictionary<string, object> argumentContext = null;
+            // indicate it's an ST-created list
+            IList results = new StringTemplate.STAttributeList();
+
+            // convert all attributes to iterators even if just one value
+            for ( int a = 0; a < attributes.Count; a++ )
+            {
+                object o = attributes[a];
+                if ( o != null )
+                {
+                    o = convertAnythingToIterator( o );
+                    attributes[a] = o; // alter the list in place
+                }
+            }
+
+            int numAttributes = attributes.Count;
+
+            // ensure arguments line up
+            var formalArguments = templateToApply.getFormalArguments();
+            if ( formalArguments == null || formalArguments.Count == 0 )
+            {
+                self.error( "missing arguments in anonymous" +
+                           " template in context " + self.getEnclosingInstanceStackString() );
+                return null;
+            }
+            string[] formalArgumentNames = formalArguments.Select( fa => fa.name ).ToArray();
+            if ( formalArgumentNames.Length != numAttributes )
+            {
+                string formalArgumentsText = formalArguments.Select( fa => fa.name ).ToList().ToElementString();
+                self.error( "number of arguments " + formalArgumentsText +
+                           " mismatch between attribute list and anonymous" +
+                           " template in context " + self.getEnclosingInstanceStackString() );
+                // truncate arg list to match smaller size
+                int shorterSize = Math.Min( formalArgumentNames.Length, numAttributes );
+                numAttributes = shorterSize;
+                string[] newFormalArgumentNames = new string[shorterSize];
+                Array.Copy( formalArgumentNames, 0,
+                                 newFormalArgumentNames, 0,
+                                 shorterSize );
+                formalArgumentNames = newFormalArgumentNames;
+            }
+
+            // keep walking while at least one attribute has values
+            int i = 0; // iteration number from 0
+            for ( ; ; )
+            {
+                argumentContext = new Dictionary<string, object>();
+                // get a value for each attribute in list; put into arg context
+                // to simulate template invocation of anonymous template
+                int numEmpty = 0;
+                for ( int a = 0; a < numAttributes; a++ )
+                {
+                    Iterator it = (Iterator)attributes[a];
+                    if ( it != null && it.hasNext() )
+                    {
+                        string argName = (string)formalArgumentNames[a];
+                        object iteratedValue = it.next();
+                        argumentContext[argName] = iteratedValue;
+                    }
+                    else
+                    {
+                        numEmpty++;
+                    }
+                }
+                if ( numEmpty == numAttributes )
+                {
+                    break;
+                }
+                argumentContext[DEFAULT_INDEX_VARIABLE_NAME] = i + 1;
+                argumentContext[DEFAULT_INDEX0_VARIABLE_NAME] = i;
+                StringTemplate embedded = templateToApply.getInstanceOf();
+                embedded.setEnclosingInstance( self );
+                embedded.setArgumentContext( argumentContext );
+                results.Add( embedded );
+                i++;
+            }
+
+            return results;
+        }
+
+        public virtual object applyListOfAlternatingTemplates( StringTemplate self,
+                                                      object attributeValue,
+                                                      IList<StringTemplate> templatesToApply )
+        {
+            if ( attributeValue == null || templatesToApply == null || templatesToApply.Count == 0 )
+            {
+                return null; // do not apply if missing templates or empty value
+            }
+            StringTemplate embedded = null;
+            Dictionary<string, object> argumentContext = null;
+
+            // normalize collections and such to use iterators
+            // anything iteratable can be used for "APPLY"
+            attributeValue = convertArrayToList( attributeValue );
+            attributeValue = convertAnythingIteratableToIterator( attributeValue );
+
+            if ( attributeValue is Iterator )
+            {
+                // results can be treated list an attribute, indicate ST created list
+                IList resultVector = new StringTemplate.STAttributeList();
+                Iterator iter = (Iterator)attributeValue;
+                int i = 0;
+                while ( iter.hasNext() )
+                {
+                    object ithValue = iter.next();
+                    if ( ithValue == null )
+                    {
+                        if ( nullValue == null )
+                        {
+                            continue;
+                        }
+                        ithValue = nullValue;
+                    }
+                    int templateIndex = i % templatesToApply.Count; // rotate through
+                    embedded = (StringTemplate)templatesToApply[templateIndex];
+                    // template to apply is an actual StringTemplate (created in
+                    // eval.g), but that is used as the examplar.  We must create
+                    // a new instance of the embedded template to apply each time
+                    // to get new attribute sets etc...
+                    StringTemplateAST args = embedded.getArgumentsAST();
+                    embedded = embedded.getInstanceOf(); // make new instance
+                    embedded.setEnclosingInstance( self );
+                    embedded.setArgumentsAST( args );
+                    argumentContext = new Dictionary<string, object>();
+                    var formalArgs = embedded.getFormalArguments();
+                    bool isAnonymous =
+                        embedded.getName() == StringTemplate.ANONYMOUS_ST_NAME;
+                    setSoleFormalArgumentToIthValue( embedded, argumentContext, ithValue );
+                    // if it's an anonymous template with a formal arg, don't set it/attr
+                    if ( !( isAnonymous && formalArgs != null && formalArgs.Count > 0 ) )
+                    {
+                        argumentContext[DEFAULT_ATTRIBUTE_NAME] = ithValue;
+                        argumentContext[DEFAULT_ATTRIBUTE_NAME_DEPRECATED] = ithValue;
+                    }
+                    argumentContext[DEFAULT_INDEX_VARIABLE_NAME] = i + 1;
+                    argumentContext[DEFAULT_INDEX0_VARIABLE_NAME] = i;
+                    embedded.setArgumentContext( argumentContext );
+                    evaluateArguments( embedded );
+                    /*
+                    System.err.println("i="+i+": applyTemplate("+embedded.getName()+
+                            ", args="+argumentContext+
+                            " to attribute value "+ithValue);
+                    */
+                    resultVector.Add( embedded );
+                    i++;
+                }
+                if ( resultVector.Count == 0 )
+                {
+                    resultVector = null;
+                }
+                return resultVector;
+            }
+            else
+            {
+                /*
+                System.out.println("setting attribute "+DEFAULT_ATTRIBUTE_NAME+" in arg context of "+
+                embedded.getName()+
+                " to "+attributeValue);
+                */
+                embedded = (StringTemplate)templatesToApply[0];
+                argumentContext = new Dictionary<string, object>();
+                var formalArgs = embedded.getFormalArguments();
+                StringTemplateAST args = embedded.getArgumentsAST();
+                setSoleFormalArgumentToIthValue( embedded, argumentContext, attributeValue );
+                bool isAnonymous =
+                    embedded.getName() == StringTemplate.ANONYMOUS_ST_NAME;
+                // if it's an anonymous template with a formal arg, don't set it/attr
+                if ( !( isAnonymous && formalArgs != null && formalArgs.Count > 0 ) )
+                {
+                    argumentContext[DEFAULT_ATTRIBUTE_NAME] = attributeValue;
+                    argumentContext[DEFAULT_ATTRIBUTE_NAME_DEPRECATED] = attributeValue;
+                }
+                argumentContext[DEFAULT_INDEX_VARIABLE_NAME] = 1;
+                argumentContext[DEFAULT_INDEX0_VARIABLE_NAME] = 0;
+                embedded.setArgumentContext( argumentContext );
+                evaluateArguments( embedded );
+                return embedded;
+            }
+        }
+
+        protected virtual void setSoleFormalArgumentToIthValue( StringTemplate embedded, IDictionary argumentContext, object ithValue )
+        {
+            var formalArgs = embedded.getFormalArguments();
+            if ( formalArgs != null )
+            {
+                string soleArgName = null;
+                bool isAnonymous =
+                    embedded.getName() == StringTemplate.ANONYMOUS_ST_NAME;
+                if ( formalArgs.Count == 1 || ( isAnonymous && formalArgs.Count > 0 ) )
+                {
+                    if ( isAnonymous && formalArgs.Count > 1 )
+                    {
+                        embedded.error( "too many arguments on {...} template: " + formalArgs );
+                    }
+                    // if exactly 1 arg or anonymous, give that the value of
+                    // "it" as a convenience like they said
+                    // $list:template(arg=it)$
+                    var argNames = formalArgs.Select( fa => fa.name );
+                    soleArgName = (string)argNames.ToArray()[0];
+                    argumentContext[soleArgName] = ithValue;
+                }
+            }
+        }
+
+        /** <summary>Return o.getPropertyName() given o and propertyName.  If o is
+         *  a stringtemplate then access it's attributes looking for propertyName
+         *  instead (don't check any of the enclosing scopes; look directly into
+         *  that object).  Also try isXXX() for booleans.  Allow Map
+         *  as special case (grab value for key).
+         *  </summary>
+         *
+         *  <remarks>
+         *  Cache repeated requests for obj.prop within same group.
+         *  </remarks>
+         */
+        public virtual object getObjectProperty( StringTemplate self,
+                                        object o,
+                                        object propertyName )
+        {
+            if ( o == null )
+                return null;
+
+            if ( propertyName == null )
+            {
+                if ( o is IDictionary && ( (IDictionary)o ).Contains( DEFAULT_MAP_VALUE_NAME ) )
+                    propertyName = DEFAULT_MAP_VALUE_NAME;
+                else
+                    return null;
+            }
+
+            /*
+            // see if property is cached in group's cache
+            Object cachedValue =
+                self.getGroup().getCachedObjectProperty(o,propertyName);
+            if ( cachedValue!=null ) {
+                return cachedValue;
+            }
+            Object value = rawGetObjectProperty(self, o, propertyName);
+            // take care of array properties...convert to a List so we can
+            // apply templates to the elements etc...
+            value = convertArrayToList(value);
+            self.getGroup().cacheObjectProperty(o,propertyName,value);
+            */
+            object value = rawGetObjectProperty( self, o, propertyName );
+            // take care of array properties...convert to a List so we can
+            // apply templates to the elements etc...
+            value = convertArrayToList( value );
+            return value;
+        }
+
+        protected virtual object rawGetObjectProperty( StringTemplate self, object o, object property )
+        {
+            Type c = o.GetType();
+            object value = null;
+
+            // Special case: our automatically created Aggregates via
+            // attribute name: "{obj.{prop1,prop2}}"
+            if ( c == typeof( StringTemplate.Aggregate ) )
+            {
+                string propertyName2 = (string)property;
+                value = ( (StringTemplate.Aggregate)o ).get( (string)propertyName2 );
+                return value;
+            }
+
+            // Special case: if it's a template, pull property from
+            // it's attribute table.
+            // TODO: TJP just asked himself why we can't do inherited attr here?
+            else if ( c == typeof( StringTemplate ) )
+            {
+                var attributes = ( (StringTemplate)o ).getAttributes();
+                if ( attributes != null )
+                {
+                    string propertyName2 = (string)property;
+                    value = attributes.get( propertyName2 );
+                    return value;
+                }
+            }
+
+            // Special case: if it's a Map then pull using
+            // key not the property method.
+            if ( o is IDictionary )
+            {
+                IDictionary map = (IDictionary)o;
+                if ( property.Equals( "keys" ) )
+                {
+                    value = map.Keys;
+                }
+                else if ( property.Equals( "values" ) )
+                {
+                    value = map.Values;
+                }
+                else if ( map.Contains( property ) )
+                {
+                    value = map[property];
+                }
+                else if ( map.Contains( property.ToString() ) )
+                {
+                    // if we can't find the key, toString it
+                    value = map[property.ToString()];
+                }
+                else
+                {
+                    if ( map.Contains( DEFAULT_MAP_VALUE_NAME ) )
+                    {
+                        value = map[DEFAULT_MAP_VALUE_NAME];
+                    }
+                }
+                if ( value == MAP_KEY_VALUE )
+                {
+                    value = property;
+                }
+                return value;
+            }
+
+            // try getXXX and isXXX properties
+
+            // check cache
+            MethodInfo m = null;
+            /*
+            Member cachedMember =
+                self.getGroup().getCachedClassProperty(c,propertyName);
+            if ( cachedMember!=null ) {
+                try {
+                    if ( cachedMember is Method ) {
+                        m = (Method)cachedMember;
+                        value = invokeMethod(m, o, value);
+                    }
+                    else {
+                        // must be a field
+                        Field f = (Field)cachedMember;
+                        value = accessField(f, o, value);
+                    }
+                }
+                catch (Exception e) {
+                    self.error("Can't get property "+propertyName+
+                        " from "+c.getName()+" instance", e);
+                }
+                return value;
+            }
+            */
+
+            // must look up using reflection
+            string propertyName = (string)property;
+            string methodSuffix = Char.ToUpperInvariant( propertyName[0] ) +
+                propertyName.Substring( 1 );
+            m = getMethod( c, "get" + methodSuffix );
+            if ( m == null )
+            {
+                m = getMethod( c, "is" + methodSuffix );
+            }
+            // BEGIN ADDED FOR C#
+            if ( m == null )
+            {
+                System.Reflection.PropertyInfo p = c.GetProperty( methodSuffix );
+                if ( p != null )
+                    m = p.GetGetMethod();
+            }
+            if ( m == null )
+            {
+                m = getMethod( c, "Get" + methodSuffix );
+            }
+            if ( m == null )
+            {
+                m = getMethod( c, "Is" + methodSuffix );
+            }
+            // END ADDED
+            if ( m != null )
+            {
+                // save to avoid lookup later
+                //self.getGroup().cacheClassProperty(c,propertyName,m);
+                try
+                {
+                    value = invokeMethod( m, o, value );
+                }
+                catch ( Exception e )
+                {
+                    self.error( "Can't get property " + propertyName + " using method get/is" + methodSuffix +
+                        " from " + c.Name + " instance", e );
+                }
+            }
+            else
+            {
+                // try for a visible field
+                FieldInfo f = c.GetField( propertyName );
+                if ( f != null )
+                {
+                    //self.getGroup().cacheClassProperty(c,propertyName,f);
+                    try
+                    {
+                        value = accessField( f, o, value );
+                    }
+                    catch ( FieldAccessException iae )
+                    {
+                        self.error( "Can't access property " + propertyName + " using method get/is" + methodSuffix +
+                            " or direct field access from " + c.Name + " instance", iae );
+                    }
+                }
+                else
+                {
+                    self.error( "Class " + c.Name + " has no such attribute: " + propertyName +
+                        " in template context " + self.getEnclosingInstanceStackString(), null );
+                }
+            }
+
+            return value;
+        }
+
+        protected virtual object accessField( FieldInfo f, object o, object value )
+        {
+#if false
+            try
+            {
+                // make sure it's accessible (stupid java)
+                f.setAccessible( true );
+            }
+            catch ( SecurityException se )
+            {
+                ; // oh well; security won't let us
+            }
+#endif
+            value = f.GetValue( o );
+            return value;
+        }
+
+        protected virtual object invokeMethod( MethodInfo m, object o, object value )
+        {
+#if false
+            try
+            {
+                // make sure it's accessible (stupid java)
+                m.setAccessible( true );
+            }
+            catch ( SecurityException se )
+            {
+                ; // oh well; security won't let us
+            }
+#endif
+            value = m.Invoke( o, null );
+            return value;
+        }
+
+        protected virtual MethodInfo getMethod( Type c, string methodName )
+        {
+            // we want a getter method
+            return c.GetMethod( methodName, new Type[0] );
+        }
+
+        /** <summary>
+         *  Normally StringTemplate tests presence or absence of attributes
+         *  for adherence to my principles of separation, but some people
+         *  disagree and want to change.
+         *  </summary>
+         *
+         *  <remarks>
+         *  For 2.0, if the object is a boolean, do something special. $if(boolean)$
+         *  will actually test the value.  Now, this breaks my rules of entanglement
+         *  listed in my paper, but it truly surprises programmers to have booleans
+         *  always true.  Further, the key to isolating logic in the model is avoiding
+         *  operators (for which you need attribute values).  But, no operator is
+         *  needed to use boolean values.  Well, actually I guess "!" (not) is
+         *  an operator.  Regardless, for practical reasons, I'm going to technically
+         *  violate my rules as I currently have them defined.  Perhaps for a future
+         *  version of the paper I will refine the rules.
+         *
+         *  Post 2.1, I added a check for non-null Iterators, Collections, ...
+         *  with size==0 to return false. TJP 5/1/2005
+         *  </remarks>
+         */
+        public virtual bool testAttributeTrue( object a )
+        {
+            if ( a == null )
+            {
+                return false;
+            }
+            if ( a is Boolean )
+            {
+                return (bool)a;
+            }
+            if ( a is ICollection )
+            {
+                return ( (ICollection)a ).Count > 0;
+            }
+            if ( a is IDictionary )
+            {
+                return ( (IDictionary)a ).Count > 0;
+            }
+            if ( a is Iterator )
+            {
+                return ( (Iterator)a ).hasNext();
+            }
+            return true; // any other non-null object, return true--it's present
+        }
+
+        /** <summary>
+         *  For now, we can only add two objects as strings; convert objects to
+         *  Strings then cat.
+         *  </summary>
+         */
+        public object add( object a, object b )
+        {
+            return Add( a, b );
+        }
+        public virtual object Add( object a, object b )
+        {
+            if ( a == null )
+            { // a null value means don't do cat, just return other value
+                return b;
+            }
+            else if ( b == null )
+            {
+                return a;
+            }
+            return a.ToString() + b.ToString();
+        }
+
+        /** <summary>
+         *  Call a string template with args and return result.  Do not convert
+         *  to a string yet.  It may need attributes that will be available after
+         *  this is inserted into another template.
+         *  </summary>
+         */
+        public virtual StringTemplate getTemplateInclude( StringTemplate enclosing,
+                                                 string templateName,
+                                                 StringTemplateAST argumentsAST )
+        {
+            //System.out.println("getTemplateInclude: look up "+enclosing.getGroup().getName()+"::"+templateName);
+            StringTemplateGroup group = enclosing.getGroup();
+            StringTemplate embedded = group.getEmbeddedInstanceOf( enclosing, templateName );
+            if ( embedded == null )
+            {
+                enclosing.error( "cannot make embedded instance of " + templateName +
+                        " in template " + enclosing.getName() );
+                return null;
+            }
+            embedded.setArgumentsAST( argumentsAST );
+            evaluateArguments( embedded );
+            return embedded;
+        }
+
+        /** <summary>
+         *  How to spit out an object.  If it's not a StringTemplate nor a
+         *  List, just do o.toString().  If it's a StringTemplate,
+         *  do o.write(out).  If it's a Vector, do a write(out,
+         *  o.elementAt(i)) for all elements.  Note that if you do
+         *  something weird like set the values of a multivalued tag
+         *  to be vectors, it will effectively flatten it.
+         *  </summary>
+         *
+         *  <remarks>
+         *  If self is an embedded template, you might have specified
+         *  a separator arg; used when is a vector.
+         *  </remarks>
+         */
+        public virtual int writeAttribute( StringTemplate self, object o, IStringTemplateWriter @out )
+        {
+            return write( self, o, @out );
+        }
+
+        /** <summary>Write o relative to self to out.</summary>
+         *
+         *  <remarks>
+         *  John Snyders fixes here for formatString.  Basically, any time
+         *  you are about to write a value, check formatting.
+         *  </remarks>
+         */
+        protected virtual int write( StringTemplate self,
+                            object o,
+                            IStringTemplateWriter @out )
+        {
+            if ( o == null )
+            {
+                if ( nullValue == null )
+                {
+                    return 0;
+                }
+                o = nullValue; // continue with null option if specified
+            }
+            int n = 0;
+            try
+            {
+                if ( o is StringTemplate )
+                {
+                    StringTemplate stToWrite = (StringTemplate)o;
+                    // failsafe: perhaps enclosing instance not set
+                    // Or, it could be set to another context!  This occurs
+                    // when you store a template instance as an attribute of more
+                    // than one template (like both a header file and C file when
+                    // generating C code).  It must execute within the context of
+                    // the enclosing template.
+                    stToWrite.setEnclosingInstance( self );
+                    // if self is found up the enclosing instance chain, then
+                    // infinite recursion
+                    if ( StringTemplate.inLintMode() &&
+                         StringTemplate.isRecursiveEnclosingInstance( stToWrite ) )
+                    {
+                        // throw exception since sometimes eval keeps going
+                        // even after I ignore this write of o.
+                        throw new InvalidOperationException( "infinite recursion to " +
+                                stToWrite.getTemplateDeclaratorString() + " referenced in " +
+                                stToWrite.getEnclosingInstance().getTemplateDeclaratorString() +
+                                "; stack trace:" + Environment.NewLine + stToWrite.getEnclosingInstanceStackTrace() );
+                    }
+                    else
+                    {
+                        // if we have a wrap string, then inform writer it
+                        // might need to wrap
+                        if ( wrapString != null )
+                        {
+                            n = @out.writeWrapSeparator( wrapString );
+                        }
+                        // check if formatting needs to be applied to the stToWrite
+                        if ( formatString != null )
+                        {
+                            IAttributeRenderer renderer =
+                                self.getAttributeRenderer( typeof( string ) );
+                            if ( renderer != null )
+                            {
+                                // you pay a penalty for applying format option to a template
+                                // because the template must be written to a temp StringWriter so it can
+                                // be formatted before being written to the real output.
+                                StringWriter buf = new StringWriter();
+                                IStringTemplateWriter sw =
+                                    self.getGroup().getStringTemplateWriter( buf );
+                                stToWrite.write( sw );
+                                n = @out.write( renderer.ToString( buf.ToString(), formatString ) );
+                                return n;
+                            }
+                        }
+                        n = stToWrite.write( @out );
+                    }
+                    return n;
+                }
+                // normalize anything iteratable to iterator
+                o = convertAnythingIteratableToIterator( o );
+                if ( o is Iterator )
+                {
+                    Iterator iter = (Iterator)o;
+                    bool seenPrevValue = false;
+                    while ( iter.hasNext() )
+                    {
+                        object iterValue = iter.next();
+                        if ( iterValue == null )
+                        {
+                            iterValue = nullValue;
+                        }
+                        if ( iterValue != null )
+                        {
+                            if ( seenPrevValue /*prevIterValue!=null*/
+                                && separatorString != null )
+                            {
+                                n += @out.writeSeparator( separatorString );
+                            }
+                            seenPrevValue = true;
+                            int nw = write( self, iterValue, @out );
+                            n += nw;
+                        }
+                    }
+                }
+                else
+                {
+                    IAttributeRenderer renderer =
+                        self.getAttributeRenderer( o.GetType() );
+                    string v = null;
+                    if ( renderer != null )
+                    {
+                        if ( formatString != null )
+                        {
+                            v = renderer.ToString( o, formatString );
+                        }
+                        else
+                        {
+                            v = renderer.ToString( o );
+                        }
+                    }
+                    else
+                    {
+                        v = o.ToString();
+                    }
+                    if ( wrapString != null )
+                    {
+                        n = @out.write( v, wrapString );
+                    }
+                    else
+                    {
+                        n = @out.write( v );
+                    }
+                    return n;
+                }
+            }
+            catch ( IOException io )
+            {
+                self.error( "problem writing object: " + o, io );
+            }
+            return n;
+        }
+
+        /** <summary>
+         *  A expr is normally just a string literal, but is still an AST that
+         *  we must evaluate.  The expr can be any expression such as a template
+         *  include or string cat expression etc...  Evaluate with its own writer
+         *  so that we can convert to string and then reuse, don't want to compute
+         *  all the time; must precompute w/o writing to output buffer.
+         *  </summary>
+         */
+        protected virtual string evaluateExpression( StringTemplate self,
+                                            object expr )
+        {
+            if ( expr == null )
+            {
+                return null;
+            }
+            if ( expr is StringTemplateAST )
+            {
+                StringTemplateAST exprAST = (StringTemplateAST)expr;
+                // must evaluate, writing to a string so we can hang on to it
+                StringWriter buf = new StringWriter();
+                IStringTemplateWriter sw =
+                    self.getGroup().getStringTemplateWriter( buf );
+                {
+                    ActionEvaluator eval =
+                            new ActionEvaluator( self, this, sw, exprAST );
+                    try
+                    {
+                        eval.action(); // eval tree
+                    }
+                    catch ( RecognitionException re )
+                    {
+                        self.error( "can't evaluate tree: " + exprTree.ToStringTree(), re );
+                    }
+                }
+                return buf.ToString();
+            }
+            else
+            {
+                // just in case we expand in the future and it's something else
+                return expr.ToString();
+            }
+        }
+
+        /** <summary>
+         *  Evaluate an argument list within the context of the enclosing
+         *  template but store the values in the context of self, the
+         *  new embedded template.  For example, bold(item=item) means
+         *  that bold.item should get the value of enclosing.item.
+         *  </summary>
+         */
+        protected virtual void evaluateArguments( StringTemplate self )
+        {
+            StringTemplateAST argumentsAST = self.getArgumentsAST();
+            if ( argumentsAST == null || argumentsAST.GetChild( 0 ) == null )
+            {
+                // return immediately if missing tree or no actual args
+                return;
+            }
+
+            // Evaluate args in the context of the enclosing template, but we
+            // need the predefined args like 'it', 'attr', and 'i' to be
+            // available as well so we put a dummy ST between the enclosing
+            // context and the embedded context.  The dummy has the predefined
+            // context as does the embedded.
+            StringTemplate enclosing = self.getEnclosingInstance();
+            StringTemplate argContextST = new StringTemplate( self.getGroup(), "" );
+            argContextST.setName( "<invoke " + self.getName() + " arg context>" );
+            argContextST.setEnclosingInstance( enclosing );
+            argContextST.setArgumentContext( self.getArgumentContext() );
+
+            ActionEvaluator eval =
+                    new ActionEvaluator( argContextST, this, null, argumentsAST );
+            /*
+            System.out.println("eval args: "+argumentsAST.toStringList());
+            System.out.println("ctx is "+self.getArgumentContext());
+            */
+            try
+            {
+                // using any initial argument context (such as when obj is set),
+                // evaluate the arg list like bold(item=obj).  Since we pass
+                // in any existing arg context, that context gets filled with
+                // new values.  With bold(item=obj), context becomes:
+                // {[obj=...],[item=...]}.
+                Dictionary<string, object> ac = eval.argList( self, self.getArgumentContext() );
+                self.setArgumentContext( ac );
+            }
+            catch ( RecognitionException re )
+            {
+                self.error( "can't evaluate tree: " + argumentsAST.ToStringTree(), re );
+            }
+        }
+
+#if false
+        public static readonly HashSet<Type> arraysConvertibleToList = new HashSet<Type>()
+            {
+                typeof(int[]),
+                typeof(long[]),
+                typeof(float[]),
+                typeof(double[])
+            };
+#endif
+
+        /** <summary>
+         *  Do a standard conversion of array attributes to a List.  Wrap the
+         *  array instead of copying like old version.  Make an
+         *  ArrayWrappedInList that knows to create an ArrayIterator.
+         *  </summary>
+         */
+        public static object convertArrayToList( object value )
+        {
+            if ( value == null )
+            {
+                return null;
+            }
+            if ( value.GetType().IsArray )
+            {
+                if ( value.GetType().GetElementType().IsPrimitive )
+                {
+                    return (IList)value;
+                }
+                return (IList)(object[])value;
+            }
+            return value;
+        }
+
+        protected internal static object convertAnythingIteratableToIterator( object o )
+        {
+            Iterator iter = null;
+            if ( o is IDictionary )
+            {
+                iter = ( (IDictionary)o ).Values.iterator();
+            }
+            else if ( o is System.Collections.IEnumerable && !(o is string) )
+            {
+                iter = ( (System.Collections.IEnumerable)o ).Cast<object>().iterator();
+            }
+            else if ( o is Iterator )
+            {
+                iter = (Iterator)o;
+            }
+            if ( iter == null )
+            {
+                return o;
+            }
+            return iter;
+        }
+
+        protected static Iterator convertAnythingToIterator( object o )
+        {
+            Iterator iter = null;
+            if ( o is ICollection )
+            {
+                iter = ( (ICollection)o ).iterator();
+            }
+            else if ( o is IDictionary )
+            {
+                iter = ( (IDictionary)o ).Values.iterator();
+            }
+            else if ( o is Iterator )
+            {
+                iter = (Iterator)o;
+            }
+            if ( iter == null )
+            {
+                IList singleton = new StringTemplate.STAttributeList( 1 );
+                singleton.Add( o );
+                return singleton.iterator();
+            }
+            return iter;
+        }
+
+        /** <summary>
+         *  Return the first attribute if multiple valued or the attribute
+         *  itself if single-valued.  Used in &lt;names:first()>
+         *  </summary>
+         */
+        public virtual object first( object attribute )
+        {
+            if ( attribute == null )
+            {
+                return null;
+            }
+            object f = attribute;
+            attribute = convertAnythingIteratableToIterator( attribute );
+            if ( attribute is Iterator )
+            {
+                Iterator it = (Iterator)attribute;
+                if ( it.hasNext() )
+                {
+                    f = it.next();
+                }
+            }
+
+            return f;
+        }
+
+        /** <summary>
+         *  Return the everything but the first attribute if multiple valued
+         *  or null if single-valued.  Used in &lt;names:rest()>.
+         *  </summary>
+         */
+        public virtual object rest( object attribute )
+        {
+            if ( attribute == null )
+            {
+                return null;
+            }
+            object theRest = attribute;
+            attribute = convertAnythingIteratableToIterator( attribute );
+            if ( attribute is Iterator )
+            {
+                IList a = new List<object>();
+                Iterator it = (Iterator)attribute;
+                if ( !it.hasNext() )
+                {
+                    return null; // if not even one value return null
+                }
+                it.next(); // ignore first value
+                while ( it.hasNext() )
+                {
+                    object o = (object)it.next();
+                    if ( o != null )
+                        a.Add( o );
+                }
+                return a;
+            }
+            else
+            {
+                theRest = null;  // rest of single-valued attribute is null
+            }
+
+            return theRest;
+        }
+
+        /** <summary>
+         *  Return the last attribute if multiple valued or the attribute
+         *  itself if single-valued.  Used in &lt;names:last()>.  This is pretty
+         *  slow as it iterates until the last element.  Ultimately, I could
+         *  make a special case for a List or Vector.
+         *  </summary>
+         */
+        public virtual object last( object attribute )
+        {
+            if ( attribute == null )
+            {
+                return null;
+            }
+            object last = attribute;
+            attribute = convertAnythingIteratableToIterator( attribute );
+            if ( attribute is Iterator )
+            {
+                Iterator it = (Iterator)attribute;
+                while ( it.hasNext() )
+                {
+                    last = it.next();
+                }
+            }
+
+            return last;
+        }
+
+        /** <summary>Return a new list w/o null values.</summary> */
+        public virtual object strip( object attribute )
+        {
+            if ( attribute == null )
+            {
+                return null;
+            }
+            attribute = convertAnythingIteratableToIterator( attribute );
+            if ( attribute is Iterator )
+            {
+                IList a = new List<object>();
+                Iterator it = (Iterator)attribute;
+                while ( it.hasNext() )
+                {
+                    object o = (object)it.next();
+                    if ( o != null )
+                        a.Add( o );
+                }
+                return a;
+            }
+            return attribute; // strip(x)==x when x single-valued attribute
+        }
+
+        /** <summary>Return all but the last element.  trunc(x)=null if x is single-valued.</summary> */
+        public virtual object trunc( object attribute )
+        {
+            if ( attribute == null )
+            {
+                return null;
+            }
+            attribute = convertAnythingIteratableToIterator( attribute );
+            if ( attribute is Iterator )
+            {
+                IList a = new List<object>();
+                Iterator it = (Iterator)attribute;
+                while ( it.hasNext() )
+                {
+                    object o = (object)it.next();
+                    if ( it.hasNext() )
+                        a.Add( o ); // only add if not last one
+                }
+                return a;
+            }
+            return null; // trunc(x)==null when x single-valued attribute
+        }
+
+        /** <summary>
+         *  Return the length of a multiple valued attribute or 1 if it is a
+         *  single attribute. If attribute is null return 0.
+         *  Special case several common collections and primitive arrays for
+         *  speed.  This method by Kay Roepke.
+         *  </summary>
+         */
+        public virtual object length( object attribute )
+        {
+            if ( attribute == null )
+            {
+                return 0;
+            }
+            int i = 1;		// we have at least one of something. Iterator and arrays might be empty.
+            if ( attribute is IDictionary )
+            {
+                i = ( (IDictionary)attribute ).Count;
+            }
+            else if ( attribute is ICollection )
+            {
+                i = ( (ICollection)attribute ).Count;
+            }
+            else if ( attribute is object[] )
+            {
+                object[] list = (object[])attribute;
+                i = list.Length;
+            }
+            else if ( attribute is int[] )
+            {
+                int[] list = (int[])attribute;
+                i = list.Length;
+            }
+            else if ( attribute is long[] )
+            {
+                long[] list = (long[])attribute;
+                i = list.Length;
+            }
+            else if ( attribute is float[] )
+            {
+                float[] list = (float[])attribute;
+                i = list.Length;
+            }
+            else if ( attribute is double[] )
+            {
+                double[] list = (double[])attribute;
+                i = list.Length;
+            }
+            else if ( attribute is Iterator )
+            {
+                Iterator it = (Iterator)attribute;
+                i = 0;
+                while ( it.hasNext() )
+                {
+                    it.next();
+                    i++;
+                }
+            }
+            return i;
+        }
+
+        public virtual object getOption( string name )
+        {
+            object value = null;
+            if ( options != null )
+            {
+                value = options.get( name );
+                if ( (value is string) && (string)value == EMPTY_OPTION )
+                {
+                    return defaultOptionValues.get( name );
+                }
+            }
+            return value;
+        }
+
+        public override string ToString()
+        {
+            return exprTree.ToStringTree();
+        }
+
+        #endregion
+    }
+}
diff --git a/Antlr3.StringTemplate/Language/Action.g3 b/Antlr3.StringTemplate/Language/Action.g3
new file mode 100644
index 0000000..893529c
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/Action.g3
@@ -0,0 +1,457 @@
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+grammar Action;
+
+options
+{
+	language=CSharp3;
+	output=AST;
+	ASTLabelType=StringTemplateAST;
+}
+
+tokens
+{
+	// template application
+	APPLY;
+	// parallel array template application
+	MULTI_APPLY;
+	// subtree is a list of (possibly empty) arguments
+	ARGS;
+	// isolated template include (no attribute)
+	INCLUDE;
+	CONDITIONAL='if';
+	// used for (foo): #(VALUE foo)
+	VALUE;
+	TEMPLATE;
+	FUNCTION;
+	SINGLEVALUEARG;
+	// [a,b,c]
+	LIST;
+	// empty list element [a, ,c]
+	NOTHING;
+}
+
+@lexer::header
+{
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+}
+
+@parser::header
+{
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+}
+
+@lexer::namespace { Antlr3.ST.Language }
+@parser::namespace { Antlr3.ST.Language }
+
+public
+action returns [IDictionary<string, object> opts=null]
+	:	(	templatesExpr (SEMI! optionList {$opts = $optionList.opts;})?
+		|	'if'^ LPAREN! ifCondition RPAREN!
+		|	'elseif'! LPAREN! ifCondition RPAREN! // return just conditional
+		)
+		EOF
+	;
+
+optionList! returns [IDictionary<string, object> opts=new Dictionary<string, object>()]
+	:	option[$opts] (COMMA option[$opts])*
+	;
+
+option[IDictionary<string, object> opts]
+@init
+{
+object v=null;
+}
+	:	ID
+		( ASSIGN nonAlternatingTemplateExpr {v=$nonAlternatingTemplateExpr.tree;}
+		| {v=ASTExpr.EMPTY_OPTION;}
+		)
+		{opts[$ID.text] = v;}
+	;
+
+templatesExpr
+	:	// LEFT FACTORED parallelArrayTemplateApplication INTO THIS RULE
+		expr
+		(	(COMMA expr)+ colon=COLON anonymousTemplate
+			-> ^(MULTI_APPLY["MULTI_APPLY"] expr+ $colon anonymousTemplate)
+		|	(	-> expr
+			)
+			(	colon=COLON templateList //template (COMMA template)*
+				-> ^(APPLY[$colon] $templatesExpr templateList/*template+*/)
+			)*
+		)
+	;
+
+templateList
+	:	template (COMMA! template)*
+	;
+
+ifCondition
+	:	ifAtom
+	|	NOT^ ifAtom
+	;
+
+ifAtom
+	:	templatesExpr
+	;
+
+expr
+	:	primaryExpr (PLUS^ primaryExpr)*
+	;
+
+primaryExpr
+	:	(templateInclude)=>templateInclude  // (see past parens to arglist)
+	|	atom
+		(	DOT^ // ignore warning on DOT ID
+			(	ID
+			|	valueExpr
+			)
+		)*
+	|	function
+		(	DOT^
+			(	ID
+			|	valueExpr
+			)
+		)*
+	|	valueExpr
+	|	list
+	;
+
+valueExpr
+	:	LPAREN templatesExpr RPAREN
+		-> ^(VALUE[$LPAREN,"value"] templatesExpr)
+	;
+
+nonAlternatingTemplateExpr
+	:	(expr -> expr) ( COLON template -> ^(APPLY[$COLON] $nonAlternatingTemplateExpr template) )*
+	;
+
+function
+	:	(	'first'
+		|	'rest'
+		|	'last'
+		|	'length'
+		|	'strip'
+		|	'trunc'
+		)
+		singleArg
+		-> ^(FUNCTION 'first'? 'rest'? 'last'? 'length'? 'strip'? 'trunc'? singleArg)
+	;
+
+template
+	:	(	namedTemplate			// foo()
+		|	anonymousTemplate		// {foo}
+		)
+		-> ^(TEMPLATE namedTemplate? anonymousTemplate?)
+	;
+
+namedTemplate
+	:	ID argList
+		-> ID argList
+	|	'super' DOT qid=ID argList
+		-> ID[$qid,"super."+$qid.text] argList
+	|	indirectTemplate
+		-> indirectTemplate
+	;
+
+anonymousTemplate
+@init
+{
+	StringTemplate anonymous = null;
+}
+@after
+{
+	$tree.StringTemplate = anonymous;
+}
+	:	t=ANONYMOUS_TEMPLATE
+		{
+			anonymous = new StringTemplate();
+			anonymous.setGroup(self.getGroup());
+			anonymous.setEnclosingInstance(self);
+			anonymous.setTemplate($t.text);
+			if ( $t is StringTemplateToken )
+				anonymous.defineFormalArguments(((StringTemplateToken)$t).args);
+			else
+				anonymous.defineFormalArguments(new ArrayList());
+		}
+	;
+
+atom
+	:	ID
+	|	STRING
+	|	INT
+	|	ANONYMOUS_TEMPLATE
+	;
+
+list
+	:	lb=LBRACK
+		listElement (COMMA listElement)*
+		RBRACK
+		-> ^(LIST[$lb,"value"] listElement+)
+	;
+
+listElement
+	:	nonAlternatingTemplateExpr
+	|
+		-> NOTHING["NOTHING"]
+	;
+
+templateInclude
+	:	(	id=ID argList -> $id argList
+		|	'super' DOT qid=ID argList -> ID[$qid,"super."+$qid.text] argList
+		|	indirectTemplate -> indirectTemplate
+		)
+		->	^(INCLUDE["include"] $templateInclude)
+	;
+
+/** Match (foo)() and (foo+".terse")() */
+indirectTemplate!
+	:	LPAREN e=templatesExpr RPAREN args=argList
+		-> ^(VALUE["value"] $e $args)
+	;
+
+argList!
+	:	LPAREN RPAREN -> ARGS["ARGS"] // view()
+	|	(singleArg)=>singleArg -> singleArg						  // bold(name)
+	|	LPAREN argumentAssignment (COMMA argumentAssignment)* RPAREN
+		-> ^(ARGS["ARGS"] argumentAssignment+)
+	;
+
+singleArg
+	:	LPAREN nonAlternatingTemplateExpr RPAREN
+		-> ^(SINGLEVALUEARG["SINGLEVALUEARG"] nonAlternatingTemplateExpr)
+	;
+
+argumentAssignment
+	:	ID ASSIGN^ nonAlternatingTemplateExpr
+	|	DOTDOTDOT
+	;
+
+//////////////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////////////
+// LEXER
+
+ID
+	:	('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'0'..'9'|'_'|'/')*
+	;
+
+INT
+	:	('0'..'9')+
+	;
+
+STRING
+@init
+{
+	char uc = '\0';
+	System.Text.StringBuilder builder = new System.Text.StringBuilder();
+}
+	:	'"'
+		(	ESC_CHAR[out uc, true] {builder.Append(uc);} // use uc since doEscape is true
+		|	ch=~('\\'|'"') {builder.Append((char)$ch);}
+		)*
+		'"'
+		{
+			$text = builder.ToString();
+		}
+	;
+
+ANONYMOUS_TEMPLATE
+@init
+{
+	StringTemplateToken t = null;
+	System.Text.StringBuilder builder = new System.Text.StringBuilder();
+	List args = new ArrayList();
+	string subtext = string.Empty;
+	char uc = '\0';
+}
+	:	'{'
+		(	(WS_CHAR? ID) => TEMPLATE_ARGS[out subtext, args] {builder.Append(subtext);} ((WS_CHAR) => WS_CHAR)?
+			{
+				// create a special token to track args
+				t = new StringTemplateToken(ANONYMOUS_TEMPLATE,$text,args);
+				//setToken(t);
+				state.token = t;
+			}
+		|	/* nothing */
+		)
+		(	('\\{') => '\\{' {builder.Append( '{' );}
+		|	('\\}') => '\\}' {builder.Append( '}' );}
+		|	ESC_CHAR[out uc, false] {builder.Append( $ESC_CHAR.text );} // use $ESC_CHAR.text since doEscape is false
+		|	NESTED_ANONYMOUS_TEMPLATE[out subtext] {builder.Append(subtext);}
+		|	ch=~('\\'|'{'|'}') {builder.Append((char)$ch);}
+		)*
+		{
+			Text = builder.ToString();
+			if ( t!=null )
+				t.Text = $text;
+		}
+		'}'
+	;
+
+fragment
+TEMPLATE_ARGS[out string _text, List args]
+@init
+{
+	$_text = string.Empty; // this template is empty text
+	$args.Clear();
+}
+	:	(WS_CHAR)? a=ID {$args.Add($a.text);}
+		( (WS_CHAR)? ',' (WS_CHAR)? a2=ID {args.Add($a2.text);} )*
+		(WS_CHAR)? '|'
+	;
+
+fragment
+NESTED_ANONYMOUS_TEMPLATE[out string _text]
+@init
+{
+	$_text = string.Empty;
+	char uc = '\0';
+	string subtext = string.Empty;
+	System.Text.StringBuilder builder = new System.Text.StringBuilder();
+}
+	:	'{'
+		{builder.Append('{');}
+		(	('\\{') => '\\{' {builder.Append('{');}
+		|	('\\}') => '\\}' {builder.Append('}');}
+		|	ESC_CHAR[out uc, false] {builder.Append($ESC_CHAR.text);} // use $ESC_CHAR.text since doEscape is false
+		|	NESTED_ANONYMOUS_TEMPLATE[out subtext] {builder.Append(subtext);}
+		|	ch=~('{'|'}'|'\\') {builder.Append((char)$ch);}
+		)*
+		'}'
+		{
+			builder.Append('}');
+			$_text = builder.ToString();
+		}
+	;
+
+/** Match escape sequences, optionally translating them for strings, but not
+ *  for templates.  Do \} only when in {...} templates.
+ */
+fragment
+ESC_CHAR[out char uc, bool doEscape]
+@init
+{
+	$uc = '\0';
+}
+	:	'\\'
+		(	'n' {if (doEscape) { $uc = '\n'; }}
+		|	'r' {if (doEscape) { $uc = '\r'; }}
+		|	't' {if (doEscape) { $uc = '\t'; }}
+		|	'b' {if (doEscape) { $uc = '\b'; }}
+		|	'f' {if (doEscape) { $uc = '\f'; }}
+		|	c=~('n'|'r'|'t'|'b'|'f') {if (doEscape) { $uc = (char)$c; }}
+		)
+	;
+
+LBRACK		: '[' ;
+RBRACK		: ']' ;
+LPAREN		: '(' ;
+RPAREN		: ')' ;
+COMMA		: ',' ;
+DOT			: '.' ;
+ASSIGN		: '=' ;
+COLON		: ':' ;
+PLUS		: '+' ;
+SEMI		: ';' ;
+NOT			: '!' ;
+DOTDOTDOT	: '...' ;
+
+WS
+	:	(' '|'\t'|'\r'|'\n')+
+		{$channel = HIDDEN;}
+	;
+
+fragment
+WS_CHAR
+	:	' '|'\t'|'\r'|'\n'
+	;
diff --git a/Antlr3.StringTemplate/Language/ActionEvaluator.cs b/Antlr3.StringTemplate/Language/ActionEvaluator.cs
new file mode 100644
index 0000000..78002f5
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/ActionEvaluator.cs
@@ -0,0 +1,1722 @@
+// $ANTLR 3.1.2 Language\\ActionEvaluator.g3 2009-03-07 08:54:44
+
+// The variable 'variable' is assigned but its value is never used.
+#pragma warning disable 219
+// Unreachable code detected.
+#pragma warning disable 162
+
+
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+using System.Linq;
+using Antlr.Runtime.JavaExtensions;
+
+using Map = System.Collections.IDictionary;
+using Set = System.Collections.Generic.HashSet<object>;
+using StringWriter = System.IO.StringWriter;
+using Vector = System.Collections.Generic.List<object>;
+
+
+using System.Collections.Generic;
+using Antlr.Runtime;
+using Antlr.Runtime.Tree;
+using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;using Stack = System.Collections.Generic.Stack<object>;
+using List = System.Collections.IList;
+using ArrayList = System.Collections.Generic.List<object>;
+
+namespace Antlr3.ST.Language
+{
+public partial class ActionEvaluator : TreeParser
+{
+	public static readonly string[] tokenNames = new string[] {
+		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ANONYMOUS_TEMPLATE", "APPLY", "ARGS", "ASSIGN", "COLON", "COMMA", "CONDITIONAL", "DOT", "DOTDOTDOT", "ESC_CHAR", "FUNCTION", "ID", "INCLUDE", "INT", "LBRACK", "LIST", "LPAREN", "MULTI_APPLY", "NESTED_ANONYMOUS_TEMPLATE", "NOT", "NOTHING", "PLUS", "RBRACK", "RPAREN", "SEMI", "SINGLEVALUEARG", "STRING", "TEMPLATE", "TEMPLATE_ARGS", "VALUE", "WS", "WS_CHAR", "'elseif'", "'first'", "'last'", "'length'", "'rest'", "'strip'", "'super'", "'trunc'"
+	};
+	public const int EOF=-1;
+	public const int T__36=36;
+	public const int T__37=37;
+	public const int T__38=38;
+	public const int T__39=39;
+	public const int T__40=40;
+	public const int T__41=41;
+	public const int T__42=42;
+	public const int T__43=43;
+	public const int ANONYMOUS_TEMPLATE=4;
+	public const int APPLY=5;
+	public const int ARGS=6;
+	public const int ASSIGN=7;
+	public const int COLON=8;
+	public const int COMMA=9;
+	public const int CONDITIONAL=10;
+	public const int DOT=11;
+	public const int DOTDOTDOT=12;
+	public const int ESC_CHAR=13;
+	public const int FUNCTION=14;
+	public const int ID=15;
+	public const int INCLUDE=16;
+	public const int INT=17;
+	public const int LBRACK=18;
+	public const int LIST=19;
+	public const int LPAREN=20;
+	public const int MULTI_APPLY=21;
+	public const int NESTED_ANONYMOUS_TEMPLATE=22;
+	public const int NOT=23;
+	public const int NOTHING=24;
+	public const int PLUS=25;
+	public const int RBRACK=26;
+	public const int RPAREN=27;
+	public const int SEMI=28;
+	public const int SINGLEVALUEARG=29;
+	public const int STRING=30;
+	public const int TEMPLATE=31;
+	public const int TEMPLATE_ARGS=32;
+	public const int VALUE=33;
+	public const int WS=34;
+	public const int WS_CHAR=35;
+
+	// delegates
+	// delegators
+
+	public ActionEvaluator( ITreeNodeStream input )
+		: this( input, new RecognizerSharedState() )
+	{
+	}
+	public ActionEvaluator( ITreeNodeStream input, RecognizerSharedState state )
+		: base( input, state )
+	{
+	}
+
+
+	public override string[] GetTokenNames() { return ActionEvaluator.tokenNames; }
+	public override string GrammarFileName { get { return "Language\\ActionEvaluator.g3"; } }
+
+
+	#region Rules
+
+	// $ANTLR start "action"
+	// Language\\ActionEvaluator.g3:87:0: public action returns [int numCharsWritten=0] : expr ;
+	public int action(  )
+	{
+
+		int numCharsWritten = 0;
+
+		object expr1 = default(object);
+
+		try
+		{
+			// Language\\ActionEvaluator.g3:88:4: ( expr )
+			// Language\\ActionEvaluator.g3:88:4: expr
+			{
+			PushFollow(Follow._expr_in_action56);
+			expr1=expr();
+
+			state._fsp--;
+
+			numCharsWritten = chunk.writeAttribute(self,expr1,writer);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return numCharsWritten;
+	}
+	// $ANTLR end "action"
+
+
+	// $ANTLR start "expr"
+	// Language\\ActionEvaluator.g3:91:0: expr returns [object value] : ( ^( PLUS a= expr b= expr ) | templateApplication | attribute | templateInclude | function | list | ^( VALUE e= expr ) );
+	private object expr(  )
+	{
+
+		object value = default(object);
+
+		object a = default(object);
+		object b = default(object);
+		object e = default(object);
+		object templateApplication2 = default(object);
+		object attribute3 = default(object);
+		object templateInclude4 = default(object);
+		object function5 = default(object);
+		object list6 = default(object);
+
+
+			Map argumentContext=null;
+			value = null;
+
+		try
+		{
+			// Language\\ActionEvaluator.g3:97:4: ( ^( PLUS a= expr b= expr ) | templateApplication | attribute | templateInclude | function | list | ^( VALUE e= expr ) )
+			int alt1=7;
+			switch ( input.LA(1) )
+			{
+			case PLUS:
+				{
+				alt1=1;
+				}
+				break;
+			case APPLY:
+			case MULTI_APPLY:
+				{
+				alt1=2;
+				}
+				break;
+			case ANONYMOUS_TEMPLATE:
+			case DOT:
+			case ID:
+			case INT:
+			case STRING:
+				{
+				alt1=3;
+				}
+				break;
+			case INCLUDE:
+				{
+				alt1=4;
+				}
+				break;
+			case FUNCTION:
+				{
+				alt1=5;
+				}
+				break;
+			case LIST:
+				{
+				alt1=6;
+				}
+				break;
+			case VALUE:
+				{
+				alt1=7;
+				}
+				break;
+			default:
+				{
+					NoViableAltException nvae = new NoViableAltException("", 1, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt1 )
+			{
+			case 1:
+				// Language\\ActionEvaluator.g3:97:4: ^( PLUS a= expr b= expr )
+				{
+				Match(input,PLUS,Follow._PLUS_in_expr79);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._expr_in_expr83);
+				a=expr();
+
+				state._fsp--;
+
+				PushFollow(Follow._expr_in_expr87);
+				b=expr();
+
+				state._fsp--;
+
+				value = chunk.Add(a,b);
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 2:
+				// Language\\ActionEvaluator.g3:98:4: templateApplication
+				{
+				PushFollow(Follow._templateApplication_in_expr95);
+				templateApplication2=templateApplication();
+
+				state._fsp--;
+
+				value = templateApplication2;
+
+				}
+				break;
+			case 3:
+				// Language\\ActionEvaluator.g3:99:4: attribute
+				{
+				PushFollow(Follow._attribute_in_expr102);
+				attribute3=attribute();
+
+				state._fsp--;
+
+				value = attribute3;
+
+				}
+				break;
+			case 4:
+				// Language\\ActionEvaluator.g3:100:4: templateInclude
+				{
+				PushFollow(Follow._templateInclude_in_expr109);
+				templateInclude4=templateInclude();
+
+				state._fsp--;
+
+				value = templateInclude4;
+
+				}
+				break;
+			case 5:
+				// Language\\ActionEvaluator.g3:101:4: function
+				{
+				PushFollow(Follow._function_in_expr116);
+				function5=function();
+
+				state._fsp--;
+
+				value = function5;
+
+				}
+				break;
+			case 6:
+				// Language\\ActionEvaluator.g3:102:4: list
+				{
+				PushFollow(Follow._list_in_expr123);
+				list6=list();
+
+				state._fsp--;
+
+				value = list6;
+
+				}
+				break;
+			case 7:
+				// Language\\ActionEvaluator.g3:103:4: ^( VALUE e= expr )
+				{
+				Match(input,VALUE,Follow._VALUE_in_expr131);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._expr_in_expr135);
+				e=expr();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+							StringWriter buf = new StringWriter();
+							IStringTemplateWriter sw = self.getGroup().getStringTemplateWriter(buf);
+							int n = chunk.writeAttribute(self,e,sw);
+							if ( n > 0 )
+							{
+								value = buf.ToString();
+							}
+
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return value;
+	}
+	// $ANTLR end "expr"
+
+
+	// $ANTLR start "list"
+	// Language\\ActionEvaluator.g3:117:0: list returns [object value=null] : ^( LIST ( expr | NOTHING )+ ) ;
+	private object list(  )
+	{
+
+		object value = null;
+
+		object expr7 = default(object);
+
+
+			List elements = new ArrayList();
+
+		try
+		{
+			// Language\\ActionEvaluator.g3:122:4: ( ^( LIST ( expr | NOTHING )+ ) )
+			// Language\\ActionEvaluator.g3:122:4: ^( LIST ( expr | NOTHING )+ )
+			{
+			Match(input,LIST,Follow._LIST_in_list167);
+
+			Match(input, TokenConstants.DOWN, null);
+			// Language\\ActionEvaluator.g3:123:4: ( expr | NOTHING )+
+			int cnt2=0;
+			for ( ; ; )
+			{
+				int alt2=3;
+				int LA2_0 = input.LA(1);
+
+				if ( ((LA2_0>=ANONYMOUS_TEMPLATE && LA2_0<=APPLY)||LA2_0==DOT||(LA2_0>=FUNCTION && LA2_0<=INT)||LA2_0==LIST||LA2_0==MULTI_APPLY||LA2_0==PLUS||LA2_0==STRING||LA2_0==VALUE) )
+				{
+					alt2=1;
+				}
+				else if ( (LA2_0==NOTHING) )
+				{
+					alt2=2;
+				}
+
+
+				switch ( alt2 )
+				{
+				case 1:
+					// Language\\ActionEvaluator.g3:123:6: expr
+					{
+					PushFollow(Follow._expr_in_list174);
+					expr7=expr();
+
+					state._fsp--;
+
+
+										if ( expr7!=null )
+										{
+											elements.Add(expr7);
+										}
+
+
+					}
+					break;
+				case 2:
+					// Language\\ActionEvaluator.g3:130:6: NOTHING
+					{
+					Match(input,NOTHING,Follow._NOTHING_in_list187);
+
+										List nullSingleton = new ArrayList( new object[] {null} );
+										elements.Add(nullSingleton.iterator()); // add a blank
+
+
+					}
+					break;
+
+				default:
+					if ( cnt2 >= 1 )
+						goto loop2;
+
+					EarlyExitException eee2 = new EarlyExitException( 2, input );
+					throw eee2;
+				}
+				cnt2++;
+			}
+			loop2:
+				;
+
+
+
+			Match(input, TokenConstants.UP, null);
+			value = new Cat(elements);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return value;
+	}
+	// $ANTLR end "list"
+
+
+	// $ANTLR start "templateInclude"
+	// Language\\ActionEvaluator.g3:140:0: templateInclude returns [object value=null] : ^( INCLUDE (id= ID a1= . | ^( VALUE n= expr a2= . ) ) ) ;
+	private object templateInclude(  )
+	{
+
+		object value = null;
+
+		StringTemplateAST id=null;
+		StringTemplateAST a1=null;
+		StringTemplateAST a2=null;
+		object n = default(object);
+
+
+			StringTemplateAST args = null;
+			string name = null;
+
+		try
+		{
+			// Language\\ActionEvaluator.g3:146:4: ( ^( INCLUDE (id= ID a1= . | ^( VALUE n= expr a2= . ) ) ) )
+			// Language\\ActionEvaluator.g3:146:4: ^( INCLUDE (id= ID a1= . | ^( VALUE n= expr a2= . ) ) )
+			{
+			Match(input,INCLUDE,Follow._INCLUDE_in_templateInclude229);
+
+			Match(input, TokenConstants.DOWN, null);
+			// Language\\ActionEvaluator.g3:148:4: (id= ID a1= . | ^( VALUE n= expr a2= . ) )
+			int alt3=2;
+			int LA3_0 = input.LA(1);
+
+			if ( (LA3_0==ID) )
+			{
+				alt3=1;
+			}
+			else if ( (LA3_0==VALUE) )
+			{
+				alt3=2;
+			}
+			else
+			{
+				NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt3 )
+			{
+			case 1:
+				// Language\\ActionEvaluator.g3:148:6: id= ID a1= .
+				{
+				id=(StringTemplateAST)Match(input,ID,Follow._ID_in_templateInclude242);
+				a1=(StringTemplateAST)input.LT(1);
+				MatchAny(input);
+				name=(id!=null?id.Text:null); args=a1;
+
+				}
+				break;
+			case 2:
+				// Language\\ActionEvaluator.g3:151:6: ^( VALUE n= expr a2= . )
+				{
+				Match(input,VALUE,Follow._VALUE_in_templateInclude262);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._expr_in_templateInclude266);
+				n=expr();
+
+				state._fsp--;
+
+				a2=(StringTemplateAST)input.LT(1);
+				MatchAny(input);
+
+				Match(input, TokenConstants.UP, null);
+				if (n!=null) {name=n.ToString();} args=a2;
+
+				}
+				break;
+
+			}
+
+
+			Match(input, TokenConstants.UP, null);
+
+						if ( name!=null )
+						{
+							value = chunk.getTemplateInclude(self, name, args);
+						}
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return value;
+	}
+	// $ANTLR end "templateInclude"
+
+
+	// $ANTLR start "templateApplication"
+	// Language\\ActionEvaluator.g3:167:0: templateApplication returns [object value] : ( ^( APPLY a= expr ( template[templatesToApply] )+ ) | ^( MULTI_APPLY (a= expr )+ COLON anon= ANONYMOUS_TEMPLATE ) );
+	private object templateApplication(  )
+	{
+
+		object value = default(object);
+
+		StringTemplateAST anon=null;
+		object a = default(object);
+
+
+			var templatesToApply = new System.Collections.Generic.List<StringTemplate>();
+			List attributes = new ArrayList();
+
+		try
+		{
+			// Language\\ActionEvaluator.g3:173:4: ( ^( APPLY a= expr ( template[templatesToApply] )+ ) | ^( MULTI_APPLY (a= expr )+ COLON anon= ANONYMOUS_TEMPLATE ) )
+			int alt6=2;
+			int LA6_0 = input.LA(1);
+
+			if ( (LA6_0==APPLY) )
+			{
+				alt6=1;
+			}
+			else if ( (LA6_0==MULTI_APPLY) )
+			{
+				alt6=2;
+			}
+			else
+			{
+				NoViableAltException nvae = new NoViableAltException("", 6, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt6 )
+			{
+			case 1:
+				// Language\\ActionEvaluator.g3:173:4: ^( APPLY a= expr ( template[templatesToApply] )+ )
+				{
+				Match(input,APPLY,Follow._APPLY_in_templateApplication316);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._expr_in_templateApplication320);
+				a=expr();
+
+				state._fsp--;
+
+				// Language\\ActionEvaluator.g3:174:4: ( template[templatesToApply] )+
+				int cnt4=0;
+				for ( ; ; )
+				{
+					int alt4=2;
+					int LA4_0 = input.LA(1);
+
+					if ( (LA4_0==TEMPLATE) )
+					{
+						alt4=1;
+					}
+
+
+					switch ( alt4 )
+					{
+					case 1:
+						// Language\\ActionEvaluator.g3:174:5: template[templatesToApply]
+						{
+						PushFollow(Follow._template_in_templateApplication326);
+						template(templatesToApply);
+
+						state._fsp--;
+
+
+						}
+						break;
+
+					default:
+						if ( cnt4 >= 1 )
+							goto loop4;
+
+						EarlyExitException eee4 = new EarlyExitException( 4, input );
+						throw eee4;
+					}
+					cnt4++;
+				}
+				loop4:
+					;
+
+
+				value = chunk.applyListOfAlternatingTemplates(self,a,templatesToApply);
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 2:
+				// Language\\ActionEvaluator.g3:177:4: ^( MULTI_APPLY (a= expr )+ COLON anon= ANONYMOUS_TEMPLATE )
+				{
+				Match(input,MULTI_APPLY,Follow._MULTI_APPLY_in_templateApplication345);
+
+				Match(input, TokenConstants.DOWN, null);
+				// Language\\ActionEvaluator.g3:177:19: (a= expr )+
+				int cnt5=0;
+				for ( ; ; )
+				{
+					int alt5=2;
+					int LA5_0 = input.LA(1);
+
+					if ( ((LA5_0>=ANONYMOUS_TEMPLATE && LA5_0<=APPLY)||LA5_0==DOT||(LA5_0>=FUNCTION && LA5_0<=INT)||LA5_0==LIST||LA5_0==MULTI_APPLY||LA5_0==PLUS||LA5_0==STRING||LA5_0==VALUE) )
+					{
+						alt5=1;
+					}
+
+
+					switch ( alt5 )
+					{
+					case 1:
+						// Language\\ActionEvaluator.g3:177:20: a= expr
+						{
+						PushFollow(Follow._expr_in_templateApplication350);
+						a=expr();
+
+						state._fsp--;
+
+						attributes.Add(a);
+
+						}
+						break;
+
+					default:
+						if ( cnt5 >= 1 )
+							goto loop5;
+
+						EarlyExitException eee5 = new EarlyExitException( 5, input );
+						throw eee5;
+					}
+					cnt5++;
+				}
+				loop5:
+					;
+
+
+				Match(input,COLON,Follow._COLON_in_templateApplication357);
+				anon=(StringTemplateAST)Match(input,ANONYMOUS_TEMPLATE,Follow._ANONYMOUS_TEMPLATE_in_templateApplication364);
+
+								StringTemplate anonymous = anon.StringTemplate;
+								templatesToApply.Add(anonymous);
+								value = chunk.applyTemplateToListOfAttributes(self,
+																			  attributes,
+																			  anon.StringTemplate);
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return value;
+	}
+	// $ANTLR end "templateApplication"
+
+
+	// $ANTLR start "function"
+	// Language\\ActionEvaluator.g3:189:0: function returns [object value] : ^( FUNCTION ( 'first' a= singleFunctionArg | 'rest' a= singleFunctionArg | 'last' a= singleFunctionArg | 'length' a= singleFunctionArg | 'strip' a= singleFunctionArg | 'trunc' a= singleFunctionArg ) ) ;
+	private object function(  )
+	{
+
+		object value = default(object);
+
+		object a = default(object);
+
+		try
+		{
+			// Language\\ActionEvaluator.g3:190:4: ( ^( FUNCTION ( 'first' a= singleFunctionArg | 'rest' a= singleFunctionArg | 'last' a= singleFunctionArg | 'length' a= singleFunctionArg | 'strip' a= singleFunctionArg | 'trunc' a= singleFunctionArg ) ) )
+			// Language\\ActionEvaluator.g3:190:4: ^( FUNCTION ( 'first' a= singleFunctionArg | 'rest' a= singleFunctionArg | 'last' a= singleFunctionArg | 'length' a= singleFunctionArg | 'strip' a= singleFunctionArg | 'trunc' a= singleFunctionArg ) )
+			{
+			Match(input,FUNCTION,Follow._FUNCTION_in_function390);
+
+			Match(input, TokenConstants.DOWN, null);
+			// Language\\ActionEvaluator.g3:191:4: ( 'first' a= singleFunctionArg | 'rest' a= singleFunctionArg | 'last' a= singleFunctionArg | 'length' a= singleFunctionArg | 'strip' a= singleFunctionArg | 'trunc' a= singleFunctionArg )
+			int alt7=6;
+			switch ( input.LA(1) )
+			{
+			case 37:
+				{
+				alt7=1;
+				}
+				break;
+			case 40:
+				{
+				alt7=2;
+				}
+				break;
+			case 38:
+				{
+				alt7=3;
+				}
+				break;
+			case 39:
+				{
+				alt7=4;
+				}
+				break;
+			case 41:
+				{
+				alt7=5;
+				}
+				break;
+			case 43:
+				{
+				alt7=6;
+				}
+				break;
+			default:
+				{
+					NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt7 )
+			{
+			case 1:
+				// Language\\ActionEvaluator.g3:191:6: 'first' a= singleFunctionArg
+				{
+				Match(input,37,Follow._37_in_function397);
+				PushFollow(Follow._singleFunctionArg_in_function402);
+				a=singleFunctionArg();
+
+				state._fsp--;
+
+				value =chunk.first(a);
+
+				}
+				break;
+			case 2:
+				// Language\\ActionEvaluator.g3:192:6: 'rest' a= singleFunctionArg
+				{
+				Match(input,40,Follow._40_in_function411);
+				PushFollow(Follow._singleFunctionArg_in_function416);
+				a=singleFunctionArg();
+
+				state._fsp--;
+
+				value =chunk.rest(a);
+
+				}
+				break;
+			case 3:
+				// Language\\ActionEvaluator.g3:193:6: 'last' a= singleFunctionArg
+				{
+				Match(input,38,Follow._38_in_function425);
+				PushFollow(Follow._singleFunctionArg_in_function430);
+				a=singleFunctionArg();
+
+				state._fsp--;
+
+				value =chunk.last(a);
+
+				}
+				break;
+			case 4:
+				// Language\\ActionEvaluator.g3:194:6: 'length' a= singleFunctionArg
+				{
+				Match(input,39,Follow._39_in_function439);
+				PushFollow(Follow._singleFunctionArg_in_function443);
+				a=singleFunctionArg();
+
+				state._fsp--;
+
+				value =chunk.length(a);
+
+				}
+				break;
+			case 5:
+				// Language\\ActionEvaluator.g3:195:6: 'strip' a= singleFunctionArg
+				{
+				Match(input,41,Follow._41_in_function452);
+				PushFollow(Follow._singleFunctionArg_in_function457);
+				a=singleFunctionArg();
+
+				state._fsp--;
+
+				value =chunk.strip(a);
+
+				}
+				break;
+			case 6:
+				// Language\\ActionEvaluator.g3:196:6: 'trunc' a= singleFunctionArg
+				{
+				Match(input,43,Follow._43_in_function466);
+				PushFollow(Follow._singleFunctionArg_in_function471);
+				a=singleFunctionArg();
+
+				state._fsp--;
+
+				value =chunk.trunc(a);
+
+				}
+				break;
+
+			}
+
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return value;
+	}
+	// $ANTLR end "function"
+
+
+	// $ANTLR start "singleFunctionArg"
+	// Language\\ActionEvaluator.g3:201:0: singleFunctionArg returns [object value=null] : ^( SINGLEVALUEARG expr ) ;
+	private object singleFunctionArg(  )
+	{
+
+		object value = null;
+
+		object expr8 = default(object);
+
+		try
+		{
+			// Language\\ActionEvaluator.g3:202:4: ( ^( SINGLEVALUEARG expr ) )
+			// Language\\ActionEvaluator.g3:202:4: ^( SINGLEVALUEARG expr )
+			{
+			Match(input,SINGLEVALUEARG,Follow._SINGLEVALUEARG_in_singleFunctionArg499);
+
+			Match(input, TokenConstants.DOWN, null);
+			PushFollow(Follow._expr_in_singleFunctionArg501);
+			expr8=expr();
+
+			state._fsp--;
+
+			value = expr8;
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return value;
+	}
+	// $ANTLR end "singleFunctionArg"
+
+
+	// $ANTLR start "template"
+	// Language\\ActionEvaluator.g3:205:0: template[System.Collections.Generic.List<StringTemplate> templatesToApply] : ^( TEMPLATE ( ID args= . |anon= ANONYMOUS_TEMPLATE | ^( VALUE n= expr args2= . ) ) ) ;
+	private void template( System.Collections.Generic.List<StringTemplate> templatesToApply )
+	{
+		StringTemplateAST anon=null;
+		StringTemplateAST ID9=null;
+		StringTemplateAST args=null;
+		StringTemplateAST args2=null;
+		object n = default(object);
+
+
+			Map argumentContext = null;
+
+		try
+		{
+			// Language\\ActionEvaluator.g3:210:4: ( ^( TEMPLATE ( ID args= . |anon= ANONYMOUS_TEMPLATE | ^( VALUE n= expr args2= . ) ) ) )
+			// Language\\ActionEvaluator.g3:210:4: ^( TEMPLATE ( ID args= . |anon= ANONYMOUS_TEMPLATE | ^( VALUE n= expr args2= . ) ) )
+			{
+			Match(input,TEMPLATE,Follow._TEMPLATE_in_template524);
+
+			Match(input, TokenConstants.DOWN, null);
+			// Language\\ActionEvaluator.g3:211:4: ( ID args= . |anon= ANONYMOUS_TEMPLATE | ^( VALUE n= expr args2= . ) )
+			int alt8=3;
+			switch ( input.LA(1) )
+			{
+			case ID:
+				{
+				alt8=1;
+				}
+				break;
+			case ANONYMOUS_TEMPLATE:
+				{
+				alt8=2;
+				}
+				break;
+			case VALUE:
+				{
+				alt8=3;
+				}
+				break;
+			default:
+				{
+					NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt8 )
+			{
+			case 1:
+				// Language\\ActionEvaluator.g3:211:6: ID args= .
+				{
+				ID9=(StringTemplateAST)Match(input,ID,Follow._ID_in_template531);
+				args=(StringTemplateAST)input.LT(1);
+				MatchAny(input);
+
+									string templateName = (ID9!=null?ID9.Text:null);
+									StringTemplateGroup group = self.getGroup();
+									StringTemplate embedded = group.getEmbeddedInstanceOf(self, templateName);
+									if ( embedded!=null )
+									{
+										embedded.setArgumentsAST(args);
+										templatesToApply.Add(embedded);
+									}
+
+
+				}
+				break;
+			case 2:
+				// Language\\ActionEvaluator.g3:223:6: anon= ANONYMOUS_TEMPLATE
+				{
+				anon=(StringTemplateAST)Match(input,ANONYMOUS_TEMPLATE,Follow._ANONYMOUS_TEMPLATE_in_template552);
+
+									StringTemplate anonymous = anon.StringTemplate;
+									// to properly see overridden templates, always set
+									// anonymous' group to be self's group
+									anonymous.setGroup(self.getGroup());
+									templatesToApply.Add(anonymous);
+
+
+				}
+				break;
+			case 3:
+				// Language\\ActionEvaluator.g3:232:6: ^( VALUE n= expr args2= . )
+				{
+				Match(input,VALUE,Follow._VALUE_in_template568);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._expr_in_template572);
+				n=expr();
+
+				state._fsp--;
+
+				args2=(StringTemplateAST)input.LT(1);
+				MatchAny(input);
+
+										StringTemplate embedded = null;
+										if ( n!=null )
+										{
+											string templateName = n.ToString();
+											StringTemplateGroup group = self.getGroup();
+											embedded = group.getEmbeddedInstanceOf(self, templateName);
+											if ( embedded!=null )
+											{
+												embedded.setArgumentsAST(args2);
+												templatesToApply.Add(embedded);
+											}
+										}
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+
+			}
+
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "template"
+
+
+	// $ANTLR start "ifCondition"
+	// Language\\ActionEvaluator.g3:253:0: public ifCondition returns [bool value] : (a= ifAtom | ^( NOT a= ifAtom ) );
+	public bool ifCondition(  )
+	{
+
+		bool value = default(bool);
+
+		object a = default(object);
+
+		try
+		{
+			// Language\\ActionEvaluator.g3:254:4: (a= ifAtom | ^( NOT a= ifAtom ) )
+			int alt9=2;
+			int LA9_0 = input.LA(1);
+
+			if ( ((LA9_0>=ANONYMOUS_TEMPLATE && LA9_0<=APPLY)||LA9_0==DOT||(LA9_0>=FUNCTION && LA9_0<=INT)||LA9_0==LIST||LA9_0==MULTI_APPLY||LA9_0==PLUS||LA9_0==STRING||LA9_0==VALUE) )
+			{
+				alt9=1;
+			}
+			else if ( (LA9_0==NOT) )
+			{
+				alt9=2;
+			}
+			else
+			{
+				NoViableAltException nvae = new NoViableAltException("", 9, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt9 )
+			{
+			case 1:
+				// Language\\ActionEvaluator.g3:254:4: a= ifAtom
+				{
+				PushFollow(Follow._ifAtom_in_ifCondition617);
+				a=ifAtom();
+
+				state._fsp--;
+
+				value = chunk.testAttributeTrue(a);
+
+				}
+				break;
+			case 2:
+				// Language\\ActionEvaluator.g3:255:4: ^( NOT a= ifAtom )
+				{
+				Match(input,NOT,Follow._NOT_in_ifCondition625);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._ifAtom_in_ifCondition629);
+				a=ifAtom();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+				value = !chunk.testAttributeTrue(a);
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return value;
+	}
+	// $ANTLR end "ifCondition"
+
+
+	// $ANTLR start "ifAtom"
+	// Language\\ActionEvaluator.g3:258:0: ifAtom returns [object value] : expr ;
+	private object ifAtom(  )
+	{
+
+		object value = default(object);
+
+		object expr10 = default(object);
+
+		try
+		{
+			// Language\\ActionEvaluator.g3:259:4: ( expr )
+			// Language\\ActionEvaluator.g3:259:4: expr
+			{
+			PushFollow(Follow._expr_in_ifAtom647);
+			expr10=expr();
+
+			state._fsp--;
+
+			value = expr10;
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return value;
+	}
+	// $ANTLR end "ifAtom"
+
+
+	// $ANTLR start "attribute"
+	// Language\\ActionEvaluator.g3:262:0: attribute returns [object value] : ( ^( DOT obj= expr (prop= ID | ^( VALUE e= expr ) ) ) |i3= ID |i= INT |s= STRING |at= ANONYMOUS_TEMPLATE );
+	private object attribute(  )
+	{
+
+		object value = default(object);
+
+		StringTemplateAST prop=null;
+		StringTemplateAST i3=null;
+		StringTemplateAST i=null;
+		StringTemplateAST s=null;
+		StringTemplateAST at=null;
+		object obj = default(object);
+		object e = default(object);
+
+
+			object propName = null;
+
+		try
+		{
+			// Language\\ActionEvaluator.g3:267:4: ( ^( DOT obj= expr (prop= ID | ^( VALUE e= expr ) ) ) |i3= ID |i= INT |s= STRING |at= ANONYMOUS_TEMPLATE )
+			int alt11=5;
+			switch ( input.LA(1) )
+			{
+			case DOT:
+				{
+				alt11=1;
+				}
+				break;
+			case ID:
+				{
+				alt11=2;
+				}
+				break;
+			case INT:
+				{
+				alt11=3;
+				}
+				break;
+			case STRING:
+				{
+				alt11=4;
+				}
+				break;
+			case ANONYMOUS_TEMPLATE:
+				{
+				alt11=5;
+				}
+				break;
+			default:
+				{
+					NoViableAltException nvae = new NoViableAltException("", 11, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt11 )
+			{
+			case 1:
+				// Language\\ActionEvaluator.g3:267:4: ^( DOT obj= expr (prop= ID | ^( VALUE e= expr ) ) )
+				{
+				Match(input,DOT,Follow._DOT_in_attribute671);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._expr_in_attribute675);
+				obj=expr();
+
+				state._fsp--;
+
+				// Language\\ActionEvaluator.g3:268:4: (prop= ID | ^( VALUE e= expr ) )
+				int alt10=2;
+				int LA10_0 = input.LA(1);
+
+				if ( (LA10_0==ID) )
+				{
+					alt10=1;
+				}
+				else if ( (LA10_0==VALUE) )
+				{
+					alt10=2;
+				}
+				else
+				{
+					NoViableAltException nvae = new NoViableAltException("", 10, 0, input);
+
+					throw nvae;
+				}
+				switch ( alt10 )
+				{
+				case 1:
+					// Language\\ActionEvaluator.g3:268:6: prop= ID
+					{
+					prop=(StringTemplateAST)Match(input,ID,Follow._ID_in_attribute684);
+					propName = (prop!=null?prop.Text:null);
+
+					}
+					break;
+				case 2:
+					// Language\\ActionEvaluator.g3:273:6: ^( VALUE e= expr )
+					{
+					Match(input,VALUE,Follow._VALUE_in_attribute714);
+
+					Match(input, TokenConstants.DOWN, null);
+					PushFollow(Follow._expr_in_attribute718);
+					e=expr();
+
+					state._fsp--;
+
+
+					Match(input, TokenConstants.UP, null);
+					if (e!=null) {propName=e;}
+
+					}
+					break;
+
+				}
+
+
+				Match(input, TokenConstants.UP, null);
+				value = chunk.getObjectProperty(self,obj,propName);
+
+				}
+				break;
+			case 2:
+				// Language\\ActionEvaluator.g3:278:4: i3= ID
+				{
+				i3=(StringTemplateAST)Match(input,ID,Follow._ID_in_attribute742);
+
+						value =self.getAttribute((i3!=null?i3.Text:null));
+
+
+				}
+				break;
+			case 3:
+				// Language\\ActionEvaluator.g3:283:4: i= INT
+				{
+				i=(StringTemplateAST)Match(input,INT,Follow._INT_in_attribute754);
+				value =int.Parse((i!=null?i.Text:null));
+
+				}
+				break;
+			case 4:
+				// Language\\ActionEvaluator.g3:285:4: s= STRING
+				{
+				s=(StringTemplateAST)Match(input,STRING,Follow._STRING_in_attribute764);
+
+						value =(s!=null?s.Text:null);
+
+
+				}
+				break;
+			case 5:
+				// Language\\ActionEvaluator.g3:290:4: at= ANONYMOUS_TEMPLATE
+				{
+				at=(StringTemplateAST)Match(input,ANONYMOUS_TEMPLATE,Follow._ANONYMOUS_TEMPLATE_in_attribute776);
+
+							value =(at!=null?at.Text:null);
+							if ( (at!=null?at.Text:null)!=null )
+							{
+								StringTemplate valueST =new StringTemplate(self.getGroup(), (at!=null?at.Text:null));
+								valueST.setEnclosingInstance(self);
+								valueST.setName("<anonymous template argument>");
+								value = valueST;
+							}
+
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return value;
+	}
+	// $ANTLR end "attribute"
+
+
+	// $ANTLR start "argList"
+	// Language\\ActionEvaluator.g3:309:0: public argList[StringTemplate embedded, System.Collections.Generic.Dictionary<string, object> initialContext] returns [System.Collections.Generic.Dictionary<string, object> argumentContext=null] : ( ^( ARGS ( argumentAssignment[$embedded,$argumentContext] )* ) | singleTemplateArg[$embedded,$argumentContext] );
+	public System.Collections.Generic.Dictionary<string, object> argList( StringTemplate embedded, System.Collections.Generic.Dictionary<string, object> initialContext )
+	{
+
+		System.Collections.Generic.Dictionary<string, object> argumentContext = null;
+
+
+			argumentContext = initialContext;
+			if ( argumentContext==null )
+			{
+				argumentContext =new System.Collections.Generic.Dictionary<string, object>();
+			}
+
+		try
+		{
+			// Language\\ActionEvaluator.g3:319:4: ( ^( ARGS ( argumentAssignment[$embedded,$argumentContext] )* ) | singleTemplateArg[$embedded,$argumentContext] )
+			int alt13=2;
+			int LA13_0 = input.LA(1);
+
+			if ( (LA13_0==ARGS) )
+			{
+				alt13=1;
+			}
+			else if ( (LA13_0==SINGLEVALUEARG) )
+			{
+				alt13=2;
+			}
+			else
+			{
+				NoViableAltException nvae = new NoViableAltException("", 13, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt13 )
+			{
+			case 1:
+				// Language\\ActionEvaluator.g3:319:4: ^( ARGS ( argumentAssignment[$embedded,$argumentContext] )* )
+				{
+				Match(input,ARGS,Follow._ARGS_in_argList808);
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null);
+					// Language\\ActionEvaluator.g3:319:12: ( argumentAssignment[$embedded,$argumentContext] )*
+					for ( ; ; )
+					{
+						int alt12=2;
+						int LA12_0 = input.LA(1);
+
+						if ( (LA12_0==ASSIGN||LA12_0==DOTDOTDOT) )
+						{
+							alt12=1;
+						}
+
+
+						switch ( alt12 )
+						{
+						case 1:
+							// Language\\ActionEvaluator.g3:319:13: argumentAssignment[$embedded,$argumentContext]
+							{
+							PushFollow(Follow._argumentAssignment_in_argList811);
+							argumentAssignment(embedded, argumentContext);
+
+							state._fsp--;
+
+
+							}
+							break;
+
+						default:
+							goto loop12;
+						}
+					}
+
+					loop12:
+						;
+
+
+
+					Match(input, TokenConstants.UP, null);
+				}
+
+				}
+				break;
+			case 2:
+				// Language\\ActionEvaluator.g3:320:4: singleTemplateArg[$embedded,$argumentContext]
+				{
+				PushFollow(Follow._singleTemplateArg_in_argList821);
+				singleTemplateArg(embedded, argumentContext);
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return argumentContext;
+	}
+	// $ANTLR end "argList"
+
+
+	// $ANTLR start "singleTemplateArg"
+	// Language\\ActionEvaluator.g3:323:0: singleTemplateArg[StringTemplate embedded, Map argumentContext] : ^( SINGLEVALUEARG e= expr ) ;
+	private void singleTemplateArg( StringTemplate embedded, Map argumentContext )
+	{
+		object e = default(object);
+
+		try
+		{
+			// Language\\ActionEvaluator.g3:324:4: ( ^( SINGLEVALUEARG e= expr ) )
+			// Language\\ActionEvaluator.g3:324:4: ^( SINGLEVALUEARG e= expr )
+			{
+			Match(input,SINGLEVALUEARG,Follow._SINGLEVALUEARG_in_singleTemplateArg836);
+
+			Match(input, TokenConstants.DOWN, null);
+			PushFollow(Follow._expr_in_singleTemplateArg840);
+			e=expr();
+
+			state._fsp--;
+
+
+			Match(input, TokenConstants.UP, null);
+
+						if ( e!=null )
+						{
+							string soleArgName = null;
+							// find the sole defined formal argument for embedded
+							bool error = false;
+							var formalArgs = embedded.getFormalArguments();
+							if ( formalArgs!=null )
+							{
+								var argNames = formalArgs.Select( fa => fa.name ).ToArray();
+								if ( argNames.Length==1 )
+								{
+									soleArgName = (string)argNames.ToArray()[0];
+									//System.out.println("sole formal arg of "+embedded.getName()+" is "+soleArgName);
+								}
+								else
+								{
+									error=true;
+								}
+							}
+							else
+							{
+								error=true;
+							}
+							if ( error )
+							{
+								self.error("template "+embedded.getName()+
+										   " must have exactly one formal arg in template context "+
+										   self.getEnclosingInstanceStackString());
+							}
+							else
+							{
+								self.rawSetArgumentAttribute(embedded,argumentContext,soleArgName,e);
+							}
+						}
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "singleTemplateArg"
+
+
+	// $ANTLR start "argumentAssignment"
+	// Language\\ActionEvaluator.g3:363:0: argumentAssignment[StringTemplate embedded, Map argumentContext] : ( ^( ASSIGN arg= ID expr ) | DOTDOTDOT );
+	private void argumentAssignment( StringTemplate embedded, Map argumentContext )
+	{
+		StringTemplateAST arg=null;
+		object expr11 = default(object);
+
+		try
+		{
+			// Language\\ActionEvaluator.g3:364:4: ( ^( ASSIGN arg= ID expr ) | DOTDOTDOT )
+			int alt14=2;
+			int LA14_0 = input.LA(1);
+
+			if ( (LA14_0==ASSIGN) )
+			{
+				alt14=1;
+			}
+			else if ( (LA14_0==DOTDOTDOT) )
+			{
+				alt14=2;
+			}
+			else
+			{
+				NoViableAltException nvae = new NoViableAltException("", 14, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt14 )
+			{
+			case 1:
+				// Language\\ActionEvaluator.g3:364:4: ^( ASSIGN arg= ID expr )
+				{
+				Match(input,ASSIGN,Follow._ASSIGN_in_argumentAssignment860);
+
+				Match(input, TokenConstants.DOWN, null);
+				arg=(StringTemplateAST)Match(input,ID,Follow._ID_in_argumentAssignment864);
+				PushFollow(Follow._expr_in_argumentAssignment866);
+				expr11=expr();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+							if ( expr11 != null )
+							{
+								self.rawSetArgumentAttribute(embedded,argumentContext,(arg!=null?arg.Text:null),expr11);
+							}
+
+
+				}
+				break;
+			case 2:
+				// Language\\ActionEvaluator.g3:371:4: DOTDOTDOT
+				{
+				Match(input,DOTDOTDOT,Follow._DOTDOTDOT_in_argumentAssignment877);
+				embedded.setPassThroughAttributes(true);
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "argumentAssignment"
+	#endregion
+
+	// Delegated rules
+
+	#region Synpreds
+	#endregion
+
+	#region DFA
+
+	protected override void InitDFAs()
+	{
+		base.InitDFAs();
+	}
+
+	#endregion
+
+	#region Follow Sets
+	public static class Follow
+	{
+		public static readonly BitSet _expr_in_action56 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _PLUS_in_expr79 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _expr_in_expr83 = new BitSet(new ulong[]{0x2422BC830UL});
+		public static readonly BitSet _expr_in_expr87 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _templateApplication_in_expr95 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _attribute_in_expr102 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _templateInclude_in_expr109 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _function_in_expr116 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _list_in_expr123 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _VALUE_in_expr131 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _expr_in_expr135 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _LIST_in_list167 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _expr_in_list174 = new BitSet(new ulong[]{0x2432BC838UL});
+		public static readonly BitSet _NOTHING_in_list187 = new BitSet(new ulong[]{0x2432BC838UL});
+		public static readonly BitSet _INCLUDE_in_templateInclude229 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_templateInclude242 = new BitSet(new ulong[]{0xFFFFFFFFFF0UL});
+		public static readonly BitSet _VALUE_in_templateInclude262 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _expr_in_templateInclude266 = new BitSet(new ulong[]{0xFFFFFFFFFF0UL});
+		public static readonly BitSet _APPLY_in_templateApplication316 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _expr_in_templateApplication320 = new BitSet(new ulong[]{0x80000000UL});
+		public static readonly BitSet _template_in_templateApplication326 = new BitSet(new ulong[]{0x80000008UL});
+		public static readonly BitSet _MULTI_APPLY_in_templateApplication345 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _expr_in_templateApplication350 = new BitSet(new ulong[]{0x2422BC930UL});
+		public static readonly BitSet _COLON_in_templateApplication357 = new BitSet(new ulong[]{0x10UL});
+		public static readonly BitSet _ANONYMOUS_TEMPLATE_in_templateApplication364 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _FUNCTION_in_function390 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _37_in_function397 = new BitSet(new ulong[]{0x20000000UL});
+		public static readonly BitSet _singleFunctionArg_in_function402 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _40_in_function411 = new BitSet(new ulong[]{0x20000000UL});
+		public static readonly BitSet _singleFunctionArg_in_function416 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _38_in_function425 = new BitSet(new ulong[]{0x20000000UL});
+		public static readonly BitSet _singleFunctionArg_in_function430 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _39_in_function439 = new BitSet(new ulong[]{0x20000000UL});
+		public static readonly BitSet _singleFunctionArg_in_function443 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _41_in_function452 = new BitSet(new ulong[]{0x20000000UL});
+		public static readonly BitSet _singleFunctionArg_in_function457 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _43_in_function466 = new BitSet(new ulong[]{0x20000000UL});
+		public static readonly BitSet _singleFunctionArg_in_function471 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _SINGLEVALUEARG_in_singleFunctionArg499 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _expr_in_singleFunctionArg501 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _TEMPLATE_in_template524 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_template531 = new BitSet(new ulong[]{0xFFFFFFFFFF0UL});
+		public static readonly BitSet _ANONYMOUS_TEMPLATE_in_template552 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _VALUE_in_template568 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _expr_in_template572 = new BitSet(new ulong[]{0xFFFFFFFFFF0UL});
+		public static readonly BitSet _ifAtom_in_ifCondition617 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _NOT_in_ifCondition625 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ifAtom_in_ifCondition629 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _expr_in_ifAtom647 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _DOT_in_attribute671 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _expr_in_attribute675 = new BitSet(new ulong[]{0x200008000UL});
+		public static readonly BitSet _ID_in_attribute684 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _VALUE_in_attribute714 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _expr_in_attribute718 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ID_in_attribute742 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _INT_in_attribute754 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _STRING_in_attribute764 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ANONYMOUS_TEMPLATE_in_attribute776 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ARGS_in_argList808 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _argumentAssignment_in_argList811 = new BitSet(new ulong[]{0x1088UL});
+		public static readonly BitSet _singleTemplateArg_in_argList821 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _SINGLEVALUEARG_in_singleTemplateArg836 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _expr_in_singleTemplateArg840 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ASSIGN_in_argumentAssignment860 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_argumentAssignment864 = new BitSet(new ulong[]{0x2422BC830UL});
+		public static readonly BitSet _expr_in_argumentAssignment866 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _DOTDOTDOT_in_argumentAssignment877 = new BitSet(new ulong[]{0x2UL});
+
+	}
+	#endregion
+}
+
+} // namespace Antlr3.ST.Language
diff --git a/Antlr3.StringTemplate/Language/ActionEvaluator.g3 b/Antlr3.StringTemplate/Language/ActionEvaluator.g3
new file mode 100644
index 0000000..90f58ae
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/ActionEvaluator.g3
@@ -0,0 +1,372 @@
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+tree grammar ActionEvaluator;
+
+options
+{
+	language=CSharp3;
+	tokenVocab=Action;
+	ASTLabelType=StringTemplateAST;
+}
+
+@header
+{
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+using System.Linq;
+using Antlr.Runtime.JavaExtensions;
+
+using Map = System.Collections.IDictionary;
+using Set = System.Collections.Generic.HashSet<object>;
+using StringWriter = System.IO.StringWriter;
+using Vector = System.Collections.Generic.List<object>;
+}
+
+@namespace {Antlr3.ST.Language}
+
+public
+action returns [int numCharsWritten=0]
+	:	expr {$numCharsWritten = chunk.writeAttribute(self,$expr.value,writer);}
+	;
+
+expr returns [object value]
+@init
+{
+	Map argumentContext=null;
+	$value = null;
+}
+	:	^(PLUS a=expr b=expr {$value = chunk.Add($a.value,$b.value);})
+	|	templateApplication {$value = $templateApplication.value;}
+	|	attribute {$value = $attribute.value;}
+	|	templateInclude {$value = $templateInclude.value;}
+	|	function {$value = $function.value;}
+	|	list {$value = $list.value;}
+	|	^(VALUE e=expr)
+		// convert to string (force early eval)
+		{
+			StringWriter buf = new StringWriter();
+			IStringTemplateWriter sw = self.getGroup().getStringTemplateWriter(buf);
+			int n = chunk.writeAttribute(self,$e.value,sw);
+			if ( n > 0 )
+			{
+				$value = buf.ToString();
+			}
+		}
+	;
+
+/** create a new list of expressions as a new multi-value attribute */
+list returns [object value=null]
+@init
+{
+	List elements = new ArrayList();
+}
+	:	^(	LIST
+			(	expr
+				{
+					if ( $expr.value!=null )
+					{
+						elements.Add($expr.value);
+					}
+				}
+			|	NOTHING
+				{
+					List nullSingleton = new ArrayList( new object[] {null} );
+					elements.Add(nullSingleton.iterator()); // add a blank
+				}
+			)+
+		)
+		{$value = new Cat(elements);}
+	;
+
+templateInclude returns [object value=null]
+@init
+{
+	StringTemplateAST args = null;
+	string name = null;
+}
+	:	^(	INCLUDE
+			//{value = chunk.getTemplateInclude(self, name.getText(), #args);}
+			(	id=ID a1=.
+				{name=$id.text; args=$a1;}
+
+			|	^( VALUE n=expr a2=. )
+				{if ($n.value!=null) {name=$n.value.ToString();} args=$a2;}
+
+			)
+		)
+		{
+			if ( name!=null )
+			{
+				$value = chunk.getTemplateInclude(self, name, args);
+			}
+		}
+	;
+
+/** Apply template(s) to an attribute; can be applied to another apply
+ *  result.
+ */
+templateApplication returns [object value]
+@init
+{
+	var templatesToApply = new System.Collections.Generic.List<StringTemplate>();
+	List attributes = new ArrayList();
+}
+	:	^(	APPLY a=expr
+			(template[templatesToApply])+
+			{$value = chunk.applyListOfAlternatingTemplates(self,$a.value,templatesToApply);}
+		)
+	|	^(	MULTI_APPLY (a=expr {attributes.Add($a.value);} )+ COLON
+			anon=ANONYMOUS_TEMPLATE
+			{
+				StringTemplate anonymous = $anon.StringTemplate;
+				templatesToApply.Add(anonymous);
+				$value = chunk.applyTemplateToListOfAttributes(self,
+															  attributes,
+															  $anon.StringTemplate);
+			}
+		)
+	;
+
+function returns [object value]
+	:	^(	FUNCTION
+			(	'first'		a=singleFunctionArg	{$value=chunk.first($a.value);}
+			|	'rest'		a=singleFunctionArg	{$value=chunk.rest($a.value);}
+			|	'last'		a=singleFunctionArg	{$value=chunk.last($a.value);}
+			|	'length'	a=singleFunctionArg	{$value=chunk.length($a.value);}
+			|	'strip'		a=singleFunctionArg	{$value=chunk.strip($a.value);}
+			|	'trunc'		a=singleFunctionArg	{$value=chunk.trunc($a.value);}
+			)
+		)
+	;
+
+singleFunctionArg returns [object value=null]
+	:	^( SINGLEVALUEARG expr {$value = $expr.value;} )
+	;
+
+template[System.Collections.Generic.List<StringTemplate> templatesToApply]
+@init
+{
+	Map argumentContext = null;
+}
+	:	^(	TEMPLATE
+			(	ID args=. // don't eval argList now; must re-eval each iteration
+				{
+					string templateName = $ID.text;
+					StringTemplateGroup group = self.getGroup();
+					StringTemplate embedded = group.getEmbeddedInstanceOf(self, templateName);
+					if ( embedded!=null )
+					{
+						embedded.setArgumentsAST($args);
+						$templatesToApply.Add(embedded);
+					}
+				}
+
+			|	anon=ANONYMOUS_TEMPLATE
+				{
+					StringTemplate anonymous = $anon.StringTemplate;
+					// to properly see overridden templates, always set
+					// anonymous' group to be self's group
+					anonymous.setGroup(self.getGroup());
+					$templatesToApply.Add(anonymous);
+				}
+
+			|	^(	VALUE n=expr args2=.
+					{
+						StringTemplate embedded = null;
+						if ( $n.value!=null )
+						{
+							string templateName = $n.value.ToString();
+							StringTemplateGroup group = self.getGroup();
+							embedded = group.getEmbeddedInstanceOf(self, templateName);
+							if ( embedded!=null )
+							{
+								embedded.setArgumentsAST($args2);
+								$templatesToApply.Add(embedded);
+							}
+						}
+					}
+				)
+			)
+		)
+	;
+
+public
+ifCondition returns [bool value]
+	:	a=ifAtom {$value = chunk.testAttributeTrue($a.value);}
+	|	^(NOT a=ifAtom) {$value = !chunk.testAttributeTrue($a.value);}
+	;
+
+ifAtom returns [object value]
+	:	expr {$value = $expr.value;}
+	;
+
+attribute returns [object value]
+@init
+{
+	object propName = null;
+}
+	:	^(	DOT obj=expr
+			(	prop=ID {propName = $prop.text;}
+				// don't force early eval here in case it's a map
+				// we need the right type on the key.
+				// E.g., <aMap.keys:{k|<k>:<aMap.(k)>}>
+				// If aMap has Integer keys, can't convert k to string then lookup.
+			|	^(VALUE e=expr) {if ($e.value!=null) {propName=$e.value;}}
+			)
+		)
+		{$value = chunk.getObjectProperty(self,$obj.value,propName);}
+
+	|	i3=ID
+		{
+		$value=self.getAttribute($i3.text);
+		}
+
+	|	i=INT {$value=int.Parse($i.text);}
+
+	|	s=STRING
+		{
+		$value=$s.text;
+		}
+
+	|	at=ANONYMOUS_TEMPLATE
+		{
+			$value=$at.text;
+			if ( $at.text!=null )
+			{
+				StringTemplate valueST =new StringTemplate(self.getGroup(), $at.text);
+				valueST.setEnclosingInstance(self);
+				valueST.setName("<anonymous template argument>");
+				$value = valueST;
+			}
+		}
+	;
+
+/** self is assumed to be the enclosing context as foo(x=y) must find y in
+ *  the template that encloses the ref to foo(x=y).  We must pass in
+ *  the embedded template (the one invoked) so we can check formal args
+ *  in rawSetArgumentAttribute.
+ */
+public
+argList[StringTemplate embedded, System.Collections.Generic.Dictionary<string, object> initialContext]
+	returns [System.Collections.Generic.Dictionary<string, object> argumentContext=null]
+@init
+{
+	$argumentContext = $initialContext;
+	if ( $argumentContext==null )
+	{
+		$argumentContext=new System.Collections.Generic.Dictionary<string, object>();
+	}
+}
+	:	^( ARGS (argumentAssignment[$embedded,$argumentContext])* )
+	|	singleTemplateArg[$embedded,$argumentContext]
+	;
+
+singleTemplateArg[StringTemplate embedded, Map argumentContext]
+	:	^( SINGLEVALUEARG e=expr )
+		{
+			if ( $e.value!=null )
+			{
+				string soleArgName = null;
+				// find the sole defined formal argument for embedded
+				bool error = false;
+				var formalArgs = $embedded.getFormalArguments();
+				if ( formalArgs!=null )
+				{
+					var argNames = formalArgs.Select( fa => fa.name ).ToArray();
+					if ( argNames.Length==1 )
+					{
+						soleArgName = (string)argNames.ToArray()[0];
+						//System.out.println("sole formal arg of "+$embedded.getName()+" is "+soleArgName);
+					}
+					else
+					{
+						error=true;
+					}
+				}
+				else
+				{
+					error=true;
+				}
+				if ( error )
+				{
+					self.error("template "+$embedded.getName()+
+							   " must have exactly one formal arg in template context "+
+							   self.getEnclosingInstanceStackString());
+				}
+				else
+				{
+					self.rawSetArgumentAttribute($embedded,$argumentContext,soleArgName,$e.value);
+				}
+			}
+		}
+	;
+
+argumentAssignment[StringTemplate embedded, Map argumentContext]
+	:	^( ASSIGN arg=ID expr )
+		{
+			if ( $expr.value != null )
+			{
+				self.rawSetArgumentAttribute($embedded,$argumentContext,$arg.text,$expr.value);
+			}
+		}
+	|	DOTDOTDOT {$embedded.setPassThroughAttributes(true);}
+	;
diff --git a/Antlr3.StringTemplate/Language/ActionEvaluatorHelper.cs b/Antlr3.StringTemplate/Language/ActionEvaluatorHelper.cs
new file mode 100644
index 0000000..e20a95a
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/ActionEvaluatorHelper.cs
@@ -0,0 +1,65 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Grammar conversion to ANTLR v3 and C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *	notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	notice, this list of conditions and the following disclaimer in the
+ *	documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *	derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST.Language
+{
+    using Antlr.Runtime;
+    using Antlr.Runtime.Tree;
+
+
+    partial class ActionEvaluator
+    {
+        public class NameValuePair
+        {
+            public string name;
+            public object value;
+        }
+
+        protected StringTemplate self = null;
+        protected IStringTemplateWriter writer = null;
+        protected ASTExpr chunk = null;
+
+        public ActionEvaluator( StringTemplate self, ASTExpr chunk, IStringTemplateWriter writer, ITree input )
+            : base( new CommonTreeNodeStream( new StringTemplateTreeAdaptor(), input ) )
+        {
+            this.self = self;
+            this.chunk = chunk;
+            this.writer = writer;
+        }
+
+        public override void ReportError( RecognitionException e )
+        {
+            self.error( "eval tree parse error", e );
+        }
+    }
+
+}
diff --git a/Antlr3.StringTemplate/Language/ActionLexer.cs b/Antlr3.StringTemplate/Language/ActionLexer.cs
new file mode 100644
index 0000000..c0c5dc0
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/ActionLexer.cs
@@ -0,0 +1,2614 @@
+// $ANTLR 3.1.2 Language\\Action.g3 2009-03-15 17:10:10
+
+// The variable 'variable' is assigned but its value is never used.
+#pragma warning disable 219
+// Unreachable code detected.
+#pragma warning disable 162
+
+
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+using System.Collections.Generic;
+using Antlr.Runtime;
+using Stack = System.Collections.Generic.Stack<object>;
+using List = System.Collections.IList;
+using ArrayList = System.Collections.Generic.List<object>;
+using Map = System.Collections.IDictionary;
+using HashMap = System.Collections.Generic.Dictionary<object, object>;
+namespace  Antlr3.ST.Language
+{
+public partial class ActionLexer : Lexer
+{
+	public const int EOF=-1;
+	public const int T__36=36;
+	public const int T__37=37;
+	public const int T__38=38;
+	public const int T__39=39;
+	public const int T__40=40;
+	public const int T__41=41;
+	public const int T__42=42;
+	public const int T__43=43;
+	public const int ANONYMOUS_TEMPLATE=4;
+	public const int APPLY=5;
+	public const int ARGS=6;
+	public const int ASSIGN=7;
+	public const int COLON=8;
+	public const int COMMA=9;
+	public const int CONDITIONAL=10;
+	public const int DOT=11;
+	public const int DOTDOTDOT=12;
+	public const int ESC_CHAR=13;
+	public const int FUNCTION=14;
+	public const int ID=15;
+	public const int INCLUDE=16;
+	public const int INT=17;
+	public const int LBRACK=18;
+	public const int LIST=19;
+	public const int LPAREN=20;
+	public const int MULTI_APPLY=21;
+	public const int NESTED_ANONYMOUS_TEMPLATE=22;
+	public const int NOT=23;
+	public const int NOTHING=24;
+	public const int PLUS=25;
+	public const int RBRACK=26;
+	public const int RPAREN=27;
+	public const int SEMI=28;
+	public const int SINGLEVALUEARG=29;
+	public const int STRING=30;
+	public const int TEMPLATE=31;
+	public const int TEMPLATE_ARGS=32;
+	public const int VALUE=33;
+	public const int WS=34;
+	public const int WS_CHAR=35;
+
+    // delegates
+    // delegators
+
+	public ActionLexer() {}
+	public ActionLexer( ICharStream input )
+		: this( input, new RecognizerSharedState() )
+	{
+	}
+	public ActionLexer( ICharStream input, RecognizerSharedState state )
+		: base( input, state )
+	{
+
+	}
+	public override string GrammarFileName { get { return "Language\\Action.g3"; } }
+
+	// $ANTLR start "CONDITIONAL"
+	private void mCONDITIONAL()
+	{
+		try
+		{
+			int _type = CONDITIONAL;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Action.g3:42:15: ( 'if' )
+			// Language\\Action.g3:42:15: 'if'
+			{
+			Match("if"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "CONDITIONAL"
+
+	// $ANTLR start "T__36"
+	private void mT__36()
+	{
+		try
+		{
+			int _type = T__36;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Action.g3:43:9: ( 'elseif' )
+			// Language\\Action.g3:43:9: 'elseif'
+			{
+			Match("elseif"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "T__36"
+
+	// $ANTLR start "T__37"
+	private void mT__37()
+	{
+		try
+		{
+			int _type = T__37;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Action.g3:44:9: ( 'first' )
+			// Language\\Action.g3:44:9: 'first'
+			{
+			Match("first"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "T__37"
+
+	// $ANTLR start "T__38"
+	private void mT__38()
+	{
+		try
+		{
+			int _type = T__38;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Action.g3:45:9: ( 'last' )
+			// Language\\Action.g3:45:9: 'last'
+			{
+			Match("last"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "T__38"
+
+	// $ANTLR start "T__39"
+	private void mT__39()
+	{
+		try
+		{
+			int _type = T__39;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Action.g3:46:9: ( 'length' )
+			// Language\\Action.g3:46:9: 'length'
+			{
+			Match("length"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "T__39"
+
+	// $ANTLR start "T__40"
+	private void mT__40()
+	{
+		try
+		{
+			int _type = T__40;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Action.g3:47:9: ( 'rest' )
+			// Language\\Action.g3:47:9: 'rest'
+			{
+			Match("rest"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "T__40"
+
+	// $ANTLR start "T__41"
+	private void mT__41()
+	{
+		try
+		{
+			int _type = T__41;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Action.g3:48:9: ( 'strip' )
+			// Language\\Action.g3:48:9: 'strip'
+			{
+			Match("strip"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "T__41"
+
+	// $ANTLR start "T__42"
+	private void mT__42()
+	{
+		try
+		{
+			int _type = T__42;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Action.g3:49:9: ( 'super' )
+			// Language\\Action.g3:49:9: 'super'
+			{
+			Match("super"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "T__42"
+
+	// $ANTLR start "T__43"
+	private void mT__43()
+	{
+		try
+		{
+			int _type = T__43;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Action.g3:50:9: ( 'trunc' )
+			// Language\\Action.g3:50:9: 'trunc'
+			{
+			Match("trunc"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "T__43"
+
+	// $ANTLR start "ID"
+	private void mID()
+	{
+		try
+		{
+			int _type = ID;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Action.g3:325:4: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' | '/' )* )
+			// Language\\Action.g3:325:4: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' | '/' )*
+			{
+			if ( (input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z') )
+			{
+				input.Consume();
+			state.failed=false;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				Recover(mse);
+				throw mse;}
+
+			// Language\\Action.g3:325:28: ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' | '/' )*
+			for ( ; ; )
+			{
+				int alt1=2;
+				int LA1_0 = input.LA(1);
+
+				if ( ((LA1_0>='/' && LA1_0<='9')||(LA1_0>='A' && LA1_0<='Z')||LA1_0=='_'||(LA1_0>='a' && LA1_0<='z')) )
+				{
+					alt1=1;
+				}
+
+
+				switch ( alt1 )
+				{
+				case 1:
+					// Language\\Action.g3:
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+
+				default:
+					goto loop1;
+				}
+			}
+
+			loop1:
+				;
+
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ID"
+
+	// $ANTLR start "INT"
+	private void mINT()
+	{
+		try
+		{
+			int _type = INT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Action.g3:329:4: ( ( '0' .. '9' )+ )
+			// Language\\Action.g3:329:4: ( '0' .. '9' )+
+			{
+			// Language\\Action.g3:329:4: ( '0' .. '9' )+
+			int cnt2=0;
+			for ( ; ; )
+			{
+				int alt2=2;
+				int LA2_0 = input.LA(1);
+
+				if ( ((LA2_0>='0' && LA2_0<='9')) )
+				{
+					alt2=1;
+				}
+
+
+				switch ( alt2 )
+				{
+				case 1:
+					// Language\\Action.g3:
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+
+				default:
+					if ( cnt2 >= 1 )
+						goto loop2;
+
+					if (state.backtracking>0) {state.failed=true; return ;}
+					EarlyExitException eee2 = new EarlyExitException( 2, input );
+					throw eee2;
+				}
+				cnt2++;
+			}
+			loop2:
+				;
+
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "INT"
+
+	// $ANTLR start "STRING"
+	private void mSTRING()
+	{
+		try
+		{
+			int _type = STRING;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			int ch;
+
+
+				char uc = '\0';
+				System.Text.StringBuilder builder = new System.Text.StringBuilder();
+
+			// Language\\Action.g3:338:4: ( '\"' ( ESC_CHAR[out uc, true] |ch=~ ( '\\\\' | '\"' ) )* '\"' )
+			// Language\\Action.g3:338:4: '\"' ( ESC_CHAR[out uc, true] |ch=~ ( '\\\\' | '\"' ) )* '\"'
+			{
+			Match('\"'); if (state.failed) return ;
+			// Language\\Action.g3:339:3: ( ESC_CHAR[out uc, true] |ch=~ ( '\\\\' | '\"' ) )*
+			for ( ; ; )
+			{
+				int alt3=3;
+				int LA3_0 = input.LA(1);
+
+				if ( (LA3_0=='\\') )
+				{
+					alt3=1;
+				}
+				else if ( ((LA3_0>='\u0000' && LA3_0<='!')||(LA3_0>='#' && LA3_0<='[')||(LA3_0>=']' && LA3_0<='\uFFFF')) )
+				{
+					alt3=2;
+				}
+
+
+				switch ( alt3 )
+				{
+				case 1:
+					// Language\\Action.g3:339:5: ESC_CHAR[out uc, true]
+					{
+					mESC_CHAR(out uc, true); if (state.failed) return ;
+					if ( state.backtracking == 0 )
+					{
+						builder.Append(uc);
+					}
+
+					}
+					break;
+				case 2:
+					// Language\\Action.g3:340:5: ch=~ ( '\\\\' | '\"' )
+					{
+					ch= input.LA(1);
+					input.Consume();
+					state.failed=false;
+					if ( state.backtracking == 0 )
+					{
+						builder.Append((char)ch);
+					}
+
+					}
+					break;
+
+				default:
+					goto loop3;
+				}
+			}
+
+			loop3:
+				;
+
+
+			Match('\"'); if (state.failed) return ;
+			if ( state.backtracking == 0 )
+			{
+
+							Text = builder.ToString();
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "STRING"
+
+	// $ANTLR start "ANONYMOUS_TEMPLATE"
+	private void mANONYMOUS_TEMPLATE()
+	{
+		try
+		{
+			int _type = ANONYMOUS_TEMPLATE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken ESC_CHAR1=null;
+			int ch;
+
+
+				StringTemplateToken t = null;
+				System.Text.StringBuilder builder = new System.Text.StringBuilder();
+				List args = new ArrayList();
+				string subtext = string.Empty;
+				char uc = '\0';
+
+			// Language\\Action.g3:357:4: ( '{' (=> TEMPLATE_ARGS[out subtext, args] (=> WS_CHAR )? |) (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '\\\\' | '{' | '}' ) )* '}' )
+			// Language\\Action.g3:357:4: '{' (=> TEMPLATE_ARGS[out subtext, args] (=> WS_CHAR )? |) (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '\\\\' | '{' | '}' ) )* '}'
+			{
+			Match('{'); if (state.failed) return ;
+			// Language\\Action.g3:358:3: (=> TEMPLATE_ARGS[out subtext, args] (=> WS_CHAR )? |)
+			int alt5=2;
+			alt5 = dfa5.Predict(input);
+			switch ( alt5 )
+			{
+			case 1:
+				// Language\\Action.g3:358:5: => TEMPLATE_ARGS[out subtext, args] (=> WS_CHAR )?
+				{
+
+				mTEMPLATE_ARGS(out subtext, args); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+					builder.Append(subtext);
+				}
+				// Language\\Action.g3:358:82: (=> WS_CHAR )?
+				int alt4=2;
+				int LA4_0 = input.LA(1);
+
+				if ( ((LA4_0>='\t' && LA4_0<='\n')||LA4_0=='\r'||LA4_0==' ') )
+				{
+					int LA4_1 = input.LA(2);
+
+					if ( (synpred2_Action()) )
+					{
+						alt4=1;
+					}
+				}
+				switch ( alt4 )
+				{
+				case 1:
+					// Language\\Action.g3:358:83: => WS_CHAR
+					{
+
+					mWS_CHAR(); if (state.failed) return ;
+
+					}
+					break;
+
+				}
+
+				if ( state.backtracking == 0 )
+				{
+
+									// create a special token to track args
+									t = new StringTemplateToken(ANONYMOUS_TEMPLATE,Text,args);
+									//setToken(t);
+									state.token = t;
+
+				}
+
+				}
+				break;
+			case 2:
+				// Language\\Action.g3:366:3:
+				{
+
+
+				}
+				break;
+
+			}
+
+			// Language\\Action.g3:367:3: (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '\\\\' | '{' | '}' ) )*
+			for ( ; ; )
+			{
+				int alt6=6;
+				alt6 = dfa6.Predict(input);
+				switch ( alt6 )
+				{
+				case 1:
+					// Language\\Action.g3:367:5: => '\\\\{'
+					{
+
+					Match("\\{"); if (state.failed) return ;
+
+					if ( state.backtracking == 0 )
+					{
+						builder.Append( '{' );
+					}
+
+					}
+					break;
+				case 2:
+					// Language\\Action.g3:368:5: => '\\\\}'
+					{
+
+					Match("\\}"); if (state.failed) return ;
+
+					if ( state.backtracking == 0 )
+					{
+						builder.Append( '}' );
+					}
+
+					}
+					break;
+				case 3:
+					// Language\\Action.g3:369:5: ESC_CHAR[out uc, false]
+					{
+					int ESC_CHAR1Start300 = GetCharIndex();
+					mESC_CHAR(out uc, false); if (state.failed) return ;
+					ESC_CHAR1 = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, ESC_CHAR1Start300, GetCharIndex()-1);
+					if ( state.backtracking == 0 )
+					{
+						builder.Append( (ESC_CHAR1!=null?ESC_CHAR1.Text:null) );
+					}
+
+					}
+					break;
+				case 4:
+					// Language\\Action.g3:370:5: NESTED_ANONYMOUS_TEMPLATE[out subtext]
+					{
+					mNESTED_ANONYMOUS_TEMPLATE(out subtext); if (state.failed) return ;
+					if ( state.backtracking == 0 )
+					{
+						builder.Append(subtext);
+					}
+
+					}
+					break;
+				case 5:
+					// Language\\Action.g3:371:5: ch=~ ( '\\\\' | '{' | '}' )
+					{
+					ch= input.LA(1);
+					input.Consume();
+					state.failed=false;
+					if ( state.backtracking == 0 )
+					{
+						builder.Append((char)ch);
+					}
+
+					}
+					break;
+
+				default:
+					goto loop6;
+				}
+			}
+
+			loop6:
+				;
+
+
+			if ( state.backtracking == 0 )
+			{
+
+							Text = builder.ToString();
+							if ( t!=null )
+								t.Text = Text;
+
+			}
+			Match('}'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ANONYMOUS_TEMPLATE"
+
+	// $ANTLR start "TEMPLATE_ARGS"
+	private void mTEMPLATE_ARGS(out string _text, List args)
+	{
+		try
+		{
+			IToken a=null;
+			IToken a2=null;
+
+
+				_text = string.Empty; // this template is empty text
+				args.Clear();
+
+			// Language\\Action.g3:389:4: ( ( WS_CHAR )? a= ID ( ( WS_CHAR )? ',' ( WS_CHAR )? a2= ID )* ( WS_CHAR )? '|' )
+			// Language\\Action.g3:389:4: ( WS_CHAR )? a= ID ( ( WS_CHAR )? ',' ( WS_CHAR )? a2= ID )* ( WS_CHAR )? '|'
+			{
+			// Language\\Action.g3:389:4: ( WS_CHAR )?
+			int alt7=2;
+			int LA7_0 = input.LA(1);
+
+			if ( ((LA7_0>='\t' && LA7_0<='\n')||LA7_0=='\r'||LA7_0==' ') )
+			{
+				alt7=1;
+			}
+			switch ( alt7 )
+			{
+			case 1:
+				// Language\\Action.g3:
+				{
+				input.Consume();
+				state.failed=false;
+
+				}
+				break;
+
+			}
+
+			int aStart368 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			a = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, aStart368, GetCharIndex()-1);
+			if ( state.backtracking == 0 )
+			{
+				args.Add((a!=null?a.Text:null));
+			}
+			// Language\\Action.g3:390:3: ( ( WS_CHAR )? ',' ( WS_CHAR )? a2= ID )*
+			for ( ; ; )
+			{
+				int alt10=2;
+				int LA10_0 = input.LA(1);
+
+				if ( ((LA10_0>='\t' && LA10_0<='\n')||LA10_0=='\r'||LA10_0==' ') )
+				{
+					int LA10_1 = input.LA(2);
+
+					if ( (LA10_1==',') )
+					{
+						alt10=1;
+					}
+
+
+				}
+				else if ( (LA10_0==',') )
+				{
+					alt10=1;
+				}
+
+
+				switch ( alt10 )
+				{
+				case 1:
+					// Language\\Action.g3:390:5: ( WS_CHAR )? ',' ( WS_CHAR )? a2= ID
+					{
+					// Language\\Action.g3:390:5: ( WS_CHAR )?
+					int alt8=2;
+					int LA8_0 = input.LA(1);
+
+					if ( ((LA8_0>='\t' && LA8_0<='\n')||LA8_0=='\r'||LA8_0==' ') )
+					{
+						alt8=1;
+					}
+					switch ( alt8 )
+					{
+					case 1:
+						// Language\\Action.g3:
+						{
+						input.Consume();
+						state.failed=false;
+
+						}
+						break;
+
+					}
+
+					Match(','); if (state.failed) return ;
+					// Language\\Action.g3:390:20: ( WS_CHAR )?
+					int alt9=2;
+					int LA9_0 = input.LA(1);
+
+					if ( ((LA9_0>='\t' && LA9_0<='\n')||LA9_0=='\r'||LA9_0==' ') )
+					{
+						alt9=1;
+					}
+					switch ( alt9 )
+					{
+					case 1:
+						// Language\\Action.g3:
+						{
+						input.Consume();
+						state.failed=false;
+
+						}
+						break;
+
+					}
+
+					int a2Start390 = GetCharIndex();
+					mID(); if (state.failed) return ;
+					a2 = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, a2Start390, GetCharIndex()-1);
+					if ( state.backtracking == 0 )
+					{
+						args.Add((a2!=null?a2.Text:null));
+					}
+
+					}
+					break;
+
+				default:
+					goto loop10;
+				}
+			}
+
+			loop10:
+				;
+
+
+			// Language\\Action.g3:391:3: ( WS_CHAR )?
+			int alt11=2;
+			int LA11_0 = input.LA(1);
+
+			if ( ((LA11_0>='\t' && LA11_0<='\n')||LA11_0=='\r'||LA11_0==' ') )
+			{
+				alt11=1;
+			}
+			switch ( alt11 )
+			{
+			case 1:
+				// Language\\Action.g3:
+				{
+				input.Consume();
+				state.failed=false;
+
+				}
+				break;
+
+			}
+
+			Match('|'); if (state.failed) return ;
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "TEMPLATE_ARGS"
+
+	// $ANTLR start "NESTED_ANONYMOUS_TEMPLATE"
+	private void mNESTED_ANONYMOUS_TEMPLATE(out string _text)
+	{
+		try
+		{
+			IToken ESC_CHAR2=null;
+			int ch;
+
+
+				_text = string.Empty;
+				char uc = '\0';
+				string subtext = string.Empty;
+				System.Text.StringBuilder builder = new System.Text.StringBuilder();
+
+			// Language\\Action.g3:403:4: ( '{' (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '{' | '}' | '\\\\' ) )* '}' )
+			// Language\\Action.g3:403:4: '{' (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '{' | '}' | '\\\\' ) )* '}'
+			{
+			Match('{'); if (state.failed) return ;
+			if ( state.backtracking == 0 )
+			{
+				builder.Append('{');
+			}
+			// Language\\Action.g3:405:3: (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '{' | '}' | '\\\\' ) )*
+			for ( ; ; )
+			{
+				int alt12=6;
+				alt12 = dfa12.Predict(input);
+				switch ( alt12 )
+				{
+				case 1:
+					// Language\\Action.g3:405:5: => '\\\\{'
+					{
+
+					Match("\\{"); if (state.failed) return ;
+
+					if ( state.backtracking == 0 )
+					{
+						builder.Append('{');
+					}
+
+					}
+					break;
+				case 2:
+					// Language\\Action.g3:406:5: => '\\\\}'
+					{
+
+					Match("\\}"); if (state.failed) return ;
+
+					if ( state.backtracking == 0 )
+					{
+						builder.Append('}');
+					}
+
+					}
+					break;
+				case 3:
+					// Language\\Action.g3:407:5: ESC_CHAR[out uc, false]
+					{
+					int ESC_CHAR2Start460 = GetCharIndex();
+					mESC_CHAR(out uc, false); if (state.failed) return ;
+					ESC_CHAR2 = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, ESC_CHAR2Start460, GetCharIndex()-1);
+					if ( state.backtracking == 0 )
+					{
+						builder.Append((ESC_CHAR2!=null?ESC_CHAR2.Text:null));
+					}
+
+					}
+					break;
+				case 4:
+					// Language\\Action.g3:408:5: NESTED_ANONYMOUS_TEMPLATE[out subtext]
+					{
+					mNESTED_ANONYMOUS_TEMPLATE(out subtext); if (state.failed) return ;
+					if ( state.backtracking == 0 )
+					{
+						builder.Append(subtext);
+					}
+
+					}
+					break;
+				case 5:
+					// Language\\Action.g3:409:5: ch=~ ( '{' | '}' | '\\\\' )
+					{
+					ch= input.LA(1);
+					input.Consume();
+					state.failed=false;
+					if ( state.backtracking == 0 )
+					{
+						builder.Append((char)ch);
+					}
+
+					}
+					break;
+
+				default:
+					goto loop12;
+				}
+			}
+
+			loop12:
+				;
+
+
+			Match('}'); if (state.failed) return ;
+			if ( state.backtracking == 0 )
+			{
+
+							builder.Append('}');
+							_text = builder.ToString();
+
+			}
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "NESTED_ANONYMOUS_TEMPLATE"
+
+	// $ANTLR start "ESC_CHAR"
+	private void mESC_CHAR(out char uc, bool doEscape)
+	{
+		try
+		{
+			int c;
+
+
+				uc = '\0';
+
+			// Language\\Action.g3:430:4: ( '\\\\' ( 'n' | 'r' | 't' | 'b' | 'f' |c=~ ( 'n' | 'r' | 't' | 'b' | 'f' ) ) )
+			// Language\\Action.g3:430:4: '\\\\' ( 'n' | 'r' | 't' | 'b' | 'f' |c=~ ( 'n' | 'r' | 't' | 'b' | 'f' ) )
+			{
+			Match('\\'); if (state.failed) return ;
+			// Language\\Action.g3:431:3: ( 'n' | 'r' | 't' | 'b' | 'f' |c=~ ( 'n' | 'r' | 't' | 'b' | 'f' ) )
+			int alt13=6;
+			int LA13_0 = input.LA(1);
+
+			if ( (LA13_0=='n') )
+			{
+				alt13=1;
+			}
+			else if ( (LA13_0=='r') )
+			{
+				alt13=2;
+			}
+			else if ( (LA13_0=='t') )
+			{
+				alt13=3;
+			}
+			else if ( (LA13_0=='b') )
+			{
+				alt13=4;
+			}
+			else if ( (LA13_0=='f') )
+			{
+				alt13=5;
+			}
+			else if ( ((LA13_0>='\u0000' && LA13_0<='a')||(LA13_0>='c' && LA13_0<='e')||(LA13_0>='g' && LA13_0<='m')||(LA13_0>='o' && LA13_0<='q')||LA13_0=='s'||(LA13_0>='u' && LA13_0<='\uFFFF')) )
+			{
+				alt13=6;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				NoViableAltException nvae = new NoViableAltException("", 13, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt13 )
+			{
+			case 1:
+				// Language\\Action.g3:431:5: 'n'
+				{
+				Match('n'); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+					if (doEscape) { uc = '\n'; }
+				}
+
+				}
+				break;
+			case 2:
+				// Language\\Action.g3:432:5: 'r'
+				{
+				Match('r'); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+					if (doEscape) { uc = '\r'; }
+				}
+
+				}
+				break;
+			case 3:
+				// Language\\Action.g3:433:5: 't'
+				{
+				Match('t'); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+					if (doEscape) { uc = '\t'; }
+				}
+
+				}
+				break;
+			case 4:
+				// Language\\Action.g3:434:5: 'b'
+				{
+				Match('b'); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+					if (doEscape) { uc = '\b'; }
+				}
+
+				}
+				break;
+			case 5:
+				// Language\\Action.g3:435:5: 'f'
+				{
+				Match('f'); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+					if (doEscape) { uc = '\f'; }
+				}
+
+				}
+				break;
+			case 6:
+				// Language\\Action.g3:436:5: c=~ ( 'n' | 'r' | 't' | 'b' | 'f' )
+				{
+				c= input.LA(1);
+				input.Consume();
+				state.failed=false;
+				if ( state.backtracking == 0 )
+				{
+					if (doEscape) { uc = (char)c; }
+				}
+
+				}
+				break;
+
+			}
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ESC_CHAR"
+
+	// $ANTLR start "LBRACK"
+	private void mLBRACK()
+	{
+		try
+		{
+			int _type = LBRACK;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Action.g3:436:11: ( '[' )
+			// Language\\Action.g3:436:11: '['
+			{
+			Match('['); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "LBRACK"
+
+	// $ANTLR start "RBRACK"
+	private void mRBRACK()
+	{
+		try
+		{
+			int _type = RBRACK;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Action.g3:437:11: ( ']' )
+			// Language\\Action.g3:437:11: ']'
+			{
+			Match(']'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "RBRACK"
+
+	// $ANTLR start "LPAREN"
+	private void mLPAREN()
+	{
+		try
+		{
+			int _type = LPAREN;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Action.g3:438:11: ( '(' )
+			// Language\\Action.g3:438:11: '('
+			{
+			Match('('); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "LPAREN"
+
+	// $ANTLR start "RPAREN"
+	private void mRPAREN()
+	{
+		try
+		{
+			int _type = RPAREN;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Action.g3:439:11: ( ')' )
+			// Language\\Action.g3:439:11: ')'
+			{
+			Match(')'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "RPAREN"
+
+	// $ANTLR start "COMMA"
+	private void mCOMMA()
+	{
+		try
+		{
+			int _type = COMMA;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Action.g3:440:10: ( ',' )
+			// Language\\Action.g3:440:10: ','
+			{
+			Match(','); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "COMMA"
+
+	// $ANTLR start "DOT"
+	private void mDOT()
+	{
+		try
+		{
+			int _type = DOT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Action.g3:441:9: ( '.' )
+			// Language\\Action.g3:441:9: '.'
+			{
+			Match('.'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "DOT"
+
+	// $ANTLR start "ASSIGN"
+	private void mASSIGN()
+	{
+		try
+		{
+			int _type = ASSIGN;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Action.g3:442:11: ( '=' )
+			// Language\\Action.g3:442:11: '='
+			{
+			Match('='); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ASSIGN"
+
+	// $ANTLR start "COLON"
+	private void mCOLON()
+	{
+		try
+		{
+			int _type = COLON;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Action.g3:443:10: ( ':' )
+			// Language\\Action.g3:443:10: ':'
+			{
+			Match(':'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "COLON"
+
+	// $ANTLR start "PLUS"
+	private void mPLUS()
+	{
+		try
+		{
+			int _type = PLUS;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Action.g3:444:9: ( '+' )
+			// Language\\Action.g3:444:9: '+'
+			{
+			Match('+'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "PLUS"
+
+	// $ANTLR start "SEMI"
+	private void mSEMI()
+	{
+		try
+		{
+			int _type = SEMI;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Action.g3:445:9: ( ';' )
+			// Language\\Action.g3:445:9: ';'
+			{
+			Match(';'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "SEMI"
+
+	// $ANTLR start "NOT"
+	private void mNOT()
+	{
+		try
+		{
+			int _type = NOT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Action.g3:446:9: ( '!' )
+			// Language\\Action.g3:446:9: '!'
+			{
+			Match('!'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "NOT"
+
+	// $ANTLR start "DOTDOTDOT"
+	private void mDOTDOTDOT()
+	{
+		try
+		{
+			int _type = DOTDOTDOT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Action.g3:447:13: ( '...' )
+			// Language\\Action.g3:447:13: '...'
+			{
+			Match("..."); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "DOTDOTDOT"
+
+	// $ANTLR start "WS"
+	private void mWS()
+	{
+		try
+		{
+			int _type = WS;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Action.g3:450:4: ( ( ' ' | '\\t' | '\\r' | '\\n' )+ )
+			// Language\\Action.g3:450:4: ( ' ' | '\\t' | '\\r' | '\\n' )+
+			{
+			// Language\\Action.g3:450:4: ( ' ' | '\\t' | '\\r' | '\\n' )+
+			int cnt14=0;
+			for ( ; ; )
+			{
+				int alt14=2;
+				int LA14_0 = input.LA(1);
+
+				if ( ((LA14_0>='\t' && LA14_0<='\n')||LA14_0=='\r'||LA14_0==' ') )
+				{
+					alt14=1;
+				}
+
+
+				switch ( alt14 )
+				{
+				case 1:
+					// Language\\Action.g3:
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+
+				default:
+					if ( cnt14 >= 1 )
+						goto loop14;
+
+					if (state.backtracking>0) {state.failed=true; return ;}
+					EarlyExitException eee14 = new EarlyExitException( 14, input );
+					throw eee14;
+				}
+				cnt14++;
+			}
+			loop14:
+				;
+
+
+			if ( state.backtracking == 0 )
+			{
+				_channel = HIDDEN;
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "WS"
+
+	// $ANTLR start "WS_CHAR"
+	private void mWS_CHAR()
+	{
+		try
+		{
+			// Language\\Action.g3:457:4: ( ' ' | '\\t' | '\\r' | '\\n' )
+			// Language\\Action.g3:
+			{
+			if ( (input.LA(1)>='\t' && input.LA(1)<='\n')||input.LA(1)=='\r'||input.LA(1)==' ' )
+			{
+				input.Consume();
+			state.failed=false;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				Recover(mse);
+				throw mse;}
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "WS_CHAR"
+
+	public override void mTokens()
+	{
+		// Language\\Action.g3:1:10: ( CONDITIONAL | T__36 | T__37 | T__38 | T__39 | T__40 | T__41 | T__42 | T__43 | ID | INT | STRING | ANONYMOUS_TEMPLATE | LBRACK | RBRACK | LPAREN | RPAREN | COMMA | DOT | ASSIGN | COLON | PLUS | SEMI | NOT | DOTDOTDOT | WS )
+		int alt15=26;
+		alt15 = dfa15.Predict(input);
+		switch ( alt15 )
+		{
+		case 1:
+			// Language\\Action.g3:1:10: CONDITIONAL
+			{
+			mCONDITIONAL(); if (state.failed) return ;
+
+			}
+			break;
+		case 2:
+			// Language\\Action.g3:1:22: T__36
+			{
+			mT__36(); if (state.failed) return ;
+
+			}
+			break;
+		case 3:
+			// Language\\Action.g3:1:28: T__37
+			{
+			mT__37(); if (state.failed) return ;
+
+			}
+			break;
+		case 4:
+			// Language\\Action.g3:1:34: T__38
+			{
+			mT__38(); if (state.failed) return ;
+
+			}
+			break;
+		case 5:
+			// Language\\Action.g3:1:40: T__39
+			{
+			mT__39(); if (state.failed) return ;
+
+			}
+			break;
+		case 6:
+			// Language\\Action.g3:1:46: T__40
+			{
+			mT__40(); if (state.failed) return ;
+
+			}
+			break;
+		case 7:
+			// Language\\Action.g3:1:52: T__41
+			{
+			mT__41(); if (state.failed) return ;
+
+			}
+			break;
+		case 8:
+			// Language\\Action.g3:1:58: T__42
+			{
+			mT__42(); if (state.failed) return ;
+
+			}
+			break;
+		case 9:
+			// Language\\Action.g3:1:64: T__43
+			{
+			mT__43(); if (state.failed) return ;
+
+			}
+			break;
+		case 10:
+			// Language\\Action.g3:1:70: ID
+			{
+			mID(); if (state.failed) return ;
+
+			}
+			break;
+		case 11:
+			// Language\\Action.g3:1:73: INT
+			{
+			mINT(); if (state.failed) return ;
+
+			}
+			break;
+		case 12:
+			// Language\\Action.g3:1:77: STRING
+			{
+			mSTRING(); if (state.failed) return ;
+
+			}
+			break;
+		case 13:
+			// Language\\Action.g3:1:84: ANONYMOUS_TEMPLATE
+			{
+			mANONYMOUS_TEMPLATE(); if (state.failed) return ;
+
+			}
+			break;
+		case 14:
+			// Language\\Action.g3:1:103: LBRACK
+			{
+			mLBRACK(); if (state.failed) return ;
+
+			}
+			break;
+		case 15:
+			// Language\\Action.g3:1:110: RBRACK
+			{
+			mRBRACK(); if (state.failed) return ;
+
+			}
+			break;
+		case 16:
+			// Language\\Action.g3:1:117: LPAREN
+			{
+			mLPAREN(); if (state.failed) return ;
+
+			}
+			break;
+		case 17:
+			// Language\\Action.g3:1:124: RPAREN
+			{
+			mRPAREN(); if (state.failed) return ;
+
+			}
+			break;
+		case 18:
+			// Language\\Action.g3:1:131: COMMA
+			{
+			mCOMMA(); if (state.failed) return ;
+
+			}
+			break;
+		case 19:
+			// Language\\Action.g3:1:137: DOT
+			{
+			mDOT(); if (state.failed) return ;
+
+			}
+			break;
+		case 20:
+			// Language\\Action.g3:1:141: ASSIGN
+			{
+			mASSIGN(); if (state.failed) return ;
+
+			}
+			break;
+		case 21:
+			// Language\\Action.g3:1:148: COLON
+			{
+			mCOLON(); if (state.failed) return ;
+
+			}
+			break;
+		case 22:
+			// Language\\Action.g3:1:154: PLUS
+			{
+			mPLUS(); if (state.failed) return ;
+
+			}
+			break;
+		case 23:
+			// Language\\Action.g3:1:159: SEMI
+			{
+			mSEMI(); if (state.failed) return ;
+
+			}
+			break;
+		case 24:
+			// Language\\Action.g3:1:164: NOT
+			{
+			mNOT(); if (state.failed) return ;
+
+			}
+			break;
+		case 25:
+			// Language\\Action.g3:1:168: DOTDOTDOT
+			{
+			mDOTDOTDOT(); if (state.failed) return ;
+
+			}
+			break;
+		case 26:
+			// Language\\Action.g3:1:178: WS
+			{
+			mWS(); if (state.failed) return ;
+
+			}
+			break;
+
+		}
+
+	}
+
+	// $ANTLR start synpred1_Action
+	public void synpred1_Action_fragment()
+	{
+		// Language\\Action.g3:358:5: ( ( WS_CHAR )? ID )
+		// Language\\Action.g3:358:6: ( WS_CHAR )? ID
+		{
+		// Language\\Action.g3:358:6: ( WS_CHAR )?
+		int alt16=2;
+		int LA16_0 = input.LA(1);
+
+		if ( ((LA16_0>='\t' && LA16_0<='\n')||LA16_0=='\r'||LA16_0==' ') )
+		{
+			alt16=1;
+		}
+		switch ( alt16 )
+		{
+		case 1:
+			// Language\\Action.g3:
+			{
+			if ( (input.LA(1)>='\t' && input.LA(1)<='\n')||input.LA(1)=='\r'||input.LA(1)==' ' )
+			{
+				input.Consume();
+			state.failed=false;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				Recover(mse);
+				throw mse;}
+
+
+			}
+			break;
+
+		}
+
+		mID(); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred1_Action
+
+	// $ANTLR start synpred2_Action
+	public void synpred2_Action_fragment()
+	{
+		// Language\\Action.g3:358:83: ( WS_CHAR )
+		// Language\\Action.g3:
+		{
+		if ( (input.LA(1)>='\t' && input.LA(1)<='\n')||input.LA(1)=='\r'||input.LA(1)==' ' )
+		{
+			input.Consume();
+		state.failed=false;
+		}
+		else
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			MismatchedSetException mse = new MismatchedSetException(null,input);
+			Recover(mse);
+			throw mse;}
+
+
+		}
+	}
+	// $ANTLR end synpred2_Action
+
+	// $ANTLR start synpred3_Action
+	public void synpred3_Action_fragment()
+	{
+		// Language\\Action.g3:367:5: ( '\\\\{' )
+		// Language\\Action.g3:367:6: '\\\\{'
+		{
+		Match("\\{"); if (state.failed) return ;
+
+
+		}
+	}
+	// $ANTLR end synpred3_Action
+
+	// $ANTLR start synpred4_Action
+	public void synpred4_Action_fragment()
+	{
+		// Language\\Action.g3:368:5: ( '\\\\}' )
+		// Language\\Action.g3:368:6: '\\\\}'
+		{
+		Match("\\}"); if (state.failed) return ;
+
+
+		}
+	}
+	// $ANTLR end synpred4_Action
+
+	// $ANTLR start synpred5_Action
+	public void synpred5_Action_fragment()
+	{
+		// Language\\Action.g3:405:5: ( '\\\\{' )
+		// Language\\Action.g3:405:6: '\\\\{'
+		{
+		Match("\\{"); if (state.failed) return ;
+
+
+		}
+	}
+	// $ANTLR end synpred5_Action
+
+	// $ANTLR start synpred6_Action
+	public void synpred6_Action_fragment()
+	{
+		// Language\\Action.g3:406:5: ( '\\\\}' )
+		// Language\\Action.g3:406:6: '\\\\}'
+		{
+		Match("\\}"); if (state.failed) return ;
+
+
+		}
+	}
+	// $ANTLR end synpred6_Action
+
+	public bool synpred2_Action()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred2_Action_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred1_Action()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred1_Action_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred3_Action()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred3_Action_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred4_Action()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred4_Action_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred5_Action()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred5_Action_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred6_Action()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred6_Action_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+
+
+	#region DFA
+	DFA5 dfa5;
+	DFA6 dfa6;
+	DFA12 dfa12;
+	DFA15 dfa15;
+
+	protected override void InitDFAs()
+	{
+		base.InitDFAs();
+		dfa5 = new DFA5( this, new SpecialStateTransitionHandler( specialStateTransition5 ) );
+		dfa6 = new DFA6( this, new SpecialStateTransitionHandler( specialStateTransition6 ) );
+		dfa12 = new DFA12( this, new SpecialStateTransitionHandler( specialStateTransition12 ) );
+		dfa15 = new DFA15( this );
+	}
+
+	class DFA5 : DFA
+	{
+
+		const string DFA5_eotS =
+			"\xD\xFFFF";
+		const string DFA5_eofS =
+			"\xD\xFFFF";
+		const string DFA5_minS =
+			"\x3\x0\x1\xFFFF\x6\x0\x1\xFFFF\x2\x0";
+		const string DFA5_maxS =
+			"\x3\xFFFF\x1\xFFFF\x3\xFFFF\x1\x0\x2\xFFFF\x1\xFFFF\x2\xFFFF";
+		const string DFA5_acceptS =
+			"\x3\xFFFF\x1\x2\x6\xFFFF\x1\x1\x2\xFFFF";
+		const string DFA5_specialS =
+			"\x1\x0\x1\x1\x1\x2\x1\xFFFF\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1\xFFFF"+
+			"\x1\x9\x1\xA}>";
+		static readonly string[] DFA5_transitionS =
+			{
+				"\x9\x3\x2\x1\x2\x3\x1\x1\x12\x3\x1\x1\x20\x3\x1A\x2\x4\x3\x1\x2\x1\x3"+
+				"\x1A\x2\xFF85\x3",
+				"\x41\x3\x1A\x2\x4\x3\x1\x2\x1\x3\x1A\x2\xFF85\x3",
+				"\x9\x3\x2\x5\x2\x3\x1\x5\x12\x3\x1\x5\xB\x3\x1\x6\x2\x3\xB\x4\x7\x3"+
+				"\x1A\x4\x4\x3\x1\x4\x1\x3\x1A\x4\x1\x3\x1\x7\xFF83\x3",
+				"",
+				"\x9\x3\x2\x5\x2\x3\x1\x5\x12\x3\x1\x5\xB\x3\x1\x6\x2\x3\xB\x4\x7\x3"+
+				"\x1A\x4\x4\x3\x1\x4\x1\x3\x1A\x4\x1\x3\x1\x7\xFF83\x3",
+				"\x2C\x3\x1\x6\x4F\x3\x1\x7\xFF83\x3",
+				"\x9\x3\x2\x8\x2\x3\x1\x8\x12\x3\x1\x8\x20\x3\x1A\x9\x4\x3\x1\x9\x1\x3"+
+				"\x1A\x9\xFF85\x3",
+				"\x1\xFFFF",
+				"\x41\x3\x1A\x9\x4\x3\x1\x9\x1\x3\x1A\x9\xFF85\x3",
+				"\x9\x3\x2\xC\x2\x3\x1\xC\x12\x3\x1\xC\xB\x3\x1\x6\x2\x3\xB\xB\x7\x3"+
+				"\x1A\xB\x4\x3\x1\xB\x1\x3\x1A\xB\x1\x3\x1\x7\xFF83\x3",
+				"",
+				"\x9\x3\x2\xC\x2\x3\x1\xC\x12\x3\x1\xC\xB\x3\x1\x6\x2\x3\xB\xB\x7\x3"+
+				"\x1A\xB\x4\x3\x1\xB\x1\x3\x1A\xB\x1\x3\x1\x7\xFF83\x3",
+				"\x2C\x3\x1\x6\x4F\x3\x1\x7\xFF83\x3"
+			};
+
+		static readonly short[] DFA5_eot = DFA.UnpackEncodedString(DFA5_eotS);
+		static readonly short[] DFA5_eof = DFA.UnpackEncodedString(DFA5_eofS);
+		static readonly char[] DFA5_min = DFA.UnpackEncodedStringToUnsignedChars(DFA5_minS);
+		static readonly char[] DFA5_max = DFA.UnpackEncodedStringToUnsignedChars(DFA5_maxS);
+		static readonly short[] DFA5_accept = DFA.UnpackEncodedString(DFA5_acceptS);
+		static readonly short[] DFA5_special = DFA.UnpackEncodedString(DFA5_specialS);
+		static readonly short[][] DFA5_transition;
+
+		static DFA5()
+		{
+			int numStates = DFA5_transitionS.Length;
+			DFA5_transition = new short[numStates][];
+			for ( int i=0; i < numStates; i++ )
+			{
+				DFA5_transition[i] = DFA.UnpackEncodedString(DFA5_transitionS[i]);
+			}
+		}
+
+		public DFA5( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
+			: base( specialStateTransition )	{
+			this.recognizer = recognizer;
+			this.decisionNumber = 5;
+			this.eot = DFA5_eot;
+			this.eof = DFA5_eof;
+			this.min = DFA5_min;
+			this.max = DFA5_max;
+			this.accept = DFA5_accept;
+			this.special = DFA5_special;
+			this.transition = DFA5_transition;
+		}
+		public override string GetDescription()
+		{
+			return "358:3: (=> TEMPLATE_ARGS[out subtext, args] (=> WS_CHAR )? |)";
+		}
+	}
+
+	int specialStateTransition5( DFA dfa, int s, IIntStream _input )
+	{
+		IIntStream input = _input;
+		int _s = s;
+		switch ( s )
+		{
+
+			case 0:
+				int LA5_0 = input.LA(1);
+
+				s = -1;
+				if ( ((LA5_0>='\t' && LA5_0<='\n')||LA5_0=='\r'||LA5_0==' ') ) {s = 1;}
+
+				else if ( ((LA5_0>='A' && LA5_0<='Z')||LA5_0=='_'||(LA5_0>='a' && LA5_0<='z')) ) {s = 2;}
+
+				else if ( ((LA5_0>='\u0000' && LA5_0<='\b')||(LA5_0>='\u000B' && LA5_0<='\f')||(LA5_0>='\u000E' && LA5_0<='\u001F')||(LA5_0>='!' && LA5_0<='@')||(LA5_0>='[' && LA5_0<='^')||LA5_0=='`'||(LA5_0>='{' && LA5_0<='\uFFFF')) ) {s = 3;}
+
+				if ( s>=0 ) return s;
+				break;
+
+			case 1:
+				int LA5_1 = input.LA(1);
+
+				s = -1;
+				if ( ((LA5_1>='A' && LA5_1<='Z')||LA5_1=='_'||(LA5_1>='a' && LA5_1<='z')) ) {s = 2;}
+
+				else if ( ((LA5_1>='\u0000' && LA5_1<='@')||(LA5_1>='[' && LA5_1<='^')||LA5_1=='`'||(LA5_1>='{' && LA5_1<='\uFFFF')) ) {s = 3;}
+
+				if ( s>=0 ) return s;
+				break;
+
+			case 2:
+				int LA5_2 = input.LA(1);
+
+				s = -1;
+				if ( ((LA5_2>='/' && LA5_2<='9')||(LA5_2>='A' && LA5_2<='Z')||LA5_2=='_'||(LA5_2>='a' && LA5_2<='z')) ) {s = 4;}
+
+				else if ( ((LA5_2>='\t' && LA5_2<='\n')||LA5_2=='\r'||LA5_2==' ') ) {s = 5;}
+
+				else if ( (LA5_2==',') ) {s = 6;}
+
+				else if ( (LA5_2=='|') ) {s = 7;}
+
+				else if ( ((LA5_2>='\u0000' && LA5_2<='\b')||(LA5_2>='\u000B' && LA5_2<='\f')||(LA5_2>='\u000E' && LA5_2<='\u001F')||(LA5_2>='!' && LA5_2<='+')||(LA5_2>='-' && LA5_2<='.')||(LA5_2>=':' && LA5_2<='@')||(LA5_2>='[' && LA5_2<='^')||LA5_2=='`'||LA5_2=='{'||(LA5_2>='}' && LA5_2<='\uFFFF')) ) {s = 3;}
+
+				if ( s>=0 ) return s;
+				break;
+
+			case 3:
+				int LA5_4 = input.LA(1);
+
+				s = -1;
+				if ( ((LA5_4>='\t' && LA5_4<='\n')||LA5_4=='\r'||LA5_4==' ') ) {s = 5;}
+
+				else if ( (LA5_4==',') ) {s = 6;}
+
+				else if ( (LA5_4=='|') ) {s = 7;}
+
+				else if ( ((LA5_4>='/' && LA5_4<='9')||(LA5_4>='A' && LA5_4<='Z')||LA5_4=='_'||(LA5_4>='a' && LA5_4<='z')) ) {s = 4;}
+
+				else if ( ((LA5_4>='\u0000' && LA5_4<='\b')||(LA5_4>='\u000B' && LA5_4<='\f')||(LA5_4>='\u000E' && LA5_4<='\u001F')||(LA5_4>='!' && LA5_4<='+')||(LA5_4>='-' && LA5_4<='.')||(LA5_4>=':' && LA5_4<='@')||(LA5_4>='[' && LA5_4<='^')||LA5_4=='`'||LA5_4=='{'||(LA5_4>='}' && LA5_4<='\uFFFF')) ) {s = 3;}
+
+				if ( s>=0 ) return s;
+				break;
+
+			case 4:
+				int LA5_5 = input.LA(1);
+
+				s = -1;
+				if ( (LA5_5==',') ) {s = 6;}
+
+				else if ( (LA5_5=='|') ) {s = 7;}
+
+				else if ( ((LA5_5>='\u0000' && LA5_5<='+')||(LA5_5>='-' && LA5_5<='{')||(LA5_5>='}' && LA5_5<='\uFFFF')) ) {s = 3;}
+
+				if ( s>=0 ) return s;
+				break;
+
+			case 5:
+				int LA5_6 = input.LA(1);
+
+				s = -1;
+				if ( ((LA5_6>='\t' && LA5_6<='\n')||LA5_6=='\r'||LA5_6==' ') ) {s = 8;}
+
+				else if ( ((LA5_6>='A' && LA5_6<='Z')||LA5_6=='_'||(LA5_6>='a' && LA5_6<='z')) ) {s = 9;}
+
+				else if ( ((LA5_6>='\u0000' && LA5_6<='\b')||(LA5_6>='\u000B' && LA5_6<='\f')||(LA5_6>='\u000E' && LA5_6<='\u001F')||(LA5_6>='!' && LA5_6<='@')||(LA5_6>='[' && LA5_6<='^')||LA5_6=='`'||(LA5_6>='{' && LA5_6<='\uFFFF')) ) {s = 3;}
+
+				if ( s>=0 ) return s;
+				break;
+
+			case 6:
+				int LA5_7 = input.LA(1);
+
+
+				int index5_7 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred1_Action()) ) {s = 10;}
+
+				else if ( (true) ) {s = 3;}
+
+
+				input.Seek(index5_7);
+				if ( s>=0 ) return s;
+				break;
+
+			case 7:
+				int LA5_8 = input.LA(1);
+
+				s = -1;
+				if ( ((LA5_8>='A' && LA5_8<='Z')||LA5_8=='_'||(LA5_8>='a' && LA5_8<='z')) ) {s = 9;}
+
+				else if ( ((LA5_8>='\u0000' && LA5_8<='@')||(LA5_8>='[' && LA5_8<='^')||LA5_8=='`'||(LA5_8>='{' && LA5_8<='\uFFFF')) ) {s = 3;}
+
+				if ( s>=0 ) return s;
+				break;
+
+			case 8:
+				int LA5_9 = input.LA(1);
+
+				s = -1;
+				if ( ((LA5_9>='/' && LA5_9<='9')||(LA5_9>='A' && LA5_9<='Z')||LA5_9=='_'||(LA5_9>='a' && LA5_9<='z')) ) {s = 11;}
+
+				else if ( ((LA5_9>='\t' && LA5_9<='\n')||LA5_9=='\r'||LA5_9==' ') ) {s = 12;}
+
+				else if ( (LA5_9=='|') ) {s = 7;}
+
+				else if ( (LA5_9==',') ) {s = 6;}
+
+				else if ( ((LA5_9>='\u0000' && LA5_9<='\b')||(LA5_9>='\u000B' && LA5_9<='\f')||(LA5_9>='\u000E' && LA5_9<='\u001F')||(LA5_9>='!' && LA5_9<='+')||(LA5_9>='-' && LA5_9<='.')||(LA5_9>=':' && LA5_9<='@')||(LA5_9>='[' && LA5_9<='^')||LA5_9=='`'||LA5_9=='{'||(LA5_9>='}' && LA5_9<='\uFFFF')) ) {s = 3;}
+
+				if ( s>=0 ) return s;
+				break;
+
+			case 9:
+				int LA5_11 = input.LA(1);
+
+				s = -1;
+				if ( ((LA5_11>='\t' && LA5_11<='\n')||LA5_11=='\r'||LA5_11==' ') ) {s = 12;}
+
+				else if ( (LA5_11=='|') ) {s = 7;}
+
+				else if ( (LA5_11==',') ) {s = 6;}
+
+				else if ( ((LA5_11>='/' && LA5_11<='9')||(LA5_11>='A' && LA5_11<='Z')||LA5_11=='_'||(LA5_11>='a' && LA5_11<='z')) ) {s = 11;}
+
+				else if ( ((LA5_11>='\u0000' && LA5_11<='\b')||(LA5_11>='\u000B' && LA5_11<='\f')||(LA5_11>='\u000E' && LA5_11<='\u001F')||(LA5_11>='!' && LA5_11<='+')||(LA5_11>='-' && LA5_11<='.')||(LA5_11>=':' && LA5_11<='@')||(LA5_11>='[' && LA5_11<='^')||LA5_11=='`'||LA5_11=='{'||(LA5_11>='}' && LA5_11<='\uFFFF')) ) {s = 3;}
+
+				if ( s>=0 ) return s;
+				break;
+
+			case 10:
+				int LA5_12 = input.LA(1);
+
+				s = -1;
+				if ( (LA5_12=='|') ) {s = 7;}
+
+				else if ( (LA5_12==',') ) {s = 6;}
+
+				else if ( ((LA5_12>='\u0000' && LA5_12<='+')||(LA5_12>='-' && LA5_12<='{')||(LA5_12>='}' && LA5_12<='\uFFFF')) ) {s = 3;}
+
+				if ( s>=0 ) return s;
+				break;
+		}
+		if (state.backtracking>0) {state.failed=true; return -1;}
+		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 5, _s, input);
+		dfa.Error(nvae);
+		throw nvae;
+	}
+	class DFA6 : DFA
+	{
+
+		const string DFA6_eotS =
+			"\xA\xFFFF";
+		const string DFA6_eofS =
+			"\xA\xFFFF";
+		const string DFA6_minS =
+			"\x1\x0\x1\xFFFF\x1\x0\x2\xFFFF\x2\x0\x3\xFFFF";
+		const string DFA6_maxS =
+			"\x1\xFFFF\x1\xFFFF\x1\xFFFF\x2\xFFFF\x2\x0\x3\xFFFF";
+		const string DFA6_acceptS =
+			"\x1\xFFFF\x1\x6\x1\xFFFF\x1\x4\x1\x5\x2\xFFFF\x1\x3\x1\x1\x1\x2";
+		const string DFA6_specialS =
+			"\x1\x0\x1\xFFFF\x1\x1\x2\xFFFF\x1\x2\x1\x3\x3\xFFFF}>";
+		static readonly string[] DFA6_transitionS =
+			{
+				"\x5C\x4\x1\x2\x1E\x4\x1\x3\x1\x4\x1\x1\xFF82\x4",
+				"",
+				"\x7B\x7\x1\x5\x1\x7\x1\x6\xFF82\x7",
+				"",
+				"",
+				"\x1\xFFFF",
+				"\x1\xFFFF",
+				"",
+				"",
+				""
+			};
+
+		static readonly short[] DFA6_eot = DFA.UnpackEncodedString(DFA6_eotS);
+		static readonly short[] DFA6_eof = DFA.UnpackEncodedString(DFA6_eofS);
+		static readonly char[] DFA6_min = DFA.UnpackEncodedStringToUnsignedChars(DFA6_minS);
+		static readonly char[] DFA6_max = DFA.UnpackEncodedStringToUnsignedChars(DFA6_maxS);
+		static readonly short[] DFA6_accept = DFA.UnpackEncodedString(DFA6_acceptS);
+		static readonly short[] DFA6_special = DFA.UnpackEncodedString(DFA6_specialS);
+		static readonly short[][] DFA6_transition;
+
+		static DFA6()
+		{
+			int numStates = DFA6_transitionS.Length;
+			DFA6_transition = new short[numStates][];
+			for ( int i=0; i < numStates; i++ )
+			{
+				DFA6_transition[i] = DFA.UnpackEncodedString(DFA6_transitionS[i]);
+			}
+		}
+
+		public DFA6( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
+			: base( specialStateTransition )	{
+			this.recognizer = recognizer;
+			this.decisionNumber = 6;
+			this.eot = DFA6_eot;
+			this.eof = DFA6_eof;
+			this.min = DFA6_min;
+			this.max = DFA6_max;
+			this.accept = DFA6_accept;
+			this.special = DFA6_special;
+			this.transition = DFA6_transition;
+		}
+		public override string GetDescription()
+		{
+			return "()* loopback of 367:3: (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '\\\\' | '{' | '}' ) )*";
+		}
+	}
+
+	int specialStateTransition6( DFA dfa, int s, IIntStream _input )
+	{
+		IIntStream input = _input;
+		int _s = s;
+		switch ( s )
+		{
+
+			case 0:
+				int LA6_0 = input.LA(1);
+
+				s = -1;
+				if ( (LA6_0=='}') ) {s = 1;}
+
+				else if ( (LA6_0=='\\') ) {s = 2;}
+
+				else if ( (LA6_0=='{') ) {s = 3;}
+
+				else if ( ((LA6_0>='\u0000' && LA6_0<='[')||(LA6_0>=']' && LA6_0<='z')||LA6_0=='|'||(LA6_0>='~' && LA6_0<='\uFFFF')) ) {s = 4;}
+
+				if ( s>=0 ) return s;
+				break;
+
+			case 1:
+				int LA6_2 = input.LA(1);
+
+				s = -1;
+				if ( (LA6_2=='{') ) {s = 5;}
+
+				else if ( (LA6_2=='}') ) {s = 6;}
+
+				else if ( ((LA6_2>='\u0000' && LA6_2<='z')||LA6_2=='|'||(LA6_2>='~' && LA6_2<='\uFFFF')) ) {s = 7;}
+
+				if ( s>=0 ) return s;
+				break;
+
+			case 2:
+				int LA6_5 = input.LA(1);
+
+
+				int index6_5 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred3_Action()) ) {s = 8;}
+
+				else if ( (true) ) {s = 7;}
+
+
+				input.Seek(index6_5);
+				if ( s>=0 ) return s;
+				break;
+
+			case 3:
+				int LA6_6 = input.LA(1);
+
+
+				int index6_6 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred4_Action()) ) {s = 9;}
+
+				else if ( (true) ) {s = 7;}
+
+
+				input.Seek(index6_6);
+				if ( s>=0 ) return s;
+				break;
+		}
+		if (state.backtracking>0) {state.failed=true; return -1;}
+		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 6, _s, input);
+		dfa.Error(nvae);
+		throw nvae;
+	}
+	class DFA12 : DFA
+	{
+
+		const string DFA12_eotS =
+			"\xA\xFFFF";
+		const string DFA12_eofS =
+			"\xA\xFFFF";
+		const string DFA12_minS =
+			"\x1\x0\x1\xFFFF\x1\x0\x2\xFFFF\x2\x0\x3\xFFFF";
+		const string DFA12_maxS =
+			"\x1\xFFFF\x1\xFFFF\x1\xFFFF\x2\xFFFF\x2\x0\x3\xFFFF";
+		const string DFA12_acceptS =
+			"\x1\xFFFF\x1\x6\x1\xFFFF\x1\x4\x1\x5\x2\xFFFF\x1\x3\x1\x1\x1\x2";
+		const string DFA12_specialS =
+			"\x1\x0\x1\xFFFF\x1\x1\x2\xFFFF\x1\x2\x1\x3\x3\xFFFF}>";
+		static readonly string[] DFA12_transitionS =
+			{
+				"\x5C\x4\x1\x2\x1E\x4\x1\x3\x1\x4\x1\x1\xFF82\x4",
+				"",
+				"\x7B\x7\x1\x5\x1\x7\x1\x6\xFF82\x7",
+				"",
+				"",
+				"\x1\xFFFF",
+				"\x1\xFFFF",
+				"",
+				"",
+				""
+			};
+
+		static readonly short[] DFA12_eot = DFA.UnpackEncodedString(DFA12_eotS);
+		static readonly short[] DFA12_eof = DFA.UnpackEncodedString(DFA12_eofS);
+		static readonly char[] DFA12_min = DFA.UnpackEncodedStringToUnsignedChars(DFA12_minS);
+		static readonly char[] DFA12_max = DFA.UnpackEncodedStringToUnsignedChars(DFA12_maxS);
+		static readonly short[] DFA12_accept = DFA.UnpackEncodedString(DFA12_acceptS);
+		static readonly short[] DFA12_special = DFA.UnpackEncodedString(DFA12_specialS);
+		static readonly short[][] DFA12_transition;
+
+		static DFA12()
+		{
+			int numStates = DFA12_transitionS.Length;
+			DFA12_transition = new short[numStates][];
+			for ( int i=0; i < numStates; i++ )
+			{
+				DFA12_transition[i] = DFA.UnpackEncodedString(DFA12_transitionS[i]);
+			}
+		}
+
+		public DFA12( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
+			: base( specialStateTransition )	{
+			this.recognizer = recognizer;
+			this.decisionNumber = 12;
+			this.eot = DFA12_eot;
+			this.eof = DFA12_eof;
+			this.min = DFA12_min;
+			this.max = DFA12_max;
+			this.accept = DFA12_accept;
+			this.special = DFA12_special;
+			this.transition = DFA12_transition;
+		}
+		public override string GetDescription()
+		{
+			return "()* loopback of 405:3: (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '{' | '}' | '\\\\' ) )*";
+		}
+	}
+
+	int specialStateTransition12( DFA dfa, int s, IIntStream _input )
+	{
+		IIntStream input = _input;
+		int _s = s;
+		switch ( s )
+		{
+
+			case 0:
+				int LA12_0 = input.LA(1);
+
+				s = -1;
+				if ( (LA12_0=='}') ) {s = 1;}
+
+				else if ( (LA12_0=='\\') ) {s = 2;}
+
+				else if ( (LA12_0=='{') ) {s = 3;}
+
+				else if ( ((LA12_0>='\u0000' && LA12_0<='[')||(LA12_0>=']' && LA12_0<='z')||LA12_0=='|'||(LA12_0>='~' && LA12_0<='\uFFFF')) ) {s = 4;}
+
+				if ( s>=0 ) return s;
+				break;
+
+			case 1:
+				int LA12_2 = input.LA(1);
+
+				s = -1;
+				if ( (LA12_2=='{') ) {s = 5;}
+
+				else if ( (LA12_2=='}') ) {s = 6;}
+
+				else if ( ((LA12_2>='\u0000' && LA12_2<='z')||LA12_2=='|'||(LA12_2>='~' && LA12_2<='\uFFFF')) ) {s = 7;}
+
+				if ( s>=0 ) return s;
+				break;
+
+			case 2:
+				int LA12_5 = input.LA(1);
+
+
+				int index12_5 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred5_Action()) ) {s = 8;}
+
+				else if ( (true) ) {s = 7;}
+
+
+				input.Seek(index12_5);
+				if ( s>=0 ) return s;
+				break;
+
+			case 3:
+				int LA12_6 = input.LA(1);
+
+
+				int index12_6 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred6_Action()) ) {s = 9;}
+
+				else if ( (true) ) {s = 7;}
+
+
+				input.Seek(index12_6);
+				if ( s>=0 ) return s;
+				break;
+		}
+		if (state.backtracking>0) {state.failed=true; return -1;}
+		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 12, _s, input);
+		dfa.Error(nvae);
+		throw nvae;
+	}
+	class DFA15 : DFA
+	{
+
+		const string DFA15_eotS =
+			"\x1\xFFFF\x7\x8\x9\xFFFF\x1\x22\x6\xFFFF\x1\x23\x8\x8\x3\xFFFF\xA\x8"+
+			"\x1\x36\x1\x8\x1\x38\x4\x8\x1\x3D\x1\xFFFF\x1\x8\x1\xFFFF\x1\x3F\x1\x40"+
+			"\x1\x41\x1\x42\x1\xFFFF\x1\x43\x5\xFFFF";
+		const string DFA15_eofS =
+			"\x44\xFFFF";
+		const string DFA15_minS =
+			"\x1\x9\x1\x66\x1\x6C\x1\x69\x1\x61\x1\x65\x1\x74\x1\x72\x9\xFFFF\x1\x2E"+
+			"\x6\xFFFF\x1\x2F\x1\x73\x1\x72\x1\x73\x1\x6E\x1\x73\x1\x72\x1\x70\x1"+
+			"\x75\x3\xFFFF\x1\x65\x1\x73\x1\x74\x1\x67\x1\x74\x1\x69\x1\x65\x1\x6E"+
+			"\x1\x69\x1\x74\x1\x2F\x1\x74\x1\x2F\x1\x70\x1\x72\x1\x63\x1\x66\x1\x2F"+
+			"\x1\xFFFF\x1\x68\x1\xFFFF\x4\x2F\x1\xFFFF\x1\x2F\x5\xFFFF";
+		const string DFA15_maxS =
+			"\x1\x7B\x1\x66\x1\x6C\x1\x69\x2\x65\x1\x75\x1\x72\x9\xFFFF\x1\x2E\x6"+
+			"\xFFFF\x1\x7A\x1\x73\x1\x72\x1\x73\x1\x6E\x1\x73\x1\x72\x1\x70\x1\x75"+
+			"\x3\xFFFF\x1\x65\x1\x73\x1\x74\x1\x67\x1\x74\x1\x69\x1\x65\x1\x6E\x1"+
+			"\x69\x1\x74\x1\x7A\x1\x74\x1\x7A\x1\x70\x1\x72\x1\x63\x1\x66\x1\x7A\x1"+
+			"\xFFFF\x1\x68\x1\xFFFF\x4\x7A\x1\xFFFF\x1\x7A\x5\xFFFF";
+		const string DFA15_acceptS =
+			"\x8\xFFFF\x1\xA\x1\xB\x1\xC\x1\xD\x1\xE\x1\xF\x1\x10\x1\x11\x1\x12\x1"+
+			"\xFFFF\x1\x14\x1\x15\x1\x16\x1\x17\x1\x18\x1\x1A\x9\xFFFF\x1\x19\x1\x13"+
+			"\x1\x1\x12\xFFFF\x1\x4\x1\xFFFF\x1\x6\x4\xFFFF\x1\x3\x1\xFFFF\x1\x7\x1"+
+			"\x8\x1\x9\x1\x2\x1\x5";
+		const string DFA15_specialS =
+			"\x44\xFFFF}>";
+		static readonly string[] DFA15_transitionS =
+			{
+				"\x2\x17\x2\xFFFF\x1\x17\x12\xFFFF\x1\x17\x1\x16\x1\xA\x5\xFFFF\x1\xE"+
+				"\x1\xF\x1\xFFFF\x1\x14\x1\x10\x1\xFFFF\x1\x11\x1\xFFFF\xA\x9\x1\x13"+
+				"\x1\x15\x1\xFFFF\x1\x12\x3\xFFFF\x1A\x8\x1\xC\x1\xFFFF\x1\xD\x1\xFFFF"+
+				"\x1\x8\x1\xFFFF\x4\x8\x1\x2\x1\x3\x2\x8\x1\x1\x2\x8\x1\x4\x5\x8\x1\x5"+
+				"\x1\x6\x1\x7\x6\x8\x1\xB",
+				"\x1\x18",
+				"\x1\x19",
+				"\x1\x1A",
+				"\x1\x1B\x3\xFFFF\x1\x1C",
+				"\x1\x1D",
+				"\x1\x1E\x1\x1F",
+				"\x1\x20",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"\x1\x21",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"\xB\x8\x7\xFFFF\x1A\x8\x4\xFFFF\x1\x8\x1\xFFFF\x1A\x8",
+				"\x1\x24",
+				"\x1\x25",
+				"\x1\x26",
+				"\x1\x27",
+				"\x1\x28",
+				"\x1\x29",
+				"\x1\x2A",
+				"\x1\x2B",
+				"",
+				"",
+				"",
+				"\x1\x2C",
+				"\x1\x2D",
+				"\x1\x2E",
+				"\x1\x2F",
+				"\x1\x30",
+				"\x1\x31",
+				"\x1\x32",
+				"\x1\x33",
+				"\x1\x34",
+				"\x1\x35",
+				"\xB\x8\x7\xFFFF\x1A\x8\x4\xFFFF\x1\x8\x1\xFFFF\x1A\x8",
+				"\x1\x37",
+				"\xB\x8\x7\xFFFF\x1A\x8\x4\xFFFF\x1\x8\x1\xFFFF\x1A\x8",
+				"\x1\x39",
+				"\x1\x3A",
+				"\x1\x3B",
+				"\x1\x3C",
+				"\xB\x8\x7\xFFFF\x1A\x8\x4\xFFFF\x1\x8\x1\xFFFF\x1A\x8",
+				"",
+				"\x1\x3E",
+				"",
+				"\xB\x8\x7\xFFFF\x1A\x8\x4\xFFFF\x1\x8\x1\xFFFF\x1A\x8",
+				"\xB\x8\x7\xFFFF\x1A\x8\x4\xFFFF\x1\x8\x1\xFFFF\x1A\x8",
+				"\xB\x8\x7\xFFFF\x1A\x8\x4\xFFFF\x1\x8\x1\xFFFF\x1A\x8",
+				"\xB\x8\x7\xFFFF\x1A\x8\x4\xFFFF\x1\x8\x1\xFFFF\x1A\x8",
+				"",
+				"\xB\x8\x7\xFFFF\x1A\x8\x4\xFFFF\x1\x8\x1\xFFFF\x1A\x8",
+				"",
+				"",
+				"",
+				"",
+				""
+			};
+
+		static readonly short[] DFA15_eot = DFA.UnpackEncodedString(DFA15_eotS);
+		static readonly short[] DFA15_eof = DFA.UnpackEncodedString(DFA15_eofS);
+		static readonly char[] DFA15_min = DFA.UnpackEncodedStringToUnsignedChars(DFA15_minS);
+		static readonly char[] DFA15_max = DFA.UnpackEncodedStringToUnsignedChars(DFA15_maxS);
+		static readonly short[] DFA15_accept = DFA.UnpackEncodedString(DFA15_acceptS);
+		static readonly short[] DFA15_special = DFA.UnpackEncodedString(DFA15_specialS);
+		static readonly short[][] DFA15_transition;
+
+		static DFA15()
+		{
+			int numStates = DFA15_transitionS.Length;
+			DFA15_transition = new short[numStates][];
+			for ( int i=0; i < numStates; i++ )
+			{
+				DFA15_transition[i] = DFA.UnpackEncodedString(DFA15_transitionS[i]);
+			}
+		}
+
+		public DFA15( BaseRecognizer recognizer )
+		{
+			this.recognizer = recognizer;
+			this.decisionNumber = 15;
+			this.eot = DFA15_eot;
+			this.eof = DFA15_eof;
+			this.min = DFA15_min;
+			this.max = DFA15_max;
+			this.accept = DFA15_accept;
+			this.special = DFA15_special;
+			this.transition = DFA15_transition;
+		}
+		public override string GetDescription()
+		{
+			return "1:0: Tokens : ( CONDITIONAL | T__36 | T__37 | T__38 | T__39 | T__40 | T__41 | T__42 | T__43 | ID | INT | STRING | ANONYMOUS_TEMPLATE | LBRACK | RBRACK | LPAREN | RPAREN | COMMA | DOT | ASSIGN | COLON | PLUS | SEMI | NOT | DOTDOTDOT | WS );";
+		}
+	}
+
+
+	#endregion
+
+}
+
+} // namespace  Antlr3.ST.Language
diff --git a/Antlr3.StringTemplate/Language/ActionLexerHelper.cs b/Antlr3.StringTemplate/Language/ActionLexerHelper.cs
new file mode 100644
index 0000000..1a2b9a5
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/ActionLexerHelper.cs
@@ -0,0 +1,31 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Grammar conversion to ANTLR v3 and C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *	notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	notice, this list of conditions and the following disclaimer in the
+ *	documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *	derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
diff --git a/Antlr3.StringTemplate/Language/ActionParser.cs b/Antlr3.StringTemplate/Language/ActionParser.cs
new file mode 100644
index 0000000..ae3f09f
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/ActionParser.cs
@@ -0,0 +1,4058 @@
+// $ANTLR 3.1.2 Language\\Action.g3 2009-03-15 17:10:09
+
+// The variable 'variable' is assigned but its value is never used.
+#pragma warning disable 219
+// Unreachable code detected.
+#pragma warning disable 162
+
+
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+using System.Collections.Generic;
+using Antlr.Runtime;
+using Stack = System.Collections.Generic.Stack<object>;
+using List = System.Collections.IList;
+using ArrayList = System.Collections.Generic.List<object>;
+using Map = System.Collections.IDictionary;
+using HashMap = System.Collections.Generic.Dictionary<object, object>;
+
+using Antlr.Runtime.Tree;
+using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;
+
+namespace  Antlr3.ST.Language
+{
+public partial class ActionParser : Parser
+{
+	public static readonly string[] tokenNames = new string[] {
+		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ANONYMOUS_TEMPLATE", "APPLY", "ARGS", "ASSIGN", "COLON", "COMMA", "CONDITIONAL", "DOT", "DOTDOTDOT", "ESC_CHAR", "FUNCTION", "ID", "INCLUDE", "INT", "LBRACK", "LIST", "LPAREN", "MULTI_APPLY", "NESTED_ANONYMOUS_TEMPLATE", "NOT", "NOTHING", "PLUS", "RBRACK", "RPAREN", "SEMI", "SINGLEVALUEARG", "STRING", "TEMPLATE", "TEMPLATE_ARGS", "VALUE", "WS", "WS_CHAR", "'elseif'", "'first'", "'last'", "'length'", "'rest'", "'strip'", "'super'", "'trunc'"
+	};
+	public const int EOF=-1;
+	public const int T__36=36;
+	public const int T__37=37;
+	public const int T__38=38;
+	public const int T__39=39;
+	public const int T__40=40;
+	public const int T__41=41;
+	public const int T__42=42;
+	public const int T__43=43;
+	public const int ANONYMOUS_TEMPLATE=4;
+	public const int APPLY=5;
+	public const int ARGS=6;
+	public const int ASSIGN=7;
+	public const int COLON=8;
+	public const int COMMA=9;
+	public const int CONDITIONAL=10;
+	public const int DOT=11;
+	public const int DOTDOTDOT=12;
+	public const int ESC_CHAR=13;
+	public const int FUNCTION=14;
+	public const int ID=15;
+	public const int INCLUDE=16;
+	public const int INT=17;
+	public const int LBRACK=18;
+	public const int LIST=19;
+	public const int LPAREN=20;
+	public const int MULTI_APPLY=21;
+	public const int NESTED_ANONYMOUS_TEMPLATE=22;
+	public const int NOT=23;
+	public const int NOTHING=24;
+	public const int PLUS=25;
+	public const int RBRACK=26;
+	public const int RPAREN=27;
+	public const int SEMI=28;
+	public const int SINGLEVALUEARG=29;
+	public const int STRING=30;
+	public const int TEMPLATE=31;
+	public const int TEMPLATE_ARGS=32;
+	public const int VALUE=33;
+	public const int WS=34;
+	public const int WS_CHAR=35;
+
+	// delegates
+	// delegators
+
+	public ActionParser( ITokenStream input )
+		: this( input, new RecognizerSharedState() )
+	{
+	}
+	public ActionParser( ITokenStream input, RecognizerSharedState state )
+		: base( input, state )
+	{
+	}
+
+	protected ITreeAdaptor adaptor = new CommonTreeAdaptor();
+
+	public ITreeAdaptor TreeAdaptor
+	{
+		get
+		{
+			return adaptor;
+		}
+		set
+		{
+			this.adaptor = value;
+		}
+	}
+
+	public override string[] GetTokenNames() { return ActionParser.tokenNames; }
+	public override string GrammarFileName { get { return "Language\\Action.g3"; } }
+
+
+	#region Rules
+	public class action_return : ParserRuleReturnScope
+	{
+		public IDictionary<string, object> opts=null;
+		public StringTemplateAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "action"
+	// Language\\Action.g3:137:0: public action returns [IDictionary<string, object> opts=null] : ( templatesExpr ( SEMI optionList )? | 'if' LPAREN ifCondition RPAREN | 'elseif' LPAREN ifCondition RPAREN ) EOF ;
+	public ActionParser.action_return action(  )
+	{
+		ActionParser.action_return retval = new ActionParser.action_return();
+		retval.start = input.LT(1);
+
+		StringTemplateAST root_0 = null;
+
+		IToken SEMI2=null;
+		IToken string_literal4=null;
+		IToken LPAREN5=null;
+		IToken RPAREN7=null;
+		IToken string_literal8=null;
+		IToken LPAREN9=null;
+		IToken RPAREN11=null;
+		IToken EOF12=null;
+		ActionParser.templatesExpr_return templatesExpr1 = default(ActionParser.templatesExpr_return);
+		ActionParser.optionList_return optionList3 = default(ActionParser.optionList_return);
+		ActionParser.ifCondition_return ifCondition6 = default(ActionParser.ifCondition_return);
+		ActionParser.ifCondition_return ifCondition10 = default(ActionParser.ifCondition_return);
+
+		StringTemplateAST SEMI2_tree=null;
+		StringTemplateAST string_literal4_tree=null;
+		StringTemplateAST LPAREN5_tree=null;
+		StringTemplateAST RPAREN7_tree=null;
+		StringTemplateAST string_literal8_tree=null;
+		StringTemplateAST LPAREN9_tree=null;
+		StringTemplateAST RPAREN11_tree=null;
+		StringTemplateAST EOF12_tree=null;
+
+		try
+		{
+			// Language\\Action.g3:138:4: ( ( templatesExpr ( SEMI optionList )? | 'if' LPAREN ifCondition RPAREN | 'elseif' LPAREN ifCondition RPAREN ) EOF )
+			// Language\\Action.g3:138:4: ( templatesExpr ( SEMI optionList )? | 'if' LPAREN ifCondition RPAREN | 'elseif' LPAREN ifCondition RPAREN ) EOF
+			{
+			root_0 = (StringTemplateAST)adaptor.Nil();
+
+			// Language\\Action.g3:138:4: ( templatesExpr ( SEMI optionList )? | 'if' LPAREN ifCondition RPAREN | 'elseif' LPAREN ifCondition RPAREN )
+			int alt2=3;
+			switch ( input.LA(1) )
+			{
+			case ANONYMOUS_TEMPLATE:
+			case ID:
+			case INT:
+			case LBRACK:
+			case LPAREN:
+			case STRING:
+			case 37:
+			case 38:
+			case 39:
+			case 40:
+			case 41:
+			case 42:
+			case 43:
+				{
+				alt2=1;
+				}
+				break;
+			case CONDITIONAL:
+				{
+				alt2=2;
+				}
+				break;
+			case 36:
+				{
+				alt2=3;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt2 )
+			{
+			case 1:
+				// Language\\Action.g3:138:6: templatesExpr ( SEMI optionList )?
+				{
+				PushFollow(Follow._templatesExpr_in_action144);
+				templatesExpr1=templatesExpr();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, templatesExpr1.Tree);
+				// Language\\Action.g3:138:20: ( SEMI optionList )?
+				int alt1=2;
+				int LA1_0 = input.LA(1);
+
+				if ( (LA1_0==SEMI) )
+				{
+					alt1=1;
+				}
+				switch ( alt1 )
+				{
+				case 1:
+					// Language\\Action.g3:138:21: SEMI optionList
+					{
+					SEMI2=(IToken)Match(input,SEMI,Follow._SEMI_in_action147); if (state.failed) return retval;
+					PushFollow(Follow._optionList_in_action150);
+					optionList3=optionList();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, optionList3.Tree);
+					if ( state.backtracking == 0 )
+					{
+						retval.opts = (optionList3!=null?optionList3.opts:default(IDictionary<string, object>));
+					}
+
+					}
+					break;
+
+				}
+
+
+				}
+				break;
+			case 2:
+				// Language\\Action.g3:139:5: 'if' LPAREN ifCondition RPAREN
+				{
+				string_literal4=(IToken)Match(input,CONDITIONAL,Follow._CONDITIONAL_in_action160); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) {
+				string_literal4_tree = (StringTemplateAST)adaptor.Create(string_literal4);
+				root_0 = (StringTemplateAST)adaptor.BecomeRoot(string_literal4_tree, root_0);
+				}
+				LPAREN5=(IToken)Match(input,LPAREN,Follow._LPAREN_in_action163); if (state.failed) return retval;
+				PushFollow(Follow._ifCondition_in_action166);
+				ifCondition6=ifCondition();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, ifCondition6.Tree);
+				RPAREN7=(IToken)Match(input,RPAREN,Follow._RPAREN_in_action168); if (state.failed) return retval;
+
+				}
+				break;
+			case 3:
+				// Language\\Action.g3:140:5: 'elseif' LPAREN ifCondition RPAREN
+				{
+				string_literal8=(IToken)Match(input,36,Follow._36_in_action175); if (state.failed) return retval;
+				LPAREN9=(IToken)Match(input,LPAREN,Follow._LPAREN_in_action178); if (state.failed) return retval;
+				PushFollow(Follow._ifCondition_in_action181);
+				ifCondition10=ifCondition();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, ifCondition10.Tree);
+				RPAREN11=(IToken)Match(input,RPAREN,Follow._RPAREN_in_action183); if (state.failed) return retval;
+
+				}
+				break;
+
+			}
+
+			EOF12=(IToken)Match(input,EOF,Follow._EOF_in_action193); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			EOF12_tree = (StringTemplateAST)adaptor.Create(EOF12);
+			adaptor.AddChild(root_0, EOF12_tree);
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "action"
+
+	public class optionList_return : ParserRuleReturnScope
+	{
+		public IDictionary<string, object> opts=new Dictionary<string, object>();
+		public StringTemplateAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "optionList"
+	// Language\\Action.g3:145:0: optionList returns [IDictionary<string, object> opts=new Dictionary<string, object>()] : option[$opts] ( COMMA option[$opts] )* ;
+	private ActionParser.optionList_return optionList(  )
+	{
+		ActionParser.optionList_return retval = new ActionParser.optionList_return();
+		retval.start = input.LT(1);
+
+		StringTemplateAST root_0 = null;
+
+		IToken COMMA14=null;
+		ActionParser.option_return option13 = default(ActionParser.option_return);
+		ActionParser.option_return option15 = default(ActionParser.option_return);
+
+		StringTemplateAST COMMA14_tree=null;
+
+		try
+		{
+			// Language\\Action.g3:146:4: ( option[$opts] ( COMMA option[$opts] )* )
+			// Language\\Action.g3:146:4: option[$opts] ( COMMA option[$opts] )*
+			{
+			root_0 = (StringTemplateAST)adaptor.Nil();
+
+			PushFollow(Follow._option_in_optionList209);
+			option13=option(retval.opts);
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, option13.Tree);
+			// Language\\Action.g3:146:18: ( COMMA option[$opts] )*
+			for ( ; ; )
+			{
+				int alt3=2;
+				int LA3_0 = input.LA(1);
+
+				if ( (LA3_0==COMMA) )
+				{
+					alt3=1;
+				}
+
+
+				switch ( alt3 )
+				{
+				case 1:
+					// Language\\Action.g3:146:19: COMMA option[$opts]
+					{
+					COMMA14=(IToken)Match(input,COMMA,Follow._COMMA_in_optionList213); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					COMMA14_tree = (StringTemplateAST)adaptor.Create(COMMA14);
+					adaptor.AddChild(root_0, COMMA14_tree);
+					}
+					PushFollow(Follow._option_in_optionList215);
+					option15=option(retval.opts);
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, option15.Tree);
+
+					}
+					break;
+
+				default:
+					goto loop3;
+				}
+			}
+
+			loop3:
+				;
+
+
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "optionList"
+
+	public class option_return : ParserRuleReturnScope
+	{
+		public StringTemplateAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "option"
+	// Language\\Action.g3:149:0: option[IDictionary<string, object> opts] : ID ( ASSIGN nonAlternatingTemplateExpr |) ;
+	private ActionParser.option_return option( IDictionary<string, object> opts )
+	{
+		ActionParser.option_return retval = new ActionParser.option_return();
+		retval.start = input.LT(1);
+
+		StringTemplateAST root_0 = null;
+
+		IToken ID16=null;
+		IToken ASSIGN17=null;
+		ActionParser.nonAlternatingTemplateExpr_return nonAlternatingTemplateExpr18 = default(ActionParser.nonAlternatingTemplateExpr_return);
+
+		StringTemplateAST ID16_tree=null;
+		StringTemplateAST ASSIGN17_tree=null;
+
+
+		object v=null;
+
+		try
+		{
+			// Language\\Action.g3:154:4: ( ID ( ASSIGN nonAlternatingTemplateExpr |) )
+			// Language\\Action.g3:154:4: ID ( ASSIGN nonAlternatingTemplateExpr |)
+			{
+			root_0 = (StringTemplateAST)adaptor.Nil();
+
+			ID16=(IToken)Match(input,ID,Follow._ID_in_option235); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			ID16_tree = (StringTemplateAST)adaptor.Create(ID16);
+			adaptor.AddChild(root_0, ID16_tree);
+			}
+			// Language\\Action.g3:155:3: ( ASSIGN nonAlternatingTemplateExpr |)
+			int alt4=2;
+			int LA4_0 = input.LA(1);
+
+			if ( (LA4_0==ASSIGN) )
+			{
+				alt4=1;
+			}
+			else if ( (LA4_0==EOF||LA4_0==COMMA) )
+			{
+				alt4=2;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt4 )
+			{
+			case 1:
+				// Language\\Action.g3:155:5: ASSIGN nonAlternatingTemplateExpr
+				{
+				ASSIGN17=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_option241); if (state.failed) return retval;
+				if ( state.backtracking==0 ) {
+				ASSIGN17_tree = (StringTemplateAST)adaptor.Create(ASSIGN17);
+				adaptor.AddChild(root_0, ASSIGN17_tree);
+				}
+				PushFollow(Follow._nonAlternatingTemplateExpr_in_option243);
+				nonAlternatingTemplateExpr18=nonAlternatingTemplateExpr();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, nonAlternatingTemplateExpr18.Tree);
+				if ( state.backtracking == 0 )
+				{
+					v=(nonAlternatingTemplateExpr18!=null?((StringTemplateAST)nonAlternatingTemplateExpr18.tree):null);
+				}
+
+				}
+				break;
+			case 2:
+				// Language\\Action.g3:156:5:
+				{
+				if ( state.backtracking == 0 )
+				{
+					v=ASTExpr.EMPTY_OPTION;
+				}
+
+				}
+				break;
+
+			}
+
+			if ( state.backtracking == 0 )
+			{
+				opts[(ID16!=null?ID16.Text:null)] = v;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "option"
+
+	public class templatesExpr_return : ParserRuleReturnScope
+	{
+		public StringTemplateAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "templatesExpr"
+	// Language\\Action.g3:161:0: templatesExpr : expr ( ( COMMA expr )+ colon= COLON anonymousTemplate -> ^( MULTI_APPLY[\"MULTI_APPLY\"] ( expr )+ $colon anonymousTemplate ) | ( -> expr ) (colon= COLON templateList -> ^( APPLY[$colon] $templatesExpr templateList ) )* ) ;
+	private ActionParser.templatesExpr_return templatesExpr(  )
+	{
+		ActionParser.templatesExpr_return retval = new ActionParser.templatesExpr_return();
+		retval.start = input.LT(1);
+
+		StringTemplateAST root_0 = null;
+
+		IToken colon=null;
+		IToken COMMA20=null;
+		ActionParser.expr_return expr19 = default(ActionParser.expr_return);
+		ActionParser.expr_return expr21 = default(ActionParser.expr_return);
+		ActionParser.anonymousTemplate_return anonymousTemplate22 = default(ActionParser.anonymousTemplate_return);
+		ActionParser.templateList_return templateList23 = default(ActionParser.templateList_return);
+
+		StringTemplateAST colon_tree=null;
+		StringTemplateAST COMMA20_tree=null;
+		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
+		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
+		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
+		RewriteRuleSubtreeStream stream_anonymousTemplate=new RewriteRuleSubtreeStream(adaptor,"rule anonymousTemplate");
+		RewriteRuleSubtreeStream stream_templateList=new RewriteRuleSubtreeStream(adaptor,"rule templateList");
+		try
+		{
+			// Language\\Action.g3:163:3: ( expr ( ( COMMA expr )+ colon= COLON anonymousTemplate -> ^( MULTI_APPLY[\"MULTI_APPLY\"] ( expr )+ $colon anonymousTemplate ) | ( -> expr ) (colon= COLON templateList -> ^( APPLY[$colon] $templatesExpr templateList ) )* ) )
+			// Language\\Action.g3:163:3: expr ( ( COMMA expr )+ colon= COLON anonymousTemplate -> ^( MULTI_APPLY[\"MULTI_APPLY\"] ( expr )+ $colon anonymousTemplate ) | ( -> expr ) (colon= COLON templateList -> ^( APPLY[$colon] $templatesExpr templateList ) )* )
+			{
+			PushFollow(Follow._expr_in_templatesExpr273);
+			expr19=expr();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_expr.Add(expr19.Tree);
+			// Language\\Action.g3:164:3: ( ( COMMA expr )+ colon= COLON anonymousTemplate -> ^( MULTI_APPLY[\"MULTI_APPLY\"] ( expr )+ $colon anonymousTemplate ) | ( -> expr ) (colon= COLON templateList -> ^( APPLY[$colon] $templatesExpr templateList ) )* )
+			int alt7=2;
+			int LA7_0 = input.LA(1);
+
+			if ( (LA7_0==COMMA) )
+			{
+				alt7=1;
+			}
+			else if ( (LA7_0==EOF||LA7_0==COLON||(LA7_0>=RPAREN && LA7_0<=SEMI)) )
+			{
+				alt7=2;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt7 )
+			{
+			case 1:
+				// Language\\Action.g3:164:5: ( COMMA expr )+ colon= COLON anonymousTemplate
+				{
+				// Language\\Action.g3:164:5: ( COMMA expr )+
+				int cnt5=0;
+				for ( ; ; )
+				{
+					int alt5=2;
+					int LA5_0 = input.LA(1);
+
+					if ( (LA5_0==COMMA) )
+					{
+						alt5=1;
+					}
+
+
+					switch ( alt5 )
+					{
+					case 1:
+						// Language\\Action.g3:164:6: COMMA expr
+						{
+						COMMA20=(IToken)Match(input,COMMA,Follow._COMMA_in_templatesExpr280); if (state.failed) return retval;
+						if ( state.backtracking == 0 ) stream_COMMA.Add(COMMA20);
+
+						PushFollow(Follow._expr_in_templatesExpr282);
+						expr21=expr();
+
+						state._fsp--;
+						if (state.failed) return retval;
+						if ( state.backtracking == 0 ) stream_expr.Add(expr21.Tree);
+
+						}
+						break;
+
+					default:
+						if ( cnt5 >= 1 )
+							goto loop5;
+
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						EarlyExitException eee5 = new EarlyExitException( 5, input );
+						throw eee5;
+					}
+					cnt5++;
+				}
+				loop5:
+					;
+
+
+				colon=(IToken)Match(input,COLON,Follow._COLON_in_templatesExpr288); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_COLON.Add(colon);
+
+				PushFollow(Follow._anonymousTemplate_in_templatesExpr290);
+				anonymousTemplate22=anonymousTemplate();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_anonymousTemplate.Add(anonymousTemplate22.Tree);
+
+
+				{
+				// AST REWRITE
+				// elements: expr, colon, anonymousTemplate
+				// token labels: colon
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleITokenStream stream_colon=new RewriteRuleITokenStream(adaptor,"token colon",colon);
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (StringTemplateAST)adaptor.Nil();
+				// 165:4: -> ^( MULTI_APPLY[\"MULTI_APPLY\"] ( expr )+ $colon anonymousTemplate )
+				{
+					// Language\\Action.g3:165:7: ^( MULTI_APPLY[\"MULTI_APPLY\"] ( expr )+ $colon anonymousTemplate )
+					{
+					StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
+					root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(MULTI_APPLY, "MULTI_APPLY"), root_1);
+
+					if ( !(stream_expr.HasNext) )
+					{
+						throw new RewriteEarlyExitException();
+					}
+					while ( stream_expr.HasNext )
+					{
+						adaptor.AddChild(root_1, stream_expr.NextTree());
+
+					}
+					stream_expr.Reset();
+					adaptor.AddChild(root_1, stream_colon.NextNode());
+					adaptor.AddChild(root_1, stream_anonymousTemplate.NextTree());
+
+					adaptor.AddChild(root_0, root_1);
+					}
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 2:
+				// Language\\Action.g3:166:5: ( -> expr ) (colon= COLON templateList -> ^( APPLY[$colon] $templatesExpr templateList ) )*
+				{
+				// Language\\Action.g3:166:5: ( -> expr )
+				// Language\\Action.g3:166:7:
+				{
+
+
+
+				{
+				// AST REWRITE
+				// elements: expr
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (StringTemplateAST)adaptor.Nil();
+				// 166:7: -> expr
+				{
+					adaptor.AddChild(root_0, stream_expr.NextTree());
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+
+				// Language\\Action.g3:168:4: (colon= COLON templateList -> ^( APPLY[$colon] $templatesExpr templateList ) )*
+				for ( ; ; )
+				{
+					int alt6=2;
+					int LA6_0 = input.LA(1);
+
+					if ( (LA6_0==COLON) )
+					{
+						alt6=1;
+					}
+
+
+					switch ( alt6 )
+					{
+					case 1:
+						// Language\\Action.g3:168:6: colon= COLON templateList
+						{
+						colon=(IToken)Match(input,COLON,Follow._COLON_in_templatesExpr332); if (state.failed) return retval;
+						if ( state.backtracking == 0 ) stream_COLON.Add(colon);
+
+						PushFollow(Follow._templateList_in_templatesExpr334);
+						templateList23=templateList();
+
+						state._fsp--;
+						if (state.failed) return retval;
+						if ( state.backtracking == 0 ) stream_templateList.Add(templateList23.Tree);
+
+
+						{
+						// AST REWRITE
+						// elements: templatesExpr, templateList
+						// token labels:
+						// rule labels: retval
+						// token list labels:
+						// rule list labels:
+						// wildcard labels:
+						if ( state.backtracking == 0 ) {
+						retval.tree = root_0;
+						RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+						root_0 = (StringTemplateAST)adaptor.Nil();
+						// 169:5: -> ^( APPLY[$colon] $templatesExpr templateList )
+						{
+							// Language\\Action.g3:169:8: ^( APPLY[$colon] $templatesExpr templateList )
+							{
+							StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
+							root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(APPLY, colon), root_1);
+
+							adaptor.AddChild(root_1, stream_retval.NextTree());
+							adaptor.AddChild(root_1, stream_templateList.NextTree());
+
+							adaptor.AddChild(root_0, root_1);
+							}
+
+						}
+
+						retval.tree = root_0;
+						}
+						}
+
+						}
+						break;
+
+					default:
+						goto loop6;
+					}
+				}
+
+				loop6:
+					;
+
+
+
+				}
+				break;
+
+			}
+
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "templatesExpr"
+
+	public class templateList_return : ParserRuleReturnScope
+	{
+		public StringTemplateAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "templateList"
+	// Language\\Action.g3:174:0: templateList : template ( COMMA template )* ;
+	private ActionParser.templateList_return templateList(  )
+	{
+		ActionParser.templateList_return retval = new ActionParser.templateList_return();
+		retval.start = input.LT(1);
+
+		StringTemplateAST root_0 = null;
+
+		IToken COMMA25=null;
+		ActionParser.template_return template24 = default(ActionParser.template_return);
+		ActionParser.template_return template26 = default(ActionParser.template_return);
+
+		StringTemplateAST COMMA25_tree=null;
+
+		try
+		{
+			// Language\\Action.g3:175:4: ( template ( COMMA template )* )
+			// Language\\Action.g3:175:4: template ( COMMA template )*
+			{
+			root_0 = (StringTemplateAST)adaptor.Nil();
+
+			PushFollow(Follow._template_in_templateList373);
+			template24=template();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, template24.Tree);
+			// Language\\Action.g3:175:13: ( COMMA template )*
+			for ( ; ; )
+			{
+				int alt8=2;
+				int LA8_0 = input.LA(1);
+
+				if ( (LA8_0==COMMA) )
+				{
+					alt8=1;
+				}
+
+
+				switch ( alt8 )
+				{
+				case 1:
+					// Language\\Action.g3:175:14: COMMA template
+					{
+					COMMA25=(IToken)Match(input,COMMA,Follow._COMMA_in_templateList376); if (state.failed) return retval;
+					PushFollow(Follow._template_in_templateList379);
+					template26=template();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, template26.Tree);
+
+					}
+					break;
+
+				default:
+					goto loop8;
+				}
+			}
+
+			loop8:
+				;
+
+
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "templateList"
+
+	public class ifCondition_return : ParserRuleReturnScope
+	{
+		public StringTemplateAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "ifCondition"
+	// Language\\Action.g3:178:0: ifCondition : ( ifAtom | NOT ifAtom );
+	private ActionParser.ifCondition_return ifCondition(  )
+	{
+		ActionParser.ifCondition_return retval = new ActionParser.ifCondition_return();
+		retval.start = input.LT(1);
+
+		StringTemplateAST root_0 = null;
+
+		IToken NOT28=null;
+		ActionParser.ifAtom_return ifAtom27 = default(ActionParser.ifAtom_return);
+		ActionParser.ifAtom_return ifAtom29 = default(ActionParser.ifAtom_return);
+
+		StringTemplateAST NOT28_tree=null;
+
+		try
+		{
+			// Language\\Action.g3:179:4: ( ifAtom | NOT ifAtom )
+			int alt9=2;
+			int LA9_0 = input.LA(1);
+
+			if ( (LA9_0==ANONYMOUS_TEMPLATE||LA9_0==ID||(LA9_0>=INT && LA9_0<=LBRACK)||LA9_0==LPAREN||LA9_0==STRING||(LA9_0>=37 && LA9_0<=43)) )
+			{
+				alt9=1;
+			}
+			else if ( (LA9_0==NOT) )
+			{
+				alt9=2;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae = new NoViableAltException("", 9, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt9 )
+			{
+			case 1:
+				// Language\\Action.g3:179:4: ifAtom
+				{
+				root_0 = (StringTemplateAST)adaptor.Nil();
+
+				PushFollow(Follow._ifAtom_in_ifCondition392);
+				ifAtom27=ifAtom();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, ifAtom27.Tree);
+
+				}
+				break;
+			case 2:
+				// Language\\Action.g3:180:4: NOT ifAtom
+				{
+				root_0 = (StringTemplateAST)adaptor.Nil();
+
+				NOT28=(IToken)Match(input,NOT,Follow._NOT_in_ifCondition397); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) {
+				NOT28_tree = (StringTemplateAST)adaptor.Create(NOT28);
+				root_0 = (StringTemplateAST)adaptor.BecomeRoot(NOT28_tree, root_0);
+				}
+				PushFollow(Follow._ifAtom_in_ifCondition400);
+				ifAtom29=ifAtom();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, ifAtom29.Tree);
+
+				}
+				break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "ifCondition"
+
+	public class ifAtom_return : ParserRuleReturnScope
+	{
+		public StringTemplateAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "ifAtom"
+	// Language\\Action.g3:183:0: ifAtom : templatesExpr ;
+	private ActionParser.ifAtom_return ifAtom(  )
+	{
+		ActionParser.ifAtom_return retval = new ActionParser.ifAtom_return();
+		retval.start = input.LT(1);
+
+		StringTemplateAST root_0 = null;
+
+		ActionParser.templatesExpr_return templatesExpr30 = default(ActionParser.templatesExpr_return);
+
+
+		try
+		{
+			// Language\\Action.g3:184:4: ( templatesExpr )
+			// Language\\Action.g3:184:4: templatesExpr
+			{
+			root_0 = (StringTemplateAST)adaptor.Nil();
+
+			PushFollow(Follow._templatesExpr_in_ifAtom411);
+			templatesExpr30=templatesExpr();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, templatesExpr30.Tree);
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "ifAtom"
+
+	public class expr_return : ParserRuleReturnScope
+	{
+		public StringTemplateAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "expr"
+	// Language\\Action.g3:187:0: expr : primaryExpr ( PLUS primaryExpr )* ;
+	private ActionParser.expr_return expr(  )
+	{
+		ActionParser.expr_return retval = new ActionParser.expr_return();
+		retval.start = input.LT(1);
+
+		StringTemplateAST root_0 = null;
+
+		IToken PLUS32=null;
+		ActionParser.primaryExpr_return primaryExpr31 = default(ActionParser.primaryExpr_return);
+		ActionParser.primaryExpr_return primaryExpr33 = default(ActionParser.primaryExpr_return);
+
+		StringTemplateAST PLUS32_tree=null;
+
+		try
+		{
+			// Language\\Action.g3:188:4: ( primaryExpr ( PLUS primaryExpr )* )
+			// Language\\Action.g3:188:4: primaryExpr ( PLUS primaryExpr )*
+			{
+			root_0 = (StringTemplateAST)adaptor.Nil();
+
+			PushFollow(Follow._primaryExpr_in_expr422);
+			primaryExpr31=primaryExpr();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, primaryExpr31.Tree);
+			// Language\\Action.g3:188:16: ( PLUS primaryExpr )*
+			for ( ; ; )
+			{
+				int alt10=2;
+				int LA10_0 = input.LA(1);
+
+				if ( (LA10_0==PLUS) )
+				{
+					alt10=1;
+				}
+
+
+				switch ( alt10 )
+				{
+				case 1:
+					// Language\\Action.g3:188:17: PLUS primaryExpr
+					{
+					PLUS32=(IToken)Match(input,PLUS,Follow._PLUS_in_expr425); if (state.failed) return retval;
+					if ( state.backtracking == 0 ) {
+					PLUS32_tree = (StringTemplateAST)adaptor.Create(PLUS32);
+					root_0 = (StringTemplateAST)adaptor.BecomeRoot(PLUS32_tree, root_0);
+					}
+					PushFollow(Follow._primaryExpr_in_expr428);
+					primaryExpr33=primaryExpr();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, primaryExpr33.Tree);
+
+					}
+					break;
+
+				default:
+					goto loop10;
+				}
+			}
+
+			loop10:
+				;
+
+
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "expr"
+
+	public class primaryExpr_return : ParserRuleReturnScope
+	{
+		public StringTemplateAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "primaryExpr"
+	// Language\\Action.g3:191:0: primaryExpr : (=> templateInclude | atom ( DOT ( ID | valueExpr ) )* | function ( DOT ( ID | valueExpr ) )* | valueExpr | list );
+	private ActionParser.primaryExpr_return primaryExpr(  )
+	{
+		ActionParser.primaryExpr_return retval = new ActionParser.primaryExpr_return();
+		retval.start = input.LT(1);
+
+		StringTemplateAST root_0 = null;
+
+		IToken DOT36=null;
+		IToken ID37=null;
+		IToken DOT40=null;
+		IToken ID41=null;
+		ActionParser.templateInclude_return templateInclude34 = default(ActionParser.templateInclude_return);
+		ActionParser.atom_return atom35 = default(ActionParser.atom_return);
+		ActionParser.valueExpr_return valueExpr38 = default(ActionParser.valueExpr_return);
+		ActionParser.function_return function39 = default(ActionParser.function_return);
+		ActionParser.valueExpr_return valueExpr42 = default(ActionParser.valueExpr_return);
+		ActionParser.valueExpr_return valueExpr43 = default(ActionParser.valueExpr_return);
+		ActionParser.list_return list44 = default(ActionParser.list_return);
+
+		StringTemplateAST DOT36_tree=null;
+		StringTemplateAST ID37_tree=null;
+		StringTemplateAST DOT40_tree=null;
+		StringTemplateAST ID41_tree=null;
+
+		try
+		{
+			// Language\\Action.g3:192:4: (=> templateInclude | atom ( DOT ( ID | valueExpr ) )* | function ( DOT ( ID | valueExpr ) )* | valueExpr | list )
+			int alt15=5;
+			alt15 = dfa15.Predict(input);
+			switch ( alt15 )
+			{
+			case 1:
+				// Language\\Action.g3:192:4: => templateInclude
+				{
+				root_0 = (StringTemplateAST)adaptor.Nil();
+
+
+				PushFollow(Follow._templateInclude_in_primaryExpr445);
+				templateInclude34=templateInclude();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, templateInclude34.Tree);
+
+				}
+				break;
+			case 2:
+				// Language\\Action.g3:193:4: atom ( DOT ( ID | valueExpr ) )*
+				{
+				root_0 = (StringTemplateAST)adaptor.Nil();
+
+				PushFollow(Follow._atom_in_primaryExpr452);
+				atom35=atom();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, atom35.Tree);
+				// Language\\Action.g3:194:3: ( DOT ( ID | valueExpr ) )*
+				for ( ; ; )
+				{
+					int alt12=2;
+					int LA12_0 = input.LA(1);
+
+					if ( (LA12_0==DOT) )
+					{
+						alt12=1;
+					}
+
+
+					switch ( alt12 )
+					{
+					case 1:
+						// Language\\Action.g3:194:5: DOT ( ID | valueExpr )
+						{
+						DOT36=(IToken)Match(input,DOT,Follow._DOT_in_primaryExpr458); if (state.failed) return retval;
+						if ( state.backtracking == 0 ) {
+						DOT36_tree = (StringTemplateAST)adaptor.Create(DOT36);
+						root_0 = (StringTemplateAST)adaptor.BecomeRoot(DOT36_tree, root_0);
+						}
+						// Language\\Action.g3:195:4: ( ID | valueExpr )
+						int alt11=2;
+						int LA11_0 = input.LA(1);
+
+						if ( (LA11_0==ID) )
+						{
+							alt11=1;
+						}
+						else if ( (LA11_0==LPAREN) )
+						{
+							alt11=2;
+						}
+						else
+						{
+							if (state.backtracking>0) {state.failed=true; return retval;}
+							NoViableAltException nvae = new NoViableAltException("", 11, 0, input);
+
+							throw nvae;
+						}
+						switch ( alt11 )
+						{
+						case 1:
+							// Language\\Action.g3:195:6: ID
+							{
+							ID37=(IToken)Match(input,ID,Follow._ID_in_primaryExpr467); if (state.failed) return retval;
+							if ( state.backtracking==0 ) {
+							ID37_tree = (StringTemplateAST)adaptor.Create(ID37);
+							adaptor.AddChild(root_0, ID37_tree);
+							}
+
+							}
+							break;
+						case 2:
+							// Language\\Action.g3:196:6: valueExpr
+							{
+							PushFollow(Follow._valueExpr_in_primaryExpr474);
+							valueExpr38=valueExpr();
+
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking == 0 ) adaptor.AddChild(root_0, valueExpr38.Tree);
+
+							}
+							break;
+
+						}
+
+
+						}
+						break;
+
+					default:
+						goto loop12;
+					}
+				}
+
+				loop12:
+					;
+
+
+
+				}
+				break;
+			case 3:
+				// Language\\Action.g3:199:4: function ( DOT ( ID | valueExpr ) )*
+				{
+				root_0 = (StringTemplateAST)adaptor.Nil();
+
+				PushFollow(Follow._function_in_primaryExpr489);
+				function39=function();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, function39.Tree);
+				// Language\\Action.g3:200:3: ( DOT ( ID | valueExpr ) )*
+				for ( ; ; )
+				{
+					int alt14=2;
+					int LA14_0 = input.LA(1);
+
+					if ( (LA14_0==DOT) )
+					{
+						alt14=1;
+					}
+
+
+					switch ( alt14 )
+					{
+					case 1:
+						// Language\\Action.g3:200:5: DOT ( ID | valueExpr )
+						{
+						DOT40=(IToken)Match(input,DOT,Follow._DOT_in_primaryExpr495); if (state.failed) return retval;
+						if ( state.backtracking == 0 ) {
+						DOT40_tree = (StringTemplateAST)adaptor.Create(DOT40);
+						root_0 = (StringTemplateAST)adaptor.BecomeRoot(DOT40_tree, root_0);
+						}
+						// Language\\Action.g3:201:4: ( ID | valueExpr )
+						int alt13=2;
+						int LA13_0 = input.LA(1);
+
+						if ( (LA13_0==ID) )
+						{
+							alt13=1;
+						}
+						else if ( (LA13_0==LPAREN) )
+						{
+							alt13=2;
+						}
+						else
+						{
+							if (state.backtracking>0) {state.failed=true; return retval;}
+							NoViableAltException nvae = new NoViableAltException("", 13, 0, input);
+
+							throw nvae;
+						}
+						switch ( alt13 )
+						{
+						case 1:
+							// Language\\Action.g3:201:6: ID
+							{
+							ID41=(IToken)Match(input,ID,Follow._ID_in_primaryExpr503); if (state.failed) return retval;
+							if ( state.backtracking==0 ) {
+							ID41_tree = (StringTemplateAST)adaptor.Create(ID41);
+							adaptor.AddChild(root_0, ID41_tree);
+							}
+
+							}
+							break;
+						case 2:
+							// Language\\Action.g3:202:6: valueExpr
+							{
+							PushFollow(Follow._valueExpr_in_primaryExpr510);
+							valueExpr42=valueExpr();
+
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking == 0 ) adaptor.AddChild(root_0, valueExpr42.Tree);
+
+							}
+							break;
+
+						}
+
+
+						}
+						break;
+
+					default:
+						goto loop14;
+					}
+				}
+
+				loop14:
+					;
+
+
+
+				}
+				break;
+			case 4:
+				// Language\\Action.g3:205:4: valueExpr
+				{
+				root_0 = (StringTemplateAST)adaptor.Nil();
+
+				PushFollow(Follow._valueExpr_in_primaryExpr525);
+				valueExpr43=valueExpr();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, valueExpr43.Tree);
+
+				}
+				break;
+			case 5:
+				// Language\\Action.g3:206:4: list
+				{
+				root_0 = (StringTemplateAST)adaptor.Nil();
+
+				PushFollow(Follow._list_in_primaryExpr530);
+				list44=list();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, list44.Tree);
+
+				}
+				break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "primaryExpr"
+
+	public class valueExpr_return : ParserRuleReturnScope
+	{
+		public StringTemplateAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "valueExpr"
+	// Language\\Action.g3:209:0: valueExpr : LPAREN templatesExpr RPAREN -> ^( VALUE[$LPAREN,\"value\"] templatesExpr ) ;
+	private ActionParser.valueExpr_return valueExpr(  )
+	{
+		ActionParser.valueExpr_return retval = new ActionParser.valueExpr_return();
+		retval.start = input.LT(1);
+
+		StringTemplateAST root_0 = null;
+
+		IToken LPAREN45=null;
+		IToken RPAREN47=null;
+		ActionParser.templatesExpr_return templatesExpr46 = default(ActionParser.templatesExpr_return);
+
+		StringTemplateAST LPAREN45_tree=null;
+		StringTemplateAST RPAREN47_tree=null;
+		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
+		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
+		RewriteRuleSubtreeStream stream_templatesExpr=new RewriteRuleSubtreeStream(adaptor,"rule templatesExpr");
+		try
+		{
+			// Language\\Action.g3:210:4: ( LPAREN templatesExpr RPAREN -> ^( VALUE[$LPAREN,\"value\"] templatesExpr ) )
+			// Language\\Action.g3:210:4: LPAREN templatesExpr RPAREN
+			{
+			LPAREN45=(IToken)Match(input,LPAREN,Follow._LPAREN_in_valueExpr541); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_LPAREN.Add(LPAREN45);
+
+			PushFollow(Follow._templatesExpr_in_valueExpr543);
+			templatesExpr46=templatesExpr();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_templatesExpr.Add(templatesExpr46.Tree);
+			RPAREN47=(IToken)Match(input,RPAREN,Follow._RPAREN_in_valueExpr545); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_RPAREN.Add(RPAREN47);
+
+
+
+			{
+			// AST REWRITE
+			// elements: templatesExpr
+			// token labels:
+			// rule labels: retval
+			// token list labels:
+			// rule list labels:
+			// wildcard labels:
+			if ( state.backtracking == 0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+			root_0 = (StringTemplateAST)adaptor.Nil();
+			// 211:3: -> ^( VALUE[$LPAREN,\"value\"] templatesExpr )
+			{
+				// Language\\Action.g3:211:6: ^( VALUE[$LPAREN,\"value\"] templatesExpr )
+				{
+				StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
+				root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(VALUE, LPAREN45, "value"), root_1);
+
+				adaptor.AddChild(root_1, stream_templatesExpr.NextTree());
+
+				adaptor.AddChild(root_0, root_1);
+				}
+
+			}
+
+			retval.tree = root_0;
+			}
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "valueExpr"
+
+	public class nonAlternatingTemplateExpr_return : ParserRuleReturnScope
+	{
+		public StringTemplateAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "nonAlternatingTemplateExpr"
+	// Language\\Action.g3:214:0: nonAlternatingTemplateExpr : ( expr -> expr ) ( COLON template -> ^( APPLY[$COLON] $nonAlternatingTemplateExpr template ) )* ;
+	private ActionParser.nonAlternatingTemplateExpr_return nonAlternatingTemplateExpr(  )
+	{
+		ActionParser.nonAlternatingTemplateExpr_return retval = new ActionParser.nonAlternatingTemplateExpr_return();
+		retval.start = input.LT(1);
+
+		StringTemplateAST root_0 = null;
+
+		IToken COLON49=null;
+		ActionParser.expr_return expr48 = default(ActionParser.expr_return);
+		ActionParser.template_return template50 = default(ActionParser.template_return);
+
+		StringTemplateAST COLON49_tree=null;
+		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
+		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
+		RewriteRuleSubtreeStream stream_template=new RewriteRuleSubtreeStream(adaptor,"rule template");
+		try
+		{
+			// Language\\Action.g3:215:4: ( ( expr -> expr ) ( COLON template -> ^( APPLY[$COLON] $nonAlternatingTemplateExpr template ) )* )
+			// Language\\Action.g3:215:4: ( expr -> expr ) ( COLON template -> ^( APPLY[$COLON] $nonAlternatingTemplateExpr template ) )*
+			{
+			// Language\\Action.g3:215:4: ( expr -> expr )
+			// Language\\Action.g3:215:5: expr
+			{
+			PushFollow(Follow._expr_in_nonAlternatingTemplateExpr568);
+			expr48=expr();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_expr.Add(expr48.Tree);
+
+
+			{
+			// AST REWRITE
+			// elements: expr
+			// token labels:
+			// rule labels: retval
+			// token list labels:
+			// rule list labels:
+			// wildcard labels:
+			if ( state.backtracking == 0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+			root_0 = (StringTemplateAST)adaptor.Nil();
+			// 215:10: -> expr
+			{
+				adaptor.AddChild(root_0, stream_expr.NextTree());
+
+			}
+
+			retval.tree = root_0;
+			}
+			}
+
+			}
+
+			// Language\\Action.g3:215:19: ( COLON template -> ^( APPLY[$COLON] $nonAlternatingTemplateExpr template ) )*
+			for ( ; ; )
+			{
+				int alt16=2;
+				int LA16_0 = input.LA(1);
+
+				if ( (LA16_0==COLON) )
+				{
+					alt16=1;
+				}
+
+
+				switch ( alt16 )
+				{
+				case 1:
+					// Language\\Action.g3:215:21: COLON template
+					{
+					COLON49=(IToken)Match(input,COLON,Follow._COLON_in_nonAlternatingTemplateExpr577); if (state.failed) return retval;
+					if ( state.backtracking == 0 ) stream_COLON.Add(COLON49);
+
+					PushFollow(Follow._template_in_nonAlternatingTemplateExpr579);
+					template50=template();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) stream_template.Add(template50.Tree);
+
+
+					{
+					// AST REWRITE
+					// elements: nonAlternatingTemplateExpr, template
+					// token labels:
+					// rule labels: retval
+					// token list labels:
+					// rule list labels:
+					// wildcard labels:
+					if ( state.backtracking == 0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+					root_0 = (StringTemplateAST)adaptor.Nil();
+					// 215:36: -> ^( APPLY[$COLON] $nonAlternatingTemplateExpr template )
+					{
+						// Language\\Action.g3:215:39: ^( APPLY[$COLON] $nonAlternatingTemplateExpr template )
+						{
+						StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
+						root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(APPLY, COLON49), root_1);
+
+						adaptor.AddChild(root_1, stream_retval.NextTree());
+						adaptor.AddChild(root_1, stream_template.NextTree());
+
+						adaptor.AddChild(root_0, root_1);
+						}
+
+					}
+
+					retval.tree = root_0;
+					}
+					}
+
+					}
+					break;
+
+				default:
+					goto loop16;
+				}
+			}
+
+			loop16:
+				;
+
+
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "nonAlternatingTemplateExpr"
+
+	public class function_return : ParserRuleReturnScope
+	{
+		public StringTemplateAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "function"
+	// Language\\Action.g3:218:0: function : ( 'first' | 'rest' | 'last' | 'length' | 'strip' | 'trunc' ) singleArg -> ^( FUNCTION ( 'first' )? ( 'rest' )? ( 'last' )? ( 'length' )? ( 'strip' )? ( 'trunc' )? singleArg ) ;
+	private ActionParser.function_return function(  )
+	{
+		ActionParser.function_return retval = new ActionParser.function_return();
+		retval.start = input.LT(1);
+
+		StringTemplateAST root_0 = null;
+
+		IToken string_literal51=null;
+		IToken string_literal52=null;
+		IToken string_literal53=null;
+		IToken string_literal54=null;
+		IToken string_literal55=null;
+		IToken string_literal56=null;
+		ActionParser.singleArg_return singleArg57 = default(ActionParser.singleArg_return);
+
+		StringTemplateAST string_literal51_tree=null;
+		StringTemplateAST string_literal52_tree=null;
+		StringTemplateAST string_literal53_tree=null;
+		StringTemplateAST string_literal54_tree=null;
+		StringTemplateAST string_literal55_tree=null;
+		StringTemplateAST string_literal56_tree=null;
+		RewriteRuleITokenStream stream_37=new RewriteRuleITokenStream(adaptor,"token 37");
+		RewriteRuleITokenStream stream_40=new RewriteRuleITokenStream(adaptor,"token 40");
+		RewriteRuleITokenStream stream_38=new RewriteRuleITokenStream(adaptor,"token 38");
+		RewriteRuleITokenStream stream_39=new RewriteRuleITokenStream(adaptor,"token 39");
+		RewriteRuleITokenStream stream_41=new RewriteRuleITokenStream(adaptor,"token 41");
+		RewriteRuleITokenStream stream_43=new RewriteRuleITokenStream(adaptor,"token 43");
+		RewriteRuleSubtreeStream stream_singleArg=new RewriteRuleSubtreeStream(adaptor,"rule singleArg");
+		try
+		{
+			// Language\\Action.g3:219:4: ( ( 'first' | 'rest' | 'last' | 'length' | 'strip' | 'trunc' ) singleArg -> ^( FUNCTION ( 'first' )? ( 'rest' )? ( 'last' )? ( 'length' )? ( 'strip' )? ( 'trunc' )? singleArg ) )
+			// Language\\Action.g3:219:4: ( 'first' | 'rest' | 'last' | 'length' | 'strip' | 'trunc' ) singleArg
+			{
+			// Language\\Action.g3:219:4: ( 'first' | 'rest' | 'last' | 'length' | 'strip' | 'trunc' )
+			int alt17=6;
+			switch ( input.LA(1) )
+			{
+			case 37:
+				{
+				alt17=1;
+				}
+				break;
+			case 40:
+				{
+				alt17=2;
+				}
+				break;
+			case 38:
+				{
+				alt17=3;
+				}
+				break;
+			case 39:
+				{
+				alt17=4;
+				}
+				break;
+			case 41:
+				{
+				alt17=5;
+				}
+				break;
+			case 43:
+				{
+				alt17=6;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 17, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt17 )
+			{
+			case 1:
+				// Language\\Action.g3:219:6: 'first'
+				{
+				string_literal51=(IToken)Match(input,37,Follow._37_in_function607); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_37.Add(string_literal51);
+
+
+				}
+				break;
+			case 2:
+				// Language\\Action.g3:220:5: 'rest'
+				{
+				string_literal52=(IToken)Match(input,40,Follow._40_in_function613); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_40.Add(string_literal52);
+
+
+				}
+				break;
+			case 3:
+				// Language\\Action.g3:221:5: 'last'
+				{
+				string_literal53=(IToken)Match(input,38,Follow._38_in_function619); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_38.Add(string_literal53);
+
+
+				}
+				break;
+			case 4:
+				// Language\\Action.g3:222:5: 'length'
+				{
+				string_literal54=(IToken)Match(input,39,Follow._39_in_function625); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_39.Add(string_literal54);
+
+
+				}
+				break;
+			case 5:
+				// Language\\Action.g3:223:5: 'strip'
+				{
+				string_literal55=(IToken)Match(input,41,Follow._41_in_function631); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_41.Add(string_literal55);
+
+
+				}
+				break;
+			case 6:
+				// Language\\Action.g3:224:5: 'trunc'
+				{
+				string_literal56=(IToken)Match(input,43,Follow._43_in_function637); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_43.Add(string_literal56);
+
+
+				}
+				break;
+
+			}
+
+			PushFollow(Follow._singleArg_in_function645);
+			singleArg57=singleArg();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_singleArg.Add(singleArg57.Tree);
+
+
+			{
+			// AST REWRITE
+			// elements: 37, 40, 38, 39, 41, 43, singleArg
+			// token labels:
+			// rule labels: retval
+			// token list labels:
+			// rule list labels:
+			// wildcard labels:
+			if ( state.backtracking == 0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+			root_0 = (StringTemplateAST)adaptor.Nil();
+			// 227:3: -> ^( FUNCTION ( 'first' )? ( 'rest' )? ( 'last' )? ( 'length' )? ( 'strip' )? ( 'trunc' )? singleArg )
+			{
+				// Language\\Action.g3:227:6: ^( FUNCTION ( 'first' )? ( 'rest' )? ( 'last' )? ( 'length' )? ( 'strip' )? ( 'trunc' )? singleArg )
+				{
+				StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
+				root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(FUNCTION, "FUNCTION"), root_1);
+
+				// Language\\Action.g3:227:17: ( 'first' )?
+				if ( stream_37.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_37.NextNode());
+
+				}
+				stream_37.Reset();
+				// Language\\Action.g3:227:26: ( 'rest' )?
+				if ( stream_40.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_40.NextNode());
+
+				}
+				stream_40.Reset();
+				// Language\\Action.g3:227:34: ( 'last' )?
+				if ( stream_38.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_38.NextNode());
+
+				}
+				stream_38.Reset();
+				// Language\\Action.g3:227:42: ( 'length' )?
+				if ( stream_39.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_39.NextNode());
+
+				}
+				stream_39.Reset();
+				// Language\\Action.g3:227:52: ( 'strip' )?
+				if ( stream_41.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_41.NextNode());
+
+				}
+				stream_41.Reset();
+				// Language\\Action.g3:227:61: ( 'trunc' )?
+				if ( stream_43.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_43.NextNode());
+
+				}
+				stream_43.Reset();
+				adaptor.AddChild(root_1, stream_singleArg.NextTree());
+
+				adaptor.AddChild(root_0, root_1);
+				}
+
+			}
+
+			retval.tree = root_0;
+			}
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "function"
+
+	public class template_return : ParserRuleReturnScope
+	{
+		public StringTemplateAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "template"
+	// Language\\Action.g3:230:0: template : ( namedTemplate | anonymousTemplate ) -> ^( TEMPLATE ( namedTemplate )? ( anonymousTemplate )? ) ;
+	private ActionParser.template_return template(  )
+	{
+		ActionParser.template_return retval = new ActionParser.template_return();
+		retval.start = input.LT(1);
+
+		StringTemplateAST root_0 = null;
+
+		ActionParser.namedTemplate_return namedTemplate58 = default(ActionParser.namedTemplate_return);
+		ActionParser.anonymousTemplate_return anonymousTemplate59 = default(ActionParser.anonymousTemplate_return);
+
+		RewriteRuleSubtreeStream stream_namedTemplate=new RewriteRuleSubtreeStream(adaptor,"rule namedTemplate");
+		RewriteRuleSubtreeStream stream_anonymousTemplate=new RewriteRuleSubtreeStream(adaptor,"rule anonymousTemplate");
+		try
+		{
+			// Language\\Action.g3:231:4: ( ( namedTemplate | anonymousTemplate ) -> ^( TEMPLATE ( namedTemplate )? ( anonymousTemplate )? ) )
+			// Language\\Action.g3:231:4: ( namedTemplate | anonymousTemplate )
+			{
+			// Language\\Action.g3:231:4: ( namedTemplate | anonymousTemplate )
+			int alt18=2;
+			int LA18_0 = input.LA(1);
+
+			if ( (LA18_0==ID||LA18_0==LPAREN||LA18_0==42) )
+			{
+				alt18=1;
+			}
+			else if ( (LA18_0==ANONYMOUS_TEMPLATE) )
+			{
+				alt18=2;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae = new NoViableAltException("", 18, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt18 )
+			{
+			case 1:
+				// Language\\Action.g3:231:6: namedTemplate
+				{
+				PushFollow(Follow._namedTemplate_in_template686);
+				namedTemplate58=namedTemplate();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_namedTemplate.Add(namedTemplate58.Tree);
+
+				}
+				break;
+			case 2:
+				// Language\\Action.g3:232:5: anonymousTemplate
+				{
+				PushFollow(Follow._anonymousTemplate_in_template695);
+				anonymousTemplate59=anonymousTemplate();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_anonymousTemplate.Add(anonymousTemplate59.Tree);
+
+				}
+				break;
+
+			}
+
+
+
+			{
+			// AST REWRITE
+			// elements: namedTemplate, anonymousTemplate
+			// token labels:
+			// rule labels: retval
+			// token list labels:
+			// rule list labels:
+			// wildcard labels:
+			if ( state.backtracking == 0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+			root_0 = (StringTemplateAST)adaptor.Nil();
+			// 234:3: -> ^( TEMPLATE ( namedTemplate )? ( anonymousTemplate )? )
+			{
+				// Language\\Action.g3:234:6: ^( TEMPLATE ( namedTemplate )? ( anonymousTemplate )? )
+				{
+				StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
+				root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(TEMPLATE, "TEMPLATE"), root_1);
+
+				// Language\\Action.g3:234:17: ( namedTemplate )?
+				if ( stream_namedTemplate.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_namedTemplate.NextTree());
+
+				}
+				stream_namedTemplate.Reset();
+				// Language\\Action.g3:234:32: ( anonymousTemplate )?
+				if ( stream_anonymousTemplate.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_anonymousTemplate.NextTree());
+
+				}
+				stream_anonymousTemplate.Reset();
+
+				adaptor.AddChild(root_0, root_1);
+				}
+
+			}
+
+			retval.tree = root_0;
+			}
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "template"
+
+	public class namedTemplate_return : ParserRuleReturnScope
+	{
+		public StringTemplateAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "namedTemplate"
+	// Language\\Action.g3:237:0: namedTemplate : ( ID argList -> ID argList | 'super' DOT qid= ID argList -> ID[$qid,\"super.\"+$qid.text] argList | indirectTemplate -> indirectTemplate );
+	private ActionParser.namedTemplate_return namedTemplate(  )
+	{
+		ActionParser.namedTemplate_return retval = new ActionParser.namedTemplate_return();
+		retval.start = input.LT(1);
+
+		StringTemplateAST root_0 = null;
+
+		IToken qid=null;
+		IToken ID60=null;
+		IToken string_literal62=null;
+		IToken DOT63=null;
+		ActionParser.argList_return argList61 = default(ActionParser.argList_return);
+		ActionParser.argList_return argList64 = default(ActionParser.argList_return);
+		ActionParser.indirectTemplate_return indirectTemplate65 = default(ActionParser.indirectTemplate_return);
+
+		StringTemplateAST qid_tree=null;
+		StringTemplateAST ID60_tree=null;
+		StringTemplateAST string_literal62_tree=null;
+		StringTemplateAST DOT63_tree=null;
+		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
+		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
+		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
+		RewriteRuleSubtreeStream stream_argList=new RewriteRuleSubtreeStream(adaptor,"rule argList");
+		RewriteRuleSubtreeStream stream_indirectTemplate=new RewriteRuleSubtreeStream(adaptor,"rule indirectTemplate");
+		try
+		{
+			// Language\\Action.g3:238:4: ( ID argList -> ID argList | 'super' DOT qid= ID argList -> ID[$qid,\"super.\"+$qid.text] argList | indirectTemplate -> indirectTemplate )
+			int alt19=3;
+			switch ( input.LA(1) )
+			{
+			case ID:
+				{
+				alt19=1;
+				}
+				break;
+			case 42:
+				{
+				alt19=2;
+				}
+				break;
+			case LPAREN:
+				{
+				alt19=3;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 19, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt19 )
+			{
+			case 1:
+				// Language\\Action.g3:238:4: ID argList
+				{
+				ID60=(IToken)Match(input,ID,Follow._ID_in_namedTemplate726); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_ID.Add(ID60);
+
+				PushFollow(Follow._argList_in_namedTemplate728);
+				argList61=argList();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_argList.Add(argList61.Tree);
+
+
+				{
+				// AST REWRITE
+				// elements: ID, argList
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (StringTemplateAST)adaptor.Nil();
+				// 239:3: -> ID argList
+				{
+					adaptor.AddChild(root_0, stream_ID.NextNode());
+					adaptor.AddChild(root_0, stream_argList.NextTree());
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 2:
+				// Language\\Action.g3:240:4: 'super' DOT qid= ID argList
+				{
+				string_literal62=(IToken)Match(input,42,Follow._42_in_namedTemplate741); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_42.Add(string_literal62);
+
+				DOT63=(IToken)Match(input,DOT,Follow._DOT_in_namedTemplate743); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_DOT.Add(DOT63);
+
+				qid=(IToken)Match(input,ID,Follow._ID_in_namedTemplate747); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_ID.Add(qid);
+
+				PushFollow(Follow._argList_in_namedTemplate749);
+				argList64=argList();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_argList.Add(argList64.Tree);
+
+
+				{
+				// AST REWRITE
+				// elements: ID, argList
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (StringTemplateAST)adaptor.Nil();
+				// 241:3: -> ID[$qid,\"super.\"+$qid.text] argList
+				{
+					adaptor.AddChild(root_0, (StringTemplateAST)adaptor.Create(ID, qid, "super."+(qid!=null?qid.Text:null)));
+					adaptor.AddChild(root_0, stream_argList.NextTree());
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 3:
+				// Language\\Action.g3:242:4: indirectTemplate
+				{
+				PushFollow(Follow._indirectTemplate_in_namedTemplate763);
+				indirectTemplate65=indirectTemplate();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_indirectTemplate.Add(indirectTemplate65.Tree);
+
+
+				{
+				// AST REWRITE
+				// elements: indirectTemplate
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (StringTemplateAST)adaptor.Nil();
+				// 243:3: -> indirectTemplate
+				{
+					adaptor.AddChild(root_0, stream_indirectTemplate.NextTree());
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "namedTemplate"
+
+	public class anonymousTemplate_return : ParserRuleReturnScope
+	{
+		public StringTemplateAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "anonymousTemplate"
+	// Language\\Action.g3:246:0: anonymousTemplate : t= ANONYMOUS_TEMPLATE ;
+	private ActionParser.anonymousTemplate_return anonymousTemplate(  )
+	{
+		ActionParser.anonymousTemplate_return retval = new ActionParser.anonymousTemplate_return();
+		retval.start = input.LT(1);
+
+		StringTemplateAST root_0 = null;
+
+		IToken t=null;
+
+		StringTemplateAST t_tree=null;
+
+
+			StringTemplate anonymous = null;
+
+		try
+		{
+			// Language\\Action.g3:255:4: (t= ANONYMOUS_TEMPLATE )
+			// Language\\Action.g3:255:4: t= ANONYMOUS_TEMPLATE
+			{
+			root_0 = (StringTemplateAST)adaptor.Nil();
+
+			t=(IToken)Match(input,ANONYMOUS_TEMPLATE,Follow._ANONYMOUS_TEMPLATE_in_anonymousTemplate792); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			t_tree = (StringTemplateAST)adaptor.Create(t);
+			adaptor.AddChild(root_0, t_tree);
+			}
+			if ( state.backtracking == 0 )
+			{
+
+							anonymous = new StringTemplate();
+							anonymous.setGroup(self.getGroup());
+							anonymous.setEnclosingInstance(self);
+							anonymous.setTemplate((t!=null?t.Text:null));
+							if ( t is StringTemplateToken )
+								anonymous.defineFormalArguments(((StringTemplateToken)t).args);
+							else
+								anonymous.defineFormalArguments(new ArrayList());
+
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+			if ( state.backtracking == 0 )
+			{
+
+					((StringTemplateAST)retval.tree).StringTemplate = anonymous;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "anonymousTemplate"
+
+	public class atom_return : ParserRuleReturnScope
+	{
+		public StringTemplateAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "atom"
+	// Language\\Action.g3:268:0: atom : ( ID | STRING | INT | ANONYMOUS_TEMPLATE );
+	private ActionParser.atom_return atom(  )
+	{
+		ActionParser.atom_return retval = new ActionParser.atom_return();
+		retval.start = input.LT(1);
+
+		StringTemplateAST root_0 = null;
+
+		IToken set66=null;
+
+		StringTemplateAST set66_tree=null;
+
+		try
+		{
+			// Language\\Action.g3:269:4: ( ID | STRING | INT | ANONYMOUS_TEMPLATE )
+			// Language\\Action.g3:
+			{
+			root_0 = (StringTemplateAST)adaptor.Nil();
+
+			set66=(IToken)input.LT(1);
+			if ( input.LA(1)==ANONYMOUS_TEMPLATE||input.LA(1)==ID||input.LA(1)==INT||input.LA(1)==STRING )
+			{
+				input.Consume();
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (StringTemplateAST)adaptor.Create(set66));
+				state.errorRecovery=false;state.failed=false;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				throw mse;
+			}
+
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "atom"
+
+	public class list_return : ParserRuleReturnScope
+	{
+		public StringTemplateAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "list"
+	// Language\\Action.g3:275:0: list : lb= LBRACK listElement ( COMMA listElement )* RBRACK -> ^( LIST[$lb,\"value\"] ( listElement )+ ) ;
+	private ActionParser.list_return list(  )
+	{
+		ActionParser.list_return retval = new ActionParser.list_return();
+		retval.start = input.LT(1);
+
+		StringTemplateAST root_0 = null;
+
+		IToken lb=null;
+		IToken COMMA68=null;
+		IToken RBRACK70=null;
+		ActionParser.listElement_return listElement67 = default(ActionParser.listElement_return);
+		ActionParser.listElement_return listElement69 = default(ActionParser.listElement_return);
+
+		StringTemplateAST lb_tree=null;
+		StringTemplateAST COMMA68_tree=null;
+		StringTemplateAST RBRACK70_tree=null;
+		RewriteRuleITokenStream stream_LBRACK=new RewriteRuleITokenStream(adaptor,"token LBRACK");
+		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
+		RewriteRuleITokenStream stream_RBRACK=new RewriteRuleITokenStream(adaptor,"token RBRACK");
+		RewriteRuleSubtreeStream stream_listElement=new RewriteRuleSubtreeStream(adaptor,"rule listElement");
+		try
+		{
+			// Language\\Action.g3:276:4: (lb= LBRACK listElement ( COMMA listElement )* RBRACK -> ^( LIST[$lb,\"value\"] ( listElement )+ ) )
+			// Language\\Action.g3:276:4: lb= LBRACK listElement ( COMMA listElement )* RBRACK
+			{
+			lb=(IToken)Match(input,LBRACK,Follow._LBRACK_in_list835); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_LBRACK.Add(lb);
+
+			PushFollow(Follow._listElement_in_list839);
+			listElement67=listElement();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_listElement.Add(listElement67.Tree);
+			// Language\\Action.g3:277:15: ( COMMA listElement )*
+			for ( ; ; )
+			{
+				int alt20=2;
+				int LA20_0 = input.LA(1);
+
+				if ( (LA20_0==COMMA) )
+				{
+					alt20=1;
+				}
+
+
+				switch ( alt20 )
+				{
+				case 1:
+					// Language\\Action.g3:277:16: COMMA listElement
+					{
+					COMMA68=(IToken)Match(input,COMMA,Follow._COMMA_in_list842); if (state.failed) return retval;
+					if ( state.backtracking == 0 ) stream_COMMA.Add(COMMA68);
+
+					PushFollow(Follow._listElement_in_list844);
+					listElement69=listElement();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) stream_listElement.Add(listElement69.Tree);
+
+					}
+					break;
+
+				default:
+					goto loop20;
+				}
+			}
+
+			loop20:
+				;
+
+
+			RBRACK70=(IToken)Match(input,RBRACK,Follow._RBRACK_in_list850); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_RBRACK.Add(RBRACK70);
+
+
+
+			{
+			// AST REWRITE
+			// elements: listElement
+			// token labels:
+			// rule labels: retval
+			// token list labels:
+			// rule list labels:
+			// wildcard labels:
+			if ( state.backtracking == 0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+			root_0 = (StringTemplateAST)adaptor.Nil();
+			// 279:3: -> ^( LIST[$lb,\"value\"] ( listElement )+ )
+			{
+				// Language\\Action.g3:279:6: ^( LIST[$lb,\"value\"] ( listElement )+ )
+				{
+				StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
+				root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(LIST, lb, "value"), root_1);
+
+				if ( !(stream_listElement.HasNext) )
+				{
+					throw new RewriteEarlyExitException();
+				}
+				while ( stream_listElement.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_listElement.NextTree());
+
+				}
+				stream_listElement.Reset();
+
+				adaptor.AddChild(root_0, root_1);
+				}
+
+			}
+
+			retval.tree = root_0;
+			}
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "list"
+
+	public class listElement_return : ParserRuleReturnScope
+	{
+		public StringTemplateAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "listElement"
+	// Language\\Action.g3:282:0: listElement : ( nonAlternatingTemplateExpr | -> NOTHING[\"NOTHING\"] );
+	private ActionParser.listElement_return listElement(  )
+	{
+		ActionParser.listElement_return retval = new ActionParser.listElement_return();
+		retval.start = input.LT(1);
+
+		StringTemplateAST root_0 = null;
+
+		ActionParser.nonAlternatingTemplateExpr_return nonAlternatingTemplateExpr71 = default(ActionParser.nonAlternatingTemplateExpr_return);
+
+
+		try
+		{
+			// Language\\Action.g3:283:4: ( nonAlternatingTemplateExpr | -> NOTHING[\"NOTHING\"] )
+			int alt21=2;
+			int LA21_0 = input.LA(1);
+
+			if ( (LA21_0==ANONYMOUS_TEMPLATE||LA21_0==ID||(LA21_0>=INT && LA21_0<=LBRACK)||LA21_0==LPAREN||LA21_0==STRING||(LA21_0>=37 && LA21_0<=43)) )
+			{
+				alt21=1;
+			}
+			else if ( (LA21_0==COMMA||LA21_0==RBRACK) )
+			{
+				alt21=2;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae = new NoViableAltException("", 21, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt21 )
+			{
+			case 1:
+				// Language\\Action.g3:283:4: nonAlternatingTemplateExpr
+				{
+				root_0 = (StringTemplateAST)adaptor.Nil();
+
+				PushFollow(Follow._nonAlternatingTemplateExpr_in_listElement873);
+				nonAlternatingTemplateExpr71=nonAlternatingTemplateExpr();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, nonAlternatingTemplateExpr71.Tree);
+
+				}
+				break;
+			case 2:
+				// Language\\Action.g3:285:3:
+				{
+
+
+
+				{
+				// AST REWRITE
+				// elements:
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (StringTemplateAST)adaptor.Nil();
+				// 285:3: -> NOTHING[\"NOTHING\"]
+				{
+					adaptor.AddChild(root_0, (StringTemplateAST)adaptor.Create(NOTHING, "NOTHING"));
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "listElement"
+
+	public class templateInclude_return : ParserRuleReturnScope
+	{
+		public StringTemplateAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "templateInclude"
+	// Language\\Action.g3:288:0: templateInclude : (id= ID argList -> $id argList | 'super' DOT qid= ID argList -> ID[$qid,\"super.\"+$qid.text] argList | indirectTemplate -> indirectTemplate ) -> ^( INCLUDE[\"include\"] $templateInclude) ;
+	private ActionParser.templateInclude_return templateInclude(  )
+	{
+		ActionParser.templateInclude_return retval = new ActionParser.templateInclude_return();
+		retval.start = input.LT(1);
+
+		StringTemplateAST root_0 = null;
+
+		IToken id=null;
+		IToken qid=null;
+		IToken string_literal73=null;
+		IToken DOT74=null;
+		ActionParser.argList_return argList72 = default(ActionParser.argList_return);
+		ActionParser.argList_return argList75 = default(ActionParser.argList_return);
+		ActionParser.indirectTemplate_return indirectTemplate76 = default(ActionParser.indirectTemplate_return);
+
+		StringTemplateAST id_tree=null;
+		StringTemplateAST qid_tree=null;
+		StringTemplateAST string_literal73_tree=null;
+		StringTemplateAST DOT74_tree=null;
+		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
+		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
+		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
+		RewriteRuleSubtreeStream stream_argList=new RewriteRuleSubtreeStream(adaptor,"rule argList");
+		RewriteRuleSubtreeStream stream_indirectTemplate=new RewriteRuleSubtreeStream(adaptor,"rule indirectTemplate");
+		try
+		{
+			// Language\\Action.g3:289:4: ( (id= ID argList -> $id argList | 'super' DOT qid= ID argList -> ID[$qid,\"super.\"+$qid.text] argList | indirectTemplate -> indirectTemplate ) -> ^( INCLUDE[\"include\"] $templateInclude) )
+			// Language\\Action.g3:289:4: (id= ID argList -> $id argList | 'super' DOT qid= ID argList -> ID[$qid,\"super.\"+$qid.text] argList | indirectTemplate -> indirectTemplate )
+			{
+			// Language\\Action.g3:289:4: (id= ID argList -> $id argList | 'super' DOT qid= ID argList -> ID[$qid,\"super.\"+$qid.text] argList | indirectTemplate -> indirectTemplate )
+			int alt22=3;
+			switch ( input.LA(1) )
+			{
+			case ID:
+				{
+				alt22=1;
+				}
+				break;
+			case 42:
+				{
+				alt22=2;
+				}
+				break;
+			case LPAREN:
+				{
+				alt22=3;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 22, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt22 )
+			{
+			case 1:
+				// Language\\Action.g3:289:6: id= ID argList
+				{
+				id=(IToken)Match(input,ID,Follow._ID_in_templateInclude898); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_ID.Add(id);
+
+				PushFollow(Follow._argList_in_templateInclude900);
+				argList72=argList();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_argList.Add(argList72.Tree);
+
+
+				{
+				// AST REWRITE
+				// elements: id, argList
+				// token labels: id
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleITokenStream stream_id=new RewriteRuleITokenStream(adaptor,"token id",id);
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (StringTemplateAST)adaptor.Nil();
+				// 289:20: -> $id argList
+				{
+					adaptor.AddChild(root_0, stream_id.NextNode());
+					adaptor.AddChild(root_0, stream_argList.NextTree());
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 2:
+				// Language\\Action.g3:290:5: 'super' DOT qid= ID argList
+				{
+				string_literal73=(IToken)Match(input,42,Follow._42_in_templateInclude913); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_42.Add(string_literal73);
+
+				DOT74=(IToken)Match(input,DOT,Follow._DOT_in_templateInclude915); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_DOT.Add(DOT74);
+
+				qid=(IToken)Match(input,ID,Follow._ID_in_templateInclude919); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_ID.Add(qid);
+
+				PushFollow(Follow._argList_in_templateInclude921);
+				argList75=argList();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_argList.Add(argList75.Tree);
+
+
+				{
+				// AST REWRITE
+				// elements: ID, argList
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (StringTemplateAST)adaptor.Nil();
+				// 290:32: -> ID[$qid,\"super.\"+$qid.text] argList
+				{
+					adaptor.AddChild(root_0, (StringTemplateAST)adaptor.Create(ID, qid, "super."+(qid!=null?qid.Text:null)));
+					adaptor.AddChild(root_0, stream_argList.NextTree());
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 3:
+				// Language\\Action.g3:291:5: indirectTemplate
+				{
+				PushFollow(Follow._indirectTemplate_in_templateInclude934);
+				indirectTemplate76=indirectTemplate();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_indirectTemplate.Add(indirectTemplate76.Tree);
+
+
+				{
+				// AST REWRITE
+				// elements: indirectTemplate
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (StringTemplateAST)adaptor.Nil();
+				// 291:22: -> indirectTemplate
+				{
+					adaptor.AddChild(root_0, stream_indirectTemplate.NextTree());
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+
+			}
+
+
+
+			{
+			// AST REWRITE
+			// elements: templateInclude
+			// token labels:
+			// rule labels: retval
+			// token list labels:
+			// rule list labels:
+			// wildcard labels:
+			if ( state.backtracking == 0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+			root_0 = (StringTemplateAST)adaptor.Nil();
+			// 293:3: -> ^( INCLUDE[\"include\"] $templateInclude)
+			{
+				// Language\\Action.g3:293:6: ^( INCLUDE[\"include\"] $templateInclude)
+				{
+				StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
+				root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(INCLUDE, "include"), root_1);
+
+				adaptor.AddChild(root_1, stream_retval.NextTree());
+
+				adaptor.AddChild(root_0, root_1);
+				}
+
+			}
+
+			retval.tree = root_0;
+			}
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "templateInclude"
+
+	public class indirectTemplate_return : ParserRuleReturnScope
+	{
+		public StringTemplateAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "indirectTemplate"
+	// Language\\Action.g3:297:0: indirectTemplate : LPAREN e= templatesExpr RPAREN args= argList -> ^( VALUE[\"value\"] $e $args) ;
+	private ActionParser.indirectTemplate_return indirectTemplate(  )
+	{
+		ActionParser.indirectTemplate_return retval = new ActionParser.indirectTemplate_return();
+		retval.start = input.LT(1);
+
+		StringTemplateAST root_0 = null;
+
+		IToken LPAREN77=null;
+		IToken RPAREN78=null;
+		ActionParser.templatesExpr_return e = default(ActionParser.templatesExpr_return);
+		ActionParser.argList_return args = default(ActionParser.argList_return);
+
+		StringTemplateAST LPAREN77_tree=null;
+		StringTemplateAST RPAREN78_tree=null;
+		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
+		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
+		RewriteRuleSubtreeStream stream_templatesExpr=new RewriteRuleSubtreeStream(adaptor,"rule templatesExpr");
+		RewriteRuleSubtreeStream stream_argList=new RewriteRuleSubtreeStream(adaptor,"rule argList");
+		try
+		{
+			// Language\\Action.g3:298:4: ( LPAREN e= templatesExpr RPAREN args= argList -> ^( VALUE[\"value\"] $e $args) )
+			// Language\\Action.g3:298:4: LPAREN e= templatesExpr RPAREN args= argList
+			{
+			LPAREN77=(IToken)Match(input,LPAREN,Follow._LPAREN_in_indirectTemplate968); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_LPAREN.Add(LPAREN77);
+
+			PushFollow(Follow._templatesExpr_in_indirectTemplate972);
+			e=templatesExpr();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_templatesExpr.Add(e.Tree);
+			RPAREN78=(IToken)Match(input,RPAREN,Follow._RPAREN_in_indirectTemplate974); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_RPAREN.Add(RPAREN78);
+
+			PushFollow(Follow._argList_in_indirectTemplate978);
+			args=argList();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_argList.Add(args.Tree);
+
+
+			{
+			// AST REWRITE
+			// elements: e, args
+			// token labels:
+			// rule labels: e, args, retval
+			// token list labels:
+			// rule list labels:
+			// wildcard labels:
+			if ( state.backtracking == 0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_e=new RewriteRuleSubtreeStream(adaptor,"rule e",e!=null?e.tree:null);
+			RewriteRuleSubtreeStream stream_args=new RewriteRuleSubtreeStream(adaptor,"rule args",args!=null?args.tree:null);
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+			root_0 = (StringTemplateAST)adaptor.Nil();
+			// 299:3: -> ^( VALUE[\"value\"] $e $args)
+			{
+				// Language\\Action.g3:299:6: ^( VALUE[\"value\"] $e $args)
+				{
+				StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
+				root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(VALUE, "value"), root_1);
+
+				adaptor.AddChild(root_1, stream_e.NextTree());
+				adaptor.AddChild(root_1, stream_args.NextTree());
+
+				adaptor.AddChild(root_0, root_1);
+				}
+
+			}
+
+			retval.tree = root_0;
+			}
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "indirectTemplate"
+
+	public class argList_return : ParserRuleReturnScope
+	{
+		public StringTemplateAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "argList"
+	// Language\\Action.g3:302:0: argList : ( LPAREN RPAREN -> ARGS[\"ARGS\"] |=> singleArg -> singleArg | LPAREN argumentAssignment ( COMMA argumentAssignment )* RPAREN -> ^( ARGS[\"ARGS\"] ( argumentAssignment )+ ) );
+	private ActionParser.argList_return argList(  )
+	{
+		ActionParser.argList_return retval = new ActionParser.argList_return();
+		retval.start = input.LT(1);
+
+		StringTemplateAST root_0 = null;
+
+		IToken LPAREN79=null;
+		IToken RPAREN80=null;
+		IToken LPAREN82=null;
+		IToken COMMA84=null;
+		IToken RPAREN86=null;
+		ActionParser.singleArg_return singleArg81 = default(ActionParser.singleArg_return);
+		ActionParser.argumentAssignment_return argumentAssignment83 = default(ActionParser.argumentAssignment_return);
+		ActionParser.argumentAssignment_return argumentAssignment85 = default(ActionParser.argumentAssignment_return);
+
+		StringTemplateAST LPAREN79_tree=null;
+		StringTemplateAST RPAREN80_tree=null;
+		StringTemplateAST LPAREN82_tree=null;
+		StringTemplateAST COMMA84_tree=null;
+		StringTemplateAST RPAREN86_tree=null;
+		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
+		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
+		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
+		RewriteRuleSubtreeStream stream_singleArg=new RewriteRuleSubtreeStream(adaptor,"rule singleArg");
+		RewriteRuleSubtreeStream stream_argumentAssignment=new RewriteRuleSubtreeStream(adaptor,"rule argumentAssignment");
+		try
+		{
+			// Language\\Action.g3:303:4: ( LPAREN RPAREN -> ARGS[\"ARGS\"] |=> singleArg -> singleArg | LPAREN argumentAssignment ( COMMA argumentAssignment )* RPAREN -> ^( ARGS[\"ARGS\"] ( argumentAssignment )+ ) )
+			int alt24=3;
+			alt24 = dfa24.Predict(input);
+			switch ( alt24 )
+			{
+			case 1:
+				// Language\\Action.g3:303:4: LPAREN RPAREN
+				{
+				LPAREN79=(IToken)Match(input,LPAREN,Follow._LPAREN_in_argList1005); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_LPAREN.Add(LPAREN79);
+
+				RPAREN80=(IToken)Match(input,RPAREN,Follow._RPAREN_in_argList1007); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_RPAREN.Add(RPAREN80);
+
+
+
+				{
+				// AST REWRITE
+				// elements:
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (StringTemplateAST)adaptor.Nil();
+				// 303:18: -> ARGS[\"ARGS\"]
+				{
+					adaptor.AddChild(root_0, (StringTemplateAST)adaptor.Create(ARGS, "ARGS"));
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 2:
+				// Language\\Action.g3:304:4: => singleArg
+				{
+
+				PushFollow(Follow._singleArg_in_argList1022);
+				singleArg81=singleArg();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_singleArg.Add(singleArg81.Tree);
+
+
+				{
+				// AST REWRITE
+				// elements: singleArg
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (StringTemplateAST)adaptor.Nil();
+				// 304:27: -> singleArg
+				{
+					adaptor.AddChild(root_0, stream_singleArg.NextTree());
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 3:
+				// Language\\Action.g3:305:4: LPAREN argumentAssignment ( COMMA argumentAssignment )* RPAREN
+				{
+				LPAREN82=(IToken)Match(input,LPAREN,Follow._LPAREN_in_argList1039); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_LPAREN.Add(LPAREN82);
+
+				PushFollow(Follow._argumentAssignment_in_argList1041);
+				argumentAssignment83=argumentAssignment();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_argumentAssignment.Add(argumentAssignment83.Tree);
+				// Language\\Action.g3:305:30: ( COMMA argumentAssignment )*
+				for ( ; ; )
+				{
+					int alt23=2;
+					int LA23_0 = input.LA(1);
+
+					if ( (LA23_0==COMMA) )
+					{
+						alt23=1;
+					}
+
+
+					switch ( alt23 )
+					{
+					case 1:
+						// Language\\Action.g3:305:31: COMMA argumentAssignment
+						{
+						COMMA84=(IToken)Match(input,COMMA,Follow._COMMA_in_argList1044); if (state.failed) return retval;
+						if ( state.backtracking == 0 ) stream_COMMA.Add(COMMA84);
+
+						PushFollow(Follow._argumentAssignment_in_argList1046);
+						argumentAssignment85=argumentAssignment();
+
+						state._fsp--;
+						if (state.failed) return retval;
+						if ( state.backtracking == 0 ) stream_argumentAssignment.Add(argumentAssignment85.Tree);
+
+						}
+						break;
+
+					default:
+						goto loop23;
+					}
+				}
+
+				loop23:
+					;
+
+
+				RPAREN86=(IToken)Match(input,RPAREN,Follow._RPAREN_in_argList1050); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_RPAREN.Add(RPAREN86);
+
+
+
+				{
+				// AST REWRITE
+				// elements: argumentAssignment
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (StringTemplateAST)adaptor.Nil();
+				// 306:3: -> ^( ARGS[\"ARGS\"] ( argumentAssignment )+ )
+				{
+					// Language\\Action.g3:306:6: ^( ARGS[\"ARGS\"] ( argumentAssignment )+ )
+					{
+					StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
+					root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(ARGS, "ARGS"), root_1);
+
+					if ( !(stream_argumentAssignment.HasNext) )
+					{
+						throw new RewriteEarlyExitException();
+					}
+					while ( stream_argumentAssignment.HasNext )
+					{
+						adaptor.AddChild(root_1, stream_argumentAssignment.NextTree());
+
+					}
+					stream_argumentAssignment.Reset();
+
+					adaptor.AddChild(root_0, root_1);
+					}
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "argList"
+
+	public class singleArg_return : ParserRuleReturnScope
+	{
+		public StringTemplateAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "singleArg"
+	// Language\\Action.g3:309:0: singleArg : LPAREN nonAlternatingTemplateExpr RPAREN -> ^( SINGLEVALUEARG[\"SINGLEVALUEARG\"] nonAlternatingTemplateExpr ) ;
+	private ActionParser.singleArg_return singleArg(  )
+	{
+		ActionParser.singleArg_return retval = new ActionParser.singleArg_return();
+		retval.start = input.LT(1);
+
+		StringTemplateAST root_0 = null;
+
+		IToken LPAREN87=null;
+		IToken RPAREN89=null;
+		ActionParser.nonAlternatingTemplateExpr_return nonAlternatingTemplateExpr88 = default(ActionParser.nonAlternatingTemplateExpr_return);
+
+		StringTemplateAST LPAREN87_tree=null;
+		StringTemplateAST RPAREN89_tree=null;
+		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
+		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
+		RewriteRuleSubtreeStream stream_nonAlternatingTemplateExpr=new RewriteRuleSubtreeStream(adaptor,"rule nonAlternatingTemplateExpr");
+		try
+		{
+			// Language\\Action.g3:310:4: ( LPAREN nonAlternatingTemplateExpr RPAREN -> ^( SINGLEVALUEARG[\"SINGLEVALUEARG\"] nonAlternatingTemplateExpr ) )
+			// Language\\Action.g3:310:4: LPAREN nonAlternatingTemplateExpr RPAREN
+			{
+			LPAREN87=(IToken)Match(input,LPAREN,Follow._LPAREN_in_singleArg1073); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_LPAREN.Add(LPAREN87);
+
+			PushFollow(Follow._nonAlternatingTemplateExpr_in_singleArg1075);
+			nonAlternatingTemplateExpr88=nonAlternatingTemplateExpr();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_nonAlternatingTemplateExpr.Add(nonAlternatingTemplateExpr88.Tree);
+			RPAREN89=(IToken)Match(input,RPAREN,Follow._RPAREN_in_singleArg1077); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_RPAREN.Add(RPAREN89);
+
+
+
+			{
+			// AST REWRITE
+			// elements: nonAlternatingTemplateExpr
+			// token labels:
+			// rule labels: retval
+			// token list labels:
+			// rule list labels:
+			// wildcard labels:
+			if ( state.backtracking == 0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+			root_0 = (StringTemplateAST)adaptor.Nil();
+			// 311:3: -> ^( SINGLEVALUEARG[\"SINGLEVALUEARG\"] nonAlternatingTemplateExpr )
+			{
+				// Language\\Action.g3:311:6: ^( SINGLEVALUEARG[\"SINGLEVALUEARG\"] nonAlternatingTemplateExpr )
+				{
+				StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
+				root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(SINGLEVALUEARG, "SINGLEVALUEARG"), root_1);
+
+				adaptor.AddChild(root_1, stream_nonAlternatingTemplateExpr.NextTree());
+
+				adaptor.AddChild(root_0, root_1);
+				}
+
+			}
+
+			retval.tree = root_0;
+			}
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "singleArg"
+
+	public class argumentAssignment_return : ParserRuleReturnScope
+	{
+		public StringTemplateAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "argumentAssignment"
+	// Language\\Action.g3:314:0: argumentAssignment : ( ID ASSIGN nonAlternatingTemplateExpr | DOTDOTDOT );
+	private ActionParser.argumentAssignment_return argumentAssignment(  )
+	{
+		ActionParser.argumentAssignment_return retval = new ActionParser.argumentAssignment_return();
+		retval.start = input.LT(1);
+
+		StringTemplateAST root_0 = null;
+
+		IToken ID90=null;
+		IToken ASSIGN91=null;
+		IToken DOTDOTDOT93=null;
+		ActionParser.nonAlternatingTemplateExpr_return nonAlternatingTemplateExpr92 = default(ActionParser.nonAlternatingTemplateExpr_return);
+
+		StringTemplateAST ID90_tree=null;
+		StringTemplateAST ASSIGN91_tree=null;
+		StringTemplateAST DOTDOTDOT93_tree=null;
+
+		try
+		{
+			// Language\\Action.g3:315:4: ( ID ASSIGN nonAlternatingTemplateExpr | DOTDOTDOT )
+			int alt25=2;
+			int LA25_0 = input.LA(1);
+
+			if ( (LA25_0==ID) )
+			{
+				alt25=1;
+			}
+			else if ( (LA25_0==DOTDOTDOT) )
+			{
+				alt25=2;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae = new NoViableAltException("", 25, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt25 )
+			{
+			case 1:
+				// Language\\Action.g3:315:4: ID ASSIGN nonAlternatingTemplateExpr
+				{
+				root_0 = (StringTemplateAST)adaptor.Nil();
+
+				ID90=(IToken)Match(input,ID,Follow._ID_in_argumentAssignment1099); if (state.failed) return retval;
+				if ( state.backtracking==0 ) {
+				ID90_tree = (StringTemplateAST)adaptor.Create(ID90);
+				adaptor.AddChild(root_0, ID90_tree);
+				}
+				ASSIGN91=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_argumentAssignment1101); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) {
+				ASSIGN91_tree = (StringTemplateAST)adaptor.Create(ASSIGN91);
+				root_0 = (StringTemplateAST)adaptor.BecomeRoot(ASSIGN91_tree, root_0);
+				}
+				PushFollow(Follow._nonAlternatingTemplateExpr_in_argumentAssignment1104);
+				nonAlternatingTemplateExpr92=nonAlternatingTemplateExpr();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, nonAlternatingTemplateExpr92.Tree);
+
+				}
+				break;
+			case 2:
+				// Language\\Action.g3:316:4: DOTDOTDOT
+				{
+				root_0 = (StringTemplateAST)adaptor.Nil();
+
+				DOTDOTDOT93=(IToken)Match(input,DOTDOTDOT,Follow._DOTDOTDOT_in_argumentAssignment1109); if (state.failed) return retval;
+				if ( state.backtracking==0 ) {
+				DOTDOTDOT93_tree = (StringTemplateAST)adaptor.Create(DOTDOTDOT93);
+				adaptor.AddChild(root_0, DOTDOTDOT93_tree);
+				}
+
+				}
+				break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "argumentAssignment"
+
+	// $ANTLR start synpred1_Action
+	public void synpred1_Action_fragment()
+	{
+		// Language\\Action.g3:192:4: ( templateInclude )
+		// Language\\Action.g3:192:5: templateInclude
+		{
+		PushFollow(Follow._templateInclude_in_synpred1_Action442);
+		templateInclude();
+
+		state._fsp--;
+		if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred1_Action
+
+	// $ANTLR start synpred2_Action
+	public void synpred2_Action_fragment()
+	{
+		// Language\\Action.g3:304:4: ( singleArg )
+		// Language\\Action.g3:304:5: singleArg
+		{
+		PushFollow(Follow._singleArg_in_synpred2_Action1019);
+		singleArg();
+
+		state._fsp--;
+		if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred2_Action
+	#endregion
+
+	// Delegated rules
+
+	#region Synpreds
+	public bool synpred1_Action()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred1_Action_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred2_Action()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred2_Action_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+
+	#endregion
+
+	#region DFA
+	DFA15 dfa15;
+	DFA24 dfa24;
+
+	protected override void InitDFAs()
+	{
+		base.InitDFAs();
+		dfa15 = new DFA15( this, new SpecialStateTransitionHandler( specialStateTransition15 ) );
+		dfa24 = new DFA24( this, new SpecialStateTransitionHandler( specialStateTransition24 ) );
+	}
+
+	class DFA15 : DFA
+	{
+
+		const string DFA15_eotS =
+			"\xD\xFFFF";
+		const string DFA15_eofS =
+			"\xD\xFFFF";
+		const string DFA15_minS =
+			"\x1\x4\x1\x0\x1\xFFFF\x1\x0\x9\xFFFF";
+		const string DFA15_maxS =
+			"\x1\x2B\x1\x0\x1\xFFFF\x1\x0\x9\xFFFF";
+		const string DFA15_acceptS =
+			"\x2\xFFFF\x1\x1\x1\xFFFF\x1\x2\x1\x3\x5\xFFFF\x1\x5\x1\x4";
+		const string DFA15_specialS =
+			"\x1\x0\x1\x1\x1\xFFFF\x1\x2\x9\xFFFF}>";
+		static readonly string[] DFA15_transitionS =
+			{
+				"\x1\x4\xA\xFFFF\x1\x1\x1\xFFFF\x1\x4\x1\xB\x1\xFFFF\x1\x3\x9\xFFFF\x1"+
+				"\x4\x6\xFFFF\x5\x5\x1\x2\x1\x5",
+				"\x1\xFFFF",
+				"",
+				"\x1\xFFFF",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				""
+			};
+
+		static readonly short[] DFA15_eot = DFA.UnpackEncodedString(DFA15_eotS);
+		static readonly short[] DFA15_eof = DFA.UnpackEncodedString(DFA15_eofS);
+		static readonly char[] DFA15_min = DFA.UnpackEncodedStringToUnsignedChars(DFA15_minS);
+		static readonly char[] DFA15_max = DFA.UnpackEncodedStringToUnsignedChars(DFA15_maxS);
+		static readonly short[] DFA15_accept = DFA.UnpackEncodedString(DFA15_acceptS);
+		static readonly short[] DFA15_special = DFA.UnpackEncodedString(DFA15_specialS);
+		static readonly short[][] DFA15_transition;
+
+		static DFA15()
+		{
+			int numStates = DFA15_transitionS.Length;
+			DFA15_transition = new short[numStates][];
+			for ( int i=0; i < numStates; i++ )
+			{
+				DFA15_transition[i] = DFA.UnpackEncodedString(DFA15_transitionS[i]);
+			}
+		}
+
+		public DFA15( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
+			: base( specialStateTransition )	{
+			this.recognizer = recognizer;
+			this.decisionNumber = 15;
+			this.eot = DFA15_eot;
+			this.eof = DFA15_eof;
+			this.min = DFA15_min;
+			this.max = DFA15_max;
+			this.accept = DFA15_accept;
+			this.special = DFA15_special;
+			this.transition = DFA15_transition;
+		}
+		public override string GetDescription()
+		{
+			return "191:0: primaryExpr : (=> templateInclude | atom ( DOT ( ID | valueExpr ) )* | function ( DOT ( ID | valueExpr ) )* | valueExpr | list );";
+		}
+	}
+
+	int specialStateTransition15( DFA dfa, int s, IIntStream _input )
+	{
+		ITokenStream input = (ITokenStream)_input;
+		int _s = s;
+		switch ( s )
+		{
+
+			case 0:
+				int LA15_0 = input.LA(1);
+
+
+				int index15_0 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (LA15_0==ID) ) {s = 1;}
+
+				else if ( (LA15_0==42) && (synpred1_Action())) {s = 2;}
+
+				else if ( (LA15_0==LPAREN) ) {s = 3;}
+
+				else if ( (LA15_0==ANONYMOUS_TEMPLATE||LA15_0==INT||LA15_0==STRING) ) {s = 4;}
+
+				else if ( ((LA15_0>=37 && LA15_0<=41)||LA15_0==43) ) {s = 5;}
+
+				else if ( (LA15_0==LBRACK) ) {s = 11;}
+
+
+				input.Seek(index15_0);
+				if ( s>=0 ) return s;
+				break;
+
+			case 1:
+				int LA15_1 = input.LA(1);
+
+
+				int index15_1 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred1_Action()) ) {s = 2;}
+
+				else if ( (true) ) {s = 4;}
+
+
+				input.Seek(index15_1);
+				if ( s>=0 ) return s;
+				break;
+
+			case 2:
+				int LA15_3 = input.LA(1);
+
+
+				int index15_3 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred1_Action()) ) {s = 2;}
+
+				else if ( (true) ) {s = 12;}
+
+
+				input.Seek(index15_3);
+				if ( s>=0 ) return s;
+				break;
+		}
+		if (state.backtracking>0) {state.failed=true; return -1;}
+		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 15, _s, input);
+		dfa.Error(nvae);
+		throw nvae;
+	}
+	class DFA24 : DFA
+	{
+
+		const string DFA24_eotS =
+			"\x14\xFFFF";
+		const string DFA24_eofS =
+			"\x14\xFFFF";
+		const string DFA24_minS =
+			"\x1\x14\x1\x4\x1\xFFFF\x1\x7\x10\xFFFF";
+		const string DFA24_maxS =
+			"\x1\x14\x1\x2B\x1\xFFFF\x1\x1B\x10\xFFFF";
+		const string DFA24_acceptS =
+			"\x2\xFFFF\x1\x1\x1\xFFFF\xA\x2\x1\x3\x5\x2";
+		const string DFA24_specialS =
+			"\x1\xFFFF\x1\x0\x1\xFFFF\x1\x1\x10\xFFFF}>";
+		static readonly string[] DFA24_transitionS =
+			{
+				"\x1\x1",
+				"\x1\x6\x7\xFFFF\x1\xE\x2\xFFFF\x1\x3\x1\xFFFF\x1\x6\x1\xD\x1\xFFFF\x1"+
+				"\x5\x6\xFFFF\x1\x2\x2\xFFFF\x1\x6\x6\xFFFF\x1\x7\x1\x9\x1\xA\x1\x8\x1"+
+				"\xB\x1\x4\x1\xC",
+				"",
+				"\x1\xE\x1\x12\x2\xFFFF\x1\x10\x8\xFFFF\x1\xF\x4\xFFFF\x1\x11\x1\xFFFF"+
+				"\x1\x13",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				""
+			};
+
+		static readonly short[] DFA24_eot = DFA.UnpackEncodedString(DFA24_eotS);
+		static readonly short[] DFA24_eof = DFA.UnpackEncodedString(DFA24_eofS);
+		static readonly char[] DFA24_min = DFA.UnpackEncodedStringToUnsignedChars(DFA24_minS);
+		static readonly char[] DFA24_max = DFA.UnpackEncodedStringToUnsignedChars(DFA24_maxS);
+		static readonly short[] DFA24_accept = DFA.UnpackEncodedString(DFA24_acceptS);
+		static readonly short[] DFA24_special = DFA.UnpackEncodedString(DFA24_specialS);
+		static readonly short[][] DFA24_transition;
+
+		static DFA24()
+		{
+			int numStates = DFA24_transitionS.Length;
+			DFA24_transition = new short[numStates][];
+			for ( int i=0; i < numStates; i++ )
+			{
+				DFA24_transition[i] = DFA.UnpackEncodedString(DFA24_transitionS[i]);
+			}
+		}
+
+		public DFA24( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
+			: base( specialStateTransition )	{
+			this.recognizer = recognizer;
+			this.decisionNumber = 24;
+			this.eot = DFA24_eot;
+			this.eof = DFA24_eof;
+			this.min = DFA24_min;
+			this.max = DFA24_max;
+			this.accept = DFA24_accept;
+			this.special = DFA24_special;
+			this.transition = DFA24_transition;
+		}
+		public override string GetDescription()
+		{
+			return "302:0: argList : ( LPAREN RPAREN -> ARGS[\"ARGS\"] |=> singleArg -> singleArg | LPAREN argumentAssignment ( COMMA argumentAssignment )* RPAREN -> ^( ARGS[\"ARGS\"] ( argumentAssignment )+ ) );";
+		}
+	}
+
+	int specialStateTransition24( DFA dfa, int s, IIntStream _input )
+	{
+		ITokenStream input = (ITokenStream)_input;
+		int _s = s;
+		switch ( s )
+		{
+
+			case 0:
+				int LA24_1 = input.LA(1);
+
+
+				int index24_1 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (LA24_1==RPAREN) ) {s = 2;}
+
+				else if ( (LA24_1==ID) ) {s = 3;}
+
+				else if ( (LA24_1==42) && (synpred2_Action())) {s = 4;}
+
+				else if ( (LA24_1==LPAREN) && (synpred2_Action())) {s = 5;}
+
+				else if ( (LA24_1==ANONYMOUS_TEMPLATE||LA24_1==INT||LA24_1==STRING) && (synpred2_Action())) {s = 6;}
+
+				else if ( (LA24_1==37) && (synpred2_Action())) {s = 7;}
+
+				else if ( (LA24_1==40) && (synpred2_Action())) {s = 8;}
+
+				else if ( (LA24_1==38) && (synpred2_Action())) {s = 9;}
+
+				else if ( (LA24_1==39) && (synpred2_Action())) {s = 10;}
+
+				else if ( (LA24_1==41) && (synpred2_Action())) {s = 11;}
+
+				else if ( (LA24_1==43) && (synpred2_Action())) {s = 12;}
+
+				else if ( (LA24_1==LBRACK) && (synpred2_Action())) {s = 13;}
+
+				else if ( (LA24_1==DOTDOTDOT) ) {s = 14;}
+
+
+				input.Seek(index24_1);
+				if ( s>=0 ) return s;
+				break;
+
+			case 1:
+				int LA24_3 = input.LA(1);
+
+
+				int index24_3 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (LA24_3==ASSIGN) ) {s = 14;}
+
+				else if ( (LA24_3==LPAREN) && (synpred2_Action())) {s = 15;}
+
+				else if ( (LA24_3==DOT) && (synpred2_Action())) {s = 16;}
+
+				else if ( (LA24_3==PLUS) && (synpred2_Action())) {s = 17;}
+
+				else if ( (LA24_3==COLON) && (synpred2_Action())) {s = 18;}
+
+				else if ( (LA24_3==RPAREN) && (synpred2_Action())) {s = 19;}
+
+
+				input.Seek(index24_3);
+				if ( s>=0 ) return s;
+				break;
+		}
+		if (state.backtracking>0) {state.failed=true; return -1;}
+		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 24, _s, input);
+		dfa.Error(nvae);
+		throw nvae;
+	}
+
+	#endregion
+
+	#region Follow Sets
+	public static class Follow
+	{
+		public static readonly BitSet _templatesExpr_in_action144 = new BitSet(new ulong[]{0x10000000UL});
+		public static readonly BitSet _SEMI_in_action147 = new BitSet(new ulong[]{0x8000UL});
+		public static readonly BitSet _optionList_in_action150 = new BitSet(new ulong[]{0x0UL});
+		public static readonly BitSet _CONDITIONAL_in_action160 = new BitSet(new ulong[]{0x100000UL});
+		public static readonly BitSet _LPAREN_in_action163 = new BitSet(new ulong[]{0xFE040968010UL});
+		public static readonly BitSet _ifCondition_in_action166 = new BitSet(new ulong[]{0x8000000UL});
+		public static readonly BitSet _RPAREN_in_action168 = new BitSet(new ulong[]{0x0UL});
+		public static readonly BitSet _36_in_action175 = new BitSet(new ulong[]{0x100000UL});
+		public static readonly BitSet _LPAREN_in_action178 = new BitSet(new ulong[]{0xFE040968010UL});
+		public static readonly BitSet _ifCondition_in_action181 = new BitSet(new ulong[]{0x8000000UL});
+		public static readonly BitSet _RPAREN_in_action183 = new BitSet(new ulong[]{0x0UL});
+		public static readonly BitSet _EOF_in_action193 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _option_in_optionList209 = new BitSet(new ulong[]{0x202UL});
+		public static readonly BitSet _COMMA_in_optionList213 = new BitSet(new ulong[]{0x8000UL});
+		public static readonly BitSet _option_in_optionList215 = new BitSet(new ulong[]{0x202UL});
+		public static readonly BitSet _ID_in_option235 = new BitSet(new ulong[]{0x82UL});
+		public static readonly BitSet _ASSIGN_in_option241 = new BitSet(new ulong[]{0xFE040168010UL});
+		public static readonly BitSet _nonAlternatingTemplateExpr_in_option243 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _expr_in_templatesExpr273 = new BitSet(new ulong[]{0x302UL});
+		public static readonly BitSet _COMMA_in_templatesExpr280 = new BitSet(new ulong[]{0xFE040168010UL});
+		public static readonly BitSet _expr_in_templatesExpr282 = new BitSet(new ulong[]{0x300UL});
+		public static readonly BitSet _COLON_in_templatesExpr288 = new BitSet(new ulong[]{0x10UL});
+		public static readonly BitSet _anonymousTemplate_in_templatesExpr290 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _COLON_in_templatesExpr332 = new BitSet(new ulong[]{0x40000108010UL});
+		public static readonly BitSet _templateList_in_templatesExpr334 = new BitSet(new ulong[]{0x102UL});
+		public static readonly BitSet _template_in_templateList373 = new BitSet(new ulong[]{0x202UL});
+		public static readonly BitSet _COMMA_in_templateList376 = new BitSet(new ulong[]{0x40000108010UL});
+		public static readonly BitSet _template_in_templateList379 = new BitSet(new ulong[]{0x202UL});
+		public static readonly BitSet _ifAtom_in_ifCondition392 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _NOT_in_ifCondition397 = new BitSet(new ulong[]{0xFE040168010UL});
+		public static readonly BitSet _ifAtom_in_ifCondition400 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _templatesExpr_in_ifAtom411 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _primaryExpr_in_expr422 = new BitSet(new ulong[]{0x2000002UL});
+		public static readonly BitSet _PLUS_in_expr425 = new BitSet(new ulong[]{0xFE040168010UL});
+		public static readonly BitSet _primaryExpr_in_expr428 = new BitSet(new ulong[]{0x2000002UL});
+		public static readonly BitSet _templateInclude_in_primaryExpr445 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _atom_in_primaryExpr452 = new BitSet(new ulong[]{0x802UL});
+		public static readonly BitSet _DOT_in_primaryExpr458 = new BitSet(new ulong[]{0x108000UL});
+		public static readonly BitSet _ID_in_primaryExpr467 = new BitSet(new ulong[]{0x802UL});
+		public static readonly BitSet _valueExpr_in_primaryExpr474 = new BitSet(new ulong[]{0x802UL});
+		public static readonly BitSet _function_in_primaryExpr489 = new BitSet(new ulong[]{0x802UL});
+		public static readonly BitSet _DOT_in_primaryExpr495 = new BitSet(new ulong[]{0x108000UL});
+		public static readonly BitSet _ID_in_primaryExpr503 = new BitSet(new ulong[]{0x802UL});
+		public static readonly BitSet _valueExpr_in_primaryExpr510 = new BitSet(new ulong[]{0x802UL});
+		public static readonly BitSet _valueExpr_in_primaryExpr525 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _list_in_primaryExpr530 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _LPAREN_in_valueExpr541 = new BitSet(new ulong[]{0xFE040168010UL});
+		public static readonly BitSet _templatesExpr_in_valueExpr543 = new BitSet(new ulong[]{0x8000000UL});
+		public static readonly BitSet _RPAREN_in_valueExpr545 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _expr_in_nonAlternatingTemplateExpr568 = new BitSet(new ulong[]{0x102UL});
+		public static readonly BitSet _COLON_in_nonAlternatingTemplateExpr577 = new BitSet(new ulong[]{0x40000108010UL});
+		public static readonly BitSet _template_in_nonAlternatingTemplateExpr579 = new BitSet(new ulong[]{0x102UL});
+		public static readonly BitSet _37_in_function607 = new BitSet(new ulong[]{0x100000UL});
+		public static readonly BitSet _40_in_function613 = new BitSet(new ulong[]{0x100000UL});
+		public static readonly BitSet _38_in_function619 = new BitSet(new ulong[]{0x100000UL});
+		public static readonly BitSet _39_in_function625 = new BitSet(new ulong[]{0x100000UL});
+		public static readonly BitSet _41_in_function631 = new BitSet(new ulong[]{0x100000UL});
+		public static readonly BitSet _43_in_function637 = new BitSet(new ulong[]{0x100000UL});
+		public static readonly BitSet _singleArg_in_function645 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _namedTemplate_in_template686 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _anonymousTemplate_in_template695 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ID_in_namedTemplate726 = new BitSet(new ulong[]{0x100000UL});
+		public static readonly BitSet _argList_in_namedTemplate728 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _42_in_namedTemplate741 = new BitSet(new ulong[]{0x800UL});
+		public static readonly BitSet _DOT_in_namedTemplate743 = new BitSet(new ulong[]{0x8000UL});
+		public static readonly BitSet _ID_in_namedTemplate747 = new BitSet(new ulong[]{0x100000UL});
+		public static readonly BitSet _argList_in_namedTemplate749 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _indirectTemplate_in_namedTemplate763 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ANONYMOUS_TEMPLATE_in_anonymousTemplate792 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _set_in_atom807 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _LBRACK_in_list835 = new BitSet(new ulong[]{0xFE044168210UL});
+		public static readonly BitSet _listElement_in_list839 = new BitSet(new ulong[]{0x4000200UL});
+		public static readonly BitSet _COMMA_in_list842 = new BitSet(new ulong[]{0xFE044168210UL});
+		public static readonly BitSet _listElement_in_list844 = new BitSet(new ulong[]{0x4000200UL});
+		public static readonly BitSet _RBRACK_in_list850 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _nonAlternatingTemplateExpr_in_listElement873 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ID_in_templateInclude898 = new BitSet(new ulong[]{0x100000UL});
+		public static readonly BitSet _argList_in_templateInclude900 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _42_in_templateInclude913 = new BitSet(new ulong[]{0x800UL});
+		public static readonly BitSet _DOT_in_templateInclude915 = new BitSet(new ulong[]{0x8000UL});
+		public static readonly BitSet _ID_in_templateInclude919 = new BitSet(new ulong[]{0x100000UL});
+		public static readonly BitSet _argList_in_templateInclude921 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _indirectTemplate_in_templateInclude934 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _LPAREN_in_indirectTemplate968 = new BitSet(new ulong[]{0xFE040168010UL});
+		public static readonly BitSet _templatesExpr_in_indirectTemplate972 = new BitSet(new ulong[]{0x8000000UL});
+		public static readonly BitSet _RPAREN_in_indirectTemplate974 = new BitSet(new ulong[]{0x100000UL});
+		public static readonly BitSet _argList_in_indirectTemplate978 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _LPAREN_in_argList1005 = new BitSet(new ulong[]{0x8000000UL});
+		public static readonly BitSet _RPAREN_in_argList1007 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _singleArg_in_argList1022 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _LPAREN_in_argList1039 = new BitSet(new ulong[]{0x9000UL});
+		public static readonly BitSet _argumentAssignment_in_argList1041 = new BitSet(new ulong[]{0x8000200UL});
+		public static readonly BitSet _COMMA_in_argList1044 = new BitSet(new ulong[]{0x9000UL});
+		public static readonly BitSet _argumentAssignment_in_argList1046 = new BitSet(new ulong[]{0x8000200UL});
+		public static readonly BitSet _RPAREN_in_argList1050 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _LPAREN_in_singleArg1073 = new BitSet(new ulong[]{0xFE040168010UL});
+		public static readonly BitSet _nonAlternatingTemplateExpr_in_singleArg1075 = new BitSet(new ulong[]{0x8000000UL});
+		public static readonly BitSet _RPAREN_in_singleArg1077 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ID_in_argumentAssignment1099 = new BitSet(new ulong[]{0x80UL});
+		public static readonly BitSet _ASSIGN_in_argumentAssignment1101 = new BitSet(new ulong[]{0xFE040168010UL});
+		public static readonly BitSet _nonAlternatingTemplateExpr_in_argumentAssignment1104 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _DOTDOTDOT_in_argumentAssignment1109 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _templateInclude_in_synpred1_Action442 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _singleArg_in_synpred2_Action1019 = new BitSet(new ulong[]{0x2UL});
+
+	}
+	#endregion
+}
+
+} // namespace  Antlr3.ST.Language
diff --git a/Antlr3.StringTemplate/Language/ActionParserHelper.cs b/Antlr3.StringTemplate/Language/ActionParserHelper.cs
new file mode 100644
index 0000000..7f8f13e
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/ActionParserHelper.cs
@@ -0,0 +1,71 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Grammar conversion to ANTLR v3 and C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *	notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	notice, this list of conditions and the following disclaimer in the
+ *	documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *	derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST.Language
+{
+    using Antlr.Runtime;
+
+    partial class ActionParser
+    {
+        protected StringTemplate self = null;
+
+        protected ActionParser( ITokenSource lexer, int k )
+            : this( new CommonTokenStream( lexer ) )
+        {
+        }
+        public ActionParser( ITokenSource lexer, StringTemplate self )
+            : this( lexer, 2 )
+        {
+            //this( new CommonTokenStream( lexer ), 2 );
+            this.self = self;
+        }
+
+        protected override void Initialize()
+        {
+            TreeAdaptor = new StringTemplateTreeAdaptor();
+            base.Initialize();
+        }
+
+        public override void ReportError( RecognitionException e )
+        {
+            StringTemplateGroup group = self.getGroup();
+            if ( group == StringTemplate.defaultGroup )
+            {
+                self.error( "action parse error; template context is " + self.getEnclosingInstanceStackString(), e );
+            }
+            else
+            {
+                self.error( "action parse error in group " + self.getGroup().Name + " line " + self.getGroupFileLine() + "; template context is " + self.getEnclosingInstanceStackString(), e );
+            }
+        }
+    }
+}
diff --git a/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.cs b/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.cs
new file mode 100644
index 0000000..a68237a
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.cs
@@ -0,0 +1,3658 @@
+// $ANTLR 3.1.2 Language\\AngleBracketTemplateLexer.g3 2009-03-07 08:53:04
+
+// The variable 'variable' is assigned but its value is never used.
+#pragma warning disable 219
+// Unreachable code detected.
+#pragma warning disable 162
+
+
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+using StringBuffer = System.Text.StringBuilder;
+
+
+using System.Collections.Generic;
+using Antlr.Runtime;
+using Stack = System.Collections.Generic.Stack<object>;
+using List = System.Collections.IList;
+using ArrayList = System.Collections.Generic.List<object>;
+using Map = System.Collections.IDictionary;
+using HashMap = System.Collections.Generic.Dictionary<object, object>;
+namespace Antlr3.ST.Language
+{
+public partial class AngleBracketTemplateLexer : Lexer
+{
+	public const int EOF=-1;
+	public const int ACTION=4;
+	public const int COMMENT=5;
+	public const int ELSE=6;
+	public const int ELSEIF=7;
+	public const int ENDIF=8;
+	public const int ESC=9;
+	public const int ESC_CHAR=10;
+	public const int EXPR=11;
+	public const int HEX=12;
+	public const int IF=13;
+	public const int IF_EXPR=14;
+	public const int INDENT=15;
+	public const int LITERAL=16;
+	public const int NESTED_PARENS=17;
+	public const int NEWLINE=18;
+	public const int REGION_DEF=19;
+	public const int REGION_REF=20;
+	public const int SUBTEMPLATE=21;
+	public const int TEMPLATE=22;
+
+    // delegates
+    // delegators
+
+	public AngleBracketTemplateLexer() {}
+	public AngleBracketTemplateLexer( ICharStream input )
+		: this( input, new RecognizerSharedState() )
+	{
+	}
+	public AngleBracketTemplateLexer( ICharStream input, RecognizerSharedState state )
+		: base( input, state )
+	{
+
+	}
+	public override string GrammarFileName { get { return "Language\\AngleBracketTemplateLexer.g3"; } }
+
+	// $ANTLR start "NEWLINE"
+	private void mNEWLINE()
+	{
+		try
+		{
+			int _type = NEWLINE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\AngleBracketTemplateLexer.g3:80:4: ( ( '\\r' )? '\\n' )
+			// Language\\AngleBracketTemplateLexer.g3:80:4: ( '\\r' )? '\\n'
+			{
+			// Language\\AngleBracketTemplateLexer.g3:80:4: ( '\\r' )?
+			int alt1=2;
+			int LA1_0 = input.LA(1);
+
+			if ( (LA1_0=='\r') )
+			{
+				alt1=1;
+			}
+			switch ( alt1 )
+			{
+			case 1:
+				// Language\\AngleBracketTemplateLexer.g3:80:5: '\\r'
+				{
+				Match('\r'); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+			Match('\n'); if (state.failed) return ;
+			if ( state.backtracking == 0 )
+			{
+				currentIndent=null;
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "NEWLINE"
+
+	// $ANTLR start "ACTION"
+	private void mACTION()
+	{
+		try
+		{
+			int _type = ACTION;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken exp=null;
+			int ch;
+
+
+				int startCol = CharPositionInLine;
+				System.Text.StringBuilder buf = null;
+				string subtext = string.Empty;
+				char uc = '\0';
+				System.Text.StringBuilder builder = null;
+				bool atLeft = false;
+				string t = null;
+
+			// Language\\AngleBracketTemplateLexer.g3:95:4: (=> '<' ( ESC_CHAR[out uc] )+ '>' |=> COMMENT | ( options {k=1; } :=> '<if' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? |=> '<elseif' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? |=> '<else>' ( ( '\\r' )? '\\n' )? |=> '<endif>' ({...}? => ( '\\r' )? '\\n' )? |=> '<@' (ch=~ ( '>' | '(' ) )+ ( '()>' | '>' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )? ) | '<' EXPR[out subtext] '>' ) )
+			int alt26=3;
+			int LA26_0 = input.LA(1);
+
+			if ( (LA26_0=='<') )
+			{
+				int LA26_1 = input.LA(2);
+
+				if ( (synpred1_AngleBracketTemplateLexer()) )
+				{
+					alt26=1;
+				}
+				else if ( (synpred2_AngleBracketTemplateLexer()) )
+				{
+					alt26=2;
+				}
+				else if ( (true) )
+				{
+					alt26=3;
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return ;}
+					NoViableAltException nvae = new NoViableAltException("", 26, 1, input);
+
+					throw nvae;
+				}
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				NoViableAltException nvae = new NoViableAltException("", 26, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt26 )
+			{
+			case 1:
+				// Language\\AngleBracketTemplateLexer.g3:95:4: => '<' ( ESC_CHAR[out uc] )+ '>'
+				{
+
+				if ( state.backtracking == 0 )
+				{
+
+								buf = new System.Text.StringBuilder();
+								uc = '\0';
+
+				}
+				Match('<'); if (state.failed) return ;
+				// Language\\AngleBracketTemplateLexer.g3:101:7: ( ESC_CHAR[out uc] )+
+				int cnt2=0;
+				for ( ; ; )
+				{
+					int alt2=2;
+					int LA2_0 = input.LA(1);
+
+					if ( (LA2_0=='\\') )
+					{
+						alt2=1;
+					}
+
+
+					switch ( alt2 )
+					{
+					case 1:
+						// Language\\AngleBracketTemplateLexer.g3:101:8: ESC_CHAR[out uc]
+						{
+						mESC_CHAR(out uc); if (state.failed) return ;
+						if ( state.backtracking == 0 )
+						{
+							buf.Append(uc);
+						}
+
+						}
+						break;
+
+					default:
+						if ( cnt2 >= 1 )
+							goto loop2;
+
+						if (state.backtracking>0) {state.failed=true; return ;}
+						EarlyExitException eee2 = new EarlyExitException( 2, input );
+						throw eee2;
+					}
+					cnt2++;
+				}
+				loop2:
+					;
+
+
+				Match('>'); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+
+								Text = buf.ToString();
+								_type = LITERAL;
+
+				}
+
+				}
+				break;
+			case 2:
+				// Language\\AngleBracketTemplateLexer.g3:106:4: => COMMENT
+				{
+
+				mCOMMENT(); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+					_channel = HIDDEN;
+				}
+
+				}
+				break;
+			case 3:
+				// Language\\AngleBracketTemplateLexer.g3:107:4: ( options {k=1; } :=> '<if' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? |=> '<elseif' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? |=> '<else>' ( ( '\\r' )? '\\n' )? |=> '<endif>' ({...}? => ( '\\r' )? '\\n' )? |=> '<@' (ch=~ ( '>' | '(' ) )+ ( '()>' | '>' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )? ) | '<' EXPR[out subtext] '>' )
+				{
+				// Language\\AngleBracketTemplateLexer.g3:107:4: ( options {k=1; } :=> '<if' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? |=> '<elseif' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? |=> '<else>' ( ( '\\r' )? '\\n' )? |=> '<endif>' ({...}? => ( '\\r' )? '\\n' )? |=> '<@' (ch=~ ( '>' | '(' ) )+ ( '()>' | '>' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )? ) | '<' EXPR[out subtext] '>' )
+				int alt25=6;
+				int LA25_0 = input.LA(1);
+
+				if ( (LA25_0=='<') )
+				{
+					int LA25_1 = input.LA(2);
+
+					if ( (synpred3_AngleBracketTemplateLexer()) )
+					{
+						alt25=1;
+					}
+					else if ( (synpred4_AngleBracketTemplateLexer()) )
+					{
+						alt25=2;
+					}
+					else if ( (synpred5_AngleBracketTemplateLexer()) )
+					{
+						alt25=3;
+					}
+					else if ( (synpred6_AngleBracketTemplateLexer()) )
+					{
+						alt25=4;
+					}
+					else if ( (synpred7_AngleBracketTemplateLexer()) )
+					{
+						alt25=5;
+					}
+					else if ( (true) )
+					{
+						alt25=6;
+					}
+					else
+					{
+						if (state.backtracking>0) {state.failed=true; return ;}
+						NoViableAltException nvae = new NoViableAltException("", 25, 1, input);
+
+						throw nvae;
+					}
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return ;}
+					NoViableAltException nvae = new NoViableAltException("", 25, 0, input);
+
+					throw nvae;
+				}
+				switch ( alt25 )
+				{
+				case 1:
+					// Language\\AngleBracketTemplateLexer.g3:108:4: => '<if' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )?
+					{
+
+					Match("<if"); if (state.failed) return ;
+
+					// Language\\AngleBracketTemplateLexer.g3:109:10: ( ' ' )*
+					for ( ; ; )
+					{
+						int alt3=2;
+						int LA3_0 = input.LA(1);
+
+						if ( (LA3_0==' ') )
+						{
+							alt3=1;
+						}
+
+
+						switch ( alt3 )
+						{
+						case 1:
+							// Language\\AngleBracketTemplateLexer.g3:109:11: ' '
+							{
+							Match(' '); if (state.failed) return ;
+
+							}
+							break;
+
+						default:
+							goto loop3;
+						}
+					}
+
+					loop3:
+						;
+
+
+					Match('('); if (state.failed) return ;
+					int expStart170 = GetCharIndex();
+					mIF_EXPR(); if (state.failed) return ;
+					exp = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, expStart170, GetCharIndex()-1);
+					Match(")>"); if (state.failed) return ;
+
+					// Language\\AngleBracketTemplateLexer.g3:110:4: ( ( '\\r' )? '\\n' )?
+					int alt5=2;
+					int LA5_0 = input.LA(1);
+
+					if ( (LA5_0=='\n'||LA5_0=='\r') )
+					{
+						alt5=1;
+					}
+					switch ( alt5 )
+					{
+					case 1:
+						// Language\\AngleBracketTemplateLexer.g3:110:6: ( '\\r' )? '\\n'
+						{
+						// Language\\AngleBracketTemplateLexer.g3:110:6: ( '\\r' )?
+						int alt4=2;
+						int LA4_0 = input.LA(1);
+
+						if ( (LA4_0=='\r') )
+						{
+							alt4=1;
+						}
+						switch ( alt4 )
+						{
+						case 1:
+							// Language\\AngleBracketTemplateLexer.g3:110:7: '\\r'
+							{
+							Match('\r'); if (state.failed) return ;
+
+							}
+							break;
+
+						}
+
+						Match('\n'); if (state.failed) return ;
+
+						}
+						break;
+
+					}
+
+					if ( state.backtracking == 0 )
+					{
+
+										Text = "if(" + (exp!=null?exp.Text:null) + ")";
+										_type = TemplateParser.IF;
+
+					}
+
+					}
+					break;
+				case 2:
+					// Language\\AngleBracketTemplateLexer.g3:115:5: => '<elseif' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )?
+					{
+
+					Match("<elseif"); if (state.failed) return ;
+
+					// Language\\AngleBracketTemplateLexer.g3:116:14: ( ' ' )*
+					for ( ; ; )
+					{
+						int alt6=2;
+						int LA6_0 = input.LA(1);
+
+						if ( (LA6_0==' ') )
+						{
+							alt6=1;
+						}
+
+
+						switch ( alt6 )
+						{
+						case 1:
+							// Language\\AngleBracketTemplateLexer.g3:116:15: ' '
+							{
+							Match(' '); if (state.failed) return ;
+
+							}
+							break;
+
+						default:
+							goto loop6;
+						}
+					}
+
+					loop6:
+						;
+
+
+					Match('('); if (state.failed) return ;
+					int expStart219 = GetCharIndex();
+					mIF_EXPR(); if (state.failed) return ;
+					exp = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, expStart219, GetCharIndex()-1);
+					Match(")>"); if (state.failed) return ;
+
+					// Language\\AngleBracketTemplateLexer.g3:117:4: ( ( '\\r' )? '\\n' )?
+					int alt8=2;
+					int LA8_0 = input.LA(1);
+
+					if ( (LA8_0=='\n'||LA8_0=='\r') )
+					{
+						alt8=1;
+					}
+					switch ( alt8 )
+					{
+					case 1:
+						// Language\\AngleBracketTemplateLexer.g3:117:6: ( '\\r' )? '\\n'
+						{
+						// Language\\AngleBracketTemplateLexer.g3:117:6: ( '\\r' )?
+						int alt7=2;
+						int LA7_0 = input.LA(1);
+
+						if ( (LA7_0=='\r') )
+						{
+							alt7=1;
+						}
+						switch ( alt7 )
+						{
+						case 1:
+							// Language\\AngleBracketTemplateLexer.g3:117:7: '\\r'
+							{
+							Match('\r'); if (state.failed) return ;
+
+							}
+							break;
+
+						}
+
+						Match('\n'); if (state.failed) return ;
+
+						}
+						break;
+
+					}
+
+					if ( state.backtracking == 0 )
+					{
+
+										Text = "elseif(" + (exp!=null?exp.Text:null) + ")";
+										_type = TemplateParser.ELSEIF;
+
+					}
+
+					}
+					break;
+				case 3:
+					// Language\\AngleBracketTemplateLexer.g3:122:5: => '<else>' ( ( '\\r' )? '\\n' )?
+					{
+
+					Match("<else>"); if (state.failed) return ;
+
+					// Language\\AngleBracketTemplateLexer.g3:124:4: ( ( '\\r' )? '\\n' )?
+					int alt10=2;
+					int LA10_0 = input.LA(1);
+
+					if ( (LA10_0=='\n'||LA10_0=='\r') )
+					{
+						alt10=1;
+					}
+					switch ( alt10 )
+					{
+					case 1:
+						// Language\\AngleBracketTemplateLexer.g3:124:6: ( '\\r' )? '\\n'
+						{
+						// Language\\AngleBracketTemplateLexer.g3:124:6: ( '\\r' )?
+						int alt9=2;
+						int LA9_0 = input.LA(1);
+
+						if ( (LA9_0=='\r') )
+						{
+							alt9=1;
+						}
+						switch ( alt9 )
+						{
+						case 1:
+							// Language\\AngleBracketTemplateLexer.g3:124:7: '\\r'
+							{
+							Match('\r'); if (state.failed) return ;
+
+							}
+							break;
+
+						}
+
+						Match('\n'); if (state.failed) return ;
+
+						}
+						break;
+
+					}
+
+					if ( state.backtracking == 0 )
+					{
+
+										Text = "else";
+										_type = TemplateParser.ELSE;
+
+					}
+
+					}
+					break;
+				case 4:
+					// Language\\AngleBracketTemplateLexer.g3:129:5: => '<endif>' ({...}? => ( '\\r' )? '\\n' )?
+					{
+
+					Match("<endif>"); if (state.failed) return ;
+
+					// Language\\AngleBracketTemplateLexer.g3:131:4: ({...}? => ( '\\r' )? '\\n' )?
+					int alt12=2;
+					int LA12_0 = input.LA(1);
+
+					if ( (LA12_0=='\n'||LA12_0=='\r') && ((startCol==0)))
+					{
+						alt12=1;
+					}
+					switch ( alt12 )
+					{
+					case 1:
+						// Language\\AngleBracketTemplateLexer.g3:131:6: {...}? => ( '\\r' )? '\\n'
+						{
+						if ( !((startCol==0)) )
+						{
+							if (state.backtracking>0) {state.failed=true; return ;}
+							throw new FailedPredicateException(input, "ACTION", "startCol==0");
+						}
+						// Language\\AngleBracketTemplateLexer.g3:131:24: ( '\\r' )?
+						int alt11=2;
+						int LA11_0 = input.LA(1);
+
+						if ( (LA11_0=='\r') )
+						{
+							alt11=1;
+						}
+						switch ( alt11 )
+						{
+						case 1:
+							// Language\\AngleBracketTemplateLexer.g3:131:25: '\\r'
+							{
+							Match('\r'); if (state.failed) return ;
+
+							}
+							break;
+
+						}
+
+						Match('\n'); if (state.failed) return ;
+
+						}
+						break;
+
+					}
+
+					if ( state.backtracking == 0 )
+					{
+
+										Text = "endif";
+										_type = TemplateParser.ENDIF;
+
+					}
+
+					}
+					break;
+				case 5:
+					// Language\\AngleBracketTemplateLexer.g3:138:4: => '<@' (ch=~ ( '>' | '(' ) )+ ( '()>' | '>' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )? )
+					{
+
+					if ( state.backtracking == 0 )
+					{
+
+										builder = new System.Text.StringBuilder();
+
+					}
+					Match("<@"); if (state.failed) return ;
+
+					// Language\\AngleBracketTemplateLexer.g3:143:4: (ch=~ ( '>' | '(' ) )+
+					int cnt13=0;
+					for ( ; ; )
+					{
+						int alt13=2;
+						int LA13_0 = input.LA(1);
+
+						if ( ((LA13_0>='\u0000' && LA13_0<='\'')||(LA13_0>=')' && LA13_0<='=')||(LA13_0>='?' && LA13_0<='\uFFFF')) )
+						{
+							alt13=1;
+						}
+
+
+						switch ( alt13 )
+						{
+						case 1:
+							// Language\\AngleBracketTemplateLexer.g3:143:6: ch=~ ( '>' | '(' )
+							{
+							ch= input.LA(1);
+							input.Consume();
+							state.failed=false;
+							if ( state.backtracking == 0 )
+							{
+								builder.Append((char)ch);
+							}
+
+							}
+							break;
+
+						default:
+							if ( cnt13 >= 1 )
+								goto loop13;
+
+							if (state.backtracking>0) {state.failed=true; return ;}
+							EarlyExitException eee13 = new EarlyExitException( 13, input );
+							throw eee13;
+						}
+						cnt13++;
+					}
+					loop13:
+						;
+
+
+					if ( state.backtracking == 0 )
+					{
+						 t = builder.ToString();
+					}
+					// Language\\AngleBracketTemplateLexer.g3:145:4: ( '()>' | '>' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )? )
+					int alt24=2;
+					int LA24_0 = input.LA(1);
+
+					if ( (LA24_0=='(') )
+					{
+						alt24=1;
+					}
+					else if ( (LA24_0=='>') )
+					{
+						alt24=2;
+					}
+					else
+					{
+						if (state.backtracking>0) {state.failed=true; return ;}
+						NoViableAltException nvae = new NoViableAltException("", 24, 0, input);
+
+						throw nvae;
+					}
+					switch ( alt24 )
+					{
+					case 1:
+						// Language\\AngleBracketTemplateLexer.g3:145:6: '()>'
+						{
+						Match("()>"); if (state.failed) return ;
+
+						if ( state.backtracking == 0 )
+						{
+
+												_type = TemplateParser.REGION_REF;
+
+						}
+
+						}
+						break;
+					case 2:
+						// Language\\AngleBracketTemplateLexer.g3:149:6: '>' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )?
+						{
+						Match('>'); if (state.failed) return ;
+						if ( state.backtracking == 0 )
+						{
+
+												_type = TemplateParser.REGION_DEF;
+												builder.Append("::=");
+
+						}
+						// Language\\AngleBracketTemplateLexer.g3:154:5: (=> ( '\\r' )? '\\n' )?
+						int alt15=2;
+						int LA15_0 = input.LA(1);
+
+						if ( (LA15_0=='\r') )
+						{
+							int LA15_1 = input.LA(2);
+
+							if ( (LA15_1=='\n') )
+							{
+								int LA15_4 = input.LA(3);
+
+								if ( (synpred8_AngleBracketTemplateLexer()) )
+								{
+									alt15=1;
+								}
+							}
+						}
+						else if ( (LA15_0=='\n') )
+						{
+							int LA15_2 = input.LA(2);
+
+							if ( (synpred8_AngleBracketTemplateLexer()) )
+							{
+								alt15=1;
+							}
+						}
+						switch ( alt15 )
+						{
+						case 1:
+							// Language\\AngleBracketTemplateLexer.g3:154:7: => ( '\\r' )? '\\n'
+							{
+
+							// Language\\AngleBracketTemplateLexer.g3:154:22: ( '\\r' )?
+							int alt14=2;
+							int LA14_0 = input.LA(1);
+
+							if ( (LA14_0=='\r') )
+							{
+								alt14=1;
+							}
+							switch ( alt14 )
+							{
+							case 1:
+								// Language\\AngleBracketTemplateLexer.g3:154:23: '\\r'
+								{
+								Match('\r'); if (state.failed) return ;
+
+								}
+								break;
+
+							}
+
+							Match('\n'); if (state.failed) return ;
+
+							}
+							break;
+
+						}
+
+						if ( state.backtracking == 0 )
+						{
+
+												atLeft = false;
+
+						}
+						// Language\\AngleBracketTemplateLexer.g3:158:5: ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+
+						int cnt18=0;
+						for ( ; ; )
+						{
+							int alt18=2;
+							alt18 = dfa18.Predict(input);
+							switch ( alt18 )
+							{
+							case 1:
+								// Language\\AngleBracketTemplateLexer.g3:158:7: {...}? => (=> ( '\\r' )? '\\n' |ch= . )
+								{
+								if ( !((!(upcomingAtEND(1) || ( input.LA(1) == '\n' && upcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && upcomingAtEND(3) )))) )
+								{
+									if (state.backtracking>0) {state.failed=true; return ;}
+									throw new FailedPredicateException(input, "ACTION", "!(upcomingAtEND(1) || ( input.LA(1) == '\\n' && upcomingAtEND(2) ) || ( input.LA(1) == '\\r' && input.LA(2) == '\\n' && upcomingAtEND(3) ))");
+								}
+								// Language\\AngleBracketTemplateLexer.g3:159:6: (=> ( '\\r' )? '\\n' |ch= . )
+								int alt17=2;
+								int LA17_0 = input.LA(1);
+
+								if ( (LA17_0=='\r') )
+								{
+									int LA17_1 = input.LA(2);
+
+									if ( (synpred9_AngleBracketTemplateLexer()) )
+									{
+										alt17=1;
+									}
+									else if ( (true) )
+									{
+										alt17=2;
+									}
+									else
+									{
+										if (state.backtracking>0) {state.failed=true; return ;}
+										NoViableAltException nvae = new NoViableAltException("", 17, 1, input);
+
+										throw nvae;
+									}
+								}
+								else if ( (LA17_0=='\n') )
+								{
+									int LA17_2 = input.LA(2);
+
+									if ( (synpred9_AngleBracketTemplateLexer()) )
+									{
+										alt17=1;
+									}
+									else if ( (true) )
+									{
+										alt17=2;
+									}
+									else
+									{
+										if (state.backtracking>0) {state.failed=true; return ;}
+										NoViableAltException nvae = new NoViableAltException("", 17, 2, input);
+
+										throw nvae;
+									}
+								}
+								else if ( ((LA17_0>='\u0000' && LA17_0<='\t')||(LA17_0>='\u000B' && LA17_0<='\f')||(LA17_0>='\u000E' && LA17_0<='\uFFFF')) )
+								{
+									alt17=2;
+								}
+								else
+								{
+									if (state.backtracking>0) {state.failed=true; return ;}
+									NoViableAltException nvae = new NoViableAltException("", 17, 0, input);
+
+									throw nvae;
+								}
+								switch ( alt17 )
+								{
+								case 1:
+									// Language\\AngleBracketTemplateLexer.g3:159:8: => ( '\\r' )? '\\n'
+									{
+
+									// Language\\AngleBracketTemplateLexer.g3:159:23: ( '\\r' )?
+									int alt16=2;
+									int LA16_0 = input.LA(1);
+
+									if ( (LA16_0=='\r') )
+									{
+										alt16=1;
+									}
+									switch ( alt16 )
+									{
+									case 1:
+										// Language\\AngleBracketTemplateLexer.g3:159:24: '\\r'
+										{
+										Match('\r'); if (state.failed) return ;
+										if ( state.backtracking == 0 )
+										{
+											builder.Append('\r');
+										}
+
+										}
+										break;
+
+									}
+
+									Match('\n'); if (state.failed) return ;
+									if ( state.backtracking == 0 )
+									{
+										builder.Append('\n'); atLeft = true;
+									}
+
+									}
+									break;
+								case 2:
+									// Language\\AngleBracketTemplateLexer.g3:160:8: ch= .
+									{
+									ch = input.LA(1);
+									MatchAny(); if (state.failed) return ;
+									if ( state.backtracking == 0 )
+									{
+										builder.Append((char)ch); atLeft = false;
+									}
+
+									}
+									break;
+
+								}
+
+
+								}
+								break;
+
+							default:
+								if ( cnt18 >= 1 )
+									goto loop18;
+
+								if (state.backtracking>0) {state.failed=true; return ;}
+								EarlyExitException eee18 = new EarlyExitException( 18, input );
+								throw eee18;
+							}
+							cnt18++;
+						}
+						loop18:
+							;
+
+
+						// Language\\AngleBracketTemplateLexer.g3:163:5: (=> ( '\\r' )? '\\n' )?
+						int alt20=2;
+						int LA20_0 = input.LA(1);
+
+						if ( (LA20_0=='\r') )
+						{
+							int LA20_1 = input.LA(2);
+
+							if ( (LA20_1=='\n') )
+							{
+								int LA20_4 = input.LA(3);
+
+								if ( (LA20_4=='<') && (synpred10_AngleBracketTemplateLexer()))
+								{
+									alt20=1;
+								}
+								else if ( ((LA20_4>='\u0000' && LA20_4<=';')||(LA20_4>='=' && LA20_4<='\uFFFF')) && (synpred10_AngleBracketTemplateLexer()))
+								{
+									alt20=1;
+								}
+							}
+						}
+						else if ( (LA20_0=='\n') )
+						{
+							int LA20_2 = input.LA(2);
+
+							if ( (LA20_2=='<') && (synpred10_AngleBracketTemplateLexer()))
+							{
+								alt20=1;
+							}
+							else if ( (LA20_2=='\r') )
+							{
+								int LA20_6 = input.LA(3);
+
+								if ( (synpred10_AngleBracketTemplateLexer()) )
+								{
+									alt20=1;
+								}
+							}
+							else if ( (LA20_2=='\n') )
+							{
+								int LA20_7 = input.LA(3);
+
+								if ( (synpred10_AngleBracketTemplateLexer()) )
+								{
+									alt20=1;
+								}
+							}
+							else if ( ((LA20_2>='\u0000' && LA20_2<='\t')||(LA20_2>='\u000B' && LA20_2<='\f')||(LA20_2>='\u000E' && LA20_2<=';')||(LA20_2>='=' && LA20_2<='\uFFFF')) && (synpred10_AngleBracketTemplateLexer()))
+							{
+								alt20=1;
+							}
+						}
+						switch ( alt20 )
+						{
+						case 1:
+							// Language\\AngleBracketTemplateLexer.g3:163:7: => ( '\\r' )? '\\n'
+							{
+
+							// Language\\AngleBracketTemplateLexer.g3:163:22: ( '\\r' )?
+							int alt19=2;
+							int LA19_0 = input.LA(1);
+
+							if ( (LA19_0=='\r') )
+							{
+								alt19=1;
+							}
+							switch ( alt19 )
+							{
+							case 1:
+								// Language\\AngleBracketTemplateLexer.g3:163:23: '\\r'
+								{
+								Match('\r'); if (state.failed) return ;
+
+								}
+								break;
+
+							}
+
+							Match('\n'); if (state.failed) return ;
+							if ( state.backtracking == 0 )
+							{
+								atLeft = true;
+							}
+
+							}
+							break;
+
+						}
+
+						// Language\\AngleBracketTemplateLexer.g3:164:5: ( '<@end>' | . )
+						int alt21=2;
+						int LA21_0 = input.LA(1);
+
+						if ( (LA21_0=='<') )
+						{
+							int LA21_1 = input.LA(2);
+
+							if ( (LA21_1=='@') )
+							{
+								alt21=1;
+							}
+							else
+							{
+								alt21=2;}
+						}
+						else if ( ((LA21_0>='\u0000' && LA21_0<=';')||(LA21_0>='=' && LA21_0<='\uFFFF')) )
+						{
+							alt21=2;
+						}
+						else
+						{
+							if (state.backtracking>0) {state.failed=true; return ;}
+							NoViableAltException nvae = new NoViableAltException("", 21, 0, input);
+
+							throw nvae;
+						}
+						switch ( alt21 )
+						{
+						case 1:
+							// Language\\AngleBracketTemplateLexer.g3:164:7: '<@end>'
+							{
+							Match("<@end>"); if (state.failed) return ;
+
+
+							}
+							break;
+						case 2:
+							// Language\\AngleBracketTemplateLexer.g3:165:7: .
+							{
+							MatchAny(); if (state.failed) return ;
+							if ( state.backtracking == 0 )
+							{
+								self.error("missing region "+t+" <@end> tag");
+							}
+
+							}
+							break;
+
+						}
+
+						// Language\\AngleBracketTemplateLexer.g3:167:5: ({...}? => ( '\\r' )? '\\n' )?
+						int alt23=2;
+						int LA23_0 = input.LA(1);
+
+						if ( (LA23_0=='\n'||LA23_0=='\r') && ((atLeft)))
+						{
+							alt23=1;
+						}
+						switch ( alt23 )
+						{
+						case 1:
+							// Language\\AngleBracketTemplateLexer.g3:167:7: {...}? => ( '\\r' )? '\\n'
+							{
+							if ( !((atLeft)) )
+							{
+								if (state.backtracking>0) {state.failed=true; return ;}
+								throw new FailedPredicateException(input, "ACTION", "atLeft");
+							}
+							// Language\\AngleBracketTemplateLexer.g3:167:20: ( '\\r' )?
+							int alt22=2;
+							int LA22_0 = input.LA(1);
+
+							if ( (LA22_0=='\r') )
+							{
+								alt22=1;
+							}
+							switch ( alt22 )
+							{
+							case 1:
+								// Language\\AngleBracketTemplateLexer.g3:167:21: '\\r'
+								{
+								Match('\r'); if (state.failed) return ;
+
+								}
+								break;
+
+							}
+
+							Match('\n'); if (state.failed) return ;
+
+							}
+							break;
+
+						}
+
+
+						}
+						break;
+
+					}
+
+					if ( state.backtracking == 0 )
+					{
+
+										Text = builder.ToString();
+
+					}
+
+					}
+					break;
+				case 6:
+					// Language\\AngleBracketTemplateLexer.g3:172:5: '<' EXPR[out subtext] '>'
+					{
+					Match('<'); if (state.failed) return ;
+					mEXPR(out subtext); if (state.failed) return ;
+					Match('>'); if (state.failed) return ;
+					if ( state.backtracking == 0 )
+					{
+						 Text = subtext;
+					}
+
+					}
+					break;
+
+				}
+
+				if ( state.backtracking == 0 )
+				{
+
+								//ChunkToken t = new ChunkToken(_type, Text, currentIndent);
+								//state.token = t; //$ setToken(t);
+								state.token = new ChunkToken(_type, Text, currentIndent);
+
+				}
+
+				}
+				break;
+
+			}
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ACTION"
+
+	// $ANTLR start "LITERAL"
+	private void mLITERAL()
+	{
+		try
+		{
+			int _type = LITERAL;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken ind=null;
+			int ch;
+
+
+				System.Text.StringBuilder builder = new System.Text.StringBuilder();
+				int loopStartIndex = 0;
+				int col = 0;
+
+			// Language\\AngleBracketTemplateLexer.g3:189:4: ( ( ( '\\\\' ( options {k=1; } :=> '<' |=> '>' |=> '\\\\' |ch= . ) ) |ind= INDENT |ch=~ ( '\\\\' | ' ' | '\\t' | '<' | '\\r' | '\\n' ) )+ )
+			// Language\\AngleBracketTemplateLexer.g3:189:4: ( ( '\\\\' ( options {k=1; } :=> '<' |=> '>' |=> '\\\\' |ch= . ) ) |ind= INDENT |ch=~ ( '\\\\' | ' ' | '\\t' | '<' | '\\r' | '\\n' ) )+
+			{
+			// Language\\AngleBracketTemplateLexer.g3:189:4: ( ( '\\\\' ( options {k=1; } :=> '<' |=> '>' |=> '\\\\' |ch= . ) ) |ind= INDENT |ch=~ ( '\\\\' | ' ' | '\\t' | '<' | '\\r' | '\\n' ) )+
+			int cnt28=0;
+			for ( ; ; )
+			{
+				int alt28=4;
+				int LA28_0 = input.LA(1);
+
+				if ( (LA28_0=='\\') )
+				{
+					alt28=1;
+				}
+				else if ( (LA28_0=='\t'||LA28_0==' ') )
+				{
+					alt28=2;
+				}
+				else if ( ((LA28_0>='\u0000' && LA28_0<='\b')||(LA28_0>='\u000B' && LA28_0<='\f')||(LA28_0>='\u000E' && LA28_0<='\u001F')||(LA28_0>='!' && LA28_0<=';')||(LA28_0>='=' && LA28_0<='[')||(LA28_0>=']' && LA28_0<='\uFFFF')) )
+				{
+					alt28=3;
+				}
+
+
+				switch ( alt28 )
+				{
+				case 1:
+					// Language\\AngleBracketTemplateLexer.g3:189:6: ( '\\\\' ( options {k=1; } :=> '<' |=> '>' |=> '\\\\' |ch= . ) )
+					{
+					// Language\\AngleBracketTemplateLexer.g3:189:6: ( '\\\\' ( options {k=1; } :=> '<' |=> '>' |=> '\\\\' |ch= . ) )
+					// Language\\AngleBracketTemplateLexer.g3:189:8: '\\\\' ( options {k=1; } :=> '<' |=> '>' |=> '\\\\' |ch= . )
+					{
+					Match('\\'); if (state.failed) return ;
+					// Language\\AngleBracketTemplateLexer.g3:190:5: ( options {k=1; } :=> '<' |=> '>' |=> '\\\\' |ch= . )
+					int alt27=4;
+					int LA27_0 = input.LA(1);
+
+					if ( (LA27_0=='<') )
+					{
+						int LA27_1 = input.LA(2);
+
+						if ( (synpred11_AngleBracketTemplateLexer()) )
+						{
+							alt27=1;
+						}
+						else if ( (true) )
+						{
+							alt27=4;
+						}
+						else
+						{
+							if (state.backtracking>0) {state.failed=true; return ;}
+							NoViableAltException nvae = new NoViableAltException("", 27, 1, input);
+
+							throw nvae;
+						}
+					}
+					else if ( (LA27_0=='>') )
+					{
+						int LA27_2 = input.LA(2);
+
+						if ( (synpred12_AngleBracketTemplateLexer()) )
+						{
+							alt27=2;
+						}
+						else if ( (true) )
+						{
+							alt27=4;
+						}
+						else
+						{
+							if (state.backtracking>0) {state.failed=true; return ;}
+							NoViableAltException nvae = new NoViableAltException("", 27, 2, input);
+
+							throw nvae;
+						}
+					}
+					else if ( (LA27_0=='\\') )
+					{
+						int LA27_3 = input.LA(2);
+
+						if ( (synpred13_AngleBracketTemplateLexer()) )
+						{
+							alt27=3;
+						}
+						else if ( (true) )
+						{
+							alt27=4;
+						}
+						else
+						{
+							if (state.backtracking>0) {state.failed=true; return ;}
+							NoViableAltException nvae = new NoViableAltException("", 27, 3, input);
+
+							throw nvae;
+						}
+					}
+					else if ( ((LA27_0>='\u0000' && LA27_0<=';')||LA27_0=='='||(LA27_0>='?' && LA27_0<='[')||(LA27_0>=']' && LA27_0<='\uFFFF')) )
+					{
+						alt27=4;
+					}
+					else
+					{
+						if (state.backtracking>0) {state.failed=true; return ;}
+						NoViableAltException nvae = new NoViableAltException("", 27, 0, input);
+
+						throw nvae;
+					}
+					switch ( alt27 )
+					{
+					case 1:
+						// Language\\AngleBracketTemplateLexer.g3:191:6: => '<'
+						{
+
+						Match('<'); if (state.failed) return ;
+						if ( state.backtracking == 0 )
+						{
+							 builder.Append('<');
+						}
+
+						}
+						break;
+					case 2:
+						// Language\\AngleBracketTemplateLexer.g3:192:7: => '>'
+						{
+
+						Match('>'); if (state.failed) return ;
+						if ( state.backtracking == 0 )
+						{
+							 builder.Append('>');
+						}
+
+						}
+						break;
+					case 3:
+						// Language\\AngleBracketTemplateLexer.g3:193:7: => '\\\\'
+						{
+
+						Match('\\'); if (state.failed) return ;
+						if ( state.backtracking == 0 )
+						{
+							 builder.Append('\\');
+						}
+
+						}
+						break;
+					case 4:
+						// Language\\AngleBracketTemplateLexer.g3:194:7: ch= .
+						{
+						ch = input.LA(1);
+						MatchAny(); if (state.failed) return ;
+						if ( state.backtracking == 0 )
+						{
+							 builder.Append( "\\" + (char)ch );
+						}
+
+						}
+						break;
+
+					}
+
+
+					}
+
+
+					}
+					break;
+				case 2:
+					// Language\\AngleBracketTemplateLexer.g3:197:5: ind= INDENT
+					{
+					int indStart709 = GetCharIndex();
+					mINDENT(); if (state.failed) return ;
+					ind = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, indStart709, GetCharIndex()-1);
+					if ( state.backtracking == 0 )
+					{
+
+										loopStartIndex = builder.Length;
+										col = CharPositionInLine - (ind!=null?ind.Text:null).Length;
+
+										builder.Append( (ind!=null?ind.Text:null) );
+										if ( col==0 && input.LA(1)=='<' )
+										{
+											// store indent in ASTExpr not in a literal
+											currentIndent=(ind!=null?ind.Text:null);
+											builder.Length = loopStartIndex; // reset length to wack text
+										}
+										else
+										{
+											currentIndent=null;
+										}
+
+					}
+
+					}
+					break;
+				case 3:
+					// Language\\AngleBracketTemplateLexer.g3:214:5: ch=~ ( '\\\\' | ' ' | '\\t' | '<' | '\\r' | '\\n' )
+					{
+					ch= input.LA(1);
+					input.Consume();
+					state.failed=false;
+					if ( state.backtracking == 0 )
+					{
+						 builder.Append( (char)ch );
+					}
+
+					}
+					break;
+
+				default:
+					if ( cnt28 >= 1 )
+						goto loop28;
+
+					if (state.backtracking>0) {state.failed=true; return ;}
+					EarlyExitException eee28 = new EarlyExitException( 28, input );
+					throw eee28;
+				}
+				cnt28++;
+			}
+			loop28:
+				;
+
+
+			if ( state.backtracking == 0 )
+			{
+
+							Text = builder.ToString();
+							if ( Text.Length == 0 )
+							{
+								_channel = HIDDEN;
+							}
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "LITERAL"
+
+	// $ANTLR start "INDENT"
+	private void mINDENT()
+	{
+		try
+		{
+			// Language\\AngleBracketTemplateLexer.g3:227:4: ( ( ' ' | '\\t' )+ )
+			// Language\\AngleBracketTemplateLexer.g3:227:4: ( ' ' | '\\t' )+
+			{
+			// Language\\AngleBracketTemplateLexer.g3:227:4: ( ' ' | '\\t' )+
+			int cnt29=0;
+			for ( ; ; )
+			{
+				int alt29=2;
+				int LA29_0 = input.LA(1);
+
+				if ( (LA29_0=='\t'||LA29_0==' ') )
+				{
+					alt29=1;
+				}
+
+
+				switch ( alt29 )
+				{
+				case 1:
+					// Language\\AngleBracketTemplateLexer.g3:
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+
+				default:
+					if ( cnt29 >= 1 )
+						goto loop29;
+
+					if (state.backtracking>0) {state.failed=true; return ;}
+					EarlyExitException eee29 = new EarlyExitException( 29, input );
+					throw eee29;
+				}
+				cnt29++;
+			}
+			loop29:
+				;
+
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "INDENT"
+
+	// $ANTLR start "EXPR"
+	private void mEXPR(out string _text)
+	{
+		try
+		{
+			IToken st=null;
+			IToken ESC1=null;
+			int ch;
+
+
+				string subtext = string.Empty;
+				_text = string.Empty;
+				System.Text.StringBuilder builder = new System.Text.StringBuilder();
+
+			// Language\\AngleBracketTemplateLexer.g3:238:4: ( ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '>' ) )+ )
+			// Language\\AngleBracketTemplateLexer.g3:238:4: ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '>' ) )+
+			{
+			// Language\\AngleBracketTemplateLexer.g3:238:4: ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '>' ) )+
+			int cnt32=0;
+			for ( ; ; )
+			{
+				int alt32=5;
+				int LA32_0 = input.LA(1);
+
+				if ( (LA32_0=='\\') )
+				{
+					alt32=1;
+				}
+				else if ( (LA32_0=='{') )
+				{
+					alt32=2;
+				}
+				else if ( (LA32_0=='+'||LA32_0=='=') )
+				{
+					alt32=3;
+				}
+				else if ( ((LA32_0>='\u0000' && LA32_0<='*')||(LA32_0>=',' && LA32_0<='<')||(LA32_0>='?' && LA32_0<='[')||(LA32_0>=']' && LA32_0<='z')||(LA32_0>='|' && LA32_0<='\uFFFF')) )
+				{
+					alt32=4;
+				}
+
+
+				switch ( alt32 )
+				{
+				case 1:
+					// Language\\AngleBracketTemplateLexer.g3:238:6: ESC
+					{
+					int ESC1Start789 = GetCharIndex();
+					mESC(); if (state.failed) return ;
+					ESC1 = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, ESC1Start789, GetCharIndex()-1);
+					if ( state.backtracking == 0 )
+					{
+						builder.Append((ESC1!=null?ESC1.Text:null));
+					}
+
+					}
+					break;
+				case 2:
+					// Language\\AngleBracketTemplateLexer.g3:239:5: st= SUBTEMPLATE
+					{
+					int stStart807 = GetCharIndex();
+					mSUBTEMPLATE(); if (state.failed) return ;
+					st = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, stStart807, GetCharIndex()-1);
+					if ( state.backtracking == 0 )
+					{
+						builder.Append((st!=null?st.Text:null));
+					}
+
+					}
+					break;
+				case 3:
+					// Language\\AngleBracketTemplateLexer.g3:240:5: ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) )
+					{
+					// Language\\AngleBracketTemplateLexer.g3:240:5: ( '=' | '+' )
+					int alt30=2;
+					int LA30_0 = input.LA(1);
+
+					if ( (LA30_0=='=') )
+					{
+						alt30=1;
+					}
+					else if ( (LA30_0=='+') )
+					{
+						alt30=2;
+					}
+					else
+					{
+						if (state.backtracking>0) {state.failed=true; return ;}
+						NoViableAltException nvae = new NoViableAltException("", 30, 0, input);
+
+						throw nvae;
+					}
+					switch ( alt30 )
+					{
+					case 1:
+						// Language\\AngleBracketTemplateLexer.g3:240:7: '='
+						{
+						Match('='); if (state.failed) return ;
+						if ( state.backtracking == 0 )
+						{
+							builder.Append('=');
+						}
+
+						}
+						break;
+					case 2:
+						// Language\\AngleBracketTemplateLexer.g3:241:6: '+'
+						{
+						Match('+'); if (state.failed) return ;
+						if ( state.backtracking == 0 )
+						{
+							builder.Append('+');
+						}
+
+						}
+						break;
+
+					}
+
+					// Language\\AngleBracketTemplateLexer.g3:243:4: ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) )
+					int alt31=3;
+					int LA31_0 = input.LA(1);
+
+					if ( (LA31_0=='\"'||LA31_0=='<') )
+					{
+						alt31=1;
+					}
+					else if ( (LA31_0=='{') )
+					{
+						alt31=2;
+					}
+					else if ( ((LA31_0>='\u0000' && LA31_0<='!')||(LA31_0>='#' && LA31_0<=';')||(LA31_0>='=' && LA31_0<='z')||(LA31_0>='|' && LA31_0<='\uFFFF')) )
+					{
+						alt31=3;
+					}
+					else
+					{
+						if (state.backtracking>0) {state.failed=true; return ;}
+						NoViableAltException nvae = new NoViableAltException("", 31, 0, input);
+
+						throw nvae;
+					}
+					switch ( alt31 )
+					{
+					case 1:
+						// Language\\AngleBracketTemplateLexer.g3:243:6: TEMPLATE[out subtext]
+						{
+						mTEMPLATE(out subtext); if (state.failed) return ;
+						if ( state.backtracking == 0 )
+						{
+							builder.Append(subtext);
+						}
+
+						}
+						break;
+					case 2:
+						// Language\\AngleBracketTemplateLexer.g3:244:6: st= SUBTEMPLATE
+						{
+						int stStart873 = GetCharIndex();
+						mSUBTEMPLATE(); if (state.failed) return ;
+						st = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, stStart873, GetCharIndex()-1);
+						if ( state.backtracking == 0 )
+						{
+							builder.Append((st!=null?st.Text:null));
+						}
+
+						}
+						break;
+					case 3:
+						// Language\\AngleBracketTemplateLexer.g3:245:6: ch=~ ( '\"' | '<' | '{' )
+						{
+						ch= input.LA(1);
+						input.Consume();
+						state.failed=false;
+						if ( state.backtracking == 0 )
+						{
+							builder.Append((char)ch);
+						}
+
+						}
+						break;
+
+					}
+
+
+					}
+					break;
+				case 4:
+					// Language\\AngleBracketTemplateLexer.g3:247:5: ch=~ ( '\\\\' | '{' | '=' | '+' | '>' )
+					{
+					ch= input.LA(1);
+					input.Consume();
+					state.failed=false;
+					if ( state.backtracking == 0 )
+					{
+						builder.Append((char)ch);
+					}
+
+					}
+					break;
+
+				default:
+					if ( cnt32 >= 1 )
+						goto loop32;
+
+					if (state.backtracking>0) {state.failed=true; return ;}
+					EarlyExitException eee32 = new EarlyExitException( 32, input );
+					throw eee32;
+				}
+				cnt32++;
+			}
+			loop32:
+				;
+
+
+			if ( state.backtracking == 0 )
+			{
+				_text = builder.ToString();
+			}
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "EXPR"
+
+	// $ANTLR start "TEMPLATE"
+	private void mTEMPLATE(out string _text)
+	{
+		try
+		{
+			IToken ESC2=null;
+			int ch;
+
+
+				_text = string.Empty;
+				System.Text.StringBuilder builder = new System.Text.StringBuilder();
+
+			// Language\\AngleBracketTemplateLexer.g3:259:4: ( '\"' ( ESC |ch=~ ( '\\\\' | '\"' ) )* '\"' | '<<' (=> ( '\\r' )? '\\n' )? ( options {k=2; } :=> ( '\\r' )? '\\n' |=>ch= . )* '>>' )
+			int alt38=2;
+			int LA38_0 = input.LA(1);
+
+			if ( (LA38_0=='\"') )
+			{
+				alt38=1;
+			}
+			else if ( (LA38_0=='<') )
+			{
+				alt38=2;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				NoViableAltException nvae = new NoViableAltException("", 38, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt38 )
+			{
+			case 1:
+				// Language\\AngleBracketTemplateLexer.g3:259:4: '\"' ( ESC |ch=~ ( '\\\\' | '\"' ) )* '\"'
+				{
+				Match('\"'); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+					builder.Append('"');
+				}
+				// Language\\AngleBracketTemplateLexer.g3:261:3: ( ESC |ch=~ ( '\\\\' | '\"' ) )*
+				for ( ; ; )
+				{
+					int alt33=3;
+					int LA33_0 = input.LA(1);
+
+					if ( (LA33_0=='\\') )
+					{
+						alt33=1;
+					}
+					else if ( ((LA33_0>='\u0000' && LA33_0<='!')||(LA33_0>='#' && LA33_0<='[')||(LA33_0>=']' && LA33_0<='\uFFFF')) )
+					{
+						alt33=2;
+					}
+
+
+					switch ( alt33 )
+					{
+					case 1:
+						// Language\\AngleBracketTemplateLexer.g3:261:5: ESC
+						{
+						int ESC2Start966 = GetCharIndex();
+						mESC(); if (state.failed) return ;
+						ESC2 = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, ESC2Start966, GetCharIndex()-1);
+						if ( state.backtracking == 0 )
+						{
+							builder.Append((ESC2!=null?ESC2.Text:null));
+						}
+
+						}
+						break;
+					case 2:
+						// Language\\AngleBracketTemplateLexer.g3:262:5: ch=~ ( '\\\\' | '\"' )
+						{
+						ch= input.LA(1);
+						input.Consume();
+						state.failed=false;
+						if ( state.backtracking == 0 )
+						{
+							builder.Append((char)ch);
+						}
+
+						}
+						break;
+
+					default:
+						goto loop33;
+					}
+				}
+
+				loop33:
+					;
+
+
+				Match('\"'); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+
+								builder.Append('"');
+								_text = builder.ToString();
+
+				}
+
+				}
+				break;
+			case 2:
+				// Language\\AngleBracketTemplateLexer.g3:269:4: '<<' (=> ( '\\r' )? '\\n' )? ( options {k=2; } :=> ( '\\r' )? '\\n' |=>ch= . )* '>>'
+				{
+				Match("<<"); if (state.failed) return ;
+
+				if ( state.backtracking == 0 )
+				{
+
+								builder.Append("<<");
+
+				}
+				// Language\\AngleBracketTemplateLexer.g3:273:3: (=> ( '\\r' )? '\\n' )?
+				int alt35=2;
+				int LA35_0 = input.LA(1);
+
+				if ( (LA35_0=='\r') )
+				{
+					int LA35_1 = input.LA(2);
+
+					if ( (LA35_1=='\n') )
+					{
+						int LA35_2 = input.LA(3);
+
+						if ( (synpred14_AngleBracketTemplateLexer()) )
+						{
+							alt35=1;
+						}
+					}
+				}
+				else if ( (LA35_0=='\n') )
+				{
+					int LA35_2 = input.LA(2);
+
+					if ( (synpred14_AngleBracketTemplateLexer()) )
+					{
+						alt35=1;
+					}
+				}
+				switch ( alt35 )
+				{
+				case 1:
+					// Language\\AngleBracketTemplateLexer.g3:273:5: => ( '\\r' )? '\\n'
+					{
+
+					// Language\\AngleBracketTemplateLexer.g3:273:20: ( '\\r' )?
+					int alt34=2;
+					int LA34_0 = input.LA(1);
+
+					if ( (LA34_0=='\r') )
+					{
+						alt34=1;
+					}
+					switch ( alt34 )
+					{
+					case 1:
+						// Language\\AngleBracketTemplateLexer.g3:273:21: '\\r'
+						{
+						Match('\r'); if (state.failed) return ;
+
+						}
+						break;
+
+					}
+
+					Match('\n'); if (state.failed) return ;
+
+					}
+					break;
+
+				}
+
+				// Language\\AngleBracketTemplateLexer.g3:274:3: ( options {k=2; } :=> ( '\\r' )? '\\n' |=>ch= . )*
+				for ( ; ; )
+				{
+					int alt37=3;
+					alt37 = dfa37.Predict(input);
+					switch ( alt37 )
+					{
+					case 1:
+						// Language\\AngleBracketTemplateLexer.g3:275:4: => ( '\\r' )? '\\n'
+						{
+
+						// Language\\AngleBracketTemplateLexer.g3:275:22: ( '\\r' )?
+						int alt36=2;
+						int LA36_0 = input.LA(1);
+
+						if ( (LA36_0=='\r') )
+						{
+							alt36=1;
+						}
+						switch ( alt36 )
+						{
+						case 1:
+							// Language\\AngleBracketTemplateLexer.g3:275:23: '\\r'
+							{
+							Match('\r'); if (state.failed) return ;
+
+							}
+							break;
+
+						}
+
+						Match('\n'); if (state.failed) return ;
+
+						}
+						break;
+					case 2:
+						// Language\\AngleBracketTemplateLexer.g3:276:5: =>ch= .
+						{
+
+						ch = input.LA(1);
+						MatchAny(); if (state.failed) return ;
+						if ( state.backtracking == 0 )
+						{
+							builder.Append((char)ch);
+						}
+
+						}
+						break;
+
+					default:
+						goto loop37;
+					}
+				}
+
+				loop37:
+					;
+
+
+				Match(">>"); if (state.failed) return ;
+
+				if ( state.backtracking == 0 )
+				{
+
+								builder.Append(">>");
+								_text = builder.ToString();
+
+				}
+
+				}
+				break;
+
+			}
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "TEMPLATE"
+
+	// $ANTLR start "IF_EXPR"
+	private void mIF_EXPR()
+	{
+		try
+		{
+			// Language\\AngleBracketTemplateLexer.g3:287:4: ( ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+ )
+			// Language\\AngleBracketTemplateLexer.g3:287:4: ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+
+			{
+			// Language\\AngleBracketTemplateLexer.g3:287:4: ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+
+			int cnt39=0;
+			for ( ; ; )
+			{
+				int alt39=5;
+				int LA39_0 = input.LA(1);
+
+				if ( (LA39_0=='\\') )
+				{
+					alt39=1;
+				}
+				else if ( (LA39_0=='{') )
+				{
+					alt39=2;
+				}
+				else if ( (LA39_0=='(') )
+				{
+					alt39=3;
+				}
+				else if ( ((LA39_0>='\u0000' && LA39_0<='\'')||(LA39_0>='*' && LA39_0<='[')||(LA39_0>=']' && LA39_0<='z')||(LA39_0>='|' && LA39_0<='\uFFFF')) )
+				{
+					alt39=4;
+				}
+
+
+				switch ( alt39 )
+				{
+				case 1:
+					// Language\\AngleBracketTemplateLexer.g3:287:6: ESC
+					{
+					mESC(); if (state.failed) return ;
+
+					}
+					break;
+				case 2:
+					// Language\\AngleBracketTemplateLexer.g3:288:5: SUBTEMPLATE
+					{
+					mSUBTEMPLATE(); if (state.failed) return ;
+
+					}
+					break;
+				case 3:
+					// Language\\AngleBracketTemplateLexer.g3:289:5: NESTED_PARENS
+					{
+					mNESTED_PARENS(); if (state.failed) return ;
+
+					}
+					break;
+				case 4:
+					// Language\\AngleBracketTemplateLexer.g3:290:5: ~ ( '\\\\' | '{' | '(' | ')' )
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+
+				default:
+					if ( cnt39 >= 1 )
+						goto loop39;
+
+					if (state.backtracking>0) {state.failed=true; return ;}
+					EarlyExitException eee39 = new EarlyExitException( 39, input );
+					throw eee39;
+				}
+				cnt39++;
+			}
+			loop39:
+				;
+
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "IF_EXPR"
+
+	// $ANTLR start "ESC_CHAR"
+	private void mESC_CHAR(out char uc)
+	{
+		try
+		{
+			IToken a=null;
+			IToken b=null;
+			IToken c=null;
+			IToken d=null;
+
+
+				uc = '\0';
+
+			// Language\\AngleBracketTemplateLexer.g3:300:4: ( '\\\\' ( 'n' | 'r' | 't' | ' ' | 'u' a= HEX b= HEX c= HEX d= HEX ) )
+			// Language\\AngleBracketTemplateLexer.g3:300:4: '\\\\' ( 'n' | 'r' | 't' | ' ' | 'u' a= HEX b= HEX c= HEX d= HEX )
+			{
+			Match('\\'); if (state.failed) return ;
+			// Language\\AngleBracketTemplateLexer.g3:301:3: ( 'n' | 'r' | 't' | ' ' | 'u' a= HEX b= HEX c= HEX d= HEX )
+			int alt40=5;
+			switch ( input.LA(1) )
+			{
+			case 'n':
+				{
+				alt40=1;
+				}
+				break;
+			case 'r':
+				{
+				alt40=2;
+				}
+				break;
+			case 't':
+				{
+				alt40=3;
+				}
+				break;
+			case ' ':
+				{
+				alt40=4;
+				}
+				break;
+			case 'u':
+				{
+				alt40=5;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return ;}
+					NoViableAltException nvae = new NoViableAltException("", 40, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt40 )
+			{
+			case 1:
+				// Language\\AngleBracketTemplateLexer.g3:301:5: 'n'
+				{
+				Match('n'); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+					uc = '\n';
+				}
+
+				}
+				break;
+			case 2:
+				// Language\\AngleBracketTemplateLexer.g3:302:5: 'r'
+				{
+				Match('r'); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+					uc = '\r';
+				}
+
+				}
+				break;
+			case 3:
+				// Language\\AngleBracketTemplateLexer.g3:303:5: 't'
+				{
+				Match('t'); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+					uc = '\t';
+				}
+
+				}
+				break;
+			case 4:
+				// Language\\AngleBracketTemplateLexer.g3:304:5: ' '
+				{
+				Match(' '); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+					uc = ' ';
+				}
+
+				}
+				break;
+			case 5:
+				// Language\\AngleBracketTemplateLexer.g3:305:5: 'u' a= HEX b= HEX c= HEX d= HEX
+				{
+				Match('u'); if (state.failed) return ;
+				int aStart1214 = GetCharIndex();
+				mHEX(); if (state.failed) return ;
+				a = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, aStart1214, GetCharIndex()-1);
+				int bStart1218 = GetCharIndex();
+				mHEX(); if (state.failed) return ;
+				b = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, bStart1218, GetCharIndex()-1);
+				int cStart1222 = GetCharIndex();
+				mHEX(); if (state.failed) return ;
+				c = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, cStart1222, GetCharIndex()-1);
+				int dStart1226 = GetCharIndex();
+				mHEX(); if (state.failed) return ;
+				d = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, dStart1226, GetCharIndex()-1);
+				if ( state.backtracking == 0 )
+				{
+					 uc = (char)int.Parse((a!=null?a.Text:null)+(b!=null?b.Text:null)+(c!=null?c.Text:null)+(d!=null?d.Text:null), System.Globalization.NumberStyles.AllowHexSpecifier);
+				}
+
+				}
+				break;
+
+			}
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ESC_CHAR"
+
+	// $ANTLR start "ESC"
+	private void mESC()
+	{
+		try
+		{
+			// Language\\AngleBracketTemplateLexer.g3:313:4: ( '\\\\' . )
+			// Language\\AngleBracketTemplateLexer.g3:313:4: '\\\\' .
+			{
+			Match('\\'); if (state.failed) return ;
+			MatchAny(); if (state.failed) return ;
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ESC"
+
+	// $ANTLR start "HEX"
+	private void mHEX()
+	{
+		try
+		{
+			// Language\\AngleBracketTemplateLexer.g3:318:4: ( '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' )
+			// Language\\AngleBracketTemplateLexer.g3:
+			{
+			if ( (input.LA(1)>='0' && input.LA(1)<='9')||(input.LA(1)>='A' && input.LA(1)<='F')||(input.LA(1)>='a' && input.LA(1)<='f') )
+			{
+				input.Consume();
+			state.failed=false;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				Recover(mse);
+				throw mse;}
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "HEX"
+
+	// $ANTLR start "SUBTEMPLATE"
+	private void mSUBTEMPLATE()
+	{
+		try
+		{
+			// Language\\AngleBracketTemplateLexer.g3:323:4: ( '{' ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )* '}' )
+			// Language\\AngleBracketTemplateLexer.g3:323:4: '{' ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )* '}'
+			{
+			Match('{'); if (state.failed) return ;
+			// Language\\AngleBracketTemplateLexer.g3:324:3: ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )*
+			for ( ; ; )
+			{
+				int alt41=4;
+				int LA41_0 = input.LA(1);
+
+				if ( (LA41_0=='{') )
+				{
+					alt41=1;
+				}
+				else if ( (LA41_0=='\\') )
+				{
+					alt41=2;
+				}
+				else if ( ((LA41_0>='\u0000' && LA41_0<='[')||(LA41_0>=']' && LA41_0<='z')||LA41_0=='|'||(LA41_0>='~' && LA41_0<='\uFFFF')) )
+				{
+					alt41=3;
+				}
+
+
+				switch ( alt41 )
+				{
+				case 1:
+					// Language\\AngleBracketTemplateLexer.g3:324:5: SUBTEMPLATE
+					{
+					mSUBTEMPLATE(); if (state.failed) return ;
+
+					}
+					break;
+				case 2:
+					// Language\\AngleBracketTemplateLexer.g3:325:5: ESC
+					{
+					mESC(); if (state.failed) return ;
+
+					}
+					break;
+				case 3:
+					// Language\\AngleBracketTemplateLexer.g3:326:5: ~ ( '{' | '\\\\' | '}' )
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+
+				default:
+					goto loop41;
+				}
+			}
+
+			loop41:
+				;
+
+
+			Match('}'); if (state.failed) return ;
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "SUBTEMPLATE"
+
+	// $ANTLR start "NESTED_PARENS"
+	private void mNESTED_PARENS()
+	{
+		try
+		{
+			// Language\\AngleBracketTemplateLexer.g3:333:4: ( '(' ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+ ')' )
+			// Language\\AngleBracketTemplateLexer.g3:333:4: '(' ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+ ')'
+			{
+			Match('('); if (state.failed) return ;
+			// Language\\AngleBracketTemplateLexer.g3:334:3: ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+
+			int cnt42=0;
+			for ( ; ; )
+			{
+				int alt42=4;
+				int LA42_0 = input.LA(1);
+
+				if ( (LA42_0=='(') )
+				{
+					alt42=1;
+				}
+				else if ( (LA42_0=='\\') )
+				{
+					alt42=2;
+				}
+				else if ( ((LA42_0>='\u0000' && LA42_0<='\'')||(LA42_0>='*' && LA42_0<='[')||(LA42_0>=']' && LA42_0<='\uFFFF')) )
+				{
+					alt42=3;
+				}
+
+
+				switch ( alt42 )
+				{
+				case 1:
+					// Language\\AngleBracketTemplateLexer.g3:334:5: NESTED_PARENS
+					{
+					mNESTED_PARENS(); if (state.failed) return ;
+
+					}
+					break;
+				case 2:
+					// Language\\AngleBracketTemplateLexer.g3:335:5: ESC
+					{
+					mESC(); if (state.failed) return ;
+
+					}
+					break;
+				case 3:
+					// Language\\AngleBracketTemplateLexer.g3:336:5: ~ ( '(' | '\\\\' | ')' )
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+
+				default:
+					if ( cnt42 >= 1 )
+						goto loop42;
+
+					if (state.backtracking>0) {state.failed=true; return ;}
+					EarlyExitException eee42 = new EarlyExitException( 42, input );
+					throw eee42;
+				}
+				cnt42++;
+			}
+			loop42:
+				;
+
+
+			Match(')'); if (state.failed) return ;
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "NESTED_PARENS"
+
+	// $ANTLR start "COMMENT"
+	private void mCOMMENT()
+	{
+		try
+		{
+
+			    int startCol = CharPositionInLine;
+
+			// Language\\AngleBracketTemplateLexer.g3:347:4: ( '<!' ( . )* '!>' ({...}? => ( '\\r' )? '\\n' )? )
+			// Language\\AngleBracketTemplateLexer.g3:347:4: '<!' ( . )* '!>' ({...}? => ( '\\r' )? '\\n' )?
+			{
+			Match("<!"); if (state.failed) return ;
+
+			// Language\\AngleBracketTemplateLexer.g3:347:9: ( . )*
+			for ( ; ; )
+			{
+				int alt43=2;
+				int LA43_0 = input.LA(1);
+
+				if ( (LA43_0=='!') )
+				{
+					int LA43_1 = input.LA(2);
+
+					if ( (LA43_1=='>') )
+					{
+						alt43=2;
+					}
+					else if ( ((LA43_1>='\u0000' && LA43_1<='=')||(LA43_1>='?' && LA43_1<='\uFFFF')) )
+					{
+						alt43=1;
+					}
+
+
+				}
+				else if ( ((LA43_0>='\u0000' && LA43_0<=' ')||(LA43_0>='\"' && LA43_0<='\uFFFF')) )
+				{
+					alt43=1;
+				}
+
+
+				switch ( alt43 )
+				{
+				case 1:
+					// Language\\AngleBracketTemplateLexer.g3:347:0: .
+					{
+					MatchAny(); if (state.failed) return ;
+
+					}
+					break;
+
+				default:
+					goto loop43;
+				}
+			}
+
+			loop43:
+				;
+
+
+			Match("!>"); if (state.failed) return ;
+
+			// Language\\AngleBracketTemplateLexer.g3:348:3: ({...}? => ( '\\r' )? '\\n' )?
+			int alt45=2;
+			int LA45_0 = input.LA(1);
+
+			if ( (LA45_0=='\n'||LA45_0=='\r') && ((startCol==0)))
+			{
+				alt45=1;
+			}
+			switch ( alt45 )
+			{
+			case 1:
+				// Language\\AngleBracketTemplateLexer.g3:348:5: {...}? => ( '\\r' )? '\\n'
+				{
+				if ( !((startCol==0)) )
+				{
+					if (state.backtracking>0) {state.failed=true; return ;}
+					throw new FailedPredicateException(input, "COMMENT", "startCol==0");
+				}
+				// Language\\AngleBracketTemplateLexer.g3:348:23: ( '\\r' )?
+				int alt44=2;
+				int LA44_0 = input.LA(1);
+
+				if ( (LA44_0=='\r') )
+				{
+					alt44=1;
+				}
+				switch ( alt44 )
+				{
+				case 1:
+					// Language\\AngleBracketTemplateLexer.g3:348:24: '\\r'
+					{
+					Match('\r'); if (state.failed) return ;
+
+					}
+					break;
+
+				}
+
+				Match('\n'); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "COMMENT"
+
+	public override void mTokens()
+	{
+		// Language\\AngleBracketTemplateLexer.g3:1:10: ( NEWLINE | ACTION | LITERAL )
+		int alt46=3;
+		int LA46_0 = input.LA(1);
+
+		if ( (LA46_0=='\n'||LA46_0=='\r') )
+		{
+			alt46=1;
+		}
+		else if ( (LA46_0=='<') )
+		{
+			alt46=2;
+		}
+		else if ( ((LA46_0>='\u0000' && LA46_0<='\t')||(LA46_0>='\u000B' && LA46_0<='\f')||(LA46_0>='\u000E' && LA46_0<=';')||(LA46_0>='=' && LA46_0<='\uFFFF')) )
+		{
+			alt46=3;
+		}
+		else
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			NoViableAltException nvae = new NoViableAltException("", 46, 0, input);
+
+			throw nvae;
+		}
+		switch ( alt46 )
+		{
+		case 1:
+			// Language\\AngleBracketTemplateLexer.g3:1:10: NEWLINE
+			{
+			mNEWLINE(); if (state.failed) return ;
+
+			}
+			break;
+		case 2:
+			// Language\\AngleBracketTemplateLexer.g3:1:18: ACTION
+			{
+			mACTION(); if (state.failed) return ;
+
+			}
+			break;
+		case 3:
+			// Language\\AngleBracketTemplateLexer.g3:1:25: LITERAL
+			{
+			mLITERAL(); if (state.failed) return ;
+
+			}
+			break;
+
+		}
+
+	}
+
+	// $ANTLR start synpred1_AngleBracketTemplateLexer
+	public void synpred1_AngleBracketTemplateLexer_fragment()
+	{
+		// Language\\AngleBracketTemplateLexer.g3:95:4: ( '<\\\\' )
+		// Language\\AngleBracketTemplateLexer.g3:95:5: '<\\\\'
+		{
+		Match("<\\"); if (state.failed) return ;
+
+
+		}
+	}
+	// $ANTLR end synpred1_AngleBracketTemplateLexer
+
+	// $ANTLR start synpred10_AngleBracketTemplateLexer
+	public void synpred10_AngleBracketTemplateLexer_fragment()
+	{
+		// Language\\AngleBracketTemplateLexer.g3:163:7: ( '\\r' | '\\n' )
+		// Language\\AngleBracketTemplateLexer.g3:
+		{
+		if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
+		{
+			input.Consume();
+		state.failed=false;
+		}
+		else
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			MismatchedSetException mse = new MismatchedSetException(null,input);
+			Recover(mse);
+			throw mse;}
+
+
+		}
+	}
+	// $ANTLR end synpred10_AngleBracketTemplateLexer
+
+	// $ANTLR start synpred11_AngleBracketTemplateLexer
+	public void synpred11_AngleBracketTemplateLexer_fragment()
+	{
+		// Language\\AngleBracketTemplateLexer.g3:191:6: ( '<' )
+		// Language\\AngleBracketTemplateLexer.g3:191:7: '<'
+		{
+		Match('<'); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred11_AngleBracketTemplateLexer
+
+	// $ANTLR start synpred12_AngleBracketTemplateLexer
+	public void synpred12_AngleBracketTemplateLexer_fragment()
+	{
+		// Language\\AngleBracketTemplateLexer.g3:192:7: ( '>' )
+		// Language\\AngleBracketTemplateLexer.g3:192:8: '>'
+		{
+		Match('>'); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred12_AngleBracketTemplateLexer
+
+	// $ANTLR start synpred13_AngleBracketTemplateLexer
+	public void synpred13_AngleBracketTemplateLexer_fragment()
+	{
+		// Language\\AngleBracketTemplateLexer.g3:193:7: ( '\\\\' )
+		// Language\\AngleBracketTemplateLexer.g3:193:8: '\\\\'
+		{
+		Match('\\'); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred13_AngleBracketTemplateLexer
+
+	// $ANTLR start synpred14_AngleBracketTemplateLexer
+	public void synpred14_AngleBracketTemplateLexer_fragment()
+	{
+		// Language\\AngleBracketTemplateLexer.g3:273:5: ( '\\r' | '\\n' )
+		// Language\\AngleBracketTemplateLexer.g3:
+		{
+		if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
+		{
+			input.Consume();
+		state.failed=false;
+		}
+		else
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			MismatchedSetException mse = new MismatchedSetException(null,input);
+			Recover(mse);
+			throw mse;}
+
+
+		}
+	}
+	// $ANTLR end synpred14_AngleBracketTemplateLexer
+
+	// $ANTLR start synpred15_AngleBracketTemplateLexer
+	public void synpred15_AngleBracketTemplateLexer_fragment()
+	{
+		// Language\\AngleBracketTemplateLexer.g3:275:4: ( ( '\\r' )? '\\n>>' )
+		// Language\\AngleBracketTemplateLexer.g3:275:5: ( '\\r' )? '\\n>>'
+		{
+		// Language\\AngleBracketTemplateLexer.g3:275:5: ( '\\r' )?
+		int alt47=2;
+		int LA47_0 = input.LA(1);
+
+		if ( (LA47_0=='\r') )
+		{
+			alt47=1;
+		}
+		switch ( alt47 )
+		{
+		case 1:
+			// Language\\AngleBracketTemplateLexer.g3:275:0: '\\r'
+			{
+			Match('\r'); if (state.failed) return ;
+
+			}
+			break;
+
+		}
+
+		Match("\n>>"); if (state.failed) return ;
+
+
+		}
+	}
+	// $ANTLR end synpred15_AngleBracketTemplateLexer
+
+	// $ANTLR start synpred16_AngleBracketTemplateLexer
+	public void synpred16_AngleBracketTemplateLexer_fragment()
+	{
+		// Language\\AngleBracketTemplateLexer.g3:276:5: ( '>' ~ '>' |~ '>' )
+		int alt48=2;
+		int LA48_0 = input.LA(1);
+
+		if ( (LA48_0=='>') )
+		{
+			alt48=1;
+		}
+		else if ( ((LA48_0>='\u0000' && LA48_0<='=')||(LA48_0>='?' && LA48_0<='\uFFFF')) )
+		{
+			alt48=2;
+		}
+		else
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			NoViableAltException nvae = new NoViableAltException("", 48, 0, input);
+
+			throw nvae;
+		}
+		switch ( alt48 )
+		{
+		case 1:
+			// Language\\AngleBracketTemplateLexer.g3:276:6: '>' ~ '>'
+			{
+			Match('>'); if (state.failed) return ;
+			if ( (input.LA(1)>='\u0000' && input.LA(1)<='=')||(input.LA(1)>='?' && input.LA(1)<='\uFFFF') )
+			{
+				input.Consume();
+			state.failed=false;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				Recover(mse);
+				throw mse;}
+
+
+			}
+			break;
+		case 2:
+			// Language\\AngleBracketTemplateLexer.g3:276:17: ~ '>'
+			{
+			if ( (input.LA(1)>='\u0000' && input.LA(1)<='=')||(input.LA(1)>='?' && input.LA(1)<='\uFFFF') )
+			{
+				input.Consume();
+			state.failed=false;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				Recover(mse);
+				throw mse;}
+
+
+			}
+			break;
+
+		}}
+	// $ANTLR end synpred16_AngleBracketTemplateLexer
+
+	// $ANTLR start synpred2_AngleBracketTemplateLexer
+	public void synpred2_AngleBracketTemplateLexer_fragment()
+	{
+		// Language\\AngleBracketTemplateLexer.g3:106:4: ( '<!' )
+		// Language\\AngleBracketTemplateLexer.g3:106:5: '<!'
+		{
+		Match("<!"); if (state.failed) return ;
+
+
+		}
+	}
+	// $ANTLR end synpred2_AngleBracketTemplateLexer
+
+	// $ANTLR start synpred3_AngleBracketTemplateLexer
+	public void synpred3_AngleBracketTemplateLexer_fragment()
+	{
+		// Language\\AngleBracketTemplateLexer.g3:108:4: ( '<if' )
+		// Language\\AngleBracketTemplateLexer.g3:108:5: '<if'
+		{
+		Match("<if"); if (state.failed) return ;
+
+
+		}
+	}
+	// $ANTLR end synpred3_AngleBracketTemplateLexer
+
+	// $ANTLR start synpred4_AngleBracketTemplateLexer
+	public void synpred4_AngleBracketTemplateLexer_fragment()
+	{
+		// Language\\AngleBracketTemplateLexer.g3:115:5: ( '<elseif' )
+		// Language\\AngleBracketTemplateLexer.g3:115:6: '<elseif'
+		{
+		Match("<elseif"); if (state.failed) return ;
+
+
+		}
+	}
+	// $ANTLR end synpred4_AngleBracketTemplateLexer
+
+	// $ANTLR start synpred5_AngleBracketTemplateLexer
+	public void synpred5_AngleBracketTemplateLexer_fragment()
+	{
+		// Language\\AngleBracketTemplateLexer.g3:122:5: ( '<else' )
+		// Language\\AngleBracketTemplateLexer.g3:122:6: '<else'
+		{
+		Match("<else"); if (state.failed) return ;
+
+
+		}
+	}
+	// $ANTLR end synpred5_AngleBracketTemplateLexer
+
+	// $ANTLR start synpred6_AngleBracketTemplateLexer
+	public void synpred6_AngleBracketTemplateLexer_fragment()
+	{
+		// Language\\AngleBracketTemplateLexer.g3:129:5: ( '<endif' )
+		// Language\\AngleBracketTemplateLexer.g3:129:6: '<endif'
+		{
+		Match("<endif"); if (state.failed) return ;
+
+
+		}
+	}
+	// $ANTLR end synpred6_AngleBracketTemplateLexer
+
+	// $ANTLR start synpred7_AngleBracketTemplateLexer
+	public void synpred7_AngleBracketTemplateLexer_fragment()
+	{
+		// Language\\AngleBracketTemplateLexer.g3:138:4: ( '<@' )
+		// Language\\AngleBracketTemplateLexer.g3:138:5: '<@'
+		{
+		Match("<@"); if (state.failed) return ;
+
+
+		}
+	}
+	// $ANTLR end synpred7_AngleBracketTemplateLexer
+
+	// $ANTLR start synpred8_AngleBracketTemplateLexer
+	public void synpred8_AngleBracketTemplateLexer_fragment()
+	{
+		// Language\\AngleBracketTemplateLexer.g3:154:7: ( '\\r' | '\\n' )
+		// Language\\AngleBracketTemplateLexer.g3:
+		{
+		if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
+		{
+			input.Consume();
+		state.failed=false;
+		}
+		else
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			MismatchedSetException mse = new MismatchedSetException(null,input);
+			Recover(mse);
+			throw mse;}
+
+
+		}
+	}
+	// $ANTLR end synpred8_AngleBracketTemplateLexer
+
+	// $ANTLR start synpred9_AngleBracketTemplateLexer
+	public void synpred9_AngleBracketTemplateLexer_fragment()
+	{
+		// Language\\AngleBracketTemplateLexer.g3:159:8: ( '\\r' | '\\n' )
+		// Language\\AngleBracketTemplateLexer.g3:
+		{
+		if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
+		{
+			input.Consume();
+		state.failed=false;
+		}
+		else
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			MismatchedSetException mse = new MismatchedSetException(null,input);
+			Recover(mse);
+			throw mse;}
+
+
+		}
+	}
+	// $ANTLR end synpred9_AngleBracketTemplateLexer
+
+	public bool synpred8_AngleBracketTemplateLexer()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred8_AngleBracketTemplateLexer_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred9_AngleBracketTemplateLexer()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred9_AngleBracketTemplateLexer_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred10_AngleBracketTemplateLexer()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred10_AngleBracketTemplateLexer_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred3_AngleBracketTemplateLexer()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred3_AngleBracketTemplateLexer_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred4_AngleBracketTemplateLexer()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred4_AngleBracketTemplateLexer_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred5_AngleBracketTemplateLexer()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred5_AngleBracketTemplateLexer_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred6_AngleBracketTemplateLexer()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred6_AngleBracketTemplateLexer_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred7_AngleBracketTemplateLexer()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred7_AngleBracketTemplateLexer_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred1_AngleBracketTemplateLexer()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred1_AngleBracketTemplateLexer_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred2_AngleBracketTemplateLexer()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred2_AngleBracketTemplateLexer_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred11_AngleBracketTemplateLexer()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred11_AngleBracketTemplateLexer_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred12_AngleBracketTemplateLexer()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred12_AngleBracketTemplateLexer_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred13_AngleBracketTemplateLexer()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred13_AngleBracketTemplateLexer_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred14_AngleBracketTemplateLexer()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred14_AngleBracketTemplateLexer_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred15_AngleBracketTemplateLexer()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred15_AngleBracketTemplateLexer_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred16_AngleBracketTemplateLexer()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred16_AngleBracketTemplateLexer_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+
+
+	#region DFA
+	DFA18 dfa18;
+	DFA37 dfa37;
+
+	protected override void InitDFAs()
+	{
+		base.InitDFAs();
+		dfa18 = new DFA18( this, new SpecialStateTransitionHandler( specialStateTransition18 ) );
+		dfa37 = new DFA37( this, new SpecialStateTransitionHandler( specialStateTransition37 ) );
+	}
+
+	class DFA18 : DFA
+	{
+
+		const string DFA18_eotS =
+			"\x3\xFFFF\x2\x6\x2\xFFFF\x1\x5\x2\xFFFF\x3\x5\x1\xFFFF";
+		const string DFA18_eofS =
+			"\xE\xFFFF";
+		const string DFA18_minS =
+			"\x5\x0\x2\xFFFF\x1\x65\x2\x0\x1\x6E\x1\x64\x1\x3E\x1\x0";
+		const string DFA18_maxS =
+			"\x1\xFFFF\x2\x0\x2\xFFFF\x2\xFFFF\x1\x65\x2\x0\x1\x6E\x1\x64\x1\x3E\x1"+
+			"\x0";
+		const string DFA18_acceptS =
+			"\x5\xFFFF\x1\x1\x1\x2\x7\xFFFF";
+		const string DFA18_specialS =
+			"\x1\x0\x1\x1\x1\x2\x1\x3\x1\x4\x2\xFFFF\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9"+
+			"\x1\xA\x1\xB}>";
+		static readonly string[] DFA18_transitionS =
+			{
+				"\xA\x4\x1\x2\x2\x4\x1\x1\x2E\x4\x1\x3\xFFC3\x4",
+				"\x1\xFFFF",
+				"\x1\xFFFF",
+				"\xA\x5\x1\x9\x2\x5\x1\x8\x32\x5\x1\x7\xFFBF\x5",
+				"\xA\x5\x1\x9\x2\x5\x1\x8\xFFF2\x5",
+				"",
+				"",
+				"\x1\xA",
+				"\x1\xFFFF",
+				"\x1\xFFFF",
+				"\x1\xB",
+				"\x1\xC",
+				"\x1\xD",
+				"\x1\xFFFF"
+			};
+
+		static readonly short[] DFA18_eot = DFA.UnpackEncodedString(DFA18_eotS);
+		static readonly short[] DFA18_eof = DFA.UnpackEncodedString(DFA18_eofS);
+		static readonly char[] DFA18_min = DFA.UnpackEncodedStringToUnsignedChars(DFA18_minS);
+		static readonly char[] DFA18_max = DFA.UnpackEncodedStringToUnsignedChars(DFA18_maxS);
+		static readonly short[] DFA18_accept = DFA.UnpackEncodedString(DFA18_acceptS);
+		static readonly short[] DFA18_special = DFA.UnpackEncodedString(DFA18_specialS);
+		static readonly short[][] DFA18_transition;
+
+		static DFA18()
+		{
+			int numStates = DFA18_transitionS.Length;
+			DFA18_transition = new short[numStates][];
+			for ( int i=0; i < numStates; i++ )
+			{
+				DFA18_transition[i] = DFA.UnpackEncodedString(DFA18_transitionS[i]);
+			}
+		}
+
+		public DFA18( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
+			: base( specialStateTransition )	{
+			this.recognizer = recognizer;
+			this.decisionNumber = 18;
+			this.eot = DFA18_eot;
+			this.eof = DFA18_eof;
+			this.min = DFA18_min;
+			this.max = DFA18_max;
+			this.accept = DFA18_accept;
+			this.special = DFA18_special;
+			this.transition = DFA18_transition;
+		}
+		public override string GetDescription()
+		{
+			return "()+ loopback of 158:5: ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+";
+		}
+	}
+
+	int specialStateTransition18( DFA dfa, int s, IIntStream _input )
+	{
+		IIntStream input = _input;
+		int _s = s;
+		switch ( s )
+		{
+
+			case 0:
+				int LA18_0 = input.LA(1);
+
+				s = -1;
+				if ( (LA18_0=='\r') ) {s = 1;}
+
+				else if ( (LA18_0=='\n') ) {s = 2;}
+
+				else if ( (LA18_0=='<') ) {s = 3;}
+
+				else if ( ((LA18_0>='\u0000' && LA18_0<='\t')||(LA18_0>='\u000B' && LA18_0<='\f')||(LA18_0>='\u000E' && LA18_0<=';')||(LA18_0>='=' && LA18_0<='\uFFFF')) ) {s = 4;}
+
+				if ( s>=0 ) return s;
+				break;
+
+			case 1:
+				int LA18_1 = input.LA(1);
+
+
+				int index18_1 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( ((!(upcomingAtEND(1) || ( input.LA(1) == '\n' && upcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && upcomingAtEND(3) )))) ) {s = 5;}
+
+				else if ( (true) ) {s = 6;}
+
+
+				input.Seek(index18_1);
+				if ( s>=0 ) return s;
+				break;
+
+			case 2:
+				int LA18_2 = input.LA(1);
+
+
+				int index18_2 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( ((!(upcomingAtEND(1) || ( input.LA(1) == '\n' && upcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && upcomingAtEND(3) )))) ) {s = 5;}
+
+				else if ( (true) ) {s = 6;}
+
+
+				input.Seek(index18_2);
+				if ( s>=0 ) return s;
+				break;
+
+			case 3:
+				int LA18_3 = input.LA(1);
+
+
+				int index18_3 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (LA18_3=='@') ) {s = 7;}
+
+				else if ( (LA18_3=='\r') ) {s = 8;}
+
+				else if ( (LA18_3=='\n') ) {s = 9;}
+
+				else if ( ((LA18_3>='\u0000' && LA18_3<='\t')||(LA18_3>='\u000B' && LA18_3<='\f')||(LA18_3>='\u000E' && LA18_3<='?')||(LA18_3>='A' && LA18_3<='\uFFFF')) && ((!(upcomingAtEND(1) || ( input.LA(1) == '\n' && upcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && upcomingAtEND(3) ))))) {s = 5;}
+
+				else s = 6;
+
+
+				input.Seek(index18_3);
+				if ( s>=0 ) return s;
+				break;
+
+			case 4:
+				int LA18_4 = input.LA(1);
+
+
+				int index18_4 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (LA18_4=='\r') ) {s = 8;}
+
+				else if ( (LA18_4=='\n') ) {s = 9;}
+
+				else if ( ((LA18_4>='\u0000' && LA18_4<='\t')||(LA18_4>='\u000B' && LA18_4<='\f')||(LA18_4>='\u000E' && LA18_4<='\uFFFF')) && ((!(upcomingAtEND(1) || ( input.LA(1) == '\n' && upcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && upcomingAtEND(3) ))))) {s = 5;}
+
+				else s = 6;
+
+
+				input.Seek(index18_4);
+				if ( s>=0 ) return s;
+				break;
+
+			case 5:
+				int LA18_7 = input.LA(1);
+
+
+				int index18_7 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (LA18_7=='e') ) {s = 10;}
+
+				else s = 5;
+
+
+				input.Seek(index18_7);
+				if ( s>=0 ) return s;
+				break;
+
+			case 6:
+				int LA18_8 = input.LA(1);
+
+
+				int index18_8 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( ((!(upcomingAtEND(1) || ( input.LA(1) == '\n' && upcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && upcomingAtEND(3) )))) ) {s = 5;}
+
+				else if ( (true) ) {s = 6;}
+
+
+				input.Seek(index18_8);
+				if ( s>=0 ) return s;
+				break;
+
+			case 7:
+				int LA18_9 = input.LA(1);
+
+
+				int index18_9 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( ((!(upcomingAtEND(1) || ( input.LA(1) == '\n' && upcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && upcomingAtEND(3) )))) ) {s = 5;}
+
+				else if ( (true) ) {s = 6;}
+
+
+				input.Seek(index18_9);
+				if ( s>=0 ) return s;
+				break;
+
+			case 8:
+				int LA18_10 = input.LA(1);
+
+
+				int index18_10 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (LA18_10=='n') ) {s = 11;}
+
+				else s = 5;
+
+
+				input.Seek(index18_10);
+				if ( s>=0 ) return s;
+				break;
+
+			case 9:
+				int LA18_11 = input.LA(1);
+
+
+				int index18_11 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (LA18_11=='d') ) {s = 12;}
+
+				else s = 5;
+
+
+				input.Seek(index18_11);
+				if ( s>=0 ) return s;
+				break;
+
+			case 10:
+				int LA18_12 = input.LA(1);
+
+
+				int index18_12 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (LA18_12=='>') ) {s = 13;}
+
+				else s = 5;
+
+
+				input.Seek(index18_12);
+				if ( s>=0 ) return s;
+				break;
+
+			case 11:
+				int LA18_13 = input.LA(1);
+
+
+				int index18_13 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( ((!(upcomingAtEND(1) || ( input.LA(1) == '\n' && upcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && upcomingAtEND(3) )))) ) {s = 5;}
+
+				else if ( (true) ) {s = 6;}
+
+
+				input.Seek(index18_13);
+				if ( s>=0 ) return s;
+				break;
+		}
+		if (state.backtracking>0) {state.failed=true; return -1;}
+		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 18, _s, input);
+		dfa.Error(nvae);
+		throw nvae;
+	}
+	class DFA37 : DFA
+	{
+
+		const string DFA37_eotS =
+			"\x13\xFFFF";
+		const string DFA37_eofS =
+			"\x13\xFFFF";
+		const string DFA37_minS =
+			"\x4\x0\x1\xFFFF\x1\x0\xD\xFFFF";
+		const string DFA37_maxS =
+			"\x2\xFFFF\x2\x0\x1\xFFFF\x1\x0\xD\xFFFF";
+		const string DFA37_acceptS =
+			"\x4\xFFFF\x1\x2\x1\xFFFF\x3\x2\x4\xFFFF\x1\x1\x4\xFFFF\x1\x3";
+		const string DFA37_specialS =
+			"\x1\x0\x1\x1\x1\x2\x1\x3\x1\xFFFF\x1\x4\xD\xFFFF}>";
+		static readonly string[] DFA37_transitionS =
+			{
+				"\xA\x4\x1\x3\x2\x4\x1\x2\x30\x4\x1\x1\xFFC1\x4",
+				"\xA\x8\x1\x7\x2\x8\x1\x6\x30\x8\x1\x5\xFFC1\x8",
+				"\x1\xFFFF",
+				"\x1\xFFFF",
+				"",
+				"\x1\xFFFF",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				""
+			};
+
+		static readonly short[] DFA37_eot = DFA.UnpackEncodedString(DFA37_eotS);
+		static readonly short[] DFA37_eof = DFA.UnpackEncodedString(DFA37_eofS);
+		static readonly char[] DFA37_min = DFA.UnpackEncodedStringToUnsignedChars(DFA37_minS);
+		static readonly char[] DFA37_max = DFA.UnpackEncodedStringToUnsignedChars(DFA37_maxS);
+		static readonly short[] DFA37_accept = DFA.UnpackEncodedString(DFA37_acceptS);
+		static readonly short[] DFA37_special = DFA.UnpackEncodedString(DFA37_specialS);
+		static readonly short[][] DFA37_transition;
+
+		static DFA37()
+		{
+			int numStates = DFA37_transitionS.Length;
+			DFA37_transition = new short[numStates][];
+			for ( int i=0; i < numStates; i++ )
+			{
+				DFA37_transition[i] = DFA.UnpackEncodedString(DFA37_transitionS[i]);
+			}
+		}
+
+		public DFA37( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
+			: base( specialStateTransition )	{
+			this.recognizer = recognizer;
+			this.decisionNumber = 37;
+			this.eot = DFA37_eot;
+			this.eof = DFA37_eof;
+			this.min = DFA37_min;
+			this.max = DFA37_max;
+			this.accept = DFA37_accept;
+			this.special = DFA37_special;
+			this.transition = DFA37_transition;
+		}
+		public override string GetDescription()
+		{
+			return "()* loopback of 274:3: ( options {k=2; } :=> ( '\\r' )? '\\n' |=>ch= . )*";
+		}
+	}
+
+	int specialStateTransition37( DFA dfa, int s, IIntStream _input )
+	{
+		IIntStream input = _input;
+		int _s = s;
+		switch ( s )
+		{
+
+			case 0:
+				int LA37_0 = input.LA(1);
+
+
+				int index37_0 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (LA37_0=='>') ) {s = 1;}
+
+				else if ( (LA37_0=='\r') ) {s = 2;}
+
+				else if ( (LA37_0=='\n') ) {s = 3;}
+
+				else if ( ((LA37_0>='\u0000' && LA37_0<='\t')||(LA37_0>='\u000B' && LA37_0<='\f')||(LA37_0>='\u000E' && LA37_0<='=')||(LA37_0>='?' && LA37_0<='\uFFFF')) && (synpred16_AngleBracketTemplateLexer())) {s = 4;}
+
+
+				input.Seek(index37_0);
+				if ( s>=0 ) return s;
+				break;
+
+			case 1:
+				int LA37_1 = input.LA(1);
+
+
+				int index37_1 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (LA37_1=='>') ) {s = 5;}
+
+				else if ( (LA37_1=='\r') && (synpred16_AngleBracketTemplateLexer())) {s = 6;}
+
+				else if ( (LA37_1=='\n') && (synpred16_AngleBracketTemplateLexer())) {s = 7;}
+
+				else if ( ((LA37_1>='\u0000' && LA37_1<='\t')||(LA37_1>='\u000B' && LA37_1<='\f')||(LA37_1>='\u000E' && LA37_1<='=')||(LA37_1>='?' && LA37_1<='\uFFFF')) && (synpred16_AngleBracketTemplateLexer())) {s = 8;}
+
+
+				input.Seek(index37_1);
+				if ( s>=0 ) return s;
+				break;
+
+			case 2:
+				int LA37_2 = input.LA(1);
+
+
+				int index37_2 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred15_AngleBracketTemplateLexer()) ) {s = 13;}
+
+				else if ( (synpred16_AngleBracketTemplateLexer()) ) {s = 8;}
+
+
+				input.Seek(index37_2);
+				if ( s>=0 ) return s;
+				break;
+
+			case 3:
+				int LA37_3 = input.LA(1);
+
+
+				int index37_3 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred15_AngleBracketTemplateLexer()) ) {s = 13;}
+
+				else if ( (synpred16_AngleBracketTemplateLexer()) ) {s = 8;}
+
+
+				input.Seek(index37_3);
+				if ( s>=0 ) return s;
+				break;
+
+			case 4:
+				int LA37_5 = input.LA(1);
+
+
+				int index37_5 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred16_AngleBracketTemplateLexer()) ) {s = 8;}
+
+				else if ( (true) ) {s = 18;}
+
+
+				input.Seek(index37_5);
+				if ( s>=0 ) return s;
+				break;
+		}
+		if (state.backtracking>0) {state.failed=true; return -1;}
+		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 37, _s, input);
+		dfa.Error(nvae);
+		throw nvae;
+	}
+
+	#endregion
+
+}
+
+} // namespace Antlr3.ST.Language
diff --git a/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.g3 b/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.g3
new file mode 100644
index 0000000..ae2c0fc
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.g3
@@ -0,0 +1,349 @@
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+lexer grammar AngleBracketTemplateLexer;
+
+options
+{
+	tokenVocab=Template;
+	language=CSharp3;
+}
+
+@lexer::header
+{
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+using StringBuffer = System.Text.StringBuilder;
+}
+
+@lexer::namespace {Antlr3.ST.Language}
+
+NEWLINE
+	:	('\r')? '\n' {currentIndent=null;}
+	;
+
+ACTION
+options { k = 1; }
+@init
+{
+	int startCol = CharPositionInLine;
+	System.Text.StringBuilder buf = null;
+	string subtext = string.Empty;
+	char uc = '\0';
+	System.Text.StringBuilder builder = null;
+	bool atLeft = false;
+	string t = null;
+}
+	:	('<\\') =>
+		// Match escapes not in a string like <\n\ufea5>
+		{
+			buf = new System.Text.StringBuilder();
+			uc = '\0';
+		}
+		'<' (ESC_CHAR[out uc] {buf.Append(uc);} )+ '>'
+		{
+			Text = buf.ToString();
+			$type = LITERAL;
+		}
+	|	('<!') => COMMENT {$channel = HIDDEN;}
+	|	(	options { k = 1; } :
+			('<if') =>
+			'<if' (' ')* '(' exp=IF_EXPR ')>'
+			( ('\r')? '\n' )? // ignore any newline right after an IF
+			{
+				Text = "if(" + $exp.text + ")";
+				$type = TemplateParser.IF;
+			}
+		|	('<elseif') =>
+			'<elseif' (' ')* '(' exp=IF_EXPR ')>'
+			( ('\r')? '\n' )? // ignore any newline right after an IF
+			{
+				Text = "elseif(" + $exp.text + ")";
+				$type = TemplateParser.ELSEIF;
+			}
+		|	('<else') =>
+			'<else>'
+			( ('\r')? '\n' )? // ignore any newline right after an ELSE
+			{
+				Text = "else";
+				$type = TemplateParser.ELSE;
+			}
+		|	('<endif') =>
+			'<endif>'
+			( {startCol==0}? => ('\r')? '\n' )? // ignore after ENDIF if on line by itself
+			{
+				Text = "endif";
+				$type = TemplateParser.ENDIF;
+			}
+		|	// match <@foo()> => foo
+			// match <@foo>...<@end> => foo::=...
+			('<@') =>
+			{
+				builder = new System.Text.StringBuilder();
+			}
+			'<@'
+			( ch=~('>'|'(') {builder.Append((char)$ch);} )+
+			{ t = builder.ToString(); }
+			(	'()>'
+				{
+					$type = TemplateParser.REGION_REF;
+				}
+			|	'>'
+				{
+					$type = TemplateParser.REGION_DEF;
+					builder.Append("::=");
+				}
+				( ('\r'|'\n') => ('\r')? '\n' )?
+				{
+					atLeft = false;
+				}
+				(	{!(upcomingAtEND(1) || ( input.LA(1) == '\n' && upcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && upcomingAtEND(3) ))}? =>
+					(	('\r'|'\n') => ('\r' {builder.Append('\r');})? '\n' {builder.Append('\n'); atLeft = true;}
+					|	ch=. {builder.Append((char)$ch); atLeft = false;}
+					)
+				)+
+				(	('\r'|'\n') => ('\r')? '\n' {atLeft = true;} )?
+				(	'<@end>'
+				|	. {self.error("missing region "+t+" <@end> tag");}
+				)
+				( {atLeft}? => ('\r')? '\n' )?
+			)
+			{
+				Text = builder.ToString();
+			}
+		|	'<' EXPR[out subtext] '>'
+			{ Text = subtext; }
+		)
+		{
+			//ChunkToken t = new ChunkToken($type, $text, currentIndent);
+			//state.token = t; //$ setToken(t);
+			state.token = new ChunkToken($type, $text, currentIndent);
+		}
+	;
+
+LITERAL
+@init
+{
+	System.Text.StringBuilder builder = new System.Text.StringBuilder();
+	int loopStartIndex = 0;
+	int col = 0;
+}
+	:	(	(	'\\'
+				(	options {k=1;}:
+					('<') => '<' { builder.Append('<'); } // allow escaped delimiter
+				|	('>') => '>' { builder.Append('>'); }
+				|	('\\') => '\\' { builder.Append('\\'); } // always replace \\ with \
+				|	ch=. { builder.Append( "\\" + (char)$ch ); }  // otherwise ignore escape char
+				)
+			)
+		|	ind=INDENT
+			{
+				loopStartIndex = builder.Length;
+				col = CharPositionInLine - $ind.text.Length;
+
+				builder.Append( $ind.text );
+				if ( col==0 && input.LA(1)=='<' )
+				{
+					// store indent in ASTExpr not in a literal
+					currentIndent=$ind.text;
+					builder.Length = loopStartIndex; // reset length to wack text
+				}
+				else
+				{
+					currentIndent=null;
+				}
+			}
+		|	ch=~('\\'|' '|'\t'|'<'|'\r'|'\n') { builder.Append( (char)$ch ); }
+		)+
+		{
+			Text = builder.ToString();
+			if ( $text.Length == 0 )
+			{
+				$channel = HIDDEN;
+			}
+		} // pure indent?
+	;
+
+fragment
+INDENT // done
+	:	(' ' | '\t')+
+	;
+
+fragment
+EXPR[out string _text]
+@init
+{
+	string subtext = string.Empty;
+	$_text = string.Empty;
+	System.Text.StringBuilder builder = new System.Text.StringBuilder();
+}
+	:	(	ESC									{builder.Append($ESC.text);}
+		|	st=SUBTEMPLATE						{builder.Append($st.text);}
+		|	(	'='								{builder.Append('=');}
+			|	'+'								{builder.Append('+');}
+			)
+			(	TEMPLATE[out subtext]			{builder.Append(subtext);}
+			|	st=SUBTEMPLATE					{builder.Append($st.text);}
+			|	ch=~('"'|'<'|'{')				{builder.Append((char)$ch);}
+			)
+		|	ch=~('\\'|'{'|'='|'+'|'>')			{builder.Append((char)$ch);}
+		)+
+		{$_text = builder.ToString();}
+	;
+
+fragment
+TEMPLATE[out string _text]
+@init
+{
+	$_text = string.Empty;
+	System.Text.StringBuilder builder = new System.Text.StringBuilder();
+}
+	:	'"'
+		{builder.Append('"');}
+		(	ESC						{builder.Append($ESC.text);}
+		|	ch=~('\\'|'"')			{builder.Append((char)$ch);}
+		)*
+		'"'
+		{
+			builder.Append('"');
+			$_text = builder.ToString();
+		}
+	|	'<<'
+		{
+			builder.Append("<<");
+		}
+		(	('\r'|'\n') => ('\r')? '\n' )? // consume 1st \n
+		(	options { k=2; }:
+			('\r'? '\n>>') => ('\r')? '\n'	// kill last \r\n or last \n
+		|	('>' ~'>' | ~'>') => ch=. {builder.Append((char)$ch);}
+		)*
+		'>>'
+		{
+			builder.Append(">>");
+			$_text = builder.ToString();
+		}
+	;
+
+fragment
+IF_EXPR
+	:	(	ESC
+		|	SUBTEMPLATE
+		|	NESTED_PARENS
+		|	~('\\'|'{'|'('|')')
+		)+
+	;
+
+fragment
+ESC_CHAR[out char uc]
+@init
+{
+	$uc = '\0';
+}
+	:	'\\'
+		(	'n' {$uc = '\n';}
+		|	'r' {$uc = '\r';}
+		|	't' {$uc = '\t';}
+		|	' ' {$uc = ' ';}
+		|	'u' a=HEX b=HEX c=HEX d=HEX
+			{ $uc = (char)int.Parse($a.text+$b.text+$c.text+$d.text, System.Globalization.NumberStyles.AllowHexSpecifier); }
+		)
+	;
+
+// just used to skip stuff (not part of unicode escape stuff)
+fragment
+ESC
+	:	'\\' . // ('<'|'>'|'n'|'t'|'"'|'\''|':'|'{'|'}'|'\\')
+	;
+
+fragment
+HEX
+	:	'0'..'9'|'A'..'F'|'a'..'f'
+	;
+
+fragment
+SUBTEMPLATE
+	:	'{'
+		(	SUBTEMPLATE
+		|	ESC
+		|	~('{'|'\\'|'}')
+		)*
+		'}'
+	;
+
+fragment
+NESTED_PARENS
+	:	'('
+		(	NESTED_PARENS
+		|	ESC
+		|	~('('|'\\'|')')
+		)+
+		')'
+	;
+
+fragment
+COMMENT
+@init
+{
+    int startCol = CharPositionInLine;
+}
+	:	'<!' .* '!>'
+		( {startCol==0}? => ('\r')? '\n' )?
+	;
diff --git a/Antlr3.StringTemplate/Language/AngleBracketTemplateLexerHelper.cs b/Antlr3.StringTemplate/Language/AngleBracketTemplateLexerHelper.cs
new file mode 100644
index 0000000..0567d1b
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/AngleBracketTemplateLexerHelper.cs
@@ -0,0 +1,80 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Grammar conversion to ANTLR v3 and C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *	notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	notice, this list of conditions and the following disclaimer in the
+ *	documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *	derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST.Language
+{
+    using ANTLRReaderStream = Antlr.Runtime.ANTLRReaderStream;
+    using RecognitionException = Antlr.Runtime.RecognitionException;
+    using TextReader = System.IO.TextReader;
+
+    partial class AngleBracketTemplateLexer
+    {
+        protected string currentIndent = null;
+        protected StringTemplate self;
+
+        public AngleBracketTemplateLexer( StringTemplate self, TextReader r )
+            : this( new ANTLRReaderStream( r ) )
+        {
+            this.self = self;
+        }
+
+        public override void ReportError( RecognitionException e )
+        {
+            self.error( "<...> chunk lexer error", e );
+        }
+
+        public override string[] GetTokenNames()
+        {
+            return TemplateParser.tokenNames;
+        }
+
+        //protected boolean upcomingELSE(int i) /*throws CharStreamException*/ {
+        //    return LA(i)=='<'&&LA(i+1)=='e'&&LA(i+2)=='l'&&LA(i+3)=='s'&&LA(i+4)=='e'&&
+        //           LA(i+5)=='>';
+        //}
+
+        //protected boolean upcomingENDIF(int i) throws CharStreamException {
+        //    return LA(i)=='<'&&LA(i+1)=='e'&&LA(i+2)=='n'&&LA(i+3)=='d'&&LA(i+4)=='i'&&
+        //           LA(i+5)=='f'&&LA(i+6)=='>';
+        //}
+
+        protected bool upcomingAtEND(int i)
+        {
+            return input.LA(i)=='<'&&input.LA(i+1)=='@'&&input.LA(i+2)=='e'&&input.LA(i+3)=='n'&&input.LA(i+4)=='d'&&input.LA(i+5)=='>';
+        }
+
+        //protected boolean upcomingNewline(int i) throws CharStreamException {
+        //    return (LA(i)=='\r'&&LA(i+1)=='\n')||LA(i)=='\n';
+        //}
+    }
+
+}
diff --git a/Antlr3.StringTemplate/Language/Cat.cs b/Antlr3.StringTemplate/Language/Cat.cs
new file mode 100644
index 0000000..c7e6f1e
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/Cat.cs
@@ -0,0 +1,68 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2003-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+
+using IEnumerable = System.Collections.IEnumerable;
+using IEnumerator = System.Collections.IEnumerator;
+using IList = System.Collections.IList;
+
+namespace Antlr3.ST.Language
+{
+    public class Cat : List<object>
+    {
+        public Cat( IList attributes )
+            : base( Unfold( attributes.Cast<object>() ).ToArray() )
+        {
+        }
+
+        static IEnumerable<object> Unfold( IEnumerable<object> items )
+        {
+            return items.SelectMany( ( item ) =>
+            {
+                item = ASTExpr.convertAnythingIteratableToIterator( item );
+                if ( item is Antlr.Runtime.JavaExtensions.Iterator )
+                    return ( (Antlr.Runtime.JavaExtensions.Iterator)item ).Source.Cast<object>();
+                else if ( item is string )
+                    return Enumerable.Repeat( item, 1 );
+                else if ( item is IEnumerable )
+                    return ( (IEnumerable)item ).Cast<object>();
+                else if ( item is IEnumerator )
+                    return Enumerable.Repeat( item, 1 );
+                else
+                    return Enumerable.Repeat( item, 1 );
+            } );
+        }
+    }
+}
diff --git a/Antlr3.StringTemplate/Language/ChunkToken.cs b/Antlr3.StringTemplate/Language/ChunkToken.cs
new file mode 100644
index 0000000..a0fe18e
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/ChunkToken.cs
@@ -0,0 +1,64 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2003-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST.Language
+{
+    using CommonToken = Antlr.Runtime.CommonToken;
+
+    /** <summary>
+     *  Tracks the various string and attribute chunks discovered
+     *  by the lexer.  Subclassed CommonToken so that I could pass
+     *  the indentation to the parser, which will add it to the
+     *  ASTExpr created for the $...$ attribute reference.
+     *  </summary>
+     */
+    public class ChunkToken : CommonToken
+    {
+        public ChunkToken( int type, string text, string indentation )
+            : base( type, text )
+        {
+            Indentation = indentation;
+        }
+
+        public string Indentation
+        {
+            get;
+            set;
+        }
+
+        public override string ToString()
+        {
+            return base.ToString() + "<indent='" + Indentation + "'>";
+        }
+    }
+
+}
diff --git a/Antlr3.StringTemplate/Language/ConditionalExpr.cs b/Antlr3.StringTemplate/Language/ConditionalExpr.cs
new file mode 100644
index 0000000..0bc8f68
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/ConditionalExpr.cs
@@ -0,0 +1,176 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2003-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST.Language
+{
+    using System.Collections.Generic;
+    using Antlr.Runtime.JavaExtensions;
+
+    using ITree = Antlr.Runtime.Tree.ITree;
+    using RecognitionException = Antlr.Runtime.RecognitionException;
+
+    /** <summary>A conditional reference to an embedded subtemplate.</summary> */
+    public class ConditionalExpr : ASTExpr
+    {
+        StringTemplate subtemplate = null;
+        List<ElseIfClauseData> elseIfSubtemplates = null;
+        StringTemplate elseSubtemplate = null;
+
+        protected class ElseIfClauseData
+        {
+            public ASTExpr expr;
+            public StringTemplate st;
+        }
+
+        public ConditionalExpr( StringTemplate enclosingTemplate, ITree tree ) :
+            base( enclosingTemplate, tree, null )
+        {
+        }
+
+        public virtual void setSubtemplate( StringTemplate subtemplate )
+        {
+            this.subtemplate = subtemplate;
+        }
+
+        public virtual void addElseIfSubtemplate( ASTExpr conditionalTree,
+                                         StringTemplate subtemplate )
+        {
+            if ( elseIfSubtemplates == null )
+            {
+                elseIfSubtemplates = new List<ElseIfClauseData>();
+            }
+            ElseIfClauseData d = new ElseIfClauseData()
+            {
+                expr = conditionalTree,
+                st = subtemplate
+            };
+            elseIfSubtemplates.Add( d );
+        }
+
+        public virtual StringTemplate getSubtemplate()
+        {
+            return subtemplate;
+        }
+
+        public virtual StringTemplate getElseSubtemplate()
+        {
+            return elseSubtemplate;
+        }
+
+        public virtual void setElseSubtemplate( StringTemplate elseSubtemplate )
+        {
+            this.elseSubtemplate = elseSubtemplate;
+        }
+
+        /** <summary>
+         *  To write out the value of a condition expr, invoke the evaluator in eval.g
+         *  to walk the condition tree computing the boolean value.  If result
+         *  is true, then write subtemplate.
+         *  </summary>
+         */
+        public override int write( StringTemplate self, IStringTemplateWriter @out )
+        {
+            if ( exprTree == null || self == null || @out == null )
+            {
+                return 0;
+            }
+            // System.out.println("evaluating conditional tree: "+exprTree.toStringList());
+            ActionEvaluator eval = null;
+            int n = 0;
+            try
+            {
+                bool testedTrue = false;
+                // get conditional from tree and compute result
+                ITree cond = exprTree.GetChild( 0 );
+                eval = new ActionEvaluator( self, this, @out, cond );
+                bool includeSubtemplate = eval.ifCondition(); // eval and write out tree
+                // System.out.println("subtemplate "+subtemplate);
+                // IF
+                if ( includeSubtemplate )
+                {
+                    n = writeSubTemplate( self, @out, subtemplate );
+                    testedTrue = true;
+                }
+                // ELSEIF
+                else if ( elseIfSubtemplates != null && elseIfSubtemplates.Count > 0 )
+                {
+                    for ( int i = 0; i < elseIfSubtemplates.Count; i++ )
+                    {
+                        ElseIfClauseData elseIfClause = elseIfSubtemplates[i];
+                        eval = new ActionEvaluator( self, this, @out, elseIfClause.expr.exprTree );
+                        includeSubtemplate = eval.ifCondition();
+                        if ( includeSubtemplate )
+                        {
+                            writeSubTemplate( self, @out, elseIfClause.st );
+                            testedTrue = true;
+                            break;
+                        }
+                    }
+                }
+                // ELSE
+                if ( !testedTrue && elseSubtemplate != null )
+                {
+                    // evaluate ELSE clause if present and IF condition failed
+                    StringTemplate s = elseSubtemplate.getInstanceOf();
+                    s.setEnclosingInstance( self );
+                    s.setGroup( self.getGroup() );
+                    s.setNativeGroup( self.getNativeGroup() );
+                    n = s.write( @out );
+                }
+            }
+            catch ( RecognitionException re )
+            {
+                self.error( "can't evaluate tree: " + exprTree.ToStringTree(), re );
+            }
+            return n;
+        }
+
+        protected virtual int writeSubTemplate( StringTemplate self,
+                                       IStringTemplateWriter @out,
+                                       StringTemplate subtemplate )
+        {
+            /* To evaluate the IF chunk, make a new instance whose enclosingInstance
+             * points at 'self' so get attribute works.  Otherwise, enclosingInstance
+             * points at the template used to make the precompiled code.  We need a
+             * new template instance every time we exec this chunk to get the new
+             * "enclosing instance" pointer.
+             */
+            StringTemplate s = subtemplate.getInstanceOf();
+            s.setEnclosingInstance( self );
+            // make sure we evaluate in context of enclosing template's
+            // group so polymorphism works. :)
+            s.setGroup( self.getGroup() );
+            s.setNativeGroup( self.getNativeGroup() );
+            return s.write( @out );
+        }
+    }
+}
diff --git a/Antlr3.StringTemplate/Language/Expr.cs b/Antlr3.StringTemplate/Language/Expr.cs
new file mode 100644
index 0000000..1503aba
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/Expr.cs
@@ -0,0 +1,86 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2003-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST.Language
+{
+    /** <summary>
+     *  A string template expression embedded within the template.
+     *  A template is parsed into a tokenized vector of Expr objects
+     *  and then executed after the user sticks in attribute values.
+     *  </summary>
+     *
+     *  <remarks>
+     *  This list of Expr objects represents a "program" for the StringTemplate
+     *  evaluator.
+     *  </remarks>
+     */
+    abstract public class Expr
+    {
+        /** <summary>The StringTemplate object surrounding this expr</summary> */
+        protected StringTemplate enclosingTemplate;
+
+        /** <summary>
+         *  Any thing spit out as a chunk (even plain text) must be indented
+         *  according to whitespace before the action that generated it.  So,
+         *  plain text in the outermost template is never indented, but the
+         *  text and attribute references in a nested template will all be
+         *  indented by the amount seen directly in front of the attribute
+         *  reference that initiates construction of the nested template.
+         *  </summary>
+         */
+        protected string indentation = null;
+
+        public Expr( StringTemplate enclosingTemplate )
+        {
+            this.enclosingTemplate = enclosingTemplate;
+        }
+
+        /** <summary>How to write this node to output; return how many char written</summary> */
+        abstract public int write( StringTemplate self, IStringTemplateWriter writer );
+
+        public virtual StringTemplate getEnclosingTemplate()
+        {
+            return enclosingTemplate;
+        }
+
+        public virtual string getIndentation()
+        {
+            return indentation;
+        }
+
+        public virtual void setIndentation( string indentation )
+        {
+            this.indentation = indentation;
+        }
+    }
+
+}
diff --git a/Antlr3.StringTemplate/Language/FormalArgument.cs b/Antlr3.StringTemplate/Language/FormalArgument.cs
new file mode 100644
index 0000000..3871ea1
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/FormalArgument.cs
@@ -0,0 +1,159 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2003-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST.Language
+{
+    using System.Collections.Generic;
+    using Antlr.Runtime.JavaExtensions;
+
+    /** <summary>
+     *  Represents the name of a formal argument
+     *  defined in a template:
+     *  </summary>
+     *
+     *  <remarks>
+     *  group test;
+     *  test(a,b) : "$a$ $b$"
+     *  t() : "blort"
+     *
+     *  Each template has a set of these formal arguments or uses
+     *  a placeholder object: UNKNOWN (indicating that no arguments
+     *  were specified such as when a template is loaded from a file.st).
+     *
+     *  Note: originally, I tracked cardinality as well as the name of an
+     *  attribute.  I'm leaving the code here as I suspect something may come
+     *  of it later.  Currently, though, cardinality is not used.
+     *  </remarks>
+     */
+    public class FormalArgument
+    {
+        // the following represent bit positions emulating a cardinality bitset.
+        public const int OPTIONAL = 1;     // a?
+        public const int REQUIRED = 2;     // a
+        public const int ZERO_OR_MORE = 4; // a*
+        public const int ONE_OR_MORE = 8;  // a+
+
+        public static readonly string[] suffixes =
+            {
+                null,
+                "?",
+                "",
+                null,
+                "*",
+                null,
+                null,
+                null,
+                "+"
+            };
+
+        /** <summary>
+         *  When template arguments are not available such as when the user
+         *  uses "new StringTemplate(...)", then the list of formal arguments
+         *  must be distinguished from the case where a template can specify
+         *  args and there just aren't any such as the t() template above.
+         *  </summary>
+         */
+        public static readonly IList<FormalArgument> UNKNOWN = new FormalArgument[0];
+
+        public string name;
+        //protected int cardinality = REQUIRED;
+
+        /** <summary>If they specified name="value", store the template here</summary> */
+        public StringTemplate defaultValueST;
+
+        public FormalArgument( string name )
+        {
+            this.name = name;
+        }
+
+        public FormalArgument( string name, StringTemplate defaultValueST )
+        {
+            this.name = name;
+            this.defaultValueST = defaultValueST;
+        }
+
+        public static string getCardinalityName( int cardinality )
+        {
+            switch ( cardinality )
+            {
+            case OPTIONAL:
+                return "optional";
+            case REQUIRED:
+                return "exactly one";
+            case ZERO_OR_MORE:
+                return "zero-or-more";
+            case ONE_OR_MORE:
+                return "one-or-more";
+            default:
+                return "unknown";
+            }
+        }
+
+        public override bool Equals( object o )
+        {
+            if ( o == null || !( o is FormalArgument ) )
+            {
+                return false;
+            }
+            FormalArgument other = (FormalArgument)o;
+            if ( !this.name.Equals( other.name ) )
+            {
+                return false;
+            }
+            // only check if there is a default value; that's all
+            if ( ( this.defaultValueST != null && other.defaultValueST == null ) ||
+                 ( this.defaultValueST == null && other.defaultValueST != null ) )
+            {
+                return false;
+            }
+            return true;
+        }
+
+        public override int GetHashCode()
+        {
+            return ObjectExtensions.ShiftPrimeXOR(
+                ( name != null ) ? name.GetHashCode() : 0,
+                ( defaultValueST != null ) ? defaultValueST.GetHashCode() : 0
+                );
+        }
+
+        public override string ToString()
+        {
+            if ( defaultValueST != null )
+            {
+                return name + "=" + defaultValueST;
+            }
+            return name;
+        }
+    }
+
+}
diff --git a/Antlr3.StringTemplate/Language/Group.g3 b/Antlr3.StringTemplate/Language/Group.g3
new file mode 100644
index 0000000..89dc48d
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/Group.g3
@@ -0,0 +1,415 @@
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+grammar Group;
+
+options
+{
+	language=CSharp3;
+}
+
+tokens
+{
+KWGROUP = 'group';
+KWIMPLEMENTS = 'implements';
+KWDEFAULT = 'default';
+}
+
+@lexer::header
+{
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+}
+
+@parser::header
+{
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+using HashMap = System.Collections.Hashtable;
+using Map = System.Collections.IDictionary;
+}
+
+@lexer::namespace {Antlr3.ST.Language}
+@parser::namespace {Antlr3.ST.Language}
+
+public
+group[StringTemplateGroup g]
+@init
+{
+this._group = g;
+}
+	:	'group' name=ID {g.Name = $name.text;}
+		( COLON s=ID {g.setSuperGroup($s.text);} )?
+		(	'implements' i=ID {g.implementInterface($i.text);}
+			(COMMA i2=ID {g.implementInterface($i2.text);} )*
+		)?
+		SEMI
+		( template[g] | mapdef[g] )+
+		EOF
+	;
+
+template[StringTemplateGroup g]
+@init
+{
+	Map formalArgs = null;
+	StringTemplate st = null;
+	bool ignore = false;
+	string templateName=null;
+	int line = input.LT(1).Line;
+}
+	:	(	AT scope2=ID DOT region=ID
+			{
+				templateName=g.getMangledRegionName($scope2.text,$region.text);
+				if ( g.isDefinedInThisGroup(templateName) )
+				{
+					g.error("group "+g.Name+" line "+line+": redefinition of template region: @"+
+						$scope2.text+"."+$region.text);
+					st = new StringTemplate(); // create bogus template to fill in
+				}
+				else
+				{
+					bool err = false;
+					// @template.region() ::= "..."
+					StringTemplate scopeST = g.lookupTemplate($scope2.text);
+					if ( scopeST == null )
+					{
+						g.error("group "+g.Name+" line "+line+": reference to region within undefined template: "+
+							$scope2.text);
+						err=true;
+					}
+					else if ( !scopeST.containsRegionName($region.text) )
+					{
+						g.error("group "+g.Name+" line "+line+": template "+$scope2.text+" has no region called "+
+							$region.text);
+						err=true;
+					}
+					if ( err )
+					{
+						st = new StringTemplate();
+					}
+					else
+					{
+						st = g.defineRegionTemplate($scope2.text,
+													$region.text,
+													null,
+													StringTemplate.REGION_EXPLICIT);
+					}
+				}
+			}
+		|	name=ID {templateName = $name.text;}
+			{
+				if ( g.isDefinedInThisGroup(templateName) )
+				{
+					g.error("redefinition of template: "+templateName);
+					st = new StringTemplate(); // create bogus template to fill in
+				}
+				else
+				{
+					st = g.defineTemplate(templateName, null);
+				}
+			}
+		)
+		{if ( st!=null ) {st.setGroupFileLine(line);}}
+		LPAREN
+			(args[st]|{st.defineEmptyFormalArgumentList();})
+		RPAREN
+		DEFINED_TO_BE
+		(	t=STRING     {st.setTemplate($t.text);}
+		|	bt=BIGSTRING {st.setTemplate($bt.text);}
+		)
+
+	|   alias=ID DEFINED_TO_BE target=ID
+		{g.defineTemplateAlias($alias.text, $target.text);}
+	;
+
+args[StringTemplate st]
+	:	arg[st] ( COMMA arg[st] )*
+	;
+
+arg[StringTemplate st]
+@init
+{
+	StringTemplate defaultValue = null;
+}
+	:	name=ID
+		(	ASSIGN s=STRING
+			{
+				defaultValue=new StringTemplate("\$_val_\$");
+				defaultValue.setAttribute("_val_", $s.text);
+				defaultValue.defineFormalArgument("_val_");
+				defaultValue.Name = "<"+st.getName()+"'s arg "+$name.text+" default value subtemplate>";
+			}
+		|	ASSIGN bs=ANONYMOUS_TEMPLATE
+			{
+				defaultValue=new StringTemplate(st.getGroup(), $bs.text);
+				defaultValue.Name = "<"+st.getName()+"'s arg "+$name.text+" default value subtemplate>";
+			}
+		)?
+		{st.defineFormalArgument($name.text, defaultValue);}
+	;
+
+mapdef[StringTemplateGroup g]
+	:	name=ID
+		DEFINED_TO_BE m=map
+		{
+			if ( g.getMap($name.text)!=null )
+			{
+				g.error("redefinition of map: "+$name.text);
+			}
+			else if ( g.isDefinedInThisGroup($name.text) )
+			{
+				g.error("redefinition of template as map: "+$name.text);
+			}
+			else
+			{
+				g.defineMap($name.text, m);
+			}
+		}
+	;
+
+map returns [Map mapping=new HashMap()]
+	:   LBRACK mapPairs[mapping] RBRACK
+	;
+
+mapPairs [Map mapping]
+	:	keyValuePair[mapping] (COMMA keyValuePair[mapping])*
+		(COMMA defaultValuePair[mapping])?
+	|	defaultValuePair[mapping]
+	;
+
+defaultValuePair[Map mapping]
+	:	'default' COLON v=keyValue
+		{mapping[ASTExpr.DEFAULT_MAP_VALUE_NAME] = $v.value;}
+	;
+
+keyValuePair[Map mapping]
+	:	key=STRING COLON v=keyValue {mapping[$key.text] = $v.value;}
+	;
+
+keyValue returns [StringTemplate value=null]
+	:	s1=BIGSTRING	{value = new StringTemplate(_group,$s1.text);}
+	|	s2=STRING		{value = new StringTemplate(_group,$s2.text);}
+	|	k=ID			{$k.text == "key"}?
+						{value = ASTExpr.MAP_KEY_VALUE;}
+	|					{value = null;}
+	;
+
+//////////////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////////////
+// LEXER
+
+ID
+	:	('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'0'..'9'|'-'|'_')*
+	;
+
+STRING
+@init
+{
+	System.Text.StringBuilder builder = new System.Text.StringBuilder();
+}
+	:	'"'
+		(	'\\'
+			(	'"'		{builder.Append('"');}
+			|	ch=~'"'	{builder.Append("\\" + (char)$ch);}
+			)
+		|	ch=~('\\'|'"') {builder.Append((char)$ch);}
+		)*
+		(	{InColorizer}? => '"'?
+		|	'"'
+		)
+		{
+			Text = builder.ToString();
+		}
+	;
+
+BIGSTRING
+@init
+{
+	System.Text.StringBuilder builder = new System.Text.StringBuilder();
+}
+	:	(	'<<'
+			{
+				if ( !InAnonymousTemplate && !InBlockComment )
+					InBigString=true;
+			}
+			( ('\r'|'\n') => ('\r')? '\n' )? // consume 1st \n
+			(	('\r\n>>') => '\r' '\n' // kill last \r\n
+			|	('\n>>') => '\n' // kill last \n
+			|	('\r'|'\n') => ('\r' { builder.Append('\r'); })? '\n' { builder.Append('\n'); } // else keep
+			|	('\\>') => '\\>' { builder.Append('>'); } // \> escape
+			|	('>' ~'>' | ~'>') => ch=. { builder.Append((char)$ch); }
+			)*
+			(	'>>'
+				{ InBigString = false; }
+			)?
+		)
+		{
+			Text = builder.ToString();
+		}
+	;
+
+ANONYMOUS_TEMPLATE
+@init
+{
+	System.Text.StringBuilder builder = new System.Text.StringBuilder();
+}
+	:	(	'{'
+			{
+				if ( !InBigString && !InBlockComment )
+					InAnonymousTemplate=true;
+			}
+			(	('\r' { builder.Append('\r'); })? '\n' { builder.Append('\n'); } // else keep
+			|	('\\}') => '\\' '}' { builder.Append('}'); }  // \} escape
+			|	ch=~('\r'|'\n'|'}') { builder.Append((char)$ch); }
+			)*
+			(	'}'
+				{ InAnonymousTemplate = false; }
+			)?
+		)
+		{
+			Text = builder.ToString();
+		}
+	;
+
+
+AT	:	'@' ;
+LPAREN: '(' ;
+RPAREN: ')' ;
+LBRACK: '[' ;
+RBRACK: ']' ;
+COMMA:  ',' ;
+DOT:  '.' ;
+DEFINED_TO_BE:  '::=';
+SEMI:   ';' ;
+COLON:  ':' ;
+STAR:   '*' ;
+PLUS:   '+' ;
+ASSIGN:   '=' ;
+OPTIONAL : '?' ;
+
+CLOSE_BIG_STRING : '>>';
+CLOSE_BLOCK_COMMENT : '*/';
+CLOSE_ANON_TEMPLATE : '}';
+
+// Single-line comments
+SL_COMMENT
+	:	'//'
+		(~('\n'|'\r'))* (('\r')? '\n')?
+		{ $channel = HIDDEN; }
+	;
+
+// multiple-line comments
+ML_COMMENT
+	:	'/*'
+		{
+			if ( !InAnonymousTemplate && !InBigString )
+				InBlockComment=true;
+
+			$channel = HIDDEN;
+		}
+		(	~('*')
+			|	('*' ~'/') => '*'
+		)*
+		('*/' {InBlockComment = false;})?
+	;
+
+// Whitespace -- ignored
+WS  :   (   ' '
+        |   '\t'
+        |   '\f'
+        |   ('\r')? '\n'
+        )+
+        { $channel = HIDDEN; }
+    ;
+
+ANYCHAR
+	:	.
+	;
diff --git a/Antlr3.StringTemplate/Language/GroupLexer.cs b/Antlr3.StringTemplate/Language/GroupLexer.cs
new file mode 100644
index 0000000..fa3ce59
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/GroupLexer.cs
@@ -0,0 +1,2633 @@
+// $ANTLR 3.1.2 Language\\Group.g3 2009-03-07 08:51:18
+
+// The variable 'variable' is assigned but its value is never used.
+#pragma warning disable 219
+// Unreachable code detected.
+#pragma warning disable 162
+
+
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+using System.Collections.Generic;
+using Antlr.Runtime;
+using Stack = System.Collections.Generic.Stack<object>;
+using List = System.Collections.IList;
+using ArrayList = System.Collections.Generic.List<object>;
+using Map = System.Collections.IDictionary;
+using HashMap = System.Collections.Generic.Dictionary<object, object>;
+namespace Antlr3.ST.Language
+{
+public partial class GroupLexer : Lexer
+{
+	public const int EOF=-1;
+	public const int ANONYMOUS_TEMPLATE=4;
+	public const int ANYCHAR=5;
+	public const int ASSIGN=6;
+	public const int AT=7;
+	public const int BIGSTRING=8;
+	public const int CLOSE_ANON_TEMPLATE=9;
+	public const int CLOSE_BIG_STRING=10;
+	public const int CLOSE_BLOCK_COMMENT=11;
+	public const int COLON=12;
+	public const int COMMA=13;
+	public const int DEFINED_TO_BE=14;
+	public const int DOT=15;
+	public const int ID=16;
+	public const int KWDEFAULT=17;
+	public const int KWGROUP=18;
+	public const int KWIMPLEMENTS=19;
+	public const int LBRACK=20;
+	public const int LPAREN=21;
+	public const int ML_COMMENT=22;
+	public const int OPTIONAL=23;
+	public const int PLUS=24;
+	public const int RBRACK=25;
+	public const int RPAREN=26;
+	public const int SEMI=27;
+	public const int SL_COMMENT=28;
+	public const int STAR=29;
+	public const int STRING=30;
+	public const int WS=31;
+
+    // delegates
+    // delegators
+
+	public GroupLexer() {}
+	public GroupLexer( ICharStream input )
+		: this( input, new RecognizerSharedState() )
+	{
+	}
+	public GroupLexer( ICharStream input, RecognizerSharedState state )
+		: base( input, state )
+	{
+
+	}
+	public override string GrammarFileName { get { return "Language\\Group.g3"; } }
+
+	// $ANTLR start "KWDEFAULT"
+	private void mKWDEFAULT()
+	{
+		try
+		{
+			int _type = KWDEFAULT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Group.g3:42:13: ( 'default' )
+			// Language\\Group.g3:42:13: 'default'
+			{
+			Match("default"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "KWDEFAULT"
+
+	// $ANTLR start "KWGROUP"
+	private void mKWGROUP()
+	{
+		try
+		{
+			int _type = KWGROUP;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Group.g3:43:11: ( 'group' )
+			// Language\\Group.g3:43:11: 'group'
+			{
+			Match("group"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "KWGROUP"
+
+	// $ANTLR start "KWIMPLEMENTS"
+	private void mKWIMPLEMENTS()
+	{
+		try
+		{
+			int _type = KWIMPLEMENTS;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Group.g3:44:16: ( 'implements' )
+			// Language\\Group.g3:44:16: 'implements'
+			{
+			Match("implements"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "KWIMPLEMENTS"
+
+	// $ANTLR start "ID"
+	private void mID()
+	{
+		try
+		{
+			int _type = ID;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Group.g3:290:4: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '-' | '_' )* )
+			// Language\\Group.g3:290:4: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '-' | '_' )*
+			{
+			if ( (input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z') )
+			{
+				input.Consume();
+			state.failed=false;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				Recover(mse);
+				throw mse;}
+
+			// Language\\Group.g3:290:28: ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '-' | '_' )*
+			for ( ; ; )
+			{
+				int alt1=2;
+				int LA1_0 = input.LA(1);
+
+				if ( (LA1_0=='-'||(LA1_0>='0' && LA1_0<='9')||(LA1_0>='A' && LA1_0<='Z')||LA1_0=='_'||(LA1_0>='a' && LA1_0<='z')) )
+				{
+					alt1=1;
+				}
+
+
+				switch ( alt1 )
+				{
+				case 1:
+					// Language\\Group.g3:
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+
+				default:
+					goto loop1;
+				}
+			}
+
+			loop1:
+				;
+
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ID"
+
+	// $ANTLR start "STRING"
+	private void mSTRING()
+	{
+		try
+		{
+			int _type = STRING;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			int ch;
+
+
+				System.Text.StringBuilder builder = new System.Text.StringBuilder();
+
+			// Language\\Group.g3:298:4: ( '\"' ( '\\\\' ( '\"' |ch=~ '\"' ) |ch=~ ( '\\\\' | '\"' ) )* ({...}? => ( '\"' )? | '\"' ) )
+			// Language\\Group.g3:298:4: '\"' ( '\\\\' ( '\"' |ch=~ '\"' ) |ch=~ ( '\\\\' | '\"' ) )* ({...}? => ( '\"' )? | '\"' )
+			{
+			Match('\"'); if (state.failed) return ;
+			// Language\\Group.g3:299:3: ( '\\\\' ( '\"' |ch=~ '\"' ) |ch=~ ( '\\\\' | '\"' ) )*
+			for ( ; ; )
+			{
+				int alt3=3;
+				int LA3_0 = input.LA(1);
+
+				if ( (LA3_0=='\\') )
+				{
+					alt3=1;
+				}
+				else if ( ((LA3_0>='\u0000' && LA3_0<='!')||(LA3_0>='#' && LA3_0<='[')||(LA3_0>=']' && LA3_0<='\uFFFF')) )
+				{
+					alt3=2;
+				}
+
+
+				switch ( alt3 )
+				{
+				case 1:
+					// Language\\Group.g3:299:5: '\\\\' ( '\"' |ch=~ '\"' )
+					{
+					Match('\\'); if (state.failed) return ;
+					// Language\\Group.g3:300:4: ( '\"' |ch=~ '\"' )
+					int alt2=2;
+					int LA2_0 = input.LA(1);
+
+					if ( (LA2_0=='\"') )
+					{
+						alt2=1;
+					}
+					else if ( ((LA2_0>='\u0000' && LA2_0<='!')||(LA2_0>='#' && LA2_0<='\uFFFF')) )
+					{
+						alt2=2;
+					}
+					else
+					{
+						if (state.backtracking>0) {state.failed=true; return ;}
+						NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
+
+						throw nvae;
+					}
+					switch ( alt2 )
+					{
+					case 1:
+						// Language\\Group.g3:300:6: '\"'
+						{
+						Match('\"'); if (state.failed) return ;
+						if ( state.backtracking == 0 )
+						{
+							builder.Append('"');
+						}
+
+						}
+						break;
+					case 2:
+						// Language\\Group.g3:301:6: ch=~ '\"'
+						{
+						ch= input.LA(1);
+						input.Consume();
+						state.failed=false;
+						if ( state.backtracking == 0 )
+						{
+							builder.Append("\\" + (char)ch);
+						}
+
+						}
+						break;
+
+					}
+
+
+					}
+					break;
+				case 2:
+					// Language\\Group.g3:303:5: ch=~ ( '\\\\' | '\"' )
+					{
+					ch= input.LA(1);
+					input.Consume();
+					state.failed=false;
+					if ( state.backtracking == 0 )
+					{
+						builder.Append((char)ch);
+					}
+
+					}
+					break;
+
+				default:
+					goto loop3;
+				}
+			}
+
+			loop3:
+				;
+
+
+			// Language\\Group.g3:305:3: ({...}? => ( '\"' )? | '\"' )
+			int alt5=2;
+			int LA5_0 = input.LA(1);
+
+			if ( (LA5_0=='\"') )
+			{
+				int LA5_1 = input.LA(2);
+
+				if ( ((InColorizer)) )
+				{
+					alt5=1;
+				}
+				else if ( (true) )
+				{
+					alt5=2;
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return ;}
+					NoViableAltException nvae = new NoViableAltException("", 5, 1, input);
+
+					throw nvae;
+				}
+			}
+			else
+			{
+				alt5=1;}
+			switch ( alt5 )
+			{
+			case 1:
+				// Language\\Group.g3:305:5: {...}? => ( '\"' )?
+				{
+				if ( !((InColorizer)) )
+				{
+					if (state.backtracking>0) {state.failed=true; return ;}
+					throw new FailedPredicateException(input, "STRING", "InColorizer");
+				}
+				// Language\\Group.g3:305:23: ( '\"' )?
+				int alt4=2;
+				int LA4_0 = input.LA(1);
+
+				if ( (LA4_0=='\"') )
+				{
+					alt4=1;
+				}
+				switch ( alt4 )
+				{
+				case 1:
+					// Language\\Group.g3:305:0: '\"'
+					{
+					Match('\"'); if (state.failed) return ;
+
+					}
+					break;
+
+				}
+
+
+				}
+				break;
+			case 2:
+				// Language\\Group.g3:306:5: '\"'
+				{
+				Match('\"'); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+			if ( state.backtracking == 0 )
+			{
+
+							Text = builder.ToString();
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "STRING"
+
+	// $ANTLR start "BIGSTRING"
+	private void mBIGSTRING()
+	{
+		try
+		{
+			int _type = BIGSTRING;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			int ch;
+
+
+				System.Text.StringBuilder builder = new System.Text.StringBuilder();
+
+			// Language\\Group.g3:318:4: ( ( '<<' (=> ( '\\r' )? '\\n' )? (=> '\\r' '\\n' |=> '\\n' |=> ( '\\r' )? '\\n' |=> '\\\\>' |=>ch= . )* ( '>>' )? ) )
+			// Language\\Group.g3:318:4: ( '<<' (=> ( '\\r' )? '\\n' )? (=> '\\r' '\\n' |=> '\\n' |=> ( '\\r' )? '\\n' |=> '\\\\>' |=>ch= . )* ( '>>' )? )
+			{
+			// Language\\Group.g3:318:4: ( '<<' (=> ( '\\r' )? '\\n' )? (=> '\\r' '\\n' |=> '\\n' |=> ( '\\r' )? '\\n' |=> '\\\\>' |=>ch= . )* ( '>>' )? )
+			// Language\\Group.g3:318:6: '<<' (=> ( '\\r' )? '\\n' )? (=> '\\r' '\\n' |=> '\\n' |=> ( '\\r' )? '\\n' |=> '\\\\>' |=>ch= . )* ( '>>' )?
+			{
+			Match("<<"); if (state.failed) return ;
+
+			if ( state.backtracking == 0 )
+			{
+
+								if ( !InAnonymousTemplate && !InBlockComment )
+									InBigString=true;
+
+			}
+			// Language\\Group.g3:323:4: (=> ( '\\r' )? '\\n' )?
+			int alt7=2;
+			int LA7_0 = input.LA(1);
+
+			if ( (LA7_0=='\r') )
+			{
+				int LA7_1 = input.LA(2);
+
+				if ( (LA7_1=='\n') )
+				{
+					int LA7_4 = input.LA(3);
+
+					if ( (synpred1_Group()) )
+					{
+						alt7=1;
+					}
+				}
+			}
+			else if ( (LA7_0=='\n') )
+			{
+				int LA7_2 = input.LA(2);
+
+				if ( (synpred1_Group()) )
+				{
+					alt7=1;
+				}
+			}
+			switch ( alt7 )
+			{
+			case 1:
+				// Language\\Group.g3:323:6: => ( '\\r' )? '\\n'
+				{
+
+				// Language\\Group.g3:323:21: ( '\\r' )?
+				int alt6=2;
+				int LA6_0 = input.LA(1);
+
+				if ( (LA6_0=='\r') )
+				{
+					alt6=1;
+				}
+				switch ( alt6 )
+				{
+				case 1:
+					// Language\\Group.g3:323:22: '\\r'
+					{
+					Match('\r'); if (state.failed) return ;
+
+					}
+					break;
+
+				}
+
+				Match('\n'); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+			// Language\\Group.g3:324:4: (=> '\\r' '\\n' |=> '\\n' |=> ( '\\r' )? '\\n' |=> '\\\\>' |=>ch= . )*
+			for ( ; ; )
+			{
+				int alt9=6;
+				alt9 = dfa9.Predict(input);
+				switch ( alt9 )
+				{
+				case 1:
+					// Language\\Group.g3:324:6: => '\\r' '\\n'
+					{
+
+					Match('\r'); if (state.failed) return ;
+					Match('\n'); if (state.failed) return ;
+
+					}
+					break;
+				case 2:
+					// Language\\Group.g3:325:6: => '\\n'
+					{
+
+					Match('\n'); if (state.failed) return ;
+
+					}
+					break;
+				case 3:
+					// Language\\Group.g3:326:6: => ( '\\r' )? '\\n'
+					{
+
+					// Language\\Group.g3:326:21: ( '\\r' )?
+					int alt8=2;
+					int LA8_0 = input.LA(1);
+
+					if ( (LA8_0=='\r') )
+					{
+						alt8=1;
+					}
+					switch ( alt8 )
+					{
+					case 1:
+						// Language\\Group.g3:326:22: '\\r'
+						{
+						Match('\r'); if (state.failed) return ;
+						if ( state.backtracking == 0 )
+						{
+							 builder.Append('\r');
+						}
+
+						}
+						break;
+
+					}
+
+					Match('\n'); if (state.failed) return ;
+					if ( state.backtracking == 0 )
+					{
+						 builder.Append('\n');
+					}
+
+					}
+					break;
+				case 4:
+					// Language\\Group.g3:327:6: => '\\\\>'
+					{
+
+					Match("\\>"); if (state.failed) return ;
+
+					if ( state.backtracking == 0 )
+					{
+						 builder.Append('>');
+					}
+
+					}
+					break;
+				case 5:
+					// Language\\Group.g3:328:6: =>ch= .
+					{
+
+					ch = input.LA(1);
+					MatchAny(); if (state.failed) return ;
+					if ( state.backtracking == 0 )
+					{
+						 builder.Append((char)ch);
+					}
+
+					}
+					break;
+
+				default:
+					goto loop9;
+				}
+			}
+
+			loop9:
+				;
+
+
+			// Language\\Group.g3:330:4: ( '>>' )?
+			int alt10=2;
+			int LA10_0 = input.LA(1);
+
+			if ( (LA10_0=='>') )
+			{
+				alt10=1;
+			}
+			switch ( alt10 )
+			{
+			case 1:
+				// Language\\Group.g3:330:6: '>>'
+				{
+				Match(">>"); if (state.failed) return ;
+
+				if ( state.backtracking == 0 )
+				{
+					 InBigString = false;
+				}
+
+				}
+				break;
+
+			}
+
+
+			}
+
+			if ( state.backtracking == 0 )
+			{
+
+							Text = builder.ToString();
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "BIGSTRING"
+
+	// $ANTLR start "ANONYMOUS_TEMPLATE"
+	private void mANONYMOUS_TEMPLATE()
+	{
+		try
+		{
+			int _type = ANONYMOUS_TEMPLATE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			int ch;
+
+
+				System.Text.StringBuilder builder = new System.Text.StringBuilder();
+
+			// Language\\Group.g3:344:4: ( ( '{' ( ( '\\r' )? '\\n' |=> '\\\\' '}' |ch=~ ( '\\r' | '\\n' | '}' ) )* ( '}' )? ) )
+			// Language\\Group.g3:344:4: ( '{' ( ( '\\r' )? '\\n' |=> '\\\\' '}' |ch=~ ( '\\r' | '\\n' | '}' ) )* ( '}' )? )
+			{
+			// Language\\Group.g3:344:4: ( '{' ( ( '\\r' )? '\\n' |=> '\\\\' '}' |ch=~ ( '\\r' | '\\n' | '}' ) )* ( '}' )? )
+			// Language\\Group.g3:344:6: '{' ( ( '\\r' )? '\\n' |=> '\\\\' '}' |ch=~ ( '\\r' | '\\n' | '}' ) )* ( '}' )?
+			{
+			Match('{'); if (state.failed) return ;
+			if ( state.backtracking == 0 )
+			{
+
+								if ( !InBigString && !InBlockComment )
+									InAnonymousTemplate=true;
+
+			}
+			// Language\\Group.g3:349:4: ( ( '\\r' )? '\\n' |=> '\\\\' '}' |ch=~ ( '\\r' | '\\n' | '}' ) )*
+			for ( ; ; )
+			{
+				int alt12=4;
+				int LA12_0 = input.LA(1);
+
+				if ( (LA12_0=='\n'||LA12_0=='\r') )
+				{
+					alt12=1;
+				}
+				else if ( (LA12_0=='\\') )
+				{
+					int LA12_3 = input.LA(2);
+
+					if ( (LA12_3=='}') )
+					{
+						int LA12_5 = input.LA(3);
+
+						if ( (synpred7_Group()) )
+						{
+							alt12=2;
+						}
+						else if ( (true) )
+						{
+							alt12=3;
+						}
+
+
+					}
+
+					else
+					{
+						alt12=3;
+					}
+
+				}
+				else if ( ((LA12_0>='\u0000' && LA12_0<='\t')||(LA12_0>='\u000B' && LA12_0<='\f')||(LA12_0>='\u000E' && LA12_0<='[')||(LA12_0>=']' && LA12_0<='|')||(LA12_0>='~' && LA12_0<='\uFFFF')) )
+				{
+					alt12=3;
+				}
+
+
+				switch ( alt12 )
+				{
+				case 1:
+					// Language\\Group.g3:349:6: ( '\\r' )? '\\n'
+					{
+					// Language\\Group.g3:349:6: ( '\\r' )?
+					int alt11=2;
+					int LA11_0 = input.LA(1);
+
+					if ( (LA11_0=='\r') )
+					{
+						alt11=1;
+					}
+					switch ( alt11 )
+					{
+					case 1:
+						// Language\\Group.g3:349:7: '\\r'
+						{
+						Match('\r'); if (state.failed) return ;
+						if ( state.backtracking == 0 )
+						{
+							 builder.Append('\r');
+						}
+
+						}
+						break;
+
+					}
+
+					Match('\n'); if (state.failed) return ;
+					if ( state.backtracking == 0 )
+					{
+						 builder.Append('\n');
+					}
+
+					}
+					break;
+				case 2:
+					// Language\\Group.g3:350:6: => '\\\\' '}'
+					{
+
+					Match('\\'); if (state.failed) return ;
+					Match('}'); if (state.failed) return ;
+					if ( state.backtracking == 0 )
+					{
+						 builder.Append('}');
+					}
+
+					}
+					break;
+				case 3:
+					// Language\\Group.g3:351:6: ch=~ ( '\\r' | '\\n' | '}' )
+					{
+					ch= input.LA(1);
+					input.Consume();
+					state.failed=false;
+					if ( state.backtracking == 0 )
+					{
+						 builder.Append((char)ch);
+					}
+
+					}
+					break;
+
+				default:
+					goto loop12;
+				}
+			}
+
+			loop12:
+				;
+
+
+			// Language\\Group.g3:353:4: ( '}' )?
+			int alt13=2;
+			int LA13_0 = input.LA(1);
+
+			if ( (LA13_0=='}') )
+			{
+				alt13=1;
+			}
+			switch ( alt13 )
+			{
+			case 1:
+				// Language\\Group.g3:353:6: '}'
+				{
+				Match('}'); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+					 InAnonymousTemplate = false;
+				}
+
+				}
+				break;
+
+			}
+
+
+			}
+
+			if ( state.backtracking == 0 )
+			{
+
+							Text = builder.ToString();
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ANONYMOUS_TEMPLATE"
+
+	// $ANTLR start "AT"
+	private void mAT()
+	{
+		try
+		{
+			int _type = AT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Group.g3:363:6: ( '@' )
+			// Language\\Group.g3:363:6: '@'
+			{
+			Match('@'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "AT"
+
+	// $ANTLR start "LPAREN"
+	private void mLPAREN()
+	{
+		try
+		{
+			int _type = LPAREN;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Group.g3:364:9: ( '(' )
+			// Language\\Group.g3:364:9: '('
+			{
+			Match('('); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "LPAREN"
+
+	// $ANTLR start "RPAREN"
+	private void mRPAREN()
+	{
+		try
+		{
+			int _type = RPAREN;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Group.g3:365:9: ( ')' )
+			// Language\\Group.g3:365:9: ')'
+			{
+			Match(')'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "RPAREN"
+
+	// $ANTLR start "LBRACK"
+	private void mLBRACK()
+	{
+		try
+		{
+			int _type = LBRACK;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Group.g3:366:9: ( '[' )
+			// Language\\Group.g3:366:9: '['
+			{
+			Match('['); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "LBRACK"
+
+	// $ANTLR start "RBRACK"
+	private void mRBRACK()
+	{
+		try
+		{
+			int _type = RBRACK;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Group.g3:367:9: ( ']' )
+			// Language\\Group.g3:367:9: ']'
+			{
+			Match(']'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "RBRACK"
+
+	// $ANTLR start "COMMA"
+	private void mCOMMA()
+	{
+		try
+		{
+			int _type = COMMA;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Group.g3:368:9: ( ',' )
+			// Language\\Group.g3:368:9: ','
+			{
+			Match(','); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "COMMA"
+
+	// $ANTLR start "DOT"
+	private void mDOT()
+	{
+		try
+		{
+			int _type = DOT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Group.g3:369:7: ( '.' )
+			// Language\\Group.g3:369:7: '.'
+			{
+			Match('.'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "DOT"
+
+	// $ANTLR start "DEFINED_TO_BE"
+	private void mDEFINED_TO_BE()
+	{
+		try
+		{
+			int _type = DEFINED_TO_BE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Group.g3:370:17: ( '::=' )
+			// Language\\Group.g3:370:17: '::='
+			{
+			Match("::="); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "DEFINED_TO_BE"
+
+	// $ANTLR start "SEMI"
+	private void mSEMI()
+	{
+		try
+		{
+			int _type = SEMI;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Group.g3:371:9: ( ';' )
+			// Language\\Group.g3:371:9: ';'
+			{
+			Match(';'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "SEMI"
+
+	// $ANTLR start "COLON"
+	private void mCOLON()
+	{
+		try
+		{
+			int _type = COLON;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Group.g3:372:9: ( ':' )
+			// Language\\Group.g3:372:9: ':'
+			{
+			Match(':'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "COLON"
+
+	// $ANTLR start "STAR"
+	private void mSTAR()
+	{
+		try
+		{
+			int _type = STAR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Group.g3:373:9: ( '*' )
+			// Language\\Group.g3:373:9: '*'
+			{
+			Match('*'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "STAR"
+
+	// $ANTLR start "PLUS"
+	private void mPLUS()
+	{
+		try
+		{
+			int _type = PLUS;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Group.g3:374:9: ( '+' )
+			// Language\\Group.g3:374:9: '+'
+			{
+			Match('+'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "PLUS"
+
+	// $ANTLR start "ASSIGN"
+	private void mASSIGN()
+	{
+		try
+		{
+			int _type = ASSIGN;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Group.g3:375:11: ( '=' )
+			// Language\\Group.g3:375:11: '='
+			{
+			Match('='); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ASSIGN"
+
+	// $ANTLR start "OPTIONAL"
+	private void mOPTIONAL()
+	{
+		try
+		{
+			int _type = OPTIONAL;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Group.g3:376:12: ( '?' )
+			// Language\\Group.g3:376:12: '?'
+			{
+			Match('?'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "OPTIONAL"
+
+	// $ANTLR start "CLOSE_BIG_STRING"
+	private void mCLOSE_BIG_STRING()
+	{
+		try
+		{
+			int _type = CLOSE_BIG_STRING;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Group.g3:378:20: ( '>>' )
+			// Language\\Group.g3:378:20: '>>'
+			{
+			Match(">>"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "CLOSE_BIG_STRING"
+
+	// $ANTLR start "CLOSE_BLOCK_COMMENT"
+	private void mCLOSE_BLOCK_COMMENT()
+	{
+		try
+		{
+			int _type = CLOSE_BLOCK_COMMENT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Group.g3:379:23: ( '*/' )
+			// Language\\Group.g3:379:23: '*/'
+			{
+			Match("*/"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "CLOSE_BLOCK_COMMENT"
+
+	// $ANTLR start "CLOSE_ANON_TEMPLATE"
+	private void mCLOSE_ANON_TEMPLATE()
+	{
+		try
+		{
+			int _type = CLOSE_ANON_TEMPLATE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Group.g3:380:23: ( '}' )
+			// Language\\Group.g3:380:23: '}'
+			{
+			Match('}'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "CLOSE_ANON_TEMPLATE"
+
+	// $ANTLR start "SL_COMMENT"
+	private void mSL_COMMENT()
+	{
+		try
+		{
+			int _type = SL_COMMENT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Group.g3:384:4: ( '//' (~ ( '\\n' | '\\r' ) )* ( ( '\\r' )? '\\n' )? )
+			// Language\\Group.g3:384:4: '//' (~ ( '\\n' | '\\r' ) )* ( ( '\\r' )? '\\n' )?
+			{
+			Match("//"); if (state.failed) return ;
+
+			// Language\\Group.g3:385:3: (~ ( '\\n' | '\\r' ) )*
+			for ( ; ; )
+			{
+				int alt14=2;
+				int LA14_0 = input.LA(1);
+
+				if ( ((LA14_0>='\u0000' && LA14_0<='\t')||(LA14_0>='\u000B' && LA14_0<='\f')||(LA14_0>='\u000E' && LA14_0<='\uFFFF')) )
+				{
+					alt14=1;
+				}
+
+
+				switch ( alt14 )
+				{
+				case 1:
+					// Language\\Group.g3:
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+
+				default:
+					goto loop14;
+				}
+			}
+
+			loop14:
+				;
+
+
+			// Language\\Group.g3:385:19: ( ( '\\r' )? '\\n' )?
+			int alt16=2;
+			int LA16_0 = input.LA(1);
+
+			if ( (LA16_0=='\n'||LA16_0=='\r') )
+			{
+				alt16=1;
+			}
+			switch ( alt16 )
+			{
+			case 1:
+				// Language\\Group.g3:385:20: ( '\\r' )? '\\n'
+				{
+				// Language\\Group.g3:385:20: ( '\\r' )?
+				int alt15=2;
+				int LA15_0 = input.LA(1);
+
+				if ( (LA15_0=='\r') )
+				{
+					alt15=1;
+				}
+				switch ( alt15 )
+				{
+				case 1:
+					// Language\\Group.g3:385:21: '\\r'
+					{
+					Match('\r'); if (state.failed) return ;
+
+					}
+					break;
+
+				}
+
+				Match('\n'); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+			if ( state.backtracking == 0 )
+			{
+				 _channel = HIDDEN;
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "SL_COMMENT"
+
+	// $ANTLR start "ML_COMMENT"
+	private void mML_COMMENT()
+	{
+		try
+		{
+			int _type = ML_COMMENT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Group.g3:391:4: ( '/*' (~ ( '*' ) |=> '*' )* ( '*/' )? )
+			// Language\\Group.g3:391:4: '/*' (~ ( '*' ) |=> '*' )* ( '*/' )?
+			{
+			Match("/*"); if (state.failed) return ;
+
+			if ( state.backtracking == 0 )
+			{
+
+							if ( !InAnonymousTemplate && !InBigString )
+								InBlockComment=true;
+
+							_channel = HIDDEN;
+
+			}
+			// Language\\Group.g3:398:3: (~ ( '*' ) |=> '*' )*
+			for ( ; ; )
+			{
+				int alt17=3;
+				int LA17_0 = input.LA(1);
+
+				if ( (LA17_0=='*') )
+				{
+					int LA17_1 = input.LA(2);
+
+					if ( (LA17_1=='/') )
+					{
+						int LA17_4 = input.LA(3);
+
+						if ( (synpred8_Group()) )
+						{
+							alt17=2;
+						}
+
+
+					}
+					else if ( (LA17_1=='*') && (synpred8_Group()))
+					{
+						alt17=2;
+					}
+					else if ( ((LA17_1>='\u0000' && LA17_1<=')')||(LA17_1>='+' && LA17_1<='.')||(LA17_1>='0' && LA17_1<='\uFFFF')) && (synpred8_Group()))
+					{
+						alt17=2;
+					}
+
+					else
+					{
+						alt17=2;
+					}
+
+				}
+				else if ( ((LA17_0>='\u0000' && LA17_0<=')')||(LA17_0>='+' && LA17_0<='\uFFFF')) )
+				{
+					alt17=1;
+				}
+
+
+				switch ( alt17 )
+				{
+				case 1:
+					// Language\\Group.g3:398:5: ~ ( '*' )
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+				case 2:
+					// Language\\Group.g3:399:6: => '*'
+					{
+
+					Match('*'); if (state.failed) return ;
+
+					}
+					break;
+
+				default:
+					goto loop17;
+				}
+			}
+
+			loop17:
+				;
+
+
+			// Language\\Group.g3:401:3: ( '*/' )?
+			int alt18=2;
+			int LA18_0 = input.LA(1);
+
+			if ( (LA18_0=='*') )
+			{
+				alt18=1;
+			}
+			switch ( alt18 )
+			{
+			case 1:
+				// Language\\Group.g3:401:4: '*/'
+				{
+				Match("*/"); if (state.failed) return ;
+
+				if ( state.backtracking == 0 )
+				{
+					InBlockComment = false;
+				}
+
+				}
+				break;
+
+			}
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ML_COMMENT"
+
+	// $ANTLR start "WS"
+	private void mWS()
+	{
+		try
+		{
+			int _type = WS;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Group.g3:405:9: ( ( ' ' | '\\t' | '\\f' | ( '\\r' )? '\\n' )+ )
+			// Language\\Group.g3:405:9: ( ' ' | '\\t' | '\\f' | ( '\\r' )? '\\n' )+
+			{
+			// Language\\Group.g3:405:9: ( ' ' | '\\t' | '\\f' | ( '\\r' )? '\\n' )+
+			int cnt20=0;
+			for ( ; ; )
+			{
+				int alt20=5;
+				switch ( input.LA(1) )
+				{
+				case ' ':
+					{
+					alt20=1;
+					}
+					break;
+				case '\t':
+					{
+					alt20=2;
+					}
+					break;
+				case '\f':
+					{
+					alt20=3;
+					}
+					break;
+				case '\n':
+				case '\r':
+					{
+					alt20=4;
+					}
+					break;
+
+				}
+
+				switch ( alt20 )
+				{
+				case 1:
+					// Language\\Group.g3:405:13: ' '
+					{
+					Match(' '); if (state.failed) return ;
+
+					}
+					break;
+				case 2:
+					// Language\\Group.g3:406:13: '\\t'
+					{
+					Match('\t'); if (state.failed) return ;
+
+					}
+					break;
+				case 3:
+					// Language\\Group.g3:407:13: '\\f'
+					{
+					Match('\f'); if (state.failed) return ;
+
+					}
+					break;
+				case 4:
+					// Language\\Group.g3:408:13: ( '\\r' )? '\\n'
+					{
+					// Language\\Group.g3:408:13: ( '\\r' )?
+					int alt19=2;
+					int LA19_0 = input.LA(1);
+
+					if ( (LA19_0=='\r') )
+					{
+						alt19=1;
+					}
+					switch ( alt19 )
+					{
+					case 1:
+						// Language\\Group.g3:408:14: '\\r'
+						{
+						Match('\r'); if (state.failed) return ;
+
+						}
+						break;
+
+					}
+
+					Match('\n'); if (state.failed) return ;
+
+					}
+					break;
+
+				default:
+					if ( cnt20 >= 1 )
+						goto loop20;
+
+					if (state.backtracking>0) {state.failed=true; return ;}
+					EarlyExitException eee20 = new EarlyExitException( 20, input );
+					throw eee20;
+				}
+				cnt20++;
+			}
+			loop20:
+				;
+
+
+			if ( state.backtracking == 0 )
+			{
+				 _channel = HIDDEN;
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "WS"
+
+	// $ANTLR start "ANYCHAR"
+	private void mANYCHAR()
+	{
+		try
+		{
+			int _type = ANYCHAR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Group.g3:414:4: ( . )
+			// Language\\Group.g3:414:4: .
+			{
+			MatchAny(); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ANYCHAR"
+
+	public override void mTokens()
+	{
+		// Language\\Group.g3:1:10: ( KWDEFAULT | KWGROUP | KWIMPLEMENTS | ID | STRING | BIGSTRING | ANONYMOUS_TEMPLATE | AT | LPAREN | RPAREN | LBRACK | RBRACK | COMMA | DOT | DEFINED_TO_BE | SEMI | COLON | STAR | PLUS | ASSIGN | OPTIONAL | CLOSE_BIG_STRING | CLOSE_BLOCK_COMMENT | CLOSE_ANON_TEMPLATE | SL_COMMENT | ML_COMMENT | WS | ANYCHAR )
+		int alt21=28;
+		alt21 = dfa21.Predict(input);
+		switch ( alt21 )
+		{
+		case 1:
+			// Language\\Group.g3:1:10: KWDEFAULT
+			{
+			mKWDEFAULT(); if (state.failed) return ;
+
+			}
+			break;
+		case 2:
+			// Language\\Group.g3:1:20: KWGROUP
+			{
+			mKWGROUP(); if (state.failed) return ;
+
+			}
+			break;
+		case 3:
+			// Language\\Group.g3:1:28: KWIMPLEMENTS
+			{
+			mKWIMPLEMENTS(); if (state.failed) return ;
+
+			}
+			break;
+		case 4:
+			// Language\\Group.g3:1:41: ID
+			{
+			mID(); if (state.failed) return ;
+
+			}
+			break;
+		case 5:
+			// Language\\Group.g3:1:44: STRING
+			{
+			mSTRING(); if (state.failed) return ;
+
+			}
+			break;
+		case 6:
+			// Language\\Group.g3:1:51: BIGSTRING
+			{
+			mBIGSTRING(); if (state.failed) return ;
+
+			}
+			break;
+		case 7:
+			// Language\\Group.g3:1:61: ANONYMOUS_TEMPLATE
+			{
+			mANONYMOUS_TEMPLATE(); if (state.failed) return ;
+
+			}
+			break;
+		case 8:
+			// Language\\Group.g3:1:80: AT
+			{
+			mAT(); if (state.failed) return ;
+
+			}
+			break;
+		case 9:
+			// Language\\Group.g3:1:83: LPAREN
+			{
+			mLPAREN(); if (state.failed) return ;
+
+			}
+			break;
+		case 10:
+			// Language\\Group.g3:1:90: RPAREN
+			{
+			mRPAREN(); if (state.failed) return ;
+
+			}
+			break;
+		case 11:
+			// Language\\Group.g3:1:97: LBRACK
+			{
+			mLBRACK(); if (state.failed) return ;
+
+			}
+			break;
+		case 12:
+			// Language\\Group.g3:1:104: RBRACK
+			{
+			mRBRACK(); if (state.failed) return ;
+
+			}
+			break;
+		case 13:
+			// Language\\Group.g3:1:111: COMMA
+			{
+			mCOMMA(); if (state.failed) return ;
+
+			}
+			break;
+		case 14:
+			// Language\\Group.g3:1:117: DOT
+			{
+			mDOT(); if (state.failed) return ;
+
+			}
+			break;
+		case 15:
+			// Language\\Group.g3:1:121: DEFINED_TO_BE
+			{
+			mDEFINED_TO_BE(); if (state.failed) return ;
+
+			}
+			break;
+		case 16:
+			// Language\\Group.g3:1:135: SEMI
+			{
+			mSEMI(); if (state.failed) return ;
+
+			}
+			break;
+		case 17:
+			// Language\\Group.g3:1:140: COLON
+			{
+			mCOLON(); if (state.failed) return ;
+
+			}
+			break;
+		case 18:
+			// Language\\Group.g3:1:146: STAR
+			{
+			mSTAR(); if (state.failed) return ;
+
+			}
+			break;
+		case 19:
+			// Language\\Group.g3:1:151: PLUS
+			{
+			mPLUS(); if (state.failed) return ;
+
+			}
+			break;
+		case 20:
+			// Language\\Group.g3:1:156: ASSIGN
+			{
+			mASSIGN(); if (state.failed) return ;
+
+			}
+			break;
+		case 21:
+			// Language\\Group.g3:1:163: OPTIONAL
+			{
+			mOPTIONAL(); if (state.failed) return ;
+
+			}
+			break;
+		case 22:
+			// Language\\Group.g3:1:172: CLOSE_BIG_STRING
+			{
+			mCLOSE_BIG_STRING(); if (state.failed) return ;
+
+			}
+			break;
+		case 23:
+			// Language\\Group.g3:1:189: CLOSE_BLOCK_COMMENT
+			{
+			mCLOSE_BLOCK_COMMENT(); if (state.failed) return ;
+
+			}
+			break;
+		case 24:
+			// Language\\Group.g3:1:209: CLOSE_ANON_TEMPLATE
+			{
+			mCLOSE_ANON_TEMPLATE(); if (state.failed) return ;
+
+			}
+			break;
+		case 25:
+			// Language\\Group.g3:1:229: SL_COMMENT
+			{
+			mSL_COMMENT(); if (state.failed) return ;
+
+			}
+			break;
+		case 26:
+			// Language\\Group.g3:1:240: ML_COMMENT
+			{
+			mML_COMMENT(); if (state.failed) return ;
+
+			}
+			break;
+		case 27:
+			// Language\\Group.g3:1:251: WS
+			{
+			mWS(); if (state.failed) return ;
+
+			}
+			break;
+		case 28:
+			// Language\\Group.g3:1:254: ANYCHAR
+			{
+			mANYCHAR(); if (state.failed) return ;
+
+			}
+			break;
+
+		}
+
+	}
+
+	// $ANTLR start synpred1_Group
+	public void synpred1_Group_fragment()
+	{
+		// Language\\Group.g3:323:6: ( '\\r' | '\\n' )
+		// Language\\Group.g3:
+		{
+		if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
+		{
+			input.Consume();
+		state.failed=false;
+		}
+		else
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			MismatchedSetException mse = new MismatchedSetException(null,input);
+			Recover(mse);
+			throw mse;}
+
+
+		}
+	}
+	// $ANTLR end synpred1_Group
+
+	// $ANTLR start synpred2_Group
+	public void synpred2_Group_fragment()
+	{
+		// Language\\Group.g3:324:6: ( '\\r\\n>>' )
+		// Language\\Group.g3:324:7: '\\r\\n>>'
+		{
+		Match("\r\n>>"); if (state.failed) return ;
+
+
+		}
+	}
+	// $ANTLR end synpred2_Group
+
+	// $ANTLR start synpred3_Group
+	public void synpred3_Group_fragment()
+	{
+		// Language\\Group.g3:325:6: ( '\\n>>' )
+		// Language\\Group.g3:325:7: '\\n>>'
+		{
+		Match("\n>>"); if (state.failed) return ;
+
+
+		}
+	}
+	// $ANTLR end synpred3_Group
+
+	// $ANTLR start synpred4_Group
+	public void synpred4_Group_fragment()
+	{
+		// Language\\Group.g3:326:6: ( '\\r' | '\\n' )
+		// Language\\Group.g3:
+		{
+		if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
+		{
+			input.Consume();
+		state.failed=false;
+		}
+		else
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			MismatchedSetException mse = new MismatchedSetException(null,input);
+			Recover(mse);
+			throw mse;}
+
+
+		}
+	}
+	// $ANTLR end synpred4_Group
+
+	// $ANTLR start synpred5_Group
+	public void synpred5_Group_fragment()
+	{
+		// Language\\Group.g3:327:6: ( '\\\\>' )
+		// Language\\Group.g3:327:7: '\\\\>'
+		{
+		Match("\\>"); if (state.failed) return ;
+
+
+		}
+	}
+	// $ANTLR end synpred5_Group
+
+	// $ANTLR start synpred6_Group
+	public void synpred6_Group_fragment()
+	{
+		// Language\\Group.g3:328:6: ( '>' ~ '>' |~ '>' )
+		int alt22=2;
+		int LA22_0 = input.LA(1);
+
+		if ( (LA22_0=='>') )
+		{
+			alt22=1;
+		}
+		else if ( ((LA22_0>='\u0000' && LA22_0<='=')||(LA22_0>='?' && LA22_0<='\uFFFF')) )
+		{
+			alt22=2;
+		}
+		else
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			NoViableAltException nvae = new NoViableAltException("", 22, 0, input);
+
+			throw nvae;
+		}
+		switch ( alt22 )
+		{
+		case 1:
+			// Language\\Group.g3:328:7: '>' ~ '>'
+			{
+			Match('>'); if (state.failed) return ;
+			if ( (input.LA(1)>='\u0000' && input.LA(1)<='=')||(input.LA(1)>='?' && input.LA(1)<='\uFFFF') )
+			{
+				input.Consume();
+			state.failed=false;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				Recover(mse);
+				throw mse;}
+
+
+			}
+			break;
+		case 2:
+			// Language\\Group.g3:328:18: ~ '>'
+			{
+			if ( (input.LA(1)>='\u0000' && input.LA(1)<='=')||(input.LA(1)>='?' && input.LA(1)<='\uFFFF') )
+			{
+				input.Consume();
+			state.failed=false;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				Recover(mse);
+				throw mse;}
+
+
+			}
+			break;
+
+		}}
+	// $ANTLR end synpred6_Group
+
+	// $ANTLR start synpred7_Group
+	public void synpred7_Group_fragment()
+	{
+		// Language\\Group.g3:350:6: ( '\\\\}' )
+		// Language\\Group.g3:350:7: '\\\\}'
+		{
+		Match("\\}"); if (state.failed) return ;
+
+
+		}
+	}
+	// $ANTLR end synpred7_Group
+
+	// $ANTLR start synpred8_Group
+	public void synpred8_Group_fragment()
+	{
+		// Language\\Group.g3:399:6: ( '*' ~ '/' )
+		// Language\\Group.g3:399:7: '*' ~ '/'
+		{
+		Match('*'); if (state.failed) return ;
+		if ( (input.LA(1)>='\u0000' && input.LA(1)<='.')||(input.LA(1)>='0' && input.LA(1)<='\uFFFF') )
+		{
+			input.Consume();
+		state.failed=false;
+		}
+		else
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			MismatchedSetException mse = new MismatchedSetException(null,input);
+			Recover(mse);
+			throw mse;}
+
+
+		}
+	}
+	// $ANTLR end synpred8_Group
+
+	public bool synpred1_Group()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred1_Group_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred4_Group()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred4_Group_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred6_Group()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred6_Group_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred3_Group()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred3_Group_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred5_Group()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred5_Group_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred2_Group()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred2_Group_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred7_Group()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred7_Group_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred8_Group()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred8_Group_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+
+
+	#region DFA
+	DFA9 dfa9;
+	DFA21 dfa21;
+
+	protected override void InitDFAs()
+	{
+		base.InitDFAs();
+		dfa9 = new DFA9( this, new SpecialStateTransitionHandler( specialStateTransition9 ) );
+		dfa21 = new DFA21( this, new SpecialStateTransitionHandler( specialStateTransition21 ) );
+	}
+
+	class DFA9 : DFA
+	{
+
+		const string DFA9_eotS =
+			"\x1\x2\x1\x8\x3\xFFFF\x1\x8\xB\xFFFF";
+		const string DFA9_eofS =
+			"\x11\xFFFF";
+		const string DFA9_minS =
+			"\x2\x0\x1\xFFFF\x1\xA\x2\x0\x1\xFFFF\x1\x0\x7\xFFFF\x1\x0\x1\xFFFF";
+		const string DFA9_maxS =
+			"\x2\xFFFF\x1\xFFFF\x1\xA\x1\x0\x1\xFFFF\x1\xFFFF\x1\x0\x7\xFFFF\x1\x0"+
+			"\x1\xFFFF";
+		const string DFA9_acceptS =
+			"\x2\xFFFF\x1\x6\x3\xFFFF\x1\x5\x1\xFFFF\x4\x5\x1\x1\x1\x3\x1\x2\x1\xFFFF"+
+			"\x1\x4";
+		const string DFA9_specialS =
+			"\x1\x0\x1\x1\x1\xFFFF\x1\x2\x1\x3\x1\x4\x1\xFFFF\x1\x5\x7\xFFFF\x1\x6"+
+			"\x1\xFFFF}>";
+		static readonly string[] DFA9_transitionS =
+			{
+				"\xA\x6\x1\x4\x2\x6\x1\x3\x30\x6\x1\x1\x1D\x6\x1\x5\xFFA3\x6",
+				"\xA\x6\x1\xA\x2\x6\x1\x9\x30\x6\x1\x7\x1D\x6\x1\xB\xFFA3\x6",
+				"",
+				"\x1\xC",
+				"\x1\xFFFF",
+				"\xA\x6\x1\xA\x2\x6\x1\x9\x30\x6\x1\xF\x1D\x6\x1\xB\xFFA3\x6",
+				"",
+				"\x1\xFFFF",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"\x1\xFFFF",
+				""
+			};
+
+		static readonly short[] DFA9_eot = DFA.UnpackEncodedString(DFA9_eotS);
+		static readonly short[] DFA9_eof = DFA.UnpackEncodedString(DFA9_eofS);
+		static readonly char[] DFA9_min = DFA.UnpackEncodedStringToUnsignedChars(DFA9_minS);
+		static readonly char[] DFA9_max = DFA.UnpackEncodedStringToUnsignedChars(DFA9_maxS);
+		static readonly short[] DFA9_accept = DFA.UnpackEncodedString(DFA9_acceptS);
+		static readonly short[] DFA9_special = DFA.UnpackEncodedString(DFA9_specialS);
+		static readonly short[][] DFA9_transition;
+
+		static DFA9()
+		{
+			int numStates = DFA9_transitionS.Length;
+			DFA9_transition = new short[numStates][];
+			for ( int i=0; i < numStates; i++ )
+			{
+				DFA9_transition[i] = DFA.UnpackEncodedString(DFA9_transitionS[i]);
+			}
+		}
+
+		public DFA9( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
+			: base( specialStateTransition )	{
+			this.recognizer = recognizer;
+			this.decisionNumber = 9;
+			this.eot = DFA9_eot;
+			this.eof = DFA9_eof;
+			this.min = DFA9_min;
+			this.max = DFA9_max;
+			this.accept = DFA9_accept;
+			this.special = DFA9_special;
+			this.transition = DFA9_transition;
+		}
+		public override string GetDescription()
+		{
+			return "()* loopback of 324:4: (=> '\\r' '\\n' |=> '\\n' |=> ( '\\r' )? '\\n' |=> '\\\\>' |=>ch= . )*";
+		}
+	}
+
+	int specialStateTransition9( DFA dfa, int s, IIntStream _input )
+	{
+		IIntStream input = _input;
+		int _s = s;
+		switch ( s )
+		{
+
+			case 0:
+				int LA9_0 = input.LA(1);
+
+
+				int index9_0 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (LA9_0=='>') ) {s = 1;}
+
+				else if ( (LA9_0=='\r') ) {s = 3;}
+
+				else if ( (LA9_0=='\n') ) {s = 4;}
+
+				else if ( (LA9_0=='\\') ) {s = 5;}
+
+				else if ( ((LA9_0>='\u0000' && LA9_0<='\t')||(LA9_0>='\u000B' && LA9_0<='\f')||(LA9_0>='\u000E' && LA9_0<='=')||(LA9_0>='?' && LA9_0<='[')||(LA9_0>=']' && LA9_0<='\uFFFF')) && (synpred6_Group())) {s = 6;}
+
+				else s = 2;
+
+
+				input.Seek(index9_0);
+				if ( s>=0 ) return s;
+				break;
+
+			case 1:
+				int LA9_1 = input.LA(1);
+
+
+				int index9_1 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (LA9_1=='>') ) {s = 7;}
+
+				else if ( (LA9_1=='\r') && (synpred6_Group())) {s = 9;}
+
+				else if ( (LA9_1=='\n') && (synpred6_Group())) {s = 10;}
+
+				else if ( (LA9_1=='\\') && (synpred6_Group())) {s = 11;}
+
+				else if ( ((LA9_1>='\u0000' && LA9_1<='\t')||(LA9_1>='\u000B' && LA9_1<='\f')||(LA9_1>='\u000E' && LA9_1<='=')||(LA9_1>='?' && LA9_1<='[')||(LA9_1>=']' && LA9_1<='\uFFFF')) && (synpred6_Group())) {s = 6;}
+
+				else s = 8;
+
+
+				input.Seek(index9_1);
+				if ( s>=0 ) return s;
+				break;
+
+			case 2:
+				int LA9_3 = input.LA(1);
+
+
+				int index9_3 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (LA9_3=='\n') && (synpred2_Group())) {s = 12;}
+
+				else if ( (synpred4_Group()) ) {s = 13;}
+
+				else if ( (synpred6_Group()) ) {s = 11;}
+
+
+				input.Seek(index9_3);
+				if ( s>=0 ) return s;
+				break;
+
+			case 3:
+				int LA9_4 = input.LA(1);
+
+
+				int index9_4 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred3_Group()) ) {s = 14;}
+
+				else if ( (synpred4_Group()) ) {s = 13;}
+
+				else if ( (synpred6_Group()) ) {s = 11;}
+
+
+				input.Seek(index9_4);
+				if ( s>=0 ) return s;
+				break;
+
+			case 4:
+				int LA9_5 = input.LA(1);
+
+
+				int index9_5 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (LA9_5=='>') ) {s = 15;}
+
+				else if ( (LA9_5=='\r') && (synpred6_Group())) {s = 9;}
+
+				else if ( (LA9_5=='\n') && (synpred6_Group())) {s = 10;}
+
+				else if ( (LA9_5=='\\') && (synpred6_Group())) {s = 11;}
+
+				else if ( ((LA9_5>='\u0000' && LA9_5<='\t')||(LA9_5>='\u000B' && LA9_5<='\f')||(LA9_5>='\u000E' && LA9_5<='=')||(LA9_5>='?' && LA9_5<='[')||(LA9_5>=']' && LA9_5<='\uFFFF')) && (synpred6_Group())) {s = 6;}
+
+				else s = 8;
+
+
+				input.Seek(index9_5);
+				if ( s>=0 ) return s;
+				break;
+
+			case 5:
+				int LA9_7 = input.LA(1);
+
+
+				int index9_7 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred6_Group()) ) {s = 11;}
+
+				else if ( (true) ) {s = 2;}
+
+
+				input.Seek(index9_7);
+				if ( s>=0 ) return s;
+				break;
+
+			case 6:
+				int LA9_15 = input.LA(1);
+
+
+				int index9_15 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred5_Group()) ) {s = 16;}
+
+				else if ( (synpred6_Group()) ) {s = 11;}
+
+
+				input.Seek(index9_15);
+				if ( s>=0 ) return s;
+				break;
+		}
+		if (state.backtracking>0) {state.failed=true; return -1;}
+		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 9, _s, input);
+		dfa.Error(nvae);
+		throw nvae;
+	}
+	class DFA21 : DFA
+	{
+
+		const string DFA21_eotS =
+			"\x1\xFFFF\x3\x1F\x2\xFFFF\x1\x1D\x8\xFFFF\x1\x2D\x1\xFFFF\x1\x30\x3\xFFFF"+
+			"\x1\x1D\x1\xFFFF\x1\x1D\x3\xFFFF\x1\x1D\x2\xFFFF\x1\x1F\x1\xFFFF\x2\x1F"+
+			"\x17\xFFFF\x7\x1F\x1\x43\x2\x1F\x1\xFFFF\x1\x1F\x1\x47\x1\x1F\x1\xFFFF"+
+			"\x2\x1F\x1\x4B\x1\xFFFF";
+		const string DFA21_eofS =
+			"\x4C\xFFFF";
+		const string DFA21_minS =
+			"\x1\x0\x1\x65\x1\x72\x1\x6D\x2\xFFFF\x1\x3C\x8\xFFFF\x1\x3A\x1\xFFFF"+
+			"\x1\x2F\x3\xFFFF\x1\x3E\x1\xFFFF\x1\x2A\x3\xFFFF\x1\xA\x2\xFFFF\x1\x66"+
+			"\x1\xFFFF\x1\x6F\x1\x70\x17\xFFFF\x1\x61\x1\x75\x1\x6C\x1\x75\x1\x70"+
+			"\x1\x65\x1\x6C\x1\x2D\x1\x6D\x1\x74\x1\xFFFF\x1\x65\x1\x2D\x1\x6E\x1"+
+			"\xFFFF\x1\x74\x1\x73\x1\x2D\x1\xFFFF";
+		const string DFA21_maxS =
+			"\x1\xFFFF\x1\x65\x1\x72\x1\x6D\x2\xFFFF\x1\x3C\x8\xFFFF\x1\x3A\x1\xFFFF"+
+			"\x1\x2F\x3\xFFFF\x1\x3E\x1\xFFFF\x1\x2F\x3\xFFFF\x1\xA\x2\xFFFF\x1\x66"+
+			"\x1\xFFFF\x1\x6F\x1\x70\x17\xFFFF\x1\x61\x1\x75\x1\x6C\x1\x75\x1\x70"+
+			"\x1\x65\x1\x6C\x1\x7A\x1\x6D\x1\x74\x1\xFFFF\x1\x65\x1\x7A\x1\x6E\x1"+
+			"\xFFFF\x1\x74\x1\x73\x1\x7A\x1\xFFFF";
+		const string DFA21_acceptS =
+			"\x4\xFFFF\x1\x4\x1\x5\x1\xFFFF\x1\x7\x1\x8\x1\x9\x1\xA\x1\xB\x1\xC\x1"+
+			"\xD\x1\xE\x1\xFFFF\x1\x10\x1\xFFFF\x1\x13\x1\x14\x1\x15\x1\xFFFF\x1\x18"+
+			"\x1\xFFFF\x3\x1B\x1\xFFFF\x1\x1B\x1\x1C\x1\xFFFF\x1\x4\x2\xFFFF\x1\x5"+
+			"\x1\x6\x1\x7\x1\x8\x1\x9\x1\xA\x1\xB\x1\xC\x1\xD\x1\xE\x1\xF\x1\x11\x1"+
+			"\x10\x1\x17\x1\x12\x1\x13\x1\x14\x1\x15\x1\x16\x1\x18\x1\x19\x1\x1A\x1"+
+			"\x1B\xA\xFFFF\x1\x2\x3\xFFFF\x1\x1\x3\xFFFF\x1\x3";
+		const string DFA21_specialS =
+			"\x1\x0\x4B\xFFFF}>";
+		static readonly string[] DFA21_transitionS =
+			{
+				"\x9\x1D\x1\x19\x1\x1C\x1\x1D\x1\x1A\x1\x1B\x12\x1D\x1\x18\x1\x1D\x1"+
+				"\x5\x5\x1D\x1\x9\x1\xA\x1\x11\x1\x12\x1\xD\x1\x1D\x1\xE\x1\x17\xA\x1D"+
+				"\x1\xF\x1\x10\x1\x6\x1\x13\x1\x15\x1\x14\x1\x8\x1A\x4\x1\xB\x1\x1D\x1"+
+				"\xC\x1\x1D\x1\x4\x1\x1D\x3\x4\x1\x1\x2\x4\x1\x2\x1\x4\x1\x3\x11\x4\x1"+
+				"\x7\x1\x1D\x1\x16\xFF82\x1D",
+				"\x1\x1E",
+				"\x1\x20",
+				"\x1\x21",
+				"",
+				"",
+				"\x1\x23",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"\x1\x2C",
+				"",
+				"\x1\x2F",
+				"",
+				"",
+				"",
+				"\x1\x34",
+				"",
+				"\x1\x37\x4\xFFFF\x1\x36",
+				"",
+				"",
+				"",
+				"\x1\x38",
+				"",
+				"",
+				"\x1\x39",
+				"",
+				"\x1\x3A",
+				"\x1\x3B",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"\x1\x3C",
+				"\x1\x3D",
+				"\x1\x3E",
+				"\x1\x3F",
+				"\x1\x40",
+				"\x1\x41",
+				"\x1\x42",
+				"\x1\x1F\x2\xFFFF\xA\x1F\x7\xFFFF\x1A\x1F\x4\xFFFF\x1\x1F\x1\xFFFF\x1A"+
+				"\x1F",
+				"\x1\x44",
+				"\x1\x45",
+				"",
+				"\x1\x46",
+				"\x1\x1F\x2\xFFFF\xA\x1F\x7\xFFFF\x1A\x1F\x4\xFFFF\x1\x1F\x1\xFFFF\x1A"+
+				"\x1F",
+				"\x1\x48",
+				"",
+				"\x1\x49",
+				"\x1\x4A",
+				"\x1\x1F\x2\xFFFF\xA\x1F\x7\xFFFF\x1A\x1F\x4\xFFFF\x1\x1F\x1\xFFFF\x1A"+
+				"\x1F",
+				""
+			};
+
+		static readonly short[] DFA21_eot = DFA.UnpackEncodedString(DFA21_eotS);
+		static readonly short[] DFA21_eof = DFA.UnpackEncodedString(DFA21_eofS);
+		static readonly char[] DFA21_min = DFA.UnpackEncodedStringToUnsignedChars(DFA21_minS);
+		static readonly char[] DFA21_max = DFA.UnpackEncodedStringToUnsignedChars(DFA21_maxS);
+		static readonly short[] DFA21_accept = DFA.UnpackEncodedString(DFA21_acceptS);
+		static readonly short[] DFA21_special = DFA.UnpackEncodedString(DFA21_specialS);
+		static readonly short[][] DFA21_transition;
+
+		static DFA21()
+		{
+			int numStates = DFA21_transitionS.Length;
+			DFA21_transition = new short[numStates][];
+			for ( int i=0; i < numStates; i++ )
+			{
+				DFA21_transition[i] = DFA.UnpackEncodedString(DFA21_transitionS[i]);
+			}
+		}
+
+		public DFA21( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
+			: base( specialStateTransition )	{
+			this.recognizer = recognizer;
+			this.decisionNumber = 21;
+			this.eot = DFA21_eot;
+			this.eof = DFA21_eof;
+			this.min = DFA21_min;
+			this.max = DFA21_max;
+			this.accept = DFA21_accept;
+			this.special = DFA21_special;
+			this.transition = DFA21_transition;
+		}
+		public override string GetDescription()
+		{
+			return "1:0: Tokens : ( KWDEFAULT | KWGROUP | KWIMPLEMENTS | ID | STRING | BIGSTRING | ANONYMOUS_TEMPLATE | AT | LPAREN | RPAREN | LBRACK | RBRACK | COMMA | DOT | DEFINED_TO_BE | SEMI | COLON | STAR | PLUS | ASSIGN | OPTIONAL | CLOSE_BIG_STRING | CLOSE_BLOCK_COMMENT | CLOSE_ANON_TEMPLATE | SL_COMMENT | ML_COMMENT | WS | ANYCHAR );";
+		}
+	}
+
+	int specialStateTransition21( DFA dfa, int s, IIntStream _input )
+	{
+		IIntStream input = _input;
+		int _s = s;
+		switch ( s )
+		{
+
+			case 0:
+				int LA21_0 = input.LA(1);
+
+				s = -1;
+				if ( (LA21_0=='d') ) {s = 1;}
+
+				else if ( (LA21_0=='g') ) {s = 2;}
+
+				else if ( (LA21_0=='i') ) {s = 3;}
+
+				else if ( ((LA21_0>='A' && LA21_0<='Z')||LA21_0=='_'||(LA21_0>='a' && LA21_0<='c')||(LA21_0>='e' && LA21_0<='f')||LA21_0=='h'||(LA21_0>='j' && LA21_0<='z')) ) {s = 4;}
+
+				else if ( (LA21_0=='\"') ) {s = 5;}
+
+				else if ( (LA21_0=='<') ) {s = 6;}
+
+				else if ( (LA21_0=='{') ) {s = 7;}
+
+				else if ( (LA21_0=='@') ) {s = 8;}
+
+				else if ( (LA21_0=='(') ) {s = 9;}
+
+				else if ( (LA21_0==')') ) {s = 10;}
+
+				else if ( (LA21_0=='[') ) {s = 11;}
+
+				else if ( (LA21_0==']') ) {s = 12;}
+
+				else if ( (LA21_0==',') ) {s = 13;}
+
+				else if ( (LA21_0=='.') ) {s = 14;}
+
+				else if ( (LA21_0==':') ) {s = 15;}
+
+				else if ( (LA21_0==';') ) {s = 16;}
+
+				else if ( (LA21_0=='*') ) {s = 17;}
+
+				else if ( (LA21_0=='+') ) {s = 18;}
+
+				else if ( (LA21_0=='=') ) {s = 19;}
+
+				else if ( (LA21_0=='?') ) {s = 20;}
+
+				else if ( (LA21_0=='>') ) {s = 21;}
+
+				else if ( (LA21_0=='}') ) {s = 22;}
+
+				else if ( (LA21_0=='/') ) {s = 23;}
+
+				else if ( (LA21_0==' ') ) {s = 24;}
+
+				else if ( (LA21_0=='\t') ) {s = 25;}
+
+				else if ( (LA21_0=='\f') ) {s = 26;}
+
+				else if ( (LA21_0=='\r') ) {s = 27;}
+
+				else if ( (LA21_0=='\n') ) {s = 28;}
+
+				else if ( ((LA21_0>='\u0000' && LA21_0<='\b')||LA21_0=='\u000B'||(LA21_0>='\u000E' && LA21_0<='\u001F')||LA21_0=='!'||(LA21_0>='#' && LA21_0<='\'')||LA21_0=='-'||(LA21_0>='0' && LA21_0<='9')||LA21_0=='\\'||LA21_0=='^'||LA21_0=='`'||LA21_0=='|'||(LA21_0>='~' && LA21_0<='\uFFFF')) ) {s = 29;}
+
+				if ( s>=0 ) return s;
+				break;
+		}
+		if (state.backtracking>0) {state.failed=true; return -1;}
+		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 21, _s, input);
+		dfa.Error(nvae);
+		throw nvae;
+	}
+
+	#endregion
+
+}
+
+} // namespace Antlr3.ST.Language
diff --git a/Antlr3.StringTemplate/Language/GroupLexerHelper.cs b/Antlr3.StringTemplate/Language/GroupLexerHelper.cs
new file mode 100644
index 0000000..215fe1f
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/GroupLexerHelper.cs
@@ -0,0 +1,152 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Grammar conversion to ANTLR v3 and C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *	notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	notice, this list of conditions and the following disclaimer in the
+ *	documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *	derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST.Language
+{
+    using System;
+    using Antlr.Runtime;
+
+    using IToken = Antlr.Runtime.IToken;
+
+    partial class GroupLexer
+    {
+        [Flags]
+        public enum StateFlags
+        {
+            LineScanning = 1 << 0,
+            InBlockComment = 1 << 1,
+            InDocComment = 1 << 2,
+            InTextBlock = 1 << 3,
+            InAction = 15 << 4,
+            InActionComment = 1 << 8,
+            InBigString = 1 << 9,
+            InAnonymousTemplate = 1 << 10
+        }
+
+        bool GetFlag( int bitfield, StateFlags flag )
+        {
+            return ( bitfield & (int)flag ) == (int)flag;
+        }
+        int SetFlag( int bitfield, StateFlags flag, bool value )
+        {
+            bitfield &= ~(int)flag;
+            if ( value )
+                bitfield |= (int)flag;
+            return bitfield;
+        }
+
+        int ScannerState
+        {
+            get;
+            set;
+        }
+        public bool InColorizer
+        {
+            get;
+            set;
+        }
+        public bool InBlockComment
+        {
+            get
+            {
+                return GetFlag( ScannerState, StateFlags.InBlockComment );
+            }
+            set
+            {
+                //if ( !value )
+                //    InDocComment = value;
+
+                //if ( LineScanning && Line > _startLine )
+                //    return;
+
+                ScannerState = SetFlag( ScannerState, StateFlags.InBlockComment, value );
+            }
+        }
+        public bool InBigString
+        {
+            get
+            {
+                return GetFlag( ScannerState, StateFlags.InBigString );
+            }
+            set
+            {
+                ScannerState = SetFlag( ScannerState, StateFlags.InBigString, value );
+            }
+        }
+        public bool InAnonymousTemplate
+        {
+            get
+            {
+                return GetFlag( ScannerState, StateFlags.InAnonymousTemplate );
+            }
+            set
+            {
+                ScannerState = SetFlag( ScannerState, StateFlags.InAnonymousTemplate, value );
+            }
+        }
+
+        public override IToken NextToken()
+        {
+            if ( !InColorizer )
+                return base.NextToken();
+
+            CommonToken token = (CommonToken)base.NextToken();
+
+            if ( InBlockComment && token.Type != EOF )
+            {
+                if ( token.Type == CLOSE_BLOCK_COMMENT )
+                    InBlockComment = false;
+
+                token.Type = ML_COMMENT;
+            }
+            else if ( InBigString && token.Type != EOF )
+            {
+                if ( token.Type == CLOSE_BIG_STRING )
+                    InBigString = false;
+
+                token.Type = BIGSTRING;
+            }
+            else if ( InAnonymousTemplate && token.Type != EOF )
+            {
+                if ( token.Type == CLOSE_ANON_TEMPLATE )
+                    InAnonymousTemplate = false;
+
+                token.Type = ANONYMOUS_TEMPLATE;
+            }
+
+            if ( token.Type != EOF && token.StartIndex > token.StopIndex )
+                throw new OperationCanceledException();
+
+            return token;
+        }
+    }
+}
diff --git a/Antlr3.StringTemplate/Language/GroupParser.cs b/Antlr3.StringTemplate/Language/GroupParser.cs
new file mode 100644
index 0000000..c73205f
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/GroupParser.cs
@@ -0,0 +1,1179 @@
+// $ANTLR 3.1.2 Language\\Group.g3 2009-03-07 08:51:18
+
+// The variable 'variable' is assigned but its value is never used.
+#pragma warning disable 219
+// Unreachable code detected.
+#pragma warning disable 162
+
+
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+using HashMap = System.Collections.Hashtable;
+using Map = System.Collections.IDictionary;
+
+
+using System.Collections.Generic;
+using Antlr.Runtime;
+using Stack = System.Collections.Generic.Stack<object>;
+using List = System.Collections.IList;
+using ArrayList = System.Collections.Generic.List<object>;
+
+namespace Antlr3.ST.Language
+{
+public partial class GroupParser : Parser
+{
+	public static readonly string[] tokenNames = new string[] {
+		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ANONYMOUS_TEMPLATE", "ANYCHAR", "ASSIGN", "AT", "BIGSTRING", "CLOSE_ANON_TEMPLATE", "CLOSE_BIG_STRING", "CLOSE_BLOCK_COMMENT", "COLON", "COMMA", "DEFINED_TO_BE", "DOT", "ID", "KWDEFAULT", "KWGROUP", "KWIMPLEMENTS", "LBRACK", "LPAREN", "ML_COMMENT", "OPTIONAL", "PLUS", "RBRACK", "RPAREN", "SEMI", "SL_COMMENT", "STAR", "STRING", "WS"
+	};
+	public const int EOF=-1;
+	public const int ANONYMOUS_TEMPLATE=4;
+	public const int ANYCHAR=5;
+	public const int ASSIGN=6;
+	public const int AT=7;
+	public const int BIGSTRING=8;
+	public const int CLOSE_ANON_TEMPLATE=9;
+	public const int CLOSE_BIG_STRING=10;
+	public const int CLOSE_BLOCK_COMMENT=11;
+	public const int COLON=12;
+	public const int COMMA=13;
+	public const int DEFINED_TO_BE=14;
+	public const int DOT=15;
+	public const int ID=16;
+	public const int KWDEFAULT=17;
+	public const int KWGROUP=18;
+	public const int KWIMPLEMENTS=19;
+	public const int LBRACK=20;
+	public const int LPAREN=21;
+	public const int ML_COMMENT=22;
+	public const int OPTIONAL=23;
+	public const int PLUS=24;
+	public const int RBRACK=25;
+	public const int RPAREN=26;
+	public const int SEMI=27;
+	public const int SL_COMMENT=28;
+	public const int STAR=29;
+	public const int STRING=30;
+	public const int WS=31;
+
+	// delegates
+	// delegators
+
+	public GroupParser( ITokenStream input )
+		: this( input, new RecognizerSharedState() )
+	{
+	}
+	public GroupParser( ITokenStream input, RecognizerSharedState state )
+		: base( input, state )
+	{
+	}
+
+
+	public override string[] GetTokenNames() { return GroupParser.tokenNames; }
+	public override string GrammarFileName { get { return "Language\\Group.g3"; } }
+
+
+	#region Rules
+
+	// $ANTLR start "group"
+	// Language\\Group.g3:123:0: public group[StringTemplateGroup g] : 'group' name= ID ( COLON s= ID )? ( 'implements' i= ID ( COMMA i2= ID )* )? SEMI ( template[g] | mapdef[g] )+ EOF ;
+	public void group( StringTemplateGroup g )
+	{
+		IToken name=null;
+		IToken s=null;
+		IToken i=null;
+		IToken i2=null;
+
+
+		this._group = g;
+
+		try
+		{
+			// Language\\Group.g3:128:4: ( 'group' name= ID ( COLON s= ID )? ( 'implements' i= ID ( COMMA i2= ID )* )? SEMI ( template[g] | mapdef[g] )+ EOF )
+			// Language\\Group.g3:128:4: 'group' name= ID ( COLON s= ID )? ( 'implements' i= ID ( COMMA i2= ID )* )? SEMI ( template[g] | mapdef[g] )+ EOF
+			{
+			Match(input,KWGROUP,Follow._KWGROUP_in_group93);
+			name=(IToken)Match(input,ID,Follow._ID_in_group97);
+			g.Name = (name!=null?name.Text:null);
+			// Language\\Group.g3:129:3: ( COLON s= ID )?
+			int alt1=2;
+			int LA1_0 = input.LA(1);
+
+			if ( (LA1_0==COLON) )
+			{
+				alt1=1;
+			}
+			switch ( alt1 )
+			{
+			case 1:
+				// Language\\Group.g3:129:5: COLON s= ID
+				{
+				Match(input,COLON,Follow._COLON_in_group105);
+				s=(IToken)Match(input,ID,Follow._ID_in_group109);
+				g.setSuperGroup((s!=null?s.Text:null));
+
+				}
+				break;
+
+			}
+
+			// Language\\Group.g3:130:3: ( 'implements' i= ID ( COMMA i2= ID )* )?
+			int alt3=2;
+			int LA3_0 = input.LA(1);
+
+			if ( (LA3_0==KWIMPLEMENTS) )
+			{
+				alt3=1;
+			}
+			switch ( alt3 )
+			{
+			case 1:
+				// Language\\Group.g3:130:5: 'implements' i= ID ( COMMA i2= ID )*
+				{
+				Match(input,KWIMPLEMENTS,Follow._KWIMPLEMENTS_in_group120);
+				i=(IToken)Match(input,ID,Follow._ID_in_group124);
+				g.implementInterface((i!=null?i.Text:null));
+				// Language\\Group.g3:131:4: ( COMMA i2= ID )*
+				for ( ; ; )
+				{
+					int alt2=2;
+					int LA2_0 = input.LA(1);
+
+					if ( (LA2_0==COMMA) )
+					{
+						alt2=1;
+					}
+
+
+					switch ( alt2 )
+					{
+					case 1:
+						// Language\\Group.g3:131:5: COMMA i2= ID
+						{
+						Match(input,COMMA,Follow._COMMA_in_group132);
+						i2=(IToken)Match(input,ID,Follow._ID_in_group136);
+						g.implementInterface((i2!=null?i2.Text:null));
+
+						}
+						break;
+
+					default:
+						goto loop2;
+					}
+				}
+
+				loop2:
+					;
+
+
+
+				}
+				break;
+
+			}
+
+			Match(input,SEMI,Follow._SEMI_in_group150);
+			// Language\\Group.g3:134:3: ( template[g] | mapdef[g] )+
+			int cnt4=0;
+			for ( ; ; )
+			{
+				int alt4=3;
+				int LA4_0 = input.LA(1);
+
+				if ( (LA4_0==AT) )
+				{
+					alt4=1;
+				}
+				else if ( (LA4_0==ID) )
+				{
+					int LA4_3 = input.LA(2);
+
+					if ( (LA4_3==DEFINED_TO_BE) )
+					{
+						int LA4_4 = input.LA(3);
+
+						if ( (LA4_4==ID) )
+						{
+							alt4=1;
+						}
+						else if ( (LA4_4==LBRACK) )
+						{
+							alt4=2;
+						}
+
+
+					}
+					else if ( (LA4_3==LPAREN) )
+					{
+						alt4=1;
+					}
+
+
+				}
+
+
+				switch ( alt4 )
+				{
+				case 1:
+					// Language\\Group.g3:134:5: template[g]
+					{
+					PushFollow(Follow._template_in_group156);
+					template(g);
+
+					state._fsp--;
+
+
+					}
+					break;
+				case 2:
+					// Language\\Group.g3:134:19: mapdef[g]
+					{
+					PushFollow(Follow._mapdef_in_group161);
+					mapdef(g);
+
+					state._fsp--;
+
+
+					}
+					break;
+
+				default:
+					if ( cnt4 >= 1 )
+						goto loop4;
+
+					EarlyExitException eee4 = new EarlyExitException( 4, input );
+					throw eee4;
+				}
+				cnt4++;
+			}
+			loop4:
+				;
+
+
+			Match(input,EOF,Follow._EOF_in_group169);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "group"
+
+
+	// $ANTLR start "template"
+	// Language\\Group.g3:138:0: template[StringTemplateGroup g] : ( ( AT scope2= ID DOT region= ID |name= ID ) LPAREN ( args[st] |) RPAREN DEFINED_TO_BE (t= STRING |bt= BIGSTRING ) |alias= ID DEFINED_TO_BE target= ID );
+	private void template( StringTemplateGroup g )
+	{
+		IToken scope2=null;
+		IToken region=null;
+		IToken name=null;
+		IToken t=null;
+		IToken bt=null;
+		IToken alias=null;
+		IToken target=null;
+
+
+			Map formalArgs = null;
+			StringTemplate st = null;
+			bool ignore = false;
+			string templateName=null;
+			int line = input.LT(1).Line;
+
+		try
+		{
+			// Language\\Group.g3:147:4: ( ( AT scope2= ID DOT region= ID |name= ID ) LPAREN ( args[st] |) RPAREN DEFINED_TO_BE (t= STRING |bt= BIGSTRING ) |alias= ID DEFINED_TO_BE target= ID )
+			int alt8=2;
+			int LA8_0 = input.LA(1);
+
+			if ( (LA8_0==AT) )
+			{
+				alt8=1;
+			}
+			else if ( (LA8_0==ID) )
+			{
+				int LA8_2 = input.LA(2);
+
+				if ( (LA8_2==DEFINED_TO_BE) )
+				{
+					alt8=2;
+				}
+				else if ( (LA8_2==LPAREN) )
+				{
+					alt8=1;
+				}
+				else
+				{
+					NoViableAltException nvae = new NoViableAltException("", 8, 2, input);
+
+					throw nvae;
+				}
+			}
+			else
+			{
+				NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt8 )
+			{
+			case 1:
+				// Language\\Group.g3:147:4: ( AT scope2= ID DOT region= ID |name= ID ) LPAREN ( args[st] |) RPAREN DEFINED_TO_BE (t= STRING |bt= BIGSTRING )
+				{
+				// Language\\Group.g3:147:4: ( AT scope2= ID DOT region= ID |name= ID )
+				int alt5=2;
+				int LA5_0 = input.LA(1);
+
+				if ( (LA5_0==AT) )
+				{
+					alt5=1;
+				}
+				else if ( (LA5_0==ID) )
+				{
+					alt5=2;
+				}
+				else
+				{
+					NoViableAltException nvae = new NoViableAltException("", 5, 0, input);
+
+					throw nvae;
+				}
+				switch ( alt5 )
+				{
+				case 1:
+					// Language\\Group.g3:147:6: AT scope2= ID DOT region= ID
+					{
+					Match(input,AT,Follow._AT_in_template188);
+					scope2=(IToken)Match(input,ID,Follow._ID_in_template192);
+					Match(input,DOT,Follow._DOT_in_template194);
+					region=(IToken)Match(input,ID,Follow._ID_in_template198);
+
+									templateName=g.getMangledRegionName((scope2!=null?scope2.Text:null),(region!=null?region.Text:null));
+									if ( g.isDefinedInThisGroup(templateName) )
+									{
+										g.error("group "+g.Name+" line "+line+": redefinition of template region: @"+
+											(scope2!=null?scope2.Text:null)+"."+(region!=null?region.Text:null));
+										st = new StringTemplate(); // create bogus template to fill in
+									}
+									else
+									{
+										bool err = false;
+										// @template.region() ::= "..."
+										StringTemplate scopeST = g.lookupTemplate((scope2!=null?scope2.Text:null));
+										if ( scopeST == null )
+										{
+											g.error("group "+g.Name+" line "+line+": reference to region within undefined template: "+
+												(scope2!=null?scope2.Text:null));
+											err=true;
+										}
+										else if ( !scopeST.containsRegionName((region!=null?region.Text:null)) )
+										{
+											g.error("group "+g.Name+" line "+line+": template "+(scope2!=null?scope2.Text:null)+" has no region called "+
+												(region!=null?region.Text:null));
+											err=true;
+										}
+										if ( err )
+										{
+											st = new StringTemplate();
+										}
+										else
+										{
+											st = g.defineRegionTemplate((scope2!=null?scope2.Text:null),
+																		(region!=null?region.Text:null),
+																		null,
+																		StringTemplate.REGION_EXPLICIT);
+										}
+									}
+
+
+					}
+					break;
+				case 2:
+					// Language\\Group.g3:186:5: name= ID
+					{
+					name=(IToken)Match(input,ID,Follow._ID_in_template211);
+					templateName = (name!=null?name.Text:null);
+
+									if ( g.isDefinedInThisGroup(templateName) )
+									{
+										g.error("redefinition of template: "+templateName);
+										st = new StringTemplate(); // create bogus template to fill in
+									}
+									else
+									{
+										st = g.defineTemplate(templateName, null);
+									}
+
+
+					}
+					break;
+
+				}
+
+				if ( st!=null ) {st.setGroupFileLine(line);}
+				Match(input,LPAREN,Follow._LPAREN_in_template230);
+				// Language\\Group.g3:201:4: ( args[st] |)
+				int alt6=2;
+				int LA6_0 = input.LA(1);
+
+				if ( (LA6_0==ID) )
+				{
+					alt6=1;
+				}
+				else if ( (LA6_0==RPAREN) )
+				{
+					alt6=2;
+				}
+				else
+				{
+					NoViableAltException nvae = new NoViableAltException("", 6, 0, input);
+
+					throw nvae;
+				}
+				switch ( alt6 )
+				{
+				case 1:
+					// Language\\Group.g3:201:5: args[st]
+					{
+					PushFollow(Follow._args_in_template236);
+					args(st);
+
+					state._fsp--;
+
+
+					}
+					break;
+				case 2:
+					// Language\\Group.g3:201:14:
+					{
+					st.defineEmptyFormalArgumentList();
+
+					}
+					break;
+
+				}
+
+				Match(input,RPAREN,Follow._RPAREN_in_template244);
+				Match(input,DEFINED_TO_BE,Follow._DEFINED_TO_BE_in_template248);
+				// Language\\Group.g3:204:3: (t= STRING |bt= BIGSTRING )
+				int alt7=2;
+				int LA7_0 = input.LA(1);
+
+				if ( (LA7_0==STRING) )
+				{
+					alt7=1;
+				}
+				else if ( (LA7_0==BIGSTRING) )
+				{
+					alt7=2;
+				}
+				else
+				{
+					NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
+
+					throw nvae;
+				}
+				switch ( alt7 )
+				{
+				case 1:
+					// Language\\Group.g3:204:5: t= STRING
+					{
+					t=(IToken)Match(input,STRING,Follow._STRING_in_template256);
+					st.setTemplate((t!=null?t.Text:null));
+
+					}
+					break;
+				case 2:
+					// Language\\Group.g3:205:5: bt= BIGSTRING
+					{
+					bt=(IToken)Match(input,BIGSTRING,Follow._BIGSTRING_in_template270);
+					st.setTemplate((bt!=null?bt.Text:null));
+
+					}
+					break;
+
+				}
+
+
+				}
+				break;
+			case 2:
+				// Language\\Group.g3:208:6: alias= ID DEFINED_TO_BE target= ID
+				{
+				alias=(IToken)Match(input,ID,Follow._ID_in_template286);
+				Match(input,DEFINED_TO_BE,Follow._DEFINED_TO_BE_in_template288);
+				target=(IToken)Match(input,ID,Follow._ID_in_template292);
+				g.defineTemplateAlias((alias!=null?alias.Text:null), (target!=null?target.Text:null));
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "template"
+
+
+	// $ANTLR start "args"
+	// Language\\Group.g3:212:0: args[StringTemplate st] : arg[st] ( COMMA arg[st] )* ;
+	private void args( StringTemplate st )
+	{
+		try
+		{
+			// Language\\Group.g3:213:4: ( arg[st] ( COMMA arg[st] )* )
+			// Language\\Group.g3:213:4: arg[st] ( COMMA arg[st] )*
+			{
+			PushFollow(Follow._arg_in_args308);
+			arg(st);
+
+			state._fsp--;
+
+			// Language\\Group.g3:213:12: ( COMMA arg[st] )*
+			for ( ; ; )
+			{
+				int alt9=2;
+				int LA9_0 = input.LA(1);
+
+				if ( (LA9_0==COMMA) )
+				{
+					alt9=1;
+				}
+
+
+				switch ( alt9 )
+				{
+				case 1:
+					// Language\\Group.g3:213:14: COMMA arg[st]
+					{
+					Match(input,COMMA,Follow._COMMA_in_args313);
+					PushFollow(Follow._arg_in_args315);
+					arg(st);
+
+					state._fsp--;
+
+
+					}
+					break;
+
+				default:
+					goto loop9;
+				}
+			}
+
+			loop9:
+				;
+
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "args"
+
+
+	// $ANTLR start "arg"
+	// Language\\Group.g3:216:0: arg[StringTemplate st] : name= ID ( ASSIGN s= STRING | ASSIGN bs= ANONYMOUS_TEMPLATE )? ;
+	private void arg( StringTemplate st )
+	{
+		IToken name=null;
+		IToken s=null;
+		IToken bs=null;
+
+
+			StringTemplate defaultValue = null;
+
+		try
+		{
+			// Language\\Group.g3:221:4: (name= ID ( ASSIGN s= STRING | ASSIGN bs= ANONYMOUS_TEMPLATE )? )
+			// Language\\Group.g3:221:4: name= ID ( ASSIGN s= STRING | ASSIGN bs= ANONYMOUS_TEMPLATE )?
+			{
+			name=(IToken)Match(input,ID,Follow._ID_in_arg338);
+			// Language\\Group.g3:222:3: ( ASSIGN s= STRING | ASSIGN bs= ANONYMOUS_TEMPLATE )?
+			int alt10=3;
+			int LA10_0 = input.LA(1);
+
+			if ( (LA10_0==ASSIGN) )
+			{
+				int LA10_1 = input.LA(2);
+
+				if ( (LA10_1==STRING) )
+				{
+					alt10=1;
+				}
+				else if ( (LA10_1==ANONYMOUS_TEMPLATE) )
+				{
+					alt10=2;
+				}
+			}
+			switch ( alt10 )
+			{
+			case 1:
+				// Language\\Group.g3:222:5: ASSIGN s= STRING
+				{
+				Match(input,ASSIGN,Follow._ASSIGN_in_arg344);
+				s=(IToken)Match(input,STRING,Follow._STRING_in_arg348);
+
+								defaultValue=new StringTemplate("$_val_$");
+								defaultValue.setAttribute("_val_", (s!=null?s.Text:null));
+								defaultValue.defineFormalArgument("_val_");
+								defaultValue.Name = "<"+st.getName()+"'s arg "+(name!=null?name.Text:null)+" default value subtemplate>";
+
+
+				}
+				break;
+			case 2:
+				// Language\\Group.g3:229:5: ASSIGN bs= ANONYMOUS_TEMPLATE
+				{
+				Match(input,ASSIGN,Follow._ASSIGN_in_arg359);
+				bs=(IToken)Match(input,ANONYMOUS_TEMPLATE,Follow._ANONYMOUS_TEMPLATE_in_arg363);
+
+								defaultValue=new StringTemplate(st.getGroup(), (bs!=null?bs.Text:null));
+								defaultValue.Name = "<"+st.getName()+"'s arg "+(name!=null?name.Text:null)+" default value subtemplate>";
+
+
+				}
+				break;
+
+			}
+
+			st.defineFormalArgument((name!=null?name.Text:null), defaultValue);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "arg"
+
+
+	// $ANTLR start "mapdef"
+	// Language\\Group.g3:238:0: mapdef[StringTemplateGroup g] : name= ID DEFINED_TO_BE m= map ;
+	private void mapdef( StringTemplateGroup g )
+	{
+		IToken name=null;
+		Map m = default(Map);
+
+		try
+		{
+			// Language\\Group.g3:239:4: (name= ID DEFINED_TO_BE m= map )
+			// Language\\Group.g3:239:4: name= ID DEFINED_TO_BE m= map
+			{
+			name=(IToken)Match(input,ID,Follow._ID_in_mapdef391);
+			Match(input,DEFINED_TO_BE,Follow._DEFINED_TO_BE_in_mapdef395);
+			PushFollow(Follow._map_in_mapdef399);
+			m=map();
+
+			state._fsp--;
+
+
+						if ( g.getMap((name!=null?name.Text:null))!=null )
+						{
+							g.error("redefinition of map: "+(name!=null?name.Text:null));
+						}
+						else if ( g.isDefinedInThisGroup((name!=null?name.Text:null)) )
+						{
+							g.error("redefinition of template as map: "+(name!=null?name.Text:null));
+						}
+						else
+						{
+							g.defineMap((name!=null?name.Text:null), m);
+						}
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "mapdef"
+
+
+	// $ANTLR start "map"
+	// Language\\Group.g3:257:0: map returns [Map mapping=new HashMap()] : LBRACK mapPairs[mapping] RBRACK ;
+	private Map map(  )
+	{
+
+		Map mapping = new HashMap();
+
+		try
+		{
+			// Language\\Group.g3:258:6: ( LBRACK mapPairs[mapping] RBRACK )
+			// Language\\Group.g3:258:6: LBRACK mapPairs[mapping] RBRACK
+			{
+			Match(input,LBRACK,Follow._LBRACK_in_map420);
+			PushFollow(Follow._mapPairs_in_map422);
+			mapPairs(mapping);
+
+			state._fsp--;
+
+			Match(input,RBRACK,Follow._RBRACK_in_map425);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return mapping;
+	}
+	// $ANTLR end "map"
+
+
+	// $ANTLR start "mapPairs"
+	// Language\\Group.g3:261:0: mapPairs[Map mapping] : ( keyValuePair[mapping] ( COMMA keyValuePair[mapping] )* ( COMMA defaultValuePair[mapping] )? | defaultValuePair[mapping] );
+	private void mapPairs( Map mapping )
+	{
+		try
+		{
+			// Language\\Group.g3:262:4: ( keyValuePair[mapping] ( COMMA keyValuePair[mapping] )* ( COMMA defaultValuePair[mapping] )? | defaultValuePair[mapping] )
+			int alt13=2;
+			int LA13_0 = input.LA(1);
+
+			if ( (LA13_0==STRING) )
+			{
+				alt13=1;
+			}
+			else if ( (LA13_0==KWDEFAULT) )
+			{
+				alt13=2;
+			}
+			else
+			{
+				NoViableAltException nvae = new NoViableAltException("", 13, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt13 )
+			{
+			case 1:
+				// Language\\Group.g3:262:4: keyValuePair[mapping] ( COMMA keyValuePair[mapping] )* ( COMMA defaultValuePair[mapping] )?
+				{
+				PushFollow(Follow._keyValuePair_in_mapPairs438);
+				keyValuePair(mapping);
+
+				state._fsp--;
+
+				// Language\\Group.g3:262:26: ( COMMA keyValuePair[mapping] )*
+				for ( ; ; )
+				{
+					int alt11=2;
+					int LA11_0 = input.LA(1);
+
+					if ( (LA11_0==COMMA) )
+					{
+						int LA11_1 = input.LA(2);
+
+						if ( (LA11_1==STRING) )
+						{
+							alt11=1;
+						}
+
+
+					}
+
+
+					switch ( alt11 )
+					{
+					case 1:
+						// Language\\Group.g3:262:27: COMMA keyValuePair[mapping]
+						{
+						Match(input,COMMA,Follow._COMMA_in_mapPairs442);
+						PushFollow(Follow._keyValuePair_in_mapPairs444);
+						keyValuePair(mapping);
+
+						state._fsp--;
+
+
+						}
+						break;
+
+					default:
+						goto loop11;
+					}
+				}
+
+				loop11:
+					;
+
+
+				// Language\\Group.g3:263:3: ( COMMA defaultValuePair[mapping] )?
+				int alt12=2;
+				int LA12_0 = input.LA(1);
+
+				if ( (LA12_0==COMMA) )
+				{
+					alt12=1;
+				}
+				switch ( alt12 )
+				{
+				case 1:
+					// Language\\Group.g3:263:4: COMMA defaultValuePair[mapping]
+					{
+					Match(input,COMMA,Follow._COMMA_in_mapPairs452);
+					PushFollow(Follow._defaultValuePair_in_mapPairs454);
+					defaultValuePair(mapping);
+
+					state._fsp--;
+
+
+					}
+					break;
+
+				}
+
+
+				}
+				break;
+			case 2:
+				// Language\\Group.g3:264:4: defaultValuePair[mapping]
+				{
+				PushFollow(Follow._defaultValuePair_in_mapPairs462);
+				defaultValuePair(mapping);
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "mapPairs"
+
+
+	// $ANTLR start "defaultValuePair"
+	// Language\\Group.g3:267:0: defaultValuePair[Map mapping] : 'default' COLON v= keyValue ;
+	private void defaultValuePair( Map mapping )
+	{
+		StringTemplate v = default(StringTemplate);
+
+		try
+		{
+			// Language\\Group.g3:268:4: ( 'default' COLON v= keyValue )
+			// Language\\Group.g3:268:4: 'default' COLON v= keyValue
+			{
+			Match(input,KWDEFAULT,Follow._KWDEFAULT_in_defaultValuePair476);
+			Match(input,COLON,Follow._COLON_in_defaultValuePair478);
+			PushFollow(Follow._keyValue_in_defaultValuePair482);
+			v=keyValue();
+
+			state._fsp--;
+
+			mapping[ASTExpr.DEFAULT_MAP_VALUE_NAME] = v;
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "defaultValuePair"
+
+
+	// $ANTLR start "keyValuePair"
+	// Language\\Group.g3:272:0: keyValuePair[Map mapping] : key= STRING COLON v= keyValue ;
+	private void keyValuePair( Map mapping )
+	{
+		IToken key=null;
+		StringTemplate v = default(StringTemplate);
+
+		try
+		{
+			// Language\\Group.g3:273:4: (key= STRING COLON v= keyValue )
+			// Language\\Group.g3:273:4: key= STRING COLON v= keyValue
+			{
+			key=(IToken)Match(input,STRING,Follow._STRING_in_keyValuePair500);
+			Match(input,COLON,Follow._COLON_in_keyValuePair502);
+			PushFollow(Follow._keyValue_in_keyValuePair506);
+			v=keyValue();
+
+			state._fsp--;
+
+			mapping[(key!=null?key.Text:null)] = v;
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "keyValuePair"
+
+
+	// $ANTLR start "keyValue"
+	// Language\\Group.g3:276:0: keyValue returns [StringTemplate value=null] : (s1= BIGSTRING |s2= STRING |k= ID {...}?|);
+	private StringTemplate keyValue(  )
+	{
+
+		StringTemplate value = null;
+
+		IToken s1=null;
+		IToken s2=null;
+		IToken k=null;
+
+		try
+		{
+			// Language\\Group.g3:277:4: (s1= BIGSTRING |s2= STRING |k= ID {...}?|)
+			int alt14=4;
+			switch ( input.LA(1) )
+			{
+			case BIGSTRING:
+				{
+				alt14=1;
+				}
+				break;
+			case STRING:
+				{
+				alt14=2;
+				}
+				break;
+			case ID:
+				{
+				alt14=3;
+				}
+				break;
+			case COMMA:
+			case RBRACK:
+				{
+				alt14=4;
+				}
+				break;
+			default:
+				{
+					NoViableAltException nvae = new NoViableAltException("", 14, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt14 )
+			{
+			case 1:
+				// Language\\Group.g3:277:4: s1= BIGSTRING
+				{
+				s1=(IToken)Match(input,BIGSTRING,Follow._BIGSTRING_in_keyValue525);
+				value = new StringTemplate(_group,(s1!=null?s1.Text:null));
+
+				}
+				break;
+			case 2:
+				// Language\\Group.g3:278:4: s2= STRING
+				{
+				s2=(IToken)Match(input,STRING,Follow._STRING_in_keyValue534);
+				value = new StringTemplate(_group,(s2!=null?s2.Text:null));
+
+				}
+				break;
+			case 3:
+				// Language\\Group.g3:279:4: k= ID {...}?
+				{
+				k=(IToken)Match(input,ID,Follow._ID_in_keyValue544);
+				if ( !(((k!=null?k.Text:null) == "key")) )
+				{
+					throw new FailedPredicateException(input, "keyValue", "$k.text == \"key\"");
+				}
+				value = ASTExpr.MAP_KEY_VALUE;
+
+				}
+				break;
+			case 4:
+				// Language\\Group.g3:281:8:
+				{
+				value = null;
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return value;
+	}
+	// $ANTLR end "keyValue"
+	#endregion
+
+	// Delegated rules
+
+	#region Synpreds
+	#endregion
+
+	#region DFA
+
+	protected override void InitDFAs()
+	{
+		base.InitDFAs();
+	}
+
+	#endregion
+
+	#region Follow Sets
+	public static class Follow
+	{
+		public static readonly BitSet _KWGROUP_in_group93 = new BitSet(new ulong[]{0x10000UL});
+		public static readonly BitSet _ID_in_group97 = new BitSet(new ulong[]{0x8081000UL});
+		public static readonly BitSet _COLON_in_group105 = new BitSet(new ulong[]{0x10000UL});
+		public static readonly BitSet _ID_in_group109 = new BitSet(new ulong[]{0x8080000UL});
+		public static readonly BitSet _KWIMPLEMENTS_in_group120 = new BitSet(new ulong[]{0x10000UL});
+		public static readonly BitSet _ID_in_group124 = new BitSet(new ulong[]{0x8002000UL});
+		public static readonly BitSet _COMMA_in_group132 = new BitSet(new ulong[]{0x10000UL});
+		public static readonly BitSet _ID_in_group136 = new BitSet(new ulong[]{0x8002000UL});
+		public static readonly BitSet _SEMI_in_group150 = new BitSet(new ulong[]{0x10080UL});
+		public static readonly BitSet _template_in_group156 = new BitSet(new ulong[]{0x10080UL});
+		public static readonly BitSet _mapdef_in_group161 = new BitSet(new ulong[]{0x10080UL});
+		public static readonly BitSet _EOF_in_group169 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _AT_in_template188 = new BitSet(new ulong[]{0x10000UL});
+		public static readonly BitSet _ID_in_template192 = new BitSet(new ulong[]{0x8000UL});
+		public static readonly BitSet _DOT_in_template194 = new BitSet(new ulong[]{0x10000UL});
+		public static readonly BitSet _ID_in_template198 = new BitSet(new ulong[]{0x200000UL});
+		public static readonly BitSet _ID_in_template211 = new BitSet(new ulong[]{0x200000UL});
+		public static readonly BitSet _LPAREN_in_template230 = new BitSet(new ulong[]{0x4010000UL});
+		public static readonly BitSet _args_in_template236 = new BitSet(new ulong[]{0x4000000UL});
+		public static readonly BitSet _RPAREN_in_template244 = new BitSet(new ulong[]{0x4000UL});
+		public static readonly BitSet _DEFINED_TO_BE_in_template248 = new BitSet(new ulong[]{0x40000100UL});
+		public static readonly BitSet _STRING_in_template256 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _BIGSTRING_in_template270 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ID_in_template286 = new BitSet(new ulong[]{0x4000UL});
+		public static readonly BitSet _DEFINED_TO_BE_in_template288 = new BitSet(new ulong[]{0x10000UL});
+		public static readonly BitSet _ID_in_template292 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _arg_in_args308 = new BitSet(new ulong[]{0x2002UL});
+		public static readonly BitSet _COMMA_in_args313 = new BitSet(new ulong[]{0x10000UL});
+		public static readonly BitSet _arg_in_args315 = new BitSet(new ulong[]{0x2002UL});
+		public static readonly BitSet _ID_in_arg338 = new BitSet(new ulong[]{0x42UL});
+		public static readonly BitSet _ASSIGN_in_arg344 = new BitSet(new ulong[]{0x40000000UL});
+		public static readonly BitSet _STRING_in_arg348 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ASSIGN_in_arg359 = new BitSet(new ulong[]{0x10UL});
+		public static readonly BitSet _ANONYMOUS_TEMPLATE_in_arg363 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ID_in_mapdef391 = new BitSet(new ulong[]{0x4000UL});
+		public static readonly BitSet _DEFINED_TO_BE_in_mapdef395 = new BitSet(new ulong[]{0x100000UL});
+		public static readonly BitSet _map_in_mapdef399 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _LBRACK_in_map420 = new BitSet(new ulong[]{0x40020000UL});
+		public static readonly BitSet _mapPairs_in_map422 = new BitSet(new ulong[]{0x2000000UL});
+		public static readonly BitSet _RBRACK_in_map425 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _keyValuePair_in_mapPairs438 = new BitSet(new ulong[]{0x2002UL});
+		public static readonly BitSet _COMMA_in_mapPairs442 = new BitSet(new ulong[]{0x40000000UL});
+		public static readonly BitSet _keyValuePair_in_mapPairs444 = new BitSet(new ulong[]{0x2002UL});
+		public static readonly BitSet _COMMA_in_mapPairs452 = new BitSet(new ulong[]{0x40020000UL});
+		public static readonly BitSet _defaultValuePair_in_mapPairs454 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _defaultValuePair_in_mapPairs462 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _KWDEFAULT_in_defaultValuePair476 = new BitSet(new ulong[]{0x1000UL});
+		public static readonly BitSet _COLON_in_defaultValuePair478 = new BitSet(new ulong[]{0x40010100UL});
+		public static readonly BitSet _keyValue_in_defaultValuePair482 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _STRING_in_keyValuePair500 = new BitSet(new ulong[]{0x1000UL});
+		public static readonly BitSet _COLON_in_keyValuePair502 = new BitSet(new ulong[]{0x40010100UL});
+		public static readonly BitSet _keyValue_in_keyValuePair506 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _BIGSTRING_in_keyValue525 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _STRING_in_keyValue534 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ID_in_keyValue544 = new BitSet(new ulong[]{0x2UL});
+
+	}
+	#endregion
+}
+
+} // namespace Antlr3.ST.Language
diff --git a/Antlr3.StringTemplate/Language/GroupParserHelper.cs b/Antlr3.StringTemplate/Language/GroupParserHelper.cs
new file mode 100644
index 0000000..e249ee2
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/GroupParserHelper.cs
@@ -0,0 +1,57 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Grammar conversion to ANTLR v3 and C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *	notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	notice, this list of conditions and the following disclaimer in the
+ *	documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *	derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST.Language
+{
+    using System;
+    using Antlr.Runtime.JavaExtensions;
+
+    using RecognitionException = Antlr.Runtime.RecognitionException;
+
+    partial class GroupParser
+    {
+        protected StringTemplateGroup _group;
+
+        public override void ReportError( RecognitionException e )
+        {
+            if ( _group != null )
+            {
+                _group.error( "template group parse error", e );
+            }
+            else
+            {
+                Console.Error.WriteLine( "template group parse error: " + e );
+                e.printStackTrace( Console.Error );
+            }
+        }
+    }
+}
diff --git a/Antlr3.StringTemplate/Language/Interface.g3 b/Antlr3.StringTemplate/Language/Interface.g3
new file mode 100644
index 0000000..1883e44
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/Interface.g3
@@ -0,0 +1,178 @@
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+grammar Interface;
+
+options
+{
+	language=CSharp3;
+}
+
+@lexer::header
+{
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+}
+
+@parser::header
+{
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+}
+
+@lexer::namespace {Antlr3.ST.Language}
+@parser::namespace {Antlr3.ST.Language}
+
+public
+groupInterface[StringTemplateGroupInterface groupI]
+@init
+{
+	this.groupI = groupI;
+}
+	:	'interface' name=ID {groupI.setName($name.text);} SEMI
+		( template[groupI] )+
+		EOF
+	;
+
+
+template[StringTemplateGroupInterface groupI]
+@init
+{
+	string templateName = null;
+}
+	:	(opt='optional')? name=ID LPAREN (formalArgs=args)? RPAREN SEMI
+		{
+			templateName = $name.text;
+			$groupI.defineTemplate( templateName, $formalArgs.args ?? new System.Collections.Generic.SortedList<string, FormalArgument>(), opt!=null );
+		}
+	;
+
+args returns[System.Collections.Generic.SortedList<string, FormalArgument> args]
+@init
+{
+	$args = new System.Collections.Generic.SortedList<string, FormalArgument>();
+}
+	:	a=ID {$args[$a.text] = new FormalArgument($a.text);}
+		( COMMA b=ID {$args[$b.text] = new FormalArgument($b.text);} )*
+	;
+
+//////////////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////////////
+// LEXER
+
+ID	:	('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'0'..'9'|'-'|'_')*
+	;
+
+LPAREN	:	'(';
+RPAREN	:	')';
+COMMA	:	',';
+SEMI	:	';';
+COLON	:	':';
+
+// Single-line comments
+SL_COMMENT
+	:	'//'
+		(~('\n'|'\r'))* (('\r')? '\n')?
+		{ $channel = HIDDEN; }
+	;
+
+ML_COMMENT
+	:	'/*' .* '*/'
+		{ $channel = HIDDEN; }
+	;
+
+WS
+	:	(	' '
+		|	'\t'
+		|	'\f'
+		|	('\r')? '\n'
+		)+
+		{ $channel = HIDDEN; }
+	;
diff --git a/Antlr3.StringTemplate/Language/InterfaceLexer.cs b/Antlr3.StringTemplate/Language/InterfaceLexer.cs
new file mode 100644
index 0000000..58cd7bf
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/InterfaceLexer.cs
@@ -0,0 +1,792 @@
+// $ANTLR 3.1.2 Language\\Interface.g3 2009-03-07 08:51:17
+
+// The variable 'variable' is assigned but its value is never used.
+#pragma warning disable 219
+// Unreachable code detected.
+#pragma warning disable 162
+
+
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+using System.Collections.Generic;
+using Antlr.Runtime;
+using Stack = System.Collections.Generic.Stack<object>;
+using List = System.Collections.IList;
+using ArrayList = System.Collections.Generic.List<object>;
+
+namespace Antlr3.ST.Language
+{
+public partial class InterfaceLexer : Lexer
+{
+	public const int EOF=-1;
+	public const int T__13=13;
+	public const int T__14=14;
+	public const int COLON=4;
+	public const int COMMA=5;
+	public const int ID=6;
+	public const int LPAREN=7;
+	public const int ML_COMMENT=8;
+	public const int RPAREN=9;
+	public const int SEMI=10;
+	public const int SL_COMMENT=11;
+	public const int WS=12;
+
+    // delegates
+    // delegators
+
+	public InterfaceLexer() {}
+	public InterfaceLexer( ICharStream input )
+		: this( input, new RecognizerSharedState() )
+	{
+	}
+	public InterfaceLexer( ICharStream input, RecognizerSharedState state )
+		: base( input, state )
+	{
+
+	}
+	public override string GrammarFileName { get { return "Language\\Interface.g3"; } }
+
+	// $ANTLR start "T__13"
+	private void mT__13()
+	{
+		try
+		{
+			int _type = T__13;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Interface.g3:42:9: ( 'interface' )
+			// Language\\Interface.g3:42:9: 'interface'
+			{
+			Match("interface");
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "T__13"
+
+	// $ANTLR start "T__14"
+	private void mT__14()
+	{
+		try
+		{
+			int _type = T__14;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Interface.g3:43:9: ( 'optional' )
+			// Language\\Interface.g3:43:9: 'optional'
+			{
+			Match("optional");
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "T__14"
+
+	// $ANTLR start "ID"
+	private void mID()
+	{
+		try
+		{
+			int _type = ID;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Interface.g3:150:6: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '-' | '_' )* )
+			// Language\\Interface.g3:150:6: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '-' | '_' )*
+			{
+			if ( (input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z') )
+			{
+				input.Consume();
+
+			}
+			else
+			{
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				Recover(mse);
+				throw mse;}
+
+			// Language\\Interface.g3:150:30: ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '-' | '_' )*
+			for ( ; ; )
+			{
+				int alt1=2;
+				int LA1_0 = input.LA(1);
+
+				if ( (LA1_0=='-'||(LA1_0>='0' && LA1_0<='9')||(LA1_0>='A' && LA1_0<='Z')||LA1_0=='_'||(LA1_0>='a' && LA1_0<='z')) )
+				{
+					alt1=1;
+				}
+
+
+				switch ( alt1 )
+				{
+				case 1:
+					// Language\\Interface.g3:
+					{
+					input.Consume();
+
+
+					}
+					break;
+
+				default:
+					goto loop1;
+				}
+			}
+
+			loop1:
+				;
+
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ID"
+
+	// $ANTLR start "LPAREN"
+	private void mLPAREN()
+	{
+		try
+		{
+			int _type = LPAREN;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Interface.g3:153:10: ( '(' )
+			// Language\\Interface.g3:153:10: '('
+			{
+			Match('(');
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "LPAREN"
+
+	// $ANTLR start "RPAREN"
+	private void mRPAREN()
+	{
+		try
+		{
+			int _type = RPAREN;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Interface.g3:154:10: ( ')' )
+			// Language\\Interface.g3:154:10: ')'
+			{
+			Match(')');
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "RPAREN"
+
+	// $ANTLR start "COMMA"
+	private void mCOMMA()
+	{
+		try
+		{
+			int _type = COMMA;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Interface.g3:155:9: ( ',' )
+			// Language\\Interface.g3:155:9: ','
+			{
+			Match(',');
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "COMMA"
+
+	// $ANTLR start "SEMI"
+	private void mSEMI()
+	{
+		try
+		{
+			int _type = SEMI;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Interface.g3:156:8: ( ';' )
+			// Language\\Interface.g3:156:8: ';'
+			{
+			Match(';');
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "SEMI"
+
+	// $ANTLR start "COLON"
+	private void mCOLON()
+	{
+		try
+		{
+			int _type = COLON;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Interface.g3:157:9: ( ':' )
+			// Language\\Interface.g3:157:9: ':'
+			{
+			Match(':');
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "COLON"
+
+	// $ANTLR start "SL_COMMENT"
+	private void mSL_COMMENT()
+	{
+		try
+		{
+			int _type = SL_COMMENT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Interface.g3:161:4: ( '//' (~ ( '\\n' | '\\r' ) )* ( ( '\\r' )? '\\n' )? )
+			// Language\\Interface.g3:161:4: '//' (~ ( '\\n' | '\\r' ) )* ( ( '\\r' )? '\\n' )?
+			{
+			Match("//");
+
+			// Language\\Interface.g3:162:3: (~ ( '\\n' | '\\r' ) )*
+			for ( ; ; )
+			{
+				int alt2=2;
+				int LA2_0 = input.LA(1);
+
+				if ( ((LA2_0>='\u0000' && LA2_0<='\t')||(LA2_0>='\u000B' && LA2_0<='\f')||(LA2_0>='\u000E' && LA2_0<='\uFFFF')) )
+				{
+					alt2=1;
+				}
+
+
+				switch ( alt2 )
+				{
+				case 1:
+					// Language\\Interface.g3:
+					{
+					input.Consume();
+
+
+					}
+					break;
+
+				default:
+					goto loop2;
+				}
+			}
+
+			loop2:
+				;
+
+
+			// Language\\Interface.g3:162:19: ( ( '\\r' )? '\\n' )?
+			int alt4=2;
+			int LA4_0 = input.LA(1);
+
+			if ( (LA4_0=='\n'||LA4_0=='\r') )
+			{
+				alt4=1;
+			}
+			switch ( alt4 )
+			{
+			case 1:
+				// Language\\Interface.g3:162:20: ( '\\r' )? '\\n'
+				{
+				// Language\\Interface.g3:162:20: ( '\\r' )?
+				int alt3=2;
+				int LA3_0 = input.LA(1);
+
+				if ( (LA3_0=='\r') )
+				{
+					alt3=1;
+				}
+				switch ( alt3 )
+				{
+				case 1:
+					// Language\\Interface.g3:162:21: '\\r'
+					{
+					Match('\r');
+
+					}
+					break;
+
+				}
+
+				Match('\n');
+
+				}
+				break;
+
+			}
+
+			 _channel = HIDDEN;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "SL_COMMENT"
+
+	// $ANTLR start "ML_COMMENT"
+	private void mML_COMMENT()
+	{
+		try
+		{
+			int _type = ML_COMMENT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Interface.g3:167:4: ( '/*' ( . )* '*/' )
+			// Language\\Interface.g3:167:4: '/*' ( . )* '*/'
+			{
+			Match("/*");
+
+			// Language\\Interface.g3:167:9: ( . )*
+			for ( ; ; )
+			{
+				int alt5=2;
+				int LA5_0 = input.LA(1);
+
+				if ( (LA5_0=='*') )
+				{
+					int LA5_1 = input.LA(2);
+
+					if ( (LA5_1=='/') )
+					{
+						alt5=2;
+					}
+					else if ( ((LA5_1>='\u0000' && LA5_1<='.')||(LA5_1>='0' && LA5_1<='\uFFFF')) )
+					{
+						alt5=1;
+					}
+
+
+				}
+				else if ( ((LA5_0>='\u0000' && LA5_0<=')')||(LA5_0>='+' && LA5_0<='\uFFFF')) )
+				{
+					alt5=1;
+				}
+
+
+				switch ( alt5 )
+				{
+				case 1:
+					// Language\\Interface.g3:167:0: .
+					{
+					MatchAny();
+
+					}
+					break;
+
+				default:
+					goto loop5;
+				}
+			}
+
+			loop5:
+				;
+
+
+			Match("*/");
+
+			 _channel = HIDDEN;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ML_COMMENT"
+
+	// $ANTLR start "WS"
+	private void mWS()
+	{
+		try
+		{
+			int _type = WS;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Interface.g3:172:4: ( ( ' ' | '\\t' | '\\f' | ( '\\r' )? '\\n' )+ )
+			// Language\\Interface.g3:172:4: ( ' ' | '\\t' | '\\f' | ( '\\r' )? '\\n' )+
+			{
+			// Language\\Interface.g3:172:4: ( ' ' | '\\t' | '\\f' | ( '\\r' )? '\\n' )+
+			int cnt7=0;
+			for ( ; ; )
+			{
+				int alt7=5;
+				switch ( input.LA(1) )
+				{
+				case ' ':
+					{
+					alt7=1;
+					}
+					break;
+				case '\t':
+					{
+					alt7=2;
+					}
+					break;
+				case '\f':
+					{
+					alt7=3;
+					}
+					break;
+				case '\n':
+				case '\r':
+					{
+					alt7=4;
+					}
+					break;
+
+				}
+
+				switch ( alt7 )
+				{
+				case 1:
+					// Language\\Interface.g3:172:6: ' '
+					{
+					Match(' ');
+
+					}
+					break;
+				case 2:
+					// Language\\Interface.g3:173:5: '\\t'
+					{
+					Match('\t');
+
+					}
+					break;
+				case 3:
+					// Language\\Interface.g3:174:5: '\\f'
+					{
+					Match('\f');
+
+					}
+					break;
+				case 4:
+					// Language\\Interface.g3:175:5: ( '\\r' )? '\\n'
+					{
+					// Language\\Interface.g3:175:5: ( '\\r' )?
+					int alt6=2;
+					int LA6_0 = input.LA(1);
+
+					if ( (LA6_0=='\r') )
+					{
+						alt6=1;
+					}
+					switch ( alt6 )
+					{
+					case 1:
+						// Language\\Interface.g3:175:6: '\\r'
+						{
+						Match('\r');
+
+						}
+						break;
+
+					}
+
+					Match('\n');
+
+					}
+					break;
+
+				default:
+					if ( cnt7 >= 1 )
+						goto loop7;
+
+					EarlyExitException eee7 = new EarlyExitException( 7, input );
+					throw eee7;
+				}
+				cnt7++;
+			}
+			loop7:
+				;
+
+
+			 _channel = HIDDEN;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "WS"
+
+	public override void mTokens()
+	{
+		// Language\\Interface.g3:1:10: ( T__13 | T__14 | ID | LPAREN | RPAREN | COMMA | SEMI | COLON | SL_COMMENT | ML_COMMENT | WS )
+		int alt8=11;
+		alt8 = dfa8.Predict(input);
+		switch ( alt8 )
+		{
+		case 1:
+			// Language\\Interface.g3:1:10: T__13
+			{
+			mT__13();
+
+			}
+			break;
+		case 2:
+			// Language\\Interface.g3:1:16: T__14
+			{
+			mT__14();
+
+			}
+			break;
+		case 3:
+			// Language\\Interface.g3:1:22: ID
+			{
+			mID();
+
+			}
+			break;
+		case 4:
+			// Language\\Interface.g3:1:25: LPAREN
+			{
+			mLPAREN();
+
+			}
+			break;
+		case 5:
+			// Language\\Interface.g3:1:32: RPAREN
+			{
+			mRPAREN();
+
+			}
+			break;
+		case 6:
+			// Language\\Interface.g3:1:39: COMMA
+			{
+			mCOMMA();
+
+			}
+			break;
+		case 7:
+			// Language\\Interface.g3:1:45: SEMI
+			{
+			mSEMI();
+
+			}
+			break;
+		case 8:
+			// Language\\Interface.g3:1:50: COLON
+			{
+			mCOLON();
+
+			}
+			break;
+		case 9:
+			// Language\\Interface.g3:1:56: SL_COMMENT
+			{
+			mSL_COMMENT();
+
+			}
+			break;
+		case 10:
+			// Language\\Interface.g3:1:67: ML_COMMENT
+			{
+			mML_COMMENT();
+
+			}
+			break;
+		case 11:
+			// Language\\Interface.g3:1:78: WS
+			{
+			mWS();
+
+			}
+			break;
+
+		}
+
+	}
+
+
+	#region DFA
+	DFA8 dfa8;
+
+	protected override void InitDFAs()
+	{
+		base.InitDFAs();
+		dfa8 = new DFA8( this );
+	}
+
+	class DFA8 : DFA
+	{
+
+		const string DFA8_eotS =
+			"\x1\xFFFF\x2\x3\x8\xFFFF\x2\x3\x2\xFFFF\xB\x3\x1\x1C\x1\x1D\x2\xFFFF";
+		const string DFA8_eofS =
+			"\x1E\xFFFF";
+		const string DFA8_minS =
+			"\x1\x9\x1\x6E\x1\x70\x6\xFFFF\x1\x2A\x1\xFFFF\x2\x74\x2\xFFFF\x1\x65"+
+			"\x1\x69\x1\x72\x1\x6F\x1\x66\x1\x6E\x2\x61\x1\x63\x1\x6C\x1\x65\x2\x2D"+
+			"\x2\xFFFF";
+		const string DFA8_maxS =
+			"\x1\x7A\x1\x6E\x1\x70\x6\xFFFF\x1\x2F\x1\xFFFF\x2\x74\x2\xFFFF\x1\x65"+
+			"\x1\x69\x1\x72\x1\x6F\x1\x66\x1\x6E\x2\x61\x1\x63\x1\x6C\x1\x65\x2\x7A"+
+			"\x2\xFFFF";
+		const string DFA8_acceptS =
+			"\x3\xFFFF\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1\xFFFF\x1\xB\x2\xFFFF"+
+			"\x1\x9\x1\xA\xD\xFFFF\x1\x2\x1\x1";
+		const string DFA8_specialS =
+			"\x1E\xFFFF}>";
+		static readonly string[] DFA8_transitionS =
+			{
+				"\x2\xA\x1\xFFFF\x2\xA\x12\xFFFF\x1\xA\x7\xFFFF\x1\x4\x1\x5\x2\xFFFF"+
+				"\x1\x6\x2\xFFFF\x1\x9\xA\xFFFF\x1\x8\x1\x7\x5\xFFFF\x1A\x3\x4\xFFFF"+
+				"\x1\x3\x1\xFFFF\x8\x3\x1\x1\x5\x3\x1\x2\xB\x3",
+				"\x1\xB",
+				"\x1\xC",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"\x1\xE\x4\xFFFF\x1\xD",
+				"",
+				"\x1\xF",
+				"\x1\x10",
+				"",
+				"",
+				"\x1\x11",
+				"\x1\x12",
+				"\x1\x13",
+				"\x1\x14",
+				"\x1\x15",
+				"\x1\x16",
+				"\x1\x17",
+				"\x1\x18",
+				"\x1\x19",
+				"\x1\x1A",
+				"\x1\x1B",
+				"\x1\x3\x2\xFFFF\xA\x3\x7\xFFFF\x1A\x3\x4\xFFFF\x1\x3\x1\xFFFF\x1A\x3",
+				"\x1\x3\x2\xFFFF\xA\x3\x7\xFFFF\x1A\x3\x4\xFFFF\x1\x3\x1\xFFFF\x1A\x3",
+				"",
+				""
+			};
+
+		static readonly short[] DFA8_eot = DFA.UnpackEncodedString(DFA8_eotS);
+		static readonly short[] DFA8_eof = DFA.UnpackEncodedString(DFA8_eofS);
+		static readonly char[] DFA8_min = DFA.UnpackEncodedStringToUnsignedChars(DFA8_minS);
+		static readonly char[] DFA8_max = DFA.UnpackEncodedStringToUnsignedChars(DFA8_maxS);
+		static readonly short[] DFA8_accept = DFA.UnpackEncodedString(DFA8_acceptS);
+		static readonly short[] DFA8_special = DFA.UnpackEncodedString(DFA8_specialS);
+		static readonly short[][] DFA8_transition;
+
+		static DFA8()
+		{
+			int numStates = DFA8_transitionS.Length;
+			DFA8_transition = new short[numStates][];
+			for ( int i=0; i < numStates; i++ )
+			{
+				DFA8_transition[i] = DFA.UnpackEncodedString(DFA8_transitionS[i]);
+			}
+		}
+
+		public DFA8( BaseRecognizer recognizer )
+		{
+			this.recognizer = recognizer;
+			this.decisionNumber = 8;
+			this.eot = DFA8_eot;
+			this.eof = DFA8_eof;
+			this.min = DFA8_min;
+			this.max = DFA8_max;
+			this.accept = DFA8_accept;
+			this.special = DFA8_special;
+			this.transition = DFA8_transition;
+		}
+		public override string GetDescription()
+		{
+			return "1:0: Tokens : ( T__13 | T__14 | ID | LPAREN | RPAREN | COMMA | SEMI | COLON | SL_COMMENT | ML_COMMENT | WS );";
+		}
+	}
+
+
+	#endregion
+
+}
+
+} // namespace Antlr3.ST.Language
diff --git a/Antlr3.StringTemplate/Language/InterfaceLexerHelper.cs b/Antlr3.StringTemplate/Language/InterfaceLexerHelper.cs
new file mode 100644
index 0000000..1a2b9a5
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/InterfaceLexerHelper.cs
@@ -0,0 +1,31 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Grammar conversion to ANTLR v3 and C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *	notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	notice, this list of conditions and the following disclaimer in the
+ *	documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *	derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
diff --git a/Antlr3.StringTemplate/Language/InterfaceParser.cs b/Antlr3.StringTemplate/Language/InterfaceParser.cs
new file mode 100644
index 0000000..637a573
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/InterfaceParser.cs
@@ -0,0 +1,354 @@
+// $ANTLR 3.1.2 Language\\Interface.g3 2009-03-07 08:51:17
+
+// The variable 'variable' is assigned but its value is never used.
+#pragma warning disable 219
+// Unreachable code detected.
+#pragma warning disable 162
+
+
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+using System.Collections.Generic;
+using Antlr.Runtime;
+using Stack = System.Collections.Generic.Stack<object>;
+using List = System.Collections.IList;
+using ArrayList = System.Collections.Generic.List<object>;
+
+namespace Antlr3.ST.Language
+{
+public partial class InterfaceParser : Parser
+{
+	public static readonly string[] tokenNames = new string[] {
+		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "COLON", "COMMA", "ID", "LPAREN", "ML_COMMENT", "RPAREN", "SEMI", "SL_COMMENT", "WS", "'interface'", "'optional'"
+	};
+	public const int EOF=-1;
+	public const int T__13=13;
+	public const int T__14=14;
+	public const int COLON=4;
+	public const int COMMA=5;
+	public const int ID=6;
+	public const int LPAREN=7;
+	public const int ML_COMMENT=8;
+	public const int RPAREN=9;
+	public const int SEMI=10;
+	public const int SL_COMMENT=11;
+	public const int WS=12;
+
+	// delegates
+	// delegators
+
+	public InterfaceParser( ITokenStream input )
+		: this( input, new RecognizerSharedState() )
+	{
+	}
+	public InterfaceParser( ITokenStream input, RecognizerSharedState state )
+		: base( input, state )
+	{
+	}
+
+
+	public override string[] GetTokenNames() { return InterfaceParser.tokenNames; }
+	public override string GrammarFileName { get { return "Language\\Interface.g3"; } }
+
+
+	#region Rules
+
+	// $ANTLR start "groupInterface"
+	// Language\\Interface.g3:113:0: public groupInterface[StringTemplateGroupInterface groupI] : 'interface' name= ID SEMI ( template[groupI] )+ EOF ;
+	public void groupInterface( StringTemplateGroupInterface groupI )
+	{
+		IToken name=null;
+
+
+			this.groupI = groupI;
+
+		try
+		{
+			// Language\\Interface.g3:118:4: ( 'interface' name= ID SEMI ( template[groupI] )+ EOF )
+			// Language\\Interface.g3:118:4: 'interface' name= ID SEMI ( template[groupI] )+ EOF
+			{
+			Match(input,13,Follow._13_in_groupInterface67);
+			name=(IToken)Match(input,ID,Follow._ID_in_groupInterface71);
+			groupI.setName((name!=null?name.Text:null));
+			Match(input,SEMI,Follow._SEMI_in_groupInterface75);
+			// Language\\Interface.g3:119:3: ( template[groupI] )+
+			int cnt1=0;
+			for ( ; ; )
+			{
+				int alt1=2;
+				int LA1_0 = input.LA(1);
+
+				if ( (LA1_0==ID||LA1_0==14) )
+				{
+					alt1=1;
+				}
+
+
+				switch ( alt1 )
+				{
+				case 1:
+					// Language\\Interface.g3:119:5: template[groupI]
+					{
+					PushFollow(Follow._template_in_groupInterface81);
+					template(groupI);
+
+					state._fsp--;
+
+
+					}
+					break;
+
+				default:
+					if ( cnt1 >= 1 )
+						goto loop1;
+
+					EarlyExitException eee1 = new EarlyExitException( 1, input );
+					throw eee1;
+				}
+				cnt1++;
+			}
+			loop1:
+				;
+
+
+			Match(input,EOF,Follow._EOF_in_groupInterface89);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "groupInterface"
+
+
+	// $ANTLR start "template"
+	// Language\\Interface.g3:124:0: template[StringTemplateGroupInterface groupI] : (opt= 'optional' )? name= ID LPAREN (formalArgs= args )? RPAREN SEMI ;
+	private void template( StringTemplateGroupInterface groupI )
+	{
+		IToken opt=null;
+		IToken name=null;
+		System.Collections.Generic.SortedList<string, FormalArgument> formalArgs = default(System.Collections.Generic.SortedList<string, FormalArgument>);
+
+
+			string templateName = null;
+
+		try
+		{
+			// Language\\Interface.g3:129:4: ( (opt= 'optional' )? name= ID LPAREN (formalArgs= args )? RPAREN SEMI )
+			// Language\\Interface.g3:129:4: (opt= 'optional' )? name= ID LPAREN (formalArgs= args )? RPAREN SEMI
+			{
+			// Language\\Interface.g3:129:4: (opt= 'optional' )?
+			int alt2=2;
+			int LA2_0 = input.LA(1);
+
+			if ( (LA2_0==14) )
+			{
+				alt2=1;
+			}
+			switch ( alt2 )
+			{
+			case 1:
+				// Language\\Interface.g3:129:5: opt= 'optional'
+				{
+				opt=(IToken)Match(input,14,Follow._14_in_template110);
+
+				}
+				break;
+
+			}
+
+			name=(IToken)Match(input,ID,Follow._ID_in_template116);
+			Match(input,LPAREN,Follow._LPAREN_in_template118);
+			// Language\\Interface.g3:129:37: (formalArgs= args )?
+			int alt3=2;
+			int LA3_0 = input.LA(1);
+
+			if ( (LA3_0==ID) )
+			{
+				alt3=1;
+			}
+			switch ( alt3 )
+			{
+			case 1:
+				// Language\\Interface.g3:129:38: formalArgs= args
+				{
+				PushFollow(Follow._args_in_template123);
+				formalArgs=args();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			Match(input,RPAREN,Follow._RPAREN_in_template127);
+			Match(input,SEMI,Follow._SEMI_in_template129);
+
+						templateName = (name!=null?name.Text:null);
+						groupI.defineTemplate( templateName, formalArgs ?? new System.Collections.Generic.SortedList<string, FormalArgument>(), opt!=null );
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "template"
+
+
+	// $ANTLR start "args"
+	// Language\\Interface.g3:136:0: args returns [System.Collections.Generic.SortedList<string, FormalArgument> args] : a= ID ( COMMA b= ID )* ;
+	private System.Collections.Generic.SortedList<string, FormalArgument> args(  )
+	{
+
+		System.Collections.Generic.SortedList<string, FormalArgument> args = default(System.Collections.Generic.SortedList<string, FormalArgument>);
+
+		IToken a=null;
+		IToken b=null;
+
+
+			args = new System.Collections.Generic.SortedList<string, FormalArgument>();
+
+		try
+		{
+			// Language\\Interface.g3:141:4: (a= ID ( COMMA b= ID )* )
+			// Language\\Interface.g3:141:4: a= ID ( COMMA b= ID )*
+			{
+			a=(IToken)Match(input,ID,Follow._ID_in_args154);
+			args[(a!=null?a.Text:null)] = new FormalArgument((a!=null?a.Text:null));
+			// Language\\Interface.g3:142:3: ( COMMA b= ID )*
+			for ( ; ; )
+			{
+				int alt4=2;
+				int LA4_0 = input.LA(1);
+
+				if ( (LA4_0==COMMA) )
+				{
+					alt4=1;
+				}
+
+
+				switch ( alt4 )
+				{
+				case 1:
+					// Language\\Interface.g3:142:5: COMMA b= ID
+					{
+					Match(input,COMMA,Follow._COMMA_in_args162);
+					b=(IToken)Match(input,ID,Follow._ID_in_args166);
+					args[(b!=null?b.Text:null)] = new FormalArgument((b!=null?b.Text:null));
+
+					}
+					break;
+
+				default:
+					goto loop4;
+				}
+			}
+
+			loop4:
+				;
+
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return args;
+	}
+	// $ANTLR end "args"
+	#endregion
+
+	// Delegated rules
+
+	#region Synpreds
+	#endregion
+
+	#region DFA
+
+	protected override void InitDFAs()
+	{
+		base.InitDFAs();
+	}
+
+	#endregion
+
+	#region Follow Sets
+	public static class Follow
+	{
+		public static readonly BitSet _13_in_groupInterface67 = new BitSet(new ulong[]{0x40UL});
+		public static readonly BitSet _ID_in_groupInterface71 = new BitSet(new ulong[]{0x400UL});
+		public static readonly BitSet _SEMI_in_groupInterface75 = new BitSet(new ulong[]{0x4040UL});
+		public static readonly BitSet _template_in_groupInterface81 = new BitSet(new ulong[]{0x4040UL});
+		public static readonly BitSet _EOF_in_groupInterface89 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _14_in_template110 = new BitSet(new ulong[]{0x40UL});
+		public static readonly BitSet _ID_in_template116 = new BitSet(new ulong[]{0x80UL});
+		public static readonly BitSet _LPAREN_in_template118 = new BitSet(new ulong[]{0x240UL});
+		public static readonly BitSet _args_in_template123 = new BitSet(new ulong[]{0x200UL});
+		public static readonly BitSet _RPAREN_in_template127 = new BitSet(new ulong[]{0x400UL});
+		public static readonly BitSet _SEMI_in_template129 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ID_in_args154 = new BitSet(new ulong[]{0x22UL});
+		public static readonly BitSet _COMMA_in_args162 = new BitSet(new ulong[]{0x40UL});
+		public static readonly BitSet _ID_in_args166 = new BitSet(new ulong[]{0x22UL});
+
+	}
+	#endregion
+}
+
+} // namespace Antlr3.ST.Language
diff --git a/Antlr3.StringTemplate/Language/InterfaceParserHelper.cs b/Antlr3.StringTemplate/Language/InterfaceParserHelper.cs
new file mode 100644
index 0000000..4b9db10
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/InterfaceParserHelper.cs
@@ -0,0 +1,57 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Grammar conversion to ANTLR v3 and C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *	notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	notice, this list of conditions and the following disclaimer in the
+ *	documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *	derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST.Language
+{
+    using System;
+    using Antlr.Runtime.JavaExtensions;
+
+    using RecognitionException = Antlr.Runtime.RecognitionException;
+
+    partial class InterfaceParser
+    {
+        protected StringTemplateGroupInterface groupI;
+
+        public override void ReportError( RecognitionException e )
+        {
+            if ( groupI != null )
+            {
+                groupI.error( "template group interface parse error", e );
+            }
+            else
+            {
+                Console.Error.WriteLine( "template group interface parse error: " + e );
+                e.printStackTrace( Console.Error );
+            }
+        }
+    }
+}
diff --git a/Antlr3.StringTemplate/Language/NewlineRef.cs b/Antlr3.StringTemplate/Language/NewlineRef.cs
new file mode 100644
index 0000000..89053bc
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/NewlineRef.cs
@@ -0,0 +1,47 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2003-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST.Language
+{
+    /** <summary>
+     *  Represents a newline.  Separated so I can do smart things like not
+     *  spitting out newlines when the only thing on a line is an attr expr.
+     *  </summary>
+     */
+    public class NewlineRef : StringRef
+    {
+        public NewlineRef( StringTemplate enclosingTemplate, string str )
+            : base( enclosingTemplate, str )
+        {
+        }
+    }
+}
diff --git a/Antlr3.StringTemplate/Language/StringRef.cs b/Antlr3.StringTemplate/Language/StringRef.cs
new file mode 100644
index 0000000..c430130
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/StringRef.cs
@@ -0,0 +1,63 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2003-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST.Language
+{
+    /** <summary>Represents a chunk of just simple text to spit out; nothing to "evaluate"</summary> */
+    public class StringRef : Expr
+    {
+        string str;
+
+        public StringRef( StringTemplate enclosingTemplate, string str )
+            : base( enclosingTemplate )
+        {
+            this.str = str;
+        }
+
+        /** <summary>
+         *  Just print out the string; no reference to self because this
+         *  is a literal--not sensitive to attribute values.  These strings
+         *  never wrap because they are not part of an &lt;...> expression.
+         *  &lt;"foo"; wrap="\n"> should wrap though if necessary.
+         *  </summary>
+         */
+        public override int write( StringTemplate self, IStringTemplateWriter writer )
+        {
+            return writer.write( str ?? string.Empty );
+        }
+
+        public override string ToString()
+        {
+            return str ?? string.Empty;
+        }
+    }
+}
diff --git a/Antlr3.StringTemplate/Language/StringTemplateAST.cs b/Antlr3.StringTemplate/Language/StringTemplateAST.cs
new file mode 100644
index 0000000..a3d05b1
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/StringTemplateAST.cs
@@ -0,0 +1,81 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2003-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST.Language
+{
+    using CommonToken = Antlr.Runtime.CommonToken;
+    using CommonTree = Antlr.Runtime.Tree.CommonTree;
+    using IToken = Antlr.Runtime.IToken;
+    using ITree = Antlr.Runtime.Tree.ITree;
+
+    public class StringTemplateAST : CommonTree
+    {
+        protected StringTemplate st = null; // track template for ANONYMOUS blocks
+
+        public StringTemplateAST()
+        {
+        }
+
+        public StringTemplateAST( int type, string text )
+            : base( new CommonToken( type, text ) )
+        {
+        }
+
+        public StringTemplateAST( IToken payload )
+            : base( payload )
+        {
+        }
+
+        public StringTemplateAST( StringTemplateAST tree )
+            : base( tree )
+        {
+            st = tree.st;
+        }
+
+        public StringTemplate StringTemplate
+        {
+            get
+            {
+                return st;
+            }
+            set
+            {
+                st = value;
+            }
+        }
+
+        public override ITree DupNode()
+        {
+            return new StringTemplateAST( this );
+        }
+    }
+}
diff --git a/Antlr3.StringTemplate/Language/StringTemplateToken.cs b/Antlr3.StringTemplate/Language/StringTemplateToken.cs
new file mode 100644
index 0000000..94eebc7
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/StringTemplateToken.cs
@@ -0,0 +1,67 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2003-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST.Language
+{
+    using CommonToken = Antlr.Runtime.CommonToken;
+    using IList = System.Collections.IList;
+
+    public class StringTemplateToken : CommonToken
+    {
+        /** <summary>
+         *  Track any args for anonymous templates like
+         *  &lt;tokens,rules:{t,r | <t> then <r>}>
+         *  The lexer in action.g returns a single token ANONYMOUS_TEMPLATE
+         *  and so I need to have it parse args in the lexer and make them
+         *  available for when I build the anonymous template.
+         *  </summary>
+         */
+        public IList args;
+
+        public StringTemplateToken( int type, string text )
+            : base( type, text )
+        {
+        }
+
+        public StringTemplateToken( int type, string text, IList args )
+            : base( type, text )
+        {
+            this.args = args;
+        }
+
+        public override string ToString()
+        {
+            return base.ToString() + "; args=" + args;
+        }
+    }
+
+}
diff --git a/Antlr3.StringTemplate/Language/StringTemplateTreeAdaptor.cs b/Antlr3.StringTemplate/Language/StringTemplateTreeAdaptor.cs
new file mode 100644
index 0000000..977e0a4
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/StringTemplateTreeAdaptor.cs
@@ -0,0 +1,46 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2003-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using Antlr.Runtime.Tree;
+
+using IToken = Antlr.Runtime.IToken;
+
+namespace Antlr3.ST.Language
+{
+    public class StringTemplateTreeAdaptor : CommonTreeAdaptor
+    {
+        public override object Create( IToken payload )
+        {
+            return new StringTemplateAST( payload );
+        }
+    }
+}
diff --git a/Antlr3.StringTemplate/Language/Template.g3 b/Antlr3.StringTemplate/Language/Template.g3
new file mode 100644
index 0000000..bdb083e
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/Template.g3
@@ -0,0 +1,518 @@
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+grammar Template;
+
+options
+{
+	language=CSharp3;
+}
+
+@lexer::header
+{
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+}
+
+@parser::header
+{
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+using Antlr.Runtime.JavaExtensions;
+}
+
+@lexer::namespace {Antlr3.ST.Language}
+@parser::namespace {Antlr3.ST.Language}
+
+public
+template[StringTemplate self]
+@init
+{
+	this.self = self;
+}
+	:	(	s=LITERAL  {self.addChunk(new StringRef(self,$s.text));}
+		|	nl=NEWLINE
+			{
+				if ( input.LA(1)!=ELSE && input.LA(1)!=ENDIF )
+				{
+					self.addChunk(new NewlineRef(self,$nl.text));
+				}
+			}
+		|	action[self]
+		)*
+		EOF?
+	;
+
+action[StringTemplate self]
+	:	a=ACTION
+		{
+			string indent = ((ChunkToken)a).Indentation;
+			ASTExpr c = self.parseAction($a.text);
+			c.setIndentation(indent);
+			self.addChunk(c);
+		}
+
+	|	i=IF
+		{
+			ConditionalExpr c = (ConditionalExpr)self.parseAction($i.text);
+			// create and precompile the subtemplate
+			StringTemplate subtemplate = new StringTemplate(self.getGroup(), null);
+			subtemplate.setEnclosingInstance(self);
+			subtemplate.setName($i.text+"_subtemplate");
+			self.addChunk(c);
+		}
+
+		template[subtemplate] {if ( c!=null ) c.setSubtemplate(subtemplate);}
+
+		(	ei=ELSEIF
+			{
+				ASTExpr ec = self.parseAction($ei.text);
+				// create and precompile the subtemplate
+				StringTemplate elseIfSubtemplate = new StringTemplate(self.getGroup(), null);
+				elseIfSubtemplate.setEnclosingInstance(self);
+				elseIfSubtemplate.setName($ei.text+"_subtemplate");
+			}
+
+			template[elseIfSubtemplate]
+
+			{if ( c!=null ) c.addElseIfSubtemplate(ec, elseIfSubtemplate);}
+		)*
+
+		(	ELSE
+			{
+				// create and precompile the subtemplate
+				StringTemplate elseSubtemplate = new StringTemplate(self.getGroup(), null);
+				elseSubtemplate.setEnclosingInstance(self);
+				elseSubtemplate.setName("else_subtemplate");
+			}
+
+			template[elseSubtemplate]
+			{if ( c!=null ) c.setElseSubtemplate(elseSubtemplate);}
+		)?
+
+		ENDIF
+
+	|	rr=REGION_REF
+		{
+			// define implicit template and
+			// convert <@r()> to <region__enclosingTemplate__r()>
+			string regionName = $rr.text;
+			string mangledRef = null;
+			bool err = false;
+			// watch out for <@super.r()>; that does NOT def implicit region
+			// convert to <super.region__enclosingTemplate__r()>
+			if ( regionName.StartsWith("super.") )
+			{
+				//System.out.println("super region ref "+regionName);
+				string regionRef = regionName.substring("super.".Length,regionName.Length);
+				string templateScope = self.getGroup().getUnMangledTemplateName(self.getName());
+				StringTemplate scopeST = self.getGroup().lookupTemplate(templateScope);
+				if ( scopeST==null )
+				{
+					self.getGroup().error("reference to region within undefined template: "+templateScope);
+					err=true;
+				}
+				if ( !scopeST.containsRegionName(regionRef) )
+				{
+					self.getGroup().error("template "+templateScope+" has no region called "+regionRef);
+					err=true;
+				}
+				else
+				{
+					mangledRef = self.getGroup().getMangledRegionName(templateScope,regionRef);
+					mangledRef = "super."+mangledRef;
+				}
+			}
+			else
+			{
+				//System.out.println("region ref "+regionName);
+				StringTemplate regionST = self.getGroup().defineImplicitRegionTemplate(self,regionName);
+				mangledRef = regionST.getName();
+			}
+
+			if ( !err )
+			{
+				// treat as regular action: mangled template include
+				string indent = ((ChunkToken)$rr).Indentation;
+				ASTExpr c = self.parseAction(mangledRef+"()");
+				c.setIndentation(indent);
+				self.addChunk(c);
+			}
+		}
+
+	|	rd=REGION_DEF
+		{
+			string combinedNameTemplateStr = $rd.text;
+			int indexOfDefSymbol = combinedNameTemplateStr.IndexOf("::=");
+			if ( indexOfDefSymbol>=1 )
+			{
+				string regionName = combinedNameTemplateStr.substring(0,indexOfDefSymbol);
+				string template = combinedNameTemplateStr.substring(indexOfDefSymbol+3, combinedNameTemplateStr.Length);
+				StringTemplate regionST = self.getGroup().defineRegionTemplate(self,regionName,template,StringTemplate.REGION_EMBEDDED);
+				// treat as regular action: mangled template include
+				string indent = ((ChunkToken)$rd).Indentation;
+				ASTExpr c = self.parseAction(regionST.getName()+"()");
+				c.setIndentation(indent);
+				self.addChunk(c);
+			}
+			else
+			{
+				self.error("embedded region definition screwed up");
+			}
+		}
+	;
+
+//////////////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////////////
+// LEXER
+
+// these rules are for manually-set tokens
+fragment IF : ;
+fragment ELSEIF : ;
+fragment ELSE : ;
+fragment ENDIF : ;
+fragment REGION_DEF : ;
+fragment REGION_REF : ;
+
+NEWLINE
+	:	('\r')? '\n' {currentIndent=null;}
+	;
+
+ACTION
+@init
+{
+	int startCol = CharPositionInLine;
+	System.Text.StringBuilder builder = new System.Text.StringBuilder();
+	System.Text.StringBuilder buf = null;
+	string subtext = string.Empty;
+	char uc = '\0';
+	bool atLeft = false;
+	string t = null;
+}
+	:	(	options { k = 1; } :
+			('$\\') =>
+			// Match escapes not in a string like <\n\ufea5>
+			'$' (ESC_CHAR[out uc] {builder.Append(uc);} )+ '$'
+			{
+				Text = builder.ToString();
+				$type = LITERAL;
+			}
+		|	('$!') => COMMENT
+			{ $channel = HIDDEN; }
+		|	(	('$if' (' '|'(')) =>
+				'$if' (' ')* '(' exp=IF_EXPR ')$'
+				{
+					Text = "if(" + $exp.text + ")";
+					$type = TemplateParser.IF;
+				}
+				( ('\r')? '\n' )? // ignore any newline right after an IF
+			|	('$elseif' (' '|'(')) =>
+				'$elseif' (' ')* '(' exp=IF_EXPR ')$'
+				{
+					Text = "elseif(" + $exp.text + ")";
+					$type = TemplateParser.ELSEIF;
+				}
+				( ('\r')? '\n' )? // ignore any newline right after an IF
+			|	('$else$') =>
+				'$else$'
+				{
+					Text = "else";
+					$type = (TemplateParser.ELSE);
+				}
+				( ('\r')? '\n' )? // ignore any newline right after an ELSE
+			|	('$endif$') =>
+				'$endif$'
+				{
+					Text = "endif";
+					$type = TemplateParser.ENDIF;
+				}
+				( {startCol==0}? => ('\r')? '\n' )? // ignore after ENDIF if on line by itself
+
+			|	// match $@foo()$ => foo
+				// match $@foo$...$@end$ => foo::=...
+				('$@') =>
+				{
+					builder = new System.Text.StringBuilder();
+				}
+				'$@' ( ch=~('$'|'(') {builder.Append((char)$ch);} )+
+				{ t = builder.ToString(); }
+				(	'()$'
+					{
+						$type = TemplateParser.REGION_REF;
+					}
+				|	'$'
+					{
+						$type = TemplateParser.REGION_DEF;
+						builder.Append("::=");
+					}
+					( ('\r'|'\n') => ('\r')? '\n' )?
+					{atLeft = false;}
+					(	{!(upcomingAtEND(1) || ( input.LA(1) == '\n' && upcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && upcomingAtEND(3) ))}? =>
+						(	('\r'|'\n') => ('\r' {builder.Append('\r');})? '\n' {builder.Append('\n'); atLeft = true;}
+						|	ch=. {builder.Append((char)$ch); atLeft = false;}
+						)
+					)+
+					(	('\r'|'\n') => ('\r')? '\n' {atLeft = true;} )?
+					(	('$@end$') => '$@end$'
+					|	.	{self.error("missing region "+t+" $@end$ tag");}
+					)
+					(	{atLeft}? ('\r')? '\n' )?
+				)
+				{
+					Text = builder.ToString();
+				}
+			|	'$' EXPR[out subtext] '$'  // (Can't start with '!', which would mean comment)
+				{ Text = subtext; }
+			)
+			{
+				//ChunkToken t = new ChunkToken($type, $text, currentIndent);
+				//state.token = t;
+				state.token = new ChunkToken($type, $text, currentIndent);
+			}
+		)
+	;
+
+LITERAL
+@init
+{
+	int loopStartIndex = $text.Length;
+	int col = CharPositionInLine;
+	System.Text.StringBuilder builder = new System.Text.StringBuilder();
+}
+	:	(	'\\'
+			(	'$'				{builder.Append("$");}  // allow escaped delimiter
+			|	'\\'			{builder.Append("\\");} // always replace \\ with \
+			|	ch=~('$'|'\\')	{builder.Append("\\" + (char)$ch);}  // otherwise ignore escape char
+			)
+		|	ind=INDENT
+			{
+				loopStartIndex = builder.Length;
+				col = CharPositionInLine - $ind.text.Length;
+
+				builder.Append( $ind.text );
+				if ( col==0 && input.LA(1)=='$' )
+				{
+					// store indent in ASTExpr not in a literal
+					currentIndent=$ind.text;
+					//text.setLength(loopStartIndex); // reset length to wack text
+					builder.Length = loopStartIndex; //= $text.Substring( 0, loopStartIndex );
+				}
+				else
+				{
+					currentIndent=null;
+				}
+			}
+		|	ch=~('$'|'\r'|'\n'|'\\'|' '|'\t') {builder.Append((char)$ch);}
+		)+
+		{Text = builder.ToString();}
+		{if ($text.Length==0) {$channel = HIDDEN;}} // pure indent?
+	;
+
+fragment
+EXPR[out string _text]
+@init
+{
+	_text = string.Empty;
+	string subtext = string.Empty;
+	System.Text.StringBuilder builder = new System.Text.StringBuilder();
+}
+	:	(	ESC							{builder.Append($ESC.text);}
+		|	st=SUBTEMPLATE				{builder.Append($st.text);}
+		|	(	'='						{builder.Append('=');}
+			|	'+'						{builder.Append('+');}
+			)
+			(	TEMPLATE[out subtext]	{builder.Append(subtext);}
+			|	st=SUBTEMPLATE			{builder.Append($st.text);}
+			|	ch=~('"'|'<'|'{')		{builder.Append((char)$ch);}
+			)
+		|	ch=~('\\'|'{'|'='|'+'|'$')	{builder.Append((char)$ch);}
+		)+
+		{$_text = builder.ToString();}
+	;
+
+fragment
+TEMPLATE[out string _text]
+@init
+{
+	_text = string.Empty;
+	System.Text.StringBuilder builder = new System.Text.StringBuilder();
+}
+	:	'"'
+		{builder.Append('"');}
+		(	ESC						{builder.Append($ESC.text);}
+		|	ch=~('\\'|'"')	{builder.Append((char)$ch);}
+		)*
+		'"'
+		{
+			builder.Append('"');
+			$_text = builder.ToString();
+		}
+	|	'<<'
+		{
+			builder.Append("<<");
+		}
+	 	(	('\r'|'\n') => ('\r')? '\n'
+	 	)? // consume 1st \n
+		(	('\r'? '\n>>') => ('\r')? '\n'	// kill last \r\n
+		|	ch=. {builder.Append((char)$ch);}
+		)*
+		'>>'
+		{
+			builder.Append(">>");
+			$_text = builder.ToString();
+		}
+	;
+
+fragment
+IF_EXPR
+	:	(	ESC
+		|	SUBTEMPLATE
+		|	NESTED_PARENS
+		|	~('\\'|'{'|'('|')')
+		)+
+	;
+
+fragment
+ESC_CHAR[out char uc]
+@init
+{
+	$uc = '\0';
+}
+	:	'\\n' {$uc = '\n';}
+	|	'\\r' {$uc = '\r';}
+	|	'\\t' {$uc = '\t';}
+	|	'\\ ' {$uc = ' ';}
+	|	'\\u' a=HEX b=HEX c=HEX d=HEX
+		{$uc = (char)int.Parse($a.text+$b.text+$c.text+$d.text, System.Globalization.NumberStyles.AllowHexSpecifier);}
+	;
+
+fragment
+ESC
+	:	'\\' . // ('$'|'n'|'t'|'"'|'\''|':'|'{'|'}')
+	;
+
+fragment
+HEX
+	:	'0'..'9'|'A'..'F'|'a'..'f'
+	;
+
+fragment
+SUBTEMPLATE
+	:	'{'
+		(	SUBTEMPLATE
+		|	ESC
+		|	~('{'|'\\'|'}')
+		)*
+		'}'
+	;
+
+fragment
+NESTED_PARENS
+	:	'('
+		(	NESTED_PARENS
+		|	ESC
+		|	~('('|'\\'|')')
+		)+
+		')'
+	;
+
+fragment
+INDENT
+	:	(' ' | '\t')+
+	;
+
+fragment
+COMMENT
+@init
+{
+	int startCol = CharPositionInLine;
+}
+	:	'$!' .* '!$' ( {startCol==0}? => ('\r')? '\n' )?
+	;
diff --git a/Antlr3.StringTemplate/Language/TemplateLexer.cs b/Antlr3.StringTemplate/Language/TemplateLexer.cs
new file mode 100644
index 0000000..8c475c3
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/TemplateLexer.cs
@@ -0,0 +1,3470 @@
+// $ANTLR 3.1.2 Language\\Template.g3 2009-03-07 08:52:37
+
+// The variable 'variable' is assigned but its value is never used.
+#pragma warning disable 219
+// Unreachable code detected.
+#pragma warning disable 162
+
+
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+using System.Collections.Generic;
+using Antlr.Runtime;
+using Stack = System.Collections.Generic.Stack<object>;
+using List = System.Collections.IList;
+using ArrayList = System.Collections.Generic.List<object>;
+using Map = System.Collections.IDictionary;
+using HashMap = System.Collections.Generic.Dictionary<object, object>;
+namespace Antlr3.ST.Language
+{
+public partial class TemplateLexer : Lexer
+{
+	public const int EOF=-1;
+	public const int ACTION=4;
+	public const int COMMENT=5;
+	public const int ELSE=6;
+	public const int ELSEIF=7;
+	public const int ENDIF=8;
+	public const int ESC=9;
+	public const int ESC_CHAR=10;
+	public const int EXPR=11;
+	public const int HEX=12;
+	public const int IF=13;
+	public const int IF_EXPR=14;
+	public const int INDENT=15;
+	public const int LITERAL=16;
+	public const int NESTED_PARENS=17;
+	public const int NEWLINE=18;
+	public const int REGION_DEF=19;
+	public const int REGION_REF=20;
+	public const int SUBTEMPLATE=21;
+	public const int TEMPLATE=22;
+
+    // delegates
+    // delegators
+
+	public TemplateLexer() {}
+	public TemplateLexer( ICharStream input )
+		: this( input, new RecognizerSharedState() )
+	{
+	}
+	public TemplateLexer( ICharStream input, RecognizerSharedState state )
+		: base( input, state )
+	{
+
+	}
+	public override string GrammarFileName { get { return "Language\\Template.g3"; } }
+
+	// $ANTLR start "IF"
+	private void mIF()
+	{
+		try
+		{
+			// Language\\Template.g3:257:15: ()
+			// Language\\Template.g3:257:15:
+			{
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "IF"
+
+	// $ANTLR start "ELSEIF"
+	private void mELSEIF()
+	{
+		try
+		{
+			// Language\\Template.g3:258:19: ()
+			// Language\\Template.g3:258:19:
+			{
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ELSEIF"
+
+	// $ANTLR start "ELSE"
+	private void mELSE()
+	{
+		try
+		{
+			// Language\\Template.g3:259:17: ()
+			// Language\\Template.g3:259:17:
+			{
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ELSE"
+
+	// $ANTLR start "ENDIF"
+	private void mENDIF()
+	{
+		try
+		{
+			// Language\\Template.g3:260:18: ()
+			// Language\\Template.g3:260:18:
+			{
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ENDIF"
+
+	// $ANTLR start "REGION_DEF"
+	private void mREGION_DEF()
+	{
+		try
+		{
+			// Language\\Template.g3:261:23: ()
+			// Language\\Template.g3:261:23:
+			{
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "REGION_DEF"
+
+	// $ANTLR start "REGION_REF"
+	private void mREGION_REF()
+	{
+		try
+		{
+			// Language\\Template.g3:262:23: ()
+			// Language\\Template.g3:262:23:
+			{
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "REGION_REF"
+
+	// $ANTLR start "NEWLINE"
+	private void mNEWLINE()
+	{
+		try
+		{
+			int _type = NEWLINE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Language\\Template.g3:265:4: ( ( '\\r' )? '\\n' )
+			// Language\\Template.g3:265:4: ( '\\r' )? '\\n'
+			{
+			// Language\\Template.g3:265:4: ( '\\r' )?
+			int alt1=2;
+			int LA1_0 = input.LA(1);
+
+			if ( (LA1_0=='\r') )
+			{
+				alt1=1;
+			}
+			switch ( alt1 )
+			{
+			case 1:
+				// Language\\Template.g3:265:5: '\\r'
+				{
+				Match('\r'); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+			Match('\n'); if (state.failed) return ;
+			if ( state.backtracking == 0 )
+			{
+				currentIndent=null;
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "NEWLINE"
+
+	// $ANTLR start "ACTION"
+	private void mACTION()
+	{
+		try
+		{
+			int _type = ACTION;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken exp=null;
+			int ch;
+
+
+				int startCol = CharPositionInLine;
+				System.Text.StringBuilder builder = new System.Text.StringBuilder();
+				System.Text.StringBuilder buf = null;
+				string subtext = string.Empty;
+				char uc = '\0';
+				bool atLeft = false;
+				string t = null;
+
+			// Language\\Template.g3:279:4: ( ( options {k=1; } :=> '$' ( ESC_CHAR[out uc] )+ '$' |=> COMMENT | (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' ) ) )
+			// Language\\Template.g3:279:4: ( options {k=1; } :=> '$' ( ESC_CHAR[out uc] )+ '$' |=> COMMENT | (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' ) )
+			{
+			// Language\\Template.g3:279:4: ( options {k=1; } :=> '$' ( ESC_CHAR[out uc] )+ '$' |=> COMMENT | (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' ) )
+			int alt26=3;
+			int LA26_0 = input.LA(1);
+
+			if ( (LA26_0=='$') )
+			{
+				int LA26_1 = input.LA(2);
+
+				if ( (synpred1_Template()) )
+				{
+					alt26=1;
+				}
+				else if ( (synpred2_Template()) )
+				{
+					alt26=2;
+				}
+				else if ( (true) )
+				{
+					alt26=3;
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return ;}
+					NoViableAltException nvae = new NoViableAltException("", 26, 1, input);
+
+					throw nvae;
+				}
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				NoViableAltException nvae = new NoViableAltException("", 26, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt26 )
+			{
+			case 1:
+				// Language\\Template.g3:280:4: => '$' ( ESC_CHAR[out uc] )+ '$'
+				{
+
+				Match('$'); if (state.failed) return ;
+				// Language\\Template.g3:282:8: ( ESC_CHAR[out uc] )+
+				int cnt2=0;
+				for ( ; ; )
+				{
+					int alt2=2;
+					int LA2_0 = input.LA(1);
+
+					if ( (LA2_0=='\\') )
+					{
+						alt2=1;
+					}
+
+
+					switch ( alt2 )
+					{
+					case 1:
+						// Language\\Template.g3:282:9: ESC_CHAR[out uc]
+						{
+						mESC_CHAR(out uc); if (state.failed) return ;
+						if ( state.backtracking == 0 )
+						{
+							builder.Append(uc);
+						}
+
+						}
+						break;
+
+					default:
+						if ( cnt2 >= 1 )
+							goto loop2;
+
+						if (state.backtracking>0) {state.failed=true; return ;}
+						EarlyExitException eee2 = new EarlyExitException( 2, input );
+						throw eee2;
+					}
+					cnt2++;
+				}
+				loop2:
+					;
+
+
+				Match('$'); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+
+									Text = builder.ToString();
+									_type = LITERAL;
+
+				}
+
+				}
+				break;
+			case 2:
+				// Language\\Template.g3:287:5: => COMMENT
+				{
+
+				mCOMMENT(); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+					 _channel = HIDDEN;
+				}
+
+				}
+				break;
+			case 3:
+				// Language\\Template.g3:289:5: (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' )
+				{
+				// Language\\Template.g3:289:5: (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' )
+				int alt25=6;
+				int LA25_0 = input.LA(1);
+
+				if ( (LA25_0=='$') )
+				{
+					int LA25_1 = input.LA(2);
+
+					if ( (synpred3_Template()) )
+					{
+						alt25=1;
+					}
+					else if ( (synpred4_Template()) )
+					{
+						alt25=2;
+					}
+					else if ( (synpred5_Template()) )
+					{
+						alt25=3;
+					}
+					else if ( (synpred6_Template()) )
+					{
+						alt25=4;
+					}
+					else if ( (synpred7_Template()) )
+					{
+						alt25=5;
+					}
+					else if ( (true) )
+					{
+						alt25=6;
+					}
+					else
+					{
+						if (state.backtracking>0) {state.failed=true; return ;}
+						NoViableAltException nvae = new NoViableAltException("", 25, 1, input);
+
+						throw nvae;
+					}
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return ;}
+					NoViableAltException nvae = new NoViableAltException("", 25, 0, input);
+
+					throw nvae;
+				}
+				switch ( alt25 )
+				{
+				case 1:
+					// Language\\Template.g3:289:7: => '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )?
+					{
+
+					Match("$if"); if (state.failed) return ;
+
+					// Language\\Template.g3:290:11: ( ' ' )*
+					for ( ; ; )
+					{
+						int alt3=2;
+						int LA3_0 = input.LA(1);
+
+						if ( (LA3_0==' ') )
+						{
+							alt3=1;
+						}
+
+
+						switch ( alt3 )
+						{
+						case 1:
+							// Language\\Template.g3:290:12: ' '
+							{
+							Match(' '); if (state.failed) return ;
+
+							}
+							break;
+
+						default:
+							goto loop3;
+						}
+					}
+
+					loop3:
+						;
+
+
+					Match('('); if (state.failed) return ;
+					int expStart206 = GetCharIndex();
+					mIF_EXPR(); if (state.failed) return ;
+					exp = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, expStart206, GetCharIndex()-1);
+					Match(")$"); if (state.failed) return ;
+
+					if ( state.backtracking == 0 )
+					{
+
+											Text = "if(" + (exp!=null?exp.Text:null) + ")";
+											_type = TemplateParser.IF;
+
+					}
+					// Language\\Template.g3:295:5: ( ( '\\r' )? '\\n' )?
+					int alt5=2;
+					int LA5_0 = input.LA(1);
+
+					if ( (LA5_0=='\n'||LA5_0=='\r') )
+					{
+						alt5=1;
+					}
+					switch ( alt5 )
+					{
+					case 1:
+						// Language\\Template.g3:295:7: ( '\\r' )? '\\n'
+						{
+						// Language\\Template.g3:295:7: ( '\\r' )?
+						int alt4=2;
+						int LA4_0 = input.LA(1);
+
+						if ( (LA4_0=='\r') )
+						{
+							alt4=1;
+						}
+						switch ( alt4 )
+						{
+						case 1:
+							// Language\\Template.g3:295:8: '\\r'
+							{
+							Match('\r'); if (state.failed) return ;
+
+							}
+							break;
+
+						}
+
+						Match('\n'); if (state.failed) return ;
+
+						}
+						break;
+
+					}
+
+
+					}
+					break;
+				case 2:
+					// Language\\Template.g3:296:6: => '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )?
+					{
+
+					Match("$elseif"); if (state.failed) return ;
+
+					// Language\\Template.g3:297:15: ( ' ' )*
+					for ( ; ; )
+					{
+						int alt6=2;
+						int LA6_0 = input.LA(1);
+
+						if ( (LA6_0==' ') )
+						{
+							alt6=1;
+						}
+
+
+						switch ( alt6 )
+						{
+						case 1:
+							// Language\\Template.g3:297:16: ' '
+							{
+							Match(' '); if (state.failed) return ;
+
+							}
+							break;
+
+						default:
+							goto loop6;
+						}
+					}
+
+					loop6:
+						;
+
+
+					Match('('); if (state.failed) return ;
+					int expStart265 = GetCharIndex();
+					mIF_EXPR(); if (state.failed) return ;
+					exp = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, expStart265, GetCharIndex()-1);
+					Match(")$"); if (state.failed) return ;
+
+					if ( state.backtracking == 0 )
+					{
+
+											Text = "elseif(" + (exp!=null?exp.Text:null) + ")";
+											_type = TemplateParser.ELSEIF;
+
+					}
+					// Language\\Template.g3:302:5: ( ( '\\r' )? '\\n' )?
+					int alt8=2;
+					int LA8_0 = input.LA(1);
+
+					if ( (LA8_0=='\n'||LA8_0=='\r') )
+					{
+						alt8=1;
+					}
+					switch ( alt8 )
+					{
+					case 1:
+						// Language\\Template.g3:302:7: ( '\\r' )? '\\n'
+						{
+						// Language\\Template.g3:302:7: ( '\\r' )?
+						int alt7=2;
+						int LA7_0 = input.LA(1);
+
+						if ( (LA7_0=='\r') )
+						{
+							alt7=1;
+						}
+						switch ( alt7 )
+						{
+						case 1:
+							// Language\\Template.g3:302:8: '\\r'
+							{
+							Match('\r'); if (state.failed) return ;
+
+							}
+							break;
+
+						}
+
+						Match('\n'); if (state.failed) return ;
+
+						}
+						break;
+
+					}
+
+
+					}
+					break;
+				case 3:
+					// Language\\Template.g3:303:6: => '$else$' ( ( '\\r' )? '\\n' )?
+					{
+
+					Match("$else$"); if (state.failed) return ;
+
+					if ( state.backtracking == 0 )
+					{
+
+											Text = "else";
+											_type = (TemplateParser.ELSE);
+
+					}
+					// Language\\Template.g3:309:5: ( ( '\\r' )? '\\n' )?
+					int alt10=2;
+					int LA10_0 = input.LA(1);
+
+					if ( (LA10_0=='\n'||LA10_0=='\r') )
+					{
+						alt10=1;
+					}
+					switch ( alt10 )
+					{
+					case 1:
+						// Language\\Template.g3:309:7: ( '\\r' )? '\\n'
+						{
+						// Language\\Template.g3:309:7: ( '\\r' )?
+						int alt9=2;
+						int LA9_0 = input.LA(1);
+
+						if ( (LA9_0=='\r') )
+						{
+							alt9=1;
+						}
+						switch ( alt9 )
+						{
+						case 1:
+							// Language\\Template.g3:309:8: '\\r'
+							{
+							Match('\r'); if (state.failed) return ;
+
+							}
+							break;
+
+						}
+
+						Match('\n'); if (state.failed) return ;
+
+						}
+						break;
+
+					}
+
+
+					}
+					break;
+				case 4:
+					// Language\\Template.g3:310:6: => '$endif$' ({...}? => ( '\\r' )? '\\n' )?
+					{
+
+					Match("$endif$"); if (state.failed) return ;
+
+					if ( state.backtracking == 0 )
+					{
+
+											Text = "endif";
+											_type = TemplateParser.ENDIF;
+
+					}
+					// Language\\Template.g3:316:5: ({...}? => ( '\\r' )? '\\n' )?
+					int alt12=2;
+					int LA12_0 = input.LA(1);
+
+					if ( (LA12_0=='\n'||LA12_0=='\r') && ((startCol==0)))
+					{
+						alt12=1;
+					}
+					switch ( alt12 )
+					{
+					case 1:
+						// Language\\Template.g3:316:7: {...}? => ( '\\r' )? '\\n'
+						{
+						if ( !((startCol==0)) )
+						{
+							if (state.backtracking>0) {state.failed=true; return ;}
+							throw new FailedPredicateException(input, "ACTION", "startCol==0");
+						}
+						// Language\\Template.g3:316:25: ( '\\r' )?
+						int alt11=2;
+						int LA11_0 = input.LA(1);
+
+						if ( (LA11_0=='\r') )
+						{
+							alt11=1;
+						}
+						switch ( alt11 )
+						{
+						case 1:
+							// Language\\Template.g3:316:26: '\\r'
+							{
+							Match('\r'); if (state.failed) return ;
+
+							}
+							break;
+
+						}
+
+						Match('\n'); if (state.failed) return ;
+
+						}
+						break;
+
+					}
+
+
+					}
+					break;
+				case 5:
+					// Language\\Template.g3:320:5: => '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? )
+					{
+
+					if ( state.backtracking == 0 )
+					{
+
+											builder = new System.Text.StringBuilder();
+
+					}
+					Match("$@"); if (state.failed) return ;
+
+					// Language\\Template.g3:324:10: (ch=~ ( '$' | '(' ) )+
+					int cnt13=0;
+					for ( ; ; )
+					{
+						int alt13=2;
+						int LA13_0 = input.LA(1);
+
+						if ( ((LA13_0>='\u0000' && LA13_0<='#')||(LA13_0>='%' && LA13_0<='\'')||(LA13_0>=')' && LA13_0<='\uFFFF')) )
+						{
+							alt13=1;
+						}
+
+
+						switch ( alt13 )
+						{
+						case 1:
+							// Language\\Template.g3:324:12: ch=~ ( '$' | '(' )
+							{
+							ch= input.LA(1);
+							input.Consume();
+							state.failed=false;
+							if ( state.backtracking == 0 )
+							{
+								builder.Append((char)ch);
+							}
+
+							}
+							break;
+
+						default:
+							if ( cnt13 >= 1 )
+								goto loop13;
+
+							if (state.backtracking>0) {state.failed=true; return ;}
+							EarlyExitException eee13 = new EarlyExitException( 13, input );
+							throw eee13;
+						}
+						cnt13++;
+					}
+					loop13:
+						;
+
+
+					if ( state.backtracking == 0 )
+					{
+						 t = builder.ToString();
+					}
+					// Language\\Template.g3:326:5: ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? )
+					int alt24=2;
+					int LA24_0 = input.LA(1);
+
+					if ( (LA24_0=='(') )
+					{
+						alt24=1;
+					}
+					else if ( (LA24_0=='$') )
+					{
+						alt24=2;
+					}
+					else
+					{
+						if (state.backtracking>0) {state.failed=true; return ;}
+						NoViableAltException nvae = new NoViableAltException("", 24, 0, input);
+
+						throw nvae;
+					}
+					switch ( alt24 )
+					{
+					case 1:
+						// Language\\Template.g3:326:7: '()$'
+						{
+						Match("()$"); if (state.failed) return ;
+
+						if ( state.backtracking == 0 )
+						{
+
+													_type = TemplateParser.REGION_REF;
+
+						}
+
+						}
+						break;
+					case 2:
+						// Language\\Template.g3:330:7: '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )?
+						{
+						Match('$'); if (state.failed) return ;
+						if ( state.backtracking == 0 )
+						{
+
+													_type = TemplateParser.REGION_DEF;
+													builder.Append("::=");
+
+						}
+						// Language\\Template.g3:335:6: (=> ( '\\r' )? '\\n' )?
+						int alt15=2;
+						int LA15_0 = input.LA(1);
+
+						if ( (LA15_0=='\r') )
+						{
+							int LA15_1 = input.LA(2);
+
+							if ( (LA15_1=='\n') )
+							{
+								int LA15_4 = input.LA(3);
+
+								if ( (synpred8_Template()) )
+								{
+									alt15=1;
+								}
+							}
+						}
+						else if ( (LA15_0=='\n') )
+						{
+							int LA15_2 = input.LA(2);
+
+							if ( (synpred8_Template()) )
+							{
+								alt15=1;
+							}
+						}
+						switch ( alt15 )
+						{
+						case 1:
+							// Language\\Template.g3:335:8: => ( '\\r' )? '\\n'
+							{
+
+							// Language\\Template.g3:335:23: ( '\\r' )?
+							int alt14=2;
+							int LA14_0 = input.LA(1);
+
+							if ( (LA14_0=='\r') )
+							{
+								alt14=1;
+							}
+							switch ( alt14 )
+							{
+							case 1:
+								// Language\\Template.g3:335:24: '\\r'
+								{
+								Match('\r'); if (state.failed) return ;
+
+								}
+								break;
+
+							}
+
+							Match('\n'); if (state.failed) return ;
+
+							}
+							break;
+
+						}
+
+						if ( state.backtracking == 0 )
+						{
+							atLeft = false;
+						}
+						// Language\\Template.g3:337:6: ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+
+						int cnt18=0;
+						for ( ; ; )
+						{
+							int alt18=2;
+							alt18 = dfa18.Predict(input);
+							switch ( alt18 )
+							{
+							case 1:
+								// Language\\Template.g3:337:8: {...}? => (=> ( '\\r' )? '\\n' |ch= . )
+								{
+								if ( !((!(upcomingAtEND(1) || ( input.LA(1) == '\n' && upcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && upcomingAtEND(3) )))) )
+								{
+									if (state.backtracking>0) {state.failed=true; return ;}
+									throw new FailedPredicateException(input, "ACTION", "!(upcomingAtEND(1) || ( input.LA(1) == '\\n' && upcomingAtEND(2) ) || ( input.LA(1) == '\\r' && input.LA(2) == '\\n' && upcomingAtEND(3) ))");
+								}
+								// Language\\Template.g3:338:7: (=> ( '\\r' )? '\\n' |ch= . )
+								int alt17=2;
+								int LA17_0 = input.LA(1);
+
+								if ( (LA17_0=='\r') )
+								{
+									int LA17_1 = input.LA(2);
+
+									if ( (synpred9_Template()) )
+									{
+										alt17=1;
+									}
+									else if ( (true) )
+									{
+										alt17=2;
+									}
+									else
+									{
+										if (state.backtracking>0) {state.failed=true; return ;}
+										NoViableAltException nvae = new NoViableAltException("", 17, 1, input);
+
+										throw nvae;
+									}
+								}
+								else if ( (LA17_0=='\n') )
+								{
+									int LA17_2 = input.LA(2);
+
+									if ( (synpred9_Template()) )
+									{
+										alt17=1;
+									}
+									else if ( (true) )
+									{
+										alt17=2;
+									}
+									else
+									{
+										if (state.backtracking>0) {state.failed=true; return ;}
+										NoViableAltException nvae = new NoViableAltException("", 17, 2, input);
+
+										throw nvae;
+									}
+								}
+								else if ( ((LA17_0>='\u0000' && LA17_0<='\t')||(LA17_0>='\u000B' && LA17_0<='\f')||(LA17_0>='\u000E' && LA17_0<='\uFFFF')) )
+								{
+									alt17=2;
+								}
+								else
+								{
+									if (state.backtracking>0) {state.failed=true; return ;}
+									NoViableAltException nvae = new NoViableAltException("", 17, 0, input);
+
+									throw nvae;
+								}
+								switch ( alt17 )
+								{
+								case 1:
+									// Language\\Template.g3:338:9: => ( '\\r' )? '\\n'
+									{
+
+									// Language\\Template.g3:338:24: ( '\\r' )?
+									int alt16=2;
+									int LA16_0 = input.LA(1);
+
+									if ( (LA16_0=='\r') )
+									{
+										alt16=1;
+									}
+									switch ( alt16 )
+									{
+									case 1:
+										// Language\\Template.g3:338:25: '\\r'
+										{
+										Match('\r'); if (state.failed) return ;
+										if ( state.backtracking == 0 )
+										{
+											builder.Append('\r');
+										}
+
+										}
+										break;
+
+									}
+
+									Match('\n'); if (state.failed) return ;
+									if ( state.backtracking == 0 )
+									{
+										builder.Append('\n'); atLeft = true;
+									}
+
+									}
+									break;
+								case 2:
+									// Language\\Template.g3:339:9: ch= .
+									{
+									ch = input.LA(1);
+									MatchAny(); if (state.failed) return ;
+									if ( state.backtracking == 0 )
+									{
+										builder.Append((char)ch); atLeft = false;
+									}
+
+									}
+									break;
+
+								}
+
+
+								}
+								break;
+
+							default:
+								if ( cnt18 >= 1 )
+									goto loop18;
+
+								if (state.backtracking>0) {state.failed=true; return ;}
+								EarlyExitException eee18 = new EarlyExitException( 18, input );
+								throw eee18;
+							}
+							cnt18++;
+						}
+						loop18:
+							;
+
+
+						// Language\\Template.g3:342:6: (=> ( '\\r' )? '\\n' )?
+						int alt20=2;
+						int LA20_0 = input.LA(1);
+
+						if ( (LA20_0=='\r') )
+						{
+							int LA20_1 = input.LA(2);
+
+							if ( (LA20_1=='\n') )
+							{
+								int LA20_4 = input.LA(3);
+
+								if ( (LA20_4=='$') && (synpred10_Template()))
+								{
+									alt20=1;
+								}
+								else if ( ((LA20_4>='\u0000' && LA20_4<='#')||(LA20_4>='%' && LA20_4<='\uFFFF')) && (synpred10_Template()))
+								{
+									alt20=1;
+								}
+							}
+						}
+						else if ( (LA20_0=='\n') )
+						{
+							int LA20_2 = input.LA(2);
+
+							if ( (LA20_2=='$') && (synpred10_Template()))
+							{
+								alt20=1;
+							}
+							else if ( (LA20_2=='\r') )
+							{
+								int LA20_6 = input.LA(3);
+
+								if ( (synpred10_Template()) )
+								{
+									alt20=1;
+								}
+							}
+							else if ( (LA20_2=='\n') )
+							{
+								int LA20_7 = input.LA(3);
+
+								if ( (synpred10_Template()) )
+								{
+									alt20=1;
+								}
+							}
+							else if ( ((LA20_2>='\u0000' && LA20_2<='\t')||(LA20_2>='\u000B' && LA20_2<='\f')||(LA20_2>='\u000E' && LA20_2<='#')||(LA20_2>='%' && LA20_2<='\uFFFF')) && (synpred10_Template()))
+							{
+								alt20=1;
+							}
+						}
+						switch ( alt20 )
+						{
+						case 1:
+							// Language\\Template.g3:342:8: => ( '\\r' )? '\\n'
+							{
+
+							// Language\\Template.g3:342:23: ( '\\r' )?
+							int alt19=2;
+							int LA19_0 = input.LA(1);
+
+							if ( (LA19_0=='\r') )
+							{
+								alt19=1;
+							}
+							switch ( alt19 )
+							{
+							case 1:
+								// Language\\Template.g3:342:24: '\\r'
+								{
+								Match('\r'); if (state.failed) return ;
+
+								}
+								break;
+
+							}
+
+							Match('\n'); if (state.failed) return ;
+							if ( state.backtracking == 0 )
+							{
+								atLeft = true;
+							}
+
+							}
+							break;
+
+						}
+
+						// Language\\Template.g3:343:6: (=> '$@end$' | . )
+						int alt21=2;
+						int LA21_0 = input.LA(1);
+
+						if ( (LA21_0=='$') )
+						{
+							int LA21_1 = input.LA(2);
+
+							if ( (LA21_1=='@') && (synpred11_Template()))
+							{
+								alt21=1;
+							}
+							else
+							{
+								alt21=2;}
+						}
+						else if ( ((LA21_0>='\u0000' && LA21_0<='#')||(LA21_0>='%' && LA21_0<='\uFFFF')) )
+						{
+							alt21=2;
+						}
+						else
+						{
+							if (state.backtracking>0) {state.failed=true; return ;}
+							NoViableAltException nvae = new NoViableAltException("", 21, 0, input);
+
+							throw nvae;
+						}
+						switch ( alt21 )
+						{
+						case 1:
+							// Language\\Template.g3:343:8: => '$@end$'
+							{
+
+							Match("$@end$"); if (state.failed) return ;
+
+
+							}
+							break;
+						case 2:
+							// Language\\Template.g3:344:8: .
+							{
+							MatchAny(); if (state.failed) return ;
+							if ( state.backtracking == 0 )
+							{
+								self.error("missing region "+t+" $@end$ tag");
+							}
+
+							}
+							break;
+
+						}
+
+						// Language\\Template.g3:346:6: ({...}? ( '\\r' )? '\\n' )?
+						int alt23=2;
+						int LA23_0 = input.LA(1);
+
+						if ( (LA23_0=='\n'||LA23_0=='\r') )
+						{
+							alt23=1;
+						}
+						switch ( alt23 )
+						{
+						case 1:
+							// Language\\Template.g3:346:8: {...}? ( '\\r' )? '\\n'
+							{
+							if ( !((atLeft)) )
+							{
+								if (state.backtracking>0) {state.failed=true; return ;}
+								throw new FailedPredicateException(input, "ACTION", "atLeft");
+							}
+							// Language\\Template.g3:346:18: ( '\\r' )?
+							int alt22=2;
+							int LA22_0 = input.LA(1);
+
+							if ( (LA22_0=='\r') )
+							{
+								alt22=1;
+							}
+							switch ( alt22 )
+							{
+							case 1:
+								// Language\\Template.g3:346:19: '\\r'
+								{
+								Match('\r'); if (state.failed) return ;
+
+								}
+								break;
+
+							}
+
+							Match('\n'); if (state.failed) return ;
+
+							}
+							break;
+
+						}
+
+
+						}
+						break;
+
+					}
+
+					if ( state.backtracking == 0 )
+					{
+
+											Text = builder.ToString();
+
+					}
+
+					}
+					break;
+				case 6:
+					// Language\\Template.g3:351:6: '$' EXPR[out subtext] '$'
+					{
+					Match('$'); if (state.failed) return ;
+					mEXPR(out subtext); if (state.failed) return ;
+					Match('$'); if (state.failed) return ;
+					if ( state.backtracking == 0 )
+					{
+						 Text = subtext;
+					}
+
+					}
+					break;
+
+				}
+
+				if ( state.backtracking == 0 )
+				{
+
+									//ChunkToken t = new ChunkToken(_type, Text, currentIndent);
+									//state.token = t;
+									state.token = new ChunkToken(_type, Text, currentIndent);
+
+				}
+
+				}
+				break;
+
+			}
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ACTION"
+
+	// $ANTLR start "LITERAL"
+	private void mLITERAL()
+	{
+		try
+		{
+			int _type = LITERAL;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken ind=null;
+			int ch;
+
+
+				int loopStartIndex = Text.Length;
+				int col = CharPositionInLine;
+				System.Text.StringBuilder builder = new System.Text.StringBuilder();
+
+			// Language\\Template.g3:369:4: ( ( '\\\\' ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) ) |ind= INDENT |ch=~ ( '$' | '\\r' | '\\n' | '\\\\' | ' ' | '\\t' ) )+ )
+			// Language\\Template.g3:369:4: ( '\\\\' ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) ) |ind= INDENT |ch=~ ( '$' | '\\r' | '\\n' | '\\\\' | ' ' | '\\t' ) )+
+			{
+			// Language\\Template.g3:369:4: ( '\\\\' ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) ) |ind= INDENT |ch=~ ( '$' | '\\r' | '\\n' | '\\\\' | ' ' | '\\t' ) )+
+			int cnt28=0;
+			for ( ; ; )
+			{
+				int alt28=4;
+				int LA28_0 = input.LA(1);
+
+				if ( (LA28_0=='\\') )
+				{
+					alt28=1;
+				}
+				else if ( (LA28_0=='\t'||LA28_0==' ') )
+				{
+					alt28=2;
+				}
+				else if ( ((LA28_0>='\u0000' && LA28_0<='\b')||(LA28_0>='\u000B' && LA28_0<='\f')||(LA28_0>='\u000E' && LA28_0<='\u001F')||(LA28_0>='!' && LA28_0<='#')||(LA28_0>='%' && LA28_0<='[')||(LA28_0>=']' && LA28_0<='\uFFFF')) )
+				{
+					alt28=3;
+				}
+
+
+				switch ( alt28 )
+				{
+				case 1:
+					// Language\\Template.g3:369:6: '\\\\' ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) )
+					{
+					Match('\\'); if (state.failed) return ;
+					// Language\\Template.g3:370:4: ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) )
+					int alt27=3;
+					int LA27_0 = input.LA(1);
+
+					if ( (LA27_0=='$') )
+					{
+						alt27=1;
+					}
+					else if ( (LA27_0=='\\') )
+					{
+						alt27=2;
+					}
+					else if ( ((LA27_0>='\u0000' && LA27_0<='#')||(LA27_0>='%' && LA27_0<='[')||(LA27_0>=']' && LA27_0<='\uFFFF')) )
+					{
+						alt27=3;
+					}
+					else
+					{
+						if (state.backtracking>0) {state.failed=true; return ;}
+						NoViableAltException nvae = new NoViableAltException("", 27, 0, input);
+
+						throw nvae;
+					}
+					switch ( alt27 )
+					{
+					case 1:
+						// Language\\Template.g3:370:6: '$'
+						{
+						Match('$'); if (state.failed) return ;
+						if ( state.backtracking == 0 )
+						{
+							builder.Append("$");
+						}
+
+						}
+						break;
+					case 2:
+						// Language\\Template.g3:371:6: '\\\\'
+						{
+						Match('\\'); if (state.failed) return ;
+						if ( state.backtracking == 0 )
+						{
+							builder.Append("\\");
+						}
+
+						}
+						break;
+					case 3:
+						// Language\\Template.g3:372:6: ch=~ ( '$' | '\\\\' )
+						{
+						ch= input.LA(1);
+						input.Consume();
+						state.failed=false;
+						if ( state.backtracking == 0 )
+						{
+							builder.Append("\\" + (char)ch);
+						}
+
+						}
+						break;
+
+					}
+
+
+					}
+					break;
+				case 2:
+					// Language\\Template.g3:374:5: ind= INDENT
+					{
+					int indStart759 = GetCharIndex();
+					mINDENT(); if (state.failed) return ;
+					ind = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, indStart759, GetCharIndex()-1);
+					if ( state.backtracking == 0 )
+					{
+
+										loopStartIndex = builder.Length;
+										col = CharPositionInLine - (ind!=null?ind.Text:null).Length;
+
+										builder.Append( (ind!=null?ind.Text:null) );
+										if ( col==0 && input.LA(1)=='$' )
+										{
+											// store indent in ASTExpr not in a literal
+											currentIndent=(ind!=null?ind.Text:null);
+											//text.setLength(loopStartIndex); // reset length to wack text
+											builder.Length = loopStartIndex; //= Text.Substring( 0, loopStartIndex );
+										}
+										else
+										{
+											currentIndent=null;
+										}
+
+					}
+
+					}
+					break;
+				case 3:
+					// Language\\Template.g3:392:5: ch=~ ( '$' | '\\r' | '\\n' | '\\\\' | ' ' | '\\t' )
+					{
+					ch= input.LA(1);
+					input.Consume();
+					state.failed=false;
+					if ( state.backtracking == 0 )
+					{
+						builder.Append((char)ch);
+					}
+
+					}
+					break;
+
+				default:
+					if ( cnt28 >= 1 )
+						goto loop28;
+
+					if (state.backtracking>0) {state.failed=true; return ;}
+					EarlyExitException eee28 = new EarlyExitException( 28, input );
+					throw eee28;
+				}
+				cnt28++;
+			}
+			loop28:
+				;
+
+
+			if ( state.backtracking == 0 )
+			{
+				Text = builder.ToString();
+			}
+			if ( state.backtracking == 0 )
+			{
+				if (Text.Length==0) {_channel = HIDDEN;}
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "LITERAL"
+
+	// $ANTLR start "EXPR"
+	private void mEXPR(out string _text)
+	{
+		try
+		{
+			IToken st=null;
+			IToken ESC1=null;
+			int ch;
+
+
+				_text = string.Empty;
+				string subtext = string.Empty;
+				System.Text.StringBuilder builder = new System.Text.StringBuilder();
+
+			// Language\\Template.g3:407:4: ( ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '$' ) )+ )
+			// Language\\Template.g3:407:4: ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '$' ) )+
+			{
+			// Language\\Template.g3:407:4: ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '$' ) )+
+			int cnt31=0;
+			for ( ; ; )
+			{
+				int alt31=5;
+				int LA31_0 = input.LA(1);
+
+				if ( (LA31_0=='\\') )
+				{
+					alt31=1;
+				}
+				else if ( (LA31_0=='{') )
+				{
+					alt31=2;
+				}
+				else if ( (LA31_0=='+'||LA31_0=='=') )
+				{
+					alt31=3;
+				}
+				else if ( ((LA31_0>='\u0000' && LA31_0<='#')||(LA31_0>='%' && LA31_0<='*')||(LA31_0>=',' && LA31_0<='<')||(LA31_0>='>' && LA31_0<='[')||(LA31_0>=']' && LA31_0<='z')||(LA31_0>='|' && LA31_0<='\uFFFF')) )
+				{
+					alt31=4;
+				}
+
+
+				switch ( alt31 )
+				{
+				case 1:
+					// Language\\Template.g3:407:6: ESC
+					{
+					int ESC1Start821 = GetCharIndex();
+					mESC(); if (state.failed) return ;
+					ESC1 = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, ESC1Start821, GetCharIndex()-1);
+					if ( state.backtracking == 0 )
+					{
+						builder.Append((ESC1!=null?ESC1.Text:null));
+					}
+
+					}
+					break;
+				case 2:
+					// Language\\Template.g3:408:5: st= SUBTEMPLATE
+					{
+					int stStart837 = GetCharIndex();
+					mSUBTEMPLATE(); if (state.failed) return ;
+					st = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, stStart837, GetCharIndex()-1);
+					if ( state.backtracking == 0 )
+					{
+						builder.Append((st!=null?st.Text:null));
+					}
+
+					}
+					break;
+				case 3:
+					// Language\\Template.g3:409:5: ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) )
+					{
+					// Language\\Template.g3:409:5: ( '=' | '+' )
+					int alt29=2;
+					int LA29_0 = input.LA(1);
+
+					if ( (LA29_0=='=') )
+					{
+						alt29=1;
+					}
+					else if ( (LA29_0=='+') )
+					{
+						alt29=2;
+					}
+					else
+					{
+						if (state.backtracking>0) {state.failed=true; return ;}
+						NoViableAltException nvae = new NoViableAltException("", 29, 0, input);
+
+						throw nvae;
+					}
+					switch ( alt29 )
+					{
+					case 1:
+						// Language\\Template.g3:409:7: '='
+						{
+						Match('='); if (state.failed) return ;
+						if ( state.backtracking == 0 )
+						{
+							builder.Append('=');
+						}
+
+						}
+						break;
+					case 2:
+						// Language\\Template.g3:410:6: '+'
+						{
+						Match('+'); if (state.failed) return ;
+						if ( state.backtracking == 0 )
+						{
+							builder.Append('+');
+						}
+
+						}
+						break;
+
+					}
+
+					// Language\\Template.g3:412:4: ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) )
+					int alt30=3;
+					int LA30_0 = input.LA(1);
+
+					if ( (LA30_0=='\"'||LA30_0=='<') )
+					{
+						alt30=1;
+					}
+					else if ( (LA30_0=='{') )
+					{
+						alt30=2;
+					}
+					else if ( ((LA30_0>='\u0000' && LA30_0<='!')||(LA30_0>='#' && LA30_0<=';')||(LA30_0>='=' && LA30_0<='z')||(LA30_0>='|' && LA30_0<='\uFFFF')) )
+					{
+						alt30=3;
+					}
+					else
+					{
+						if (state.backtracking>0) {state.failed=true; return ;}
+						NoViableAltException nvae = new NoViableAltException("", 30, 0, input);
+
+						throw nvae;
+					}
+					switch ( alt30 )
+					{
+					case 1:
+						// Language\\Template.g3:412:6: TEMPLATE[out subtext]
+						{
+						mTEMPLATE(out subtext); if (state.failed) return ;
+						if ( state.backtracking == 0 )
+						{
+							builder.Append(subtext);
+						}
+
+						}
+						break;
+					case 2:
+						// Language\\Template.g3:413:6: st= SUBTEMPLATE
+						{
+						int stStart895 = GetCharIndex();
+						mSUBTEMPLATE(); if (state.failed) return ;
+						st = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, stStart895, GetCharIndex()-1);
+						if ( state.backtracking == 0 )
+						{
+							builder.Append((st!=null?st.Text:null));
+						}
+
+						}
+						break;
+					case 3:
+						// Language\\Template.g3:414:6: ch=~ ( '\"' | '<' | '{' )
+						{
+						ch= input.LA(1);
+						input.Consume();
+						state.failed=false;
+						if ( state.backtracking == 0 )
+						{
+							builder.Append((char)ch);
+						}
+
+						}
+						break;
+
+					}
+
+
+					}
+					break;
+				case 4:
+					// Language\\Template.g3:416:5: ch=~ ( '\\\\' | '{' | '=' | '+' | '$' )
+					{
+					ch= input.LA(1);
+					input.Consume();
+					state.failed=false;
+					if ( state.backtracking == 0 )
+					{
+						builder.Append((char)ch);
+					}
+
+					}
+					break;
+
+				default:
+					if ( cnt31 >= 1 )
+						goto loop31;
+
+					if (state.backtracking>0) {state.failed=true; return ;}
+					EarlyExitException eee31 = new EarlyExitException( 31, input );
+					throw eee31;
+				}
+				cnt31++;
+			}
+			loop31:
+				;
+
+
+			if ( state.backtracking == 0 )
+			{
+				_text = builder.ToString();
+			}
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "EXPR"
+
+	// $ANTLR start "TEMPLATE"
+	private void mTEMPLATE(out string _text)
+	{
+		try
+		{
+			IToken ESC2=null;
+			int ch;
+
+
+				_text = string.Empty;
+				System.Text.StringBuilder builder = new System.Text.StringBuilder();
+
+			// Language\\Template.g3:428:4: ( '\"' ( ESC |ch=~ ( '\\\\' | '\"' ) )* '\"' | '<<' (=> ( '\\r' )? '\\n' )? (=> ( '\\r' )? '\\n' |ch= . )* '>>' )
+			int alt37=2;
+			int LA37_0 = input.LA(1);
+
+			if ( (LA37_0=='\"') )
+			{
+				alt37=1;
+			}
+			else if ( (LA37_0=='<') )
+			{
+				alt37=2;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				NoViableAltException nvae = new NoViableAltException("", 37, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt37 )
+			{
+			case 1:
+				// Language\\Template.g3:428:4: '\"' ( ESC |ch=~ ( '\\\\' | '\"' ) )* '\"'
+				{
+				Match('\"'); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+					builder.Append('"');
+				}
+				// Language\\Template.g3:430:3: ( ESC |ch=~ ( '\\\\' | '\"' ) )*
+				for ( ; ; )
+				{
+					int alt32=3;
+					int LA32_0 = input.LA(1);
+
+					if ( (LA32_0=='\\') )
+					{
+						alt32=1;
+					}
+					else if ( ((LA32_0>='\u0000' && LA32_0<='!')||(LA32_0>='#' && LA32_0<='[')||(LA32_0>=']' && LA32_0<='\uFFFF')) )
+					{
+						alt32=2;
+					}
+
+
+					switch ( alt32 )
+					{
+					case 1:
+						// Language\\Template.g3:430:5: ESC
+						{
+						int ESC2Start981 = GetCharIndex();
+						mESC(); if (state.failed) return ;
+						ESC2 = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, ESC2Start981, GetCharIndex()-1);
+						if ( state.backtracking == 0 )
+						{
+							builder.Append((ESC2!=null?ESC2.Text:null));
+						}
+
+						}
+						break;
+					case 2:
+						// Language\\Template.g3:431:5: ch=~ ( '\\\\' | '\"' )
+						{
+						ch= input.LA(1);
+						input.Consume();
+						state.failed=false;
+						if ( state.backtracking == 0 )
+						{
+							builder.Append((char)ch);
+						}
+
+						}
+						break;
+
+					default:
+						goto loop32;
+					}
+				}
+
+				loop32:
+					;
+
+
+				Match('\"'); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+
+								builder.Append('"');
+								_text = builder.ToString();
+
+				}
+
+				}
+				break;
+			case 2:
+				// Language\\Template.g3:438:4: '<<' (=> ( '\\r' )? '\\n' )? (=> ( '\\r' )? '\\n' |ch= . )* '>>'
+				{
+				Match("<<"); if (state.failed) return ;
+
+				if ( state.backtracking == 0 )
+				{
+
+								builder.Append("<<");
+
+				}
+				// Language\\Template.g3:442:4: (=> ( '\\r' )? '\\n' )?
+				int alt34=2;
+				int LA34_0 = input.LA(1);
+
+				if ( (LA34_0=='\r') )
+				{
+					int LA34_1 = input.LA(2);
+
+					if ( (LA34_1=='\n') )
+					{
+						int LA34_2 = input.LA(3);
+
+						if ( (synpred12_Template()) )
+						{
+							alt34=1;
+						}
+					}
+				}
+				else if ( (LA34_0=='\n') )
+				{
+					int LA34_2 = input.LA(2);
+
+					if ( (synpred12_Template()) )
+					{
+						alt34=1;
+					}
+				}
+				switch ( alt34 )
+				{
+				case 1:
+					// Language\\Template.g3:442:6: => ( '\\r' )? '\\n'
+					{
+
+					// Language\\Template.g3:442:21: ( '\\r' )?
+					int alt33=2;
+					int LA33_0 = input.LA(1);
+
+					if ( (LA33_0=='\r') )
+					{
+						alt33=1;
+					}
+					switch ( alt33 )
+					{
+					case 1:
+						// Language\\Template.g3:442:22: '\\r'
+						{
+						Match('\r'); if (state.failed) return ;
+
+						}
+						break;
+
+					}
+
+					Match('\n'); if (state.failed) return ;
+
+					}
+					break;
+
+				}
+
+				// Language\\Template.g3:444:3: (=> ( '\\r' )? '\\n' |ch= . )*
+				for ( ; ; )
+				{
+					int alt36=3;
+					int LA36_0 = input.LA(1);
+
+					if ( (LA36_0=='>') )
+					{
+						int LA36_1 = input.LA(2);
+
+						if ( (LA36_1=='>') )
+						{
+							int LA36_5 = input.LA(3);
+
+							if ( ((LA36_5>='\u0000' && LA36_5<='\uFFFF')) )
+							{
+								alt36=2;
+							}
+
+
+						}
+						else if ( ((LA36_1>='\u0000' && LA36_1<='=')||(LA36_1>='?' && LA36_1<='\uFFFF')) )
+						{
+							alt36=2;
+						}
+
+
+					}
+					else if ( (LA36_0=='\r') )
+					{
+						int LA36_2 = input.LA(2);
+
+						if ( (synpred13_Template()) )
+						{
+							alt36=1;
+						}
+						else if ( (true) )
+						{
+							alt36=2;
+						}
+
+
+					}
+					else if ( (LA36_0=='\n') )
+					{
+						int LA36_3 = input.LA(2);
+
+						if ( (synpred13_Template()) )
+						{
+							alt36=1;
+						}
+						else if ( (true) )
+						{
+							alt36=2;
+						}
+
+
+					}
+					else if ( ((LA36_0>='\u0000' && LA36_0<='\t')||(LA36_0>='\u000B' && LA36_0<='\f')||(LA36_0>='\u000E' && LA36_0<='=')||(LA36_0>='?' && LA36_0<='\uFFFF')) )
+					{
+						alt36=2;
+					}
+
+
+					switch ( alt36 )
+					{
+					case 1:
+						// Language\\Template.g3:444:5: => ( '\\r' )? '\\n'
+						{
+
+						// Language\\Template.g3:444:23: ( '\\r' )?
+						int alt35=2;
+						int LA35_0 = input.LA(1);
+
+						if ( (LA35_0=='\r') )
+						{
+							alt35=1;
+						}
+						switch ( alt35 )
+						{
+						case 1:
+							// Language\\Template.g3:444:24: '\\r'
+							{
+							Match('\r'); if (state.failed) return ;
+
+							}
+							break;
+
+						}
+
+						Match('\n'); if (state.failed) return ;
+
+						}
+						break;
+					case 2:
+						// Language\\Template.g3:445:5: ch= .
+						{
+						ch = input.LA(1);
+						MatchAny(); if (state.failed) return ;
+						if ( state.backtracking == 0 )
+						{
+							builder.Append((char)ch);
+						}
+
+						}
+						break;
+
+					default:
+						goto loop36;
+					}
+				}
+
+				loop36:
+					;
+
+
+				Match(">>"); if (state.failed) return ;
+
+				if ( state.backtracking == 0 )
+				{
+
+								builder.Append(">>");
+								_text = builder.ToString();
+
+				}
+
+				}
+				break;
+
+			}
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "TEMPLATE"
+
+	// $ANTLR start "IF_EXPR"
+	private void mIF_EXPR()
+	{
+		try
+		{
+			// Language\\Template.g3:456:4: ( ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+ )
+			// Language\\Template.g3:456:4: ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+
+			{
+			// Language\\Template.g3:456:4: ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+
+			int cnt38=0;
+			for ( ; ; )
+			{
+				int alt38=5;
+				int LA38_0 = input.LA(1);
+
+				if ( (LA38_0=='\\') )
+				{
+					alt38=1;
+				}
+				else if ( (LA38_0=='{') )
+				{
+					alt38=2;
+				}
+				else if ( (LA38_0=='(') )
+				{
+					alt38=3;
+				}
+				else if ( ((LA38_0>='\u0000' && LA38_0<='\'')||(LA38_0>='*' && LA38_0<='[')||(LA38_0>=']' && LA38_0<='z')||(LA38_0>='|' && LA38_0<='\uFFFF')) )
+				{
+					alt38=4;
+				}
+
+
+				switch ( alt38 )
+				{
+				case 1:
+					// Language\\Template.g3:456:6: ESC
+					{
+					mESC(); if (state.failed) return ;
+
+					}
+					break;
+				case 2:
+					// Language\\Template.g3:457:5: SUBTEMPLATE
+					{
+					mSUBTEMPLATE(); if (state.failed) return ;
+
+					}
+					break;
+				case 3:
+					// Language\\Template.g3:458:5: NESTED_PARENS
+					{
+					mNESTED_PARENS(); if (state.failed) return ;
+
+					}
+					break;
+				case 4:
+					// Language\\Template.g3:459:5: ~ ( '\\\\' | '{' | '(' | ')' )
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+
+				default:
+					if ( cnt38 >= 1 )
+						goto loop38;
+
+					if (state.backtracking>0) {state.failed=true; return ;}
+					EarlyExitException eee38 = new EarlyExitException( 38, input );
+					throw eee38;
+				}
+				cnt38++;
+			}
+			loop38:
+				;
+
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "IF_EXPR"
+
+	// $ANTLR start "ESC_CHAR"
+	private void mESC_CHAR(out char uc)
+	{
+		try
+		{
+			IToken a=null;
+			IToken b=null;
+			IToken c=null;
+			IToken d=null;
+
+
+				uc = '\0';
+
+			// Language\\Template.g3:469:4: ( '\\\\n' | '\\\\r' | '\\\\t' | '\\\\ ' | '\\\\u' a= HEX b= HEX c= HEX d= HEX )
+			int alt39=5;
+			int LA39_0 = input.LA(1);
+
+			if ( (LA39_0=='\\') )
+			{
+				switch ( input.LA(2) )
+				{
+				case 'n':
+					{
+					alt39=1;
+					}
+					break;
+				case 'r':
+					{
+					alt39=2;
+					}
+					break;
+				case 't':
+					{
+					alt39=3;
+					}
+					break;
+				case ' ':
+					{
+					alt39=4;
+					}
+					break;
+				case 'u':
+					{
+					alt39=5;
+					}
+					break;
+				default:
+					{
+						if (state.backtracking>0) {state.failed=true; return ;}
+						NoViableAltException nvae = new NoViableAltException("", 39, 1, input);
+
+						throw nvae;
+					}
+				}
+
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				NoViableAltException nvae = new NoViableAltException("", 39, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt39 )
+			{
+			case 1:
+				// Language\\Template.g3:469:4: '\\\\n'
+				{
+				Match("\\n"); if (state.failed) return ;
+
+				if ( state.backtracking == 0 )
+				{
+					uc = '\n';
+				}
+
+				}
+				break;
+			case 2:
+				// Language\\Template.g3:470:4: '\\\\r'
+				{
+				Match("\\r"); if (state.failed) return ;
+
+				if ( state.backtracking == 0 )
+				{
+					uc = '\r';
+				}
+
+				}
+				break;
+			case 3:
+				// Language\\Template.g3:471:4: '\\\\t'
+				{
+				Match("\\t"); if (state.failed) return ;
+
+				if ( state.backtracking == 0 )
+				{
+					uc = '\t';
+				}
+
+				}
+				break;
+			case 4:
+				// Language\\Template.g3:472:4: '\\\\ '
+				{
+				Match("\\ "); if (state.failed) return ;
+
+				if ( state.backtracking == 0 )
+				{
+					uc = ' ';
+				}
+
+				}
+				break;
+			case 5:
+				// Language\\Template.g3:473:4: '\\\\u' a= HEX b= HEX c= HEX d= HEX
+				{
+				Match("\\u"); if (state.failed) return ;
+
+				int aStart1192 = GetCharIndex();
+				mHEX(); if (state.failed) return ;
+				a = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, aStart1192, GetCharIndex()-1);
+				int bStart1196 = GetCharIndex();
+				mHEX(); if (state.failed) return ;
+				b = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, bStart1196, GetCharIndex()-1);
+				int cStart1200 = GetCharIndex();
+				mHEX(); if (state.failed) return ;
+				c = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, cStart1200, GetCharIndex()-1);
+				int dStart1204 = GetCharIndex();
+				mHEX(); if (state.failed) return ;
+				d = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, dStart1204, GetCharIndex()-1);
+				if ( state.backtracking == 0 )
+				{
+					uc = (char)int.Parse((a!=null?a.Text:null)+(b!=null?b.Text:null)+(c!=null?c.Text:null)+(d!=null?d.Text:null), System.Globalization.NumberStyles.AllowHexSpecifier);
+				}
+
+				}
+				break;
+
+			}
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ESC_CHAR"
+
+	// $ANTLR start "ESC"
+	private void mESC()
+	{
+		try
+		{
+			// Language\\Template.g3:479:4: ( '\\\\' . )
+			// Language\\Template.g3:479:4: '\\\\' .
+			{
+			Match('\\'); if (state.failed) return ;
+			MatchAny(); if (state.failed) return ;
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ESC"
+
+	// $ANTLR start "HEX"
+	private void mHEX()
+	{
+		try
+		{
+			// Language\\Template.g3:484:4: ( '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' )
+			// Language\\Template.g3:
+			{
+			if ( (input.LA(1)>='0' && input.LA(1)<='9')||(input.LA(1)>='A' && input.LA(1)<='F')||(input.LA(1)>='a' && input.LA(1)<='f') )
+			{
+				input.Consume();
+			state.failed=false;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				Recover(mse);
+				throw mse;}
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "HEX"
+
+	// $ANTLR start "SUBTEMPLATE"
+	private void mSUBTEMPLATE()
+	{
+		try
+		{
+			// Language\\Template.g3:489:4: ( '{' ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )* '}' )
+			// Language\\Template.g3:489:4: '{' ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )* '}'
+			{
+			Match('{'); if (state.failed) return ;
+			// Language\\Template.g3:490:3: ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )*
+			for ( ; ; )
+			{
+				int alt40=4;
+				int LA40_0 = input.LA(1);
+
+				if ( (LA40_0=='{') )
+				{
+					alt40=1;
+				}
+				else if ( (LA40_0=='\\') )
+				{
+					alt40=2;
+				}
+				else if ( ((LA40_0>='\u0000' && LA40_0<='[')||(LA40_0>=']' && LA40_0<='z')||LA40_0=='|'||(LA40_0>='~' && LA40_0<='\uFFFF')) )
+				{
+					alt40=3;
+				}
+
+
+				switch ( alt40 )
+				{
+				case 1:
+					// Language\\Template.g3:490:5: SUBTEMPLATE
+					{
+					mSUBTEMPLATE(); if (state.failed) return ;
+
+					}
+					break;
+				case 2:
+					// Language\\Template.g3:491:5: ESC
+					{
+					mESC(); if (state.failed) return ;
+
+					}
+					break;
+				case 3:
+					// Language\\Template.g3:492:5: ~ ( '{' | '\\\\' | '}' )
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+
+				default:
+					goto loop40;
+				}
+			}
+
+			loop40:
+				;
+
+
+			Match('}'); if (state.failed) return ;
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "SUBTEMPLATE"
+
+	// $ANTLR start "NESTED_PARENS"
+	private void mNESTED_PARENS()
+	{
+		try
+		{
+			// Language\\Template.g3:499:4: ( '(' ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+ ')' )
+			// Language\\Template.g3:499:4: '(' ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+ ')'
+			{
+			Match('('); if (state.failed) return ;
+			// Language\\Template.g3:500:3: ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+
+			int cnt41=0;
+			for ( ; ; )
+			{
+				int alt41=4;
+				int LA41_0 = input.LA(1);
+
+				if ( (LA41_0=='(') )
+				{
+					alt41=1;
+				}
+				else if ( (LA41_0=='\\') )
+				{
+					alt41=2;
+				}
+				else if ( ((LA41_0>='\u0000' && LA41_0<='\'')||(LA41_0>='*' && LA41_0<='[')||(LA41_0>=']' && LA41_0<='\uFFFF')) )
+				{
+					alt41=3;
+				}
+
+
+				switch ( alt41 )
+				{
+				case 1:
+					// Language\\Template.g3:500:5: NESTED_PARENS
+					{
+					mNESTED_PARENS(); if (state.failed) return ;
+
+					}
+					break;
+				case 2:
+					// Language\\Template.g3:501:5: ESC
+					{
+					mESC(); if (state.failed) return ;
+
+					}
+					break;
+				case 3:
+					// Language\\Template.g3:502:5: ~ ( '(' | '\\\\' | ')' )
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+
+				default:
+					if ( cnt41 >= 1 )
+						goto loop41;
+
+					if (state.backtracking>0) {state.failed=true; return ;}
+					EarlyExitException eee41 = new EarlyExitException( 41, input );
+					throw eee41;
+				}
+				cnt41++;
+			}
+			loop41:
+				;
+
+
+			Match(')'); if (state.failed) return ;
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "NESTED_PARENS"
+
+	// $ANTLR start "INDENT"
+	private void mINDENT()
+	{
+		try
+		{
+			// Language\\Template.g3:509:4: ( ( ' ' | '\\t' )+ )
+			// Language\\Template.g3:509:4: ( ' ' | '\\t' )+
+			{
+			// Language\\Template.g3:509:4: ( ' ' | '\\t' )+
+			int cnt42=0;
+			for ( ; ; )
+			{
+				int alt42=2;
+				int LA42_0 = input.LA(1);
+
+				if ( (LA42_0=='\t'||LA42_0==' ') )
+				{
+					alt42=1;
+				}
+
+
+				switch ( alt42 )
+				{
+				case 1:
+					// Language\\Template.g3:
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+
+				default:
+					if ( cnt42 >= 1 )
+						goto loop42;
+
+					if (state.backtracking>0) {state.failed=true; return ;}
+					EarlyExitException eee42 = new EarlyExitException( 42, input );
+					throw eee42;
+				}
+				cnt42++;
+			}
+			loop42:
+				;
+
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "INDENT"
+
+	// $ANTLR start "COMMENT"
+	private void mCOMMENT()
+	{
+		try
+		{
+
+				int startCol = CharPositionInLine;
+
+			// Language\\Template.g3:518:4: ( '$!' ( . )* '!$' ({...}? => ( '\\r' )? '\\n' )? )
+			// Language\\Template.g3:518:4: '$!' ( . )* '!$' ({...}? => ( '\\r' )? '\\n' )?
+			{
+			Match("$!"); if (state.failed) return ;
+
+			// Language\\Template.g3:518:9: ( . )*
+			for ( ; ; )
+			{
+				int alt43=2;
+				int LA43_0 = input.LA(1);
+
+				if ( (LA43_0=='!') )
+				{
+					int LA43_1 = input.LA(2);
+
+					if ( (LA43_1=='$') )
+					{
+						alt43=2;
+					}
+					else if ( ((LA43_1>='\u0000' && LA43_1<='#')||(LA43_1>='%' && LA43_1<='\uFFFF')) )
+					{
+						alt43=1;
+					}
+
+
+				}
+				else if ( ((LA43_0>='\u0000' && LA43_0<=' ')||(LA43_0>='\"' && LA43_0<='\uFFFF')) )
+				{
+					alt43=1;
+				}
+
+
+				switch ( alt43 )
+				{
+				case 1:
+					// Language\\Template.g3:518:0: .
+					{
+					MatchAny(); if (state.failed) return ;
+
+					}
+					break;
+
+				default:
+					goto loop43;
+				}
+			}
+
+			loop43:
+				;
+
+
+			Match("!$"); if (state.failed) return ;
+
+			// Language\\Template.g3:518:17: ({...}? => ( '\\r' )? '\\n' )?
+			int alt45=2;
+			int LA45_0 = input.LA(1);
+
+			if ( (LA45_0=='\n'||LA45_0=='\r') && ((startCol==0)))
+			{
+				alt45=1;
+			}
+			switch ( alt45 )
+			{
+			case 1:
+				// Language\\Template.g3:518:19: {...}? => ( '\\r' )? '\\n'
+				{
+				if ( !((startCol==0)) )
+				{
+					if (state.backtracking>0) {state.failed=true; return ;}
+					throw new FailedPredicateException(input, "COMMENT", "startCol==0");
+				}
+				// Language\\Template.g3:518:37: ( '\\r' )?
+				int alt44=2;
+				int LA44_0 = input.LA(1);
+
+				if ( (LA44_0=='\r') )
+				{
+					alt44=1;
+				}
+				switch ( alt44 )
+				{
+				case 1:
+					// Language\\Template.g3:518:38: '\\r'
+					{
+					Match('\r'); if (state.failed) return ;
+
+					}
+					break;
+
+				}
+
+				Match('\n'); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "COMMENT"
+
+	public override void mTokens()
+	{
+		// Language\\Template.g3:1:10: ( NEWLINE | ACTION | LITERAL )
+		int alt46=3;
+		int LA46_0 = input.LA(1);
+
+		if ( (LA46_0=='\n'||LA46_0=='\r') )
+		{
+			alt46=1;
+		}
+		else if ( (LA46_0=='$') )
+		{
+			alt46=2;
+		}
+		else if ( ((LA46_0>='\u0000' && LA46_0<='\t')||(LA46_0>='\u000B' && LA46_0<='\f')||(LA46_0>='\u000E' && LA46_0<='#')||(LA46_0>='%' && LA46_0<='\uFFFF')) )
+		{
+			alt46=3;
+		}
+		else
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			NoViableAltException nvae = new NoViableAltException("", 46, 0, input);
+
+			throw nvae;
+		}
+		switch ( alt46 )
+		{
+		case 1:
+			// Language\\Template.g3:1:10: NEWLINE
+			{
+			mNEWLINE(); if (state.failed) return ;
+
+			}
+			break;
+		case 2:
+			// Language\\Template.g3:1:18: ACTION
+			{
+			mACTION(); if (state.failed) return ;
+
+			}
+			break;
+		case 3:
+			// Language\\Template.g3:1:25: LITERAL
+			{
+			mLITERAL(); if (state.failed) return ;
+
+			}
+			break;
+
+		}
+
+	}
+
+	// $ANTLR start synpred1_Template
+	public void synpred1_Template_fragment()
+	{
+		// Language\\Template.g3:280:4: ( '$\\\\' )
+		// Language\\Template.g3:280:5: '$\\\\'
+		{
+		Match("$\\"); if (state.failed) return ;
+
+
+		}
+	}
+	// $ANTLR end synpred1_Template
+
+	// $ANTLR start synpred10_Template
+	public void synpred10_Template_fragment()
+	{
+		// Language\\Template.g3:342:8: ( '\\r' | '\\n' )
+		// Language\\Template.g3:
+		{
+		if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
+		{
+			input.Consume();
+		state.failed=false;
+		}
+		else
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			MismatchedSetException mse = new MismatchedSetException(null,input);
+			Recover(mse);
+			throw mse;}
+
+
+		}
+	}
+	// $ANTLR end synpred10_Template
+
+	// $ANTLR start synpred11_Template
+	public void synpred11_Template_fragment()
+	{
+		// Language\\Template.g3:343:8: ( '$@end$' )
+		// Language\\Template.g3:343:9: '$@end$'
+		{
+		Match("$@end$"); if (state.failed) return ;
+
+
+		}
+	}
+	// $ANTLR end synpred11_Template
+
+	// $ANTLR start synpred12_Template
+	public void synpred12_Template_fragment()
+	{
+		// Language\\Template.g3:442:6: ( '\\r' | '\\n' )
+		// Language\\Template.g3:
+		{
+		if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
+		{
+			input.Consume();
+		state.failed=false;
+		}
+		else
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			MismatchedSetException mse = new MismatchedSetException(null,input);
+			Recover(mse);
+			throw mse;}
+
+
+		}
+	}
+	// $ANTLR end synpred12_Template
+
+	// $ANTLR start synpred13_Template
+	public void synpred13_Template_fragment()
+	{
+		// Language\\Template.g3:444:5: ( ( '\\r' )? '\\n>>' )
+		// Language\\Template.g3:444:6: ( '\\r' )? '\\n>>'
+		{
+		// Language\\Template.g3:444:6: ( '\\r' )?
+		int alt47=2;
+		int LA47_0 = input.LA(1);
+
+		if ( (LA47_0=='\r') )
+		{
+			alt47=1;
+		}
+		switch ( alt47 )
+		{
+		case 1:
+			// Language\\Template.g3:444:0: '\\r'
+			{
+			Match('\r'); if (state.failed) return ;
+
+			}
+			break;
+
+		}
+
+		Match("\n>>"); if (state.failed) return ;
+
+
+		}
+	}
+	// $ANTLR end synpred13_Template
+
+	// $ANTLR start synpred2_Template
+	public void synpred2_Template_fragment()
+	{
+		// Language\\Template.g3:287:5: ( '$!' )
+		// Language\\Template.g3:287:6: '$!'
+		{
+		Match("$!"); if (state.failed) return ;
+
+
+		}
+	}
+	// $ANTLR end synpred2_Template
+
+	// $ANTLR start synpred3_Template
+	public void synpred3_Template_fragment()
+	{
+		// Language\\Template.g3:289:7: ( '$if' ( ' ' | '(' ) )
+		// Language\\Template.g3:289:8: '$if' ( ' ' | '(' )
+		{
+		Match("$if"); if (state.failed) return ;
+
+		if ( input.LA(1)==' '||input.LA(1)=='(' )
+		{
+			input.Consume();
+		state.failed=false;
+		}
+		else
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			MismatchedSetException mse = new MismatchedSetException(null,input);
+			Recover(mse);
+			throw mse;}
+
+
+		}
+	}
+	// $ANTLR end synpred3_Template
+
+	// $ANTLR start synpred4_Template
+	public void synpred4_Template_fragment()
+	{
+		// Language\\Template.g3:296:6: ( '$elseif' ( ' ' | '(' ) )
+		// Language\\Template.g3:296:7: '$elseif' ( ' ' | '(' )
+		{
+		Match("$elseif"); if (state.failed) return ;
+
+		if ( input.LA(1)==' '||input.LA(1)=='(' )
+		{
+			input.Consume();
+		state.failed=false;
+		}
+		else
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			MismatchedSetException mse = new MismatchedSetException(null,input);
+			Recover(mse);
+			throw mse;}
+
+
+		}
+	}
+	// $ANTLR end synpred4_Template
+
+	// $ANTLR start synpred5_Template
+	public void synpred5_Template_fragment()
+	{
+		// Language\\Template.g3:303:6: ( '$else$' )
+		// Language\\Template.g3:303:7: '$else$'
+		{
+		Match("$else$"); if (state.failed) return ;
+
+
+		}
+	}
+	// $ANTLR end synpred5_Template
+
+	// $ANTLR start synpred6_Template
+	public void synpred6_Template_fragment()
+	{
+		// Language\\Template.g3:310:6: ( '$endif$' )
+		// Language\\Template.g3:310:7: '$endif$'
+		{
+		Match("$endif$"); if (state.failed) return ;
+
+
+		}
+	}
+	// $ANTLR end synpred6_Template
+
+	// $ANTLR start synpred7_Template
+	public void synpred7_Template_fragment()
+	{
+		// Language\\Template.g3:320:5: ( '$@' )
+		// Language\\Template.g3:320:6: '$@'
+		{
+		Match("$@"); if (state.failed) return ;
+
+
+		}
+	}
+	// $ANTLR end synpred7_Template
+
+	// $ANTLR start synpred8_Template
+	public void synpred8_Template_fragment()
+	{
+		// Language\\Template.g3:335:8: ( '\\r' | '\\n' )
+		// Language\\Template.g3:
+		{
+		if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
+		{
+			input.Consume();
+		state.failed=false;
+		}
+		else
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			MismatchedSetException mse = new MismatchedSetException(null,input);
+			Recover(mse);
+			throw mse;}
+
+
+		}
+	}
+	// $ANTLR end synpred8_Template
+
+	// $ANTLR start synpred9_Template
+	public void synpred9_Template_fragment()
+	{
+		// Language\\Template.g3:338:9: ( '\\r' | '\\n' )
+		// Language\\Template.g3:
+		{
+		if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
+		{
+			input.Consume();
+		state.failed=false;
+		}
+		else
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			MismatchedSetException mse = new MismatchedSetException(null,input);
+			Recover(mse);
+			throw mse;}
+
+
+		}
+	}
+	// $ANTLR end synpred9_Template
+
+	public bool synpred8_Template()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred8_Template_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred9_Template()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred9_Template_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred10_Template()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred10_Template_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred11_Template()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred11_Template_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred3_Template()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred3_Template_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred4_Template()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred4_Template_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred5_Template()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred5_Template_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred6_Template()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred6_Template_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred7_Template()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred7_Template_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred1_Template()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred1_Template_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred2_Template()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred2_Template_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred12_Template()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred12_Template_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred13_Template()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred13_Template_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+
+
+	#region DFA
+	DFA18 dfa18;
+
+	protected override void InitDFAs()
+	{
+		base.InitDFAs();
+		dfa18 = new DFA18( this, new SpecialStateTransitionHandler( specialStateTransition18 ) );
+	}
+
+	class DFA18 : DFA
+	{
+
+		const string DFA18_eotS =
+			"\x3\xFFFF\x2\x6\x2\xFFFF\x1\x5\x2\xFFFF\x3\x5\x1\xFFFF";
+		const string DFA18_eofS =
+			"\xE\xFFFF";
+		const string DFA18_minS =
+			"\x5\x0\x2\xFFFF\x1\x65\x2\x0\x1\x6E\x1\x64\x1\x24\x1\x0";
+		const string DFA18_maxS =
+			"\x1\xFFFF\x2\x0\x2\xFFFF\x2\xFFFF\x1\x65\x2\x0\x1\x6E\x1\x64\x1\x24\x1"+
+			"\x0";
+		const string DFA18_acceptS =
+			"\x5\xFFFF\x1\x1\x1\x2\x7\xFFFF";
+		const string DFA18_specialS =
+			"\x1\x0\x1\x1\x1\x2\x1\x3\x1\x4\x2\xFFFF\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9"+
+			"\x1\xA\x1\xB}>";
+		static readonly string[] DFA18_transitionS =
+			{
+				"\xA\x4\x1\x2\x2\x4\x1\x1\x16\x4\x1\x3\xFFDB\x4",
+				"\x1\xFFFF",
+				"\x1\xFFFF",
+				"\xA\x5\x1\x9\x2\x5\x1\x8\x32\x5\x1\x7\xFFBF\x5",
+				"\xA\x5\x1\x9\x2\x5\x1\x8\xFFF2\x5",
+				"",
+				"",
+				"\x1\xA",
+				"\x1\xFFFF",
+				"\x1\xFFFF",
+				"\x1\xB",
+				"\x1\xC",
+				"\x1\xD",
+				"\x1\xFFFF"
+			};
+
+		static readonly short[] DFA18_eot = DFA.UnpackEncodedString(DFA18_eotS);
+		static readonly short[] DFA18_eof = DFA.UnpackEncodedString(DFA18_eofS);
+		static readonly char[] DFA18_min = DFA.UnpackEncodedStringToUnsignedChars(DFA18_minS);
+		static readonly char[] DFA18_max = DFA.UnpackEncodedStringToUnsignedChars(DFA18_maxS);
+		static readonly short[] DFA18_accept = DFA.UnpackEncodedString(DFA18_acceptS);
+		static readonly short[] DFA18_special = DFA.UnpackEncodedString(DFA18_specialS);
+		static readonly short[][] DFA18_transition;
+
+		static DFA18()
+		{
+			int numStates = DFA18_transitionS.Length;
+			DFA18_transition = new short[numStates][];
+			for ( int i=0; i < numStates; i++ )
+			{
+				DFA18_transition[i] = DFA.UnpackEncodedString(DFA18_transitionS[i]);
+			}
+		}
+
+		public DFA18( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
+			: base( specialStateTransition )	{
+			this.recognizer = recognizer;
+			this.decisionNumber = 18;
+			this.eot = DFA18_eot;
+			this.eof = DFA18_eof;
+			this.min = DFA18_min;
+			this.max = DFA18_max;
+			this.accept = DFA18_accept;
+			this.special = DFA18_special;
+			this.transition = DFA18_transition;
+		}
+		public override string GetDescription()
+		{
+			return "()+ loopback of 337:6: ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+";
+		}
+	}
+
+	int specialStateTransition18( DFA dfa, int s, IIntStream _input )
+	{
+		IIntStream input = _input;
+		int _s = s;
+		switch ( s )
+		{
+
+			case 0:
+				int LA18_0 = input.LA(1);
+
+				s = -1;
+				if ( (LA18_0=='\r') ) {s = 1;}
+
+				else if ( (LA18_0=='\n') ) {s = 2;}
+
+				else if ( (LA18_0=='$') ) {s = 3;}
+
+				else if ( ((LA18_0>='\u0000' && LA18_0<='\t')||(LA18_0>='\u000B' && LA18_0<='\f')||(LA18_0>='\u000E' && LA18_0<='#')||(LA18_0>='%' && LA18_0<='\uFFFF')) ) {s = 4;}
+
+				if ( s>=0 ) return s;
+				break;
+
+			case 1:
+				int LA18_1 = input.LA(1);
+
+
+				int index18_1 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( ((!(upcomingAtEND(1) || ( input.LA(1) == '\n' && upcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && upcomingAtEND(3) )))) ) {s = 5;}
+
+				else if ( (true) ) {s = 6;}
+
+
+				input.Seek(index18_1);
+				if ( s>=0 ) return s;
+				break;
+
+			case 2:
+				int LA18_2 = input.LA(1);
+
+
+				int index18_2 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( ((!(upcomingAtEND(1) || ( input.LA(1) == '\n' && upcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && upcomingAtEND(3) )))) ) {s = 5;}
+
+				else if ( (true) ) {s = 6;}
+
+
+				input.Seek(index18_2);
+				if ( s>=0 ) return s;
+				break;
+
+			case 3:
+				int LA18_3 = input.LA(1);
+
+
+				int index18_3 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (LA18_3=='@') ) {s = 7;}
+
+				else if ( (LA18_3=='\r') ) {s = 8;}
+
+				else if ( (LA18_3=='\n') ) {s = 9;}
+
+				else if ( ((LA18_3>='\u0000' && LA18_3<='\t')||(LA18_3>='\u000B' && LA18_3<='\f')||(LA18_3>='\u000E' && LA18_3<='?')||(LA18_3>='A' && LA18_3<='\uFFFF')) && ((!(upcomingAtEND(1) || ( input.LA(1) == '\n' && upcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && upcomingAtEND(3) ))))) {s = 5;}
+
+				else s = 6;
+
+
+				input.Seek(index18_3);
+				if ( s>=0 ) return s;
+				break;
+
+			case 4:
+				int LA18_4 = input.LA(1);
+
+
+				int index18_4 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (LA18_4=='\r') ) {s = 8;}
+
+				else if ( (LA18_4=='\n') ) {s = 9;}
+
+				else if ( ((LA18_4>='\u0000' && LA18_4<='\t')||(LA18_4>='\u000B' && LA18_4<='\f')||(LA18_4>='\u000E' && LA18_4<='\uFFFF')) && ((!(upcomingAtEND(1) || ( input.LA(1) == '\n' && upcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && upcomingAtEND(3) ))))) {s = 5;}
+
+				else s = 6;
+
+
+				input.Seek(index18_4);
+				if ( s>=0 ) return s;
+				break;
+
+			case 5:
+				int LA18_7 = input.LA(1);
+
+
+				int index18_7 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (LA18_7=='e') ) {s = 10;}
+
+				else s = 5;
+
+
+				input.Seek(index18_7);
+				if ( s>=0 ) return s;
+				break;
+
+			case 6:
+				int LA18_8 = input.LA(1);
+
+
+				int index18_8 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( ((!(upcomingAtEND(1) || ( input.LA(1) == '\n' && upcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && upcomingAtEND(3) )))) ) {s = 5;}
+
+				else if ( (true) ) {s = 6;}
+
+
+				input.Seek(index18_8);
+				if ( s>=0 ) return s;
+				break;
+
+			case 7:
+				int LA18_9 = input.LA(1);
+
+
+				int index18_9 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( ((!(upcomingAtEND(1) || ( input.LA(1) == '\n' && upcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && upcomingAtEND(3) )))) ) {s = 5;}
+
+				else if ( (true) ) {s = 6;}
+
+
+				input.Seek(index18_9);
+				if ( s>=0 ) return s;
+				break;
+
+			case 8:
+				int LA18_10 = input.LA(1);
+
+
+				int index18_10 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (LA18_10=='n') ) {s = 11;}
+
+				else s = 5;
+
+
+				input.Seek(index18_10);
+				if ( s>=0 ) return s;
+				break;
+
+			case 9:
+				int LA18_11 = input.LA(1);
+
+
+				int index18_11 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (LA18_11=='d') ) {s = 12;}
+
+				else s = 5;
+
+
+				input.Seek(index18_11);
+				if ( s>=0 ) return s;
+				break;
+
+			case 10:
+				int LA18_12 = input.LA(1);
+
+
+				int index18_12 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (LA18_12=='$') ) {s = 13;}
+
+				else s = 5;
+
+
+				input.Seek(index18_12);
+				if ( s>=0 ) return s;
+				break;
+
+			case 11:
+				int LA18_13 = input.LA(1);
+
+
+				int index18_13 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( ((!(upcomingAtEND(1) || ( input.LA(1) == '\n' && upcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && upcomingAtEND(3) )))) ) {s = 5;}
+
+				else if ( (true) ) {s = 6;}
+
+
+				input.Seek(index18_13);
+				if ( s>=0 ) return s;
+				break;
+		}
+		if (state.backtracking>0) {state.failed=true; return -1;}
+		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 18, _s, input);
+		dfa.Error(nvae);
+		throw nvae;
+	}
+
+	#endregion
+
+}
+
+} // namespace Antlr3.ST.Language
diff --git a/Antlr3.StringTemplate/Language/TemplateLexerHelper.cs b/Antlr3.StringTemplate/Language/TemplateLexerHelper.cs
new file mode 100644
index 0000000..744e0b5
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/TemplateLexerHelper.cs
@@ -0,0 +1,74 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Grammar conversion to ANTLR v3 and C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *	notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	notice, this list of conditions and the following disclaimer in the
+ *	documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *	derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST.Language
+{
+    using ANTLRReaderStream = Antlr.Runtime.ANTLRReaderStream;
+    using RecognitionException = Antlr.Runtime.RecognitionException;
+    using TextReader = System.IO.TextReader;
+
+    partial class TemplateLexer
+    {
+        protected string currentIndent = null;
+        protected StringTemplate self;
+
+        public TemplateLexer( StringTemplate self, TextReader r )
+            : this( new ANTLRReaderStream( r ) )
+        {
+            this.self = self;
+        }
+
+        public override void ReportError( RecognitionException e )
+        {
+            self.error( "$...$ chunk lexer error", e );
+        }
+
+        //protected boolean upcomingELSE(int i) throws CharStreamException {
+        //    return LA(i)=='$'&&LA(i+1)=='e'&&LA(i+2)=='l'&&LA(i+3)=='s'&&LA(i+4)=='e'&&
+        //           LA(i+5)=='$';
+        //}
+
+        //protected boolean upcomingENDIF(int i) throws CharStreamException {
+        //    return LA(i)=='$'&&LA(i+1)=='e'&&LA(i+2)=='n'&&LA(i+3)=='d'&&LA(i+4)=='i'&&
+        //           LA(i+5)=='f'&&LA(i+6)=='$';
+        //}
+
+        protected bool upcomingAtEND(int i)
+        {
+            return input.LA(i)=='$'&&input.LA(i+1)=='@'&&input.LA(i+2)=='e'&&input.LA(i+3)=='n'&&input.LA(i+4)=='d'&&input.LA(i+5)=='$';
+        }
+
+        //protected boolean upcomingNewline(int i) throws CharStreamException {
+        //    return (LA(i)=='\r'&&LA(i+1)=='\n')||LA(i)=='\n';
+        //}
+    }
+}
diff --git a/Antlr3.StringTemplate/Language/TemplateParser.cs b/Antlr3.StringTemplate/Language/TemplateParser.cs
new file mode 100644
index 0000000..0243dde
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/TemplateParser.cs
@@ -0,0 +1,507 @@
+// $ANTLR 3.1.2 Language\\Template.g3 2009-03-07 08:52:37
+
+// The variable 'variable' is assigned but its value is never used.
+#pragma warning disable 219
+// Unreachable code detected.
+#pragma warning disable 162
+
+
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+using Antlr.Runtime.JavaExtensions;
+
+
+using System.Collections.Generic;
+using Antlr.Runtime;
+using Stack = System.Collections.Generic.Stack<object>;
+using List = System.Collections.IList;
+using ArrayList = System.Collections.Generic.List<object>;
+
+namespace Antlr3.ST.Language
+{
+public partial class TemplateParser : Parser
+{
+	public static readonly string[] tokenNames = new string[] {
+		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "COMMENT", "ELSE", "ELSEIF", "ENDIF", "ESC", "ESC_CHAR", "EXPR", "HEX", "IF", "IF_EXPR", "INDENT", "LITERAL", "NESTED_PARENS", "NEWLINE", "REGION_DEF", "REGION_REF", "SUBTEMPLATE", "TEMPLATE"
+	};
+	public const int EOF=-1;
+	public const int ACTION=4;
+	public const int COMMENT=5;
+	public const int ELSE=6;
+	public const int ELSEIF=7;
+	public const int ENDIF=8;
+	public const int ESC=9;
+	public const int ESC_CHAR=10;
+	public const int EXPR=11;
+	public const int HEX=12;
+	public const int IF=13;
+	public const int IF_EXPR=14;
+	public const int INDENT=15;
+	public const int LITERAL=16;
+	public const int NESTED_PARENS=17;
+	public const int NEWLINE=18;
+	public const int REGION_DEF=19;
+	public const int REGION_REF=20;
+	public const int SUBTEMPLATE=21;
+	public const int TEMPLATE=22;
+
+	// delegates
+	// delegators
+
+	public TemplateParser( ITokenStream input )
+		: this( input, new RecognizerSharedState() )
+	{
+	}
+	public TemplateParser( ITokenStream input, RecognizerSharedState state )
+		: base( input, state )
+	{
+	}
+
+
+	public override string[] GetTokenNames() { return TemplateParser.tokenNames; }
+	public override string GrammarFileName { get { return "Language\\Template.g3"; } }
+
+
+	#region Rules
+
+	// $ANTLR start "template"
+	// Language\\Template.g3:114:0: public template[StringTemplate self] : (s= LITERAL |nl= NEWLINE | action[self] )* ( EOF )? ;
+	public void template( StringTemplate self )
+	{
+		IToken s=null;
+		IToken nl=null;
+
+
+			this.self = self;
+
+		try
+		{
+			// Language\\Template.g3:119:4: ( (s= LITERAL |nl= NEWLINE | action[self] )* ( EOF )? )
+			// Language\\Template.g3:119:4: (s= LITERAL |nl= NEWLINE | action[self] )* ( EOF )?
+			{
+			// Language\\Template.g3:119:4: (s= LITERAL |nl= NEWLINE | action[self] )*
+			for ( ; ; )
+			{
+				int alt1=4;
+				switch ( input.LA(1) )
+				{
+				case LITERAL:
+					{
+					alt1=1;
+					}
+					break;
+				case NEWLINE:
+					{
+					alt1=2;
+					}
+					break;
+				case ACTION:
+				case IF:
+				case REGION_DEF:
+				case REGION_REF:
+					{
+					alt1=3;
+					}
+					break;
+
+				}
+
+				switch ( alt1 )
+				{
+				case 1:
+					// Language\\Template.g3:119:6: s= LITERAL
+					{
+					s=(IToken)Match(input,LITERAL,Follow._LITERAL_in_template71);
+					self.addChunk(new StringRef(self,(s!=null?s.Text:null)));
+
+					}
+					break;
+				case 2:
+					// Language\\Template.g3:120:5: nl= NEWLINE
+					{
+					nl=(IToken)Match(input,NEWLINE,Follow._NEWLINE_in_template82);
+
+									if ( input.LA(1)!=ELSE && input.LA(1)!=ENDIF )
+									{
+										self.addChunk(new NewlineRef(self,(nl!=null?nl.Text:null)));
+									}
+
+
+					}
+					break;
+				case 3:
+					// Language\\Template.g3:127:5: action[self]
+					{
+					PushFollow(Follow._action_in_template93);
+					action(self);
+
+					state._fsp--;
+
+
+					}
+					break;
+
+				default:
+					goto loop1;
+				}
+			}
+
+			loop1:
+				;
+
+
+			// Language\\Template.g3:129:3: ( EOF )?
+			int alt2=2;
+			int LA2_0 = input.LA(1);
+
+			if ( (LA2_0==EOF) )
+			{
+				alt2=1;
+			}
+			switch ( alt2 )
+			{
+			case 1:
+				// Language\\Template.g3:129:0: EOF
+				{
+				Match(input,EOF,Follow._EOF_in_template103);
+
+				}
+				break;
+
+			}
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "template"
+
+
+	// $ANTLR start "action"
+	// Language\\Template.g3:132:0: action[StringTemplate self] : (a= ACTION |i= IF template[subtemplate] (ei= ELSEIF template[elseIfSubtemplate] )* ( ELSE template[elseSubtemplate] )? ENDIF |rr= REGION_REF |rd= REGION_DEF );
+	private void action( StringTemplate self )
+	{
+		IToken a=null;
+		IToken i=null;
+		IToken ei=null;
+		IToken rr=null;
+		IToken rd=null;
+
+		try
+		{
+			// Language\\Template.g3:133:4: (a= ACTION |i= IF template[subtemplate] (ei= ELSEIF template[elseIfSubtemplate] )* ( ELSE template[elseSubtemplate] )? ENDIF |rr= REGION_REF |rd= REGION_DEF )
+			int alt5=4;
+			switch ( input.LA(1) )
+			{
+			case ACTION:
+				{
+				alt5=1;
+				}
+				break;
+			case IF:
+				{
+				alt5=2;
+				}
+				break;
+			case REGION_REF:
+				{
+				alt5=3;
+				}
+				break;
+			case REGION_DEF:
+				{
+				alt5=4;
+				}
+				break;
+			default:
+				{
+					NoViableAltException nvae = new NoViableAltException("", 5, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt5 )
+			{
+			case 1:
+				// Language\\Template.g3:133:4: a= ACTION
+				{
+				a=(IToken)Match(input,ACTION,Follow._ACTION_in_action118);
+
+							string indent = ((ChunkToken)a).Indentation;
+							ASTExpr c = self.parseAction((a!=null?a.Text:null));
+							c.setIndentation(indent);
+							self.addChunk(c);
+
+
+				}
+				break;
+			case 2:
+				// Language\\Template.g3:141:4: i= IF template[subtemplate] (ei= ELSEIF template[elseIfSubtemplate] )* ( ELSE template[elseSubtemplate] )? ENDIF
+				{
+				i=(IToken)Match(input,IF,Follow._IF_in_action130);
+
+							ConditionalExpr c = (ConditionalExpr)self.parseAction((i!=null?i.Text:null));
+							// create and precompile the subtemplate
+							StringTemplate subtemplate = new StringTemplate(self.getGroup(), null);
+							subtemplate.setEnclosingInstance(self);
+							subtemplate.setName((i!=null?i.Text:null)+"_subtemplate");
+							self.addChunk(c);
+
+				PushFollow(Follow._template_in_action139);
+				template(subtemplate);
+
+				state._fsp--;
+
+				if ( c!=null ) c.setSubtemplate(subtemplate);
+				// Language\\Template.g3:153:3: (ei= ELSEIF template[elseIfSubtemplate] )*
+				for ( ; ; )
+				{
+					int alt3=2;
+					int LA3_0 = input.LA(1);
+
+					if ( (LA3_0==ELSEIF) )
+					{
+						alt3=1;
+					}
+
+
+					switch ( alt3 )
+					{
+					case 1:
+						// Language\\Template.g3:153:5: ei= ELSEIF template[elseIfSubtemplate]
+						{
+						ei=(IToken)Match(input,ELSEIF,Follow._ELSEIF_in_action151);
+
+										ASTExpr ec = self.parseAction((ei!=null?ei.Text:null));
+										// create and precompile the subtemplate
+										StringTemplate elseIfSubtemplate = new StringTemplate(self.getGroup(), null);
+										elseIfSubtemplate.setEnclosingInstance(self);
+										elseIfSubtemplate.setName((ei!=null?ei.Text:null)+"_subtemplate");
+
+						PushFollow(Follow._template_in_action162);
+						template(elseIfSubtemplate);
+
+						state._fsp--;
+
+						if ( c!=null ) c.addElseIfSubtemplate(ec, elseIfSubtemplate);
+
+						}
+						break;
+
+					default:
+						goto loop3;
+					}
+				}
+
+				loop3:
+					;
+
+
+				// Language\\Template.g3:167:3: ( ELSE template[elseSubtemplate] )?
+				int alt4=2;
+				int LA4_0 = input.LA(1);
+
+				if ( (LA4_0==ELSE) )
+				{
+					alt4=1;
+				}
+				switch ( alt4 )
+				{
+				case 1:
+					// Language\\Template.g3:167:5: ELSE template[elseSubtemplate]
+					{
+					Match(input,ELSE,Follow._ELSE_in_action181);
+
+									// create and precompile the subtemplate
+									StringTemplate elseSubtemplate = new StringTemplate(self.getGroup(), null);
+									elseSubtemplate.setEnclosingInstance(self);
+									elseSubtemplate.setName("else_subtemplate");
+
+					PushFollow(Follow._template_in_action192);
+					template(elseSubtemplate);
+
+					state._fsp--;
+
+					if ( c!=null ) c.setElseSubtemplate(elseSubtemplate);
+
+					}
+					break;
+
+				}
+
+				Match(input,ENDIF,Follow._ENDIF_in_action208);
+
+				}
+				break;
+			case 3:
+				// Language\\Template.g3:181:4: rr= REGION_REF
+				{
+				rr=(IToken)Match(input,REGION_REF,Follow._REGION_REF_in_action216);
+
+							// define implicit template and
+							// convert <@r()> to <region__enclosingTemplate__r()>
+							string regionName = (rr!=null?rr.Text:null);
+							string mangledRef = null;
+							bool err = false;
+							// watch out for <@super.r()>; that does NOT def implicit region
+							// convert to <super.region__enclosingTemplate__r()>
+							if ( regionName.StartsWith("super.") )
+							{
+								//System.out.println("super region ref "+regionName);
+								string regionRef = regionName.substring("super.".Length,regionName.Length);
+								string templateScope = self.getGroup().getUnMangledTemplateName(self.getName());
+								StringTemplate scopeST = self.getGroup().lookupTemplate(templateScope);
+								if ( scopeST==null )
+								{
+									self.getGroup().error("reference to region within undefined template: "+templateScope);
+									err=true;
+								}
+								if ( !scopeST.containsRegionName(regionRef) )
+								{
+									self.getGroup().error("template "+templateScope+" has no region called "+regionRef);
+									err=true;
+								}
+								else
+								{
+									mangledRef = self.getGroup().getMangledRegionName(templateScope,regionRef);
+									mangledRef = "super."+mangledRef;
+								}
+							}
+							else
+							{
+								//System.out.println("region ref "+regionName);
+								StringTemplate regionST = self.getGroup().defineImplicitRegionTemplate(self,regionName);
+								mangledRef = regionST.getName();
+							}
+
+							if ( !err )
+							{
+								// treat as regular action: mangled template include
+								string indent = ((ChunkToken)rr).Indentation;
+								ASTExpr c = self.parseAction(mangledRef+"()");
+								c.setIndentation(indent);
+								self.addChunk(c);
+							}
+
+
+				}
+				break;
+			case 4:
+				// Language\\Template.g3:229:4: rd= REGION_DEF
+				{
+				rd=(IToken)Match(input,REGION_DEF,Follow._REGION_DEF_in_action228);
+
+							string combinedNameTemplateStr = (rd!=null?rd.Text:null);
+							int indexOfDefSymbol = combinedNameTemplateStr.IndexOf("::=");
+							if ( indexOfDefSymbol>=1 )
+							{
+								string regionName = combinedNameTemplateStr.substring(0,indexOfDefSymbol);
+								string template = combinedNameTemplateStr.substring(indexOfDefSymbol+3, combinedNameTemplateStr.Length);
+								StringTemplate regionST = self.getGroup().defineRegionTemplate(self,regionName,template,StringTemplate.REGION_EMBEDDED);
+								// treat as regular action: mangled template include
+								string indent = ((ChunkToken)rd).Indentation;
+								ASTExpr c = self.parseAction(regionST.getName()+"()");
+								c.setIndentation(indent);
+								self.addChunk(c);
+							}
+							else
+							{
+								self.error("embedded region definition screwed up");
+							}
+
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "action"
+	#endregion
+
+	// Delegated rules
+
+	#region Synpreds
+	#endregion
+
+	#region DFA
+
+	protected override void InitDFAs()
+	{
+		base.InitDFAs();
+	}
+
+	#endregion
+
+	#region Follow Sets
+	public static class Follow
+	{
+		public static readonly BitSet _LITERAL_in_template71 = new BitSet(new ulong[]{0x1D2012UL});
+		public static readonly BitSet _NEWLINE_in_template82 = new BitSet(new ulong[]{0x1D2012UL});
+		public static readonly BitSet _action_in_template93 = new BitSet(new ulong[]{0x1D2012UL});
+		public static readonly BitSet _EOF_in_template103 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ACTION_in_action118 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _IF_in_action130 = new BitSet(new ulong[]{0x1D2010UL});
+		public static readonly BitSet _template_in_action139 = new BitSet(new ulong[]{0x1C0UL});
+		public static readonly BitSet _ELSEIF_in_action151 = new BitSet(new ulong[]{0x1D2010UL});
+		public static readonly BitSet _template_in_action162 = new BitSet(new ulong[]{0x1C0UL});
+		public static readonly BitSet _ELSE_in_action181 = new BitSet(new ulong[]{0x1D2010UL});
+		public static readonly BitSet _template_in_action192 = new BitSet(new ulong[]{0x100UL});
+		public static readonly BitSet _ENDIF_in_action208 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _REGION_REF_in_action216 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _REGION_DEF_in_action228 = new BitSet(new ulong[]{0x2UL});
+
+	}
+	#endregion
+}
+
+} // namespace Antlr3.ST.Language
diff --git a/Antlr3.StringTemplate/Language/TemplateParserHelper.cs b/Antlr3.StringTemplate/Language/TemplateParserHelper.cs
new file mode 100644
index 0000000..afbebc3
--- /dev/null
+++ b/Antlr3.StringTemplate/Language/TemplateParserHelper.cs
@@ -0,0 +1,54 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Grammar conversion to ANTLR v3 and C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *	notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	notice, this list of conditions and the following disclaimer in the
+ *	documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *	derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST.Language
+{
+    using RecognitionException = Antlr.Runtime.RecognitionException;
+
+    partial class TemplateParser
+    {
+        protected StringTemplate self;
+
+        public override void ReportError( RecognitionException e )
+        {
+            StringTemplateGroup group = self.getGroup();
+            if ( group == StringTemplate.defaultGroup )
+            {
+                self.error( "template parse error; template context is " + self.getEnclosingInstanceStackString(), e );
+            }
+            else
+            {
+                self.error( "template parse error in group " + self.getGroup().Name + " line " + self.getGroupFileLine() + "; template context is " + self.getEnclosingInstanceStackString(), e );
+            }
+        }
+    }
+}
diff --git a/Antlr3.StringTemplate/NoIndentWriter.cs b/Antlr3.StringTemplate/NoIndentWriter.cs
new file mode 100644
index 0000000..ed1bf29
--- /dev/null
+++ b/Antlr3.StringTemplate/NoIndentWriter.cs
@@ -0,0 +1,51 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2003-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST
+{
+    using TextWriter = System.IO.TextWriter;
+
+    /** <summary>Just pass through the text</summary> */
+    public class NoIndentWriter : AutoIndentWriter
+    {
+        public NoIndentWriter( TextWriter writer )
+            : base( writer )
+        {
+        }
+
+        public override int write( string str )
+        {
+            Writer.Write( str );
+            return str.Length;
+        }
+    }
+}
diff --git a/Antlr3.StringTemplate/PathGroupLoader.cs b/Antlr3.StringTemplate/PathGroupLoader.cs
new file mode 100644
index 0000000..89019bf
--- /dev/null
+++ b/Antlr3.StringTemplate/PathGroupLoader.cs
@@ -0,0 +1,221 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2003-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST
+{
+    using System;
+    using Antlr.Runtime.JavaExtensions;
+    using Antlr3.ST.Language;
+
+    using Encoding = System.Text.Encoding;
+    using IOException = System.IO.IOException;
+    using Stream = System.IO.Stream;
+    using StreamReader = System.IO.StreamReader;
+    using TextReader = System.IO.TextReader;
+
+    /** <summary>
+     *  A brain dead loader that looks only in the directory(ies) you
+     *  specify in the ctor.
+     *  </summary>
+     *
+     *  <remarks>
+     *  You may specify the char encoding.
+     *  NOTE: this does not work when you jar things up!  Use
+     *  CommonGroupLoader instead in that case
+     *  </remarks>
+     */
+    public class PathGroupLoader : IStringTemplateGroupLoader
+    {
+        /** <summary>List of ':' separated dirs to pull groups from</summary> */
+        protected string[] _dirs = null;
+
+        IStringTemplateErrorListener _errors = null;
+
+        /** <summary>
+         *  How are the files encoded (ascii, UTF8, ...)?  You might want to read
+         *  UTF8 for example on an ascii machine.
+         *  </summary>
+         */
+        Encoding _fileCharEncoding = Encoding.Default;
+
+        public PathGroupLoader( IStringTemplateErrorListener errors )
+        {
+            _errors = errors;
+        }
+
+        /** <summary>
+         *  Pass a single dir or multiple dirs separated by colons from which
+         *  to load groups/interfaces.
+         *  </summary>
+         */
+        public PathGroupLoader( string dirStr, IStringTemplateErrorListener errors )
+        {
+            _errors = errors;
+            _dirs = dirStr.Split( ':' );
+        }
+
+        /** <summary>
+         *  Load a group with a specified superGroup.  Groups with
+         *  region definitions must know their supergroup to find templates
+         *  during parsing.
+         *  </summary>
+         */
+        public virtual StringTemplateGroup loadGroup( string groupName,
+                                             Type templateLexer,
+                                             StringTemplateGroup superGroup )
+        {
+            StringTemplateGroup group = null;
+            TextReader br = null;
+            // group file format defaults to <...>
+            Type lexer = typeof( AngleBracketTemplateLexer );
+            if ( templateLexer != null )
+            {
+                lexer = templateLexer;
+            }
+            try
+            {
+                br = locate( groupName + ".stg" );
+                if ( br == null )
+                {
+                    error( "no such group file " + groupName + ".stg" );
+                    return null;
+                }
+                group = new StringTemplateGroup( br, lexer, _errors, superGroup );
+                br.Close();
+                br = null;
+            }
+            catch ( IOException ioe )
+            {
+                error( "can't load group " + groupName, ioe );
+            }
+            finally
+            {
+                if ( br != null )
+                {
+                    try
+                    {
+                        br.Close();
+                    }
+                    catch ( IOException ioe2 )
+                    {
+                        error( "Cannot close template group file: " + groupName + ".stg", ioe2 );
+                    }
+                }
+            }
+            return group;
+        }
+
+        public virtual StringTemplateGroup loadGroup( string groupName,
+                                             StringTemplateGroup superGroup )
+        {
+            return loadGroup( groupName, null, superGroup );
+        }
+
+        public virtual StringTemplateGroup loadGroup( string groupName )
+        {
+            return loadGroup( groupName, null );
+        }
+
+        public virtual StringTemplateGroupInterface loadInterface( string interfaceName )
+        {
+            StringTemplateGroupInterface I = null;
+            try
+            {
+                TextReader br = locate( interfaceName + ".sti" );
+                if ( br == null )
+                {
+                    error( "no such interface file " + interfaceName + ".sti" );
+                    return null;
+                }
+                I = new StringTemplateGroupInterface( br, _errors );
+            }
+            catch ( IOException ioe )
+            {
+                error( "can't load interface " + interfaceName, ioe );
+            }
+            return I;
+        }
+
+        /** <summary>Look in each directory for the file called 'name'.</summary> */
+        protected virtual TextReader locate( string name )
+        {
+            for ( int i = 0; i < _dirs.Length; i++ )
+            {
+                string dir = _dirs[i];
+                string fileName = dir + "/" + name;
+                if ( System.IO.File.Exists( fileName ) )
+                {
+                    System.IO.FileStream fis = System.IO.File.OpenRead( fileName );
+                    StreamReader isr = getInputStreamReader( new System.IO.BufferedStream( fis ) );
+                    return isr;
+                }
+            }
+            return null;
+        }
+
+        protected virtual StreamReader getInputStreamReader( Stream stream )
+        {
+            return new StreamReader( stream, _fileCharEncoding );
+        }
+
+        public virtual Encoding getFileCharEncoding()
+        {
+            return _fileCharEncoding;
+        }
+
+        public virtual void setFileCharEncoding( Encoding fileCharEncoding )
+        {
+            this._fileCharEncoding = fileCharEncoding ?? Encoding.Default;
+        }
+
+        public virtual void error( string msg )
+        {
+            error( msg, null );
+        }
+
+        public virtual void error( string msg, Exception e )
+        {
+            if ( _errors != null )
+            {
+                _errors.error( msg, e );
+            }
+            else
+            {
+                Console.Error.WriteLine( "StringTemplate: " + msg );
+                if ( e != null )
+                {
+                    e.printStackTrace();
+                }
+            }
+        }
+    }
+}
diff --git a/Antlr3.StringTemplate/Properties/AssemblyInfo.cs b/Antlr3.StringTemplate/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..c5c0d4d
--- /dev/null
+++ b/Antlr3.StringTemplate/Properties/AssemblyInfo.cs
@@ -0,0 +1,68 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2003-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle( "StringTemplate" )]
+[assembly: AssemblyDescription( "" )]
+[assembly: AssemblyConfiguration( "" )]
+[assembly: AssemblyCompany( "Pixel Mine, Inc." )]
+[assembly: AssemblyProduct( "StringTemplate" )]
+[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2008" )]
+[assembly: AssemblyTrademark( "" )]
+[assembly: AssemblyCulture( "" )]
+
+// Setting ComVisible to false makes the types in this assembly not visible
+// to COM components.  If you need to access a type in this assembly from
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible( false )]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid( "a4b023e1-07a4-48c5-b095-1e1beb854b3d" )]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion( "3.1.17527.0" )]
+[assembly: AssemblyFileVersion( "3.1.17527.0" )]
diff --git a/Antlr3.StringTemplate/Runtime.Tree/DOTTreeGenerator.cs b/Antlr3.StringTemplate/Runtime.Tree/DOTTreeGenerator.cs
new file mode 100644
index 0000000..6aacc62
--- /dev/null
+++ b/Antlr3.StringTemplate/Runtime.Tree/DOTTreeGenerator.cs
@@ -0,0 +1,233 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr.Runtime.Tree
+{
+    using System.Collections.Generic;
+    using StringTemplate = Antlr3.ST.StringTemplate;
+
+    /** A utility class to generate DOT diagrams (graphviz) from
+     *  arbitrary trees.  You can pass in your own templates and
+     *  can pass in any kind of tree or use Tree interface method.
+     *  I wanted this separator so that you don't have to include
+     *  ST just to use the org.antlr.runtime.tree.* package.
+     *  This is a set of non-static methods so you can subclass
+     *  to override.  For example, here is an invocation:
+     *
+     *      CharStream input = new ANTLRInputStream(System.in);
+     *      TLexer lex = new TLexer(input);
+     *      CommonTokenStream tokens = new CommonTokenStream(lex);
+     *      TParser parser = new TParser(tokens);
+     *      TParser.e_return r = parser.e();
+     *      Tree t = (Tree)r.tree;
+     *      System.out.println(t.toStringTree());
+     *      DOTTreeGenerator gen = new DOTTreeGenerator();
+     *      StringTemplate st = gen.toDOT(t);
+     *      System.out.println(st);
+     */
+    public class DOTTreeGenerator
+    {
+
+        public static StringTemplate _treeST =
+            new StringTemplate(
+                "digraph {\n\n" +
+                "\tordering=out;\n" +
+                "\tranksep=.4;\n" +
+                "\tbgcolor=\"lightgrey\"; node [shape=box, fixedsize=false, fontsize=12, fontname=\"Helvetica-bold\", fontcolor=\"blue\"\n" +
+                "\t\twidth=.25, height=.25, color=\"black\", fillcolor=\"white\", style=\"filled, solid, bold\"];\n" +
+                "\tedge [arrowsize=.5, color=\"black\", style=\"bold\"]\n\n" +
+                "  $nodes$\n" +
+                "  $edges$\n" +
+                "}\n" );
+
+        public static StringTemplate _nodeST =
+                new StringTemplate( "$name$ [label=\"$text$\"];\n" );
+
+        public static StringTemplate _edgeST =
+                new StringTemplate( "$parent$ -> $child$ // \"$parentText$\" -> \"$childText$\"\n" );
+
+        /** Track node to number mapping so we can get proper node name back */
+        Dictionary<object, int> nodeToNumberMap = new Dictionary<object, int>();
+
+        /** Track node number so we can get unique node names */
+        int nodeNumber = 0;
+
+        public virtual StringTemplate toDOT( object tree,
+                                    ITreeAdaptor adaptor,
+                                    StringTemplate _treeST,
+                                    StringTemplate _edgeST )
+        {
+            StringTemplate treeST = _treeST.getInstanceOf();
+            nodeNumber = 0;
+            toDOTDefineNodes( tree, adaptor, treeST );
+            nodeNumber = 0;
+            toDOTDefineEdges( tree, adaptor, treeST );
+            /*
+            if ( adaptor.getChildCount(tree)==0 ) {
+                // single node, don't do edge.
+                treeST.setAttribute("nodes", adaptor.getText(tree));
+            }
+            */
+            return treeST;
+        }
+
+        public virtual StringTemplate toDOT( object tree,
+                                    ITreeAdaptor adaptor )
+        {
+            return toDOT( tree, adaptor, _treeST, _edgeST );
+        }
+
+        /** Generate DOT (graphviz) for a whole tree not just a node.
+         *  For example, 3+4*5 should generate:
+         *
+         * digraph {
+         *   node [shape=plaintext, fixedsize=true, fontsize=11, fontname="Courier",
+         *         width=.4, height=.2];
+         *   edge [arrowsize=.7]
+         *   "+"->3
+         *   "+"->"*"
+         *   "*"->4
+         *   "*"->5
+         * }
+         *
+         * Return the ST not a string in case people want to alter.
+         *
+         * Takes a Tree interface object.
+         */
+        public virtual StringTemplate toDOT( ITree tree )
+        {
+            return toDOT( tree, new CommonTreeAdaptor() );
+        }
+
+        protected virtual void toDOTDefineNodes( object tree, ITreeAdaptor adaptor, StringTemplate treeST )
+        {
+            if ( tree == null )
+            {
+                return;
+            }
+            int n = adaptor.GetChildCount( tree );
+            if ( n == 0 )
+            {
+                // must have already dumped as child from previous
+                // invocation; do nothing
+                return;
+            }
+
+            // define parent node
+            StringTemplate parentNodeST = getNodeST( adaptor, tree );
+            treeST.setAttribute( "nodes", parentNodeST );
+
+            // for each child, do a "<unique-name> [label=text]" node def
+            for ( int i = 0; i < n; i++ )
+            {
+                object child = adaptor.GetChild( tree, i );
+                StringTemplate nodeST = getNodeST( adaptor, child );
+                treeST.setAttribute( "nodes", nodeST );
+                toDOTDefineNodes( child, adaptor, treeST );
+            }
+        }
+
+        protected virtual void toDOTDefineEdges( object tree, ITreeAdaptor adaptor, StringTemplate treeST )
+        {
+            if ( tree == null )
+            {
+                return;
+            }
+            int n = adaptor.GetChildCount( tree );
+            if ( n == 0 )
+            {
+                // must have already dumped as child from previous
+                // invocation; do nothing
+                return;
+            }
+
+            string parentName = "n" + getNodeNumber( tree );
+
+            // for each child, do a parent -> child edge using unique node names
+            string parentText = adaptor.GetText( tree );
+            for ( int i = 0; i < n; i++ )
+            {
+                object child = adaptor.GetChild( tree, i );
+                string childText = adaptor.GetText( child );
+                string childName = "n" + getNodeNumber( child );
+                StringTemplate edgeST = _edgeST.getInstanceOf();
+                edgeST.setAttribute( "parent", parentName );
+                edgeST.setAttribute( "child", childName );
+                edgeST.setAttribute( "parentText", fixString( parentText ) );
+                edgeST.setAttribute( "childText", fixString( childText ) );
+                treeST.setAttribute( "edges", edgeST );
+                toDOTDefineEdges( child, adaptor, treeST );
+            }
+        }
+
+        protected virtual StringTemplate getNodeST( ITreeAdaptor adaptor, object t )
+        {
+            string text = adaptor.GetText( t );
+            StringTemplate nodeST = _nodeST.getInstanceOf();
+            string uniqueName = "n" + getNodeNumber( t );
+            nodeST.setAttribute( "name", uniqueName );
+            nodeST.setAttribute( "text", fixString( text ) );
+            return nodeST;
+        }
+
+        protected virtual int getNodeNumber( object t )
+        {
+            int i;
+            if ( nodeToNumberMap.TryGetValue( t, out i ) )
+            {
+                return i;
+            }
+            else
+            {
+                nodeToNumberMap[t] = nodeNumber;
+                nodeNumber++;
+                return nodeNumber - 1;
+            }
+        }
+
+        protected virtual string fixString( string text )
+        {
+            if ( text != null )
+            {
+                text = System.Text.RegularExpressions.Regex.Replace( text, "\"", "\\\\\"" );
+                text = System.Text.RegularExpressions.Regex.Replace( text, "\\t", "    " );
+                text = System.Text.RegularExpressions.Regex.Replace( text, "\\n", "\\\\n" );
+                text = System.Text.RegularExpressions.Regex.Replace( text, "\\r", "\\\\r" );
+
+                if ( text.Length > 20 )
+                    text = text.Substring( 0, 8 ) + "..." + text.Substring( text.Length - 8 );
+            }
+
+            return text;
+        }
+    }
+}
diff --git a/Antlr3.StringTemplate/StringTemplate.cs b/Antlr3.StringTemplate/StringTemplate.cs
new file mode 100644
index 0000000..3e2e10a
--- /dev/null
+++ b/Antlr3.StringTemplate/StringTemplate.cs
@@ -0,0 +1,2245 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2003-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST
+{
+    using System;
+    using System.Collections.Generic;
+    using System.Linq;
+    using Antlr.Runtime.JavaExtensions;
+    using Antlr3.ST.Language;
+
+    using CommonToken = Antlr.Runtime.CommonToken;
+    using CommonTokenStream = Antlr.Runtime.CommonTokenStream;
+    using CommonTree = Antlr.Runtime.Tree.CommonTree;
+    using ConstructorInfo = System.Reflection.ConstructorInfo;
+    using ICollection = System.Collections.ICollection;
+    using IDictionary = System.Collections.IDictionary;
+    using IList = System.Collections.IList;
+    using IOException = System.IO.IOException;
+    using ITree = Antlr.Runtime.Tree.ITree;
+    using Lexer = Antlr.Runtime.Lexer;
+    using RecognitionException = Antlr.Runtime.RecognitionException;
+    using StringBuilder = System.Text.StringBuilder;
+    using StringReader = System.IO.StringReader;
+    using StringWriter = System.IO.StringWriter;
+    using TargetInvocationException = System.Reflection.TargetInvocationException;
+    using TextReader = System.IO.TextReader;
+
+    /** <summary>
+     *  A <tt>StringTemplate</tt> is a "document" with holes in it where you can stick
+     *  values.  <tt>StringTemplate</tt> breaks up your template into chunks of text and
+     *  attribute expressions.  <tt>StringTemplate</tt> ignores everything outside
+     *  of attribute expressions, treating it as just text to spit
+     *  out when you call <tt>StringTemplate.toString()</tt>.
+     *  </summary>
+     */
+    public class StringTemplate
+    {
+        public const string VERSION = "3.3a"; // August 11, 2008
+
+        /** <summary>&lt;@r()&gt;</summary> */
+        public const int REGION_IMPLICIT = 1;
+        /** <summary>&lt;@r&gt;...&lt;@end&gt;</summary> */
+        public const int REGION_EMBEDDED = 2;
+        /** <summary>@t.r() ::= "..." defined manually by coder</summary> */
+        public const int REGION_EXPLICIT = 3;
+
+        /** <summary>An automatically created aggregate of properties.</summary>
+         *
+         *  <remarks>
+         *  I often have lists of things that need to be formatted, but the list
+         *  items are actually pieces of data that are not already in an object.  I
+         *  need ST to do something like:
+         *
+         *  Ter=3432
+         *  Tom=32234
+         *  ....
+         *
+         *  using template:
+         *
+         *  $items:{$attr.name$=$attr.type$}$
+         *
+         *  This example will call getName() on the objects in items attribute, but
+         *  what if they aren't objects?  I have perhaps two parallel arrays
+         *  instead of a single array of objects containing two fields.  One
+         *  solution is allow Maps to be handled like properties so that it.name
+         *  would fail getName() but then see that it's a Map and do
+         *  it.get("name") instead.
+         *
+         *  This very clean approach is espoused by some, but the problem is that
+         *  it's a hole in my separation rules.  People can put the logic in the
+         *  view because you could say: "go get bob's data" in the view:
+         *
+         *  Bob's Phone: $db.bob.phone$
+         *
+         *  A view should not be part of the program and hence should never be able
+         *  to go ask for a specific person's data.
+         *
+         *  After much thought, I finally decided on a simple solution.  I've
+         *  added setAttribute variants that pass in multiple property values,
+         *  with the property names specified as part of the name using a special
+         *  attribute name syntax: "name.{propName1,propName2,...}".  This
+         *  object is a special kind of HashMap that hopefully prevents people
+         *  from passing a subclass or other variant that they have created as
+         *  it would be a loophole.  Anyway, the ASTExpr.getObjectProperty()
+         *  method looks for Aggregate as a special case and does a get() instead
+         *  of getPropertyName.
+         *  </remarks>
+         */
+        public sealed class Aggregate
+        {
+            Dictionary<string, object> properties = new Dictionary<string, object>();
+            /** <summary>
+             *  Allow StringTemplate to add values, but prevent the end
+             *  user from doing so.
+             *  </summary>
+             */
+            public void put( string propName, object propValue )
+            {
+                properties[propName] = propValue;
+            }
+            public object get( string propName )
+            {
+                object value;
+                if ( properties.TryGetValue( propName, out value ) )
+                    return value;
+
+                return null;
+            }
+            public override string ToString()
+            {
+                return properties.ToString();
+            }
+        }
+
+        /** <summary>
+         *  Just an alias for ArrayList, but this way I can track whether a
+         *  list is something ST created or it's an incoming list.
+         *  </summary>
+         */
+        public sealed class STAttributeList : List<object>
+        {
+            public STAttributeList( int size ) : base( size )
+            {
+            }
+            public STAttributeList()
+            {
+            }
+        }
+
+        public const string ANONYMOUS_ST_NAME = "anonymous";
+
+        /** <summary>Track probable issues like setting attribute that is not referenced.</summary> */
+        static bool _lintMode = false;
+
+        List<string> _referencedAttributes = null;
+
+        /** <summary>What's the name of this template?</summary> */
+        string _name = ANONYMOUS_ST_NAME;
+
+        static int _templateCounter = 0;
+        static int getNextTemplateCounter()
+        {
+            return System.Threading.Interlocked.Increment( ref _templateCounter );
+        }
+        /** <summary>
+         *  Reset the template ID counter to 0; public so that testing routine
+         *  can access but not really of interest to the user.
+         *  </summary>
+         */
+        public static void resetTemplateCounter()
+        {
+            _templateCounter = 0;
+        }
+
+        int _templateID = getNextTemplateCounter();
+
+        /** <summary>
+         *  Enclosing instance if I'm embedded within another template.
+         *  IF-subtemplates are considered embedded as well.
+         *  </summary>
+         */
+        StringTemplate _enclosingInstance = null;
+
+        /** <summary>
+         *  If this template is an embedded template such as when you apply
+         *  a template to an attribute, then the arguments passed to this
+         *  template represent the argument context--a set of values
+         *  computed by walking the argument assignment list.  For example,
+         *  &lt;name:bold(item=name, foo="x")&gt; would result in an
+         *  argument context of {[item=name], [foo="x"]} for this
+         *  template.  This template would be the bold() template and
+         *  the enclosingInstance would point at the template that held
+         *  that &lt;name:bold(...)&gt; template call.  When you want to get
+         *  an attribute value, you first check the attributes for the
+         *  'self' template then the arg context then the enclosingInstance
+         *  like resolving variables in pascal-like language with nested
+         *  procedures.
+         *  </summary>
+         *
+         *  <remarks>
+         *  With multi-valued attributes such as &lt;faqList:briefFAQDisplay()&gt;
+         *  attribute "i" is set to 1..n.
+         *  </remarks>
+         */
+        Dictionary<string, object> _argumentContext = null;
+
+        /** <summary>
+         *  If this template is embedded in another template, the arguments
+         *  must be evaluated just before each application when applying
+         *  template to a list of values.  The "it" attribute must change
+         *  with each application so that $names:bold(item=it)$ works.  If
+         *  you evaluate once before starting the application loop then it
+         *  has a single fixed value.  Eval.g saves the AST rather than evaluating
+         *  before invoking applyListOfAlternatingTemplates().  Each iteration
+         *  of a template application to a multi-valued attribute, these args
+         *  are re-evaluated with an initial context of {[it=...], [i=...]}.
+         *  </summary>
+         */
+        StringTemplateAST _argumentsAST = null;
+
+        /** <summary>
+         *  When templates are defined in a group file format, the attribute
+         *  list is provided including information about attribute cardinality
+         *  such as present, optional, ...  When this information is available,
+         *  rawSetAttribute should do a quick existence check as should the
+         *  invocation of other templates.  So if you ref bold(item="foo") but
+         *  item is not defined in bold(), then an exception should be thrown.
+         *  When actually rendering the template, the cardinality is checked.
+         *  This is a Map&lt;String,FormalArgument>.
+         *  </summary>
+         */
+        IList<FormalArgument> _formalArguments = FormalArgument.UNKNOWN;
+
+        /** <summary>
+         *  How many formal arguments to this template have default values
+         *  specified?
+         *  </summary>
+         */
+        int _numberOfDefaultArgumentValues = 0;
+
+        /** <summary>
+         *  Normally, formal parameters hide any attributes inherited from the
+         *  enclosing template with the same name.  This is normally what you
+         *  want, but makes it hard to invoke another template passing in all
+         *  the data.  Use notation now: &lt;otherTemplate(...)> to say "pass in
+         *  all data".  Works great.  Can also say &lt;otherTemplate(foo="xxx",...)>
+         *  </summary>
+         */
+        bool _passThroughAttributes = false;
+
+        /** <summary>
+         *  What group originally defined the prototype for this template?
+         *  This affects the set of templates I can refer to.  super.t() must
+         *  always refer to the super of the original group.
+         *  </summary>
+         *
+         *  <remarks>
+         *  group base;
+         *  t ::= "base";
+         *
+         *  group sub;
+         *  t ::= "super.t()2"
+         *
+         *  group subsub;
+         *  t ::= "super.t()3"
+         *  </remarks>
+         */
+        StringTemplateGroup _nativeGroup;
+
+        /** <summary>
+         *  This template was created as part of what group?  Even if this
+         *  template was created from a prototype in a supergroup, its group
+         *  will be the subgroup.  That's the way polymorphism works.
+         *  </summary>
+         */
+        StringTemplateGroup _group;
+
+
+        /** <summary>If this template is defined within a group file, what line number?</summary> */
+        int _groupFileLine;
+
+        /** <summary>Where to report errors</summary> */
+        IStringTemplateErrorListener _listener = null;
+
+        /** <summary>
+         *  The original, immutable pattern/language (not really used again after
+         *  initial "compilation", setup/parsing).
+         *  </summary>
+         */
+        string _pattern;
+
+        /** <summary>
+         *  Map an attribute name to its value(s).  These values are set by outside
+         *  code via st.setAttribute(name, value).  StringTemplate is like self in
+         *  that a template is both the "class def" and "instance".  When you
+         *  create a StringTemplate or setTemplate, the text is broken up into chunks
+         *  (i.e., compiled down into a series of chunks that can be evaluated later).
+         *  You can have multiple
+         *  </summary>
+         */
+        protected internal IDictionary<string, object> attributes;
+
+        /** <summary>
+         *  A Map&lt;Class,Object> that allows people to register a renderer for
+         *  a particular kind of object to be displayed in this template.  This
+         *  overrides any renderer set for this template's group.
+         *  </summary>
+         *
+         *  <remarks>
+         *  Most of the time this map is not used because the StringTemplateGroup
+         *  has the general renderer map for all templates in that group.
+         *  Sometimes though you want to override the group's renderers.
+         *  </remarks>
+          */
+        Dictionary<Type, IAttributeRenderer> _attributeRenderers;
+
+        /** <summary>
+         *  A list of alternating string and ASTExpr references.
+         *  This is compiled to when the template is loaded/defined and walked to
+         *  write out a template instance.
+         *  </summary>
+         */
+        List<Expr> _chunks;
+
+        /** <summary>If someone refs &lt;@r()> in template t, an implicit
+         *
+         *   @t.r() ::= ""
+         *
+         *  is defined, but you can overwrite this def by defining your
+         *  own.  We need to prevent more than one manual def though.  Between
+         *  this var and isEmbeddedRegion we can determine these cases.
+         *  </summary>
+         */
+        int _regionDefType;
+
+        /** <summary>
+         *  Does this template come from a &lt;@region>...&lt;@end> embedded in
+         *  another template?
+         *  </summary>
+         */
+        bool _isRegion;
+
+        /** <summary>Set of implicit and embedded regions for this template</summary> */
+        HashSet<object> _regions;
+
+        public static StringTemplateGroup defaultGroup =
+            new StringTemplateGroup( "defaultGroup", "." );
+
+        /** <summary>Create a blank template with no pattern and no attributes</summary> */
+        public StringTemplate()
+        {
+            _group = defaultGroup; // make sure has a group even if default
+        }
+
+        /** <summary>
+         *  Create an anonymous template.  It has no name just
+         *  chunks (which point to this anonymous template) and attributes.
+         *  </summary>
+         */
+        public StringTemplate( string template )
+            : this( null, template )
+        {
+        }
+
+        public StringTemplate( string template, Type lexer )
+            : this()
+        {
+            setGroup( new StringTemplateGroup( "defaultGroup", lexer ) );
+            setTemplate( template );
+        }
+
+        /** <summary>Create an anonymous template with no name, but with a group</summary> */
+        public StringTemplate( StringTemplateGroup group, string template )
+            : this()
+        {
+            if ( group != null )
+            {
+                setGroup( group );
+            }
+            setTemplate( template );
+        }
+
+        public StringTemplate( StringTemplateGroup group,
+                              string template,
+                              IDictionary<string, object> attributes )
+            : this( group, template )
+        {
+            this.attributes = attributes;
+        }
+
+        #region PIXEL MINE ADDED
+
+        public Dictionary<string, object> ArgumentContext
+        {
+            get
+            {
+                return getArgumentContext();
+            }
+            set
+            {
+                setArgumentContext( value );
+            }
+        }
+
+        public StringTemplateAST ArgumentsAST
+        {
+            get
+            {
+                return getArgumentsAST();
+            }
+            set
+            {
+                setArgumentsAST( value );
+            }
+        }
+
+        public IDictionary<string, object> Attributes
+        {
+            get
+            {
+                return getAttributes();
+            }
+            set
+            {
+                setAttributes( value );
+            }
+        }
+
+        public IList<Expr> Chunks
+        {
+            get
+            {
+                return getChunks();
+            }
+        }
+
+        public StringTemplate EnclosingInstance
+        {
+            get
+            {
+                return getEnclosingInstance();
+            }
+            set
+            {
+                setEnclosingInstance( value );
+            }
+        }
+
+        public IStringTemplateErrorListener ErrorListener
+        {
+            get
+            {
+                return getErrorListener();
+            }
+            set
+            {
+                setErrorListener( value );
+            }
+        }
+
+        public StringTemplateGroup Group
+        {
+            get
+            {
+                return getGroup();
+            }
+            set
+            {
+                setGroup( value );
+            }
+        }
+
+        public int GroupFileLine
+        {
+            get
+            {
+                return getGroupFileLine();
+            }
+            set
+            {
+                setGroupFileLine( value );
+            }
+        }
+
+        public IEnumerable<FormalArgument> FormalArguments
+        {
+            get
+            {
+                return getFormalArguments();
+            }
+        }
+
+        public bool IsRegion
+        {
+            get
+            {
+                return getIsRegion();
+            }
+            set
+            {
+                setIsRegion( value );
+            }
+        }
+
+        public static bool LintMode
+        {
+            get
+            {
+                return inLintMode();
+            }
+            set
+            {
+                setLintMode( value );
+            }
+        }
+
+        public string Name
+        {
+            get
+            {
+                return getName();
+            }
+            set
+            {
+                setName( value );
+            }
+        }
+
+        public StringTemplateGroup NativeGroup
+        {
+            get
+            {
+                return getNativeGroup();
+            }
+            set
+            {
+                setNativeGroup( value );
+            }
+        }
+
+        public StringTemplate OutermostEnclosingInstance
+        {
+            get
+            {
+                return getOutermostEnclosingInstance();
+            }
+        }
+
+        public string OutermostName
+        {
+            get
+            {
+                return getOutermostName();
+            }
+        }
+
+        public int RegionDefType
+        {
+            get
+            {
+                return getRegionDefType();
+            }
+            set
+            {
+                setRegionDefType( value );
+            }
+        }
+
+        public string Template
+        {
+            get
+            {
+                return getTemplate();
+            }
+            set
+            {
+                setTemplate( value );
+            }
+        }
+
+        public string TemplateDeclaratorString
+        {
+            get
+            {
+                return getTemplateDeclaratorString();
+            }
+        }
+
+        public int TemplateID
+        {
+            get
+            {
+                return getTemplateID();
+            }
+        }
+
+        #endregion
+
+        /** <summary>
+         *  Make the 'to' template look exactly like the 'from' template
+         *  except for the attributes.  This is like creating an instance
+         *  of a class in that the executable code is the same (the template
+         *  chunks), but the instance data is blank (the attributes).  Do
+         *  not copy the enclosingInstance pointer since you will want this
+         *  template to eval in a context different from the examplar.
+         *  </summary>
+         */
+        protected virtual void dup( StringTemplate from, StringTemplate to )
+        {
+            to._attributeRenderers = from._attributeRenderers;
+            to._pattern = from._pattern;
+            to._chunks = from._chunks;
+            to._formalArguments = from._formalArguments;
+            to._numberOfDefaultArgumentValues = from._numberOfDefaultArgumentValues;
+            to._name = from._name;
+            to._group = from._group;
+            to._nativeGroup = from._nativeGroup;
+            to._listener = from._listener;
+            to._regions = from._regions;
+            to._isRegion = from._isRegion;
+            to._regionDefType = from._regionDefType;
+        }
+
+        /** <summary>
+         *  Make an instance of this template; it contains an exact copy of
+         *  everything (except the attributes and enclosing instance pointer).
+         *  So the new template refers to the previously compiled chunks of this
+         *  template but does not have any attribute values.
+         *  </summary>
+         */
+        public virtual StringTemplate getInstanceOf()
+        {
+            StringTemplate t = null;
+            if ( _nativeGroup != null )
+            {
+                // create a template using the native group for this template
+                // but it's "group" is set to this.group by dup after creation so
+                // polymorphism still works.
+                t = _nativeGroup.createStringTemplate();
+            }
+            else
+            {
+                t = _group.createStringTemplate();
+            }
+            dup( this, t );
+            return t;
+        }
+
+        public virtual StringTemplate getEnclosingInstance()
+        {
+            return _enclosingInstance;
+        }
+
+        public virtual StringTemplate getOutermostEnclosingInstance()
+        {
+            if ( _enclosingInstance != null )
+            {
+                return _enclosingInstance.getOutermostEnclosingInstance();
+            }
+            return this;
+        }
+
+        public virtual void setEnclosingInstance( StringTemplate enclosingInstance )
+        {
+            if ( this == enclosingInstance )
+            {
+                throw new ArgumentException( "cannot embed template " + getName() + " in itself" );
+            }
+            // set the parent for this template
+            this._enclosingInstance = enclosingInstance;
+        }
+
+        public virtual Dictionary<string, object> getArgumentContext()
+        {
+            return _argumentContext;
+        }
+
+        public virtual void setArgumentContext( Dictionary<string, object> ac )
+        {
+            _argumentContext = ac;
+        }
+
+        public virtual StringTemplateAST getArgumentsAST()
+        {
+            return _argumentsAST;
+        }
+
+        public virtual void setArgumentsAST( StringTemplateAST argumentsAST )
+        {
+            this._argumentsAST = argumentsAST;
+        }
+
+        public virtual string getName()
+        {
+            return _name;
+        }
+
+        public virtual string getOutermostName()
+        {
+            if ( _enclosingInstance != null )
+            {
+                return _enclosingInstance.getOutermostName();
+            }
+            return getName();
+        }
+
+        public virtual void setName( string name )
+        {
+            this._name = name;
+        }
+
+        public virtual StringTemplateGroup getGroup()
+        {
+            return _group;
+        }
+
+        public virtual void setGroup( StringTemplateGroup group )
+        {
+            this._group = group;
+        }
+
+        public virtual StringTemplateGroup getNativeGroup()
+        {
+            return _nativeGroup;
+        }
+
+        public virtual void setNativeGroup( StringTemplateGroup nativeGroup )
+        {
+            this._nativeGroup = nativeGroup;
+        }
+
+        /** <summary>Return the outermost template's group file line number</summary> */
+        public virtual int getGroupFileLine()
+        {
+            if ( _enclosingInstance != null )
+            {
+                return _enclosingInstance.getGroupFileLine();
+            }
+            return _groupFileLine;
+        }
+
+        public virtual void setGroupFileLine( int groupFileLine )
+        {
+            this._groupFileLine = groupFileLine;
+        }
+
+        public virtual void setTemplate( string template )
+        {
+            this._pattern = template;
+            breakTemplateIntoChunks();
+        }
+
+        public virtual string getTemplate()
+        {
+            return _pattern;
+        }
+
+        public virtual void setErrorListener( IStringTemplateErrorListener listener )
+        {
+            this._listener = listener;
+        }
+
+        public virtual IStringTemplateErrorListener getErrorListener()
+        {
+            if ( _listener == null )
+            {
+                return _group.ErrorListener;
+            }
+            return _listener;
+        }
+
+        public virtual void reset()
+        {
+            attributes = new Dictionary<string, object>(); // just throw out table and make new one
+        }
+
+        public virtual void setPredefinedAttributes()
+        {
+            if ( !inLintMode() )
+            {
+                return; // only do this method so far in lint mode
+            }
+        }
+
+        public virtual void removeAttribute( string name )
+        {
+            if ( attributes != null )
+                attributes.Remove( name );
+        }
+
+        /** <summary>
+         *  Set an attribute for this template.  If you set the same
+         *  attribute more than once, you get a multi-valued attribute.
+         *  If you send in a StringTemplate object as a value, it's
+         *  enclosing instance (where it will inherit values from) is
+         *  set to 'this'.  This would be the normal case, though you
+         *  can set it back to null after this call if you want.
+         *  If you send in a List plus other values to the same
+         *  attribute, they all get flattened into one List of values.
+         *  This will be a new list object so that incoming objects are
+         *  not altered.
+         *  </summary>
+         *
+         *  <remarks>
+         *  If you send in an array, it is converted to an ArrayIterator.
+         *  </remarks>
+         */
+        public virtual void setAttribute( string name, object value )
+        {
+            if ( value == null || name == null )
+            {
+                return;
+            }
+            if ( name.IndexOf( '.' ) >= 0 )
+            {
+                throw new ArgumentException( "cannot have '.' in attribute names" );
+            }
+            if ( attributes == null )
+            {
+                attributes = new Dictionary<string, object>();
+            }
+
+            if ( value is StringTemplate )
+            {
+                ( (StringTemplate)value ).setEnclosingInstance( this );
+            }
+            else if ( value is HashSet<object> )
+            {
+                value = ( (HashSet<object>)value ).ToArray();
+            }
+            else
+            {
+                // convert value if array
+                value = ASTExpr.convertArrayToList( value );
+            }
+
+            // convert plain collections
+            // get exactly in this scope (no enclosing)
+            object o = this.attributes.get( name );
+            if ( o == null )
+            { // new attribute
+                rawSetAttribute( this.attributes, name, value );
+                return;
+            }
+            // it will be a multi-value attribute
+            //System.out.println("exists: "+name+"="+o);
+            STAttributeList v = null;
+            if ( o.GetType() == typeof( STAttributeList ) )
+            { // already a list made by ST
+                v = (STAttributeList)o;
+            }
+            else if ( o is IList )
+            { // existing attribute is non-ST List
+                // must copy to an ST-managed list before adding new attribute
+                IList listAttr = (IList)o;
+                v = new STAttributeList( listAttr.Count );
+                v.AddRange( listAttr.Cast<object>() );
+                rawSetAttribute( this.attributes, name, v ); // replace attribute w/list
+            }
+            else
+            {
+                // non-list second attribute, must convert existing to ArrayList
+                v = new STAttributeList(); // make list to hold multiple values
+                // make it point to list now
+                rawSetAttribute( this.attributes, name, v ); // replace attribute w/list
+                v.Add( o );  // add previous single-valued attribute
+            }
+            if ( value is IList )
+            {
+                // flatten incoming list into existing
+                if ( v != value )
+                { // avoid weird cyclic add
+                    v.AddRange( ( (IList)value ).Cast<object>() );
+                }
+            }
+            else
+            {
+                v.Add( value );
+            }
+        }
+
+        /** <summary>
+         *  Set an aggregate attribute with two values.  The attribute name
+         *  must have the format: "name.{propName1,propName2}".
+         *  </summary>
+         */
+        public virtual void setAttribute( string aggrSpec, object v1, object v2 )
+        {
+            setAttribute( aggrSpec, new object[] { v1, v2 } );
+        }
+
+        public virtual void setAttribute( string aggrSpec, object v1, object v2, object v3 )
+        {
+            setAttribute( aggrSpec, new object[] { v1, v2, v3 } );
+        }
+
+        public virtual void setAttribute( string aggrSpec, object v1, object v2, object v3, object v4 )
+        {
+            setAttribute( aggrSpec, new object[] { v1, v2, v3, v4 } );
+        }
+
+        public virtual void setAttribute( string aggrSpec, object v1, object v2, object v3, object v4, object v5 )
+        {
+            setAttribute( aggrSpec, new object[] { v1, v2, v3, v4, v5 } );
+        }
+
+        /** <summary>
+         *  Create an aggregate from the list of properties in aggrSpec and fill
+         *  with values from values array.  This is not publically visible because
+         *  it conflicts semantically with setAttribute("foo",new Object[] {...});
+         *  </summary>
+         */
+        protected virtual void setAttribute( string aggrSpec, params object[] values )
+        {
+            if ( values.Length < 2 )
+                throw new ArgumentException();
+
+            List<string> properties = new List<string>();
+            string aggrName = parseAggregateAttributeSpec( aggrSpec, properties );
+            if ( values == null || properties.Count == 0 )
+            {
+                throw new ArgumentException( "missing properties or values for '" + aggrSpec + "'" );
+            }
+            if ( values.Length != properties.Count )
+            {
+                throw new ArgumentException( "number of properties in '" + aggrSpec + "' != number of values" );
+            }
+            Aggregate aggr = new Aggregate();
+            for ( int i = 0; i < values.Length; i++ )
+            {
+                object value = values[i];
+                if ( value is StringTemplate )
+                {
+                    ( (StringTemplate)value ).setEnclosingInstance( this );
+                }
+                else
+                {
+                    value = ASTExpr.convertArrayToList( value );
+                }
+                aggr.put( properties[i], value );
+            }
+            setAttribute( aggrName, aggr );
+        }
+
+        /** <summary>
+         *  Split "aggrName.{propName1,propName2}" into list [propName1,propName2]
+         *  and the aggrName. Space is allowed around ','.
+         *  </summary>
+         */
+        protected virtual string parseAggregateAttributeSpec( string aggrSpec, List<string> properties )
+        {
+            int dot = aggrSpec.IndexOf( '.' );
+            if ( dot <= 0 )
+            {
+                throw new ArgumentException( "invalid aggregate attribute format: " +
+                        aggrSpec );
+            }
+            string aggrName = aggrSpec.Substring( 0, dot );
+            string propString = aggrSpec.Substring( dot + 1 );
+            bool error = true;
+            StringTokenizer tokenizer = new StringTokenizer( propString, "{,}", true );
+            //match:
+            if ( tokenizer.hasMoreTokens() )
+            {
+                string token = tokenizer.nextToken(); // advance to {
+                token = token.Trim();
+                if ( token.Equals( "{" ) )
+                {
+                    token = tokenizer.nextToken();    // advance to first prop name
+                    token = token.Trim();
+                    properties.Add( token );
+                    token = tokenizer.nextToken();    // advance to a comma
+                    token = token.Trim();
+                    while ( token.Equals( "," ) )
+                    {
+                        token = tokenizer.nextToken();    // advance to a prop name
+                        token = token.Trim();
+                        properties.Add( token );
+                        token = tokenizer.nextToken();    // advance to a "," or "}"
+                        token = token.Trim();
+                    }
+                    if ( token.Equals( "}" ) )
+                    {
+                        error = false;
+                    }
+                }
+            }
+            if ( error )
+            {
+                throw new ArgumentException( "invalid aggregate attribute format: " +
+                        aggrSpec );
+            }
+            return aggrName;
+        }
+
+        /** <summary>
+         *  Map a value to a named attribute.  Throw NoSuchElementException if
+         *  the named attribute is not formally defined in self's specific template
+         *  and a formal argument list exists.
+         *  </summary>
+         */
+        protected virtual void rawSetAttribute( IDictionary<string, object> attributes,
+                                       string name,
+                                       object value )
+        {
+            if ( _formalArguments != FormalArgument.UNKNOWN &&
+                getFormalArgument( name ) == null )
+            {
+                // a normal call to setAttribute with unknown attribute
+                throw new ArgumentException( "no such attribute: " + name +
+                                                 " in template context " +
+                                                 getEnclosingInstanceStackString() );
+            }
+            if ( value == null )
+            {
+                return;
+            }
+            attributes[name] = value;
+        }
+
+        /** <summary>
+         *  Argument evaluation such as foo(x=y), x must
+         *  be checked against foo's argument list not this's (which is
+         *  the enclosing context).  So far, only eval.g uses arg self as
+         *  something other than "this".
+         *  </summary>
+         */
+        public virtual void rawSetArgumentAttribute( StringTemplate embedded,
+                                            IDictionary attributes,
+                                            string name,
+                                            object value )
+        {
+            if ( embedded._formalArguments != FormalArgument.UNKNOWN &&
+                 embedded.getFormalArgument( name ) == null )
+            {
+                throw new ArgumentException( "template " + embedded.getName() +
+                                                 " has no such attribute: " + name +
+                                                 " in template context " +
+                                                 getEnclosingInstanceStackString() );
+            }
+            if ( value == null )
+            {
+                return;
+            }
+            attributes[name] = value;
+        }
+
+        public virtual object getAttribute( string name )
+        {
+            return get( this, name );
+        }
+
+        /** <summary>
+         *  Walk the chunks, asking them to write themselves out according
+         *  to attribute values of 'this.attributes'.  This is like evaluating or
+         *  interpreting the StringTemplate as a program using the
+         *  attributes.  The chunks will be identical (point at same list)
+         *  for all instances of this template.
+         *  </summary>
+         */
+        public virtual int write( IStringTemplateWriter writer )
+        {
+            if ( _group.debugTemplateOutput )
+            {
+                _group.emitTemplateStartDebugString( this, writer );
+            }
+            int n = 0;
+            setPredefinedAttributes();
+            setDefaultArgumentValues();
+            for ( int i = 0; _chunks != null && i < _chunks.Count; i++ )
+            {
+                Expr a = (Expr)_chunks[i];
+                int chunkN = a.write( this, writer );
+                // expr-on-first-line-with-no-output NEWLINE => NEWLINE
+                if ( chunkN == 0 && i == 0 && ( i + 1 ) < _chunks.Count &&
+                     _chunks[i + 1] is NewlineRef )
+                {
+                    //System.out.println("found pure first-line-blank \\n pattern");
+                    i++; // skip next NEWLINE;
+                    continue;
+                }
+                // NEWLINE expr-with-no-output NEWLINE => NEWLINE
+                // Indented $...$ have the indent stored with the ASTExpr
+                // so the indent does not come out as a StringRef
+                if ( chunkN == 0 &&
+                    ( i - 1 ) >= 0 && _chunks[i - 1] is NewlineRef &&
+                    ( i + 1 ) < _chunks.Count && _chunks[i + 1] is NewlineRef )
+                {
+                    //System.out.println("found pure \\n blank \\n pattern");
+                    i++; // make it skip over the next chunk, the NEWLINE
+                }
+                n += chunkN;
+            }
+            if ( _group.debugTemplateOutput )
+            {
+                _group.emitTemplateStopDebugString( this, writer );
+            }
+            if ( _lintMode )
+            {
+                checkForTrouble();
+            }
+            return n;
+        }
+
+        /** <summary>Resolve an attribute reference.</summary>
+         *
+         *  <remarks>
+         *  It can be in four possible places:
+         *
+         *  1. the attribute list for the current template
+         *  2. if self is an embedded template, somebody invoked us possibly
+         *     with arguments--check the argument context
+         *  3. if self is an embedded template, the attribute list for the enclosing
+         *     instance (recursively up the enclosing instance chain)
+         *  4. if nothing is found in the enclosing instance chain, then it might
+         *     be a map defined in the group or the its supergroup etc...
+         *
+         *  Attribute references are checked for validity.  If an attribute has
+         *  a value, its validity was checked before template rendering.
+         *  If the attribute has no value, then we must check to ensure it is a
+         *  valid reference.  Somebody could reference any random value like $xyz$;
+         *  formal arg checks before rendering cannot detect this--only the ref
+         *  can initiate a validity check.  So, if no value, walk up the enclosed
+         *  template tree again, this time checking formal parameters not
+         *  attributes Map.  The formal definition must exist even if no value.
+         *
+         *  To avoid infinite recursion in toString(), we have another condition
+         *  to check regarding attribute values.  If your template has a formal
+         *  argument, foo, then foo will hide any value available from "above"
+         *  in order to prevent infinite recursion.
+         *
+         *  This method is not static so people can override functionality.
+         *  </remarks>
+         */
+        public virtual object get( StringTemplate self, string attribute )
+        {
+            //System.out.println("### get("+self.getEnclosingInstanceStackString()+", "+attribute+")");
+            //System.out.println("attributes="+(self.attributes!=null?self.attributes.keySet().toString():"none"));
+            if ( self == null )
+            {
+                return null;
+            }
+
+            if ( _lintMode )
+            {
+                self.trackAttributeReference( attribute );
+            }
+
+            // is it here?
+            object o = null;
+            if ( self.attributes != null )
+            {
+                o = self.attributes.get( attribute );
+            }
+
+            // nope, check argument context in case embedded
+            if ( o == null )
+            {
+                IDictionary<string, object> argContext = self.getArgumentContext();
+                if ( argContext != null )
+                {
+                    o = argContext.get( attribute );
+                }
+            }
+
+            if ( o == null &&
+                 !self._passThroughAttributes &&
+                 self.getFormalArgument( attribute ) != null )
+            {
+                // if you've defined attribute as formal arg for this
+                // template and it has no value, do not look up the
+                // enclosing dynamic scopes.  This avoids potential infinite
+                // recursion.
+                return null;
+            }
+
+            // not locally defined, check enclosingInstance if embedded
+            if ( o == null && self._enclosingInstance != null )
+            {
+                /*
+                System.out.println("looking for "+getName()+"."+attribute+" in super="+
+                        enclosingInstance.getName());
+                */
+                object valueFromEnclosing = get( self._enclosingInstance, attribute );
+                if ( valueFromEnclosing == null )
+                {
+                    checkNullAttributeAgainstFormalArguments( self, attribute );
+                }
+                o = valueFromEnclosing;
+            }
+
+            // not found and no enclosing instance to look at
+            else if ( o == null && self._enclosingInstance == null )
+            {
+                // It might be a map in the group or supergroup...
+                o = self._group.getMap( attribute );
+            }
+
+            return o;
+        }
+
+        /** <summary>
+         *  Walk a template, breaking it into a list of
+         *  chunks: Strings and actions/expressions.
+         *  </summary>
+         */
+        protected virtual void breakTemplateIntoChunks()
+        {
+            //System.out.println("parsing template: "+pattern);
+            if ( _pattern == null )
+            {
+                return;
+            }
+            try
+            {
+                // instead of creating a specific template lexer, use
+                // an instance of the class specified by the user.
+                // The default is DefaultTemplateLexer.
+                // The only constraint is that you use an ANTLR lexer
+                // so I can use the special ChunkToken.
+                Type lexerClass = _group.TemplateLexerClass;
+                ConstructorInfo ctor =
+                        lexerClass.GetConstructor(
+                            new Type[] { typeof( StringTemplate ), typeof( TextReader ) }
+                        );
+                Lexer chunkStream =
+                        (Lexer)ctor.Invoke(
+                            new object[] { this, new StringReader( _pattern ) }
+                        );
+                //chunkStream.setTokenObjectClass("org.antlr.stringtemplate.language.ChunkToken");
+                //ITokenStream tokenStream = new CommonTokenStream(chunkStream);
+                //System.Diagnostics.Debug.Assert( tokenStream.LT( 1 ) is ChunkToken );
+                TemplateParser chunkifier = new TemplateParser( new CommonTokenStream( chunkStream ) );
+                chunkifier.template( this );
+                //System.out.println("chunks="+chunks);
+            }
+            catch ( Exception e )
+            {
+                string name = "<unknown>";
+                string outerName = getOutermostName();
+                if ( getName() != null )
+                {
+                    name = getName();
+                }
+                if ( outerName != null && !name.Equals( outerName ) )
+                {
+                    name = name + " nested in " + outerName;
+                }
+                error( "problem parsing template '" + name + "'", e );
+            }
+        }
+
+        public virtual ASTExpr parseAction( string action )
+        {
+            //System.out.println("parse action "+action);
+            ActionLexer lexer = new ActionLexer( new Antlr.Runtime.ANTLRStringStream( action.ToString() ) );
+            ActionParser parser =
+                new ActionParser( lexer, this );
+            //parser.setASTNodeClass("org.antlr.stringtemplate.language.StringTemplateAST");
+            //lexer.setTokenObjectClass("org.antlr.stringtemplate.language.StringTemplateToken");
+            ASTExpr a = null;
+            try
+            {
+                ActionParser.action_return result = parser.action();
+                IDictionary<string, object> options = result.opts;
+                ITree tree = (ITree)result.Tree;
+                if ( tree != null )
+                {
+                    if ( tree.Type == ActionParser.CONDITIONAL )
+                    {
+                        a = new ConditionalExpr( this, tree );
+                    }
+                    else
+                    {
+                        a = new ASTExpr( this, tree, options );
+                    }
+                }
+            }
+            catch ( RecognitionException re )
+            {
+                error( "Can't parse chunk: " + action.ToString(), re );
+            }
+            //catch (TokenStreamException tse) {
+            //    error("Can't parse chunk: "+action.toString(), tse);
+            //}
+            //catch ( Exception e )
+            //{
+            //    throw new NotImplementedException("Specific exception may need handling", e);
+            //}
+
+            return a;
+        }
+
+        public virtual int getTemplateID()
+        {
+            return _templateID;
+        }
+
+        public virtual IDictionary<string, object> getAttributes()
+        {
+            return attributes;
+        }
+
+        /** <summary>
+         *  Get a list of the strings and subtemplates and attribute
+         *  refs in a template.
+         *  </summary>
+         */
+        public virtual IList<Expr> getChunks()
+        {
+            return _chunks;
+        }
+
+        public virtual void addChunk( Expr e )
+        {
+            if ( _chunks == null )
+            {
+                _chunks = new List<Expr>();
+            }
+            _chunks.Add( e );
+        }
+
+        public virtual void setAttributes( IDictionary<string, object> attributes )
+        {
+            this.attributes = attributes;
+        }
+
+        #region Formal Arg Stuff
+
+        public virtual IList<FormalArgument> getFormalArguments()
+        {
+            return _formalArguments;
+        }
+
+        public virtual void setFormalArguments( IList<FormalArgument> args )
+        {
+            _formalArguments = args;
+        }
+
+        /** <summary>
+         *  Set any default argument values that were not set by the
+         *  invoking template or by setAttribute directly.  Note
+         *  that the default values may be templates.  Their evaluation
+         *  context is the template itself and, hence, can see attributes
+         *  within the template, any arguments, and any values inherited
+         *  by the template.
+         *  </summary>
+         *
+         *  <remarks>
+         *  Default values are stored in the argument context rather than
+         *  the template attributes table just for consistency's sake.
+         *  </remarks>
+         */
+        public virtual void setDefaultArgumentValues()
+        {
+            if ( _numberOfDefaultArgumentValues == 0 )
+            {
+                return;
+            }
+            if ( _argumentContext == null )
+            {
+                _argumentContext = new Dictionary<string, object>();
+            }
+            if ( _formalArguments != FormalArgument.UNKNOWN )
+            {
+                foreach ( FormalArgument arg in _formalArguments )
+                {
+                    string argName = arg.name;
+                    // use the default value then
+                    if ( arg.defaultValueST != null )
+                    {
+                        object existingValue = getAttribute( argName );
+                        if ( existingValue == null )
+                        { // value unset?
+                            // if no value for attribute, set arg context
+                            // to the default value.  We don't need an instance
+                            // here because no attributes can be set in
+                            // the arg templates by the user.
+                            _argumentContext[argName] = arg.defaultValueST;
+                        }
+                    }
+                }
+            }
+        }
+
+        /** <summary>
+         *  From this template upward in the enclosing template tree,
+         *  recursively look for the formal parameter.
+         *  </summary>
+         */
+        public virtual FormalArgument lookupFormalArgument( string name )
+        {
+            FormalArgument arg = getFormalArgument( name );
+            if ( arg == null && _enclosingInstance != null )
+            {
+                arg = _enclosingInstance.lookupFormalArgument( name );
+            }
+            return arg;
+        }
+
+        public virtual FormalArgument getFormalArgument( string name )
+        {
+            return _formalArguments.FirstOrDefault( fa => fa.name == name );
+        }
+
+        public virtual void defineEmptyFormalArgumentList()
+        {
+            setFormalArguments( new List<FormalArgument>() );
+        }
+
+        public virtual void defineFormalArgument( string name )
+        {
+            defineFormalArgument( name, null );
+        }
+
+        public virtual void defineFormalArguments( IList names )
+        {
+            if ( names == null )
+            {
+                return;
+            }
+            for ( int i = 0; i < names.Count; i++ )
+            {
+                string name = (string)names[i];
+                defineFormalArgument( name );
+            }
+        }
+
+        public virtual void defineFormalArgument( string name, StringTemplate defaultValue )
+        {
+            if ( defaultValue != null )
+            {
+                _numberOfDefaultArgumentValues++;
+            }
+            FormalArgument a = new FormalArgument( name, defaultValue );
+            if ( _formalArguments == FormalArgument.UNKNOWN )
+            {
+                _formalArguments = new List<FormalArgument>();
+            }
+            _formalArguments.Add( a );
+        }
+
+        #endregion
+
+        /** <summary>
+         *  Normally if you call template y from x, y cannot see any attributes
+         *  of x that are defined as formal parameters of y.  Setting this
+         *  passThroughAttributes to true, will override that and allow a
+         *  template to see through the formal arg list to inherited values.
+         *  </summary>
+         */
+        public virtual void setPassThroughAttributes( bool passThroughAttributes )
+        {
+            this._passThroughAttributes = passThroughAttributes;
+        }
+
+        /** <summary>
+         *  Specify a complete map of what object classes should map to which
+         *  renderer objects.
+         *  </summary>
+         */
+        public virtual void setAttributeRenderers( Dictionary<Type, IAttributeRenderer> renderers )
+        {
+            this._attributeRenderers = renderers;
+        }
+
+        /** <summary>
+         *  Register a renderer for all objects of a particular type.  This
+         *  overrides any renderer set in the group for this class type.
+         *  </summary>
+         */
+        public virtual void registerRenderer( Type attributeClassType, IAttributeRenderer renderer )
+        {
+            if ( _attributeRenderers == null )
+            {
+                _attributeRenderers = new Dictionary<Type, IAttributeRenderer>();
+            }
+            _attributeRenderers[attributeClassType] = renderer;
+        }
+
+        /** <summary>
+         *  What renderer is registered for this attributeClassType for
+         *  this template.  If not found, the template's group is queried.
+         *  </summary>
+         */
+        public virtual IAttributeRenderer getAttributeRenderer( Type attributeClassType )
+        {
+            IAttributeRenderer renderer = null;
+            if ( _attributeRenderers != null )
+            {
+                if ( !_attributeRenderers.TryGetValue( attributeClassType, out renderer ) )
+                    renderer = null;
+            }
+            if ( renderer != null )
+            {
+                // found it!
+                return renderer;
+            }
+
+            // we have no renderer overrides for the template or none for class arg
+            // check parent template if we are embedded
+            if ( _enclosingInstance != null )
+            {
+                return _enclosingInstance.getAttributeRenderer( attributeClassType );
+            }
+            // else check group
+            return _group.getAttributeRenderer( attributeClassType );
+        }
+
+        #region Utility routines
+
+        public virtual void error( string msg )
+        {
+            error( msg, null );
+        }
+
+        public virtual void warning( string msg )
+        {
+            if ( getErrorListener() != null )
+            {
+                getErrorListener().warning( msg );
+            }
+            else
+            {
+                Console.Error.WriteLine( "StringTemplate: warning: " + msg );
+            }
+        }
+
+        public virtual void error( string msg, Exception e )
+        {
+            if ( getErrorListener() != null )
+            {
+                getErrorListener().error( msg, e );
+            }
+            else
+            {
+                if ( e != null )
+                {
+                    Console.Error.WriteLine( "StringTemplate: error: " + msg + ": " + e.ToString() );
+                    if ( e is TargetInvocationException )
+                    {
+                        e = e.InnerException ?? e;
+                    }
+                    e.printStackTrace( Console.Error );
+                }
+                else
+                {
+                    Console.Error.WriteLine( "StringTemplate: error: " + msg );
+                }
+            }
+        }
+
+        /** <summary>
+         *  Make StringTemplate check your work as it evaluates templates.
+         *  Problems are sent to error listener.   Currently warns when
+         *  you set attributes that are not used.
+         *  </summary>
+         */
+        public static void setLintMode( bool lint )
+        {
+            StringTemplate._lintMode = lint;
+        }
+
+        public static bool inLintMode()
+        {
+            return _lintMode;
+        }
+
+        /** <summary>Indicates that 'name' has been referenced in this template.</summary> */
+        protected virtual void trackAttributeReference( string name )
+        {
+            if ( _referencedAttributes == null )
+            {
+                _referencedAttributes = new List<string>();
+            }
+            _referencedAttributes.Add( name );
+        }
+
+        /** <summary>
+         *  Look up the enclosing instance chain (and include this) to see
+         *  if st is a template already in the enclosing instance chain.
+         *  </summary>
+         */
+        public static bool isRecursiveEnclosingInstance( StringTemplate st )
+        {
+            if ( st == null )
+            {
+                return false;
+            }
+            StringTemplate p = st._enclosingInstance;
+            if ( p == st )
+            {
+                return true; // self-recursive
+            }
+            // now look for indirect recursion
+            while ( p != null )
+            {
+                if ( p == st )
+                {
+                    return true;
+                }
+                p = p._enclosingInstance;
+            }
+            return false;
+        }
+
+        string _newline = Environment.NewLine;
+
+        public virtual string getEnclosingInstanceStackTrace()
+        {
+            StringBuilder buf = new StringBuilder();
+            HashSet<object> seen = new HashSet<object>();
+            StringTemplate p = this;
+            while ( p != null )
+            {
+                if ( seen.Contains( p ) )
+                {
+                    buf.Append( p.getTemplateDeclaratorString() );
+                    buf.Append( " (start of recursive cycle)" );
+                    buf.Append( _newline );
+                    buf.Append( "..." );
+                    break;
+                }
+                seen.Add( p );
+                buf.Append( p.getTemplateDeclaratorString() );
+                if ( p.attributes != null )
+                {
+                    buf.Append( ", attributes=[" );
+                    int i = 0;
+                    foreach ( string attrName in p.attributes.Keys )
+                    {
+                        if ( i > 0 )
+                        {
+                            buf.Append( ", " );
+                        }
+                        i++;
+                        buf.Append( attrName );
+                        object o = p.attributes.get( attrName );
+                        if ( o is StringTemplate )
+                        {
+                            StringTemplate st = (StringTemplate)o;
+                            buf.Append( "=" );
+                            buf.Append( "<" );
+                            buf.Append( st.getName() );
+                            buf.Append( "()@" );
+                            buf.Append( st.getTemplateID().ToString() );
+                            buf.Append( ">" );
+                        }
+                        else if ( o is IList )
+                        {
+                            buf.Append( "=List[.." );
+                            IList list = (IList)o;
+                            int n = 0;
+                            for ( int j = 0; j < list.Count; j++ )
+                            {
+                                object listValue = list[j];
+                                if ( listValue is StringTemplate )
+                                {
+                                    if ( n > 0 )
+                                    {
+                                        buf.Append( ", " );
+                                    }
+                                    n++;
+                                    StringTemplate st = (StringTemplate)listValue;
+                                    buf.Append( "<" );
+                                    buf.Append( st.getName() );
+                                    buf.Append( "()@" );
+                                    buf.Append( st.getTemplateID().ToString() );
+                                    buf.Append( ">" );
+                                }
+                            }
+                            buf.Append( "..]" );
+                        }
+                    }
+                    buf.Append( "]" );
+                }
+                if ( p._referencedAttributes != null )
+                {
+                    buf.Append( ", references=" );
+                    buf.Append( "[" + string.Join( ", ", p._referencedAttributes.ToArray() ) + "]" );
+                }
+                buf.Append( ">" + _newline );
+                p = p._enclosingInstance;
+            }
+            /*
+                    if ( enclosingInstance!=null ) {
+                    buf.append(enclosingInstance.getEnclosingInstanceStackTrace());
+                    }
+                    */
+            return buf.ToString();
+        }
+
+        public virtual string getTemplateDeclaratorString()
+        {
+            StringBuilder buf = new StringBuilder();
+            buf.Append( "<" );
+            buf.Append( getName() );
+            buf.Append( "(" );
+            buf.Append( _formalArguments.Select( fa => fa.name ).ToList().ToElementString() );
+            buf.Append( ")@" );
+            buf.Append( getTemplateID().ToString() );
+            buf.Append( ">" );
+            return buf.ToString();
+        }
+
+        protected virtual string getTemplateHeaderString( bool showAttributes )
+        {
+            if ( showAttributes )
+            {
+                StringBuilder buf = new StringBuilder();
+                buf.Append( getName() );
+                if ( attributes != null )
+                {
+                    buf.Append( "[" + string.Join( ", ", attributes.Keys.Cast<object>().Select( o => o.ToString() ).ToArray() ) + "]" );
+                }
+                return buf.ToString();
+            }
+            return getName();
+        }
+
+#if false
+        /** <summary>
+         *  Find "missing attribute" and "cardinality mismatch" errors.
+         *  Excecuted before a template writes its chunks out.
+         *  When you find a problem, throw an IllegalArgumentException.
+         *  We must check the attributes as well as the incoming arguments
+         *  in argumentContext.
+         *  </summary>
+         */
+        protected void checkAttributesAgainstFormalArguments()
+        {
+            var args = FormalArguments;
+            /*
+            if ( (attributes==null||attributes.size()==0) &&
+                 (argumentContext==null||argumentContext.size()==0) &&
+                 formalArguments.size()!=0 )
+            {
+                throw new IllegalArgumentException("missing argument(s): "+args+" in template "+getName());
+            }
+            Iterator iter = args.iterator();
+            while ( iter.hasNext() )
+            {
+                String argName = (String)iter.next();
+                FormalArgument arg = getFormalArgument(argName);
+                int expectedCardinality = arg.getCardinality();
+                Object value = getAttribute(argName);
+                int actualCardinality = getActualArgumentCardinality(value);
+                // if intersection of expected and actual is empty, mismatch
+                if ( (expectedCardinality&actualCardinality)==0 )
+                {
+                    throw new IllegalArgumentException("cardinality mismatch: "+
+                            argName+"; expected "+
+                            FormalArgument.getCardinalityName(expectedCardinality)+
+                            " found cardinality="+getObjectLength(value));
+                }
+            }
+        }
+#endif
+
+        /** <summary>
+         *  A reference to an attribute with no value, must be compared against
+         *  the formal parameter to see if it exists; if it exists all is well,
+         *  but if not, throw an exception.
+         *  </summary>
+         *
+         *  <remarks>
+         *  Don't do the check if no formal parameters exist for this template;
+         *  ask enclosing.
+         *  </remarks>
+         */
+        protected virtual void checkNullAttributeAgainstFormalArguments(
+                StringTemplate self,
+                string attribute )
+        {
+            if ( self.getFormalArguments() == FormalArgument.UNKNOWN )
+            {
+                // bypass unknown arg lists
+                if ( self._enclosingInstance != null )
+                {
+                    checkNullAttributeAgainstFormalArguments(
+                            self._enclosingInstance,
+                            attribute );
+                }
+                return;
+            }
+            FormalArgument formalArg = self.lookupFormalArgument( attribute );
+            if ( formalArg == null )
+            {
+                throw new ArgumentException( "no such attribute: " + attribute +
+                                                 " in template context " + getEnclosingInstanceStackString() );
+            }
+        }
+
+        /** <summary>
+         *  Executed after evaluating a template.  For now, checks for setting
+         *  of attributes not reference.
+         *  </summary>
+         */
+        protected virtual void checkForTrouble()
+        {
+            // we have table of set values and list of values referenced
+            // compare, looking for SET BUT NOT REFERENCED ATTRIBUTES
+            if ( attributes == null )
+            {
+                return;
+            }
+            // if in names and not in referenced attributes, trouble
+            foreach ( string name in attributes.Keys )
+            {
+                if ( _referencedAttributes != null &&
+                    !_referencedAttributes.Contains( name ) )
+                {
+                    warning( getName() + ": set but not used: " + name );
+                }
+            }
+            // can do the reverse, but will have lots of false warnings :(
+        }
+
+        /** <summary>
+         *  If an instance of x is enclosed in a y which is in a z, return
+         *  a String of these instance names in order from topmost to lowest;
+         *  here that would be "[z y x]".
+         *  </summary>
+         */
+        public virtual string getEnclosingInstanceStackString()
+        {
+            System.Collections.Generic.List<string> names = new System.Collections.Generic.List<string>();
+            StringTemplate p = this;
+            while ( p != null )
+            {
+                string name = p.getName();
+                names.Insert( 0, name + ( p._passThroughAttributes ? "(...)" : "" ) );
+                p = p._enclosingInstance;
+            }
+            return "[" + string.Join( " ", names.ToArray() ) + "]";
+        }
+
+        public virtual bool getIsRegion()
+        {
+            return _isRegion;
+        }
+
+        public virtual void setIsRegion( bool isRegion )
+        {
+            this._isRegion = isRegion;
+        }
+
+        public virtual void addRegionName( string name )
+        {
+            if ( _regions == null )
+            {
+                _regions = new HashSet<object>();
+            }
+            _regions.Add( name );
+        }
+
+        /** <summary>Does this template ref or embed region name?</summary> */
+        public virtual bool containsRegionName( string name )
+        {
+            if ( _regions == null )
+            {
+                return false;
+            }
+            return _regions.Contains( name );
+        }
+
+        public virtual int getRegionDefType()
+        {
+            return _regionDefType;
+        }
+
+        public virtual void setRegionDefType( int regionDefType )
+        {
+            this._regionDefType = regionDefType;
+        }
+
+        public virtual string toDebugString()
+        {
+            StringBuilder buf = new StringBuilder();
+            buf.Append( "template-" + getTemplateDeclaratorString() + ":" );
+            buf.Append( "chunks=" );
+            if ( _chunks != null )
+            {
+                buf.Append( _chunks.ToString() );
+            }
+            buf.Append( "attributes=[" );
+            if ( attributes != null )
+            {
+                int n = 0;
+                foreach ( string name in attributes.Keys )
+                {
+                    if ( n > 0 )
+                    {
+                        buf.Append( ',' );
+                    }
+                    buf.Append( name + "=" );
+                    object value = attributes.get( name );
+                    if ( value is StringTemplate )
+                    {
+                        buf.Append( ( (StringTemplate)value ).toDebugString() );
+                    }
+                    else
+                    {
+                        buf.Append( value );
+                    }
+                    n++;
+                }
+                buf.Append( "]" );
+            }
+            return buf.ToString();
+        }
+
+        /** <summary>
+         *  Don't print values, just report the nested structure with attribute names.
+         *  Follow (nest) attributes that are templates only.
+         *  </summary>
+         */
+        public virtual string toStructureString()
+        {
+            return toStructureString( 0 );
+        }
+
+        public virtual string toStructureString( int indent )
+        {
+            StringBuilder buf = new StringBuilder();
+            for ( int i = 1; i <= indent; i++ )
+            { // indent
+                buf.Append( "  " );
+            }
+            buf.Append( getName() );
+            buf.Append( attributes.Keys );
+            buf.Append( ":" + _newline );
+            if ( attributes != null )
+            {
+                foreach ( var attr in attributes )
+                {
+                    string name = attr.Key;
+                    object value = attr.Value;
+                    if ( value is StringTemplate )
+                    { // descend
+                        buf.Append( ( (StringTemplate)value ).toStructureString( indent + 1 ) );
+                    }
+                    else
+                    {
+                        if ( value is IList )
+                        {
+                            IList alist = (IList)value;
+                            for ( int i = 0; i < alist.Count; i++ )
+                            {
+                                object o = (object)alist[i];
+                                if ( o is StringTemplate )
+                                { // descend
+                                    buf.Append( ( (StringTemplate)o ).toStructureString( indent + 1 ) );
+                                }
+                            }
+                        }
+                        else if ( value is IDictionary )
+                        {
+                            IDictionary m = (IDictionary)value;
+                            ICollection mvalues = m.Values;
+                            foreach ( object o in mvalues )
+                            {
+                                if ( o is StringTemplate )
+                                { // descend
+                                    buf.Append( ( (StringTemplate)o ).toStructureString( indent + 1 ) );
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+            return buf.ToString();
+        }
+
+#if false
+        public String getDOTForDependencyGraph(bool showAttributes) {
+            StringBuffer buf = new StringBuffer();
+            buf.append("digraph prof {\n");
+            HashMap edges = new HashMap();
+            this.getDependencyGraph(edges, showAttributes);
+            Set sourceNodes = edges.keySet();
+            // for each source template
+            for (Iterator it = sourceNodes.iterator(); it.hasNext();) {
+                String src = (String) it.next();
+                Set targetNodes = (Set)edges.get(src);
+                // for each target template
+                for (Iterator it2 = targetNodes.iterator(); it2.hasNext();) {
+                    String trg = (String) it2.next();
+                    buf.append('"');
+                    buf.append(src);
+                    buf.append('"');
+                    buf.append("->");
+                    buf.append('"');
+                    buf.append(trg);
+                    buf.append("\"\n");
+                }
+            }
+            buf.append("}");
+            return buf.toString();
+        }
+#endif
+
+        /** <summary>
+         *  Generate a DOT file for displaying the template enclosure graph.
+         *  </summary>
+         *
+         *  <remarks>
+         *  For example:
+         *
+         *      digraph prof {
+         *          "t1" -> "t2"
+         *          "t1" -> "t3"
+         *          "t4" -> "t5"
+         *      }
+         *  </remarks>
+         */
+        public virtual StringTemplate getDOTForDependencyGraph( bool showAttributes )
+        {
+            string structure =
+                "digraph StringTemplateDependencyGraph {" + _newline +
+                "node [shape=$shape$, $if(width)$width=$width$,$endif$" +
+                "      $if(height)$height=$height$,$endif$ fontsize=$fontsize$];" + _newline +
+                "$edges:{e|\"$e.src$\" -> \"$e.trg$\"" + _newline + "}$" +
+                "}" + _newline;
+            StringTemplate graphST = new StringTemplate( structure );
+            Dictionary<object, object> edges = new Dictionary<object, object>();
+            this.getDependencyGraph( edges, showAttributes );
+            var sourceNodes = edges.Keys;
+            // for each source template
+            foreach ( string src in sourceNodes )
+            {
+                HashSet<object> targetNodes = (HashSet<object>)edges.get( src );
+                // for each target template
+                foreach ( string trg in targetNodes )
+                {
+                    graphST.setAttribute( "edges.{src,trg}", src, trg );
+                }
+            }
+            graphST.setAttribute( "shape", "none" );
+            graphST.setAttribute( "fontsize", "11" );
+            graphST.setAttribute( "height", "0" ); // make height
+            return graphST;
+        }
+
+        /** <summary>
+         *  Get a list of n->m edges where template n contains template m.
+         *  The map you pass in is filled with edges: key->value.  Useful
+         *  for having DOT print out an enclosing template graph.  It
+         *  finds all direct template invocations too like &lt;foo()> but not
+         *  indirect ones like &lt;(name)()>.
+         *  </summary>
+         *
+         *  <remarks>
+         *  Ack, I just realized that this is done statically and hence
+         *  cannot see runtime arg values on statically included templates.
+         *  Hmm...someday figure out to do this dynamically as if we were
+         *  evaluating the templates.  There will be extra nodes in the tree
+         *  because we are static like method and method[...] with args.
+         *  </remarks>
+         */
+        public virtual void getDependencyGraph( IDictionary edges, bool showAttributes )
+        {
+            string srcNode = this.getTemplateHeaderString( showAttributes );
+            if ( attributes != null )
+            {
+                foreach ( var attr in attributes )
+                {
+                    string name = attr.Key;
+                    object value = attr.Value;
+                    if ( value is StringTemplate )
+                    {
+                        string targetNode =
+                            ( (StringTemplate)value ).getTemplateHeaderString( showAttributes );
+                        putToMultiValuedMap( edges, srcNode, targetNode );
+                        ( (StringTemplate)value ).getDependencyGraph( edges, showAttributes ); // descend
+                    }
+                    else
+                    {
+                        if ( value is IList )
+                        {
+                            IList alist = (IList)value;
+                            for ( int i = 0; i < alist.Count; i++ )
+                            {
+                                object o = (object)alist[i];
+                                if ( o is StringTemplate )
+                                {
+                                    string targetNode =
+                                        ( (StringTemplate)o ).getTemplateHeaderString( showAttributes );
+                                    putToMultiValuedMap( edges, srcNode, targetNode );
+                                    ( (StringTemplate)o ).getDependencyGraph( edges, showAttributes ); // descend
+                                }
+                            }
+                        }
+                        else if ( value is IDictionary )
+                        {
+                            IDictionary m = (IDictionary)value;
+                            ICollection mvalues = m.Values;
+                            foreach ( object o in mvalues )
+                            {
+                                if ( o is StringTemplate )
+                                {
+                                    string targetNode =
+                                        ( (StringTemplate)o ).getTemplateHeaderString( showAttributes );
+                                    putToMultiValuedMap( edges, srcNode, targetNode );
+                                    ( (StringTemplate)o ).getDependencyGraph( edges, showAttributes ); // descend
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+            // look in chunks too for template refs
+            for ( int i = 0; _chunks != null && i < _chunks.Count; i++ )
+            {
+                Expr expr = _chunks[i];
+                if ( expr is ASTExpr )
+                {
+                    ASTExpr e = (ASTExpr)expr;
+                    ITree tree = e.AST;
+                    ITree includeAST =
+                        new CommonTree( new CommonToken( ActionEvaluator.INCLUDE, "include" ) );
+                    var it = tree.findAllPartial( includeAST );
+                    foreach ( ITree t in it )
+                    {
+                        string templateInclude = t.GetChild( 0 ).Text;
+                        Console.Out.WriteLine( "found include " + templateInclude );
+                        putToMultiValuedMap( edges, srcNode, templateInclude );
+                        StringTemplateGroup group = getGroup();
+                        if ( group != null )
+                        {
+                            StringTemplate st = group.getInstanceOf( templateInclude );
+                            // descend into the reference template
+                            st.getDependencyGraph( edges, showAttributes );
+                        }
+                    }
+                }
+            }
+        }
+
+        /** <summary>Manage a hash table like it has multiple unique values.  Map&lt;Object,Set>.</summary> */
+        protected virtual void putToMultiValuedMap( IDictionary map, object key, object value )
+        {
+            HashSet<object> bag = (HashSet<object>)map[key];
+            if ( bag == null )
+            {
+                bag = new HashSet<object>();
+                map[key] = bag;
+            }
+            bag.Add( value );
+        }
+
+        public virtual void printDebugString()
+        {
+            Console.Out.WriteLine( "template-" + getName() + ":" );
+            Console.Out.Write( "chunks=" );
+            Console.Out.WriteLine( _chunks.ToString() );
+            if ( attributes == null )
+            {
+                return;
+            }
+            Console.Out.Write( "attributes=[" );
+            int n = 0;
+            foreach ( var attr in attributes )
+            {
+                if ( n > 0 )
+                {
+                    Console.Out.Write( ',' );
+                }
+                string name = attr.Key;
+                object value = attr.Value;
+                if ( value is StringTemplate )
+                {
+                    Console.Out.Write( name + "=" );
+                    ( (StringTemplate)value ).printDebugString();
+                }
+                else
+                {
+                    if ( value is IList )
+                    {
+                        List<object> alist = (List<object>)value;
+                        for ( int i = 0; i < alist.Count; i++ )
+                        {
+                            object o = (object)alist[i];
+                            Console.Out.Write( name + "[" + i + "] is " + o.GetType().Name + "=" );
+                            if ( o is StringTemplate )
+                            {
+                                ( (StringTemplate)o ).printDebugString();
+                            }
+                            else
+                            {
+                                Console.Out.WriteLine( o );
+                            }
+                        }
+                    }
+                    else
+                    {
+                        Console.Out.Write( name + "=" );
+                        Console.Out.WriteLine( value );
+                    }
+                }
+                n++;
+            }
+            Console.Out.Write( "]" + _newline );
+        }
+
+        public override string ToString()
+        {
+            return ToString( StringTemplateWriterConstants.NO_WRAP );
+        }
+
+        public virtual string ToString( int lineWidth )
+        {
+            StringWriter @out = new StringWriter();
+            // Write the output to a StringWriter
+            IStringTemplateWriter wr = _group.getStringTemplateWriter( @out );
+            wr.setLineWidth( lineWidth );
+            try
+            {
+                write( wr );
+            }
+            catch ( IOException /*io*/)
+            {
+                error( "Got IOException writing to writer " + wr.GetType().Name );
+            }
+            // reset so next toString() does not wrap; normally this is a new writer
+            // each time, but just in case they override the group to reuse the
+            // writer.
+            wr.setLineWidth( StringTemplateWriterConstants.NO_WRAP );
+            return @out.ToString();
+        }
+
+        #endregion
+
+    }
+}
diff --git a/Antlr3.StringTemplate/StringTemplateErrorListener.cs b/Antlr3.StringTemplate/StringTemplateErrorListener.cs
new file mode 100644
index 0000000..848f013
--- /dev/null
+++ b/Antlr3.StringTemplate/StringTemplateErrorListener.cs
@@ -0,0 +1,47 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2003-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST
+{
+    using System;
+
+    /** <summary>
+     *  Lets you specify where errors, warnings go. Warning: debug is useful at
+     *  the moment.
+     *  </summary>
+     */
+    public interface IStringTemplateErrorListener
+    {
+        void error( string msg, Exception e );
+        void warning( string msg );
+    }
+}
diff --git a/Antlr3.StringTemplate/StringTemplateGroup.cs b/Antlr3.StringTemplate/StringTemplateGroup.cs
new file mode 100644
index 0000000..613b1a3
--- /dev/null
+++ b/Antlr3.StringTemplate/StringTemplateGroup.cs
@@ -0,0 +1,1477 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2003-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST
+{
+    using System;
+    using System.Collections.Generic;
+    using System.Linq;
+    using Antlr.Runtime.JavaExtensions;
+
+    using AngleBracketTemplateLexer = Antlr3.ST.Language.AngleBracketTemplateLexer;
+    using ANTLRReaderStream = Antlr.Runtime.ANTLRReaderStream;
+    using Assembly = System.Reflection.Assembly;
+    using CommonTokenStream = Antlr.Runtime.CommonTokenStream;
+    using ConstructorInfo = System.Reflection.ConstructorInfo;
+    using DefaultTemplateLexer = Antlr3.ST.Language.TemplateLexer;
+    using Encoding = System.Text.Encoding;
+    using GroupLexer = Antlr3.ST.Language.GroupLexer;
+    using GroupParser = Antlr3.ST.Language.GroupParser;
+    using IDictionary = System.Collections.IDictionary;
+    using IList = System.Collections.IList;
+    using IOException = System.IO.IOException;
+    using MethodImpl = System.Runtime.CompilerServices.MethodImplAttribute;
+    using MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;
+    using Stream = System.IO.Stream;
+    using StreamReader = System.IO.StreamReader;
+    using StringBuilder = System.Text.StringBuilder;
+    using TextReader = System.IO.TextReader;
+    using TextWriter = System.IO.TextWriter;
+
+    /** <summary>
+     *  Manages a group of named mutually-referential StringTemplate objects.
+     *  Currently the templates must all live under a directory so that you
+     *  can reference them as foo.st or gutter/header.st.  To refresh a
+     *  group of templates, just create a new StringTemplateGroup and start
+     *  pulling templates from there.  Or, set the refresh interval.
+     *  </summary>
+     *
+     *  <remarks>
+     *  Use getInstanceOf(template-name) to get a string template
+     *  to fill in.
+     *
+     *  The name of a template is the file name minus ".st" ending if present
+     *  unless you name it as you load it.
+     *
+     *  You can use the group file format also to define a group of templates
+     *  (this works better for code gen than for html page gen).  You must give
+     *  a Reader to the ctor for it to load the group; this is general and
+     *  distinguishes it from the ctors for the old-style "load template files
+     *  from the disk".
+     *
+     *  10/2005 I am adding a StringTemplateGroupLoader concept so people can define supergroups
+     *  within a group and have it load that group automatically.
+     *  </remarks>
+     */
+    public class StringTemplateGroup
+    {
+        /** <summary>What is the group name</summary> */
+        string _name;
+
+        /** <summary>Maps template name to StringTemplate object</summary> */
+        Dictionary<string, StringTemplate> _templates = new Dictionary<string, StringTemplate>();
+
+        /** <summary>
+         *  Maps map names to HashMap objects.  This is the list of maps
+         *  defined by the user like typeInitMap ::= ["int":"0"]
+         *  </summary>
+         */
+        Dictionary<string, IDictionary> _maps = new Dictionary<string, IDictionary>();
+
+        /** <summary>How to pull apart a template into chunks?</summary> */
+        Type _templateLexerClass = null;
+
+        /** <summary>
+         *  You can set the lexer once if you know all of your groups use the
+         *  same separator.  If the instance has templateLexerClass set
+         *  then it is used as an override.
+         *  </summary>
+         */
+        static Type _defaultTemplateLexerClass = typeof( DefaultTemplateLexer );
+
+        /** <summary>
+         *  Under what directory should I look for templates?  If null,
+         *  to look into the CLASSPATH for templates as resources.
+         *  </summary>
+         */
+        string _rootDir;
+        Assembly _rootAssembly;
+
+        /** <summary>Track all groups by name; maps name to StringTemplateGroup</summary> */
+        //static Map _nameToGroupMap = System.Collections.Hashtable.Synchronized( new System.Collections.Hashtable() );
+        public static IDictionary<string, StringTemplateGroup> _nameToGroupMap = new Dictionary<string, StringTemplateGroup>();
+
+        /** <summary>Track all interfaces by name; maps name to StringTemplateGroupInterface</summary> */
+        //static Map _nameToInterfaceMap = System.Collections.Hashtable.Synchronized( new System.Collections.Hashtable() );
+        public static IDictionary<string, StringTemplateGroupInterface> _nameToInterfaceMap = new Dictionary<string, StringTemplateGroupInterface>();
+
+        /** <summary>
+         *  Are we derived from another group?  Templates not found in this group
+         *  will be searched for in the superGroup recursively.
+         *  </summary>
+         */
+        StringTemplateGroup _superGroup = null;
+
+        /** <summary>Keep track of all interfaces implemented by this group.</summary> */
+        List<StringTemplateGroupInterface> _interfaces = null;
+
+        /** <summary>
+         *  When templates are files on the disk, the refresh interval is used
+         *  to know when to reload.  When a Reader is passed to the ctor,
+         *  it is a stream full of template definitions.  The former is used
+         *  for web development, but the latter is most likely used for source
+         *  code generation for translators; a refresh is unlikely.  Anyway,
+         *  I decided to track the source of templates in case such info is useful
+         *  in other situations than just turning off refresh interval.  I just
+         *  found another: don't ever look on the disk for individual templates
+         *  if this group is a group file...immediately look into any super group.
+         *  If not in the super group, report no such template.
+         *  </summary>
+         */
+        bool _templatesDefinedInGroupFile = false;
+
+        /** <summary>
+         *  Normally AutoIndentWriter is used to filter output, but user can
+         *  specify a new one.
+         *  </summary>
+         */
+        Type _userSpecifiedWriter;
+
+        internal bool debugTemplateOutput = false;
+
+        /** <summary>The set of templates to ignore when dumping start/stop debug strings</summary> */
+        HashSet<string> _noDebugStartStopStrings;
+
+        /** <summary>
+         *  A Map&lt;Class,Object> that allows people to register a renderer for
+         *  a particular kind of object to be displayed for any template in this
+         *  group.  For example, a date should be formatted differently depending
+         *  on the locale.  You can set Date.class to an object whose
+         *  toString(Object) method properly formats a Date attribute
+         *  according to locale.  Or you can have a different renderer object
+         *  for each locale.
+         *  </summary>
+         *
+         *  <remarks>
+         *  These render objects are used way down in the evaluation chain
+         *  right before an attribute's toString() method would normally be
+         *  called in ASTExpr.write().
+         *
+         *  Synchronized at creation time.
+         *  </remarks>
+         */
+        Dictionary<Type, IAttributeRenderer> _attributeRenderers;
+
+#if false
+        /** <summary>
+         *  Maps obj.prop to a value to avoid reflection costs; track one
+         *  set of all class.property -> Member mappings for all ST usage in VM.
+         *  </summary>
+         */
+        protected static IDictionary classPropertyCache = new Dictionary<object, object>();
+
+        public class ClassPropCacheKey
+        {
+            Type c;
+            string propertyName;
+            public ClassPropCacheKey( Type c, string propertyName )
+            {
+                this.c = c;
+                this.propertyName = propertyName;
+            }
+
+            public override bool Equals( object other )
+            {
+                ClassPropCacheKey otherKey = (ClassPropCacheKey)other;
+                return c.Equals( otherKey.c ) &&
+                    propertyName.Equals( otherKey.propertyName );
+            }
+
+            public override int GetHashCode()
+            {
+                return c.GetHashCode() + propertyName.GetHashCode();
+            }
+        }
+#endif
+
+        /** <summary>
+         *  If a group file indicates it derives from a supergroup, how do we
+         *  find it?  Shall we make it so the initial StringTemplateGroup file
+         *  can be loaded via this loader?  Right now we pass a Reader to ctor
+         *  to distinguish from the other variety.
+         *  </summary>
+         */
+        static IStringTemplateGroupLoader _groupLoader = null;
+
+        /** <summary>
+         *  Where to report errors.  All string templates in this group
+         *  use this error handler by default.
+         *  </summary>
+         */
+        IStringTemplateErrorListener _listener = DEFAULT_ERROR_LISTENER;
+
+        class DefaultErrorListener : IStringTemplateErrorListener
+        {
+            public virtual void error( string s, Exception e )
+            {
+                Console.Error.WriteLine( s );
+                if ( e != null )
+                {
+                    e.printStackTrace( Console.Error );
+                }
+            }
+
+            public virtual void warning( string s )
+            {
+                Console.Out.WriteLine( s );
+            }
+        }
+
+        public static IStringTemplateErrorListener DEFAULT_ERROR_LISTENER = new DefaultErrorListener();
+
+        /** <summary>
+         *  Used to indicate that the template doesn't exist.
+         *  We don't have to check disk for it; we know it's not there.
+         *  </summary>
+         */
+        static readonly StringTemplate NOT_FOUND_ST = new StringTemplate();
+
+        /** <summary>How long before tossing out all templates in seconds.</summary> */
+        TimeSpan _refreshIntervalInSeconds = TimeSpan.FromDays( 7 ); // default: no refreshing from disk
+        DateTime _lastCheckedDisk = DateTime.MinValue;
+
+        /** <summary>
+         *  How are the files encoded (ascii, UTF8, ...)?  You might want to read
+         *  UTF8 for example on an ascii machine.
+         *  </summary>
+         */
+        Encoding _fileCharEncoding = Encoding.Default;
+
+        /** <summary>
+         *  Create a group manager for some templates, all of which are
+         *  at or below the indicated directory.
+         *  </summary>
+         */
+        public StringTemplateGroup( string name, string rootDir )
+            : this( name, rootDir, typeof( DefaultTemplateLexer ), Assembly.GetCallingAssembly() )
+        {
+        }
+        public StringTemplateGroup( string name, System.Reflection.Assembly rootAssembly )
+            : this( name, null, typeof( DefaultTemplateLexer ), Assembly.GetCallingAssembly() )
+        {
+        }
+
+        public StringTemplateGroup( string name, string rootDir, Type lexer )
+            : this( name, rootDir, lexer, Assembly.GetCallingAssembly() )
+        {
+        }
+
+        public StringTemplateGroup( string name, string rootDir, Type lexer, Assembly rootAssembly )
+        {
+            this._name = name;
+            this._rootDir = rootDir;
+            this._rootAssembly = rootAssembly;
+            _lastCheckedDisk = DateTime.Now;
+            _nameToGroupMap[name] = this;
+            this._templateLexerClass = lexer;
+        }
+
+        /** <summary>
+         *  Create a group manager for some templates, all of which are
+         *  loaded as resources via the classloader.
+         *  </summary>
+         */
+        public StringTemplateGroup( string name )
+            : this( name, null, null, Assembly.GetCallingAssembly() )
+        {
+        }
+
+        public StringTemplateGroup( string name, Type lexer )
+            : this( name, null, lexer, Assembly.GetCallingAssembly() )
+        {
+        }
+
+        /** <summary>
+         *  Create a group from the template group defined by a input stream.
+         *  The name is pulled from the file.
+         *  </summary>
+         *
+         *  <remarks>
+         *  The format is
+         *
+         *  group name;
+         *
+         *  t1(args) ::= "..."
+         *  t2() ::= &lt;&lt;
+         *  >>
+         *  ...
+         *  </remarks>
+         */
+        public StringTemplateGroup( TextReader r )
+            : this( r, typeof( AngleBracketTemplateLexer ), DEFAULT_ERROR_LISTENER, (StringTemplateGroup)null )
+        {
+        }
+
+        public StringTemplateGroup( TextReader r, IStringTemplateErrorListener errors )
+            : this( r, typeof( AngleBracketTemplateLexer ), errors, (StringTemplateGroup)null )
+        {
+        }
+
+        public StringTemplateGroup( TextReader r, Type lexer )
+            : this( r, lexer, null, (StringTemplateGroup)null )
+        {
+        }
+
+        public StringTemplateGroup( TextReader r, Type lexer, IStringTemplateErrorListener errors )
+            : this( r, lexer, errors, (StringTemplateGroup)null )
+        {
+        }
+
+        /** <summary>
+         *  Create a group from the input stream, but use a nondefault lexer
+         *  to break the templates up into chunks.  This is usefor changing
+         *  the delimiter from the default $...$ to &lt;...>, for example.
+         *  </summary>
+         */
+        public StringTemplateGroup( TextReader r,
+                                   Type lexer,
+                                   IStringTemplateErrorListener errors,
+                                   StringTemplateGroup superGroup )
+        {
+            this._templatesDefinedInGroupFile = true;
+            // if no lexer specified, then assume <...> when loading from group file
+            if ( lexer == null )
+            {
+                lexer = typeof( AngleBracketTemplateLexer );
+            }
+            this._templateLexerClass = lexer;
+            if ( errors != null )
+            { // always have to have a listener
+                this._listener = errors;
+            }
+            SuperGroup = superGroup;
+            parseGroup( r );
+            _nameToGroupMap[_name] = this;
+            verifyInterfaceImplementations();
+        }
+
+
+        #region PIXEL MINE ADDED
+
+        public IStringTemplateErrorListener ErrorListener
+        {
+            get
+            {
+                return _listener;
+            }
+            set
+            {
+                _listener = value;
+            }
+        }
+
+        public Encoding FileCharEncoding
+        {
+            get
+            {
+                return _fileCharEncoding;
+            }
+            set
+            {
+                _fileCharEncoding = value;
+            }
+        }
+
+        public string Name
+        {
+            get
+            {
+                return _name;
+            }
+            set
+            {
+                _name = value;
+            }
+        }
+
+        /** <summary>
+         *  How often to refresh all templates from disk.  This is a crude
+         *  mechanism at the moment--just tosses everything out at this
+         *  frequency.  Set interval to 0 to refresh constantly (no caching).
+         *  Set interval to a huge number like MAX_INT to have no refreshing
+         *  at all (DEFAULT); it will cache stuff.
+         *  </summary>
+         */
+        public TimeSpan RefreshInterval
+        {
+            get
+            {
+                return _refreshIntervalInSeconds;
+            }
+            set
+            {
+                _refreshIntervalInSeconds = value;
+            }
+        }
+
+        public string RootDir
+        {
+            get
+            {
+                return _rootDir;
+            }
+            set
+            {
+                _rootDir = value;
+            }
+        }
+
+        public StringTemplateGroup SuperGroup
+        {
+            get
+            {
+                return _superGroup;
+            }
+            set
+            {
+                _superGroup = value;
+            }
+        }
+
+        /** <summary>
+         *  What lexer class to use to break up templates.  If not lexer set
+         *  for this group, use static default.
+         *  </summary>
+         */
+        public Type TemplateLexerClass
+        {
+            get
+            {
+                if ( _templateLexerClass != null )
+                {
+                    return _templateLexerClass;
+                }
+                return _defaultTemplateLexerClass;
+            }
+        }
+
+        public ICollection<StringTemplate> Templates
+        {
+            get
+            {
+                return _templates.Values;
+            }
+        }
+
+        #endregion
+
+        [Obsolete]
+        public Type getTemplateLexerClass()
+        {
+            return TemplateLexerClass;
+        }
+
+        [Obsolete]
+        public string getName()
+        {
+            return Name;
+        }
+
+        [Obsolete]
+        public void setName( string name )
+        {
+            Name = name;
+        }
+
+        [Obsolete]
+        public void setSuperGroup( StringTemplateGroup superGroup )
+        {
+            SuperGroup = superGroup;
+        }
+
+        /** <summary>
+         *  Called by group parser when ": supergroupname" is found.
+         *  This method forces the supergroup's lexer to be same as lexer
+         *  for this (sub) group.
+         *  </summary>
+         */
+        public virtual void setSuperGroup( string superGroupName )
+        {
+            StringTemplateGroup superGroup =
+                (StringTemplateGroup)_nameToGroupMap.get( superGroupName );
+            if ( superGroup != null )
+            { // we've seen before; just use it
+                SuperGroup = superGroup;
+                return;
+            }
+            // else load it using this group's template lexer
+            superGroup = loadGroup( superGroupName, this._templateLexerClass, null );
+            if ( superGroup != null )
+            {
+                _nameToGroupMap[superGroupName] = superGroup;
+                SuperGroup = superGroup;
+            }
+            else
+            {
+                if ( _groupLoader == null )
+                {
+                    _listener.error( "no group loader registered", null );
+                }
+            }
+        }
+
+        /** <summary>Just track the new interface; check later.  Allows dups, but no biggie.</summary> */
+        public virtual void implementInterface( StringTemplateGroupInterface I )
+        {
+            if ( _interfaces == null )
+            {
+                _interfaces = new List<StringTemplateGroupInterface>();
+            }
+            _interfaces.Add( I );
+        }
+
+        /** <summary>
+         *  Indicate that this group implements this interface; load if necessary
+         *  if not in the nameToInterfaceMap.
+         *  </summary>
+         */
+        public virtual void implementInterface( string interfaceName )
+        {
+            StringTemplateGroupInterface I = _nameToInterfaceMap.get( interfaceName );
+            if ( I != null )
+            { // we've seen before; just use it
+                implementInterface( I );
+                return;
+            }
+            I = loadInterface( interfaceName ); // else load it
+            if ( I != null )
+            {
+                _nameToInterfaceMap[interfaceName] = I;
+                implementInterface( I );
+            }
+            else
+            {
+                if ( _groupLoader == null )
+                {
+                    _listener.error( "no group loader registered", null );
+                }
+            }
+        }
+
+        [Obsolete]
+        public StringTemplateGroup getSuperGroup()
+        {
+            return SuperGroup;
+        }
+
+        /** <summary>Walk up group hierarchy and show top down to this group</summary> */
+        public virtual string getGroupHierarchyStackString()
+        {
+            System.Collections.Generic.List<string> groupNames = new System.Collections.Generic.List<string>();
+            StringTemplateGroup p = this;
+            while ( p != null )
+            {
+                groupNames.Insert( 0, p._name );
+                p = p._superGroup;
+            }
+            return "[" + string.Join( " ", groupNames.ToArray() ) + "]";
+        }
+
+        [Obsolete]
+        public string getRootDir()
+        {
+            return RootDir;
+        }
+
+        [Obsolete]
+        public void setRootDir( string rootDir )
+        {
+            RootDir = rootDir;
+        }
+
+        /** <summary>StringTemplate object factory; each group can have its own.</summary> */
+        public virtual StringTemplate createStringTemplate()
+        {
+            StringTemplate st = new StringTemplate();
+            return st;
+        }
+
+        /** <summary>
+         *  A support routine that gets an instance of name knowing which
+         *  ST encloses it for error messages.
+         *  </summary>
+         */
+        protected virtual StringTemplate getInstanceOf( StringTemplate enclosingInstance,
+                                               string name )
+        {
+            //System.out.println("getInstanceOf("+getName()+"::"+name+")");
+            StringTemplate st = lookupTemplate( enclosingInstance, name );
+            if ( st != null )
+            {
+                StringTemplate instanceST = st.getInstanceOf();
+                return instanceST;
+            }
+            return null;
+        }
+
+        /** <summary>The primary means of getting an instance of a template from this group.</summary> */
+        public virtual StringTemplate getInstanceOf( string name )
+        {
+            return getInstanceOf( null, name );
+        }
+
+        /** <summary>
+         *  The primary means of getting an instance of a template from this
+         *  group when you have a predefined set of attributes you want to
+         *  use.
+         *  </summary>
+         */
+        public virtual StringTemplate getInstanceOf( string name, IDictionary<string, object> attributes )
+        {
+            StringTemplate st = getInstanceOf( name );
+            st.attributes = attributes;
+            return st;
+        }
+
+        public virtual StringTemplate getEmbeddedInstanceOf( StringTemplate enclosingInstance,
+                                                    string name )
+        {
+            /*
+            System.out.println("surrounding group is "+
+                               enclosingInstance.getGroup().getName()+
+                               " with native group "+enclosingInstance.getNativeGroup().getName());
+                               */
+            StringTemplate st = null;
+            // TODO: seems like this should go into lookupTemplate
+            if ( name.StartsWith( "super." ) )
+            {
+                // for super.foo() refs, ensure that we look at the native
+                // group for the embedded instance not the current evaluation
+                // group (which is always pulled down to the original group
+                // from which somebody did group.getInstanceOf("foo");
+                st = enclosingInstance.getNativeGroup().getInstanceOf( enclosingInstance, name );
+            }
+            else
+            {
+                st = getInstanceOf( enclosingInstance, name );
+            }
+            // make sure all embedded templates have the same group as enclosing
+            // so that polymorphic refs will start looking at the original group
+            st.setGroup( this );
+            st.setEnclosingInstance( enclosingInstance );
+            return st;
+        }
+
+        /** <summary>
+         *  Get the template called 'name' from the group.  If not found,
+         *  attempt to load.  If not found on disk, then try the superGroup
+         *  if any.  If not even there, then record that it's
+         *  NOT_FOUND so we don't waste time looking again later.  If we've gone
+         *  past refresh interval, flush and look again.
+         *  </summary>
+         *
+         *  <remarks>
+         *  If I find a template in a super group, copy an instance down here
+         *  </remarks>
+         */
+        [MethodImpl( MethodImplOptions.Synchronized )]
+        public virtual StringTemplate lookupTemplate( StringTemplate enclosingInstance, string name )
+        {
+            //System.out.println("look up "+getName()+"::"+name);
+            if ( name.StartsWith( "super." ) )
+            {
+                if ( _superGroup != null )
+                {
+                    int dot = name.IndexOf( '.' );
+                    name = name.Substring( dot + 1 );
+                    StringTemplate superScopeST =
+                        _superGroup.lookupTemplate( enclosingInstance, name );
+                    /*
+                    System.out.println("superScopeST is "+
+                                       superScopeST.getGroup().getName()+"::"+name+
+                                       " with native group "+superScopeST.getNativeGroup().getName());
+                    */
+                    return superScopeST;
+                }
+                throw new ArgumentException( Name + " has no super group; invalid template: " + name );
+            }
+            checkRefreshInterval();
+            StringTemplate st;
+            if ( !_templates.TryGetValue( name, out st ) || st == null )
+            {
+                // not there?  Attempt to load
+                if ( !_templatesDefinedInGroupFile )
+                {
+                    // only check the disk for individual template
+                    st = loadTemplateFromBeneathRootDirOrCLASSPATH( getFileNameFromTemplateName( name ) );
+                }
+                if ( st == null && _superGroup != null )
+                {
+                    // try to resolve in super group
+                    st = _superGroup.getInstanceOf( name );
+                    // make sure that when we inherit a template, that it's
+                    // group is reset; it's nativeGroup will remain where it was
+                    if ( st != null )
+                    {
+                        st.setGroup( this );
+                    }
+                }
+                if ( st != null )
+                { // found in superGroup
+                    // insert into this group; refresh will allow super
+                    // to change it's def later or this group to add
+                    // an override.
+                    _templates[name] = st;
+                }
+                else
+                {
+                    // not found; remember that this sucker doesn't exist
+                    _templates[name] = NOT_FOUND_ST;
+                    string context = "";
+                    if ( enclosingInstance != null )
+                    {
+                        context = "; context is " +
+                                  enclosingInstance.getEnclosingInstanceStackString();
+                    }
+                    string hier = getGroupHierarchyStackString();
+                    context += "; group hierarchy is " + hier;
+                    throw new ArgumentException( "Can't find template " +
+                                                       getFileNameFromTemplateName( name ) +
+                                                       context );
+                }
+            }
+            else if ( st == NOT_FOUND_ST )
+            {
+                return null;
+            }
+            //System.out.println("lookup found "+st.getGroup().getName()+"::"+st.getName());
+            return st;
+        }
+
+        public virtual StringTemplate lookupTemplate( string name )
+        {
+            try
+            {
+                return lookupTemplate( null, name );
+            }
+            catch ( ArgumentException )
+            {
+                return null;
+            }
+        }
+
+        protected virtual void checkRefreshInterval()
+        {
+            if ( _templatesDefinedInGroupFile )
+            {
+                return;
+            }
+            bool timeToFlush = _refreshIntervalInSeconds == TimeSpan.Zero ||
+                                ( DateTime.Now - _lastCheckedDisk ) >= _refreshIntervalInSeconds;
+            if ( timeToFlush )
+            {
+                // throw away all pre-compiled references
+                _templates.Clear();
+                _lastCheckedDisk = DateTime.Now;
+            }
+        }
+
+        protected virtual StringTemplate loadTemplate( string name, TextReader r )
+        {
+            string line;
+            string nl = Environment.NewLine;
+            StringBuilder buf = new StringBuilder( 300 );
+            while ( ( line = r.ReadLine() ) != null )
+            {
+                buf.Append( line );
+                buf.Append( nl );
+            }
+            // strip newlines etc.. from front/back since filesystem
+            // may add newlines etc...
+            string pattern = buf.ToString().Trim();
+            if ( pattern.Length == 0 )
+            {
+                error( "no text in template '" + name + "'" );
+                return null;
+            }
+            return defineTemplate( name, pattern );
+        }
+
+        /** <summary>
+         *  Load a template whose name is derived from the template filename.
+         *  If there is no root directory, try to load the template from
+         *  the classpath.  If there is a rootDir, try to load the file
+         *  from there.
+         *  </summary>
+         */
+        protected virtual StringTemplate loadTemplateFromBeneathRootDirOrCLASSPATH( string fileName )
+        {
+            StringTemplate template = null;
+            string name = getTemplateNameFromFileName( fileName );
+            // if no rootDir, try to load as a resource in CLASSPATH
+            if ( RootDir == null )
+            {
+                string resourceName = getFileNameFromTemplateName( name.Replace( '/', '.' ) );
+                System.Reflection.Assembly assembly = _rootAssembly ?? System.Reflection.Assembly.GetCallingAssembly();
+                System.IO.Stream @is = assembly.GetManifestResourceStream( resourceName );
+                if ( @is == null )
+                {
+                    assembly = this.GetType().Assembly;
+                    @is = assembly.GetManifestResourceStream( resourceName );
+                }
+#if false
+			ClassLoader cl = Thread.currentThread().getContextClassLoader();
+			InputStream @is = cl.getResourceAsStream(fileName);
+			if ( @is==null ) {
+				cl = this.getClass().getClassLoader();
+				@is = cl.getResourceAsStream(fileName);
+			}
+#endif
+                if ( @is == null )
+                {
+                    return null;
+                }
+                TextReader br = null;
+                try
+                {
+                    br = getInputStreamReader( new System.IO.BufferedStream( @is ) );
+                    template = loadTemplate( name, br );
+                }
+                catch ( IOException ioe )
+                {
+                    error( "Problem reading template file: " + fileName, ioe );
+                }
+                finally
+                {
+                    if ( br != null )
+                    {
+                        try
+                        {
+                            br.Close();
+                        }
+                        catch ( IOException ioe2 )
+                        {
+                            error( "Cannot close template file: " + fileName, ioe2 );
+                        }
+                    }
+                }
+                return template;
+            }
+            // load via rootDir
+            template = loadTemplate( name, RootDir + "/" + fileName );
+            return template;
+        }
+
+        /** <summary>
+         *  (public so that people can override behavior; not a general
+         *  purpose method)
+         *  </summary>
+         */
+        public virtual string getFileNameFromTemplateName( string templateName )
+        {
+            return templateName + ".st";
+        }
+
+        /** <summary>
+         *  Convert a filename relativePath/name.st to relativePath/name.
+         *  (public so that people can override behavior; not a general
+         *  purpose method)
+         *  </summary>
+         */
+        public virtual string getTemplateNameFromFileName( string fileName )
+        {
+            string name = fileName;
+            int suffix = name.LastIndexOf( ".st" );
+            if ( suffix >= 0 )
+            {
+                name = name.Substring( 0, suffix );
+            }
+            return name;
+        }
+
+        protected virtual StringTemplate loadTemplate( string name, string fileName )
+        {
+            TextReader br = null;
+            StringTemplate template = null;
+            try
+            {
+                Stream fin = System.IO.File.OpenRead( fileName );
+                StreamReader isr = getInputStreamReader( new System.IO.BufferedStream( fin ) );
+                br = isr;
+                template = loadTemplate( name, br );
+                br.Close();
+                br = null;
+            }
+            catch ( IOException /*ioe*/)
+            {
+                if ( br != null )
+                {
+                    try
+                    {
+                        br.Close();
+                    }
+                    catch ( IOException /*ioe2*/)
+                    {
+                        error( "Cannot close template file: " + fileName );
+                    }
+                }
+            }
+            return template;
+        }
+
+        protected virtual StreamReader getInputStreamReader( Stream @in )
+        {
+            StreamReader isr = null;
+            try
+            {
+                isr = new StreamReader( @in, _fileCharEncoding );
+            }
+            catch ( ArgumentException /*uee*/)
+            {
+                error( "Invalid file character encoding: " + _fileCharEncoding );
+            }
+            return isr;
+        }
+
+        [Obsolete]
+        public Encoding getFileCharEncoding()
+        {
+            return FileCharEncoding;
+        }
+
+        [Obsolete]
+        public void setFileCharEncoding( Encoding fileCharEncoding )
+        {
+            FileCharEncoding = fileCharEncoding;
+        }
+
+        /** <summary>
+         *  Define an examplar template; precompiled and stored
+         *  with no attributes.  Remove any previous definition.
+         *  </summary>
+         */
+        [MethodImpl( MethodImplOptions.Synchronized )]
+        public virtual StringTemplate defineTemplate( string name, string template )
+        {
+            //System.out.println("defineTemplate "+getName()+"::"+name);
+            if ( name != null && name.IndexOf( '.' ) >= 0 )
+            {
+                throw new ArgumentException( "cannot have '.' in template names" );
+            }
+            StringTemplate st = createStringTemplate();
+            st.setName( name );
+            st.setGroup( this );
+            st.setNativeGroup( this );
+            st.setTemplate( template );
+            st.setErrorListener( _listener );
+            _templates[name] = st;
+            return st;
+        }
+
+        /** <summary>Track all references to regions &lt;@foo>...&lt;@end> or &lt;@foo()>.</summary> */
+        public virtual StringTemplate defineRegionTemplate( string enclosingTemplateName,
+                                                   string regionName,
+                                                   string template,
+                                                   int type )
+        {
+            string mangledName =
+                getMangledRegionName( enclosingTemplateName, regionName );
+            StringTemplate regionST = defineTemplate( mangledName, template );
+            regionST.setIsRegion( true );
+            regionST.setRegionDefType( type );
+            return regionST;
+        }
+
+        /** <summary>Track all references to regions &lt;@foo>...&lt;@end> or &lt;@foo()>.</summary>  */
+        public virtual StringTemplate defineRegionTemplate( StringTemplate enclosingTemplate,
+                                                   string regionName,
+                                                   string template,
+                                                   int type )
+        {
+            StringTemplate regionST =
+                defineRegionTemplate( enclosingTemplate.getOutermostName(),
+                                     regionName,
+                                     template,
+                                     type );
+            enclosingTemplate.getOutermostEnclosingInstance().addRegionName( regionName );
+            return regionST;
+        }
+
+        /** <summary>Track all references to regions &lt;@foo()>.  We automatically
+         *  define as
+         *
+         *     @enclosingtemplate.foo() ::= ""
+         *  </summary>
+         *
+         *  <remarks>
+         *  You cannot set these manually in the same group; you have to subgroup
+         *  to override.
+         *  </remarks>
+         */
+        public virtual StringTemplate defineImplicitRegionTemplate( StringTemplate enclosingTemplate,
+                                                           string name )
+        {
+            return defineRegionTemplate( enclosingTemplate,
+                                        name,
+                                        "",
+                                        StringTemplate.REGION_IMPLICIT );
+
+        }
+
+        /** <summary>The "foo" of t() ::= "&lt;@foo()>" is mangled to "region#t#foo"</summary> */
+        public virtual string getMangledRegionName( string enclosingTemplateName,
+                                           string name )
+        {
+            return "region__" + enclosingTemplateName + "__" + name;
+        }
+
+        /** <summary>Return "t" from "region__t__foo"</summary> */
+        public virtual string getUnMangledTemplateName( string mangledName )
+        {
+            return mangledName.substring( "region__".Length,
+                                         mangledName.LastIndexOf( "__" ) );
+        }
+
+        /** <summary>Make name and alias for target.  Replace any previous def of name</summary> */
+        [MethodImpl( MethodImplOptions.Synchronized )]
+        public virtual StringTemplate defineTemplateAlias( string name, string target )
+        {
+            StringTemplate targetST = getTemplateDefinition( target );
+            if ( targetST == null )
+            {
+                error( "cannot alias " + name + " to undefined template: " + target );
+                return null;
+            }
+            _templates[name] = targetST;
+            return targetST;
+        }
+
+        [MethodImpl( MethodImplOptions.Synchronized )]
+        public virtual bool isDefinedInThisGroup( string name )
+        {
+            StringTemplate st;
+            if ( _templates.TryGetValue( name, out st ) && st != null )
+            {
+                if ( st.getIsRegion() )
+                {
+                    // don't allow redef of @t.r() ::= "..." or <@r>...<@end>
+                    if ( st.getRegionDefType() == StringTemplate.REGION_IMPLICIT )
+                    {
+                        return false;
+                    }
+                }
+                return true;
+            }
+            return false;
+        }
+
+        /** <summary>Get the ST for 'name' in this group only</summary> */
+        [MethodImpl( MethodImplOptions.Synchronized )]
+        public virtual StringTemplate getTemplateDefinition( string name )
+        {
+            return _templates[name];
+        }
+
+        /** <summary>
+         *  Is there *any* definition for template 'name' in this template
+         *  or above it in the group hierarchy?
+         *  </summary>
+         */
+        public virtual bool isDefined( string name )
+        {
+            try
+            {
+                return lookupTemplate( name ) != null;
+            }
+            catch ( ArgumentException /*iae*/)
+            {
+                return false;
+            }
+        }
+
+        protected virtual void parseGroup( TextReader r )
+        {
+            try
+            {
+                GroupLexer lexer = new GroupLexer( new ANTLRReaderStream( r ) );
+                GroupParser parser = new GroupParser( new CommonTokenStream( lexer ) );
+                parser.group( this );
+                //System.out.println("read group\n"+this.toString());
+            }
+            catch ( Exception e )
+            {
+                string name = "<unknown>";
+                if ( Name != null )
+                {
+                    name = Name;
+                }
+                error( "problem parsing group " + name + ": " + e, e );
+            }
+        }
+
+        /** <summary>Verify that this group satisfies its interfaces</summary> */
+        protected virtual void verifyInterfaceImplementations()
+        {
+            for ( int i = 0; _interfaces != null && i < _interfaces.Count; i++ )
+            {
+                StringTemplateGroupInterface I = _interfaces[i];
+                IList missing = I.getMissingTemplates( this );
+                IList mismatched = I.getMismatchedTemplates( this );
+                if ( missing != null )
+                {
+                    string missingText = "[" + string.Join( ",", missing.Cast<string>().ToArray() ) + "]";
+                    error( "group " + Name + " does not satisfy interface " +
+                          I.getName() + ": missing templates " + missingText );
+                }
+                if ( mismatched != null )
+                {
+                    string mismatchedText = "[" + string.Join( ",", mismatched.Cast<string>().ToArray() ) + "]";
+                    error( "group " + Name + " does not satisfy interface " +
+                          I.getName() + ": mismatched arguments on these templates " + mismatchedText );
+                }
+            }
+        }
+
+        [Obsolete]
+        public TimeSpan getRefreshInterval()
+        {
+            return RefreshInterval;
+        }
+
+        [Obsolete]
+        public void setRefreshInterval( TimeSpan refreshInterval )
+        {
+            RefreshInterval = refreshInterval;
+        }
+
+        [Obsolete]
+        public void setErrorListener( IStringTemplateErrorListener listener )
+        {
+            ErrorListener = listener;
+        }
+
+        [Obsolete]
+        public IStringTemplateErrorListener getErrorListener()
+        {
+            return ErrorListener;
+        }
+
+        /** <summary>
+         *  Specify a StringTemplateWriter implementing class to use for
+         *  filtering output
+         *  </summary>
+         */
+        public virtual void setStringTemplateWriter( Type c )
+        {
+            _userSpecifiedWriter = c;
+        }
+
+        /** <summary>
+         *  Return an instance of a StringTemplateWriter that spits output to w.
+         *  If a writer is specified, use it instead of the default.
+         *  </summary>
+         */
+        public virtual IStringTemplateWriter getStringTemplateWriter( TextWriter w )
+        {
+            IStringTemplateWriter stw = null;
+            if ( _userSpecifiedWriter != null )
+            {
+                try
+                {
+                    ConstructorInfo ctor =
+                        _userSpecifiedWriter.GetConstructor( new Type[] { typeof( TextWriter ) } );
+                    stw = (IStringTemplateWriter)ctor.Invoke( new Object[] { w } );
+                }
+                catch ( Exception e )
+                {
+                    error( "problems getting StringTemplateWriter", e );
+                }
+            }
+            if ( stw == null )
+            {
+                stw = new AutoIndentWriter( w );
+            }
+            return stw;
+        }
+
+        /** <summary>
+         *  Specify a complete map of what object classes should map to which
+         *  renderer objects for every template in this group (that doesn't
+         *  override it per template).
+         *  </summary>
+         */
+        public virtual void setAttributeRenderers( Dictionary<Type, IAttributeRenderer> renderers )
+        {
+            this._attributeRenderers = renderers;
+        }
+
+        /** <summary>
+         *  Register a renderer for all objects of a particular type for all
+         *  templates in this group.
+         *  </summary>
+         */
+        public virtual void registerRenderer( Type attributeClassType, IAttributeRenderer renderer )
+        {
+            if ( _attributeRenderers == null )
+            {
+                _attributeRenderers = new Dictionary<Type, IAttributeRenderer>();
+            }
+            _attributeRenderers[attributeClassType] = renderer;
+        }
+
+        /** <summary>
+         *  What renderer is registered for this attributeClassType for
+         *  this group?  If not found, as superGroup if it has one.
+         *  </summary>
+         */
+        public virtual IAttributeRenderer getAttributeRenderer( Type attributeClassType )
+        {
+            if ( _attributeRenderers == null )
+            {
+                if ( _superGroup == null )
+                {
+                    return null; // no renderers and no parent?  Stop.
+                }
+                // no renderers; consult super group
+                return _superGroup.getAttributeRenderer( attributeClassType );
+            }
+
+            IAttributeRenderer renderer;
+            if ( !_attributeRenderers.TryGetValue( attributeClassType, out renderer ) || renderer == null )
+            {
+                if ( _superGroup != null )
+                {
+                    // no renderer registered for this class, check super group
+                    renderer = _superGroup.getAttributeRenderer( attributeClassType );
+                }
+            }
+            return renderer;
+        }
+
+#if false
+        public virtual void cacheClassProperty(Type c, String propertyName, Member member) {
+            Object key = new ClassPropCacheKey(c,propertyName);
+            classPropertyCache.put(key,member);
+        }
+
+        public virtual Member getCachedClassProperty(Type c, String propertyName) {
+            Object key = new ClassPropCacheKey(c,propertyName);
+            return (Member)classPropertyCache.get(key);
+        }
+#endif
+
+        public virtual IDictionary getMap( string name )
+        {
+            if ( _maps == null )
+            {
+                if ( _superGroup == null )
+                {
+                    return null;
+                }
+                return _superGroup.getMap( name );
+            }
+            IDictionary m;
+            if ( ( !_maps.TryGetValue( name, out m ) || m == null ) && _superGroup != null )
+            {
+                m = _superGroup.getMap( name );
+            }
+            return m;
+        }
+
+        /** <summary>
+         *  Define a map for this group; not thread safe...do not keep adding
+         *  these while you reference them.
+         *  </summary>
+         */
+        public virtual void defineMap( string name, IDictionary mapping )
+        {
+            _maps[name] = mapping;
+        }
+
+        public static void registerDefaultLexer( Type lexerClass )
+        {
+            _defaultTemplateLexerClass = lexerClass;
+        }
+
+        public static void registerGroupLoader( IStringTemplateGroupLoader loader )
+        {
+            _groupLoader = loader;
+        }
+
+        public static StringTemplateGroup loadGroup( string name )
+        {
+            return loadGroup( name, null, null );
+        }
+
+        public static StringTemplateGroup loadGroup( string name,
+                                                    StringTemplateGroup superGroup )
+        {
+            return loadGroup( name, null, superGroup );
+        }
+
+        public static StringTemplateGroup loadGroup( string name,
+                                                    Type lexer,
+                                                    StringTemplateGroup superGroup )
+        {
+            if ( _groupLoader != null )
+            {
+                return _groupLoader.loadGroup( name, lexer, superGroup );
+            }
+            return null;
+        }
+
+        public static StringTemplateGroupInterface loadInterface( string name )
+        {
+            if ( _groupLoader != null )
+            {
+                return _groupLoader.loadInterface( name );
+            }
+            return null;
+        }
+
+        public virtual void error( string msg )
+        {
+            error( msg, null );
+        }
+
+        public virtual void error( string msg, Exception e )
+        {
+            if ( _listener != null )
+            {
+                _listener.error( msg, e );
+            }
+            else
+            {
+                Console.Error.WriteLine( "StringTemplate: " + msg );
+                if ( e != null )
+                {
+                    e.printStackTrace();
+                }
+            }
+        }
+
+        [MethodImpl( MethodImplOptions.Synchronized )]
+        public virtual ICollection<string> getTemplateNames()
+        {
+            return _templates.Keys;
+        }
+
+        /** <summary>
+         *  Indicate whether ST should emit &lt;templatename>...&lt;/templatename>
+         *  strings for debugging around output for templates from this group.
+         *  </summary>
+         */
+        public virtual void emitDebugStartStopStrings( bool emit )
+        {
+            this.debugTemplateOutput = emit;
+        }
+
+        public virtual void doNotEmitDebugStringsForTemplate( string templateName )
+        {
+            if ( _noDebugStartStopStrings == null )
+            {
+                _noDebugStartStopStrings = new HashSet<string>();
+            }
+            _noDebugStartStopStrings.Add( templateName );
+        }
+
+        public virtual void emitTemplateStartDebugString( StringTemplate st,
+                                                 IStringTemplateWriter @out )
+        {
+            if ( _noDebugStartStopStrings == null ||
+                 !_noDebugStartStopStrings.Contains( st.getName() ) )
+            {
+                string groupPrefix = "";
+                if ( !st.getName().StartsWith( "if" ) && !st.getName().StartsWith( "else" ) )
+                {
+                    if ( st.getNativeGroup() != null )
+                    {
+                        groupPrefix = st.getNativeGroup().Name + ".";
+                    }
+                    else
+                    {
+                        groupPrefix = st.getGroup().Name + ".";
+                    }
+                }
+                @out.write( "<" + groupPrefix + st.getName() + ">" );
+            }
+        }
+
+        public virtual void emitTemplateStopDebugString( StringTemplate st,
+                                                IStringTemplateWriter @out )
+        {
+            if ( _noDebugStartStopStrings == null ||
+                 !_noDebugStartStopStrings.Contains( st.getName() ) )
+            {
+                string groupPrefix = "";
+                if ( !st.getName().StartsWith( "if" ) && !st.getName().StartsWith( "else" ) )
+                {
+                    if ( st.getNativeGroup() != null )
+                    {
+                        groupPrefix = st.getNativeGroup().Name + ".";
+                    }
+                    else
+                    {
+                        groupPrefix = st.getGroup().Name + ".";
+                    }
+                }
+                @out.write( "</" + groupPrefix + st.getName() + ">" );
+            }
+        }
+
+        public override string ToString()
+        {
+            return ToString( true );
+        }
+
+        string _newline = Environment.NewLine;
+
+        public virtual string ToString( bool showTemplatePatterns )
+        {
+            StringBuilder buf = new StringBuilder();
+            buf.Append( "group " + Name + ";" + _newline );
+            StringTemplate formalArgs = new StringTemplate( "$args;separator=\",\"$" );
+            foreach ( var template in _templates.OrderBy( item => (string)item.Key ) )
+            {
+                string tname = template.Key;
+                StringTemplate st = template.Value;
+                if ( st != NOT_FOUND_ST )
+                {
+                    formalArgs = formalArgs.getInstanceOf();
+                    formalArgs.setAttribute( "args", st.getFormalArguments() );
+                    buf.Append( tname + "(" + formalArgs + ")" );
+                    if ( showTemplatePatterns )
+                    {
+                        buf.Append( " ::= <<" );
+                        buf.Append( st.getTemplate() );
+                        buf.Append( ">>" + _newline );
+                    }
+                    else
+                    {
+                        buf.Append( _newline );
+                    }
+                }
+            }
+            return buf.ToString();
+        }
+    }
+}
diff --git a/Antlr3.StringTemplate/StringTemplateGroupInterface.cs b/Antlr3.StringTemplate/StringTemplateGroupInterface.cs
new file mode 100644
index 0000000..cd9ea02
--- /dev/null
+++ b/Antlr3.StringTemplate/StringTemplateGroupInterface.cs
@@ -0,0 +1,312 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2003-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST
+{
+    using System;
+    using System.Collections.Generic;
+    using System.Linq;
+    using Antlr.Runtime.JavaExtensions;
+    using Antlr3.ST.Language;
+
+    using IList = System.Collections.IList;
+    using StringBuilder = System.Text.StringBuilder;
+    using TextReader = System.IO.TextReader;
+
+    /** <summary>A group interface is like a group without the template implementations.</summary>
+     *
+     *  <remarks>
+     *  There are just template names/argument-lists like this:
+     *
+     *  interface foo;
+     *  class(name,fields);
+     *  method(name,args,body);
+     *  </remarks>
+     */
+    public class StringTemplateGroupInterface
+    {
+        /** <summary>What is the group name</summary> */
+        string _name;
+
+        /** <summary>Maps template name to TemplateDefinition object</summary> */
+        Dictionary<string, TemplateDefinition> _templates = new Dictionary<string, TemplateDefinition>();
+
+        /** <summary>
+         *  Are we derived from another group?  Templates not found in this group
+         *  will be searched for in the superGroup recursively.
+         *  </summary>
+         */
+        StringTemplateGroupInterface _superInterface = null;
+
+        /** <summary>
+         *  Where to report errors.  All string templates in this group
+         *  use this error handler by default.
+         *  </summary>
+         */
+        IStringTemplateErrorListener _listener = DEFAULT_ERROR_LISTENER;
+
+        class DefaultErrorListener : IStringTemplateErrorListener
+        {
+            #region StringTemplateErrorListener Members
+
+            public void error( string s, Exception e )
+            {
+                Console.Error.WriteLine( s );
+                if ( e != null )
+                {
+                    e.printStackTrace( Console.Error );
+                }
+            }
+
+            public void warning( string s )
+            {
+                Console.Out.WriteLine( s );
+            }
+
+            #endregion
+        }
+
+        public static IStringTemplateErrorListener DEFAULT_ERROR_LISTENER = new DefaultErrorListener();
+
+        /** <summary>All the info we need to track for a template defined in an interface</summary> */
+        protected class TemplateDefinition
+        {
+            public string name;
+            public IDictionary<string, FormalArgument> formalArgs; // LinkedHashMap<FormalArgument>
+            public bool optional = false;
+            public TemplateDefinition( string name, IDictionary<string, FormalArgument> formalArgs, bool optional )
+            {
+                this.name = name;
+                this.formalArgs = formalArgs;
+                this.optional = optional;
+            }
+        }
+
+        public StringTemplateGroupInterface( TextReader r )
+            : this( r, DEFAULT_ERROR_LISTENER, (StringTemplateGroupInterface)null )
+        {
+        }
+
+        public StringTemplateGroupInterface( TextReader r, IStringTemplateErrorListener errors )
+            : this( r, errors, (StringTemplateGroupInterface)null )
+        {
+        }
+
+        /** <summary>Create an interface from the input stream</summary> */
+        public StringTemplateGroupInterface( TextReader r,
+                                            IStringTemplateErrorListener errors,
+                                            StringTemplateGroupInterface superInterface )
+        {
+            this._listener = errors;
+            setSuperInterface( superInterface );
+            parseInterface( r );
+        }
+
+        public virtual StringTemplateGroupInterface getSuperInterface()
+        {
+            return _superInterface;
+        }
+
+        public virtual void setSuperInterface( StringTemplateGroupInterface superInterface )
+        {
+            this._superInterface = superInterface;
+        }
+
+        protected virtual void parseInterface( TextReader r )
+        {
+            try
+            {
+                InterfaceLexer lexer = new InterfaceLexer( new Antlr.Runtime.ANTLRReaderStream( r ) );
+                InterfaceParser parser = new InterfaceParser( new Antlr.Runtime.CommonTokenStream( lexer ) );
+                parser.groupInterface( this );
+                //System.out.println("read interface\n"+this.toString());
+            }
+            catch ( Exception e )
+            {
+                string name = "<unknown>";
+                if ( getName() != null )
+                {
+                    name = getName();
+                }
+                error( "problem parsing group " + name + ": " + e, e );
+            }
+        }
+
+        public virtual void defineTemplate( string name, IDictionary<string, FormalArgument> formalArgs, bool optional )
+        {
+            TemplateDefinition d = new TemplateDefinition( name, formalArgs, optional );
+            _templates[d.name] = d;
+        }
+
+        /** <summary>
+         *  Return a list of all template names missing from group that are defined
+         *  in this interface.  Return null if all is well.
+         *  </summary>
+         */
+        public virtual IList getMissingTemplates( StringTemplateGroup group )
+        {
+            IList missing =
+                _templates.Values
+                .Where( template => !template.optional && !group.isDefined( template.name ) )
+                .Select( template => template.name )
+                .ToArray();
+
+            return ( missing.Count == 0 ) ? null : missing;
+        }
+
+        /** <summary>
+         *  Return a list of all template sigs that are present in the group, but
+         *  that have wrong formal argument lists.  Return null if all is well.
+         *  </summary>
+         */
+        public virtual IList getMismatchedTemplates( StringTemplateGroup group )
+        {
+            IList mismatched = new List<object>();
+            foreach ( TemplateDefinition d in _templates.Values )
+            {
+                if ( group.isDefined( d.name ) )
+                {
+                    StringTemplate defST = group.getTemplateDefinition( d.name );
+                    var formalArgs = defST.getFormalArguments();
+                    bool ack = false;
+                    if ( ( d.formalArgs != null && formalArgs == null ) ||
+                        ( d.formalArgs == null && formalArgs != null ) ||
+                        d.formalArgs.Count != formalArgs.Count )
+                    {
+                        ack = true;
+                    }
+                    if ( !ack )
+                    {
+                        foreach ( var arg in formalArgs )
+                        {
+                            FormalArgument arg2;
+                            if ( !d.formalArgs.TryGetValue( arg.name, out arg2 ) || arg2 == null )
+                            {
+                                ack = true;
+                                break;
+                            }
+                        }
+                    }
+                    if ( ack )
+                    {
+                        //System.out.println(d.formalArgs+"!="+formalArgs);
+                        mismatched.Add( getTemplateSignature( d ) );
+                    }
+                }
+            }
+            if ( mismatched.Count == 0 )
+            {
+                mismatched = null;
+            }
+            return mismatched;
+        }
+
+        public virtual string getName()
+        {
+            return _name;
+        }
+
+        public virtual void setName( string name )
+        {
+            this._name = name;
+        }
+
+        public virtual void error( string msg )
+        {
+            error( msg, null );
+        }
+
+        public virtual void error( string msg, Exception e )
+        {
+            if ( _listener != null )
+            {
+                _listener.error( msg, e );
+            }
+            else
+            {
+                Console.Error.WriteLine( "StringTemplate: " + msg );
+                if ( e != null )
+                {
+                    e.printStackTrace();
+                }
+            }
+        }
+
+        string newline = Environment.NewLine;
+
+        public override string ToString()
+        {
+            StringBuilder buf = new StringBuilder();
+            buf.Append( "interface " );
+            buf.Append( getName() );
+            buf.Append( ";" + newline );
+            foreach ( TemplateDefinition d in _templates.Values )
+            {
+                buf.Append( getTemplateSignature( d ) );
+                buf.Append( ";" + newline );
+            }
+            return buf.ToString();
+        }
+
+        protected virtual string getTemplateSignature( TemplateDefinition d )
+        {
+            StringBuilder buf = new StringBuilder();
+            if ( d.optional )
+            {
+                buf.Append( "optional " );
+            }
+            buf.Append( d.name );
+            if ( d.formalArgs != null )
+            {
+                StringBuilder args = new StringBuilder();
+                args.Append( '(' );
+                int i = 1;
+                foreach ( string name in d.formalArgs.Keys )
+                {
+                    if ( i > 1 )
+                    {
+                        args.Append( ", " );
+                    }
+                    args.Append( name );
+                    i++;
+                }
+                args.Append( ')' );
+                buf.Append( args );
+            }
+            else
+            {
+                buf.Append( "()" );
+            }
+            return buf.ToString();
+        }
+    }
+}
diff --git a/Antlr3.StringTemplate/StringTemplateGroupLoader.cs b/Antlr3.StringTemplate/StringTemplateGroupLoader.cs
new file mode 100644
index 0000000..1a94454
--- /dev/null
+++ b/Antlr3.StringTemplate/StringTemplateGroupLoader.cs
@@ -0,0 +1,78 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2003-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST
+{
+    using System;
+
+    /** <summary>
+     *  When group files derive from another group, we have to know how to
+     *  load that group and its supergroups.  This interface also knows how
+     *  to load interfaces.
+     *  </summary>
+     */
+    public interface IStringTemplateGroupLoader
+    {
+        /** <summary>
+         *  Load the group called groupName from somewhere.  Return null
+         *  if no group is found.
+         *  </summary>
+         */
+        StringTemplateGroup loadGroup( string groupName );
+
+        /** <summary>
+         *  Load a group with a specified superGroup.  Groups with
+         *  region definitions must know their supergroup to find templates
+         *  during parsing.
+         *  </summary>
+         */
+        StringTemplateGroup loadGroup( string groupName,
+                                             StringTemplateGroup superGroup );
+
+
+        /** <summary>
+         *  Specify the template lexer to use for parsing templates.  If null,
+         *  it assumes angle brackets &lt;...>.
+         *  </summary>
+         */
+        StringTemplateGroup loadGroup( string groupName,
+                                             Type templateLexer,
+                                             StringTemplateGroup superGroup );
+
+        /** <summary>
+         *  Load the interface called interfaceName from somewhere.  Return null
+         *  if no interface is found.
+         *  </summary>
+         */
+        StringTemplateGroupInterface loadInterface( string interfaceName );
+    }
+}
diff --git a/Antlr3.StringTemplate/StringTemplateWriter.cs b/Antlr3.StringTemplate/StringTemplateWriter.cs
new file mode 100644
index 0000000..73f9bb6
--- /dev/null
+++ b/Antlr3.StringTemplate/StringTemplateWriter.cs
@@ -0,0 +1,92 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2003-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.ST
+{
+    public static class StringTemplateWriterConstants
+    {
+        public const int NO_WRAP = -1;
+    }
+
+    /** <summary>Generic StringTemplate output writer filter.</summary>
+     *
+     *  <remarks>
+     *  Literals and the elements of expressions are emitted via write().
+     *  Separators are emitted via writeSeparator() because they must be
+     *  handled specially when wrapping lines (we don't want to wrap
+     *  in between an element and it's separator).
+     *  </remarks>
+     */
+    public interface IStringTemplateWriter
+    {
+        void pushIndentation( string indent );
+
+        string popIndentation();
+
+        void pushAnchorPoint();
+
+        void popAnchorPoint();
+
+        void setLineWidth( int lineWidth );
+
+        /** <summary>
+         *  Write the string and return how many actual chars were written.
+         *  With autoindentation and wrapping, more chars than length(str)
+         *  can be emitted.  No wrapping is done.
+         *  </summary>
+         */
+        int write( string str );
+
+        /** <summary>
+         *  Same as write, but wrap lines using the indicated string as the
+         *  wrap character (such as "\n").
+         *  </summary>
+         */
+        int write( string str, string wrap );
+
+        /** <summary>
+         *  Because we might need to wrap at a non-atomic string boundary
+         *  (such as when we wrap in between template applications
+         *   &lt;data:{v|[&lt;v>]}; wrap>) we need to expose the wrap string
+         *  writing just like for the separator.
+         *  </summary>
+         */
+        int writeWrapSeparator( string wrap );
+
+        /** <summary>
+         *  Write a separator.  Same as write() except that a \n cannot
+         *  be inserted before emitting a separator.
+         *  </summary>
+         */
+        int writeSeparator( string str );
+    }
+}
diff --git a/Antlr3.Targets/Antlr3.Targets.ActionScript/ActionScriptTarget.cs b/Antlr3.Targets/Antlr3.Targets.ActionScript/ActionScriptTarget.cs
new file mode 100644
index 0000000..af0260a
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.ActionScript/ActionScriptTarget.cs
@@ -0,0 +1,143 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+namespace Antlr3.Targets
+{
+    using CodeGenerator = Antlr3.Codegen.CodeGenerator;
+    using Console = System.Console;
+    using Grammar = Antlr3.Tool.Grammar;
+    using StringBuilder = System.Text.StringBuilder;
+    using Target = Antlr3.Codegen.Target;
+
+    public class ActionScriptTarget : Target
+    {
+
+        public override string getTargetCharLiteralFromANTLRCharLiteral(
+                CodeGenerator generator,
+                string literal )
+        {
+
+            int c = Grammar.getCharValueFromGrammarCharLiteral( literal );
+            return c.ToString();
+        }
+
+        public override string getTokenTypeAsTargetLabel( CodeGenerator generator,
+                                                int ttype )
+        {
+            // use ints for predefined types;
+            // <invalid> <EOR> <DOWN> <UP>
+            if ( ttype >= 0 && ttype <= 3 )
+            {
+                return ttype.ToString();
+            }
+
+            string name = generator.grammar.getTokenDisplayName( ttype );
+
+            // If name is a literal, return the token type instead
+            if ( name[0] == '\'' )
+            {
+                return ttype.ToString();
+            }
+
+            return name;
+        }
+
+        /**
+         * ActionScript doesn't support Unicode String literals that are considered "illegal"
+         * or are in the surrogate pair ranges.  For example "/uffff" will not encode properly
+         * nor will "/ud800".  To keep things as compact as possible we use the following encoding
+         * if the int is below 255, we encode as hex literal
+         * If the int is between 255 and 0x7fff we use a single unicode literal with the value
+         * If the int is above 0x7fff, we use a unicode literal of 0x80hh, where hh is the high-order
+         * bits followed by \xll where ll is the lower order bits of a 16-bit number.
+         *
+         * Ideally this should be improved at a future date.  The most optimal way to encode this
+         * may be a compressed AMF encoding that is embedded using an Embed tag in ActionScript.
+         *
+         * @param v
+         * @return
+         */
+        public override string encodeIntAsCharEscape( int v )
+        {
+            // encode as hex
+            if ( v <= 255 )
+            {
+                return "\\x" + v.ToString( "x2" );
+            }
+            if ( v <= 0x7fff )
+            {
+                string hex = v.ToString( "x4" );
+                return "\\u" + hex;
+            }
+            if ( v > 0xffff )
+            {
+                Console.Error.WriteLine( "Warning: character literal out of range for ActionScript target " + v );
+                return "";
+            }
+            StringBuilder buf = new StringBuilder( "\\u80" );
+            buf.Append( ( v >> 8 ).ToString( "x2" ) ); // high - order bits
+            buf.Append( "\\x" );
+            buf.Append( ( v & 0xff ).ToString( "x2" ) ); // low -order bits
+            return buf.ToString();
+        }
+
+        /** Convert long to two 32-bit numbers separted by a comma.
+         *  ActionScript does not support 64-bit numbers, so we need to break
+         *  the number into two 32-bit literals to give to the Bit.  A number like
+         *  0xHHHHHHHHLLLLLLLL is broken into the following string:
+         *  "0xLLLLLLLL, 0xHHHHHHHH"
+         *  Note that the low order bits are first, followed by the high order bits.
+         *  This is to match how the BitSet constructor works, where the bits are
+         *  passed in in 32-bit chunks with low-order bits coming first.
+         */
+        public override string getTarget64BitStringFromValue( ulong word )
+        {
+            StringBuilder buf = new StringBuilder( 22 ); // enough for the two "0x", "," and " "
+            buf.Append( "0x" );
+            writeHexWithPadding( buf, ( (uint)word ).ToString( "x" ) );
+            buf.Append( ", 0x" );
+            writeHexWithPadding( buf, ( word >> 32 ).ToString( "x" ) );
+
+            return buf.ToString();
+        }
+
+        private void writeHexWithPadding( StringBuilder buf, string digits )
+        {
+            // pad left with zeros
+            int padding = 8 - digits.Length;
+            buf.Append( new string( '0', padding ) );
+
+            digits = digits.ToUpperInvariant();
+            buf.Append( digits );
+        }
+    }
+
+}
diff --git a/Antlr3.Targets/Antlr3.Targets.ActionScript/Antlr3.Targets.ActionScript.csproj b/Antlr3.Targets/Antlr3.Targets.ActionScript/Antlr3.Targets.ActionScript.csproj
new file mode 100644
index 0000000..c17cf28
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.ActionScript/Antlr3.Targets.ActionScript.csproj
@@ -0,0 +1,64 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{2A03CB56-C3E2-4B65-92C0-004C9D78E2A4}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>Antlr3.Targets</RootNamespace>
+    <AssemblyName>Antlr3.Targets.ActionScript</AssemblyName>
+    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <TargetFrameworkSubset>
+    </TargetFrameworkSubset>
+    <SccProjectName>SAK</SccProjectName>
+    <SccLocalPath>SAK</SccLocalPath>
+    <SccAuxPath>SAK</SccAuxPath>
+    <SccProvider>SAK</SccProvider>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\bin\Debug\Targets\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\bin\Release\Targets\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="ActionScriptTarget.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\Antlr3\Antlr3.csproj">
+      <Project>{2AB8CAED-C046-4F05-8B18-6948100D2FE7}</Project>
+      <Name>Antlr3</Name>
+      <Private>False</Private>
+    </ProjectReference>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="app.config" />
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
\ No newline at end of file
diff --git a/Antlr3.Targets/Antlr3.Targets.ActionScript/Antlr3.Targets.ActionScript.csproj.vspscc b/Antlr3.Targets/Antlr3.Targets.ActionScript/Antlr3.Targets.ActionScript.csproj.vspscc
new file mode 100644
index 0000000..b6d3289
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.ActionScript/Antlr3.Targets.ActionScript.csproj.vspscc
@@ -0,0 +1,10 @@
+﻿""
+{
+"FILE_VERSION" = "9237"
+"ENLISTMENT_CHOICE" = "NEVER"
+"PROJECT_FILE_RELATIVE_PATH" = ""
+"NUMBER_OF_EXCLUDED_FILES" = "0"
+"ORIGINAL_PROJECT_FILE_PATH" = ""
+"NUMBER_OF_NESTED_PROJECTS" = "0"
+"SOURCE_CONTROL_SETTINGS_PROVIDER" = "PROVIDER"
+}
diff --git a/Antlr3.Targets/Antlr3.Targets.ActionScript/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.ActionScript/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..3caf6b9
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.ActionScript/Properties/AssemblyInfo.cs
@@ -0,0 +1,68 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle( "Antlr3.Targets.ActionScript" )]
+[assembly: AssemblyDescription( "" )]
+[assembly: AssemblyConfiguration( "" )]
+[assembly: AssemblyCompany( "Pixel Mine, Inc." )]
+[assembly: AssemblyProduct( "Antlr3.Targets.ActionScript" )]
+[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2009" )]
+[assembly: AssemblyTrademark( "" )]
+[assembly: AssemblyCulture( "" )]
+
+// Setting ComVisible to false makes the types in this assembly not visible
+// to COM components.  If you need to access a type in this assembly from
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible( false )]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid( "aa95e5e0-ddff-4ced-a130-69b0cd02f755" )]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion( "1.0.0.0" )]
+[assembly: AssemblyFileVersion( "1.0.0.0" )]
diff --git a/Antlr3.Targets/Antlr3.Targets.ActionScript/app.config b/Antlr3.Targets/Antlr3.Targets.ActionScript/app.config
new file mode 100644
index 0000000..df20690
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.ActionScript/app.config
@@ -0,0 +1,3 @@
+﻿<?xml version="1.0"?>
+<configuration>
+<startup><supportedRuntime version="v2.0.50727"/></startup></configuration>
diff --git a/Antlr3.Targets/Antlr3.Targets.C/Antlr3.Targets.C.csproj b/Antlr3.Targets/Antlr3.Targets.C/Antlr3.Targets.C.csproj
new file mode 100644
index 0000000..4d563ac
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.C/Antlr3.Targets.C.csproj
@@ -0,0 +1,69 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{ABFF04E1-91CE-4F31-AAA0-0C70E3DBB4A6}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>Antlr3.Targets</RootNamespace>
+    <AssemblyName>Antlr3.Targets.C</AssemblyName>
+    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <TargetFrameworkSubset>
+    </TargetFrameworkSubset>
+    <SccProjectName>SAK</SccProjectName>
+    <SccLocalPath>SAK</SccLocalPath>
+    <SccAuxPath>SAK</SccAuxPath>
+    <SccProvider>SAK</SccProvider>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\bin\Debug\Targets\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\bin\Release\Targets\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="CTarget.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\Antlr3.StringTemplate\Antlr3.StringTemplate.csproj">
+      <Project>{B5910BE2-DE21-4AA9-95C1-486F42B9E794}</Project>
+      <Name>Antlr3.StringTemplate</Name>
+      <Private>False</Private>
+    </ProjectReference>
+    <ProjectReference Include="..\..\Antlr3\Antlr3.csproj">
+      <Project>{2AB8CAED-C046-4F05-8B18-6948100D2FE7}</Project>
+      <Name>Antlr3</Name>
+      <Private>False</Private>
+    </ProjectReference>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="app.config" />
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
\ No newline at end of file
diff --git a/Antlr3.Targets/Antlr3.Targets.C/Antlr3.Targets.C.csproj.vspscc b/Antlr3.Targets/Antlr3.Targets.C/Antlr3.Targets.C.csproj.vspscc
new file mode 100644
index 0000000..b6d3289
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.C/Antlr3.Targets.C.csproj.vspscc
@@ -0,0 +1,10 @@
+﻿""
+{
+"FILE_VERSION" = "9237"
+"ENLISTMENT_CHOICE" = "NEVER"
+"PROJECT_FILE_RELATIVE_PATH" = ""
+"NUMBER_OF_EXCLUDED_FILES" = "0"
+"ORIGINAL_PROJECT_FILE_PATH" = ""
+"NUMBER_OF_NESTED_PROJECTS" = "0"
+"SOURCE_CONTROL_SETTINGS_PROVIDER" = "PROVIDER"
+}
diff --git a/Antlr3.Targets/Antlr3.Targets.C/CTarget.cs b/Antlr3.Targets/Antlr3.Targets.C/CTarget.cs
new file mode 100644
index 0000000..4a98849
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.C/CTarget.cs
@@ -0,0 +1,263 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Targets
+{
+    using System.Collections.Generic;
+
+    using CodeGenerator = Antlr3.Codegen.CodeGenerator;
+    using Grammar = Antlr3.Tool.Grammar;
+    using StringBuilder = System.Text.StringBuilder;
+    using StringTemplate = Antlr3.ST.StringTemplate;
+    using Target = Antlr3.Codegen.Target;
+
+    public class CTarget : Target
+    {
+        List<string> strings = new List<string>();
+
+        protected override void genRecognizerFile( AntlrTool tool,
+                                    CodeGenerator generator,
+                                    Grammar grammar,
+                                    StringTemplate outputFileST )
+        {
+
+            // Before we write this, and cause it to generate its string,
+            // we need to add all the string literals that we are going to match
+            //
+            outputFileST.setAttribute( "literals", strings );
+            string fileName = generator.getRecognizerFileName( grammar.name, grammar.type );
+            generator.write( outputFileST, fileName );
+        }
+
+        protected override void genRecognizerHeaderFile( AntlrTool tool,
+                                               CodeGenerator generator,
+                                               Grammar grammar,
+                                               StringTemplate headerFileST,
+                                               string extName )
+        {
+            // Pick up the file name we are generating. This method will return a
+            // a file suffixed with .c, so we must substring and add the extName
+            // to it as we cannot assign into strings in Java.
+            ///
+            string fileName = generator.getRecognizerFileName( grammar.name, grammar.type );
+            fileName = fileName.Substring( 0, fileName.Length - 2 ) + extName;
+
+            generator.write( headerFileST, fileName );
+        }
+
+        /** Is scope in @scope::name {action} valid for this kind of grammar?
+         *  Targets like C++ may want to allow new scopes like headerfile or
+         *  some such.  The action names themselves are not policed at the
+         *  moment so targets can add template actions w/o having to recompile
+         *  ANTLR.
+         */
+        public override bool isValidActionScope( int grammarType, string scope )
+        {
+            switch ( grammarType )
+            {
+            case Grammar.LEXER:
+                switch ( scope )
+                {
+                case "lexer":
+                case "header":
+                case "includes":
+                case "preincludes":
+                case "overrides":
+                    return true;
+                }
+
+                break;
+
+            case Grammar.PARSER:
+                switch ( scope )
+                {
+                case "parser":
+                case "header":
+                case "includes":
+                case "preincludes":
+                case "overrides":
+                    return true;
+                }
+
+                break;
+
+            case Grammar.COMBINED:
+                switch ( scope )
+                {
+                case "parser":
+                case "lexer":
+                case "header":
+                case "includes":
+                case "preincludes":
+                case "overrides":
+                    return true;
+                }
+
+                break;
+
+            case Grammar.TREE_PARSER:
+                switch ( scope )
+                {
+                case "treeparser":
+                case "header":
+                case "includes":
+                case "preincludes":
+                case "overrides":
+                    return true;
+                }
+
+                break;
+            }
+
+            return false;
+        }
+
+        public override string getTargetCharLiteralFromANTLRCharLiteral( CodeGenerator generator, string literal )
+        {
+
+            if ( literal.StartsWith( "'\\u" ) )
+            {
+                literal = "0x" + literal.Substring( 3, 4 );
+            }
+            else
+            {
+                int c = literal[1];
+
+                if ( c < 32 || c > 127 )
+                {
+                    literal = "0x" + c.ToString( "x" );
+                }
+            }
+
+            return literal;
+        }
+
+        /** Convert from an ANTLR string literal found in a grammar file to
+         *  an equivalent string literal in the C target.
+         *  Because we must support Unicode character sets and have chosen
+         *  to have the lexer match UTF32 characters, then we must encode
+         *  string matches to use 32 bit character arrays. Here then we
+         *  must produce the C array and cater for the case where the
+         *  lexer has been encoded with a string such as 'xyz\n',
+         */
+        public override string getTargetStringLiteralFromANTLRStringLiteral( CodeGenerator generator, string literal )
+        {
+            int index;
+            //int outc;
+            string bytes;
+            StringBuilder buf = new StringBuilder();
+
+            buf.Append( "{ " );
+
+            // We need ot lose any escaped characters of the form \x and just
+            // replace them with their actual values as well as lose the surrounding
+            // quote marks.
+            //
+            for ( int i = 1; i < literal.Length - 1; i++ )
+            {
+                buf.Append( "0x" );
+
+                if ( literal[i] == '\\' )
+                {
+                    i++; // Assume that there is a next character, this will just yield
+                    // invalid strings if not, which is what the input would be of course - invalid
+                    switch ( literal[i] )
+                    {
+                    case 'u':
+                    case 'U':
+                        buf.Append( literal.Substring( i + 1, 4 ) );  // Already a hex string
+                        i = i + 5;                                // Move to next string/char/escape
+                        break;
+
+                    case 'n':
+                    case 'N':
+
+                        buf.Append( "0A" );
+                        break;
+
+                    case 'r':
+                    case 'R':
+
+                        buf.Append( "0D" );
+                        break;
+
+                    case 't':
+                    case 'T':
+
+                        buf.Append( "09" );
+                        break;
+
+                    case 'b':
+                    case 'B':
+
+                        buf.Append( "08" );
+                        break;
+
+                    case 'f':
+                    case 'F':
+
+                        buf.Append( "0C" );
+                        break;
+
+                    default:
+
+                        // Anything else is what it is!
+                        //
+                        buf.Append( ( (int)literal[i] ).ToString( "X" ) );
+                        break;
+                    }
+                }
+                else
+                {
+                    buf.Append( ( (int)literal[i] ).ToString( "X" ) );
+                }
+                buf.Append( ", " );
+            }
+            buf.Append( " ANTLR3_STRING_TERMINATOR}" );
+
+            bytes = buf.ToString();
+            index = strings.IndexOf( bytes );
+
+            if ( index == -1 )
+            {
+                strings.Add( bytes );
+                index = strings.IndexOf( bytes );
+            }
+
+            string strref = "lit_" + ( index + 1 ).ToString();
+
+            return strref;
+        }
+
+    }
+
+}
diff --git a/Antlr3.Targets/Antlr3.Targets.C/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.C/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..9ea3da0
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.C/Properties/AssemblyInfo.cs
@@ -0,0 +1,68 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle( "Antlr3.Targets.C" )]
+[assembly: AssemblyDescription( "" )]
+[assembly: AssemblyConfiguration( "" )]
+[assembly: AssemblyCompany( "Pixel Mine, Inc." )]
+[assembly: AssemblyProduct( "Antlr3.Targets.C" )]
+[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2009" )]
+[assembly: AssemblyTrademark( "" )]
+[assembly: AssemblyCulture( "" )]
+
+// Setting ComVisible to false makes the types in this assembly not visible
+// to COM components.  If you need to access a type in this assembly from
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible( false )]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid( "b8dcb19a-ffa0-4d55-8fd2-747d6c70c8ae" )]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion( "1.0.0.0" )]
+[assembly: AssemblyFileVersion( "1.0.0.0" )]
diff --git a/Antlr3.Targets/Antlr3.Targets.C/app.config b/Antlr3.Targets/Antlr3.Targets.C/app.config
new file mode 100644
index 0000000..df20690
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.C/app.config
@@ -0,0 +1,3 @@
+﻿<?xml version="1.0"?>
+<configuration>
+<startup><supportedRuntime version="v2.0.50727"/></startup></configuration>
diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp/Antlr3.Targets.CSharp.csproj b/Antlr3.Targets/Antlr3.Targets.CSharp/Antlr3.Targets.CSharp.csproj
new file mode 100644
index 0000000..dc2614f
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp/Antlr3.Targets.CSharp.csproj
@@ -0,0 +1,64 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{48A0E438-158B-4C9E-887D-350E67A8AA09}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>Antlr3.Targets</RootNamespace>
+    <AssemblyName>Antlr3.Targets.CSharp</AssemblyName>
+    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <TargetFrameworkSubset>
+    </TargetFrameworkSubset>
+    <SccProjectName>SAK</SccProjectName>
+    <SccLocalPath>SAK</SccLocalPath>
+    <SccAuxPath>SAK</SccAuxPath>
+    <SccProvider>SAK</SccProvider>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\bin\Debug\Targets\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\bin\Release\Targets\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="CSharpTarget.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\Antlr3\Antlr3.csproj">
+      <Project>{2AB8CAED-C046-4F05-8B18-6948100D2FE7}</Project>
+      <Name>Antlr3</Name>
+      <Private>False</Private>
+    </ProjectReference>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="app.config" />
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
\ No newline at end of file
diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp/Antlr3.Targets.CSharp.csproj.vspscc b/Antlr3.Targets/Antlr3.Targets.CSharp/Antlr3.Targets.CSharp.csproj.vspscc
new file mode 100644
index 0000000..b6d3289
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp/Antlr3.Targets.CSharp.csproj.vspscc
@@ -0,0 +1,10 @@
+﻿""
+{
+"FILE_VERSION" = "9237"
+"ENLISTMENT_CHOICE" = "NEVER"
+"PROJECT_FILE_RELATIVE_PATH" = ""
+"NUMBER_OF_EXCLUDED_FILES" = "0"
+"ORIGINAL_PROJECT_FILE_PATH" = ""
+"NUMBER_OF_NESTED_PROJECTS" = "0"
+"SOURCE_CONTROL_SETTINGS_PROVIDER" = "PROVIDER"
+}
diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp/CSharpTarget.cs b/Antlr3.Targets/Antlr3.Targets.CSharp/CSharpTarget.cs
new file mode 100644
index 0000000..159f562
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp/CSharpTarget.cs
@@ -0,0 +1,44 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2006 Kunle Odutola
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+namespace Antlr3.Targets
+{
+    using Target = Antlr3.Codegen.Target;
+
+    public class CSharpTarget : Target
+    {
+        public override string encodeIntAsCharEscape( int v )
+        {
+            return "\\x" + v.ToString( "X" );
+        }
+    }
+}
diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.CSharp/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..d6ea0db
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp/Properties/AssemblyInfo.cs
@@ -0,0 +1,68 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle( "Antlr3.Targets.CSharp" )]
+[assembly: AssemblyDescription( "" )]
+[assembly: AssemblyConfiguration( "" )]
+[assembly: AssemblyCompany( "Pixel Mine, Inc." )]
+[assembly: AssemblyProduct( "Antlr3.Targets.CSharp" )]
+[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2009" )]
+[assembly: AssemblyTrademark( "" )]
+[assembly: AssemblyCulture( "" )]
+
+// Setting ComVisible to false makes the types in this assembly not visible
+// to COM components.  If you need to access a type in this assembly from
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible( false )]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid( "11e2eab4-bee7-4cb9-9d97-57073f909c8a" )]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion( "1.0.0.0" )]
+[assembly: AssemblyFileVersion( "1.0.0.0" )]
diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp/app.config b/Antlr3.Targets/Antlr3.Targets.CSharp/app.config
new file mode 100644
index 0000000..df20690
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp/app.config
@@ -0,0 +1,3 @@
+﻿<?xml version="1.0"?>
+<configuration>
+<startup><supportedRuntime version="v2.0.50727"/></startup></configuration>
diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp2/Antlr3.Targets.CSharp2.csproj b/Antlr3.Targets/Antlr3.Targets.CSharp2/Antlr3.Targets.CSharp2.csproj
new file mode 100644
index 0000000..5b653c4
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp2/Antlr3.Targets.CSharp2.csproj
@@ -0,0 +1,64 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{5CBAC55A-A209-45CA-9F57-D0BFFFE2B7F9}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>Antlr3.Targets</RootNamespace>
+    <AssemblyName>Antlr3.Targets.CSharp2</AssemblyName>
+    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <TargetFrameworkSubset>
+    </TargetFrameworkSubset>
+    <SccProjectName>SAK</SccProjectName>
+    <SccLocalPath>SAK</SccLocalPath>
+    <SccAuxPath>SAK</SccAuxPath>
+    <SccProvider>SAK</SccProvider>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\bin\Debug\Targets\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\bin\Release\Targets\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="CSharp2Target.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\Antlr3\Antlr3.csproj">
+      <Project>{2AB8CAED-C046-4F05-8B18-6948100D2FE7}</Project>
+      <Name>Antlr3</Name>
+      <Private>False</Private>
+    </ProjectReference>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="app.config" />
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
\ No newline at end of file
diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp2/Antlr3.Targets.CSharp2.csproj.vspscc b/Antlr3.Targets/Antlr3.Targets.CSharp2/Antlr3.Targets.CSharp2.csproj.vspscc
new file mode 100644
index 0000000..b6d3289
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp2/Antlr3.Targets.CSharp2.csproj.vspscc
@@ -0,0 +1,10 @@
+﻿""
+{
+"FILE_VERSION" = "9237"
+"ENLISTMENT_CHOICE" = "NEVER"
+"PROJECT_FILE_RELATIVE_PATH" = ""
+"NUMBER_OF_EXCLUDED_FILES" = "0"
+"ORIGINAL_PROJECT_FILE_PATH" = ""
+"NUMBER_OF_NESTED_PROJECTS" = "0"
+"SOURCE_CONTROL_SETTINGS_PROVIDER" = "PROVIDER"
+}
diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp2/CSharp2Target.cs b/Antlr3.Targets/Antlr3.Targets.CSharp2/CSharp2Target.cs
new file mode 100644
index 0000000..c812845
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp2/CSharp2Target.cs
@@ -0,0 +1,44 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2006 Kunle Odutola
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+namespace Antlr3.Targets
+{
+    using Target = Antlr3.Codegen.Target;
+
+    public class CSharp2Target : Target
+    {
+        public override string encodeIntAsCharEscape( int v )
+        {
+            return "\\x" + v.ToString( "X" );
+        }
+    }
+}
diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp2/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.CSharp2/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..46afe97
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp2/Properties/AssemblyInfo.cs
@@ -0,0 +1,68 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle( "Antlr3.Targets.CSharp2" )]
+[assembly: AssemblyDescription( "" )]
+[assembly: AssemblyConfiguration( "" )]
+[assembly: AssemblyCompany( "Pixel Mine, Inc." )]
+[assembly: AssemblyProduct( "Antlr3.Targets.CSharp2" )]
+[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2009" )]
+[assembly: AssemblyTrademark( "" )]
+[assembly: AssemblyCulture( "" )]
+
+// Setting ComVisible to false makes the types in this assembly not visible
+// to COM components.  If you need to access a type in this assembly from
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible( false )]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid( "c30b57a2-68f1-44ec-b14b-3436d52a6233" )]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion( "1.0.0.0" )]
+[assembly: AssemblyFileVersion( "1.0.0.0" )]
diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp2/app.config b/Antlr3.Targets/Antlr3.Targets.CSharp2/app.config
new file mode 100644
index 0000000..df20690
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp2/app.config
@@ -0,0 +1,3 @@
+﻿<?xml version="1.0"?>
+<configuration>
+<startup><supportedRuntime version="v2.0.50727"/></startup></configuration>
diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp3/Antlr3.Targets.CSharp3.csproj b/Antlr3.Targets/Antlr3.Targets.CSharp3/Antlr3.Targets.CSharp3.csproj
new file mode 100644
index 0000000..77a9776
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp3/Antlr3.Targets.CSharp3.csproj
@@ -0,0 +1,64 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{67012F41-94F9-48E6-9677-E3C56E42917F}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>Antlr3.Targets</RootNamespace>
+    <AssemblyName>Antlr3.Targets.CSharp3</AssemblyName>
+    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <TargetFrameworkSubset>
+    </TargetFrameworkSubset>
+    <SccProjectName>SAK</SccProjectName>
+    <SccLocalPath>SAK</SccLocalPath>
+    <SccAuxPath>SAK</SccAuxPath>
+    <SccProvider>SAK</SccProvider>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\bin\Debug\Targets\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\bin\Release\Targets\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="CSharp3Target.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\Antlr3\Antlr3.csproj">
+      <Project>{2AB8CAED-C046-4F05-8B18-6948100D2FE7}</Project>
+      <Name>Antlr3</Name>
+      <Private>False</Private>
+    </ProjectReference>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="app.config" />
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
\ No newline at end of file
diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp3/Antlr3.Targets.CSharp3.csproj.vspscc b/Antlr3.Targets/Antlr3.Targets.CSharp3/Antlr3.Targets.CSharp3.csproj.vspscc
new file mode 100644
index 0000000..b6d3289
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp3/Antlr3.Targets.CSharp3.csproj.vspscc
@@ -0,0 +1,10 @@
+﻿""
+{
+"FILE_VERSION" = "9237"
+"ENLISTMENT_CHOICE" = "NEVER"
+"PROJECT_FILE_RELATIVE_PATH" = ""
+"NUMBER_OF_EXCLUDED_FILES" = "0"
+"ORIGINAL_PROJECT_FILE_PATH" = ""
+"NUMBER_OF_NESTED_PROJECTS" = "0"
+"SOURCE_CONTROL_SETTINGS_PROVIDER" = "PROVIDER"
+}
diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp3/CSharp3Target.cs b/Antlr3.Targets/Antlr3.Targets.CSharp3/CSharp3Target.cs
new file mode 100644
index 0000000..5ecc89b
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp3/CSharp3Target.cs
@@ -0,0 +1,48 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+namespace Antlr3.Targets
+{
+    using Target = Antlr3.Codegen.Target;
+
+    public class CSharp3Target : Target
+    {
+        public override string encodeIntAsCharEscape( int v )
+        {
+            return "\\x" + v.ToString( "X" );
+        }
+
+        public override string getTarget64BitStringFromValue( ulong word )
+        {
+            return "0x" + word.ToString( "X" );
+        }
+    }
+}
diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp3/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.CSharp3/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..a8f31b7
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp3/Properties/AssemblyInfo.cs
@@ -0,0 +1,68 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle( "Antlr3.Target.CSharp3" )]
+[assembly: AssemblyDescription( "" )]
+[assembly: AssemblyConfiguration( "" )]
+[assembly: AssemblyCompany( "Pixel Mine, Inc." )]
+[assembly: AssemblyProduct( "Antlr3.Target.CSharp3" )]
+[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2009" )]
+[assembly: AssemblyTrademark( "" )]
+[assembly: AssemblyCulture( "" )]
+
+// Setting ComVisible to false makes the types in this assembly not visible
+// to COM components.  If you need to access a type in this assembly from
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible( false )]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid( "efdd8135-be27-45be-8fd2-9070ff9df797" )]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion( "1.0.0.0" )]
+[assembly: AssemblyFileVersion( "1.0.0.0" )]
diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp3/app.config b/Antlr3.Targets/Antlr3.Targets.CSharp3/app.config
new file mode 100644
index 0000000..df20690
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp3/app.config
@@ -0,0 +1,3 @@
+﻿<?xml version="1.0"?>
+<configuration>
+<startup><supportedRuntime version="v2.0.50727"/></startup></configuration>
diff --git a/Antlr3.Targets/Antlr3.Targets.Cpp/Antlr3.Targets.Cpp.csproj b/Antlr3.Targets/Antlr3.Targets.Cpp/Antlr3.Targets.Cpp.csproj
new file mode 100644
index 0000000..ec2fdfb
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Cpp/Antlr3.Targets.Cpp.csproj
@@ -0,0 +1,69 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{46171154-755A-4595-99AA-537D684BCA28}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>Antlr3.Targets</RootNamespace>
+    <AssemblyName>Antlr3.Targets.Cpp</AssemblyName>
+    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <TargetFrameworkSubset>
+    </TargetFrameworkSubset>
+    <SccProjectName>SAK</SccProjectName>
+    <SccLocalPath>SAK</SccLocalPath>
+    <SccAuxPath>SAK</SccAuxPath>
+    <SccProvider>SAK</SccProvider>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\bin\Debug\Targets\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\bin\Release\Targets\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="CPPTarget.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\Antlr3.StringTemplate\Antlr3.StringTemplate.csproj">
+      <Project>{B5910BE2-DE21-4AA9-95C1-486F42B9E794}</Project>
+      <Name>Antlr3.StringTemplate</Name>
+      <Private>False</Private>
+    </ProjectReference>
+    <ProjectReference Include="..\..\Antlr3\Antlr3.csproj">
+      <Project>{2AB8CAED-C046-4F05-8B18-6948100D2FE7}</Project>
+      <Name>Antlr3</Name>
+      <Private>False</Private>
+    </ProjectReference>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="app.config" />
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
\ No newline at end of file
diff --git a/Antlr3.Targets/Antlr3.Targets.Cpp/Antlr3.Targets.Cpp.csproj.vspscc b/Antlr3.Targets/Antlr3.Targets.Cpp/Antlr3.Targets.Cpp.csproj.vspscc
new file mode 100644
index 0000000..b6d3289
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Cpp/Antlr3.Targets.Cpp.csproj.vspscc
@@ -0,0 +1,10 @@
+﻿""
+{
+"FILE_VERSION" = "9237"
+"ENLISTMENT_CHOICE" = "NEVER"
+"PROJECT_FILE_RELATIVE_PATH" = ""
+"NUMBER_OF_EXCLUDED_FILES" = "0"
+"ORIGINAL_PROJECT_FILE_PATH" = ""
+"NUMBER_OF_NESTED_PROJECTS" = "0"
+"SOURCE_CONTROL_SETTINGS_PROVIDER" = "PROVIDER"
+}
diff --git a/Antlr3.Targets/Antlr3.Targets.Cpp/CPPTarget.cs b/Antlr3.Targets/Antlr3.Targets.Cpp/CPPTarget.cs
new file mode 100644
index 0000000..c06576f
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Cpp/CPPTarget.cs
@@ -0,0 +1,158 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+namespace Antlr3.Targets
+{
+    using CodeGenerator = Antlr3.Codegen.CodeGenerator;
+    using Grammar = Antlr3.Tool.Grammar;
+    using StringBuilder = System.Text.StringBuilder;
+    using StringTemplate = Antlr3.ST.StringTemplate;
+    using StringTemplateGroup = Antlr3.ST.StringTemplateGroup;
+    using Target = Antlr3.Codegen.Target;
+
+    public class CPPTarget : Target
+    {
+        public string escapeChar( int c )
+        {
+            // System.out.println("CPPTarget.escapeChar("+c+")");
+            switch ( c )
+            {
+            case '\n':
+                return "\\n";
+            case '\t':
+                return "\\t";
+            case '\r':
+                return "\\r";
+            case '\\':
+                return "\\\\";
+            case '\'':
+                return "\\'";
+            case '"':
+                return "\\\"";
+            default:
+                if ( c < ' ' || c > 126 )
+                {
+                    if ( c > 255 )
+                    {
+                        string s = c.ToString( "x" );
+                        // put leading zeroes in front of the thing..
+                        while ( s.Length < 4 )
+                            s = '0' + s;
+                        return "\\u" + s;
+                    }
+                    else
+                    {
+                        return "\\" + c.ToString( "8" );
+                    }
+                }
+                else
+                {
+                    return ( (char)c ).ToString();
+                }
+            }
+        }
+
+        /** Converts a String into a representation that can be use as a literal
+         * when surrounded by double-quotes.
+         *
+         * Used for escaping semantic predicate strings for exceptions.
+         *
+         * @param s The String to be changed into a literal
+         */
+        public string escapeString( string s )
+        {
+            StringBuilder retval = new StringBuilder();
+            for ( int i = 0; i < s.Length; i++ )
+            {
+                retval.Append( escapeChar( s[i] ) );
+            }
+
+            return retval.ToString();
+        }
+
+        protected override void genRecognizerHeaderFile( AntlrTool tool,
+                                               CodeGenerator generator,
+                                               Grammar grammar,
+                                               StringTemplate headerFileST,
+                                               string extName )
+        {
+            StringTemplateGroup templates = generator.getTemplates();
+            generator.write( headerFileST, grammar.name + extName );
+        }
+
+        /** Convert from an ANTLR char literal found in a grammar file to
+         *  an equivalent char literal in the target language.  For Java, this
+         *  is the identify translation; i.e., '\n' -> '\n'.  Most languages
+         *  will be able to use this 1-to-1 mapping.  Expect single quotes
+         *  around the incoming literal.
+         *  Depending on the charvocabulary the charliteral should be prefixed with a 'L'
+         */
+        public override string getTargetCharLiteralFromANTLRCharLiteral( CodeGenerator codegen, string literal )
+        {
+            int c = Grammar.getCharValueFromGrammarCharLiteral( literal );
+            string prefix = "'";
+            if ( codegen.grammar.MaxCharValue > 255 )
+                prefix = "L'";
+            else if ( ( c & 0x80 ) != 0 )	// if in char mode prevent sign extensions
+                return "" + c;
+            return prefix + escapeChar( c ) + "'";
+        }
+
+        /** Convert from an ANTLR string literal found in a grammar file to
+         *  an equivalent string literal in the target language.  For Java, this
+         *  is the identify translation; i.e., "\"\n" -> "\"\n".  Most languages
+         *  will be able to use this 1-to-1 mapping.  Expect double quotes
+         *  around the incoming literal.
+         *  Depending on the charvocabulary the string should be prefixed with a 'L'
+         */
+        public override string getTargetStringLiteralFromANTLRStringLiteral( CodeGenerator codegen, string literal )
+        {
+            StringBuilder buf = Grammar.getUnescapedStringFromGrammarStringLiteral( literal );
+            string prefix = "\"";
+            if ( codegen.grammar.MaxCharValue > 255 )
+                prefix = "L\"";
+            return prefix + escapeString( buf.ToString() ) + "\"";
+        }
+        /** Character constants get truncated to this value.
+         * TODO: This should be derived from the charVocabulary. Depending on it
+         * being 255 or 0xFFFF the templates should generate normal character
+         * constants or multibyte ones.
+         */
+        public override int getMaxCharValue( CodeGenerator codegen )
+        {
+            int maxval = 255; // codegen.grammar.get????();
+            if ( maxval <= 255 )
+                return 255;
+            else
+                return maxval;
+        }
+    }
+}
diff --git a/Antlr3.Targets/Antlr3.Targets.Cpp/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.Cpp/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..255a4a0
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Cpp/Properties/AssemblyInfo.cs
@@ -0,0 +1,68 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle( "Antlr3.Targets.Cpp" )]
+[assembly: AssemblyDescription( "" )]
+[assembly: AssemblyConfiguration( "" )]
+[assembly: AssemblyCompany( "Pixel Mine, Inc." )]
+[assembly: AssemblyProduct( "Antlr3.Targets.Cpp" )]
+[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2009" )]
+[assembly: AssemblyTrademark( "" )]
+[assembly: AssemblyCulture( "" )]
+
+// Setting ComVisible to false makes the types in this assembly not visible
+// to COM components.  If you need to access a type in this assembly from
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible( false )]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid( "8e891174-fb0e-45c6-953d-d847b757bcc9" )]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion( "1.0.0.0" )]
+[assembly: AssemblyFileVersion( "1.0.0.0" )]
diff --git a/Antlr3.Targets/Antlr3.Targets.Cpp/app.config b/Antlr3.Targets/Antlr3.Targets.Cpp/app.config
new file mode 100644
index 0000000..df20690
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Cpp/app.config
@@ -0,0 +1,3 @@
+﻿<?xml version="1.0"?>
+<configuration>
+<startup><supportedRuntime version="v2.0.50727"/></startup></configuration>
diff --git a/Antlr3.Targets/Antlr3.Targets.Delphi/Antlr3.Targets.Delphi.csproj b/Antlr3.Targets/Antlr3.Targets.Delphi/Antlr3.Targets.Delphi.csproj
new file mode 100644
index 0000000..32c88cf
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Delphi/Antlr3.Targets.Delphi.csproj
@@ -0,0 +1,64 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{6689F268-CE30-4CEC-AAD5-2DF72C43623C}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>Antlr3.Targets</RootNamespace>
+    <AssemblyName>Antlr3.Targets.Delphi</AssemblyName>
+    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <TargetFrameworkSubset>
+    </TargetFrameworkSubset>
+    <SccProjectName>SAK</SccProjectName>
+    <SccLocalPath>SAK</SccLocalPath>
+    <SccAuxPath>SAK</SccAuxPath>
+    <SccProvider>SAK</SccProvider>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\bin\Debug\Targets\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\bin\Release\Targets\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="DelphiTarget.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\Antlr3\Antlr3.csproj">
+      <Project>{2AB8CAED-C046-4F05-8B18-6948100D2FE7}</Project>
+      <Name>Antlr3</Name>
+      <Private>False</Private>
+    </ProjectReference>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="app.config" />
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
\ No newline at end of file
diff --git a/Antlr3.Targets/Antlr3.Targets.Delphi/Antlr3.Targets.Delphi.csproj.vspscc b/Antlr3.Targets/Antlr3.Targets.Delphi/Antlr3.Targets.Delphi.csproj.vspscc
new file mode 100644
index 0000000..b6d3289
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Delphi/Antlr3.Targets.Delphi.csproj.vspscc
@@ -0,0 +1,10 @@
+﻿""
+{
+"FILE_VERSION" = "9237"
+"ENLISTMENT_CHOICE" = "NEVER"
+"PROJECT_FILE_RELATIVE_PATH" = ""
+"NUMBER_OF_EXCLUDED_FILES" = "0"
+"ORIGINAL_PROJECT_FILE_PATH" = ""
+"NUMBER_OF_NESTED_PROJECTS" = "0"
+"SOURCE_CONTROL_SETTINGS_PROVIDER" = "PROVIDER"
+}
diff --git a/Antlr3.Targets/Antlr3.Targets.Delphi/DelphiTarget.cs b/Antlr3.Targets/Antlr3.Targets.Delphi/DelphiTarget.cs
new file mode 100644
index 0000000..7a8d3c1
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Delphi/DelphiTarget.cs
@@ -0,0 +1,143 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2008 Erik van Bilsen
+ * Copyright (c) 2006 Kunle Odutola
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+namespace Antlr3.Targets
+{
+    using CodeGenerator = Antlr3.Codegen.CodeGenerator;
+    using Grammar = Antlr3.Tool.Grammar;
+    using Label = Antlr3.Analysis.Label;
+    using StringBuilder = System.Text.StringBuilder;
+    using Target = Antlr3.Codegen.Target;
+
+    public class DelphiTarget : Target
+    {
+        public DelphiTarget()
+        {
+            targetCharValueEscape['\n'] = "'#10'";
+            targetCharValueEscape['\r'] = "'#13'";
+            targetCharValueEscape['\t'] = "'#9'";
+            targetCharValueEscape['\b'] = "\\b";
+            targetCharValueEscape['\f'] = "\\f";
+            targetCharValueEscape['\\'] = "\\";
+            targetCharValueEscape['\''] = "''";
+            targetCharValueEscape['"'] = "'";
+        }
+
+        public override string encodeIntAsCharEscape( int v )
+        {
+            string hex = ( v <= 127 ) ? v.ToString( "x2" ) : v.ToString( "x4" );
+            return "'#$" + hex + "'";
+        }
+
+        public override string getTargetCharLiteralFromANTLRCharLiteral( CodeGenerator generator, string literal )
+        {
+            StringBuilder buf = new StringBuilder();
+            int c = Grammar.getCharValueFromGrammarCharLiteral( literal );
+            if ( c < Label.MIN_CHAR_VALUE )
+            {
+                return "0";
+            }
+            // normal char
+            buf.Append( c );
+
+            return buf.ToString();
+        }
+
+        public override string getTargetStringLiteralFromString( string s, bool quoted )
+        {
+            if ( s == null )
+            {
+                return null;
+            }
+            StringBuilder buf = new StringBuilder();
+            if ( quoted )
+            {
+                buf.Append( '\'' );
+            }
+            for ( int i = 0; i < s.Length; i++ )
+            {
+                int c = s[i];
+                if ( c != '"' && // don't escape double quotes in strings for Delphi
+                   c < targetCharValueEscape.Length &&
+                   targetCharValueEscape[c] != null )
+                {
+                    buf.Append( targetCharValueEscape[c] );
+                }
+                else
+                {
+                    buf.Append( (char)c );
+                }
+                if ( ( i & 127 ) == 127 )
+                {
+                    // Concatenate string literals because Delphi doesn't support literals over 255 characters,
+                    // and the code editor doesn't support lines over 1023 characters
+                    buf.Append( "\' + \r\n  \'" );
+                }
+            }
+            if ( quoted )
+            {
+                buf.Append( '\'' );
+            }
+            return buf.ToString();
+        }
+
+        public override string getTargetStringLiteralFromANTLRStringLiteral( CodeGenerator generator, string literal )
+        {
+            literal = literal.Replace( "\\\'", "''" ); // \' to ' to normalize
+            literal = literal.Replace( "\\r\\n", "'#13#10'" );
+            literal = literal.Replace( "\\r", "'#13'" );
+            literal = literal.Replace( "\\n", "'#10'" );
+            StringBuilder buf = new StringBuilder( literal );
+            buf[0] = '\'';
+            buf[literal.Length - 1] = '\'';
+            return buf.ToString();
+        }
+
+        public override string getTarget64BitStringFromValue( ulong word )
+        {
+            int numHexDigits = 8 * 2;
+            StringBuilder buf = new StringBuilder( numHexDigits + 2 );
+            buf.Append( "$" );
+            string digits = word.ToString( "X" );
+            int padding = numHexDigits - digits.Length;
+            // pad left with zeros
+            for ( int i = 1; i <= padding; i++ )
+            {
+                buf.Append( '0' );
+            }
+            buf.Append( digits );
+            return buf.ToString();
+        }
+
+    }
+}
diff --git a/Antlr3.Targets/Antlr3.Targets.Delphi/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.Delphi/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..fe71beb
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Delphi/Properties/AssemblyInfo.cs
@@ -0,0 +1,68 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle( "Antlr3.Targets.Delphi" )]
+[assembly: AssemblyDescription( "" )]
+[assembly: AssemblyConfiguration( "" )]
+[assembly: AssemblyCompany( "Pixel Mine, Inc." )]
+[assembly: AssemblyProduct( "Antlr3.Targets.Delphi" )]
+[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2009" )]
+[assembly: AssemblyTrademark( "" )]
+[assembly: AssemblyCulture( "" )]
+
+// Setting ComVisible to false makes the types in this assembly not visible
+// to COM components.  If you need to access a type in this assembly from
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible( false )]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid( "0987d253-96de-4d56-9387-dc6f4293a374" )]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion( "1.0.0.0" )]
+[assembly: AssemblyFileVersion( "1.0.0.0" )]
diff --git a/Antlr3.Targets/Antlr3.Targets.Delphi/app.config b/Antlr3.Targets/Antlr3.Targets.Delphi/app.config
new file mode 100644
index 0000000..df20690
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Delphi/app.config
@@ -0,0 +1,3 @@
+﻿<?xml version="1.0"?>
+<configuration>
+<startup><supportedRuntime version="v2.0.50727"/></startup></configuration>
diff --git a/Antlr3.Targets/Antlr3.Targets.Java/Antlr3.Targets.Java.csproj b/Antlr3.Targets/Antlr3.Targets.Java/Antlr3.Targets.Java.csproj
new file mode 100644
index 0000000..6ad7999
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Java/Antlr3.Targets.Java.csproj
@@ -0,0 +1,64 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{696F611F-003B-477D-AFA0-4F15478C9D32}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>Antlr3.Targets</RootNamespace>
+    <AssemblyName>Antlr3.Targets.Java</AssemblyName>
+    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <TargetFrameworkSubset>
+    </TargetFrameworkSubset>
+    <SccProjectName>SAK</SccProjectName>
+    <SccLocalPath>SAK</SccLocalPath>
+    <SccAuxPath>SAK</SccAuxPath>
+    <SccProvider>SAK</SccProvider>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\bin\Debug\Targets\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\bin\Release\Targets\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="JavaTarget.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\Antlr3\Antlr3.csproj">
+      <Project>{2AB8CAED-C046-4F05-8B18-6948100D2FE7}</Project>
+      <Name>Antlr3</Name>
+      <Private>False</Private>
+    </ProjectReference>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="app.config" />
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
\ No newline at end of file
diff --git a/Antlr3.Targets/Antlr3.Targets.Java/Antlr3.Targets.Java.csproj.vspscc b/Antlr3.Targets/Antlr3.Targets.Java/Antlr3.Targets.Java.csproj.vspscc
new file mode 100644
index 0000000..b6d3289
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Java/Antlr3.Targets.Java.csproj.vspscc
@@ -0,0 +1,10 @@
+﻿""
+{
+"FILE_VERSION" = "9237"
+"ENLISTMENT_CHOICE" = "NEVER"
+"PROJECT_FILE_RELATIVE_PATH" = ""
+"NUMBER_OF_EXCLUDED_FILES" = "0"
+"ORIGINAL_PROJECT_FILE_PATH" = ""
+"NUMBER_OF_NESTED_PROJECTS" = "0"
+"SOURCE_CONTROL_SETTINGS_PROVIDER" = "PROVIDER"
+}
diff --git a/Antlr3.Targets/Antlr3.Targets.Java/JavaTarget.cs b/Antlr3.Targets/Antlr3.Targets.Java/JavaTarget.cs
new file mode 100644
index 0000000..c39be9e
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Java/JavaTarget.cs
@@ -0,0 +1,39 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+namespace Antlr3.Targets
+{
+    using Target = Antlr3.Codegen.Target;
+
+    public class JavaTarget : Target
+    {
+    }
+}
diff --git a/Antlr3.Targets/Antlr3.Targets.Java/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.Java/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..5fef08a
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Java/Properties/AssemblyInfo.cs
@@ -0,0 +1,68 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle( "Antlr3.Targets.Java" )]
+[assembly: AssemblyDescription( "" )]
+[assembly: AssemblyConfiguration( "" )]
+[assembly: AssemblyCompany( "Pixel Mine, Inc." )]
+[assembly: AssemblyProduct( "Antlr3.Targets.Java" )]
+[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2009" )]
+[assembly: AssemblyTrademark( "" )]
+[assembly: AssemblyCulture( "" )]
+
+// Setting ComVisible to false makes the types in this assembly not visible
+// to COM components.  If you need to access a type in this assembly from
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible( false )]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid( "2388a4ff-439f-48b3-80fd-364f7bccfb9d" )]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion( "1.0.0.0" )]
+[assembly: AssemblyFileVersion( "1.0.0.0" )]
diff --git a/Antlr3.Targets/Antlr3.Targets.Java/app.config b/Antlr3.Targets/Antlr3.Targets.Java/app.config
new file mode 100644
index 0000000..df20690
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Java/app.config
@@ -0,0 +1,3 @@
+﻿<?xml version="1.0"?>
+<configuration>
+<startup><supportedRuntime version="v2.0.50727"/></startup></configuration>
diff --git a/Antlr3.Targets/Antlr3.Targets.JavaScript/Antlr3.Targets.JavaScript.csproj b/Antlr3.Targets/Antlr3.Targets.JavaScript/Antlr3.Targets.JavaScript.csproj
new file mode 100644
index 0000000..37e2a1a
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.JavaScript/Antlr3.Targets.JavaScript.csproj
@@ -0,0 +1,64 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{1551D1E7-D515-4488-A889-5DEBB4950880}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>Antlr3.Targets</RootNamespace>
+    <AssemblyName>Antlr3.Targets.JavaScript</AssemblyName>
+    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <TargetFrameworkSubset>
+    </TargetFrameworkSubset>
+    <SccProjectName>SAK</SccProjectName>
+    <SccLocalPath>SAK</SccLocalPath>
+    <SccAuxPath>SAK</SccAuxPath>
+    <SccProvider>SAK</SccProvider>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\bin\Debug\Targets\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\bin\Release\Targets\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="JavaScriptTarget.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\Antlr3\Antlr3.csproj">
+      <Project>{2AB8CAED-C046-4F05-8B18-6948100D2FE7}</Project>
+      <Name>Antlr3</Name>
+      <Private>False</Private>
+    </ProjectReference>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="app.config" />
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
\ No newline at end of file
diff --git a/Antlr3.Targets/Antlr3.Targets.JavaScript/Antlr3.Targets.JavaScript.csproj.vspscc b/Antlr3.Targets/Antlr3.Targets.JavaScript/Antlr3.Targets.JavaScript.csproj.vspscc
new file mode 100644
index 0000000..b6d3289
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.JavaScript/Antlr3.Targets.JavaScript.csproj.vspscc
@@ -0,0 +1,10 @@
+﻿""
+{
+"FILE_VERSION" = "9237"
+"ENLISTMENT_CHOICE" = "NEVER"
+"PROJECT_FILE_RELATIVE_PATH" = ""
+"NUMBER_OF_EXCLUDED_FILES" = "0"
+"ORIGINAL_PROJECT_FILE_PATH" = ""
+"NUMBER_OF_NESTED_PROJECTS" = "0"
+"SOURCE_CONTROL_SETTINGS_PROVIDER" = "PROVIDER"
+}
diff --git a/Antlr3.Targets/Antlr3.Targets.JavaScript/JavaScriptTarget.cs b/Antlr3.Targets/Antlr3.Targets.JavaScript/JavaScriptTarget.cs
new file mode 100644
index 0000000..c098f54
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.JavaScript/JavaScriptTarget.cs
@@ -0,0 +1,86 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+namespace Antlr3.Targets
+{
+    using StringBuilder = System.Text.StringBuilder;
+    using Target = Antlr3.Codegen.Target;
+
+    public class JavaScriptTarget : Target
+    {
+        /** Convert an int to a JavaScript Unicode character literal.
+         *
+         *  The current JavaScript spec (ECMA-262) doesn't provide for octal
+         *  notation in String literals, although some implementations support it.
+         *  This method overrides the parent class so that characters will always
+         *  be encoded as Unicode literals (e.g. \u0011).
+         */
+        public override string encodeIntAsCharEscape( int v )
+        {
+            string hex = v.ToString( "x4" );
+            return "\\u" + hex;
+        }
+
+        /** Convert long to two 32-bit numbers separted by a comma.
+         *  JavaScript does not support 64-bit numbers, so we need to break
+         *  the number into two 32-bit literals to give to the Bit.  A number like
+         *  0xHHHHHHHHLLLLLLLL is broken into the following string:
+         *  "0xLLLLLLLL, 0xHHHHHHHH"
+         *  Note that the low order bits are first, followed by the high order bits.
+         *  This is to match how the BitSet constructor works, where the bits are
+         *  passed in in 32-bit chunks with low-order bits coming first.
+         *
+         *  Note: stole the following two methods from the ActionScript target.
+         */
+        public override string getTarget64BitStringFromValue( ulong word )
+        {
+            StringBuilder buf = new StringBuilder( 22 ); // enough for the two "0x", "," and " "
+            buf.Append( "0x" );
+            writeHexWithPadding( buf, ( (uint)word ).ToString( "x" ) );
+            buf.Append( ", 0x" );
+            writeHexWithPadding( buf, ( word >> 32 ).ToString( "x" ) );
+
+            return buf.ToString();
+        }
+
+        private void writeHexWithPadding( StringBuilder buf, string digits )
+        {
+            digits = digits.ToUpperInvariant();
+            int padding = 8 - digits.Length;
+            // pad left with zeros
+            for ( int i = 1; i <= padding; i++ )
+            {
+                buf.Append( '0' );
+            }
+            buf.Append( digits );
+        }
+    }
+}
diff --git a/Antlr3.Targets/Antlr3.Targets.JavaScript/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.JavaScript/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..a4f50d1
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.JavaScript/Properties/AssemblyInfo.cs
@@ -0,0 +1,68 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle( "Antlr3.Targets.JavaScript" )]
+[assembly: AssemblyDescription( "" )]
+[assembly: AssemblyConfiguration( "" )]
+[assembly: AssemblyCompany( "Pixel Mine, Inc." )]
+[assembly: AssemblyProduct( "Antlr3.Targets.JavaScript" )]
+[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2009" )]
+[assembly: AssemblyTrademark( "" )]
+[assembly: AssemblyCulture( "" )]
+
+// Setting ComVisible to false makes the types in this assembly not visible
+// to COM components.  If you need to access a type in this assembly from
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible( false )]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid( "4fbc2549-85b3-43fa-8994-cb4ac111a33c" )]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion( "1.0.0.0" )]
+[assembly: AssemblyFileVersion( "1.0.0.0" )]
diff --git a/Antlr3.Targets/Antlr3.Targets.JavaScript/app.config b/Antlr3.Targets/Antlr3.Targets.JavaScript/app.config
new file mode 100644
index 0000000..df20690
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.JavaScript/app.config
@@ -0,0 +1,3 @@
+﻿<?xml version="1.0"?>
+<configuration>
+<startup><supportedRuntime version="v2.0.50727"/></startup></configuration>
diff --git a/Antlr3.Targets/Antlr3.Targets.ObjC/Antlr3.Targets.ObjC.csproj b/Antlr3.Targets/Antlr3.Targets.ObjC/Antlr3.Targets.ObjC.csproj
new file mode 100644
index 0000000..9c11268
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.ObjC/Antlr3.Targets.ObjC.csproj
@@ -0,0 +1,69 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{8EFEA650-B9F6-498B-8865-A78103CCB590}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>Antlr3.Targets</RootNamespace>
+    <AssemblyName>Antlr3.Targets.ObjC</AssemblyName>
+    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <TargetFrameworkSubset>
+    </TargetFrameworkSubset>
+    <SccProjectName>SAK</SccProjectName>
+    <SccLocalPath>SAK</SccLocalPath>
+    <SccAuxPath>SAK</SccAuxPath>
+    <SccProvider>SAK</SccProvider>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\bin\Debug\Targets\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\bin\Release\Targets\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="ObjCTarget.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\Antlr3.StringTemplate\Antlr3.StringTemplate.csproj">
+      <Project>{B5910BE2-DE21-4AA9-95C1-486F42B9E794}</Project>
+      <Name>Antlr3.StringTemplate</Name>
+      <Private>False</Private>
+    </ProjectReference>
+    <ProjectReference Include="..\..\Antlr3\Antlr3.csproj">
+      <Project>{2AB8CAED-C046-4F05-8B18-6948100D2FE7}</Project>
+      <Name>Antlr3</Name>
+      <Private>False</Private>
+    </ProjectReference>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="app.config" />
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
\ No newline at end of file
diff --git a/Antlr3.Targets/Antlr3.Targets.ObjC/Antlr3.Targets.ObjC.csproj.vspscc b/Antlr3.Targets/Antlr3.Targets.ObjC/Antlr3.Targets.ObjC.csproj.vspscc
new file mode 100644
index 0000000..b6d3289
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.ObjC/Antlr3.Targets.ObjC.csproj.vspscc
@@ -0,0 +1,10 @@
+﻿""
+{
+"FILE_VERSION" = "9237"
+"ENLISTMENT_CHOICE" = "NEVER"
+"PROJECT_FILE_RELATIVE_PATH" = ""
+"NUMBER_OF_EXCLUDED_FILES" = "0"
+"ORIGINAL_PROJECT_FILE_PATH" = ""
+"NUMBER_OF_NESTED_PROJECTS" = "0"
+"SOURCE_CONTROL_SETTINGS_PROVIDER" = "PROVIDER"
+}
diff --git a/Antlr3.Targets/Antlr3.Targets.ObjC/ObjCTarget.cs b/Antlr3.Targets/Antlr3.Targets.ObjC/ObjCTarget.cs
new file mode 100644
index 0000000..828d7e5
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.ObjC/ObjCTarget.cs
@@ -0,0 +1,125 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * Copyright (c) 2006 Kay Roepke (Objective-C runtime)
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Targets
+{
+    using CodeGenerator = Antlr3.Codegen.CodeGenerator;
+    using Grammar = Antlr3.Tool.Grammar;
+    using StringBuilder = System.Text.StringBuilder;
+    using StringTemplate = Antlr3.ST.StringTemplate;
+    using Target = Antlr3.Codegen.Target;
+
+    public class ObjCTarget : Target
+    {
+        protected override void genRecognizerHeaderFile( AntlrTool tool,
+                                               CodeGenerator generator,
+                                               Grammar grammar,
+                                               StringTemplate headerFileST,
+                                               string extName )
+        {
+            generator.write( headerFileST, grammar.name + Grammar.grammarTypeToFileNameSuffix[grammar.type] + extName );
+        }
+
+        public override string getTargetCharLiteralFromANTLRCharLiteral( CodeGenerator generator,
+                                                               string literal )
+        {
+            if ( literal.StartsWith( "'\\u" ) )
+            {
+                literal = "0x" + literal.Substring( 3, 4 );
+            }
+            else
+            {
+                int c = literal[1]; // TJP
+                if ( c < 32 || c > 127 )
+                {
+                    literal = "0x" + c.ToString( "x" );
+                }
+            }
+
+            return literal;
+        }
+
+        /** Convert from an ANTLR string literal found in a grammar file to
+        *  an equivalent string literal in the target language.  For Java, this
+        *  is the translation 'a\n"' -> "a\n\"".  Expect single quotes
+        *  around the incoming literal.  Just flip the quotes and replace
+        *  double quotes with \"
+        */
+        public override string getTargetStringLiteralFromANTLRStringLiteral( CodeGenerator generator,
+                                                                   string literal )
+        {
+            literal = literal.Replace( "\"", "\\\"" );
+            StringBuilder buf = new StringBuilder( literal );
+            buf[0] = '"';
+            buf[literal.Length - 1] = '"';
+            buf.Insert( 0, '@' );
+            return buf.ToString();
+        }
+
+        /** If we have a label, prefix it with the recognizer's name */
+        public override string getTokenTypeAsTargetLabel( CodeGenerator generator, int ttype )
+        {
+            string name = generator.grammar.getTokenDisplayName( ttype );
+            // If name is a literal, return the token type instead
+            if ( name[0] == '\'' )
+            {
+                return ttype.ToString();
+            }
+            return generator.grammar.name + Grammar.grammarTypeToFileNameSuffix[generator.grammar.type] + "_" + name;
+            //return super.getTokenTypeAsTargetLabel(generator, ttype);
+            //return this.getTokenTextAndTypeAsTargetLabel(generator, null, ttype);
+        }
+
+        /** Target must be able to override the labels used for token types. Sometimes also depends on the token text.*/
+        string getTokenTextAndTypeAsTargetLabel( CodeGenerator generator, string text, int tokenType )
+        {
+            string name = generator.grammar.getTokenDisplayName( tokenType );
+            // If name is a literal, return the token type instead
+            if ( name[0] == '\'' )
+            {
+                return tokenType.ToString();
+            }
+            string textEquivalent = text == null ? name : text;
+            if ( textEquivalent[0] >= '0' && textEquivalent[0] <= '9' )
+            {
+                return textEquivalent;
+            }
+            else
+            {
+                return generator.grammar.name + Grammar.grammarTypeToFileNameSuffix[generator.grammar.type] + "_" + textEquivalent;
+            }
+        }
+
+    }
+
+}
diff --git a/Antlr3.Targets/Antlr3.Targets.ObjC/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.ObjC/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..604a2b0
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.ObjC/Properties/AssemblyInfo.cs
@@ -0,0 +1,68 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle( "Antlr3.Targets.ObjC" )]
+[assembly: AssemblyDescription( "" )]
+[assembly: AssemblyConfiguration( "" )]
+[assembly: AssemblyCompany( "Pixel Mine, Inc." )]
+[assembly: AssemblyProduct( "Antlr3.Targets.ObjC" )]
+[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2009" )]
+[assembly: AssemblyTrademark( "" )]
+[assembly: AssemblyCulture( "" )]
+
+// Setting ComVisible to false makes the types in this assembly not visible
+// to COM components.  If you need to access a type in this assembly from
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible( false )]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid( "a8b15bc5-58a3-49d3-982d-051730d2bd79" )]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion( "1.0.0.0" )]
+[assembly: AssemblyFileVersion( "1.0.0.0" )]
diff --git a/Antlr3.Targets/Antlr3.Targets.ObjC/app.config b/Antlr3.Targets/Antlr3.Targets.ObjC/app.config
new file mode 100644
index 0000000..df20690
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.ObjC/app.config
@@ -0,0 +1,3 @@
+﻿<?xml version="1.0"?>
+<configuration>
+<startup><supportedRuntime version="v2.0.50727"/></startup></configuration>
diff --git a/Antlr3.Targets/Antlr3.Targets.Perl5/Antlr3.Targets.Perl5.csproj b/Antlr3.Targets/Antlr3.Targets.Perl5/Antlr3.Targets.Perl5.csproj
new file mode 100644
index 0000000..a4d2c4c
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Perl5/Antlr3.Targets.Perl5.csproj
@@ -0,0 +1,64 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{9444ACEF-784D-47B0-B317-F374782FA511}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>Antlr3.Targets</RootNamespace>
+    <AssemblyName>Antlr3.Targets.Perl5</AssemblyName>
+    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <TargetFrameworkSubset>
+    </TargetFrameworkSubset>
+    <SccProjectName>SAK</SccProjectName>
+    <SccLocalPath>SAK</SccLocalPath>
+    <SccAuxPath>SAK</SccAuxPath>
+    <SccProvider>SAK</SccProvider>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\bin\Debug\Targets\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\bin\Release\Targets\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="Perl5Target.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\Antlr3\Antlr3.csproj">
+      <Project>{2AB8CAED-C046-4F05-8B18-6948100D2FE7}</Project>
+      <Name>Antlr3</Name>
+      <Private>False</Private>
+    </ProjectReference>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="app.config" />
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
\ No newline at end of file
diff --git a/Antlr3.Targets/Antlr3.Targets.Perl5/Antlr3.Targets.Perl5.csproj.vspscc b/Antlr3.Targets/Antlr3.Targets.Perl5/Antlr3.Targets.Perl5.csproj.vspscc
new file mode 100644
index 0000000..b6d3289
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Perl5/Antlr3.Targets.Perl5.csproj.vspscc
@@ -0,0 +1,10 @@
+﻿""
+{
+"FILE_VERSION" = "9237"
+"ENLISTMENT_CHOICE" = "NEVER"
+"PROJECT_FILE_RELATIVE_PATH" = ""
+"NUMBER_OF_EXCLUDED_FILES" = "0"
+"ORIGINAL_PROJECT_FILE_PATH" = ""
+"NUMBER_OF_NESTED_PROJECTS" = "0"
+"SOURCE_CONTROL_SETTINGS_PROVIDER" = "PROVIDER"
+}
diff --git a/Antlr3.Targets/Antlr3.Targets.Perl5/Perl5Target.cs b/Antlr3.Targets/Antlr3.Targets.Perl5/Perl5Target.cs
new file mode 100644
index 0000000..20982de
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Perl5/Perl5Target.cs
@@ -0,0 +1,111 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2007 Ronald Blaschke
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+namespace Antlr3.Targets
+{
+    using AttributeScope = Antlr3.Tool.AttributeScope;
+    using CodeGenerator = Antlr3.Codegen.CodeGenerator;
+    using Grammar = Antlr3.Tool.Grammar;
+    using Label = Antlr3.Analysis.Label;
+    using RuleLabelScope = Antlr3.Tool.RuleLabelScope;
+    using StringBuilder = System.Text.StringBuilder;
+    using Target = Antlr3.Codegen.Target;
+
+    public class Perl5Target : Target
+    {
+        public Perl5Target()
+        {
+            targetCharValueEscape['$'] = "\\$";
+            targetCharValueEscape['@'] = "\\@";
+            targetCharValueEscape['%'] = "\\%";
+            AttributeScope.tokenScope.addAttribute( "self", null );
+            RuleLabelScope.predefinedLexerRulePropertiesScope.addAttribute( "self", null );
+        }
+
+        public override string getTargetCharLiteralFromANTLRCharLiteral( CodeGenerator generator,
+                                                                string literal )
+        {
+            StringBuilder buf = new StringBuilder( 10 );
+
+            int c = Grammar.getCharValueFromGrammarCharLiteral( literal );
+            if ( c < Label.MIN_CHAR_VALUE )
+            {
+                buf.Append( "\\x{0000}" );
+            }
+            else if ( c < targetCharValueEscape.Length &&
+                    targetCharValueEscape[c] != null )
+            {
+                buf.Append( targetCharValueEscape[c] );
+            }
+            else if ( ( c < 0x7F ) && !char.IsControl( (char)c ) )
+            {
+                // normal char
+                buf.Append( (char)c );
+            }
+            else
+            {
+                // must be something unprintable...use \\uXXXX
+                // turn on the bit above max "\\uFFFF" value so that we pad with zeros
+                // then only take last 4 digits
+                string hex = c.ToString( "X4" );
+                buf.Append( "\\x{" );
+                buf.Append( hex );
+                buf.Append( "}" );
+            }
+
+            if ( buf.ToString().IndexOf( '\\' ) == -1 )
+            {
+                // no need for interpolation, use single quotes
+                buf.Insert( 0, '\'' );
+                buf.Append( '\'' );
+            }
+            else
+            {
+                // need string interpolation
+                buf.Insert( 0, '\"' );
+                buf.Append( '\"' );
+            }
+
+            return buf.ToString();
+        }
+
+        public override string encodeIntAsCharEscape( int v )
+        {
+            int intValue;
+            if ( ( v & 0x8000 ) == 0 )
+                intValue = v;
+            else
+                intValue = -( 0x10000 - v );
+
+            return intValue.ToString();
+        }
+    }
+}
diff --git a/Antlr3.Targets/Antlr3.Targets.Perl5/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.Perl5/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..445945c
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Perl5/Properties/AssemblyInfo.cs
@@ -0,0 +1,68 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle( "Antlr3.Targets.Perl5" )]
+[assembly: AssemblyDescription( "" )]
+[assembly: AssemblyConfiguration( "" )]
+[assembly: AssemblyCompany( "Pixel Mine, Inc." )]
+[assembly: AssemblyProduct( "Antlr3.Targets.Perl5" )]
+[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2009" )]
+[assembly: AssemblyTrademark( "" )]
+[assembly: AssemblyCulture( "" )]
+
+// Setting ComVisible to false makes the types in this assembly not visible
+// to COM components.  If you need to access a type in this assembly from
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible( false )]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid( "3d2be877-baf6-4b83-961a-b91aed7b8258" )]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion( "1.0.0.0" )]
+[assembly: AssemblyFileVersion( "1.0.0.0" )]
diff --git a/Antlr3.Targets/Antlr3.Targets.Perl5/app.config b/Antlr3.Targets/Antlr3.Targets.Perl5/app.config
new file mode 100644
index 0000000..df20690
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Perl5/app.config
@@ -0,0 +1,3 @@
+﻿<?xml version="1.0"?>
+<configuration>
+<startup><supportedRuntime version="v2.0.50727"/></startup></configuration>
diff --git a/Antlr3.Targets/Antlr3.Targets.Python/Antlr3.Targets.Python.csproj b/Antlr3.Targets/Antlr3.Targets.Python/Antlr3.Targets.Python.csproj
new file mode 100644
index 0000000..0762c87
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Python/Antlr3.Targets.Python.csproj
@@ -0,0 +1,69 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{1DEA6EB4-2288-4B6C-B5F4-1D102B8745BB}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>Antlr3.Targets</RootNamespace>
+    <AssemblyName>Antlr3.Targets.Python</AssemblyName>
+    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <TargetFrameworkSubset>
+    </TargetFrameworkSubset>
+    <SccProjectName>SAK</SccProjectName>
+    <SccLocalPath>SAK</SccLocalPath>
+    <SccAuxPath>SAK</SccAuxPath>
+    <SccProvider>SAK</SccProvider>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\bin\Debug\Targets\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\bin\Release\Targets\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="Properties\AssemblyInfo.cs" />
+    <Compile Include="PythonTarget.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="app.config" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\..\..\antlr\main\runtime\CSharp3\Sources\Antlr3.Runtime\Antlr3.Runtime.csproj">
+      <Project>{8FDC0A87-9005-4D5A-AB75-E55CEB575559}</Project>
+      <Name>Antlr3.Runtime</Name>
+      <Private>False</Private>
+    </ProjectReference>
+    <ProjectReference Include="..\..\Antlr3\Antlr3.csproj">
+      <Project>{2AB8CAED-C046-4F05-8B18-6948100D2FE7}</Project>
+      <Name>Antlr3</Name>
+      <Private>False</Private>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
\ No newline at end of file
diff --git a/Antlr3.Targets/Antlr3.Targets.Python/Antlr3.Targets.Python.csproj.vspscc b/Antlr3.Targets/Antlr3.Targets.Python/Antlr3.Targets.Python.csproj.vspscc
new file mode 100644
index 0000000..b6d3289
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Python/Antlr3.Targets.Python.csproj.vspscc
@@ -0,0 +1,10 @@
+﻿""
+{
+"FILE_VERSION" = "9237"
+"ENLISTMENT_CHOICE" = "NEVER"
+"PROJECT_FILE_RELATIVE_PATH" = ""
+"NUMBER_OF_EXCLUDED_FILES" = "0"
+"ORIGINAL_PROJECT_FILE_PATH" = ""
+"NUMBER_OF_NESTED_PROJECTS" = "0"
+"SOURCE_CONTROL_SETTINGS_PROVIDER" = "PROVIDER"
+}
diff --git a/Antlr3.Targets/Antlr3.Targets.Python/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.Python/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..a57fe34
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Python/Properties/AssemblyInfo.cs
@@ -0,0 +1,68 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle( "Antlr3.Targets.Python" )]
+[assembly: AssemblyDescription( "" )]
+[assembly: AssemblyConfiguration( "" )]
+[assembly: AssemblyCompany( "Pixel Mine, Inc." )]
+[assembly: AssemblyProduct( "Antlr3.Targets.Python" )]
+[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2009" )]
+[assembly: AssemblyTrademark( "" )]
+[assembly: AssemblyCulture( "" )]
+
+// Setting ComVisible to false makes the types in this assembly not visible
+// to COM components.  If you need to access a type in this assembly from
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible( false )]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid( "e40e91d9-3120-4442-86d8-33571ee23495" )]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion( "1.0.0.0" )]
+[assembly: AssemblyFileVersion( "1.0.0.0" )]
diff --git a/Antlr3.Targets/Antlr3.Targets.Python/PythonTarget.cs b/Antlr3.Targets/Antlr3.Targets.Python/PythonTarget.cs
new file mode 100644
index 0000000..4135515
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Python/PythonTarget.cs
@@ -0,0 +1,230 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005 Martin Traverso
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+
+Please excuse my obvious lack of Java experience. The code here is probably
+full of WTFs - though IMHO Java is the Real WTF(TM) here...
+
+ */
+
+namespace Antlr3.Targets
+{
+    using System.Collections.Generic;
+
+    using CodeGenerator = Antlr3.Codegen.CodeGenerator;
+    using Console = System.Console;
+    using Grammar = Antlr3.Tool.Grammar;
+    using IList = System.Collections.IList;
+    using IToken = Antlr.Runtime.IToken;
+    using Target = Antlr3.Codegen.Target;
+
+    public class PythonTarget : Target
+    {
+        /** Target must be able to override the labels used for token types */
+        public override string getTokenTypeAsTargetLabel( CodeGenerator generator,
+                            int ttype )
+        {
+            // use ints for predefined types;
+            // <invalid> <EOR> <DOWN> <UP>
+            if ( ttype >= 0 && ttype <= 3 )
+            {
+                return ttype.ToString();
+            }
+
+            string name = generator.grammar.getTokenDisplayName( ttype );
+
+            // If name is a literal, return the token type instead
+            if ( name[0] == '\'' )
+            {
+                return ttype.ToString();
+            }
+
+            return name;
+        }
+
+        public override string getTargetCharLiteralFromANTLRCharLiteral(
+                CodeGenerator generator,
+                string literal )
+        {
+            int c = Grammar.getCharValueFromGrammarCharLiteral( literal );
+            return ( (char)c ).ToString();
+        }
+
+        private IList<string> splitLines( string text )
+        {
+            return text.Split( '\n' );
+        }
+
+        public override IList postProcessAction( IList chunks, IToken actionToken )
+        {
+            /* TODO
+               - check for and report TAB usage
+             */
+
+            //System.out.println("\n*** Action at " + actionToken.getLine() + ":" + actionToken.getColumn());
+
+            /* First I create a new list of chunks. String chunks are splitted into
+               lines and some whitespace my be added at the beginning.
+
+               As a result I get a list of chunks
+               - where the first line starts at column 0
+               - where every LF is at the end of a string chunk
+            */
+
+            List<object> nChunks = new List<object>();
+            for ( int i = 0; i < chunks.Count; i++ )
+            {
+                object chunk = chunks[i];
+
+                string text = chunk as string;
+                if ( text != null )
+                {
+                    if ( nChunks.Count == 0 && actionToken.CharPositionInLine > 0 )
+                    {
+                        // first chunk and some 'virtual' WS at beginning
+                        // prepend to this chunk
+                        string ws = new string( ' ', actionToken.CharPositionInLine );
+                        text = ws + text;
+                    }
+
+                    nChunks.AddRange( text.Split( '\n' ) );
+                }
+                else
+                {
+                    if ( nChunks.Count == 0 && actionToken.CharPositionInLine > 0 )
+                    {
+                        // first chunk and some 'virtual' WS at beginning
+                        // add as a chunk of its own
+                        string ws = new string( ' ', actionToken.CharPositionInLine );
+                        nChunks.Add( ws );
+                    }
+
+                    nChunks.Add( chunk );
+                }
+            }
+
+            int lineNo = actionToken.Line;
+            int col = 0;
+
+            // strip trailing empty lines
+            int lastChunk = nChunks.Count - 1;
+            while ( lastChunk > 0
+                    && nChunks[lastChunk] is string
+                    && ( (string)nChunks[lastChunk] ).Trim().Length == 0 )
+            {
+                lastChunk--;
+            }
+
+            // string leading empty lines
+            int firstChunk = 0;
+            while ( firstChunk <= lastChunk
+                    && nChunks[firstChunk] is string
+                    && ( (string)nChunks[firstChunk] ).Trim().Length == 0
+                    && ( (string)nChunks[firstChunk] ).EndsWith( "\n" ) )
+            {
+                lineNo++;
+                firstChunk++;
+            }
+
+            int indent = -1;
+            for ( int i = firstChunk; i <= lastChunk; i++ )
+            {
+                object chunk = nChunks[i];
+
+                //System.out.println(lineNo + ":" + col + " " + quote(chunk.toString()));
+
+                string text = chunk as string;
+                if ( text != null )
+                {
+                    if ( col == 0 )
+                    {
+                        if ( indent == -1 )
+                        {
+                            // first non-blank line
+                            // count number of leading whitespaces
+
+                            indent = 0;
+                            for ( int j = 0; j < text.Length; j++ )
+                            {
+                                if ( !char.IsWhiteSpace( text[j] ) )
+                                    break;
+
+                                indent++;
+                            }
+                        }
+
+                        if ( text.Length >= indent )
+                        {
+                            int j;
+                            for ( j = 0; j < indent; j++ )
+                            {
+                                if ( !char.IsWhiteSpace( text[j] ) )
+                                {
+                                    // should do real error reporting here...
+                                    Console.Error.WriteLine( "Warning: badly indented line " + lineNo + " in action:" );
+                                    Console.Error.WriteLine( text );
+                                    break;
+                                }
+                            }
+
+                            nChunks[i] = text.Substring( j );
+                        }
+                        else if ( text.Trim().Length > 0 )
+                        {
+                            // should do real error reporting here...
+                            Console.Error.WriteLine( "Warning: badly indented line " + lineNo + " in action:" );
+                            Console.Error.WriteLine( text );
+                        }
+                    }
+
+                    if ( text.EndsWith( "\n" ) )
+                    {
+                        lineNo++;
+                        col = 0;
+                    }
+                    else
+                    {
+                        col += text.Length;
+                    }
+                }
+                else
+                {
+                    // not really correct, but all I need is col to increment...
+                    col += 1;
+                }
+            }
+
+            return nChunks;
+        }
+    }
+}
diff --git a/Antlr3.Targets/Antlr3.Targets.Python/app.config b/Antlr3.Targets/Antlr3.Targets.Python/app.config
new file mode 100644
index 0000000..df20690
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Python/app.config
@@ -0,0 +1,3 @@
+﻿<?xml version="1.0"?>
+<configuration>
+<startup><supportedRuntime version="v2.0.50727"/></startup></configuration>
diff --git a/Antlr3.Targets/Antlr3.Targets.Ruby/Antlr3.Targets.Ruby.csproj b/Antlr3.Targets/Antlr3.Targets.Ruby/Antlr3.Targets.Ruby.csproj
new file mode 100644
index 0000000..f052320
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Ruby/Antlr3.Targets.Ruby.csproj
@@ -0,0 +1,64 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{64418260-E75A-4556-BB7E-8BDAAFC2EFB9}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>Antlr3.Targets</RootNamespace>
+    <AssemblyName>Antlr3.Targets.Ruby</AssemblyName>
+    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <TargetFrameworkSubset>
+    </TargetFrameworkSubset>
+    <SccProjectName>SAK</SccProjectName>
+    <SccLocalPath>SAK</SccLocalPath>
+    <SccAuxPath>SAK</SccAuxPath>
+    <SccProvider>SAK</SccProvider>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\bin\Debug\Targets\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\bin\Release\Targets\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="Properties\AssemblyInfo.cs" />
+    <Compile Include="RubyTarget.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\Antlr3\Antlr3.csproj">
+      <Project>{2AB8CAED-C046-4F05-8B18-6948100D2FE7}</Project>
+      <Name>Antlr3</Name>
+      <Private>False</Private>
+    </ProjectReference>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="app.config" />
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
\ No newline at end of file
diff --git a/Antlr3.Targets/Antlr3.Targets.Ruby/Antlr3.Targets.Ruby.csproj.vspscc b/Antlr3.Targets/Antlr3.Targets.Ruby/Antlr3.Targets.Ruby.csproj.vspscc
new file mode 100644
index 0000000..b6d3289
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Ruby/Antlr3.Targets.Ruby.csproj.vspscc
@@ -0,0 +1,10 @@
+﻿""
+{
+"FILE_VERSION" = "9237"
+"ENLISTMENT_CHOICE" = "NEVER"
+"PROJECT_FILE_RELATIVE_PATH" = ""
+"NUMBER_OF_EXCLUDED_FILES" = "0"
+"ORIGINAL_PROJECT_FILE_PATH" = ""
+"NUMBER_OF_NESTED_PROJECTS" = "0"
+"SOURCE_CONTROL_SETTINGS_PROVIDER" = "PROVIDER"
+}
diff --git a/Antlr3.Targets/Antlr3.Targets.Ruby/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.Ruby/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..df08449
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Ruby/Properties/AssemblyInfo.cs
@@ -0,0 +1,68 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle( "Antlr3.Targets.Ruby" )]
+[assembly: AssemblyDescription( "" )]
+[assembly: AssemblyConfiguration( "" )]
+[assembly: AssemblyCompany( "Pixel Mine, Inc." )]
+[assembly: AssemblyProduct( "Antlr3.Targets.Ruby" )]
+[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2009" )]
+[assembly: AssemblyTrademark( "" )]
+[assembly: AssemblyCulture( "" )]
+
+// Setting ComVisible to false makes the types in this assembly not visible
+// to COM components.  If you need to access a type in this assembly from
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible( false )]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid( "9471023a-b241-4aed-a706-c8e8fa621dbf" )]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion( "1.0.0.0" )]
+[assembly: AssemblyFileVersion( "1.0.0.0" )]
diff --git a/Antlr3.Targets/Antlr3.Targets.Ruby/RubyTarget.cs b/Antlr3.Targets/Antlr3.Targets.Ruby/RubyTarget.cs
new file mode 100644
index 0000000..4194b27
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Ruby/RubyTarget.cs
@@ -0,0 +1,85 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005 Martin Traverso
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Targets
+{
+    using CodeGenerator = Antlr3.Codegen.CodeGenerator;
+    using Target = Antlr3.Codegen.Target;
+
+    public class RubyTarget : Target
+    {
+        public override string getTargetCharLiteralFromANTLRCharLiteral(
+                CodeGenerator generator,
+                string literal )
+        {
+            literal = literal.Substring( 1, literal.Length - 2 );
+
+            string result = "?";
+
+            if ( literal.Equals( "\\" ) )
+            {
+                result += "\\\\";
+            }
+            else if ( literal.Equals( " " ) )
+            {
+                result += "\\s";
+            }
+            else if ( literal.StartsWith( "\\u" ) )
+            {
+                result = "0x" + literal.Substring( 2 );
+            }
+            else
+            {
+                result += literal;
+            }
+
+            return result;
+        }
+
+        public override int getMaxCharValue( CodeGenerator generator )
+        {
+            // we don't support unicode, yet.
+            return 0xFF;
+        }
+
+        public override string getTokenTypeAsTargetLabel( CodeGenerator generator, int ttype )
+        {
+            string name = generator.grammar.getTokenDisplayName( ttype );
+            // If name is a literal, return the token type instead
+            if ( name[0] == '\'' )
+            {
+                return generator.grammar.computeTokenNameFromLiteral( ttype, name );
+            }
+            return name;
+        }
+    }
+}
diff --git a/Antlr3.Targets/Antlr3.Targets.Ruby/app.config b/Antlr3.Targets/Antlr3.Targets.Ruby/app.config
new file mode 100644
index 0000000..df20690
--- /dev/null
+++ b/Antlr3.Targets/Antlr3.Targets.Ruby/app.config
@@ -0,0 +1,3 @@
+﻿<?xml version="1.0"?>
+<configuration>
+<startup><supportedRuntime version="v2.0.50727"/></startup></configuration>
diff --git a/Antlr3.sln b/Antlr3.sln
new file mode 100644
index 0000000..6c1cb7d
--- /dev/null
+++ b/Antlr3.sln
@@ -0,0 +1,222 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 10.00
+# Visual Studio 2008
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Antlr3", "Antlr3\Antlr3.csproj", "{2AB8CAED-C046-4F05-8B18-6948100D2FE7}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Antlr3.StringTemplate", "Antlr3.StringTemplate\Antlr3.StringTemplate.csproj", "{B5910BE2-DE21-4AA9-95C1-486F42B9E794}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Antlr3.Test", "Antlr3.Test\Antlr3.Test.csproj", "{8B58597B-058E-4D7A-B83E-5269BDABBE2C}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Targets", "Targets", "{3A92893D-7810-4D8B-80D8-E1E8D151FA73}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Antlr3.Targets.ActionScript", "Antlr3.Targets\Antlr3.Targets.ActionScript\Antlr3.Targets.ActionScript.csproj", "{2A03CB56-C3E2-4B65-92C0-004C9D78E2A4}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Antlr3.Targets.C", "Antlr3.Targets\Antlr3.Targets.C\Antlr3.Targets.C.csproj", "{ABFF04E1-91CE-4F31-AAA0-0C70E3DBB4A6}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Antlr3.Targets.Cpp", "Antlr3.Targets\Antlr3.Targets.Cpp\Antlr3.Targets.Cpp.csproj", "{46171154-755A-4595-99AA-537D684BCA28}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Antlr3.Targets.CSharp", "Antlr3.Targets\Antlr3.Targets.CSharp\Antlr3.Targets.CSharp.csproj", "{48A0E438-158B-4C9E-887D-350E67A8AA09}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Antlr3.Targets.CSharp2", "Antlr3.Targets\Antlr3.Targets.CSharp2\Antlr3.Targets.CSharp2.csproj", "{5CBAC55A-A209-45CA-9F57-D0BFFFE2B7F9}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Antlr3.Targets.CSharp3", "Antlr3.Targets\Antlr3.Targets.CSharp3\Antlr3.Targets.CSharp3.csproj", "{67012F41-94F9-48E6-9677-E3C56E42917F}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Antlr3.Targets.Delphi", "Antlr3.Targets\Antlr3.Targets.Delphi\Antlr3.Targets.Delphi.csproj", "{6689F268-CE30-4CEC-AAD5-2DF72C43623C}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Antlr3.Targets.Java", "Antlr3.Targets\Antlr3.Targets.Java\Antlr3.Targets.Java.csproj", "{696F611F-003B-477D-AFA0-4F15478C9D32}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Antlr3.Targets.JavaScript", "Antlr3.Targets\Antlr3.Targets.JavaScript\Antlr3.Targets.JavaScript.csproj", "{1551D1E7-D515-4488-A889-5DEBB4950880}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Antlr3.Targets.ObjC", "Antlr3.Targets\Antlr3.Targets.ObjC\Antlr3.Targets.ObjC.csproj", "{8EFEA650-B9F6-498B-8865-A78103CCB590}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Antlr3.Targets.Perl5", "Antlr3.Targets\Antlr3.Targets.Perl5\Antlr3.Targets.Perl5.csproj", "{9444ACEF-784D-47B0-B317-F374782FA511}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Antlr3.Targets.Python", "Antlr3.Targets\Antlr3.Targets.Python\Antlr3.Targets.Python.csproj", "{1DEA6EB4-2288-4B6C-B5F4-1D102B8745BB}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Antlr3.Targets.Ruby", "Antlr3.Targets\Antlr3.Targets.Ruby\Antlr3.Targets.Ruby.csproj", "{64418260-E75A-4556-BB7E-8BDAAFC2EFB9}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Antlr3.Runtime", "..\..\antlr\main\runtime\CSharp3\Sources\Antlr3.Runtime\Antlr3.Runtime.csproj", "{8FDC0A87-9005-4D5A-AB75-E55CEB575559}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Antlr3.Runtime.Debug", "..\..\antlr\main\runtime\CSharp3\Sources\Antlr3.Runtime.Debug\Antlr3.Runtime.Debug.csproj", "{5EE27A90-B023-42C9-AAF1-52B0424C5D0B}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{C0B451C4-EAFC-4942-B18E-49EC73DABABD}"
+	ProjectSection(SolutionItems) = preProject
+		Antlr3.vsmdi = Antlr3.vsmdi
+		AntlrTestConfig.testrunconfig = AntlrTestConfig.testrunconfig
+	EndProjectSection
+EndProject
+Global
+	GlobalSection(TestCaseManagementSettings) = postSolution
+		CategoryFile = Antlr3.vsmdi
+	EndGlobalSection
+	GlobalSection(SourceCodeControl) = preSolution
+		SccNumberOfProjects = 19
+		SccProjectName0 = Perforce\u0020Project
+		SccLocalPath0 = ..\\..
+		SccProvider0 = MSSCCI:Perforce\u0020SCM
+		SccProjectFilePathRelativizedFromConnection0 = antlrcs\\main\\
+		SccProjectUniqueName1 = Antlr3\\Antlr3.csproj
+		SccLocalPath1 = ..\\..
+		SccProjectFilePathRelativizedFromConnection1 = antlrcs\\main\\Antlr3\\
+		SccProjectUniqueName2 = Antlr3.StringTemplate\\Antlr3.StringTemplate.csproj
+		SccLocalPath2 = ..\\..
+		SccProjectFilePathRelativizedFromConnection2 = antlrcs\\main\\Antlr3.StringTemplate\\
+		SccProjectUniqueName3 = Antlr3.Targets\\Antlr3.Targets.ActionScript\\Antlr3.Targets.ActionScript.csproj
+		SccProjectTopLevelParentUniqueName3 = Antlr3.sln
+		SccLocalPath3 = ..\\..
+		SccProjectFilePathRelativizedFromConnection3 = antlrcs\\main\\Antlr3.Targets\\Antlr3.Targets.ActionScript\\
+		SccProjectUniqueName4 = Antlr3.Targets\\Antlr3.Targets.C\\Antlr3.Targets.C.csproj
+		SccProjectTopLevelParentUniqueName4 = Antlr3.sln
+		SccLocalPath4 = ..\\..
+		SccProjectFilePathRelativizedFromConnection4 = antlrcs\\main\\Antlr3.Targets\\Antlr3.Targets.C\\
+		SccProjectUniqueName5 = Antlr3.Targets\\Antlr3.Targets.Cpp\\Antlr3.Targets.Cpp.csproj
+		SccProjectTopLevelParentUniqueName5 = Antlr3.sln
+		SccLocalPath5 = ..\\..
+		SccProjectFilePathRelativizedFromConnection5 = antlrcs\\main\\Antlr3.Targets\\Antlr3.Targets.Cpp\\
+		SccProjectUniqueName6 = Antlr3.Targets\\Antlr3.Targets.CSharp\\Antlr3.Targets.CSharp.csproj
+		SccProjectTopLevelParentUniqueName6 = Antlr3.sln
+		SccLocalPath6 = ..\\..
+		SccProjectFilePathRelativizedFromConnection6 = antlrcs\\main\\Antlr3.Targets\\Antlr3.Targets.CSharp\\
+		SccProjectUniqueName7 = Antlr3.Targets\\Antlr3.Targets.CSharp2\\Antlr3.Targets.CSharp2.csproj
+		SccProjectTopLevelParentUniqueName7 = Antlr3.sln
+		SccLocalPath7 = ..\\..
+		SccProjectFilePathRelativizedFromConnection7 = antlrcs\\main\\Antlr3.Targets\\Antlr3.Targets.CSharp2\\
+		SccProjectUniqueName8 = Antlr3.Targets\\Antlr3.Targets.CSharp3\\Antlr3.Targets.CSharp3.csproj
+		SccProjectTopLevelParentUniqueName8 = Antlr3.sln
+		SccLocalPath8 = ..\\..
+		SccProjectFilePathRelativizedFromConnection8 = antlrcs\\main\\Antlr3.Targets\\Antlr3.Targets.CSharp3\\
+		SccProjectUniqueName9 = Antlr3.Targets\\Antlr3.Targets.Delphi\\Antlr3.Targets.Delphi.csproj
+		SccProjectTopLevelParentUniqueName9 = Antlr3.sln
+		SccLocalPath9 = ..\\..
+		SccProjectFilePathRelativizedFromConnection9 = antlrcs\\main\\Antlr3.Targets\\Antlr3.Targets.Delphi\\
+		SccProjectUniqueName10 = Antlr3.Targets\\Antlr3.Targets.Java\\Antlr3.Targets.Java.csproj
+		SccProjectTopLevelParentUniqueName10 = Antlr3.sln
+		SccLocalPath10 = ..\\..
+		SccProjectFilePathRelativizedFromConnection10 = antlrcs\\main\\Antlr3.Targets\\Antlr3.Targets.Java\\
+		SccProjectUniqueName11 = Antlr3.Targets\\Antlr3.Targets.JavaScript\\Antlr3.Targets.JavaScript.csproj
+		SccProjectTopLevelParentUniqueName11 = Antlr3.sln
+		SccLocalPath11 = ..\\..
+		SccProjectFilePathRelativizedFromConnection11 = antlrcs\\main\\Antlr3.Targets\\Antlr3.Targets.JavaScript\\
+		SccProjectUniqueName12 = Antlr3.Targets\\Antlr3.Targets.ObjC\\Antlr3.Targets.ObjC.csproj
+		SccProjectTopLevelParentUniqueName12 = Antlr3.sln
+		SccLocalPath12 = ..\\..
+		SccProjectFilePathRelativizedFromConnection12 = antlrcs\\main\\Antlr3.Targets\\Antlr3.Targets.ObjC\\
+		SccProjectUniqueName13 = Antlr3.Targets\\Antlr3.Targets.Perl5\\Antlr3.Targets.Perl5.csproj
+		SccProjectTopLevelParentUniqueName13 = Antlr3.sln
+		SccLocalPath13 = ..\\..
+		SccProjectFilePathRelativizedFromConnection13 = antlrcs\\main\\Antlr3.Targets\\Antlr3.Targets.Perl5\\
+		SccProjectUniqueName14 = Antlr3.Targets\\Antlr3.Targets.Python\\Antlr3.Targets.Python.csproj
+		SccProjectTopLevelParentUniqueName14 = Antlr3.sln
+		SccLocalPath14 = ..\\..
+		SccProjectFilePathRelativizedFromConnection14 = antlrcs\\main\\Antlr3.Targets\\Antlr3.Targets.Python\\
+		SccProjectUniqueName15 = Antlr3.Targets\\Antlr3.Targets.Ruby\\Antlr3.Targets.Ruby.csproj
+		SccProjectTopLevelParentUniqueName15 = Antlr3.sln
+		SccLocalPath15 = ..\\..
+		SccProjectFilePathRelativizedFromConnection15 = antlrcs\\main\\Antlr3.Targets\\Antlr3.Targets.Ruby\\
+		SccProjectUniqueName16 = ..\\..\\antlr\\main\\runtime\\CSharp3\\Sources\\Antlr3.Runtime\\Antlr3.Runtime.csproj
+		SccLocalPath16 = ..\\..
+		SccProjectFilePathRelativizedFromConnection16 = antlr\\main\\runtime\\CSharp3\\Sources\\Antlr3.Runtime\\
+		SccProjectUniqueName17 = ..\\..\\antlr\\main\\runtime\\CSharp3\\Sources\\Antlr3.Runtime.Debug\\Antlr3.Runtime.Debug.csproj
+		SccLocalPath17 = ..\\..
+		SccProjectFilePathRelativizedFromConnection17 = antlr\\main\\runtime\\CSharp3\\Sources\\Antlr3.Runtime.Debug\\
+		SccProjectUniqueName18 = Antlr3.Test\\Antlr3.Test.csproj
+		SccLocalPath18 = ..\\..
+		SccProjectFilePathRelativizedFromConnection18 = antlrcs\\main\\Antlr3.Test\\
+	EndGlobalSection
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Any CPU = Debug|Any CPU
+		Release|Any CPU = Release|Any CPU
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{2AB8CAED-C046-4F05-8B18-6948100D2FE7}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{2AB8CAED-C046-4F05-8B18-6948100D2FE7}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{2AB8CAED-C046-4F05-8B18-6948100D2FE7}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{2AB8CAED-C046-4F05-8B18-6948100D2FE7}.Release|Any CPU.Build.0 = Release|Any CPU
+		{B5910BE2-DE21-4AA9-95C1-486F42B9E794}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{B5910BE2-DE21-4AA9-95C1-486F42B9E794}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{B5910BE2-DE21-4AA9-95C1-486F42B9E794}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{B5910BE2-DE21-4AA9-95C1-486F42B9E794}.Release|Any CPU.Build.0 = Release|Any CPU
+		{8B58597B-058E-4D7A-B83E-5269BDABBE2C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{8B58597B-058E-4D7A-B83E-5269BDABBE2C}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{8B58597B-058E-4D7A-B83E-5269BDABBE2C}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{8B58597B-058E-4D7A-B83E-5269BDABBE2C}.Release|Any CPU.Build.0 = Release|Any CPU
+		{2A03CB56-C3E2-4B65-92C0-004C9D78E2A4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{2A03CB56-C3E2-4B65-92C0-004C9D78E2A4}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{2A03CB56-C3E2-4B65-92C0-004C9D78E2A4}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{2A03CB56-C3E2-4B65-92C0-004C9D78E2A4}.Release|Any CPU.Build.0 = Release|Any CPU
+		{ABFF04E1-91CE-4F31-AAA0-0C70E3DBB4A6}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{ABFF04E1-91CE-4F31-AAA0-0C70E3DBB4A6}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{ABFF04E1-91CE-4F31-AAA0-0C70E3DBB4A6}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{ABFF04E1-91CE-4F31-AAA0-0C70E3DBB4A6}.Release|Any CPU.Build.0 = Release|Any CPU
+		{46171154-755A-4595-99AA-537D684BCA28}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{46171154-755A-4595-99AA-537D684BCA28}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{46171154-755A-4595-99AA-537D684BCA28}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{46171154-755A-4595-99AA-537D684BCA28}.Release|Any CPU.Build.0 = Release|Any CPU
+		{48A0E438-158B-4C9E-887D-350E67A8AA09}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{48A0E438-158B-4C9E-887D-350E67A8AA09}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{48A0E438-158B-4C9E-887D-350E67A8AA09}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{48A0E438-158B-4C9E-887D-350E67A8AA09}.Release|Any CPU.Build.0 = Release|Any CPU
+		{5CBAC55A-A209-45CA-9F57-D0BFFFE2B7F9}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{5CBAC55A-A209-45CA-9F57-D0BFFFE2B7F9}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{5CBAC55A-A209-45CA-9F57-D0BFFFE2B7F9}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{5CBAC55A-A209-45CA-9F57-D0BFFFE2B7F9}.Release|Any CPU.Build.0 = Release|Any CPU
+		{67012F41-94F9-48E6-9677-E3C56E42917F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{67012F41-94F9-48E6-9677-E3C56E42917F}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{67012F41-94F9-48E6-9677-E3C56E42917F}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{67012F41-94F9-48E6-9677-E3C56E42917F}.Release|Any CPU.Build.0 = Release|Any CPU
+		{6689F268-CE30-4CEC-AAD5-2DF72C43623C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{6689F268-CE30-4CEC-AAD5-2DF72C43623C}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{6689F268-CE30-4CEC-AAD5-2DF72C43623C}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{6689F268-CE30-4CEC-AAD5-2DF72C43623C}.Release|Any CPU.Build.0 = Release|Any CPU
+		{696F611F-003B-477D-AFA0-4F15478C9D32}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{696F611F-003B-477D-AFA0-4F15478C9D32}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{696F611F-003B-477D-AFA0-4F15478C9D32}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{696F611F-003B-477D-AFA0-4F15478C9D32}.Release|Any CPU.Build.0 = Release|Any CPU
+		{1551D1E7-D515-4488-A889-5DEBB4950880}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{1551D1E7-D515-4488-A889-5DEBB4950880}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{1551D1E7-D515-4488-A889-5DEBB4950880}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{1551D1E7-D515-4488-A889-5DEBB4950880}.Release|Any CPU.Build.0 = Release|Any CPU
+		{8EFEA650-B9F6-498B-8865-A78103CCB590}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{8EFEA650-B9F6-498B-8865-A78103CCB590}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{8EFEA650-B9F6-498B-8865-A78103CCB590}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{8EFEA650-B9F6-498B-8865-A78103CCB590}.Release|Any CPU.Build.0 = Release|Any CPU
+		{9444ACEF-784D-47B0-B317-F374782FA511}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{9444ACEF-784D-47B0-B317-F374782FA511}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{9444ACEF-784D-47B0-B317-F374782FA511}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{9444ACEF-784D-47B0-B317-F374782FA511}.Release|Any CPU.Build.0 = Release|Any CPU
+		{1DEA6EB4-2288-4B6C-B5F4-1D102B8745BB}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{1DEA6EB4-2288-4B6C-B5F4-1D102B8745BB}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{1DEA6EB4-2288-4B6C-B5F4-1D102B8745BB}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{1DEA6EB4-2288-4B6C-B5F4-1D102B8745BB}.Release|Any CPU.Build.0 = Release|Any CPU
+		{64418260-E75A-4556-BB7E-8BDAAFC2EFB9}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{64418260-E75A-4556-BB7E-8BDAAFC2EFB9}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{64418260-E75A-4556-BB7E-8BDAAFC2EFB9}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{64418260-E75A-4556-BB7E-8BDAAFC2EFB9}.Release|Any CPU.Build.0 = Release|Any CPU
+		{8FDC0A87-9005-4D5A-AB75-E55CEB575559}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{8FDC0A87-9005-4D5A-AB75-E55CEB575559}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{8FDC0A87-9005-4D5A-AB75-E55CEB575559}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{8FDC0A87-9005-4D5A-AB75-E55CEB575559}.Release|Any CPU.Build.0 = Release|Any CPU
+		{5EE27A90-B023-42C9-AAF1-52B0424C5D0B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{5EE27A90-B023-42C9-AAF1-52B0424C5D0B}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{5EE27A90-B023-42C9-AAF1-52B0424C5D0B}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{5EE27A90-B023-42C9-AAF1-52B0424C5D0B}.Release|Any CPU.Build.0 = Release|Any CPU
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+	GlobalSection(NestedProjects) = preSolution
+		{2A03CB56-C3E2-4B65-92C0-004C9D78E2A4} = {3A92893D-7810-4D8B-80D8-E1E8D151FA73}
+		{ABFF04E1-91CE-4F31-AAA0-0C70E3DBB4A6} = {3A92893D-7810-4D8B-80D8-E1E8D151FA73}
+		{46171154-755A-4595-99AA-537D684BCA28} = {3A92893D-7810-4D8B-80D8-E1E8D151FA73}
+		{48A0E438-158B-4C9E-887D-350E67A8AA09} = {3A92893D-7810-4D8B-80D8-E1E8D151FA73}
+		{5CBAC55A-A209-45CA-9F57-D0BFFFE2B7F9} = {3A92893D-7810-4D8B-80D8-E1E8D151FA73}
+		{67012F41-94F9-48E6-9677-E3C56E42917F} = {3A92893D-7810-4D8B-80D8-E1E8D151FA73}
+		{6689F268-CE30-4CEC-AAD5-2DF72C43623C} = {3A92893D-7810-4D8B-80D8-E1E8D151FA73}
+		{696F611F-003B-477D-AFA0-4F15478C9D32} = {3A92893D-7810-4D8B-80D8-E1E8D151FA73}
+		{1551D1E7-D515-4488-A889-5DEBB4950880} = {3A92893D-7810-4D8B-80D8-E1E8D151FA73}
+		{8EFEA650-B9F6-498B-8865-A78103CCB590} = {3A92893D-7810-4D8B-80D8-E1E8D151FA73}
+		{9444ACEF-784D-47B0-B317-F374782FA511} = {3A92893D-7810-4D8B-80D8-E1E8D151FA73}
+		{1DEA6EB4-2288-4B6C-B5F4-1D102B8745BB} = {3A92893D-7810-4D8B-80D8-E1E8D151FA73}
+		{64418260-E75A-4556-BB7E-8BDAAFC2EFB9} = {3A92893D-7810-4D8B-80D8-E1E8D151FA73}
+	EndGlobalSection
+EndGlobal
diff --git a/Antlr3.vsmdi b/Antlr3.vsmdi
new file mode 100644
index 0000000..bfb7dae
--- /dev/null
+++ b/Antlr3.vsmdi
@@ -0,0 +1,1375 @@
+﻿<?xml version="1.0" encoding="UTF-8"?>
+<TestLists xmlns="http://microsoft.com/schemas/VisualStudio/TeamTest/2006">
+  <TestList name="Tree parsing" id="06545df4-3577-43fa-8733-dd19464eea3a" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="55c346ef-612d-8413-657d-693660fb2a3c" name="TestSimpleTree" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0fc07c70-5c2a-245a-d31f-cf8592f0e292" name="TestWildcardLookahead" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d8d8f2c7-5687-0007-2452-6e516a8771fa" name="TestFlatList" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4478aecb-7cce-a294-40ac-e3ce2b0258e2" name="TestNullableChildList2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b73e7175-f13b-534b-06b4-26336439f7c5" name="TestCyclicDFALookahead" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f7f7a0f1-6534-8fc4-da58-e4af85bac4fc" name="TestNullableChildList3" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="cd31efe6-4981-45d9-d906-4e6777778600" name="TestFlatVsTreeDecision" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8da6c166-6f70-a771-e2c9-7899efac6764" name="TestWildcardLookahead2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="bf36b7cb-e5d3-4dd0-7b39-0981db0e72d0" name="TestNullableChildList" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="61882724-6684-28f5-107a-463d9e471712" name="TestFlatVsTreeDecision2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6330d6ea-8452-2e58-d34f-ba4f4585a201" name="TestWildcardLookahead3" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f359caf6-f25d-f9e8-bd6d-59aefeb54cc9" name="TestWildcardPlusLookahead" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="bd846272-fd8d-2948-a1f5-8adb030bd0de" name="TestTemplateOutput" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4ec05d5d-0b8d-f4d5-e26d-53100e89936e" name="TestActionsAfterRoot" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="Attributes" id="07ad9dce-6f06-4a3e-9993-335618220390" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="ce065251-8e59-a3b9-c090-9af7e103e602" name="TestIllegalAssignRuleRefAttr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ee262b7a-62a2-b1cc-8f20-17b842762e9e" name="TestRuleLabelWithoutOutputOption" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f671732a-bc65-bfae-6700-744b16a579d0" name="TestComplicatedArgParsingWithTranslation" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2c1c6ec2-7013-d450-e2c8-e10fb861ca1a" name="TestComplicatedSingleArgParsing" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="37b48982-776e-dafd-1286-bafaebe9d4ba" name="TestRuleScopeOutsideRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2f6adcb0-c227-2188-de06-858a490e54db" name="TestRefToReturnValueBeforeRefToPredefinedAttr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="048efe17-6490-e1d1-ee50-b574d61b1af4" name="TestDoNotTranslateAttributeCompare" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="99a29765-198c-43b6-fcff-5af85b1fe370" name="TestDynamicScopeRefOkEvenThoughRuleRefExists" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="69adff13-fafc-28b5-45b7-51da4a2e6671" name="TestCharLabelInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6544be6e-0c32-c4e7-a3d5-36de54dbc201" name="TestListAndTokenLabelTypeMismatch" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1c0007e2-5e64-769c-762d-615e4741ad2d" name="TestSimplePlusEqualLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="85a9471c-2ba3-6c8f-a928-0e5a4abc19a6" name="TestUnknownGlobalDynamicAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4bff4b50-e583-6a40-3cb0-96bef5c4461f" name="TestMultipleReturnInitValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d7134ea0-b130-07c7-dbeb-c85de83a9046" name="TestRuleLabelFromMultipleAlts" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8e6dace0-487f-e973-4b3c-f7f6ccafbc4a" name="TestRuleAttributeScopeInit" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a6c7ae41-0a87-d82f-0809-c6227c32ac8d" name="TestPlusEqualStringLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="319f6def-a0d5-0659-7555-8db046fb5bd0" name="TestArgsWhenNoneDefined" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="02b959a8-18b4-5ff3-99fa-9afc39fa001d" name="TestInvalidRuleLabelAccessesParameter" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9589f99c-65e1-99ac-6d56-aaa5dec3851b" name="TestArgsWithInitValues" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="32764a8a-d6c4-bfba-2ead-8c3713ef441a" name="TestRefToTextAttributeForCurrentTreeRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="42344a4f-3c30-756e-2912-40c9f5ddde13" name="TestWildcardCharLabelInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="501cc9a5-20a6-67a8-6dae-465d58479732" name="TestSetFullyQualifiedRefToCurrentRuleRetVal" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b92bc28d-6f55-3e82-054e-1f38bf6b05c4" name="TestLexerLabelRefs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="071e1203-843b-6978-5c54-8cb90349b995" name="TestRuleLabelOnTwoDifferentRulesTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3c1670f6-d3e5-65ba-5ed6-7b268e9c0344" name="TestIsolatedRefToRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="88e183a7-c08e-00f3-f306-3474fdd56241" name="TestGlobalScopeOutsideRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f9ea61f7-0801-7c5e-aa90-33520db332b6" name="TestMissingRuleAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="415ae124-09a5-f02d-ef51-562d0ea48ea1" name="TestTokenLabels" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="bb50eae8-7079-41c3-e1a7-a2625c08d8ca" name="TestUnqualifiedRuleScopeAccessInsideRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2e13a1d7-d63e-952e-a492-c0e352475dc2" name="TestReturnValueWithNumber" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4e7ef164-e577-468f-a709-c7832aee17bc" name="TestIsolatedGlobalScopeRef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d2437d58-2076-5447-c0c9-93ba480318e9" name="TestArgsOnToken" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="57cc9d2f-909b-9526-ed7e-223911fab3e6" name="TestReturnInitValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3577c3e8-4e05-6aa2-f111-d413b3610ccc" name="TestGenericsAsReturnValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d00b5122-5262-2af8-832c-7fd04eab7f68" name="TestRefToRuleRefInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f798f713-80e5-929c-d04e-421a95cd40d6" name="TestRuleRefWithDynamicScope" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f48c22e5-21eb-877a-2078-686fe3292a0a" name="TestImplicitTokenLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8235dcd5-5f80-cbf0-3ceb-906e170c657f" name="TestListAndRuleLabelTypeMismatch" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="439e8410-02af-bc19-8f0a-34fb91007a82" name="TestScopeAndAttributeWithUnderscore" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d0cd9f4a-fc0b-b9a5-426f-4ed068a864a4" name="TestReuseExistingLabelWithImplicitTokenLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2dc9064b-1819-f588-e797-412ae8dc1744" name="TestUnknownDynamicAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2c4ff356-df5f-e902-6160-f93431c211f5" name="TestInvalidArguments" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="93adf286-b2ff-6c3b-05b2-73f1527f23f2" name="TestEscapedLessThanInAction" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d3dbafcb-6603-d18c-068b-86b9d4341c87" name="TestAmbiguousTokenRef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="aa85bb67-f646-6bd1-8d33-4ef575b15aba" name="TestGenericsAsArgumentDefinition2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="12fe73fc-6cd2-4b41-14c2-3c930042319c" name="TestReuseExistingListLabelWithImplicitTokenLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="93900714-62fb-67fe-9abf-751959da6112" name="TestPlusEqualWildcardLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6ff630fe-471b-1536-7c65-c65a8c14521b" name="TestComplicatedArgParsing" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ff7cdb50-c091-ed77-5631-9fb1b049524c" name="TestGlobalAttributeScopeInit" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="403075fd-e2f6-5fb5-0db8-12fb103df443" name="TestFullyQualifiedRefToCurrentRuleParameter" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ca04a830-2849-8c36-ae47-7945a43d789d" name="TestImplicitRuleLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f1d6d129-9542-8ac7-fca4-a49614328fee" name="TestRefToTextAttributeForCurrentRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="92d6c8d9-19fb-e1d2-0e9a-1a2c4a0d160c" name="TestReuseExistingLabelWithImplicitRuleLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d801861a-966c-7b55-708a-da4421e15c8f" name="TestLabelOnRuleRefInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8d633a5a-a66f-9c28-d909-620d95fa116f" name="Test0IndexedGlobalScope" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="19b4f830-48ee-128b-47e7-a9dbc1b8ee9b" name="TestCharListLabelInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="170fee09-b6e2-d717-bddd-c20cf370eab7" name="TestArgsOnTokenInLexerRuleOfCombined" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="cf0f4b78-c082-ffaa-ec9e-cd278058d367" name="TestUnknownGlobalScope" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="06a62072-f79d-f7da-4543-e51dc69e6818" name="TestReturnValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b789995d-d9f4-787b-237a-b96408f3759a" name="TestGenericsAsArgumentDefinition" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a90706c5-a418-31f5-3289-71ed90b74729" name="TestRuleLabelBeforeRefToPredefinedAttr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6f0036a3-801a-47a1-ed05-2148cf86807b" name="TestBasicRuleScope" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="94671953-950e-6057-d6ca-42d4568f18e5" name="TestIndexedGlobalScope" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e440c54c-24d6-10e0-4914-99fd14465eb9" name="TestAbsoluteIndexedGlobalScope" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="687b7e58-1308-3df2-a761-5c496de428c2" name="TestUnqualifiedRuleScopeAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e458144a-1cd4-b609-39cf-bc71dc63c22b" name="TestAssignToTreeNodeAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="30632428-f8ed-ff94-b6ee-be4907458afd" name="TestTreeRuleStopAttributeIsInvalid" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4145dcb2-1e72-5269-2038-553cf11d4e04" name="TestRefToStartAttributeForCurrentRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d0eb02bf-8a18-4a18-75f3-d0143e33b657" name="TestTokenLabelFromMultipleAlts" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="fb75906b-6eae-4345-f005-c7f9160bf8bb" name="TestTypeOfGuardedAttributeRefIsCorrect" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5984ea78-5258-4396-45cf-9de6a0438c90" name="TestTokenLabelTreeProperty" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4f76d488-0dc9-d06a-bfee-c0eb470264fe" name="TestAmbiguousTokenRefWithProp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2387fd58-247a-89e7-e908-740cb550665a" name="TestIllegalAssignTokenRefAttr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a54a7df7-03d8-3b0b-9db3-14f9af6e7a44" name="TestRuleLabelOnTwoDifferentRulesAST" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a9c85478-1726-87f6-3699-c64d1273641d" name="TestFullyQualifiedRefToTemplateAttributeInCurrentRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ecef7e9e-3ea6-9a1b-c537-300019fa8232" name="TestIsolatedRefToCurrentRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="de7a8585-dac3-cbea-c27d-f52fd62b8936" name="TestStringArgParsing" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f23f8074-19f4-2ce9-135b-e2dbde060c5a" name="TestIsolatedDynamicRuleScopeRef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b1b17d2b-4cec-0cba-bb5c-4ac119f64f32" name="TestReturnValues" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0fdd88c8-32f0-f87d-c646-98fc24fe2e06" name="TestArguments" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0f1a1e1e-8dda-a034-784a-af3e2e13d0b3" name="TestWildcardCharListLabelInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f196fc11-403c-f100-630c-199c70c8c0f8" name="TestSharedGlobalScope" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6467a4bb-3343-6d53-2348-61e817b14504" name="TestDynamicRuleScopeRefInSubrule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="09561d11-434c-0454-26f5-8877f37309ab" name="TestDoNotTranslateScopeAttributeCompare" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3726c18b-3b07-8011-54d3-99603eeb64fc" name="TestRuleScopeFromAnotherRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4b4bd625-c500-46cb-70b5-8ee5c903c55f" name="TestInvalidReturnValues" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="22c04ecf-1d86-36c2-d288-6e4c8e08c8f5" name="TestIllegalAssignToOwnRulenameAttr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="297faa22-784f-2e4d-5657-161f78fc72e0" name="TestCStyleReturnInitValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="32f35b74-1fcd-91b1-91e4-978654a5cc56" name="TestPlusEqualSetLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6f5cd57d-757b-2aff-b33c-36d2cd828aef" name="TestRuleLabelsWithSpecialToken" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2ff25957-c8f7-a4b6-db86-c81009d43031" name="TestAssignToOwnParamAttr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5b8ece42-43cb-4456-dbd1-fde8f58f87a5" name="TestNonDynamicAttributeOutsideRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ebdec41f-9b6e-631a-5590-cb33e2700ca7" name="TestInvalidRuleAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ef5dc8eb-6c99-6d58-d548-d3162177350f" name="TestAmbiguRuleRef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="163cf22e-e7c8-be20-8575-6fdd63b9dbb4" name="TestSettingLexerRulePropertyRefs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="426cb08d-44a5-60b3-1811-671b2a4dc45a" name="TestMissingUnlabeledRuleAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6063c2ec-cf06-12e5-1ab1-d3e248b14ed5" name="TestArgWithLT" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6f1c4410-4091-c704-d42f-3e3719f4e95b" name="TestRuleRefWhenRuleHasScope" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f3405ac9-bfd6-ae54-7f59-dcede716344d" name="TestFullyQualifiedRefToCurrentRuleRetVal" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1aed0522-6482-f125-7074-2bca882b2de7" name="TestInvalidRuleLabelAccessesScopeAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7ea2e21d-e1a0-055d-2a5b-f94c0057a372" name="TestBasicGlobalScope" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0592d124-9e29-836d-19bd-d282742d9b2c" name="TestArgReturnValueMismatch" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b4c0f716-a25f-1e7b-4867-752bf5230a4b" name="TestMissingArgs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e95e6266-b1b1-6585-61fb-7f342ce3f3b0" name="TestIllegalAssignToLocalAttr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0e155c62-c572-76b5-0abb-b7454002dc1e" name="TestRuleAndTokenLabelTypeMismatch" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="79684b5b-11b6-3f30-3386-b4b05817bef2" name="TestRefToTemplateAttributeForCurrentRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7a58be1d-b12a-7e8f-8e6f-3759ede37f4f" name="TestReuseExistingListLabelWithImplicitRuleLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2aa3876d-2889-5c32-cb02-ebc25ab16b25" name="TestMissingArgsOnTokenInLexerRuleOfCombined" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d73b0cee-4949-b36f-e9ea-204c49cb2bdb" name="TestBracketArgParsing" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e262e6ec-d9d0-65db-e3e4-e346f822dcb4" name="TestNonDynamicAttributeOutsideRule2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1290c605-a473-a920-fd85-2fb8d6c2876b" name="TestReturnWithMultipleRuleRefs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ec5acc9a-d627-3288-68ea-6886ea91a37a" name="TestAssignToOwnRulenameAttr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="cf456791-5f92-c367-15e7-c3ad9ad4188b" name="TestEscaped_InAction" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2b00d705-3cb1-16d0-489d-c7f2e16dbfd7" name="TestRuleLabels" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="26bb51bd-fc10-0fca-7d56-5c85b89f8081" name="TestTokenRefTreeProperty" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c857c36f-1a60-9c75-86f3-439a0450c800" name="TestForwardRefRuleLabels" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3c3a2881-6266-014f-ad9b-e69ed26a964b" name="TestLexerRulePropertyRefs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="fd264423-da6e-9db0-8e09-1ffa2a21be2a" name="TestRefToRuleRefInLexerNoAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1e12aad5-76cd-51d9-8035-dc8bd61a0585" name="TestArgsOnTokenInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3d44d51f-83ba-cb2b-0b6f-81610a0ef5c1" name="TestMissingArgsInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="Semantic predicate evaluation" id="07d341dc-3861-4c94-9185-2e515634243d" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="b587d1bc-09b4-9f0c-717f-728bbf974613" name="TestLexerPredsInCyclicDFA2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2a146c5f-f7bb-97ab-62e5-b7540bc16024" name="TestLexerPredInExitBranch3" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="75f49c3d-ac26-a53d-d10d-9a583a857ca9" name="TestSimpleCyclicDFAWithPredicate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b85c501a-a2a6-b005-7271-0e91c9e1c17b" name="TestPredicatesWithGlobalScope3" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="52f856c1-fe9f-2150-93c8-757f4ccb25e7" name="TestLexerPredInExitBranch2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c5549531-096c-95d3-7b55-ba4e2b2fadba" name="TestLexerPredInExitBranch" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0447aa9c-3021-9a8d-f814-70d07c82f1fa" name="TestPredicatesWithGlobalScope" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a9b5b13c-69da-5420-f30a-e10654c6f457" name="TestLexerPredsInCyclicDFA" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0692dc79-4629-4552-e489-9d1a69f50596" name="TestPredWithActionTranslation" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="674a436a-c9ac-f31d-b0bd-f73481a7f049" name="TestLexerPredInExitBranch4" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="210e1340-3310-164f-d199-10fabd17adf4" name="TestPredicateValidation" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8ae07bff-91de-1296-2aca-b1c36807c774" name="TestGatedPred2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e4f5d560-1801-3edf-7527-b6371959cffa" name="TestSynpredLookahead" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6530af17-eae2-d962-c651-9c6cbd8a245c" name="TestGatedPred" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="361c113f-812d-c43b-27a4-6fba4e1a758b" name="TestLexerPreds" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e11ffef5-9044-7071-34f6-da1095ae108a" name="TestSimpleCyclicDFAWithInstanceVarPredicate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4b762312-7258-c7cd-9612-3fb08ab34df8" name="TestPredicatesWithGlobalScope2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="04c61ff2-0426-08ee-0ddb-0ce7237c01e6" name="TestLexerPreds2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8e297d7c-0ac7-d3c5-245a-b0a4ab2157ff" name="TestPredicatesOnEOTTarget" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="NFA construction" id="080e174f-fb4c-436a-b43b-b25c77a99b6e" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="34f73c15-4735-2347-c5d9-cf1640242481" name="TestSetsInCombinedGrammarSentToLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="fecbef7f-c983-da9b-d236-597a74a0780b" name="TestNakedAoptional" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e1acb3ac-fb7a-d0b2-b673-803d48006219" name="TestPredicatedAorB" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f009675f-ec9b-13c1-b049-e5365eeff9e6" name="TestLabeledNotBlockSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="877dfe12-839c-8a7b-9d90-9c80a060a2a5" name="TestNotSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2e55c117-7bcd-e87a-f402-f2d449bafee6" name="TestNotBlockSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="59cdbe3d-4a19-6259-1186-e2814f848121" name="TestAorBorEmptyPlus" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b0e9edb8-9570-f9ee-0a7a-d8f4627aa7a4" name="TestMultiplePredicates" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d0567f0b-dca7-7950-eae6-33dcd5a223e6" name="TestAutoBacktracking_PlusBlock1Alt" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="574bd454-9b7a-6716-c82d-9d16c852fa02" name="TestAutoBacktracking_ExistingPred" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8d5def1b-9e3c-6431-6051-cefa2ad6d77c" name="TestAB" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="baeb11ea-10f2-d7e1-a395-57432dc04e36" name="TestAutoBacktracking_OptionalBlock2Alts" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d307af66-dfe7-f16f-3599-a90288f2671d" name="TestAutoBacktracking_StarSetBlock" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="08736193-45c9-d2ef-0354-ab2482113485" name="TestAplus" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="564ff4c2-e2e2-a5f0-f153-22eb14201a07" name="TestAutoBacktracking_SetBlock" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e3806172-4ae1-a15a-0d18-1394af30fa29" name="TestAutoBacktracking_SimpleBlock" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="058775ef-860a-dec7-160d-aef4b0bd1b5c" name="TestAutoBacktracking_RuleBlock" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b39c2fcc-b2ab-2edc-15de-0554858359b9" name="TestRange" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c457595f-aa9f-c7b1-85ed-adc974eb0698" name="TestAorB" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e3d706db-c692-be41-908e-7786c5561ecf" name="TestCharSetInParser" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="732fc371-2def-9bf7-0d67-a2faf96026d0" name="TestNestedAstar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="23122115-4903-418e-58b4-20b0f4a7a35b" name="TestAplusNonGreedy" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="629888e3-14dc-63d2-db65-049554963757" name="TestNotSingletonBlockSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="02a5f6f7-4d74-5613-c89e-1f5344b65f0b" name="TestABorCD" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="eb7e5cd4-0898-65f2-93c1-45686873ac54" name="TestAutoBacktracking_PlusBlock" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a783ad7b-1406-bb50-9ca5-fde85744b070" name="TestbA" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8f49a597-ca67-246f-847f-a03aca09dbc5" name="TestLabeledNotCharSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="44a7cc90-d50b-f0ac-b9e3-cb6b4d995958" name="TestAutoBacktracking_OptionalBlock1Alt" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="730b2898-6a5c-b6c4-64b1-5dee9145a9ab" name="TestNotSetLoop" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8cae9029-0a01-53bb-f301-0a7ffb52c581" name="TestStarNestedInPlus" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9272cec1-3ea0-5511-6629-a1128cc3e73a" name="TestAorEpsilon" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="788312a0-b958-d829-36a8-6bea370b2b2e" name="TestNotBlockSetLoop" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="eb309e45-bc3c-4be7-f44f-ea2d7450bf3c" name="TestAutoBacktracking_PlusSetBlock" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="35fd1d6e-4e97-fe93-b507-962ae186f354" name="TestAorBthenC" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="92d31a32-a4b4-cbd8-5789-5cee666bdcdf" name="TestAStar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c225cb32-4c48-7fda-4902-b5cebe057410" name="TestNotCharSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="23fe1636-7ae0-f222-d0f6-ae198ba09dac" name="TestNakedAstar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="67c2b25e-d42a-6962-30ce-8675568012d5" name="TestAOptional" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="947103f7-a321-8187-5c97-d614ef4da663" name="TestbA_bC" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="15c60270-96dc-6095-9d0b-d861852bef4b" name="TestAorBstar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a4d59683-42e0-e9a2-7d0b-0e27d59a0c4f" name="TestPlusNestedInStar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9f07be14-74ff-c40c-e85f-fc4e604af5a5" name="TestSets" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f983279a-e57e-264b-f509-a39eb38173e3" name="TestRangeOrRange" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0be46363-c82c-40e8-9299-7d251dde742e" name="TestA" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0332e8b6-b801-1674-3518-486bdb3e9068" name="TestAutoBacktracking_StarSetBlock_IgnoresPreds" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="22c9d88e-4a9f-0b48-a32a-56004861134c" name="TestAutoBacktracking_StarBlock1Alt" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="93538649-4459-9b1a-498b-870ca68e8361" name="TestEscapedStringLiteral" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f09797bf-bc07-b6dc-c887-2228ed1c044d" name="TestEscapedCharLiteral" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="55a1e92a-a026-6773-5c57-3747d997409a" name="TestLabeledNotSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9b0a595a-c383-adea-199b-87ee3d81e5f4" name="TestNakedAplus" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="212ace24-eef8-12f4-cb23-7e721adce9ff" name="TestAorBplus" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b502480f-5d39-076f-0a7b-24553d260ba1" name="TestAutoBacktracking_StarBlock" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6d30bb07-65fa-7af5-919c-79050997d1b6" name="TestAorBOptionalSubrule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8683d0ed-4ca7-e535-bd00-7cac24cb94b2" name="TestAutoBacktracking_RuleSetBlock" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="Interval set" id="1b23ecf0-f2dd-483e-a626-2cc253d102a2" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="84ac057a-c148-ba85-b555-2b7f926ffb9d" name="TestComplement3" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="612fef56-57cd-7e3a-17ce-e3adccad0a8e" name="TestNotSetEdgeElement" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b61bf92e-b93e-2cfd-4c26-ddd8cf6e2f24" name="TestMergeWhereAdditionMergesTwoExistingIntervals" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="770cd3bf-e675-98ad-b884-598d02eda9ce" name="TestMergeOfRangesAndSingleValues" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="34fac6bd-71b4-6660-19f4-d42b0aa83ecd" name="TestSubtractOfCompletelyCoveredRange" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8b82ca3d-fdff-9a06-f51c-b78f92717e53" name="TestEquals" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9135c4a6-35ac-80f7-9f0d-0ca745718274" name="TestSize" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c53f3ea4-5a29-04f9-7e6d-0402f5331edb" name="TestSingleElement" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a9498367-d81a-2afe-6ad7-197284ab25db" name="TestEmptyIntersectionSingleElements" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b00fde23-04ff-9b63-bed8-d5fa36d87b53" name="TestNotSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="089a155f-a2e9-b7bd-cfcf-8cc736aacdaa" name="TestIntersectionWithTwoContainedElementsReversed" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3bd2b5a0-bae6-761e-0423-6bb39e3d972f" name="TestIntersectionWithTwoContainedElements" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="bdb17f9d-795e-c047-b18b-0486e522b72c" name="TestSubtractOfCompletelyContainedRange" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ced54110-32f0-9830-d2c5-72eea0b48d74" name="TestSimpleAnd" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7cd3974a-9c4a-9500-4ffb-14d10153338c" name="TestSubtractOfWackyRange" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b6c5c9d2-2a30-7f8f-16f9-3b423f107b52" name="TestComplement" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c4866417-906f-70ce-a18c-600fa01d8d33" name="TestIsolatedElements" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="17b95254-fa03-5537-7545-66b081675eb2" name="TestSubtractOfRangeSpanningMultipleRanges" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d4052d0c-88cc-4ae9-4007-6659d94752dc" name="TestNotSetFragmentedVocabulary" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="428928b6-3b85-6632-066b-a82edfe8ddcc" name="TestComplement2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a7e11c3a-b9be-0987-f4a2-b745e7f0ae5e" name="TestNotEqualSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7e59816f-6683-cbd7-c002-1b50dc019cc4" name="TestNotRIntersectionNotT" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3a357f71-820d-f52a-12ca-dedfe782472d" name="TestSingleElementMinusDisjointSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e0608145-ea2b-ba2f-e6ab-c04d498cb9e1" name="TestMergeWithDoubleOverlap" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d907a6bc-b977-f2f2-d3a0-5bd8a813540f" name="TestSubtractOfOverlappingRangeFromLeft" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1259d149-baeb-31a1-8878-bc1cd5d3e143" name="TestMergeOfRangesAndSingleValuesReverse" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6ade85c7-0650-f85d-1298-bbda9859090f" name="TestNotSingleElement" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f685c607-f43d-c45c-186c-f00aa5291023" name="TestRangeAndIsolatedElement" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b049948a-e1d8-e762-c6a8-5a36d2f15740" name="TestSimpleEquals" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8c4b83c3-e81d-99a9-55a0-92442277e2c4" name="TestSubtractOfOverlappingRangeFromRight" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a1b8a772-1d8a-0766-fd41-f5c3c18fafc3" name="TestMembership" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f233a225-7ee9-f08a-8ab3-a53b04adb172" name="TestMixedRangesAndElements" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="87fec540-8d12-d4c9-4543-a3e27248b249" name="TestToList" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="bad5f4f4-42d5-78e0-8c75-60d1ec57766b" name="TestEmptyIntersection" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="Java code generation" id="1d2d6741-19a6-4148-a0ab-04631362f521" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="709e302c-4ca7-0411-13ac-61b25bda2bbf" name="TestLabeledSetsInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="fc65f32a-f622-72ad-f549-8cf17f0a56cf" name="TestDoubleQuoteEscape" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d934d248-3574-78e8-fb54-8083f3b7a93b" name="TestLabeledWildcardInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="091f4249-a665-4130-275d-543bc3f57163" name="TestLabeledRangeInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="69b0864a-5797-d5be-eaed-7f463ab348d8" name="TestSynpredWithPlusLoop" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="40e3e3d6-03f3-1b59-1f40-b225ef1ba138" name="TestUserExceptionInParser" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="211151c1-c177-ed1b-3885-417966241af6" name="TestDupVarDefForPinchedState" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d91387b8-07ea-e9b6-7401-8c929cac5355" name="TestLabeledNotSetsInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="Templates" id="24fbf8dd-7c87-4dac-ab4d-7fbcb52b5177" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="c60bf111-c68e-a2f1-9208-f0ae4e3e80dd" name="TestTemplateConstructorNoArgs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4d529b0e-5db6-2938-e99b-37c648da4008" name="TestStringConstructor" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e7b1b494-7e99-665b-91a2-85f1d229b333" name="TestSetAttrOfExpr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4927cfc0-ddb7-1a2b-c48e-0a202dd3998f" name="TestSetAttrOfExprInMembers" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="743ad731-a1bd-a3d7-a376-8c0fed11cbda" name="TestCannotHaveSpaceBeforeDot" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="52a31340-61bc-d0b5-d6cf-9c180c85aaeb" name="TestCannotHaveSpaceAfterDot" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5ca410c6-8422-5401-81ab-2c7eb531ebce" name="TestSetAttr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e9f981b6-f7c6-d63c-8dc6-b6d46f3f7164" name="TestTemplateConstructor" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1420257e-df20-90c7-8863-110a9bb44f27" name="TestIndirectTemplateConstructor" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="Rewrite templates" id="2dbc20ec-9234-470e-a9b4-82226d3db427" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="623fe805-fbf3-d4f6-9fea-d4d52aeb8aa0" name="TestReturnValueWithTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e6942f33-23dd-e498-ea66-dfbe16277aa3" name="TestRewriteRuleAndRewriteModeRefRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="234c0529-728a-6e7a-8b57-23b84e095621" name="TestInlineTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="49c34b2d-c650-cf84-4a46-46aa84909ab1" name="TestAction" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="42cfabe2-038c-cc91-4528-d88cdbb15211" name="TestIndirectTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="feb0b08e-b559-a19d-a025-1997155c59c3" name="TestEmbeddedLiteralConstructor" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="fb1ac7d0-5bd7-a73c-58cb-7c94ef8609e6" name="TestTemplateRefToDynamicAttributes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9073725e-eaa1-03bb-bb16-011bcef3eb19" name="TestInlineTemplateInvokingLib" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="29ed83cf-5b19-288c-63b2-a63c0798ba41" name="TestDelete" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="952b1a29-30f3-d354-3880-a1b5ae71bcd7" name="TestTemplateReturn" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2ca8a0d6-5de8-e889-6f14-501af99fc18e" name="TestNamedTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2c74168c-9b98-c450-eae3-62a2e6d60d22" name="TestRewriteRuleAndRewriteModeOnSimpleElements" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="69738a9c-5205-8a78-5167-51895508b640" name="TestRewriteRuleAndRewriteModeIgnoreActionsPredicates" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2fc6ecf6-eb3e-7830-881b-3f6d1d05ad25" name="TestRewriteRuleAndRewriteModeNotSimple" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f6871b28-90a2-8ffa-2f7e-0f7f8b62a52e" name="TestSingleNode" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4c0c01f3-c97f-da8a-c792-144fcec2600c" name="TestSingleNodeRewriteMode" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="974c0f39-9999-aa1d-c24a-f5e9c5d29362" name="TestPredicatedAlts" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="DFA matching" id="3c885cce-ffa3-4ee4-baa8-8a9c03a14e0e" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="ce60fa3d-c350-a12f-5aa6-43189e37b763" name="TestSimpleLoops" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b18812a5-f955-9c33-6dce-4f85d055ca4a" name="TestSets" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="89888be8-82ff-a00d-96d6-51bd06a222e6" name="TestFiniteCommonLeftPrefixes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e4e8fa76-0075-26cc-d332-afc3babf7528" name="TestSimpleAltCharTest" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="Messages" id="3feb70ac-993d-4494-8e38-182e280ff9f1" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="8510a7f7-a3a3-0adc-49c2-b321d86206d2" name="TestMessageStringificationIsConsistent" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="Hetero AST" id="449a1f1e-8ee4-4c11-8653-061078124292" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="99f64a94-43fd-7928-f19a-a36588617d6f" name="TestStringRoot" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d8770320-df8a-7728-8444-591d80e028e3" name="TestTreeParserAutoHeteroAST" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="454eeacd-e4fd-96f1-f16c-4c7d72ea207a" name="TestTreeParserRewriteImaginaryFromReal" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b9e61931-d8f8-f079-8fba-de6a5847db45" name="TestRewriteString" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ea0bf81b-f6e7-84b0-a07c-5395d0d58610" name="TestTokenRoot" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4c1be00c-a512-3635-cabf-13a599429fa8" name="TestRewriteTokenWithArgs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="161e990e-1579-af29-066d-f71d2f19ccf5" name="TestTokenWithLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c7243313-5316-e1cc-04a0-7bd3ce60085d" name="TestTokenWithListLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="908ff205-5d05-5435-5ac0-ccf8bc2a36cf" name="TestCopySemanticsWithHetero" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a6564648-1b88-afb0-80ea-1be350a89538" name="TestTreeParserRewriteImaginaryWithArgs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1aa41df9-2441-1399-0cad-3f0ea6b2b801" name="TestTokenRootWithListLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1abaf7ba-8d56-44d5-4c20-24e9462648c6" name="TestRewriteTokenRoot" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2e215840-bbd9-aad5-ec58-a6ed0532a5c7" name="TestRewriteToken" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e337cc32-9b85-e188-9389-eed2c7875843" name="TestRewriteStringRoot" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="57fae555-de73-78d5-dcd1-a9338e9d6223" name="TestRewriteRuleResults" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="dc6e94b9-1ed0-556a-ec6e-d722c8e3ac47" name="TestTreeParserRewriteTree" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="df4a697e-7e88-98c5-9ae8-d3691b60e141" name="TestTreeParserRewriteImaginaryRoot" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7a3b1df4-b68e-ac9c-d345-3796bdb353f5" name="TestTreeParserRewriteImaginary" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e72697a3-db2b-87ab-0dcd-b03198819547" name="TestTokenWithQualifiedType" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f7f9db52-49f0-3750-3318-5fd80b158a00" name="TestToken" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c2509a22-1110-de73-d450-d3d2b69a903f" name="TestString" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3360a6af-7d0a-87dd-35e8-02091f03d140" name="TestTreeParserRewriteFlatList" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="DFA conversion" id="700cc8dd-23d3-4b5a-a523-d9fbf43ecde2" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="4678f76b-0eca-2cb7-3208-05a34196451b" name="TestAStarBOrAStarC" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ff009252-a909-8550-bb44-381b94f3eff9" name="TestComplement" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="10f173fa-6c37-47c1-3e35-35b7cf99b424" name="TestComplementChar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6e865920-f5b9-45bf-86c7-6b89dae57183" name="TestRecursionOverflow2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7689bc04-7779-600e-ba02-26af3ce74e54" name="TestAPlusNonGreedyWhenDeterministic" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="cf7252da-d535-307c-1c29-4de4c76a0943" name="TestMultipleSequenceCollision" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c7be9270-ee1f-6dfd-7b9d-e7589848ae10" name="TestSynPredResolvesRecursion3" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a8d76c4c-b202-657a-2a68-695dccf5860f" name="TestLoopbackAndExit" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0b225cb5-9685-9071-95ac-6c2cc2209bd5" name="TestAPlusNonGreedyWhenNonDeterministic" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1ef4f102-6799-5065-34bc-c7457bcebd8e" name="TestNoSetCollapseWithActions" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="489f609f-6d49-b4ce-784e-b3169c6078ad" name="TestTokenCallsAnotherOnLeftEdge" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="eb4ff09a-1787-8960-74fc-770879c96151" name="TestimmediateLeftRecursion" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5d3cf669-47dd-b2ed-aaac-f404b5f8f527" name="TestAStar_immediateTailRecursion" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8f470739-be69-7bfd-2ca0-356433834fc8" name="TestGatedSynPred" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ee436ac9-fc2b-22b4-846f-122533a0001a" name="TestifThenElse" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7703e98a-7f08-cce7-3ab6-4035547494d9" name="TestAorBorCStar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="701a2463-c022-694d-f6d5-fe40cec43e2e" name="TestRecursionOverflowWithPredOk2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7f8a3f66-a6a2-8865-c471-fcd4fcb3c8f2" name="TestIndirectIFThenElseStyleAmbig" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6f8bf21a-2bd2-b4e2-24f6-d1e08338c505" name="TestWildcardInTreeGrammar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6f97fafd-9e15-3815-ca83-2519640808b2" name="TestIndirectRecursionLoop3" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="dc0d9b39-fe8c-db28-5543-dc3c1bde9e62" name="TestInvokeRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1db72d67-94cc-75b4-a836-4187e08c526e" name="TestTailRecursionInvokedFromArbitraryLookaheadDecision" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d44fbd5b-128f-3f40-50ba-3abd32e2e38b" name="TestselfRecurseNonDet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4dd47e1f-663f-2e2f-fc1c-87a76ea37a56" name="TestAorBorCPlus" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0a925845-bf8d-519a-0cb8-9bc97323e8d1" name="TestRecursionOverflow" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="66878551-abda-b771-d584-486a15f0cb6f" name="TestCannotSeePastRecursion" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="79eeb074-0a28-2f1e-217f-9f2e5f591a3f" name="TestSynPredResolvesRecursion" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e8a2f59b-8f4c-a517-6d29-bc77a4f9c9fb" name="TestHoistedGatedSynPred" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="afe0c7ed-8849-a156-6221-104d90fd5cbd" name="TestWildcardInTreeGrammar2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="aa4f9903-4993-babe-cc63-73d07d6ede2d" name="TestAOptional" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5beeba3b-b5c2-3d9e-58d5-87c49488857d" name="TestRuleAltsSetCollapse" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="60205fa1-6256-3a2b-f714-7aad8a626967" name="TestSynPredResolvesRecursion4" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5c3aeff9-e1e0-bdcc-0734-9e7055d135e0" name="TestMultipleAltsSameSequenceCollision" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="44685767-9a93-6e81-3f42-ff7d91ac488f" name="TestAStar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e581affe-d7e5-47eb-da26-9a157d223eeb" name="TestAutoBacktrackResolvesRecursion" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="07b2dd25-5e1e-da34-67db-7f132bfa66b3" name="TestAorBorCOptional" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="28120725-1276-a6d9-a6e3-b16ec65fd318" name="TestAB_or_AC" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="69aeab9e-5d26-f785-e805-562ec73df1d4" name="TestAPlusGreedyWhenNonDeterministic" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="eddf4857-faf6-597c-8ede-709fb6488d18" name="TestCycleInsideRuleDoesNotForceInfiniteRecursion" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5011ac03-b4f9-0f2a-1a94-2543bdaa9066" name="TestIndirectLeftRecursion" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="46ceefad-be1e-171c-7b9f-e47d0e84c62d" name="TestResolveLL1ByChoosingFirst" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a5e14519-fd5f-797b-ad31-de6f8c7e78a0" name="TestAOrBPlusOrAPlus" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="59f52c78-5960-f222-f0e3-42d6c7a6d5ef" name="TestSynPredResolvesRecursion2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="98c0d731-d794-2eaa-a0d1-a993346c42c6" name="TestNoStartRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="23a6aad4-28d2-be53-eb00-c7c76b93e112" name="TestOptionalAltAndBypass" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d84835ea-a5d0-4e1b-bf71-a587239253f3" name="TestResolveLL2ByChoosingFirst" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="470182e5-ac58-5fdd-603e-5b30799489dc" name="TestWildcardPlusK1AndNonGreedyByDefaultInParser" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8928c090-a789-0cd3-792c-b830b4ad062b" name="TestCyclicTableCreation" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d03de438-4c68-b9b3-29ee-d5b0dded3f14" name="TestLeftRecursionInMultipleCycles" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2bb21a9c-5d10-1a29-8b4b-32393a753df7" name="TestComplementToken" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="52271c68-1f0f-277e-932f-1ea65dce0f4d" name="TestAutoBacktrackResolvesRecursionInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4ee0264d-a4d3-edcc-0180-fddf5ba4d087" name="TestFollowReturnsToLoopReenteringSameRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="75e1aaf6-0436-e38d-6afb-4f2c09cabfd4" name="TestSelfRecursionAmbigAlts" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="62e542c9-e845-77a4-9077-24431cfae7d3" name="TestAStarBOrAPlusC" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="edc367d6-7e85-b302-fafb-1a04828d3438" name="TestAStar_immediateTailRecursion2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="18f58e86-d1b6-84b1-f34b-aa712b4aab33" name="TestIndirectRecursionLoop" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ffb8afda-9f67-e647-91e3-7e494d42970b" name="TestTokensRuleAltsDoNotCollapse" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b001abc1-5a7e-24ae-58a4-036a1abbcd86" name="TestIndirectRecursionLoop2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="670aecae-cf5a-61cc-67f5-f69dbcf1ac4c" name="TestSemPredResolvesRecursion" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a1be4088-4c1f-dbd5-3069-8689b528e42a" name="TestAB_or_AC_k1" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c808ada3-7835-86cf-b1ff-180655b1407a" name="TestifThenElseChecksStackSuffixConflict" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8033fac3-3583-af76-afd4-1ff21810e9b5" name="TestComplementCharSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2a53561f-0627-67ec-9a09-4336347f893f" name="TestIndirectRecursionAmbigAlts" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="dfeb59c3-0e3e-be7e-6d66-1a67121d35b1" name="TestimmediateTailRecursion" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7281d05d-5871-4b28-c09f-e15f5def6822" name="TestAB_or_AC_k2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c8c2848e-6a66-1dc5-1fb7-1ebf6c6946fe" name="TestselfRecurseNonDet2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b706c966-9567-1ae2-a2b5-067c9300e7f8" name="TestSemPredResolvesRecursion2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a1f895b3-e4f8-36dc-4ad8-7e8b64260fab" name="TestWildcardStarK1AndNonGreedyByDefaultInParser" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8d546e55-ab80-de0a-5ba7-284ac94bfc66" name="TestDoubleInvokeRuleLeftEdge" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5a339518-66f8-acaa-843d-3c41981dedc5" name="TestSemPredResolvesRecursion3" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="311a27f5-cf3e-dec3-2d3e-e0b52a0623ab" name="TestSynPredResolvesRecursionInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c31ba203-5df6-30fd-8744-01de7f779e16" name="TestResolveLL2MixAlt" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a288dfa5-9edd-3588-56c3-8f3ccd693a3e" name="TestRecursionOverflowWithPredOk" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="dfed7aab-953a-e13f-d75f-11da8f5ae988" name="TestA" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="78ce57d6-0409-6556-6dab-48ab5f9e9d09" name="TestAPlus" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="Syntactic predicate evaluation" id="70dd9298-1df2-4244-97b6-099a0a976dee" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="2668f699-7db3-f5da-897b-ca91e954ea06" name="TestSimpleNestedPred" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="191068c9-68e3-3907-61bd-6b77aa75d056" name="TesTLexerPredCyclicPrediction2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="21b15468-9cdb-7964-b365-d1cf863b9a02" name="TestTwoPredsWithNakedAlt" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7335a946-9760-ad4f-aa58-12b22de9454b" name="TestTwoPredsWithNakedAltNotLast" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1877f13b-b30c-4d2b-00a2-4958240c1fa3" name="TestTripleNestedPredInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9db5706b-275b-43ca-89d8-242366521362" name="TestTreeParserWithNestedSynPred" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f2afe0e5-11fb-eea5-6e0a-dd9890de09df" name="TesTLexerPredCyclicPrediction" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="db080632-9bd2-3881-a950-f0944fd689ef" name="TestTreeParserWithSynPred" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e9ce064f-eec3-2061-b9b0-0c232434479a" name="TestSynPredWithOutputTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6b231544-7aee-91bf-bf1b-d479ed21d97d" name="TestSynPredWithOutputAST" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9166656c-3743-ee33-d181-d6a13c85ba2a" name="TesTLexerWithPredLongerThanAlt" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2f09e188-769e-a827-a99d-9de150df0cc6" name="TestSynPredKStar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3771eb49-3d83-41da-d994-39869928e49b" name="TestSynPredK2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="158ebd86-cab7-9e24-e863-d5f7415e3eed" name="TestOptionalBlockWithSynPred" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="56c5869e-f51e-102f-500f-0fbb899011bc" name="TesTLexerPred" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="Buffered Tree Node Stream" id="717ef273-fa6a-41e0-9bf9-b430f5cd4df1" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="0d016d3b-5e1c-e8fe-81b1-b703fa0816f8" name="Test4Nodes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3c80989b-7aae-8146-928c-c8ac2d7952ec" name="TestSingleNode" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8a29597d-42fe-2324-b708-a98fa021e45c" name="TestMarkRewindNested" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6a84ae9a-d7b7-ae2a-fddc-677844228ca1" name="TestListWithOneNode" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="67e12299-22cb-b842-0ca4-c0ddb7963034" name="TestMarkRewindEntire" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ead9ce20-35eb-e6b8-8397-666b78ca1bee" name="TestMarkRewindInMiddle" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="eea2b048-3613-0001-fc04-1a132d0a6bf8" name="TestSeekFromStart" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1f811c28-104f-e3ec-f4f9-d85d22204eee" name="TestFlatList" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="670869e5-2b78-077a-b790-a29b2db9d205" name="TestSeek" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c8bd4b35-518b-0c0e-3312-422f12e74733" name="TestLT" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a0098ad9-46a0-8339-bcc9-7fd0d7dd0baa" name="TestList" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="07073a3c-36a1-7ee5-65f3-18bbe29eb340" name="TestAoverB" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="AST Construction" id="764e067f-f13a-4639-a809-4201d71686df" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="42ee802c-bf3b-12f2-a9d3-51e97461b0fb" name="TestNotSetLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3cae375f-e1ab-1fe4-f003-5adb685b3867" name="TestSetLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="81eae235-afc8-8b1f-fcdb-4e726823a20f" name="TestRuleStar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9b41dd13-052f-2e59-e66f-821e0a452113" name="TestCharStar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2b5d7346-ba46-766b-9363-0d4aa8dab9c6" name="TestRuleLabelOfPositiveClosure" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0e5820f5-d9fd-6503-7860-3caa04ea4605" name="TestNakeRulePlusInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5e1130a2-0b90-5130-bf84-9e4a12b43920" name="TestCharRangePlus" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="58682bbb-2027-3cda-de52-a7195f8bd165" name="TestRuleListLabelOfPositiveClosure" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="210d3679-fe35-4ce6-4790-a3186022f53f" name="TestA" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="81702789-0dba-9df6-4dcb-60725817a807" name="TestLabelOfClosure" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="11a7e3be-a950-6b0a-b2d2-0eeb6bd021c8" name="TestLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="48e35718-ee20-2954-00e9-71051af24314" name="TestRuleOptional" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4186d952-8c16-f6ea-ba4c-eb865d02cd59" name="TestNakedRuleStar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2f246613-0273-b7b2-df7c-6c8f569742fe" name="TestCharOptional" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f0e07070-4297-fd26-1fd0-a6bb192efe36" name="TestNotSetListLabelInLoop" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d0333260-41c7-f0e5-2719-6297678d4f24" name="TestRulePlus" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="69c6ec4b-7bcf-cedb-7b3a-1f1f037ec466" name="TestListLabelOfClosure" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a3e2063f-a7f2-b40d-09c1-2412d9a9f873" name="TestCharPlus" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="66f3f55b-f2b5-08ba-87a3-d2191da398fb" name="TestNakedRuleOptional" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6dfa18b7-c918-f13c-66f5-d789d5d2d06a" name="TestActionInStarLoop" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="bc64f436-9a8e-9d79-d611-f2a5e06df976" name="TestRuleLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="cf0d0b24-62e0-fd5b-99cc-acc24fbd8206" name="TestNotSetListLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="131dcf10-fc5e-79c8-ac27-ef5201f765b4" name="TestRootTokenInStarLoop" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="03a27340-b660-a9f8-79ab-c4faf3ccc7ea" name="TestLabelOfOptional" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="30052d1c-0313-6b61-6ada-f31115ae96c1" name="TestStringStar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3605dee9-18d9-adba-a536-0772cf1cead0" name="TestCharPlusInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="93aa457d-701e-2bf3-f504-35452f10ea2e" name="TestListLabelOfClosure2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d3ed9255-494d-8019-c904-0cbea539e565" name="TestNakedRulePlus" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="00e6da85-cb77-14b7-fac3-c887eeb8a9a3" name="TestStringStarInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="eab39496-a93f-5868-5884-cacd540b7b46" name="TestCharOptionalInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f3d10a14-b02f-d5e1-90ae-ea41506d9c35" name="TestCharStarInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="Auto AST" id="7c25c66c-4f25-4791-9634-78cd087c2efb" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="f5082326-7318-c00c-5b82-cb0d5b27a963" name="TestMissingSetInSimpleDecl" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ce6de1c8-1a26-c905-ac3a-56d5147f7c86" name="TestWildcardRootWithLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ad7c7652-45ab-530b-0458-f84a7e0bb684" name="TestExtraTokenGivesErrorNode" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="764393ff-2bcc-f23e-8c8e-8facc000d061" name="TestRuleInvocationRuleRootInLoop" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ed41d735-fa80-5090-b9d3-1fbb91ca3def" name="TestInvokeRuleAsRootWithListLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a9b443e3-b5e5-1c6d-4004-32f732108bf0" name="TestWildcardRoot" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="cc84e1d3-17b9-6da1-59aa-feaa2b2fcfcd" name="TestRootThenRootInLoop" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c34634e0-28a3-bbbb-0ac1-4f795d1af669" name="TestTokenListInSingleAltBlock" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="bbd0dc3b-49d6-25ef-cffd-e8e19ed68fa5" name="TestSetRoot" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="656964b2-3362-ae67-96f6-657f46d332cd" name="TestLabeledStringRoot" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="08b3d7de-17c0-6cea-7c0f-46e51679da1b" name="TestSimpleRootAtOuterLevel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="72a3e526-4cc4-8b85-198a-aef1e815a22e" name="TestComplicatedMelange" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="bdfc3d9a-b08e-5815-8559-5ea59d2b8cde" name="TestWildcardRootWithListLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1aee168c-1913-d73a-ae8c-cfdd8ceb2977" name="TestNestedSubrule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a5fe0db2-a1a6-a58d-6ab7-9eee75bd97ad" name="TestNotSetRootWithLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="11de2e43-adc8-50e5-bdf5-79683ebdedbd" name="TestRuleListLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d3cb8dfa-79dd-6c4c-af63-c1b587df1142" name="TestRuleListLabelBang" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="de89ecb1-cb1d-6e64-c723-845f8fe97626" name="TestSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8fed95ba-4f7b-48e4-8800-6064dbf76dd2" name="TestNoViableAltGivesErrorNode" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="61ebbef9-bb19-0a74-c061-6ce7b8b186f3" name="TestTokenLabelReuse2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="326b679d-00b0-2ed9-7f2c-8d66bd83f440" name="TestTokenList" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4fed8429-1a2d-e06e-577d-48dce4c0afc9" name="TestNotSetRoot" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6ff27292-cb03-9f28-de12-6a5d86ae6684" name="TestNotSetWithListLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ff080183-87d0-31a4-b2e7-08f4ac6eb6df" name="TestMissingIDInSimpleDecl" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="98df9a67-7ec3-714f-0d31-85dc5aad8e2e" name="TestSimpleRootAtOuterLevelReverse" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b5c4c653-f04a-1ca0-3d2b-7cd3601839ba" name="TestInvokeRuleAsRootWithLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="83e2d559-3cbc-6f16-3b16-3e0ac558c8a5" name="TestBang" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a9aacd50-7e88-232e-1c45-c44edf15f5de" name="TestNotSetRootWithListLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="de602145-805c-0bd7-5f87-7ade2748deba" name="TestTokenListLabelRuleRoot" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f5c49295-2f78-f3d9-7eab-9adf00066de2" name="TestExtraTokenInSimpleDecl" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="98a47a70-e950-2178-8978-ec647578fce3" name="TestMissingTokenGivesErrorNodeInInvokedRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5b8c39c2-ed47-9d08-724f-de291648dd7e" name="TestInvokeRuleAsRoot" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="12b064aa-8a04-2c08-76b2-eddbd1c12a6d" name="TestSetRootWithLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f2fe9bef-7033-12cf-0f4c-0947ba7c6b44" name="TestReturnValueWithAST" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="68681f29-4579-04ec-b9cb-2933ce4eaae0" name="TestTokenListLabelBang" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8e31cfbc-32f5-9bc2-1b5d-a64fafaaf68c" name="TestTokenLabelReuse" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="21320fe4-2a4d-9be4-a148-42c00f40243e" name="TestRuleListLabelRuleRoot" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4ba378ff-8d06-63d9-4c32-ff2f8e57825e" name="TestWildcard" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="797ae1bb-0ba9-12e4-2a35-87ca6cb93822" name="TestTokenListLabelReuse2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1ac414c7-6264-77a0-d959-d8be8af41f8a" name="TestInvokeRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a59e35fb-c1d4-bc70-cc4f-52b2c5fa2b48" name="TestTailRecursion" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="bc2eeb00-03d7-6471-f877-401d687f1f28" name="TestMissingTokenGivesErrorNode" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d00dd20b-edf2-3635-51ec-6076e7ad292e" name="TestRootRoot2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6f7f47af-efcd-2e9e-7e79-c00eb47a172d" name="TestTokenListLabelReuse" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="33eb0f36-8e83-62fc-521d-2f90aca271e0" name="TestMissingFirstTokenGivesErrorNode" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="390e2008-b7a1-c510-6b05-39edb506cadd" name="TestRootRoot" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f8daca51-511f-bd94-d702-3abbcd87e501" name="TestNotSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9ba2b53e-0167-6c35-915d-7d876592b58c" name="TestRuleRootInLoop" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="55df11dd-61ff-6cef-4084-599cfd3efb23" name="TestNotSetRuleRootInLoop" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a9165fa5-549f-8d06-29ba-2a40978dae67" name="TestMissingFirstTokenGivesErrorNode2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="54f02648-688f-5134-44f7-89da655c308b" name="TestOptionalThenRoot" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="55f5e3ee-89ee-3887-fe9a-ec7991b2531a" name="TestWildcardBangWithListLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2b14ca66-370b-45b9-9a51-ae289f679874" name="TestNotSetWithLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="64a84594-d9f6-250b-1f34-50dfe6514259" name="TestSetLoop" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a0c4141a-eea4-5e7e-98dd-15fd84a9fd82" name="TestSetAsRuleRootInLoop" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="Lexer" id="7d50fd9f-8e61-4406-ad41-5191c259678f" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="4bcedd80-7e5f-f275-f866-6bc1e37e1d99" name="TestIsolatedEOTEdge" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f5084e66-75d5-b6d6-63e7-7308ad6f38a8" name="TestWeCanSetType" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9ddb92f6-5e35-fe77-89ce-dc3cb616aee2" name="TestSetText" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c957bce2-62e7-b4ba-fdcc-d0096ecdff80" name="TestRefToFragment" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="46aa4ddb-fea5-c463-116b-fd067aa6e85c" name="TestEscapedLiterals" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5d908711-02cd-fce9-6009-a9a386de50cb" name="TestListLabelInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="10a56f61-6861-6bbf-cb96-6586cb0b36a9" name="TestMultipleRefToFragment" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="bc10480e-b070-fed6-78aa-0dc4bd0e899b" name="TestRepeatedRuleLabelInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f98b42c0-87ee-497b-ad15-bb7ea2c66994" name="TestRepeatedLabelInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6bd56c35-13e5-d06c-c5f4-9ccc262cbf41" name="TestNewlineLiterals" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ea9e9121-0f8e-8991-d956-da8e283c4be7" name="TestRefToRuleDoesNotSetTokenNorEmitAnother" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="fbd31f79-64fd-9e25-b32d-3d893324551a" name="TestLabelInSubrule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ae8a7e68-5938-3cef-0dbd-a3ad56dedc3f" name="TestRefToRuleDoesNotSetChannel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="02629bb1-04d5-7a99-a4c2-6ae45dbfd6cf" name="TestCharLabelInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2585cf62-e879-c7b4-42dc-76c355b7eb04" name="TestDupListRefInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b25970d5-2ada-ab8b-956e-265a3695b54f" name="TestRefToTokenInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="Interpreted lexing" id="8863002f-5b85-4a70-b1bf-bf68c57c9fee" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="13f36ad3-33de-62d4-e805-f3ac6be93277" name="TestMultAltLoop" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f079e286-7caf-d291-0970-90989b4c10e7" name="TestSimpleLoops" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0474fe31-33bb-f20b-57e5-2c0b42a280b1" name="TestSimpleAltCharTest" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c6c70558-e52f-830f-120f-a4a212cebeee" name="TestSingleRuleRef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="96ccc26c-2e9e-60b5-4b8f-938d3464b0be" name="TestSimpleLoop" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="45a17a33-bf7d-e5ae-1604-62692232e033" name="TestTokensRules" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="Lists of Tests" id="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <RunConfiguration id="ffdb4029-8f84-4bbb-9829-cc1e67c5715e" name="AntlrTestConfig" storage="antlrtestconfig.testrunconfig" type="Microsoft.VisualStudio.TestTools.Common.TestRunConfiguration, Microsoft.VisualStudio.QualityTools.Common,   PublicKeyToken=b03f5f7f11d50a3a" />
+  </TestList>
+  <TestList name="Token rewrite stream" id="94e6f38e-08b6-447a-8730-ed245d8fed16" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="e22bf43e-c090-9175-e78e-778cdc7f23f1" name="TestReplaceMiddleIndex" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1cdb6ed9-b4d1-3832-6de0-d05ed66298d0" name="TestReplaceSubsetThenFetch" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="39d420bd-6703-58e6-9124-9a14fcf5a9a7" name="TestCombineInserts" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="45f60fb1-c843-6e9f-e24e-b1e37101dc63" name="TestLeaveAloneDisjointInsert" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7cee99fa-0d18-484c-d883-607f877fb7c9" name="TestReplaceRangeThenInsertAtRightEdge" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9bd3fe23-7ab0-e1d4-eb53-4b12249e3a48" name="Test2ReplaceMiddleIndex" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d15e0ea4-5989-7417-674f-6548e1cb0b0f" name="TestReplaceIndex0" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="91429e58-107e-a9db-31c9-a4c7ce25974c" name="TestOverlappingReplace2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ff50bc03-c56e-da79-068c-778caba4803f" name="Test2InsertBeforeAfterMiddleIndex" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6594c2b5-2f47-3efa-454d-3171807a8f8a" name="TestOverlappingReplace3" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="83a1420b-8ea6-8c39-62ba-3bc5d21c34fb" name="TestDropPrevCoveredInsert" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="df3790e1-acf0-fae8-dafb-f0d3d33b973b" name="TestCombineInsertOnLeftWithDelete" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5dd707cf-246f-728d-0afd-a5b2bdf3d5ae" name="TestLeaveAloneDisjointInsert2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8fb1ab67-da6c-6717-4786-3278a990fec6" name="TestCombine3Inserts" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0215450b-87b5-20c1-1d91-9fc2939bff32" name="TestToStringStartStop2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="adf6b564-cb34-a22e-a88b-938a1ce224be" name="TestReplaceRangeThenInsertAtLeftEdge" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="33880a5b-f866-e66b-a315-2ec51c53864b" name="TestReplaceThenDeleteMiddleIndex" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f383e78d-f701-d8d1-4d84-fbce6ae40d42" name="TestReplaceThenInsertBeforeLastIndex" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="302d4893-660a-dd12-e447-9235d249be04" name="TestInsertInPriorReplace" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b6e8c75b-9aad-7bd2-e5ee-46653ab5e2c9" name="TestReplaceThenInsertAfterLastIndex" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="044db98f-ee20-a701-a00d-498fe5fedc5c" name="TestReplaceThenReplaceSuperset" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="677dc0d5-e9db-02ad-42fd-74d436fc0fd8" name="TestCombineInsertOnLeftWithReplace" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="943d8236-f957-47ec-70b2-2ea8058c1292" name="TestDropIdenticalReplace" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b7cf787b-115a-8699-c933-31a38e6c91c1" name="TestReplaceRangeThenInsertAfterRightEdge" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7e4b7be5-9cb1-4c43-4774-c9ca0583531d" name="TestOverlappingReplace" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5b0e61c7-b963-f818-e1d4-3db6281e109c" name="Test2ReplaceMiddleIndex1InsertBefore" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e2efdb18-9782-f299-de07-f27a3d80ae40" name="TestReplaceThenReplaceLowerIndexedSuperset" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9480275e-433d-d326-f9de-99ee519011ef" name="TestInsertThenReplaceSameIndex" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2b8ae639-6713-0b7f-fb3b-b7ce8093b6be" name="TestToStringStartStop" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0a4a6aa8-5b54-561a-b906-e0e6fb521ea8" name="Test2InsertThenReplaceIndex0" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e04eeae3-fe2e-7a7f-8dc4-0663a67acf62" name="TestReplaceAll" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c0fcb8db-ff62-386b-547e-0bc5db32e32c" name="TestReplaceSingleMiddleThenOverlappingSuperset" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c6f03e2e-e6f2-0942-afb0-d0e2a036454f" name="Test2InsertMiddleIndex" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b1c0c59c-f5c6-3866-d5bc-b90ee79b3d6c" name="TestReplaceLastIndex" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2add5f23-928d-46bb-7248-e17fed0b1a84" name="TestInsertThenReplaceLastIndex" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b0c67250-30fb-f7e6-df28-d6526bb68e26" name="TestOverlappingReplace4" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1551b702-140f-35bd-0d56-fc7d7a254228" name="TestDisjointInserts" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="cf90ed88-7491-1f73-3b5d-ec1cafdfd880" name="TestInsertBeforeIndex0" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1c7cad7b-74c8-d951-b38c-cac8100a4b96" name="TestInsertAfterLastIndex" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="Composite grammars" id="97360533-ccdc-4595-85bd-cc148ff2edac" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="6e9d5c2c-7dd8-5ab8-b459-65e5104746ae" name="TestCombinedImportsCombined" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d0682c80-5f55-3b94-d06d-8320a7de1fd7" name="TestImportedTokenVocabWorksInRoot" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ed06e8a9-f390-8d48-f132-4a9590891d07" name="TestSyntaxErrorsInImportsNotThrownOut" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8ad9a872-f0c2-a6c6-ccd6-06d6707915db" name="TestSyntaxErrorsInImportsNotThrownOut2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6ab05b4c-8f93-245d-0c11-47bbdd0dd367" name="TestLexerDelegatorRuleOverridesDelegate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ad947ca1-6eb1-15e3-78ba-925d2cb6aede" name="TestSyntacticPredicateRulesAreNotInherited" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e3f344aa-e045-42d0-1fc4-070d19a3e181" name="TestWildcardStillWorks" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c4b95c63-242d-24c4-adb4-be7a255fa8a0" name="TestDelegatesSeeSameTokenType2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0676d9e0-ffcd-2e3a-7790-9d7e0f230c93" name="TestDelegatorInvokesFirstVersionOfDelegateRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="bbb71a38-26c0-44eb-036b-b98258c0612a" name="TestDelegatorRuleOverridesDelegate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="259bb193-8e92-4768-b0c8-6a242308abbe" name="TestWarningForUndefinedToken" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0e1a5f62-e1ac-1311-2886-5abf9f331d72" name="TestDelegatorRuleOverridesLookaheadInDelegate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="072dcd79-2f55-7f6b-e345-d0f969306fb6" name="TestImportedTokenVocabIgnoredWithWarning" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1ba0cf6c-e0ec-3fa0-905f-56cc2fc459f1" name="TestLexerDelegatorInvokesDelegateRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9a64ceb8-6f58-8bac-4864-c8417db468f1" name="TestRulesVisibleThroughMultilevelImport" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="87ee5593-3b21-0b5a-3dc0-fefd37df0dfa" name="TestDelegatorInvokesDelegateRuleWithReturnStruct" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="64cad709-25f2-9292-9809-887ad4b68141" name="TestInvalidImportMechanism" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8a23848b-6909-e708-f9b1-8b9dd8b3de7b" name="TestDelegatorInvokesDelegateRuleWithArgs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="df94ec3c-ed68-c1e9-77d7-c1ef39336e68" name="TestDelegatesSeeSameTokenType" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1509cad4-f64c-3374-e0c6-15dbf193990f" name="TestDelegatorAccessesDelegateMembers" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="381bf3c6-c4d2-243a-055e-23fd8fcfe591" name="TestKeywordVSIDGivesNoWarning" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="de8190c6-8ae0-bb32-c9f4-1d6eff755c3a" name="TestSameStringTwoNames" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a62ee3d7-653a-f618-edd4-c5e7327a0804" name="Test3LevelImport" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d1de139d-16b0-2127-f6ee-ffb79ed0c9a9" name="TestBigTreeOfImports" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2e2b2b8f-deee-b4f2-f845-d177f4689e01" name="TestLexerDelegatorRuleOverridesDelegateLeavingNoRules" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ae6c1866-8adb-25eb-3d0d-0c5225c92a3c" name="TestSameNameTwoStrings" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="634a1109-c072-4c05-aeb6-fd3458e3e202" name="TestDelegatorInvokesDelegateRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="Symbol definitions" id="a1b187ef-bf1e-415e-96b9-6ae2d0ac2945" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="0af33246-8dc3-44dd-8016-12b9e12ff183" name="TestCombinedGrammarWithRefToLiteralButNoTokenIDRef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7cb5cd15-b69c-ea52-e582-eb816d2ed269" name="TestLabelAndArgConflict" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="eeacd404-6039-0620-2ed1-3184389e64a9" name="TestCombinedGrammarLiterals" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="aac0539b-c21d-dc0d-0028-7f22bbada79a" name="TestRuleLabelScopeConflict" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="75dc7fd1-b0d9-7623-0dfe-5fd4be0f3f65" name="TestTokenVocabStringUsedInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="647f6c85-7af2-b058-64f3-511bb12effce" name="TestUndefinedTokenOkInParser" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b95575d5-de99-2a80-5b9c-5c4f2888e63e" name="TestLabelAndTokenNameConflict" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8d9c8aef-af15-3986-cf9f-a2884ccacc1c" name="TestEmptyNotSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1995e60e-dd3c-a17b-4405-c01d06b96968" name="TestEmptyNotToken" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="87ad1257-ca09-73d6-30f0-cb08f647b691" name="TestLabelRuleScopeConflict" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="88a39e71-5792-001b-f90e-f314e2c0876c" name="TestSimplePlusEqualLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8ba50eef-5b22-c625-382e-e074c76a93b0" name="TestParserCharLiteralWithEscape" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5791e1c5-698e-f671-c6f5-417412819082" name="TestRuleRedefinition" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f2ea7651-7b5d-9385-80bf-05347d449a66" name="TestTokenScopeConflict" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="faa68846-742a-bcc2-b3f2-dda8c648a4ed" name="TestTokenInTokensSectionAndTokenRuleDef2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4c69f589-7b40-8d67-825e-2fb43a942cce" name="TestTokenVocabStringUsedInCombined" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e13c8c6f-18d5-e0f5-0634-99882beeb548" name="TestTokenLabelScopeConflict" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5410ed41-76ff-defe-4d60-90958a97cef6" name="TestRuleScopeArgConflict" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6e78c6fd-e2e5-a048-b42c-79b0fc4faa0c" name="TestParserRuleInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="59e29067-420a-ebfb-89e5-6219f07bebc2" name="TestUndefinedToken" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7a2df488-436b-c11b-25da-c5c0a7624938" name="TestEmptyNotChar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8fb83455-277a-dcab-e32e-0d1849746d46" name="TestLiteralInParserAndLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="fa825d5a-4a89-a938-ab34-2896da07f6c0" name="TestStringLiteralInParserTokensSection" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="df34efc4-ac05-3d4c-49fa-9633012ab94a" name="TestBadRuleOption" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0ac0eccd-c4ac-5b39-ab3c-f8b29e69acb0" name="TestSetDoesNotMissTokenAliases" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b72664b2-3a7a-ef85-d8d8-f87bb82e1bd4" name="TestMixedPlusEqualLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8d2b174c-169a-0660-91fd-b9d6eab2a43d" name="TestLabelAndRuleNameConflict" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7e0a141e-b875-36f8-79f8-a59e41075b29" name="TestTokensSectionWithAssignmentSection" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4280bd92-a2c1-6a5c-5b34-836082449079" name="TestParserTokensSection" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="44dce9c3-486f-326a-2da5-fb2584465e5d" name="TestParserSimpleTokens" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="84cab8d4-2b2d-40d9-fc30-294eb4526487" name="TestCombinedRuleRedefinition" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c71d2dc5-c764-2d1b-8806-a5e27890014e" name="TestParserCharLiterals" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f8a08661-4130-e87a-b7bb-dae72c3be657" name="TestBadSubRuleOption" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="59b7c130-1e40-0708-1d6d-749974019a03" name="TestLexerRuleInParser" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a1a1e587-f1f3-0f6b-f067-ef932935581a" name="TestCharLiteralInLexerTokensSection" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b3b81f14-6a28-0c6d-ecef-98ed5d1e08cf" name="TestRefToRuleWithNoReturnValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="64c45b92-8a47-3d0d-a846-70509724ca6d" name="TestRuleScopeRuleNameConflict" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="09d6e351-197c-7238-555f-c2bf49260279" name="TestBadGrammarOption" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="30e3b11f-1da5-6425-84b7-9e2a5021e2a4" name="TestRuleScopeConflict" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b56c722a-178d-1e0d-472e-852d289a513a" name="TestRuleScopeReturnValueConflict" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="25715de6-c008-08d5-0ce4-ae641f6bd5d7" name="TestTokenInTokensSectionAndTokenRuleDef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c0ea8642-0d28-e98f-7160-2713661b84c7" name="TestCharLiteralInParserTokensSection" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="335f70e1-1bde-22b2-9b11-69cc8c0f2412" name="TestUndefinedRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1d3389d5-7121-5284-75cf-36584b94d25f" name="TestLabelAndParameterConflict" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b938d16d-b6aa-b5e9-f489-445152d85a10" name="TestLexerTokensSection" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1d6fed64-ca66-36ae-64b6-17c00b6d3f01" name="TestParserStringLiterals" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="594ff8ed-c425-5198-0de9-d3349596d82d" name="TestTokenRuleScopeConflict" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f32df87f-bb8c-d7be-97e1-d055997d2193" name="TestTokenRuleScopeConflictInLexerGrammar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="fc81d99d-fce2-aade-e97c-3b5713041806" name="TestLexerRuleRedefinition" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="Char DFA conversion" id="a5edd101-e97e-4629-90b7-10d1107f3625" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="39cef987-8ab8-8b8a-44db-775896423051" name="TestNonGreedyWildcardPlus" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="bee6b7ed-7f24-8f24-d9e3-cdb29d1aebaa" name="TestAdjacentNotCharLoops" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="69ad0dec-4c28-397f-c092-80124d776df5" name="TestDisjointSetCollidingWithTwoRangesCharsFirst" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e5e12a7f-5d78-d660-5ddd-ce7d6c78e1c7" name="TestSimpleRangeVersusChar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8c5603ce-b204-76b5-9e4a-13f1e85be28f" name="TestNonGreedyByDefaultWildcardStar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5309eae3-d92c-9b86-4ec7-e5850cd6da24" name="TestNonGreedyWildcardStar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ff44422c-b919-fd23-61d2-8a1020aeeed9" name="TestNotSetWithRuleInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d736f2ca-339f-7739-dccb-fecb79cd53b7" name="TestNotSetFragmentInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="cb0a0a42-7aa3-a873-b4e4-cb24304fd2ba" name="TestNotTokenInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f065ab64-412d-2c47-da48-5dd0da750c2b" name="TestNotFragmentInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6e823067-79cf-45cb-2a54-29d37e73ab96" name="TestNonAdjacentNotCharLoops" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="20ed6c03-5998-2188-b3d0-65f3531fbb4d" name="TestDisjointSetCollidingWithTwoRanges" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5c3b7ac1-97bd-aed1-4dd5-f97119c47101" name="TestDisjointSetCollidingWithTwoRangesAsSeparateAlts" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ce926da4-9d6d-850d-f921-eaf3c6240535" name="TestKeywordVersusID" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="46c6d92d-d83f-6297-2da9-c8156c9893e0" name="TestRecursive" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="af3a1e76-f351-4bbf-beb3-1de53e79d298" name="TestAltConflictsWithLoopThenExit" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="714d1a46-ceef-49ff-30ca-116177b971d4" name="TestNonGreedyByDefaultWildcardPlusWithParens" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ace79932-a099-ef05-0422-c9851e900673" name="TestRangeWithDisjointSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d7a11322-b775-696f-a424-9d5c0f2f7eba" name="TestNonGreedy" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a8127e05-3b3b-fd7c-3a02-ad7b6330b338" name="TestSynPredInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="81c29b70-e3ca-26f0-584d-8874fbe16b17" name="TestRecursive2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b077ff73-889c-c188-7d46-64fd8118fff4" name="TestSetCallsRuleWithNot" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9a8336ff-a90c-7a8b-d64b-199a27b522a8" name="TestLoopsWithOptimizedOutExitBranches" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e2b382a9-ee95-8f04-1ba8-98ce733e0b0c" name="TestNonWildcardEOTMakesItWorkWithoutNonGreedyOption" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c7498de1-197f-58f4-db3b-395dcb7da6f2" name="TestNonWildcardNonGreedy" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0e192582-e307-a73b-5e39-16c233964ed5" name="TestIdenticalRules" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="404c9a53-2d72-d19c-7a4c-57a6a2a80aa1" name="TestNonGreedyByDefaultWildcardPlus" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a4ac2795-09c2-c790-8063-c261222526f5" name="TestNotComplicatedSetRuleInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a22418bd-d9c9-ceee-7522-d31a7565b1eb" name="TestNonGreedyLoopThatNeverLoops" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="Rewrite AST" id="b537d8a4-a63f-42fc-bd02-ac25d6cfc7ae" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="671e4bfb-7176-500f-9919-7b15ad226608" name="TestPositiveClosureSingleRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0bc04928-13d1-d054-15b1-efcc815e5239" name="TestOptional2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e9e8726d-7437-a7fe-dee5-5028b747e72b" name="TestOptionalSingleToken" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="063b66d3-bbe6-816c-ca21-f045061dc6da" name="TestRuleListLabel2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1c070661-24f7-9839-dbad-620da159548e" name="TestSingleRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9c9cb44e-79ed-1317-45d4-ccbf1dd3ca4a" name="TestImaginaryTokenCopy" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="722f12e2-c2f9-89b1-64ae-65cc41ea84e7" name="TestTokenUnreferencedOnLeftButDefined" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="476ec1fa-abd5-1bcf-7ca7-8cb0ae0ad144" name="TestRewriteAction" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e1bc2675-558f-15a4-1be1-eed1f23cca02" name="TestCardinality" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b312a247-3291-840a-5edf-af3a27b50a73" name="TestSubruleWithRewrite2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="feca4f95-f56d-b4fd-e8a6-df606faa178d" name="TestExtraTokenInSimpleDecl" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3e76c486-0907-4e8a-ecb5-bba2a14ea1bd" name="TestUnknownToken" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="857ddd22-57ce-6e66-a077-faec7497852c" name="TestClosureSingleToken" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1b5ede6f-fd98-d547-9498-530cb8789300" name="TestTokenTreeAfterOtherStuff" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9d875b70-6d92-30da-f395-2185d8fd19ea" name="TestCardinality2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7d8a8034-db5e-3c3d-d891-7afb094d6fe5" name="TestTokenCopyInLoopAgainstTwoOthers" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5b66003c-a6fd-740b-a059-e95cc89929f5" name="TestLoopCardinality" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="dcf0952c-4ae0-13b6-533c-5ce0bf5a9cee" name="TestClosureSingleRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f5e5d4c7-c1ed-a819-0889-4c638a68b17c" name="TestUnknownCharLiteralToken" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="82895fda-ce95-f456-bc20-febc1cba80a7" name="TestReorderTokenAndRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3fe4cff9-1097-6e87-2b18-11535b7b851f" name="TestImaginaryTokenNoCopyFromToken" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="57ca6532-1e01-4c43-2aea-d17c0a6de645" name="TestTokenCopyInLoop" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="fef84f23-80b2-c36a-abd6-55f7fc782ab1" name="TestCopySemanticsForRules4" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8f45812a-b8ef-e89e-7ef0-3180b747316a" name="TestSetWithLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a0b06a29-11ee-01bd-4521-68afa6ba9053" name="TestCardinality3" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="96d93b0b-a18d-4b4b-a40e-5eb31f9240b5" name="TestSinglePredicateF" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="17748ed9-358e-3c48-2069-99ad841a4c29" name="TestNestedTrees" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c64d1653-ecfa-5be1-29b1-69278b94f8ea" name="TestCopySemanticsForRules3Double" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7eba73a2-cc5d-0d49-72ae-bb4eef62b703" name="TestListRefdOneAtATime" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="df5542cf-f175-b941-7175-552bf4f927b4" name="TestOptional3" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="febb1349-4131-2580-7d97-b8603c900029" name="TestOptionalSubruleWithoutRealElements" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a2f966c3-f3d1-f430-3314-90b6578b6231" name="TestAmbiguousRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="105369e8-5fc8-08ac-2f23-a640719ef508" name="TestSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9cdaa9a3-9226-fce1-7d8c-c381f3d1c5de" name="TestSingleCharLiteral" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a4357a79-e7d6-4eb8-977c-1066dd285f7d" name="TestSingleToken" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="aed2a586-4776-e59a-b61f-38bcdea6d09e" name="TestSimpleTree" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6f15726e-a357-db41-c91d-e1a21f20171c" name="TestSimpleTree2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5d5f825a-f3d7-225b-a4f0-b85d524724e9" name="TestCopySemanticsForRules2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="acf088eb-6a12-9008-1514-b8816224c1c6" name="TestImaginaryTokenNoCopyFromTokenSetText" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1d7b5fc6-f7bc-df5a-20b2-0cc98c542a6a" name="TestCopyRuleLabel2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2c3d5793-71f1-7b39-ec64-bf2291fb3ca2" name="TestSinglePredicateT" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="572e4233-f335-1071-afce-2306aa33bf4b" name="TestOptional5" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e4f349cd-226c-3554-4210-3f511597794b" name="TestMultiplePredicateTrees" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="46ce5be4-0348-894a-ff95-a328886fd613" name="TestUnknownStringLiteralToken" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1133e237-1b8e-8606-745c-7e36e14fd482" name="TestOptionalSingleRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="806158af-06bb-0d28-b2bf-6c149877f69b" name="TestMissingSetInSimpleDecl" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0f15a718-3179-1a09-32e2-c5bb4bb0640f" name="TestSet2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="198e2211-9e6a-2f17-0d6e-a6bbd90fffef" name="TestSubruleWithRewrite" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="72e97114-1bce-1d9a-3901-19383c55f673" name="TestRuleLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7ffe2a03-63a4-7994-8c19-7c9af9e9e0b3" name="TestDelete" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ba5a442a-e396-9687-3865-aa18e8064cfc" name="TestMissingFirstTokenGivesErrorNode" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="216faac4-0f82-c904-ab63-3f42f023ceac" name="TestCopySemanticsLists" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="aacc17d7-308c-451d-24de-e4cdfad18ba8" name="TestSplitListWithLabels" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ee4649ce-bf2d-68db-270f-45a71dccc4b2" name="TestSingleStringLiteral" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7d6dc7bb-9004-b704-f205-2cf1c76fecd8" name="TestWildcard" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ab8aaf90-e024-d554-9ff3-73d61030a409" name="TestArbitraryExprType" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2d6359d3-2e2a-f555-7566-314ac105ccdb" name="TestCopyRuleLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="44b52f53-4a25-28e8-2557-adaec431275d" name="TestPositiveClosureSingleToken" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f150f22b-e714-d2f0-142f-0b71fd2c6d50" name="TestImaginaryTokenCopySetText" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8500293f-e267-686d-8c38-6996400d1eda" name="TestUnknownRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ade10af2-759e-67fd-0acc-1896442fcdf7" name="TestMixedRewriteAndAutoAST" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="fddab8c2-484f-c47d-c2fb-0b4b1567501f" name="TestExtraTokenGivesErrorNode" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="654f1794-0b29-a0bd-4d64-17b02a37d0bb" name="TestNestedTokenTreeWithOuterLoop" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f4e0e1a7-ed1f-2f16-63e2-d09a99d49cc5" name="TestOptional" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="88521875-d40a-be46-8b3a-0119332f40b0" name="TestMultiplePredicate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c530bd38-c797-5ecd-a349-783050b61187" name="TestSingleTokenToNewNodeRoot" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6d45d762-aeb3-96b0-002f-fb9b59c5532e" name="TestMissingIDInSimpleDecl" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0cefdbe3-6105-dde6-a3ba-987c659fcf8e" name="TestSingleTokenToNewNode" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4d4c0ea7-2d9b-530d-db7f-e5e8231f07be" name="TestOptionalLabelNoListLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4c2e5062-505a-47b2-0700-b0a4b992122b" name="TestMissingTokenGivesErrorNode" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="fec81790-374d-e51b-a4eb-65e0a4313f2d" name="TestNoViableAltGivesErrorNode" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="533455fa-98f8-7f28-c444-76c256e09483" name="TestClosureOfLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d2965c40-556a-3072-aea4-d2c3639590b7" name="TestMissingFirstTokenGivesErrorNode2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ae6c450f-f718-a92b-37c1-e58e8842a7a2" name="TestRewriteActions" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="44322f85-6ecd-44a8-6751-ef3230bb554f" name="TestCopySemanticsForRules" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="39069f5d-9976-c2ba-f4be-be080c2f6756" name="TestComplicatedMelange" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="62f016da-54cc-65bc-ca8c-b3f31f8694f1" name="TestCopySemanticsForRules3" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="42de20fe-25fc-a6e1-f684-df0a24639f06" name="TestUnknownLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f11cfef9-a58e-b143-6622-d5c40769ab8f" name="TestRefToOldValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e0ac3e59-5b4d-a0e0-48e0-a4b7471b7851" name="TestTokenTree" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4ca90232-5601-42f6-040d-58e08b395818" name="TestSingleTokenToNewNode2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0321667a-a58b-db7c-8851-1cbf357302e3" name="TestNestedRewriteShutsOffAutoAST" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9eb111d5-befc-557b-a029-12ae5af5f5d1" name="TestKnownRuleButNotInLHS" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="74af9fea-3e9c-1448-3e3f-a91c7436b6f7" name="TestCopyOfTokens" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="96ec71cd-5bbc-d917-ddeb-c1271ea2a8d3" name="TestOptional4" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f7b0381d-867f-76d2-4b03-ede361cc24ca" name="TestRuleListLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="368b6d6b-fea0-d43f-b3ff-34483d088dcb" name="TestReorderTokens" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0c0490e7-79ea-05f5-fcdd-62532b6948a0" name="TestQueueingOfTokens" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3238964a-c7ea-e3fa-e811-525a14562835" name="TestWeirdRuleRef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8afa5764-c131-e06e-fc61-e9598c884ae5" name="TestRewriteActions2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="Tree grammar rewrite AST" id="c07b8a15-6914-4452-992f-7741e4abfb96" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="f05c18d4-eba7-a63c-7f47-5ef3f36e22a9" name="TestRewriteModeChainRuleTree" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="dfe5ae59-d631-0267-c563-bebfbe07b801" name="TestAutoWildcard" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="aa7ef264-f8cd-33bb-54b0-a597f909e1cd" name="TestAutoWildcardWithListLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0b32ec58-c83a-b52f-e87a-716bf7534938" name="TestRewriteOfRuleRefRootLabeled" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2961f91d-b978-3af6-b6f9-b8059a6b56a1" name="TestAutoDupTreeWithListLabels" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="bc5337f4-fb93-8bef-c68e-31379041b9aa" name="TestWildcardSingleNode" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c08156e0-15df-c11a-933b-20ddd8aae279" name="TestWildcardGrabsSubtree" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5a8f4051-d6fc-32ed-6030-7c586f964648" name="TestAutoWildcardWithLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="def84127-f797-e07c-895b-0783e7720c11" name="TestRewriteModeCombinedRewriteAndAuto" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b066248a-6384-48ae-c7eb-55a23c9faaae" name="TestAutoDupTreeWithLabels" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="34470844-882f-fd8c-3f05-c3b2f2e6a4de" name="TestAutoDupTree" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="24c16cad-876b-f1f7-c389-d1776ebd420e" name="TestAutoDupTreeWithSubruleInside" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="56737319-ceef-6c4f-8cdb-bc75fd475a86" name="TestDelete" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="38786531-fd5e-c5f4-784c-0ead4a91b24d" name="TestSetOptionalMatchNoRewrite" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5308540a-9f53-50f6-2700-cf04744bc96a" name="TestRewriteModeChainRuleTree2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a3a10277-f576-6aa2-a542-4c248eb67dcc" name="TestCombinedRewriteAndAuto" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a08f0ecf-5075-1f5f-cf43-bfc058972c77" name="TestAutoDupRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="19e99140-2e77-373a-ec43-2752220e4e1a" name="TestWildcardUnlabeledSingleNode" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="724b1eb7-2b63-ef93-5e09-07a91d26cebf" name="TestLoop" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b15326b1-6591-4f3f-6e28-ee73d94955eb" name="TestRewriteOfRuleRef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7bcc0760-ed78-d3f0-6858-7c3c840a26d6" name="TestRewriteModeChainRuleTree4" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="70cc366b-9c92-c180-2684-fb9de483290f" name="TestAutoWildcard2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="515d7169-66c7-90c9-a087-a5c2440c9cd0" name="TestAutoDup" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="52be505f-42c4-7f06-8b6d-43d7d6a7c1cc" name="TestNoWildcardAsRootError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f18fa4a6-f52a-28e2-9cdd-e99a102deed7" name="TestRewriteOfRuleRefListLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4a287924-26bc-be65-2ff5-235cfbdba7a0" name="TestWildcardGrabsSubtree2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d59ff183-8c21-380e-7527-c4c078f4a302" name="TestAutoDupTreeWithRuleRoot" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="07d05edc-57ba-b38e-2da6-c5d2b24c70bb" name="TestNonImaginaryWithCtor" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7692c591-f0ed-6677-37ee-1a72705b8e8f" name="TestAvoidDup" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0ac7347a-b97a-8ee3-b80a-e33ed5f01535" name="TestRewriteOfRuleRefRootListLabeled" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="db8db0d2-b01c-9760-3c47-4ced7bbcbb85" name="TestSimpleTree" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="fb169782-827f-a5fe-2a40-d18465c4b3aa" name="TestAutoDupTreeWithRuleRootAndLabels" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f2834348-cbab-3089-f00c-3270e070b516" name="TestRewriteOfRuleRefLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1bb28603-4db4-33ab-eae9-28979f7b9d8d" name="TestRewriteModeWithPredicatedRewrites" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="aa840249-45a3-3c0f-4ea1-95ff0175a756" name="TestWildcardListLabel2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f82f0497-3a42-2c25-55ad-9b1d76605084" name="TestRewriteModeChainRuleTree5" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5955fbfe-9d9f-e08b-4a13-38317cf0d35a" name="TestAutoDupTreeWithRuleRootAndListLabels" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="cb320162-24ab-a4f0-f130-809fd1914d08" name="TestSetMatchNoRewriteLevel2Root" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d05e2e9a-3390-81de-21f6-765ead7a2062" name="TestAutoDupMultiple" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c283e34d-e2b1-36ce-e2bc-9ef508eb98c0" name="TestRewriteOfRuleRefRoot" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5d7fe4f7-94cc-e1d8-032f-264a19d197e1" name="TestWildcardListLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="42e46fc0-3af0-c19c-0daa-1c2dc7affcc3" name="TestFlatList" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="40702160-3c1e-b447-c52c-58cccf0cd9bd" name="TestRewriteModeFlatTree" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d3cc2096-7e8e-adce-39bc-a28a2cbc94e6" name="TestSetMatchNoRewrite" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1a4f72f1-1138-08b7-70f9-931cd2f5f0d4" name="TestRewriteModeChainRuleFlatTree" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="44f7708f-1695-6d03-4c6a-76dd21cdeda6" name="TestAutoDupTree2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="40309d89-7d64-931d-745c-6791cfb32f27" name="TestRewriteOfRuleRefChild" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d7ecc403-7020-c466-e842-3eac8a9e8e2d" name="TestAutoDupNestedTree" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="99feedcf-fa24-a2b4-dd99-244596dbde33" name="TestSetMatchNoRewriteLevel2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0b123cb4-9696-a957-9f6a-58cc6fef6709" name="TestRewriteModeChainRuleTree3" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="FastQueue" id="cbefbc15-ff84-4892-9c3f-42773c74900f" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="0911fbc0-a30e-a173-3df8-c100584b4f9c" name="TestQueueThenRemoveOneByOne" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="95115011-85da-85d2-a439-b0d856c1545a" name="TestGetFromEmptyQueue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="700441e7-fff3-0cd5-6514-b35d14cc6457" name="TestGetFromEmptyQueueAfterSomeAdds" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7828ca2b-df2b-714b-4672-39b431289957" name="TestQueueNoRemove" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4d4bd6a8-4ad7-5175-e560-0708613d0b0a" name="TestQueueThenRemoveAll" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="Trees" id="e433d4d6-0eb4-4104-bbda-10aa34646d26" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="7c44cecb-5184-24d7-66b8-c2971b235732" name="TestReplaceAllWithTwo" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="dd601a6c-7b3a-da68-3457-0931ffa9eade" name="TestReplaceAtRight" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3864a271-38c7-4245-236e-e562a2b1051d" name="TestReplaceAllWithOne" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d353bca8-b700-00af-e6fe-7e13214cca41" name="TestReplaceWithOneChildren" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e66cc2b9-40a7-9fe2-c440-dcc2c1c716e2" name="TestAddListToExistChildren" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ddd1b2af-ca65-91b8-909d-5242aefd298c" name="TestReplaceInMiddle" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ef9dc75d-e5bc-b0ec-fff3-0f68196e23b3" name="TestBecomeRoot" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="39a45684-7ee9-cdf6-e00a-48c0dedf4628" name="TestBecomeRoot5" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3105161a-09b6-09da-0226-aaae16d5d638" name="TestReplaceOneWithTwoAtRight" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a948ab8f-4a1f-355c-9d04-9ddbfdee2357" name="Test4Nodes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ba9b0d81-212d-5e3e-009a-5a0c3d81d7e5" name="TestSingleNode" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="716c0192-778a-ae4a-30cf-9d89fcb43758" name="TestBecomeRoot3" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4fa6f5c9-be65-5a93-d1c8-77898f7fa80f" name="TestBecomeRoot6" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="431f5c8b-e9b8-cb8e-923f-186f00eea50f" name="TestReplaceAtLeft" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="96021ec3-0105-650c-fa53-af86404e6746" name="TestTwoChildrenOfNilRoot" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="927a102c-cf6c-0cce-bc55-442fc41f4fbe" name="TestDupTree" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6b7558fa-0840-d02e-79c0-028e028c0902" name="TestReplaceTwoWithOneAtRight" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0ac661a7-781b-fd48-ce51-dd46aa720cd9" name="TestReplaceTwoWithOneAtLeft" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2196b69c-4cc9-122c-da61-849f14b8c670" name="TestList" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="05ccf9bf-9a29-8cbc-0db3-8e5513920409" name="TestReplaceOneWithTwoInMiddle" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="858e9b8f-8a86-7bc9-405b-705261a7d161" name="TestList2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c4957ec8-2ea0-88f2-56f6-cc32ba0b9b72" name="TestReplaceWithNoChildren" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="969d6a1d-9872-e07b-dd19-890edba571f1" name="TestReplaceOneWithTwoAtLeft" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="795b6e51-4b14-5360-15f0-a99827152fb4" name="TestBecomeRoot2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="Semantic predicates" id="e9bca924-69b5-47ed-b2d1-6bf19252b829" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="aa4b592f-abc8-b749-eb82-d66598e809c9" name="TestIgnoresHoistingDepthGreaterThanZero" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="19743391-7589-ae9b-5aa7-57bfe34f0973" name="TestPredsUsedAfterK2FailsNoRecursionOverflow" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="55748c54-32c2-b1a0-d7ec-a9adac245c16" name="TestOrPredicates" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c4778e4f-abc2-49ff-1289-ac408ebeada0" name="TestPredGets2SymbolSyntacticContext" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e6c1572b-40db-9193-e10e-8ec99945e098" name="TestIncompleteSemanticHoistedContextInFOLLOWk2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e363d875-c5ee-387d-7809-5be03d084ba0" name="TestPredicatedLoop" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="40466cc3-4581-209d-ae3a-fc7990e7934a" name="TestGatedPredDoesNotForceAllToBeGated" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a12a21e5-301b-c7a4-71c6-5a3396a8238d" name="TestDefaultPredNakedAltNotLast" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="dbad75d5-0450-e458-e493-01ecffa8a8f5" name="TestTooFewSemanticPredicates" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8de9ad84-8e8e-4fb9-8406-75d605a8b70b" name="TestIncompleteSemanticHoistedContext2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="30438ef2-938f-5058-2078-490f2f95a1f2" name="TestLL_1_Pred" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3de4032c-ece2-f149-4cae-32b3203513d8" name="TestLexerMatchesLongestMinusPred" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="bbe55f07-401e-0eff-60b6-977996758bf9" name="TestSemanticContextPreventsEarlyTerminationOfClosure" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6985d64b-a39f-dcf9-9970-460cdedc1243" name="TestUniquePredicateOR" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9a6361f9-2981-7edc-8710-d32f3879af0f" name="TestLL_2_Pred" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="bf0d267b-e412-df0c-e549-da20aa8a09d4" name="TestIgnorePredFromLL2AltLastAltIsDefaultTrue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5615b789-6b04-a049-659d-689f11298962" name="TestPredsButSyntaxResolves" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="eaf15aa2-e7f8-5f8d-3d44-aa3fcf3996cd" name="TestGatedPredNotActuallyUsedOnEdges" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6fad5be4-633f-ba65-192b-8baa001387dc" name="TestPredsUsedAfterRecursionOverflow" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ff3a8d5d-0f1a-5bba-7fa0-c7a0b8f233cd" name="TestIncompleteSemanticHoistedContextInFOLLOW" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="10db6edb-b73b-f6ea-0a8f-9699f7b79c52" name="TestHoistCorrectContext" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="22ac4797-1f9c-1cf5-e102-6396ddcc9e26" name="TestPredicatedToStayInLoop" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="704eba9c-0ed6-82a1-2c00-6d10fdbefe6c" name="TestPredWithArbitraryLookahead" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="46f7afe0-8783-cddd-dd29-f7d420c9822c" name="TestIncompleteSemanticHoistedContextInFOLLOWDueToHiddenPred" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="69138466-9b81-764a-4631-1cd5529249c5" name="TestLexerMatchesLongestThenTestPred" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="382c26ed-819f-d427-bfca-18dbf401e615" name="TestIncompleteSemanticHoistedContextk2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="002f817d-58f4-5cdf-14ed-e3934a936372" name="TestPredWithK1" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1e6cdbc9-09d4-7273-b8ac-1da0b121aebb" name="TestGatedPredInCyclicDFA" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d87e5abf-f971-d8b1-4053-e9785b4cd4f9" name="TestLeftRecursivePred" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8d340762-ab00-fe9a-db5b-22dc31fa83fc" name="TestGatedPred" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c69f5e6f-f537-72a7-f47b-98b671f947cd" name="TestLL_1_Pred_forced_k_1" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e1131b72-3715-e4f1-83e4-20e09a9fd2f1" name="TestGatedPredHoistsAndCanBeInStopState" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="df34d692-ece3-46c5-1f86-2fdb70e82622" name="TestHoist2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="dff20587-615d-e394-3b98-e9371cf23f1f" name="TestIgnorePredFromLL2AltPredUnionNeeded" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b06bc3bd-377e-c4f4-2c3a-1401985b5b4f" name="TestIncompleteSemanticHoistedContext" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d295b48c-2f64-9a17-ea68-e7c4c2988b79" name="TestAndPredicates" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a4e3adb9-9095-bb00-cd76-c4382dad475c" name="TestORGatedPred" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ae4ade20-6a95-59ea-d8a7-9df2870df720" name="TestIgnoresPredsHiddenByActionsOneAlt" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="836c3c14-7d1c-c0b9-63dc-425e6be9a543" name="TestIgnoresPredsHiddenByActions" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="abb6b2ec-4585-945a-cc48-5f32202f317b" name="TestGatedPredDoesNotForceAllToBeGated2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="11e966de-6d16-480c-0a64-9d4bba603b56" name="TestDefaultPredNakedAltIsLast" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1420c77f-fd0d-92bf-6a3a-8baa44bb2654" name="TestMatchesLongestThenTestPred" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="StringTemplate" id="f5f852b3-d8bb-4b03-bbb1-b9184f36badc" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="1429e05c-8f33-8acb-543c-3b54e356fb21" name="TestAngleBracketsWithGroupFile" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="70e55fc7-1a2f-4259-6af4-a2bd53f12aa1" name="TestImplicitRegionRedefError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d22703c4-36fe-e74c-a276-c205624d9517" name="TestMapEmptyValueAndAngleBracketStrings" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="46c85b35-3efc-91c6-f122-92c3e7d3fcea" name="TestEmbeddedRegionRef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="cc61811d-b9ae-2e07-0a62-e55662d0e2a0" name="TestMultipleRefsToListAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ab496999-28ef-76c1-46c8-55d48c735bfa" name="TestEmbeddedRegionRefAngleBrackets" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="cee342a7-b038-5ed3-900f-6c49761ad185" name="TestAngleBracketsNoGroup" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f5735b8b-fe94-0781-d293-2f93b1db9b72" name="TestApplyTemplateWithSingleFormalArgs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="67f65178-38cb-28d1-331e-c666d434a3a7" name="TestSizeZeroOnLineWithIndentGetsNoOutput" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1751873f-8ce2-a033-c222-89cc58156464" name="TestTemplateRedef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c67c491e-ea54-feeb-f310-a82c470d90fc" name="TestEmptyIteratedConditionalWithElseValueGetsSeparator" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="83c1f357-60c6-665c-5e75-d48f971ffe05" name="TestChangingAttrValueTemplateApplicationToVector" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="35a1504e-e452-5273-839f-5a6a51fc0887" name="TestEscapesOutsideExpressions" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="928ab338-fb07-90c1-8f11-3f60fc826e67" name="TestNestedIF" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3a2c2890-7cee-c526-5ec2-f857df1a5959" name="TestParallelAttributeIterationWithSingletons" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e4fb9edf-432a-9c5d-c6db-e272ecc4255f" name="TestSingleValuedAttributes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8ce7fd07-d4e3-1e43-6a12-fd49d7668086" name="TestMapValuesAreTemplates" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4a32f30a-220a-7343-4046-fee4a1ce7006" name="TestCatWithTemplateApplicationAsElement" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a922fbdf-9eb6-d0b2-ac7c-abdb0c788068" name="TestMissingInheritedAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c4e35019-44a4-8027-12b1-b029dc7b726f" name="TestElseIfClauseAndElse" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4b6bcdf0-9bff-e7e6-9ece-943feb13cebe" name="TestRendererForST" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5ef6e900-d281-e909-9452-583abb04d15e" name="TestIndentBetweenLeftJustifiedLiterals" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d8f8ad81-26c4-6434-ada1-ee281d9b70ef" name="TestComputedPropertyName" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9678c103-5000-a8ee-6f10-e4c2e79713b8" name="TestNullListGetsNoOutput" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="48cacd73-7a54-a727-f0e3-a0e316f991a6" name="TestLazyEvalOfSuperInApplySuperTemplateRef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0f61ae2a-8f5a-0eb4-74ee-f3e51bd21a6f" name="TestGroupExtendsSuperGroupWithAngleBrackets" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9ee8a781-7ff5-a372-91de-15801fd31576" name="TestNestedIndent" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="10d8ef6e-7bc6-eb2c-1de7-64b503d13a4e" name="TestMultiDirGroupLoading" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7bf7f0f9-4e80-afa6-5fc4-8ee820fcc148" name="TestSingleExprTemplateArgumentError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ae855ebd-043e-eadd-9108-e9bdcc6f21aa" name="TestElseIfClause2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="eef8e6a4-cee6-ebc9-4cfc-195a925d7910" name="TestEmbeddedComments" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2574e754-8a62-a696-5a41-91cfa1331ca7" name="TestApplyTemplateToSingleValuedAttributeWithDefaultAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f7c21c2f-6a54-1301-c0d4-989a04927eb9" name="TestNoDotsInTemplateNames" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a89031af-01c2-2f51-5b31-f990ca048bdc" name="TestCatWithIFAsElement" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d6cb5cf1-a9f7-b619-411a-3165f23692d8" name="TestTemplateNameExpression" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="149c6f4d-d751-5fe1-1039-0aa44cec3b26" name="TestMissingEndRegionError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a8441696-c95e-89b1-20c3-9c7941149f03" name="TestCatListAndEmptyAttributes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b555c6a5-546c-25e8-e3ae-aac466add421" name="TestReUseOfRestResult" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="74402ff1-4349-e950-e5e5-5f83780b10ff" name="TestMapKeysWithIntegerType" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5440f694-f01d-12fd-bc58-948498cf096c" name="TestIFConditionWithTemplateApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0419b0ae-66ac-ef6b-71d7-80b472446750" name="TestParenthesizedExpression" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="097c5d6f-a5d2-79a3-1fa5-1efabee363c0" name="TestIFBoolean" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="925dc2de-f248-47b6-dbbc-75397ea5f2e7" name="TestAnonTemplateArgs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="bf6b2f46-3908-961f-e5e7-3517a59063e7" name="TestArgumentsAsTemplatesDefaultDelimiters" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1316fede-446f-0add-4fb8-b9e968752433" name="TestTemplateAlias" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="34b3dc9c-a559-0da2-22f2-3b4889ee0528" name="TestLengthOpSingleValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9baa2cc2-3507-0c5b-8255-37f2bf5bedae" name="TestIncomingLists" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="edda67dd-9e59-58d5-c255-291ed7e8364c" name="TestMapDefaultValueIsKey" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="267b43b4-c413-0202-4460-e75bddd643f0" name="TestNullTemplateApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="aaa39864-e027-7e59-3b03-672d32119a9a" name="TestMultipleAdditions" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="161a5028-d3ca-64ce-f245-c987a3402767" name="TestMultiValuedAttributeWithSeparator" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c5ae5510-0c02-7e11-d466-51c1cedd1bfd" name="TestDoNotInheritAttributesThroughFormalArgs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7163ed86-68bc-8c17-3708-9eccaad0fa5d" name="TestIncomingListsAreNotModified" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5c36232e-2025-f9bc-2d25-0664b178b9ac" name="TestNestedIndentedExpr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="22dd3353-436b-1711-37f4-168926c0227b" name="TestInheritArgumentFromRecursiveTemplateApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2a6a36fb-2e47-23de-8c49-ddf948e4cb10" name="TestRepeatedApplicationOfTemplateToSingleValuedAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a981d7a7-cc3b-2290-49ff-089b51174505" name="TestMapViaEnclosingTemplates" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3e65262d-4c3d-7d51-d2be-ca2ece434589" name="TestStringLiteralAsAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e4a7a2c8-9293-2ece-821f-0de5db73d898" name="TestSoleFormalTemplateArgumentInMultiApply" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6cc5e0c3-84f5-a0a6-8081-0db7a6c6dff1" name="TestNonNullButEmptyIteratorTestsFalse" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ce7eb8db-d1a9-7840-ff77-dba38a8cacc8" name="TestMapEmptyDefaultValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9d913d03-4d17-cade-7892-d9660ab1fe52" name="TestArgumentContext" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ce468e69-fe0e-9261-b8a7-a75c9f098e74" name="TestAlternativeWriter" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c868fd80-d85b-0e3d-188d-396e6e12a0fc" name="TestApplyRepeatedAnonymousTemplateWithForeignTemplateRefToMultiValuedAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4f48ef54-ab9e-3b19-2de9-b045ad9fa796" name="TestLastWithOneAttributeOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6fe66374-8f72-d284-d1ba-1178e9910605" name="TestLengthOpPrimitive" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="aef0b15d-9df1-1923-b714-c655ca706b5e" name="TestParallelAttributeIterationWithMismatchArgListSizes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d4959251-9d72-f88f-6142-0085686cab54" name="TestComplicatedSeparatorExpr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="79818e0c-e3c9-0a63-2f71-7dce5a4d9672" name="TestFormalArgumentAssignmentInApply" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1fdeebe9-53e0-103a-b4d4-9c73da34fac4" name="TestEmptyListGetsNoOutput" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="964dcd2f-b572-3c4e-4b54-0576c281c4ce" name="TestCombinedOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1ad0248b-14c8-e974-0ebd-3f14d84b44bf" name="TestGroupSatisfiesSingleInterface" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="dd425c91-b461-ccc9-6b91-e7e9fbb89a9e" name="TestDumpMapAndSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="38ff7db0-94cb-604a-3371-f405b9b058b2" name="TestRendererWithFormat" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4d3bf45c-3b92-4b79-bd5e-e37be6694fc7" name="TestNullIndirectTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0a4bb10a-a089-201b-d895-3f320c471b11" name="TestMapKeyLookupViaTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="329c12ab-fbd5-c2dc-8cad-fda287fe0e7e" name="TestTemplateGetPropertyGetsAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d5356540-edc4-7ff8-30d5-cf49b1db2f6c" name="TestMapDefaultIsDefaultString" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="31f910b6-4436-1801-c3b5-687ce99500a4" name="TestMapValues" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c4c84799-6f36-2c1c-5a30-4327eda77e4b" name="TestLineWrapCharAfterWrapIsNewline" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1aba3dcf-8f20-4d77-d34d-08751792b3e5" name="TestCat3Attributes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="43f2d35d-e529-4199-c152-418ce87dcb77" name="TestObjectPropertyReference" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4b179b23-fe3a-f60e-6eed-ebc6dfebb9e1" name="TestAnonymousTemplateAccessToEnclosingAttributes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="13856f52-70e4-a8ac-61e2-a5548f2da699" name="TestTemplateApplicationAsRHSOfAssignment" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="47934c2b-7483-4be6-f2bd-bbfd3c5d74ec" name="TestLastWithLengthOneListAttributeOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e0e8a0f2-9f19-4b59-3cd1-e94ec3c31088" name="TestNullValueInListWithTemplateApply" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c021b968-b9a5-cac6-78a9-f9d437703abf" name="TestNullIndirectTemplateApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9696e50b-9e52-3dba-8710-85cf11f9d9f6" name="TestEscapes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="75d13121-37ec-b175-a552-f4765c3c3685" name="TestRendererWithFormatAndList" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="465c3cad-256e-7d9c-6257-8d38b3a07251" name="TestIndexVar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4105c938-02b3-7318-a132-697817798eb9" name="TestEmptyGroupTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a0924cba-d4f2-5d96-8d6b-5a414cdfcefa" name="TestWhiteSpaceAtEndOfTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3ca99b12-a84a-950f-6502-05ae73c658be" name="TestInvokeIndirectTemplateWithSingleFormalArgs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="691feccd-341a-f324-6e65-df6d1eb32123" name="TestParallelAttributeIterationWithMissingArgs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="533b3a12-a8aa-8aa6-c3af-d1413ac7ca25" name="TestNullSingleValueInListWithTemplateApply" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b33492b7-2c96-5fe1-49ae-0cd5a946a058" name="TestCatWithNestedTemplateApplicationAsElement" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b3aab89d-19f2-2d07-2c0e-8cb27868e8fb" name="TestRegionRefWithDefAngleBrackets" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5b45445b-7207-a01f-9573-31ac431dabff" name="TestIndirectTemplateWithArgsApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8ff45b62-6c96-985c-4755-cc81d673d79a" name="TestOverrideThroughConditional" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0b904660-91db-cf1b-e6a9-25138fff3570" name="TestComplicatedInheritance" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="256b263e-8c2c-034e-6ebc-08a73e488af1" name="TestNullValueInListNoNullOption" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5cddaaa1-8fc1-c15b-1755-635072532681" name="TestElseIfClause" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="dcaa0fea-0222-0465-d575-35a6109e1aed" name="TestReUseOfCat" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8b569889-e592-e96c-14c2-0a1a23a3efc1" name="TestMapHiddenByFormalArg" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5053bace-5b38-aeb5-6ed7-11e60ebcfb3e" name="TestIndexVarWithMultipleExprs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8cb85f0d-3414-e336-6106-ce55664eae10" name="TestRestOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c669ee0c-f106-2f02-eff4-87c41738c4fc" name="TestCharLiterals" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2b3eaace-a9b2-0537-1caa-911c9386dae9" name="TestPassThroughAttributes2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4e5ad2a7-eac1-a49b-0696-9849ffa42dc3" name="TestStringCatenationOpOnArg" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4c88aeb3-8a3b-2375-3bc3-ba2b9fa3e2a9" name="Test16BitUnicodeChar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b226efec-7007-04cc-3971-66e34b952825" name="TestNonPublicPropertyAccess" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b7331a9f-474b-5e41-e936-33df48846e1e" name="TestRepeatedApplicationOfTemplateToMultiValuedAttributeWithSeparator" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1192c9df-1c93-10b5-f05a-fe1d8206d7e2" name="TestRegionRefWithDefInConditional" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f2dd8fa5-3bcc-b702-8245-50dd958f50ae" name="TestNewlineNormalizationInTemplateStringPC" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ab945285-5733-5fdc-5d6c-5f69a5492e4f" name="TestEmptyStringAndEmptyAnonTemplateAsParameterUsingDollarLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="250b81e1-0f27-15dc-9699-41b3e8fef9d7" name="TestAnonTemplateOnLeftOfApply" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="afdd665a-7b19-fb41-14cc-ca2e56cb7e2a" name="TestLengthOpOfStrippedListWithNulls" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9d56a24a-d656-6ab0-a7f2-eef8a7168861" name="TestApplyTemplateNameTemplateEval" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3507b32b-85bd-7340-a16d-e949e52fa290" name="TestIndentBeyondLineWidth" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c2f33561-6e25-32d6-ce55-3af54a96997a" name="TestStripOpOfListWithNulls" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="92102684-25a7-a225-7d8f-f68cff24f10c" name="TestHashMapPropertyFetchEmbeddedStringTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ee95beeb-c729-40a7-3527-db3303487b72" name="TestApplyAnonymousTemplateToMapAndSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="dd248781-7888-dab5-faad-bf0ad0cbff00" name="TestNullValueInList" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="70b3ed25-62a0-1804-70ec-247ad34e0078" name="TestSizeZeroOnLineByItselfGetsNoOutput" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3ced3a2c-6120-cab7-f46e-93e09a4991ca" name="TestRegionOverrideRefSuperImplicitRegion" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="45ca614d-da04-db29-8e50-36688df5c925" name="TestStripOpOfSingleAlt" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3a69f99a-2dbb-423c-bd05-5baecad4c50a" name="TestRendererWithFormatAndSeparator" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4f472302-32bf-ea13-3c13-0d767d36f1d1" name="TestRepeatedRestOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ab6d943d-7382-f7c2-3ddc-2d26ba9d9405" name="TestCatListAndSingleAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="02128320-6ac5-4e22-6fa1-d6f3da55ae40" name="TestEmbeddedCommentsAngleBracketed" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b29aecbd-473b-51c8-a42d-26ba15632c4e" name="TestUndefinedDefaultAttributeReference" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="51643f13-8f84-493e-703e-2b8887edf319" name="TestIFCondWithParensDollarDelimsTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e5022a58-86aa-7910-5fae-f58e974e663c" name="TestRegionOverride" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ade58a1e-9ad3-7d77-9ad2-5e95065e0760" name="TestLineWrapAnchored" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2ba3eb7f-26c5-991b-01af-f244ebf57a70" name="TestRecursion" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="443e83b2-f67c-b678-33fa-68df8822fe43" name="TestEscapeEscape" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="95ecf7c0-820b-953a-88bc-b4b1707f8a1a" name="TestApplyAnonymousTemplateToMultiValuedAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ce0f83ae-b6ca-e5bf-e7a7-86ea1c6bcdf1" name="TestCat2Attributes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a476faff-8e37-cb1d-5a02-b60d5df51626" name="TestFirstOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2bad7fda-1062-3485-6a7a-9fda8e018831" name="TestSingleValueWrap" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="20989214-9031-a9f8-60d8-2a4b5a07715a" name="TestEscapeEscapeNestedAngle" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="243a05c4-8989-433b-8f28-757fa684d625" name="TestExpressionAsRHSOfAssignment" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="11d12ffd-a7ed-e580-16c5-10d7a8f995af" name="TestFirstWithOneAttributeOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="071e78bf-f23e-6bf9-cd8f-8c0b821be6b6" name="TestEmptyExprAsFirstLineGetsNoOutput" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b3be3fe3-488c-8c74-397e-bfd1571f0f84" name="TestElseClause" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c0113798-3953-f36a-8afe-801c24cae17b" name="Test3LevelSuperRef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="fbb9f06e-4ed4-6f5a-123e-60b0c1bcbd9b" name="TestImmediateTemplateAsAttributeLoop" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="27e7e7e9-12ae-b8a9-efbf-9a21ad900341" name="TestMapViaEnclosingTemplates2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="47c8b938-dae1-ae21-09f3-ce047342a082" name="TestIncomingListsAreNotModified2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e4ca4742-742a-ce8f-80d2-3c7d4718b07d" name="TestOverrideInheritance" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e782a001-9335-8b49-bcdc-542646bc3bb4" name="TestEmptyIteratedConditionalValueGetsSeparator" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e0f6648c-8c62-43aa-95ba-8a36755dcc34" name="TestEmbeddedRegionRefWithNewlinesAngleBrackets" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2c507847-8169-53fb-1357-f4a85afa74a9" name="TestNullOptionHasEmptyNullValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2d5f0383-4043-4a3f-60de-252947c624f1" name="TestListOfEmbeddedTemplateSeesEnclosingAttributes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e32880cf-0ed3-afc2-1de3-06d97ea18279" name="TestEmptyIteratedValueGetsSeparator" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4b4f34bf-7676-70ac-9131-6c5ece69ae77" name="TestLengthOpOfStrippedListWithNullsFrontAndBack" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="05ca07ca-aec6-1e3b-ed72-3030b165b2fb" name="TestRegionOverrideRefSuperRegion" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="73271f08-f68e-51b9-dbb3-0807a70a031f" name="TestTruncOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="54230e0c-daa3-7059-3a21-abeb80009840" name="TestSimpleInheritance" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d06266d0-7733-e1ee-d987-7286bc49f686" name="TestRestWithOneAttributeOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ee0f7ff9-3d7a-c304-0e2b-32a134dd1223" name="TestParallelAttributeIterationWithDifferentSizesTemplateRefInsideToo" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2d0da3dd-8a0a-676e-5a7f-b3d5746d2d5b" name="TestIndex0Var" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="57834834-e7dd-eb16-499e-1c24d2c0de6a" name="TestEscapedTemplateDelimiters" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b54469aa-62ce-0a0a-4a2e-ba93b6652d9b" name="TestMismatchedInterfaceTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2b9f7786-8950-cbf9-3c9e-c92a92fa8035" name="TestDefaultArgumentAsTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1d70c2d6-3982-5823-3adc-87dc117f917f" name="TestLengthOpNull" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="694f000c-5fb7-33f8-bf65-52ea13f73f92" name="TestEmptyStringAndEmptyAnonTemplateAsParameterUsingAngleBracketLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9c248572-d7c0-d49e-c56d-dd2f13e00b08" name="TestGroupExtendsSuperGroup" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e6232613-8db1-056c-2f92-e66985b7f482" name="TestRegionRef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4300735f-dd2a-2c2e-f877-f0264bf5e78c" name="TestNestedAnonymousTemplatesAgain" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8fee7b2a-9264-fc2b-054a-7a02d1e78372" name="TestPassThroughAttributes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6a77e947-a01d-4dc2-af73-73e6b3b48477" name="TestApplyAnonymousTemplateToAggregateAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="833ba687-53e9-f9a6-4f45-6ff9f6916d7c" name="TestUnknownRegionDefError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="844505ec-5b80-2cdd-e80a-5e0b2211af69" name="TestNestedWithIndentAndTrackStartOfExpr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4881272a-52d7-0980-7f58-244e944a35ab" name="TestLineWrapEdgeCase" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0be859fa-8613-db49-1a2e-67b1789f47e3" name="TestNestedIFTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d23e20b4-74ca-7088-68de-8516a694f6a2" name="TestNullSingleValueWithTemplateApply" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6b489eb6-c3da-e2aa-17c2-9396643c89ee" name="TestLengthOpWithMap" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="757fc18c-d65c-dfdb-0237-3ea49e801835" name="TestListLiteralWithEmptyElements" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5f67f7cf-a999-fbc5-b515-62278e984002" name="TestApplyAnonymousTemplateToArrayAndMapProperty" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2bab381c-c2a0-f2e5-8ecc-05f961570e9d" name="TestCat2AttributesWithApply" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1dc8b826-d5dc-df42-f3a5-38d33f122cbf" name="TestMapMissingDefaultValueIsEmpty" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="67c65aad-667c-e9ee-d234-91b8f641af44" name="TestRendererWithFormatAndSeparatorAndNull" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5be7d853-a933-a454-e09d-b2b8770569fa" name="TestNewlineNormalizationInTemplateString" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="943804f7-7dc8-ea47-471e-2cc814862d4c" name="TestCollectionAttributes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c4c9fb8b-d75f-a3f1-6807-113648432512" name="TestComplicatedIndirectTemplateApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f1a6a0f1-900f-d420-dd46-9729b5c2381c" name="TestIndex0VarWithMultipleExprs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ef3969bd-8c2f-1ba3-66fa-a2a4837cc834" name="TestMapDefaultValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4bb829e0-d03e-a757-d584-b444bff03543" name="TestRegionRefAngleBrackets" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="10bc0ffc-5548-6be4-fb76-aad2b8bf320b" name="TestMapDefaultStringAsKey" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="97921ecd-863e-5aa2-03ab-8c637a327788" name="TestNestedAnonymousTemplates" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a970d0e7-1b59-9997-fcb8-10677ac4ce45" name="TestStringCatenationOpOnArgWithEqualsInString" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="57deddf3-95b9-1eb3-6923-0662ccd362af" name="TestIndentOfMultilineAttributes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="04c9f0ea-2cbb-5c67-1375-23cec5b98d87" name="TestSuperReferenceInIfClause" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9c81357e-089d-1b9b-5958-5a6d0376b008" name="TestNewlineNormalizationInAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="14f693ae-6c1f-7535-1a1b-91403b3b80a8" name="TestSuperRegionRefError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7a920609-3def-0da1-6b02-d5418e3257c0" name="TestLastOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8dec30e2-8893-cd6c-d0f8-4796be2169b5" name="TestEmbeddedRegionRedefError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2e96a90a-2b23-2da1-cdf8-bc8d9b67e5d4" name="TestFormalArgumentAssignment" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d3242c5a-ecff-32f6-9420-0f38cfed35b5" name="TestDeliberateRecursiveTemplateApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ca6958f1-c4a9-f425-5ffd-d007df4873f9" name="TestLineWrapForAnonTemplateAnchored" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="aded18b6-aeae-edc9-3abb-3dc63b448595" name="TestLengthOpOfListWithNulls" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c259730c-3aef-8d4f-1829-abbcfdd2927b" name="TestOverriddenRenderer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5857e209-7452-7f2f-bf58-aad9a0a21c4a" name="TestElseIfClauseAngleBrackets" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="212391ae-3588-2620-c372-28b9f4535a4a" name="TestNoGroupLoader" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2e7c7cdb-9905-d568-bbd2-ef215f849489" name="TestApplyTemplateToSingleValuedAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="21d28793-27eb-a41c-c494-21caa0a80527" name="TestAlternatingTemplateApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f4b13414-9c10-2fca-dcf3-bbc9e547c4ed" name="TestLineWrapLastCharIsNewline" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0a3162b0-40b8-0b94-bd7e-6e5de38e0317" name="TestIFCondWithParensTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b9d92187-f0a3-5c71-f6f2-1259ffe5e6f9" name="TestIncomingArraysAreOk" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="bd744a9a-9c7a-60c1-66b2-c2138c55aad8" name="TestDefaultArgumentAsTemplate2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="631b91f4-26cf-e556-330c-f90615535fd4" name="TestListAsTemplateArgument" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="11a84016-83c2-f9a3-4f54-23f2d7aea8dc" name="TestNullTemplateToMultiValuedApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8c99dc10-305a-9192-f055-fca054f7b0b4" name="TestImplicitOverriddenRegionRedefError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0d313f6e-6d2d-7d3b-f776-e0a45d71cbb7" name="TestUnicodeLiterals" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ad2d0887-2e56-8843-9595-92cf8f6dd276" name="TestLineWrapForAnonTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0e40fe7a-160c-53ac-e4d2-629b58a77794" name="TestNoDotsInAttributeNames" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="fc342ba6-ff8c-1baa-9121-fe8e63b11b10" name="TestMissingEndRegionErrorAngleBrackets" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f9a345d7-799f-d72f-8154-2af80d30a62d" name="TestExprInParens" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="52ed7d57-599a-6fff-74a2-4a9c0dd42a06" name="TestApplyAnonymousTemplateToSingleValuedAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8ebebf4d-f80c-5292-5a9c-7a392fff7c3d" name="TestSetButNotRefd" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a2e481eb-2d75-8952-c787-604eed023296" name="TestTemplateParameterDecls" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c3c59071-877a-34e3-c436-4006b05c73c6" name="TestIFTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0ca549c4-bd22-bb1f-261b-98cffb1acd33" name="TestSuperTemplateRef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f7c7b455-75f9-a11e-0f76-b6058ac8e452" name="TestSingleExprTemplateArgument" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="13ebfc90-2464-9f8f-1a22-2f86d3463083" name="TestDefaultArgument2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="919c992f-9b4e-a30f-47cf-c60b2071ccd5" name="TestLengthOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="dec05f46-1133-5e06-afcc-54727d2de8fa" name="TestAnonTemplateWithArgHasNoITArg" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9a0b0dd3-6e05-78af-3650-ed05964de683" name="TestParallelAttributeIterationWithDifferentSizes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="86d36f29-feb6-4a20-0885-4ac8cc6340c4" name="TestApplyTemplateWithNoFormalArgs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="197a6bc7-8a27-ba13-89be-3ac61a9c5112" name="TestIndentOfMultipleBlankLines" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1d5f200b-7472-967a-34fc-ef3f09208c5a" name="TestMultiValuedAttributeWithAnonymousTemplateUsingIndexVariableI" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ac731860-1873-3d56-dd2c-d379a9dd6b31" name="TestStripOpOfListOfListsWithNulls" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="15503b07-90e5-150e-1fac-f5b7efba0b65" name="TestSubtemplatesAnchorToo" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="32dd044c-12f4-c9ce-8d91-9058c24886b8" name="TestAnonTemplateArgs2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f8aba869-af5d-23c5-a9e2-c0ec9c630f4b" name="TestMap" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7e60946b-cb95-deae-b24f-18b96f43e4fa" name="TestSimpleAutoIndent" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8819bef6-80b4-55a8-ae24-9d8598bfb1bb" name="TestUndefinedAttributeReference" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="10ea1f1c-f002-3ca7-3ad8-1bb0bbc62c8e" name="TestLineWrapWithNormalizedNewlines" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6d8bc4c1-abd1-515d-cd43-2dc489eb7e67" name="TestNullOptionSingleNullValueInList" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="da61aa5a-5cce-16bb-ea63-d8517ae40fe8" name="TestDefaultArgument" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a46646c2-93fc-8a96-960a-4b726279e182" name="TestEmptyListNoIteratorGetsNoOutput" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="fb038d4a-c919-d59a-1599-77526002ea11" name="TestStringCatenationOnSingleValuedAttributeViaTemplateLiteral" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5e1ccf03-3f15-8bc4-f85b-cadc5b044a49" name="TestFirstWithCatAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a446aafa-acca-edbd-8f20-5b7a14a41c56" name="TestMissingEndDelimiter" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3d078d2f-efb6-5fac-9cdd-f7cd385ad5c0" name="TestRestWithLengthOneListAttributeOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="454d0876-4cf3-f774-b65b-911e499fd00a" name="TestMapKeys" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1d53a0a8-3cfb-d55e-db56-9902e36c01e4" name="TestMissingOptionalInterfaceTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3e1641b4-06ac-ae2b-2551-abbbc095af98" name="TestFindTemplateInCLASSPATH" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a4cbd45c-445a-93d1-bd0d-d6a9404b3ab3" name="TestParallelAttributeIteration" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="af0c6ab6-f1d1-bf9c-4144-3936b3b46b30" name="TestHashMapPropertyFetch" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5d8e1c40-859f-debc-b37e-8b81d09badda" name="TestNullOptionSingleNullValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4ced359c-e8d4-db82-2074-ecd036a2e072" name="TestApplyingTemplateFromDiskWithPrecompiledIF" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0d70a6f5-7452-6804-5962-c5e2358fb606" name="Test8BitEuroChars" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="157142d0-d910-63d3-66d0-f1fef9add2ff" name="TestListOfIntArrays" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6676345c-c826-a7c5-c536-f00419b30e33" name="TestRegionRefWithImplicitDefInConditional" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0cca0749-d905-b00d-edb6-7414545e579e" name="TestMultiLevelInheritance" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ba2bf6af-553f-0241-3ffc-52c54e71f2ee" name="TestAttributeRefButtedUpAgainstEndifAndWhitespace" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6333032c-25d9-4497-f015-5d9ecd3d81ae" name="TestEmbeddedRendererSeesEnclosing" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="96b0f408-1310-1766-b8df-e8633d03edca" name="TestDoNotUseDefaultArgument" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4801a924-a9e7-adfd-3afa-9c6b1c2a55cc" name="TestRendererForGroup" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="266706f8-c10d-098a-1819-7c98baeca8ca" name="TestFirstWithListOfMaps" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="37116ca3-8f6d-e51d-0d43-c93310de4dba" name="TestLineWrap" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a1493dcb-6617-e844-560b-f9032cf95b61" name="TestApplySuperTemplateRef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0b470a08-80a8-c680-aca5-1d03d8ca0582" name="TestInterfaceFileFormat" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4775aa30-de07-fbec-a539-34281b6a4696" name="TestSingleExprTemplateArgumentInApply" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c97bb1fe-5c48-983f-8519-b7ca437ae7a8" name="TestSimpleIndentOfAttributeList" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1036a13b-e95e-df51-c9fe-07666e6242e1" name="TestJustCat" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7e0bc3e2-04bb-5d7d-ef47-7b94689b1dc6" name="TestNullValueInListWithTemplateApplyNullFirstValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8dbe4c75-1799-c60a-df22-961aaaeaea04" name="TestParameterAndAttributeScoping" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="147d2f91-a897-aee1-809e-1c35dccc6709" name="TestLineDoesNotWrapDueToLiteral" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="25280a52-1aac-d2b7-c101-624db74c912f" name="TestParallelAttributeIterationHasI" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1b59210a-f614-837c-21b4-c22a81dbb203" name="TestLineWrapForAnonTemplateComplicatedWrap" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="428abed9-a441-4412-265c-3dc3517ba6e4" name="TestUndefinedArgumentAssignmentInApply" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="63916867-335d-1261-05b2-a6d63ab3883a" name="TestMissingInterfaceTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="43b6155b-695f-15eb-ed3a-ae06eac53b93" name="TestGroupFileFormat" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4460f2ff-81f1-53d5-7521-3715705174e1" name="TestArgEvaluationContext" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b8e0cb54-9199-5afe-4e00-071d76e71c46" name="TestLengthOpWithSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="cbf09b31-1f2d-e8ed-3b58-15843c6f5d90" name="TestEmbeddedMultiLineIF" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f23b09cd-4550-eedd-6d44-fef66a588383" name="TestParallelAttributeIterationWithNullValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="fb9c3a91-e055-b248-8058-774635212306" name="TestReUseOfStripResult" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4444e888-11e5-18dd-ca7f-dd500680a28a" name="TestCannotFindInterfaceFile" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0ab5d1f3-1a48-15ce-f7ec-09892d91aa78" name="TestLineWrapInNestedExpr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d05ebb71-321e-c897-3bc5-201799a16169" name="TestRestOpEmptyList" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f217257c-d872-4003-3d51-4074e541cbf1" name="TestRepeatedIteratedAttrFromArg" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="483db2c4-b830-2542-59d4-3edcc4a01f3f" name="TestTemplateArgumentEvaluatedInSurroundingContext" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a9c71eca-2007-73da-d1b5-ba0847ad8b3c" name="TestChangingAttrValueRepeatedTemplateApplicationToVector" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="77dd6188-175c-cb70-edf0-29b0f0e0d092" name="TestLineWrapWithDiffAnchor" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="155124f5-7cf4-0220-209a-961dfaa8d0d2" name="TestCatWithNullTemplateApplicationAsElement" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="87d04b4d-9d96-b7f4-e22a-974dbdc5f5fd" name="TestIndentedExpr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1e34e569-da63-f98a-279d-eb62f8336713" name="TestArgumentsAsTemplates" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5869adb1-b072-82ce-52fb-1b13c2935211" name="TestFortranLineWrap" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c787665f-8ec3-7ca4-9ded-3acca1bb0244" name="TestStripOpOfNull" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="babfe618-007d-b5c2-98ae-a8c6287e3956" name="TestIndirectTemplateApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8dc95758-39d5-4081-72bd-d3706e472666" name="TestSizeZeroButNonNullListGetsNoOutput" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4a72ff89-d2a8-0df4-8e4d-b66c512fa9d6" name="TestTemplatePolymorphism" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="858bf68b-c8ca-9a4d-3989-5513441e94f2" name="TestTemplateApplicationAsOptionValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="fce7c8b6-1453-40f6-a2d9-b980f947a5a7" name="TestApplyTemplateNameExpression" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="621dc32c-648f-5bec-4f2e-cf53562a0bd0" name="TestUndefinedArgumentAssignment" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a055bddb-4395-9d9f-7175-f7c79c93931c" name="TestDefaultArgsWhenNotInvoked" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c9c5b11a-7a30-077c-e712-8773a1ad20dd" name="TestNestedOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f6052295-fc31-35d3-176c-2f8e2dfda847" name="TestRegionOverrideRefSuperRegion3Levels" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="Sets" id="f79900aa-8296-4e3b-8fcb-0d69c0ab01ee" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="a4ac2110-5b31-753c-8e40-ae750f8d2f4f" name="TestStarLexerSingleElement" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1d750629-fe45-78bf-97b4-4e0e32b2bf3c" name="TestParserNotToken" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b3490bf4-e870-c163-1704-2c774592a99f" name="TestParserNotSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c92076c0-e69d-6be9-1df2-058567e8925f" name="TestParserSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="eaeb28d0-36d6-64f2-56ae-e3b3107f0761" name="TestPlusLexerSingleElement" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="71d474b3-be8f-4b58-7c3a-f0191bafc113" name="TestParserNotTokenWithLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a73eab39-9ee1-043e-60db-995d87b66106" name="TestStarSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="da32805d-e7e2-0d4a-7c05-9225770df4ed" name="TestLexerStarSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f77b6f5c-a957-9958-5f25-25ac814a1f64" name="TestRuleAsSetAST" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a4f89e69-1dd9-ba05-907f-1e44f8c788da" name="TestNotCharSetWithRuleRef4" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="efbf5a9d-3769-726d-f4e6-7891af402c2d" name="TestNotCharSetWithRuleRef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8aafe02d-fbdc-32b2-c9b1-93c8932292ed" name="TestNotCharSetWithLabel" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6609a6a3-2f70-97ef-4c29-828948f27799" name="TestSeqDoesNotBecomeSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4ab21f0f-e91e-dae9-717c-040b0dadcde4" name="TestLexerPlusSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ac8aeabb-45b2-db4f-4d5c-bcdbc6afa946" name="TestLexerOptionalSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="eeaa63ee-6f98-879d-f05e-92546afac566" name="TestNotChar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2f177469-b1ab-6968-832c-b715a9f611ff" name="TestOptionalLexerSingleElement" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2712d6fd-b726-437d-571d-9497b72ad2bd" name="TestRuleAsSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="715bab0d-ec41-0c51-9560-53e48cf3796f" name="TestNotCharSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7b8fbe2a-a472-4c24-3ede-6143e2faf537" name="TestNotCharSetWithRuleRef3" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e5162a38-9174-73dd-822a-3dba5a43618d" name="TestNotCharSetWithRuleRef2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="33283cd8-b0f2-f592-4ecb-c2d2135484bc" name="TestPlusSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f28171ba-9fac-91a7-b650-9aad6e8d06ff" name="TestOptionalSingleElement" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3b84dbe5-305e-cd8a-43f8-61e44310d3a0" name="TestOptionalSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="Tree node stream" id="fa4c5fec-1f21-41c1-b3cd-ee93c59c2878" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="a7f6ea17-b702-e48b-aba7-079aef404569" name="TestMarkRewindInMiddle" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="452bb313-1729-fb5f-e42a-62a01c63bb73" name="TestList" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d2b39917-67ab-64af-97cb-58b3def85d9a" name="TestMarkRewindNested" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="bea55e0e-3524-85ac-7fd7-5c1d3e03d409" name="Test4Nodes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e5c045eb-07f2-91ce-2bfb-ac20b23330b7" name="TestMarkRewindEntire" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="68cf0923-24b3-537f-a768-7000de2181b8" name="TestAoverB" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e97b1713-8a12-3afe-8ceb-0d79e578c4b1" name="TestLT" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e3e8ed50-34a6-c232-bc99-404e39bb028a" name="TestFlatList" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2db7c00c-28e9-040d-e482-9ae999d1c1b0" name="TestSeekFromStart" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7f590120-8cdb-414f-34ee-26a279048e94" name="TestSingleNode" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ac3c51c9-b3f0-6d84-d0fa-0baae00f6476" name="TestListWithOneNode" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="Interpreted parsing" id="fa740596-5ef5-4716-a448-10fb44b16585" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="a4df44f9-dc79-9670-b27d-b19ef20d8329" name="TestSimpleParse" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="bded81e3-5937-1b84-e64e-7af47bee1534" name="TestMismatchedSetError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="10aba033-7c50-b07b-a5ce-95f4d04daf90" name="TestNoViableAltError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3bfcf512-887e-e507-acba-00389876cb5a" name="TestMismatchedTokenError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+  <TestList name="Tree wizard" id="fe6d0beb-460c-4ebd-b41f-2ff740558c22" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
+    <TestLinks>
+      <TestLink id="8f6b87a4-3e39-356b-7434-910704210083" name="TestSingleNodeWithArg" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9b6683f3-11fc-0177-76ea-b2bb995baa5a" name="TestParseSingleNode" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="dbf4c9d6-ffad-4505-0948-f0ba29d660c6" name="TestNoRepeatsVisit2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c151e44e-ca29-7af4-fc3c-3edb58b8509f" name="TestEquals" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1889b56c-4c97-746c-4ebc-7b8950b1f8e7" name="TestRepeatsVisitWithContext" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b6aa3278-f524-6483-00cd-3f4aaa809295" name="TestSingleNodeIndex" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1dc10beb-6c52-78e8-fd46-9c5d918dfa93" name="TestVisitPatternMultiple" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3a31027b-073e-9561-57e3-9151516bee12" name="TestSingleLevelTree" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b5be33d2-293d-21c7-a6bf-23e2bf9297ca" name="TestInvalidListTree" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e7f94315-3f18-9349-79bb-7139fe7c7bdb" name="TestRepeatsVisit" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6192cafd-d11f-eacc-80ee-457431cdd81e" name="TestSingleNode" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5b94547b-d46b-4772-ddc5-933e0fd18747" name="TestEqualsWithMismatchedText" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="be257587-5a59-73ec-3086-0a867f3683d6" name="TestParseLabels" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="51d9144a-c045-a6e9-827f-4a49483dc6ea" name="TestParseLabelsInNestedTree" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="947031a0-1713-0449-0eb8-24dc6bde9314" name="TestParseFlatTree" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="475153ec-ff20-0100-7cdc-b9d9246b8434" name="TestRepeatsVisit2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="22e31d07-2af3-3a5a-197a-3082886788a2" name="TestRepeatsVisitWithNullParentAndContext" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="34937a46-d3da-48ae-90cb-3bb456d54f4d" name="TestSingleNodeTree" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f254d54c-cb40-2465-cb68-a0a06f7dc401" name="TestNoRepeatsIndex" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="744fac0e-0522-e1c5-465e-7f8652e83653" name="TestParse" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0067793a-133c-e1fb-8d97-66823ce56fe2" name="TestNoRepeatsVisit" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="cac421b0-f901-e8b3-d9a5-add9b79e8126" name="TestDoubleLevelTree" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="bb70a43a-d84c-f341-c872-e4bd43ffed9b" name="TestParseWithText" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5df13e2a-0889-e1f8-ebd3-39e3a79cabb9" name="TestRepeatsIndex" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="860ef752-d476-484d-82d0-873e0ceb0731" name="TestVisitPatternMultipleWithLabels" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b77400c7-c90a-d2ad-d870-5cdf2bf918cd" name="TestEqualsWithText" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a2426e2b-1774-8c78-48cd-6609e1aa8e57" name="TestParseLabelsAndTestText" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7468aeae-c2fe-f82b-1fb0-b5b57e33796b" name="TestParseWithTextFails" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="493f67c3-1b8e-9497-d433-3da0efc0fa88" name="TestVisitPattern" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2cd933e0-218d-ae5a-72d1-22ae6849e098" name="TestWildcard" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="05d48d12-9710-7041-a394-4f785a6e324e" name="TestListTree" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="fa5bb43e-203f-6be5-3b06-c2028994d103" name="TestFindPattern" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2575f8ba-e861-5812-3f37-f6a4f136ea2b" name="TestParseWithWildcardLabels" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
+</TestLists>
\ No newline at end of file
diff --git a/Antlr3.vssscc b/Antlr3.vssscc
new file mode 100644
index 0000000..6cb031b
--- /dev/null
+++ b/Antlr3.vssscc
@@ -0,0 +1,10 @@
+﻿""
+{
+"FILE_VERSION" = "9237"
+"ENLISTMENT_CHOICE" = "NEVER"
+"PROJECT_FILE_RELATIVE_PATH" = ""
+"NUMBER_OF_EXCLUDED_FILES" = "0"
+"ORIGINAL_PROJECT_FILE_PATH" = ""
+"NUMBER_OF_NESTED_PROJECTS" = "0"
+"SOURCE_CONTROL_SETTINGS_PROVIDER" = "PROJECT"
+}
diff --git a/Antlr3/Analysis/ActionLabel.cs b/Antlr3/Analysis/ActionLabel.cs
new file mode 100644
index 0000000..00d5baa
--- /dev/null
+++ b/Antlr3/Analysis/ActionLabel.cs
@@ -0,0 +1,75 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Analysis
+{
+    using Grammar = Antlr3.Tool.Grammar;
+    using GrammarAST = Antlr3.Tool.GrammarAST;
+
+    public class ActionLabel : Label
+    {
+        public GrammarAST actionAST;
+
+        public ActionLabel( GrammarAST actionAST ) :
+            base( ACTION )
+        {
+            this.actionAST = actionAST;
+        }
+
+        public override bool IsEpsilon
+        {
+            get
+            {
+                // we are to be ignored by analysis 'cept for predicates
+                return true;
+            }
+        }
+
+        public override bool IsAction
+        {
+            get
+            {
+                return true;
+            }
+        }
+
+        public override string ToString()
+        {
+            return "{" + actionAST + "}";
+        }
+
+        public override string ToString( Grammar g )
+        {
+            return ToString();
+        }
+    }
+}
diff --git a/Antlr3/Analysis/AnalysisRecursionOverflowException.cs b/Antlr3/Analysis/AnalysisRecursionOverflowException.cs
new file mode 100644
index 0000000..d34b4e5
--- /dev/null
+++ b/Antlr3/Analysis/AnalysisRecursionOverflowException.cs
@@ -0,0 +1,49 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Analysis
+{
+    using Exception = System.Exception;
+
+    /** An NFA configuration context stack overflowed. */
+    public class AnalysisRecursionOverflowException : Exception
+    {
+        public DFAState ovfState;
+        public NFAConfiguration proposedNFAConfiguration;
+
+        public AnalysisRecursionOverflowException( DFAState ovfState, NFAConfiguration proposedNFAConfiguration )
+        {
+            this.ovfState = ovfState;
+            this.proposedNFAConfiguration = proposedNFAConfiguration;
+        }
+    }
+}
diff --git a/Antlr3/Analysis/AnalysisTimeoutException.cs b/Antlr3/Analysis/AnalysisTimeoutException.cs
new file mode 100644
index 0000000..9371b2d
--- /dev/null
+++ b/Antlr3/Analysis/AnalysisTimeoutException.cs
@@ -0,0 +1,47 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Analysis
+{
+    using Exception = System.Exception;
+
+    /** Analysis took too long; bail out of entire DFA construction. */
+    public class AnalysisTimeoutException : Exception
+    {
+        public DFA abortedDFA;
+
+        public AnalysisTimeoutException( DFA abortedDFA )
+        {
+            this.abortedDFA = abortedDFA;
+        }
+    }
+}
diff --git a/Antlr3/Analysis/DFA.cs b/Antlr3/Analysis/DFA.cs
new file mode 100644
index 0000000..2075cc3
--- /dev/null
+++ b/Antlr3/Analysis/DFA.cs
@@ -0,0 +1,1362 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Analysis
+{
+    using System;
+    using System.Collections.Generic;
+    using System.Linq;
+    using Antlr.Runtime.JavaExtensions;
+    using Antlr3.Tool;
+
+    using CodeGenerator = Antlr3.Codegen.CodeGenerator;
+    using IIntSet = Antlr3.Misc.IIntSet;
+    using IIntStream = Antlr.Runtime.IIntStream;
+    using IList = System.Collections.IList;
+    using IntervalSet = Antlr3.Misc.IntervalSet;
+    using StringBuilder = System.Text.StringBuilder;
+    using StringTemplate = Antlr3.ST.StringTemplate;
+
+    /** A DFA (converted from a grammar's NFA).
+     *  DFAs are used as prediction machine for alternative blocks in all kinds
+     *  of recognizers (lexers, parsers, tree walkers).
+     */
+    public class DFA
+    {
+        public const int REACHABLE_UNKNOWN = -2;
+        public const int REACHABLE_BUSY = -1; // in process of computing
+        public const int REACHABLE_NO = 0;
+        public const int REACHABLE_YES = 1;
+
+        /** Prevent explosion of DFA states during conversion. The max number
+         *  of states per alt in a single decision's DFA.
+        public static final int MAX_STATES_PER_ALT_IN_DFA = 450;
+         */
+
+        /** Set to 0 to not terminate early (time in ms) */
+        public static TimeSpan MAX_TIME_PER_DFA_CREATION = TimeSpan.FromSeconds( 1 );
+
+        /** How many edges can each DFA state have before a "special" state
+         *  is created that uses IF expressions instead of a table?
+         */
+        public static int MAX_STATE_TRANSITIONS_FOR_TABLE = 65534;
+
+        /** What's the start state for this DFA? */
+        public DFAState startState;
+
+        /** This DFA is being built for which decision? */
+        public int decisionNumber = 0;
+
+        /** From what NFAState did we create the DFA? */
+        public NFAState decisionNFAStartState;
+
+        /** The printable grammar fragment associated with this DFA */
+        public String description;
+
+        /** A set of all uniquely-numbered DFA states.  Maps hash of DFAState
+         *  to the actual DFAState object.  We use this to detect
+         *  existing DFA states.  Map<DFAState,DFAState>.  Use Map so
+         *  we can get old state back (Set only allows you to see if it's there).
+         *  Not used during fixed k lookahead as it's a waste to fill it with
+         *  a dup of states array.
+         */
+        //protected Map<DFAState, DFAState> uniqueStates = new HashMap<DFAState, DFAState>();
+        protected IDictionary<DFAState, DFAState> uniqueStates = new Dictionary<DFAState, DFAState>();
+
+        /** Maps the state number to the actual DFAState.  Use a Vector as it
+         *  grows automatically when I set the ith element.  This contains all
+         *  states, but the states are not unique.  s3 might be same as s1 so
+         *  s3 -> s1 in this table.  This is how cycles occur.  If fixed k,
+         *  then these states will all be unique as states[i] always points
+         *  at state i when no cycles exist.
+         *
+         *  This is managed in parallel with uniqueStates and simply provides
+         *  a way to go from state number to DFAState rather than via a
+         *  hash lookup.
+         */
+        protected List<DFAState> states = new List<DFAState>();
+
+        /** Unique state numbers per DFA */
+        protected int stateCounter = 0;
+
+        /** count only new states not states that were rejected as already present */
+        protected int numberOfStates = 0;
+
+        /** User specified max fixed lookahead.  If 0, nothing specified.  -1
+         *  implies we have not looked at the options table yet to set k.
+         */
+        protected int user_k = -1;
+
+        /** While building the DFA, track max lookahead depth if not cyclic */
+        protected internal int max_k = -1;
+
+        /** Is this DFA reduced?  I.e., can all states lead to an accept state? */
+        protected bool reduced = true;
+
+        /** Are there any loops in this DFA?
+         *  Computed by doesStateReachAcceptState()
+         */
+        protected bool cyclic = false;
+
+        /** Track whether this DFA has at least one sem/syn pred encountered
+         *  during a closure operation.  This is useful for deciding whether
+         *  to retry a non-LL(*) with k=1.  If no pred, it will not work w/o
+         *  a pred so don't bother.  It would just give another error message.
+         */
+        public bool predicateVisible = false;
+
+        public bool hasPredicateBlockedByAction = false;
+
+        /** Each alt in an NFA derived from a grammar must have a DFA state that
+         *  predicts it lest the parser not know what to do.  Nondeterminisms can
+         *  lead to this situation (assuming no semantic predicates can resolve
+         *  the problem) and when for some reason, I cannot compute the lookahead
+         *  (which might arise from an error in the algorithm or from
+         *  left-recursion etc...).  This list starts out with all alts contained
+         *  and then in method doesStateReachAcceptState() I remove the alts I
+         *  know to be uniquely predicted.
+         */
+        protected List<int> unreachableAlts;
+
+        protected int nAlts = 0;
+
+        /** We only want one accept state per predicted alt; track here */
+        protected DFAState[] altToAcceptState;
+
+        /** Track whether an alt discovers recursion for each alt during
+         *  NFA to DFA conversion; >1 alt with recursion implies nonregular.
+         */
+        public IIntSet recursiveAltSet = new IntervalSet();
+
+        /** Which NFA are we converting (well, which piece of the NFA)? */
+        public NFA nfa;
+
+        protected NFAToDFAConverter nfaConverter;
+
+        /** This probe tells you a lot about a decision and is useful even
+         *  when there is no error such as when a syntactic nondeterminism
+         *  is solved via semantic predicates.  Perhaps a GUI would want
+         *  the ability to show that.
+         */
+        public DecisionProbe probe;
+
+        /** Track absolute time of the conversion so we can have a failsafe:
+         *  if it takes too long, then terminate.  Assume bugs are in the
+         *  analysis engine.
+         */
+        protected internal DateTime conversionStartTime;
+
+        /** Map an edge transition table to a unique set number; ordered so
+         *  we can push into the output template as an ordered list of sets
+         *  and then ref them from within the transition[][] table.  Like this
+         *  for C# target:
+         *     public static readonly DFA30_transition0 =
+         *     	new short[] { 46, 46, -1, 46, 46, -1, -1, -1, -1, -1, -1, -1,...};
+         *         public static readonly DFA30_transition1 =
+         *     	new short[] { 21 };
+         *      public static readonly short[][] DFA30_transition = {
+         *     	  DFA30_transition0,
+         *     	  DFA30_transition0,
+         *     	  DFA30_transition1,
+         *     	  ...
+         *      };
+         */
+        public IDictionary<int[], int?> edgeTransitionClassMap = new Dictionary<int[], int?>();
+
+        /** The unique edge transition class number; every time we see a new
+         *  set of edges emanating from a state, we number it so we can reuse
+         *  if it's every seen again for another state.  For Java grammar,
+         *  some of the big edge transition tables are seen about 57 times.
+         */
+        protected int edgeTransitionClass = 0;
+
+        /* This DFA can be converted to a transition[state][char] table and
+         * the following tables are filled by createStateTables upon request.
+         * These are injected into the templates for code generation.
+         * See March 25, 2006 entry for description:
+         *   http://www.antlr.org/blog/antlr3/codegen.tml
+         * Often using Vector as can't set ith position in a List and have
+         * it extend list size; bizarre.
+         */
+
+        /** List of special DFAState objects */
+        public IList specialStates;
+        /** List of ST for special states. */
+        public IList specialStateSTs;
+        public const int EmptyValue = -1;
+        public int[] accept;
+        public int[] eot;
+        public int[] eof;
+        public int[] min;
+        public int[] max;
+        public int[] special;
+        public int[][] transition;
+        /** just the Vector<Integer> indicating which unique edge table is at
+         *  position i.
+         */
+        public List<int?> transitionEdgeTables; // not used by java yet
+        protected int uniqueCompressedSpecialStateNum = 0;
+
+        /** Which generator to use if we're building state tables */
+        protected CodeGenerator generator = null;
+
+        protected DFA()
+        {
+            probe = new DecisionProbe( this );
+        }
+
+        public DFA( int decisionNumber, NFAState decisionStartState )
+            : this()
+        {
+            this.decisionNumber = decisionNumber;
+            this.decisionNFAStartState = decisionStartState;
+            nfa = decisionStartState.nfa;
+            nAlts = nfa.grammar.getNumberOfAltsForDecisionNFA( decisionStartState );
+            //setOptions( nfa.grammar.getDecisionOptions(getDecisionNumber()) );
+            initAltRelatedInfo();
+
+            //long start = JSystem.currentTimeMillis();
+            nfaConverter = new NFAToDFAConverter( this );
+            try
+            {
+                nfaConverter.convert();
+
+                // figure out if there are problems with decision
+                verify();
+
+                if ( !probe.IsDeterministic || probe.AnalysisOverflowed )
+                {
+                    probe.issueWarnings();
+                }
+
+                // must be after verify as it computes cyclic, needed by this routine
+                // should be after warnings because early termination or something
+                // will not allow the reset to operate properly in some cases.
+                resetStateNumbersToBeContiguous();
+
+                //long stop = JSystem.currentTimeMillis();
+                //JSystem.@out.println("verify cost: "+(int)(stop-start)+" ms");
+            }
+            catch ( AnalysisTimeoutException /*at*/ )
+            {
+                probe.reportAnalysisTimeout();
+                if ( !OkToRetryWithK1 )
+                {
+                    probe.issueWarnings();
+                }
+            }
+            catch ( NonLLStarDecisionException /*nonLL*/ )
+            {
+                probe.reportNonLLStarDecision( this );
+                // >1 alt recurses, k=* and no auto backtrack nor manual sem/syn
+                if ( !OkToRetryWithK1 )
+                {
+                    probe.issueWarnings();
+                }
+            }
+        }
+
+        #region Properties
+        public bool AnalysisTimedOut
+        {
+            get
+            {
+                return analysisTimedOut();
+            }
+        }
+        public bool CanInlineDecision
+        {
+            get
+            {
+                return canInlineDecision();
+            }
+        }
+        public bool AutoBacktrackMode
+        {
+            get
+            {
+                return getAutoBacktrackMode();
+            }
+        }
+        public GrammarAST DecisionASTNode
+        {
+            get
+            {
+                return getDecisionASTNode();
+            }
+        }
+        public int DecisionNumber
+        {
+            get
+            {
+                return getDecisionNumber();
+            }
+        }
+        public string Description
+        {
+            get
+            {
+                return getDescription();
+            }
+        }
+        public bool IsCyclic
+        {
+            get
+            {
+                return isCyclic();
+            }
+        }
+        public bool IsGreedy
+        {
+            get
+            {
+                return isGreedy();
+            }
+        }
+        public bool IsReduced
+        {
+            get
+            {
+                return isReduced();
+            }
+        }
+        public bool IsTokensRuleDecision
+        {
+            get
+            {
+                return isTokensRuleDecision();
+            }
+        }
+        public int MaxLookaheadDepth
+        {
+            get
+            {
+                return getMaxLookaheadDepth();
+            }
+        }
+        public int MaxStateNumber
+        {
+            get
+            {
+                return getMaxStateNumber();
+            }
+        }
+        public NFAState NFADecisionStartState
+        {
+            get
+            {
+                return getNFADecisionStartState();
+            }
+        }
+        public int NumberOfAlts
+        {
+            get
+            {
+                return getNumberOfAlts();
+            }
+        }
+        public int NumberOfStates
+        {
+            get
+            {
+                return getNumberOfStates();
+            }
+        }
+        public bool OkToRetryWithK1
+        {
+            get
+            {
+                return okToRetryDFAWithK1();
+            }
+        }
+        public string ReasonForFailure
+        {
+            get
+            {
+                return getReasonForFailure();
+            }
+        }
+        public IDictionary<DFAState, DFAState> UniqueStates
+        {
+            get
+            {
+                return getUniqueStates();
+            }
+        }
+        public ICollection<int> UnreachableAlts
+        {
+            get
+            {
+                return getUnreachableAlts();
+            }
+        }
+        public int UserMaxLookahead
+        {
+            get
+            {
+                return getUserMaxLookahead();
+            }
+        }
+        #endregion
+
+        /** Walk all states and reset their numbers to be a contiguous sequence
+         *  of integers starting from 0.  Only cyclic DFA can have unused positions
+         *  in states list.  State i might be identical to a previous state j and
+         *  will result in states[i] == states[j].  We don't want to waste a state
+         *  number on this.  Useful mostly for code generation in tables.
+         *
+         *  At the start of this routine, states[i].stateNumber <= i by definition.
+         *  If states[50].stateNumber is 50 then a cycle during conversion may
+         *  try to add state 103, but we find that an identical DFA state, named
+         *  50, already exists, hence, states[103]==states[50] and both have
+         *  stateNumber 50 as they point at same object.  Afterwards, the set
+         *  of state numbers from all states should represent a contiguous range
+         *  from 0..n-1 where n is the number of unique states.
+         */
+        public virtual void resetStateNumbersToBeContiguous()
+        {
+            if ( UserMaxLookahead > 0 )
+            {
+                // all numbers are unique already; no states are thrown out.
+                return;
+            }
+
+            // walk list of DFAState objects by state number,
+            // setting state numbers to 0..n-1
+            int snum = 0;
+            for ( int i = 0; i <= MaxStateNumber; i++ )
+            {
+                DFAState s = getState( i );
+                // some states are unused after creation most commonly due to cycles
+                // or conflict resolution.
+                if ( s == null )
+                {
+                    continue;
+                }
+                // state i is mapped to DFAState with state number set to i originally
+                // so if it's less than i, then we renumbered it already; that
+                // happens when states have been merged or cycles occurred I think.
+                // states[50] will point to DFAState with s50 in it but
+                // states[103] might also point at this same DFAState.  Since
+                // 50 < 103 then it's already been renumbered as it points downwards.
+                bool alreadyRenumbered = s.stateNumber < i;
+                if ( !alreadyRenumbered )
+                {
+                    // state i is a valid state, reset it's state number
+                    s.stateNumber = snum; // rewrite state numbers to be 0..n-1
+                    snum++;
+                }
+            }
+            if ( snum != NumberOfStates )
+            {
+                ErrorManager.internalError( "DFA " + decisionNumber + ": " +
+                    decisionNFAStartState.Description + " num unique states " + NumberOfStates +
+                    "!= num renumbered states " + snum );
+            }
+        }
+
+        // JAVA-SPECIFIC Accessors!!!!!  It is so impossible to get arrays
+        // or even consistently formatted strings acceptable to java that
+        // I am forced to build the individual char elements here
+
+        public virtual List<string> getJavaCompressedAccept()
+        {
+            return getRunLengthEncoding( accept );
+        }
+        public virtual List<string> getJavaCompressedEOT()
+        {
+            return getRunLengthEncoding( eot );
+        }
+        public virtual List<string> getJavaCompressedEOF()
+        {
+            return getRunLengthEncoding( eof );
+        }
+        public virtual List<string> getJavaCompressedMin()
+        {
+            return getRunLengthEncoding( min );
+        }
+        public virtual List<string> getJavaCompressedMax()
+        {
+            return getRunLengthEncoding( max );
+        }
+        public virtual List<string> getJavaCompressedSpecial()
+        {
+            return getRunLengthEncoding( special );
+        }
+        public virtual List<List<string>> getJavaCompressedTransition()
+        {
+            if ( transition == null || transition.Length == 0 )
+            {
+                return null;
+            }
+            List<List<string>> encoded = new List<List<string>>( transition.Length );
+            // walk Vector<Vector<FormattedInteger>> which is the transition[][] table
+            for ( int i = 0; i < transition.Length; i++ )
+            {
+                var transitionsForState = transition[i];
+                encoded.Add( getRunLengthEncoding( transitionsForState ) );
+            }
+            return encoded;
+        }
+
+        /** Compress the incoming data list so that runs of same number are
+         *  encoded as number,value pair sequences.  3 -1 -1 -1 28 is encoded
+         *  as 1 3 3 -1 1 28.  I am pretty sure this is the lossless compression
+         *  that GIF files use.  Transition tables are heavily compressed by
+         *  this technique.  I got the idea from JFlex http://jflex.de/
+         *
+         *  Return List<String> where each string is either \xyz for 8bit char
+         *  and \uFFFF for 16bit.  Hideous and specific to Java, but it is the
+         *  only target bad enough to need it.
+         */
+        public virtual List<string> getRunLengthEncoding( int[] data )
+        {
+            if ( data == null || data.Length == 0 )
+            {
+                // for states with no transitions we want an empty string ""
+                // to hold its place in the transitions array.
+                List<string> empty = new List<string>();
+                empty.Add( "" );
+                return empty;
+            }
+            int size = Math.Max( 2, data.Length / 2 );
+            List<string> encoded = new List<string>( size ); // guess at size
+            // scan values looking for runs
+            int i = 0;
+            while ( i < data.Length )
+            {
+                int I = data[i];
+                //if ( I == null )
+                //{
+                //    I = emptyValue;
+                //}
+
+                // count how many v there are?
+                int n = 0;
+                for ( int j = i; j < data.Length; j++ )
+                {
+                    int v = data[j];
+                    //if ( v == null )
+                    //{
+                    //    v = emptyValue;
+                    //}
+                    if ( I.Equals( v ) )
+                    {
+                        n++;
+                    }
+                    else
+                    {
+                        break;
+                    }
+                }
+                encoded.Add( generator.target.encodeIntAsCharEscape( (char)n ) );
+                encoded.Add( generator.target.encodeIntAsCharEscape( (char)(int)I ) );
+                i += n;
+            }
+            return encoded;
+        }
+
+        public virtual void createStateTables( CodeGenerator generator )
+        {
+            //JSystem.@out.println("createTables:\n"+this);
+            this.generator = generator;
+            description = NFADecisionStartState.Description;
+            description =
+                generator.target.getTargetStringLiteralFromString( description );
+
+            // create all the tables
+            //special = new List<int>( this.NumberOfStates ); // Vector<short>
+            //special.setSize( this.NumberOfStates );
+            special = Enumerable.Repeat( EmptyValue, NumberOfStates ).ToArray();
+            specialStates = new List<object>();				// List<DFAState>
+            specialStateSTs = new List<object>();				// List<ST>
+            //accept = new List<int>( this.NumberOfStates ); // Vector<int>
+            //accept.setSize( this.NumberOfStates );
+            accept = Enumerable.Repeat( EmptyValue, NumberOfStates ).ToArray();
+            //eot = new List<int>( this.NumberOfStates ); // Vector<int>
+            //eot.setSize( this.NumberOfStates );
+            eot = Enumerable.Repeat( EmptyValue, NumberOfStates ).ToArray();
+            //eof = new List<int>( this.NumberOfStates ); // Vector<int>
+            //eof.setSize( this.NumberOfStates );
+            eof = Enumerable.Repeat( EmptyValue, NumberOfStates ).ToArray();
+            //min = new List<int>( this.NumberOfStates ); // Vector<int>
+            //min.setSize( this.NumberOfStates );
+            min = Enumerable.Repeat( EmptyValue, NumberOfStates ).ToArray();
+            //max = new List<int>( this.NumberOfStates ); // Vector<int>
+            //max.setSize( this.NumberOfStates );
+            max = Enumerable.Repeat( EmptyValue, NumberOfStates ).ToArray();
+            transition = new int[NumberOfStates][]; // Vector<Vector<int>>
+            //transition.setSize( this.NumberOfStates );
+            transitionEdgeTables = new List<int?>( this.NumberOfStates ); // Vector<Vector<int>>
+            transitionEdgeTables.setSize( this.NumberOfStates );
+
+            // for each state in the DFA, fill relevant tables.
+            IEnumerable<DFAState> it = null;
+            if ( UserMaxLookahead > 0 )
+            {
+                it = states;
+            }
+            else
+            {
+                it = UniqueStates.Values;
+            }
+            foreach ( DFAState s in it )
+            {
+                if ( s == null )
+                {
+                    // ignore null states; some acylic DFA see this condition
+                    // when inlining DFA (due to lacking of exit branch pruning?)
+                    continue;
+                }
+                if ( s.IsAcceptState )
+                {
+                    // can't compute min,max,special,transition on accepts
+                    accept[s.stateNumber] = s.getUniquelyPredictedAlt();
+                }
+                else
+                {
+                    createMinMaxTables( s );
+                    createTransitionTableEntryForState( s );
+                    createSpecialTable( s );
+                    createEOTAndEOFTables( s );
+                }
+            }
+
+            // now that we have computed list of specialStates, gen code for 'em
+            for ( int i = 0; i < specialStates.Count; i++ )
+            {
+                DFAState ss = (DFAState)specialStates[i];
+                StringTemplate stateST =
+                    generator.generateSpecialState( ss );
+                specialStateSTs.Add( stateST );
+            }
+
+            // check that the tables are not messed up by encode/decode
+            /*
+            testEncodeDecode(min);
+            testEncodeDecode(max);
+            testEncodeDecode(accept);
+            testEncodeDecode(special);
+            JSystem.@out.println("min="+min);
+            JSystem.@out.println("max="+max);
+            JSystem.@out.println("eot="+eot);
+            JSystem.@out.println("eof="+eof);
+            JSystem.@out.println("accept="+accept);
+            JSystem.@out.println("special="+special);
+            JSystem.@out.println("transition="+transition);
+            */
+        }
+
+        /*
+        private void testEncodeDecode(List data) {
+            JSystem.@out.println("data="+data);
+            List encoded = getRunLengthEncoding(data);
+            StringBuffer buf = new StringBuffer();
+            for (int i = 0; i < encoded.size(); i++) {
+                String I = (String)encoded.get(i);
+                int v = 0;
+                if ( I.startsWith("\\u") ) {
+                    v = Integer.parseInt(I.substring(2,I.length()), 16);
+                }
+                else {
+                    v = Integer.parseInt(I.substring(1,I.length()), 8);
+                }
+                buf.append((char)v);
+            }
+            String encodedS = buf.toString();
+            short[] decoded = org.antlr.runtime.DFA.unpackEncodedString(encodedS);
+            //JSystem.@out.println("decoded:");
+            for (int i = 0; i < decoded.length; i++) {
+                short x = decoded[i];
+                if ( x!=((Integer)data.get(i)).intValue() ) {
+                    System.err.println("problem with encoding");
+                }
+                //JSystem.@out.print(", "+x);
+            }
+            //JSystem.@out.println();
+        }
+        */
+
+        protected virtual void createMinMaxTables( DFAState s )
+        {
+            int smin = Label.MAX_CHAR_VALUE + 1;
+            int smax = Label.MIN_ATOM_VALUE - 1;
+            for ( int j = 0; j < s.NumberOfTransitions; j++ )
+            {
+                Transition edge = (Transition)s.transition( j );
+                Label label = edge.label;
+                if ( label.IsAtom )
+                {
+                    if ( label.Atom >= Label.MIN_CHAR_VALUE )
+                    {
+                        if ( label.Atom < smin )
+                        {
+                            smin = label.Atom;
+                        }
+                        if ( label.Atom > smax )
+                        {
+                            smax = label.Atom;
+                        }
+                    }
+                }
+                else if ( label.IsSet )
+                {
+                    IntervalSet labels = (IntervalSet)label.Set;
+                    int lmin = labels.getMinElement();
+                    // if valid char (don't do EOF) and less than current min
+                    if ( lmin < smin && lmin >= Label.MIN_CHAR_VALUE )
+                    {
+                        smin = labels.getMinElement();
+                    }
+                    if ( labels.getMaxElement() > smax )
+                    {
+                        smax = labels.getMaxElement();
+                    }
+                }
+            }
+
+            if ( smax < 0 )
+            {
+                // must be predicates or pure EOT transition; just zero out min, max
+                smin = Label.MIN_CHAR_VALUE;
+                smax = Label.MIN_CHAR_VALUE;
+            }
+
+            min[s.stateNumber] = (char)smin;
+            max[s.stateNumber] = (char)smax;
+
+            if ( smax < 0 || smin > Label.MAX_CHAR_VALUE || smin < 0 )
+            {
+                ErrorManager.internalError( "messed up: min=" + min + ", max=" + max );
+            }
+        }
+
+        protected virtual void createTransitionTableEntryForState( DFAState s )
+        {
+            /*
+            JSystem.@out.println("createTransitionTableEntryForState s"+s.stateNumber+
+                " dec "+s.dfa.decisionNumber+" cyclic="+s.dfa.isCyclic());
+                */
+            int smax = max[s.stateNumber];
+            int smin = min[s.stateNumber];
+
+            int[] stateTransitions = new int[smax - smin + 1];
+            for ( int i = 0; i < stateTransitions.Length; i++ )
+                stateTransitions[i] = EmptyValue;
+
+            transition[s.stateNumber] = stateTransitions;
+            for ( int j = 0; j < s.NumberOfTransitions; j++ )
+            {
+                Transition edge = s.transition( j );
+                Label label = edge.label;
+                if ( label.IsAtom && label.Atom >= Label.MIN_CHAR_VALUE )
+                {
+                    int labelIndex = label.Atom - smin; // offset from 0
+                    stateTransitions[labelIndex] = edge.target.stateNumber;
+                }
+                else if ( label.IsSet )
+                {
+                    foreach ( var interval in ((IntervalSet)label.Set).Intervals )
+                    {
+                        for ( int i = Math.Max( interval.a, Label.MIN_CHAR_VALUE ); i <= interval.b; i++ )
+                        {
+                            stateTransitions[i - smin] = edge.target.stateNumber;
+                        }
+                    }
+                }
+            }
+            // track unique state transition tables so we can reuse
+            int? edgeClass; // = edgeTransitionClassMap.get( stateTransitions );
+            if ( edgeTransitionClassMap.TryGetValue( stateTransitions, out edgeClass ) && edgeClass != null )
+            {
+                //JSystem.@out.println("we've seen this array before; size="+stateTransitions.size());
+                transitionEdgeTables[s.stateNumber] = edgeClass;
+            }
+            else
+            {
+                edgeClass = edgeTransitionClass;
+                transitionEdgeTables[s.stateNumber] = edgeClass;
+                edgeTransitionClassMap[stateTransitions] = edgeClass;
+                edgeTransitionClass++;
+            }
+        }
+
+        /** Set up the EOT and EOF tables; we cannot put -1 min/max values so
+         *  we need another way to test that in the DFA transition function.
+         */
+        protected virtual void createEOTAndEOFTables( DFAState s )
+        {
+            for ( int j = 0; j < s.NumberOfTransitions; j++ )
+            {
+                Transition edge = s.transition( j );
+                Label label = edge.label;
+                if ( label.IsAtom )
+                {
+                    if ( label.Atom == Label.EOT )
+                    {
+                        // eot[s] points to accept state
+                        eot[s.stateNumber] = edge.target.stateNumber;
+                    }
+                    else if ( label.Atom == Label.EOF )
+                    {
+                        // eof[s] points to accept state
+                        eof[s.stateNumber] = edge.target.stateNumber;
+                    }
+                }
+                else if ( label.IsSet )
+                {
+                    if ( label.Set.member( Label.EOT ) )
+                    {
+                        eot[s.stateNumber] = edge.target.stateNumber;
+                    }
+
+                    if ( label.Set.member( Label.EOF ) )
+                    {
+                        eof[s.stateNumber] = edge.target.stateNumber;
+                    }
+                }
+            }
+        }
+
+        protected virtual void createSpecialTable( DFAState s )
+        {
+            // number all special states from 0...n-1 instead of their usual numbers
+            bool hasSemPred = false;
+
+            // TODO this code is very similar to canGenerateSwitch.  Refactor to share
+            for ( int j = 0; j < s.NumberOfTransitions; j++ )
+            {
+                Transition edge = (Transition)s.transition( j );
+                Label label = edge.label;
+                // can't do a switch if the edges have preds or are going to
+                // require gated predicates
+                if ( label.IsSemanticPredicate ||
+                     ( (DFAState)edge.target ).getGatedPredicatesInNFAConfigurations() != null )
+                {
+                    hasSemPred = true;
+                    break;
+                }
+            }
+            // if has pred or too big for table, make it special
+            int smax = max[s.stateNumber];
+            int smin = min[s.stateNumber];
+            if ( hasSemPred || smax - smin > MAX_STATE_TRANSITIONS_FOR_TABLE )
+            {
+                special[s.stateNumber] = uniqueCompressedSpecialStateNum;
+                uniqueCompressedSpecialStateNum++;
+                specialStates.Add( s );
+            }
+            else
+            {
+                special[s.stateNumber] = EmptyValue; // not special
+            }
+        }
+
+        public virtual int predict( IIntStream input )
+        {
+            Interpreter interp = new Interpreter( nfa.grammar, input );
+            return interp.predict( this );
+        }
+
+        /** Add a new DFA state to this DFA if not already present.
+         *  To force an acyclic, fixed maximum depth DFA, just always
+         *  return the incoming state.  By not reusing old states,
+         *  no cycles can be created.  If we're doing fixed k lookahead
+         *  don't updated uniqueStates, just return incoming state, which
+         *  indicates it's a new state.
+         */
+        protected internal virtual DFAState addState( DFAState d )
+        {
+            if ( UserMaxLookahead > 0 )
+            {
+                return d;
+            }
+            // does a DFA state exist already with everything the same
+            // except its state number?
+            DFAState existing = (DFAState)uniqueStates.get( d );
+            if ( existing != null )
+            {
+                /*
+                JSystem.@out.println("state "+d.stateNumber+" exists as state "+
+                    existing.stateNumber);
+                    */
+                // already there...get the existing DFA state
+                return existing;
+            }
+
+            // if not there, then add new state.
+            uniqueStates[d] = d;
+            numberOfStates++;
+            return d;
+        }
+
+        public void removeState( DFAState d )
+        {
+            DFAState it;
+            if ( uniqueStates.TryGetValue( d, out it ) )
+            {
+                uniqueStates.Remove( d );
+                if ( it != null )
+                {
+                    numberOfStates--;
+                }
+            }
+        }
+
+        public IDictionary<DFAState, DFAState> getUniqueStates()
+        {
+            return uniqueStates;
+        }
+
+        /** What is the max state number ever created?  This may be beyond
+         *  getNumberOfStates().
+         */
+        public int getMaxStateNumber()
+        {
+            return states.Count - 1;
+        }
+
+        public virtual DFAState getState( int stateNumber )
+        {
+            return (DFAState)states[stateNumber];
+        }
+
+        public virtual void setState( int stateNumber, DFAState d )
+        {
+            states[stateNumber] = d;
+        }
+
+        /** Is the DFA reduced?  I.e., does every state have a path to an accept
+         *  state?  If not, don't delete as we need to generate an error indicating
+         *  which paths are "dead ends".  Also tracks list of alts with no accept
+         *  state in the DFA.  Must call verify() first before this makes sense.
+         */
+        public virtual bool isReduced()
+        {
+            return reduced;
+        }
+
+        /** Is this DFA cyclic?  That is, are there any loops?  If not, then
+         *  the DFA is essentially an LL(k) predictor for some fixed, max k value.
+         *  We can build a series of nested IF statements to match this.  In the
+         *  presence of cycles, we need to build a general DFA and interpret it
+         *  to distinguish between alternatives.
+         */
+        public virtual bool isCyclic()
+        {
+            return cyclic && UserMaxLookahead == 0;
+        }
+
+        public virtual bool canInlineDecision()
+        {
+            return !IsCyclic &&
+                !probe.IsNonLLStarDecision &&
+                NumberOfStates < CodeGenerator.MAX_ACYCLIC_DFA_STATES_INLINE;
+        }
+
+        /** Is this DFA derived from the NFA for the Tokens rule? */
+        public virtual bool isTokensRuleDecision()
+        {
+            if ( nfa.grammar.type != Grammar.LEXER )
+            {
+                return false;
+            }
+            NFAState nfaStart = NFADecisionStartState;
+            Rule r = nfa.grammar.getLocallyDefinedRule( Grammar.ARTIFICIAL_TOKENS_RULENAME );
+            NFAState TokensRuleStart = r.startState;
+            NFAState TokensDecisionStart =
+                (NFAState)TokensRuleStart.transition[0].target;
+            return nfaStart == TokensDecisionStart;
+        }
+
+        /** The user may specify a max, acyclic lookahead for any decision.  No
+         *  DFA cycles are created when this value, k, is greater than 0.
+         *  If this decision has no k lookahead specified, then try the grammar.
+         */
+        public virtual int getUserMaxLookahead()
+        {
+            if ( user_k >= 0 )
+            { // cache for speed
+                return user_k;
+            }
+            user_k = nfa.grammar.getUserMaxLookahead( decisionNumber );
+            return user_k;
+        }
+
+        public virtual bool getAutoBacktrackMode()
+        {
+            return nfa.grammar.getAutoBacktrackMode( decisionNumber );
+        }
+
+        public virtual void setUserMaxLookahead( int k )
+        {
+            this.user_k = k;
+        }
+
+        /** Return k if decision is LL(k) for some k else return max int */
+        public virtual int getMaxLookaheadDepth()
+        {
+            if ( IsCyclic )
+            {
+                return int.MaxValue;
+            }
+            return max_k;
+        }
+
+        /** Return a list of Integer alt numbers for which no lookahead could
+         *  be computed or for which no single DFA accept state predicts those
+         *  alts.  Must call verify() first before this makes sense.
+         */
+        public virtual List<int> getUnreachableAlts()
+        {
+            return unreachableAlts;
+        }
+
+        /** Once this DFA has been built, need to verify that:
+         *
+         *  1. it's reduced
+         *  2. all alts have an accept state
+         *
+         *  Elsewhere, in the NFA converter, we need to verify that:
+         *
+         *  3. alts i and j have disjoint lookahead if no sem preds
+         *  4. if sem preds, nondeterministic alts must be sufficiently covered
+         *
+         *  This is avoided if analysis bails out for any reason.
+         */
+        public virtual void verify()
+        {
+            doesStateReachAcceptState( startState );
+        }
+
+        /** figure out if this state eventually reaches an accept state and
+         *  modify the instance variable 'reduced' to indicate if we find
+         *  at least one state that cannot reach an accept state.  This implies
+         *  that the overall DFA is not reduced.  This algorithm should be
+         *  linear in the number of DFA states.
+         *
+         *  The algorithm also tracks which alternatives have no accept state,
+         *  indicating a nondeterminism.
+         *
+         *  Also computes whether the DFA is cyclic.
+         *
+         *  TODO: I call getUniquelyPredicatedAlt too much; cache predicted alt
+         */
+        protected virtual bool doesStateReachAcceptState( DFAState d )
+        {
+            if ( d.IsAcceptState )
+            {
+                // accept states have no edges emanating from them so we can return
+                d.setAcceptStateReachable( REACHABLE_YES );
+                // this alt is uniquely predicted, remove from nondeterministic list
+                int predicts = d.getUniquelyPredictedAlt();
+                unreachableAlts.Remove( predicts );
+                return true;
+            }
+
+            // avoid infinite loops
+            d.setAcceptStateReachable( REACHABLE_BUSY );
+
+            bool anEdgeReachesAcceptState = false;
+            // Visit every transition, track if at least one edge reaches stop state
+            // Cannot terminate when we know this state reaches stop state since
+            // all transitions must be traversed to set status of each DFA state.
+            for ( int i = 0; i < d.NumberOfTransitions; i++ )
+            {
+                Transition t = d.transition( i );
+                DFAState edgeTarget = (DFAState)t.target;
+                int targetStatus = edgeTarget.AcceptStateReachable;
+                if ( targetStatus == REACHABLE_BUSY )
+                { // avoid cycles; they say nothing
+                    cyclic = true;
+                    continue;
+                }
+                if ( targetStatus == REACHABLE_YES )
+                { // avoid unnecessary work
+                    anEdgeReachesAcceptState = true;
+                    continue;
+                }
+                if ( targetStatus == REACHABLE_NO )
+                {  // avoid unnecessary work
+                    continue;
+                }
+                // target must be REACHABLE_UNKNOWN (i.e., unvisited)
+                if ( doesStateReachAcceptState( edgeTarget ) )
+                {
+                    anEdgeReachesAcceptState = true;
+                    // have to keep looking so don't break loop
+                    // must cover all states even if we find a path for this state
+                }
+            }
+            if ( anEdgeReachesAcceptState )
+            {
+                d.setAcceptStateReachable( REACHABLE_YES );
+            }
+            else
+            {
+                d.setAcceptStateReachable( REACHABLE_NO );
+                reduced = false;
+            }
+            return anEdgeReachesAcceptState;
+        }
+
+        /** Walk all accept states and find the manually-specified synpreds.
+         *  Gated preds are not always hoisted
+         *  I used to do this in the code generator, but that is too late.
+         *  This converter tries to avoid computing DFA for decisions in
+         *  syntactic predicates that are not ever used such as those
+         *  created by autobacktrack mode.
+         */
+        public virtual void findAllGatedSynPredsUsedInDFAAcceptStates()
+        {
+            int nAlts = NumberOfAlts;
+            for ( int i = 1; i <= nAlts; i++ )
+            {
+                DFAState a = getAcceptState( i );
+                //JSystem.@out.println("alt "+i+": "+a);
+                if ( a != null )
+                {
+                    HashSet<SemanticContext> synpreds = a.getGatedSyntacticPredicatesInNFAConfigurations();
+                    if ( synpreds != null )
+                    {
+                        // add all the predicates we find (should be just one, right?)
+                        foreach ( SemanticContext semctx in synpreds )
+                        {
+                            // JSystem.@out.println("synpreds: "+semctx);
+                            nfa.grammar.synPredUsedInDFA( this, semctx );
+                        }
+                    }
+                }
+            }
+        }
+
+        public virtual NFAState getNFADecisionStartState()
+        {
+            return decisionNFAStartState;
+        }
+
+        public virtual DFAState getAcceptState( int alt )
+        {
+            return altToAcceptState[alt];
+        }
+
+        public virtual void setAcceptState( int alt, DFAState acceptState )
+        {
+            altToAcceptState[alt] = acceptState;
+        }
+
+        public virtual String getDescription()
+        {
+            return description;
+        }
+
+        public virtual int getDecisionNumber()
+        {
+            return decisionNFAStartState.DecisionNumber;
+        }
+
+        /** If this DFA failed to finish during construction, we might be
+         *  able to retry with k=1 but we need to know whether it will
+         *  potentially succeed.  Can only succeed if there is a predicate
+         *  to resolve the issue.  Don't try if k=1 already as it would
+         *  cycle forever.  Timeout can retry with k=1 even if no predicate
+         *  if k!=1.
+         */
+        public virtual bool okToRetryDFAWithK1()
+        {
+            bool nonLLStarOrOverflowAndPredicateVisible =
+                ( probe.IsNonLLStarDecision || probe.AnalysisOverflowed ) &&
+                predicateVisible; // auto backtrack or manual sem/syn
+            return UserMaxLookahead != 1 &&
+                 ( AnalysisTimedOut || nonLLStarOrOverflowAndPredicateVisible );
+        }
+
+        public virtual String getReasonForFailure()
+        {
+            StringBuilder buf = new StringBuilder();
+            if ( probe.IsNonLLStarDecision )
+            {
+                buf.Append( "non-LL(*)" );
+                if ( predicateVisible )
+                {
+                    buf.Append( " && predicate visible" );
+                }
+            }
+            if ( probe.AnalysisOverflowed )
+            {
+                buf.Append( "recursion overflow" );
+                if ( predicateVisible )
+                {
+                    buf.Append( " && predicate visible" );
+                }
+            }
+            if ( AnalysisTimedOut )
+            {
+                if ( buf.Length > 0 )
+                {
+                    buf.Append( " && " );
+                }
+                buf.Append( "timed out (>" );
+                buf.Append( DFA.MAX_TIME_PER_DFA_CREATION );
+                buf.Append( "ms)" );
+            }
+            buf.Append( "\n" );
+            return buf.ToString();
+        }
+
+        /** What GrammarAST node (derived from the grammar) is this DFA
+         *  associated with?  It will point to the start of a block or
+         *  the loop back of a (...)+ block etc...
+         */
+        public virtual GrammarAST getDecisionASTNode()
+        {
+            return decisionNFAStartState.associatedASTNode;
+        }
+
+        public virtual bool isGreedy()
+        {
+            GrammarAST blockAST = nfa.grammar.getDecisionBlockAST( decisionNumber );
+            Object v = nfa.grammar.getBlockOption( blockAST, "greedy" );
+            if ( v != null && v.Equals( "false" ) )
+            {
+                return false;
+            }
+            return true;
+
+        }
+
+        public virtual DFAState newState()
+        {
+            DFAState n = new DFAState( this );
+            n.stateNumber = stateCounter;
+            stateCounter++;
+            states.setSize( n.stateNumber + 1 );
+            states[n.stateNumber] = n; // track state num to state
+            return n;
+        }
+
+        public virtual int getNumberOfStates()
+        {
+            if ( UserMaxLookahead > 0 )
+            {
+                // if using fixed lookahead then uniqueSets not set
+                return states.Count;
+            }
+            return numberOfStates;
+        }
+
+        public virtual int getNumberOfAlts()
+        {
+            return nAlts;
+        }
+
+        public virtual bool analysisTimedOut()
+        {
+            return probe.AnalysisTimedOut;
+        }
+
+        protected virtual void initAltRelatedInfo()
+        {
+            unreachableAlts = new List<int>();
+            for ( int i = 1; i <= nAlts; i++ )
+            {
+                unreachableAlts.Add( i );
+            }
+            altToAcceptState = new DFAState[nAlts + 1];
+        }
+
+        public override string ToString()
+        {
+            FASerializer serializer = new FASerializer( nfa.grammar );
+            if ( startState == null )
+            {
+                return "";
+            }
+            return serializer.serialize( startState, false );
+        }
+
+        /** EOT (end of token) is a label that indicates when the DFA conversion
+         *  algorithm would "fall off the end of a lexer rule".  It normally
+         *  means the default clause.  So for ('a'..'z')+ you would see a DFA
+         *  with a state that has a..z and EOT emanating from it.  a..z would
+         *  jump to a state predicting alt 1 and EOT would jump to a state
+         *  predicting alt 2 (the exit loop branch).  EOT implies anything other
+         *  than a..z.  If for some reason, the set is "all char" such as with
+         *  the wildcard '.', then EOT cannot match anything.  For example,
+         *
+         *     BLOCK : '{' (.)* '}'
+         *
+         *  consumes all char until EOF when greedy=true.  When all edges are
+         *  combined for the DFA state after matching '}', you will find that
+         *  it is all char.  The EOT transition has nothing to match and is
+         *  unreachable.  The findNewDFAStatesAndAddDFATransitions() method
+         *  must know to ignore the EOT, so we simply remove it from the
+         *  reachable labels.  Later analysis will find that the exit branch
+         *  is not predicted by anything.  For greedy=false, we leave only
+         *  the EOT label indicating that the DFA should stop immediately
+         *  and predict the exit branch. The reachable labels are often a
+         *  set of disjoint values like: [<EOT>, 42, {0..41, 43..65534}]
+         *  due to DFA conversion so must construct a pure set to see if
+         *  it is same as Label.ALLCHAR.
+         *
+         *  Only do this for Lexers.
+         *
+         *  If EOT coexists with ALLCHAR:
+         *  1. If not greedy, modify the labels parameter to be EOT
+         *  2. If greedy, remove EOT from the labels set
+        protected boolean reachableLabelsEOTCoexistsWithAllChar(OrderedHashSet labels)
+        {
+            Label eot = new Label(Label.EOT);
+            if ( !labels.containsKey(eot) ) {
+                return false;
+            }
+            JSystem.@out.println("### contains EOT");
+            boolean containsAllChar = false;
+            IntervalSet completeVocab = new IntervalSet();
+            int n = labels.size();
+            for (int i=0; i<n; i++) {
+                Label rl = (Label)labels.get(i);
+                if ( !rl.equals(eot) ) {
+                    completeVocab.addAll(rl.getSet());
+                }
+            }
+            JSystem.@out.println("completeVocab="+completeVocab);
+            if ( completeVocab.equals(Label.ALLCHAR) ) {
+                JSystem.@out.println("all char");
+                containsAllChar = true;
+            }
+            return containsAllChar;
+        }
+         */
+    }
+
+}
diff --git a/Antlr3/Analysis/DFAOptimizer.cs b/Antlr3/Analysis/DFAOptimizer.cs
new file mode 100644
index 0000000..49b909d
--- /dev/null
+++ b/Antlr3/Analysis/DFAOptimizer.cs
@@ -0,0 +1,281 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Analysis
+{
+    using System.Collections.Generic;
+
+    using Grammar = Antlr3.Tool.Grammar;
+
+    /** A module to perform optimizations on DFAs.
+     *
+     *  I could more easily (and more quickly) do some optimizations (such as
+     *  PRUNE_EBNF_EXIT_BRANCHES) during DFA construction, but then it
+     *  messes up the determinism checking.  For example, it looks like
+     *  loop exit branches are unreachable if you prune exit branches
+     *  during DFA construction and before determinism checks.
+     *
+     *  In general, ANTLR's NFA->DFA->codegen pipeline seems very robust
+     *  to me which I attribute to a uniform and consistent set of data
+     *  structures.  Regardless of what I want to "say"/implement, I do so
+     *  within the confines of, for example, a DFA.  The code generator
+     *  can then just generate code--it doesn't have to do much thinking.
+     *  Putting optimizations in the code gen code really starts to make
+     *  it a spagetti factory (uh oh, now I'm hungry!).  The pipeline is
+     *  very testable; each stage has well defined input/output pairs.
+     *
+     *  ### Optimization: PRUNE_EBNF_EXIT_BRANCHES
+     *
+     *  There is no need to test EBNF block exit branches.  Not only is it
+     *  an unneeded computation, but counter-intuitively, you actually get
+     *  better errors. You can report an error at the missing or extra
+     *  token rather than as soon as you've figured out you will fail.
+     *
+     *  Imagine optional block "( DOT CLASS )? SEMI".  ANTLR generates:
+     *
+     *  int alt=0;
+     *  if ( input.LA(1)==DOT ) {
+     *      alt=1;
+     *  }
+     *  else if ( input.LA(1)==SEMI ) {
+     *      alt=2;
+     *  }
+     *
+     *  Clearly, since Parser.match() will ultimately find the error, we
+     *  do not want to report an error nor do we want to bother testing
+     *  lookahead against what follows the (...)?  We want to generate
+     *  simply "should I enter the subrule?":
+     *
+     *  int alt=2;
+     *  if ( input.LA(1)==DOT ) {
+     *      alt=1;
+     *  }
+     *
+     *  NOTE 1. Greedy loops cannot be optimized in this way.  For example,
+     *  "(greedy=false:'x'|.)* '\n'".  You specifically need the exit branch
+     *  to tell you when to terminate the loop as the same input actually
+     *  predicts one of the alts (i.e., staying in the loop).
+     *
+     *  NOTE 2.  I do not optimize cyclic DFAs at the moment as it doesn't
+     *  seem to work. ;)  I'll have to investigate later to see what work I
+     *  can do on cyclic DFAs to make them have fewer edges.  Might have
+     *  something to do with the EOT token.
+     *
+     *  ### PRUNE_SUPERFLUOUS_EOT_EDGES
+     *
+     *  When a token is a subset of another such as the following rules, ANTLR
+     *  quietly assumes the first token to resolve the ambiguity.
+     *
+     *  EQ			: '=' ;
+     *  ASSIGNOP	: '=' | '+=' ;
+     *
+     *  It can yield states that have only a single edge on EOT to an accept
+     *  state.  This is a waste and messes up my code generation. ;)  If
+     *  Tokens rule DFA goes
+     *
+     * 		s0 -'='-> s3 -EOT-> s5 (accept)
+     *
+     *  then s5 should be pruned and s3 should be made an accept.  Do NOT do this
+     *  for keyword versus ID as the state with EOT edge emanating from it will
+     *  also have another edge.
+     *
+     *  ### Optimization: COLLAPSE_ALL_INCIDENT_EDGES
+     *
+     *  Done during DFA construction.  See method addTransition() in
+     *  NFAToDFAConverter.
+     *
+     *  ### Optimization: MERGE_STOP_STATES
+     *
+     *  Done during DFA construction.  See addDFAState() in NFAToDFAConverter.
+     */
+    public class DFAOptimizer
+    {
+        public static bool PRUNE_EBNF_EXIT_BRANCHES = true;
+        public static bool PRUNE_TOKENS_RULE_SUPERFLUOUS_EOT_EDGES = true;
+        public static bool COLLAPSE_ALL_PARALLEL_EDGES = true;
+        public static bool MERGE_STOP_STATES = true;
+
+        /** Used by DFA state machine generator to avoid infinite recursion
+         *  resulting from cycles int the DFA.  This is a set of int state #s.
+         *  This is a side-effect of calling optimize; can't clear after use
+         *  because code gen needs it.
+         */
+        protected HashSet<object> visited = new HashSet<object>();
+
+        protected Grammar grammar;
+
+        public DFAOptimizer( Grammar grammar )
+        {
+            this.grammar = grammar;
+        }
+
+        public virtual void optimize()
+        {
+            // optimize each DFA in this grammar
+            for ( int decisionNumber = 1;
+                 decisionNumber <= grammar.NumberOfDecisions;
+                 decisionNumber++ )
+            {
+                DFA dfa = grammar.getLookaheadDFA( decisionNumber );
+                optimize( dfa );
+            }
+        }
+
+        protected virtual void optimize( DFA dfa )
+        {
+            if ( dfa == null )
+            {
+                return; // nothing to do
+            }
+            /*
+            JSystem.@out.println("Optimize DFA "+dfa.decisionNFAStartState.decisionNumber+
+                               " num states="+dfa.getNumberOfStates());
+            */
+            //long start = JSystem.currentTimeMillis();
+            if ( PRUNE_EBNF_EXIT_BRANCHES && dfa.CanInlineDecision )
+            {
+                visited.Clear();
+                int decisionType =
+                    dfa.NFADecisionStartState.decisionStateType;
+                if ( dfa.IsGreedy &&
+                     ( decisionType == NFAState.OPTIONAL_BLOCK_START ||
+                     decisionType == NFAState.LOOPBACK ) )
+                {
+                    optimizeExitBranches( dfa.startState );
+                }
+            }
+            // If the Tokens rule has syntactically ambiguous rules, try to prune
+            if ( PRUNE_TOKENS_RULE_SUPERFLUOUS_EOT_EDGES &&
+                 dfa.IsTokensRuleDecision &&
+                 dfa.probe.stateToSyntacticallyAmbiguousTokensRuleAltsMap.Count > 0 )
+            {
+                visited.Clear();
+                optimizeEOTBranches( dfa.startState );
+            }
+
+            /* ack...code gen needs this, cannot optimize
+            visited.clear();
+            unlinkUnneededStateData(dfa.startState);
+            */
+            //long stop = JSystem.currentTimeMillis();
+            //JSystem.@out.println("minimized in "+(int)(stop-start)+" ms");
+        }
+
+        protected virtual void optimizeExitBranches( DFAState d )
+        {
+            int sI = d.stateNumber;
+            if ( visited.Contains( sI ) )
+            {
+                return; // already visited
+            }
+            visited.Add( sI );
+            int nAlts = d.dfa.NumberOfAlts;
+            for ( int i = 0; i < d.NumberOfTransitions; i++ )
+            {
+                Transition edge = (Transition)d.transition( i );
+                DFAState edgeTarget = ( (DFAState)edge.target );
+                /*
+                JSystem.@out.println(d.stateNumber+"-"+
+                                   edge.label.toString(d.dfa.nfa.grammar)+"->"+
+                                   edgeTarget.stateNumber);
+                */
+                // if target is an accept state and that alt is the exit alt
+                if ( edgeTarget.IsAcceptState &&
+                    edgeTarget.getUniquelyPredictedAlt() == nAlts )
+                {
+                    /*
+                    JSystem.@out.println("ignoring transition "+i+" to max alt "+
+                        d.dfa.getNumberOfAlts());
+                    */
+                    d.removeTransition( i );
+                    i--; // back up one so that i++ of loop iteration stays within bounds
+                }
+                optimizeExitBranches( edgeTarget );
+            }
+        }
+
+        protected virtual void optimizeEOTBranches( DFAState d )
+        {
+            int sI = d.stateNumber;
+            if ( visited.Contains( sI ) )
+            {
+                return; // already visited
+            }
+            visited.Add( sI );
+            for ( int i = 0; i < d.NumberOfTransitions; i++ )
+            {
+                Transition edge = (Transition)d.transition( i );
+                DFAState edgeTarget = ( (DFAState)edge.target );
+                /*
+                JSystem.@out.println(d.stateNumber+"-"+
+                                   edge.label.toString(d.dfa.nfa.grammar)+"->"+
+                                   edgeTarget.stateNumber);
+                */
+                // if only one edge coming out, it is EOT, and target is accept prune
+                if ( PRUNE_TOKENS_RULE_SUPERFLUOUS_EOT_EDGES &&
+                    edgeTarget.IsAcceptState &&
+                    d.NumberOfTransitions == 1 &&
+                    edge.label.IsAtom &&
+                    edge.label.Atom == Label.EOT )
+                {
+                    //JSystem.@out.println("state "+d+" can be pruned");
+                    // remove the superfluous EOT edge
+                    d.removeTransition( i );
+                    d.IsAcceptState = true; // make it an accept state
+                    // force it to uniquely predict the originally predicted state
+                    d.cachedUniquelyPredicatedAlt =
+                        edgeTarget.getUniquelyPredictedAlt();
+                    i--; // back up one so that i++ of loop iteration stays within bounds
+                }
+                optimizeEOTBranches( edgeTarget );
+            }
+        }
+
+        /** Walk DFA states, unlinking the nfa configs and whatever else I
+         *  can to reduce memory footprint.
+        protected void unlinkUnneededStateData(DFAState d) {
+            Integer sI = Utils.integer(d.stateNumber);
+            if ( visited.contains(sI) ) {
+                return; // already visited
+            }
+            visited.add(sI);
+            d.nfaConfigurations = null;
+            for (int i = 0; i < d.getNumberOfTransitions(); i++) {
+                Transition edge = (Transition) d.transition(i);
+                DFAState edgeTarget = ((DFAState)edge.target);
+                unlinkUnneededStateData(edgeTarget);
+            }
+        }
+         */
+
+    }
+}
diff --git a/Antlr3/Analysis/DFAState.cs b/Antlr3/Analysis/DFAState.cs
new file mode 100644
index 0000000..3eac4f2
--- /dev/null
+++ b/Antlr3/Analysis/DFAState.cs
@@ -0,0 +1,922 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Analysis
+{
+    using System;
+    using System.Collections.Generic;
+    using System.Linq;
+    using Antlr.Runtime.JavaExtensions;
+    using Antlr3.Misc;
+
+    using Grammar = Antlr3.Tool.Grammar;
+    using StringBuilder = System.Text.StringBuilder;
+
+    /** A DFA state represents a set of possible NFA configurations.
+     *  As Aho, Sethi, Ullman p. 117 says "The DFA uses its state
+     *  to keep track of all possible states the NFA can be in after
+     *  reading each input symbol.  That is to say, after reading
+     *  input a1a2..an, the DFA is in a state that represents the
+     *  subset T of the states of the NFA that are reachable from the
+     *  NFA's start state along some path labeled a1a2..an."
+     *  In conventional NFA->DFA conversion, therefore, the subset T
+     *  would be a bitset representing the set of states the
+     *  NFA could be in.  We need to track the alt predicted by each
+     *  state as well, however.  More importantly, we need to maintain
+     *  a stack of states, tracking the closure operations as they
+     *  jump from rule to rule, emulating rule invocations (method calls).
+     *  Recall that NFAs do not normally have a stack like a pushdown-machine
+     *  so I have to add one to simulate the proper lookahead sequences for
+     *  the underlying LL grammar from which the NFA was derived.
+     *
+     *  I use a list of NFAConfiguration objects.  An NFAConfiguration
+     *  is both a state (ala normal conversion) and an NFAContext describing
+     *  the chain of rules (if any) followed to arrive at that state.  There
+     *  is also the semantic context, which is the "set" of predicates found
+     *  on the path to this configuration.
+     *
+     *  A DFA state may have multiple references to a particular state,
+     *  but with different NFAContexts (with same or different alts)
+     *  meaning that state was reached via a different set of rule invocations.
+     */
+    public class DFAState : State
+    {
+        public const int INITIAL_NUM_TRANSITIONS = 4;
+        public const int PREDICTED_ALT_UNSET = NFA.INVALID_ALT_NUMBER - 1;
+
+        /** We are part of what DFA?  Use this ref to get access to the
+         *  context trees for an alt.
+         */
+        public DFA dfa;
+
+        /** Track the transitions emanating from this DFA state.  The List
+         *  elements are Transition objects.
+         */
+        protected IList<Transition> transitions =
+            new List<Transition>( INITIAL_NUM_TRANSITIONS );
+
+        /** When doing an acyclic DFA, this is the number of lookahead symbols
+         *  consumed to reach this state.  This value may be nonzero for most
+         *  dfa states, but it is only a valid value if the user has specified
+         *  a max fixed lookahead.
+         */
+        protected internal int k;
+
+        /** The NFA->DFA algorithm may terminate leaving some states
+         *  without a path to an accept state, implying that upon certain
+         *  input, the decision is not deterministic--no decision about
+         *  predicting a unique alternative can be made.  Recall that an
+         *  accept state is one in which a unique alternative is predicted.
+         */
+        protected int acceptStateReachable = DFA.REACHABLE_UNKNOWN;
+
+        /** Rather than recheck every NFA configuration in a DFA state (after
+         *  resolving) in findNewDFAStatesAndAddDFATransitions just check
+         *  this boolean.  Saves a linear walk perhaps DFA state creation.
+         *  Every little bit helps.
+         */
+        protected internal bool resolvedWithPredicates = false;
+
+        /** If a closure operation finds that we tried to invoke the same
+         *  rule too many times (stack would grow beyond a threshold), it
+         *  marks the state has aborted and notifies the DecisionProbe.
+         */
+        public bool abortedDueToRecursionOverflow = false;
+
+        /** If we detect recursion on more than one alt, decision is non-LL(*),
+         *  but try to isolate it to only those states whose closure operations
+         *  detect recursion.  There may be other alts that are cool:
+         *
+         *  a : recur '.'
+         *    | recur ';'
+         *    | X Y  // LL(2) decision; don't abort and use k=1 plus backtracking
+         *    | X Z
+         *    ;
+         *
+         *  12/13/2007: Actually this has caused problems.  If k=*, must terminate
+         *  and throw out entire DFA; retry with k=1.  Since recursive, do not
+         *  attempt more closure ops as it may take forever.  Exception thrown
+         *  now and we simply report the problem.  If synpreds exist, I'll retry
+         *  with k=1.
+         */
+        protected internal bool abortedDueToMultipleRecursiveAlts = false;
+
+        /** Build up the hash code for this state as NFA configurations
+         *  are added as it's monotonically increasing list of configurations.
+         */
+        protected int cachedHashCode;
+
+        protected internal int cachedUniquelyPredicatedAlt = PREDICTED_ALT_UNSET;
+
+        public int minAltInConfigurations = int.MaxValue;
+
+        public bool atLeastOneConfigurationHasAPredicate = false;
+
+        /** The set of NFA configurations (state,alt,context) for this DFA state */
+        public OrderedHashSet<NFAConfiguration> nfaConfigurations =
+            new OrderedHashSet<NFAConfiguration>();
+
+        public IList<NFAConfiguration> configurationsWithLabeledEdges =
+            new List<NFAConfiguration>();
+
+        /** Used to prevent the closure operation from looping to itself and
+         *  hence looping forever.  Sensitive to the NFA state, the alt, and
+         *  the stack context.  This just the nfa config set because we want to
+         *  prevent closures only on states contributed by closure not reach
+         *  operations.
+         *
+         *  Two configurations identical including semantic context are
+         *  considered the same closure computation.  @see NFAToDFAConverter.closureBusy().
+         */
+        protected internal HashSet<NFAConfiguration> closureBusy = new HashSet<NFAConfiguration>();
+
+        /** As this state is constructed (i.e., as NFA states are added), we
+         *  can easily check for non-epsilon transitions because the only
+         *  transition that could be a valid label is transition(0).  When we
+         *  process this node eventually, we'll have to walk all states looking
+         *  for all possible transitions.  That is of the order: size(label space)
+         *  times size(nfa states), which can be pretty damn big.  It's better
+         *  to simply track possible labels.
+         */
+        protected OrderedHashSet<Label> reachableLabels;
+
+        public DFAState( DFA dfa )
+        {
+            this.dfa = dfa;
+        }
+
+        #region Properties
+        public int AcceptStateReachable
+        {
+            get
+            {
+                return getAcceptStateReachable();
+            }
+        }
+        public ICollection<int> AltSet
+        {
+            get
+            {
+                return getAltSet();
+            }
+        }
+        public ICollection<int> DisabledAlternatives
+        {
+            get
+            {
+                return getDisabledAlternatives();
+            }
+        }
+        public bool IsResolvedWithPredicates
+        {
+            get
+            {
+                return isResolvedWithPredicates();
+            }
+        }
+        public int LookaheadDepth
+        {
+            get
+            {
+                return getLookaheadDepth();
+            }
+        }
+        public ICollection<Label> ReachableLabels
+        {
+            get
+            {
+                return getReachableLabels();
+            }
+        }
+        #endregion
+
+        public virtual void reset()
+        {
+            //nfaConfigurations = null; // getGatedPredicatesInNFAConfigurations needs
+            configurationsWithLabeledEdges = null;
+            closureBusy = null;
+            reachableLabels = null;
+        }
+
+        public virtual Transition transition( int i )
+        {
+            return (Transition)transitions[i];
+        }
+
+        public override int NumberOfTransitions
+        {
+            get
+            {
+                return transitions.Count;
+            }
+        }
+
+        public override void addTransition( Transition t )
+        {
+            transitions.Add( t );
+        }
+
+        /** Add a transition from this state to target with label.  Return
+         *  the transition number from 0..n-1.
+         */
+        public virtual int addTransition( DFAState target, Label label )
+        {
+            transitions.Add( new Transition( label, target ) );
+            return transitions.Count - 1;
+        }
+
+        public override Transition getTransition( int trans )
+        {
+            return transitions[trans];
+        }
+
+        public virtual void removeTransition( int trans )
+        {
+            transitions.RemoveAt( trans );
+        }
+
+        /** Add an NFA configuration to this DFA node.  Add uniquely
+         *  an NFA state/alt/syntactic&semantic context (chain of invoking state(s)
+         *  and semantic predicate contexts).
+         *
+         *  I don't see how there could be two configurations with same
+         *  state|alt|synCtx and different semantic contexts because the
+         *  semantic contexts are computed along the path to a particular state
+         *  so those two configurations would have to have the same predicate.
+         *  Nonetheless, the addition of configurations is unique on all
+         *  configuration info.  I guess I'm saying that syntactic context
+         *  implies semantic context as the latter is computed according to the
+         *  former.
+         *
+         *  As we add configurations to this DFA state, track the set of all possible
+         *  transition labels so we can simply walk it later rather than doing a
+         *  loop over all possible labels in the NFA.
+         */
+        public virtual void addNFAConfiguration( NFAState state, NFAConfiguration c )
+        {
+            if ( nfaConfigurations.Contains( c ) )
+            {
+                return;
+            }
+
+            nfaConfigurations.add( c );
+
+            // track min alt rather than compute later
+            if ( c.alt < minAltInConfigurations )
+            {
+                minAltInConfigurations = c.alt;
+            }
+
+            if ( c.semanticContext != SemanticContext.EMPTY_SEMANTIC_CONTEXT )
+            {
+                atLeastOneConfigurationHasAPredicate = true;
+            }
+
+            // update hashCode; for some reason using context.hashCode() also
+            // makes the GC take like 70% of the CPU and is slow!
+            cachedHashCode += c.state + c.alt;
+
+            // update reachableLabels
+            // We're adding an NFA state; check to see if it has a non-epsilon edge
+            if ( state.transition[0] != null )
+            {
+                Label label = state.transition[0].label;
+                if ( !( label.IsEpsilon || label.IsSemanticPredicate ) )
+                {
+                    // this NFA state has a non-epsilon edge, track for fast
+                    // walking later when we do reach on this DFA state we're
+                    // building.
+                    configurationsWithLabeledEdges.Add( c );
+                    if ( state.transition[1] == null )
+                    {
+                        // later we can check this to ignore o-A->o states in closure
+                        c.singleAtomTransitionEmanating = true;
+                    }
+                    addReachableLabel( label );
+                }
+            }
+        }
+
+        public virtual NFAConfiguration addNFAConfiguration( NFAState state,
+                                                    int alt,
+                                                    NFAContext context,
+                                                    SemanticContext semanticContext )
+        {
+            NFAConfiguration c = new NFAConfiguration( state.stateNumber,
+                                                      alt,
+                                                      context,
+                                                      semanticContext );
+            addNFAConfiguration( state, c );
+            return c;
+        }
+
+        /** Add label uniquely and disjointly; intersection with
+         *  another set or int/char forces breaking up the set(s).
+         *
+         *  Example, if reachable list of labels is [a..z, {k,9}, 0..9],
+         *  the disjoint list will be [{a..j,l..z}, k, 9, 0..8].
+         *
+         *  As we add NFA configurations to a DFA state, we might as well track
+         *  the set of all possible transition labels to make the DFA conversion
+         *  more efficient.  W/o the reachable labels, we'd need to check the
+         *  whole vocabulary space (could be 0..\uFFFF)!  The problem is that
+         *  labels can be sets, which may overlap with int labels or other sets.
+         *  As we need a deterministic set of transitions from any
+         *  state in the DFA, we must make the reachable labels set disjoint.
+         *  This operation amounts to finding the character classes for this
+         *  DFA state whereas with tools like flex, that need to generate a
+         *  homogeneous DFA, must compute char classes across all states.
+         *  We are going to generate DFAs with heterogeneous states so we
+         *  only care that the set of transitions out of a single state are
+         *  unique. :)
+         *
+         *  The idea for adding a new set, t, is to look for overlap with the
+         *  elements of existing list s.  Upon overlap, replace
+         *  existing set s[i] with two new disjoint sets, s[i]-t and s[i]&t.
+         *  (if s[i]-t is nil, don't add).  The remainder is t-s[i], which is
+         *  what you want to add to the set minus what was already there.  The
+         *  remainder must then be compared against the i+1..n elements in s
+         *  looking for another collision.  Each collision results in a smaller
+         *  and smaller remainder.  Stop when you run out of s elements or
+         *  remainder goes to nil.  If remainder is non nil when you run out of
+         *  s elements, then add remainder to the end.
+         *
+         *  Single element labels are treated as sets to make the code uniform.
+         */
+        protected virtual void addReachableLabel( Label label )
+        {
+            if ( reachableLabels == null )
+            {
+                reachableLabels = new OrderedHashSet<Label>();
+            }
+            /*
+            JSystem.@out.println("addReachableLabel to state "+dfa.decisionNumber+"."+stateNumber+": "+label.getSet().toString(dfa.nfa.grammar));
+            JSystem.@out.println("start of add to state "+dfa.decisionNumber+"."+stateNumber+": " +
+                    "reachableLabels="+reachableLabels.toString());
+                    */
+            if ( reachableLabels.Contains( label ) )
+            { // exact label present
+                return;
+            }
+            IIntSet t = label.Set;
+            IIntSet remainder = t; // remainder starts out as whole set to add
+            int n = reachableLabels.size(); // only look at initial elements
+            // walk the existing list looking for the collision
+            for ( int i = 0; i < n; i++ )
+            {
+                Label rl = reachableLabels.get( i );
+                /*
+                JSystem.@out.println("comparing ["+i+"]: "+label.toString(dfa.nfa.grammar)+" & "+
+                        rl.toString(dfa.nfa.grammar)+"="+
+                        intersection.toString(dfa.nfa.grammar));
+                */
+                if ( !Label.intersect( label, rl ) )
+                {
+                    continue;
+                }
+                //JSystem.@out.println(label+" collides with "+rl);
+
+                // For any (s_i, t) with s_i&t!=nil replace with (s_i-t, s_i&t)
+                // (ignoring s_i-t if nil; don't put in list)
+
+                // Replace existing s_i with intersection since we
+                // know that will always be a non nil character class
+                IIntSet s_i = rl.Set;
+                IIntSet intersection = s_i.and( t );
+                reachableLabels.set( i, new Label( intersection ) );
+
+                // Compute s_i-t to see what is in current set and not in incoming
+                IIntSet existingMinusNewElements = s_i.subtract( t );
+                //JSystem.@out.println(s_i+"-"+t+"="+existingMinusNewElements);
+                if ( !existingMinusNewElements.isNil() )
+                {
+                    // found a new character class, add to the end (doesn't affect
+                    // outer loop duration due to n computation a priori.
+                    Label newLabel = new Label( existingMinusNewElements );
+                    reachableLabels.add( newLabel );
+                }
+
+                /*
+                JSystem.@out.println("after collision, " +
+                        "reachableLabels="+reachableLabels.toString());
+                        */
+
+                // anything left to add to the reachableLabels?
+                remainder = t.subtract( s_i );
+                if ( remainder.isNil() )
+                {
+                    break; // nothing left to add to set.  done!
+                }
+
+                t = remainder;
+            }
+            if ( !remainder.isNil() )
+            {
+                /*
+                JSystem.@out.println("before add remainder to state "+dfa.decisionNumber+"."+stateNumber+": " +
+                        "reachableLabels="+reachableLabels.toString());
+                JSystem.@out.println("remainder state "+dfa.decisionNumber+"."+stateNumber+": "+remainder.toString(dfa.nfa.grammar));
+                */
+                Label newLabel = new Label( remainder );
+                reachableLabels.add( newLabel );
+            }
+            /*
+            JSystem.@out.println("#END of add to state "+dfa.decisionNumber+"."+stateNumber+": " +
+                    "reachableLabels="+reachableLabels.toString());
+                    */
+        }
+
+        public virtual OrderedHashSet<Label> getReachableLabels()
+        {
+            return reachableLabels;
+        }
+
+        public virtual void setNFAConfigurations( OrderedHashSet<NFAConfiguration> configs )
+        {
+            this.nfaConfigurations = configs;
+        }
+
+        /** A decent hash for a DFA state is the sum of the NFA state/alt pairs.
+         *  This is used when we add DFAState objects to the DFA.states Map and
+         *  when we compare DFA states.  Computed in addNFAConfiguration()
+         */
+        public override int GetHashCode()
+        {
+            if ( cachedHashCode == 0 )
+            {
+                // LL(1) algorithm doesn't use NFA configurations, which
+                // dynamically compute hashcode; must have something; use super
+                return base.GetHashCode();
+            }
+            return cachedHashCode;
+        }
+
+        /** Two DFAStates are equal if their NFA configuration sets are the
+         *  same. This method is used to see if a DFA state already exists.
+         *
+         *  Because the number of alternatives and number of NFA configurations are
+         *  finite, there is a finite number of DFA states that can be processed.
+         *  This is necessary to show that the algorithm terminates.
+         *
+         *  Cannot test the DFA state numbers here because in DFA.addState we need
+         *  to know if any other state exists that has this exact set of NFA
+         *  configurations.  The DFAState state number is irrelevant.
+         */
+        public override bool Equals( object o )
+        {
+            // compare set of NFA configurations in this set with other
+            DFAState other = (DFAState)o;
+
+            if ( object.ReferenceEquals( nfaConfigurations, other.nfaConfigurations ) )
+                return true;
+
+            if ( this.nfaConfigurations.Equals( other.nfaConfigurations ) )
+                return true;
+
+            if ( nfaConfigurations.SequenceEqual( other.nfaConfigurations ) )
+                return true;
+
+            return false;
+        }
+
+        /** Walk each configuration and if they are all the same alt, return
+         *  that alt else return NFA.INVALID_ALT_NUMBER.  Ignore resolved
+         *  configurations, but don't ignore resolveWithPredicate configs
+         *  because this state should not be an accept state.  We need to add
+         *  this to the work list and then have semantic predicate edges
+         *  emanating from it.
+         */
+        public virtual int getUniquelyPredictedAlt()
+        {
+            if ( cachedUniquelyPredicatedAlt != PREDICTED_ALT_UNSET )
+            {
+                return cachedUniquelyPredicatedAlt;
+            }
+            int alt = NFA.INVALID_ALT_NUMBER;
+            int numConfigs = nfaConfigurations.size();
+            for ( int i = 0; i < numConfigs; i++ )
+            {
+                NFAConfiguration configuration = (NFAConfiguration)nfaConfigurations.get( i );
+                // ignore anything we resolved; predicates will still result
+                // in transitions out of this state, so must count those
+                // configurations; i.e., don't ignore resolveWithPredicate configs
+                if ( configuration.resolved )
+                {
+                    continue;
+                }
+                if ( alt == NFA.INVALID_ALT_NUMBER )
+                {
+                    alt = configuration.alt; // found first nonresolved alt
+                }
+                else if ( configuration.alt != alt )
+                {
+                    return NFA.INVALID_ALT_NUMBER;
+                }
+            }
+            this.cachedUniquelyPredicatedAlt = alt;
+            return alt;
+        }
+
+        /** Return the uniquely mentioned alt from the NFA configurations;
+         *  Ignore the resolved bit etc...  Return INVALID_ALT_NUMBER
+         *  if there is more than one alt mentioned.
+         */
+        public virtual int getUniqueAlt()
+        {
+            int alt = NFA.INVALID_ALT_NUMBER;
+            int numConfigs = nfaConfigurations.size();
+            for ( int i = 0; i < numConfigs; i++ )
+            {
+                NFAConfiguration configuration = (NFAConfiguration)nfaConfigurations.get( i );
+                if ( alt == NFA.INVALID_ALT_NUMBER )
+                {
+                    alt = configuration.alt; // found first alt
+                }
+                else if ( configuration.alt != alt )
+                {
+                    return NFA.INVALID_ALT_NUMBER;
+                }
+            }
+            return alt;
+        }
+
+        /** When more than one alternative can match the same input, the first
+         *  alternative is chosen to resolve the conflict.  The other alts
+         *  are "turned off" by setting the "resolved" flag in the NFA
+         *  configurations.  Return the set of disabled alternatives.  For
+         *
+         *  a : A | A | A ;
+         *
+         *  this method returns {2,3} as disabled.  This does not mean that
+         *  the alternative is totally unreachable, it just means that for this
+         *  DFA state, that alt is disabled.  There may be other accept states
+         *  for that alt.
+         */
+        public virtual ICollection<int> getDisabledAlternatives()
+        {
+            HashSet<int> disabled = new HashSet<int>();
+            int numConfigs = nfaConfigurations.size();
+            for ( int i = 0; i < numConfigs; i++ )
+            {
+                NFAConfiguration configuration = (NFAConfiguration)nfaConfigurations.get( i );
+                if ( configuration.resolved )
+                {
+                    disabled.Add( configuration.alt );
+                }
+            }
+            return disabled;
+        }
+
+        protected internal virtual HashSet<int> getNonDeterministicAlts()
+        {
+            int user_k = dfa.UserMaxLookahead;
+            if ( user_k > 0 && user_k == k )
+            {
+                // if fixed lookahead, then more than 1 alt is a nondeterminism
+                // if we have hit the max lookahead
+                return new HashSet<int>( AltSet );
+            }
+            else if ( abortedDueToMultipleRecursiveAlts || abortedDueToRecursionOverflow )
+            {
+                // if we had to abort for non-LL(*) state assume all alts are a problem
+                return new HashSet<int>( AltSet );
+            }
+            else
+            {
+                return getConflictingAlts();
+            }
+        }
+
+        /** Walk each NFA configuration in this DFA state looking for a conflict
+         *  where (s|i|ctx) and (s|j|ctx) exist, indicating that state s with
+         *  context conflicting ctx predicts alts i and j.  Return an Integer set
+         *  of the alternative numbers that conflict.  Two contexts conflict if
+         *  they are equal or one is a stack suffix of the other or one is
+         *  the empty context.
+         *
+         *  Use a hash table to record the lists of configs for each state
+         *  as they are encountered.  We need only consider states for which
+         *  there is more than one configuration.  The configurations' predicted
+         *  alt must be different or must have different contexts to avoid a
+         *  conflict.
+         *
+         *  Don't report conflicts for DFA states that have conflicting Tokens
+         *  rule NFA states; they will be resolved in favor of the first rule.
+         */
+        protected virtual HashSet<int> getConflictingAlts()
+        {
+            // TODO this is called multiple times: cache result?
+            //JSystem.@out.println("getNondetAlts for DFA state "+stateNumber);
+            HashSet<int> nondeterministicAlts = new HashSet<int>();
+
+            // If only 1 NFA conf then no way it can be nondeterministic;
+            // save the overhead.  There are many o-a->o NFA transitions
+            // and so we save a hash map and iterator creation for each
+            // state.
+            int numConfigs = nfaConfigurations.size();
+            if ( numConfigs <= 1 )
+            {
+                return null;
+            }
+
+            // First get a list of configurations for each state.
+            // Most of the time, each state will have one associated configuration.
+            MultiMap<int, NFAConfiguration> stateToConfigListMap =
+                new MultiMap<int, NFAConfiguration>();
+            for ( int i = 0; i < numConfigs; i++ )
+            {
+                NFAConfiguration configuration = (NFAConfiguration)nfaConfigurations.get( i );
+                int stateI = configuration.state;
+                stateToConfigListMap.map( stateI, configuration );
+            }
+            // potential conflicts are states with > 1 configuration and diff alts
+            ICollection<int> states = stateToConfigListMap.Keys.ToArray();
+            int numPotentialConflicts = 0;
+            foreach ( int stateI in states )
+            {
+                bool thisStateHasPotentialProblem = false;
+                var configsForState = stateToConfigListMap.get( stateI );
+                int alt = 0;
+                int numConfigsForState = configsForState.Count;
+                for ( int i = 0; i < numConfigsForState && numConfigsForState > 1; i++ )
+                {
+                    NFAConfiguration c = (NFAConfiguration)configsForState[i];
+                    if ( alt == 0 )
+                    {
+                        alt = c.alt;
+                    }
+                    else if ( c.alt != alt )
+                    {
+                        /*
+                        JSystem.@out.println("potential conflict in state "+stateI+
+                                           " configs: "+configsForState);
+                        */
+                        // 11/28/2005: don't report closures that pinch back
+                        // together in Tokens rule.  We want to silently resolve
+                        // to the first token definition ala lex/flex by ignoring
+                        // these conflicts.
+                        // Also this ensures that lexers look for more and more
+                        // characters (longest match) before resorting to predicates.
+                        // TestSemanticPredicates.testLexerMatchesLongestThenTestPred()
+                        // for example would terminate at state s1 and test predicate
+                        // meaning input "ab" would test preds to decide what to
+                        // do but it should match rule C w/o testing preds.
+                        if ( dfa.nfa.grammar.type != Grammar.LEXER ||
+                             !dfa.decisionNFAStartState.enclosingRule.name.Equals( Grammar.ARTIFICIAL_TOKENS_RULENAME ) )
+                        {
+                            numPotentialConflicts++;
+                            thisStateHasPotentialProblem = true;
+                        }
+                    }
+                }
+                if ( !thisStateHasPotentialProblem )
+                {
+                    // remove NFA state's configurations from
+                    // further checking; no issues with it
+                    // (can't remove as it's concurrent modification; set to null)
+                    stateToConfigListMap[stateI] = null;
+                }
+            }
+
+            // a fast check for potential issues; most states have none
+            if ( numPotentialConflicts == 0 )
+            {
+                return null;
+            }
+
+            // we have a potential problem, so now go through config lists again
+            // looking for different alts (only states with potential issues
+            // are left in the states set).  Now we will check context.
+            // For example, the list of configs for NFA state 3 in some DFA
+            // state might be:
+            //   [3|2|[28 18 $], 3|1|[28 $], 3|1, 3|2]
+            // I want to create a map from context to alts looking for overlap:
+            //   [28 18 $] -> 2
+            //   [28 $] -> 1
+            //   [$] -> 1,2
+            // Indeed a conflict exists as same state 3, same context [$], predicts
+            // alts 1 and 2.
+            // walk each state with potential conflicting configurations
+            foreach ( int stateI in states )
+            {
+                var configsForState = stateToConfigListMap.get( stateI );
+                // compare each configuration pair s, t to ensure:
+                // s.ctx different than t.ctx if s.alt != t.alt
+                int numConfigsForState = 0;
+                if ( configsForState != null )
+                {
+                    numConfigsForState = configsForState.Count;
+                }
+                for ( int i = 0; i < numConfigsForState; i++ )
+                {
+                    NFAConfiguration s = configsForState[i];
+                    for ( int j = i + 1; j < numConfigsForState; j++ )
+                    {
+                        NFAConfiguration t = configsForState[j];
+                        // conflicts means s.ctx==t.ctx or s.ctx is a stack
+                        // suffix of t.ctx or vice versa (if alts differ).
+                        // Also a conflict if s.ctx or t.ctx is empty
+                        if ( s.alt != t.alt && s.context.conflictsWith( t.context ) )
+                        {
+                            nondeterministicAlts.Add( s.alt );
+                            nondeterministicAlts.Add( t.alt );
+                        }
+                    }
+                }
+            }
+
+            if ( nondeterministicAlts.Count == 0 )
+            {
+                return null;
+            }
+            return nondeterministicAlts;
+        }
+
+        /** Get the set of all alts mentioned by all NFA configurations in this
+         *  DFA state.
+         */
+        public virtual HashSet<int> getAltSet()
+        {
+            int numConfigs = nfaConfigurations.size();
+            HashSet<int> alts = new HashSet<int>();
+            for ( int i = 0; i < numConfigs; i++ )
+            {
+                NFAConfiguration configuration = (NFAConfiguration)nfaConfigurations.get( i );
+                alts.Add( configuration.alt );
+            }
+            if ( alts.Count == 0 )
+            {
+                return null;
+            }
+            return alts;
+        }
+
+        public virtual HashSet<SemanticContext> getGatedSyntacticPredicatesInNFAConfigurations()
+        {
+            int numConfigs = nfaConfigurations.size();
+            HashSet<SemanticContext> synpreds = new HashSet<SemanticContext>();
+            for ( int i = 0; i < numConfigs; i++ )
+            {
+                NFAConfiguration configuration = (NFAConfiguration)nfaConfigurations.get( i );
+                SemanticContext gatedPredExpr =
+                    configuration.semanticContext.GatedPredicateContext;
+                // if this is a manual syn pred (gated and syn pred), add
+                if ( gatedPredExpr != null &&
+                     configuration.semanticContext.IsSyntacticPredicate )
+                {
+                    synpreds.Add( configuration.semanticContext );
+                }
+            }
+            if ( synpreds.Count == 0 )
+            {
+                return null;
+            }
+            return synpreds;
+        }
+
+        /** For gated productions, we need an OR'd list of all predicates for the
+         *  target of an edge so we can gate the edge based upon the predicates
+         *  associated with taking that path (if any).
+         *
+         *  For syntactic predicates, we only want to generate predicate
+         *  evaluations as it transitions to an accept state; waste to
+         *  do it earlier.  So, only add gated preds derived from manually-
+         *  specified syntactic predicates if this is an accept state.
+         *
+         *  Also, since configurations w/o gated predicates are like true
+         *  gated predicates, finding a configuration whose alt has no gated
+         *  predicate implies we should evaluate the predicate to true. This
+         *  means the whole edge has to be ungated. Consider:
+         *
+         *	 X : ('a' | {p}?=> 'a')
+         *	   | 'a' 'b'
+         *	   ;
+         *
+         *  Here, you 'a' gets you from s0 to s1 but you can't test p because
+         *  plain 'a' is ok.  It's also ok for starting alt 2.  Hence, you can't
+         *  test p.  Even on the edge going to accept state for alt 1 of X, you
+         *  can't test p.  You can get to the same place with and w/o the context.
+         *  Therefore, it is never ok to test p in this situation.
+         *
+         *  TODO: cache this as it's called a lot; or at least set bit if >1 present in state
+         */
+        public virtual SemanticContext getGatedPredicatesInNFAConfigurations()
+        {
+            SemanticContext unionOfPredicatesFromAllAlts = null;
+            int numConfigs = nfaConfigurations.size();
+            for ( int i = 0; i < numConfigs; i++ )
+            {
+                NFAConfiguration configuration = (NFAConfiguration)nfaConfigurations.get( i );
+                SemanticContext gatedPredExpr =
+                    configuration.semanticContext.GatedPredicateContext;
+                if ( gatedPredExpr == null )
+                {
+                    // if we ever find a configuration w/o a gated predicate
+                    // (even if it's a nongated predicate), we cannot gate
+                    // the indident edges.
+                    return null;
+                }
+                else if ( acceptState || !configuration.semanticContext.IsSyntacticPredicate )
+                {
+                    // at this point we have a gated predicate and, due to elseif,
+                    // we know it's an accept and not a syn pred.  In this case,
+                    // it's safe to add the gated predicate to the union.  We
+                    // only want to add syn preds if it's an accept state.  Other
+                    // gated preds can be used with edges leading to accept states.
+                    if ( unionOfPredicatesFromAllAlts == null )
+                    {
+                        unionOfPredicatesFromAllAlts = gatedPredExpr;
+                    }
+                    else
+                    {
+                        unionOfPredicatesFromAllAlts =
+                            SemanticContext.or( unionOfPredicatesFromAllAlts, gatedPredExpr );
+                    }
+                }
+            }
+            if ( unionOfPredicatesFromAllAlts is SemanticContext.TruePredicate )
+            {
+                return null;
+            }
+            return unionOfPredicatesFromAllAlts;
+        }
+
+        /** Is an accept state reachable from this state? */
+        public virtual int getAcceptStateReachable()
+        {
+            return acceptStateReachable;
+        }
+
+        public virtual void setAcceptStateReachable( int acceptStateReachable )
+        {
+            this.acceptStateReachable = acceptStateReachable;
+        }
+
+        public virtual bool isResolvedWithPredicates()
+        {
+            return resolvedWithPredicates;
+        }
+
+        /** Print all NFA states plus what alts they predict */
+        public override String ToString()
+        {
+            StringBuilder buf = new StringBuilder();
+            buf.Append( stateNumber + ":{" );
+            for ( int i = 0; i < nfaConfigurations.size(); i++ )
+            {
+                NFAConfiguration configuration = (NFAConfiguration)nfaConfigurations.get( i );
+                if ( i > 0 )
+                {
+                    buf.Append( ", " );
+                }
+                buf.Append( configuration );
+            }
+            buf.Append( "}" );
+            return buf.ToString();
+        }
+
+        public virtual int getLookaheadDepth()
+        {
+            return k;
+        }
+
+        public virtual void setLookaheadDepth( int k )
+        {
+            this.k = k;
+            if ( k > dfa.max_k )
+            { // track max k for entire DFA
+                dfa.max_k = k;
+            }
+        }
+
+    }
+}
diff --git a/Antlr3/Analysis/DecisionProbe.cs b/Antlr3/Analysis/DecisionProbe.cs
new file mode 100644
index 0000000..787e527
--- /dev/null
+++ b/Antlr3/Analysis/DecisionProbe.cs
@@ -0,0 +1,1158 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Analysis
+{
+    using System;
+    using System.Collections.Generic;
+    using System.Linq;
+    using Antlr.Runtime.JavaExtensions;
+    using Antlr3.Misc;
+
+    using ANTLRParser = Antlr3.Grammars.ANTLRParser;
+    using ErrorManager = Antlr3.Tool.ErrorManager;
+    using Grammar = Antlr3.Tool.Grammar;
+    using GrammarAST = Antlr3.Tool.GrammarAST;
+    using IList = System.Collections.IList;
+    using IToken = Antlr.Runtime.IToken;
+    using StringBuilder = System.Text.StringBuilder;
+
+    /** Collection of information about what is wrong with a decision as
+     *  discovered while building the DFA predictor.
+     *
+     *  The information is collected during NFA->DFA conversion and, while
+     *  some of this is available elsewhere, it is nice to have it all tracked
+     *  in one spot so a great error message can be easily had.  I also like
+     *  the fact that this object tracks it all for later perusing to make an
+     *  excellent error message instead of lots of imprecise on-the-fly warnings
+     *  (during conversion).
+     *
+     *  A decision normally only has one problem; e.g., some input sequence
+     *  can be matched by multiple alternatives.  Unfortunately, some decisions
+     *  such as
+     *
+     *  a : ( A | B ) | ( A | B ) | A ;
+     *
+     *  have multiple problems.  So in general, you should approach a decision
+     *  as having multiple flaws each one uniquely identified by a DFAState.
+     *  For example, statesWithSyntacticallyAmbiguousAltsSet tracks the set of
+     *  all DFAStates where ANTLR has discovered a problem.  Recall that a decision
+     *  is represented internall with a DFA comprised of multiple states, each of
+     *  which could potentially have problems.
+     *
+     *  Because of this, you need to iterate over this list of DFA states.  You'll
+     *  note that most of the informational methods like
+     *  getSampleNonDeterministicInputSequence() require a DFAState.  This state
+     *  will be one of the iterated states from stateToSyntacticallyAmbiguousAltsSet.
+     *
+     *  This class is not thread safe due to shared use of visited maps etc...
+     *  Only one thread should really need to access one DecisionProbe anyway.
+     */
+    public class DecisionProbe
+    {
+        public DFA dfa;
+
+        /** Track all DFA states with nondeterministic alternatives.
+         *  By reaching the same DFA state, a path through the NFA for some input
+         *  is able to reach the same NFA state by starting at more than one
+         *  alternative's left edge.  Though, later, we may find that predicates
+         *  resolve the issue, but track info anyway.
+         *  Note that from the DFA state, you can ask for
+         *  which alts are nondeterministic.
+         */
+        //protected Set<DFAState> statesWithSyntacticallyAmbiguousAltsSet = new HashSet<DFAState>();
+        protected ICollection<DFAState> statesWithSyntacticallyAmbiguousAltsSet = new HashSet<DFAState>();
+
+        /** Track just like stateToSyntacticallyAmbiguousAltsMap, but only
+         *  for nondeterminisms that arise in the Tokens rule such as keyword vs
+         *  ID rule.  The state maps to the list of Tokens rule alts that are
+         *  in conflict.
+         */
+        //protected Map<DFAState, Set<Integer>> stateToSyntacticallyAmbiguousTokensRuleAltsMap =
+        //    new HashMap<DFAState, Set<Integer>>();
+        protected internal IDictionary<DFAState, ICollection<int>> stateToSyntacticallyAmbiguousTokensRuleAltsMap =
+            new Dictionary<DFAState, ICollection<int>>();
+
+        /** Was a syntactic ambiguity resolved with predicates?  Any DFA
+         *  state that predicts more than one alternative, must be resolved
+         *  with predicates or it should be reported to the user.
+         */
+        //protected Set<DFAState> statesResolvedWithSemanticPredicatesSet = new HashSet<DFAState>();
+        protected ICollection<DFAState> statesResolvedWithSemanticPredicatesSet = new HashSet<DFAState>();
+
+        /** Track the predicates for each alt per DFA state;
+         *  more than one DFA state might have syntactically ambig alt prediction.
+         *  Maps DFA state to another map, mapping alt number to a
+         *  SemanticContext (pred(s) to execute to resolve syntactic ambiguity).
+         */
+        //protected Map<DFAState, Map<Integer,SemanticContext>> stateToAltSetWithSemanticPredicatesMap =
+        //    new HashMap<DFAState, Map<Integer,SemanticContext>>();
+        protected IDictionary<DFAState, IDictionary<int, SemanticContext>> stateToAltSetWithSemanticPredicatesMap =
+            new Dictionary<DFAState, IDictionary<int, SemanticContext>>();
+
+        /** Tracks alts insufficiently covered.
+         *  For example, p1||true gets reduced to true and so leaves
+         *  whole alt uncovered.  This maps DFA state to the set of alts
+         */
+        //protected Map<DFAState,Map<Integer, Set<Token>>> stateToIncompletelyCoveredAltsMap =
+        //    new HashMap<DFAState,Map<Integer, Set<Token>>>();
+        protected IDictionary<DFAState, IDictionary<int, ICollection<IToken>>> stateToIncompletelyCoveredAltsMap =
+            new Dictionary<DFAState, IDictionary<int, ICollection<IToken>>>();
+
+        /** The set of states w/o emanating edges and w/o resolving sem preds. */
+        //protected Set<DFAState> danglingStates = new HashSet<DFAState>();
+        protected ICollection<DFAState> danglingStates = new HashSet<DFAState>();
+
+        /** The overall list of alts within the decision that have at least one
+         *  conflicting input sequence.
+         */
+        //protected Set<Integer> altsWithProblem = new HashSet<Integer>();
+        protected ICollection<int> altsWithProblem = new HashSet<int>();
+
+        /** If decision with > 1 alt has recursion in > 1 alt, it's nonregular
+         *  lookahead.  The decision cannot be made with a DFA.
+         *  the alts are stored in altsWithProblem.
+         */
+        protected bool nonLLStarDecision = false;
+
+        /** Recursion is limited to a particular depth.  If that limit is exceeded
+         *  the proposed new NFAConfiguration is recorded for the associated DFA state.
+         */
+        //protected MultiMap<Integer, NFAConfiguration> stateToRecursionOverflowConfigurationsMap =
+        //    new MultiMap<Integer, NFAConfiguration>();
+	protected MultiMap<int, NFAConfiguration> stateToRecursionOverflowConfigurationsMap =
+		new MultiMap<int, NFAConfiguration>();
+
+        /*
+	protected Map<Integer, List<NFAConfiguration>> stateToRecursionOverflowConfigurationsMap =
+		new HashMap<Integer, List<NFAConfiguration>>();
+		*/
+
+        /** Left recursion discovered.  The proposed new NFAConfiguration
+         *  is recorded for the associated DFA state.
+        protected Map<Integer,List<NFAConfiguration>> stateToLeftRecursiveConfigurationsMap =
+            new HashMap<Integer,List<NFAConfiguration>>();
+         */
+
+        /** Did ANTLR have to terminate early on the analysis of this decision? */
+        protected bool timedOut = false;
+
+        /** Used to find paths through syntactically ambiguous DFA. If we've
+         *  seen statement number before, what did we learn?
+         */
+        //protected Map<Integer, Integer> stateReachable;
+        protected IDictionary<int, int> stateReachable;
+
+        public const int REACHABLE_BUSY = -1;
+        public const int REACHABLE_NO = 0;
+        public const int REACHABLE_YES = 1;
+
+        /** Used while finding a path through an NFA whose edge labels match
+         *  an input sequence.  Tracks the input position
+         *  we were at the last time at this node.  If same input position, then
+         *  we'd have reached same state without consuming input...probably an
+         *  infinite loop.  Stop.  Set<String>.  The strings look like
+         *  stateNumber_labelIndex.
+         */
+        //protected Set<String> statesVisitedAtInputDepth;
+        protected ICollection<String> statesVisitedAtInputDepth;
+
+        //protected Set<Integer> statesVisitedDuringSampleSequence;
+        protected ICollection<int> statesVisitedDuringSampleSequence;
+
+        public static bool verbose = false;
+
+        public DecisionProbe( DFA dfa )
+        {
+            this.dfa = dfa;
+        }
+
+        #region Properties
+        public bool AnalysisOverflowed
+        {
+            get
+            {
+                return analysisOverflowed();
+            }
+        }
+        public bool AnalysisTimedOut
+        {
+            get
+            {
+                return analysisTimedOut();
+            }
+        }
+        public ICollection<DFAState> DanglingStates
+        {
+            get
+            {
+                return getDanglingStates();
+            }
+        }
+        public string Description
+        {
+            get
+            {
+                return getDescription();
+            }
+        }
+        public ICollection<DFAState> DFAStatesWithSyntacticallyAmbiguousAlts
+        {
+            get
+            {
+                return getDFAStatesWithSyntacticallyAmbiguousAlts();
+            }
+        }
+        public bool HasPredicate
+        {
+            get
+            {
+                return hasPredicate();
+            }
+        }
+        public bool IsCyclic
+        {
+            get
+            {
+                return isCyclic();
+            }
+        }
+        public bool IsDeterministic
+        {
+            get
+            {
+                return isDeterministic();
+            }
+        }
+        public bool IsNonLLStarDecision
+        {
+            get
+            {
+                return isNonLLStarDecision();
+            }
+        }
+        public bool IsReduced
+        {
+            get
+            {
+                return isReduced();
+            }
+        }
+        public ICollection<int> NonDeterministicAlts
+        {
+            get
+            {
+                return getNonDeterministicAlts();
+            }
+        }
+        public ICollection<DFAState> NondeterministicStatesResolvedWithSemanticPredicate
+        {
+            get
+            {
+                return getNondeterministicStatesResolvedWithSemanticPredicate();
+            }
+        }
+        public int NumberOfStates
+        {
+            get
+            {
+                return getNumberOfStates();
+            }
+        }
+        public ICollection<int> UnreachableAlts
+        {
+            get
+            {
+                return getUnreachableAlts();
+            }
+        }
+        #endregion
+
+        // I N F O R M A T I O N  A B O U T  D E C I S I O N
+
+        /** Return a string like "3:22: ( A {;} | B )" that describes this
+         *  decision.
+         */
+        public virtual String getDescription()
+        {
+            return dfa.NFADecisionStartState.Description;
+        }
+
+        public virtual bool isReduced()
+        {
+            return dfa.IsReduced;
+        }
+
+        public virtual bool isCyclic()
+        {
+            return dfa.IsCyclic;
+        }
+
+        /** If no states are dead-ends, no alts are unreachable, there are
+         *  no nondeterminisms unresolved by syn preds, all is ok with decision.
+         */
+        public virtual bool isDeterministic()
+        {
+            if ( danglingStates.Count == 0 &&
+                 statesWithSyntacticallyAmbiguousAltsSet.Count == 0 &&
+                 dfa.UnreachableAlts.Count == 0 )
+            {
+                return true;
+            }
+
+            if ( statesWithSyntacticallyAmbiguousAltsSet.Count > 0 )
+            {
+                return statesWithSyntacticallyAmbiguousAltsSet
+                    .Except( statesResolvedWithSemanticPredicatesSet )
+                    .Take( 1 )
+                    .Count() == 0;
+            }
+
+            return false;
+            //if ( statesWithSyntacticallyAmbiguousAltsSet.size() > 0 )
+            //{
+            //    Iterator it =
+            //        statesWithSyntacticallyAmbiguousAltsSet.iterator();
+            //    while ( it.hasNext() )
+            //    {
+            //        DFAState d = (DFAState)it.next();
+            //        if ( !statesResolvedWithSemanticPredicatesSet.contains( d ) )
+            //        {
+            //            return false;
+            //        }
+            //    }
+            //    // no syntactically ambig alts were left unresolved by predicates
+            //    return true;
+            //}
+            //return false;
+        }
+
+        /** Did the analysis complete it's work? */
+        public virtual bool analysisTimedOut()
+        {
+            return timedOut;
+        }
+
+        /** Took too long to analyze a DFA */
+        public virtual bool analysisOverflowed()
+        {
+            return stateToRecursionOverflowConfigurationsMap.Count > 0;
+        }
+
+        /** Found recursion in > 1 alt */
+        public virtual bool isNonLLStarDecision()
+        {
+            return nonLLStarDecision;
+        }
+
+        /** How many states does the DFA predictor have? */
+        public virtual int getNumberOfStates()
+        {
+            return dfa.NumberOfStates;
+        }
+
+        /** Get a list of all unreachable alternatives for this decision.  There
+         *  may be multiple alternatives with ambiguous input sequences, but this
+         *  is the overall list of unreachable alternatives (either due to
+         *  conflict resolution or alts w/o accept states).
+         */
+        public virtual IList<int> getUnreachableAlts()
+        {
+            return (IList<int>)dfa.UnreachableAlts;
+        }
+
+        /** return set of states w/o emanating edges and w/o resolving sem preds.
+         *  These states come about because the analysis algorithm had to
+         *  terminate early to avoid infinite recursion for example (due to
+         *  left recursion perhaps).
+         */
+        public virtual ICollection<DFAState> getDanglingStates()
+        {
+            return danglingStates;
+        }
+
+        public virtual ICollection<int> getNonDeterministicAlts()
+        {
+            return altsWithProblem;
+        }
+
+        /** Return the sorted list of alts that conflict within a single state.
+         *  Note that predicates may resolve the conflict.
+         */
+        public virtual IList getNonDeterministicAltsForState( DFAState targetState )
+        {
+            IEnumerable<int> nondetAlts = targetState.getNonDeterministicAlts();
+            if ( nondetAlts == null )
+                return null;
+
+            return nondetAlts.OrderBy( i => i ).ToList();
+
+            //HashSet<int> nondetAlts = targetState.getNonDeterministicAlts();
+            //if ( nondetAlts == null )
+            //{
+            //    return null;
+            //}
+            //List sorted = new LinkedList();
+            //sorted.addAll( nondetAlts );
+            //Collections.sort( sorted ); // make sure it's 1, 2, ...
+            //return sorted;
+        }
+
+        /** Return all DFA states in this DFA that have NFA configurations that
+         *  conflict.  You must report a problem for each state in this set
+         *  because each state represents a different input sequence.
+         */
+        public virtual ICollection<DFAState> getDFAStatesWithSyntacticallyAmbiguousAlts()
+        {
+            return statesWithSyntacticallyAmbiguousAltsSet;
+        }
+
+        /** Which alts were specifically turned off to resolve nondeterminisms?
+         *  This is different than the unreachable alts.  Disabled doesn't mean that
+         *  the alternative is totally unreachable necessarily, it just means
+         *  that for this DFA state, that alt is disabled.  There may be other
+         *  accept states for that alt that make an alt reachable.
+         */
+        public virtual ICollection<int> getDisabledAlternatives( DFAState d )
+        {
+            return d.DisabledAlternatives;
+        }
+
+        /** If a recursion overflow is resolve with predicates, then we need
+         *  to shut off the warning that would be generated.
+         */
+        public virtual void removeRecursiveOverflowState( DFAState d )
+        {
+            //Integer stateI = Utils.integer( d.stateNumber );
+            stateToRecursionOverflowConfigurationsMap.Remove( d.stateNumber );
+        }
+
+        /** Return a IList<Label> indicating an input sequence that can be matched
+         *  from the start state of the DFA to the targetState (which is known
+         *  to have a problem).
+         */
+        public virtual IList<Label> getSampleNonDeterministicInputSequence( DFAState targetState )
+        {
+            HashSet<object> dfaStates = getDFAPathStatesToTarget( targetState );
+            statesVisitedDuringSampleSequence = new HashSet<int>();
+            IList<Label> labels = new List<Label>(); // may access ith element; use array
+            if ( dfa == null || dfa.startState == null )
+            {
+                return labels;
+            }
+            getSampleInputSequenceUsingStateSet( dfa.startState,
+                                                targetState,
+                                                dfaStates,
+                                                labels );
+            return labels;
+        }
+
+        /** Given IList<Label>, return a String with a useful representation
+         *  of the associated input string.  One could show something different
+         *  for lexers and parsers, for example.
+         */
+        public virtual String getInputSequenceDisplay( IList<Label> labels )
+        {
+            Grammar g = dfa.nfa.grammar;
+            StringBuilder buf = new StringBuilder();
+            //for ( Iterator it = labels.iterator(); it.hasNext(); )
+            foreach ( Label label in labels )
+            {
+                //Label label = (Label)it.next();
+                buf.Append( label.ToString( g ) );
+                if ( /*it.hasNext() &&*/ g.type != Grammar.LEXER )
+                {
+                    buf.Append( ' ' );
+                }
+            }
+
+            // remove the final appended space
+            if ( g.type != Grammar.LEXER )
+                buf.Length = buf.Length - 1;
+
+            return buf.ToString();
+        }
+
+        /** Given an alternative associated with a nondeterministic DFA state,
+         *  find the path of NFA states associated with the labels sequence.
+         *  Useful tracing where in the NFA, a single input sequence can be
+         *  matched.  For different alts, you should get different NFA paths.
+         *
+         *  The first NFA state for all NFA paths will be the same: the starting
+         *  NFA state of the first nondeterministic alt.  Imagine (A|B|A|A):
+         *
+         * 	5->9-A->o
+         *  |
+         *  6->10-B->o
+         *  |
+         *  7->11-A->o
+         *  |
+         *  8->12-A->o
+         *
+         *  There are 3 nondeterministic alts.  The paths should be:
+         *  5 9 ...
+         *  5 6 7 11 ...
+         *  5 6 7 8 12 ...
+         *
+         *  The NFA path matching the sample input sequence (labels) is computed
+         *  using states 9, 11, and 12 rather than 5, 7, 8 because state 5, for
+         *  example can get to all ambig paths.  Must isolate for each alt (hence,
+         *  the extra state beginning each alt in my NFA structures).  Here,
+         *  firstAlt=1.
+         */
+        public virtual IList getNFAPathStatesForAlt( int firstAlt,
+                                           int alt,
+                                           IList<Label> labels )
+        {
+            NFAState nfaStart = dfa.NFADecisionStartState;
+            List<NFAState> path = new List<NFAState>();
+            // first add all NFA states leading up to altStart state
+            for ( int a = firstAlt; a <= alt; a++ )
+            {
+                NFAState s =
+                    dfa.nfa.grammar.getNFAStateForAltOfDecision( nfaStart, a );
+                path.Add( s );
+            }
+
+            // add first state of actual alt
+            NFAState altStart = dfa.nfa.grammar.getNFAStateForAltOfDecision( nfaStart, alt );
+            NFAState isolatedAltStart = (NFAState)altStart.transition[0].target;
+            path.Add( isolatedAltStart );
+
+            // add the actual path now
+            statesVisitedAtInputDepth = new HashSet<string>();
+            getNFAPath( isolatedAltStart,
+                       0,
+                       labels,
+                       path );
+            return path;
+        }
+
+        /** Each state in the DFA represents a different input sequence for an
+         *  alt of the decision.  Given a DFA state, what is the semantic
+         *  predicate context for a particular alt.
+         */
+        public virtual SemanticContext getSemanticContextForAlt( DFAState d, int alt )
+        {
+            var altToPredMap = stateToAltSetWithSemanticPredicatesMap.get( d );
+            if ( altToPredMap == null )
+            {
+                return null;
+            }
+            return altToPredMap.get( alt );
+        }
+
+        /** At least one alt refs a sem or syn pred */
+        public virtual bool hasPredicate()
+        {
+            return stateToAltSetWithSemanticPredicatesMap.Count > 0;
+        }
+
+        public virtual ICollection<DFAState> getNondeterministicStatesResolvedWithSemanticPredicate()
+        {
+            return statesResolvedWithSemanticPredicatesSet;
+        }
+
+        /** Return a list of alts whose predicate context was insufficient to
+         *  resolve a nondeterminism for state d.
+         */
+        public virtual IDictionary<int, ICollection<IToken>> getIncompletelyCoveredAlts( DFAState d )
+        {
+            return stateToIncompletelyCoveredAltsMap.get( d );
+        }
+
+        public virtual void issueWarnings()
+        {
+            // NONREGULAR DUE TO RECURSION > 1 ALTS
+            // Issue this before aborted analysis, which might also occur
+            // if we take too long to terminate
+            if ( nonLLStarDecision && !dfa.AutoBacktrackMode )
+            {
+                ErrorManager.nonLLStarDecision( this );
+            }
+
+            if ( AnalysisTimedOut )
+            {
+                // only report early termination errors if !backtracking
+                if ( !dfa.AutoBacktrackMode )
+                {
+                    ErrorManager.analysisAborted( this );
+                }
+                // now just return...if we bailed out, don't spew other messages
+                return;
+            }
+
+            issueRecursionWarnings();
+
+            // generate a separate message for each problem state in DFA
+            ICollection<DFAState> resolvedStates = NondeterministicStatesResolvedWithSemanticPredicate;
+            ICollection<DFAState> problemStates = DFAStatesWithSyntacticallyAmbiguousAlts;
+            if ( problemStates.Count > 0 )
+            {
+                foreach ( DFAState d in problemStates )
+                {
+                    if ( dfa.nfa.grammar.NFAToDFAConversionExternallyAborted() )
+                        break;
+
+                    IDictionary<int, ICollection<IToken>> insufficientAltToLocations = getIncompletelyCoveredAlts( d );
+                    if ( insufficientAltToLocations != null && insufficientAltToLocations.Count > 0 )
+                    {
+                        ErrorManager.insufficientPredicates( this, d, insufficientAltToLocations );
+                    }
+                    // don't report problem if resolved
+                    if ( resolvedStates == null || !resolvedStates.Contains( d ) )
+                    {
+                        // first strip last alt from disableAlts if it's wildcard
+                        // then don't print error if no more disable alts
+                        ICollection<int> disabledAlts = getDisabledAlternatives( d );
+                        stripWildCardAlts( disabledAlts );
+                        if ( disabledAlts.Count > 0 )
+                        {
+                            ErrorManager.nondeterminism( this, d );
+                        }
+                    }
+                }
+            }
+
+            ICollection<DFAState> danglingStates = DanglingStates;
+            if ( danglingStates.Count > 0 )
+            {
+                //System.err.println("no emanating edges for states: "+danglingStates);
+                foreach ( DFAState d in danglingStates )
+                {
+                    ErrorManager.danglingState( this, d );
+                }
+            }
+
+            if ( !nonLLStarDecision )
+            {
+                var unreachableAlts = dfa.UnreachableAlts;
+                if ( unreachableAlts != null && unreachableAlts.Count > 0 )
+                {
+                    // give different msg if it's an empty Tokens rule from delegate
+                    bool isInheritedTokensRule = false;
+                    if ( dfa.IsTokensRuleDecision )
+                    {
+                        foreach ( int altI in unreachableAlts )
+                        {
+                            GrammarAST decAST = dfa.DecisionASTNode;
+                            GrammarAST altAST = (GrammarAST)decAST.GetChild( altI - 1 );
+                            GrammarAST delegatedTokensAlt =
+                                (GrammarAST)altAST.GetFirstChildWithType( ANTLRParser.DOT );
+                            if ( delegatedTokensAlt != null )
+                            {
+                                isInheritedTokensRule = true;
+                                ErrorManager.grammarWarning( ErrorManager.MSG_IMPORTED_TOKENS_RULE_EMPTY,
+                                                            dfa.nfa.grammar,
+                                                            null,
+                                                            dfa.nfa.grammar.name,
+                                                            delegatedTokensAlt.GetChild( 0 ).Text );
+                            }
+                        }
+                    }
+                    if ( isInheritedTokensRule )
+                    {
+                    }
+                    else
+                    {
+                        ErrorManager.unreachableAlts( this, unreachableAlts );
+                    }
+                }
+            }
+        }
+
+        /** Get the last disabled alt number and check in the grammar to see
+         *  if that alt is a simple wildcard.  If so, treat like an else clause
+         *  and don't emit the error.  Strip out the last alt if it's wildcard.
+         */
+        protected virtual void stripWildCardAlts( ICollection<int> disabledAlts )
+        {
+            List<int> sortedDisableAlts = new List<int>( disabledAlts );
+            sortedDisableAlts.Sort();
+            //Collections.sort( sortedDisableAlts );
+            int lastAlt =
+                (int)sortedDisableAlts[sortedDisableAlts.Count - 1];
+            GrammarAST blockAST =
+                dfa.nfa.grammar.getDecisionBlockAST( dfa.decisionNumber );
+            //JSystem.@out.println("block with error = "+blockAST.toStringTree());
+            GrammarAST lastAltAST = null;
+            if ( blockAST.GetChild( 0 ).Type == ANTLRParser.OPTIONS )
+            {
+                // if options, skip first child: ( options { ( = greedy false ) )
+                lastAltAST = (GrammarAST)blockAST.GetChild( lastAlt );
+            }
+            else
+            {
+                lastAltAST = (GrammarAST)blockAST.GetChild( lastAlt - 1 );
+            }
+            //JSystem.@out.println("last alt is "+lastAltAST.toStringTree());
+            // if last alt looks like ( ALT . <end-of-alt> ) then wildcard
+            // Avoid looking at optional blocks etc... that have last alt
+            // as the EOB:
+            // ( BLOCK ( ALT 'else' statement <end-of-alt> ) <end-of-block> )
+            if ( lastAltAST.Type != ANTLRParser.EOB &&
+                 lastAltAST.GetChild( 0 ).Type == ANTLRParser.WILDCARD &&
+                 lastAltAST.GetChild( 1 ).Type == ANTLRParser.EOA )
+            {
+                //JSystem.@out.println("wildcard");
+                disabledAlts.Remove( lastAlt );
+            }
+        }
+
+        protected virtual void issueRecursionWarnings()
+        {
+            // RECURSION OVERFLOW
+            ICollection<int> dfaStatesWithRecursionProblems =
+                stateToRecursionOverflowConfigurationsMap.Keys;
+            // now walk truly unique (unaliased) list of dfa states with inf recur
+            // Goal: create a map from alt to map<target,IList<callsites>>
+            // Map<Map<String target, IList<NFAState call sites>>
+            IDictionary<int, IDictionary<string, ICollection<NFAState>>> altToTargetToCallSitesMap =
+                new Dictionary<int, IDictionary<string, ICollection<NFAState>>>();
+            // track a single problem DFA state for each alt
+            var altToDFAState = new Dictionary<int, DFAState>();
+            computeAltToProblemMaps( dfaStatesWithRecursionProblems,
+                                    stateToRecursionOverflowConfigurationsMap,
+                                    altToTargetToCallSitesMap, // output param
+                                    altToDFAState );            // output param
+
+            // walk each alt with recursion overflow problems and generate error
+            ICollection<int> alts = altToTargetToCallSitesMap.Keys;
+            List<int> sortedAlts = new List<int>( alts );
+            sortedAlts.Sort();
+            //Collections.sort( sortedAlts );
+            foreach ( int altI in sortedAlts )
+            {
+                var targetToCallSiteMap =
+                    altToTargetToCallSitesMap.get( altI );
+                var targetRules = targetToCallSiteMap.Keys;
+                var callSiteStates = targetToCallSiteMap.Values;
+                DFAState sampleBadState = (DFAState)altToDFAState.get( altI );
+                ErrorManager.recursionOverflow( this,
+                                               sampleBadState,
+                                               altI,
+                                               targetRules,
+                                               callSiteStates );
+            }
+        }
+
+        private void computeAltToProblemMaps( IEnumerable<int> dfaStatesUnaliased,
+                                             IDictionary<int,IList<NFAConfiguration>> configurationsMap,
+                                             IDictionary<int,IDictionary<string,ICollection<NFAState>>> altToTargetToCallSitesMap,
+                                             IDictionary<int, DFAState> altToDFAState )
+        {
+            foreach ( int stateI in dfaStatesUnaliased )
+            {
+                // walk this DFA's config list
+                IList configs = (IList)configurationsMap.get( stateI );
+                for ( int i = 0; i < configs.Count; i++ )
+                {
+                    NFAConfiguration c = (NFAConfiguration)configs[i];
+                    NFAState ruleInvocationState = dfa.nfa.getState( c.state );
+                    Transition transition0 = ruleInvocationState.transition[0];
+                    RuleClosureTransition @ref = (RuleClosureTransition)transition0;
+                    String targetRule = ( (NFAState)@ref.target ).enclosingRule.name;
+                    int altI = c.alt;
+                    IDictionary<string, ICollection<NFAState>> targetToCallSiteMap =
+                        altToTargetToCallSitesMap.get( altI );
+                    if ( targetToCallSiteMap == null )
+                    {
+                        targetToCallSiteMap = new Dictionary<string, ICollection<NFAState>>();
+                        altToTargetToCallSitesMap[altI] = targetToCallSiteMap;
+                    }
+                    ICollection<NFAState> callSites = targetToCallSiteMap.get( targetRule );
+                    if ( callSites == null )
+                    {
+                        callSites = new HashSet<NFAState>();
+                        targetToCallSiteMap[targetRule] = callSites;
+                    }
+                    callSites.Add( ruleInvocationState );
+                    // track one problem DFA state per alt
+                    if ( altToDFAState.get( altI ) == null )
+                    {
+                        DFAState sampleBadState = dfa.getState( stateI );
+                        altToDFAState[altI] = sampleBadState;
+                    }
+                }
+            }
+        }
+
+        private HashSet<object> getUnaliasedDFAStateSet( HashSet<object> dfaStatesWithRecursionProblems )
+        {
+            HashSet<object> dfaStatesUnaliased = new HashSet<object>();
+            foreach ( int stateI in dfaStatesWithRecursionProblems )
+            {
+                DFAState d = dfa.getState( stateI );
+                dfaStatesUnaliased.Add( d.stateNumber );
+            }
+            return dfaStatesUnaliased;
+        }
+
+
+        // T R A C K I N G  M E T H O D S
+
+        /** Report the fact that DFA state d is not a state resolved with
+         *  predicates and yet it has no emanating edges.  Usually this
+         *  is a result of the closure/reach operations being unable to proceed
+         */
+        public virtual void reportDanglingState( DFAState d )
+        {
+            danglingStates.Add( d );
+        }
+
+        public virtual void reportAnalysisTimeout()
+        {
+            timedOut = true;
+            dfa.nfa.grammar.setOfDFAWhoseAnalysisTimedOut.Add( dfa );
+        }
+
+        /** Report that at least 2 alts have recursive constructs.  There is
+         *  no way to build a DFA so we terminated.
+         */
+        public virtual void reportNonLLStarDecision( DFA dfa )
+        {
+            /*
+            JSystem.@out.println("non-LL(*) DFA "+dfa.decisionNumber+", alts: "+
+                               dfa.recursiveAltSet.toList());
+                               */
+            nonLLStarDecision = true;
+            altsWithProblem.addAll( dfa.recursiveAltSet.ToList() );
+        }
+
+        public virtual void reportRecursionOverflow( DFAState d,
+                                            NFAConfiguration recursionNFAConfiguration )
+        {
+            // track the state number rather than the state as d will change
+            // out from underneath us; hash wouldn't return any value
+
+            // left-recursion is detected in start state.  Since we can't
+            // call resolveNondeterminism() on the start state (it would
+            // not look k=1 to get min single token lookahead), we must
+            // prevent errors derived from this state.  Avoid start state
+            if ( d.stateNumber > 0 )
+            {
+                int stateI = d.stateNumber;
+                stateToRecursionOverflowConfigurationsMap.map( stateI, recursionNFAConfiguration );
+            }
+        }
+
+        public virtual void reportNondeterminism( DFAState d, HashSet<int> nondeterministicAlts )
+        {
+            altsWithProblem.addAll( nondeterministicAlts ); // track overall list
+            statesWithSyntacticallyAmbiguousAltsSet.Add( d );
+            dfa.nfa.grammar.setOfNondeterministicDecisionNumbers.Add(
+                dfa.DecisionNumber
+            );
+        }
+
+        /** Currently the analysis reports issues between token definitions, but
+         *  we don't print out warnings in favor of just picking the first token
+         *  definition found in the grammar ala lex/flex.
+         */
+        public virtual void reportLexerRuleNondeterminism( DFAState d, HashSet<int> nondeterministicAlts )
+        {
+            stateToSyntacticallyAmbiguousTokensRuleAltsMap[d] = nondeterministicAlts;
+        }
+
+        public virtual void reportNondeterminismResolvedWithSemanticPredicate( DFAState d )
+        {
+            // First, prevent a recursion warning on this state due to
+            // pred resolution
+            if ( d.abortedDueToRecursionOverflow )
+            {
+                d.dfa.probe.removeRecursiveOverflowState( d );
+            }
+            statesResolvedWithSemanticPredicatesSet.Add( d );
+            //JSystem.@out.println("resolved with pred: "+d);
+            dfa.nfa.grammar.setOfNondeterministicDecisionNumbersResolvedWithPredicates.Add(
+                dfa.DecisionNumber
+            );
+        }
+
+        /** Report the list of predicates found for each alternative; copy
+         *  the list because this set gets altered later by the method
+         *  tryToResolveWithSemanticPredicates() while flagging NFA configurations
+         *  in d as resolved.
+         */
+        public virtual void reportAltPredicateContext( DFAState d, IDictionary<int, SemanticContext> altPredicateContext )
+        {
+            IDictionary<int, SemanticContext> copy = new Dictionary<int, SemanticContext>( altPredicateContext );
+            //copy.putAll( altPredicateContext );
+            stateToAltSetWithSemanticPredicatesMap[d] = copy;
+        }
+
+        public virtual void reportIncompletelyCoveredAlts( DFAState d,
+                                                  IDictionary<int, ICollection<IToken>> altToLocationsReachableWithoutPredicate )
+        {
+            stateToIncompletelyCoveredAltsMap[d] = altToLocationsReachableWithoutPredicate;
+        }
+
+        // S U P P O R T
+
+        /** Given a start state and a target state, return true if start can reach
+         *  target state.  Also, compute the set of DFA states
+         *  that are on a path from start to target; return in states parameter.
+         */
+        protected virtual bool reachesState( DFAState startState,
+                                       DFAState targetState,
+                                       HashSet<object> states )
+        {
+            if ( startState == targetState )
+            {
+                states.Add( targetState );
+                //JSystem.@out.println("found target DFA state "+targetState.getStateNumber());
+                stateReachable[startState.stateNumber] = REACHABLE_YES;
+                return true;
+            }
+
+            DFAState s = startState;
+            // avoid infinite loops
+            stateReachable[s.stateNumber] = REACHABLE_BUSY;
+
+            // look for a path to targetState among transitions for this state
+            // stop when you find the first one; I'm pretty sure there is
+            // at most one path to any DFA state with conflicting predictions
+            for ( int i = 0; i < s.NumberOfTransitions; i++ )
+            {
+                Transition t = s.transition( i );
+                DFAState edgeTarget = (DFAState)t.target;
+
+                int targetStatus; //= stateReachable.get( edgeTarget.stateNumber );
+                if ( stateReachable.TryGetValue( edgeTarget.stateNumber, out targetStatus ) )
+                {
+                    if ( targetStatus == REACHABLE_BUSY )
+                    { // avoid cycles; they say nothing
+                        continue;
+                    }
+                    if ( targetStatus == REACHABLE_YES )
+                    { // return success!
+                        stateReachable[s.stateNumber] = REACHABLE_YES;
+                        return true;
+                    }
+                    if ( targetStatus == REACHABLE_NO )
+                    { // try another transition
+                        continue;
+                    }
+                }
+
+                // if null, target must be REACHABLE_UNKNOWN (i.e., unvisited)
+                if ( reachesState( edgeTarget, targetState, states ) )
+                {
+                    states.Add( s );
+                    stateReachable[s.stateNumber] = REACHABLE_YES;
+                    return true;
+                }
+            }
+
+            stateReachable[s.stateNumber] = REACHABLE_NO;
+            return false; // no path to targetState found.
+        }
+
+        protected virtual HashSet<object> getDFAPathStatesToTarget( DFAState targetState )
+        {
+            HashSet<object> dfaStates = new HashSet<object>();
+            stateReachable = new Dictionary<int, int>();
+            if ( dfa == null || dfa.startState == null )
+            {
+                return dfaStates;
+            }
+            bool reaches = reachesState( dfa.startState, targetState, dfaStates );
+            return dfaStates;
+        }
+
+        /** Given a start state and a final state, find a list of edge labels
+         *  between the two ignoring epsilon.  Limit your scan to a set of states
+         *  passed in.  This is used to show a sample input sequence that is
+         *  nondeterministic with respect to this decision.  Return IList<Label> as
+         *  a parameter.  The incoming states set must be all states that lead
+         *  from startState to targetState and no others so this algorithm doesn't
+         *  take a path that eventually leads to a state other than targetState.
+         *  Don't follow loops, leading to short (possibly shortest) path.
+         */
+        protected virtual void getSampleInputSequenceUsingStateSet( State startState,
+                                                           State targetState,
+                                                           HashSet<object> states,
+                                                           IList<Label> labels )
+        {
+            statesVisitedDuringSampleSequence.Add( startState.stateNumber );
+
+            // pick the first edge in states as the one to traverse
+            for ( int i = 0; i < startState.NumberOfTransitions; i++ )
+            {
+                Transition t = startState.getTransition( i );
+                DFAState edgeTarget = (DFAState)t.target;
+                if ( states.Contains( edgeTarget ) &&
+                     !statesVisitedDuringSampleSequence.Contains( edgeTarget.stateNumber ) )
+                {
+                    labels.Add( t.label ); // traverse edge and track label
+                    if ( edgeTarget != targetState )
+                    {
+                        // get more labels if not at target
+                        getSampleInputSequenceUsingStateSet( edgeTarget,
+                                                            targetState,
+                                                            states,
+                                                            labels );
+                    }
+                    // done with this DFA state as we've found a good path to target
+                    return;
+                }
+            }
+            labels.Add( new Label( Label.EPSILON ) ); // indicate no input found
+            // this happens on a : {p1}? a | A ;
+            //ErrorManager.error(ErrorManager.MSG_CANNOT_COMPUTE_SAMPLE_INPUT_SEQ);
+        }
+
+        /** Given a sample input sequence, you usually would like to know the
+         *  path taken through the NFA.  Return the list of NFA states visited
+         *  while matching a list of labels.  This cannot use the usual
+         *  interpreter, which does a deterministic walk.  We need to be able to
+         *  take paths that are turned off during nondeterminism resolution. So,
+         *  just do a depth-first walk traversing edges labeled with the current
+         *  label.  Return true if a path was found emanating from state s.
+         */
+        protected virtual bool getNFAPath( NFAState s,     // starting where?
+                                     int labelIndex, // 0..labels.size()-1
+                                     IList<Label> labels,    // input sequence
+                                     IList<NFAState> path )      // output list of NFA states
+        {
+            // track a visit to state s at input index labelIndex if not seen
+            String thisStateKey = getStateLabelIndexKey( s.stateNumber, labelIndex );
+            if ( statesVisitedAtInputDepth.Contains( thisStateKey ) )
+            {
+                /*
+                JSystem.@out.println("### already visited "+s.stateNumber+" previously at index "+
+                               labelIndex);
+                */
+                return false;
+            }
+            statesVisitedAtInputDepth.Add( thisStateKey );
+
+            /*
+            JSystem.@out.println("enter state "+s.stateNumber+" visited states: "+
+                               statesVisitedAtInputDepth);
+            */
+
+            // pick the first edge whose target is in states and whose
+            // label is labels[labelIndex]
+            for ( int i = 0; i < s.NumberOfTransitions; i++ )
+            {
+                Transition t = s.transition[i];
+                NFAState edgeTarget = (NFAState)t.target;
+                Label label = (Label)labels[labelIndex];
+                /*
+                JSystem.@out.println(s.stateNumber+"-"+
+                                   t.label.toString(dfa.nfa.grammar)+"->"+
+                                   edgeTarget.stateNumber+" =="+
+                                   label.toString(dfa.nfa.grammar)+"?");
+                */
+                if ( t.label.IsEpsilon || t.label.IsSemanticPredicate )
+                {
+                    // nondeterministically backtrack down epsilon edges
+                    path.Add( edgeTarget );
+                    bool found =
+                        getNFAPath( edgeTarget, labelIndex, labels, path );
+                    if ( found )
+                    {
+                        statesVisitedAtInputDepth.Remove( thisStateKey );
+                        return true; // return to "calling" state
+                    }
+                    path.RemoveAt( path.Count - 1 ); // remove; didn't work out
+                    continue; // look at the next edge
+                }
+                if ( t.label.matches( label ) )
+                {
+                    path.Add( edgeTarget );
+                    /*
+                    JSystem.@out.println("found label "+
+                                       t.label.toString(dfa.nfa.grammar)+
+                                       " at state "+s.stateNumber+"; labelIndex="+labelIndex);
+                    */
+                    if ( labelIndex == labels.Count - 1 )
+                    {
+                        // found last label; done!
+                        statesVisitedAtInputDepth.Remove( thisStateKey );
+                        return true;
+                    }
+                    // otherwise try to match remaining input
+                    bool found =
+                        getNFAPath( edgeTarget, labelIndex + 1, labels, path );
+                    if ( found )
+                    {
+                        statesVisitedAtInputDepth.Remove( thisStateKey );
+                        return true;
+                    }
+                    /*
+                    JSystem.@out.println("backtrack; path from "+s.stateNumber+"->"+
+                                       t.label.toString(dfa.nfa.grammar)+" didn't work");
+                    */
+                    path.RemoveAt( path.Count - 1 ); // remove; didn't work out
+                    continue; // keep looking for a path for labels
+                }
+            }
+            //JSystem.@out.println("no epsilon or matching edge; removing "+thisStateKey);
+            // no edge was found matching label; is ok, some state will have it
+            statesVisitedAtInputDepth.Remove( thisStateKey );
+            return false;
+        }
+
+        protected virtual String getStateLabelIndexKey( int s, int i )
+        {
+            StringBuilder buf = new StringBuilder();
+            buf.Append( s );
+            buf.Append( '_' );
+            buf.Append( i );
+            return buf.ToString();
+        }
+
+        /** From an alt number associated with artificial Tokens rule, return
+         *  the name of the token that is associated with that alt.
+         */
+        public virtual String getTokenNameForTokensRuleAlt( int alt )
+        {
+            NFAState decisionState = dfa.NFADecisionStartState;
+            NFAState altState =
+                dfa.nfa.grammar.getNFAStateForAltOfDecision( decisionState, alt );
+            NFAState decisionLeft = (NFAState)altState.transition[0].target;
+            RuleClosureTransition ruleCallEdge =
+                (RuleClosureTransition)decisionLeft.transition[0];
+            NFAState ruleStartState = (NFAState)ruleCallEdge.target;
+            //JSystem.@out.println("alt = "+decisionLeft.getEnclosingRule());
+            return ruleStartState.enclosingRule.name;
+        }
+
+        public virtual void reset()
+        {
+            stateToRecursionOverflowConfigurationsMap.Clear();
+        }
+    }
+
+}
diff --git a/Antlr3/Analysis/LL1Analyzer.cs b/Antlr3/Analysis/LL1Analyzer.cs
new file mode 100644
index 0000000..cb077c6
--- /dev/null
+++ b/Antlr3/Analysis/LL1Analyzer.cs
@@ -0,0 +1,500 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Analysis
+{
+    using System.Collections.Generic;
+    using Antlr.Runtime.JavaExtensions;
+
+    using ANTLRParser = Antlr3.Grammars.ANTLRParser;
+    using Console = System.Console;
+    using Grammar = Antlr3.Tool.Grammar;
+    using IIntSet = Antlr3.Misc.IIntSet;
+    using IntervalSet = Antlr3.Misc.IntervalSet;
+    using Rule = Antlr3.Tool.Rule;
+
+    /**
+     * Created by IntelliJ IDEA.
+     * User: parrt
+     * Date: Dec 31, 2007
+     * Time: 1:31:16 PM
+     * To change this template use File | Settings | File Templates.
+     */
+    public class LL1Analyzer
+    {
+        /**	0	if we hit end of rule and invoker should keep going (epsilon) */
+        public const int DETECT_PRED_EOR = 0;
+        /**	1	if we found a nonautobacktracking pred */
+        public const int DETECT_PRED_FOUND = 1;
+        /**	2	if we didn't find such a pred */
+        public const int DETECT_PRED_NOT_FOUND = 2;
+
+        public Grammar grammar;
+
+        /** Used during LOOK to detect computation cycles */
+        protected HashSet<NFAState> lookBusy = new HashSet<NFAState>();
+
+        public IDictionary<NFAState, LookaheadSet> FIRSTCache = new Dictionary<NFAState, LookaheadSet>();
+        public IDictionary<Rule, LookaheadSet> FOLLOWCache = new Dictionary<Rule, LookaheadSet>();
+
+        public LL1Analyzer( Grammar grammar )
+        {
+            this.grammar = grammar;
+        }
+
+        /*
+        public void computeRuleFIRSTSets() {
+            if ( getNumberOfDecisions()==0 ) {
+                createNFAs();
+            }
+            for (Iterator it = getRules().iterator(); it.hasNext();) {
+                Rule r = (Rule)it.next();
+                if ( r.isSynPred ) {
+                    continue;
+                }
+                LookaheadSet s = FIRST(r);
+                JSystem.@out.println("FIRST("+r.name+")="+s);
+            }
+        }
+        */
+
+        /*
+        public Set<String> getOverriddenRulesWithDifferentFIRST() {
+            // walk every rule in this grammar and compare FIRST set with
+            // those in imported grammars.
+            Set<String> rules = new HashSet();
+            for (Iterator it = getRules().iterator(); it.hasNext();) {
+                Rule r = (Rule)it.next();
+                //JSystem.@out.println(r.name+" FIRST="+r.FIRST);
+                for (int i = 0; i < delegates.size(); i++) {
+                    Grammar g = delegates.get(i);
+                    Rule importedRule = g.getRule(r.name);
+                    if ( importedRule != null ) { // exists in imported grammar
+                        // JSystem.@out.println(r.name+" exists in imported grammar: FIRST="+importedRule.FIRST);
+                        if ( !r.FIRST.equals(importedRule.FIRST) ) {
+                            rules.add(r.name);
+                        }
+                    }
+                }
+            }
+            return rules;
+        }
+
+        public Set<Rule> getImportedRulesSensitiveToOverriddenRulesDueToLOOK() {
+            Set<String> diffFIRSTs = getOverriddenRulesWithDifferentFIRST();
+            Set<Rule> rules = new HashSet();
+            for (Iterator it = diffFIRSTs.iterator(); it.hasNext();) {
+                String r = (String) it.next();
+                for (int i = 0; i < delegates.size(); i++) {
+                    Grammar g = delegates.get(i);
+                    Set<Rule> callers = g.ruleSensitivity.get(r);
+                    // somebody invokes rule whose FIRST changed in subgrammar?
+                    if ( callers!=null ) {
+                        rules.addAll(callers);
+                        //JSystem.@out.println(g.name+" rules "+callers+" sensitive to "+r+"; dup 'em");
+                    }
+                }
+            }
+            return rules;
+        }
+    */
+
+        /*
+        public LookaheadSet LOOK(Rule r) {
+            if ( r.FIRST==null ) {
+                r.FIRST = FIRST(r.startState);
+            }
+            return r.FIRST;
+        }
+    */
+
+        /** From an NFA state, s, find the set of all labels reachable from s.
+         *  Used to compute follow sets for error recovery.  Never computes
+         *  a FOLLOW operation.  FIRST stops at end of rules, returning EOR, unless
+         *  invoked from another rule.  I.e., routine properly handles
+         *
+         *     a : b A ;
+         *
+         *  where b is nullable.
+         *
+         *  We record with EOR_TOKEN_TYPE if we hit the end of a rule so we can
+         *  know at runtime (when these sets are used) to start walking up the
+         *  follow chain to compute the real, correct follow set (as opposed to
+         *  the FOLLOW, which is a superset).
+         *
+         *  This routine will only be used on parser and tree parser grammars.
+         */
+        public virtual LookaheadSet FIRST( NFAState s )
+        {
+            //JSystem.@out.println("> FIRST("+s.enclosingRule.name+") in rule "+s.enclosingRule);
+            lookBusy.Clear();
+            LookaheadSet look = _FIRST( s, false );
+            //JSystem.@out.println("< FIRST("+s.enclosingRule.name+") in rule "+s.enclosingRule+"="+look.toString(this.grammar));
+            return look;
+        }
+
+        public virtual LookaheadSet FOLLOW( Rule r )
+        {
+            //JSystem.@out.println("> FOLLOW("+r.name+") in rule "+r.startState.enclosingRule);
+            LookaheadSet f = FOLLOWCache.get( r );
+            if ( f != null )
+            {
+                return f;
+            }
+            f = _FIRST( r.stopState, true );
+            FOLLOWCache[r] = f;
+            //JSystem.@out.println("< FOLLOW("+r+") in rule "+r.startState.enclosingRule+"="+f.toString(this.grammar));
+            return f;
+        }
+
+        public virtual LookaheadSet LOOK( NFAState s )
+        {
+            if ( NFAToDFAConverter.debug )
+            {
+                Console.Out.WriteLine( "> LOOK(" + s + ")" );
+            }
+            lookBusy.Clear();
+            LookaheadSet look = _FIRST( s, true );
+            // FOLLOW makes no sense (at the moment!) for lexical rules.
+            if ( grammar.type != Grammar.LEXER && look.member( Label.EOR_TOKEN_TYPE ) )
+            {
+                // avoid altering FIRST reset as it is cached
+                LookaheadSet f = FOLLOW( s.enclosingRule );
+                f.orInPlace( look );
+                f.remove( Label.EOR_TOKEN_TYPE );
+                look = f;
+                //look.orInPlace(FOLLOW(s.enclosingRule));
+            }
+            else if ( grammar.type == Grammar.LEXER && look.member( Label.EOT ) )
+            {
+                // if this has EOT, lookahead is all char (all char can follow rule)
+                //look = new LookaheadSet(Label.EOT);
+                look = new LookaheadSet( IntervalSet.COMPLETE_SET );
+            }
+            if ( NFAToDFAConverter.debug )
+            {
+                Console.Out.WriteLine( "< LOOK(" + s + ")=" + look.ToString( grammar ) );
+            }
+            return look;
+        }
+
+        protected virtual LookaheadSet _FIRST( NFAState s, bool chaseFollowTransitions )
+        {
+            /*
+            JSystem.@out.println("_LOOK("+s+") in rule "+s.enclosingRule);
+            if ( s.transition[0] instanceof RuleClosureTransition ) {
+                JSystem.@out.println("go to rule "+((NFAState)s.transition[0].target).enclosingRule);
+            }
+            */
+            if ( !chaseFollowTransitions && s.IsAcceptState )
+            {
+                if ( grammar.type == Grammar.LEXER )
+                {
+                    // FOLLOW makes no sense (at the moment!) for lexical rules.
+                    // assume all char can follow
+                    return new LookaheadSet( IntervalSet.COMPLETE_SET );
+                }
+                return new LookaheadSet( Label.EOR_TOKEN_TYPE );
+            }
+
+            if ( lookBusy.Contains( s ) )
+            {
+                // return a copy of an empty set; we may modify set inline
+                return new LookaheadSet();
+            }
+            lookBusy.Add( s );
+
+            Transition transition0 = s.transition[0];
+            if ( transition0 == null )
+            {
+                return null;
+            }
+
+            if ( transition0.label.IsAtom )
+            {
+                int atom = transition0.label.Atom;
+                return new LookaheadSet( atom );
+            }
+            if ( transition0.label.IsSet )
+            {
+                IIntSet sl = transition0.label.Set;
+                return new LookaheadSet( sl );
+            }
+
+            // compute FIRST of transition 0
+            LookaheadSet tset = null;
+            // if transition 0 is a rule call and we don't want FOLLOW, check cache
+            if ( !chaseFollowTransitions && transition0 is RuleClosureTransition )
+            {
+                LookaheadSet prev = FIRSTCache.get( (NFAState)transition0.target );
+                if ( prev != null )
+                {
+                    tset = new LookaheadSet( prev );
+                }
+            }
+
+            // if not in cache, must compute
+            if ( tset == null )
+            {
+                tset = _FIRST( (NFAState)transition0.target, chaseFollowTransitions );
+                // save FIRST cache for transition 0 if rule call
+                if ( !chaseFollowTransitions && transition0 is RuleClosureTransition )
+                {
+                    FIRSTCache[(NFAState)transition0.target] = tset;
+                }
+            }
+
+            // did we fall off the end?
+            if ( grammar.type != Grammar.LEXER && tset.member( Label.EOR_TOKEN_TYPE ) )
+            {
+                if ( transition0 is RuleClosureTransition )
+                {
+                    // we called a rule that found the end of the rule.
+                    // That means the rule is nullable and we need to
+                    // keep looking at what follows the rule ref.  E.g.,
+                    // a : b A ; where b is nullable means that LOOK(a)
+                    // should include A.
+                    RuleClosureTransition ruleInvocationTrans =
+                        (RuleClosureTransition)transition0;
+                    // remove the EOR and get what follows
+                    //tset.remove(Label.EOR_TOKEN_TYPE);
+                    NFAState following = (NFAState)ruleInvocationTrans.followState;
+                    LookaheadSet fset = _FIRST( following, chaseFollowTransitions );
+                    fset.orInPlace( tset ); // tset cached; or into new set
+                    fset.remove( Label.EOR_TOKEN_TYPE );
+                    tset = fset;
+                }
+            }
+
+            Transition transition1 = s.transition[1];
+            if ( transition1 != null )
+            {
+                LookaheadSet tset1 =
+                    _FIRST( (NFAState)transition1.target, chaseFollowTransitions );
+                tset1.orInPlace( tset ); // tset cached; or into new set
+                tset = tset1;
+            }
+
+            return tset;
+        }
+
+        /** Is there a non-syn-pred predicate visible from s that is not in
+         *  the rule enclosing s?  This accounts for most predicate situations
+         *  and lets ANTLR do a simple LL(1)+pred computation.
+         *
+         *  TODO: what about gated vs regular preds?
+         */
+        public bool detectConfoundingPredicates( NFAState s )
+        {
+            lookBusy.Clear();
+            Rule r = s.enclosingRule;
+            return _detectConfoundingPredicates( s, r, false ) == DETECT_PRED_FOUND;
+        }
+
+        protected int _detectConfoundingPredicates( NFAState s,
+                                                   Rule enclosingRule,
+                                                   bool chaseFollowTransitions )
+        {
+            //JSystem.@out.println("_detectNonAutobacktrackPredicates("+s+")");
+            if ( !chaseFollowTransitions && s.IsAcceptState )
+            {
+                if ( grammar.type == Grammar.LEXER )
+                {
+                    // FOLLOW makes no sense (at the moment!) for lexical rules.
+                    // assume all char can follow
+                    return DETECT_PRED_NOT_FOUND;
+                }
+                return DETECT_PRED_EOR;
+            }
+
+            if ( lookBusy.Contains( s ) )
+            {
+                // return a copy of an empty set; we may modify set inline
+                return DETECT_PRED_NOT_FOUND;
+            }
+            lookBusy.Add( s );
+
+            Transition transition0 = s.transition[0];
+            if ( transition0 == null )
+            {
+                return DETECT_PRED_NOT_FOUND;
+            }
+
+            if ( !( transition0.label.IsSemanticPredicate ||
+                   transition0.label.IsEpsilon ) )
+            {
+                return DETECT_PRED_NOT_FOUND;
+            }
+
+            if ( transition0.label.IsSemanticPredicate )
+            {
+                //JSystem.@out.println("pred "+transition0.label);
+                SemanticContext ctx = transition0.label.SemanticContext;
+                SemanticContext.Predicate p = (SemanticContext.Predicate)ctx;
+                if ( p.predicateAST.Type != ANTLRParser.BACKTRACK_SEMPRED )
+                {
+                    return DETECT_PRED_FOUND;
+                }
+            }
+
+            /*
+            if ( transition0.label.isSemanticPredicate() ) {
+                JSystem.@out.println("pred "+transition0.label);
+                SemanticContext ctx = transition0.label.getSemanticContext();
+                SemanticContext.Predicate p = (SemanticContext.Predicate)ctx;
+                // if a non-syn-pred found not in enclosingRule, say we found one
+                if ( p.predicateAST.getType() != ANTLRParser.BACKTRACK_SEMPRED &&
+                     !p.predicateAST.enclosingRuleName.equals(enclosingRule.name) )
+                {
+                    JSystem.@out.println("found pred "+p+" not in "+enclosingRule.name);
+                    return DETECT_PRED_FOUND;
+                }
+            }
+            */
+
+            int result = _detectConfoundingPredicates( (NFAState)transition0.target,
+                                                      enclosingRule,
+                                                      chaseFollowTransitions );
+            if ( result == DETECT_PRED_FOUND )
+            {
+                return DETECT_PRED_FOUND;
+            }
+
+            if ( result == DETECT_PRED_EOR )
+            {
+                if ( transition0 is RuleClosureTransition )
+                {
+                    // we called a rule that found the end of the rule.
+                    // That means the rule is nullable and we need to
+                    // keep looking at what follows the rule ref.  E.g.,
+                    // a : b A ; where b is nullable means that LOOK(a)
+                    // should include A.
+                    RuleClosureTransition ruleInvocationTrans =
+                        (RuleClosureTransition)transition0;
+                    NFAState following = (NFAState)ruleInvocationTrans.followState;
+                    int afterRuleResult =
+                        _detectConfoundingPredicates( following,
+                                                     enclosingRule,
+                                                     chaseFollowTransitions );
+                    if ( afterRuleResult == DETECT_PRED_FOUND )
+                    {
+                        return DETECT_PRED_FOUND;
+                    }
+                }
+            }
+
+            Transition transition1 = s.transition[1];
+            if ( transition1 != null )
+            {
+                int t1Result =
+                    _detectConfoundingPredicates( (NFAState)transition1.target,
+                                                 enclosingRule,
+                                                 chaseFollowTransitions );
+                if ( t1Result == DETECT_PRED_FOUND )
+                {
+                    return DETECT_PRED_FOUND;
+                }
+            }
+
+            return DETECT_PRED_NOT_FOUND;
+        }
+
+        /** Return predicate expression found via epsilon edges from s.  Do
+         *  not look into other rules for now.  Do something simple.  Include
+         *  backtracking synpreds.
+         */
+        public virtual SemanticContext getPredicates( NFAState altStartState )
+        {
+            lookBusy.Clear();
+            return _getPredicates( altStartState, altStartState );
+        }
+
+        protected virtual SemanticContext _getPredicates( NFAState s, NFAState altStartState )
+        {
+            //JSystem.@out.println("_getPredicates("+s+")");
+            if ( s.IsAcceptState )
+            {
+                return null;
+            }
+
+            // avoid infinite loops from (..)* etc...
+            if ( lookBusy.Contains( s ) )
+            {
+                return null;
+            }
+            lookBusy.Add( s );
+
+            Transition transition0 = s.transition[0];
+            // no transitions
+            if ( transition0 == null )
+            {
+                return null;
+            }
+
+            // not a predicate and not even an epsilon
+            if ( !( transition0.label.IsSemanticPredicate ||
+                   transition0.label.IsEpsilon ) )
+            {
+                return null;
+            }
+
+            SemanticContext p = null;
+            SemanticContext p0 = null;
+            SemanticContext p1 = null;
+            if ( transition0.label.IsSemanticPredicate )
+            {
+                //JSystem.@out.println("pred "+transition0.label);
+                p = transition0.label.SemanticContext;
+                // ignore backtracking preds not on left edge for this decision
+                if ( ( (SemanticContext.Predicate)p ).predicateAST.Type ==
+                      ANTLRParser.BACKTRACK_SEMPRED &&
+                     s == altStartState.transition[0].target )
+                {
+                    p = null; // don't count
+                }
+            }
+
+            // get preds from beyond this state
+            p0 = _getPredicates( (NFAState)transition0.target, altStartState );
+
+            // get preds from other transition
+            Transition transition1 = s.transition[1];
+            if ( transition1 != null )
+            {
+                p1 = _getPredicates( (NFAState)transition1.target, altStartState );
+            }
+
+            // join this&following-right|following-down
+            return SemanticContext.and( p, SemanticContext.or( p0, p1 ) );
+        }
+    }
+}
diff --git a/Antlr3/Analysis/LL1DFA.cs b/Antlr3/Analysis/LL1DFA.cs
new file mode 100644
index 0000000..3deff53
--- /dev/null
+++ b/Antlr3/Analysis/LL1DFA.cs
@@ -0,0 +1,201 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Analysis
+{
+    using System.Collections.Generic;
+    using System.Linq;
+    using Antlr3.Misc;
+    using Antlr.Runtime.JavaExtensions;
+
+    using ANTLRParser = Antlr3.Grammars.ANTLRParser;
+
+    /** A special DFA that is exactly LL(1) or LL(1) with backtracking mode
+     *  predicates to resolve edge set collisions.
+     */
+    public class LL1DFA : DFA
+    {
+        /** From list of lookahead sets (one per alt in decision), create
+         *  an LL(1) DFA.  One edge per set.
+         *
+         *  s0-{alt1}->:o=>1
+         *  | \
+         *  |  -{alt2}->:o=>2
+         *  |
+         *  ...
+         */
+        public LL1DFA( int decisionNumber, NFAState decisionStartState, LookaheadSet[] altLook )
+        {
+            DFAState s0 = newState();
+            startState = s0;
+            nfa = decisionStartState.nfa;
+            nAlts = nfa.grammar.getNumberOfAltsForDecisionNFA( decisionStartState );
+            this.decisionNumber = decisionNumber;
+            this.decisionNFAStartState = decisionStartState;
+            initAltRelatedInfo();
+            unreachableAlts = null;
+            for ( int alt = 1; alt < altLook.Length; alt++ )
+            {
+                DFAState acceptAltState = newState();
+                acceptAltState.acceptState = true;
+                setAcceptState( alt, acceptAltState );
+                acceptAltState.k = 1;
+                acceptAltState.cachedUniquelyPredicatedAlt = alt;
+                Label e = getLabelForSet( altLook[alt].tokenTypeSet );
+                s0.addTransition( acceptAltState, e );
+            }
+        }
+
+        /** From a set of edgeset->list-of-alts mappings, create a DFA
+         *  that uses syn preds for all |list-of-alts|>1.
+         */
+        public LL1DFA( int decisionNumber,
+                      NFAState decisionStartState,
+                      MultiMap<IntervalSet, int> edgeMap )
+        {
+            DFAState s0 = newState();
+            startState = s0;
+            nfa = decisionStartState.nfa;
+            nAlts = nfa.grammar.getNumberOfAltsForDecisionNFA( decisionStartState );
+            this.decisionNumber = decisionNumber;
+            this.decisionNFAStartState = decisionStartState;
+            initAltRelatedInfo();
+            unreachableAlts = null;
+            foreach ( var edgeVar in edgeMap )
+            {
+                IntervalSet edge = edgeVar.Key;
+                IList<int> alts = edgeVar.Value;
+                alts = alts.OrderBy( i => i ).ToList();
+                //Collections.sort( alts ); // make sure alts are attempted in order
+                //JSystem.@out.println(edge+" -> "+alts);
+                DFAState s = newState();
+                s.k = 1;
+                Label e = getLabelForSet( edge );
+                s0.addTransition( s, e );
+                if ( alts.Count == 1 )
+                {
+                    s.acceptState = true;
+                    int alt = alts[0];
+                    setAcceptState( alt, s );
+                    s.cachedUniquelyPredicatedAlt = alt;
+                }
+                else
+                {
+                    // resolve with syntactic predicates.  Add edges from
+                    // state s that test predicates.
+                    s.resolvedWithPredicates = true;
+                    for ( int i = 0; i < alts.Count; i++ )
+                    {
+                        int alt = (int)alts[i];
+                        s.cachedUniquelyPredicatedAlt = NFA.INVALID_ALT_NUMBER;
+                        DFAState predDFATarget = getAcceptState( alt );
+                        if ( predDFATarget == null )
+                        {
+                            predDFATarget = newState(); // create if not there.
+                            predDFATarget.acceptState = true;
+                            predDFATarget.cachedUniquelyPredicatedAlt = alt;
+                            setAcceptState( alt, predDFATarget );
+                        }
+                        // add a transition to pred target from d
+                        /*
+                        int walkAlt =
+                            decisionStartState.translateDisplayAltToWalkAlt(alt);
+                        NFAState altLeftEdge = nfa.grammar.getNFAStateForAltOfDecision(decisionStartState, walkAlt);
+                        NFAState altStartState = (NFAState)altLeftEdge.transition[0].target;
+                        SemanticContext ctx = nfa.grammar.ll1Analyzer.getPredicates(altStartState);
+                        JSystem.@out.println("sem ctx = "+ctx);
+                        if ( ctx == null ) {
+                            ctx = new SemanticContext.TruePredicate();
+                        }
+                        s.addTransition(predDFATarget, new Label(ctx));
+                        */
+                        SemanticContext.Predicate synpred =
+                            getSynPredForAlt( decisionStartState, alt );
+                        if ( synpred == null )
+                        {
+                            synpred = new SemanticContext.TruePredicate();
+                        }
+                        s.addTransition( predDFATarget, new PredicateLabel( synpred ) );
+                    }
+                }
+            }
+            //JSystem.@out.println("dfa for preds=\n"+this);
+        }
+
+        protected virtual Label getLabelForSet( IntervalSet edgeSet )
+        {
+            Label e = null;
+            int atom = edgeSet.getSingleElement();
+            if ( atom != Label.INVALID )
+            {
+                e = new Label( atom );
+            }
+            else
+            {
+                e = new Label( edgeSet );
+            }
+            return e;
+        }
+
+        protected virtual SemanticContext.Predicate getSynPredForAlt( NFAState decisionStartState,
+                                                             int alt )
+        {
+            int walkAlt =
+                decisionStartState.translateDisplayAltToWalkAlt( alt );
+            NFAState altLeftEdge =
+                nfa.grammar.getNFAStateForAltOfDecision( decisionStartState, walkAlt );
+            NFAState altStartState = (NFAState)altLeftEdge.transition[0].target;
+            //JSystem.@out.println("alt "+alt+" start state = "+altStartState.stateNumber);
+            if ( altStartState.transition[0].IsSemanticPredicate )
+            {
+                SemanticContext ctx = altStartState.transition[0].label.SemanticContext;
+                if ( ctx.IsSyntacticPredicate )
+                {
+                    SemanticContext.Predicate p = (SemanticContext.Predicate)ctx;
+                    if ( p.predicateAST.Type == ANTLRParser.BACKTRACK_SEMPRED )
+                    {
+                        /*
+                        JSystem.@out.println("syn pred for alt "+walkAlt+" "+
+                                           ((SemanticContext.Predicate)altStartState.transition[0].label.getSemanticContext()).predicateAST);
+                        */
+                        if ( ctx.IsSyntacticPredicate )
+                        {
+                            nfa.grammar.synPredUsedInDFA( this, ctx );
+                        }
+                        return (SemanticContext.Predicate)altStartState.transition[0].label.SemanticContext;
+                    }
+                }
+            }
+            return null;
+        }
+    }
+}
diff --git a/Antlr3/Analysis/Label.cs b/Antlr3/Analysis/Label.cs
new file mode 100644
index 0000000..57f8649
--- /dev/null
+++ b/Antlr3/Analysis/Label.cs
@@ -0,0 +1,465 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Analysis
+{
+    using Grammar = Antlr3.Tool.Grammar;
+    using ICloneable = System.ICloneable;
+    using IComparable = System.IComparable;
+    using IIntSet = Antlr3.Misc.IIntSet;
+    using InvalidOperationException = System.InvalidOperationException;
+    using IntervalSet = Antlr3.Misc.IntervalSet;
+    using TokenConstants = Antlr.Runtime.TokenConstants;
+
+    /** A state machine transition label.  A label can be either a simple
+     *  label such as a token or character.  A label can be a set of char or
+     *  tokens.  It can be an epsilon transition.  It can be a semantic predicate
+     *  (which assumes an epsilon transition) or a tree of predicates (in a DFA).
+     */
+    public class Label : IComparable, ICloneable
+    {
+        public const int INVALID = -7;
+
+        public const int ACTION = -6;
+
+        public const int EPSILON = -5;
+
+        public const string EPSILON_STR = "<EPSILON>";
+
+        /** label is a semantic predicate; implies label is epsilon also */
+        public const int SEMPRED = -4;
+
+        /** label is a set of tokens or char */
+        public const int SET = -3;
+
+        /** End of Token is like EOF for lexer rules.  It implies that no more
+         *  characters are available and that NFA conversion should terminate
+         *  for this path.  For example
+         *
+         *  A : 'a' 'b' | 'a' ;
+         *
+         *  yields a DFA predictor:
+         *
+         *  o-a->o-b->1   predict alt 1
+         *       |
+         *       |-EOT->o predict alt 2
+         *
+         *  To generate code for EOT, treat it as the "default" path, which
+         *  implies there is no way to mismatch a char for the state from
+         *  which the EOT emanates.
+         */
+        public const int EOT = -2;
+
+        public const int EOF = -1;
+
+        /** We have labels like EPSILON that are below 0; it's hard to
+         *  store them in an array with negative index so use this
+         *  constant as an index shift when accessing arrays based upon
+         *  token type.  If real token type is i, then array index would be
+         *  NUM_FAUX_LABELS + i.
+         */
+        public const int NUM_FAUX_LABELS = -INVALID;
+
+        /** Anything at this value or larger can be considered a simple atom int
+         *  for easy comparison during analysis only; faux labels are not used
+         *  during parse time for real token types or char values.
+         */
+        public const int MIN_ATOM_VALUE = EOT;
+
+        // TODO: is 0 a valid unicode char? max is FFFF -1, right?
+        public const int MIN_CHAR_VALUE = '\u0000';
+        public const int MAX_CHAR_VALUE = '\uFFFF';
+
+        /** End of rule token type; imaginary token type used only for
+         *  local, partial FOLLOW sets to indicate that the local FOLLOW
+         *  hit the end of rule.  During error recovery, the local FOLLOW
+         *  of a token reference may go beyond the end of the rule and have
+         *  to use FOLLOW(rule).  I have to just shift the token types to 2..n
+         *  rather than 1..n to accommodate this imaginary token in my bitsets.
+         *  If I didn't use a bitset implementation for runtime sets, I wouldn't
+         *  need this.  EOF is another candidate for a run time token type for
+         *  parsers.  Follow sets are not computed for lexers so we do not have
+         *  this issue.
+         */
+        public const int EOR_TOKEN_TYPE =
+            TokenConstants.EOR_TOKEN_TYPE;
+
+        public const int DOWN = TokenConstants.DOWN;
+        public const int UP = TokenConstants.UP;
+
+        /** tokens and char range overlap; tokens are MIN_TOKEN_TYPE..n */
+        public const int MIN_TOKEN_TYPE =
+            TokenConstants.MIN_TOKEN_TYPE;
+
+        /** The wildcard '.' char atom implies all valid characters==UNICODE */
+        //public static final IntSet ALLCHAR = IntervalSet.of(MIN_CHAR_VALUE,MAX_CHAR_VALUE);
+
+        /** The token type or character value; or, signifies special label. */
+        protected internal int label;
+
+        /** A set of token types or character codes if label==SET */
+        // TODO: try IntervalSet for everything
+        protected IIntSet labelSet;
+
+        public Label( int label )
+        {
+            this.label = label;
+        }
+
+        /** Make a set label */
+        public Label( IIntSet labelSet )
+        {
+            if ( labelSet == null )
+            {
+                this.label = SET;
+                this.labelSet = IntervalSet.of( INVALID );
+                return;
+            }
+            int singleAtom = labelSet.getSingleElement();
+            if ( singleAtom != INVALID )
+            {
+                // convert back to a single atomic element if |labelSet|==1
+                label = singleAtom;
+                return;
+            }
+            this.label = SET;
+            this.labelSet = labelSet;
+        }
+
+        #region Properties
+        /** return the single atom label or INVALID if not a single atom */
+        public virtual int Atom
+        {
+            get
+            {
+                if ( IsAtom )
+                {
+                    return label;
+                }
+                return INVALID;
+            }
+        }
+        public virtual bool IsAction
+        {
+            get
+            {
+                return false;
+            }
+        }
+        public virtual bool IsAtom
+        {
+            get
+            {
+                return label >= MIN_ATOM_VALUE;
+            }
+        }
+        public virtual bool IsEpsilon
+        {
+            get
+            {
+                return label == EPSILON;
+            }
+        }
+        public virtual bool IsSemanticPredicate
+        {
+            get
+            {
+                return false;
+            }
+        }
+        public virtual bool IsSet
+        {
+            get
+            {
+                return label == SET;
+            }
+        }
+        public virtual SemanticContext SemanticContext
+        {
+            get
+            {
+                return null;
+            }
+        }
+        public virtual IIntSet Set
+        {
+            get
+            {
+                if ( label != SET )
+                {
+                    // convert single element to a set if they ask for it.
+                    return IntervalSet.of( label );
+                }
+                return labelSet;
+            }
+            set
+            {
+                label = SET;
+                labelSet = value;
+            }
+        }
+        #endregion
+
+        public virtual object Clone()
+        {
+            Label l;
+            //try
+            //{
+                //l = (Label)base.clone();
+                l = new Label( label );
+                l.label = this.label;
+                l.labelSet = new IntervalSet();
+                l.labelSet.addAll( this.labelSet );
+            //}
+            //catch ( CloneNotSupportedException e )
+            //{
+            //    throw new InternalError();
+            //}
+            return l;
+        }
+
+        public virtual void add( Label a )
+        {
+            if ( IsAtom )
+            {
+                labelSet = IntervalSet.of( label );
+                label = SET;
+                if ( a.IsAtom )
+                {
+                    labelSet.add( a.Atom );
+                }
+                else if ( a.IsSet )
+                {
+                    labelSet.addAll( a.Set );
+                }
+                else
+                {
+                    throw new InvalidOperationException( "can't add element to Label of type " + label );
+                }
+                return;
+            }
+            if ( IsSet )
+            {
+                if ( a.IsAtom )
+                {
+                    labelSet.add( a.Atom );
+                }
+                else if ( a.IsSet )
+                {
+                    labelSet.addAll( a.Set );
+                }
+                else
+                {
+                    throw new InvalidOperationException( "can't add element to Label of type " + label );
+                }
+                return;
+            }
+            throw new InvalidOperationException( "can't add element to Label of type " + label );
+        }
+
+        public virtual bool matches( int atom )
+        {
+            if ( label == atom )
+            {
+                return true; // handle the single atom case efficiently
+            }
+            if ( IsSet )
+            {
+                return labelSet.member( atom );
+            }
+            return false;
+        }
+
+        public virtual bool matches( IIntSet set )
+        {
+            if ( IsAtom )
+            {
+                return set.member( Atom );
+            }
+            if ( IsSet )
+            {
+                // matches if intersection non-nil
+                return !Set.and( set ).isNil();
+            }
+            return false;
+        }
+
+
+        public virtual bool matches( Label other )
+        {
+            if ( other.IsSet )
+            {
+                return matches( other.Set );
+            }
+            if ( other.IsAtom )
+            {
+                return matches( other.Atom );
+            }
+            return false;
+        }
+
+        public override int GetHashCode()
+        {
+            if ( label == SET )
+            {
+                return labelSet.GetHashCode();
+            }
+            else
+            {
+                return label;
+            }
+        }
+
+        // TODO: do we care about comparing set {A} with atom A? Doesn't now.
+        public override bool Equals( object o )
+        {
+            if ( o == null )
+            {
+                return false;
+            }
+            if ( this == o )
+            {
+                return true; // equals if same object
+            }
+            // labels must be the same even if epsilon or set or sempred etc...
+            if ( label != ( (Label)o ).label )
+            {
+                return false;
+            }
+            if ( label == SET )
+            {
+                return this.labelSet.Equals( ( (Label)o ).labelSet );
+            }
+            return true;  // label values are same, so true
+        }
+
+        public virtual int CompareTo( object o )
+        {
+            return this.label - ( (Label)o ).label;
+        }
+
+        /** Predicates are lists of AST nodes from the NFA created from the
+         *  grammar, but the same predicate could be cut/paste into multiple
+         *  places in the grammar.  I must compare the text of all the
+         *  predicates to truly answer whether {p1,p2} .equals {p1,p2}.
+         *  Unfortunately, I cannot rely on the AST.equals() to work properly
+         *  so I must do a brute force O(n^2) nested traversal of the Set
+         *  doing a String compare.
+         *
+         *  At this point, Labels are not compared for equals when they are
+         *  predicates, but here's the code for future use.
+         */
+        /*
+        protected boolean predicatesEquals(Set others) {
+            Iterator iter = semanticContext.iterator();
+            while (iter.hasNext()) {
+                AST predAST = (AST) iter.next();
+                Iterator inner = semanticContext.iterator();
+                while (inner.hasNext()) {
+                    AST otherPredAST = (AST) inner.next();
+                    if ( !predAST.getText().equals(otherPredAST.getText()) ) {
+                        return false;
+                    }
+                }
+            }
+            return true;
+        }
+          */
+
+        public override string ToString()
+        {
+            switch ( label )
+            {
+            case SET:
+                return labelSet.ToString();
+            default:
+                return label.ToString(); //String.valueOf( label );
+            }
+        }
+
+        public virtual string ToString( Grammar g )
+        {
+            switch ( label )
+            {
+            case SET:
+                return labelSet.ToString( g );
+            default:
+                return g.getTokenDisplayName( label );
+            }
+        }
+
+        /*
+        public String predicatesToString() {
+            if ( semanticContext==NFAConfiguration.DEFAULT_CLAUSE_SEMANTIC_CONTEXT ) {
+                return "!other preds";
+            }
+            StringBuffer buf = new StringBuffer();
+            Iterator iter = semanticContext.iterator();
+            while (iter.hasNext()) {
+                AST predAST = (AST) iter.next();
+                buf.append(predAST.getText());
+                if ( iter.hasNext() ) {
+                    buf.append("&");
+                }
+            }
+            return buf.toString();
+        }
+        */
+
+        public static bool intersect( Label label, Label edgeLabel )
+        {
+            bool hasIntersection = false;
+            bool labelIsSet = label.IsSet;
+            bool edgeIsSet = edgeLabel.IsSet;
+            if ( !labelIsSet && !edgeIsSet && edgeLabel.label == label.label )
+            {
+                hasIntersection = true;
+            }
+            else if ( labelIsSet && edgeIsSet &&
+                      !edgeLabel.Set.and( label.Set ).isNil() )
+            {
+                hasIntersection = true;
+            }
+            else if ( labelIsSet && !edgeIsSet &&
+                      label.Set.member( edgeLabel.label ) )
+            {
+                hasIntersection = true;
+            }
+            else if ( !labelIsSet && edgeIsSet &&
+                      edgeLabel.Set.member( label.label ) )
+            {
+                hasIntersection = true;
+            }
+            return hasIntersection;
+        }
+    }
+}
diff --git a/Antlr3/Analysis/LookaheadSet.cs b/Antlr3/Analysis/LookaheadSet.cs
new file mode 100644
index 0000000..63da25a
--- /dev/null
+++ b/Antlr3/Analysis/LookaheadSet.cs
@@ -0,0 +1,142 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Analysis
+{
+    using Grammar = Antlr3.Tool.Grammar;
+    using IIntSet = Antlr3.Misc.IIntSet;
+    using IntervalSet = Antlr3.Misc.IntervalSet;
+
+    /** An LL(1) lookahead set; contains a set of token types and a "hasEOF"
+     *  condition when the set contains EOF.  Since EOF is -1 everywhere and -1
+     *  cannot be stored in my BitSet, I set a condition here.  There may be other
+     *  reasons in the future to abstract a LookaheadSet over a raw BitSet.
+     */
+    public class LookaheadSet
+    {
+        public IntervalSet tokenTypeSet;
+
+        public LookaheadSet()
+        {
+            tokenTypeSet = new IntervalSet();
+        }
+
+        public LookaheadSet( IIntSet s )
+            : this()
+        {
+            tokenTypeSet.addAll( s );
+        }
+
+        public LookaheadSet( int atom )
+        {
+            tokenTypeSet = IntervalSet.of( atom );
+        }
+
+        public LookaheadSet( LookaheadSet other )
+            : this()
+        {
+            this.tokenTypeSet.addAll( other.tokenTypeSet );
+        }
+
+        #region Properties
+        public bool IsNil
+        {
+            get
+            {
+                return isNil();
+            }
+        }
+        #endregion
+
+        public virtual void orInPlace( LookaheadSet other )
+        {
+            this.tokenTypeSet.addAll( other.tokenTypeSet );
+        }
+
+        public virtual LookaheadSet or( LookaheadSet other )
+        {
+            return new LookaheadSet( tokenTypeSet.or( other.tokenTypeSet ) );
+        }
+
+        public virtual LookaheadSet subtract( LookaheadSet other )
+        {
+            return new LookaheadSet( this.tokenTypeSet.subtract( other.tokenTypeSet ) );
+        }
+
+        public virtual bool member( int a )
+        {
+            return tokenTypeSet.member( a );
+        }
+
+        public virtual LookaheadSet intersection( LookaheadSet s )
+        {
+            IIntSet i = this.tokenTypeSet.and( s.tokenTypeSet );
+            LookaheadSet intersection = new LookaheadSet( i );
+            return intersection;
+        }
+
+        public virtual bool isNil()
+        {
+            return tokenTypeSet.isNil();
+        }
+
+        public virtual void remove( int a )
+        {
+            tokenTypeSet = (IntervalSet)tokenTypeSet.subtract( IntervalSet.of( a ) );
+        }
+
+        public override int GetHashCode()
+        {
+            return tokenTypeSet.GetHashCode();
+        }
+
+        public override bool Equals( object other )
+        {
+            return tokenTypeSet.Equals( ( (LookaheadSet)other ).tokenTypeSet );
+        }
+
+        public virtual string ToString( Grammar g )
+        {
+            if ( tokenTypeSet == null )
+            {
+                return "";
+            }
+            string r = tokenTypeSet.ToString( g );
+            return r;
+        }
+
+        public override string ToString()
+        {
+            return ToString( null );
+        }
+    }
+}
diff --git a/Antlr3/Analysis/NFA.cs b/Antlr3/Analysis/NFA.cs
new file mode 100644
index 0000000..8665487
--- /dev/null
+++ b/Antlr3/Analysis/NFA.cs
@@ -0,0 +1,89 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Analysis
+{
+    using Grammar = Antlr3.Tool.Grammar;
+    using NFAFactory = Antlr3.Tool.NFAFactory;
+
+    /** An NFA (collection of NFAStates) constructed from a grammar.  This
+     *  NFA is one big machine for entire grammar.  Decision points are recorded
+     *  by the Grammar object so we can, for example, convert to DFA or simulate
+     *  the NFA (interpret a decision).
+     */
+    public class NFA
+    {
+        public const int INVALID_ALT_NUMBER = -1;
+
+        /** This NFA represents which grammar? */
+        public Grammar grammar;
+
+        /** Which factory created this NFA? */
+        protected NFAFactory factory = null;
+
+        public bool complete;
+
+        public NFA( Grammar g )
+        {
+            this.grammar = g;
+        }
+
+        #region Properties
+        public NFAFactory Factory
+        {
+            get
+            {
+                return factory;
+            }
+            set
+            {
+                factory = value;
+            }
+        }
+        #endregion
+
+        public int getNewNFAStateNumber()
+        {
+            return grammar.composite.getNewNFAStateNumber();
+        }
+
+        public void addState( NFAState state )
+        {
+            grammar.composite.addState( state );
+        }
+
+        public NFAState getState( int s )
+        {
+            return grammar.composite.getState( s );
+        }
+    }
+}
diff --git a/Antlr3/Analysis/NFAConfiguration.cs b/Antlr3/Analysis/NFAConfiguration.cs
new file mode 100644
index 0000000..b33050e
--- /dev/null
+++ b/Antlr3/Analysis/NFAConfiguration.cs
@@ -0,0 +1,169 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Analysis
+{
+    using StringBuilder = System.Text.StringBuilder;
+
+    /** An NFA state, predicted alt, and syntactic/semantic context.
+     *  The syntactic context is a pointer into the rule invocation
+     *  chain used to arrive at the state.  The semantic context is
+     *  the unordered set semantic predicates encountered before reaching
+     *  an NFA state.
+     */
+    public class NFAConfiguration
+    {
+        /** The NFA state associated with this configuration */
+        public int state;
+
+        /** What alt is predicted by this configuration */
+        public int alt;
+
+        /** What is the stack of rule invocations that got us to state? */
+        public NFAContext context;
+
+        /** The set of semantic predicates associated with this NFA
+         *  configuration.  The predicates were found on the way to
+         *  the associated NFA state in this syntactic context.
+         *  Set<AST>: track nodes in grammar containing the predicate
+         *  for error messages and such (nice to know where the predicate
+         *  came from in case of duplicates etc...).  By using a set,
+         *  the equals() method will correctly show {pred1,pred2} as equals()
+         *  to {pred2,pred1}.
+         */
+        public SemanticContext semanticContext = SemanticContext.EMPTY_SEMANTIC_CONTEXT;
+
+        /** Indicate that this configuration has been resolved and no further
+         *  DFA processing should occur with it.  Essentially, this is used
+         *  as an "ignore" bit so that upon a set of nondeterministic configurations
+         *  such as (s|2) and (s|3), I can set (s|3) to resolved=true (and any
+         *  other configuration associated with alt 3).
+         */
+        protected internal bool resolved;
+
+        /** This bit is used to indicate a semantic predicate will be
+         *  used to resolve the conflict.  Method
+         *  DFA.findNewDFAStatesAndAddDFATransitions will add edges for
+         *  the predicates after it performs the reach operation.  The
+         *  nondeterminism resolver sets this when it finds a set of
+         *  nondeterministic configurations (as it does for "resolved" field)
+         *  that have enough predicates to resolve the conflit.
+         */
+        protected internal bool resolveWithPredicate;
+
+        /** Lots of NFA states have only epsilon edges (1 or 2).  We can
+         *  safely consider only n>0 during closure.
+         */
+        protected int numberEpsilonTransitionsEmanatingFromState;
+
+        /** Indicates that the NFA state associated with this configuration
+         *  has exactly one transition and it's an atom (not epsilon etc...).
+         */
+        protected internal bool singleAtomTransitionEmanating;
+
+        //protected boolean addedDuringClosure = true;
+
+        public NFAConfiguration( int state,
+                                int alt,
+                                NFAContext context,
+                                SemanticContext semanticContext )
+        {
+            this.state = state;
+            this.alt = alt;
+            this.context = context;
+            this.semanticContext = semanticContext;
+        }
+
+        /** An NFA configuration is equal to another if both have
+         *  the same state, the predict the same alternative, and
+         *  syntactic/semantic contexts are the same.  I don't think
+         *  the state|alt|ctx could be the same and have two different
+         *  semantic contexts, but might as well define equals to be
+         *  everything.
+         */
+        public override bool Equals( object o )
+        {
+            if ( o == null )
+            {
+                return false;
+            }
+            NFAConfiguration other = (NFAConfiguration)o;
+            return this.state == other.state &&
+                   this.alt == other.alt &&
+                   this.context.Equals( other.context ) &&
+                   this.semanticContext.Equals( other.semanticContext );
+        }
+
+        public override int GetHashCode()
+        {
+            int h = state + alt + context.GetHashCode();
+            return h;
+        }
+
+        public override string ToString()
+        {
+            return ToString( true );
+        }
+
+        public string ToString( bool showAlt )
+        {
+            StringBuilder buf = new StringBuilder();
+            buf.Append( state );
+            if ( showAlt )
+            {
+                buf.Append( "|" );
+                buf.Append( alt );
+            }
+            if ( context.parent != null )
+            {
+                buf.Append( "|" );
+                buf.Append( context );
+            }
+            if ( semanticContext != null &&
+                 semanticContext != SemanticContext.EMPTY_SEMANTIC_CONTEXT )
+            {
+                buf.Append( "|" );
+                string escQuote = semanticContext.ToString().Replace( "\"", "\\\"" );
+                buf.Append( escQuote );
+            }
+            if ( resolved )
+            {
+                buf.Append( "|resolved" );
+            }
+            if ( resolveWithPredicate )
+            {
+                buf.Append( "|resolveWithPredicate" );
+            }
+            return buf.ToString();
+        }
+    }
+}
diff --git a/Antlr3/Analysis/NFAContext.cs b/Antlr3/Analysis/NFAContext.cs
new file mode 100644
index 0000000..b99c1f1
--- /dev/null
+++ b/Antlr3/Analysis/NFAContext.cs
@@ -0,0 +1,328 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Analysis
+{
+    using StringBuilder = System.Text.StringBuilder;
+
+    /** A tree node for tracking the call chains for NFAs that invoke
+     *  other NFAs.  These trees only have to point upwards to their parents
+     *  so we can walk back up the tree (i.e., pop stuff off the stack).  We
+     *  never walk from stack down down through the children.
+     *
+     *  Each alt predicted in a decision has its own context tree,
+     *  representing all possible return nodes.  The initial stack has
+     *  EOF ("$") in it.  So, for m alternative productions, the lookahead
+     *  DFA will have m NFAContext trees.
+     *
+     *  To "push" a new context, just do "new NFAContext(context-parent, state)"
+     *  which will add itself to the parent.  The root is NFAContext(null, null).
+     *
+     *  The complete context for an NFA configuration is the set of invoking states
+     *  on the path from this node thru the parent pointers to the root.
+     */
+    public class NFAContext
+    {
+        /** This is similar to Bermudez's m constant in his LAR(m) where
+         *  you bound the stack so your states don't explode.  The main difference
+         *  is that I bound only recursion on the stack, not the simple stack size.
+         *  This looser constraint will let the conversion roam further to find
+         *  lookahead to resolve a decision.
+         *
+         *  Bermudez's m operates differently as it is his LR stack depth
+         *  I'm pretty sure it therefore includes all stack symbols.  Here I
+         *  restrict the size of an NFA configuration to be finite because a
+         *  stack component may mention the same NFA invocation state at
+         *  most m times.  Hence, the number of DFA states will not grow forever.
+         *  With recursive rules like
+         *
+         *    e : '(' e ')' | INT ;
+         *
+         *  you could chase your tail forever if somebody said "s : e '.' | e ';' ;"
+         *  This constant prevents new states from being created after a stack gets
+         *  "too big".  Actually (12/14/2007) I realize that this example is
+         *  trapped by the non-LL(*) detector for recursion in > 1 alt.  Here is
+         *  an example that trips stack overflow:
+         *
+         *	  s : a Y | A A A A A X ; // force recursion past m=4
+         *	  a : A a | Q;
+         *
+         *  If that were:
+         *
+         *	  s : a Y | A+ X ;
+         *
+         *  it could loop forever.
+         *
+         *  Imagine doing a depth-first search on the e DFA...as you chase an input
+         *  sequence you can recurse to same rule such as e above.  You'd have a
+         *  chain of ((((.  When you get do some point, you have to give up.  The
+         *  states in the chain will have longer and longer NFA config stacks.
+         *  Must limit size.
+         *
+         *  max=0 implies you cannot ever jump to another rule during closure.
+         *  max=1 implies you can make as many calls as you want--you just
+         *        can't ever visit a state that is on your rule invocation stack.
+         * 		  I.e., you cannot ever recurse.
+         *  max=2 implies you are able to recurse once (i.e., call a rule twice
+         *  	  from the same place).
+         *
+         *  This tracks recursion to a rule specific to an invocation site!
+         *  It does not detect multiple calls to a rule from different rule
+         *  invocation states.  We are guaranteed to terminate because the
+         *  stack can only grow as big as the number of NFA states * max.
+         *
+         *  I noticed that the Java grammar didn't work with max=1, but did with
+         *  max=4.  Let's set to 4. Recursion is sometimes needed to resolve some
+         *  fixed lookahead decisions.
+         */
+        public static int MAX_SAME_RULE_INVOCATIONS_PER_NFA_CONFIG_STACK = 4;
+
+        public NFAContext parent;
+
+        /** The NFA state that invoked another rule's start state is recorded
+         *  on the rule invocation context stack.
+         */
+        public NFAState invokingState;
+
+        /** Computing the hashCode is very expensive and closureBusy()
+         *  uses it to track when it's seen a state|ctx before to avoid
+         *  infinite loops.  As we add new contexts, record the hash code
+         *  as this.invokingState + parent.cachedHashCode.  Avoids walking
+         *  up the tree for every hashCode().  Note that this caching works
+         *  because a context is a monotonically growing tree of context nodes
+         *  and nothing on the stack is ever modified...ctx just grows
+         *  or shrinks.
+         */
+        protected int cachedHashCode;
+
+        public NFAContext( NFAContext parent, NFAState invokingState )
+        {
+            this.parent = parent;
+            this.invokingState = invokingState;
+            if ( invokingState != null )
+            {
+                this.cachedHashCode = invokingState.stateNumber;
+            }
+            if ( parent != null )
+            {
+                this.cachedHashCode += parent.cachedHashCode;
+            }
+        }
+
+        #region Properties
+        /** A context is empty if there is no parent; meaning nobody pushed
+         *  anything on the call stack.
+         */
+        public bool IsEmpty
+        {
+            get
+            {
+                return parent == null;
+            }
+        }
+        #endregion
+
+        /** Two contexts are equals() if both have
+         *  same call stack; walk upwards to the root.
+         *  Recall that the root sentinel node has no invokingStates and no parent.
+         *  Note that you may be comparing contexts in different alt trees.
+         *
+         *  The hashCode is now cheap as it's computed once upon each context
+         *  push on the stack.  Use it to make equals() more efficient.
+         */
+        public override bool Equals( object o )
+        {
+            NFAContext other = ( (NFAContext)o );
+            if ( this.cachedHashCode != other.cachedHashCode )
+            {
+                return false; // can't be same if hash is different
+            }
+            if ( this == other )
+            {
+                return true;
+            }
+            // JSystem.@out.println("comparing "+this+" with "+other);
+            NFAContext sp = this;
+            while ( sp.parent != null && other.parent != null )
+            {
+                if ( sp.invokingState != other.invokingState )
+                {
+                    return false;
+                }
+                sp = sp.parent;
+                other = other.parent;
+            }
+            if ( !( sp.parent == null && other.parent == null ) )
+            {
+                return false; // both pointers must be at their roots after walk
+            }
+            return true;
+        }
+
+        /** Two contexts conflict() if they are equals() or one is a stack suffix
+         *  of the other.  For example, contexts [21 12 $] and [21 9 $] do not
+         *  conflict, but [21 $] and [21 12 $] do conflict.  Note that I should
+         *  probably not show the $ in this case.  There is a dummy node for each
+         *  stack that just means empty; $ is a marker that's all.
+         *
+         *  This is used in relation to checking conflicts associated with a
+         *  single NFA state's configurations within a single DFA state.
+         *  If there are configurations s and t within a DFA state such that
+         *  s.state=t.state && s.alt != t.alt && s.ctx conflicts t.ctx then
+         *  the DFA state predicts more than a single alt--it's nondeterministic.
+         *  Two contexts conflict if they are the same or if one is a suffix
+         *  of the other.
+         *
+         *  When comparing contexts, if one context has a stack and the other
+         *  does not then they should be considered the same context.  The only
+         *  way for an NFA state p to have an empty context and a nonempty context
+         *  is the case when closure falls off end of rule without a call stack
+         *  and re-enters the rule with a context.  This resolves the issue I
+         *  discussed with Sriram Srinivasan Feb 28, 2005 about not terminating
+         *  fast enough upon nondeterminism.
+         */
+        public virtual bool conflictsWith( NFAContext other )
+        {
+            return this.suffix( other ); // || this.equals(other);
+        }
+
+        /** [$] suffix any context
+         *  [21 $] suffix [21 12 $]
+         *  [21 12 $] suffix [21 $]
+         *  [21 18 $] suffix [21 18 12 9 $]
+         *  [21 18 12 9 $] suffix [21 18 $]
+         *  [21 12 $] not suffix [21 9 $]
+         *
+         *  Example "[21 $] suffix [21 12 $]" means: rule r invoked current rule
+         *  from state 21.  Rule s invoked rule r from state 12 which then invoked
+         *  current rule also via state 21.  While the context prior to state 21
+         *  is different, the fact that both contexts emanate from state 21 implies
+         *  that they are now going to track perfectly together.  Once they
+         *  converged on state 21, there is no way they can separate.  In other
+         *  words, the prior stack state is not consulted when computing where to
+         *  go in the closure operation.  ?$ and ??$ are considered the same stack.
+         *  If ? is popped off then $ and ?$ remain; they are now an empty and
+         *  nonempty context comparison.  So, if one stack is a suffix of
+         *  another, then it will still degenerate to the simple empty stack
+         *  comparison case.
+         */
+        protected virtual bool suffix( NFAContext other )
+        {
+            NFAContext sp = this;
+            // if one of the contexts is empty, it never enters loop and returns true
+            while ( sp.parent != null && other.parent != null )
+            {
+                if ( sp.invokingState != other.invokingState )
+                {
+                    return false;
+                }
+                sp = sp.parent;
+                other = other.parent;
+            }
+            //JSystem.@out.println("suffix");
+            return true;
+        }
+
+        /** Walk upwards to the root of the call stack context looking
+         *  for a particular invoking state.
+        public boolean contains(int state) {
+            NFAContext sp = this;
+            int n = 0; // track recursive invocations of state
+            JSystem.@out.println("this.context is "+sp);
+            while ( sp.parent!=null ) {
+                if ( sp.invokingState.stateNumber == state ) {
+                    return true;
+                }
+                sp = sp.parent;
+            }
+            return false;
+        }
+         */
+
+        /** Given an NFA state number, how many times has the NFA-to-DFA
+         *  conversion pushed that state on the stack?  In other words,
+         *  the NFA state must be a rule invocation state and this method
+         *  tells you how many times you've been to this state.  If none,
+         *  then you have not called the target rule from this state before
+         *  (though another NFA state could have called that target rule).
+         *  If n=1, then you've been to this state before during this
+         *  DFA construction and are going to invoke that rule again.
+         *
+         *  Note that many NFA states can invoke rule r, but we ignore recursion
+         *  unless you hit the same rule invocation state again.
+         */
+        public virtual int recursionDepthEmanatingFromState( int state )
+        {
+            NFAContext sp = this;
+            int n = 0; // track recursive invocations of target from this state
+            //JSystem.@out.println("this.context is "+sp);
+            while ( sp.parent != null )
+            {
+                if ( sp.invokingState.stateNumber == state )
+                {
+                    n++;
+                }
+                sp = sp.parent;
+            }
+            return n;
+        }
+
+        public override int GetHashCode()
+        {
+            return cachedHashCode;
+            /*
+            int h = 0;
+            NFAContext sp = this;
+            while ( sp.parent!=null ) {
+                h += sp.invokingState.getStateNumber();
+                sp = sp.parent;
+            }
+            return h;
+            */
+        }
+
+        public override string ToString()
+        {
+            StringBuilder buf = new StringBuilder();
+            NFAContext sp = this;
+            buf.Append( "[" );
+            while ( sp.parent != null )
+            {
+                buf.Append( sp.invokingState.stateNumber );
+                buf.Append( " " );
+                sp = sp.parent;
+            }
+            buf.Append( "$]" );
+            return buf.ToString();
+        }
+    }
+}
diff --git a/Antlr3/Analysis/NFAConversionThread.cs b/Antlr3/Analysis/NFAConversionThread.cs
new file mode 100644
index 0000000..d8f2020
--- /dev/null
+++ b/Antlr3/Analysis/NFAConversionThread.cs
@@ -0,0 +1,78 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Analysis
+{
+    using Barrier = Antlr3.Misc.Barrier;
+    using ErrorManager = Antlr3.Tool.ErrorManager;
+    using Grammar = Antlr3.Tool.Grammar;
+    using OperationCanceledException = System.OperationCanceledException;
+
+    /** Convert all decisions i..j inclusive in a thread */
+    public class NFAConversionThread //: Runnable
+    {
+        Grammar grammar;
+        int i, j;
+        Barrier barrier;
+        public NFAConversionThread( Grammar grammar,
+                                   Barrier barrier,
+                                   int i,
+                                   int j )
+        {
+            this.grammar = grammar;
+            this.barrier = barrier;
+            this.i = i;
+            this.j = j;
+        }
+        public virtual void run()
+        {
+            for ( int decision = i; decision <= j; decision++ )
+            {
+                NFAState decisionStartState = grammar.getDecisionNFAStartState( decision );
+                if ( decisionStartState.NumberOfTransitions > 1 )
+                {
+                    grammar.createLookaheadDFA( decision, true );
+                }
+            }
+            // now wait for others to finish
+            try
+            {
+                barrier.waitForRelease();
+            }
+            catch ( OperationCanceledException e )
+            {
+                ErrorManager.internalError( "what the hell? DFA interruptus", e );
+            }
+        }
+    }
+
+}
diff --git a/Antlr3/Analysis/NFAState.cs b/Antlr3/Analysis/NFAState.cs
new file mode 100644
index 0000000..06f6347
--- /dev/null
+++ b/Antlr3/Analysis/NFAState.cs
@@ -0,0 +1,304 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Analysis
+{
+    using ErrorManager = Antlr3.Tool.ErrorManager;
+    using GrammarAST = Antlr3.Tool.GrammarAST;
+    using ArgumentException = System.ArgumentException;
+    using Rule = Antlr3.Tool.Rule;
+
+    /** A state within an NFA. At most 2 transitions emanate from any NFA state. */
+    // sealed to make functions non-virtual
+    public sealed class NFAState : State
+    {
+        // I need to distinguish between NFA decision states for (...)* and (...)+
+        // during NFA interpretation.
+        public const int LOOPBACK = 1;
+        public const int BLOCK_START = 2;
+        public const int OPTIONAL_BLOCK_START = 3;
+        public const int BYPASS = 4;
+        public const int RIGHT_EDGE_OF_BLOCK = 5;
+
+        public const int MAX_TRANSITIONS = 2;
+
+        /** How many transitions; 0, 1, or 2 transitions */
+        int numTransitions = 0;
+        public Transition[] transition = new Transition[MAX_TRANSITIONS];
+
+        /** For o-A->o type NFA tranitions, record the label that leads to this
+         *  state.  Useful for creating rich error messages when we find
+         *  insufficiently (with preds) covered states.
+         */
+        public Label incidentEdgeLabel;
+
+        /** Which NFA are we in? */
+        public NFA nfa = null;
+
+        /** What's its decision number from 1..n? */
+        int decisionNumber = 0;
+
+        /** Subrules (...)* and (...)+ have more than one decision point in
+         *  the NFA created for them.  They both have a loop-exit-or-stay-in
+         *  decision node (the loop back node).  They both have a normal
+         *  alternative block decision node at the left edge.  The (...)* is
+         *  worse as it even has a bypass decision (2 alts: stay in or bypass)
+         *  node at the extreme left edge.  This is not how they get generated
+         *  in code as a while-loop or whatever deals nicely with either.  For
+         *  error messages (where I need to print the nondeterministic alts)
+         *  and for interpretation, I need to use the single DFA that is created
+         *  (for efficiency) but interpret the results differently depending
+         *  on which of the 2 or 3 decision states uses the DFA.  For example,
+         *  the DFA will always report alt n+1 as the exit branch for n real
+         *  alts, so I need to translate that depending on the decision state.
+         *
+         *  If decisionNumber>0 then this var tells you what kind of decision
+         *  state it is.
+         */
+        public int decisionStateType;
+
+        /** What rule do we live in? */
+        public Rule enclosingRule;
+
+        /** During debugging and for nondeterminism warnings, it's useful
+         *  to know what relationship this node has to the original grammar.
+         *  For example, "start of alt 1 of rule a".
+         */
+        string description;
+
+        /** Associate this NFAState with the corresponding GrammarAST node
+         *  from which this node was created.  This is useful not only for
+         *  associating the eventual lookahead DFA with the associated
+         *  Grammar position, but also for providing users with
+         *  nondeterminism warnings.  Mainly used by decision states to
+         *  report line:col info.  Could also be used to track line:col
+         *  for elements such as token refs.
+         */
+        public GrammarAST associatedASTNode;
+
+        /** Is this state the sole target of an EOT transition? */
+        bool EOTTargetState = false;
+
+        /** Jean Bovet needs in the GUI to know which state pairs correspond
+         *  to the start/stop of a block.
+          */
+        public int endOfBlockStateNumber = State.INVALID_STATE_NUMBER;
+
+        public NFAState( NFA nfa )
+        {
+            this.nfa = nfa;
+        }
+
+        #region Properties
+        public int DecisionNumber
+        {
+            get
+            {
+                return decisionNumber;
+            }
+            set
+            {
+                decisionNumber = value;
+            }
+        }
+        public string Description
+        {
+            get
+            {
+                return description;
+            }
+            set
+            {
+                description = value;
+            }
+        }
+        public bool IsDecisionState
+        {
+            get
+            {
+                return decisionStateType > 0;
+            }
+        }
+        public bool IsEOTTargetState
+        {
+            get
+            {
+                return EOTTargetState;
+            }
+            set
+            {
+                EOTTargetState = value;
+            }
+        }
+        #endregion
+
+        public override int NumberOfTransitions
+        {
+            get
+            {
+                return numTransitions;
+            }
+        }
+
+        public override void addTransition( Transition e )
+        {
+            if ( e == null )
+            {
+                throw new ArgumentException( "You can't add a null transition" );
+            }
+            if ( numTransitions > transition.Length )
+            {
+                throw new ArgumentException( "You can only have " + transition.Length + " transitions" );
+            }
+            if ( e != null )
+            {
+                transition[numTransitions] = e;
+                numTransitions++;
+                // Set the "back pointer" of the target state so that it
+                // knows about the label of the incoming edge.
+                Label label = e.label;
+                if ( label.IsAtom || label.IsSet )
+                {
+                    if ( ( (NFAState)e.target ).incidentEdgeLabel != null )
+                    {
+                        ErrorManager.internalError( "Clobbered incident edge" );
+                    }
+                    ( (NFAState)e.target ).incidentEdgeLabel = e.label;
+                }
+            }
+        }
+
+        /** Used during optimization to reset a state to have the (single)
+         *  transition another state has.
+         */
+        public void setTransition0( Transition e )
+        {
+            if ( e == null )
+            {
+                throw new ArgumentException( "You can't use a solitary null transition" );
+            }
+            transition[0] = e;
+            transition[1] = null;
+            numTransitions = 1;
+        }
+
+        public override Transition getTransition( int i )
+        {
+            return transition[i];
+        }
+
+        /** The DFA decision for this NFA decision state always has
+         *  an exit path for loops as n+1 for n alts in the loop.
+         *  That is really useful for displaying nondeterministic alts
+         *  and so on, but for walking the NFA to get a sequence of edge
+         *  labels or for actually parsing, we need to get the real alt
+         *  number.  The real alt number for exiting a loop is always 1
+         *  as transition 0 points at the exit branch (we compute DFAs
+         *  always for loops at the loopback state).
+         *
+         *  For walking/parsing the loopback state:
+         * 		1 2 3 display alt (for human consumption)
+         * 		2 3 1 walk alt
+         *
+         *  For walking the block start:
+         * 		1 2 3 display alt
+         * 		1 2 3
+         *
+         *  For walking the bypass state of a (...)* loop:
+         * 		1 2 3 display alt
+         * 		1 1 2 all block alts map to entering loop exit means take bypass
+         *
+         *  Non loop EBNF do not need to be translated; they are ignored by
+         *  this method as decisionStateType==0.
+         *
+         *  Return same alt if we can't translate.
+         */
+        public int translateDisplayAltToWalkAlt( int displayAlt )
+        {
+            NFAState nfaStart = this;
+            if ( decisionNumber == 0 || decisionStateType == 0 )
+            {
+                return displayAlt;
+            }
+            int walkAlt = 0;
+            // find the NFA loopback state associated with this DFA
+            // and count number of alts (all alt numbers are computed
+            // based upon the loopback's NFA state.
+            /*
+            DFA dfa = nfa.grammar.getLookaheadDFA(decisionNumber);
+            if ( dfa==null ) {
+                ErrorManager.internalError("can't get DFA for decision "+decisionNumber);
+            }
+            */
+            int nAlts = nfa.grammar.getNumberOfAltsForDecisionNFA( nfaStart );
+            switch ( nfaStart.decisionStateType )
+            {
+            case LOOPBACK:
+                walkAlt = displayAlt % nAlts + 1; // rotate right mod 1..3
+                break;
+            case BLOCK_START:
+            case OPTIONAL_BLOCK_START:
+                walkAlt = displayAlt; // identity transformation
+                break;
+            case BYPASS:
+                if ( displayAlt == nAlts )
+                {
+                    walkAlt = 2; // bypass
+                }
+                else
+                {
+                    walkAlt = 1; // any non exit branch alt predicts entering
+                }
+                break;
+            }
+            return walkAlt;
+        }
+
+        // Setter/Getters
+
+        /** What AST node is associated with this NFAState?  When you
+         *  set the AST node, I set the node to point back to this NFA state.
+         */
+        public void setDecisionASTNode( GrammarAST decisionASTNode )
+        {
+            decisionASTNode.setNFAStartState( this );
+            this.associatedASTNode = decisionASTNode;
+        }
+
+        public override string ToString()
+        {
+            return stateNumber.ToString();
+        }
+
+    }
+
+}
diff --git a/Antlr3/Analysis/NFAtoDFAConverter.cs b/Antlr3/Analysis/NFAtoDFAConverter.cs
new file mode 100644
index 0000000..1c2b0d3
--- /dev/null
+++ b/Antlr3/Analysis/NFAtoDFAConverter.cs
@@ -0,0 +1,1862 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Analysis
+{
+    using System.Collections.Generic;
+    using System.Linq;
+    using Antlr.Runtime.JavaExtensions;
+
+    using BitSet = Antlr3.Misc.BitSet;
+    using Console = System.Console;
+    using ErrorManager = Antlr3.Tool.ErrorManager;
+    using IList = System.Collections.IList;
+    using IToken = Antlr.Runtime.IToken;
+
+    /** Code that embodies the NFA conversion to DFA. A new object is needed
+     *  per DFA (also required for thread safety if multiple conversions
+     *  launched).
+     */
+    public class NFAToDFAConverter
+    {
+        /** A list of DFA states we still need to process during NFA conversion */
+        protected Queue<DFAState> work = new Queue<DFAState>();
+
+        /** While converting NFA, we must track states that
+         *  reference other rule's NFAs so we know what to do
+         *  at the end of a rule.  We need to know what context invoked
+         *  this rule so we can know where to continue looking for NFA
+         *  states.  I'm tracking a context tree (record of rule invocation
+         *  stack trace) for each alternative that could be predicted.
+         */
+        protected NFAContext[] contextTrees;
+
+        /** We are converting which DFA? */
+        protected DFA dfa;
+
+        public static bool debug = false;
+
+        /** Should ANTLR launch multiple threads to convert NFAs to DFAs?
+         *  With a 2-CPU box, I note that it's about the same single or
+         *  multithreaded.  Both CPU meters are going even when single-threaded
+         *  so I assume the GC is killing us.  Could be the compiler.  When I
+         *  run java -Xint mode, I get about 15% speed improvement with multiple
+         *  threads.
+         */
+        public static bool SINGLE_THREADED_NFA_CONVERSION = true;
+
+        protected bool computingStartState = false;
+
+        public NFAToDFAConverter( DFA dfa )
+        {
+            this.dfa = dfa;
+            int nAlts = dfa.NumberOfAlts;
+            initContextTrees( nAlts );
+        }
+
+        public virtual void convert()
+        {
+            dfa.conversionStartTime = System.DateTime.Now;
+
+            // create the DFA start state
+            dfa.startState = computeStartState();
+
+            // while more DFA states to check, process them
+            while ( work.Count > 0 &&
+                    !dfa.nfa.grammar.NFAToDFAConversionExternallyAborted() )
+            {
+                DFAState d = (DFAState)work.Peek();
+                if ( dfa.nfa.grammar.composite.watchNFAConversion )
+                {
+                    Console.Out.WriteLine( "convert DFA state " + d.stateNumber +
+                                       " (" + d.nfaConfigurations.size() + " nfa states)" );
+                }
+                int k = dfa.UserMaxLookahead;
+                if ( k > 0 && k == d.LookaheadDepth )
+                {
+                    // we've hit max lookahead, make this a stop state
+                    //JSystem.@out.println("stop state @k="+k+" (terminated early)");
+                    /*
+                    IList<Label> sampleInputLabels = d.dfa.probe.getSampleNonDeterministicInputSequence(d);
+                    String input = d.dfa.probe.getInputSequenceDisplay(sampleInputLabels);
+                    JSystem.@out.println("sample input: "+input);
+                     */
+                    resolveNonDeterminisms( d );
+                    // Check to see if we need to add any semantic predicate transitions
+                    if ( d.IsResolvedWithPredicates )
+                    {
+                        addPredicateTransitions( d );
+                    }
+                    else
+                    {
+                        d.IsAcceptState = true; // must convert to accept state at k
+                    }
+                }
+                else
+                {
+                    findNewDFAStatesAndAddDFATransitions( d );
+                }
+                work.Dequeue(); // done with it; remove from work list
+            }
+
+            // Find all manual syn preds (gated).  These are not discovered
+            // in tryToResolveWithSemanticPredicates because they are implicitly
+            // added to every edge by code gen, DOT generation etc...
+            dfa.findAllGatedSynPredsUsedInDFAAcceptStates();
+        }
+
+        /** From this first NFA state of a decision, create a DFA.
+         *  Walk each alt in decision and compute closure from the start of that
+         *  rule, making sure that the closure does not include other alts within
+         *  that same decision.  The idea is to associate a specific alt number
+         *  with the starting closure so we can trace the alt number for all states
+         *  derived from this.  At a stop state in the DFA, we can return this alt
+         *  number, indicating which alt is predicted.
+         *
+         *  If this DFA is derived from an loop back NFA state, then the first
+         *  transition is actually the exit branch of the loop.  Rather than make
+         *  this alternative one, let's make this alt n+1 where n is the number of
+         *  alts in this block.  This is nice to keep the alts of the block 1..n;
+         *  helps with error messages.
+         *
+         *  I handle nongreedy in findNewDFAStatesAndAddDFATransitions
+         *  when nongreedy and EOT transition.  Make state with EOT emanating
+         *  from it the accept state.
+         */
+        protected virtual DFAState computeStartState()
+        {
+            NFAState alt = dfa.decisionNFAStartState;
+            DFAState startState = dfa.newState();
+            computingStartState = true;
+            int i = 0;
+            int altNum = 1;
+            while ( alt != null )
+            {
+                // find the set of NFA states reachable without consuming
+                // any input symbols for each alt.  Keep adding to same
+                // overall closure that will represent the DFA start state,
+                // but track the alt number
+                NFAContext initialContext = contextTrees[i];
+                // if first alt is derived from loopback/exit branch of loop,
+                // make alt=n+1 for n alts instead of 1
+                if ( i == 0 &&
+                     dfa.NFADecisionStartState.decisionStateType == NFAState.LOOPBACK )
+                {
+                    int numAltsIncludingExitBranch = dfa.nfa.grammar
+                        .getNumberOfAltsForDecisionNFA( dfa.decisionNFAStartState );
+                    altNum = numAltsIncludingExitBranch;
+                    closure( (NFAState)alt.transition[0].target,
+                            altNum,
+                            initialContext,
+                            SemanticContext.EMPTY_SEMANTIC_CONTEXT,
+                            startState,
+                            true
+                    );
+                    altNum = 1; // make next alt the first
+                }
+                else
+                {
+                    closure( (NFAState)alt.transition[0].target,
+                            altNum,
+                            initialContext,
+                            SemanticContext.EMPTY_SEMANTIC_CONTEXT,
+                            startState,
+                            true
+                    );
+                    altNum++;
+                }
+                i++;
+
+                // move to next alternative
+                if ( alt.transition[1] == null )
+                {
+                    break;
+                }
+                alt = (NFAState)alt.transition[1].target;
+            }
+
+            // now DFA start state has the complete closure for the decision
+            // but we have tracked which alt is associated with which
+            // NFA states.
+            dfa.addState( startState ); // make sure dfa knows about this state
+            work.Enqueue( startState );
+            computingStartState = false;
+            return startState;
+        }
+
+        /** From this node, add a d--a-->t transition for all
+         *  labels 'a' where t is a DFA node created
+         *  from the set of NFA states reachable from any NFA
+         *  state in DFA state d.
+         */
+        protected virtual void findNewDFAStatesAndAddDFATransitions( DFAState d )
+        {
+            //JSystem.@out.println("work on DFA state "+d);
+            var labels = d.ReachableLabels;
+            //JSystem.@out.println("reachable labels="+labels);
+
+            /*
+            JSystem.@out.println("|reachable|/|nfaconfigs|="+
+                    labels.size()+"/"+d.getNFAConfigurations().size()+"="+
+                    labels.size()/(float)d.getNFAConfigurations().size());
+            */
+
+            // normally EOT is the "default" clause and decisions just
+            // choose that last clause when nothing else matches.  DFA conversion
+            // continues searching for a unique sequence that predicts the
+            // various alts or until it finds EOT.  So this rule
+            //
+            // DUH : ('x'|'y')* "xy!";
+            //
+            // does not need a greedy indicator.  The following rule works fine too
+            //
+            // A : ('x')+ ;
+            //
+            // When the follow branch could match what is in the loop, by default,
+            // the nondeterminism is resolved in favor of the loop.  You don't
+            // get a warning because the only way to get this condition is if
+            // the DFA conversion hits the end of the token.  In that case,
+            // we're not *sure* what will happen next, but it could be anything.
+            // Anyway, EOT is the default case which means it will never be matched
+            // as resolution goes to the lowest alt number.  Exit branches are
+            // always alt n+1 for n alts in a block.
+            //
+            // When a loop is nongreedy and we find an EOT transition, the DFA
+            // state should become an accept state, predicting exit of loop.  It's
+            // just reversing the resolution of ambiguity.
+            // TODO: should this be done in the resolveAmbig method?
+            Label EOTLabel = new Label( Label.EOT );
+            bool containsEOT = labels != null && labels.Contains( EOTLabel );
+            if ( !dfa.IsGreedy && containsEOT )
+            {
+                convertToEOTAcceptState( d );
+                return; // no more work to do on this accept state
+            }
+
+            // if in filter mode for lexer, want to match shortest not longest
+            // string so if we see an EOT edge emanating from this state, then
+            // convert this state to an accept state.  This only counts for
+            // The Tokens rule as all other decisions must continue to look for
+            // longest match.
+            // [Taking back out a few days later on Jan 17, 2006.  This could
+            //  be an option for the future, but this was wrong soluion for
+            //  filtering.]
+            /*
+            if ( dfa.nfa.grammar.type==Grammar.LEXER && containsEOT ) {
+                String filterOption = (String)dfa.nfa.grammar.getOption("filter");
+                boolean filterMode = filterOption!=null && filterOption.equals("true");
+                if ( filterMode && d.dfa.isTokensRuleDecision() ) {
+                    DFAState t = reach(d, EOTLabel);
+                    if ( t.getNFAConfigurations().size()>0 ) {
+                        convertToEOTAcceptState(d);
+                        //JSystem.@out.println("state "+d+" has EOT target "+t.stateNumber);
+                        return;
+                    }
+                }
+            }
+            */
+
+            int numberOfEdgesEmanating = 0;
+            var targetToLabelMap = new Dictionary<int, Transition>();
+            // for each label that could possibly emanate from NFAStates of d
+            int numLabels = 0;
+            if ( labels != null )
+            {
+                numLabels = labels.Count;
+            }
+            for ( int i = 0; i < numLabels; i++ )
+            {
+                Label label = (Label)labels.ElementAt( i );
+                DFAState t = reach( d, label );
+                if ( debug )
+                {
+                    Console.Out.WriteLine( "DFA state after reach " + label + " " + d + "-" +
+                                       label.ToString( dfa.nfa.grammar ) + "->" + t );
+                }
+                if ( t == null )
+                {
+                    // nothing was reached by label due to conflict resolution
+                    // EOT also seems to be in here occasionally probably due
+                    // to an end-of-rule state seeing it even though we'll pop
+                    // an invoking state off the state; don't bother to conflict
+                    // as this labels set is a covering approximation only.
+                    continue;
+                }
+                //JSystem.@out.println("dfa.k="+dfa.getUserMaxLookahead());
+                if ( t.getUniqueAlt() == NFA.INVALID_ALT_NUMBER )
+                {
+                    // Only compute closure if a unique alt number is not known.
+                    // If a unique alternative is mentioned among all NFA
+                    // configurations then there is no possibility of needing to look
+                    // beyond this state; also no possibility of a nondeterminism.
+                    // This optimization May 22, 2006 just dropped -Xint time
+                    // for analysis of Java grammar from 11.5s to 2s!  Wow.
+                    closure( t );  // add any NFA states reachable via epsilon
+                }
+
+                /*
+                JSystem.@out.println("DFA state after closure "+d+"-"+
+                                   label.toString(dfa.nfa.grammar)+
+                                   "->"+t);
+                                   */
+
+                // add if not in DFA yet and then make d-label->t
+                DFAState targetState = addDFAStateToWorkList( t );
+
+                numberOfEdgesEmanating +=
+                    addTransition( d, label, targetState, targetToLabelMap );
+
+                // lookahead of target must be one larger than d's k
+                // We are possibly setting the depth of a pre-existing state
+                // that is equal to one we just computed...not sure if that's
+                // ok.
+                targetState.setLookaheadDepth( d.LookaheadDepth + 1 );
+            }
+
+            //JSystem.@out.println("DFA after reach / closures:\n"+dfa);
+
+            if ( !d.IsResolvedWithPredicates && numberOfEdgesEmanating == 0 )
+            {
+                //JSystem.@out.println("dangling DFA state "+d+"\nAfter reach / closures:\n"+dfa);
+                // TODO: can fixed lookahead hit a dangling state case?
+                // TODO: yes, with left recursion
+                //System.err.println("dangling state alts: "+d.getAltSet());
+                dfa.probe.reportDanglingState( d );
+                // turn off all configurations except for those associated with
+                // min alt number; somebody has to win else some input will not
+                // predict any alt.
+                int minAlt = resolveByPickingMinAlt( d, null );
+                // force it to be an accept state
+                // don't call convertToAcceptState() which merges stop states.
+                // other states point at us; don't want them pointing to dead states
+                d.IsAcceptState = true; // might be adding new accept state for alt
+                dfa.setAcceptState( minAlt, d );
+                //convertToAcceptState(d, minAlt); // force it to be an accept state
+            }
+
+            // Check to see if we need to add any semantic predicate transitions
+            if ( d.IsResolvedWithPredicates )
+            {
+                addPredicateTransitions( d );
+            }
+        }
+
+        /** Add a transition from state d to targetState with label in normal case.
+         *  if COLLAPSE_ALL_INCIDENT_EDGES, however, try to merge all edges from
+         *  d to targetState; this means merging their labels.  Another optimization
+         *  is to reduce to a single EOT edge any set of edges from d to targetState
+         *  where there exists an EOT state.  EOT is like the wildcard so don't
+         *  bother to test any other edges.  Example:
+         *
+         *  NUM_INT
+         *    : '1'..'9' ('0'..'9')* ('l'|'L')?
+         *    | '0' ('x'|'X') ('0'..'9'|'a'..'f'|'A'..'F')+ ('l'|'L')?
+         *    | '0' ('0'..'7')* ('l'|'L')?
+         *    ;
+         *
+         *  The normal decision to predict alts 1, 2, 3 is:
+         *
+         *  if ( (input.LA(1)>='1' && input.LA(1)<='9') ) {
+         *       alt7=1;
+         *  }
+         *  else if ( input.LA(1)=='0' ) {
+         *      if ( input.LA(2)=='X'||input.LA(2)=='x' ) {
+         *          alt7=2;
+         *      }
+         *      else if ( (input.LA(2)>='0' && input.LA(2)<='7') ) {
+         *           alt7=3;
+         *      }
+         *      else if ( input.LA(2)=='L'||input.LA(2)=='l' ) {
+         *           alt7=3;
+         *      }
+         *      else {
+         *           alt7=3;
+         *      }
+         *  }
+         *  else error
+         *
+         *  Clearly, alt 3 is predicted with extra work since it tests 0..7
+         *  and [lL] before finally realizing that any character is actually
+         *  ok at k=2.
+         *
+         *  A better decision is as follows:
+         *
+         *  if ( (input.LA(1)>='1' && input.LA(1)<='9') ) {
+         *      alt7=1;
+         *  }
+         *  else if ( input.LA(1)=='0' ) {
+         *      if ( input.LA(2)=='X'||input.LA(2)=='x' ) {
+         *          alt7=2;
+         *      }
+         *      else {
+         *          alt7=3;
+         *      }
+         *  }
+         *
+         *  The DFA originally has 3 edges going to the state the predicts alt 3,
+         *  but upon seeing the EOT edge (the "else"-clause), this method
+         *  replaces the old merged label (which would have (0..7|l|L)) with EOT.
+         *  The code generator then leaves alt 3 predicted with a simple else-
+         *  clause. :)
+         *
+         *  The only time the EOT optimization makes no sense is in the Tokens
+         *  rule.  We want EOT to truly mean you have matched an entire token
+         *  so don't bother actually rewinding to execute that rule unless there
+         *  are actions in that rule.  For now, since I am not preventing
+         *  backtracking from Tokens rule, I will simply allow the optimization.
+         */
+        protected static int addTransition( DFAState d,
+                                           Label label,
+                                           DFAState targetState,
+                                           IDictionary<int, Transition> targetToLabelMap )
+        {
+            //JSystem.@out.println(d.stateNumber+"-"+label.toString(dfa.nfa.grammar)+"->"+targetState.stateNumber);
+            int n = 0;
+            if ( DFAOptimizer.COLLAPSE_ALL_PARALLEL_EDGES )
+            {
+                // track which targets we've hit
+                int tI = targetState.stateNumber;
+                Transition oldTransition = (Transition)targetToLabelMap.get( tI );
+                if ( oldTransition != null )
+                {
+                    //JSystem.@out.println("extra transition to "+tI+" upon "+label.toString(dfa.nfa.grammar));
+                    // already seen state d to target transition, just add label
+                    // to old label unless EOT
+                    if ( label.Atom == Label.EOT )
+                    {
+                        // merge with EOT means old edge can go away
+                        oldTransition.label = new Label( Label.EOT );
+                    }
+                    else
+                    {
+                        // don't add anything to EOT, it's essentially the wildcard
+                        if ( oldTransition.label.Atom != Label.EOT )
+                        {
+                            // ok, not EOT, add in this label to old label
+                            oldTransition.label.add( label );
+                        }
+                        //JSystem.@out.println("label updated to be "+oldTransition.label.toString(dfa.nfa.grammar));
+                    }
+                }
+                else
+                {
+                    // make a transition from d to t upon 'a'
+                    n = 1;
+                    label = (Label)label.Clone(); // clone in case we alter later
+                    int transitionIndex = d.addTransition( targetState, label );
+                    Transition trans = d.getTransition( transitionIndex );
+                    // track target/transition pairs
+                    targetToLabelMap[tI] = trans;
+                }
+            }
+            else
+            {
+                n = 1;
+                d.addTransition( targetState, label );
+            }
+            return n;
+        }
+
+        /** For all NFA states (configurations) merged in d,
+         *  compute the epsilon closure; that is, find all NFA states reachable
+         *  from the NFA states in d via purely epsilon transitions.
+         */
+        public virtual void closure( DFAState d )
+        {
+            if ( debug )
+            {
+                Console.Out.WriteLine( "closure(" + d + ")" );
+            }
+
+            IList<NFAConfiguration> configs = new List<NFAConfiguration>();
+            // Because we are adding to the configurations in closure
+            // must clone initial list so we know when to stop doing closure
+            configs.addAll( d.nfaConfigurations );
+            // for each NFA configuration in d (abort if we detect non-LL(*) state)
+            int numConfigs = configs.Count;
+            for ( int i = 0; i < numConfigs; i++ )
+            {
+                NFAConfiguration c = (NFAConfiguration)configs[i];
+                if ( c.singleAtomTransitionEmanating )
+                {
+                    continue; // ignore NFA states w/o epsilon transitions
+                }
+                //JSystem.@out.println("go do reach for NFA state "+c.state);
+                // figure out reachable NFA states from each of d's nfa states
+                // via epsilon transitions.
+                // Fill configsInClosure rather than altering d configs inline
+                closure( dfa.nfa.getState( c.state ),
+                        c.alt,
+                        c.context,
+                        c.semanticContext,
+                        d,
+                        false );
+            }
+            //JSystem.@out.println("after closure d="+d);
+            d.closureBusy = null; // wack all that memory used during closure
+        }
+
+        /** Where can we get from NFA state p traversing only epsilon transitions?
+         *  Add new NFA states + context to DFA state d.  Also add semantic
+         *  predicates to semantic context if collectPredicates is set.  We only
+         *  collect predicates at hoisting depth 0, meaning before any token/char
+         *  have been recognized.  This corresponds, during analysis, to the
+         *  initial DFA start state construction closure() invocation.
+         *
+         *  There are four cases of interest (the last being the usual transition):
+         *
+         *   1. Traverse an edge that takes us to the start state of another
+         *      rule, r.  We must push this state so that if the DFA
+         *      conversion hits the end of rule r, then it knows to continue
+         *      the conversion at state following state that "invoked" r. By
+         *      construction, there is a single transition emanating from a rule
+         *      ref node.
+         *
+         *   2. Reach an NFA state associated with the end of a rule, r, in the
+         *      grammar from which it was built.  We must add an implicit (i.e.,
+         *      don't actually add an epsilon transition) epsilon transition
+         *      from r's end state to the NFA state following the NFA state
+         *      that transitioned to rule r's start state.  Because there are
+         *      many states that could reach r, the context for a rule invocation
+         *      is part of a call tree not a simple stack.  When we fall off end
+         *      of rule, "pop" a state off the call tree and add that state's
+         *      "following" node to d's NFA configuration list.  The context
+         *      for this new addition will be the new "stack top" in the call tree.
+         *
+         *   3. Like case 2, we reach an NFA state associated with the end of a
+         *      rule, r, in the grammar from which NFA was built.  In this case,
+         *      however, we realize that during this NFA->DFA conversion, no state
+         *      invoked the current rule's NFA.  There is no choice but to add
+         *      all NFA states that follow references to r's start state.  This is
+         *      analogous to computing the FOLLOW(r) in the LL(k) world.  By
+         *      construction, even rule stop state has a chain of nodes emanating
+         *      from it that points to every possible following node.  This case
+         *      is conveniently handled then by the 4th case.
+         *
+         *   4. Normal case.  If p can reach another NFA state q, then add
+         *      q to d's configuration list, copying p's context for q's context.
+         *      If there is a semantic predicate on the transition, then AND it
+         *      with any existing semantic context.
+         *
+         *   Current state p is always added to d's configuration list as it's part
+         *   of the closure as well.
+         *
+         *  When is a closure operation in a cycle condition?  While it is
+         *  very possible to have the same NFA state mentioned twice
+         *  within the same DFA state, there are two situations that
+         *  would lead to nontermination of closure operation:
+         *
+         *  o   Whenever closure reaches a configuration where the same state
+         *      with same or a suffix context already exists.  This catches
+         *      the IF-THEN-ELSE tail recursion cycle and things like
+         *
+         *      a : A a | B ;
+         *
+         *      the context will be $ (empty stack).
+         *
+         *      We have to check
+         *      larger context stacks because of (...)+ loops.  For
+         *      example, the context of a (...)+ can be nonempty if the
+         *      surrounding rule is invoked by another rule:
+         *
+         *      a : b A | X ;
+         *      b : (B|)+ ;  // nondeterministic by the way
+         *
+         *      The context of the (B|)+ loop is "invoked from item
+         *      a : . b A ;" and then the empty alt of the loop can reach back
+         *      to itself.  The context stack will have one "return
+         *      address" element and so we must check for same state, same
+         *      context for arbitrary context stacks.
+         *
+         *      Idea: If we've seen this configuration before during closure, stop.
+         *      We also need to avoid reaching same state with conflicting context.
+         *      Ultimately analysis would stop and we'd find the conflict, but we
+         *      should stop the computation.  Previously I only checked for
+         *      exact config.  Need to check for same state, suffix context
+         * 		not just exact context.
+         *
+         *  o   Whenever closure reaches a configuration where state p
+         *      is present in its own context stack.  This means that
+         *      p is a rule invocation state and the target rule has
+         *      been called before.  NFAContext.MAX_RECURSIVE_INVOCATIONS
+         *      (See the comment there also) determines how many times
+         *      it's possible to recurse; clearly we cannot recurse forever.
+         *      Some grammars such as the following actually require at
+         *      least one recursive call to correctly compute the lookahead:
+         *
+         *      a : L ID R
+         *        | b
+         *        ;
+         *      b : ID
+         *        | L a R
+         *        ;
+         *
+         *      Input L ID R is ambiguous but to figure this out, ANTLR
+         *      needs to go a->b->a->b to find the L ID sequence.
+         *
+         *      Do not allow closure to add a configuration that would
+         *      allow too much recursion.
+         *
+         *      This case also catches infinite left recursion.
+         */
+        public virtual void closure( NFAState p,
+                            int alt,
+                            NFAContext context,
+                            SemanticContext semanticContext,
+                            DFAState d,
+                            bool collectPredicates )
+        {
+            if ( debug )
+            {
+                Console.Out.WriteLine( "closure at " + p.enclosingRule.name + " state " + p.stateNumber + "|" +
+                                   alt + " filling DFA state " + d.stateNumber + " with context " + context
+                                   );
+            }
+
+            if ( DFA.MAX_TIME_PER_DFA_CREATION > System.TimeSpan.Zero &&
+                 System.DateTime.Now - d.dfa.conversionStartTime >=
+                 DFA.MAX_TIME_PER_DFA_CREATION )
+            {
+                // bail way out; we've blown up somehow
+                throw new AnalysisTimeoutException( d.dfa );
+            }
+
+            NFAConfiguration proposedNFAConfiguration =
+                    new NFAConfiguration( p.stateNumber,
+                            alt,
+                            context,
+                            semanticContext );
+
+            // Avoid infinite recursion
+            if ( closureIsBusy( d, proposedNFAConfiguration ) )
+            {
+                if ( debug )
+                {
+                    Console.Out.WriteLine( "avoid visiting exact closure computation NFA config: " +
+                                       proposedNFAConfiguration + " in " + p.enclosingRule.name );
+                    Console.Out.WriteLine( "state is " + d.dfa.decisionNumber + "." + d.stateNumber );
+                }
+                return;
+            }
+
+            // set closure to be busy for this NFA configuration
+            d.closureBusy.Add( proposedNFAConfiguration );
+
+            // p itself is always in closure
+            d.addNFAConfiguration( p, proposedNFAConfiguration );
+
+            // Case 1: are we a reference to another rule?
+            Transition transition0 = p.transition[0];
+            if ( transition0 is RuleClosureTransition )
+            {
+                int depth = context.recursionDepthEmanatingFromState( p.stateNumber );
+                // Detect recursion by more than a single alt, which indicates
+                // that the decision's lookahead language is non-regular; terminate
+                if ( depth == 1 && d.dfa.UserMaxLookahead == 0 )
+                { // k=* only
+                    d.dfa.recursiveAltSet.add( alt ); // indicate that this alt is recursive
+                    if ( d.dfa.recursiveAltSet.size() > 1 )
+                    {
+                        //JSystem.@out.println("recursive alts: "+d.dfa.recursiveAltSet.toString());
+                        d.abortedDueToMultipleRecursiveAlts = true;
+                        throw new NonLLStarDecisionException( d.dfa );
+                    }
+                    /*
+                    JSystem.@out.println("alt "+alt+" in rule "+p.enclosingRule+" dec "+d.dfa.decisionNumber+
+                        " ctx: "+context);
+                    JSystem.@out.println("d="+d);
+                    */
+                }
+                // Detect an attempt to recurse too high
+                // if this context has hit the max recursions for p.stateNumber,
+                // don't allow it to enter p.stateNumber again
+                if ( depth >= NFAContext.MAX_SAME_RULE_INVOCATIONS_PER_NFA_CONFIG_STACK )
+                {
+                    /*
+                    JSystem.@out.println("OVF state "+d);
+                    JSystem.@out.println("proposed "+proposedNFAConfiguration);
+                    */
+                    d.abortedDueToRecursionOverflow = true;
+                    d.dfa.probe.reportRecursionOverflow( d, proposedNFAConfiguration );
+                    if ( debug )
+                    {
+                        Console.Out.WriteLine( "analysis overflow in closure(" + d.stateNumber + ")" );
+                    }
+                    return;
+                }
+
+                // otherwise, it's cool to (re)enter target of this rule ref
+                RuleClosureTransition @ref = (RuleClosureTransition)transition0;
+                // first create a new context and push onto call tree,
+                // recording the fact that we are invoking a rule and
+                // from which state (case 2 below will get the following state
+                // via the RuleClosureTransition emanating from the invoking state
+                // pushed on the stack).
+                // Reset the context to reflect the fact we invoked rule
+                NFAContext newContext = new NFAContext( context, p );
+                //JSystem.@out.println("invoking rule "+ref.rule.name);
+                // JSystem.@out.println(" context="+context);
+                // traverse epsilon edge to new rule
+                NFAState ruleTarget = (NFAState)@ref.target;
+                closure( ruleTarget, alt, newContext, semanticContext, d, collectPredicates );
+            }
+            // Case 2: end of rule state, context (i.e., an invoker) exists
+            else if ( p.IsAcceptState && context.parent != null )
+            {
+                NFAState whichStateInvokedRule = context.invokingState;
+                RuleClosureTransition edgeToRule =
+                    (RuleClosureTransition)whichStateInvokedRule.transition[0];
+                NFAState continueState = edgeToRule.followState;
+                NFAContext newContext = context.parent; // "pop" invoking state
+                closure( continueState, alt, newContext, semanticContext, d, collectPredicates );
+            }
+            // Case 3: end of rule state, nobody invoked this rule (no context)
+            //    Fall thru to be handled by case 4 automagically.
+            // Case 4: ordinary NFA->DFA conversion case: simple epsilon transition
+            else
+            {
+                // recurse down any epsilon transitions
+                if ( transition0 != null && transition0.IsEpsilon )
+                {
+                    bool collectPredicatesAfterAction = collectPredicates;
+                    if ( transition0.IsAction && collectPredicates )
+                    {
+                        collectPredicatesAfterAction = false;
+                        /*
+                        if ( computingStartState ) {
+                            JSystem.@out.println("found action during prediction closure "+((ActionLabel)transition0.label).actionAST.token);
+                        }
+                         */
+                    }
+                    closure( (NFAState)transition0.target,
+                            alt,
+                            context,
+                            semanticContext,
+                            d,
+                            collectPredicatesAfterAction
+                    );
+                }
+                else if ( transition0 != null && transition0.IsSemanticPredicate )
+                {
+                    if ( computingStartState )
+                    {
+                        if ( collectPredicates )
+                        {
+                            // only indicate we can see a predicate if we're collecting preds
+                            // Could be computing start state & seen an action before this.
+                            dfa.predicateVisible = true;
+                        }
+                        else
+                        {
+                            // this state has a pred, but we can't see it.
+                            dfa.hasPredicateBlockedByAction = true;
+                            // JSystem.@out.println("found pred during prediction but blocked by action found previously");
+                        }
+                    }
+                    // continue closure here too, but add the sem pred to ctx
+                    SemanticContext newSemanticContext = semanticContext;
+                    if ( collectPredicates )
+                    {
+                        // AND the previous semantic context with new pred
+                        SemanticContext labelContext =
+                            transition0.label.SemanticContext;
+                        // do not hoist syn preds from other rules; only get if in
+                        // starting state's rule (i.e., context is empty)
+                        int walkAlt =
+                            dfa.decisionNFAStartState.translateDisplayAltToWalkAlt( alt );
+                        NFAState altLeftEdge =
+                            dfa.nfa.grammar.getNFAStateForAltOfDecision( dfa.decisionNFAStartState, walkAlt );
+                        /*
+                        JSystem.@out.println("state "+p.stateNumber+" alt "+alt+" walkAlt "+walkAlt+" trans to "+transition0.target);
+                        JSystem.@out.println("DFA start state "+dfa.decisionNFAStartState.stateNumber);
+                        JSystem.@out.println("alt left edge "+altLeftEdge.stateNumber+
+                            ", epsilon target "+
+                            altLeftEdge.transition(0).target.stateNumber);
+                        */
+                        if ( !labelContext.IsSyntacticPredicate ||
+                             p == altLeftEdge.transition[0].target )
+                        {
+                            //JSystem.@out.println("&"+labelContext+" enclosingRule="+p.enclosingRule);
+                            newSemanticContext =
+                                SemanticContext.and( semanticContext, labelContext );
+                        }
+                    }
+                    closure( (NFAState)transition0.target,
+                            alt,
+                            context,
+                            newSemanticContext,
+                            d,
+                            collectPredicates );
+                }
+                Transition transition1 = p.transition[1];
+                if ( transition1 != null && transition1.IsEpsilon )
+                {
+                    closure( (NFAState)transition1.target,
+                            alt,
+                            context,
+                            semanticContext,
+                            d,
+                            collectPredicates );
+                }
+            }
+
+            // don't remove "busy" flag as we want to prevent all
+            // references to same config of state|alt|ctx|semCtx even
+            // if resulting from another NFA state
+        }
+
+        /** A closure operation should abort if that computation has already
+         *  been done or a computation with a conflicting context has already
+         *  been done.  If proposed NFA config's state and alt are the same
+         *  there is potentially a problem.  If the stack context is identical
+         *  then clearly the exact same computation is proposed.  If a context
+         *  is a suffix of the other, then again the computation is in an
+         *  identical context.  ?$ and ??$ are considered the same stack.
+         *  We could walk configurations linearly doing the comparison instead
+         *  of a set for exact matches but it's much slower because you can't
+         *  do a Set lookup.  I use exact match as ANTLR
+         *  always detect the conflict later when checking for context suffixes...
+         *  I check for left-recursive stuff and terminate before analysis to
+         *  avoid need to do this more expensive computation.
+         *
+         *  12-31-2007: I had to use the loop again rather than simple
+         *  closureBusy.contains(proposedNFAConfiguration) lookup.  The
+         *  semantic context should not be considered when determining if
+         *  a closure operation is busy.  I saw a FOLLOW closure operation
+         *  spin until time out because the predicate context kept increasing
+         *  in size even though it's same boolean value.  This seems faster also
+         *  because I'm not doing String.equals on the preds all the time.
+         *
+         *  05-05-2008: Hmm...well, i think it was a mistake to remove the sem
+         *  ctx check below...adding back in.  Coincides with report of ANTLR
+         *  getting super slow: http://www.antlr.org:8888/browse/ANTLR-235
+         *  This could be because it doesn't properly compute then resolve
+         *  a predicate expression.  Seems to fix unit test:
+         *  TestSemanticPredicates.testSemanticContextPreventsEarlyTerminationOfClosure()
+         *  Changing back to Set from List.  Changed a large grammar from 8 minutes
+         *  to 11 seconds.  Cool.  Closing ANTLR-235.
+         */
+        public static bool closureIsBusy( DFAState d,
+                                            NFAConfiguration proposedNFAConfiguration )
+        {
+            return d.closureBusy.Contains( proposedNFAConfiguration );
+            /*
+                    int numConfigs = d.closureBusy.size();
+                    // Check epsilon cycle (same state, same alt, same context)
+                    for (int i = 0; i < numConfigs; i++) {
+                        NFAConfiguration c = (NFAConfiguration) d.closureBusy.get(i);
+                        if ( proposedNFAConfiguration.state==c.state &&
+                             proposedNFAConfiguration.alt==c.alt &&
+                             proposedNFAConfiguration.semanticContext.equals(c.semanticContext) &&
+                             proposedNFAConfiguration.context.suffix(c.context) )
+                        {
+                            return true;
+                        }
+                    }
+                    return false;
+                    */
+        }
+
+        /** Given the set of NFA states in DFA state d, find all NFA states
+         *  reachable traversing label arcs.  By definition, there can be
+         *  only one DFA state reachable by an atom from DFA state d so we must
+         *  find and merge all NFA states reachable via label.  Return a new
+         *  DFAState that has all of those NFA states with their context (i.e.,
+         *  which alt do they predict and where to return to if they fall off
+         *  end of a rule).
+         *
+         *  Because we cannot jump to another rule nor fall off the end of a rule
+         *  via a non-epsilon transition, NFA states reachable from d have the
+         *  same configuration as the NFA state in d.  So if NFA state 7 in d's
+         *  configurations can reach NFA state 13 then 13 will be added to the
+         *  new DFAState (labelDFATarget) with the same configuration as state
+         *  7 had.
+         *
+         *  This method does not see EOT transitions off the end of token rule
+         *  accept states if the rule was invoked by somebody.
+         */
+        public virtual DFAState reach( DFAState d, Label label )
+        {
+            //JSystem.@out.println("reach "+label.toString(dfa.nfa.grammar)+" from "+d.stateNumber);
+            DFAState labelDFATarget = dfa.newState();
+
+            // for each NFA state in d with a labeled edge,
+            // add in target states for label
+            //JSystem.@out.println("size(d.state="+d.stateNumber+")="+d.nfaConfigurations.size());
+            //JSystem.@out.println("size(labeled edge states)="+d.configurationsWithLabeledEdges.size());
+            IList<NFAConfiguration> configs = d.configurationsWithLabeledEdges;
+            int numConfigs = configs.Count;
+            for ( int i = 0; i < numConfigs; i++ )
+            {
+                NFAConfiguration c = configs[i];
+                if ( c.resolved || c.resolveWithPredicate )
+                {
+                    continue; // the conflict resolver indicates we must leave alone
+                }
+                NFAState p = dfa.nfa.getState( c.state );
+                // by design of the grammar->NFA conversion, only transition 0
+                // may have a non-epsilon edge.
+                Transition edge = p.transition[0];
+                if ( edge == null || !c.singleAtomTransitionEmanating )
+                {
+                    continue;
+                }
+                Label edgeLabel = edge.label;
+
+                // SPECIAL CASE
+                // if it's an EOT transition on end of lexer rule, but context
+                // stack is not empty, then don't see the EOT; the closure
+                // will have added in the proper states following the reference
+                // to this rule in the invoking rule.  In other words, if
+                // somebody called this rule, don't see the EOT emanating from
+                // this accept state.
+                if ( c.context.parent != null && edgeLabel.label == Label.EOT )
+                {
+                    continue;
+                }
+
+                // Labels not unique at this point (not until addReachableLabels)
+                // so try simple int label match before general set intersection
+                //JSystem.@out.println("comparing "+edgeLabel+" with "+label);
+                if ( Label.intersect( label, edgeLabel ) )
+                {
+                    // found a transition with label;
+                    // add NFA target to (potentially) new DFA state
+                    NFAConfiguration newC = labelDFATarget.addNFAConfiguration(
+                        (NFAState)edge.target,
+                        c.alt,
+                        c.context,
+                        c.semanticContext );
+                }
+            }
+            if ( labelDFATarget.nfaConfigurations.size() == 0 )
+            {
+                // kill; it's empty
+                dfa.setState( labelDFATarget.stateNumber, null );
+                labelDFATarget = null;
+            }
+            return labelDFATarget;
+        }
+
+        /** Walk the configurations of this DFA state d looking for the
+         *  configuration, c, that has a transition on EOT.  State d should
+         *  be converted to an accept state predicting the c.alt.  Blast
+         *  d's current configuration set and make it just have config c.
+         *
+         *  TODO: can there be more than one config with EOT transition?
+         *  That would mean that two NFA configurations could reach the
+         *  end of the token with possibly different predicted alts.
+         *  Seems like that would be rare or impossible.  Perhaps convert
+         *  this routine to find all such configs and give error if >1.
+         */
+        protected virtual void convertToEOTAcceptState( DFAState d )
+        {
+            Label eot = new Label( Label.EOT );
+            int numConfigs = d.nfaConfigurations.size();
+            for ( int i = 0; i < numConfigs; i++ )
+            {
+                NFAConfiguration c = (NFAConfiguration)d.nfaConfigurations.get( i );
+                if ( c.resolved || c.resolveWithPredicate )
+                {
+                    continue; // the conflict resolver indicates we must leave alone
+                }
+                NFAState p = dfa.nfa.getState( c.state );
+                Transition edge = p.transition[0];
+                Label edgeLabel = edge.label;
+                if ( edgeLabel.Equals( eot ) )
+                {
+                    //JSystem.@out.println("config with EOT: "+c);
+                    d.IsAcceptState = true;
+                    //JSystem.@out.println("d goes from "+d);
+                    d.nfaConfigurations.clear();
+                    d.addNFAConfiguration( p, c.alt, c.context, c.semanticContext );
+                    //JSystem.@out.println("to "+d);
+                    return; // assume only one EOT transition
+                }
+            }
+        }
+
+        /** Add a new DFA state to the DFA if not already present.
+         *  If the DFA state uniquely predicts a single alternative, it
+         *  becomes a stop state; don't add to work list.  Further, if
+         *  there exists an NFA state predicted by > 1 different alternatives
+         *  and with the same syn and sem context, the DFA is nondeterministic for
+         *  at least one input sequence reaching that NFA state.
+         */
+        protected virtual DFAState addDFAStateToWorkList( DFAState d )
+        {
+            DFAState existingState = dfa.addState( d );
+            if ( d != existingState )
+            {
+                // already there...use/return the existing DFA state.
+                // But also set the states[d.stateNumber] to the existing
+                // DFA state because the closureIsBusy must report
+                // infinite recursion on a state before it knows
+                // whether or not the state will already be
+                // found after closure on it finishes.  It could be
+                // referring to a state that will ultimately not make it
+                // into the reachable state space and the error
+                // reporting must be able to compute the path from
+                // start to the error state with infinite recursion
+                dfa.setState( d.stateNumber, existingState );
+                return existingState;
+            }
+
+            // if not there, then examine new state.
+
+            // resolve syntactic conflicts by choosing a single alt or
+            // by using semantic predicates if present.
+            resolveNonDeterminisms( d );
+
+            // If deterministic, don't add this state; it's an accept state
+            // Just return as a valid DFA state
+            int alt = d.getUniquelyPredictedAlt();
+            if ( alt != NFA.INVALID_ALT_NUMBER )
+            { // uniquely predicts an alt?
+                d = convertToAcceptState( d, alt );
+                /*
+                JSystem.@out.println("convert to accept; DFA "+d.dfa.decisionNumber+" state "+d.stateNumber+" uniquely predicts alt "+
+                    d.getUniquelyPredictedAlt());
+                    */
+            }
+            else
+            {
+                // unresolved, add to work list to continue NFA conversion
+                work.Enqueue( d );
+            }
+            return d;
+        }
+
+        protected virtual DFAState convertToAcceptState( DFAState d, int alt )
+        {
+            // only merge stop states if they are deterministic and no
+            // recursion problems and only if they have the same gated pred
+            // context!
+            // Later, the error reporting may want to trace the path from
+            // the start state to the nondet state
+            if ( DFAOptimizer.MERGE_STOP_STATES &&
+                d.getNonDeterministicAlts() == null &&
+                !d.abortedDueToRecursionOverflow &&
+                !d.abortedDueToMultipleRecursiveAlts )
+            {
+                // check to see if we already have an accept state for this alt
+                // [must do this after we resolve nondeterminisms in general]
+                DFAState acceptStateForAlt = dfa.getAcceptState( alt );
+                if ( acceptStateForAlt != null )
+                {
+                    // we already have an accept state for alt;
+                    // Are their gate sem pred contexts the same?
+                    // For now we assume a braindead version: both must not
+                    // have gated preds or share exactly same single gated pred.
+                    // The equals() method is only defined on Predicate contexts not
+                    // OR etc...
+                    SemanticContext gatedPreds = d.getGatedPredicatesInNFAConfigurations();
+                    SemanticContext existingStateGatedPreds =
+                        acceptStateForAlt.getGatedPredicatesInNFAConfigurations();
+                    if ( ( gatedPreds == null && existingStateGatedPreds == null ) ||
+                         ( ( gatedPreds != null && existingStateGatedPreds != null ) &&
+                          gatedPreds.Equals( existingStateGatedPreds ) ) )
+                    {
+                        // make this d.statenumber point at old DFA state
+                        dfa.setState( d.stateNumber, acceptStateForAlt );
+                        dfa.removeState( d );    // remove this state from unique DFA state set
+                        d = acceptStateForAlt; // use old accept state; throw this one out
+                        return d;
+                    }
+                    // else consider it a new accept state; fall through.
+                }
+            }
+            d.IsAcceptState = true; // new accept state for alt
+            dfa.setAcceptState( alt, d );
+            return d;
+        }
+
+        /** If > 1 NFA configurations within this DFA state have identical
+         *  NFA state and context, but differ in their predicted
+         *  TODO update for new context suffix stuff 3-9-2005
+         *  alternative then a single input sequence predicts multiple alts.
+         *  The NFA decision is therefore syntactically indistinguishable
+         *  from the left edge upon at least one input sequence.  We may
+         *  terminate the NFA to DFA conversion for these paths since no
+         *  paths emanating from those NFA states can possibly separate
+         *  these conjoined twins once interwined to make things
+         *  deterministic (unless there are semantic predicates; see below).
+         *
+         *  Upon a nondeterministic set of NFA configurations, we should
+         *  report a problem to the grammar designer and resolve the issue
+         *  by aribitrarily picking the first alternative (this usually
+         *  ends up producing the most natural behavior).  Pick the lowest
+         *  alt number and just turn off all NFA configurations
+         *  associated with the other alts. Rather than remove conflicting
+         *  NFA configurations, I set the "resolved" bit so that future
+         *  computations will ignore them.  In this way, we maintain the
+         *  complete DFA state with all its configurations, but prevent
+         *  future DFA conversion operations from pursuing undesirable
+         *  paths.  Remember that we want to terminate DFA conversion as
+         *  soon as we know the decision is deterministic *or*
+         *  nondeterministic.
+         *
+         *  [BTW, I have convinced myself that there can be at most one
+         *  set of nondeterministic configurations in a DFA state.  Only NFA
+         *  configurations arising from the same input sequence can appear
+         *  in a DFA state.  There is no way to have another complete set
+         *  of nondeterministic NFA configurations without another input
+         *  sequence, which would reach a different DFA state.  Therefore,
+         *  the two nondeterministic NFA configuration sets cannot collide
+         *  in the same DFA state.]
+         *
+         *  Consider DFA state {(s|1),(s|2),(s|3),(t|3),(v|4)} where (s|a)
+         *  is state 's' and alternative 'a'.  Here, configuration set
+         *  {(s|1),(s|2),(s|3)} predicts 3 different alts.  Configurations
+         *  (s|2) and (s|3) are "resolved", leaving {(s|1),(t|3),(v|4)} as
+         *  items that must still be considered by the DFA conversion
+         *  algorithm in DFA.findNewDFAStatesAndAddDFATransitions().
+         *
+         *  Consider the following grammar where alts 1 and 2 are no
+         *  problem because of the 2nd lookahead symbol.  Alts 3 and 4 are
+         *  identical and will therefore reach the rule end NFA state but
+         *  predicting 2 different alts (no amount of future lookahead
+         *  will render them deterministic/separable):
+         *
+         *  a : A B
+         *    | A C
+         *    | A
+         *    | A
+         *    ;
+         *
+         *  Here is a (slightly reduced) NFA of this grammar:
+         *
+         *  (1)-A->(2)-B->(end)-EOF->(8)
+         *   |              ^
+         *  (2)-A->(3)-C----|
+         *   |              ^
+         *  (4)-A->(5)------|
+         *   |              ^
+         *  (6)-A->(7)------|
+         *
+         *  where (n) is NFA state n.  To begin DFA conversion, the start
+         *  state is created:
+         *
+         *  {(1|1),(2|2),(4|3),(6|4)}
+         *
+         *  Upon A, all NFA configurations lead to new NFA states yielding
+         *  new DFA state:
+         *
+         *  {(2|1),(3|2),(5|3),(7|4),(end|3),(end|4)}
+         *
+         *  where the configurations with state end in them are added
+         *  during the epsilon closure operation.  State end predicts both
+         *  alts 3 and 4.  An error is reported, the latter configuration is
+         *  flagged as resolved leaving the DFA state as:
+         *
+         *  {(2|1),(3|2),(5|3),(7|4|resolved),(end|3),(end|4|resolved)}
+         *
+         *  As NFA configurations are added to a DFA state during its
+         *  construction, the reachable set of labels is computed.  Here
+         *  reachable is {B,C,EOF} because there is at least one NFA state
+         *  in the DFA state that can transition upon those symbols.
+         *
+         *  The final DFA looks like:
+         *
+         *  {(1|1),(2|2),(4|3),(6|4)}
+         *              |
+         *              v
+         *  {(2|1),(3|2),(5|3),(7|4),(end|3),(end|4)} -B-> (end|1)
+         *              |                        |
+         *              C                        ----EOF-> (8,3)
+         *              |
+         *              v
+         *           (end|2)
+         *
+         *  Upon AB, alt 1 is predicted.  Upon AC, alt 2 is predicted.
+         *  Upon A EOF, alt 3 is predicted.  Alt 4 is not a viable
+         *  alternative.
+         *
+         *  The algorithm is essentially to walk all the configurations
+         *  looking for a conflict of the form (s|i) and (s|j) for i!=j.
+         *  Use a hash table to track state+context pairs for collisions
+         *  so that we have O(n) to walk the n configurations looking for
+         *  a conflict.  Upon every conflict, track the alt number so
+         *  we have a list of all nondeterministically predicted alts. Also
+         *  track the minimum alt.  Next go back over the configurations, setting
+         *  the "resolved" bit for any that have an alt that is a member of
+         *  the nondeterministic set.  This will effectively remove any alts
+         *  but the one we want from future consideration.
+         *
+         *  See resolveWithSemanticPredicates()
+         *
+         *  AMBIGUOUS TOKENS
+         *
+         *  With keywords and ID tokens, there is an inherit ambiguity in that
+         *  "int" can be matched by ID also.  Each lexer rule has an EOT
+         *  transition emanating from it which is used whenever the end of
+         *  a rule is reached and another token rule did not invoke it.  EOT
+         *  is the only thing that can be seen next.  If two rules are identical
+         *  like "int" and "int" then the 2nd def is unreachable and you'll get
+         *  a warning.  We prevent a warning though for the keyword/ID issue as
+         *  ID is still reachable.  This can be a bit weird.  '+' rule then a
+         *  '+'|'+=' rule will fail to match '+' for the 2nd rule.
+         *
+         *  If all NFA states in this DFA state are targets of EOT transitions,
+         *  (and there is more than one state plus no unique alt is predicted)
+         *  then DFA conversion will leave this state as a dead state as nothing
+         *  can be reached from this state.  To resolve the ambiguity, just do
+         *  what flex and friends do: pick the first rule (alt in this case) to
+         *  win.  This means you should put keywords before the ID rule.
+         *  If the DFA state has only one NFA state then there is no issue:
+         *  it uniquely predicts one alt. :)  Problem
+         *  states will look like this during conversion:
+         *
+         *  DFA 1:{9|1, 19|2, 14|3, 20|2, 23|2, 24|2, ...}-<EOT>->5:{41|3, 42|2}
+         *
+         *  Worse, when you have two identical literal rules, you will see 3 alts
+         *  in the EOT state (one for ID and one each for the identical rules).
+         */
+        public virtual void resolveNonDeterminisms( DFAState d )
+        {
+            if ( debug )
+            {
+                Console.Out.WriteLine( "resolveNonDeterminisms " + d.ToString() );
+            }
+            bool conflictingLexerRules = false;
+            HashSet<int> nondeterministicAlts = d.getNonDeterministicAlts();
+            if ( debug && nondeterministicAlts != null )
+            {
+                Console.Out.WriteLine( "nondet alts=" + nondeterministicAlts );
+            }
+
+            // CHECK FOR AMBIGUOUS EOT (if |allAlts|>1 and EOT state, resolve)
+            // grab any config to see if EOT state; any other configs must
+            // transition on EOT to get to this DFA state as well so all
+            // states in d must be targets of EOT.  These are the end states
+            // created in NFAFactory.build_EOFState
+            NFAConfiguration anyConfig = d.nfaConfigurations.get( 0 );
+            NFAState anyState = dfa.nfa.getState( anyConfig.state );
+
+            // if d is target of EOT and more than one predicted alt
+            // indicate that d is nondeterministic on all alts otherwise
+            // it looks like state has no problem
+            if ( anyState.IsEOTTargetState )
+            {
+                HashSet<int> allAlts = new HashSet<int>( d.AltSet );
+                // is more than 1 alt predicted?
+                if ( allAlts != null && allAlts.Count > 1 )
+                {
+                    nondeterministicAlts = allAlts;
+                    // track Tokens rule issues differently than other decisions
+                    if ( d.dfa.IsTokensRuleDecision )
+                    {
+                        dfa.probe.reportLexerRuleNondeterminism( d, allAlts );
+                        //JSystem.@out.println("Tokens rule DFA state "+d+" nondeterministic");
+                        conflictingLexerRules = true;
+                    }
+                }
+            }
+
+            // if no problems return unless we aborted work on d to avoid inf recursion
+            if ( !d.abortedDueToRecursionOverflow && nondeterministicAlts == null )
+            {
+                return; // no problems, return
+            }
+
+            // if we're not a conflicting lexer rule and we didn't abort, report ambig
+            // We should get a report for abort so don't give another
+            if ( !d.abortedDueToRecursionOverflow && !conflictingLexerRules )
+            {
+                // TODO: with k=x option set, this is called twice for same state
+                dfa.probe.reportNondeterminism( d, nondeterministicAlts );
+                // TODO: how to turn off when it's only the FOLLOW that is
+                // conflicting.  This used to shut off even alts i,j < n
+                // conflict warnings. :(
+            }
+
+            // ATTEMPT TO RESOLVE WITH SEMANTIC PREDICATES
+            bool resolved =
+                tryToResolveWithSemanticPredicates( d, nondeterministicAlts );
+            if ( resolved )
+            {
+                if ( debug )
+                {
+                    Console.Out.WriteLine( "resolved DFA state " + d.stateNumber + " with pred" );
+                }
+                d.resolvedWithPredicates = true;
+                dfa.probe.reportNondeterminismResolvedWithSemanticPredicate( d );
+                return;
+            }
+
+            // RESOLVE SYNTACTIC CONFLICT BY REMOVING ALL BUT ONE ALT
+            resolveByChoosingFirstAlt( d, nondeterministicAlts );
+
+            //JSystem.@out.println("state "+d.stateNumber+" resolved to alt "+winningAlt);
+        }
+
+        protected virtual int resolveByChoosingFirstAlt( DFAState d, ICollection<int> nondeterministicAlts )
+        {
+            int winningAlt = 0;
+            if ( dfa.IsGreedy )
+            {
+                winningAlt = resolveByPickingMinAlt( d, nondeterministicAlts );
+            }
+            else
+            {
+                // If nongreedy, the exit alt shout win, but only if it's
+                // involved in the nondeterminism!
+                /*
+                JSystem.@out.println("resolving exit alt for decision="+
+                    dfa.decisionNumber+" state="+d);
+                JSystem.@out.println("nondet="+nondeterministicAlts);
+                JSystem.@out.println("exit alt "+exitAlt);
+                */
+                int exitAlt = dfa.NumberOfAlts;
+                if ( nondeterministicAlts.Contains( exitAlt ) )
+                {
+                    // if nongreedy and exit alt is one of those nondeterministic alts
+                    // predicted, resolve in favor of what follows block
+                    winningAlt = resolveByPickingExitAlt( d, nondeterministicAlts );
+                }
+                else
+                {
+                    winningAlt = resolveByPickingMinAlt( d, nondeterministicAlts );
+                }
+            }
+            return winningAlt;
+        }
+
+        /** Turn off all configurations associated with the
+         *  set of incoming nondeterministic alts except the min alt number.
+         *  There may be many alts among the configurations but only turn off
+         *  the ones with problems (other than the min alt of course).
+         *
+         *  If nondeterministicAlts is null then turn off all configs 'cept those
+         *  associated with the minimum alt.
+         *
+         *  Return the min alt found.
+         */
+        protected virtual int resolveByPickingMinAlt( DFAState d, ICollection<int> nondeterministicAlts )
+        {
+            int min = int.MaxValue;
+            if ( nondeterministicAlts != null )
+            {
+                min = getMinAlt( nondeterministicAlts );
+            }
+            else
+            {
+                min = d.minAltInConfigurations;
+            }
+
+            turnOffOtherAlts( d, min, nondeterministicAlts );
+
+            return min;
+        }
+
+        /** Resolve state d by choosing exit alt, which is same value as the
+         *  number of alternatives.  Return that exit alt.
+         */
+        protected virtual int resolveByPickingExitAlt( DFAState d, ICollection<int> nondeterministicAlts )
+        {
+            int exitAlt = dfa.NumberOfAlts;
+            turnOffOtherAlts( d, exitAlt, nondeterministicAlts );
+            return exitAlt;
+        }
+
+        /** turn off all states associated with alts other than the good one
+         *  (as long as they are one of the nondeterministic ones)
+         */
+        protected static void turnOffOtherAlts( DFAState d, int min, ICollection<int> nondeterministicAlts )
+        {
+            int numConfigs = d.nfaConfigurations.size();
+            for ( int i = 0; i < numConfigs; i++ )
+            {
+                NFAConfiguration configuration = (NFAConfiguration)d.nfaConfigurations.get( i );
+                if ( configuration.alt != min )
+                {
+                    if ( nondeterministicAlts == null ||
+                         nondeterministicAlts.Contains( configuration.alt ) )
+                    {
+                        configuration.resolved = true;
+                    }
+                }
+            }
+        }
+
+        protected static int getMinAlt( ICollection<int> nondeterministicAlts )
+        {
+            int min = int.MaxValue;
+            foreach ( int altI in nondeterministicAlts )
+            {
+                int alt = altI;
+                if ( alt < min )
+                {
+                    min = alt;
+                }
+            }
+            return min;
+        }
+
+        /** See if a set of nondeterministic alternatives can be disambiguated
+         *  with the semantic predicate contexts of the alternatives.
+         *
+         *  Without semantic predicates, syntactic conflicts are resolved
+         *  by simply choosing the first viable alternative.  In the
+         *  presence of semantic predicates, you can resolve the issue by
+         *  evaluating boolean expressions at run time.  During analysis,
+         *  this amounts to suppressing grammar error messages to the
+         *  developer.  NFA configurations are always marked as "to be
+         *  resolved with predicates" so that
+         *  DFA.findNewDFAStatesAndAddDFATransitions() will know to ignore
+         *  these configurations and add predicate transitions to the DFA
+         *  after adding token/char labels.
+         *
+         *  During analysis, we can simply make sure that for n
+         *  ambiguously predicted alternatives there are at least n-1
+         *  unique predicate sets.  The nth alternative can be predicted
+         *  with "not" the "or" of all other predicates.  NFA configurations without
+         *  predicates are assumed to have the default predicate of
+         *  "true" from a user point of view.  When true is combined via || with
+         *  another predicate, the predicate is a tautology and must be removed
+         *  from consideration for disambiguation:
+         *
+         *  a : b | B ; // hoisting p1||true out of rule b, yields no predicate
+         *  b : {p1}? B | B ;
+         *
+         *  This is done down in getPredicatesPerNonDeterministicAlt().
+         */
+        protected virtual bool tryToResolveWithSemanticPredicates( DFAState d,
+                                                             ICollection<int> nondeterministicAlts )
+        {
+            IDictionary<int, SemanticContext> altToPredMap =
+                    getPredicatesPerNonDeterministicAlt( d, nondeterministicAlts );
+
+            if ( altToPredMap.Count == 0 )
+            {
+                return false;
+            }
+
+            //JSystem.@out.println("nondeterministic alts with predicates: "+altToPredMap);
+            dfa.probe.reportAltPredicateContext( d, altToPredMap );
+
+            if ( nondeterministicAlts.Count - altToPredMap.Count > 1 )
+            {
+                // too few predicates to resolve; just return
+                // TODO: actually do we need to gen error here?
+                return false;
+            }
+
+            // Handle case where 1 predicate is missing
+            // Case 1. Semantic predicates
+            // If the missing pred is on nth alt, !(union of other preds)==true
+            // so we can avoid that computation.  If naked alt is ith, then must
+            // test it with !(union) since semantic predicated alts are order
+            // independent
+            // Case 2: Syntactic predicates
+            // The naked alt is always assumed to be true as the order of
+            // alts is the order of precedence.  The naked alt will be a tautology
+            // anyway as it's !(union of other preds).  This implies
+            // that there is no such thing as noviable alt for synpred edges
+            // emanating from a DFA state.
+            if ( altToPredMap.Count == nondeterministicAlts.Count - 1 )
+            {
+                // if there are n-1 predicates for n nondeterministic alts, can fix
+                BitSet ndSet = BitSet.of( nondeterministicAlts );
+                BitSet predSet = BitSet.of( altToPredMap );
+                int nakedAlt = ndSet.subtract( predSet ).getSingleElement();
+                SemanticContext nakedAltPred = null;
+                if ( nakedAlt == max( nondeterministicAlts ) )
+                {
+                    // the naked alt is the last nondet alt and will be the default clause
+                    nakedAltPred = new SemanticContext.TruePredicate();
+                }
+                else
+                {
+                    // pretend naked alternative is covered with !(union other preds)
+                    // unless it's a synpred since those have precedence same
+                    // as alt order
+                    SemanticContext unionOfPredicatesFromAllAlts =
+                        getUnionOfPredicates( altToPredMap );
+                    //JSystem.@out.println("all predicates "+unionOfPredicatesFromAllAlts);
+                    if ( unionOfPredicatesFromAllAlts.IsSyntacticPredicate )
+                    {
+                        nakedAltPred = new SemanticContext.TruePredicate();
+                    }
+                    else
+                    {
+                        nakedAltPred =
+                            SemanticContext.not( unionOfPredicatesFromAllAlts );
+                    }
+                }
+
+                //JSystem.@out.println("covering naked alt="+nakedAlt+" with "+nakedAltPred);
+
+                altToPredMap[nakedAlt] = nakedAltPred;
+                // set all config with alt=nakedAlt to have the computed predicate
+                int numConfigs = d.nfaConfigurations.size();
+                for ( int i = 0; i < numConfigs; i++ )
+                {
+                    NFAConfiguration configuration = (NFAConfiguration)d.nfaConfigurations.get( i );
+                    if ( configuration.alt == nakedAlt )
+                    {
+                        configuration.semanticContext = nakedAltPred;
+                    }
+                }
+            }
+
+            if ( altToPredMap.Count == nondeterministicAlts.Count )
+            {
+                // RESOLVE CONFLICT by picking one NFA configuration for each alt
+                // and setting its resolvedWithPredicate flag
+                // First, prevent a recursion warning on this state due to
+                // pred resolution
+                if ( d.abortedDueToRecursionOverflow )
+                {
+                    d.dfa.probe.removeRecursiveOverflowState( d );
+                }
+                int numConfigs = d.nfaConfigurations.size();
+                for ( int i = 0; i < numConfigs; i++ )
+                {
+                    NFAConfiguration configuration = (NFAConfiguration)d.nfaConfigurations.get( i );
+                    SemanticContext semCtx = (SemanticContext)
+                            altToPredMap.get( configuration.alt );
+                    if ( semCtx != null )
+                    {
+                        // resolve (first found) with pred
+                        // and remove alt from problem list
+                        configuration.resolveWithPredicate = true;
+                        configuration.semanticContext = semCtx; // reset to combined
+                        altToPredMap.Remove( configuration.alt );
+
+                        // notify grammar that we've used the preds contained in semCtx
+                        if ( semCtx.IsSyntacticPredicate )
+                        {
+                            dfa.nfa.grammar.synPredUsedInDFA( dfa, semCtx );
+                        }
+                    }
+                    else if ( nondeterministicAlts.Contains( configuration.alt ) )
+                    {
+                        // resolve all configurations for nondeterministic alts
+                        // for which there is no predicate context by turning it off
+                        configuration.resolved = true;
+                    }
+                }
+                return true;
+            }
+
+            return false;  // couldn't fix the problem with predicates
+        }
+
+        /** Return a mapping from nondeterministc alt to combined list of predicates.
+         *  If both (s|i|semCtx1) and (t|i|semCtx2) exist, then the proper predicate
+         *  for alt i is semCtx1||semCtx2 because you have arrived at this single
+         *  DFA state via two NFA paths, both of which have semantic predicates.
+         *  We ignore deterministic alts because syntax alone is sufficient
+         *  to predict those.  Do not include their predicates.
+         *
+         *  Alts with no predicate are assumed to have {true}? pred.
+         *
+         *  When combining via || with "true", all predicates are removed from
+         *  consideration since the expression will always be true and hence
+         *  not tell us how to resolve anything.  So, if any NFA configuration
+         *  in this DFA state does not have a semantic context, the alt cannot
+         *  be resolved with a predicate.
+         *
+         *  If nonnull, incidentEdgeLabel tells us what NFA transition label
+         *  we did a reach on to compute state d.  d may have insufficient
+         *  preds, so we really want this for the error message.
+         */
+        protected virtual IDictionary<int, SemanticContext> getPredicatesPerNonDeterministicAlt( DFAState d,
+                                                                                    ICollection<int> nondeterministicAlts )
+        {
+            // map alt to combined SemanticContext
+            IDictionary<int, SemanticContext> altToPredicateContextMap =
+                new Dictionary<int, SemanticContext>();
+            // init the alt to predicate set map
+            IDictionary<int, HashSet<SemanticContext>> altToSetOfContextsMap =
+                new Dictionary<int, HashSet<SemanticContext>>();
+            foreach ( int altI in nondeterministicAlts )
+            {
+                altToSetOfContextsMap[altI] = new HashSet<SemanticContext>();
+            }
+
+            /*
+            IList<Label> sampleInputLabels = d.dfa.probe.getSampleNonDeterministicInputSequence(d);
+            String input = d.dfa.probe.getInputSequenceDisplay(sampleInputLabels);
+            JSystem.@out.println("sample input: "+input);
+            */
+
+            // for each configuration, create a unique set of predicates
+            // Also, track the alts with at least one uncovered configuration
+            // (one w/o a predicate); tracks tautologies like p1||true
+            IDictionary<int, ICollection<IToken>> altToLocationsReachableWithoutPredicate = new Dictionary<int, ICollection<IToken>>();
+            HashSet<int> nondetAltsWithUncoveredConfiguration = new HashSet<int>();
+            //JSystem.@out.println("configs="+d.nfaConfigurations);
+            //JSystem.@out.println("configs with preds?"+d.atLeastOneConfigurationHasAPredicate);
+            //JSystem.@out.println("configs with preds="+d.configurationsWithPredicateEdges);
+            int numConfigs = d.nfaConfigurations.size();
+            for ( int i = 0; i < numConfigs; i++ )
+            {
+                NFAConfiguration configuration = (NFAConfiguration)d.nfaConfigurations.get( i );
+                int altI = configuration.alt;
+                // if alt is nondeterministic, combine its predicates
+                if ( nondeterministicAlts.Contains( altI ) )
+                {
+                    // if there is a predicate for this NFA configuration, OR in
+                    if ( configuration.semanticContext !=
+                         SemanticContext.EMPTY_SEMANTIC_CONTEXT )
+                    {
+                        HashSet<SemanticContext> predSet = altToSetOfContextsMap.get( altI );
+                        predSet.Add( configuration.semanticContext );
+                    }
+                    else
+                    {
+                        // if no predicate, but it's part of nondeterministic alt
+                        // then at least one path exists not covered by a predicate.
+                        // must remove predicate for this alt; track incomplete alts
+                        nondetAltsWithUncoveredConfiguration.Add( altI );
+                        /*
+                        NFAState s = dfa.nfa.getState(configuration.state);
+                        JSystem.@out.println("###\ndec "+dfa.decisionNumber+" alt "+configuration.alt+
+                                           " enclosing rule for nfa state not covered "+
+                                           s.enclosingRule);
+                        if ( s.associatedASTNode!=null ) {
+                            JSystem.@out.println("token="+s.associatedASTNode.token);
+                        }
+                        JSystem.@out.println("nfa state="+s);
+
+                        if ( s.incidentEdgeLabel!=null && Label.intersect(incidentEdgeLabel, s.incidentEdgeLabel) ) {
+                            Set<Token> locations = altToLocationsReachableWithoutPredicate.get(altI);
+                            if ( locations==null ) {
+                                locations = new HashSet<Token>();
+                                altToLocationsReachableWithoutPredicate.put(altI, locations);
+                            }
+                            locations.add(s.associatedASTNode.token);
+                        }
+                        */
+                    }
+                }
+            }
+
+            // For each alt, OR together all unique predicates associated with
+            // all configurations
+            // Also, track the list of incompletely covered alts: those alts
+            // with at least 1 predicate and at least one configuration w/o a
+            // predicate. We want this in order to report to the decision probe.
+            IList<int> incompletelyCoveredAlts = new List<int>();
+            foreach ( int altI in nondeterministicAlts )
+            {
+                HashSet<SemanticContext> contextsForThisAlt = altToSetOfContextsMap.get( altI );
+                if ( nondetAltsWithUncoveredConfiguration.Contains( altI ) )
+                { // >= 1 config has no ctx
+                    if ( contextsForThisAlt.Count > 0 )
+                    {    // && at least one pred
+                        incompletelyCoveredAlts.Add( altI );  // this alt incompleted covered
+                    }
+                    continue; // don't include at least 1 config has no ctx
+                }
+                SemanticContext combinedContext = null;
+                foreach ( SemanticContext ctx in contextsForThisAlt )
+                {
+                    combinedContext = SemanticContext.or( combinedContext, ctx );
+                }
+                altToPredicateContextMap[altI] = combinedContext;
+            }
+
+            if ( incompletelyCoveredAlts.Count > 0 )
+            {
+                /*
+                JSystem.@out.println("prob in dec "+dfa.decisionNumber+" state="+d);
+                FASerializer serializer = new FASerializer(dfa.nfa.grammar);
+                String result = serializer.serialize(dfa.startState);
+                JSystem.@out.println("dfa: "+result);
+                JSystem.@out.println("incomplete alts: "+incompletelyCoveredAlts);
+                JSystem.@out.println("nondet="+nondeterministicAlts);
+                JSystem.@out.println("nondetAltsWithUncoveredConfiguration="+ nondetAltsWithUncoveredConfiguration);
+                JSystem.@out.println("altToCtxMap="+altToSetOfContextsMap);
+                JSystem.@out.println("altToPredicateContextMap="+altToPredicateContextMap);
+                */
+                for ( int i = 0; i < numConfigs; i++ )
+                {
+                    NFAConfiguration configuration = (NFAConfiguration)d.nfaConfigurations.get( i );
+                    int altI = configuration.alt;
+                    if ( incompletelyCoveredAlts.Contains( altI ) &&
+                         configuration.semanticContext == SemanticContext.EMPTY_SEMANTIC_CONTEXT )
+                    {
+                        NFAState s = dfa.nfa.getState( configuration.state );
+                        /*
+                        JSystem.@out.print("nondet config w/o context "+configuration+
+                                         " incident "+(s.incidentEdgeLabel!=null?s.incidentEdgeLabel.toString(dfa.nfa.grammar):null));
+                        if ( s.associatedASTNode!=null ) {
+                            JSystem.@out.print(" token="+s.associatedASTNode.token);
+                        }
+                        else JSystem.@out.println();
+                        */
+                        // We want to report getting to an NFA state with an
+                        // incoming label, unless it's EOF, w/o a predicate.
+                        if ( s.incidentEdgeLabel != null && s.incidentEdgeLabel.label != Label.EOF )
+                        {
+                            if ( s.associatedASTNode == null || s.associatedASTNode.token == null )
+                            {
+                                ErrorManager.internalError( "no AST/token for nonepsilon target w/o predicate" );
+                            }
+                            else
+                            {
+                                ICollection<IToken> locations = altToLocationsReachableWithoutPredicate.get( altI );
+                                if ( locations == null )
+                                {
+                                    locations = new HashSet<IToken>();
+                                    altToLocationsReachableWithoutPredicate[altI] = locations;
+                                }
+                                locations.Add( s.associatedASTNode.token );
+                            }
+                        }
+                    }
+                }
+                dfa.probe.reportIncompletelyCoveredAlts( d,
+                                                        altToLocationsReachableWithoutPredicate );
+            }
+
+            return altToPredicateContextMap;
+        }
+
+        /** OR together all predicates from the alts.  Note that the predicate
+         *  for an alt could itself be a combination of predicates.
+         */
+        protected static SemanticContext getUnionOfPredicates( IDictionary<int, SemanticContext> altToPredMap )
+        {
+            SemanticContext unionOfPredicatesFromAllAlts = null;
+            foreach ( SemanticContext semCtx in altToPredMap.Values )
+            {
+                if ( unionOfPredicatesFromAllAlts == null )
+                {
+                    unionOfPredicatesFromAllAlts = semCtx;
+                }
+                else
+                {
+                    unionOfPredicatesFromAllAlts =
+                            SemanticContext.or( unionOfPredicatesFromAllAlts, semCtx );
+                }
+            }
+            return unionOfPredicatesFromAllAlts;
+        }
+
+        class AddPredicateTransitionsComparer : IComparer<NFAConfiguration>
+        {
+            public virtual int Compare( NFAConfiguration ca, NFAConfiguration cb )
+            {
+                if ( ca.alt < cb.alt )
+                    return -1;
+                else if ( ca.alt > cb.alt )
+                    return 1;
+                return 0;
+            }
+        }
+
+        /** for each NFA config in d, look for "predicate required" sign set
+         *  during nondeterminism resolution.
+         *
+         *  Add the predicate edges sorted by the alternative number; I'm fairly
+         *  sure that I could walk the configs backwards so they are added to
+         *  the predDFATarget in the right order, but it's best to make sure.
+         *  Predicates succeed in the order they are specifed.  Alt i wins
+         *  over alt i+1 if both predicates are true.
+         */
+        protected virtual void addPredicateTransitions( DFAState d )
+        {
+            List<NFAConfiguration> configsWithPreds = new List<NFAConfiguration>();
+            // get a list of all configs with predicates
+            int numConfigs = d.nfaConfigurations.size();
+            for ( int i = 0; i < numConfigs; i++ )
+            {
+                NFAConfiguration c = (NFAConfiguration)d.nfaConfigurations.get( i );
+                if ( c.resolveWithPredicate )
+                {
+                    configsWithPreds.Add( c );
+                }
+            }
+            // Sort ascending according to alt; alt i has higher precedence than i+1
+            configsWithPreds.Sort( new AddPredicateTransitionsComparer() );
+            //Collections.sort( configsWithPreds, new AddPredicateTransitionsComparer() );
+            IList predConfigsSortedByAlt = configsWithPreds;
+            // Now, we can add edges emanating from d for these preds in right order
+            for ( int i = 0; i < predConfigsSortedByAlt.Count; i++ )
+            {
+                NFAConfiguration c = (NFAConfiguration)predConfigsSortedByAlt[i];
+                DFAState predDFATarget = d.dfa.getAcceptState( c.alt );
+                if ( predDFATarget == null )
+                {
+                    predDFATarget = dfa.newState(); // create if not there.
+                    // create a new DFA state that is a target of the predicate from d
+                    predDFATarget.addNFAConfiguration( dfa.nfa.getState( c.state ),
+                                                      c.alt,
+                                                      c.context,
+                                                      c.semanticContext );
+                    predDFATarget.IsAcceptState = true;
+                    dfa.setAcceptState( c.alt, predDFATarget );
+                    DFAState existingState = dfa.addState( predDFATarget );
+                    if ( predDFATarget != existingState )
+                    {
+                        // already there...use/return the existing DFA state that
+                        // is a target of this predicate.  Make this state number
+                        // point at the existing state
+                        dfa.setState( predDFATarget.stateNumber, existingState );
+                        predDFATarget = existingState;
+                    }
+                }
+                // add a transition to pred target from d
+                d.addTransition( predDFATarget, new PredicateLabel( c.semanticContext ) );
+            }
+        }
+
+        protected virtual void initContextTrees( int numberOfAlts )
+        {
+            contextTrees = new NFAContext[numberOfAlts];
+            for ( int i = 0; i < contextTrees.Length; i++ )
+            {
+                int alt = i + 1;
+                // add a dummy root node so that an NFA configuration can
+                // always point at an NFAContext.  If a context refers to this
+                // node then it implies there is no call stack for
+                // that configuration
+                contextTrees[i] = new NFAContext( null, null );
+            }
+        }
+
+        public static int max( ICollection<int> s )
+        {
+            if ( s == null )
+                return int.MinValue;
+
+            if ( s.Count == 0 )
+                return 0;
+
+            return s.Max();
+        }
+    }
+}
diff --git a/Antlr3/Analysis/NonLLStarDecisionException.cs b/Antlr3/Analysis/NonLLStarDecisionException.cs
new file mode 100644
index 0000000..40ad542
--- /dev/null
+++ b/Antlr3/Analysis/NonLLStarDecisionException.cs
@@ -0,0 +1,48 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Analysis
+{
+    using Exception = System.Exception;
+
+    /** Used to abort DFA construction when we find non-LL(*) decision; i.e.,
+     *  a decision that has recursion in more than a single alt.
+     */
+    public class NonLLStarDecisionException : Exception
+    {
+        public DFA abortedDFA;
+        public NonLLStarDecisionException( DFA abortedDFA )
+        {
+            this.abortedDFA = abortedDFA;
+        }
+    }
+}
diff --git a/Antlr3/Analysis/PredicateLabel.cs b/Antlr3/Analysis/PredicateLabel.cs
new file mode 100644
index 0000000..d5ff2b8
--- /dev/null
+++ b/Antlr3/Analysis/PredicateLabel.cs
@@ -0,0 +1,111 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Analysis
+{
+    using Grammar = Antlr3.Tool.Grammar;
+    using GrammarAST = Antlr3.Tool.GrammarAST;
+
+    public class PredicateLabel : Label
+    {
+        /** A tree of semantic predicates from the grammar AST if label==SEMPRED.
+         *  In the NFA, labels will always be exactly one predicate, but the DFA
+         *  may have to combine a bunch of them as it collects predicates from
+         *  multiple NFA configurations into a single DFA state.
+         */
+        protected SemanticContext semanticContext;
+
+        /** Make a semantic predicate label */
+        public PredicateLabel( GrammarAST predicateASTNode )
+            : base( SEMPRED )
+        {
+            this.semanticContext = new SemanticContext.Predicate( predicateASTNode );
+        }
+
+        /** Make a semantic predicates label */
+        public PredicateLabel( SemanticContext semCtx )
+            : base( SEMPRED )
+        {
+            this.semanticContext = semCtx;
+        }
+
+        public override int GetHashCode()
+        {
+            return semanticContext.GetHashCode();
+        }
+
+        public override bool Equals( object o )
+        {
+            if ( o == null )
+            {
+                return false;
+            }
+            if ( object.ReferenceEquals( this, o ) )
+            {
+                return true; // equals if same object
+            }
+            PredicateLabel pl = o as PredicateLabel;
+            if ( pl == null )
+            {
+                return false;
+            }
+            return semanticContext.Equals( pl.SemanticContext );
+        }
+
+        public override bool IsSemanticPredicate
+        {
+            get
+            {
+                return true;
+            }
+        }
+
+        public override SemanticContext SemanticContext
+        {
+            get
+            {
+                return semanticContext;
+            }
+        }
+
+        public override string ToString()
+        {
+            return "{" + semanticContext + "}?";
+        }
+
+        public override string ToString( Grammar g )
+        {
+            return ToString();
+        }
+    }
+
+}
diff --git a/Antlr3/Analysis/RuleClosureTransition.cs b/Antlr3/Analysis/RuleClosureTransition.cs
new file mode 100644
index 0000000..db31504
--- /dev/null
+++ b/Antlr3/Analysis/RuleClosureTransition.cs
@@ -0,0 +1,61 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Analysis
+{
+    using Rule = Antlr3.Tool.Rule;
+
+    /** A transition used to reference another rule.  It tracks two targets
+     *  really: the actual transition target and the state following the
+     *  state that refers to the other rule.  Conversion of an NFA that
+     *  falls off the end of a rule will be able to figure out who invoked
+     *  that rule because of these special transitions.
+     */
+    public class RuleClosureTransition : Transition
+    {
+        /** Ptr to the rule definition object for this rule ref */
+        public Rule rule;
+
+        /** What node to begin computations following ref to rule */
+        public NFAState followState;
+
+        public RuleClosureTransition( Rule rule,
+                                     NFAState ruleStart,
+                                     NFAState followState )
+            : base( Label.EPSILON, ruleStart )
+        {
+            this.rule = rule;
+            this.followState = followState;
+        }
+    }
+
+}
diff --git a/Antlr3/Analysis/SemanticContext.cs b/Antlr3/Analysis/SemanticContext.cs
new file mode 100644
index 0000000..71a64d1
--- /dev/null
+++ b/Antlr3/Analysis/SemanticContext.cs
@@ -0,0 +1,606 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Analysis
+{
+    using System.Collections.Generic;
+    using Antlr.Runtime.JavaExtensions;
+
+    using ANTLRParser = Antlr3.Grammars.ANTLRParser;
+    using CodeGenerator = Antlr3.Codegen.CodeGenerator;
+    using Grammar = Antlr3.Tool.Grammar;
+    using GrammarAST = Antlr3.Tool.GrammarAST;
+    using StringBuilder = System.Text.StringBuilder;
+    using StringTemplate = Antlr3.ST.StringTemplate;
+    using StringTemplateGroup = Antlr3.ST.StringTemplateGroup;
+
+    /** A binary tree structure used to record the semantic context in which
+     *  an NFA configuration is valid.  It's either a single predicate or
+     *  a tree representing an operation tree such as: p1&&p2 or p1||p2.
+     *
+     *  For NFA o-p1->o-p2->o, create tree AND(p1,p2).
+     *  For NFA (1)-p1->(2)
+     *           |       ^
+     *           |       |
+     *          (3)-p2----
+     *  we will have to combine p1 and p2 into DFA state as we will be
+     *  adding NFA configurations for state 2 with two predicates p1,p2.
+     *  So, set context for combined NFA config for state 2: OR(p1,p2).
+     *
+     *  I have scoped the AND, NOT, OR, and Predicate subclasses of
+     *  SemanticContext within the scope of this outer class.
+     *
+     *  July 7, 2006: TJP altered OR to be set of operands. the Binary tree
+     *  made it really hard to reduce complicated || sequences to their minimum.
+     *  Got huge repeated || conditions.
+     */
+    public abstract class SemanticContext
+    {
+        /** Create a default value for the semantic context shared among all
+         *  NFAConfigurations that do not have an actual semantic context.
+         *  This prevents lots of if!=null type checks all over; it represents
+         *  just an empty set of predicates.
+         */
+        public static readonly SemanticContext EMPTY_SEMANTIC_CONTEXT = new Predicate();
+
+        /** Given a semantic context expression tree, return a tree with all
+         *  nongated predicates set to true and then reduced.  So p&&(q||r) would
+         *  return p&&r if q is nongated but p and r are gated.
+         */
+        public abstract SemanticContext GatedPredicateContext
+        {
+            get;
+        }
+
+        /** Generate an expression that will evaluate the semantic context,
+         *  given a set of output templates.
+         */
+        public abstract StringTemplate genExpr( CodeGenerator generator,
+                                               StringTemplateGroup templates,
+                                               DFA dfa );
+
+        public abstract bool IsSyntacticPredicate
+        {
+            get;
+        }
+
+        /** Notify the indicated grammar of any syn preds used within this context */
+        public virtual void trackUseOfSyntacticPredicates( Grammar g )
+        {
+        }
+
+        public /*static*/ class Predicate : SemanticContext
+        {
+            /** The AST node in tree created from the grammar holding the predicate */
+            public GrammarAST predicateAST;
+
+            /** Is this a {...}?=> gating predicate or a normal disambiguating {..}?
+             *  If any predicate in expression is gated, then expression is considered
+             *  gated.
+             *
+             *  The simple Predicate object's predicate AST's type is used to set
+             *  gated to true if type==GATED_SEMPRED.
+             */
+            protected bool gated = false;
+
+            /** syntactic predicates are converted to semantic predicates
+             *  but synpreds are generated slightly differently.
+             */
+            protected bool synpred = false;
+
+            public const int INVALID_PRED_VALUE = -1;
+            public const int FALSE_PRED = 0;
+            public const int TRUE_PRED = 1;
+
+            /** sometimes predicates are known to be true or false; we need
+             *  a way to represent this without resorting to a target language
+             *  value like true or TRUE.
+             */
+            protected int constantValue = INVALID_PRED_VALUE;
+
+            public Predicate()
+            {
+                predicateAST = new GrammarAST();
+                this.gated = false;
+            }
+
+            public Predicate( GrammarAST predicate )
+            {
+                this.predicateAST = predicate;
+                this.gated =
+                    predicate.Type == ANTLRParser.GATED_SEMPRED ||
+                    predicate.Type == ANTLRParser.SYN_SEMPRED;
+                this.synpred =
+                    predicate.Type == ANTLRParser.SYN_SEMPRED ||
+                    predicate.Type == ANTLRParser.BACKTRACK_SEMPRED;
+            }
+
+            public Predicate( Predicate p )
+            {
+                this.predicateAST = p.predicateAST;
+                this.gated = p.gated;
+                this.synpred = p.synpred;
+                this.constantValue = p.constantValue;
+            }
+
+            /** Two predicates are the same if they are literally the same
+             *  text rather than same node in the grammar's AST.
+             *  Or, if they have the same constant value, return equal.
+             *  As of July 2006 I'm not sure these are needed.
+             */
+            public override bool Equals( object o )
+            {
+                Predicate p = o as Predicate;
+                if ( p == null )
+                {
+                    return false;
+                }
+                return predicateAST.Text.Equals( p.predicateAST.Text );
+            }
+
+            public override int GetHashCode()
+            {
+                if ( predicateAST == null )
+                {
+                    return 0;
+                }
+                return predicateAST.Text.GetHashCode();
+            }
+
+            public override StringTemplate genExpr( CodeGenerator generator,
+                                          StringTemplateGroup templates,
+                                          DFA dfa )
+            {
+                StringTemplate eST = null;
+                if ( templates != null )
+                {
+                    if ( synpred )
+                    {
+                        eST = templates.getInstanceOf( "evalSynPredicate" );
+                    }
+                    else
+                    {
+                        eST = templates.getInstanceOf( "evalPredicate" );
+                        generator.grammar.decisionsWhoseDFAsUsesSemPreds.Add( dfa );
+                    }
+                    string predEnclosingRuleName = predicateAST.enclosingRuleName;
+                    /*
+                    String decisionEnclosingRuleName =
+                        dfa.getNFADecisionStartState().getEnclosingRule();
+                    // if these rulenames are diff, then pred was hoisted out of rule
+                    // Currently I don't warn you about this as it could be annoying.
+                    // I do the translation anyway.
+                    */
+                    //eST.setAttribute("pred", this.toString());
+                    if ( generator != null )
+                    {
+                        eST.setAttribute( "pred",
+                                         generator.translateAction( predEnclosingRuleName, predicateAST ) );
+                    }
+                }
+                else
+                {
+                    eST = new StringTemplate( "$pred$" );
+                    eST.setAttribute( "pred", this.ToString() );
+                    return eST;
+                }
+                if ( generator != null )
+                {
+                    string description =
+                        generator.target.getTargetStringLiteralFromString( this.ToString() );
+                    eST.setAttribute( "description", description );
+                }
+                return eST;
+            }
+
+            public override SemanticContext GatedPredicateContext
+            {
+                get
+                {
+                    if ( gated )
+                    {
+                        return this;
+                    }
+                    return null;
+                }
+            }
+
+            public override bool IsSyntacticPredicate
+            {
+                get
+                {
+                    return predicateAST != null &&
+                        ( predicateAST.Type == ANTLRParser.SYN_SEMPRED ||
+                          predicateAST.Type == ANTLRParser.BACKTRACK_SEMPRED );
+                }
+            }
+
+            public override void trackUseOfSyntacticPredicates( Grammar g )
+            {
+                if ( synpred )
+                {
+                    g.synPredNamesUsedInDFA.Add( predicateAST.Text );
+                }
+            }
+
+            public override string ToString()
+            {
+                if ( predicateAST == null )
+                {
+                    return "<nopred>";
+                }
+                return predicateAST.Text;
+            }
+        }
+
+        public /*static*/ class TruePredicate : Predicate
+        {
+            public TruePredicate()
+            {
+                this.constantValue = TRUE_PRED;
+            }
+
+            public override StringTemplate genExpr( CodeGenerator generator,
+                                          StringTemplateGroup templates,
+                                          DFA dfa )
+            {
+                if ( templates != null )
+                {
+                    return templates.getInstanceOf( "true" );
+                }
+                return new StringTemplate( "true" );
+            }
+
+            public override string ToString()
+            {
+                return "true"; // not used for code gen, just DOT and print outs
+            }
+        }
+
+        /*
+        public static class FalsePredicate extends Predicate {
+            public FalsePredicate() {
+                super();
+                this.constantValue = FALSE_PRED;
+            }
+            public StringTemplate genExpr(CodeGenerator generator,
+                                          StringTemplateGroup templates,
+                                          DFA dfa)
+            {
+                if ( templates!=null ) {
+                    return templates.getInstanceOf("false");
+                }
+                return new StringTemplate("false");
+            }
+            public String toString() {
+                return "false"; // not used for code gen, just DOT and print outs
+            }
+        }
+        */
+
+        public /*static*/ class AND : SemanticContext
+        {
+            protected SemanticContext left, right;
+            public AND( SemanticContext a, SemanticContext b )
+            {
+                this.left = a;
+                this.right = b;
+            }
+            public override StringTemplate genExpr( CodeGenerator generator,
+                                          StringTemplateGroup templates,
+                                          DFA dfa )
+            {
+                StringTemplate eST = null;
+                if ( templates != null )
+                {
+                    eST = templates.getInstanceOf( "andPredicates" );
+                }
+                else
+                {
+                    eST = new StringTemplate( "($left$&&$right$)" );
+                }
+                eST.setAttribute( "left", left.genExpr( generator, templates, dfa ) );
+                eST.setAttribute( "right", right.genExpr( generator, templates, dfa ) );
+                return eST;
+            }
+            public override SemanticContext GatedPredicateContext
+            {
+                get
+                {
+                    SemanticContext gatedLeft = left.GatedPredicateContext;
+                    SemanticContext gatedRight = right.GatedPredicateContext;
+                    if ( gatedLeft == null )
+                    {
+                        return gatedRight;
+                    }
+                    if ( gatedRight == null )
+                    {
+                        return gatedLeft;
+                    }
+                    return new AND( gatedLeft, gatedRight );
+                }
+            }
+            public override bool IsSyntacticPredicate
+            {
+                get
+                {
+                    return left.IsSyntacticPredicate || right.IsSyntacticPredicate;
+                }
+            }
+            public override void trackUseOfSyntacticPredicates( Grammar g )
+            {
+                left.trackUseOfSyntacticPredicates( g );
+                right.trackUseOfSyntacticPredicates( g );
+            }
+            public override string ToString()
+            {
+                return "(" + left + "&&" + right + ")";
+            }
+        }
+
+        public /*static*/ class OR : SemanticContext
+        {
+            protected HashSet<object> operands;
+            public OR( SemanticContext a, SemanticContext b )
+            {
+                operands = new HashSet<object>();
+                if ( a is OR )
+                {
+                    operands.addAll( ( (OR)a ).operands );
+                }
+                else if ( a != null )
+                {
+                    operands.Add( a );
+                }
+                if ( b is OR )
+                {
+                    operands.addAll( ( (OR)b ).operands );
+                }
+                else if ( b != null )
+                {
+                    operands.Add( b );
+                }
+            }
+            public override StringTemplate genExpr( CodeGenerator generator,
+                                          StringTemplateGroup templates,
+                                          DFA dfa )
+            {
+                StringTemplate eST = null;
+                if ( templates != null )
+                {
+                    eST = templates.getInstanceOf( "orPredicates" );
+                }
+                else
+                {
+                    eST = new StringTemplate( "($first(operands)$$rest(operands):{o | ||$o$}$)" );
+                }
+                foreach ( SemanticContext semctx in operands )
+                {
+                    eST.setAttribute( "operands", semctx.genExpr( generator, templates, dfa ) );
+                }
+                return eST;
+            }
+            public override SemanticContext GatedPredicateContext
+            {
+                get
+                {
+                    SemanticContext result = null;
+                    foreach ( SemanticContext semctx in operands )
+                    {
+                        SemanticContext gatedPred = semctx.GatedPredicateContext;
+                        if ( gatedPred != null )
+                        {
+                            result = or( result, gatedPred );
+                            // result = new OR(result, gatedPred);
+                        }
+                    }
+                    return result;
+                }
+            }
+            public override bool IsSyntacticPredicate
+            {
+                get
+                {
+                    foreach ( SemanticContext semctx in operands )
+                    {
+                        if ( semctx.IsSyntacticPredicate )
+                        {
+                            return true;
+                        }
+                    }
+                    return false;
+                }
+            }
+            public override void trackUseOfSyntacticPredicates( Grammar g )
+            {
+                foreach ( SemanticContext semctx in operands )
+                {
+                    semctx.trackUseOfSyntacticPredicates( g );
+                }
+            }
+            public override string ToString()
+            {
+                StringBuilder buf = new StringBuilder();
+                buf.Append( "(" );
+                int i = 0;
+                foreach ( SemanticContext semctx in operands )
+                {
+                    if ( i > 0 )
+                    {
+                        buf.Append( "||" );
+                    }
+                    buf.Append( semctx.ToString() );
+                    i++;
+                }
+                buf.Append( ")" );
+                return buf.ToString();
+            }
+        }
+
+        public /*static*/ class NOT : SemanticContext
+        {
+            protected internal SemanticContext ctx;
+            public NOT( SemanticContext ctx )
+            {
+                this.ctx = ctx;
+            }
+            public override StringTemplate genExpr( CodeGenerator generator,
+                                          StringTemplateGroup templates,
+                                          DFA dfa )
+            {
+                StringTemplate eST = null;
+                if ( templates != null )
+                {
+                    eST = templates.getInstanceOf( "notPredicate" );
+                }
+                else
+                {
+                    eST = new StringTemplate( "?!($pred$)" );
+                }
+                eST.setAttribute( "pred", ctx.genExpr( generator, templates, dfa ) );
+                return eST;
+            }
+            public override SemanticContext GatedPredicateContext
+            {
+                get
+                {
+                    SemanticContext p = ctx.GatedPredicateContext;
+                    if ( p == null )
+                    {
+                        return null;
+                    }
+                    return new NOT( p );
+                }
+            }
+            public override bool IsSyntacticPredicate
+            {
+                get
+                {
+                    return ctx.IsSyntacticPredicate;
+                }
+            }
+            public override void trackUseOfSyntacticPredicates( Grammar g )
+            {
+                ctx.trackUseOfSyntacticPredicates( g );
+            }
+
+            public override bool Equals( object @object )
+            {
+                if ( !( @object is NOT ) )
+                {
+                    return false;
+                }
+                return this.ctx.Equals( ( (NOT)@object ).ctx );
+            }
+
+            public override int GetHashCode()
+            {
+                return ctx.GetHashCode();
+            }
+
+            public override string ToString()
+            {
+                return "!(" + ctx + ")";
+            }
+        }
+
+        public static SemanticContext and( SemanticContext a, SemanticContext b )
+        {
+            //JSystem.@out.println("AND: "+a+"&&"+b);
+            if ( a == EMPTY_SEMANTIC_CONTEXT || a == null )
+            {
+                return b;
+            }
+            if ( b == EMPTY_SEMANTIC_CONTEXT || b == null )
+            {
+                return a;
+            }
+            if ( a.Equals( b ) )
+            {
+                return a; // if same, just return left one
+            }
+            //JSystem.@out.println("## have to AND");
+            return new AND( a, b );
+        }
+
+        public static SemanticContext or( SemanticContext a, SemanticContext b )
+        {
+            //JSystem.@out.println("OR: "+a+"||"+b);
+            if ( a == EMPTY_SEMANTIC_CONTEXT || a == null )
+            {
+                return b;
+            }
+            if ( b == EMPTY_SEMANTIC_CONTEXT || b == null )
+            {
+                return a;
+            }
+            if ( a is TruePredicate )
+            {
+                return a;
+            }
+            if ( b is TruePredicate )
+            {
+                return b;
+            }
+            if ( a is NOT && b is Predicate )
+            {
+                NOT n = (NOT)a;
+                // check for !p||p
+                if ( n.ctx.Equals( b ) )
+                {
+                    return new TruePredicate();
+                }
+            }
+            else if ( b is NOT && a is Predicate )
+            {
+                NOT n = (NOT)b;
+                // check for p||!p
+                if ( n.ctx.Equals( a ) )
+                {
+                    return new TruePredicate();
+                }
+            }
+            else if ( a.Equals( b ) )
+            {
+                return a;
+            }
+            //JSystem.@out.println("## have to OR");
+            return new OR( a, b );
+        }
+
+        public static SemanticContext not( SemanticContext a )
+        {
+            return new NOT( a );
+        }
+
+    }
+}
diff --git a/Antlr3/Analysis/State.cs b/Antlr3/Analysis/State.cs
new file mode 100644
index 0000000..e248cd9
--- /dev/null
+++ b/Antlr3/Analysis/State.cs
@@ -0,0 +1,69 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Analysis
+{
+    /** A generic state machine state. */
+    public abstract class State
+    {
+        public const int INVALID_STATE_NUMBER = -1;
+
+        public int stateNumber = INVALID_STATE_NUMBER;
+
+        /** An accept state is an end of rule state for lexers and
+         *  parser grammar rules.
+         */
+        protected internal bool acceptState = false;
+
+        #region Properties
+        public virtual bool IsAcceptState
+        {
+            get
+            {
+                return acceptState;
+            }
+            set
+            {
+                acceptState = value;
+            }
+        }
+        public abstract int NumberOfTransitions
+        {
+            get;
+        }
+        #endregion
+
+        public abstract void addTransition( Transition e );
+
+        public abstract Transition getTransition( int i );
+    }
+}
diff --git a/Antlr3/Analysis/StateCluster.cs b/Antlr3/Analysis/StateCluster.cs
new file mode 100644
index 0000000..bf5d723
--- /dev/null
+++ b/Antlr3/Analysis/StateCluster.cs
@@ -0,0 +1,51 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Analysis
+{
+
+    /** A Cluster object points to the left/right (start and end) states of a
+     *  state machine.  Used to build NFAs.
+     */
+    public class StateCluster
+    {
+        public NFAState left;
+        public NFAState right;
+
+        public StateCluster( NFAState left, NFAState right )
+        {
+            this.left = left;
+            this.right = right;
+        }
+    }
+
+}
diff --git a/Antlr3/Analysis/Transition.cs b/Antlr3/Analysis/Transition.cs
new file mode 100644
index 0000000..cfb13ed
--- /dev/null
+++ b/Antlr3/Analysis/Transition.cs
@@ -0,0 +1,126 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Analysis
+{
+    using System;
+
+    /** A generic transition between any two state machine states.  It defines
+     *  some special labels that indicate things like epsilon transitions and
+     *  that the label is actually a set of labels or a semantic predicate.
+     *  This is a one way link.  It emanates from a state (usually via a list of
+     *  transitions) and has a label/target pair.  I have abstracted the notion
+     *  of a Label to handle the various kinds of things it can be.
+     */
+    public class Transition : IComparable
+    {
+        /** What label must be consumed to transition to target */
+        public Label label;
+
+        /** The target of this transition */
+        public State target;
+
+        public Transition( Label label, State target )
+        {
+            this.label = label;
+            this.target = target;
+        }
+
+        public Transition( int label, State target )
+        {
+            this.label = new Label( label );
+            this.target = target;
+        }
+
+        #region Properties
+        public Label Label
+        {
+            get
+            {
+                return label;
+            }
+        }
+        public State Target
+        {
+            get
+            {
+                return target;
+            }
+        }
+
+        public bool IsAction
+        {
+            get
+            {
+                return label.IsAction;
+            }
+        }
+        public bool IsEpsilon
+        {
+            get
+            {
+                return label.IsEpsilon;
+            }
+        }
+        public bool IsSemanticPredicate
+        {
+            get
+            {
+                return label.IsSemanticPredicate;
+            }
+        }
+        #endregion
+
+        public override int GetHashCode()
+        {
+            return label.GetHashCode() + target.stateNumber;
+        }
+
+        public override bool Equals( object o )
+        {
+            Transition other = (Transition)o;
+            return this.label.Equals( other.label ) &&
+                   this.target.Equals( other.target );
+        }
+
+        public virtual int CompareTo( object o )
+        {
+            Transition other = (Transition)o;
+            return this.label.CompareTo( other.label );
+        }
+
+        public override string ToString()
+        {
+            return label + "->" + target.stateNumber;
+        }
+    }
+}
diff --git a/Antlr3/Antlr3.csproj b/Antlr3/Antlr3.csproj
new file mode 100644
index 0000000..2a6385b
--- /dev/null
+++ b/Antlr3/Antlr3.csproj
@@ -0,0 +1,591 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{2AB8CAED-C046-4F05-8B18-6948100D2FE7}</ProjectGuid>
+    <OutputType>Exe</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>Antlr3</RootNamespace>
+    <AssemblyName>Antlr3</AssemblyName>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <SccProjectName>Perforce Project</SccProjectName>
+    <SccLocalPath>..\..\..</SccLocalPath>
+    <SccAuxPath>
+    </SccAuxPath>
+    <SccProvider>MSSCCI:Perforce SCM</SccProvider>
+    <StartupObject>
+    </StartupObject>
+    <SignAssembly>true</SignAssembly>
+    <AssemblyOriginatorKeyFile>Key.snk</AssemblyOriginatorKeyFile>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\bin\Debug\</OutputPath>
+    <DefineConstants>TRACE;DEBUG</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\bin\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="vjslib" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="Analysis\ActionLabel.cs" />
+    <Compile Include="Analysis\AnalysisRecursionOverflowException.cs" />
+    <Compile Include="Analysis\AnalysisTimeoutException.cs" />
+    <Compile Include="Analysis\DecisionProbe.cs" />
+    <Compile Include="Analysis\DFA.cs" />
+    <Compile Include="Analysis\DFAOptimizer.cs" />
+    <Compile Include="Analysis\DFAState.cs" />
+    <Compile Include="Analysis\Label.cs" />
+    <Compile Include="Analysis\LL1Analyzer.cs" />
+    <Compile Include="Analysis\LL1DFA.cs" />
+    <Compile Include="Analysis\LookaheadSet.cs" />
+    <Compile Include="Analysis\NFA.cs" />
+    <Compile Include="Analysis\NFAConfiguration.cs" />
+    <Compile Include="Analysis\NFAContext.cs" />
+    <Compile Include="Analysis\NFAConversionThread.cs" />
+    <Compile Include="Analysis\NFAState.cs" />
+    <Compile Include="Analysis\NFAtoDFAConverter.cs" />
+    <Compile Include="Analysis\NonLLStarDecisionException.cs" />
+    <Compile Include="Analysis\PredicateLabel.cs" />
+    <Compile Include="Analysis\RuleClosureTransition.cs" />
+    <Compile Include="Analysis\SemanticContext.cs" />
+    <Compile Include="Analysis\State.cs" />
+    <Compile Include="Analysis\StateCluster.cs" />
+    <Compile Include="Analysis\Transition.cs" />
+    <Compile Include="Codegen\CodeGenerator.cs" />
+    <Compile Include="Codegen\Target.cs" />
+    <Compile Include="Misc\Barrier.cs" />
+    <Compile Include="Misc\BitSet.cs" />
+    <Compile Include="Misc\IntArrayList.cs" />
+    <Compile Include="Misc\Interval.cs" />
+    <Compile Include="Misc\IntervalSet.cs" />
+    <Compile Include="Misc\IntSet.cs" />
+    <Compile Include="Misc\MultiMap.cs" />
+    <Compile Include="Misc\OrderedHashSet.cs" />
+    <Compile Include="Misc\Utils.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+    <Compile Include="AntlrTool.cs" />
+    <Compile Include="Tool\ANTLRErrorListener.cs" />
+    <Compile Include="Tool\ErrorManager.cs" />
+    <Compile Include="Tool\Grammar.cs" />
+    <Compile Include="Tool\GrammarAST.cs" />
+    <Compile Include="Tool\Message.cs" />
+    <Compile Include="Tool\Rule.cs" />
+    <Compile Include="Tool\ToolMessage.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <Antlr3 Include="Grammars\ActionTranslator.g3">
+      <OutputFiles>Grammars\ActionTranslator.cs;Grammars\ActionTranslator.tokens</OutputFiles>
+    </Antlr3>
+    <Compile Include="Codegen\ACyclicDFACodeGenerator.cs" />
+    <Compile Include="Tool\Attribute.cs" />
+    <Compile Include="Tool\AttributeScope.cs" />
+    <Compile Include="Tool\CompositeGrammar.cs" />
+    <Compile Include="Tool\CompositeGrammarTree.cs" />
+    <Compile Include="Tool\GrammarSanity.cs" />
+    <Compile Include="Tool\NameSpaceChecker.cs" />
+    <Compile Include="Tool\NFAFactory.cs" />
+    <Compile Include="Grammars\ActionTranslator.cs">
+      <AutoGen>True</AutoGen>
+      <DesignTime>True</DesignTime>
+      <DependentUpon>ActionTranslator.g3</DependentUpon>
+    </Compile>
+    <Compile Include="Grammars\ActionTranslatorHelper.cs">
+      <DependentUpon>ActionTranslator.g3</DependentUpon>
+    </Compile>
+    <Antlr3 Include="Grammars\CodeGenTreeWalker.g3">
+      <OutputFiles>Grammars\CodeGenTreeWalker.cs;Grammars\CodeGenTreeWalker.tokens</OutputFiles>
+    </Antlr3>
+    <Compile Include="Grammars\CodeGenTreeWalker.cs">
+      <AutoGen>True</AutoGen>
+      <DesignTime>True</DesignTime>
+      <DependentUpon>CodeGenTreeWalker.g3</DependentUpon>
+    </Compile>
+    <Compile Include="Grammars\CodeGenTreeWalkerHelper.cs">
+      <DependentUpon>CodeGenTreeWalker.g3</DependentUpon>
+    </Compile>
+  </ItemGroup>
+  <ItemGroup>
+    <Antlr3 Include="Grammars\ActionAnalysisLexer.g3">
+      <OutputFiles>Grammars\ActionAnalysisLexer.cs;Grammars\ActionAnalysisLexer.tokens</OutputFiles>
+    </Antlr3>
+    <Compile Include="Grammars\ActionAnalysisLexer.cs">
+      <AutoGen>True</AutoGen>
+      <DesignTime>True</DesignTime>
+      <DependentUpon>ActionAnalysisLexer.g3</DependentUpon>
+    </Compile>
+    <Compile Include="Grammars\ActionAnalysisLexerHelper.cs">
+      <DependentUpon>ActionAnalysisLexer.g3</DependentUpon>
+    </Compile>
+  </ItemGroup>
+  <ItemGroup>
+    <Antlr3 Include="Grammars\ANTLR.g3">
+      <OutputFiles>Grammars\ANTLRParser.cs;Grammars\ANTLRLexer.cs;Grammars\ANTLR.tokens</OutputFiles>
+      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
+    </Antlr3>
+    <Compile Include="Grammars\ANTLRParser.cs">
+      <AutoGen>True</AutoGen>
+      <DesignTime>True</DesignTime>
+      <DependentUpon>ANTLR.g3</DependentUpon>
+    </Compile>
+    <Compile Include="Grammars\ANTLRParserHelper.cs">
+      <DependentUpon>ANTLR.g3</DependentUpon>
+    </Compile>
+    <Compile Include="Grammars\ANTLRLexer.cs">
+      <AutoGen>True</AutoGen>
+      <DesignTime>True</DesignTime>
+      <DependentUpon>ANTLR.g3</DependentUpon>
+    </Compile>
+    <Compile Include="Grammars\ANTLRLexerHelper.cs">
+      <DependentUpon>ANTLR.g3</DependentUpon>
+    </Compile>
+  </ItemGroup>
+  <ItemGroup>
+    <Antlr3 Include="Grammars\ANTLRTreePrinter.g3">
+      <OutputFiles>Grammars\ANTLRTreePrinter.cs;Grammars\ANTLRTreePrinter.tokens</OutputFiles>
+    </Antlr3>
+    <Compile Include="Grammars\ANTLRTreePrinter.cs">
+      <AutoGen>True</AutoGen>
+      <DesignTime>True</DesignTime>
+      <DependentUpon>ANTLRTreePrinter.g3</DependentUpon>
+    </Compile>
+    <Compile Include="Grammars\ANTLRTreePrinterHelper.cs">
+      <DependentUpon>ANTLRTreePrinter.g3</DependentUpon>
+    </Compile>
+  </ItemGroup>
+  <ItemGroup>
+    <Antlr3 Include="Grammars\AssignTokenTypesWalker.g3">
+      <OutputFiles>Grammars\AssignTokenTypesWalker.cs;Grammars\AssignTokenTypesWalker.tokens</OutputFiles>
+    </Antlr3>
+    <Compile Include="Grammars\AssignTokenTypesWalker.cs">
+      <AutoGen>True</AutoGen>
+      <DesignTime>True</DesignTime>
+      <DependentUpon>AssignTokenTypesWalker.g3</DependentUpon>
+    </Compile>
+    <Compile Include="Grammars\AssignTokenTypesWalkerHelper.cs">
+      <DependentUpon>AssignTokenTypesWalker.g3</DependentUpon>
+    </Compile>
+  </ItemGroup>
+  <ItemGroup>
+    <Antlr3 Include="Grammars\DefineGrammarItemsWalker.g3">
+      <OutputFiles>Grammars\DefineGrammarItemsWalker.cs;Grammars\DefineGrammarItemsWalker.tokens</OutputFiles>
+    </Antlr3>
+    <Compile Include="Grammars\DefineGrammarItemsWalker.cs">
+      <AutoGen>True</AutoGen>
+      <DesignTime>True</DesignTime>
+      <DependentUpon>DefineGrammarItemsWalker.g3</DependentUpon>
+    </Compile>
+    <Compile Include="Grammars\DefineGrammarItemsWalkerHelper.cs">
+      <DependentUpon>DefineGrammarItemsWalker.g3</DependentUpon>
+    </Compile>
+  </ItemGroup>
+  <ItemGroup>
+    <Antlr3 Include="Grammars\TreeToNFAConverter.g3">
+      <OutputFiles>Grammars\TreeToNFAConverter.cs;Grammars\TreeToNFAConverter.tokens</OutputFiles>
+    </Antlr3>
+    <Compile Include="Extensions\EnumerableExtensions.cs" />
+    <Compile Include="Extensions\FuncEqualityComparer.cs" />
+    <Compile Include="Extensions\ListExtensions.cs" />
+    <Compile Include="Tool\AssignTokenTypesBehavior.cs" />
+    <Compile Include="Tool\BuildDependencyGenerator.cs" />
+    <Compile Include="Tool\DOTGenerator.cs" />
+    <Compile Include="Tool\FASerializer.cs" />
+    <Compile Include="Tool\GrammarAnalysisAbortedMessage.cs" />
+    <Compile Include="Tool\GrammarDanglingStateMessage.cs" />
+    <Compile Include="Tool\GrammarInsufficientPredicatesMessage.cs" />
+    <Compile Include="Tool\GrammarNonDeterminismMessage.cs" />
+    <Compile Include="Tool\GrammarReport.cs" />
+    <Compile Include="Tool\GrammarSemanticsMessage.cs" />
+    <Compile Include="Tool\GrammarSyntaxMessage.cs" />
+    <Compile Include="Tool\GrammarUnreachableAltsMessage.cs" />
+    <Compile Include="Tool\Interpreter.cs" />
+    <Compile Include="Tool\LeftRecursionCyclesMessage.cs" />
+    <Compile Include="Tool\NonRegularDecisionMessage.cs" />
+    <Compile Include="Tool\RecursionOverflowMessage.cs" />
+    <Compile Include="Tool\RuleLabelScope.cs" />
+    <Compile Include="Grammars\TreeToNFAConverter.cs">
+      <AutoGen>True</AutoGen>
+      <DesignTime>True</DesignTime>
+      <DependentUpon>TreeToNFAConverter.g3</DependentUpon>
+    </Compile>
+    <Compile Include="Grammars\TreeToNFAConverterHelper.cs">
+      <DependentUpon>TreeToNFAConverter.g3</DependentUpon>
+    </Compile>
+  </ItemGroup>
+  <ItemGroup>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\ActionScript\ActionScript.stg">
+      <Link>Codegen\Templates\ActionScript\ActionScript.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\ActionScript\AST.stg">
+      <Link>Codegen\Templates\ActionScript\AST.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\ActionScript\ASTParser.stg">
+      <Link>Codegen\Templates\ActionScript\ASTParser.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\ActionScript\ASTTreeParser.stg">
+      <Link>Codegen\Templates\ActionScript\ASTTreeParser.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <EmbeddedResource Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\ANTLRCore.sti">
+      <Link>Codegen\Templates\ANTLRCore.sti</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </EmbeddedResource>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\CSharp3\AST.stg">
+      <Link>Codegen\Templates\CSharp3\AST.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\CSharp3\ASTDbg.stg">
+      <Link>Codegen\Templates\CSharp3\ASTDbg.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\CSharp3\ASTParser.stg">
+      <Link>Codegen\Templates\CSharp3\ASTParser.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\CSharp3\ASTTreeParser.stg">
+      <Link>Codegen\Templates\CSharp3\ASTTreeParser.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\CSharp3\CSharp3.stg">
+      <Link>Codegen\Templates\CSharp3\CSharp3.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\CSharp3\Dbg.stg">
+      <Link>Codegen\Templates\CSharp3\Dbg.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\CSharp3\ST.stg">
+      <Link>Codegen\Templates\CSharp3\ST.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\CSharp2\AST.stg">
+      <Link>Codegen\Templates\CSharp2\AST.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\CSharp2\ASTDbg.stg">
+      <Link>Codegen\Templates\CSharp2\ASTDbg.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\CSharp2\ASTParser.stg">
+      <Link>Codegen\Templates\CSharp2\ASTParser.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\CSharp2\ASTTreeParser.stg">
+      <Link>Codegen\Templates\CSharp2\ASTTreeParser.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\CSharp2\CSharp2.stg">
+      <Link>Codegen\Templates\CSharp2\CSharp2.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\CSharp2\Dbg.stg">
+      <Link>Codegen\Templates\CSharp2\Dbg.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\CSharp2\ST.stg">
+      <Link>Codegen\Templates\CSharp2\ST.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\CSharp\AST.stg">
+      <Link>Codegen\Templates\CSharp\AST.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\CSharp\ASTDbg.stg">
+      <Link>Codegen\Templates\CSharp\ASTDbg.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\CSharp\ASTParser.stg">
+      <Link>Codegen\Templates\CSharp\ASTParser.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\CSharp\ASTTreeParser.stg">
+      <Link>Codegen\Templates\CSharp\ASTTreeParser.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\CSharp\CSharp.stg">
+      <Link>Codegen\Templates\CSharp\CSharp.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\CSharp\Dbg.stg">
+      <Link>Codegen\Templates\CSharp\Dbg.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\CSharp\ST.stg">
+      <Link>Codegen\Templates\CSharp\ST.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\C\AST.stg">
+      <Link>Codegen\Templates\C\AST.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\C\ASTDbg.stg">
+      <Link>Codegen\Templates\C\ASTDbg.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\C\ASTParser.stg">
+      <Link>Codegen\Templates\C\ASTParser.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\C\ASTTreeParser.stg">
+      <Link>Codegen\Templates\C\ASTTreeParser.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\C\C.stg">
+      <Link>Codegen\Templates\C\C.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\C\Dbg.stg">
+      <Link>Codegen\Templates\C\Dbg.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\CPP\CPP.stg">
+      <Link>Codegen\Templates\CPP\CPP.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\Delphi\AST.stg">
+      <Link>Codegen\Templates\Delphi\AST.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\Delphi\ASTParser.stg">
+      <Link>Codegen\Templates\Delphi\ASTParser.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\Delphi\ASTTreeParser.stg">
+      <Link>Codegen\Templates\Delphi\ASTTreeParser.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\Delphi\Delphi.stg">
+      <Link>Codegen\Templates\Delphi\Delphi.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\JavaScript\AST.stg">
+      <Link>Codegen\Templates\JavaScript\AST.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\JavaScript\ASTParser.stg">
+      <Link>Codegen\Templates\JavaScript\ASTParser.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\JavaScript\ASTTreeParser.stg">
+      <Link>Codegen\Templates\JavaScript\ASTTreeParser.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\JavaScript\JavaScript.stg">
+      <Link>Codegen\Templates\JavaScript\JavaScript.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\Java\AST.stg">
+      <Link>Codegen\Templates\Java\AST.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\Java\ASTDbg.stg">
+      <Link>Codegen\Templates\Java\ASTDbg.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\Java\ASTParser.stg">
+      <Link>Codegen\Templates\Java\ASTParser.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\Java\ASTTreeParser.stg">
+      <Link>Codegen\Templates\Java\ASTTreeParser.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\Java\Dbg.stg">
+      <Link>Codegen\Templates\Java\Dbg.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\Java\Java.stg">
+      <Link>Codegen\Templates\Java\Java.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\Java\ST.stg">
+      <Link>Codegen\Templates\Java\ST.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\ObjC\AST.stg">
+      <Link>Codegen\Templates\ObjC\AST.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\ObjC\ASTDbg.stg">
+      <Link>Codegen\Templates\ObjC\ASTDbg.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\ObjC\ASTParser.stg">
+      <Link>Codegen\Templates\ObjC\ASTParser.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\ObjC\ASTTreeParser.stg">
+      <Link>Codegen\Templates\ObjC\ASTTreeParser.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\ObjC\Dbg.stg">
+      <Link>Codegen\Templates\ObjC\Dbg.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\ObjC\ObjC.stg">
+      <Link>Codegen\Templates\ObjC\ObjC.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\Perl5\ASTTreeParser.stg">
+      <Link>Codegen\Templates\Perl5\ASTTreeParser.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\Perl5\Perl5.stg">
+      <Link>Codegen\Templates\Perl5\Perl5.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\Python\AST.stg">
+      <Link>Codegen\Templates\Python\AST.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\Python\ASTDbg.stg">
+      <Link>Codegen\Templates\Python\ASTDbg.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\Python\ASTParser.stg">
+      <Link>Codegen\Templates\Python\ASTParser.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\Python\ASTTreeParser.stg">
+      <Link>Codegen\Templates\Python\ASTTreeParser.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\Python\Dbg.stg">
+      <Link>Codegen\Templates\Python\Dbg.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\Python\Python.stg">
+      <Link>Codegen\Templates\Python\Python.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\Python\ST.stg">
+      <Link>Codegen\Templates\Python\ST.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\codegen\templates\Ruby\Ruby.stg">
+      <Link>Codegen\Templates\Ruby\Ruby.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+  </ItemGroup>
+  <ItemGroup>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\tool\templates\depend.stg">
+      <Link>Tool\Templates\depend.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <EmbeddedResource Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\tool\templates\messages\formats\antlr.stg">
+      <Link>Tool\Templates\messages\formats\antlr.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </EmbeddedResource>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\tool\templates\messages\formats\gnu.stg">
+      <Link>Tool\Templates\messages\formats\gnu.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\tool\templates\messages\formats\vs2005.stg">
+      <Link>Tool\Templates\messages\formats\vs2005.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <EmbeddedResource Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\tool\templates\messages\languages\en.stg">
+      <Link>Tool\Templates\messages\languages\en.stg</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </EmbeddedResource>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\tool\templates\dot\action-edge.st">
+      <Link>Tool\Templates\dot\action-edge.st</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\tool\templates\dot\decision-rank.st">
+      <Link>Tool\Templates\dot\decision-rank.st</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\tool\templates\dot\dfa.st">
+      <Link>Tool\Templates\dot\dfa.st</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\tool\templates\dot\edge.st">
+      <Link>Tool\Templates\dot\edge.st</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\tool\templates\dot\epsilon-edge.st">
+      <Link>Tool\Templates\dot\epsilon-edge.st</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\tool\templates\dot\nfa.st">
+      <Link>Tool\Templates\dot\nfa.st</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\tool\templates\dot\state.st">
+      <Link>Tool\Templates\dot\state.st</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="..\..\..\antlr\main\tool\src\main\resources\org\antlr\tool\templates\dot\stopstate.st">
+      <Link>Tool\Templates\dot\stopstate.st</Link>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <None Include="Key.snk" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\..\antlr\main\runtime\CSharp3\Sources\Antlr3.Runtime.Debug\Antlr3.Runtime.Debug.csproj">
+      <Project>{5EE27A90-B023-42C9-AAF1-52B0424C5D0B}</Project>
+      <Name>Antlr3.Runtime.Debug</Name>
+    </ProjectReference>
+    <ProjectReference Include="..\..\..\antlr\main\runtime\CSharp3\Sources\Antlr3.Runtime\Antlr3.Runtime.csproj">
+      <Project>{8FDC0A87-9005-4D5A-AB75-E55CEB575559}</Project>
+      <Name>Antlr3.Runtime</Name>
+    </ProjectReference>
+    <ProjectReference Include="..\Antlr3.StringTemplate\Antlr3.StringTemplate.csproj">
+      <Project>{B5910BE2-DE21-4AA9-95C1-486F42B9E794}</Project>
+      <Name>Antlr3.StringTemplate</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <PropertyGroup>
+    <UseHostCompilerIfAvailable>False</UseHostCompilerIfAvailable>
+  </PropertyGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <PropertyGroup>
+    <Antlr3ToolPath>$(MSBuildProjectDirectory)\..\bin\Bootstrap</Antlr3ToolPath>
+    <CoreCompileDependsOn>$(CoreCompileDependsOn);GenerateAntlrCode</CoreCompileDependsOn>
+    <CoreCleanDependsOn>$(CoreCleanDependsOn);CleanAntlrCode</CoreCleanDependsOn>
+    <PostBuildEvent>
+    </PostBuildEvent>
+  </PropertyGroup>
+  <Target Name="GenerateAntlrCode" Inputs="@(Antlr3)" Outputs="%(OutputFiles)">
+    <Message Importance="normal" Text="Antlr: Transforming '@(Antlr3)' to '%(Antlr3.OutputFiles)'" />
+    <!--<Exec Command="java -cp %22$(Antlr3ToolPath)\antlr3.jar;$(Antlr3ToolPath)\antlr-2.7.7.jar;$(Antlr3ToolPath)\stringtemplate-3.1b1.jar%22 org.antlr.Tool -lib %22%(RootDir)%(Directory).%22 -message-format vs2005 @(Antlr3)" Outputs="%(OutputFiles)" />-->
+    <Exec Command="%22$(Antlr3ToolPath)\Antlr3.exe%22 -Xconversiontimeout 60000 -lib %22%(RootDir)%(Directory).%22 -message-format vs2005 @(Antlr3)" Outputs="%(OutputFiles)" />
+  </Target>
+  <Target Name="CleanAntlrCode">
+    <ItemGroup>
+      <_CleanAntlrFileWrites Include="@(Antlr3->'%(RelativeDir)%(Filename).tokens')" />
+    </ItemGroup>
+    <Message Importance="normal" Text="Antlr: Deleting output files '@(_CleanAntlrFileWrites)'" />
+    <!--<Delete Files="@(_CleanAntlrFileWrites)" />-->
+  </Target>
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
\ No newline at end of file
diff --git a/Antlr3/Antlr3.csproj.vspscc b/Antlr3/Antlr3.csproj.vspscc
new file mode 100644
index 0000000..b6d3289
--- /dev/null
+++ b/Antlr3/Antlr3.csproj.vspscc
@@ -0,0 +1,10 @@
+﻿""
+{
+"FILE_VERSION" = "9237"
+"ENLISTMENT_CHOICE" = "NEVER"
+"PROJECT_FILE_RELATIVE_PATH" = ""
+"NUMBER_OF_EXCLUDED_FILES" = "0"
+"ORIGINAL_PROJECT_FILE_PATH" = ""
+"NUMBER_OF_NESTED_PROJECTS" = "0"
+"SOURCE_CONTROL_SETTINGS_PROVIDER" = "PROVIDER"
+}
diff --git a/Antlr3/AntlrTool.cs b/Antlr3/AntlrTool.cs
new file mode 100644
index 0000000..fefd32d
--- /dev/null
+++ b/Antlr3/AntlrTool.cs
@@ -0,0 +1,805 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3
+{
+    using System;
+    using System.Collections.Generic;
+    using Antlr.Runtime.JavaExtensions;
+    using Antlr3.Analysis;
+    using Antlr3.Codegen;
+    using Antlr3.Tool;
+
+    using FileInfo = System.IO.FileInfo;
+    using IList = System.Collections.IList;
+    using IOException = System.IO.IOException;
+    using Stats = Antlr.Runtime.Misc.Stats;
+    using StringReader = System.IO.StringReader;
+    using StringWriter = System.IO.StringWriter;
+    using TextWriter = System.IO.TextWriter;
+
+    public class AntlrTool
+    {
+        public const string VERSION = "3.1.2";
+        public const string UNINITIALIZED_DIR = "<unset-dir>";
+
+        // Input parameters / option
+
+        protected List<string> grammarFileNames = new List<string>();
+        protected bool generate_NFA_dot = false;
+        protected bool generate_DFA_dot = false;
+        protected string outputDirectory = UNINITIALIZED_DIR;
+        protected string libDirectory = ".";
+        protected bool debug = false;
+        protected bool trace = false;
+        protected bool profile = false;
+        protected bool report = false;
+        protected bool printGrammar = false;
+        protected bool depend = false;
+        protected bool forceAllFilesToOutputDir = false;
+        protected bool deleteTempLexer = true;
+        protected bool verbose = false;
+
+        // the internal options are for my use on the command line during dev
+
+        public static bool internalOption_PrintGrammarTree = false;
+        public static bool internalOption_PrintDFA = false;
+        public static bool internalOption_ShowNFAConfigsInDFA = false;
+        public static bool internalOption_watchNFAConversion = false;
+
+        public static void Main( string[] args )
+        {
+            AntlrTool antlr = new AntlrTool( args );
+            if ( antlr.verbose )
+                ErrorManager.info( "ANTLR Parser Generator  Version " + VERSION );
+            antlr.process();
+            Environment.ExitCode = ( ErrorManager.getNumErrors() > 0 ) ? 1 : 0;
+        }
+
+        public AntlrTool()
+        {
+        }
+
+        public AntlrTool( string[] args )
+        {
+            processArgs( args );
+        }
+
+        public virtual void processArgs( string[] args )
+        {
+            if ( args == null || args.Length == 0 )
+            {
+                help();
+                return;
+            }
+
+            for ( int i = 0; i < args.Length; i++ )
+            {
+                if ( args[i] == "-o" || args[i] == "-fo" )
+                {
+                    if ( i + 1 >= args.Length )
+                    {
+                        Console.Error.WriteLine( "missing output directory with -fo/-o option; ignoring" );
+                    }
+                    else
+                    {
+                        if ( args[i] == "-fo" )
+                            forceAllFilesToOutputDir = true;
+                        i++;
+                        outputDirectory = args[i];
+                        if ( outputDirectory.EndsWith( "/" ) || outputDirectory.EndsWith( "\\" ) )
+                            outputDirectory = outputDirectory.Substring( 0, outputDirectory.Length - 1 );
+                        if ( System.IO.File.Exists( outputDirectory ) )
+                        {
+                            ErrorManager.error( ErrorManager.MSG_OUTPUT_DIR_IS_FILE, outputDirectory );
+                            libDirectory = ".";
+                        }
+                    }
+                }
+                else if ( args[i] == "-lib" )
+                {
+                    if ( i + 1 >= args.Length )
+                    {
+                        Console.Error.WriteLine( "missing library directory with -lib option; ignoring" );
+                    }
+                    else
+                    {
+                        i++;
+                        libDirectory = args[i];
+                        if ( libDirectory.EndsWith( "/" ) ||
+                             libDirectory.EndsWith( "\\" ) )
+                        {
+                            libDirectory =
+                                libDirectory.Substring( 0, libDirectory.Length - 1 );
+                        }
+                        //File outDir = new File( libDirectory );
+                        if ( !System.IO.Directory.Exists( libDirectory ) )
+                        {
+                            ErrorManager.error( ErrorManager.MSG_DIR_NOT_FOUND, libDirectory );
+                            libDirectory = ".";
+                        }
+                    }
+                }
+                else if ( args[i] == "-nfa" )
+                {
+                    generate_NFA_dot = true;
+                }
+                else if ( args[i] == "-dfa" )
+                {
+                    generate_DFA_dot = true;
+                }
+                else if ( args[i] == "-debug" )
+                {
+                    debug = true;
+                }
+                else if ( args[i] == "-trace" )
+                {
+                    trace = true;
+                }
+                else if ( args[i] == "-report" )
+                {
+                    report = true;
+                }
+                else if ( args[i] == "-profile" )
+                {
+                    profile = true;
+                }
+                else if ( args[i] == "-print" )
+                {
+                    printGrammar = true;
+                }
+                else if ( args[i] == "-depend" )
+                {
+                    depend = true;
+                }
+                else if ( args[i] == "-verbose" )
+                {
+                    verbose = true;
+                }
+                else if ( args[i] == "-message-format" )
+                {
+                    if ( i + 1 >= args.Length )
+                    {
+                        Console.Error.WriteLine( "missing output format with -message-format option; using default" );
+                    }
+                    else
+                    {
+                        i++;
+                        ErrorManager.setFormat( args[i] );
+                    }
+                }
+                else if ( args[i] == "-Xgrtree" )
+                {
+                    internalOption_PrintGrammarTree = true;
+                }
+                else if ( args[i] == "-Xdfa" )
+                {
+                    internalOption_PrintDFA = true;
+                }
+                else if ( args[i] == "-Xnoprune" )
+                {
+                    DFAOptimizer.PRUNE_EBNF_EXIT_BRANCHES = false;
+                }
+                else if ( args[i] == "-Xnocollapse" )
+                {
+                    DFAOptimizer.COLLAPSE_ALL_PARALLEL_EDGES = false;
+                }
+                else if ( args[i] == "-Xdbgconversion" )
+                {
+                    NFAToDFAConverter.debug = true;
+                }
+                else if ( args[i] == "-Xmultithreaded" )
+                {
+                    NFAToDFAConverter.SINGLE_THREADED_NFA_CONVERSION = false;
+                }
+                else if ( args[i] == "-Xnomergestopstates" )
+                {
+                    DFAOptimizer.MERGE_STOP_STATES = false;
+                }
+                else if ( args[i] == "-Xdfaverbose" )
+                {
+                    internalOption_ShowNFAConfigsInDFA = true;
+                }
+                else if ( args[i] == "-Xwatchconversion" )
+                {
+                    internalOption_watchNFAConversion = true;
+                }
+                else if ( args[i] == "-XdbgST" )
+                {
+                    CodeGenerator.EMIT_TEMPLATE_DELIMITERS = true;
+                }
+                else if ( args[i] == "-Xmaxinlinedfastates" )
+                {
+                    if ( i + 1 >= args.Length )
+                    {
+                        Console.Error.WriteLine( "missing max inline dfa states -Xmaxinlinedfastates option; ignoring" );
+                    }
+                    else
+                    {
+                        i++;
+                        CodeGenerator.MAX_ACYCLIC_DFA_STATES_INLINE = int.Parse( args[i] );
+                    }
+                }
+                else if ( args[i] == "-Xm" )
+                {
+                    if ( i + 1 >= args.Length )
+                    {
+                        Console.Error.WriteLine( "missing max recursion with -Xm option; ignoring" );
+                    }
+                    else
+                    {
+                        i++;
+                        NFAContext.MAX_SAME_RULE_INVOCATIONS_PER_NFA_CONFIG_STACK = int.Parse( args[i] );
+                    }
+                }
+                else if ( args[i] == "-Xmaxdfaedges" )
+                {
+                    if ( i + 1 >= args.Length )
+                    {
+                        Console.Error.WriteLine( "missing max number of edges with -Xmaxdfaedges option; ignoring" );
+                    }
+                    else
+                    {
+                        i++;
+                        DFA.MAX_STATE_TRANSITIONS_FOR_TABLE = int.Parse( args[i] );
+                    }
+                }
+                else if ( args[i] == "-Xconversiontimeout" )
+                {
+                    if ( i + 1 >= args.Length )
+                    {
+                        Console.Error.WriteLine( "missing max time in ms -Xconversiontimeout option; ignoring" );
+                    }
+                    else
+                    {
+                        i++;
+                        DFA.MAX_TIME_PER_DFA_CREATION = TimeSpan.FromMilliseconds( int.Parse( args[i] ) );
+                    }
+                }
+                else if ( args[i] == "-Xnfastates" )
+                {
+                    DecisionProbe.verbose = true;
+                }
+                else if ( args[i] == "-X" )
+                {
+                    Xhelp();
+                }
+                else
+                {
+                    if ( args[i][0] != '-' )
+                    {
+                        // must be the grammar file
+                        grammarFileNames.Add( args[i] );
+                    }
+                }
+            }
+        }
+
+        /*
+            protected void checkForInvalidArguments(String[] args, BitSet cmdLineArgValid) {
+                // check for invalid command line args
+                for (int a = 0; a < args.length; a++) {
+                    if (!cmdLineArgValid.member(a)) {
+                        System.err.println("invalid command-line argument: " + args[a] + "; ignored");
+                    }
+                }
+            }
+            */
+
+        public virtual void process()
+        {
+            int numFiles = grammarFileNames.Count;
+            bool exceptionWhenWritingLexerFile = false;
+            string lexerGrammarFileName = null;		// necessary at this scope to have access in the catch below
+            for ( int i = 0; i < numFiles; i++ )
+            {
+                string grammarFileName = grammarFileNames[i];
+                if ( verbose && !depend )
+                {
+                    Console.Out.WriteLine( grammarFileName );
+                }
+                try
+                {
+                    if ( depend )
+                    {
+                        BuildDependencyGenerator dep = new BuildDependencyGenerator( this, grammarFileName );
+                        IList<string> outputFiles = dep.getGeneratedFileList();
+                        IList<string> dependents = dep.getDependenciesFileList();
+                        //Console.Out.println("output: "+outputFiles);
+                        //Console.Out.println("dependents: "+dependents);
+                        Console.Out.WriteLine( dep.getDependencies() );
+                        continue;
+                    }
+                    Grammar grammar = getRootGrammar( grammarFileName );
+                    // we now have all grammars read in as ASTs
+                    // (i.e., root and all delegates)
+                    grammar.composite.assignTokenTypes();
+                    grammar.composite.defineGrammarSymbols();
+                    grammar.composite.createNFAs();
+
+                    generateRecognizer( grammar );
+
+                    if ( printGrammar )
+                    {
+                        grammar.printGrammar( Console.Out );
+                    }
+
+                    if ( report )
+                    {
+                        GrammarReport report2 = new GrammarReport( grammar );
+                        Console.Out.WriteLine( report2.ToString() );
+                        // print out a backtracking report too (that is not encoded into log)
+                        Console.Out.WriteLine( report2.getBacktrackingReport() );
+                        // same for aborted NFA->DFA conversions
+                        Console.Out.WriteLine( report2.getAnalysisTimeoutReport() );
+                    }
+                    if ( profile )
+                    {
+                        GrammarReport report2 = new GrammarReport( grammar );
+                        Stats.WriteReport( GrammarReport.GRAMMAR_STATS_FILENAME,
+                                          report2.toNotifyString() );
+                    }
+
+                    // now handle the lexer if one was created for a merged spec
+                    string lexerGrammarStr = grammar.getLexerGrammar();
+                    //JSystem.@out.println("lexer grammar:\n"+lexerGrammarStr);
+                    if ( grammar.type == Grammar.COMBINED && lexerGrammarStr != null )
+                    {
+                        lexerGrammarFileName = grammar.ImplicitlyGeneratedLexerFileName;
+                        try
+                        {
+                            TextWriter w = getOutputFile( grammar, lexerGrammarFileName );
+                            w.Write( lexerGrammarStr );
+                            w.Close();
+                        }
+                        catch ( IOException e )
+                        {
+                            // emit different error message when creating the implicit lexer fails
+                            // due to write permission error
+                            exceptionWhenWritingLexerFile = true;
+                            throw e;
+                        }
+                        try
+                        {
+                            StringReader sr = new StringReader( lexerGrammarStr );
+                            Grammar lexerGrammar = new Grammar();
+                            lexerGrammar.composite.watchNFAConversion = internalOption_watchNFAConversion;
+                            lexerGrammar.implicitLexer = true;
+                            lexerGrammar.Tool = this;
+                            FileInfo lexerGrammarFullFile = new FileInfo( System.IO.Path.Combine( getFileDirectory( lexerGrammarFileName ), lexerGrammarFileName ) );
+                            lexerGrammar.FileName = lexerGrammarFullFile.ToString();
+
+                            lexerGrammar.importTokenVocabulary( grammar );
+                            lexerGrammar.parseAndBuildAST( sr );
+
+                            sr.Close();
+
+                            lexerGrammar.composite.assignTokenTypes();
+                            lexerGrammar.composite.defineGrammarSymbols();
+                            lexerGrammar.composite.createNFAs();
+
+                            generateRecognizer( lexerGrammar );
+                        }
+                        finally
+                        {
+                            // make sure we clean up
+                            if ( deleteTempLexer )
+                            {
+                                System.IO.DirectoryInfo outputDir = getOutputDirectory( lexerGrammarFileName );
+                                FileInfo outputFile = new FileInfo( System.IO.Path.Combine( outputDir.FullName, lexerGrammarFileName ) );
+                                outputFile.Delete();
+                            }
+                        }
+                    }
+                }
+                catch ( IOException e )
+                {
+                    if ( exceptionWhenWritingLexerFile )
+                    {
+                        ErrorManager.error( ErrorManager.MSG_CANNOT_WRITE_FILE,
+                                           lexerGrammarFileName, e );
+                    }
+                    else
+                    {
+                        ErrorManager.error( ErrorManager.MSG_CANNOT_OPEN_FILE,
+                                           grammarFileName );
+                    }
+                }
+                catch ( Exception e )
+                {
+                    ErrorManager.error( ErrorManager.MSG_INTERNAL_ERROR, grammarFileName, e );
+                }
+                /*
+                finally {
+                    JSystem.@out.println("creates="+ Interval.creates);
+                    JSystem.@out.println("hits="+ Interval.hits);
+                    JSystem.@out.println("misses="+ Interval.misses);
+                    JSystem.@out.println("outOfRange="+ Interval.outOfRange);
+                }
+                */
+            }
+        }
+
+        /** Get a grammar mentioned on the command-line and any delegates */
+        public virtual Grammar getRootGrammar( string grammarFileName )
+        {
+            //StringTemplate.setLintMode(true);
+            // grammars mentioned on command line are either roots or single grammars.
+            // create the necessary composite in case it's got delegates; even
+            // single grammar needs it to get token types.
+            CompositeGrammar composite = new CompositeGrammar();
+            Grammar grammar = new Grammar( this, grammarFileName, composite );
+            composite.setDelegationRoot( grammar );
+            //FileReader fr = null;
+            //fr = new FileReader( grammarFileName );
+            //BufferedReader br = new BufferedReader( fr );
+            //grammar.parseAndBuildAST( br );
+            StringReader reader = new StringReader( System.IO.File.ReadAllText( grammarFileName ) );
+            grammar.parseAndBuildAST( reader );
+            composite.watchNFAConversion = internalOption_watchNFAConversion;
+            //br.close();
+            //fr.close();
+            return grammar;
+        }
+
+        /** Create NFA, DFA and generate code for grammar.
+         *  Create NFA for any delegates first.  Once all NFA are created,
+         *  it's ok to create DFA, which must check for left-recursion.  That check
+         *  is done by walking the full NFA, which therefore must be complete.
+         *  After all NFA, comes DFA conversion for root grammar then code gen for
+         *  root grammar.  DFA and code gen for delegates comes next.
+         */
+        protected virtual void generateRecognizer( Grammar grammar )
+        {
+            string language = (string)grammar.getOption( "language" );
+            if ( language != null )
+            {
+                CodeGenerator generator = new CodeGenerator( this, grammar, language );
+                grammar.setCodeGenerator( generator );
+                generator.setDebug( debug );
+                generator.setProfile( profile );
+                generator.setTrace( trace );
+
+                // generate NFA early in case of crash later (for debugging)
+                if ( generate_NFA_dot )
+                {
+                    generateNFAs( grammar );
+                }
+
+                // GENERATE CODE
+                generator.genRecognizer();
+
+                if ( generate_DFA_dot )
+                {
+                    generateDFAs( grammar );
+                }
+
+                IList<Grammar> delegates = grammar.getDirectDelegates();
+                for ( int i = 0; delegates != null && i < delegates.Count; i++ )
+                {
+                    Grammar @delegate = (Grammar)delegates[i];
+                    if ( @delegate != grammar )
+                    { // already processing this one
+                        generateRecognizer( @delegate );
+                    }
+                }
+            }
+        }
+
+        public virtual void generateDFAs( Grammar g )
+        {
+            for ( int d = 1; d <= g.NumberOfDecisions; d++ )
+            {
+                DFA dfa = g.getLookaheadDFA( d );
+                if ( dfa == null )
+                {
+                    continue; // not there for some reason, ignore
+                }
+                DOTGenerator dotGenerator = new DOTGenerator( g );
+                string dot = dotGenerator.getDOT( dfa.startState );
+                string dotFileName = g.name + "." + "dec-" + d;
+                if ( g.implicitLexer )
+                {
+                    dotFileName = g.name + Grammar.grammarTypeToFileNameSuffix[g.type] + "." + "dec-" + d;
+                }
+                try
+                {
+                    writeDOTFile( g, dotFileName, dot );
+                }
+                catch ( IOException ioe )
+                {
+                    ErrorManager.error( ErrorManager.MSG_CANNOT_GEN_DOT_FILE,
+                                       dotFileName,
+                                       ioe );
+                }
+            }
+        }
+
+        protected virtual void generateNFAs( Grammar g )
+        {
+            DOTGenerator dotGenerator = new DOTGenerator( g );
+            ICollection<Rule> rules = g.getAllImportedRules();
+            rules.addAll( g.Rules );
+
+            foreach ( Rule r in rules )
+            {
+                try
+                {
+                    string dot = dotGenerator.getDOT( r.startState );
+                    if ( dot != null )
+                    {
+                        writeDOTFile( g, r, dot );
+                    }
+                }
+                catch ( IOException ioe )
+                {
+                    ErrorManager.error( ErrorManager.MSG_CANNOT_WRITE_FILE, ioe );
+                }
+            }
+        }
+
+        protected virtual void writeDOTFile( Grammar g, Rule r, string dot )
+        {
+            writeDOTFile( g, r.grammar.name + "." + r.name, dot );
+        }
+
+        protected virtual void writeDOTFile( Grammar g, string name, string dot )
+        {
+            TextWriter fw = getOutputFile( g, name + ".dot" );
+            fw.Write( dot );
+            fw.Close();
+        }
+
+        private static void help()
+        {
+            Console.Error.WriteLine( "usage: java org.antlr.Tool [args] file.g [file2.g file3.g ...]" );
+            Console.Error.WriteLine( "  -o outputDir          specify output directory where all output is generated" );
+            Console.Error.WriteLine( "  -fo outputDir         same as -o but force even files with relative paths to dir" );
+            Console.Error.WriteLine( "  -lib dir              specify location of token files" );
+            Console.Error.WriteLine( "  -depend               generate file dependencies" );
+            Console.Error.WriteLine( "  -verbose              generate ANTLR version and other information" );
+            Console.Error.WriteLine( "  -report               print out a report about the grammar(s) processed" );
+            Console.Error.WriteLine( "  -print                print out the grammar without actions" );
+            Console.Error.WriteLine( "  -debug                generate a parser that emits debugging events" );
+            Console.Error.WriteLine( "  -profile              generate a parser that computes profiling information" );
+            Console.Error.WriteLine( "  -nfa                  generate an NFA for each rule" );
+            Console.Error.WriteLine( "  -dfa                  generate a DFA for each decision point" );
+            Console.Error.WriteLine( "  -message-format name  specify output style for messages" );
+            Console.Error.WriteLine( "  -X                    display extended argument list" );
+        }
+
+        private static void Xhelp()
+        {
+            Console.Error.WriteLine( "  -Xgrtree               print the grammar AST" );
+            Console.Error.WriteLine( "  -Xdfa                  print DFA as text " );
+            Console.Error.WriteLine( "  -Xnoprune              test lookahead against EBNF block exit branches" );
+            Console.Error.WriteLine( "  -Xnocollapse           collapse incident edges into DFA states" );
+            Console.Error.WriteLine( "  -Xdbgconversion        dump lots of info during NFA conversion" );
+            Console.Error.WriteLine( "  -Xmultithreaded        run the analysis in 2 threads" );
+            Console.Error.WriteLine( "  -Xnomergestopstates    do not merge stop states" );
+            Console.Error.WriteLine( "  -Xdfaverbose           generate DFA states in DOT with NFA configs" );
+            Console.Error.WriteLine( "  -Xwatchconversion      print a message for each NFA before converting" );
+            Console.Error.WriteLine( "  -XdbgST                put tags at start/stop of all templates in output" );
+            Console.Error.WriteLine( "  -Xm m                  max number of rule invocations during conversion" );
+            Console.Error.WriteLine( "  -Xmaxdfaedges m        max \"comfortable\" number of edges for single DFA state" );
+            Console.Error.WriteLine( "  -Xconversiontimeout t  set NFA conversion timeout for each decision" );
+            Console.Error.WriteLine( "  -Xmaxinlinedfastates m max DFA states before table used rather than inlining" );
+            Console.Error.WriteLine( "  -Xnfastates            for nondeterminisms, list NFA states for each path" );
+        }
+
+        public virtual void setOutputDirectory( string outputDirectory )
+        {
+            this.outputDirectory = outputDirectory;
+        }
+
+        public virtual TextWriter getOutputFile( Grammar g, string fileName )
+        {
+            if ( outputDirectory == null )
+                return new StringWriter();
+
+            System.IO.DirectoryInfo outputDir = getOutputDirectory( g.FileName );
+            FileInfo outputFile = new FileInfo( System.IO.Path.Combine( outputDir.FullName, fileName ) );
+
+            if ( !outputDir.Exists )
+                outputDir.Create();
+
+            if ( outputFile.Exists )
+                outputFile.Delete();
+
+            return new System.IO.StreamWriter( new System.IO.BufferedStream( outputFile.OpenWrite() ) );
+            //if ( outputDirectory == null )
+            //{
+            //    return new StringWriter();
+            //}
+            //// output directory is a function of where the grammar file lives
+            //// for subdir/T.g, you get subdir here.  Well, depends on -o etc...
+            //File outputDir = getOutputDirectory( g.getFileName() );
+            //File outputFile = new File( outputDir, fileName );
+
+            //if ( !outputDir.exists() )
+            //{
+            //    outputDir.mkdirs();
+            //}
+            //FileWriter fw = new FileWriter( outputFile );
+            //return new BufferedWriter( fw );
+        }
+
+        public virtual System.IO.DirectoryInfo getOutputDirectory( string fileNameWithPath )
+        {
+            //File outputDir = new File( outputDirectory );
+            //String fileDirectory = getFileDirectory( fileNameWithPath );
+            //if ( outputDirectory != UNINITIALIZED_DIR )
+            //{
+            //    // -o /tmp /var/lib/t.g => /tmp/T.java
+            //    // -o subdir/output /usr/lib/t.g => subdir/output/T.java
+            //    // -o . /usr/lib/t.g => ./T.java
+            //    if ( fileDirectory != null &&
+            //         ( new File( fileDirectory ).isAbsolute() ||
+            //          fileDirectory.startsWith( "~" ) ) || // isAbsolute doesn't count this :(
+            //                                         forceAllFilesToOutputDir
+            //        )
+            //    {
+            //        // somebody set the dir, it takes precendence; write new file there
+            //        outputDir = new File( outputDirectory );
+            //    }
+            //    else
+            //    {
+            //        // -o /tmp subdir/t.g => /tmp/subdir/t.g
+            //        if ( fileDirectory != null )
+            //        {
+            //            outputDir = new File( outputDirectory, fileDirectory );
+            //        }
+            //        else
+            //        {
+            //            outputDir = new File( outputDirectory );
+            //        }
+            //    }
+            //}
+            //else
+            //{
+            //    // they didn't specify a -o dir so just write to location
+            //    // where grammar is, absolute or relative
+            //    String dir = ".";
+            //    if ( fileDirectory != null )
+            //    {
+            //        dir = fileDirectory;
+            //    }
+            //    outputDir = new File( dir );
+            //}
+            //return outputDir;
+
+            //File outputDir = new File( outputDirectory );
+            string outputDir = outputDirectory;
+
+            if ( fileNameWithPath.IndexOfAny( System.IO.Path.GetInvalidPathChars() ) >= 0 )
+                return new System.IO.DirectoryInfo( outputDir );
+
+            if ( !System.IO.Path.IsPathRooted( fileNameWithPath ) )
+                fileNameWithPath = System.IO.Path.GetFullPath( fileNameWithPath );
+
+            string fileDirectory = getFileDirectory( fileNameWithPath );
+            if ( outputDirectory != UNINITIALIZED_DIR )
+            {
+                // -o /tmp /var/lib/t.g => /tmp/T.java
+                // -o subdir/output /usr/lib/t.g => subdir/output/T.java
+                // -o . /usr/lib/t.g => ./T.java
+                if ( fileDirectory != null &&
+                     ( System.IO.Path.IsPathRooted( fileDirectory ) ||
+                      fileDirectory.StartsWith( "~" ) ) || // isAbsolute doesn't count this :(
+                                                     forceAllFilesToOutputDir
+                    )
+                {
+                    // somebody set the dir, it takes precendence; write new file there
+                    //outputDir = new File( outputDirectory );
+                    outputDir = outputDirectory;
+                }
+                else
+                {
+                    // -o /tmp subdir/t.g => /tmp/subdir/t.g
+                    if ( fileDirectory != null )
+                    {
+                        //outputDir = new File( outputDirectory, fileDirectory );
+                        outputDir = System.IO.Path.Combine( outputDirectory, fileDirectory );
+                    }
+                    else
+                    {
+                        //outputDir = new File( outputDirectory );
+                        outputDir = outputDirectory;
+                    }
+                }
+            }
+            else
+            {
+                // they didn't specify a -o dir so just write to location
+                // where grammar is, absolute or relative
+                string dir = ".";
+                if ( fileDirectory != null )
+                {
+                    dir = fileDirectory;
+                }
+                //outputDir = new File( dir );
+                outputDir = dir;
+            }
+            return new System.IO.DirectoryInfo( outputDir );
+        }
+
+        public virtual string getLibraryFile( string fileName )
+        {
+            return System.IO.Path.Combine( libDirectory, fileName );
+        }
+
+        public virtual string getLibraryDirectory()
+        {
+            return libDirectory;
+        }
+
+        public virtual string getFileDirectory( string fileName )
+        {
+            return System.IO.Path.GetDirectoryName( fileName );
+        }
+
+        public virtual FileInfo getImportedVocabFile( string vocabName )
+        {
+            string path = System.IO.Path.Combine( getLibraryDirectory(), vocabName + CodeGenerator.VOCAB_FILE_EXTENSION );
+            if ( System.IO.File.Exists( path ) )
+                return new FileInfo( path );
+
+            return new FileInfo( System.IO.Path.Combine( outputDirectory, vocabName + CodeGenerator.VOCAB_FILE_EXTENSION ) );
+            //File f = new File( getLibraryDirectory(),
+            //                  File.separator +
+            //                  vocabName +
+            //                  CodeGenerator.VOCAB_FILE_EXTENSION );
+            //if ( f.exists() )
+            //{
+            //    return f;
+            //}
+            //
+            //return new File( outputDirectory +
+            //                File.separator +
+            //                vocabName +
+            //                CodeGenerator.VOCAB_FILE_EXTENSION );
+        }
+
+        public virtual void panic()
+        {
+            throw new Exception( "ANTLR panic" );
+        }
+
+        /// <summary>
+        /// Return a time stamp string accurate to sec: yyyy-mm-dd hh:mm:ss
+        /// </summary>
+        public static string getCurrentTimeStamp()
+        {
+            return DateTime.Now.ToString( "yyyy\\-MM\\-dd HH\\:mm\\:ss" );
+        }
+    }
+}
diff --git a/Antlr3/Codegen/ACyclicDFACodeGenerator.cs b/Antlr3/Codegen/ACyclicDFACodeGenerator.cs
new file mode 100644
index 0000000..63515bd
--- /dev/null
+++ b/Antlr3/Codegen/ACyclicDFACodeGenerator.cs
@@ -0,0 +1,204 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Codegen
+{
+    using System.Collections.Generic;
+    using System.Linq;
+    using Antlr3.Analysis;
+
+    using StringTemplate = Antlr3.ST.StringTemplate;
+    using StringTemplateGroup = Antlr3.ST.StringTemplateGroup;
+
+    public class ACyclicDFACodeGenerator
+    {
+        protected CodeGenerator parentGenerator;
+
+        public ACyclicDFACodeGenerator( CodeGenerator parent )
+        {
+            this.parentGenerator = parent;
+        }
+
+        public virtual StringTemplate genFixedLookaheadDecision( StringTemplateGroup templates,
+                                                        DFA dfa )
+        {
+            return walkFixedDFAGeneratingStateMachine( templates, dfa, dfa.startState, 1 );
+        }
+
+        protected virtual StringTemplate walkFixedDFAGeneratingStateMachine(
+                StringTemplateGroup templates,
+                DFA dfa,
+                DFAState s,
+                int k )
+        {
+            //System.out.println("walk "+s.stateNumber+" in dfa for decision "+dfa.decisionNumber);
+            if ( s.IsAcceptState )
+            {
+                StringTemplate dfaST2 = templates.getInstanceOf( "dfaAcceptState" );
+                dfaST2.setAttribute( "alt", s.getUniquelyPredictedAlt() );
+                return dfaST2;
+            }
+
+            // the default templates for generating a state and its edges
+            // can be an if-then-else structure or a switch
+            string dfaStateName = "dfaState";
+            string dfaLoopbackStateName = "dfaLoopbackState";
+            string dfaOptionalBlockStateName = "dfaOptionalBlockState";
+            string dfaEdgeName = "dfaEdge";
+            if ( parentGenerator.canGenerateSwitch( s ) )
+            {
+                dfaStateName = "dfaStateSwitch";
+                dfaLoopbackStateName = "dfaLoopbackStateSwitch";
+                dfaOptionalBlockStateName = "dfaOptionalBlockStateSwitch";
+                dfaEdgeName = "dfaEdgeSwitch";
+            }
+
+            StringTemplate dfaST = templates.getInstanceOf( dfaStateName );
+            if ( dfa.NFADecisionStartState.decisionStateType == NFAState.LOOPBACK )
+            {
+                dfaST = templates.getInstanceOf( dfaLoopbackStateName );
+            }
+            else if ( dfa.NFADecisionStartState.decisionStateType == NFAState.OPTIONAL_BLOCK_START )
+            {
+                dfaST = templates.getInstanceOf( dfaOptionalBlockStateName );
+            }
+            dfaST.setAttribute( "k", k );
+            dfaST.setAttribute( "stateNumber", s.stateNumber );
+            dfaST.setAttribute( "semPredState",
+                               s.IsResolvedWithPredicates );
+            /*
+            String description = dfa.getNFADecisionStartState().getDescription();
+            description = parentGenerator.target.getTargetStringLiteralFromString(description);
+            //System.out.println("DFA: "+description+" associated with AST "+dfa.getNFADecisionStartState());
+            if ( description!=null ) {
+                dfaST.setAttribute("description", description);
+            }
+            */
+            int EOTPredicts = NFA.INVALID_ALT_NUMBER;
+            DFAState EOTTarget = null;
+            //System.out.println("DFA state "+s.stateNumber);
+            for ( int i = 0; i < s.NumberOfTransitions; i++ )
+            {
+                Transition edge = (Transition)s.transition( i );
+                //System.out.println("edge "+s.stateNumber+"-"+edge.label.toString()+"->"+edge.target.stateNumber);
+                if ( edge.label.Atom == Label.EOT )
+                {
+                    // don't generate a real edge for EOT; track alt EOT predicts
+                    // generate that prediction in the else clause as default case
+                    EOTTarget = (DFAState)edge.target;
+                    EOTPredicts = EOTTarget.getUniquelyPredictedAlt();
+                    /*
+                    System.out.println("DFA s"+s.stateNumber+" EOT goes to s"+
+                                       edge.target.stateNumber+" predicates alt "+
+                                       EOTPredicts);
+                    */
+                    continue;
+                }
+                StringTemplate edgeST = templates.getInstanceOf( dfaEdgeName );
+                // If the template wants all the label values delineated, do that
+                if ( edgeST.getFormalArgument( "labels" ) != null )
+                {
+                    List<string> labels = edge.Label.Set.Select( value => parentGenerator.getTokenTypeAsTargetLabel( value ) ).ToList();
+                    edgeST.setAttribute( "labels", labels );
+                }
+                else
+                { // else create an expression to evaluate (the general case)
+                    edgeST.setAttribute( "labelExpr",
+                                        parentGenerator.genLabelExpr( templates, edge, k ) );
+                }
+
+                // stick in any gated predicates for any edge if not already a pred
+                if ( !edge.label.IsSemanticPredicate )
+                {
+                    DFAState target = (DFAState)edge.target;
+                    SemanticContext preds =
+                        target.getGatedPredicatesInNFAConfigurations();
+                    if ( preds != null )
+                    {
+                        //System.out.println("preds="+target.getGatedPredicatesInNFAConfigurations());
+                        StringTemplate predST = preds.genExpr( parentGenerator,
+                                                              parentGenerator.Templates,
+                                                              dfa );
+                        edgeST.setAttribute( "predicates", predST );
+                    }
+                }
+
+                StringTemplate targetST =
+                    walkFixedDFAGeneratingStateMachine( templates,
+                                                       dfa,
+                                                       (DFAState)edge.target,
+                                                       k + 1 );
+                edgeST.setAttribute( "targetState", targetST );
+                dfaST.setAttribute( "edges", edgeST );
+                /*
+                System.out.println("back to DFA "+
+                                   dfa.decisionNumber+"."+s.stateNumber);
+                                   */
+            }
+
+            // HANDLE EOT EDGE
+            if ( EOTPredicts != NFA.INVALID_ALT_NUMBER )
+            {
+                // EOT unique predicts an alt
+                dfaST.setAttribute( "eotPredictsAlt", EOTPredicts );
+            }
+            else if ( EOTTarget != null && EOTTarget.NumberOfTransitions > 0 )
+            {
+                // EOT state has transitions so must split on predicates.
+                // Generate predicate else-if clauses and then generate
+                // NoViableAlt exception as else clause.
+                // Note: these predicates emanate from the EOT target state
+                // rather than the current DFAState s so the error message
+                // might be slightly misleading if you are looking at the
+                // state number.  Predicates emanating from EOT targets are
+                // hoisted up to the state that has the EOT edge.
+                for ( int i = 0; i < EOTTarget.NumberOfTransitions; i++ )
+                {
+                    Transition predEdge = (Transition)EOTTarget.transition( i );
+                    StringTemplate edgeST = templates.getInstanceOf( dfaEdgeName );
+                    edgeST.setAttribute( "labelExpr",
+                                        parentGenerator.genSemanticPredicateExpr( templates, predEdge ) );
+                    // the target must be an accept state
+                    //System.out.println("EOT edge");
+                    StringTemplate targetST =
+                        walkFixedDFAGeneratingStateMachine( templates,
+                                                           dfa,
+                                                           (DFAState)predEdge.target,
+                                                           k + 1 );
+                    edgeST.setAttribute( "targetState", targetST );
+                    dfaST.setAttribute( "edges", edgeST );
+                }
+            }
+            return dfaST;
+        }
+    }
+}
diff --git a/Antlr3/Codegen/CodeGenerator.cs b/Antlr3/Codegen/CodeGenerator.cs
new file mode 100644
index 0000000..b38ab2e
--- /dev/null
+++ b/Antlr3/Codegen/CodeGenerator.cs
@@ -0,0 +1,1556 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Codegen
+{
+    using System.Collections.Generic;
+    using System.Linq;
+    using Antlr.Runtime.JavaExtensions;
+    using Antlr3.Analysis;
+    using Antlr3.Grammars;
+
+    using AngleBracketTemplateLexer = Antlr3.ST.Language.AngleBracketTemplateLexer;
+    using ANTLRLexer = Antlr3.Grammars.ANTLRLexer;
+    using ANTLRParser = Antlr3.Grammars.ANTLRParser;
+    using AntlrTool = Antlr3.AntlrTool;
+    using ArgumentException = System.ArgumentException;
+    using AttributeScope = Antlr3.Tool.AttributeScope;
+    using BitSet = Antlr3.Misc.BitSet;
+    using CommonGroupLoader = Antlr3.ST.CommonGroupLoader;
+    using CommonToken = Antlr.Runtime.CommonToken;
+    using DateTime = System.DateTime;
+    using DFA = Antlr3.Analysis.DFA;
+    using DFAOptimizer = Antlr3.Analysis.DFAOptimizer;
+    using DFAState = Antlr3.Analysis.DFAState;
+    using ErrorManager = Antlr3.Tool.ErrorManager;
+    using Exception = System.Exception;
+    using Grammar = Antlr3.Tool.Grammar;
+    using GrammarAST = Antlr3.Tool.GrammarAST;
+    using IDictionary = System.Collections.IDictionary;
+    using IIntSet = Antlr3.Misc.IIntSet;
+    using IList = System.Collections.IList;
+    using Interval = Antlr3.Misc.Interval;
+    using IntervalSet = Antlr3.Misc.IntervalSet;
+    using IOException = System.IO.IOException;
+    using IStringTemplateGroupLoader = Antlr3.ST.IStringTemplateGroupLoader;
+    using IStringTemplateWriter = Antlr3.ST.IStringTemplateWriter;
+    using IToken = Antlr.Runtime.IToken;
+    using Label = Antlr3.Analysis.Label;
+    using LookaheadSet = Antlr3.Analysis.LookaheadSet;
+    using NFAState = Antlr3.Analysis.NFAState;
+    using RecognitionException = Antlr.Runtime.RecognitionException;
+    using Rule = Antlr3.Tool.Rule;
+    using StringTemplate = Antlr3.ST.StringTemplate;
+    using StringTemplateGroup = Antlr3.ST.StringTemplateGroup;
+    using TextWriter = System.IO.TextWriter;
+
+    /** ANTLR's code generator.
+     *
+     *  Generate recognizers derived from grammars.  Language independence
+     *  achieved through the use of StringTemplateGroup objects.  All output
+     *  strings are completely encapsulated in the group files such as Java.stg.
+     *  Some computations are done that are unused by a particular language.
+     *  This generator just computes and sets the values into the templates;
+     *  the templates are free to use or not use the information.
+     *
+     *  To make a new code generation target, define X.stg for language X
+     *  by copying from existing Y.stg most closely releated to your language;
+     *  e.g., to do CSharp.stg copy Java.stg.  The template group file has a
+     *  bunch of templates that are needed by the code generator.  You can add
+     *  a new target w/o even recompiling ANTLR itself.  The language=X option
+     *  in a grammar file dictates which templates get loaded/used.
+     *
+     *  Some language like C need both parser files and header files.  Java needs
+     *  to have a separate file for the cyclic DFA as ANTLR generates bytecodes
+     *  directly (which cannot be in the generated parser Java file).  To facilitate
+     *  this,
+     *
+     * cyclic can be in same file, but header, output must be searpate.  recognizer
+     *  is in outptufile.
+     */
+    public class CodeGenerator
+    {
+        /** When generating SWITCH statements, some targets might need to limit
+         *  the size (based upon the number of case labels).  Generally, this
+         *  limit will be hit only for lexers where wildcard in a UNICODE
+         *  vocabulary environment would generate a SWITCH with 65000 labels.
+         */
+        public int MAX_SWITCH_CASE_LABELS = 300;
+        public int MIN_SWITCH_ALTS = 3;
+        public bool GENERATE_SWITCHES_WHEN_POSSIBLE = true;
+        //public static boolean GEN_ACYCLIC_DFA_INLINE = true;
+        public static bool EMIT_TEMPLATE_DELIMITERS = false;
+        public static int MAX_ACYCLIC_DFA_STATES_INLINE = 10;
+
+        //public string classpathTemplateRootDirectoryName = "org/antlr/codegen/templates";
+        //public string classpathTemplateRootDirectoryName = "Antlr3.Codegen.Templates";
+        public string classpathTemplateRootDirectoryName =
+            System.IO.Path.Combine( System.IO.Path.GetDirectoryName( typeof( CodeGenerator ).Assembly.Location ), @"Codegen\Templates" );
+
+        /** Which grammar are we generating code for?  Each generator
+         *  is attached to a specific grammar.
+         */
+        public Grammar grammar;
+
+        /** What language are we generating? */
+        protected string language;
+
+        /** The target specifies how to write out files and do other language
+         *  specific actions.
+         */
+        public Target target = null;
+
+        /** Where are the templates this generator should use to generate code? */
+        protected StringTemplateGroup templates;
+
+        /** The basic output templates without AST or templates stuff; this will be
+         *  the templates loaded for the language such as Java.stg *and* the Dbg
+         *  stuff if turned on.  This is used for generating syntactic predicates.
+         */
+        protected StringTemplateGroup baseTemplates;
+
+        protected StringTemplate recognizerST;
+        protected StringTemplate outputFileST;
+        protected StringTemplate headerFileST;
+
+        /** Used to create unique labels */
+        protected int uniqueLabelNumber = 1;
+
+        /** A reference to the ANTLR tool so we can learn about output directories
+         *  and such.
+         */
+        protected AntlrTool tool;
+
+        /** Generate debugging event method calls */
+        protected bool debug;
+
+        /** Create a Tracer object and make the recognizer invoke this. */
+        protected bool trace;
+
+        /** Track runtime parsing information about decisions etc...
+         *  This requires the debugging event mechanism to work.
+         */
+        protected bool profile;
+
+        protected int lineWidth = 72;
+
+        /** I have factored out the generation of acyclic DFAs to separate class */
+        public ACyclicDFACodeGenerator acyclicDFAGenerator;
+
+        /** I have factored out the generation of cyclic DFAs to separate class */
+        /*
+        public CyclicDFACodeGenerator cyclicDFAGenerator =
+            new CyclicDFACodeGenerator(this);
+            */
+
+        public const string VOCAB_FILE_EXTENSION = ".tokens";
+        protected const string vocabFilePattern =
+            "<tokens:{<attr.name>=<attr.type>\n}>" +
+            "<literals:{<attr.name>=<attr.type>\n}>";
+
+        public CodeGenerator( AntlrTool tool, Grammar grammar, string language )
+        {
+            this.tool = tool;
+            this.grammar = grammar;
+            this.language = language;
+
+            acyclicDFAGenerator = new ACyclicDFACodeGenerator( this );
+
+            loadLanguageTarget( language );
+        }
+
+        #region Properties
+        public StringTemplateGroup BaseTemplates
+        {
+            get
+            {
+                return getBaseTemplates();
+            }
+        }
+        public StringTemplate RecognizerST
+        {
+            get
+            {
+                return getRecognizerST();
+            }
+        }
+        public StringTemplateGroup Templates
+        {
+            get
+            {
+                return getTemplates();
+            }
+        }
+        public string VocabFileName
+        {
+            get
+            {
+                return getVocabFileName();
+            }
+        }
+        public bool Debug
+        {
+            get
+            {
+                return debug;
+            }
+        }
+        public bool Profile
+        {
+            get
+            {
+                return profile;
+            }
+        }
+        public bool Trace
+        {
+            get
+            {
+                return trace;
+            }
+        }
+        #endregion
+
+        protected virtual void loadLanguageTarget( string language )
+        {
+            // first try to load the target via a satellite DLL
+            string assembly = "Antlr3.Targets." + language + ".dll";
+            string path1 = System.IO.Path.Combine( System.IO.Path.GetDirectoryName( typeof( CodeGenerator ).Assembly.Location ), "Targets" );
+            string path2 = System.IO.Path.GetDirectoryName( typeof( CodeGenerator ).Assembly.Location );
+            string[] paths = { path1, path2 };
+
+            System.Reflection.Assembly targetAssembly = null;
+            System.Type targetType = null;
+            string targetName = "Antlr3.Targets." + language + "Target";
+
+            foreach ( string path in paths )
+            {
+                string filename = System.IO.Path.Combine( path, assembly );
+                if ( System.IO.File.Exists( filename ) )
+                {
+                    try
+                    {
+                        targetAssembly = System.Reflection.Assembly.LoadFile( filename );
+                        targetType = targetAssembly.GetType( targetName, false );
+                    }
+                    catch
+                    {
+                    }
+                }
+            }
+
+            // then try to load from the current file
+            if ( targetType == null )
+            {
+                targetType = System.Type.GetType( targetName );
+
+                if ( targetType == null )
+                {
+                    ErrorManager.error( ErrorManager.MSG_CANNOT_CREATE_TARGET_GENERATOR, targetName );
+                    return;
+                }
+            }
+
+            target = (Target)targetType.GetConstructor( new System.Type[0] ).Invoke( new object[0] );
+        }
+
+        /** load the main language.stg template group file */
+        public virtual void loadTemplates( string language )
+        {
+            // get a group loader containing main templates dir and target subdir
+            string templateDirs =
+                classpathTemplateRootDirectoryName + ":" +
+                classpathTemplateRootDirectoryName + @"\" + language;
+            //JSystem.@out.println("targets="+templateDirs.toString());
+            IStringTemplateGroupLoader loader =
+                new CommonGroupLoader( templateDirs,
+                                      ErrorManager.getStringTemplateErrorListener() );
+            StringTemplateGroup.registerGroupLoader( loader );
+            StringTemplateGroup.registerDefaultLexer( typeof( AngleBracketTemplateLexer ) );
+
+            // first load main language template
+            StringTemplateGroup coreTemplates =
+                StringTemplateGroup.loadGroup( language );
+            baseTemplates = coreTemplates;
+            if ( coreTemplates == null )
+            {
+                ErrorManager.error( ErrorManager.MSG_MISSING_CODE_GEN_TEMPLATES,
+                                   language );
+                return;
+            }
+
+            // dynamically add subgroups that act like filters to apply to
+            // their supergroup.  E.g., Java:Dbg:AST:ASTParser::ASTDbg.
+            string outputOption = (string)grammar.getOption( "output" );
+            if ( outputOption != null && outputOption.Equals( "AST" ) )
+            {
+                if ( debug && grammar.type != Grammar.LEXER )
+                {
+                    StringTemplateGroup dbgTemplates =
+                        StringTemplateGroup.loadGroup( "Dbg", coreTemplates );
+                    baseTemplates = dbgTemplates;
+                    StringTemplateGroup astTemplates =
+                        StringTemplateGroup.loadGroup( "AST", dbgTemplates );
+                    StringTemplateGroup astParserTemplates = astTemplates;
+                    //if ( !grammar.rewriteMode() ) {
+                    if ( grammar.type == Grammar.TREE_PARSER )
+                    {
+                        astParserTemplates =
+                            StringTemplateGroup.loadGroup( "ASTTreeParser", astTemplates );
+                    }
+                    else
+                    {
+                        astParserTemplates =
+                            StringTemplateGroup.loadGroup( "ASTParser", astTemplates );
+                    }
+                    //}
+                    StringTemplateGroup astDbgTemplates =
+                        StringTemplateGroup.loadGroup( "ASTDbg", astParserTemplates );
+                    templates = astDbgTemplates;
+                }
+                else
+                {
+                    StringTemplateGroup astTemplates =
+                        StringTemplateGroup.loadGroup( "AST", coreTemplates );
+                    StringTemplateGroup astParserTemplates = astTemplates;
+                    //if ( !grammar.rewriteMode() ) {
+                    if ( grammar.type == Grammar.TREE_PARSER )
+                    {
+                        astParserTemplates =
+                            StringTemplateGroup.loadGroup( "ASTTreeParser", astTemplates );
+                    }
+                    else
+                    {
+                        astParserTemplates =
+                            StringTemplateGroup.loadGroup( "ASTParser", astTemplates );
+                    }
+                    //}
+                    templates = astParserTemplates;
+                }
+            }
+            else if ( outputOption != null && outputOption.Equals( "template" ) )
+            {
+                if ( debug && grammar.type != Grammar.LEXER )
+                {
+                    StringTemplateGroup dbgTemplates =
+                        StringTemplateGroup.loadGroup( "Dbg", coreTemplates );
+                    baseTemplates = dbgTemplates;
+                    StringTemplateGroup stTemplates =
+                        StringTemplateGroup.loadGroup( "ST", dbgTemplates );
+                    templates = stTemplates;
+                }
+                else
+                {
+                    templates = StringTemplateGroup.loadGroup( "ST", coreTemplates );
+                }
+            }
+            else if ( debug && grammar.type != Grammar.LEXER )
+            {
+                templates = StringTemplateGroup.loadGroup( "Dbg", coreTemplates );
+                baseTemplates = templates;
+            }
+            else
+            {
+                templates = coreTemplates;
+            }
+
+            if ( EMIT_TEMPLATE_DELIMITERS )
+            {
+                templates.emitDebugStartStopStrings( true );
+                templates.doNotEmitDebugStringsForTemplate( "codeFileExtension" );
+                templates.doNotEmitDebugStringsForTemplate( "headerFileExtension" );
+            }
+        }
+
+        /** Given the grammar to which we are attached, walk the AST associated
+         *  with that grammar to create NFAs.  Then create the DFAs for all
+         *  decision points in the grammar by converting the NFAs to DFAs.
+         *  Finally, walk the AST again to generate code.
+         *
+         *  Either 1 or 2 files are written:
+         *
+         * 		recognizer: the main parser/lexer/treewalker item
+         * 		header file: language like C/C++ need extern definitions
+         *
+         *  The target, such as JavaTarget, dictates which files get written.
+         */
+        public virtual StringTemplate genRecognizer()
+        {
+            //JSystem.@out.println("### generate "+grammar.name+" recognizer");
+            // LOAD OUTPUT TEMPLATES
+            loadTemplates( language );
+            if ( templates == null )
+            {
+                return null;
+            }
+
+            // CREATE NFA FROM GRAMMAR, CREATE DFA FROM NFA
+            if ( ErrorManager.doNotAttemptAnalysis() )
+            {
+                return null;
+            }
+            target.performGrammarAnalysis( this, grammar );
+
+
+            // some grammar analysis errors will not yield reliable DFA
+            if ( ErrorManager.doNotAttemptCodeGen() )
+            {
+                return null;
+            }
+
+            // OPTIMIZE DFA
+            DFAOptimizer optimizer = new DFAOptimizer( grammar );
+            optimizer.optimize();
+
+            // OUTPUT FILE (contains recognizerST)
+            outputFileST = templates.getInstanceOf( "outputFile" );
+
+            // HEADER FILE
+            if ( templates.isDefined( "headerFile" ) )
+            {
+                headerFileST = templates.getInstanceOf( "headerFile" );
+            }
+            else
+            {
+                // create a dummy to avoid null-checks all over code generator
+                headerFileST = new StringTemplate( templates, "" );
+                headerFileST.setName( "dummy-header-file" );
+            }
+
+            bool filterMode = grammar.getOption( "filter" ) != null &&
+                                  grammar.getOption( "filter" ).Equals( "true" );
+            bool canBacktrack = grammar.composite.getRootGrammar().atLeastOneBacktrackOption ||
+                                   grammar.SyntacticPredicates != null ||
+                                   filterMode;
+
+            // TODO: move this down further because generating the recognizer
+            // alters the model with info on who uses predefined properties etc...
+            // The actions here might refer to something.
+
+            // The only two possible output files are available at this point.
+            // Verify action scopes are ok for target and dump actions into output
+            // Templates can say <actions.parser.header> for example.
+            var actions = grammar.Actions;
+            verifyActionScopesOkForTarget( actions );
+            // translate $x::y references
+            translateActionAttributeReferences( actions );
+            StringTemplate gateST = templates.getInstanceOf( "actionGate" );
+            if ( filterMode )
+            {
+                // if filtering, we need to set actions to execute at backtracking
+                // level 1 not 0.
+                gateST = templates.getInstanceOf( "filteringActionGate" );
+            }
+            grammar.setSynPredGateIfNotAlready( gateST );
+
+            headerFileST.setAttribute( "actions", actions );
+            outputFileST.setAttribute( "actions", actions );
+
+            headerFileST.setAttribute( "buildTemplate", grammar.BuildTemplate );
+            outputFileST.setAttribute( "buildTemplate", grammar.BuildTemplate );
+            headerFileST.setAttribute( "buildAST", grammar.BuildAST );
+            outputFileST.setAttribute( "buildAST", grammar.BuildAST );
+
+            outputFileST.setAttribute( "rewriteMode", grammar.RewriteMode );
+            headerFileST.setAttribute( "rewriteMode", grammar.RewriteMode );
+
+            outputFileST.setAttribute( "backtracking", canBacktrack );
+            headerFileST.setAttribute( "backtracking", canBacktrack );
+            // turn on memoize attribute at grammar level so we can create ruleMemo.
+            // each rule has memoize attr that hides this one, indicating whether
+            // it needs to save results
+            string memoize = (string)grammar.getOption( "memoize" );
+            outputFileST.setAttribute( "memoize",
+                                      ( grammar.atLeastOneRuleMemoizes ||
+                                      ( memoize != null && memoize.Equals( "true" ) ) &&
+                                                  canBacktrack ) );
+            headerFileST.setAttribute( "memoize",
+                                      ( grammar.atLeastOneRuleMemoizes ||
+                                      ( memoize != null && memoize.Equals( "true" ) ) &&
+                                                  canBacktrack ) );
+
+
+            outputFileST.setAttribute( "trace", trace );
+            headerFileST.setAttribute( "trace", trace );
+
+            outputFileST.setAttribute( "profile", profile );
+            headerFileST.setAttribute( "profile", profile );
+
+            // RECOGNIZER
+            if ( grammar.type == Grammar.LEXER )
+            {
+                recognizerST = templates.getInstanceOf( "lexer" );
+                outputFileST.setAttribute( "LEXER", true );
+                headerFileST.setAttribute( "LEXER", true );
+                recognizerST.setAttribute( "filterMode", filterMode );
+            }
+            else if ( grammar.type == Grammar.PARSER ||
+                grammar.type == Grammar.COMBINED )
+            {
+                recognizerST = templates.getInstanceOf( "parser" );
+                outputFileST.setAttribute( "PARSER", true );
+                headerFileST.setAttribute( "PARSER", true );
+            }
+            else
+            {
+                recognizerST = templates.getInstanceOf( "treeParser" );
+                outputFileST.setAttribute( "TREE_PARSER", true );
+                headerFileST.setAttribute( "TREE_PARSER", true );
+                recognizerST.setAttribute( "filterMode", filterMode );
+            }
+            outputFileST.setAttribute( "recognizer", recognizerST );
+            headerFileST.setAttribute( "recognizer", recognizerST );
+            outputFileST.setAttribute( "actionScope",
+                                      grammar.getDefaultActionScope( grammar.type ) );
+            headerFileST.setAttribute( "actionScope",
+                                      grammar.getDefaultActionScope( grammar.type ) );
+
+            string targetAppropriateFileNameString =
+                target.getTargetStringLiteralFromString( grammar.FileName );
+            outputFileST.setAttribute( "fileName", targetAppropriateFileNameString );
+            headerFileST.setAttribute( "fileName", targetAppropriateFileNameString );
+            outputFileST.setAttribute( "ANTLRVersion", AntlrTool.VERSION );
+            headerFileST.setAttribute( "ANTLRVersion", AntlrTool.VERSION );
+            outputFileST.setAttribute( "generatedTimestamp", AntlrTool.getCurrentTimeStamp() );
+            headerFileST.setAttribute( "generatedTimestamp", AntlrTool.getCurrentTimeStamp() );
+
+            {
+                // GENERATE RECOGNIZER
+                // Walk the AST holding the input grammar, this time generating code
+                // Decisions are generated by using the precomputed DFAs
+                // Fill in the various templates with data
+                CodeGenTreeWalker gen = new CodeGenTreeWalker( new Antlr.Runtime.Tree.CommonTreeNodeStream( grammar.Tree ) );
+                try
+                {
+                    gen.grammar_( grammar,
+                                recognizerST,
+                                outputFileST,
+                                headerFileST );
+                }
+                catch ( RecognitionException re )
+                {
+                    ErrorManager.error( ErrorManager.MSG_BAD_AST_STRUCTURE,
+                                       re );
+                }
+            }
+
+            genTokenTypeConstants( recognizerST );
+            genTokenTypeConstants( outputFileST );
+            genTokenTypeConstants( headerFileST );
+
+            if ( grammar.type != Grammar.LEXER )
+            {
+                genTokenTypeNames( recognizerST );
+                genTokenTypeNames( outputFileST );
+                genTokenTypeNames( headerFileST );
+            }
+
+            // Now that we know what synpreds are used, we can set into template
+            HashSet<string> synpredNames = null;
+            if ( grammar.synPredNamesUsedInDFA.Count > 0 )
+            {
+                synpredNames = grammar.synPredNamesUsedInDFA;
+            }
+            outputFileST.setAttribute( "synpreds", synpredNames );
+            headerFileST.setAttribute( "synpreds", synpredNames );
+
+            // all recognizers can see Grammar object
+            recognizerST.setAttribute( "grammar", grammar );
+
+            // WRITE FILES
+            try
+            {
+                target.genRecognizerFile( tool, this, grammar, outputFileST );
+                if ( templates.isDefined( "headerFile" ) )
+                {
+                    StringTemplate extST = templates.getInstanceOf( "headerFileExtension" );
+                    target.genRecognizerHeaderFile( tool, this, grammar, headerFileST, extST.ToString() );
+                }
+                // write out the vocab interchange file; used by antlr,
+                // does not change per target
+                StringTemplate tokenVocabSerialization = genTokenVocabOutput();
+                string vocabFileName = VocabFileName;
+                if ( vocabFileName != null )
+                {
+                    write( tokenVocabSerialization, vocabFileName );
+                }
+                //JSystem.@out.println(outputFileST.getDOTForDependencyGraph(false));
+            }
+            catch ( IOException ioe )
+            {
+                ErrorManager.error( ErrorManager.MSG_CANNOT_WRITE_FILE,
+                                   VocabFileName,
+                                   ioe );
+            }
+            /*
+            JSystem.@out.println("num obj.prop refs: "+ ASTExpr.totalObjPropRefs);
+            JSystem.@out.println("num reflection lookups: "+ ASTExpr.totalReflectionLookups);
+            */
+
+            return outputFileST;
+        }
+
+        /** Some targets will have some extra scopes like C++ may have
+         *  '@headerfile:name {action}' or something.  Make sure the
+         *  target likes the scopes in action table.
+         */
+        protected virtual void verifyActionScopesOkForTarget( IDictionary<string, IDictionary<string, object>> actions )
+        {
+            foreach ( var action in actions )
+            {
+                string scope = action.Key;
+                if ( !target.isValidActionScope( grammar.type, scope ) )
+                {
+                    // get any action from the scope to get error location
+                    var scopeActions = action.Value;
+                    GrammarAST actionAST = scopeActions.Values.Cast<GrammarAST>().First();
+                    ErrorManager.grammarError(
+                        ErrorManager.MSG_INVALID_ACTION_SCOPE, grammar,
+                        actionAST.Token, scope,
+                        grammar.GrammarTypeString );
+                }
+            }
+        }
+
+        /** Actions may reference $x::y attributes, call translateAction on
+         *  each action and replace that action in the Map.
+         */
+        protected virtual void translateActionAttributeReferences( IDictionary<string, IDictionary<string, object>> actions )
+        {
+            foreach ( var action in actions )
+            {
+                string scope = action.Key;
+                var scopeActions = action.Value;
+                translateActionAttributeReferencesForSingleScope( null, scopeActions );
+            }
+        }
+
+        /** Use for translating rule @init{...} actions that have no scope */
+        protected internal virtual void translateActionAttributeReferencesForSingleScope(
+            Rule r,
+            IDictionary<string,object> scopeActions )
+        {
+            string ruleName = null;
+            if ( r != null )
+            {
+                ruleName = r.name;
+            }
+            ICollection<string> actionNameSet = scopeActions.Keys.ToArray();
+            foreach ( string name in actionNameSet )
+            {
+                GrammarAST actionAST = (GrammarAST)scopeActions.get( name );
+                IList chunks = translateAction( ruleName, actionAST );
+                scopeActions[name] = chunks; // replace with translation
+            }
+        }
+
+        /** Error recovery in ANTLR recognizers.
+         *
+         *  Based upon original ideas:
+         *
+         *  Algorithms + Data Structures = Programs by Niklaus Wirth
+         *
+         *  and
+         *
+         *  A note on error recovery in recursive descent parsers:
+         *  http://portal.acm.org/citation.cfm?id=947902.947905
+         *
+         *  Later, Josef Grosch had some good ideas:
+         *  Efficient and Comfortable Error Recovery in Recursive Descent Parsers:
+         *  ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip
+         *
+         *  Like Grosch I implemented local FOLLOW sets that are combined at run-time
+         *  upon error to avoid parsing overhead.
+         */
+        public virtual void generateLocalFOLLOW( GrammarAST referencedElementNode,
+                                        string referencedElementName,
+                                        string enclosingRuleName,
+                                        int elementIndex )
+        {
+            /*
+            JSystem.@out.println("compute FOLLOW "+grammar.name+"."+referencedElementNode.toString()+
+                             " for "+referencedElementName+"#"+elementIndex +" in "+
+                             enclosingRuleName+
+                             " line="+referencedElementNode.getLine());
+                             */
+            NFAState followingNFAState = referencedElementNode.followingNFAState;
+            LookaheadSet follow = null;
+            if ( followingNFAState != null )
+            {
+                // compute follow for this element and, as side-effect, track
+                // the rule LOOK sensitivity.
+                follow = grammar.FIRST( followingNFAState );
+            }
+
+            if ( follow == null )
+            {
+                ErrorManager.internalError( "no follow state or cannot compute follow" );
+                follow = new LookaheadSet();
+            }
+            if ( follow.member( Label.EOF ) )
+            {
+                // TODO: can we just remove?  Seems needed here:
+                // compilation_unit : global_statement* EOF
+                // Actually i guess we resync to EOF regardless
+                follow.remove( Label.EOF );
+            }
+            //JSystem.@out.println(" "+follow);
+
+            IList tokenTypeList = null;
+            ulong[] words = null;
+            if ( follow.tokenTypeSet == null )
+            {
+                words = new ulong[1];
+                tokenTypeList = new List<object>();
+            }
+            else
+            {
+                BitSet bits = BitSet.of( follow.tokenTypeSet );
+                words = bits.toPackedArray();
+                tokenTypeList = follow.tokenTypeSet.ToList();
+            }
+            // use the target to convert to hex strings (typically)
+            string[] wordStrings = new string[words.Length];
+            for ( int j = 0; j < words.Length; j++ )
+            {
+                ulong w = words[j];
+                wordStrings[j] = target.getTarget64BitStringFromValue( w );
+            }
+            recognizerST.setAttribute( "bitsets.{name,inName,bits,tokenTypes,tokenIndex}",
+                    referencedElementName,
+                    enclosingRuleName,
+                    wordStrings,
+                    tokenTypeList,
+                    elementIndex );
+            outputFileST.setAttribute( "bitsets.{name,inName,bits,tokenTypes,tokenIndex}",
+                    referencedElementName,
+                    enclosingRuleName,
+                    wordStrings,
+                    tokenTypeList,
+                    elementIndex );
+            headerFileST.setAttribute( "bitsets.{name,inName,bits,tokenTypes,tokenIndex}",
+                    referencedElementName,
+                    enclosingRuleName,
+                    wordStrings,
+                    tokenTypeList,
+                    elementIndex );
+        }
+
+        // L O O K A H E A D  D E C I S I O N  G E N E R A T I O N
+
+        /** Generate code that computes the predicted alt given a DFA.  The
+         *  recognizerST can be either the main generated recognizerTemplate
+         *  for storage in the main parser file or a separate file.  It's up to
+         *  the code that ultimately invokes the codegen.g grammar rule.
+         *
+         *  Regardless, the output file and header file get a copy of the DFAs.
+         */
+        public virtual StringTemplate genLookaheadDecision( StringTemplate recognizerST,
+                                                   DFA dfa )
+        {
+            StringTemplate decisionST;
+            // If we are doing inline DFA and this one is acyclic and LL(*)
+            // I have to check for is-non-LL(*) because if non-LL(*) the cyclic
+            // check is not done by DFA.verify(); that is, verify() avoids
+            // doesStateReachAcceptState() if non-LL(*)
+            if ( dfa.CanInlineDecision )
+            {
+                decisionST =
+                    acyclicDFAGenerator.genFixedLookaheadDecision( Templates, dfa );
+            }
+            else
+            {
+                // generate any kind of DFA here (cyclic or acyclic)
+                dfa.createStateTables( this );
+                outputFileST.setAttribute( "cyclicDFAs", dfa );
+                headerFileST.setAttribute( "cyclicDFAs", dfa );
+                decisionST = templates.getInstanceOf( "dfaDecision" );
+                string description = dfa.NFADecisionStartState.Description;
+                description = target.getTargetStringLiteralFromString( description );
+                if ( description != null )
+                {
+                    decisionST.setAttribute( "description", description );
+                }
+                decisionST.setAttribute( "decisionNumber",
+                                        dfa.DecisionNumber );
+            }
+            return decisionST;
+        }
+
+        /** A special state is huge (too big for state tables) or has a predicated
+         *  edge.  Generate a simple if-then-else.  Cannot be an accept state as
+         *  they have no emanating edges.  Don't worry about switch vs if-then-else
+         *  because if you get here, the state is super complicated and needs an
+         *  if-then-else.  This is used by the new DFA scheme created June 2006.
+         */
+        public virtual StringTemplate generateSpecialState( DFAState s )
+        {
+            StringTemplate stateST;
+            stateST = templates.getInstanceOf( "cyclicDFAState" );
+            stateST.setAttribute( "needErrorClause", true );
+            stateST.setAttribute( "semPredState", s.IsResolvedWithPredicates );
+            stateST.setAttribute( "stateNumber", s.stateNumber );
+            stateST.setAttribute( "decisionNumber", s.dfa.decisionNumber );
+
+            bool foundGatedPred = false;
+            StringTemplate eotST = null;
+            for ( int i = 0; i < s.NumberOfTransitions; i++ )
+            {
+                Transition edge = (Transition)s.transition( i );
+                StringTemplate edgeST;
+                if ( edge.label.Atom == Label.EOT )
+                {
+                    // this is the default clause; has to held until last
+                    edgeST = templates.getInstanceOf( "eotDFAEdge" );
+                    stateST.removeAttribute( "needErrorClause" );
+                    eotST = edgeST;
+                }
+                else
+                {
+                    edgeST = templates.getInstanceOf( "cyclicDFAEdge" );
+                    StringTemplate exprST =
+                        genLabelExpr( templates, edge, 1 );
+                    edgeST.setAttribute( "labelExpr", exprST );
+                }
+                edgeST.setAttribute( "edgeNumber", i + 1 );
+                edgeST.setAttribute( "targetStateNumber",
+                                     edge.target.stateNumber );
+                // stick in any gated predicates for any edge if not already a pred
+                if ( !edge.label.IsSemanticPredicate )
+                {
+                    DFAState t = (DFAState)edge.target;
+                    SemanticContext preds = t.getGatedPredicatesInNFAConfigurations();
+                    if ( preds != null )
+                    {
+                        foundGatedPred = true;
+                        StringTemplate predST = preds.genExpr( this,
+                                                              Templates,
+                                                              t.dfa );
+                        edgeST.setAttribute( "predicates", predST.ToString() );
+                    }
+                }
+                if ( edge.label.Atom != Label.EOT )
+                {
+                    stateST.setAttribute( "edges", edgeST );
+                }
+            }
+            if ( foundGatedPred )
+            {
+                // state has >= 1 edge with a gated pred (syn or sem)
+                // must rewind input first, set flag.
+                stateST.setAttribute( "semPredState", foundGatedPred );
+            }
+            if ( eotST != null )
+            {
+                stateST.setAttribute( "edges", eotST );
+            }
+            return stateST;
+        }
+
+        /** Generate an expression for traversing an edge. */
+        protected internal virtual StringTemplate genLabelExpr( StringTemplateGroup templates,
+                                              Transition edge,
+                                              int k )
+        {
+            Label label = edge.label;
+            if ( label.IsSemanticPredicate )
+            {
+                return genSemanticPredicateExpr( templates, edge );
+            }
+            if ( label.IsSet )
+            {
+                return genSetExpr( templates, label.Set, k, true );
+            }
+            // must be simple label
+            StringTemplate eST = templates.getInstanceOf( "lookaheadTest" );
+            eST.setAttribute( "atom", getTokenTypeAsTargetLabel( label.Atom ) );
+            eST.setAttribute( "atomAsInt", label.Atom );
+            eST.setAttribute( "k", k );
+            return eST;
+        }
+
+        protected internal virtual StringTemplate genSemanticPredicateExpr( StringTemplateGroup templates,
+                                                          Transition edge )
+        {
+            DFA dfa = ( (DFAState)edge.target ).dfa; // which DFA are we in
+            Label label = edge.label;
+            SemanticContext semCtx = label.SemanticContext;
+            return semCtx.genExpr( this, templates, dfa );
+        }
+
+        /** For intervals such as [3..3, 30..35], generate an expression that
+         *  tests the lookahead similar to LA(1)==3 || (LA(1)>=30&&LA(1)<=35)
+         */
+        public virtual StringTemplate genSetExpr( StringTemplateGroup templates,
+                                         IIntSet set,
+                                         int k,
+                                         bool partOfDFA )
+        {
+            if ( !( set is IntervalSet ) )
+            {
+                throw new ArgumentException( "unable to generate expressions for non IntervalSet objects" );
+            }
+            IntervalSet iset = (IntervalSet)set;
+            if ( iset.Intervals == null || iset.Intervals.Count == 0 )
+            {
+                StringTemplate emptyST = new StringTemplate( templates, "" );
+                emptyST.setName( "empty-set-expr" );
+                return emptyST;
+            }
+            string testSTName = "lookaheadTest";
+            string testRangeSTName = "lookaheadRangeTest";
+            if ( !partOfDFA )
+            {
+                testSTName = "isolatedLookaheadTest";
+                testRangeSTName = "isolatedLookaheadRangeTest";
+            }
+            StringTemplate setST = templates.getInstanceOf( "setTest" );
+            int rangeNumber = 1;
+            foreach ( Interval I in iset.getIntervals() )
+            {
+                int a = I.a;
+                int b = I.b;
+                StringTemplate eST;
+                if ( a == b )
+                {
+                    eST = templates.getInstanceOf( testSTName );
+                    eST.setAttribute( "atom", getTokenTypeAsTargetLabel( a ) );
+                    eST.setAttribute( "atomAsInt", a );
+                    //eST.setAttribute("k",Utils.integer(k));
+                }
+                else
+                {
+                    eST = templates.getInstanceOf( testRangeSTName );
+                    eST.setAttribute( "lower", getTokenTypeAsTargetLabel( a ) );
+                    eST.setAttribute( "lowerAsInt", a );
+                    eST.setAttribute( "upper", getTokenTypeAsTargetLabel( b ) );
+                    eST.setAttribute( "upperAsInt", b );
+                    eST.setAttribute( "rangeNumber", rangeNumber );
+                }
+                eST.setAttribute( "k", k );
+                setST.setAttribute( "ranges", eST );
+                rangeNumber++;
+            }
+            return setST;
+        }
+
+        // T O K E N  D E F I N I T I O N  G E N E R A T I O N
+
+        /** Set attributes tokens and literals attributes in the incoming
+         *  code template.  This is not the token vocab interchange file, but
+         *  rather a list of token type ID needed by the recognizer.
+         */
+        protected virtual void genTokenTypeConstants( StringTemplate code )
+        {
+            // make constants for the token types
+            foreach ( string tokenID in grammar.TokenIDs )
+            {
+                int tokenType = grammar.getTokenType( tokenID );
+                if ( tokenType == Label.EOF ||
+                     tokenType >= Label.MIN_TOKEN_TYPE )
+                {
+                    // don't do FAUX labels 'cept EOF
+                    code.setAttribute( "tokens.{name,type}", tokenID, tokenType );
+                }
+            }
+        }
+
+        /** Generate a token names table that maps token type to a printable
+         *  name: either the label like INT or the literal like "begin".
+         */
+        protected virtual void genTokenTypeNames( StringTemplate code )
+        {
+            for ( int t = Label.MIN_TOKEN_TYPE; t <= grammar.MaxTokenType; t++ )
+            {
+                string tokenName = grammar.getTokenDisplayName( t );
+                if ( tokenName != null )
+                {
+                    tokenName = target.getTargetStringLiteralFromString( tokenName, true );
+                    code.setAttribute( "tokenNames", tokenName );
+                }
+            }
+        }
+
+        /** Get a meaningful name for a token type useful during code generation.
+         *  Literals without associated names are converted to the string equivalent
+         *  of their integer values. Used to generate x==ID and x==34 type comparisons
+         *  etc...  Essentially we are looking for the most obvious way to refer
+         *  to a token type in the generated code.  If in the lexer, return the
+         *  char literal translated to the target language.  For example, ttype=10
+         *  will yield '\n' from the getTokenDisplayName method.  That must
+         *  be converted to the target languages literals.  For most C-derived
+         *  languages no translation is needed.
+         */
+        public virtual string getTokenTypeAsTargetLabel( int ttype )
+        {
+            if ( grammar.type == Grammar.LEXER )
+            {
+                string name = grammar.getTokenDisplayName( ttype );
+                return target.getTargetCharLiteralFromANTLRCharLiteral( this, name );
+            }
+            return target.getTokenTypeAsTargetLabel( this, ttype );
+        }
+
+        /** Generate a token vocab file with all the token names/types.  For example:
+         *  ID=7
+         *  FOR=8
+         *  'for'=8
+         *
+         *  This is independent of the target language; used by antlr internally
+         */
+        protected virtual StringTemplate genTokenVocabOutput()
+        {
+            StringTemplate vocabFileST =
+                new StringTemplate( vocabFilePattern,
+                                   typeof( AngleBracketTemplateLexer ) );
+            vocabFileST.setName( "vocab-file" );
+            // make constants for the token names
+            foreach ( string tokenID in grammar.TokenIDs )
+            {
+                int tokenType = grammar.getTokenType( tokenID );
+                if ( tokenType >= Label.MIN_TOKEN_TYPE )
+                {
+                    vocabFileST.setAttribute( "tokens.{name,type}", tokenID, tokenType );
+                }
+            }
+
+            // now dump the strings
+            foreach ( string literal in grammar.StringLiterals )
+            {
+                int tokenType = grammar.getTokenType( literal );
+                if ( tokenType >= Label.MIN_TOKEN_TYPE )
+                {
+                    vocabFileST.setAttribute( "tokens.{name,type}", literal, tokenType );
+                }
+            }
+
+            return vocabFileST;
+        }
+
+        public virtual IList translateAction( string ruleName,
+                                    GrammarAST actionTree )
+        {
+            if ( actionTree.Type == ANTLRParser.ARG_ACTION )
+            {
+                return translateArgAction( ruleName, actionTree );
+            }
+            ActionTranslator translator = new ActionTranslator( this, ruleName, actionTree );
+            IList chunks = translator.translateToChunks();
+            chunks = target.postProcessAction( chunks, actionTree.token );
+            return chunks;
+        }
+
+        /** Translate an action like [3,"foo",a[3]] and return a List of the
+         *  translated actions.  Because actions are themselves translated to a list
+         *  of chunks, must cat together into a StringTemplate>.  Don't translate
+         *  to strings early as we need to eval templates in context.
+         */
+        public virtual List<StringTemplate> translateArgAction( string ruleName,
+                                               GrammarAST actionTree )
+        {
+            string actionText = actionTree.token.Text;
+            List<string> args = getListOfArgumentsFromAction( actionText, ',' );
+            List<StringTemplate> translatedArgs = new List<StringTemplate>();
+            foreach ( string arg in args )
+            {
+                if ( arg != null )
+                {
+                    IToken actionToken =
+                        new CommonToken( ANTLRParser.ACTION, arg );
+                    ActionTranslator translator =
+                        new ActionTranslator( this, ruleName,
+                                                  actionToken,
+                                                  actionTree.outerAltNum );
+                    IList chunks = translator.translateToChunks();
+                    chunks = target.postProcessAction( chunks, actionToken );
+                    StringTemplate catST = new StringTemplate( templates, "<chunks>" );
+                    catST.setAttribute( "chunks", chunks );
+                    templates.createStringTemplate();
+                    translatedArgs.Add( catST );
+                }
+            }
+            if ( translatedArgs.Count == 0 )
+            {
+                return null;
+            }
+            return translatedArgs;
+        }
+
+        public static List<string> getListOfArgumentsFromAction( string actionText,
+                                                                int separatorChar )
+        {
+            List<string> args = new List<string>();
+            getListOfArgumentsFromAction( actionText, 0, -1, separatorChar, args );
+            return args;
+        }
+
+        /** Given an arg action like
+         *
+         *  [x, (*a).foo(21,33), 3.2+1, '\n',
+         *  "a,oo\nick", {bl, "fdkj"eck}, ["cat\n,", x, 43]]
+         *
+         *  convert to a list of arguments.  Allow nested square brackets etc...
+         *  Set separatorChar to ';' or ',' or whatever you want.
+         */
+        public static int getListOfArgumentsFromAction( string actionText,
+                                                       int start,
+                                                       int targetChar,
+                                                       int separatorChar,
+                                                       IList<string> args )
+        {
+            if ( actionText == null )
+            {
+                return -1;
+            }
+            actionText = actionText.replaceAll( "//.*\n", "" );
+            int n = actionText.Length;
+            //JSystem.@out.println("actionText@"+start+"->"+(char)targetChar+"="+actionText.substring(start,n));
+            int p = start;
+            int last = p;
+            while ( p < n && actionText[p] != targetChar )
+            {
+                int c = actionText[p];
+                switch ( c )
+                {
+                case '\'':
+                    p++;
+                    while ( p < n && actionText[p] != '\'' )
+                    {
+                        if ( actionText[p] == '\\' && ( p + 1 ) < n &&
+                             actionText[p + 1] == '\'' )
+                        {
+                            p++; // skip escaped quote
+                        }
+                        p++;
+                    }
+                    p++;
+                    break;
+                case '"':
+                    p++;
+                    while ( p < n && actionText[p] != '\"' )
+                    {
+                        if ( actionText[p] == '\\' && ( p + 1 ) < n &&
+                             actionText[p + 1] == '\"' )
+                        {
+                            p++; // skip escaped quote
+                        }
+                        p++;
+                    }
+                    p++;
+                    break;
+                case '(':
+                    p = getListOfArgumentsFromAction( actionText, p + 1, ')', separatorChar, args );
+                    break;
+                case '{':
+                    p = getListOfArgumentsFromAction( actionText, p + 1, '}', separatorChar, args );
+                    break;
+                case '<':
+                    if ( actionText.IndexOf( '>', p + 1 ) >= p )
+                    {
+                        // do we see a matching '>' ahead?  if so, hope it's a generic
+                        // and not less followed by expr with greater than
+                        p = getListOfArgumentsFromAction( actionText, p + 1, '>', separatorChar, args );
+                    }
+                    else
+                    {
+                        p++; // treat as normal char
+                    }
+                    break;
+                case '[':
+                    p = getListOfArgumentsFromAction( actionText, p + 1, ']', separatorChar, args );
+                    break;
+                default:
+                    if ( c == separatorChar && targetChar == -1 )
+                    {
+                        string arg = actionText.Substring( last, p - last );
+                        //JSystem.@out.println("arg="+arg);
+                        args.Add( arg.Trim() );
+                        last = p + 1;
+                    }
+                    p++;
+                    break;
+                }
+            }
+            if ( targetChar == -1 && p <= n )
+            {
+                string arg = actionText.Substring( last, p - last ).Trim();
+                //JSystem.@out.println("arg="+arg);
+                if ( arg.Length > 0 )
+                {
+                    args.Add( arg.Trim() );
+                }
+            }
+            p++;
+            return p;
+        }
+
+        /** Given a template constructor action like %foo(a={...}) in
+         *  an action, translate it to the appropriate template constructor
+         *  from the templateLib. This translates a *piece* of the action.
+         */
+        public virtual StringTemplate translateTemplateConstructor( string ruleName,
+                                                           int outerAltNum,
+                                                           IToken actionToken,
+                                                           string templateActionText )
+        {
+            GrammarAST rewriteTree = null;
+
+            {
+                // first, parse with antlr.g
+                //JSystem.@out.println("translate template: "+templateActionText);
+                ANTLRLexer lexer = new ANTLRLexer( new Antlr.Runtime.ANTLRStringStream( templateActionText ) );
+                lexer.Filename = grammar.FileName;
+                //lexer.setTokenObjectClass( "antlr.TokenWithIndex" );
+                //TokenStreamRewriteEngine tokenBuffer = new TokenStreamRewriteEngine( lexer );
+                //tokenBuffer.discard( ANTLRParser.WS );
+                //tokenBuffer.discard( ANTLRParser.ML_COMMENT );
+                //tokenBuffer.discard( ANTLRParser.COMMENT );
+                //tokenBuffer.discard( ANTLRParser.SL_COMMENT );
+                ANTLRParser parser = new ANTLRParser( new Antlr.Runtime.CommonTokenStream( lexer ) );
+                parser.FileName = grammar.FileName;
+                //parser.setASTNodeClass( "org.antlr.tool.GrammarAST" );
+                try
+                {
+                    ANTLRParser.rewrite_template_return result = parser.rewrite_template();
+                    rewriteTree = (GrammarAST)result.Tree;
+                }
+                catch ( RecognitionException /*re*/ )
+                {
+                    ErrorManager.grammarError( ErrorManager.MSG_INVALID_TEMPLATE_ACTION,
+                                                  grammar,
+                                                  actionToken,
+                                                  templateActionText );
+                }
+                catch ( Exception tse )
+                {
+                    ErrorManager.internalError( "can't parse template action", tse );
+                }
+            }
+
+            {
+                // then translate via codegen.g
+                CodeGenTreeWalker gen = new CodeGenTreeWalker( new Antlr.Runtime.Tree.CommonTreeNodeStream( rewriteTree ) );
+                gen.init( grammar );
+                gen.currentRuleName = ruleName;
+                gen.outerAltNum = outerAltNum;
+                StringTemplate st = null;
+                try
+                {
+                    st = gen.rewrite_template();
+                }
+                catch ( RecognitionException re )
+                {
+                    ErrorManager.error( ErrorManager.MSG_BAD_AST_STRUCTURE,
+                                       re );
+                }
+                return st;
+            }
+        }
+
+
+        public virtual void issueInvalidScopeError( string x,
+                                           string y,
+                                           Rule enclosingRule,
+                                           IToken actionToken,
+                                           int outerAltNum )
+        {
+            //JSystem.@out.println("error $"+x+"::"+y);
+            Rule r = grammar.getRule( x );
+            AttributeScope scope = grammar.getGlobalScope( x );
+            if ( scope == null )
+            {
+                if ( r != null )
+                {
+                    scope = r.ruleScope; // if not global, might be rule scope
+                }
+            }
+            if ( scope == null )
+            {
+                ErrorManager.grammarError( ErrorManager.MSG_UNKNOWN_DYNAMIC_SCOPE,
+                                              grammar,
+                                              actionToken,
+                                              x );
+            }
+            else if ( scope.getAttribute( y ) == null )
+            {
+                ErrorManager.grammarError( ErrorManager.MSG_UNKNOWN_DYNAMIC_SCOPE_ATTRIBUTE,
+                                              grammar,
+                                              actionToken,
+                                              x,
+                                              y );
+            }
+        }
+
+        public virtual void issueInvalidAttributeError( string x,
+                                               string y,
+                                               Rule enclosingRule,
+                                               IToken actionToken,
+                                               int outerAltNum )
+        {
+            //JSystem.@out.println("error $"+x+"."+y);
+            if ( enclosingRule == null )
+            {
+                // action not in a rule
+                ErrorManager.grammarError( ErrorManager.MSG_ATTRIBUTE_REF_NOT_IN_RULE,
+                                              grammar,
+                                              actionToken,
+                                              x,
+                                              y );
+                return;
+            }
+
+            // action is in a rule
+            Grammar.LabelElementPair label = enclosingRule.getRuleLabel( x );
+
+            if ( label != null || enclosingRule.getRuleRefsInAlt( x, outerAltNum ) != null )
+            {
+                // $rulelabel.attr or $ruleref.attr; must be unknown attr
+                string refdRuleName = x;
+                if ( label != null )
+                {
+                    refdRuleName = enclosingRule.getRuleLabel( x ).referencedRuleName;
+                }
+                Rule refdRule = grammar.getRule( refdRuleName );
+                AttributeScope scope = refdRule.getAttributeScope( y );
+                if ( scope == null )
+                {
+                    ErrorManager.grammarError( ErrorManager.MSG_UNKNOWN_RULE_ATTRIBUTE,
+                                              grammar,
+                                              actionToken,
+                                              refdRuleName,
+                                              y );
+                }
+                else if ( scope.isParameterScope )
+                {
+                    ErrorManager.grammarError( ErrorManager.MSG_INVALID_RULE_PARAMETER_REF,
+                                              grammar,
+                                              actionToken,
+                                              refdRuleName,
+                                              y );
+                }
+                else if ( scope.isDynamicRuleScope )
+                {
+                    ErrorManager.grammarError( ErrorManager.MSG_INVALID_RULE_SCOPE_ATTRIBUTE_REF,
+                                              grammar,
+                                              actionToken,
+                                              refdRuleName,
+                                              y );
+                }
+            }
+
+        }
+
+        public virtual void issueInvalidAttributeError( string x,
+                                               Rule enclosingRule,
+                                               IToken actionToken,
+                                               int outerAltNum )
+        {
+            //JSystem.@out.println("error $"+x);
+            if ( enclosingRule == null )
+            {
+                // action not in a rule
+                ErrorManager.grammarError( ErrorManager.MSG_ATTRIBUTE_REF_NOT_IN_RULE,
+                                              grammar,
+                                              actionToken,
+                                              x );
+                return;
+            }
+
+            // action is in a rule
+            Grammar.LabelElementPair label = enclosingRule.getRuleLabel( x );
+            AttributeScope scope = enclosingRule.getAttributeScope( x );
+
+            if ( label != null ||
+                 enclosingRule.getRuleRefsInAlt( x, outerAltNum ) != null ||
+                 enclosingRule.name.Equals( x ) )
+            {
+                ErrorManager.grammarError( ErrorManager.MSG_ISOLATED_RULE_SCOPE,
+                                              grammar,
+                                              actionToken,
+                                              x );
+            }
+            else if ( scope != null && scope.isDynamicRuleScope )
+            {
+                ErrorManager.grammarError( ErrorManager.MSG_ISOLATED_RULE_ATTRIBUTE,
+                                              grammar,
+                                              actionToken,
+                                              x );
+            }
+            else
+            {
+                ErrorManager.grammarError( ErrorManager.MSG_UNKNOWN_SIMPLE_ATTRIBUTE,
+                                          grammar,
+                                          actionToken,
+                                          x );
+            }
+        }
+
+        // M I S C
+
+        public virtual StringTemplateGroup getTemplates()
+        {
+            return templates;
+        }
+
+        public virtual StringTemplateGroup getBaseTemplates()
+        {
+            return baseTemplates;
+        }
+
+        public virtual void setDebug( bool debug )
+        {
+            this.debug = debug;
+        }
+
+        public virtual void setTrace( bool trace )
+        {
+            this.trace = trace;
+        }
+
+        public virtual void setProfile( bool profile )
+        {
+            this.profile = profile;
+            if ( profile )
+            {
+                setDebug( true ); // requires debug events
+            }
+        }
+
+        public virtual StringTemplate getRecognizerST()
+        {
+            return outputFileST;
+        }
+
+        /** Generate TParser.java and TLexer.java from T.g if combined, else
+         *  just use T.java as output regardless of type.
+         */
+        public virtual string getRecognizerFileName( string name, int type )
+        {
+            StringTemplate extST = templates.getInstanceOf( "codeFileExtension" );
+            string recognizerName = grammar.getRecognizerName();
+            return recognizerName + extST.ToString();
+            /*
+            String suffix = "";
+            if ( type==Grammar.COMBINED ||
+                 (type==Grammar.LEXER && !grammar.implicitLexer) )
+            {
+                suffix = Grammar.grammarTypeToFileNameSuffix[type];
+            }
+            return name+suffix+extST.toString();
+            */
+        }
+
+        /** What is the name of the vocab file generated for this grammar?
+         *  Returns null if no .tokens file should be generated.
+         */
+        public virtual string getVocabFileName()
+        {
+            if ( grammar.IsBuiltFromString )
+            {
+                return null;
+            }
+            return grammar.name + VOCAB_FILE_EXTENSION;
+        }
+
+        public virtual void write( StringTemplate code, string fileName )
+        {
+            DateTime start = DateTime.Now;
+            TextWriter w = tool.getOutputFile( grammar, fileName );
+            // Write the output to a StringWriter
+            IStringTemplateWriter wr = templates.getStringTemplateWriter( w );
+            wr.setLineWidth( lineWidth );
+            code.write( wr );
+            w.Close();
+            DateTime stop = DateTime.Now;
+            //JSystem.@out.println("render time for "+fileName+": "+(int)(stop-start)+"ms");
+        }
+
+        /** You can generate a switch rather than if-then-else for a DFA state
+         *  if there are no semantic predicates and the number of edge label
+         *  values is small enough; e.g., don't generate a switch for a state
+         *  containing an edge label such as 20..52330 (the resulting byte codes
+         *  would overflow the method 65k limit probably).
+         */
+        protected internal virtual bool canGenerateSwitch( DFAState s )
+        {
+            if ( !GENERATE_SWITCHES_WHEN_POSSIBLE )
+            {
+                return false;
+            }
+            int size = 0;
+            for ( int i = 0; i < s.NumberOfTransitions; i++ )
+            {
+                Transition edge = (Transition)s.transition( i );
+                if ( edge.label.IsSemanticPredicate )
+                {
+                    return false;
+                }
+                // can't do a switch if the edges are going to require predicates
+                if ( edge.label.Atom == Label.EOT )
+                {
+                    int EOTPredicts = ( (DFAState)edge.target ).getUniquelyPredictedAlt();
+                    if ( EOTPredicts == NFA.INVALID_ALT_NUMBER )
+                    {
+                        // EOT target has to be a predicate then; no unique alt
+                        return false;
+                    }
+                }
+                // if target is a state with gated preds, we need to use preds on
+                // this edge then to reach it.
+                if ( ( (DFAState)edge.target ).getGatedPredicatesInNFAConfigurations() != null )
+                {
+                    return false;
+                }
+                size += edge.label.Set.size();
+            }
+            if ( s.NumberOfTransitions < MIN_SWITCH_ALTS ||
+                 size > MAX_SWITCH_CASE_LABELS )
+            {
+                return false;
+            }
+            return true;
+        }
+
+        /** Create a label to track a token / rule reference's result.
+         *  Technically, this is a place where I break model-view separation
+         *  as I am creating a variable name that could be invalid in a
+         *  target language, however, label ::= <ID><INT> is probably ok in
+         *  all languages we care about.
+         */
+        public virtual string createUniqueLabel( string name )
+        {
+            return name + ( uniqueLabelNumber++ );
+            //return new StringBuffer()
+            //    .append( name ).append( uniqueLabelNumber++ ).toString();
+        }
+    }
+}
diff --git a/Antlr3/Codegen/Target.cs b/Antlr3/Codegen/Target.cs
new file mode 100644
index 0000000..7d9870c
--- /dev/null
+++ b/Antlr3/Codegen/Target.cs
@@ -0,0 +1,419 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Codegen
+{
+    using Antlr.Runtime.JavaExtensions;
+
+    using AntlrTool = Antlr3.AntlrTool;
+    using Character = java.lang.Character;
+    using Grammar = Antlr3.Tool.Grammar;
+    using IList = System.Collections.IList;
+    using IToken = Antlr.Runtime.IToken;
+    using Label = Antlr3.Analysis.Label;
+    using StringBuilder = System.Text.StringBuilder;
+    using StringTemplate = Antlr3.ST.StringTemplate;
+
+    /** The code generator for ANTLR can usually be retargeted just by providing
+     *  a new X.stg file for language X, however, sometimes the files that must
+     *  be generated vary enough that some X-specific functionality is required.
+     *  For example, in C, you must generate header files whereas in Java you do not.
+     *  Other languages may want to keep DFA separate from the main
+     *  generated recognizer file.
+     *
+     *  The notion of a Code Generator target abstracts out the creation
+     *  of the various files.  As new language targets get added to the ANTLR
+     *  system, this target class may have to be altered to handle more
+     *  functionality.  Eventually, just about all language generation issues
+     *  will be expressible in terms of these methods.
+     *
+     *  If org.antlr.codegen.XTarget class exists, it is used else
+     *  Target base class is used.  I am using a superclass rather than an
+     *  interface for this target concept because I can add functionality
+     *  later without breaking previously written targets (extra interface
+     *  methods would force adding dummy functions to all code generator
+     *  target classes).
+     *
+     */
+    public abstract class Target
+    {
+        /** For pure strings of Java 16-bit unicode char, how can we display
+         *  it in the target language as a literal.  Useful for dumping
+         *  predicates and such that may refer to chars that need to be escaped
+         *  when represented as strings.  Also, templates need to be escaped so
+         *  that the target language can hold them as a string.
+         *
+         *  I have defined (via the constructor) the set of typical escapes,
+         *  but your Target subclass is free to alter the translated chars or
+         *  add more definitions.  This is nonstatic so each target can have
+         *  a different set in memory at same time.
+         */
+        protected string[] targetCharValueEscape = new string[255];
+
+        public Target()
+        {
+            targetCharValueEscape['\n'] = "\\n";
+            targetCharValueEscape['\r'] = "\\r";
+            targetCharValueEscape['\t'] = "\\t";
+            targetCharValueEscape['\b'] = "\\b";
+            targetCharValueEscape['\f'] = "\\f";
+            targetCharValueEscape['\\'] = "\\\\";
+            targetCharValueEscape['\''] = "\\'";
+            targetCharValueEscape['"'] = "\\\"";
+        }
+
+        protected internal virtual void genRecognizerFile( AntlrTool tool,
+                                         CodeGenerator generator,
+                                         Grammar grammar,
+                                         StringTemplate outputFileST )
+        {
+            string fileName =
+                generator.getRecognizerFileName( grammar.name, grammar.type );
+            generator.write( outputFileST, fileName );
+        }
+
+        protected internal virtual void genRecognizerHeaderFile( AntlrTool tool,
+                                               CodeGenerator generator,
+                                               Grammar grammar,
+                                               StringTemplate headerFileST,
+                                               string extName ) // e.g., ".h"
+        {
+            // no header file by default
+        }
+
+        protected internal virtual void performGrammarAnalysis( CodeGenerator generator,
+                                              Grammar grammar )
+        {
+            // Build NFAs from the grammar AST
+            grammar.buildNFA();
+
+            // Create the DFA predictors for each decision
+            grammar.createLookaheadDFAs();
+        }
+
+        /** Is scope in @scope::name {action} valid for this kind of grammar?
+         *  Targets like C++ may want to allow new scopes like headerfile or
+         *  some such.  The action names themselves are not policed at the
+         *  moment so targets can add template actions w/o having to recompile
+         *  ANTLR.
+         */
+        public virtual bool isValidActionScope( int grammarType, string scope )
+        {
+            switch ( grammarType )
+            {
+            case Grammar.LEXER:
+                if ( scope.Equals( "lexer" ) )
+                {
+                    return true;
+                }
+                break;
+            case Grammar.PARSER:
+                if ( scope.Equals( "parser" ) )
+                {
+                    return true;
+                }
+                break;
+            case Grammar.COMBINED:
+                if ( scope.Equals( "parser" ) )
+                {
+                    return true;
+                }
+                if ( scope.Equals( "lexer" ) )
+                {
+                    return true;
+                }
+                break;
+            case Grammar.TREE_PARSER:
+                if ( scope.Equals( "treeparser" ) )
+                {
+                    return true;
+                }
+                break;
+            }
+            return false;
+        }
+
+        /** Target must be able to override the labels used for token types */
+        public virtual string getTokenTypeAsTargetLabel( CodeGenerator generator, int ttype )
+        {
+            string name = generator.grammar.getTokenDisplayName( ttype );
+            // If name is a literal, return the token type instead
+            if ( name[0] == '\'' )
+            {
+                return ttype.ToString(); //String.valueOf( ttype );
+            }
+            return name;
+        }
+
+        /** Convert from an ANTLR char literal found in a grammar file to
+         *  an equivalent char literal in the target language.  For most
+         *  languages, this means leaving 'x' as 'x'.  Actually, we need
+         *  to escape '\u000A' so that it doesn't get converted to \n by
+         *  the compiler.  Convert the literal to the char value and then
+         *  to an appropriate target char literal.
+         *
+         *  Expect single quotes around the incoming literal.
+         */
+        public virtual string getTargetCharLiteralFromANTLRCharLiteral(
+            CodeGenerator generator,
+            string literal )
+        {
+            StringBuilder buf = new StringBuilder();
+            buf.Append( '\'' );
+            int c = Grammar.getCharValueFromGrammarCharLiteral( literal );
+            if ( c < Label.MIN_CHAR_VALUE )
+            {
+                return "'\u0000'";
+            }
+            if ( c < targetCharValueEscape.Length &&
+                 targetCharValueEscape[c] != null )
+            {
+                buf.Append( targetCharValueEscape[c] );
+            }
+            else if ( Character.UnicodeBlock.of( (char)c ) ==
+                      Character.UnicodeBlock.BASIC_LATIN &&
+                      !Character.isISOControl( (char)c ) )
+            {
+                // normal char
+                buf.Append( (char)c );
+            }
+            else
+            {
+                // must be something unprintable...use \\uXXXX
+                // turn on the bit above max "\\uFFFF" value so that we pad with zeros
+                // then only take last 4 digits
+                string hex = c.ToString( "X4" );
+                buf.Append( "\\u" );
+                buf.Append( hex );
+            }
+
+            buf.Append( '\'' );
+            return buf.ToString();
+        }
+
+        /** Convert from an ANTLR string literal found in a grammar file to
+         *  an equivalent string literal in the target language.  For Java, this
+         *  is the translation 'a\n"' -> "a\n\"".  Expect single quotes
+         *  around the incoming literal.  Just flip the quotes and replace
+         *  double quotes with \"
+         *
+         *  Note that we have decided to allow poeple to use '\"' without
+         *  penalty, so we must build the target string in a loop as Utils.replae
+         *  cannot handle both \" and " without a lot of messing around.
+         *
+         */
+        public virtual string getTargetStringLiteralFromANTLRStringLiteral(
+            CodeGenerator generator,
+            string literal )
+        {
+            StringBuilder sb = new StringBuilder();
+            StringBuilder @is = new StringBuilder( literal );
+
+            // Opening quote
+            //
+            sb.Append( '"' );
+
+            for ( int i = 1; i < @is.Length - 1; i++ )
+            {
+
+                if ( @is[i] == '\\' )
+                {
+
+                    // Anything escaped is what it is! We assume that
+                    // people know how to escape characters correctly. However
+                    // we catch anything that does not need an escape in Java (which
+                    // is what the default implementation is dealing with and remove
+                    // the escape. The C target does this for instance.
+                    //
+                    switch ( @is[i + 1] )
+                    {
+
+                    // Pass through any escapes that Java also needs
+                    //
+                    case '"':
+                    case 'n':
+                    case 'r':
+                    case 't':
+                    case 'b':
+                    case 'f':
+                    case '\\':
+                    case 'u':    // Assume unnnn
+
+                        sb.Append( '\\' );    // Pass the escape through
+                        break;
+
+                    default:
+
+                        // Remove the escape by virtue of not adding it here
+                        // Thus \' becomes ' and so on
+                        //
+                        break;
+                    }
+
+                    // Go past the \ character
+                    //
+                    i++;
+
+                }
+                else
+                {
+
+                    // Chracters that don't need \ in ANTLR 'strings' but do in Java
+                    //
+                    if ( @is[i] == '"' )
+                    {
+
+                        // We need to escape " in Java
+                        //
+                        sb.Append( '\\' );
+                    }
+                }
+
+                // Add in the next character, which may have been escaped
+                //
+                sb.Append( @is[i] );
+            }
+
+            // Append closing " and return
+            //
+            sb.Append( '"' );
+
+            return sb.ToString();
+        }
+
+        /** Given a random string of Java unicode chars, return a new string with
+         *  optionally appropriate quote characters for target language and possibly
+         *  with some escaped characters.  For example, if the incoming string has
+         *  actual newline characters, the output of this method would convert them
+         *  to the two char sequence \n for Java, C, C++, ...  The new string has
+         *  double-quotes around it as well.  Example String in memory:
+         *
+         *     a"[newlinechar]b'c[carriagereturnchar]d[tab]e\f
+         *
+         *  would be converted to the valid Java s:
+         *
+         *     "a\"\nb'c\rd\te\\f"
+         *
+         *  or
+         *
+         *     a\"\nb'c\rd\te\\f
+         *
+         *  depending on the quoted arg.
+         */
+        public virtual string getTargetStringLiteralFromString( string s, bool quoted )
+        {
+            if ( s == null )
+            {
+                return null;
+            }
+            StringBuilder buf = new StringBuilder();
+            if ( quoted )
+            {
+                buf.Append( '"' );
+            }
+            for ( int i = 0; i < s.Length; i++ )
+            {
+                int c = s[i];
+                if ( c != '\'' && // don't escape single quotes in strings for java
+                     c < targetCharValueEscape.Length &&
+                     targetCharValueEscape[c] != null )
+                {
+                    buf.Append( targetCharValueEscape[c] );
+                }
+                else
+                {
+                    buf.Append( (char)c );
+                }
+            }
+            if ( quoted )
+            {
+                buf.Append( '"' );
+            }
+            return buf.ToString();
+        }
+
+        public virtual string getTargetStringLiteralFromString( string s )
+        {
+            return getTargetStringLiteralFromString( s, false );
+        }
+
+        /** Convert long to 0xNNNNNNNNNNNNNNNN by default for spitting out
+         *  with bitsets.  I.e., convert bytes to hex string.
+         */
+        public virtual string getTarget64BitStringFromValue( ulong word )
+        {
+            int numHexDigits = 8 * 2;
+            StringBuilder buf = new StringBuilder( numHexDigits + 2 );
+            buf.Append( "0x" );
+            //String digits = Long.toHexString( word );
+            //digits = digits.toUpperCase();
+            string digits = word.ToString( "X" );
+            int padding = numHexDigits - digits.Length;
+            // pad left with zeros
+            for ( int i = 1; i <= padding; i++ )
+            {
+                buf.Append( '0' );
+            }
+            buf.Append( digits );
+            return buf.ToString();
+        }
+
+        public virtual string encodeIntAsCharEscape( int v )
+        {
+            if ( v <= 127 )
+            {
+                return "\\" + java.lang.Integer.toOctalString( v );
+            }
+            //String hex = Integer.toHexString( v | 0x10000 ).substring( 1, 5 );
+            string hex = v.ToString( "x4" );
+            return "\\u" + hex;
+        }
+
+        /** Some targets only support ASCII or 8-bit chars/strings.  For example,
+         *  C++ will probably want to return 0xFF here.
+         */
+        public virtual int getMaxCharValue( CodeGenerator generator )
+        {
+            return Label.MAX_CHAR_VALUE;
+        }
+
+        /** Give target a chance to do some postprocessing on actions.
+         *  Python for example will have to fix the indention.
+         */
+        public virtual IList postProcessAction( IList chunks, IToken actionToken )
+        {
+            return chunks;
+        }
+
+    }
+
+}
diff --git a/Antlr3/Extensions/EnumerableExtensions.cs b/Antlr3/Extensions/EnumerableExtensions.cs
new file mode 100644
index 0000000..797ce99
--- /dev/null
+++ b/Antlr3/Extensions/EnumerableExtensions.cs
@@ -0,0 +1,55 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+
+namespace Antlr3.Extensions
+{
+    public static class EnumerableExtensions
+    {
+        public static T Reduce<T>( this IEnumerable<T> source, Func<T, T, T> func )
+        {
+            return source.Skip( 1 ).Aggregate( source.FirstOrDefault(), func );
+        }
+
+        public static bool SequenceEqual<T>( this IEnumerable<T> first, IEnumerable<T> second, Func<T, T, bool> comparer )
+        {
+            return first.SequenceEqual( second, new FuncEqualityComparer<T>( comparer ) );
+        }
+        public static bool SequenceEqual<T>( this IEnumerable<T> first, IEnumerable<T> second, Func<T, T, bool> comparer, Func<T, int> hash )
+        {
+            return first.SequenceEqual( second, new FuncEqualityComparer<T>( comparer, hash ) );
+        }
+    }
+}
diff --git a/Antlr3/Extensions/FuncEqualityComparer.cs b/Antlr3/Extensions/FuncEqualityComparer.cs
new file mode 100644
index 0000000..d8ba412
--- /dev/null
+++ b/Antlr3/Extensions/FuncEqualityComparer.cs
@@ -0,0 +1,63 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Collections.Generic;
+
+namespace Antlr3.Extensions
+{
+    public class FuncEqualityComparer<T> : IEqualityComparer<T>
+    {
+        Func<T, T, bool> _comparer;
+        Func<T, int> _hash;
+
+        public FuncEqualityComparer( Func<T, T, bool> comparer )
+        {
+            _comparer = comparer;
+            _hash = t => t.GetHashCode();
+        }
+        public FuncEqualityComparer( Func<T, T, bool> comparer, Func<T, int> hash )
+        {
+            _comparer = comparer;
+            _hash = hash;
+        }
+
+        public bool Equals( T x, T y )
+        {
+            return _comparer( x, y );
+        }
+        public int GetHashCode( T obj )
+        {
+            return _hash( obj );
+        }
+    }
+}
diff --git a/Antlr3/Extensions/ListExtensions.cs b/Antlr3/Extensions/ListExtensions.cs
new file mode 100644
index 0000000..c74dd37
--- /dev/null
+++ b/Antlr3/Extensions/ListExtensions.cs
@@ -0,0 +1,413 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+
+namespace Antlr3.Extensions
+{
+    public static class ListExtensions
+    {
+        public static IList<T> CastList<T>( this System.Collections.IList list )
+        {
+            return new CastListView<T>( list );
+        }
+
+        public static IList<T> CastList<T, TSource>( this IList<TSource> list )
+            where TSource : T
+        {
+            return new CastListView<T, TSource>( list );
+        }
+
+        public static IList<T> CastListDown<T, TSource>( this IList<TSource> list )
+            where T : TSource
+        {
+            return new DownCastListView<T, TSource>( list );
+        }
+
+        class CastListView<T> : IList<T>
+        {
+            System.Collections.IList _source;
+
+            public CastListView( System.Collections.IList source )
+            {
+                _source = source;
+            }
+
+            #region IList<T> Members
+
+            public int IndexOf( T item )
+            {
+                return _source.IndexOf( item );
+            }
+
+            public void Insert( int index, T item )
+            {
+                _source.Insert( index, item );
+            }
+
+            public void RemoveAt( int index )
+            {
+                _source.RemoveAt( index );
+            }
+
+            public T this[int index]
+            {
+                get
+                {
+                    return (T)_source[index];
+                }
+                set
+                {
+                    _source[index] = value;
+                }
+            }
+
+            #endregion
+
+            #region ICollection<T> Members
+
+            public void Add( T item )
+            {
+                _source.Add( item );
+            }
+
+            public void Clear()
+            {
+                _source.Clear();
+            }
+
+            public bool Contains( T item )
+            {
+                return _source.Contains( item );
+            }
+
+            public void CopyTo( T[] array, int arrayIndex )
+            {
+                _source.CopyTo( array, arrayIndex );
+            }
+
+            public int Count
+            {
+                get
+                {
+                    return _source.Count;
+                }
+            }
+
+            public bool IsReadOnly
+            {
+                get
+                {
+                    return _source.IsReadOnly;
+                }
+            }
+
+            public bool Remove( T item )
+            {
+                int index = _source.IndexOf( item );
+                if ( index < 0 )
+                    return false;
+
+                _source.RemoveAt( index );
+                return true;
+            }
+
+            #endregion
+
+            #region IEnumerable<T> Members
+
+            public IEnumerator<T> GetEnumerator()
+            {
+                return _source.Cast<T>().GetEnumerator();
+            }
+
+            #endregion
+
+            #region IEnumerable Members
+
+            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
+            {
+                return _source.GetEnumerator();
+            }
+
+            #endregion
+        }
+
+        class CastListView<T, TSource> : IList<T>
+            where TSource : T
+        {
+            IList<TSource> _source;
+
+            public CastListView( IList<TSource> source )
+            {
+                _source = source;
+            }
+
+            #region IList<T> Members
+
+            public int IndexOf( T item )
+            {
+                return _source.IndexOf( (TSource)item );
+            }
+
+            public void Insert( int index, T item )
+            {
+                _source.Insert( index, (TSource)item );
+            }
+
+            public void RemoveAt( int index )
+            {
+                _source.RemoveAt( index );
+            }
+
+            public T this[int index]
+            {
+                get
+                {
+                    return (T)_source[index];
+                }
+                set
+                {
+                    _source[index] = (TSource)value;
+                }
+            }
+
+            #endregion
+
+            #region ICollection<T> Members
+
+            public void Add( T item )
+            {
+                _source.Add( (TSource)item );
+            }
+
+            public void Clear()
+            {
+                _source.Clear();
+            }
+
+            public bool Contains( T item )
+            {
+                return _source.Contains( (TSource)item );
+            }
+
+            public void CopyTo( T[] array, int arrayIndex )
+            {
+                System.Collections.IList source = _source as System.Collections.IList;
+                if ( source != null )
+                {
+                    source.CopyTo( array, arrayIndex );
+                }
+                else
+                {
+                    if ( array == null )
+                        throw new ArgumentNullException( "array" );
+
+                    if ( arrayIndex < 0 )
+                        throw new ArgumentOutOfRangeException( "arrayIndex" );
+
+                    if ( _source.Count + arrayIndex >= array.Length )
+                        throw new ArgumentException();
+
+                    for ( int i = 0; i < _source.Count; i++ )
+                        array[arrayIndex + i] = (T)_source[i];
+                }
+            }
+
+            public int Count
+            {
+                get
+                {
+                    return _source.Count;
+                }
+            }
+
+            public bool IsReadOnly
+            {
+                get
+                {
+                    return _source.IsReadOnly;
+                }
+            }
+
+            public bool Remove( T item )
+            {
+                return _source.Remove( (TSource)item );
+            }
+
+            #endregion
+
+            #region IEnumerable<T> Members
+
+            public IEnumerator<T> GetEnumerator()
+            {
+                return _source.Cast<T>().GetEnumerator();
+            }
+
+            #endregion
+
+            #region IEnumerable Members
+
+            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
+            {
+                return _source.GetEnumerator();
+            }
+
+            #endregion
+        }
+
+        class DownCastListView<T, TSource> : IList<T>
+            where T : TSource
+        {
+            IList<TSource> _source;
+
+            public DownCastListView( IList<TSource> source )
+            {
+                _source = source;
+            }
+
+            #region IList<T> Members
+
+            public int IndexOf( T item )
+            {
+                return _source.IndexOf( (TSource)item );
+            }
+
+            public void Insert( int index, T item )
+            {
+                _source.Insert( index, (TSource)item );
+            }
+
+            public void RemoveAt( int index )
+            {
+                _source.RemoveAt( index );
+            }
+
+            public T this[int index]
+            {
+                get
+                {
+                    return (T)_source[index];
+                }
+                set
+                {
+                    _source[index] = (TSource)value;
+                }
+            }
+
+            #endregion
+
+            #region ICollection<T> Members
+
+            public void Add( T item )
+            {
+                _source.Add( (TSource)item );
+            }
+
+            public void Clear()
+            {
+                _source.Clear();
+            }
+
+            public bool Contains( T item )
+            {
+                return _source.Contains( (TSource)item );
+            }
+
+            public void CopyTo( T[] array, int arrayIndex )
+            {
+                System.Collections.IList source = _source as System.Collections.IList;
+                if ( source != null )
+                {
+                    source.CopyTo( array, arrayIndex );
+                }
+                else
+                {
+                    if ( array == null )
+                        throw new ArgumentNullException( "array" );
+
+                    if ( arrayIndex < 0 )
+                        throw new ArgumentOutOfRangeException( "arrayIndex" );
+
+                    if ( _source.Count + arrayIndex >= array.Length )
+                        throw new ArgumentException();
+
+                    for ( int i = 0; i < _source.Count; i++ )
+                        array[arrayIndex + i] = (T)_source[i];
+                }
+            }
+
+            public int Count
+            {
+                get
+                {
+                    return _source.Count;
+                }
+            }
+
+            public bool IsReadOnly
+            {
+                get
+                {
+                    return _source.IsReadOnly;
+                }
+            }
+
+            public bool Remove( T item )
+            {
+                return _source.Remove( (TSource)item );
+            }
+
+            #endregion
+
+            #region IEnumerable<T> Members
+
+            public IEnumerator<T> GetEnumerator()
+            {
+                return _source.Cast<T>().GetEnumerator();
+            }
+
+            #endregion
+
+            #region IEnumerable Members
+
+            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
+            {
+                return _source.GetEnumerator();
+            }
+
+            #endregion
+        }
+    }
+}
diff --git a/Antlr3/Grammars/ANTLR.g3 b/Antlr3/Grammars/ANTLR.g3
new file mode 100644
index 0000000..d434426
--- /dev/null
+++ b/Antlr3/Grammars/ANTLR.g3
@@ -0,0 +1,1133 @@
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/** Read in an ANTLR grammar and build an AST.  Try not to do
+ *  any actions, just build the tree.
+ *
+ *  The phases are:
+ *
+ *		antlr.g (this file)
+ *		assign.types.g
+ *		define.g
+ *		buildnfa.g
+ *		antlr.print.g (optional)
+ *		codegen.g
+ *
+ *  Terence Parr
+ *  University of San Francisco
+ *  2005
+ */
+
+grammar ANTLR;
+
+options
+{
+	language=CSharp3;
+	output=AST;
+	ASTLabelType=GrammarAST;
+}
+
+tokens
+{
+	//OPTIONS='options';
+	//TOKENS='tokens';
+	LEXER='lexer';
+	PARSER='parser';
+	CATCH='catch';
+	FINALLY='finally';
+	GRAMMAR='grammar';
+	PRIVATE='private';
+	PROTECTED='protected';
+	PUBLIC='public';
+	RETURNS='returns';
+	THROWS='throws';
+	TREE='tree';
+
+	RULE;
+	BLOCK;
+	OPTIONAL;
+	CLOSURE;
+	POSITIVE_CLOSURE;
+	SYNPRED;
+	RANGE;
+	CHAR_RANGE;
+	EPSILON;
+	ALT;
+	EOR;
+	EOB;
+	EOA; // end of alt
+	ID;
+	ARG;
+	ARGLIST;
+	RET;
+	LEXER_GRAMMAR;
+	PARSER_GRAMMAR;
+	TREE_GRAMMAR;
+	COMBINED_GRAMMAR;
+	INITACTION;
+	FORCED_ACTION; // {{...}} always exec even during syn preds
+	LABEL; // $x used in rewrite rules
+	TEMPLATE;
+	SCOPE='scope';
+	IMPORT='import';
+	GATED_SEMPRED; // {p}? =>
+	SYN_SEMPRED; // (...) =>   it's a manually-specified synpred converted to sempred
+	BACKTRACK_SEMPRED; // auto backtracking mode syn pred converted to sempred
+	FRAGMENT='fragment';
+	DOT;
+}
+
+@lexer::header
+{
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+using ErrorManager = Antlr3.Tool.ErrorManager;
+using Grammar = Antlr3.Tool.Grammar;
+using StringBuffer = System.Text.StringBuilder;
+}
+
+@parser::header {
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+using ErrorManager = Antlr3.Tool.ErrorManager;
+using Grammar = Antlr3.Tool.Grammar;
+using GrammarAST = Antlr3.Tool.GrammarAST;
+using IntSet = Antlr3.Misc.IIntSet;
+using StringBuffer = System.Text.StringBuilder;
+using TokenWithIndex = Antlr.Runtime.CommonToken;
+}
+
+@lexer::namespace{Antlr3.Grammars}
+@parser::namespace{Antlr3.Grammars}
+
+public
+grammar_![Grammar g]
+@init
+{
+	this.Grammar = g;
+	IDictionary<string, object> opts;
+}
+@after
+{
+	cleanup( $tree );
+}
+	:	//hdr:headerSpec
+		( ACTION )?
+		( cmt=DOC_COMMENT  )?
+		gr=grammarType gid=id {Grammar.setName($gid.text);} SEMI
+		(	optionsSpec {opts = $optionsSpec.opts; Grammar.setOptions(opts, $optionsSpec.start);}
+		)?
+		(ig=delegateGrammars)?
+		(ts=tokensSpec)?
+		scopes=attrScopes
+		(a=actions)?
+		r=rules
+		EOF
+		-> ^($gr $gid $cmt? optionsSpec? $ig? $ts? $scopes? $a? $r)
+	;
+
+grammarType
+	:	(	'lexer'  gr='grammar' {GrammarType=LEXER_GRAMMAR; Grammar.type = Grammar.LEXER;}       // pure lexer
+			-> LEXER_GRAMMAR[$gr]
+		|	'parser' gr='grammar' {GrammarType=PARSER_GRAMMAR; Grammar.type = Grammar.PARSER;}     // pure parser
+			-> PARSER_GRAMMAR[$gr]
+		|	'tree'   gr='grammar' {GrammarType=TREE_GRAMMAR; Grammar.type = Grammar.TREE_PARSER;}  // a tree parser
+			-> TREE_GRAMMAR[$gr]
+		|			 gr='grammar' {GrammarType=COMBINED_GRAMMAR; Grammar.type = Grammar.COMBINED;} // merged parser/lexer
+			-> COMBINED_GRAMMAR[$gr]
+		)
+	;
+
+actions
+	:	(action)+
+	;
+
+/** Match stuff like @parser::members {int i;} */
+action
+	:	AMPERSAND^ (actionScopeName COLON! COLON!)? id ACTION
+	;
+
+/** Sometimes the scope names will collide with keywords; allow them as
+ *  ids for action scopes.
+ */
+actionScopeName
+	:	id
+	|	l='lexer'
+		-> ID[l]
+	|	p='parser'
+		-> ID[p]
+	;
+
+optionsSpec returns [IDictionary<string, object> opts=new Dictionary<string, object>()]
+	:	OPTIONS^ (option[$opts] SEMI!)+ RCURLY!
+	;
+
+option[IDictionary<string, object> opts]
+	:	id ASSIGN^ optionValue
+		{
+			$opts[$id.text] = $optionValue.value;
+		}
+	;
+
+optionValue returns [object value=null]
+	:	x=id			 {$value = $x.text;}
+	|	s=STRING_LITERAL {string vs = $s.text;
+						  // remove the quotes:
+						  $value=vs.Substring(1,vs.Length-2);}
+	|	c=CHAR_LITERAL   {string vs = $c.text;
+						  // remove the quotes:
+						  $value=vs.Substring(1,vs.Length-2);}
+	|	i=INT            {$value = int.Parse($i.text);}
+	|	ss=STAR			 {$value = "*";} // used for k=*
+		-> STRING_LITERAL[$ss]
+//	|	cs:charSet       {value = #cs;} // return set AST in this case
+	;
+
+delegateGrammars
+	:	'import'^ delegateGrammar (COMMA! delegateGrammar)* SEMI!
+	;
+
+delegateGrammar
+	:	lab=id ASSIGN^ g=id {Grammar.importGrammar($g.tree, $lab.text);}
+	|	g2=id               {Grammar.importGrammar($g2.tree,null);}
+	;
+
+tokensSpec
+	:	TOKENS^
+			( tokenSpec	)+
+		RCURLY!
+	;
+
+tokenSpec
+	:	TOKEN_REF ( ASSIGN^ (STRING_LITERAL|CHAR_LITERAL) )? SEMI!
+	;
+
+attrScopes
+	:	(attrScope)*
+	;
+
+attrScope
+	:	'scope'^ id ruleActions? ACTION
+	;
+
+rules
+	:	(	rule
+		)+
+	;
+
+public
+rule
+@init
+{
+	GrammarAST eob=null;
+	int start = ((CommonToken)LT(1)).TokenIndex;
+	int startLine = LT(1).Line;
+}
+	:
+	(	(	d=DOC_COMMENT
+		)?
+		(	p1='protected'	//{modifier=$p1.tree;}
+		|	p2='public'		//{modifier=$p2.tree;}
+		|	p3='private'	//{modifier=$p3.tree;}
+		|	p4='fragment'	//{modifier=$p4.tree;}
+		)?
+		ruleName=id
+		{
+			currentRuleName=$ruleName.text;
+			if ( GrammarType==LEXER_GRAMMAR && $p4==null )
+				Grammar.lexerRuleNamesInCombined.Add(currentRuleName);
+		}
+		( BANG )?
+		( aa=ARG_ACTION )?
+		( 'returns' rt=ARG_ACTION  )?
+		( throwsSpec )?
+		( optionsSpec )?
+		scopes=ruleScopeSpec
+		(ruleActions)?
+		COLON
+		altList[$optionsSpec.opts]
+		SEMI
+		( ex=exceptionGroup )?
+		->	^(	RULE["rule"]
+				^($ruleName)
+				// the modifier will be 0 or one of the modifiers:
+				$p1? $p2? $p3? $p4?
+				^(ARG["ARG"] $aa?)
+				^(RET["RET"] $rt?)
+				throwsSpec?
+				optionsSpec?
+				^($scopes)
+				ruleActions?
+				altList
+				$ex?
+				EOR[$SEMI,"<end-of-rule>"])
+	)
+	{
+		((GrammarAST)$tree.GetChild(0)).setBlockOptions( $optionsSpec.opts );
+	}
+	;
+
+ruleActions
+	:	(ruleAction)+
+	;
+
+/** Match stuff like @init {int i;} */
+ruleAction
+	:	AMPERSAND^ id ACTION
+	;
+
+throwsSpec
+	:	'throws'^ id ( COMMA! id )*
+	;
+
+ruleScopeSpec
+	:	( 'scope' ruleActions? ACTION )?
+		( 'scope' idList SEMI )*
+		-> ^(SCOPE[$start,"scope"] ruleActions? ACTION? idList*)
+	;
+
+/** Build #(BLOCK ( #(ALT ...) EOB )+ ) */
+block
+@init
+{
+	GrammarAST save = currentBlockAST;
+	Map opts=null;
+}
+	:	(	lp=LPAREN
+			-> BLOCK[$lp,"BLOCK"]
+		)
+		{currentBlockAST = (GrammarAST)$tree.GetChild(0);}
+		(
+			// 2nd alt and optional branch ambig due to
+			// linear approx LL(2) issue.  COLON ACTION
+			// matched correctly in 2nd alt.
+			(optionsSpec {((GrammarAST)$tree.GetChild(0)).setOptions(Grammar,$optionsSpec.opts);})?
+			( ruleActions )?
+			COLON
+		|	ACTION COLON
+		)?
+
+		a=alternative r=rewrite
+		{
+			stream_alternative.Add( $r.tree );
+			if ( LA(1)==OR || (LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR) )
+				prefixWithSynPred($a.tree);
+		}
+		(	OR a=alternative r=rewrite
+			{
+				stream_alternative.Add( $r.tree );
+				if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR))
+					prefixWithSynPred($a.tree);
+			}
+		)*
+
+		rp=RPAREN
+		-> ^($block optionsSpec? ruleActions? ACTION? alternative+ EOB[$rp,"<end-of-block>"])
+	;
+finally { currentBlockAST = save; }
+
+altList[IDictionary<string, object> opts]
+@init
+{
+	GrammarAST blkRoot = null;
+	GrammarAST save = currentBlockAST;
+}
+	:	( -> BLOCK[$start,"BLOCK"] )
+		{
+			blkRoot = (GrammarAST)$tree.GetChild(0);
+			blkRoot.setBlockOptions( $opts );
+			currentBlockAST = blkRoot;
+		}
+		(	a1=alternative r1=rewrite
+			{if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR)) prefixWithSynPred($a1.tree);}
+			-> $a1 $r1?
+		)
+		(	OR a2=alternative r2=rewrite
+			{if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR)) prefixWithSynPred($a2.tree);}
+			-> $altList $a2 $r2?
+		)*
+		-> ^({blkRoot} $altList EOB["<end-of-block>"])
+	;
+finally { currentBlockAST = save; }
+
+alternative
+@init
+{
+	GrammarAST eoa = null;
+	GrammarAST altRoot = null;
+}
+	:	( -> EOA["<end-of-alt>"] )
+		{ eoa = $tree; }
+		( -> ALT[$start,"ALT"] )
+		{ altRoot = $tree; }
+
+		(	( el+=element )+
+			-> ^({altRoot} $el+ {eoa})
+		|
+			-> ^({altRoot} EPSILON[$start,"epsilon"] {eoa})
+		)
+	;
+
+exceptionGroup
+	:	( exceptionHandler )+ ( finallyClause )?
+	|	finallyClause
+	;
+
+exceptionHandler
+	:	'catch'^ ARG_ACTION ACTION
+	;
+
+finallyClause
+	:	'finally'^ ACTION
+	;
+
+element
+	:	elementNoOptionSpec
+	;
+
+elementNoOptionSpec
+@init
+{
+	IntSet elements=null;
+}
+	:	(	(	id (ASSIGN^|PLUS_ASSIGN^) (atom|block)
+			)
+			(	sub=ebnfSuffix[root_0,false]! {root_0 = $sub.tree;}
+			)?
+		|	a=atom
+			(	sub2=ebnfSuffix[$a.tree,false]! {root_0=$sub2.tree;}
+			)?
+		|	ebnf
+		|	FORCED_ACTION
+		|	ACTION
+		|	p=SEMPRED ( IMPLIES! {$p.Type = GATED_SEMPRED;} )?
+			{
+			Grammar.blocksWithSemPreds.Add(currentBlockAST);
+			}
+		|	t3=tree_
+		)
+	;
+
+atom
+	:	range (ROOT^|BANG^)?
+	|	(
+			// grammar.rule but ensure no spaces. "A . B" is not a qualified ref
+			// We do here rather than lexer so we can build a tree
+			({LT(1).CharPositionInLine+LT(1).Text.Length==LT(2).CharPositionInLine&&
+			 LT(2).CharPositionInLine+1==LT(3).CharPositionInLine}? id WILDCARD (terminal|ruleref)) =>
+			id w=WILDCARD^ (terminal|ruleref) {$w.Type = DOT;}
+		|	terminal
+		|	ruleref
+		)
+	|	notSet (ROOT^|BANG^)?
+	;
+
+ruleref
+	:	rr=RULE_REF^ ( ARG_ACTION )? (ROOT^|BANG^)?
+	;
+
+notSet
+	:	NOT^
+		(	notTerminal
+		|	block
+		)
+	;
+
+treeRoot
+	:	{atTreeRoot=true;}
+		(	id (ASSIGN^|PLUS_ASSIGN^) (atom|block)
+		|	atom
+		|	block
+		)
+		{atTreeRoot=false;}
+	;
+
+tree_
+	:	TREE_BEGIN^
+		treeRoot ( element )+
+		RPAREN!
+	;
+
+/** matches ENBF blocks (and sets via block rule) */
+ebnf
+	:	block
+		(	QUESTION
+			-> ^(OPTIONAL[$start,"?"] block)
+		|	STAR
+			-> ^(CLOSURE[$start,"*"] block)
+		|	PLUS
+			-> ^(POSITIVE_CLOSURE[$start,"+"] block)
+		|	IMPLIES // syntactic predicate
+			// ignore for lexer rules in combined
+			-> {GrammarType == COMBINED_GRAMMAR && char.IsUpper(currentRuleName[0])}? ^(SYNPRED[$start,"=>"] block)
+			// create manually specified (...)=> predicate; convert to sempred
+			-> {createSynSemPredFromBlock($block.tree, SYN_SEMPRED)}
+		|	ROOT
+			-> ^(ROOT block)
+		|	BANG
+			-> ^(BANG block)
+		|
+			-> block
+		)
+	;
+
+range
+	:	c1=CHAR_LITERAL RANGE c2=CHAR_LITERAL
+		-> ^(CHAR_RANGE[$c1,".."] $c1 $c2)
+	;
+
+terminal
+	:	cl=CHAR_LITERAL^ ( elementOptions[$cl.tree]! )? (ROOT^|BANG^)?
+
+	|	tr=TOKEN_REF^
+		( elementOptions[$tr.tree]! )?
+		( ARG_ACTION )? // Args are only valid for lexer rules
+		(ROOT^|BANG^)?
+
+	|	sl=STRING_LITERAL^ ( elementOptions[$sl.tree]! )? (ROOT^|BANG^)?
+
+	|	wi=WILDCARD (ROOT^|BANG^)?
+		{
+			if ( atTreeRoot )
+			{
+				ErrorManager.syntaxError(
+					ErrorManager.MSG_WILDCARD_AS_ROOT,Grammar,$wi,null,null);
+			}
+		}
+	;
+
+elementOptions[GrammarAST terminalAST]
+	:	OPEN_ELEMENT_OPTION^ defaultNodeOption[terminalAST] CLOSE_ELEMENT_OPTION!
+	|	OPEN_ELEMENT_OPTION^ elementOption[terminalAST] (SEMI! elementOption[terminalAST])* CLOSE_ELEMENT_OPTION!
+	;
+
+defaultNodeOption[GrammarAST terminalAST]
+@init
+{
+StringBuffer buf = new StringBuffer();
+}
+	:	i=id {buf.Append($i.text);} (WILDCARD i2=id {buf.Append("."+$i2.text);})*
+		{terminalAST.setTerminalOption(Grammar,Grammar.defaultTokenOption,buf.ToString());}
+	;
+
+elementOption[GrammarAST terminalAST]
+	:	a=id ASSIGN^ (b=id|s=STRING_LITERAL)
+		{
+		object v = ($b.tree!=null)?$b.text:$s.text;
+		terminalAST.setTerminalOption(Grammar,$a.text,v);
+		}
+	;
+
+ebnfSuffix[GrammarAST elemAST, bool inRewrite]
+@init
+{
+GrammarAST blkRoot=null;
+GrammarAST alt=null;
+GrammarAST save = currentBlockAST;
+}
+@after
+{
+currentBlockAST = save;
+}
+	:	(	-> BLOCK["BLOCK"]
+		)
+		{ blkRoot = (GrammarAST)$tree.GetChild(0); currentBlockAST = blkRoot; }
+		(	// create alt
+			-> ^(ALT["ALT"] {$elemAST} EOA["<end-of-alt>"])
+		)
+		{
+			alt = (GrammarAST)$tree.GetChild(0);
+			if ( !inRewrite )
+				prefixWithSynPred(alt);
+		}
+		(	QUESTION
+			-> OPTIONAL[$elemAST.Token,"?"]
+		|	STAR
+			-> CLOSURE[$elemAST.Token,"*"]
+		|	PLUS
+			-> POSITIVE_CLOSURE[$elemAST.Token,"+"]
+		)
+		-> ^($ebnfSuffix ^({blkRoot} {alt} EOB[$elemAST.Token, "<end-of-block>"]))
+	;
+
+notTerminal
+	:	cl=CHAR_LITERAL
+	|	tr=TOKEN_REF
+	|	STRING_LITERAL
+	;
+
+idList
+	:	id (COMMA! id)*
+	;
+
+id
+	:	TOKEN_REF
+		-> ID[$TOKEN_REF]
+	|	RULE_REF
+		-> ID[$RULE_REF]
+	;
+
+// R E W R I T E  S Y N T A X
+
+rewrite
+	:	rewrite_with_sempred*
+		REWRITE rewrite_alternative
+		-> rewrite_with_sempred* ^(REWRITE rewrite_alternative)
+	|
+	;
+
+rewrite_with_sempred
+	:	REWRITE^ SEMPRED rewrite_alternative
+	;
+
+rewrite_block
+	:	LPAREN
+		rewrite_alternative
+		RPAREN
+		-> ^(BLOCK[$LPAREN,"BLOCK"] rewrite_alternative EOB[$RPAREN,"<end-of-block>"])
+	;
+
+rewrite_alternative
+options{k=1;}
+	:	{Grammar.BuildTemplate}? => rewrite_template
+
+	|	{Grammar.BuildAST}? => ( rewrite_element )+
+		-> {!stream_rewrite_element.HasNext}? ^(ALT[LT(1),"ALT"] EPSILON["epsilon"] EOA["<end-of-alt>"])
+		-> ^(ALT[LT(1),"ALT"] rewrite_element+ EOA["<end-of-alt>"])
+
+	|
+		-> ^(ALT[LT(1),"ALT"] EPSILON["epsilon"] EOA["<end-of-alt>"])
+	|	{Grammar.BuildAST}? ETC
+	;
+
+rewrite_element
+	:	(	t=rewrite_atom
+			-> $t
+		)
+		(	subrule=ebnfSuffix[$t.tree,true]
+			-> $subrule
+		)?
+	|	rewrite_ebnf
+	|	(	tr=rewrite_tree
+			-> $tr
+		)
+		(	subrule=ebnfSuffix[$tr.tree,true]
+			-> $subrule
+		)?
+	;
+
+rewrite_atom
+@init
+{
+GrammarAST subrule=null;
+}
+	:	(	tr=TOKEN_REF
+			-> $tr
+		)
+		(elementOptions[(GrammarAST)$tree.GetChild(0)])? (ARG_ACTION)? // for imaginary nodes
+		-> ^($rewrite_atom ARG_ACTION?)
+	|	rr=RULE_REF
+	|	(	cl=CHAR_LITERAL
+			-> $cl
+		)
+		(elementOptions[(GrammarAST)$tree.GetChild(0)])?
+	|	(	sl=STRING_LITERAL
+			-> $sl
+		)
+		(eo=elementOptions[(GrammarAST)$tree.GetChild(0)])?
+	|	d=DOLLAR i=id // reference to a label in a rewrite rule
+		-> LABEL[$i.start,$i.text]
+	|	ACTION
+	;
+
+rewrite_ebnf
+	:	b=rewrite_block
+		(	QUESTION
+			-> ^(OPTIONAL[$b.start,"?"] $b)
+		|	STAR
+			-> ^(CLOSURE[$b.start,"*"] $b)
+		|	PLUS
+			-> ^(POSITIVE_CLOSURE[$b.start,"+"] $b)
+		)
+	;
+
+rewrite_tree
+	:	TREE_BEGIN^
+			rewrite_atom ( rewrite_element )*
+		RPAREN!
+	;
+
+/** Build a tree for a template rewrite:
+	  ^(TEMPLATE (ID|ACTION) ^(ARGLIST ^(ARG ID ACTION) ...) )
+	where ARGLIST is always there even if no args exist.
+	ID can be "template" keyword.  If first child is ACTION then it's
+	an indirect template ref
+
+	-> foo(a={...}, b={...})
+	-> ({string-e})(a={...}, b={...})  // e evaluates to template name
+	-> {%{$ID.text}} // create literal template from string (done in ActionTranslator)
+	-> {st-expr} // st-expr evaluates to ST
+ */
+public
+rewrite_template
+options{k=1;}
+	:	// -> template(a={...},...) "..."
+		{LT(1).Text.Equals("template")}? => // inline
+		(	rewrite_template_head
+			-> rewrite_template_head
+		)
+		( st=DOUBLE_QUOTE_STRING_LITERAL | st=DOUBLE_ANGLE_STRING_LITERAL )
+		{ adaptor.AddChild( $tree.GetChild(0), adaptor.Create($st) ); }
+
+	|	// -> foo(a={...}, ...)
+		rewrite_template_head
+
+	|	// -> ({expr})(a={...}, ...)
+		rewrite_indirect_template_head
+
+	|	// -> {...}
+		ACTION
+	;
+
+/** -> foo(a={...}, ...) */
+rewrite_template_head
+	:	id lp=LPAREN
+		rewrite_template_args
+		RPAREN
+		-> ^(TEMPLATE[$lp,"TEMPLATE"] id rewrite_template_args)
+	;
+
+/** -> ({expr})(a={...}, ...) */
+rewrite_indirect_template_head
+	:	lp=LPAREN
+		ACTION
+		RPAREN
+		LPAREN rewrite_template_args RPAREN
+		-> ^(TEMPLATE[$lp,"TEMPLATE"] ACTION rewrite_template_args)
+	;
+
+rewrite_template_args
+	:	rewrite_template_arg (COMMA rewrite_template_arg)*
+		-> ^(ARGLIST["ARGLIST"] rewrite_template_arg+)
+	|
+		-> ARGLIST["ARGLIST"]
+	;
+
+rewrite_template_arg
+	:	id a=ASSIGN ACTION
+		-> ^(ARG[$a,"ARG"] id ACTION)
+	;
+
+//////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////
+// L E X E R
+
+// get rid of warnings:
+fragment STRING_LITERAL : ;
+fragment FORCED_ACTION : ;
+fragment DOC_COMMENT : ;
+fragment SEMPRED : ;
+
+WS
+	:	(	' '
+		|	'\t'
+		|	('\r')? '\n'
+		)
+		{ $channel = HIDDEN; }
+	;
+
+COMMENT
+	:	( SL_COMMENT | ML_COMMENT[ref $type] )
+		{
+			if ( $type != DOC_COMMENT )
+				$channel = HIDDEN;
+		}
+	;
+
+fragment
+SL_COMMENT
+	:	'//'
+		(	(' $ANTLR') => ' $ANTLR ' SRC (('\r')? '\n')? // src directive
+		|	~('\r'|'\n')* (('\r')? '\n')?
+		)
+	;
+
+fragment
+ML_COMMENT[ref int type]
+@init
+{
+	$type = ML_COMMENT;
+}
+	:	'/*'
+		(	('*' ~'/') => '*' {$type = DOC_COMMENT;}
+		|
+		)
+		(	('*' ~'/') => '*'
+		|	~'*'
+		)*
+		'*/'
+	;
+
+OPEN_ELEMENT_OPTION
+	:	'<'
+	;
+
+CLOSE_ELEMENT_OPTION
+	:	'>'
+	;
+
+AMPERSAND : '@';
+
+COMMA : ',';
+
+QUESTION :	'?' ;
+
+TREE_BEGIN : '^(' ;
+
+LPAREN:	'(' ;
+
+RPAREN:	')' ;
+
+COLON :	':' ;
+
+STAR:	'*' ;
+
+PLUS:	'+' ;
+
+ASSIGN : '=' ;
+
+PLUS_ASSIGN : '+=' ;
+
+IMPLIES : '=>' ;
+
+REWRITE : '->' ;
+
+SEMI:	';' ;
+
+ROOT : '^' {hasASTOperator=true;} ;
+
+BANG : '!' {hasASTOperator=true;} ;
+
+OR	:	'|' ;
+
+WILDCARD : '.' ;
+
+ETC : '...' ;
+
+RANGE : '..' ;
+
+NOT :	'~' ;
+
+RCURLY:	'}'	;
+
+DOLLAR : '$' ;
+
+STRAY_BRACKET
+	:	']'
+		{
+			ErrorManager.syntaxError(
+				ErrorManager.MSG_SYNTAX_ERROR,
+				null,
+				state.token,
+				"antlr: dangling ']'? make sure to escape with \\]",
+				null);
+		}
+	;
+
+CHAR_LITERAL
+	:	'\''
+		(	ESC
+		|	~('\\'|'\'')
+		)*
+		'\''
+		{
+			StringBuffer s = Grammar.getUnescapedStringFromGrammarStringLiteral($text);
+			if ( s.Length > 1 )
+			{
+				$type = STRING_LITERAL;
+			}
+		}
+	;
+
+DOUBLE_QUOTE_STRING_LITERAL
+@init
+{
+	System.Text.StringBuilder builder = new System.Text.StringBuilder();
+}
+	:	'"'							{builder.Append('"');}
+		(	('\\\"') => '\\' '"'	{builder.Append('"');}
+		|	'\\' c=~'"'				{builder.Append("\\" + (char)$c);}
+		|	c=~('\\'|'"')			{builder.Append((char)$c);}
+		)*
+		'"'							{builder.Append('"');}
+		{
+			Text = builder.ToString();
+		}
+	;
+
+DOUBLE_ANGLE_STRING_LITERAL
+	:	'<<'
+		(	~'>'
+		|	('>' ~'>') => '>'
+		)*
+		'>>'
+	;
+
+fragment
+ESC
+	:	'\\'
+		(	'n'
+		|	'r'
+		|	't'
+		|	'b'
+		|	'f'
+		|	'"'
+		|	'\''
+		|	'\\'
+		|	'>'
+		|	'u' XDIGIT XDIGIT XDIGIT XDIGIT
+		|	. // unknown, leave as it is
+		)
+	;
+
+fragment
+DIGIT
+	:	'0'..'9'
+	;
+
+fragment
+XDIGIT
+	:	'0' .. '9'
+	|	'a' .. 'f'
+	|	'A' .. 'F'
+	;
+
+INT
+	:	('0'..'9')+
+	;
+
+ARG_ACTION
+@init
+{
+	string text_ = string.Empty;
+}
+	:	'['
+		NESTED_ARG_ACTION[out text_]
+		']'
+		{ Text = text_; }
+	;
+
+fragment
+NESTED_ARG_ACTION[out string text_]
+@init
+{
+	$text_ = string.Empty;
+	System.Text.StringBuilder builder = new System.Text.StringBuilder();
+}
+	:	(	('\\]') => '\\' ']'		{builder.Append("]");}
+		|	'\\' c=~(']')			{builder.Append("\\" + (char)$c);}
+		|	ACTION_STRING_LITERAL	{builder.Append($ACTION_STRING_LITERAL.text);}
+		|	ACTION_CHAR_LITERAL		{builder.Append($ACTION_CHAR_LITERAL.text);}
+		|	c=~('\\'|'"'|'\''|']')	{builder.Append((char)$c);}
+		)*
+		{
+			$text_ = builder.ToString();
+		}
+	;
+
+ACTION
+@init
+{
+	int actionLine = Line;
+	int actionColumn = CharPositionInLine;
+}
+	:	NESTED_ACTION
+		('?' {$type = SEMPRED;})?
+		{
+			string action = $text;
+			int n = 1; // num delimiter chars
+			if ( action.StartsWith("{{") && action.EndsWith("}}") )
+			{
+				$type = FORCED_ACTION;
+				n = 2;
+			}
+			action = action.Substring(n,action.Length-n - ($type==SEMPRED ? 1 : 0) - n);
+			Text = action;
+		}
+	;
+
+fragment
+NESTED_ACTION
+	:	'{'
+		(	NESTED_ACTION
+		|	ACTION_CHAR_LITERAL
+		|	('//' | '/*') => COMMENT
+		|	ACTION_STRING_LITERAL
+		|	ACTION_ESC
+		|	~('{'|'\''|'"'|'\\'|'}')
+		)*
+		'}'
+	;
+
+fragment
+ACTION_CHAR_LITERAL
+	:	'\''
+		(	ACTION_ESC
+		|	~('\\'|'\'')
+		)*
+		'\''
+	;
+
+fragment
+ACTION_STRING_LITERAL
+	:	'"'
+		(	ACTION_ESC
+		|	~('\\'|'"')
+		)*
+		'"'
+	;
+
+fragment
+ACTION_ESC
+	:	'\\\''
+	|	'\\\"'
+	|	'\\' ~('\''|'"')
+	;
+
+TOKEN_REF
+	:	'A'..'Z'
+		(	'a'..'z'|'A'..'Z'|'_'|'0'..'9'
+		)*
+	;
+
+TOKENS
+	:	'tokens' WS_LOOP '{'
+	;
+
+OPTIONS
+	:	'options' WS_LOOP '{'
+	;
+
+// we get a warning here when looking for options '{', but it works right
+RULE_REF
+@init
+{
+	int t=0;
+}
+	:	'a'..'z' ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*
+	;
+
+fragment
+WS_LOOP
+	:	(	WS
+		|	COMMENT
+		)*
+	;
+
+fragment
+WS_OPT
+	:	(WS)?
+	;
+
+/** Reset the file and line information; useful when the grammar
+ *  has been generated so that errors are shown relative to the
+ *  original file like the old C preprocessor used to do.
+ */
+fragment
+SRC
+	:	'src' ' ' file=ACTION_STRING_LITERAL ' ' line=INT
+		{
+			Filename = $file.text.Substring(1,$file.text.Length-2);
+			Line = int.Parse($line.text) - 1;  // -1 because SL_COMMENT will increment the line no. KR
+		}
+	;
diff --git a/Antlr3/Grammars/ANTLRLexer.cs b/Antlr3/Grammars/ANTLRLexer.cs
new file mode 100644
index 0000000..a7b2d0f
--- /dev/null
+++ b/Antlr3/Grammars/ANTLRLexer.cs
@@ -0,0 +1,4442 @@
+// $ANTLR 3.1.2 Grammars\\ANTLR.g3 2009-03-07 09:02:31
+
+// The variable 'variable' is assigned but its value is never used.
+#pragma warning disable 219
+// Unreachable code detected.
+#pragma warning disable 162
+
+
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+using ErrorManager = Antlr3.Tool.ErrorManager;
+using Grammar = Antlr3.Tool.Grammar;
+using StringBuffer = System.Text.StringBuilder;
+
+
+using System.Collections.Generic;
+using Antlr.Runtime;
+using Stack = System.Collections.Generic.Stack<object>;
+using List = System.Collections.IList;
+using ArrayList = System.Collections.Generic.List<object>;
+using Map = System.Collections.IDictionary;
+using HashMap = System.Collections.Generic.Dictionary<object, object>;
+namespace Antlr3.Grammars
+{
+public partial class ANTLRLexer : Lexer
+{
+	public const int EOF=-1;
+	public const int ACTION=4;
+	public const int ACTION_CHAR_LITERAL=5;
+	public const int ACTION_ESC=6;
+	public const int ACTION_STRING_LITERAL=7;
+	public const int ALT=8;
+	public const int AMPERSAND=9;
+	public const int ARG=10;
+	public const int ARG_ACTION=11;
+	public const int ARGLIST=12;
+	public const int ASSIGN=13;
+	public const int BACKTRACK_SEMPRED=14;
+	public const int BANG=15;
+	public const int BLOCK=16;
+	public const int CATCH=17;
+	public const int CHAR_LITERAL=18;
+	public const int CHAR_RANGE=19;
+	public const int CLOSE_ELEMENT_OPTION=20;
+	public const int CLOSURE=21;
+	public const int COLON=22;
+	public const int COMBINED_GRAMMAR=23;
+	public const int COMMA=24;
+	public const int COMMENT=25;
+	public const int DIGIT=26;
+	public const int DOC_COMMENT=27;
+	public const int DOLLAR=28;
+	public const int DOT=29;
+	public const int DOUBLE_ANGLE_STRING_LITERAL=30;
+	public const int DOUBLE_QUOTE_STRING_LITERAL=31;
+	public const int EOA=32;
+	public const int EOB=33;
+	public const int EOR=34;
+	public const int EPSILON=35;
+	public const int ESC=36;
+	public const int ETC=37;
+	public const int FINALLY=38;
+	public const int FORCED_ACTION=39;
+	public const int FRAGMENT=40;
+	public const int GATED_SEMPRED=41;
+	public const int GRAMMAR=42;
+	public const int ID=43;
+	public const int IMPLIES=44;
+	public const int IMPORT=45;
+	public const int INITACTION=46;
+	public const int INT=47;
+	public const int LABEL=48;
+	public const int LEXER=49;
+	public const int LEXER_GRAMMAR=50;
+	public const int LPAREN=51;
+	public const int ML_COMMENT=52;
+	public const int NESTED_ACTION=53;
+	public const int NESTED_ARG_ACTION=54;
+	public const int NOT=55;
+	public const int OPEN_ELEMENT_OPTION=56;
+	public const int OPTIONAL=57;
+	public const int OPTIONS=58;
+	public const int OR=59;
+	public const int PARSER=60;
+	public const int PARSER_GRAMMAR=61;
+	public const int PLUS=62;
+	public const int PLUS_ASSIGN=63;
+	public const int POSITIVE_CLOSURE=64;
+	public const int PRIVATE=65;
+	public const int PROTECTED=66;
+	public const int PUBLIC=67;
+	public const int QUESTION=68;
+	public const int RANGE=69;
+	public const int RCURLY=70;
+	public const int RET=71;
+	public const int RETURNS=72;
+	public const int REWRITE=73;
+	public const int ROOT=74;
+	public const int RPAREN=75;
+	public const int RULE=76;
+	public const int RULE_REF=77;
+	public const int SCOPE=78;
+	public const int SEMI=79;
+	public const int SEMPRED=80;
+	public const int SL_COMMENT=81;
+	public const int SRC=82;
+	public const int STAR=83;
+	public const int STRAY_BRACKET=84;
+	public const int STRING_LITERAL=85;
+	public const int SYN_SEMPRED=86;
+	public const int SYNPRED=87;
+	public const int TEMPLATE=88;
+	public const int THROWS=89;
+	public const int TOKEN_REF=90;
+	public const int TOKENS=91;
+	public const int TREE=92;
+	public const int TREE_BEGIN=93;
+	public const int TREE_GRAMMAR=94;
+	public const int WILDCARD=95;
+	public const int WS=96;
+	public const int WS_LOOP=97;
+	public const int WS_OPT=98;
+	public const int XDIGIT=99;
+
+    // delegates
+    // delegators
+
+	public ANTLRLexer() {}
+	public ANTLRLexer( ICharStream input )
+		: this( input, new RecognizerSharedState() )
+	{
+	}
+	public ANTLRLexer( ICharStream input, RecognizerSharedState state )
+		: base( input, state )
+	{
+
+	}
+	public override string GrammarFileName { get { return "Grammars\\ANTLR.g3"; } }
+
+	// $ANTLR start "CATCH"
+	private void mCATCH()
+	{
+		try
+		{
+			int _type = CATCH;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:46:9: ( 'catch' )
+			// Grammars\\ANTLR.g3:46:9: 'catch'
+			{
+			Match("catch"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "CATCH"
+
+	// $ANTLR start "FINALLY"
+	private void mFINALLY()
+	{
+		try
+		{
+			int _type = FINALLY;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:47:11: ( 'finally' )
+			// Grammars\\ANTLR.g3:47:11: 'finally'
+			{
+			Match("finally"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "FINALLY"
+
+	// $ANTLR start "FRAGMENT"
+	private void mFRAGMENT()
+	{
+		try
+		{
+			int _type = FRAGMENT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:48:12: ( 'fragment' )
+			// Grammars\\ANTLR.g3:48:12: 'fragment'
+			{
+			Match("fragment"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "FRAGMENT"
+
+	// $ANTLR start "GRAMMAR"
+	private void mGRAMMAR()
+	{
+		try
+		{
+			int _type = GRAMMAR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:49:11: ( 'grammar' )
+			// Grammars\\ANTLR.g3:49:11: 'grammar'
+			{
+			Match("grammar"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "GRAMMAR"
+
+	// $ANTLR start "IMPORT"
+	private void mIMPORT()
+	{
+		try
+		{
+			int _type = IMPORT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:50:10: ( 'import' )
+			// Grammars\\ANTLR.g3:50:10: 'import'
+			{
+			Match("import"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "IMPORT"
+
+	// $ANTLR start "LEXER"
+	private void mLEXER()
+	{
+		try
+		{
+			int _type = LEXER;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:51:9: ( 'lexer' )
+			// Grammars\\ANTLR.g3:51:9: 'lexer'
+			{
+			Match("lexer"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "LEXER"
+
+	// $ANTLR start "PARSER"
+	private void mPARSER()
+	{
+		try
+		{
+			int _type = PARSER;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:52:10: ( 'parser' )
+			// Grammars\\ANTLR.g3:52:10: 'parser'
+			{
+			Match("parser"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "PARSER"
+
+	// $ANTLR start "PRIVATE"
+	private void mPRIVATE()
+	{
+		try
+		{
+			int _type = PRIVATE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:53:11: ( 'private' )
+			// Grammars\\ANTLR.g3:53:11: 'private'
+			{
+			Match("private"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "PRIVATE"
+
+	// $ANTLR start "PROTECTED"
+	private void mPROTECTED()
+	{
+		try
+		{
+			int _type = PROTECTED;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:54:13: ( 'protected' )
+			// Grammars\\ANTLR.g3:54:13: 'protected'
+			{
+			Match("protected"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "PROTECTED"
+
+	// $ANTLR start "PUBLIC"
+	private void mPUBLIC()
+	{
+		try
+		{
+			int _type = PUBLIC;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:55:10: ( 'public' )
+			// Grammars\\ANTLR.g3:55:10: 'public'
+			{
+			Match("public"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "PUBLIC"
+
+	// $ANTLR start "RETURNS"
+	private void mRETURNS()
+	{
+		try
+		{
+			int _type = RETURNS;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:56:11: ( 'returns' )
+			// Grammars\\ANTLR.g3:56:11: 'returns'
+			{
+			Match("returns"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "RETURNS"
+
+	// $ANTLR start "SCOPE"
+	private void mSCOPE()
+	{
+		try
+		{
+			int _type = SCOPE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:57:9: ( 'scope' )
+			// Grammars\\ANTLR.g3:57:9: 'scope'
+			{
+			Match("scope"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "SCOPE"
+
+	// $ANTLR start "THROWS"
+	private void mTHROWS()
+	{
+		try
+		{
+			int _type = THROWS;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:58:10: ( 'throws' )
+			// Grammars\\ANTLR.g3:58:10: 'throws'
+			{
+			Match("throws"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "THROWS"
+
+	// $ANTLR start "TREE"
+	private void mTREE()
+	{
+		try
+		{
+			int _type = TREE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:59:8: ( 'tree' )
+			// Grammars\\ANTLR.g3:59:8: 'tree'
+			{
+			Match("tree"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "TREE"
+
+	// $ANTLR start "STRING_LITERAL"
+	private void mSTRING_LITERAL()
+	{
+		try
+		{
+			// Grammars\\ANTLR.g3:816:27: ()
+			// Grammars\\ANTLR.g3:816:27:
+			{
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "STRING_LITERAL"
+
+	// $ANTLR start "FORCED_ACTION"
+	private void mFORCED_ACTION()
+	{
+		try
+		{
+			// Grammars\\ANTLR.g3:817:26: ()
+			// Grammars\\ANTLR.g3:817:26:
+			{
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "FORCED_ACTION"
+
+	// $ANTLR start "DOC_COMMENT"
+	private void mDOC_COMMENT()
+	{
+		try
+		{
+			// Grammars\\ANTLR.g3:818:24: ()
+			// Grammars\\ANTLR.g3:818:24:
+			{
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "DOC_COMMENT"
+
+	// $ANTLR start "SEMPRED"
+	private void mSEMPRED()
+	{
+		try
+		{
+			// Grammars\\ANTLR.g3:819:20: ()
+			// Grammars\\ANTLR.g3:819:20:
+			{
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "SEMPRED"
+
+	// $ANTLR start "WS"
+	private void mWS()
+	{
+		try
+		{
+			int _type = WS;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:822:4: ( ( ' ' | '\\t' | ( '\\r' )? '\\n' ) )
+			// Grammars\\ANTLR.g3:822:4: ( ' ' | '\\t' | ( '\\r' )? '\\n' )
+			{
+			// Grammars\\ANTLR.g3:822:4: ( ' ' | '\\t' | ( '\\r' )? '\\n' )
+			int alt2=3;
+			switch ( input.LA(1) )
+			{
+			case ' ':
+				{
+				alt2=1;
+				}
+				break;
+			case '\t':
+				{
+				alt2=2;
+				}
+				break;
+			case '\n':
+			case '\r':
+				{
+				alt2=3;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return ;}
+					NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt2 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:822:6: ' '
+				{
+				Match(' '); if (state.failed) return ;
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:823:5: '\\t'
+				{
+				Match('\t'); if (state.failed) return ;
+
+				}
+				break;
+			case 3:
+				// Grammars\\ANTLR.g3:824:5: ( '\\r' )? '\\n'
+				{
+				// Grammars\\ANTLR.g3:824:5: ( '\\r' )?
+				int alt1=2;
+				int LA1_0 = input.LA(1);
+
+				if ( (LA1_0=='\r') )
+				{
+					alt1=1;
+				}
+				switch ( alt1 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:824:6: '\\r'
+					{
+					Match('\r'); if (state.failed) return ;
+
+					}
+					break;
+
+				}
+
+				Match('\n'); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+			if ( state.backtracking == 0 )
+			{
+				 _channel = HIDDEN;
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "WS"
+
+	// $ANTLR start "COMMENT"
+	private void mCOMMENT()
+	{
+		try
+		{
+			int _type = COMMENT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:830:4: ( ( SL_COMMENT | ML_COMMENT[ref $type] ) )
+			// Grammars\\ANTLR.g3:830:4: ( SL_COMMENT | ML_COMMENT[ref $type] )
+			{
+			// Grammars\\ANTLR.g3:830:4: ( SL_COMMENT | ML_COMMENT[ref $type] )
+			int alt3=2;
+			int LA3_0 = input.LA(1);
+
+			if ( (LA3_0=='/') )
+			{
+				int LA3_1 = input.LA(2);
+
+				if ( (LA3_1=='/') )
+				{
+					alt3=1;
+				}
+				else if ( (LA3_1=='*') )
+				{
+					alt3=2;
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return ;}
+					NoViableAltException nvae = new NoViableAltException("", 3, 1, input);
+
+					throw nvae;
+				}
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt3 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:830:6: SL_COMMENT
+				{
+				mSL_COMMENT(); if (state.failed) return ;
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:830:19: ML_COMMENT[ref $type]
+				{
+				mML_COMMENT(ref _type); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+			if ( state.backtracking == 0 )
+			{
+
+							if ( _type != DOC_COMMENT )
+								_channel = HIDDEN;
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "COMMENT"
+
+	// $ANTLR start "SL_COMMENT"
+	private void mSL_COMMENT()
+	{
+		try
+		{
+			// Grammars\\ANTLR.g3:840:4: ( '//' (=> ' $ANTLR ' SRC ( ( '\\r' )? '\\n' )? | (~ ( '\\r' | '\\n' ) )* ( ( '\\r' )? '\\n' )? ) )
+			// Grammars\\ANTLR.g3:840:4: '//' (=> ' $ANTLR ' SRC ( ( '\\r' )? '\\n' )? | (~ ( '\\r' | '\\n' ) )* ( ( '\\r' )? '\\n' )? )
+			{
+			Match("//"); if (state.failed) return ;
+
+			// Grammars\\ANTLR.g3:841:3: (=> ' $ANTLR ' SRC ( ( '\\r' )? '\\n' )? | (~ ( '\\r' | '\\n' ) )* ( ( '\\r' )? '\\n' )? )
+			int alt9=2;
+			alt9 = dfa9.Predict(input);
+			switch ( alt9 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:841:5: => ' $ANTLR ' SRC ( ( '\\r' )? '\\n' )?
+				{
+
+				Match(" $ANTLR "); if (state.failed) return ;
+
+				mSRC(); if (state.failed) return ;
+				// Grammars\\ANTLR.g3:841:35: ( ( '\\r' )? '\\n' )?
+				int alt5=2;
+				int LA5_0 = input.LA(1);
+
+				if ( (LA5_0=='\n'||LA5_0=='\r') )
+				{
+					alt5=1;
+				}
+				switch ( alt5 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:841:36: ( '\\r' )? '\\n'
+					{
+					// Grammars\\ANTLR.g3:841:36: ( '\\r' )?
+					int alt4=2;
+					int LA4_0 = input.LA(1);
+
+					if ( (LA4_0=='\r') )
+					{
+						alt4=1;
+					}
+					switch ( alt4 )
+					{
+					case 1:
+						// Grammars\\ANTLR.g3:841:37: '\\r'
+						{
+						Match('\r'); if (state.failed) return ;
+
+						}
+						break;
+
+					}
+
+					Match('\n'); if (state.failed) return ;
+
+					}
+					break;
+
+				}
+
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:842:5: (~ ( '\\r' | '\\n' ) )* ( ( '\\r' )? '\\n' )?
+				{
+				// Grammars\\ANTLR.g3:842:5: (~ ( '\\r' | '\\n' ) )*
+				for ( ; ; )
+				{
+					int alt6=2;
+					int LA6_0 = input.LA(1);
+
+					if ( ((LA6_0>='\u0000' && LA6_0<='\t')||(LA6_0>='\u000B' && LA6_0<='\f')||(LA6_0>='\u000E' && LA6_0<='\uFFFF')) )
+					{
+						alt6=1;
+					}
+
+
+					switch ( alt6 )
+					{
+					case 1:
+						// Grammars\\ANTLR.g3:
+						{
+						input.Consume();
+						state.failed=false;
+
+						}
+						break;
+
+					default:
+						goto loop6;
+					}
+				}
+
+				loop6:
+					;
+
+
+				// Grammars\\ANTLR.g3:842:19: ( ( '\\r' )? '\\n' )?
+				int alt8=2;
+				int LA8_0 = input.LA(1);
+
+				if ( (LA8_0=='\n'||LA8_0=='\r') )
+				{
+					alt8=1;
+				}
+				switch ( alt8 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:842:20: ( '\\r' )? '\\n'
+					{
+					// Grammars\\ANTLR.g3:842:20: ( '\\r' )?
+					int alt7=2;
+					int LA7_0 = input.LA(1);
+
+					if ( (LA7_0=='\r') )
+					{
+						alt7=1;
+					}
+					switch ( alt7 )
+					{
+					case 1:
+						// Grammars\\ANTLR.g3:842:21: '\\r'
+						{
+						Match('\r'); if (state.failed) return ;
+
+						}
+						break;
+
+					}
+
+					Match('\n'); if (state.failed) return ;
+
+					}
+					break;
+
+				}
+
+
+				}
+				break;
+
+			}
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "SL_COMMENT"
+
+	// $ANTLR start "ML_COMMENT"
+	private void mML_COMMENT(ref int type)
+	{
+		try
+		{
+
+				type = ML_COMMENT;
+
+			// Grammars\\ANTLR.g3:852:4: ( '/*' (=> '*' |) (=> '*' |~ '*' )* '*/' )
+			// Grammars\\ANTLR.g3:852:4: '/*' (=> '*' |) (=> '*' |~ '*' )* '*/'
+			{
+			Match("/*"); if (state.failed) return ;
+
+			// Grammars\\ANTLR.g3:853:3: (=> '*' |)
+			int alt10=2;
+			int LA10_0 = input.LA(1);
+
+			if ( (LA10_0=='*') )
+			{
+				int LA10_1 = input.LA(2);
+
+				if ( (synpred2_ANTLR()) )
+				{
+					alt10=1;
+				}
+				else if ( (true) )
+				{
+					alt10=2;
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return ;}
+					NoViableAltException nvae = new NoViableAltException("", 10, 1, input);
+
+					throw nvae;
+				}
+			}
+			else if ( ((LA10_0>='\u0000' && LA10_0<=')')||(LA10_0>='+' && LA10_0<='\uFFFF')) )
+			{
+				alt10=2;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				NoViableAltException nvae = new NoViableAltException("", 10, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt10 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:853:5: => '*'
+				{
+
+				Match('*'); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+					type = DOC_COMMENT;
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:855:3:
+				{
+
+
+				}
+				break;
+
+			}
+
+			// Grammars\\ANTLR.g3:856:3: (=> '*' |~ '*' )*
+			for ( ; ; )
+			{
+				int alt11=3;
+				int LA11_0 = input.LA(1);
+
+				if ( (LA11_0=='*') )
+				{
+					int LA11_1 = input.LA(2);
+
+					if ( (LA11_1=='/') )
+					{
+						int LA11_3 = input.LA(3);
+
+						if ( (LA11_3=='*') && (synpred3_ANTLR()))
+						{
+							alt11=1;
+						}
+						else if ( ((LA11_3>='\u0000' && LA11_3<=')')||(LA11_3>='+' && LA11_3<='\uFFFF')) && (synpred3_ANTLR()))
+						{
+							alt11=1;
+						}
+
+
+					}
+					else if ( (LA11_1=='*') && (synpred3_ANTLR()))
+					{
+						alt11=1;
+					}
+					else if ( ((LA11_1>='\u0000' && LA11_1<=')')||(LA11_1>='+' && LA11_1<='.')||(LA11_1>='0' && LA11_1<='\uFFFF')) && (synpred3_ANTLR()))
+					{
+						alt11=1;
+					}
+
+
+				}
+				else if ( ((LA11_0>='\u0000' && LA11_0<=')')||(LA11_0>='+' && LA11_0<='\uFFFF')) )
+				{
+					alt11=2;
+				}
+
+
+				switch ( alt11 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:856:5: => '*'
+					{
+
+					Match('*'); if (state.failed) return ;
+
+					}
+					break;
+				case 2:
+					// Grammars\\ANTLR.g3:857:5: ~ '*'
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+
+				default:
+					goto loop11;
+				}
+			}
+
+			loop11:
+				;
+
+
+			Match("*/"); if (state.failed) return ;
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ML_COMMENT"
+
+	// $ANTLR start "OPEN_ELEMENT_OPTION"
+	private void mOPEN_ELEMENT_OPTION()
+	{
+		try
+		{
+			int _type = OPEN_ELEMENT_OPTION;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:862:4: ( '<' )
+			// Grammars\\ANTLR.g3:862:4: '<'
+			{
+			Match('<'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "OPEN_ELEMENT_OPTION"
+
+	// $ANTLR start "CLOSE_ELEMENT_OPTION"
+	private void mCLOSE_ELEMENT_OPTION()
+	{
+		try
+		{
+			int _type = CLOSE_ELEMENT_OPTION;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:866:4: ( '>' )
+			// Grammars\\ANTLR.g3:866:4: '>'
+			{
+			Match('>'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "CLOSE_ELEMENT_OPTION"
+
+	// $ANTLR start "AMPERSAND"
+	private void mAMPERSAND()
+	{
+		try
+		{
+			int _type = AMPERSAND;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:869:13: ( '@' )
+			// Grammars\\ANTLR.g3:869:13: '@'
+			{
+			Match('@'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "AMPERSAND"
+
+	// $ANTLR start "COMMA"
+	private void mCOMMA()
+	{
+		try
+		{
+			int _type = COMMA;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:871:9: ( ',' )
+			// Grammars\\ANTLR.g3:871:9: ','
+			{
+			Match(','); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "COMMA"
+
+	// $ANTLR start "QUESTION"
+	private void mQUESTION()
+	{
+		try
+		{
+			int _type = QUESTION;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:873:12: ( '?' )
+			// Grammars\\ANTLR.g3:873:12: '?'
+			{
+			Match('?'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "QUESTION"
+
+	// $ANTLR start "TREE_BEGIN"
+	private void mTREE_BEGIN()
+	{
+		try
+		{
+			int _type = TREE_BEGIN;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:875:14: ( '^(' )
+			// Grammars\\ANTLR.g3:875:14: '^('
+			{
+			Match("^("); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "TREE_BEGIN"
+
+	// $ANTLR start "LPAREN"
+	private void mLPAREN()
+	{
+		try
+		{
+			int _type = LPAREN;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:877:9: ( '(' )
+			// Grammars\\ANTLR.g3:877:9: '('
+			{
+			Match('('); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "LPAREN"
+
+	// $ANTLR start "RPAREN"
+	private void mRPAREN()
+	{
+		try
+		{
+			int _type = RPAREN;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:879:9: ( ')' )
+			// Grammars\\ANTLR.g3:879:9: ')'
+			{
+			Match(')'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "RPAREN"
+
+	// $ANTLR start "COLON"
+	private void mCOLON()
+	{
+		try
+		{
+			int _type = COLON;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:881:9: ( ':' )
+			// Grammars\\ANTLR.g3:881:9: ':'
+			{
+			Match(':'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "COLON"
+
+	// $ANTLR start "STAR"
+	private void mSTAR()
+	{
+		try
+		{
+			int _type = STAR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:883:7: ( '*' )
+			// Grammars\\ANTLR.g3:883:7: '*'
+			{
+			Match('*'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "STAR"
+
+	// $ANTLR start "PLUS"
+	private void mPLUS()
+	{
+		try
+		{
+			int _type = PLUS;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:885:7: ( '+' )
+			// Grammars\\ANTLR.g3:885:7: '+'
+			{
+			Match('+'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "PLUS"
+
+	// $ANTLR start "ASSIGN"
+	private void mASSIGN()
+	{
+		try
+		{
+			int _type = ASSIGN;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:887:10: ( '=' )
+			// Grammars\\ANTLR.g3:887:10: '='
+			{
+			Match('='); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ASSIGN"
+
+	// $ANTLR start "PLUS_ASSIGN"
+	private void mPLUS_ASSIGN()
+	{
+		try
+		{
+			int _type = PLUS_ASSIGN;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:889:15: ( '+=' )
+			// Grammars\\ANTLR.g3:889:15: '+='
+			{
+			Match("+="); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "PLUS_ASSIGN"
+
+	// $ANTLR start "IMPLIES"
+	private void mIMPLIES()
+	{
+		try
+		{
+			int _type = IMPLIES;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:891:11: ( '=>' )
+			// Grammars\\ANTLR.g3:891:11: '=>'
+			{
+			Match("=>"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "IMPLIES"
+
+	// $ANTLR start "REWRITE"
+	private void mREWRITE()
+	{
+		try
+		{
+			int _type = REWRITE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:893:11: ( '->' )
+			// Grammars\\ANTLR.g3:893:11: '->'
+			{
+			Match("->"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "REWRITE"
+
+	// $ANTLR start "SEMI"
+	private void mSEMI()
+	{
+		try
+		{
+			int _type = SEMI;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:895:7: ( ';' )
+			// Grammars\\ANTLR.g3:895:7: ';'
+			{
+			Match(';'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "SEMI"
+
+	// $ANTLR start "ROOT"
+	private void mROOT()
+	{
+		try
+		{
+			int _type = ROOT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:897:8: ( '^' )
+			// Grammars\\ANTLR.g3:897:8: '^'
+			{
+			Match('^'); if (state.failed) return ;
+			if ( state.backtracking == 0 )
+			{
+				hasASTOperator=true;
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ROOT"
+
+	// $ANTLR start "BANG"
+	private void mBANG()
+	{
+		try
+		{
+			int _type = BANG;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:899:8: ( '!' )
+			// Grammars\\ANTLR.g3:899:8: '!'
+			{
+			Match('!'); if (state.failed) return ;
+			if ( state.backtracking == 0 )
+			{
+				hasASTOperator=true;
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "BANG"
+
+	// $ANTLR start "OR"
+	private void mOR()
+	{
+		try
+		{
+			int _type = OR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:901:6: ( '|' )
+			// Grammars\\ANTLR.g3:901:6: '|'
+			{
+			Match('|'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "OR"
+
+	// $ANTLR start "WILDCARD"
+	private void mWILDCARD()
+	{
+		try
+		{
+			int _type = WILDCARD;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:903:12: ( '.' )
+			// Grammars\\ANTLR.g3:903:12: '.'
+			{
+			Match('.'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "WILDCARD"
+
+	// $ANTLR start "ETC"
+	private void mETC()
+	{
+		try
+		{
+			int _type = ETC;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:905:7: ( '...' )
+			// Grammars\\ANTLR.g3:905:7: '...'
+			{
+			Match("..."); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ETC"
+
+	// $ANTLR start "RANGE"
+	private void mRANGE()
+	{
+		try
+		{
+			int _type = RANGE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:907:9: ( '..' )
+			// Grammars\\ANTLR.g3:907:9: '..'
+			{
+			Match(".."); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "RANGE"
+
+	// $ANTLR start "NOT"
+	private void mNOT()
+	{
+		try
+		{
+			int _type = NOT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:909:7: ( '~' )
+			// Grammars\\ANTLR.g3:909:7: '~'
+			{
+			Match('~'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "NOT"
+
+	// $ANTLR start "RCURLY"
+	private void mRCURLY()
+	{
+		try
+		{
+			int _type = RCURLY;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:911:9: ( '}' )
+			// Grammars\\ANTLR.g3:911:9: '}'
+			{
+			Match('}'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "RCURLY"
+
+	// $ANTLR start "DOLLAR"
+	private void mDOLLAR()
+	{
+		try
+		{
+			int _type = DOLLAR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:913:10: ( '$' )
+			// Grammars\\ANTLR.g3:913:10: '$'
+			{
+			Match('$'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "DOLLAR"
+
+	// $ANTLR start "STRAY_BRACKET"
+	private void mSTRAY_BRACKET()
+	{
+		try
+		{
+			int _type = STRAY_BRACKET;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:916:4: ( ']' )
+			// Grammars\\ANTLR.g3:916:4: ']'
+			{
+			Match(']'); if (state.failed) return ;
+			if ( state.backtracking == 0 )
+			{
+
+							ErrorManager.syntaxError(
+								ErrorManager.MSG_SYNTAX_ERROR,
+								null,
+								state.token,
+								"antlr: dangling ']'? make sure to escape with \\]",
+								null);
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "STRAY_BRACKET"
+
+	// $ANTLR start "CHAR_LITERAL"
+	private void mCHAR_LITERAL()
+	{
+		try
+		{
+			int _type = CHAR_LITERAL;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:928:4: ( '\\'' ( ESC |~ ( '\\\\' | '\\'' ) )* '\\'' )
+			// Grammars\\ANTLR.g3:928:4: '\\'' ( ESC |~ ( '\\\\' | '\\'' ) )* '\\''
+			{
+			Match('\''); if (state.failed) return ;
+			// Grammars\\ANTLR.g3:929:3: ( ESC |~ ( '\\\\' | '\\'' ) )*
+			for ( ; ; )
+			{
+				int alt12=3;
+				int LA12_0 = input.LA(1);
+
+				if ( (LA12_0=='\\') )
+				{
+					alt12=1;
+				}
+				else if ( ((LA12_0>='\u0000' && LA12_0<='&')||(LA12_0>='(' && LA12_0<='[')||(LA12_0>=']' && LA12_0<='\uFFFF')) )
+				{
+					alt12=2;
+				}
+
+
+				switch ( alt12 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:929:5: ESC
+					{
+					mESC(); if (state.failed) return ;
+
+					}
+					break;
+				case 2:
+					// Grammars\\ANTLR.g3:930:5: ~ ( '\\\\' | '\\'' )
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+
+				default:
+					goto loop12;
+				}
+			}
+
+			loop12:
+				;
+
+
+			Match('\''); if (state.failed) return ;
+			if ( state.backtracking == 0 )
+			{
+
+							StringBuffer s = Grammar.getUnescapedStringFromGrammarStringLiteral(Text);
+							if ( s.Length > 1 )
+							{
+								_type = STRING_LITERAL;
+							}
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "CHAR_LITERAL"
+
+	// $ANTLR start "DOUBLE_QUOTE_STRING_LITERAL"
+	private void mDOUBLE_QUOTE_STRING_LITERAL()
+	{
+		try
+		{
+			int _type = DOUBLE_QUOTE_STRING_LITERAL;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			int c;
+
+
+				System.Text.StringBuilder builder = new System.Text.StringBuilder();
+
+			// Grammars\\ANTLR.g3:947:4: ( '\"' (=> '\\\\' '\"' | '\\\\' c=~ '\"' |c=~ ( '\\\\' | '\"' ) )* '\"' )
+			// Grammars\\ANTLR.g3:947:4: '\"' (=> '\\\\' '\"' | '\\\\' c=~ '\"' |c=~ ( '\\\\' | '\"' ) )* '\"'
+			{
+			Match('\"'); if (state.failed) return ;
+			if ( state.backtracking == 0 )
+			{
+				builder.Append('"');
+			}
+			// Grammars\\ANTLR.g3:948:3: (=> '\\\\' '\"' | '\\\\' c=~ '\"' |c=~ ( '\\\\' | '\"' ) )*
+			for ( ; ; )
+			{
+				int alt13=4;
+				int LA13_0 = input.LA(1);
+
+				if ( (LA13_0=='\\') )
+				{
+					int LA13_2 = input.LA(2);
+
+					if ( (LA13_2=='\"') && (synpred4_ANTLR()))
+					{
+						alt13=1;
+					}
+					else if ( ((LA13_2>='\u0000' && LA13_2<='!')||(LA13_2>='#' && LA13_2<='\uFFFF')) )
+					{
+						alt13=2;
+					}
+
+
+				}
+				else if ( ((LA13_0>='\u0000' && LA13_0<='!')||(LA13_0>='#' && LA13_0<='[')||(LA13_0>=']' && LA13_0<='\uFFFF')) )
+				{
+					alt13=3;
+				}
+
+
+				switch ( alt13 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:948:5: => '\\\\' '\"'
+					{
+
+					Match('\\'); if (state.failed) return ;
+					Match('\"'); if (state.failed) return ;
+					if ( state.backtracking == 0 )
+					{
+						builder.Append('"');
+					}
+
+					}
+					break;
+				case 2:
+					// Grammars\\ANTLR.g3:949:5: '\\\\' c=~ '\"'
+					{
+					Match('\\'); if (state.failed) return ;
+					c= input.LA(1);
+					input.Consume();
+					state.failed=false;
+					if ( state.backtracking == 0 )
+					{
+						builder.Append("\\" + (char)c);
+					}
+
+					}
+					break;
+				case 3:
+					// Grammars\\ANTLR.g3:950:5: c=~ ( '\\\\' | '\"' )
+					{
+					c= input.LA(1);
+					input.Consume();
+					state.failed=false;
+					if ( state.backtracking == 0 )
+					{
+						builder.Append((char)c);
+					}
+
+					}
+					break;
+
+				default:
+					goto loop13;
+				}
+			}
+
+			loop13:
+				;
+
+
+			Match('\"'); if (state.failed) return ;
+			if ( state.backtracking == 0 )
+			{
+				builder.Append('"');
+			}
+			if ( state.backtracking == 0 )
+			{
+
+							Text = builder.ToString();
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "DOUBLE_QUOTE_STRING_LITERAL"
+
+	// $ANTLR start "DOUBLE_ANGLE_STRING_LITERAL"
+	private void mDOUBLE_ANGLE_STRING_LITERAL()
+	{
+		try
+		{
+			int _type = DOUBLE_ANGLE_STRING_LITERAL;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:959:4: ( '<<' (~ '>' |=> '>' )* '>>' )
+			// Grammars\\ANTLR.g3:959:4: '<<' (~ '>' |=> '>' )* '>>'
+			{
+			Match("<<"); if (state.failed) return ;
+
+			// Grammars\\ANTLR.g3:960:3: (~ '>' |=> '>' )*
+			for ( ; ; )
+			{
+				int alt14=3;
+				int LA14_0 = input.LA(1);
+
+				if ( (LA14_0=='>') )
+				{
+					int LA14_1 = input.LA(2);
+
+					if ( (LA14_1=='>') )
+					{
+						int LA14_3 = input.LA(3);
+
+						if ( (LA14_3=='>') && (synpred5_ANTLR()))
+						{
+							alt14=2;
+						}
+						else if ( ((LA14_3>='\u0000' && LA14_3<='=')||(LA14_3>='?' && LA14_3<='\uFFFF')) && (synpred5_ANTLR()))
+						{
+							alt14=2;
+						}
+
+
+					}
+					else if ( ((LA14_1>='\u0000' && LA14_1<='=')||(LA14_1>='?' && LA14_1<='\uFFFF')) && (synpred5_ANTLR()))
+					{
+						alt14=2;
+					}
+
+
+				}
+				else if ( ((LA14_0>='\u0000' && LA14_0<='=')||(LA14_0>='?' && LA14_0<='\uFFFF')) )
+				{
+					alt14=1;
+				}
+
+
+				switch ( alt14 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:960:5: ~ '>'
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+				case 2:
+					// Grammars\\ANTLR.g3:961:5: => '>'
+					{
+
+					Match('>'); if (state.failed) return ;
+
+					}
+					break;
+
+				default:
+					goto loop14;
+				}
+			}
+
+			loop14:
+				;
+
+
+			Match(">>"); if (state.failed) return ;
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "DOUBLE_ANGLE_STRING_LITERAL"
+
+	// $ANTLR start "ESC"
+	private void mESC()
+	{
+		try
+		{
+			// Grammars\\ANTLR.g3:969:4: ( '\\\\' ( 'n' | 'r' | 't' | 'b' | 'f' | '\"' | '\\'' | '\\\\' | '>' | 'u' XDIGIT XDIGIT XDIGIT XDIGIT | . ) )
+			// Grammars\\ANTLR.g3:969:4: '\\\\' ( 'n' | 'r' | 't' | 'b' | 'f' | '\"' | '\\'' | '\\\\' | '>' | 'u' XDIGIT XDIGIT XDIGIT XDIGIT | . )
+			{
+			Match('\\'); if (state.failed) return ;
+			// Grammars\\ANTLR.g3:970:3: ( 'n' | 'r' | 't' | 'b' | 'f' | '\"' | '\\'' | '\\\\' | '>' | 'u' XDIGIT XDIGIT XDIGIT XDIGIT | . )
+			int alt15=11;
+			alt15 = dfa15.Predict(input);
+			switch ( alt15 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:970:5: 'n'
+				{
+				Match('n'); if (state.failed) return ;
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:971:5: 'r'
+				{
+				Match('r'); if (state.failed) return ;
+
+				}
+				break;
+			case 3:
+				// Grammars\\ANTLR.g3:972:5: 't'
+				{
+				Match('t'); if (state.failed) return ;
+
+				}
+				break;
+			case 4:
+				// Grammars\\ANTLR.g3:973:5: 'b'
+				{
+				Match('b'); if (state.failed) return ;
+
+				}
+				break;
+			case 5:
+				// Grammars\\ANTLR.g3:974:5: 'f'
+				{
+				Match('f'); if (state.failed) return ;
+
+				}
+				break;
+			case 6:
+				// Grammars\\ANTLR.g3:975:5: '\"'
+				{
+				Match('\"'); if (state.failed) return ;
+
+				}
+				break;
+			case 7:
+				// Grammars\\ANTLR.g3:976:5: '\\''
+				{
+				Match('\''); if (state.failed) return ;
+
+				}
+				break;
+			case 8:
+				// Grammars\\ANTLR.g3:977:5: '\\\\'
+				{
+				Match('\\'); if (state.failed) return ;
+
+				}
+				break;
+			case 9:
+				// Grammars\\ANTLR.g3:978:5: '>'
+				{
+				Match('>'); if (state.failed) return ;
+
+				}
+				break;
+			case 10:
+				// Grammars\\ANTLR.g3:979:5: 'u' XDIGIT XDIGIT XDIGIT XDIGIT
+				{
+				Match('u'); if (state.failed) return ;
+				mXDIGIT(); if (state.failed) return ;
+				mXDIGIT(); if (state.failed) return ;
+				mXDIGIT(); if (state.failed) return ;
+				mXDIGIT(); if (state.failed) return ;
+
+				}
+				break;
+			case 11:
+				// Grammars\\ANTLR.g3:980:5: .
+				{
+				MatchAny(); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ESC"
+
+	// $ANTLR start "DIGIT"
+	private void mDIGIT()
+	{
+		try
+		{
+			// Grammars\\ANTLR.g3:986:4: ( '0' .. '9' )
+			// Grammars\\ANTLR.g3:
+			{
+			if ( (input.LA(1)>='0' && input.LA(1)<='9') )
+			{
+				input.Consume();
+			state.failed=false;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				Recover(mse);
+				throw mse;}
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "DIGIT"
+
+	// $ANTLR start "XDIGIT"
+	private void mXDIGIT()
+	{
+		try
+		{
+			// Grammars\\ANTLR.g3:991:4: ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )
+			// Grammars\\ANTLR.g3:
+			{
+			if ( (input.LA(1)>='0' && input.LA(1)<='9')||(input.LA(1)>='A' && input.LA(1)<='F')||(input.LA(1)>='a' && input.LA(1)<='f') )
+			{
+				input.Consume();
+			state.failed=false;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				Recover(mse);
+				throw mse;}
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "XDIGIT"
+
+	// $ANTLR start "INT"
+	private void mINT()
+	{
+		try
+		{
+			int _type = INT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:996:4: ( ( '0' .. '9' )+ )
+			// Grammars\\ANTLR.g3:996:4: ( '0' .. '9' )+
+			{
+			// Grammars\\ANTLR.g3:996:4: ( '0' .. '9' )+
+			int cnt16=0;
+			for ( ; ; )
+			{
+				int alt16=2;
+				int LA16_0 = input.LA(1);
+
+				if ( ((LA16_0>='0' && LA16_0<='9')) )
+				{
+					alt16=1;
+				}
+
+
+				switch ( alt16 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+
+				default:
+					if ( cnt16 >= 1 )
+						goto loop16;
+
+					if (state.backtracking>0) {state.failed=true; return ;}
+					EarlyExitException eee16 = new EarlyExitException( 16, input );
+					throw eee16;
+				}
+				cnt16++;
+			}
+			loop16:
+				;
+
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "INT"
+
+	// $ANTLR start "ARG_ACTION"
+	private void mARG_ACTION()
+	{
+		try
+		{
+			int _type = ARG_ACTION;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+
+				string text_ = string.Empty;
+
+			// Grammars\\ANTLR.g3:1004:4: ( '[' NESTED_ARG_ACTION[out text_] ']' )
+			// Grammars\\ANTLR.g3:1004:4: '[' NESTED_ARG_ACTION[out text_] ']'
+			{
+			Match('['); if (state.failed) return ;
+			mNESTED_ARG_ACTION(out text_); if (state.failed) return ;
+			Match(']'); if (state.failed) return ;
+			if ( state.backtracking == 0 )
+			{
+				 Text = text_;
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ARG_ACTION"
+
+	// $ANTLR start "NESTED_ARG_ACTION"
+	private void mNESTED_ARG_ACTION(out string text_)
+	{
+		try
+		{
+			IToken ACTION_STRING_LITERAL1=null;
+			IToken ACTION_CHAR_LITERAL2=null;
+			int c;
+
+
+				text_ = string.Empty;
+				System.Text.StringBuilder builder = new System.Text.StringBuilder();
+
+			// Grammars\\ANTLR.g3:1018:4: ( (=> '\\\\' ']' | '\\\\' c=~ ( ']' ) | ACTION_STRING_LITERAL | ACTION_CHAR_LITERAL |c=~ ( '\\\\' | '\"' | '\\'' | ']' ) )* )
+			// Grammars\\ANTLR.g3:1018:4: (=> '\\\\' ']' | '\\\\' c=~ ( ']' ) | ACTION_STRING_LITERAL | ACTION_CHAR_LITERAL |c=~ ( '\\\\' | '\"' | '\\'' | ']' ) )*
+			{
+			// Grammars\\ANTLR.g3:1018:4: (=> '\\\\' ']' | '\\\\' c=~ ( ']' ) | ACTION_STRING_LITERAL | ACTION_CHAR_LITERAL |c=~ ( '\\\\' | '\"' | '\\'' | ']' ) )*
+			for ( ; ; )
+			{
+				int alt17=6;
+				int LA17_0 = input.LA(1);
+
+				if ( (LA17_0=='\\') )
+				{
+					int LA17_2 = input.LA(2);
+
+					if ( (LA17_2==']') && (synpred6_ANTLR()))
+					{
+						alt17=1;
+					}
+					else if ( ((LA17_2>='\u0000' && LA17_2<='\\')||(LA17_2>='^' && LA17_2<='\uFFFF')) )
+					{
+						alt17=2;
+					}
+
+
+				}
+				else if ( (LA17_0=='\"') )
+				{
+					alt17=3;
+				}
+				else if ( (LA17_0=='\'') )
+				{
+					alt17=4;
+				}
+				else if ( ((LA17_0>='\u0000' && LA17_0<='!')||(LA17_0>='#' && LA17_0<='&')||(LA17_0>='(' && LA17_0<='[')||(LA17_0>='^' && LA17_0<='\uFFFF')) )
+				{
+					alt17=5;
+				}
+
+
+				switch ( alt17 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:1018:6: => '\\\\' ']'
+					{
+
+					Match('\\'); if (state.failed) return ;
+					Match(']'); if (state.failed) return ;
+					if ( state.backtracking == 0 )
+					{
+						builder.Append("]");
+					}
+
+					}
+					break;
+				case 2:
+					// Grammars\\ANTLR.g3:1019:5: '\\\\' c=~ ( ']' )
+					{
+					Match('\\'); if (state.failed) return ;
+					c= input.LA(1);
+					input.Consume();
+					state.failed=false;
+					if ( state.backtracking == 0 )
+					{
+						builder.Append("\\" + (char)c);
+					}
+
+					}
+					break;
+				case 3:
+					// Grammars\\ANTLR.g3:1020:5: ACTION_STRING_LITERAL
+					{
+					int ACTION_STRING_LITERAL1Start993 = GetCharIndex();
+					mACTION_STRING_LITERAL(); if (state.failed) return ;
+					ACTION_STRING_LITERAL1 = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, ACTION_STRING_LITERAL1Start993, GetCharIndex()-1);
+					if ( state.backtracking == 0 )
+					{
+						builder.Append((ACTION_STRING_LITERAL1!=null?ACTION_STRING_LITERAL1.Text:null));
+					}
+
+					}
+					break;
+				case 4:
+					// Grammars\\ANTLR.g3:1021:5: ACTION_CHAR_LITERAL
+					{
+					int ACTION_CHAR_LITERAL2Start1001 = GetCharIndex();
+					mACTION_CHAR_LITERAL(); if (state.failed) return ;
+					ACTION_CHAR_LITERAL2 = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, ACTION_CHAR_LITERAL2Start1001, GetCharIndex()-1);
+					if ( state.backtracking == 0 )
+					{
+						builder.Append((ACTION_CHAR_LITERAL2!=null?ACTION_CHAR_LITERAL2.Text:null));
+					}
+
+					}
+					break;
+				case 5:
+					// Grammars\\ANTLR.g3:1022:5: c=~ ( '\\\\' | '\"' | '\\'' | ']' )
+					{
+					c= input.LA(1);
+					input.Consume();
+					state.failed=false;
+					if ( state.backtracking == 0 )
+					{
+						builder.Append((char)c);
+					}
+
+					}
+					break;
+
+				default:
+					goto loop17;
+				}
+			}
+
+			loop17:
+				;
+
+
+			if ( state.backtracking == 0 )
+			{
+
+							text_ = builder.ToString();
+
+			}
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "NESTED_ARG_ACTION"
+
+	// $ANTLR start "ACTION"
+	private void mACTION()
+	{
+		try
+		{
+			int _type = ACTION;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+
+				int actionLine = Line;
+				int actionColumn = CharPositionInLine;
+
+			// Grammars\\ANTLR.g3:1034:4: ( NESTED_ACTION ( '?' )? )
+			// Grammars\\ANTLR.g3:1034:4: NESTED_ACTION ( '?' )?
+			{
+			mNESTED_ACTION(); if (state.failed) return ;
+			// Grammars\\ANTLR.g3:1035:3: ( '?' )?
+			int alt18=2;
+			int LA18_0 = input.LA(1);
+
+			if ( (LA18_0=='?') )
+			{
+				alt18=1;
+			}
+			switch ( alt18 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:1035:4: '?'
+				{
+				Match('?'); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+					_type = SEMPRED;
+				}
+
+				}
+				break;
+
+			}
+
+			if ( state.backtracking == 0 )
+			{
+
+							string action = Text;
+							int n = 1; // num delimiter chars
+							if ( action.StartsWith("{{") && action.EndsWith("}}") )
+							{
+								_type = FORCED_ACTION;
+								n = 2;
+							}
+							action = action.Substring(n,action.Length-n - (_type==SEMPRED ? 1 : 0) - n);
+							Text = action;
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ACTION"
+
+	// $ANTLR start "NESTED_ACTION"
+	private void mNESTED_ACTION()
+	{
+		try
+		{
+			// Grammars\\ANTLR.g3:1052:4: ( '{' ( NESTED_ACTION | ACTION_CHAR_LITERAL |=> COMMENT | ACTION_STRING_LITERAL | ACTION_ESC |~ ( '{' | '\\'' | '\"' | '\\\\' | '}' ) )* '}' )
+			// Grammars\\ANTLR.g3:1052:4: '{' ( NESTED_ACTION | ACTION_CHAR_LITERAL |=> COMMENT | ACTION_STRING_LITERAL | ACTION_ESC |~ ( '{' | '\\'' | '\"' | '\\\\' | '}' ) )* '}'
+			{
+			Match('{'); if (state.failed) return ;
+			// Grammars\\ANTLR.g3:1053:3: ( NESTED_ACTION | ACTION_CHAR_LITERAL |=> COMMENT | ACTION_STRING_LITERAL | ACTION_ESC |~ ( '{' | '\\'' | '\"' | '\\\\' | '}' ) )*
+			for ( ; ; )
+			{
+				int alt19=7;
+				int LA19_0 = input.LA(1);
+
+				if ( (LA19_0=='{') )
+				{
+					alt19=1;
+				}
+				else if ( (LA19_0=='\'') )
+				{
+					alt19=2;
+				}
+				else if ( (LA19_0=='/') )
+				{
+					int LA19_4 = input.LA(2);
+
+					if ( (synpred7_ANTLR()) )
+					{
+						alt19=3;
+					}
+					else if ( (true) )
+					{
+						alt19=6;
+					}
+
+
+				}
+				else if ( (LA19_0=='\"') )
+				{
+					alt19=4;
+				}
+				else if ( (LA19_0=='\\') )
+				{
+					alt19=5;
+				}
+				else if ( ((LA19_0>='\u0000' && LA19_0<='!')||(LA19_0>='#' && LA19_0<='&')||(LA19_0>='(' && LA19_0<='.')||(LA19_0>='0' && LA19_0<='[')||(LA19_0>=']' && LA19_0<='z')||LA19_0=='|'||(LA19_0>='~' && LA19_0<='\uFFFF')) )
+				{
+					alt19=6;
+				}
+
+
+				switch ( alt19 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:1053:5: NESTED_ACTION
+					{
+					mNESTED_ACTION(); if (state.failed) return ;
+
+					}
+					break;
+				case 2:
+					// Grammars\\ANTLR.g3:1054:5: ACTION_CHAR_LITERAL
+					{
+					mACTION_CHAR_LITERAL(); if (state.failed) return ;
+
+					}
+					break;
+				case 3:
+					// Grammars\\ANTLR.g3:1055:5: => COMMENT
+					{
+
+					mCOMMENT(); if (state.failed) return ;
+
+					}
+					break;
+				case 4:
+					// Grammars\\ANTLR.g3:1056:5: ACTION_STRING_LITERAL
+					{
+					mACTION_STRING_LITERAL(); if (state.failed) return ;
+
+					}
+					break;
+				case 5:
+					// Grammars\\ANTLR.g3:1057:5: ACTION_ESC
+					{
+					mACTION_ESC(); if (state.failed) return ;
+
+					}
+					break;
+				case 6:
+					// Grammars\\ANTLR.g3:1058:5: ~ ( '{' | '\\'' | '\"' | '\\\\' | '}' )
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+
+				default:
+					goto loop19;
+				}
+			}
+
+			loop19:
+				;
+
+
+			Match('}'); if (state.failed) return ;
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "NESTED_ACTION"
+
+	// $ANTLR start "ACTION_CHAR_LITERAL"
+	private void mACTION_CHAR_LITERAL()
+	{
+		try
+		{
+			// Grammars\\ANTLR.g3:1065:4: ( '\\'' ( ACTION_ESC |~ ( '\\\\' | '\\'' ) )* '\\'' )
+			// Grammars\\ANTLR.g3:1065:4: '\\'' ( ACTION_ESC |~ ( '\\\\' | '\\'' ) )* '\\''
+			{
+			Match('\''); if (state.failed) return ;
+			// Grammars\\ANTLR.g3:1066:3: ( ACTION_ESC |~ ( '\\\\' | '\\'' ) )*
+			for ( ; ; )
+			{
+				int alt20=3;
+				int LA20_0 = input.LA(1);
+
+				if ( (LA20_0=='\\') )
+				{
+					alt20=1;
+				}
+				else if ( ((LA20_0>='\u0000' && LA20_0<='&')||(LA20_0>='(' && LA20_0<='[')||(LA20_0>=']' && LA20_0<='\uFFFF')) )
+				{
+					alt20=2;
+				}
+
+
+				switch ( alt20 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:1066:5: ACTION_ESC
+					{
+					mACTION_ESC(); if (state.failed) return ;
+
+					}
+					break;
+				case 2:
+					// Grammars\\ANTLR.g3:1067:5: ~ ( '\\\\' | '\\'' )
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+
+				default:
+					goto loop20;
+				}
+			}
+
+			loop20:
+				;
+
+
+			Match('\''); if (state.failed) return ;
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ACTION_CHAR_LITERAL"
+
+	// $ANTLR start "ACTION_STRING_LITERAL"
+	private void mACTION_STRING_LITERAL()
+	{
+		try
+		{
+			// Grammars\\ANTLR.g3:1074:4: ( '\"' ( ACTION_ESC |~ ( '\\\\' | '\"' ) )* '\"' )
+			// Grammars\\ANTLR.g3:1074:4: '\"' ( ACTION_ESC |~ ( '\\\\' | '\"' ) )* '\"'
+			{
+			Match('\"'); if (state.failed) return ;
+			// Grammars\\ANTLR.g3:1075:3: ( ACTION_ESC |~ ( '\\\\' | '\"' ) )*
+			for ( ; ; )
+			{
+				int alt21=3;
+				int LA21_0 = input.LA(1);
+
+				if ( (LA21_0=='\\') )
+				{
+					alt21=1;
+				}
+				else if ( ((LA21_0>='\u0000' && LA21_0<='!')||(LA21_0>='#' && LA21_0<='[')||(LA21_0>=']' && LA21_0<='\uFFFF')) )
+				{
+					alt21=2;
+				}
+
+
+				switch ( alt21 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:1075:5: ACTION_ESC
+					{
+					mACTION_ESC(); if (state.failed) return ;
+
+					}
+					break;
+				case 2:
+					// Grammars\\ANTLR.g3:1076:5: ~ ( '\\\\' | '\"' )
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+
+				default:
+					goto loop21;
+				}
+			}
+
+			loop21:
+				;
+
+
+			Match('\"'); if (state.failed) return ;
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ACTION_STRING_LITERAL"
+
+	// $ANTLR start "ACTION_ESC"
+	private void mACTION_ESC()
+	{
+		try
+		{
+			// Grammars\\ANTLR.g3:1083:4: ( '\\\\\\'' | '\\\\\\\"' | '\\\\' ~ ( '\\'' | '\"' ) )
+			int alt22=3;
+			int LA22_0 = input.LA(1);
+
+			if ( (LA22_0=='\\') )
+			{
+				int LA22_1 = input.LA(2);
+
+				if ( (LA22_1=='\'') )
+				{
+					alt22=1;
+				}
+				else if ( (LA22_1=='\"') )
+				{
+					alt22=2;
+				}
+				else if ( ((LA22_1>='\u0000' && LA22_1<='!')||(LA22_1>='#' && LA22_1<='&')||(LA22_1>='(' && LA22_1<='\uFFFF')) )
+				{
+					alt22=3;
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return ;}
+					NoViableAltException nvae = new NoViableAltException("", 22, 1, input);
+
+					throw nvae;
+				}
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				NoViableAltException nvae = new NoViableAltException("", 22, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt22 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:1083:4: '\\\\\\''
+				{
+				Match("\\'"); if (state.failed) return ;
+
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:1084:4: '\\\\\\\"'
+				{
+				Match("\\\""); if (state.failed) return ;
+
+
+				}
+				break;
+			case 3:
+				// Grammars\\ANTLR.g3:1085:4: '\\\\' ~ ( '\\'' | '\"' )
+				{
+				Match('\\'); if (state.failed) return ;
+				input.Consume();
+				state.failed=false;
+
+				}
+				break;
+
+			}
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ACTION_ESC"
+
+	// $ANTLR start "TOKEN_REF"
+	private void mTOKEN_REF()
+	{
+		try
+		{
+			int _type = TOKEN_REF;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:1088:4: ( 'A' .. 'Z' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
+			// Grammars\\ANTLR.g3:1088:4: 'A' .. 'Z' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
+			{
+			MatchRange('A','Z'); if (state.failed) return ;
+			// Grammars\\ANTLR.g3:1089:3: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
+			for ( ; ; )
+			{
+				int alt23=2;
+				int LA23_0 = input.LA(1);
+
+				if ( ((LA23_0>='0' && LA23_0<='9')||(LA23_0>='A' && LA23_0<='Z')||LA23_0=='_'||(LA23_0>='a' && LA23_0<='z')) )
+				{
+					alt23=1;
+				}
+
+
+				switch ( alt23 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+
+				default:
+					goto loop23;
+				}
+			}
+
+			loop23:
+				;
+
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "TOKEN_REF"
+
+	// $ANTLR start "TOKENS"
+	private void mTOKENS()
+	{
+		try
+		{
+			int _type = TOKENS;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:1094:4: ( 'tokens' WS_LOOP '{' )
+			// Grammars\\ANTLR.g3:1094:4: 'tokens' WS_LOOP '{'
+			{
+			Match("tokens"); if (state.failed) return ;
+
+			mWS_LOOP(); if (state.failed) return ;
+			Match('{'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "TOKENS"
+
+	// $ANTLR start "OPTIONS"
+	private void mOPTIONS()
+	{
+		try
+		{
+			int _type = OPTIONS;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ANTLR.g3:1098:4: ( 'options' WS_LOOP '{' )
+			// Grammars\\ANTLR.g3:1098:4: 'options' WS_LOOP '{'
+			{
+			Match("options"); if (state.failed) return ;
+
+			mWS_LOOP(); if (state.failed) return ;
+			Match('{'); if (state.failed) return ;
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "OPTIONS"
+
+	// $ANTLR start "RULE_REF"
+	private void mRULE_REF()
+	{
+		try
+		{
+			int _type = RULE_REF;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+
+				int t=0;
+
+			// Grammars\\ANTLR.g3:1107:4: ( 'a' .. 'z' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
+			// Grammars\\ANTLR.g3:1107:4: 'a' .. 'z' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
+			{
+			MatchRange('a','z'); if (state.failed) return ;
+			// Grammars\\ANTLR.g3:1107:13: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
+			for ( ; ; )
+			{
+				int alt24=2;
+				int LA24_0 = input.LA(1);
+
+				if ( ((LA24_0>='0' && LA24_0<='9')||(LA24_0>='A' && LA24_0<='Z')||LA24_0=='_'||(LA24_0>='a' && LA24_0<='z')) )
+				{
+					alt24=1;
+				}
+
+
+				switch ( alt24 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+
+				default:
+					goto loop24;
+				}
+			}
+
+			loop24:
+				;
+
+
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "RULE_REF"
+
+	// $ANTLR start "WS_LOOP"
+	private void mWS_LOOP()
+	{
+		try
+		{
+			// Grammars\\ANTLR.g3:1113:4: ( ( WS | COMMENT )* )
+			// Grammars\\ANTLR.g3:1113:4: ( WS | COMMENT )*
+			{
+			// Grammars\\ANTLR.g3:1113:4: ( WS | COMMENT )*
+			for ( ; ; )
+			{
+				int alt25=3;
+				int LA25_0 = input.LA(1);
+
+				if ( ((LA25_0>='\t' && LA25_0<='\n')||LA25_0=='\r'||LA25_0==' ') )
+				{
+					alt25=1;
+				}
+				else if ( (LA25_0=='/') )
+				{
+					alt25=2;
+				}
+
+
+				switch ( alt25 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:1113:6: WS
+					{
+					mWS(); if (state.failed) return ;
+
+					}
+					break;
+				case 2:
+					// Grammars\\ANTLR.g3:1114:5: COMMENT
+					{
+					mCOMMENT(); if (state.failed) return ;
+
+					}
+					break;
+
+				default:
+					goto loop25;
+				}
+			}
+
+			loop25:
+				;
+
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "WS_LOOP"
+
+	// $ANTLR start "WS_OPT"
+	private void mWS_OPT()
+	{
+		try
+		{
+			// Grammars\\ANTLR.g3:1120:4: ( ( WS )? )
+			// Grammars\\ANTLR.g3:1120:4: ( WS )?
+			{
+			// Grammars\\ANTLR.g3:1120:4: ( WS )?
+			int alt26=2;
+			int LA26_0 = input.LA(1);
+
+			if ( ((LA26_0>='\t' && LA26_0<='\n')||LA26_0=='\r'||LA26_0==' ') )
+			{
+				alt26=1;
+			}
+			switch ( alt26 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:1120:5: WS
+				{
+				mWS(); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "WS_OPT"
+
+	// $ANTLR start "SRC"
+	private void mSRC()
+	{
+		try
+		{
+			IToken file=null;
+			IToken line=null;
+
+			// Grammars\\ANTLR.g3:1133:4: ( 'src' ' ' file= ACTION_STRING_LITERAL ' ' line= INT )
+			// Grammars\\ANTLR.g3:1133:4: 'src' ' ' file= ACTION_STRING_LITERAL ' ' line= INT
+			{
+			Match("src"); if (state.failed) return ;
+
+			Match(' '); if (state.failed) return ;
+			int fileStart1406 = GetCharIndex();
+			mACTION_STRING_LITERAL(); if (state.failed) return ;
+			file = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, fileStart1406, GetCharIndex()-1);
+			Match(' '); if (state.failed) return ;
+			int lineStart1412 = GetCharIndex();
+			mINT(); if (state.failed) return ;
+			line = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, lineStart1412, GetCharIndex()-1);
+			if ( state.backtracking == 0 )
+			{
+
+							Filename = (file!=null?file.Text:null).Substring(1,(file!=null?file.Text:null).Length-2);
+							Line = int.Parse((line!=null?line.Text:null)) - 1;  // -1 because SL_COMMENT will increment the line no. KR
+
+			}
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "SRC"
+
+	public override void mTokens()
+	{
+		// Grammars\\ANTLR.g3:1:10: ( CATCH | FINALLY | FRAGMENT | GRAMMAR | IMPORT | LEXER | PARSER | PRIVATE | PROTECTED | PUBLIC | RETURNS | SCOPE | THROWS | TREE | WS | COMMENT | OPEN_ELEMENT_OPTION | CLOSE_ELEMENT_OPTION | AMPERSAND | COMMA | QUESTION | TREE_BEGIN | LPAREN | RPAREN | COLON | STAR | PLUS | ASSIGN | PLUS_ASSIGN | IMPLIES | REWRITE | SEMI | ROOT | BANG | OR | WILDCARD | ETC | RANGE | NOT | RCURLY | DOLLAR | STRAY_BRACKET | CHAR_LITERAL | DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL | INT | ARG_ACTION | ACTION | TOKEN_REF | TOKENS | OPTIONS | RULE_REF )
+		int alt27=52;
+		alt27 = dfa27.Predict(input);
+		switch ( alt27 )
+		{
+		case 1:
+			// Grammars\\ANTLR.g3:1:10: CATCH
+			{
+			mCATCH(); if (state.failed) return ;
+
+			}
+			break;
+		case 2:
+			// Grammars\\ANTLR.g3:1:16: FINALLY
+			{
+			mFINALLY(); if (state.failed) return ;
+
+			}
+			break;
+		case 3:
+			// Grammars\\ANTLR.g3:1:24: FRAGMENT
+			{
+			mFRAGMENT(); if (state.failed) return ;
+
+			}
+			break;
+		case 4:
+			// Grammars\\ANTLR.g3:1:33: GRAMMAR
+			{
+			mGRAMMAR(); if (state.failed) return ;
+
+			}
+			break;
+		case 5:
+			// Grammars\\ANTLR.g3:1:41: IMPORT
+			{
+			mIMPORT(); if (state.failed) return ;
+
+			}
+			break;
+		case 6:
+			// Grammars\\ANTLR.g3:1:48: LEXER
+			{
+			mLEXER(); if (state.failed) return ;
+
+			}
+			break;
+		case 7:
+			// Grammars\\ANTLR.g3:1:54: PARSER
+			{
+			mPARSER(); if (state.failed) return ;
+
+			}
+			break;
+		case 8:
+			// Grammars\\ANTLR.g3:1:61: PRIVATE
+			{
+			mPRIVATE(); if (state.failed) return ;
+
+			}
+			break;
+		case 9:
+			// Grammars\\ANTLR.g3:1:69: PROTECTED
+			{
+			mPROTECTED(); if (state.failed) return ;
+
+			}
+			break;
+		case 10:
+			// Grammars\\ANTLR.g3:1:79: PUBLIC
+			{
+			mPUBLIC(); if (state.failed) return ;
+
+			}
+			break;
+		case 11:
+			// Grammars\\ANTLR.g3:1:86: RETURNS
+			{
+			mRETURNS(); if (state.failed) return ;
+
+			}
+			break;
+		case 12:
+			// Grammars\\ANTLR.g3:1:94: SCOPE
+			{
+			mSCOPE(); if (state.failed) return ;
+
+			}
+			break;
+		case 13:
+			// Grammars\\ANTLR.g3:1:100: THROWS
+			{
+			mTHROWS(); if (state.failed) return ;
+
+			}
+			break;
+		case 14:
+			// Grammars\\ANTLR.g3:1:107: TREE
+			{
+			mTREE(); if (state.failed) return ;
+
+			}
+			break;
+		case 15:
+			// Grammars\\ANTLR.g3:1:112: WS
+			{
+			mWS(); if (state.failed) return ;
+
+			}
+			break;
+		case 16:
+			// Grammars\\ANTLR.g3:1:115: COMMENT
+			{
+			mCOMMENT(); if (state.failed) return ;
+
+			}
+			break;
+		case 17:
+			// Grammars\\ANTLR.g3:1:123: OPEN_ELEMENT_OPTION
+			{
+			mOPEN_ELEMENT_OPTION(); if (state.failed) return ;
+
+			}
+			break;
+		case 18:
+			// Grammars\\ANTLR.g3:1:143: CLOSE_ELEMENT_OPTION
+			{
+			mCLOSE_ELEMENT_OPTION(); if (state.failed) return ;
+
+			}
+			break;
+		case 19:
+			// Grammars\\ANTLR.g3:1:164: AMPERSAND
+			{
+			mAMPERSAND(); if (state.failed) return ;
+
+			}
+			break;
+		case 20:
+			// Grammars\\ANTLR.g3:1:174: COMMA
+			{
+			mCOMMA(); if (state.failed) return ;
+
+			}
+			break;
+		case 21:
+			// Grammars\\ANTLR.g3:1:180: QUESTION
+			{
+			mQUESTION(); if (state.failed) return ;
+
+			}
+			break;
+		case 22:
+			// Grammars\\ANTLR.g3:1:189: TREE_BEGIN
+			{
+			mTREE_BEGIN(); if (state.failed) return ;
+
+			}
+			break;
+		case 23:
+			// Grammars\\ANTLR.g3:1:200: LPAREN
+			{
+			mLPAREN(); if (state.failed) return ;
+
+			}
+			break;
+		case 24:
+			// Grammars\\ANTLR.g3:1:207: RPAREN
+			{
+			mRPAREN(); if (state.failed) return ;
+
+			}
+			break;
+		case 25:
+			// Grammars\\ANTLR.g3:1:214: COLON
+			{
+			mCOLON(); if (state.failed) return ;
+
+			}
+			break;
+		case 26:
+			// Grammars\\ANTLR.g3:1:220: STAR
+			{
+			mSTAR(); if (state.failed) return ;
+
+			}
+			break;
+		case 27:
+			// Grammars\\ANTLR.g3:1:225: PLUS
+			{
+			mPLUS(); if (state.failed) return ;
+
+			}
+			break;
+		case 28:
+			// Grammars\\ANTLR.g3:1:230: ASSIGN
+			{
+			mASSIGN(); if (state.failed) return ;
+
+			}
+			break;
+		case 29:
+			// Grammars\\ANTLR.g3:1:237: PLUS_ASSIGN
+			{
+			mPLUS_ASSIGN(); if (state.failed) return ;
+
+			}
+			break;
+		case 30:
+			// Grammars\\ANTLR.g3:1:249: IMPLIES
+			{
+			mIMPLIES(); if (state.failed) return ;
+
+			}
+			break;
+		case 31:
+			// Grammars\\ANTLR.g3:1:257: REWRITE
+			{
+			mREWRITE(); if (state.failed) return ;
+
+			}
+			break;
+		case 32:
+			// Grammars\\ANTLR.g3:1:265: SEMI
+			{
+			mSEMI(); if (state.failed) return ;
+
+			}
+			break;
+		case 33:
+			// Grammars\\ANTLR.g3:1:270: ROOT
+			{
+			mROOT(); if (state.failed) return ;
+
+			}
+			break;
+		case 34:
+			// Grammars\\ANTLR.g3:1:275: BANG
+			{
+			mBANG(); if (state.failed) return ;
+
+			}
+			break;
+		case 35:
+			// Grammars\\ANTLR.g3:1:280: OR
+			{
+			mOR(); if (state.failed) return ;
+
+			}
+			break;
+		case 36:
+			// Grammars\\ANTLR.g3:1:283: WILDCARD
+			{
+			mWILDCARD(); if (state.failed) return ;
+
+			}
+			break;
+		case 37:
+			// Grammars\\ANTLR.g3:1:292: ETC
+			{
+			mETC(); if (state.failed) return ;
+
+			}
+			break;
+		case 38:
+			// Grammars\\ANTLR.g3:1:296: RANGE
+			{
+			mRANGE(); if (state.failed) return ;
+
+			}
+			break;
+		case 39:
+			// Grammars\\ANTLR.g3:1:302: NOT
+			{
+			mNOT(); if (state.failed) return ;
+
+			}
+			break;
+		case 40:
+			// Grammars\\ANTLR.g3:1:306: RCURLY
+			{
+			mRCURLY(); if (state.failed) return ;
+
+			}
+			break;
+		case 41:
+			// Grammars\\ANTLR.g3:1:313: DOLLAR
+			{
+			mDOLLAR(); if (state.failed) return ;
+
+			}
+			break;
+		case 42:
+			// Grammars\\ANTLR.g3:1:320: STRAY_BRACKET
+			{
+			mSTRAY_BRACKET(); if (state.failed) return ;
+
+			}
+			break;
+		case 43:
+			// Grammars\\ANTLR.g3:1:334: CHAR_LITERAL
+			{
+			mCHAR_LITERAL(); if (state.failed) return ;
+
+			}
+			break;
+		case 44:
+			// Grammars\\ANTLR.g3:1:347: DOUBLE_QUOTE_STRING_LITERAL
+			{
+			mDOUBLE_QUOTE_STRING_LITERAL(); if (state.failed) return ;
+
+			}
+			break;
+		case 45:
+			// Grammars\\ANTLR.g3:1:375: DOUBLE_ANGLE_STRING_LITERAL
+			{
+			mDOUBLE_ANGLE_STRING_LITERAL(); if (state.failed) return ;
+
+			}
+			break;
+		case 46:
+			// Grammars\\ANTLR.g3:1:403: INT
+			{
+			mINT(); if (state.failed) return ;
+
+			}
+			break;
+		case 47:
+			// Grammars\\ANTLR.g3:1:407: ARG_ACTION
+			{
+			mARG_ACTION(); if (state.failed) return ;
+
+			}
+			break;
+		case 48:
+			// Grammars\\ANTLR.g3:1:418: ACTION
+			{
+			mACTION(); if (state.failed) return ;
+
+			}
+			break;
+		case 49:
+			// Grammars\\ANTLR.g3:1:425: TOKEN_REF
+			{
+			mTOKEN_REF(); if (state.failed) return ;
+
+			}
+			break;
+		case 50:
+			// Grammars\\ANTLR.g3:1:435: TOKENS
+			{
+			mTOKENS(); if (state.failed) return ;
+
+			}
+			break;
+		case 51:
+			// Grammars\\ANTLR.g3:1:442: OPTIONS
+			{
+			mOPTIONS(); if (state.failed) return ;
+
+			}
+			break;
+		case 52:
+			// Grammars\\ANTLR.g3:1:450: RULE_REF
+			{
+			mRULE_REF(); if (state.failed) return ;
+
+			}
+			break;
+
+		}
+
+	}
+
+	// $ANTLR start synpred1_ANTLR
+	public void synpred1_ANTLR_fragment()
+	{
+		// Grammars\\ANTLR.g3:841:5: ( ' $ANTLR' )
+		// Grammars\\ANTLR.g3:841:6: ' $ANTLR'
+		{
+		Match(" $ANTLR"); if (state.failed) return ;
+
+
+		}
+	}
+	// $ANTLR end synpred1_ANTLR
+
+	// $ANTLR start synpred2_ANTLR
+	public void synpred2_ANTLR_fragment()
+	{
+		// Grammars\\ANTLR.g3:853:5: ( '*' ~ '/' )
+		// Grammars\\ANTLR.g3:853:6: '*' ~ '/'
+		{
+		Match('*'); if (state.failed) return ;
+		if ( (input.LA(1)>='\u0000' && input.LA(1)<='.')||(input.LA(1)>='0' && input.LA(1)<='\uFFFF') )
+		{
+			input.Consume();
+		state.failed=false;
+		}
+		else
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			MismatchedSetException mse = new MismatchedSetException(null,input);
+			Recover(mse);
+			throw mse;}
+
+
+		}
+	}
+	// $ANTLR end synpred2_ANTLR
+
+	// $ANTLR start synpred3_ANTLR
+	public void synpred3_ANTLR_fragment()
+	{
+		// Grammars\\ANTLR.g3:856:5: ( '*' ~ '/' )
+		// Grammars\\ANTLR.g3:856:6: '*' ~ '/'
+		{
+		Match('*'); if (state.failed) return ;
+		if ( (input.LA(1)>='\u0000' && input.LA(1)<='.')||(input.LA(1)>='0' && input.LA(1)<='\uFFFF') )
+		{
+			input.Consume();
+		state.failed=false;
+		}
+		else
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			MismatchedSetException mse = new MismatchedSetException(null,input);
+			Recover(mse);
+			throw mse;}
+
+
+		}
+	}
+	// $ANTLR end synpred3_ANTLR
+
+	// $ANTLR start synpred4_ANTLR
+	public void synpred4_ANTLR_fragment()
+	{
+		// Grammars\\ANTLR.g3:948:5: ( '\\\\\\\"' )
+		// Grammars\\ANTLR.g3:948:6: '\\\\\\\"'
+		{
+		Match("\\\""); if (state.failed) return ;
+
+
+		}
+	}
+	// $ANTLR end synpred4_ANTLR
+
+	// $ANTLR start synpred5_ANTLR
+	public void synpred5_ANTLR_fragment()
+	{
+		// Grammars\\ANTLR.g3:961:5: ( '>' ~ '>' )
+		// Grammars\\ANTLR.g3:961:6: '>' ~ '>'
+		{
+		Match('>'); if (state.failed) return ;
+		if ( (input.LA(1)>='\u0000' && input.LA(1)<='=')||(input.LA(1)>='?' && input.LA(1)<='\uFFFF') )
+		{
+			input.Consume();
+		state.failed=false;
+		}
+		else
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			MismatchedSetException mse = new MismatchedSetException(null,input);
+			Recover(mse);
+			throw mse;}
+
+
+		}
+	}
+	// $ANTLR end synpred5_ANTLR
+
+	// $ANTLR start synpred6_ANTLR
+	public void synpred6_ANTLR_fragment()
+	{
+		// Grammars\\ANTLR.g3:1018:6: ( '\\\\]' )
+		// Grammars\\ANTLR.g3:1018:7: '\\\\]'
+		{
+		Match("\\]"); if (state.failed) return ;
+
+
+		}
+	}
+	// $ANTLR end synpred6_ANTLR
+
+	// $ANTLR start synpred7_ANTLR
+	public void synpred7_ANTLR_fragment()
+	{
+		// Grammars\\ANTLR.g3:1055:5: ( '//' | '/*' )
+		int alt28=2;
+		int LA28_0 = input.LA(1);
+
+		if ( (LA28_0=='/') )
+		{
+			int LA28_1 = input.LA(2);
+
+			if ( (LA28_1=='/') )
+			{
+				alt28=1;
+			}
+			else if ( (LA28_1=='*') )
+			{
+				alt28=2;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				NoViableAltException nvae = new NoViableAltException("", 28, 1, input);
+
+				throw nvae;
+			}
+		}
+		else
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			NoViableAltException nvae = new NoViableAltException("", 28, 0, input);
+
+			throw nvae;
+		}
+		switch ( alt28 )
+		{
+		case 1:
+			// Grammars\\ANTLR.g3:1055:6: '//'
+			{
+			Match("//"); if (state.failed) return ;
+
+
+			}
+			break;
+		case 2:
+			// Grammars\\ANTLR.g3:1055:13: '/*'
+			{
+			Match("/*"); if (state.failed) return ;
+
+
+			}
+			break;
+
+		}}
+	// $ANTLR end synpred7_ANTLR
+
+	public bool synpred1_ANTLR()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred1_ANTLR_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred2_ANTLR()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred2_ANTLR_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred3_ANTLR()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred3_ANTLR_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred4_ANTLR()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred4_ANTLR_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred5_ANTLR()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred5_ANTLR_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred6_ANTLR()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred6_ANTLR_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred7_ANTLR()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred7_ANTLR_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+
+
+	#region DFA
+	DFA9 dfa9;
+	DFA15 dfa15;
+	DFA27 dfa27;
+
+	protected override void InitDFAs()
+	{
+		base.InitDFAs();
+		dfa9 = new DFA9( this, new SpecialStateTransitionHandler( specialStateTransition9 ) );
+		dfa15 = new DFA15( this, new SpecialStateTransitionHandler( specialStateTransition15 ) );
+		dfa27 = new DFA27( this );
+	}
+
+	class DFA9 : DFA
+	{
+
+		const string DFA9_eotS =
+			"\x2\x2\x1\xFFFF\xD\x2\x1\xFFFF\x5\x2\x1\xFFFF\x2\x2\x3\xFFFF\x1\x2\x1"+
+			"\xFFFF";
+		const string DFA9_eofS =
+			"\x1E\xFFFF";
+		const string DFA9_minS =
+			"\x1\x20\x1\x24\x1\xFFFF\x1\x41\x1\x4E\x1\x54\x1\x4C\x1\x52\x1\x20\x1"+
+			"\x73\x1\x72\x1\x63\x1\x20\x1\x22\x3\x0\x1\x20\x7\x0\x3\xFFFF\x1\x30\x1"+
+			"\x0";
+		const string DFA9_maxS =
+			"\x1\x20\x1\x24\x1\xFFFF\x1\x41\x1\x4E\x1\x54\x1\x4C\x1\x52\x1\x20\x1"+
+			"\x73\x1\x72\x1\x63\x1\x20\x1\x22\x3\xFFFF\x1\x20\x7\xFFFF\x3\xFFFF\x1"+
+			"\x39\x1\x0";
+		const string DFA9_acceptS =
+			"\x2\xFFFF\x1\x2\x16\xFFFF\x3\x1\x2\xFFFF";
+		const string DFA9_specialS =
+			"\xE\xFFFF\x1\x0\x1\x1\x1\x2\x1\xFFFF\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1"+
+			"\x8\x1\x9\x4\xFFFF\x1\xA}>";
+		static readonly string[] DFA9_transitionS =
+			{
+				"\x1\x1",
+				"\x1\x3",
+				"",
+				"\x1\x4",
+				"\x1\x5",
+				"\x1\x6",
+				"\x1\x7",
+				"\x1\x8",
+				"\x1\x9",
+				"\x1\xA",
+				"\x1\xB",
+				"\x1\xC",
+				"\x1\xD",
+				"\x1\xE",
+				"\xA\x13\x1\x12\x2\x13\x1\x10\x14\x13\x1\x11\x39\x13\x1\xF\xFFA3\x13",
+				"\xA\x18\x1\x17\x2\x18\x1\x16\x14\x18\x1\x15\x4\x18\x1\x14\xFFD8\x18",
+				"\xA\x1B\x1\x12\x17\x1B\x1\x19\x39\x1B\x1\x1A\xFFA3\x1B",
+				"\x1\x1C",
+				"\x22\x1B\x1\x19\x39\x1B\x1\x1A\xFFA3\x1B",
+				"\xA\x13\x1\x12\x2\x13\x1\x10\x14\x13\x1\x11\x39\x13\x1\xF\xFFA3\x13",
+				"\xA\x13\x1\x12\x2\x13\x1\x10\x14\x13\x1\x11\x39\x13\x1\xF\xFFA3\x13",
+				"\xA\x13\x1\x12\x2\x13\x1\x10\x14\x13\x1\x11\x39\x13\x1\xF\xFFA3\x13",
+				"\xA\x1B\x1\x12\x17\x1B\x1\x19\x39\x1B\x1\x1A\xFFA3\x1B",
+				"\x22\x1B\x1\x19\x39\x1B\x1\x1A\xFFA3\x1B",
+				"\xA\x13\x1\x12\x2\x13\x1\x10\x14\x13\x1\x11\x39\x13\x1\xF\xFFA3\x13",
+				"",
+				"",
+				"",
+				"\xA\x1D",
+				"\x1\xFFFF"
+			};
+
+		static readonly short[] DFA9_eot = DFA.UnpackEncodedString(DFA9_eotS);
+		static readonly short[] DFA9_eof = DFA.UnpackEncodedString(DFA9_eofS);
+		static readonly char[] DFA9_min = DFA.UnpackEncodedStringToUnsignedChars(DFA9_minS);
+		static readonly char[] DFA9_max = DFA.UnpackEncodedStringToUnsignedChars(DFA9_maxS);
+		static readonly short[] DFA9_accept = DFA.UnpackEncodedString(DFA9_acceptS);
+		static readonly short[] DFA9_special = DFA.UnpackEncodedString(DFA9_specialS);
+		static readonly short[][] DFA9_transition;
+
+		static DFA9()
+		{
+			int numStates = DFA9_transitionS.Length;
+			DFA9_transition = new short[numStates][];
+			for ( int i=0; i < numStates; i++ )
+			{
+				DFA9_transition[i] = DFA.UnpackEncodedString(DFA9_transitionS[i]);
+			}
+		}
+
+		public DFA9( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
+			: base( specialStateTransition )	{
+			this.recognizer = recognizer;
+			this.decisionNumber = 9;
+			this.eot = DFA9_eot;
+			this.eof = DFA9_eof;
+			this.min = DFA9_min;
+			this.max = DFA9_max;
+			this.accept = DFA9_accept;
+			this.special = DFA9_special;
+			this.transition = DFA9_transition;
+		}
+		public override string GetDescription()
+		{
+			return "841:3: (=> ' $ANTLR ' SRC ( ( '\\r' )? '\\n' )? | (~ ( '\\r' | '\\n' ) )* ( ( '\\r' )? '\\n' )? )";
+		}
+	}
+
+	int specialStateTransition9( DFA dfa, int s, IIntStream _input )
+	{
+		IIntStream input = _input;
+		int _s = s;
+		switch ( s )
+		{
+
+			case 0:
+				int LA9_14 = input.LA(1);
+
+				s = -1;
+				if ( (LA9_14=='\\') ) {s = 15;}
+
+				else if ( (LA9_14=='\r') ) {s = 16;}
+
+				else if ( (LA9_14=='\"') ) {s = 17;}
+
+				else if ( (LA9_14=='\n') ) {s = 18;}
+
+				else if ( ((LA9_14>='\u0000' && LA9_14<='\t')||(LA9_14>='\u000B' && LA9_14<='\f')||(LA9_14>='\u000E' && LA9_14<='!')||(LA9_14>='#' && LA9_14<='[')||(LA9_14>=']' && LA9_14<='\uFFFF')) ) {s = 19;}
+
+				else s = 2;
+
+				if ( s>=0 ) return s;
+				break;
+
+			case 1:
+				int LA9_15 = input.LA(1);
+
+				s = -1;
+				if ( (LA9_15=='\'') ) {s = 20;}
+
+				else if ( (LA9_15=='\"') ) {s = 21;}
+
+				else if ( (LA9_15=='\r') ) {s = 22;}
+
+				else if ( (LA9_15=='\n') ) {s = 23;}
+
+				else if ( ((LA9_15>='\u0000' && LA9_15<='\t')||(LA9_15>='\u000B' && LA9_15<='\f')||(LA9_15>='\u000E' && LA9_15<='!')||(LA9_15>='#' && LA9_15<='&')||(LA9_15>='(' && LA9_15<='\uFFFF')) ) {s = 24;}
+
+				else s = 2;
+
+				if ( s>=0 ) return s;
+				break;
+
+			case 2:
+				int LA9_16 = input.LA(1);
+
+
+				int index9_16 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (LA9_16=='\"') && (synpred1_ANTLR())) {s = 25;}
+
+				else if ( (LA9_16=='\\') && (synpred1_ANTLR())) {s = 26;}
+
+				else if ( (LA9_16=='\n') ) {s = 18;}
+
+				else if ( ((LA9_16>='\u0000' && LA9_16<='\t')||(LA9_16>='\u000B' && LA9_16<='!')||(LA9_16>='#' && LA9_16<='[')||(LA9_16>=']' && LA9_16<='\uFFFF')) && (synpred1_ANTLR())) {s = 27;}
+
+
+				input.Seek(index9_16);
+				if ( s>=0 ) return s;
+				break;
+
+			case 3:
+				int LA9_18 = input.LA(1);
+
+
+				int index9_18 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (LA9_18=='\"') && (synpred1_ANTLR())) {s = 25;}
+
+				else if ( (LA9_18=='\\') && (synpred1_ANTLR())) {s = 26;}
+
+				else if ( ((LA9_18>='\u0000' && LA9_18<='!')||(LA9_18>='#' && LA9_18<='[')||(LA9_18>=']' && LA9_18<='\uFFFF')) && (synpred1_ANTLR())) {s = 27;}
+
+				else s = 2;
+
+
+				input.Seek(index9_18);
+				if ( s>=0 ) return s;
+				break;
+
+			case 4:
+				int LA9_19 = input.LA(1);
+
+				s = -1;
+				if ( (LA9_19=='\"') ) {s = 17;}
+
+				else if ( (LA9_19=='\\') ) {s = 15;}
+
+				else if ( (LA9_19=='\r') ) {s = 16;}
+
+				else if ( (LA9_19=='\n') ) {s = 18;}
+
+				else if ( ((LA9_19>='\u0000' && LA9_19<='\t')||(LA9_19>='\u000B' && LA9_19<='\f')||(LA9_19>='\u000E' && LA9_19<='!')||(LA9_19>='#' && LA9_19<='[')||(LA9_19>=']' && LA9_19<='\uFFFF')) ) {s = 19;}
+
+				else s = 2;
+
+				if ( s>=0 ) return s;
+				break;
+
+			case 5:
+				int LA9_20 = input.LA(1);
+
+				s = -1;
+				if ( (LA9_20=='\"') ) {s = 17;}
+
+				else if ( (LA9_20=='\\') ) {s = 15;}
+
+				else if ( (LA9_20=='\r') ) {s = 16;}
+
+				else if ( (LA9_20=='\n') ) {s = 18;}
+
+				else if ( ((LA9_20>='\u0000' && LA9_20<='\t')||(LA9_20>='\u000B' && LA9_20<='\f')||(LA9_20>='\u000E' && LA9_20<='!')||(LA9_20>='#' && LA9_20<='[')||(LA9_20>=']' && LA9_20<='\uFFFF')) ) {s = 19;}
+
+				else s = 2;
+
+				if ( s>=0 ) return s;
+				break;
+
+			case 6:
+				int LA9_21 = input.LA(1);
+
+				s = -1;
+				if ( (LA9_21=='\"') ) {s = 17;}
+
+				else if ( (LA9_21=='\\') ) {s = 15;}
+
+				else if ( (LA9_21=='\r') ) {s = 16;}
+
+				else if ( (LA9_21=='\n') ) {s = 18;}
+
+				else if ( ((LA9_21>='\u0000' && LA9_21<='\t')||(LA9_21>='\u000B' && LA9_21<='\f')||(LA9_21>='\u000E' && LA9_21<='!')||(LA9_21>='#' && LA9_21<='[')||(LA9_21>=']' && LA9_21<='\uFFFF')) ) {s = 19;}
+
+				else s = 2;
+
+				if ( s>=0 ) return s;
+				break;
+
+			case 7:
+				int LA9_22 = input.LA(1);
+
+
+				int index9_22 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (LA9_22=='\"') && (synpred1_ANTLR())) {s = 25;}
+
+				else if ( (LA9_22=='\\') && (synpred1_ANTLR())) {s = 26;}
+
+				else if ( (LA9_22=='\n') ) {s = 18;}
+
+				else if ( ((LA9_22>='\u0000' && LA9_22<='\t')||(LA9_22>='\u000B' && LA9_22<='!')||(LA9_22>='#' && LA9_22<='[')||(LA9_22>=']' && LA9_22<='\uFFFF')) && (synpred1_ANTLR())) {s = 27;}
+
+
+				input.Seek(index9_22);
+				if ( s>=0 ) return s;
+				break;
+
+			case 8:
+				int LA9_23 = input.LA(1);
+
+
+				int index9_23 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (LA9_23=='\"') && (synpred1_ANTLR())) {s = 25;}
+
+				else if ( (LA9_23=='\\') && (synpred1_ANTLR())) {s = 26;}
+
+				else if ( ((LA9_23>='\u0000' && LA9_23<='!')||(LA9_23>='#' && LA9_23<='[')||(LA9_23>=']' && LA9_23<='\uFFFF')) && (synpred1_ANTLR())) {s = 27;}
+
+				else s = 2;
+
+
+				input.Seek(index9_23);
+				if ( s>=0 ) return s;
+				break;
+
+			case 9:
+				int LA9_24 = input.LA(1);
+
+				s = -1;
+				if ( (LA9_24=='\"') ) {s = 17;}
+
+				else if ( (LA9_24=='\\') ) {s = 15;}
+
+				else if ( (LA9_24=='\r') ) {s = 16;}
+
+				else if ( (LA9_24=='\n') ) {s = 18;}
+
+				else if ( ((LA9_24>='\u0000' && LA9_24<='\t')||(LA9_24>='\u000B' && LA9_24<='\f')||(LA9_24>='\u000E' && LA9_24<='!')||(LA9_24>='#' && LA9_24<='[')||(LA9_24>=']' && LA9_24<='\uFFFF')) ) {s = 19;}
+
+				else s = 2;
+
+				if ( s>=0 ) return s;
+				break;
+
+			case 10:
+				int LA9_29 = input.LA(1);
+
+
+				int index9_29 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred1_ANTLR()) ) {s = 27;}
+
+				else if ( (true) ) {s = 2;}
+
+
+				input.Seek(index9_29);
+				if ( s>=0 ) return s;
+				break;
+		}
+		if (state.backtracking>0) {state.failed=true; return -1;}
+		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 9, _s, input);
+		dfa.Error(nvae);
+		throw nvae;
+	}
+	class DFA15 : DFA
+	{
+
+		const string DFA15_eotS =
+			"\xA\xFFFF\x1\xB\x2\xFFFF";
+		const string DFA15_eofS =
+			"\xD\xFFFF";
+		const string DFA15_minS =
+			"\x1\x0\x9\xFFFF\x1\x30\x2\xFFFF";
+		const string DFA15_maxS =
+			"\x1\xFFFF\x9\xFFFF\x1\x66\x2\xFFFF";
+		const string DFA15_acceptS =
+			"\x1\xFFFF\x1\x1\x1\x2\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9\x1\xFFFF"+
+			"\x1\xB\x1\xA";
+		const string DFA15_specialS =
+			"\x1\x0\xC\xFFFF}>";
+		static readonly string[] DFA15_transitionS =
+			{
+				"\x22\xB\x1\x6\x4\xB\x1\x7\x16\xB\x1\x9\x1D\xB\x1\x8\x5\xB\x1\x4\x3\xB"+
+				"\x1\x5\x7\xB\x1\x1\x3\xB\x1\x2\x1\xB\x1\x3\x1\xA\xFF8A\xB",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"\xA\xC\x7\xFFFF\x6\xC\x1A\xFFFF\x6\xC",
+				"",
+				""
+			};
+
+		static readonly short[] DFA15_eot = DFA.UnpackEncodedString(DFA15_eotS);
+		static readonly short[] DFA15_eof = DFA.UnpackEncodedString(DFA15_eofS);
+		static readonly char[] DFA15_min = DFA.UnpackEncodedStringToUnsignedChars(DFA15_minS);
+		static readonly char[] DFA15_max = DFA.UnpackEncodedStringToUnsignedChars(DFA15_maxS);
+		static readonly short[] DFA15_accept = DFA.UnpackEncodedString(DFA15_acceptS);
+		static readonly short[] DFA15_special = DFA.UnpackEncodedString(DFA15_specialS);
+		static readonly short[][] DFA15_transition;
+
+		static DFA15()
+		{
+			int numStates = DFA15_transitionS.Length;
+			DFA15_transition = new short[numStates][];
+			for ( int i=0; i < numStates; i++ )
+			{
+				DFA15_transition[i] = DFA.UnpackEncodedString(DFA15_transitionS[i]);
+			}
+		}
+
+		public DFA15( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
+			: base( specialStateTransition )	{
+			this.recognizer = recognizer;
+			this.decisionNumber = 15;
+			this.eot = DFA15_eot;
+			this.eof = DFA15_eof;
+			this.min = DFA15_min;
+			this.max = DFA15_max;
+			this.accept = DFA15_accept;
+			this.special = DFA15_special;
+			this.transition = DFA15_transition;
+		}
+		public override string GetDescription()
+		{
+			return "970:3: ( 'n' | 'r' | 't' | 'b' | 'f' | '\"' | '\\'' | '\\\\' | '>' | 'u' XDIGIT XDIGIT XDIGIT XDIGIT | . )";
+		}
+	}
+
+	int specialStateTransition15( DFA dfa, int s, IIntStream _input )
+	{
+		IIntStream input = _input;
+		int _s = s;
+		switch ( s )
+		{
+
+			case 0:
+				int LA15_0 = input.LA(1);
+
+				s = -1;
+				if ( (LA15_0=='n') ) {s = 1;}
+
+				else if ( (LA15_0=='r') ) {s = 2;}
+
+				else if ( (LA15_0=='t') ) {s = 3;}
+
+				else if ( (LA15_0=='b') ) {s = 4;}
+
+				else if ( (LA15_0=='f') ) {s = 5;}
+
+				else if ( (LA15_0=='\"') ) {s = 6;}
+
+				else if ( (LA15_0=='\'') ) {s = 7;}
+
+				else if ( (LA15_0=='\\') ) {s = 8;}
+
+				else if ( (LA15_0=='>') ) {s = 9;}
+
+				else if ( (LA15_0=='u') ) {s = 10;}
+
+				else if ( ((LA15_0>='\u0000' && LA15_0<='!')||(LA15_0>='#' && LA15_0<='&')||(LA15_0>='(' && LA15_0<='=')||(LA15_0>='?' && LA15_0<='[')||(LA15_0>=']' && LA15_0<='a')||(LA15_0>='c' && LA15_0<='e')||(LA15_0>='g' && LA15_0<='m')||(LA15_0>='o' && LA15_0<='q')||LA15_0=='s'||(LA15_0>='v' && LA15_0<='\uFFFF')) ) {s = 11;}
+
+				if ( s>=0 ) return s;
+				break;
+		}
+		if (state.backtracking>0) {state.failed=true; return -1;}
+		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 15, _s, input);
+		dfa.Error(nvae);
+		throw nvae;
+	}
+	class DFA27 : DFA
+	{
+
+		const string DFA27_eotS =
+			"\x1\xFFFF\x9\x28\x2\xFFFF\x1\x38\x4\xFFFF\x1\x3A\x4\xFFFF\x1\x3C\x1\x3E"+
+			"\x4\xFFFF\x1\x40\xA\xFFFF\x1\x28\x1\xFFFF\xE\x28\x8\xFFFF\x1\x52\x1\xFFFF"+
+			"\x10\x28\x2\xFFFF\xE\x28\x1\x71\x2\x28\x1\x74\x4\x28\x1\x79\x5\x28\x1"+
+			"\x7F\x1\x28\x1\xFFFF\x2\x28\x1\xFFFF\x3\x28\x1\x86\x1\xFFFF\x1\x87\x2"+
+			"\x28\x1\x8A\x1\x28\x1\xFFFF\x1\x8C\x2\x28\x1\x8F\x1\x28\x1\x91\x2\xFFFF"+
+			"\x1\x92\x1\x28\x1\xFFFF\x1\x94\x2\xFFFF\x1\x28\x1\xFFFF\x1\x96\x2\xFFFF"+
+			"\x1\x28\x3\xFFFF\x1\x98\x1\xFFFF";
+		const string DFA27_eofS =
+			"\x99\xFFFF";
+		const string DFA27_minS =
+			"\x1\x9\x1\x61\x1\x69\x1\x72\x1\x6D\x1\x65\x1\x61\x1\x65\x1\x63\x1\x68"+
+			"\x2\xFFFF\x1\x3C\x4\xFFFF\x1\x28\x4\xFFFF\x1\x3D\x1\x3E\x4\xFFFF\x1\x2E"+
+			"\xA\xFFFF\x1\x70\x1\xFFFF\x1\x74\x1\x6E\x2\x61\x1\x70\x1\x78\x1\x72\x1"+
+			"\x69\x1\x62\x1\x74\x1\x6F\x1\x72\x1\x65\x1\x6B\x8\xFFFF\x1\x2E\x1\xFFFF"+
+			"\x1\x74\x1\x63\x1\x61\x1\x67\x1\x6D\x1\x6F\x1\x65\x1\x73\x1\x76\x1\x74"+
+			"\x1\x6C\x1\x75\x1\x70\x1\x6F\x2\x65\x2\xFFFF\x1\x69\x1\x68\x1\x6C\x2"+
+			"\x6D\x2\x72\x1\x65\x1\x61\x1\x65\x1\x69\x1\x72\x1\x65\x1\x77\x1\x30\x1"+
+			"\x6E\x1\x6F\x1\x30\x1\x6C\x1\x65\x1\x61\x1\x74\x1\x30\x1\x72\x1\x74\x2"+
+			"\x63\x1\x6E\x1\x30\x1\x73\x1\xFFFF\x1\x73\x1\x6E\x1\xFFFF\x1\x79\x1\x6E"+
+			"\x1\x72\x1\x30\x1\xFFFF\x1\x30\x1\x65\x1\x74\x1\x30\x1\x73\x1\xFFFF\x1"+
+			"\x30\x1\x9\x1\x73\x1\x30\x1\x74\x1\x30\x2\xFFFF\x1\x30\x1\x65\x1\xFFFF"+
+			"\x1\x30\x2\xFFFF\x1\x9\x1\xFFFF\x1\x30\x2\xFFFF\x1\x64\x3\xFFFF\x1\x30"+
+			"\x1\xFFFF";
+		const string DFA27_maxS =
+			"\x1\x7E\x1\x61\x2\x72\x1\x6D\x1\x65\x1\x75\x1\x65\x1\x63\x1\x72\x2\xFFFF"+
+			"\x1\x3C\x4\xFFFF\x1\x28\x4\xFFFF\x1\x3D\x1\x3E\x4\xFFFF\x1\x2E\xA\xFFFF"+
+			"\x1\x70\x1\xFFFF\x1\x74\x1\x6E\x2\x61\x1\x70\x1\x78\x1\x72\x1\x6F\x1"+
+			"\x62\x1\x74\x1\x6F\x1\x72\x1\x65\x1\x6B\x8\xFFFF\x1\x2E\x1\xFFFF\x1\x74"+
+			"\x1\x63\x1\x61\x1\x67\x1\x6D\x1\x6F\x1\x65\x1\x73\x1\x76\x1\x74\x1\x6C"+
+			"\x1\x75\x1\x70\x1\x6F\x2\x65\x2\xFFFF\x1\x69\x1\x68\x1\x6C\x2\x6D\x2"+
+			"\x72\x1\x65\x1\x61\x1\x65\x1\x69\x1\x72\x1\x65\x1\x77\x1\x7A\x1\x6E\x1"+
+			"\x6F\x1\x7A\x1\x6C\x1\x65\x1\x61\x1\x74\x1\x7A\x1\x72\x1\x74\x2\x63\x1"+
+			"\x6E\x1\x7A\x1\x73\x1\xFFFF\x1\x73\x1\x6E\x1\xFFFF\x1\x79\x1\x6E\x1\x72"+
+			"\x1\x7A\x1\xFFFF\x1\x7A\x1\x65\x1\x74\x1\x7A\x1\x73\x1\xFFFF\x1\x7A\x1"+
+			"\x7B\x1\x73\x1\x7A\x1\x74\x1\x7A\x2\xFFFF\x1\x7A\x1\x65\x1\xFFFF\x1\x7A"+
+			"\x2\xFFFF\x1\x7B\x1\xFFFF\x1\x7A\x2\xFFFF\x1\x64\x3\xFFFF\x1\x7A\x1\xFFFF";
+		const string DFA27_acceptS =
+			"\xA\xFFFF\x1\xF\x1\x10\x1\xFFFF\x1\x12\x1\x13\x1\x14\x1\x15\x1\xFFFF"+
+			"\x1\x17\x1\x18\x1\x19\x1\x1A\x2\xFFFF\x1\x1F\x1\x20\x1\x22\x1\x23\x1"+
+			"\xFFFF\x1\x27\x1\x28\x1\x29\x1\x2A\x1\x2B\x1\x2C\x1\x2E\x1\x2F\x1\x30"+
+			"\x1\x31\x1\xFFFF\x1\x34\xE\xFFFF\x1\x2D\x1\x11\x1\x16\x1\x21\x1\x1D\x1"+
+			"\x1B\x1\x1E\x1\x1C\x1\xFFFF\x1\x24\x10\xFFFF\x1\x25\x1\x26\x1E\xFFFF"+
+			"\x1\xE\x2\xFFFF\x1\x1\x4\xFFFF\x1\x6\x5\xFFFF\x1\xC\x6\xFFFF\x1\x5\x1"+
+			"\x7\x2\xFFFF\x1\xA\x1\xFFFF\x1\xD\x1\x32\x1\xFFFF\x1\x2\x1\xFFFF\x1\x4"+
+			"\x1\x8\x1\xFFFF\x1\xB\x1\x33\x1\x3\x1\xFFFF\x1\x9";
+		const string DFA27_specialS =
+			"\x99\xFFFF}>";
+		static readonly string[] DFA27_transitionS =
+			{
+				"\x2\xA\x2\xFFFF\x1\xA\x12\xFFFF\x1\xA\x1\x1A\x1\x22\x1\xFFFF\x1\x1F"+
+				"\x2\xFFFF\x1\x21\x1\x12\x1\x13\x1\x15\x1\x16\x1\xF\x1\x18\x1\x1C\x1"+
+				"\xB\xA\x23\x1\x14\x1\x19\x1\xC\x1\x17\x1\xD\x1\x10\x1\xE\x1A\x26\x1"+
+				"\x24\x1\xFFFF\x1\x20\x1\x11\x2\xFFFF\x2\x28\x1\x1\x2\x28\x1\x2\x1\x3"+
+				"\x1\x28\x1\x4\x2\x28\x1\x5\x2\x28\x1\x27\x1\x6\x1\x28\x1\x7\x1\x8\x1"+
+				"\x9\x6\x28\x1\x25\x1\x1B\x1\x1E\x1\x1D",
+				"\x1\x29",
+				"\x1\x2A\x8\xFFFF\x1\x2B",
+				"\x1\x2C",
+				"\x1\x2D",
+				"\x1\x2E",
+				"\x1\x2F\x10\xFFFF\x1\x30\x2\xFFFF\x1\x31",
+				"\x1\x32",
+				"\x1\x33",
+				"\x1\x34\x6\xFFFF\x1\x36\x2\xFFFF\x1\x35",
+				"",
+				"",
+				"\x1\x37",
+				"",
+				"",
+				"",
+				"",
+				"\x1\x39",
+				"",
+				"",
+				"",
+				"",
+				"\x1\x3B",
+				"\x1\x3D",
+				"",
+				"",
+				"",
+				"",
+				"\x1\x3F",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"\x1\x41",
+				"",
+				"\x1\x42",
+				"\x1\x43",
+				"\x1\x44",
+				"\x1\x45",
+				"\x1\x46",
+				"\x1\x47",
+				"\x1\x48",
+				"\x1\x49\x5\xFFFF\x1\x4A",
+				"\x1\x4B",
+				"\x1\x4C",
+				"\x1\x4D",
+				"\x1\x4E",
+				"\x1\x4F",
+				"\x1\x50",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"\x1\x51",
+				"",
+				"\x1\x53",
+				"\x1\x54",
+				"\x1\x55",
+				"\x1\x56",
+				"\x1\x57",
+				"\x1\x58",
+				"\x1\x59",
+				"\x1\x5A",
+				"\x1\x5B",
+				"\x1\x5C",
+				"\x1\x5D",
+				"\x1\x5E",
+				"\x1\x5F",
+				"\x1\x60",
+				"\x1\x61",
+				"\x1\x62",
+				"",
+				"",
+				"\x1\x63",
+				"\x1\x64",
+				"\x1\x65",
+				"\x1\x66",
+				"\x1\x67",
+				"\x1\x68",
+				"\x1\x69",
+				"\x1\x6A",
+				"\x1\x6B",
+				"\x1\x6C",
+				"\x1\x6D",
+				"\x1\x6E",
+				"\x1\x6F",
+				"\x1\x70",
+				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
+				"\x1\x72",
+				"\x1\x73",
+				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
+				"\x1\x75",
+				"\x1\x76",
+				"\x1\x77",
+				"\x1\x78",
+				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
+				"\x1\x7A",
+				"\x1\x7B",
+				"\x1\x7C",
+				"\x1\x7D",
+				"\x1\x7E",
+				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
+				"\x1\x80",
+				"",
+				"\x1\x81",
+				"\x1\x82",
+				"",
+				"\x1\x83",
+				"\x1\x84",
+				"\x1\x85",
+				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
+				"",
+				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
+				"\x1\x88",
+				"\x1\x89",
+				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
+				"\x1\x8B",
+				"",
+				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
+				"\x2\x8D\x2\xFFFF\x1\x8D\x12\xFFFF\x1\x8D\xE\xFFFF\x1\x8D\x4B\xFFFF\x1"+
+				"\x8D",
+				"\x1\x8E",
+				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
+				"\x1\x90",
+				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
+				"",
+				"",
+				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
+				"\x1\x93",
+				"",
+				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
+				"",
+				"",
+				"\x2\x95\x2\xFFFF\x1\x95\x12\xFFFF\x1\x95\xE\xFFFF\x1\x95\x4B\xFFFF\x1"+
+				"\x95",
+				"",
+				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
+				"",
+				"",
+				"\x1\x97",
+				"",
+				"",
+				"",
+				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
+				""
+			};
+
+		static readonly short[] DFA27_eot = DFA.UnpackEncodedString(DFA27_eotS);
+		static readonly short[] DFA27_eof = DFA.UnpackEncodedString(DFA27_eofS);
+		static readonly char[] DFA27_min = DFA.UnpackEncodedStringToUnsignedChars(DFA27_minS);
+		static readonly char[] DFA27_max = DFA.UnpackEncodedStringToUnsignedChars(DFA27_maxS);
+		static readonly short[] DFA27_accept = DFA.UnpackEncodedString(DFA27_acceptS);
+		static readonly short[] DFA27_special = DFA.UnpackEncodedString(DFA27_specialS);
+		static readonly short[][] DFA27_transition;
+
+		static DFA27()
+		{
+			int numStates = DFA27_transitionS.Length;
+			DFA27_transition = new short[numStates][];
+			for ( int i=0; i < numStates; i++ )
+			{
+				DFA27_transition[i] = DFA.UnpackEncodedString(DFA27_transitionS[i]);
+			}
+		}
+
+		public DFA27( BaseRecognizer recognizer )
+		{
+			this.recognizer = recognizer;
+			this.decisionNumber = 27;
+			this.eot = DFA27_eot;
+			this.eof = DFA27_eof;
+			this.min = DFA27_min;
+			this.max = DFA27_max;
+			this.accept = DFA27_accept;
+			this.special = DFA27_special;
+			this.transition = DFA27_transition;
+		}
+		public override string GetDescription()
+		{
+			return "1:0: Tokens : ( CATCH | FINALLY | FRAGMENT | GRAMMAR | IMPORT | LEXER | PARSER | PRIVATE | PROTECTED | PUBLIC | RETURNS | SCOPE | THROWS | TREE | WS | COMMENT | OPEN_ELEMENT_OPTION | CLOSE_ELEMENT_OPTION | AMPERSAND | COMMA | QUESTION | TREE_BEGIN | LPAREN | RPAREN | COLON | STAR | PLUS | ASSIGN | PLUS_ASSIGN | IMPLIES | REWRITE | SEMI | ROOT | BANG | OR | WILDCARD | ETC | RANGE | NOT | RCURLY | DOLLAR | STRAY_BRACKET | CHAR_LITERAL | DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL | INT | ARG_ACTION | ACTION | TOKEN_REF | TOKENS | OPTIONS | RULE_REF );";
+		}
+	}
+
+
+	#endregion
+
+}
+
+} // namespace Antlr3.Grammars
diff --git a/Antlr3/Grammars/ANTLRLexerHelper.cs b/Antlr3/Grammars/ANTLRLexerHelper.cs
new file mode 100644
index 0000000..0bce4a5
--- /dev/null
+++ b/Antlr3/Grammars/ANTLRLexerHelper.cs
@@ -0,0 +1,45 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Grammar conversion to ANTLR v3 and C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *	notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	notice, this list of conditions and the following disclaimer in the
+ *	documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *	derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Grammars
+{
+    partial class ANTLRLexer
+    {
+        public bool hasASTOperator = false;
+
+        public string Filename
+        {
+            get;
+            set;
+        }
+    }
+}
diff --git a/Antlr3/Grammars/ANTLRParser.cs b/Antlr3/Grammars/ANTLRParser.cs
new file mode 100644
index 0000000..b92845f
--- /dev/null
+++ b/Antlr3/Grammars/ANTLRParser.cs
@@ -0,0 +1,11199 @@
+// $ANTLR 3.1.2 Grammars\\ANTLR.g3 2009-03-08 16:31:33
+
+// The variable 'variable' is assigned but its value is never used.
+#pragma warning disable 219
+// Unreachable code detected.
+#pragma warning disable 162
+
+
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+using ErrorManager = Antlr3.Tool.ErrorManager;
+using Grammar = Antlr3.Tool.Grammar;
+using GrammarAST = Antlr3.Tool.GrammarAST;
+using IntSet = Antlr3.Misc.IIntSet;
+using StringBuffer = System.Text.StringBuilder;
+using TokenWithIndex = Antlr.Runtime.CommonToken;
+
+
+using System.Collections.Generic;
+using Antlr.Runtime;
+using Stack = System.Collections.Generic.Stack<object>;
+using List = System.Collections.IList;
+using ArrayList = System.Collections.Generic.List<object>;
+using Map = System.Collections.IDictionary;
+using HashMap = System.Collections.Generic.Dictionary<object, object>;
+
+using Antlr.Runtime.Tree;
+using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;
+
+namespace Antlr3.Grammars
+{
+/** Read in an ANTLR grammar and build an AST.  Try not to do
+ *  any actions, just build the tree.
+ *
+ *  The phases are:
+ *
+ *		antlr.g (this file)
+ *		assign.types.g
+ *		define.g
+ *		buildnfa.g
+ *		antlr.print.g (optional)
+ *		codegen.g
+ *
+ *  Terence Parr
+ *  University of San Francisco
+ *  2005
+ */
+public partial class ANTLRParser : Parser
+{
+	public static readonly string[] tokenNames = new string[] {
+		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", "ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARG_ACTION", "ARGLIST", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", "CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", "COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", "DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", "EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", "GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", "LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", "NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", "OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", "RET", "RETURNS", "REWRITE", "ROOT", "RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", "SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYN_SEMPRED", "SYNPRED", "TEMPLATE", "THROWS", "TOKEN_REF", "TOKENS", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", "WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT"
+	};
+	public const int EOF=-1;
+	public const int ACTION=4;
+	public const int ACTION_CHAR_LITERAL=5;
+	public const int ACTION_ESC=6;
+	public const int ACTION_STRING_LITERAL=7;
+	public const int ALT=8;
+	public const int AMPERSAND=9;
+	public const int ARG=10;
+	public const int ARG_ACTION=11;
+	public const int ARGLIST=12;
+	public const int ASSIGN=13;
+	public const int BACKTRACK_SEMPRED=14;
+	public const int BANG=15;
+	public const int BLOCK=16;
+	public const int CATCH=17;
+	public const int CHAR_LITERAL=18;
+	public const int CHAR_RANGE=19;
+	public const int CLOSE_ELEMENT_OPTION=20;
+	public const int CLOSURE=21;
+	public const int COLON=22;
+	public const int COMBINED_GRAMMAR=23;
+	public const int COMMA=24;
+	public const int COMMENT=25;
+	public const int DIGIT=26;
+	public const int DOC_COMMENT=27;
+	public const int DOLLAR=28;
+	public const int DOT=29;
+	public const int DOUBLE_ANGLE_STRING_LITERAL=30;
+	public const int DOUBLE_QUOTE_STRING_LITERAL=31;
+	public const int EOA=32;
+	public const int EOB=33;
+	public const int EOR=34;
+	public const int EPSILON=35;
+	public const int ESC=36;
+	public const int ETC=37;
+	public const int FINALLY=38;
+	public const int FORCED_ACTION=39;
+	public const int FRAGMENT=40;
+	public const int GATED_SEMPRED=41;
+	public const int GRAMMAR=42;
+	public const int ID=43;
+	public const int IMPLIES=44;
+	public const int IMPORT=45;
+	public const int INITACTION=46;
+	public const int INT=47;
+	public const int LABEL=48;
+	public const int LEXER=49;
+	public const int LEXER_GRAMMAR=50;
+	public const int LPAREN=51;
+	public const int ML_COMMENT=52;
+	public const int NESTED_ACTION=53;
+	public const int NESTED_ARG_ACTION=54;
+	public const int NOT=55;
+	public const int OPEN_ELEMENT_OPTION=56;
+	public const int OPTIONAL=57;
+	public const int OPTIONS=58;
+	public const int OR=59;
+	public const int PARSER=60;
+	public const int PARSER_GRAMMAR=61;
+	public const int PLUS=62;
+	public const int PLUS_ASSIGN=63;
+	public const int POSITIVE_CLOSURE=64;
+	public const int PRIVATE=65;
+	public const int PROTECTED=66;
+	public const int PUBLIC=67;
+	public const int QUESTION=68;
+	public const int RANGE=69;
+	public const int RCURLY=70;
+	public const int RET=71;
+	public const int RETURNS=72;
+	public const int REWRITE=73;
+	public const int ROOT=74;
+	public const int RPAREN=75;
+	public const int RULE=76;
+	public const int RULE_REF=77;
+	public const int SCOPE=78;
+	public const int SEMI=79;
+	public const int SEMPRED=80;
+	public const int SL_COMMENT=81;
+	public const int SRC=82;
+	public const int STAR=83;
+	public const int STRAY_BRACKET=84;
+	public const int STRING_LITERAL=85;
+	public const int SYN_SEMPRED=86;
+	public const int SYNPRED=87;
+	public const int TEMPLATE=88;
+	public const int THROWS=89;
+	public const int TOKEN_REF=90;
+	public const int TOKENS=91;
+	public const int TREE=92;
+	public const int TREE_BEGIN=93;
+	public const int TREE_GRAMMAR=94;
+	public const int WILDCARD=95;
+	public const int WS=96;
+	public const int WS_LOOP=97;
+	public const int WS_OPT=98;
+	public const int XDIGIT=99;
+
+	// delegates
+	// delegators
+
+	public ANTLRParser( ITokenStream input )
+		: this( input, new RecognizerSharedState() )
+	{
+	}
+	public ANTLRParser( ITokenStream input, RecognizerSharedState state )
+		: base( input, state )
+	{
+	}
+
+	protected ITreeAdaptor adaptor = new CommonTreeAdaptor();
+
+	public ITreeAdaptor TreeAdaptor
+	{
+		get
+		{
+			return adaptor;
+		}
+		set
+		{
+			this.adaptor = value;
+		}
+	}
+
+	public override string[] GetTokenNames() { return ANTLRParser.tokenNames; }
+	public override string GrammarFileName { get { return "Grammars\\ANTLR.g3"; } }
+
+
+	#region Rules
+	public class grammar__return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "grammar_"
+	// Grammars\\ANTLR.g3:193:0: public grammar_[Grammar g] : ( ACTION )? (cmt= DOC_COMMENT )? gr= grammarType gid= id SEMI ( optionsSpec )? (ig= delegateGrammars )? (ts= tokensSpec )? scopes= attrScopes (a= actions )? r= rules EOF -> ^( $gr $gid ( $cmt)? ( optionsSpec )? ( $ig)? ( $ts)? ( $scopes)? ( $a)? $r) ;
+	public ANTLRParser.grammar__return grammar_( Grammar g )
+	{
+		ANTLRParser.grammar__return retval = new ANTLRParser.grammar__return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken cmt=null;
+		IToken ACTION1=null;
+		IToken SEMI2=null;
+		IToken EOF4=null;
+		ANTLRParser.grammarType_return gr = default(ANTLRParser.grammarType_return);
+		ANTLRParser.id_return gid = default(ANTLRParser.id_return);
+		ANTLRParser.delegateGrammars_return ig = default(ANTLRParser.delegateGrammars_return);
+		ANTLRParser.tokensSpec_return ts = default(ANTLRParser.tokensSpec_return);
+		ANTLRParser.attrScopes_return scopes = default(ANTLRParser.attrScopes_return);
+		ANTLRParser.actions_return a = default(ANTLRParser.actions_return);
+		ANTLRParser.rules_return r = default(ANTLRParser.rules_return);
+		ANTLRParser.optionsSpec_return optionsSpec3 = default(ANTLRParser.optionsSpec_return);
+
+		GrammarAST cmt_tree=null;
+		GrammarAST ACTION1_tree=null;
+		GrammarAST SEMI2_tree=null;
+		GrammarAST EOF4_tree=null;
+		RewriteRuleITokenStream stream_ACTION=new RewriteRuleITokenStream(adaptor,"token ACTION");
+		RewriteRuleITokenStream stream_DOC_COMMENT=new RewriteRuleITokenStream(adaptor,"token DOC_COMMENT");
+		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
+		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
+		RewriteRuleSubtreeStream stream_grammarType=new RewriteRuleSubtreeStream(adaptor,"rule grammarType");
+		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
+		RewriteRuleSubtreeStream stream_optionsSpec=new RewriteRuleSubtreeStream(adaptor,"rule optionsSpec");
+		RewriteRuleSubtreeStream stream_delegateGrammars=new RewriteRuleSubtreeStream(adaptor,"rule delegateGrammars");
+		RewriteRuleSubtreeStream stream_tokensSpec=new RewriteRuleSubtreeStream(adaptor,"rule tokensSpec");
+		RewriteRuleSubtreeStream stream_attrScopes=new RewriteRuleSubtreeStream(adaptor,"rule attrScopes");
+		RewriteRuleSubtreeStream stream_actions=new RewriteRuleSubtreeStream(adaptor,"rule actions");
+		RewriteRuleSubtreeStream stream_rules=new RewriteRuleSubtreeStream(adaptor,"rule rules");
+
+			this.Grammar = g;
+			IDictionary<string, object> opts;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:204:3: ( ( ACTION )? (cmt= DOC_COMMENT )? gr= grammarType gid= id SEMI ( optionsSpec )? (ig= delegateGrammars )? (ts= tokensSpec )? scopes= attrScopes (a= actions )? r= rules EOF -> ^( $gr $gid ( $cmt)? ( optionsSpec )? ( $ig)? ( $ts)? ( $scopes)? ( $a)? $r) )
+			// Grammars\\ANTLR.g3:204:3: ( ACTION )? (cmt= DOC_COMMENT )? gr= grammarType gid= id SEMI ( optionsSpec )? (ig= delegateGrammars )? (ts= tokensSpec )? scopes= attrScopes (a= actions )? r= rules EOF
+			{
+			// Grammars\\ANTLR.g3:204:3: ( ACTION )?
+			int alt1=2;
+			int LA1_0 = input.LA(1);
+
+			if ( (LA1_0==ACTION) )
+			{
+				alt1=1;
+			}
+			switch ( alt1 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:204:5: ACTION
+				{
+				ACTION1=(IToken)Match(input,ACTION,Follow._ACTION_in_grammar_308); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_ACTION.Add(ACTION1);
+
+
+				}
+				break;
+
+			}
+
+			// Grammars\\ANTLR.g3:205:3: (cmt= DOC_COMMENT )?
+			int alt2=2;
+			int LA2_0 = input.LA(1);
+
+			if ( (LA2_0==DOC_COMMENT) )
+			{
+				alt2=1;
+			}
+			switch ( alt2 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:205:5: cmt= DOC_COMMENT
+				{
+				cmt=(IToken)Match(input,DOC_COMMENT,Follow._DOC_COMMENT_in_grammar_319); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_DOC_COMMENT.Add(cmt);
+
+
+				}
+				break;
+
+			}
+
+			PushFollow(Follow._grammarType_in_grammar_329);
+			gr=grammarType();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_grammarType.Add(gr.Tree);
+			PushFollow(Follow._id_in_grammar_333);
+			gid=id();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_id.Add(gid.Tree);
+			if ( state.backtracking == 0 )
+			{
+				Grammar.setName((gid!=null?input.ToString(gid.start,gid.stop):null));
+			}
+			SEMI2=(IToken)Match(input,SEMI,Follow._SEMI_in_grammar_337); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_SEMI.Add(SEMI2);
+
+			// Grammars\\ANTLR.g3:207:3: ( optionsSpec )?
+			int alt3=2;
+			int LA3_0 = input.LA(1);
+
+			if ( (LA3_0==OPTIONS) )
+			{
+				alt3=1;
+			}
+			switch ( alt3 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:207:5: optionsSpec
+				{
+				PushFollow(Follow._optionsSpec_in_grammar_343);
+				optionsSpec3=optionsSpec();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_optionsSpec.Add(optionsSpec3.Tree);
+				if ( state.backtracking == 0 )
+				{
+					opts = (optionsSpec3!=null?optionsSpec3.opts:default(IDictionary<string, object>)); Grammar.setOptions(opts, (optionsSpec3!=null?((IToken)optionsSpec3.start):null));
+				}
+
+				}
+				break;
+
+			}
+
+			// Grammars\\ANTLR.g3:209:3: (ig= delegateGrammars )?
+			int alt4=2;
+			int LA4_0 = input.LA(1);
+
+			if ( (LA4_0==IMPORT) )
+			{
+				alt4=1;
+			}
+			switch ( alt4 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:209:4: ig= delegateGrammars
+				{
+				PushFollow(Follow._delegateGrammars_in_grammar_357);
+				ig=delegateGrammars();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_delegateGrammars.Add(ig.Tree);
+
+				}
+				break;
+
+			}
+
+			// Grammars\\ANTLR.g3:210:3: (ts= tokensSpec )?
+			int alt5=2;
+			int LA5_0 = input.LA(1);
+
+			if ( (LA5_0==TOKENS) )
+			{
+				alt5=1;
+			}
+			switch ( alt5 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:210:4: ts= tokensSpec
+				{
+				PushFollow(Follow._tokensSpec_in_grammar_366);
+				ts=tokensSpec();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_tokensSpec.Add(ts.Tree);
+
+				}
+				break;
+
+			}
+
+			PushFollow(Follow._attrScopes_in_grammar_374);
+			scopes=attrScopes();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_attrScopes.Add(scopes.Tree);
+			// Grammars\\ANTLR.g3:212:3: (a= actions )?
+			int alt6=2;
+			int LA6_0 = input.LA(1);
+
+			if ( (LA6_0==AMPERSAND) )
+			{
+				alt6=1;
+			}
+			switch ( alt6 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:212:4: a= actions
+				{
+				PushFollow(Follow._actions_in_grammar_381);
+				a=actions();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_actions.Add(a.Tree);
+
+				}
+				break;
+
+			}
+
+			PushFollow(Follow._rules_in_grammar_389);
+			r=rules();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_rules.Add(r.Tree);
+			EOF4=(IToken)Match(input,EOF,Follow._EOF_in_grammar_393); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_EOF.Add(EOF4);
+
+
+
+			{
+			// AST REWRITE
+			// elements: gr, gid, cmt, optionsSpec, ig, ts, scopes, a, r
+			// token labels: cmt
+			// rule labels: gr, gid, ig, ts, scopes, a, r, retval
+			// token list labels:
+			// rule list labels:
+			// wildcard labels:
+			if ( state.backtracking == 0 ) {
+			retval.tree = root_0;
+			RewriteRuleITokenStream stream_cmt=new RewriteRuleITokenStream(adaptor,"token cmt",cmt);
+			RewriteRuleSubtreeStream stream_gr=new RewriteRuleSubtreeStream(adaptor,"rule gr",gr!=null?gr.tree:null);
+			RewriteRuleSubtreeStream stream_gid=new RewriteRuleSubtreeStream(adaptor,"rule gid",gid!=null?gid.tree:null);
+			RewriteRuleSubtreeStream stream_ig=new RewriteRuleSubtreeStream(adaptor,"rule ig",ig!=null?ig.tree:null);
+			RewriteRuleSubtreeStream stream_ts=new RewriteRuleSubtreeStream(adaptor,"rule ts",ts!=null?ts.tree:null);
+			RewriteRuleSubtreeStream stream_scopes=new RewriteRuleSubtreeStream(adaptor,"rule scopes",scopes!=null?scopes.tree:null);
+			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.tree:null);
+			RewriteRuleSubtreeStream stream_r=new RewriteRuleSubtreeStream(adaptor,"rule r",r!=null?r.tree:null);
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+			root_0 = (GrammarAST)adaptor.Nil();
+			// 215:3: -> ^( $gr $gid ( $cmt)? ( optionsSpec )? ( $ig)? ( $ts)? ( $scopes)? ( $a)? $r)
+			{
+				// Grammars\\ANTLR.g3:215:6: ^( $gr $gid ( $cmt)? ( optionsSpec )? ( $ig)? ( $ts)? ( $scopes)? ( $a)? $r)
+				{
+				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+				root_1 = (GrammarAST)adaptor.BecomeRoot(stream_gr.NextNode(), root_1);
+
+				adaptor.AddChild(root_1, stream_gid.NextTree());
+				// Grammars\\ANTLR.g3:215:18: ( $cmt)?
+				if ( stream_cmt.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_cmt.NextNode());
+
+				}
+				stream_cmt.Reset();
+				// Grammars\\ANTLR.g3:215:23: ( optionsSpec )?
+				if ( stream_optionsSpec.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_optionsSpec.NextTree());
+
+				}
+				stream_optionsSpec.Reset();
+				// Grammars\\ANTLR.g3:215:37: ( $ig)?
+				if ( stream_ig.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_ig.NextTree());
+
+				}
+				stream_ig.Reset();
+				// Grammars\\ANTLR.g3:215:42: ( $ts)?
+				if ( stream_ts.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_ts.NextTree());
+
+				}
+				stream_ts.Reset();
+				// Grammars\\ANTLR.g3:215:47: ( $scopes)?
+				if ( stream_scopes.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_scopes.NextTree());
+
+				}
+				stream_scopes.Reset();
+				// Grammars\\ANTLR.g3:215:56: ( $a)?
+				if ( stream_a.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_a.NextTree());
+
+				}
+				stream_a.Reset();
+				adaptor.AddChild(root_1, stream_r.NextTree());
+
+				adaptor.AddChild(root_0, root_1);
+				}
+
+			}
+
+			retval.tree = root_0;
+			}
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+			if ( state.backtracking == 0 )
+			{
+
+					cleanup( ((GrammarAST)retval.tree) );
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "grammar_"
+
+	public class grammarType_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "grammarType"
+	// Grammars\\ANTLR.g3:218:0: grammarType : ( 'lexer' gr= 'grammar' -> LEXER_GRAMMAR[$gr] | 'parser' gr= 'grammar' -> PARSER_GRAMMAR[$gr] | 'tree' gr= 'grammar' -> TREE_GRAMMAR[$gr] |gr= 'grammar' -> COMBINED_GRAMMAR[$gr] ) ;
+	private ANTLRParser.grammarType_return grammarType(  )
+	{
+		ANTLRParser.grammarType_return retval = new ANTLRParser.grammarType_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken gr=null;
+		IToken string_literal5=null;
+		IToken string_literal6=null;
+		IToken string_literal7=null;
+
+		GrammarAST gr_tree=null;
+		GrammarAST string_literal5_tree=null;
+		GrammarAST string_literal6_tree=null;
+		GrammarAST string_literal7_tree=null;
+		RewriteRuleITokenStream stream_LEXER=new RewriteRuleITokenStream(adaptor,"token LEXER");
+		RewriteRuleITokenStream stream_GRAMMAR=new RewriteRuleITokenStream(adaptor,"token GRAMMAR");
+		RewriteRuleITokenStream stream_PARSER=new RewriteRuleITokenStream(adaptor,"token PARSER");
+		RewriteRuleITokenStream stream_TREE=new RewriteRuleITokenStream(adaptor,"token TREE");
+
+		try
+		{
+			// Grammars\\ANTLR.g3:219:4: ( ( 'lexer' gr= 'grammar' -> LEXER_GRAMMAR[$gr] | 'parser' gr= 'grammar' -> PARSER_GRAMMAR[$gr] | 'tree' gr= 'grammar' -> TREE_GRAMMAR[$gr] |gr= 'grammar' -> COMBINED_GRAMMAR[$gr] ) )
+			// Grammars\\ANTLR.g3:219:4: ( 'lexer' gr= 'grammar' -> LEXER_GRAMMAR[$gr] | 'parser' gr= 'grammar' -> PARSER_GRAMMAR[$gr] | 'tree' gr= 'grammar' -> TREE_GRAMMAR[$gr] |gr= 'grammar' -> COMBINED_GRAMMAR[$gr] )
+			{
+			// Grammars\\ANTLR.g3:219:4: ( 'lexer' gr= 'grammar' -> LEXER_GRAMMAR[$gr] | 'parser' gr= 'grammar' -> PARSER_GRAMMAR[$gr] | 'tree' gr= 'grammar' -> TREE_GRAMMAR[$gr] |gr= 'grammar' -> COMBINED_GRAMMAR[$gr] )
+			int alt7=4;
+			switch ( input.LA(1) )
+			{
+			case LEXER:
+				{
+				alt7=1;
+				}
+				break;
+			case PARSER:
+				{
+				alt7=2;
+				}
+				break;
+			case TREE:
+				{
+				alt7=3;
+				}
+				break;
+			case GRAMMAR:
+				{
+				alt7=4;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt7 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:219:6: 'lexer' gr= 'grammar'
+				{
+				string_literal5=(IToken)Match(input,LEXER,Follow._LEXER_in_grammarType444); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_LEXER.Add(string_literal5);
+
+				gr=(IToken)Match(input,GRAMMAR,Follow._GRAMMAR_in_grammarType449); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_GRAMMAR.Add(gr);
+
+				if ( state.backtracking == 0 )
+				{
+					GrammarType=LEXER_GRAMMAR; Grammar.type = Grammar.LEXER;
+				}
+
+
+				{
+				// AST REWRITE
+				// elements:
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 220:4: -> LEXER_GRAMMAR[$gr]
+				{
+					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(LEXER_GRAMMAR, gr));
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:221:5: 'parser' gr= 'grammar'
+				{
+				string_literal6=(IToken)Match(input,PARSER,Follow._PARSER_in_grammarType472); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_PARSER.Add(string_literal6);
+
+				gr=(IToken)Match(input,GRAMMAR,Follow._GRAMMAR_in_grammarType476); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_GRAMMAR.Add(gr);
+
+				if ( state.backtracking == 0 )
+				{
+					GrammarType=PARSER_GRAMMAR; Grammar.type = Grammar.PARSER;
+				}
+
+
+				{
+				// AST REWRITE
+				// elements:
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 222:4: -> PARSER_GRAMMAR[$gr]
+				{
+					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(PARSER_GRAMMAR, gr));
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 3:
+				// Grammars\\ANTLR.g3:223:5: 'tree' gr= 'grammar'
+				{
+				string_literal7=(IToken)Match(input,TREE,Follow._TREE_in_grammarType497); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_TREE.Add(string_literal7);
+
+				gr=(IToken)Match(input,GRAMMAR,Follow._GRAMMAR_in_grammarType503); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_GRAMMAR.Add(gr);
+
+				if ( state.backtracking == 0 )
+				{
+					GrammarType=TREE_GRAMMAR; Grammar.type = Grammar.TREE_PARSER;
+				}
+
+
+				{
+				// AST REWRITE
+				// elements:
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 224:4: -> TREE_GRAMMAR[$gr]
+				{
+					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(TREE_GRAMMAR, gr));
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 4:
+				// Grammars\\ANTLR.g3:225:8: gr= 'grammar'
+				{
+				gr=(IToken)Match(input,GRAMMAR,Follow._GRAMMAR_in_grammarType526); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_GRAMMAR.Add(gr);
+
+				if ( state.backtracking == 0 )
+				{
+					GrammarType=COMBINED_GRAMMAR; Grammar.type = Grammar.COMBINED;
+				}
+
+
+				{
+				// AST REWRITE
+				// elements:
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 226:4: -> COMBINED_GRAMMAR[$gr]
+				{
+					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(COMBINED_GRAMMAR, gr));
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+
+			}
+
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "grammarType"
+
+	public class actions_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "actions"
+	// Grammars\\ANTLR.g3:230:0: actions : ( action )+ ;
+	private ANTLRParser.actions_return actions(  )
+	{
+		ANTLRParser.actions_return retval = new ANTLRParser.actions_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		ANTLRParser.action_return action8 = default(ANTLRParser.action_return);
+
+
+		try
+		{
+			// Grammars\\ANTLR.g3:231:4: ( ( action )+ )
+			// Grammars\\ANTLR.g3:231:4: ( action )+
+			{
+			root_0 = (GrammarAST)adaptor.Nil();
+
+			// Grammars\\ANTLR.g3:231:4: ( action )+
+			int cnt8=0;
+			for ( ; ; )
+			{
+				int alt8=2;
+				int LA8_0 = input.LA(1);
+
+				if ( (LA8_0==AMPERSAND) )
+				{
+					alt8=1;
+				}
+
+
+				switch ( alt8 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:231:5: action
+					{
+					PushFollow(Follow._action_in_actions553);
+					action8=action();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, action8.Tree);
+
+					}
+					break;
+
+				default:
+					if ( cnt8 >= 1 )
+						goto loop8;
+
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					EarlyExitException eee8 = new EarlyExitException( 8, input );
+					throw eee8;
+				}
+				cnt8++;
+			}
+			loop8:
+				;
+
+
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "actions"
+
+	public class action_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "action"
+	// Grammars\\ANTLR.g3:235:0: action : AMPERSAND ( actionScopeName COLON COLON )? id ACTION ;
+	private ANTLRParser.action_return action(  )
+	{
+		ANTLRParser.action_return retval = new ANTLRParser.action_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken AMPERSAND9=null;
+		IToken COLON11=null;
+		IToken COLON12=null;
+		IToken ACTION14=null;
+		ANTLRParser.actionScopeName_return actionScopeName10 = default(ANTLRParser.actionScopeName_return);
+		ANTLRParser.id_return id13 = default(ANTLRParser.id_return);
+
+		GrammarAST AMPERSAND9_tree=null;
+		GrammarAST COLON11_tree=null;
+		GrammarAST COLON12_tree=null;
+		GrammarAST ACTION14_tree=null;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:236:4: ( AMPERSAND ( actionScopeName COLON COLON )? id ACTION )
+			// Grammars\\ANTLR.g3:236:4: AMPERSAND ( actionScopeName COLON COLON )? id ACTION
+			{
+			root_0 = (GrammarAST)adaptor.Nil();
+
+			AMPERSAND9=(IToken)Match(input,AMPERSAND,Follow._AMPERSAND_in_action568); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) {
+			AMPERSAND9_tree = (GrammarAST)adaptor.Create(AMPERSAND9);
+			root_0 = (GrammarAST)adaptor.BecomeRoot(AMPERSAND9_tree, root_0);
+			}
+			// Grammars\\ANTLR.g3:236:15: ( actionScopeName COLON COLON )?
+			int alt9=2;
+			switch ( input.LA(1) )
+			{
+			case TOKEN_REF:
+				{
+				int LA9_1 = input.LA(2);
+
+				if ( (LA9_1==COLON) )
+				{
+					alt9=1;
+				}
+				}
+				break;
+			case RULE_REF:
+				{
+				int LA9_2 = input.LA(2);
+
+				if ( (LA9_2==COLON) )
+				{
+					alt9=1;
+				}
+				}
+				break;
+			case LEXER:
+			case PARSER:
+				{
+				alt9=1;
+				}
+				break;
+			}
+
+			switch ( alt9 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:236:16: actionScopeName COLON COLON
+				{
+				PushFollow(Follow._actionScopeName_in_action572);
+				actionScopeName10=actionScopeName();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, actionScopeName10.Tree);
+				COLON11=(IToken)Match(input,COLON,Follow._COLON_in_action574); if (state.failed) return retval;
+				COLON12=(IToken)Match(input,COLON,Follow._COLON_in_action577); if (state.failed) return retval;
+
+				}
+				break;
+
+			}
+
+			PushFollow(Follow._id_in_action582);
+			id13=id();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, id13.Tree);
+			ACTION14=(IToken)Match(input,ACTION,Follow._ACTION_in_action584); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			ACTION14_tree = (GrammarAST)adaptor.Create(ACTION14);
+			adaptor.AddChild(root_0, ACTION14_tree);
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "action"
+
+	public class actionScopeName_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "actionScopeName"
+	// Grammars\\ANTLR.g3:242:0: actionScopeName : ( id |l= 'lexer' -> ID[l] |p= 'parser' -> ID[p] );
+	private ANTLRParser.actionScopeName_return actionScopeName(  )
+	{
+		ANTLRParser.actionScopeName_return retval = new ANTLRParser.actionScopeName_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken l=null;
+		IToken p=null;
+		ANTLRParser.id_return id15 = default(ANTLRParser.id_return);
+
+		GrammarAST l_tree=null;
+		GrammarAST p_tree=null;
+		RewriteRuleITokenStream stream_LEXER=new RewriteRuleITokenStream(adaptor,"token LEXER");
+		RewriteRuleITokenStream stream_PARSER=new RewriteRuleITokenStream(adaptor,"token PARSER");
+
+		try
+		{
+			// Grammars\\ANTLR.g3:243:4: ( id |l= 'lexer' -> ID[l] |p= 'parser' -> ID[p] )
+			int alt10=3;
+			switch ( input.LA(1) )
+			{
+			case RULE_REF:
+			case TOKEN_REF:
+				{
+				alt10=1;
+				}
+				break;
+			case LEXER:
+				{
+				alt10=2;
+				}
+				break;
+			case PARSER:
+				{
+				alt10=3;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 10, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt10 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:243:4: id
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				PushFollow(Follow._id_in_actionScopeName597);
+				id15=id();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, id15.Tree);
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:244:4: l= 'lexer'
+				{
+				l=(IToken)Match(input,LEXER,Follow._LEXER_in_actionScopeName604); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_LEXER.Add(l);
+
+
+
+				{
+				// AST REWRITE
+				// elements:
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 245:3: -> ID[l]
+				{
+					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(ID, l));
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 3:
+				// Grammars\\ANTLR.g3:246:4: p= 'parser'
+				{
+				p=(IToken)Match(input,PARSER,Follow._PARSER_in_actionScopeName618); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_PARSER.Add(p);
+
+
+
+				{
+				// AST REWRITE
+				// elements:
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 247:3: -> ID[p]
+				{
+					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(ID, p));
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "actionScopeName"
+
+	public class optionsSpec_return : ParserRuleReturnScope
+	{
+		public IDictionary<string, object> opts=new Dictionary<string, object>();
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "optionsSpec"
+	// Grammars\\ANTLR.g3:250:0: optionsSpec returns [IDictionary<string, object> opts=new Dictionary<string, object>()] : OPTIONS ( option[$opts] SEMI )+ RCURLY ;
+	private ANTLRParser.optionsSpec_return optionsSpec(  )
+	{
+		ANTLRParser.optionsSpec_return retval = new ANTLRParser.optionsSpec_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken OPTIONS16=null;
+		IToken SEMI18=null;
+		IToken RCURLY19=null;
+		ANTLRParser.option_return option17 = default(ANTLRParser.option_return);
+
+		GrammarAST OPTIONS16_tree=null;
+		GrammarAST SEMI18_tree=null;
+		GrammarAST RCURLY19_tree=null;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:251:4: ( OPTIONS ( option[$opts] SEMI )+ RCURLY )
+			// Grammars\\ANTLR.g3:251:4: OPTIONS ( option[$opts] SEMI )+ RCURLY
+			{
+			root_0 = (GrammarAST)adaptor.Nil();
+
+			OPTIONS16=(IToken)Match(input,OPTIONS,Follow._OPTIONS_in_optionsSpec640); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) {
+			OPTIONS16_tree = (GrammarAST)adaptor.Create(OPTIONS16);
+			root_0 = (GrammarAST)adaptor.BecomeRoot(OPTIONS16_tree, root_0);
+			}
+			// Grammars\\ANTLR.g3:251:13: ( option[$opts] SEMI )+
+			int cnt11=0;
+			for ( ; ; )
+			{
+				int alt11=2;
+				int LA11_0 = input.LA(1);
+
+				if ( (LA11_0==RULE_REF||LA11_0==TOKEN_REF) )
+				{
+					alt11=1;
+				}
+
+
+				switch ( alt11 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:251:14: option[$opts] SEMI
+					{
+					PushFollow(Follow._option_in_optionsSpec644);
+					option17=option(retval.opts);
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, option17.Tree);
+					SEMI18=(IToken)Match(input,SEMI,Follow._SEMI_in_optionsSpec647); if (state.failed) return retval;
+
+					}
+					break;
+
+				default:
+					if ( cnt11 >= 1 )
+						goto loop11;
+
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					EarlyExitException eee11 = new EarlyExitException( 11, input );
+					throw eee11;
+				}
+				cnt11++;
+			}
+			loop11:
+				;
+
+
+			RCURLY19=(IToken)Match(input,RCURLY,Follow._RCURLY_in_optionsSpec652); if (state.failed) return retval;
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "optionsSpec"
+
+	public class option_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "option"
+	// Grammars\\ANTLR.g3:254:0: option[IDictionary<string, object> opts] : id ASSIGN optionValue ;
+	private ANTLRParser.option_return option( IDictionary<string, object> opts )
+	{
+		ANTLRParser.option_return retval = new ANTLRParser.option_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken ASSIGN21=null;
+		ANTLRParser.id_return id20 = default(ANTLRParser.id_return);
+		ANTLRParser.optionValue_return optionValue22 = default(ANTLRParser.optionValue_return);
+
+		GrammarAST ASSIGN21_tree=null;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:255:4: ( id ASSIGN optionValue )
+			// Grammars\\ANTLR.g3:255:4: id ASSIGN optionValue
+			{
+			root_0 = (GrammarAST)adaptor.Nil();
+
+			PushFollow(Follow._id_in_option665);
+			id20=id();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, id20.Tree);
+			ASSIGN21=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_option667); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) {
+			ASSIGN21_tree = (GrammarAST)adaptor.Create(ASSIGN21);
+			root_0 = (GrammarAST)adaptor.BecomeRoot(ASSIGN21_tree, root_0);
+			}
+			PushFollow(Follow._optionValue_in_option670);
+			optionValue22=optionValue();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, optionValue22.Tree);
+			if ( state.backtracking == 0 )
+			{
+
+							opts[(id20!=null?input.ToString(id20.start,id20.stop):null)] = (optionValue22!=null?optionValue22.value:default(object));
+
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "option"
+
+	public class optionValue_return : ParserRuleReturnScope
+	{
+		public object value=null;
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "optionValue"
+	// Grammars\\ANTLR.g3:261:0: optionValue returns [object value=null] : (x= id |s= STRING_LITERAL |c= CHAR_LITERAL |i= INT |ss= STAR -> STRING_LITERAL[$ss] );
+	private ANTLRParser.optionValue_return optionValue(  )
+	{
+		ANTLRParser.optionValue_return retval = new ANTLRParser.optionValue_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken s=null;
+		IToken c=null;
+		IToken i=null;
+		IToken ss=null;
+		ANTLRParser.id_return x = default(ANTLRParser.id_return);
+
+		GrammarAST s_tree=null;
+		GrammarAST c_tree=null;
+		GrammarAST i_tree=null;
+		GrammarAST ss_tree=null;
+		RewriteRuleITokenStream stream_STAR=new RewriteRuleITokenStream(adaptor,"token STAR");
+
+		try
+		{
+			// Grammars\\ANTLR.g3:262:4: (x= id |s= STRING_LITERAL |c= CHAR_LITERAL |i= INT |ss= STAR -> STRING_LITERAL[$ss] )
+			int alt12=5;
+			switch ( input.LA(1) )
+			{
+			case RULE_REF:
+			case TOKEN_REF:
+				{
+				alt12=1;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt12=2;
+				}
+				break;
+			case CHAR_LITERAL:
+				{
+				alt12=3;
+				}
+				break;
+			case INT:
+				{
+				alt12=4;
+				}
+				break;
+			case STAR:
+				{
+				alt12=5;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 12, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt12 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:262:4: x= id
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				PushFollow(Follow._id_in_optionValue691);
+				x=id();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, x.Tree);
+				if ( state.backtracking == 0 )
+				{
+					retval.value = (x!=null?input.ToString(x.start,x.stop):null);
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:263:4: s= STRING_LITERAL
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				s=(IToken)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_optionValue703); if (state.failed) return retval;
+				if ( state.backtracking==0 ) {
+				s_tree = (GrammarAST)adaptor.Create(s);
+				adaptor.AddChild(root_0, s_tree);
+				}
+				if ( state.backtracking == 0 )
+				{
+					string vs = (s!=null?s.Text:null);
+											  // remove the quotes:
+											  retval.value =vs.Substring(1,vs.Length-2);
+				}
+
+				}
+				break;
+			case 3:
+				// Grammars\\ANTLR.g3:266:4: c= CHAR_LITERAL
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				c=(IToken)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_optionValue712); if (state.failed) return retval;
+				if ( state.backtracking==0 ) {
+				c_tree = (GrammarAST)adaptor.Create(c);
+				adaptor.AddChild(root_0, c_tree);
+				}
+				if ( state.backtracking == 0 )
+				{
+					string vs = (c!=null?c.Text:null);
+											  // remove the quotes:
+											  retval.value =vs.Substring(1,vs.Length-2);
+				}
+
+				}
+				break;
+			case 4:
+				// Grammars\\ANTLR.g3:269:4: i= INT
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				i=(IToken)Match(input,INT,Follow._INT_in_optionValue723); if (state.failed) return retval;
+				if ( state.backtracking==0 ) {
+				i_tree = (GrammarAST)adaptor.Create(i);
+				adaptor.AddChild(root_0, i_tree);
+				}
+				if ( state.backtracking == 0 )
+				{
+					retval.value = int.Parse((i!=null?i.Text:null));
+				}
+
+				}
+				break;
+			case 5:
+				// Grammars\\ANTLR.g3:270:4: ss= STAR
+				{
+				ss=(IToken)Match(input,STAR,Follow._STAR_in_optionValue743); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_STAR.Add(ss);
+
+				if ( state.backtracking == 0 )
+				{
+					retval.value = "*";
+				}
+
+
+				{
+				// AST REWRITE
+				// elements:
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 271:3: -> STRING_LITERAL[$ss]
+				{
+					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(STRING_LITERAL, ss));
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "optionValue"
+
+	public class delegateGrammars_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "delegateGrammars"
+	// Grammars\\ANTLR.g3:275:0: delegateGrammars : 'import' delegateGrammar ( COMMA delegateGrammar )* SEMI ;
+	private ANTLRParser.delegateGrammars_return delegateGrammars(  )
+	{
+		ANTLRParser.delegateGrammars_return retval = new ANTLRParser.delegateGrammars_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken string_literal23=null;
+		IToken COMMA25=null;
+		IToken SEMI27=null;
+		ANTLRParser.delegateGrammar_return delegateGrammar24 = default(ANTLRParser.delegateGrammar_return);
+		ANTLRParser.delegateGrammar_return delegateGrammar26 = default(ANTLRParser.delegateGrammar_return);
+
+		GrammarAST string_literal23_tree=null;
+		GrammarAST COMMA25_tree=null;
+		GrammarAST SEMI27_tree=null;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:276:4: ( 'import' delegateGrammar ( COMMA delegateGrammar )* SEMI )
+			// Grammars\\ANTLR.g3:276:4: 'import' delegateGrammar ( COMMA delegateGrammar )* SEMI
+			{
+			root_0 = (GrammarAST)adaptor.Nil();
+
+			string_literal23=(IToken)Match(input,IMPORT,Follow._IMPORT_in_delegateGrammars768); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) {
+			string_literal23_tree = (GrammarAST)adaptor.Create(string_literal23);
+			root_0 = (GrammarAST)adaptor.BecomeRoot(string_literal23_tree, root_0);
+			}
+			PushFollow(Follow._delegateGrammar_in_delegateGrammars771);
+			delegateGrammar24=delegateGrammar();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, delegateGrammar24.Tree);
+			// Grammars\\ANTLR.g3:276:30: ( COMMA delegateGrammar )*
+			for ( ; ; )
+			{
+				int alt13=2;
+				int LA13_0 = input.LA(1);
+
+				if ( (LA13_0==COMMA) )
+				{
+					alt13=1;
+				}
+
+
+				switch ( alt13 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:276:31: COMMA delegateGrammar
+					{
+					COMMA25=(IToken)Match(input,COMMA,Follow._COMMA_in_delegateGrammars774); if (state.failed) return retval;
+					PushFollow(Follow._delegateGrammar_in_delegateGrammars777);
+					delegateGrammar26=delegateGrammar();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, delegateGrammar26.Tree);
+
+					}
+					break;
+
+				default:
+					goto loop13;
+				}
+			}
+
+			loop13:
+				;
+
+
+			SEMI27=(IToken)Match(input,SEMI,Follow._SEMI_in_delegateGrammars781); if (state.failed) return retval;
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "delegateGrammars"
+
+	public class delegateGrammar_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "delegateGrammar"
+	// Grammars\\ANTLR.g3:279:0: delegateGrammar : (lab= id ASSIGN g= id |g2= id );
+	private ANTLRParser.delegateGrammar_return delegateGrammar(  )
+	{
+		ANTLRParser.delegateGrammar_return retval = new ANTLRParser.delegateGrammar_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken ASSIGN28=null;
+		ANTLRParser.id_return lab = default(ANTLRParser.id_return);
+		ANTLRParser.id_return g = default(ANTLRParser.id_return);
+		ANTLRParser.id_return g2 = default(ANTLRParser.id_return);
+
+		GrammarAST ASSIGN28_tree=null;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:280:4: (lab= id ASSIGN g= id |g2= id )
+			int alt14=2;
+			int LA14_0 = input.LA(1);
+
+			if ( (LA14_0==TOKEN_REF) )
+			{
+				int LA14_1 = input.LA(2);
+
+				if ( (LA14_1==ASSIGN) )
+				{
+					alt14=1;
+				}
+				else if ( (LA14_1==COMMA||LA14_1==SEMI) )
+				{
+					alt14=2;
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 14, 1, input);
+
+					throw nvae;
+				}
+			}
+			else if ( (LA14_0==RULE_REF) )
+			{
+				int LA14_2 = input.LA(2);
+
+				if ( (LA14_2==ASSIGN) )
+				{
+					alt14=1;
+				}
+				else if ( (LA14_2==COMMA||LA14_2==SEMI) )
+				{
+					alt14=2;
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 14, 2, input);
+
+					throw nvae;
+				}
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae = new NoViableAltException("", 14, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt14 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:280:4: lab= id ASSIGN g= id
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				PushFollow(Follow._id_in_delegateGrammar795);
+				lab=id();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, lab.Tree);
+				ASSIGN28=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_delegateGrammar797); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) {
+				ASSIGN28_tree = (GrammarAST)adaptor.Create(ASSIGN28);
+				root_0 = (GrammarAST)adaptor.BecomeRoot(ASSIGN28_tree, root_0);
+				}
+				PushFollow(Follow._id_in_delegateGrammar802);
+				g=id();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, g.Tree);
+				if ( state.backtracking == 0 )
+				{
+					Grammar.importGrammar((g!=null?((GrammarAST)g.tree):null), (lab!=null?input.ToString(lab.start,lab.stop):null));
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:281:4: g2= id
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				PushFollow(Follow._id_in_delegateGrammar811);
+				g2=id();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, g2.Tree);
+				if ( state.backtracking == 0 )
+				{
+					Grammar.importGrammar((g2!=null?((GrammarAST)g2.tree):null),null);
+				}
+
+				}
+				break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "delegateGrammar"
+
+	public class tokensSpec_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "tokensSpec"
+	// Grammars\\ANTLR.g3:284:0: tokensSpec : TOKENS ( tokenSpec )+ RCURLY ;
+	private ANTLRParser.tokensSpec_return tokensSpec(  )
+	{
+		ANTLRParser.tokensSpec_return retval = new ANTLRParser.tokensSpec_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken TOKENS29=null;
+		IToken RCURLY31=null;
+		ANTLRParser.tokenSpec_return tokenSpec30 = default(ANTLRParser.tokenSpec_return);
+
+		GrammarAST TOKENS29_tree=null;
+		GrammarAST RCURLY31_tree=null;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:285:4: ( TOKENS ( tokenSpec )+ RCURLY )
+			// Grammars\\ANTLR.g3:285:4: TOKENS ( tokenSpec )+ RCURLY
+			{
+			root_0 = (GrammarAST)adaptor.Nil();
+
+			TOKENS29=(IToken)Match(input,TOKENS,Follow._TOKENS_in_tokensSpec838); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) {
+			TOKENS29_tree = (GrammarAST)adaptor.Create(TOKENS29);
+			root_0 = (GrammarAST)adaptor.BecomeRoot(TOKENS29_tree, root_0);
+			}
+			// Grammars\\ANTLR.g3:286:4: ( tokenSpec )+
+			int cnt15=0;
+			for ( ; ; )
+			{
+				int alt15=2;
+				int LA15_0 = input.LA(1);
+
+				if ( (LA15_0==TOKEN_REF) )
+				{
+					alt15=1;
+				}
+
+
+				switch ( alt15 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:286:6: tokenSpec
+					{
+					PushFollow(Follow._tokenSpec_in_tokensSpec846);
+					tokenSpec30=tokenSpec();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, tokenSpec30.Tree);
+
+					}
+					break;
+
+				default:
+					if ( cnt15 >= 1 )
+						goto loop15;
+
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					EarlyExitException eee15 = new EarlyExitException( 15, input );
+					throw eee15;
+				}
+				cnt15++;
+			}
+			loop15:
+				;
+
+
+			RCURLY31=(IToken)Match(input,RCURLY,Follow._RCURLY_in_tokensSpec853); if (state.failed) return retval;
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "tokensSpec"
+
+	public class tokenSpec_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "tokenSpec"
+	// Grammars\\ANTLR.g3:290:0: tokenSpec : TOKEN_REF ( ASSIGN ( STRING_LITERAL | CHAR_LITERAL ) )? SEMI ;
+	private ANTLRParser.tokenSpec_return tokenSpec(  )
+	{
+		ANTLRParser.tokenSpec_return retval = new ANTLRParser.tokenSpec_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken TOKEN_REF32=null;
+		IToken ASSIGN33=null;
+		IToken set34=null;
+		IToken SEMI35=null;
+
+		GrammarAST TOKEN_REF32_tree=null;
+		GrammarAST ASSIGN33_tree=null;
+		GrammarAST set34_tree=null;
+		GrammarAST SEMI35_tree=null;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:291:4: ( TOKEN_REF ( ASSIGN ( STRING_LITERAL | CHAR_LITERAL ) )? SEMI )
+			// Grammars\\ANTLR.g3:291:4: TOKEN_REF ( ASSIGN ( STRING_LITERAL | CHAR_LITERAL ) )? SEMI
+			{
+			root_0 = (GrammarAST)adaptor.Nil();
+
+			TOKEN_REF32=(IToken)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_tokenSpec865); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			TOKEN_REF32_tree = (GrammarAST)adaptor.Create(TOKEN_REF32);
+			adaptor.AddChild(root_0, TOKEN_REF32_tree);
+			}
+			// Grammars\\ANTLR.g3:291:14: ( ASSIGN ( STRING_LITERAL | CHAR_LITERAL ) )?
+			int alt16=2;
+			int LA16_0 = input.LA(1);
+
+			if ( (LA16_0==ASSIGN) )
+			{
+				alt16=1;
+			}
+			switch ( alt16 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:291:16: ASSIGN ( STRING_LITERAL | CHAR_LITERAL )
+				{
+				ASSIGN33=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_tokenSpec869); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) {
+				ASSIGN33_tree = (GrammarAST)adaptor.Create(ASSIGN33);
+				root_0 = (GrammarAST)adaptor.BecomeRoot(ASSIGN33_tree, root_0);
+				}
+				set34=(IToken)input.LT(1);
+				if ( input.LA(1)==CHAR_LITERAL||input.LA(1)==STRING_LITERAL )
+				{
+					input.Consume();
+					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(set34));
+					state.errorRecovery=false;state.failed=false;
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					MismatchedSetException mse = new MismatchedSetException(null,input);
+					throw mse;
+				}
+
+
+				}
+				break;
+
+			}
+
+			SEMI35=(IToken)Match(input,SEMI,Follow._SEMI_in_tokenSpec881); if (state.failed) return retval;
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "tokenSpec"
+
+	public class attrScopes_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "attrScopes"
+	// Grammars\\ANTLR.g3:294:0: attrScopes : ( attrScope )* ;
+	private ANTLRParser.attrScopes_return attrScopes(  )
+	{
+		ANTLRParser.attrScopes_return retval = new ANTLRParser.attrScopes_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		ANTLRParser.attrScope_return attrScope36 = default(ANTLRParser.attrScope_return);
+
+
+		try
+		{
+			// Grammars\\ANTLR.g3:295:4: ( ( attrScope )* )
+			// Grammars\\ANTLR.g3:295:4: ( attrScope )*
+			{
+			root_0 = (GrammarAST)adaptor.Nil();
+
+			// Grammars\\ANTLR.g3:295:4: ( attrScope )*
+			for ( ; ; )
+			{
+				int alt17=2;
+				int LA17_0 = input.LA(1);
+
+				if ( (LA17_0==SCOPE) )
+				{
+					alt17=1;
+				}
+
+
+				switch ( alt17 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:295:5: attrScope
+					{
+					PushFollow(Follow._attrScope_in_attrScopes894);
+					attrScope36=attrScope();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, attrScope36.Tree);
+
+					}
+					break;
+
+				default:
+					goto loop17;
+				}
+			}
+
+			loop17:
+				;
+
+
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "attrScopes"
+
+	public class attrScope_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "attrScope"
+	// Grammars\\ANTLR.g3:298:0: attrScope : 'scope' id ( ruleActions )? ACTION ;
+	private ANTLRParser.attrScope_return attrScope(  )
+	{
+		ANTLRParser.attrScope_return retval = new ANTLRParser.attrScope_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken string_literal37=null;
+		IToken ACTION40=null;
+		ANTLRParser.id_return id38 = default(ANTLRParser.id_return);
+		ANTLRParser.ruleActions_return ruleActions39 = default(ANTLRParser.ruleActions_return);
+
+		GrammarAST string_literal37_tree=null;
+		GrammarAST ACTION40_tree=null;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:299:4: ( 'scope' id ( ruleActions )? ACTION )
+			// Grammars\\ANTLR.g3:299:4: 'scope' id ( ruleActions )? ACTION
+			{
+			root_0 = (GrammarAST)adaptor.Nil();
+
+			string_literal37=(IToken)Match(input,SCOPE,Follow._SCOPE_in_attrScope907); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) {
+			string_literal37_tree = (GrammarAST)adaptor.Create(string_literal37);
+			root_0 = (GrammarAST)adaptor.BecomeRoot(string_literal37_tree, root_0);
+			}
+			PushFollow(Follow._id_in_attrScope910);
+			id38=id();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, id38.Tree);
+			// Grammars\\ANTLR.g3:299:16: ( ruleActions )?
+			int alt18=2;
+			int LA18_0 = input.LA(1);
+
+			if ( (LA18_0==AMPERSAND) )
+			{
+				alt18=1;
+			}
+			switch ( alt18 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:299:0: ruleActions
+				{
+				PushFollow(Follow._ruleActions_in_attrScope912);
+				ruleActions39=ruleActions();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, ruleActions39.Tree);
+
+				}
+				break;
+
+			}
+
+			ACTION40=(IToken)Match(input,ACTION,Follow._ACTION_in_attrScope915); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			ACTION40_tree = (GrammarAST)adaptor.Create(ACTION40);
+			adaptor.AddChild(root_0, ACTION40_tree);
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "attrScope"
+
+	public class rules_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "rules"
+	// Grammars\\ANTLR.g3:302:0: rules : ( rule )+ ;
+	private ANTLRParser.rules_return rules(  )
+	{
+		ANTLRParser.rules_return retval = new ANTLRParser.rules_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		ANTLRParser.rule_return rule41 = default(ANTLRParser.rule_return);
+
+
+		try
+		{
+			// Grammars\\ANTLR.g3:303:4: ( ( rule )+ )
+			// Grammars\\ANTLR.g3:303:4: ( rule )+
+			{
+			root_0 = (GrammarAST)adaptor.Nil();
+
+			// Grammars\\ANTLR.g3:303:4: ( rule )+
+			int cnt19=0;
+			for ( ; ; )
+			{
+				int alt19=2;
+				int LA19_0 = input.LA(1);
+
+				if ( (LA19_0==DOC_COMMENT||LA19_0==FRAGMENT||(LA19_0>=PRIVATE && LA19_0<=PUBLIC)||LA19_0==RULE_REF||LA19_0==TOKEN_REF) )
+				{
+					alt19=1;
+				}
+
+
+				switch ( alt19 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:303:6: rule
+					{
+					PushFollow(Follow._rule_in_rules928);
+					rule41=rule();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, rule41.Tree);
+
+					}
+					break;
+
+				default:
+					if ( cnt19 >= 1 )
+						goto loop19;
+
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					EarlyExitException eee19 = new EarlyExitException( 19, input );
+					throw eee19;
+				}
+				cnt19++;
+			}
+			loop19:
+				;
+
+
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "rules"
+
+	public class rule_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "rule"
+	// Grammars\\ANTLR.g3:308:0: public rule : ( (d= DOC_COMMENT )? (p1= 'protected' |p2= 'public' |p3= 'private' |p4= 'fragment' )? ruleName= id ( BANG )? (aa= ARG_ACTION )? ( 'returns' rt= ARG_ACTION )? ( throwsSpec )? ( optionsSpec )? scopes= ruleScopeSpec ( ruleActions )? COLON altList[$optionsSpec.opts] SEMI (ex= exceptionGroup )? -> ^( RULE[\"rule\"] ^( $ruleName) ( $p1)? ( $p2)? ( $p3)? ( $p4)? ^( ARG[\"ARG\"] ( $aa)? ) ^( RET[\"RET\"] ( $rt)? ) ( throwsSpec )? ( optionsSpec )? ^( $scopes) ( ruleActions )? altList ( $ex)? EOR[$SEMI,\"<end-of-rule>\"] ) ) ;
+	public ANTLRParser.rule_return rule(  )
+	{
+		ANTLRParser.rule_return retval = new ANTLRParser.rule_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken d=null;
+		IToken p1=null;
+		IToken p2=null;
+		IToken p3=null;
+		IToken p4=null;
+		IToken aa=null;
+		IToken rt=null;
+		IToken BANG42=null;
+		IToken string_literal43=null;
+		IToken COLON47=null;
+		IToken SEMI49=null;
+		ANTLRParser.id_return ruleName = default(ANTLRParser.id_return);
+		ANTLRParser.ruleScopeSpec_return scopes = default(ANTLRParser.ruleScopeSpec_return);
+		ANTLRParser.exceptionGroup_return ex = default(ANTLRParser.exceptionGroup_return);
+		ANTLRParser.throwsSpec_return throwsSpec44 = default(ANTLRParser.throwsSpec_return);
+		ANTLRParser.optionsSpec_return optionsSpec45 = default(ANTLRParser.optionsSpec_return);
+		ANTLRParser.ruleActions_return ruleActions46 = default(ANTLRParser.ruleActions_return);
+		ANTLRParser.altList_return altList48 = default(ANTLRParser.altList_return);
+
+		GrammarAST d_tree=null;
+		GrammarAST p1_tree=null;
+		GrammarAST p2_tree=null;
+		GrammarAST p3_tree=null;
+		GrammarAST p4_tree=null;
+		GrammarAST aa_tree=null;
+		GrammarAST rt_tree=null;
+		GrammarAST BANG42_tree=null;
+		GrammarAST string_literal43_tree=null;
+		GrammarAST COLON47_tree=null;
+		GrammarAST SEMI49_tree=null;
+		RewriteRuleITokenStream stream_DOC_COMMENT=new RewriteRuleITokenStream(adaptor,"token DOC_COMMENT");
+		RewriteRuleITokenStream stream_PROTECTED=new RewriteRuleITokenStream(adaptor,"token PROTECTED");
+		RewriteRuleITokenStream stream_PUBLIC=new RewriteRuleITokenStream(adaptor,"token PUBLIC");
+		RewriteRuleITokenStream stream_PRIVATE=new RewriteRuleITokenStream(adaptor,"token PRIVATE");
+		RewriteRuleITokenStream stream_FRAGMENT=new RewriteRuleITokenStream(adaptor,"token FRAGMENT");
+		RewriteRuleITokenStream stream_BANG=new RewriteRuleITokenStream(adaptor,"token BANG");
+		RewriteRuleITokenStream stream_ARG_ACTION=new RewriteRuleITokenStream(adaptor,"token ARG_ACTION");
+		RewriteRuleITokenStream stream_RETURNS=new RewriteRuleITokenStream(adaptor,"token RETURNS");
+		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
+		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
+		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
+		RewriteRuleSubtreeStream stream_throwsSpec=new RewriteRuleSubtreeStream(adaptor,"rule throwsSpec");
+		RewriteRuleSubtreeStream stream_optionsSpec=new RewriteRuleSubtreeStream(adaptor,"rule optionsSpec");
+		RewriteRuleSubtreeStream stream_ruleScopeSpec=new RewriteRuleSubtreeStream(adaptor,"rule ruleScopeSpec");
+		RewriteRuleSubtreeStream stream_ruleActions=new RewriteRuleSubtreeStream(adaptor,"rule ruleActions");
+		RewriteRuleSubtreeStream stream_altList=new RewriteRuleSubtreeStream(adaptor,"rule altList");
+		RewriteRuleSubtreeStream stream_exceptionGroup=new RewriteRuleSubtreeStream(adaptor,"rule exceptionGroup");
+
+			GrammarAST eob=null;
+			int start = ((CommonToken)LT(1)).TokenIndex;
+			int startLine = LT(1).Line;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:316:2: ( ( (d= DOC_COMMENT )? (p1= 'protected' |p2= 'public' |p3= 'private' |p4= 'fragment' )? ruleName= id ( BANG )? (aa= ARG_ACTION )? ( 'returns' rt= ARG_ACTION )? ( throwsSpec )? ( optionsSpec )? scopes= ruleScopeSpec ( ruleActions )? COLON altList[$optionsSpec.opts] SEMI (ex= exceptionGroup )? -> ^( RULE[\"rule\"] ^( $ruleName) ( $p1)? ( $p2)? ( $p3)? ( $p4)? ^( ARG[\"ARG\"] ( $aa)? ) ^( RET[\"RET\"] ( $rt)? ) ( throwsSpec )? ( optionsSpec )? ^( $scopes) ( ruleActions )? altList ( $ex)? EOR[$SEMI,\"<end-of-rule>\"] ) ) )
+			// Grammars\\ANTLR.g3:316:2: ( (d= DOC_COMMENT )? (p1= 'protected' |p2= 'public' |p3= 'private' |p4= 'fragment' )? ruleName= id ( BANG )? (aa= ARG_ACTION )? ( 'returns' rt= ARG_ACTION )? ( throwsSpec )? ( optionsSpec )? scopes= ruleScopeSpec ( ruleActions )? COLON altList[$optionsSpec.opts] SEMI (ex= exceptionGroup )? -> ^( RULE[\"rule\"] ^( $ruleName) ( $p1)? ( $p2)? ( $p3)? ( $p4)? ^( ARG[\"ARG\"] ( $aa)? ) ^( RET[\"RET\"] ( $rt)? ) ( throwsSpec )? ( optionsSpec )? ^( $scopes) ( ruleActions )? altList ( $ex)? EOR[$SEMI,\"<end-of-rule>\"] ) )
+			{
+			// Grammars\\ANTLR.g3:316:2: ( (d= DOC_COMMENT )? (p1= 'protected' |p2= 'public' |p3= 'private' |p4= 'fragment' )? ruleName= id ( BANG )? (aa= ARG_ACTION )? ( 'returns' rt= ARG_ACTION )? ( throwsSpec )? ( optionsSpec )? scopes= ruleScopeSpec ( ruleActions )? COLON altList[$optionsSpec.opts] SEMI (ex= exceptionGroup )? -> ^( RULE[\"rule\"] ^( $ruleName) ( $p1)? ( $p2)? ( $p3)? ( $p4)? ^( ARG[\"ARG\"] ( $aa)? ) ^( RET[\"RET\"] ( $rt)? ) ( throwsSpec )? ( optionsSpec )? ^( $scopes) ( ruleActions )? altList ( $ex)? EOR[$SEMI,\"<end-of-rule>\"] ) )
+			// Grammars\\ANTLR.g3:316:4: (d= DOC_COMMENT )? (p1= 'protected' |p2= 'public' |p3= 'private' |p4= 'fragment' )? ruleName= id ( BANG )? (aa= ARG_ACTION )? ( 'returns' rt= ARG_ACTION )? ( throwsSpec )? ( optionsSpec )? scopes= ruleScopeSpec ( ruleActions )? COLON altList[$optionsSpec.opts] SEMI (ex= exceptionGroup )?
+			{
+			// Grammars\\ANTLR.g3:316:4: (d= DOC_COMMENT )?
+			int alt20=2;
+			int LA20_0 = input.LA(1);
+
+			if ( (LA20_0==DOC_COMMENT) )
+			{
+				alt20=1;
+			}
+			switch ( alt20 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:316:6: d= DOC_COMMENT
+				{
+				d=(IToken)Match(input,DOC_COMMENT,Follow._DOC_COMMENT_in_rule958); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_DOC_COMMENT.Add(d);
+
+
+				}
+				break;
+
+			}
+
+			// Grammars\\ANTLR.g3:318:3: (p1= 'protected' |p2= 'public' |p3= 'private' |p4= 'fragment' )?
+			int alt21=5;
+			switch ( input.LA(1) )
+			{
+			case PROTECTED:
+				{
+				alt21=1;
+				}
+				break;
+			case PUBLIC:
+				{
+				alt21=2;
+				}
+				break;
+			case PRIVATE:
+				{
+				alt21=3;
+				}
+				break;
+			case FRAGMENT:
+				{
+				alt21=4;
+				}
+				break;
+			}
+
+			switch ( alt21 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:318:5: p1= 'protected'
+				{
+				p1=(IToken)Match(input,PROTECTED,Follow._PROTECTED_in_rule971); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_PROTECTED.Add(p1);
+
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:319:5: p2= 'public'
+				{
+				p2=(IToken)Match(input,PUBLIC,Follow._PUBLIC_in_rule980); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_PUBLIC.Add(p2);
+
+
+				}
+				break;
+			case 3:
+				// Grammars\\ANTLR.g3:320:5: p3= 'private'
+				{
+				p3=(IToken)Match(input,PRIVATE,Follow._PRIVATE_in_rule990); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_PRIVATE.Add(p3);
+
+
+				}
+				break;
+			case 4:
+				// Grammars\\ANTLR.g3:321:5: p4= 'fragment'
+				{
+				p4=(IToken)Match(input,FRAGMENT,Follow._FRAGMENT_in_rule999); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_FRAGMENT.Add(p4);
+
+
+				}
+				break;
+
+			}
+
+			PushFollow(Follow._id_in_rule1011);
+			ruleName=id();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_id.Add(ruleName.Tree);
+			if ( state.backtracking == 0 )
+			{
+
+							currentRuleName=(ruleName!=null?input.ToString(ruleName.start,ruleName.stop):null);
+							if ( GrammarType==LEXER_GRAMMAR && p4==null )
+								Grammar.lexerRuleNamesInCombined.Add(currentRuleName);
+
+			}
+			// Grammars\\ANTLR.g3:329:3: ( BANG )?
+			int alt22=2;
+			int LA22_0 = input.LA(1);
+
+			if ( (LA22_0==BANG) )
+			{
+				alt22=1;
+			}
+			switch ( alt22 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:329:5: BANG
+				{
+				BANG42=(IToken)Match(input,BANG,Follow._BANG_in_rule1021); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_BANG.Add(BANG42);
+
+
+				}
+				break;
+
+			}
+
+			// Grammars\\ANTLR.g3:330:3: (aa= ARG_ACTION )?
+			int alt23=2;
+			int LA23_0 = input.LA(1);
+
+			if ( (LA23_0==ARG_ACTION) )
+			{
+				alt23=1;
+			}
+			switch ( alt23 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:330:5: aa= ARG_ACTION
+				{
+				aa=(IToken)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule1032); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_ARG_ACTION.Add(aa);
+
+
+				}
+				break;
+
+			}
+
+			// Grammars\\ANTLR.g3:331:3: ( 'returns' rt= ARG_ACTION )?
+			int alt24=2;
+			int LA24_0 = input.LA(1);
+
+			if ( (LA24_0==RETURNS) )
+			{
+				alt24=1;
+			}
+			switch ( alt24 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:331:5: 'returns' rt= ARG_ACTION
+				{
+				string_literal43=(IToken)Match(input,RETURNS,Follow._RETURNS_in_rule1041); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_RETURNS.Add(string_literal43);
+
+				rt=(IToken)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule1045); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_ARG_ACTION.Add(rt);
+
+
+				}
+				break;
+
+			}
+
+			// Grammars\\ANTLR.g3:332:3: ( throwsSpec )?
+			int alt25=2;
+			int LA25_0 = input.LA(1);
+
+			if ( (LA25_0==THROWS) )
+			{
+				alt25=1;
+			}
+			switch ( alt25 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:332:5: throwsSpec
+				{
+				PushFollow(Follow._throwsSpec_in_rule1055);
+				throwsSpec44=throwsSpec();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_throwsSpec.Add(throwsSpec44.Tree);
+
+				}
+				break;
+
+			}
+
+			// Grammars\\ANTLR.g3:333:3: ( optionsSpec )?
+			int alt26=2;
+			int LA26_0 = input.LA(1);
+
+			if ( (LA26_0==OPTIONS) )
+			{
+				alt26=1;
+			}
+			switch ( alt26 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:333:5: optionsSpec
+				{
+				PushFollow(Follow._optionsSpec_in_rule1064);
+				optionsSpec45=optionsSpec();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_optionsSpec.Add(optionsSpec45.Tree);
+
+				}
+				break;
+
+			}
+
+			PushFollow(Follow._ruleScopeSpec_in_rule1073);
+			scopes=ruleScopeSpec();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_ruleScopeSpec.Add(scopes.Tree);
+			// Grammars\\ANTLR.g3:335:3: ( ruleActions )?
+			int alt27=2;
+			int LA27_0 = input.LA(1);
+
+			if ( (LA27_0==AMPERSAND) )
+			{
+				alt27=1;
+			}
+			switch ( alt27 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:335:4: ruleActions
+				{
+				PushFollow(Follow._ruleActions_in_rule1078);
+				ruleActions46=ruleActions();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_ruleActions.Add(ruleActions46.Tree);
+
+				}
+				break;
+
+			}
+
+			COLON47=(IToken)Match(input,COLON,Follow._COLON_in_rule1084); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_COLON.Add(COLON47);
+
+			PushFollow(Follow._altList_in_rule1088);
+			altList48=altList((optionsSpec45!=null?optionsSpec45.opts:default(IDictionary<string, object>)));
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_altList.Add(altList48.Tree);
+			SEMI49=(IToken)Match(input,SEMI,Follow._SEMI_in_rule1093); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_SEMI.Add(SEMI49);
+
+			// Grammars\\ANTLR.g3:339:3: (ex= exceptionGroup )?
+			int alt28=2;
+			int LA28_0 = input.LA(1);
+
+			if ( (LA28_0==CATCH||LA28_0==FINALLY) )
+			{
+				alt28=1;
+			}
+			switch ( alt28 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:339:5: ex= exceptionGroup
+				{
+				PushFollow(Follow._exceptionGroup_in_rule1101);
+				ex=exceptionGroup();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_exceptionGroup.Add(ex.Tree);
+
+				}
+				break;
+
+			}
+
+
+
+			{
+			// AST REWRITE
+			// elements: ruleName, p1, p2, p3, p4, aa, rt, throwsSpec, optionsSpec, scopes, ruleActions, altList, ex
+			// token labels: p1, p2, p3, p4, aa, rt
+			// rule labels: ruleName, scopes, ex, retval
+			// token list labels:
+			// rule list labels:
+			// wildcard labels:
+			if ( state.backtracking == 0 ) {
+			retval.tree = root_0;
+			RewriteRuleITokenStream stream_p1=new RewriteRuleITokenStream(adaptor,"token p1",p1);
+			RewriteRuleITokenStream stream_p2=new RewriteRuleITokenStream(adaptor,"token p2",p2);
+			RewriteRuleITokenStream stream_p3=new RewriteRuleITokenStream(adaptor,"token p3",p3);
+			RewriteRuleITokenStream stream_p4=new RewriteRuleITokenStream(adaptor,"token p4",p4);
+			RewriteRuleITokenStream stream_aa=new RewriteRuleITokenStream(adaptor,"token aa",aa);
+			RewriteRuleITokenStream stream_rt=new RewriteRuleITokenStream(adaptor,"token rt",rt);
+			RewriteRuleSubtreeStream stream_ruleName=new RewriteRuleSubtreeStream(adaptor,"rule ruleName",ruleName!=null?ruleName.tree:null);
+			RewriteRuleSubtreeStream stream_scopes=new RewriteRuleSubtreeStream(adaptor,"rule scopes",scopes!=null?scopes.tree:null);
+			RewriteRuleSubtreeStream stream_ex=new RewriteRuleSubtreeStream(adaptor,"rule ex",ex!=null?ex.tree:null);
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+			root_0 = (GrammarAST)adaptor.Nil();
+			// 340:3: -> ^( RULE[\"rule\"] ^( $ruleName) ( $p1)? ( $p2)? ( $p3)? ( $p4)? ^( ARG[\"ARG\"] ( $aa)? ) ^( RET[\"RET\"] ( $rt)? ) ( throwsSpec )? ( optionsSpec )? ^( $scopes) ( ruleActions )? altList ( $ex)? EOR[$SEMI,\"<end-of-rule>\"] )
+			{
+				// Grammars\\ANTLR.g3:340:6: ^( RULE[\"rule\"] ^( $ruleName) ( $p1)? ( $p2)? ( $p3)? ( $p4)? ^( ARG[\"ARG\"] ( $aa)? ) ^( RET[\"RET\"] ( $rt)? ) ( throwsSpec )? ( optionsSpec )? ^( $scopes) ( ruleActions )? altList ( $ex)? EOR[$SEMI,\"<end-of-rule>\"] )
+				{
+				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+				root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(RULE, "rule"), root_1);
+
+				// Grammars\\ANTLR.g3:341:5: ^( $ruleName)
+				{
+				GrammarAST root_2 = (GrammarAST)adaptor.Nil();
+				root_2 = (GrammarAST)adaptor.BecomeRoot(stream_ruleName.NextNode(), root_2);
+
+				adaptor.AddChild(root_1, root_2);
+				}
+				// Grammars\\ANTLR.g3:343:6: ( $p1)?
+				if ( stream_p1.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_p1.NextNode());
+
+				}
+				stream_p1.Reset();
+				// Grammars\\ANTLR.g3:343:11: ( $p2)?
+				if ( stream_p2.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_p2.NextNode());
+
+				}
+				stream_p2.Reset();
+				// Grammars\\ANTLR.g3:343:16: ( $p3)?
+				if ( stream_p3.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_p3.NextNode());
+
+				}
+				stream_p3.Reset();
+				// Grammars\\ANTLR.g3:343:21: ( $p4)?
+				if ( stream_p4.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_p4.NextNode());
+
+				}
+				stream_p4.Reset();
+				// Grammars\\ANTLR.g3:344:5: ^( ARG[\"ARG\"] ( $aa)? )
+				{
+				GrammarAST root_2 = (GrammarAST)adaptor.Nil();
+				root_2 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(ARG, "ARG"), root_2);
+
+				// Grammars\\ANTLR.g3:344:19: ( $aa)?
+				if ( stream_aa.HasNext )
+				{
+					adaptor.AddChild(root_2, stream_aa.NextNode());
+
+				}
+				stream_aa.Reset();
+
+				adaptor.AddChild(root_1, root_2);
+				}
+				// Grammars\\ANTLR.g3:345:5: ^( RET[\"RET\"] ( $rt)? )
+				{
+				GrammarAST root_2 = (GrammarAST)adaptor.Nil();
+				root_2 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(RET, "RET"), root_2);
+
+				// Grammars\\ANTLR.g3:345:19: ( $rt)?
+				if ( stream_rt.HasNext )
+				{
+					adaptor.AddChild(root_2, stream_rt.NextNode());
+
+				}
+				stream_rt.Reset();
+
+				adaptor.AddChild(root_1, root_2);
+				}
+				// Grammars\\ANTLR.g3:346:5: ( throwsSpec )?
+				if ( stream_throwsSpec.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_throwsSpec.NextTree());
+
+				}
+				stream_throwsSpec.Reset();
+				// Grammars\\ANTLR.g3:347:5: ( optionsSpec )?
+				if ( stream_optionsSpec.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_optionsSpec.NextTree());
+
+				}
+				stream_optionsSpec.Reset();
+				// Grammars\\ANTLR.g3:348:5: ^( $scopes)
+				{
+				GrammarAST root_2 = (GrammarAST)adaptor.Nil();
+				root_2 = (GrammarAST)adaptor.BecomeRoot(stream_scopes.NextNode(), root_2);
+
+				adaptor.AddChild(root_1, root_2);
+				}
+				// Grammars\\ANTLR.g3:349:5: ( ruleActions )?
+				if ( stream_ruleActions.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_ruleActions.NextTree());
+
+				}
+				stream_ruleActions.Reset();
+				adaptor.AddChild(root_1, stream_altList.NextTree());
+				// Grammars\\ANTLR.g3:351:6: ( $ex)?
+				if ( stream_ex.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_ex.NextTree());
+
+				}
+				stream_ex.Reset();
+				adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EOR, SEMI49, "<end-of-rule>"));
+
+				adaptor.AddChild(root_0, root_1);
+				}
+
+			}
+
+			retval.tree = root_0;
+			}
+			}
+
+			}
+
+			if ( state.backtracking == 0 )
+			{
+
+						((GrammarAST)((GrammarAST)retval.tree).GetChild(0)).setBlockOptions( (optionsSpec45!=null?optionsSpec45.opts:default(IDictionary<string, object>)) );
+
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "rule"
+
+	public class ruleActions_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "ruleActions"
+	// Grammars\\ANTLR.g3:359:0: ruleActions : ( ruleAction )+ ;
+	private ANTLRParser.ruleActions_return ruleActions(  )
+	{
+		ANTLRParser.ruleActions_return retval = new ANTLRParser.ruleActions_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		ANTLRParser.ruleAction_return ruleAction50 = default(ANTLRParser.ruleAction_return);
+
+
+		try
+		{
+			// Grammars\\ANTLR.g3:360:4: ( ( ruleAction )+ )
+			// Grammars\\ANTLR.g3:360:4: ( ruleAction )+
+			{
+			root_0 = (GrammarAST)adaptor.Nil();
+
+			// Grammars\\ANTLR.g3:360:4: ( ruleAction )+
+			int cnt29=0;
+			for ( ; ; )
+			{
+				int alt29=2;
+				int LA29_0 = input.LA(1);
+
+				if ( (LA29_0==AMPERSAND) )
+				{
+					alt29=1;
+				}
+
+
+				switch ( alt29 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:360:5: ruleAction
+					{
+					PushFollow(Follow._ruleAction_in_ruleActions1243);
+					ruleAction50=ruleAction();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, ruleAction50.Tree);
+
+					}
+					break;
+
+				default:
+					if ( cnt29 >= 1 )
+						goto loop29;
+
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					EarlyExitException eee29 = new EarlyExitException( 29, input );
+					throw eee29;
+				}
+				cnt29++;
+			}
+			loop29:
+				;
+
+
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "ruleActions"
+
+	public class ruleAction_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "ruleAction"
+	// Grammars\\ANTLR.g3:364:0: ruleAction : AMPERSAND id ACTION ;
+	private ANTLRParser.ruleAction_return ruleAction(  )
+	{
+		ANTLRParser.ruleAction_return retval = new ANTLRParser.ruleAction_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken AMPERSAND51=null;
+		IToken ACTION53=null;
+		ANTLRParser.id_return id52 = default(ANTLRParser.id_return);
+
+		GrammarAST AMPERSAND51_tree=null;
+		GrammarAST ACTION53_tree=null;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:365:4: ( AMPERSAND id ACTION )
+			// Grammars\\ANTLR.g3:365:4: AMPERSAND id ACTION
+			{
+			root_0 = (GrammarAST)adaptor.Nil();
+
+			AMPERSAND51=(IToken)Match(input,AMPERSAND,Follow._AMPERSAND_in_ruleAction1258); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) {
+			AMPERSAND51_tree = (GrammarAST)adaptor.Create(AMPERSAND51);
+			root_0 = (GrammarAST)adaptor.BecomeRoot(AMPERSAND51_tree, root_0);
+			}
+			PushFollow(Follow._id_in_ruleAction1261);
+			id52=id();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, id52.Tree);
+			ACTION53=(IToken)Match(input,ACTION,Follow._ACTION_in_ruleAction1263); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			ACTION53_tree = (GrammarAST)adaptor.Create(ACTION53);
+			adaptor.AddChild(root_0, ACTION53_tree);
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "ruleAction"
+
+	public class throwsSpec_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "throwsSpec"
+	// Grammars\\ANTLR.g3:368:0: throwsSpec : 'throws' id ( COMMA id )* ;
+	private ANTLRParser.throwsSpec_return throwsSpec(  )
+	{
+		ANTLRParser.throwsSpec_return retval = new ANTLRParser.throwsSpec_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken string_literal54=null;
+		IToken COMMA56=null;
+		ANTLRParser.id_return id55 = default(ANTLRParser.id_return);
+		ANTLRParser.id_return id57 = default(ANTLRParser.id_return);
+
+		GrammarAST string_literal54_tree=null;
+		GrammarAST COMMA56_tree=null;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:369:4: ( 'throws' id ( COMMA id )* )
+			// Grammars\\ANTLR.g3:369:4: 'throws' id ( COMMA id )*
+			{
+			root_0 = (GrammarAST)adaptor.Nil();
+
+			string_literal54=(IToken)Match(input,THROWS,Follow._THROWS_in_throwsSpec1274); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) {
+			string_literal54_tree = (GrammarAST)adaptor.Create(string_literal54);
+			root_0 = (GrammarAST)adaptor.BecomeRoot(string_literal54_tree, root_0);
+			}
+			PushFollow(Follow._id_in_throwsSpec1277);
+			id55=id();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, id55.Tree);
+			// Grammars\\ANTLR.g3:369:17: ( COMMA id )*
+			for ( ; ; )
+			{
+				int alt30=2;
+				int LA30_0 = input.LA(1);
+
+				if ( (LA30_0==COMMA) )
+				{
+					alt30=1;
+				}
+
+
+				switch ( alt30 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:369:19: COMMA id
+					{
+					COMMA56=(IToken)Match(input,COMMA,Follow._COMMA_in_throwsSpec1281); if (state.failed) return retval;
+					PushFollow(Follow._id_in_throwsSpec1284);
+					id57=id();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, id57.Tree);
+
+					}
+					break;
+
+				default:
+					goto loop30;
+				}
+			}
+
+			loop30:
+				;
+
+
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "throwsSpec"
+
+	public class ruleScopeSpec_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "ruleScopeSpec"
+	// Grammars\\ANTLR.g3:372:0: ruleScopeSpec : ( 'scope' ( ruleActions )? ACTION )? ( 'scope' idList SEMI )* -> ^( SCOPE[$start,\"scope\"] ( ruleActions )? ( ACTION )? ( idList )* ) ;
+	private ANTLRParser.ruleScopeSpec_return ruleScopeSpec(  )
+	{
+		ANTLRParser.ruleScopeSpec_return retval = new ANTLRParser.ruleScopeSpec_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken string_literal58=null;
+		IToken ACTION60=null;
+		IToken string_literal61=null;
+		IToken SEMI63=null;
+		ANTLRParser.ruleActions_return ruleActions59 = default(ANTLRParser.ruleActions_return);
+		ANTLRParser.idList_return idList62 = default(ANTLRParser.idList_return);
+
+		GrammarAST string_literal58_tree=null;
+		GrammarAST ACTION60_tree=null;
+		GrammarAST string_literal61_tree=null;
+		GrammarAST SEMI63_tree=null;
+		RewriteRuleITokenStream stream_SCOPE=new RewriteRuleITokenStream(adaptor,"token SCOPE");
+		RewriteRuleITokenStream stream_ACTION=new RewriteRuleITokenStream(adaptor,"token ACTION");
+		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
+		RewriteRuleSubtreeStream stream_ruleActions=new RewriteRuleSubtreeStream(adaptor,"rule ruleActions");
+		RewriteRuleSubtreeStream stream_idList=new RewriteRuleSubtreeStream(adaptor,"rule idList");
+		try
+		{
+			// Grammars\\ANTLR.g3:373:4: ( ( 'scope' ( ruleActions )? ACTION )? ( 'scope' idList SEMI )* -> ^( SCOPE[$start,\"scope\"] ( ruleActions )? ( ACTION )? ( idList )* ) )
+			// Grammars\\ANTLR.g3:373:4: ( 'scope' ( ruleActions )? ACTION )? ( 'scope' idList SEMI )*
+			{
+			// Grammars\\ANTLR.g3:373:4: ( 'scope' ( ruleActions )? ACTION )?
+			int alt32=2;
+			int LA32_0 = input.LA(1);
+
+			if ( (LA32_0==SCOPE) )
+			{
+				int LA32_1 = input.LA(2);
+
+				if ( (LA32_1==ACTION||LA32_1==AMPERSAND) )
+				{
+					alt32=1;
+				}
+			}
+			switch ( alt32 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:373:6: 'scope' ( ruleActions )? ACTION
+				{
+				string_literal58=(IToken)Match(input,SCOPE,Follow._SCOPE_in_ruleScopeSpec1300); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_SCOPE.Add(string_literal58);
+
+				// Grammars\\ANTLR.g3:373:14: ( ruleActions )?
+				int alt31=2;
+				int LA31_0 = input.LA(1);
+
+				if ( (LA31_0==AMPERSAND) )
+				{
+					alt31=1;
+				}
+				switch ( alt31 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:373:0: ruleActions
+					{
+					PushFollow(Follow._ruleActions_in_ruleScopeSpec1302);
+					ruleActions59=ruleActions();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) stream_ruleActions.Add(ruleActions59.Tree);
+
+					}
+					break;
+
+				}
+
+				ACTION60=(IToken)Match(input,ACTION,Follow._ACTION_in_ruleScopeSpec1305); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_ACTION.Add(ACTION60);
+
+
+				}
+				break;
+
+			}
+
+			// Grammars\\ANTLR.g3:374:3: ( 'scope' idList SEMI )*
+			for ( ; ; )
+			{
+				int alt33=2;
+				int LA33_0 = input.LA(1);
+
+				if ( (LA33_0==SCOPE) )
+				{
+					alt33=1;
+				}
+
+
+				switch ( alt33 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:374:5: 'scope' idList SEMI
+					{
+					string_literal61=(IToken)Match(input,SCOPE,Follow._SCOPE_in_ruleScopeSpec1314); if (state.failed) return retval;
+					if ( state.backtracking == 0 ) stream_SCOPE.Add(string_literal61);
+
+					PushFollow(Follow._idList_in_ruleScopeSpec1316);
+					idList62=idList();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) stream_idList.Add(idList62.Tree);
+					SEMI63=(IToken)Match(input,SEMI,Follow._SEMI_in_ruleScopeSpec1318); if (state.failed) return retval;
+					if ( state.backtracking == 0 ) stream_SEMI.Add(SEMI63);
+
+
+					}
+					break;
+
+				default:
+					goto loop33;
+				}
+			}
+
+			loop33:
+				;
+
+
+
+
+			{
+			// AST REWRITE
+			// elements: ruleActions, ACTION, idList
+			// token labels:
+			// rule labels: retval
+			// token list labels:
+			// rule list labels:
+			// wildcard labels:
+			if ( state.backtracking == 0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+			root_0 = (GrammarAST)adaptor.Nil();
+			// 375:3: -> ^( SCOPE[$start,\"scope\"] ( ruleActions )? ( ACTION )? ( idList )* )
+			{
+				// Grammars\\ANTLR.g3:375:6: ^( SCOPE[$start,\"scope\"] ( ruleActions )? ( ACTION )? ( idList )* )
+				{
+				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+				root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(SCOPE, ((IToken)retval.start), "scope"), root_1);
+
+				// Grammars\\ANTLR.g3:375:30: ( ruleActions )?
+				if ( stream_ruleActions.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_ruleActions.NextTree());
+
+				}
+				stream_ruleActions.Reset();
+				// Grammars\\ANTLR.g3:375:43: ( ACTION )?
+				if ( stream_ACTION.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_ACTION.NextNode());
+
+				}
+				stream_ACTION.Reset();
+				// Grammars\\ANTLR.g3:375:51: ( idList )*
+				while ( stream_idList.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_idList.NextTree());
+
+				}
+				stream_idList.Reset();
+
+				adaptor.AddChild(root_0, root_1);
+				}
+
+			}
+
+			retval.tree = root_0;
+			}
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "ruleScopeSpec"
+
+	public class block_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "block"
+	// Grammars\\ANTLR.g3:379:0: block : (lp= LPAREN -> BLOCK[$lp,\"BLOCK\"] ) ( ( optionsSpec )? ( ruleActions )? COLON | ACTION COLON )? a= alternative r= rewrite ( OR a= alternative r= rewrite )* rp= RPAREN -> ^( $block ( optionsSpec )? ( ruleActions )? ( ACTION )? ( alternative )+ EOB[$rp,\"<end-of-block>\"] ) ;
+	private ANTLRParser.block_return block(  )
+	{
+		ANTLRParser.block_return retval = new ANTLRParser.block_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken lp=null;
+		IToken rp=null;
+		IToken COLON66=null;
+		IToken ACTION67=null;
+		IToken COLON68=null;
+		IToken OR69=null;
+		ANTLRParser.alternative_return a = default(ANTLRParser.alternative_return);
+		ANTLRParser.rewrite_return r = default(ANTLRParser.rewrite_return);
+		ANTLRParser.optionsSpec_return optionsSpec64 = default(ANTLRParser.optionsSpec_return);
+		ANTLRParser.ruleActions_return ruleActions65 = default(ANTLRParser.ruleActions_return);
+
+		GrammarAST lp_tree=null;
+		GrammarAST rp_tree=null;
+		GrammarAST COLON66_tree=null;
+		GrammarAST ACTION67_tree=null;
+		GrammarAST COLON68_tree=null;
+		GrammarAST OR69_tree=null;
+		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
+		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
+		RewriteRuleITokenStream stream_ACTION=new RewriteRuleITokenStream(adaptor,"token ACTION");
+		RewriteRuleITokenStream stream_OR=new RewriteRuleITokenStream(adaptor,"token OR");
+		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
+		RewriteRuleSubtreeStream stream_optionsSpec=new RewriteRuleSubtreeStream(adaptor,"rule optionsSpec");
+		RewriteRuleSubtreeStream stream_ruleActions=new RewriteRuleSubtreeStream(adaptor,"rule ruleActions");
+		RewriteRuleSubtreeStream stream_alternative=new RewriteRuleSubtreeStream(adaptor,"rule alternative");
+		RewriteRuleSubtreeStream stream_rewrite=new RewriteRuleSubtreeStream(adaptor,"rule rewrite");
+
+			GrammarAST save = currentBlockAST;
+			Map opts=null;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:385:4: ( (lp= LPAREN -> BLOCK[$lp,\"BLOCK\"] ) ( ( optionsSpec )? ( ruleActions )? COLON | ACTION COLON )? a= alternative r= rewrite ( OR a= alternative r= rewrite )* rp= RPAREN -> ^( $block ( optionsSpec )? ( ruleActions )? ( ACTION )? ( alternative )+ EOB[$rp,\"<end-of-block>\"] ) )
+			// Grammars\\ANTLR.g3:385:4: (lp= LPAREN -> BLOCK[$lp,\"BLOCK\"] ) ( ( optionsSpec )? ( ruleActions )? COLON | ACTION COLON )? a= alternative r= rewrite ( OR a= alternative r= rewrite )* rp= RPAREN
+			{
+			// Grammars\\ANTLR.g3:385:4: (lp= LPAREN -> BLOCK[$lp,\"BLOCK\"] )
+			// Grammars\\ANTLR.g3:385:6: lp= LPAREN
+			{
+			lp=(IToken)Match(input,LPAREN,Follow._LPAREN_in_block1361); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_LPAREN.Add(lp);
+
+
+
+			{
+			// AST REWRITE
+			// elements:
+			// token labels:
+			// rule labels: retval
+			// token list labels:
+			// rule list labels:
+			// wildcard labels:
+			if ( state.backtracking == 0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+			root_0 = (GrammarAST)adaptor.Nil();
+			// 386:4: -> BLOCK[$lp,\"BLOCK\"]
+			{
+				adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(BLOCK, lp, "BLOCK"));
+
+			}
+
+			retval.tree = root_0;
+			}
+			}
+
+			}
+
+			if ( state.backtracking == 0 )
+			{
+				currentBlockAST = (GrammarAST)((GrammarAST)retval.tree).GetChild(0);
+			}
+			// Grammars\\ANTLR.g3:389:3: ( ( optionsSpec )? ( ruleActions )? COLON | ACTION COLON )?
+			int alt36=3;
+			int LA36_0 = input.LA(1);
+
+			if ( (LA36_0==AMPERSAND||LA36_0==COLON||LA36_0==OPTIONS) )
+			{
+				alt36=1;
+			}
+			else if ( (LA36_0==ACTION) )
+			{
+				int LA36_2 = input.LA(2);
+
+				if ( (LA36_2==COLON) )
+				{
+					alt36=2;
+				}
+			}
+			switch ( alt36 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:393:4: ( optionsSpec )? ( ruleActions )? COLON
+				{
+				// Grammars\\ANTLR.g3:393:4: ( optionsSpec )?
+				int alt34=2;
+				int LA34_0 = input.LA(1);
+
+				if ( (LA34_0==OPTIONS) )
+				{
+					alt34=1;
+				}
+				switch ( alt34 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:393:5: optionsSpec
+					{
+					PushFollow(Follow._optionsSpec_in_block1399);
+					optionsSpec64=optionsSpec();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) stream_optionsSpec.Add(optionsSpec64.Tree);
+					if ( state.backtracking == 0 )
+					{
+						((GrammarAST)((GrammarAST)retval.tree).GetChild(0)).setOptions(Grammar,(optionsSpec64!=null?optionsSpec64.opts:default(IDictionary<string, object>)));
+					}
+
+					}
+					break;
+
+				}
+
+				// Grammars\\ANTLR.g3:394:4: ( ruleActions )?
+				int alt35=2;
+				int LA35_0 = input.LA(1);
+
+				if ( (LA35_0==AMPERSAND) )
+				{
+					alt35=1;
+				}
+				switch ( alt35 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:394:6: ruleActions
+					{
+					PushFollow(Follow._ruleActions_in_block1410);
+					ruleActions65=ruleActions();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) stream_ruleActions.Add(ruleActions65.Tree);
+
+					}
+					break;
+
+				}
+
+				COLON66=(IToken)Match(input,COLON,Follow._COLON_in_block1418); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_COLON.Add(COLON66);
+
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:396:5: ACTION COLON
+				{
+				ACTION67=(IToken)Match(input,ACTION,Follow._ACTION_in_block1424); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_ACTION.Add(ACTION67);
+
+				COLON68=(IToken)Match(input,COLON,Follow._COLON_in_block1426); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_COLON.Add(COLON68);
+
+
+				}
+				break;
+
+			}
+
+			PushFollow(Follow._alternative_in_block1438);
+			a=alternative();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_alternative.Add(a.Tree);
+			PushFollow(Follow._rewrite_in_block1442);
+			r=rewrite();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_rewrite.Add(r.Tree);
+			if ( state.backtracking == 0 )
+			{
+
+							stream_alternative.Add( (r!=null?((GrammarAST)r.tree):null) );
+							if ( LA(1)==OR || (LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR) )
+								prefixWithSynPred((a!=null?((GrammarAST)a.tree):null));
+
+			}
+			// Grammars\\ANTLR.g3:405:3: ( OR a= alternative r= rewrite )*
+			for ( ; ; )
+			{
+				int alt37=2;
+				int LA37_0 = input.LA(1);
+
+				if ( (LA37_0==OR) )
+				{
+					alt37=1;
+				}
+
+
+				switch ( alt37 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:405:5: OR a= alternative r= rewrite
+					{
+					OR69=(IToken)Match(input,OR,Follow._OR_in_block1452); if (state.failed) return retval;
+					if ( state.backtracking == 0 ) stream_OR.Add(OR69);
+
+					PushFollow(Follow._alternative_in_block1456);
+					a=alternative();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) stream_alternative.Add(a.Tree);
+					PushFollow(Follow._rewrite_in_block1460);
+					r=rewrite();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) stream_rewrite.Add(r.Tree);
+					if ( state.backtracking == 0 )
+					{
+
+										stream_alternative.Add( (r!=null?((GrammarAST)r.tree):null) );
+										if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR))
+											prefixWithSynPred((a!=null?((GrammarAST)a.tree):null));
+
+					}
+
+					}
+					break;
+
+				default:
+					goto loop37;
+				}
+			}
+
+			loop37:
+				;
+
+
+			rp=(IToken)Match(input,RPAREN,Follow._RPAREN_in_block1477); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_RPAREN.Add(rp);
+
+
+
+			{
+			// AST REWRITE
+			// elements: block, optionsSpec, ruleActions, ACTION, alternative
+			// token labels:
+			// rule labels: retval
+			// token list labels:
+			// rule list labels:
+			// wildcard labels:
+			if ( state.backtracking == 0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+			root_0 = (GrammarAST)adaptor.Nil();
+			// 414:3: -> ^( $block ( optionsSpec )? ( ruleActions )? ( ACTION )? ( alternative )+ EOB[$rp,\"<end-of-block>\"] )
+			{
+				// Grammars\\ANTLR.g3:414:6: ^( $block ( optionsSpec )? ( ruleActions )? ( ACTION )? ( alternative )+ EOB[$rp,\"<end-of-block>\"] )
+				{
+				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+				root_1 = (GrammarAST)adaptor.BecomeRoot(stream_retval.NextNode(), root_1);
+
+				// Grammars\\ANTLR.g3:414:15: ( optionsSpec )?
+				if ( stream_optionsSpec.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_optionsSpec.NextTree());
+
+				}
+				stream_optionsSpec.Reset();
+				// Grammars\\ANTLR.g3:414:28: ( ruleActions )?
+				if ( stream_ruleActions.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_ruleActions.NextTree());
+
+				}
+				stream_ruleActions.Reset();
+				// Grammars\\ANTLR.g3:414:41: ( ACTION )?
+				if ( stream_ACTION.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_ACTION.NextNode());
+
+				}
+				stream_ACTION.Reset();
+				if ( !(stream_alternative.HasNext) )
+				{
+					throw new RewriteEarlyExitException();
+				}
+				while ( stream_alternative.HasNext )
+				{
+					adaptor.AddChild(root_1, stream_alternative.NextTree());
+
+				}
+				stream_alternative.Reset();
+				adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EOB, rp, "<end-of-block>"));
+
+				adaptor.AddChild(root_0, root_1);
+				}
+
+			}
+
+			retval.tree = root_0;
+			}
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+			 currentBlockAST = save;
+		}
+		return retval;
+	}
+	// $ANTLR end "block"
+
+	public class altList_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "altList"
+	// Grammars\\ANTLR.g3:418:0: altList[IDictionary<string, object> opts] : ( -> BLOCK[$start,\"BLOCK\"] ) (a1= alternative r1= rewrite -> $a1 ( $r1)? ) ( OR a2= alternative r2= rewrite -> $altList $a2 ( $r2)? )* -> ^( $altList EOB[\"<end-of-block>\"] ) ;
+	private ANTLRParser.altList_return altList( IDictionary<string, object> opts )
+	{
+		ANTLRParser.altList_return retval = new ANTLRParser.altList_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken OR70=null;
+		ANTLRParser.alternative_return a1 = default(ANTLRParser.alternative_return);
+		ANTLRParser.rewrite_return r1 = default(ANTLRParser.rewrite_return);
+		ANTLRParser.alternative_return a2 = default(ANTLRParser.alternative_return);
+		ANTLRParser.rewrite_return r2 = default(ANTLRParser.rewrite_return);
+
+		GrammarAST OR70_tree=null;
+		RewriteRuleITokenStream stream_OR=new RewriteRuleITokenStream(adaptor,"token OR");
+		RewriteRuleSubtreeStream stream_alternative=new RewriteRuleSubtreeStream(adaptor,"rule alternative");
+		RewriteRuleSubtreeStream stream_rewrite=new RewriteRuleSubtreeStream(adaptor,"rule rewrite");
+
+			GrammarAST blkRoot = null;
+			GrammarAST save = currentBlockAST;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:424:4: ( ( -> BLOCK[$start,\"BLOCK\"] ) (a1= alternative r1= rewrite -> $a1 ( $r1)? ) ( OR a2= alternative r2= rewrite -> $altList $a2 ( $r2)? )* -> ^( $altList EOB[\"<end-of-block>\"] ) )
+			// Grammars\\ANTLR.g3:424:4: ( -> BLOCK[$start,\"BLOCK\"] ) (a1= alternative r1= rewrite -> $a1 ( $r1)? ) ( OR a2= alternative r2= rewrite -> $altList $a2 ( $r2)? )*
+			{
+			// Grammars\\ANTLR.g3:424:4: ( -> BLOCK[$start,\"BLOCK\"] )
+			// Grammars\\ANTLR.g3:424:6:
+			{
+
+
+
+			{
+			// AST REWRITE
+			// elements:
+			// token labels:
+			// rule labels: retval
+			// token list labels:
+			// rule list labels:
+			// wildcard labels:
+			if ( state.backtracking == 0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+			root_0 = (GrammarAST)adaptor.Nil();
+			// 424:6: -> BLOCK[$start,\"BLOCK\"]
+			{
+				adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(BLOCK, ((IToken)retval.start), "BLOCK"));
+
+			}
+
+			retval.tree = root_0;
+			}
+			}
+
+			}
+
+			if ( state.backtracking == 0 )
+			{
+
+							blkRoot = (GrammarAST)((GrammarAST)retval.tree).GetChild(0);
+							blkRoot.setBlockOptions( opts );
+							currentBlockAST = blkRoot;
+
+			}
+			// Grammars\\ANTLR.g3:430:3: (a1= alternative r1= rewrite -> $a1 ( $r1)? )
+			// Grammars\\ANTLR.g3:430:5: a1= alternative r1= rewrite
+			{
+			PushFollow(Follow._alternative_in_altList1541);
+			a1=alternative();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_alternative.Add(a1.Tree);
+			PushFollow(Follow._rewrite_in_altList1545);
+			r1=rewrite();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_rewrite.Add(r1.Tree);
+			if ( state.backtracking == 0 )
+			{
+				if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR)) prefixWithSynPred((a1!=null?((GrammarAST)a1.tree):null));
+			}
+
+
+			{
+			// AST REWRITE
+			// elements: a1, r1
+			// token labels:
+			// rule labels: a1, r1, retval
+			// token list labels:
+			// rule list labels:
+			// wildcard labels:
+			if ( state.backtracking == 0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_a1=new RewriteRuleSubtreeStream(adaptor,"rule a1",a1!=null?a1.tree:null);
+			RewriteRuleSubtreeStream stream_r1=new RewriteRuleSubtreeStream(adaptor,"rule r1",r1!=null?r1.tree:null);
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+			root_0 = (GrammarAST)adaptor.Nil();
+			// 432:4: -> $a1 ( $r1)?
+			{
+				adaptor.AddChild(root_0, stream_a1.NextTree());
+				// Grammars\\ANTLR.g3:432:12: ( $r1)?
+				if ( stream_r1.HasNext )
+				{
+					adaptor.AddChild(root_0, stream_r1.NextTree());
+
+				}
+				stream_r1.Reset();
+
+			}
+
+			retval.tree = root_0;
+			}
+			}
+
+			}
+
+			// Grammars\\ANTLR.g3:434:3: ( OR a2= alternative r2= rewrite -> $altList $a2 ( $r2)? )*
+			for ( ; ; )
+			{
+				int alt38=2;
+				int LA38_0 = input.LA(1);
+
+				if ( (LA38_0==OR) )
+				{
+					alt38=1;
+				}
+
+
+				switch ( alt38 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:434:5: OR a2= alternative r2= rewrite
+					{
+					OR70=(IToken)Match(input,OR,Follow._OR_in_altList1572); if (state.failed) return retval;
+					if ( state.backtracking == 0 ) stream_OR.Add(OR70);
+
+					PushFollow(Follow._alternative_in_altList1576);
+					a2=alternative();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) stream_alternative.Add(a2.Tree);
+					PushFollow(Follow._rewrite_in_altList1580);
+					r2=rewrite();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) stream_rewrite.Add(r2.Tree);
+					if ( state.backtracking == 0 )
+					{
+						if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR)) prefixWithSynPred((a2!=null?((GrammarAST)a2.tree):null));
+					}
+
+
+					{
+					// AST REWRITE
+					// elements: altList, a2, r2
+					// token labels:
+					// rule labels: a2, r2, retval
+					// token list labels:
+					// rule list labels:
+					// wildcard labels:
+					if ( state.backtracking == 0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_a2=new RewriteRuleSubtreeStream(adaptor,"rule a2",a2!=null?a2.tree:null);
+					RewriteRuleSubtreeStream stream_r2=new RewriteRuleSubtreeStream(adaptor,"rule r2",r2!=null?r2.tree:null);
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+					root_0 = (GrammarAST)adaptor.Nil();
+					// 436:4: -> $altList $a2 ( $r2)?
+					{
+						adaptor.AddChild(root_0, stream_retval.NextTree());
+						adaptor.AddChild(root_0, stream_a2.NextTree());
+						// Grammars\\ANTLR.g3:436:21: ( $r2)?
+						if ( stream_r2.HasNext )
+						{
+							adaptor.AddChild(root_0, stream_r2.NextTree());
+
+						}
+						stream_r2.Reset();
+
+					}
+
+					retval.tree = root_0;
+					}
+					}
+
+					}
+					break;
+
+				default:
+					goto loop38;
+				}
+			}
+
+			loop38:
+				;
+
+
+
+
+			{
+			// AST REWRITE
+			// elements: altList
+			// token labels:
+			// rule labels: retval
+			// token list labels:
+			// rule list labels:
+			// wildcard labels:
+			if ( state.backtracking == 0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+			root_0 = (GrammarAST)adaptor.Nil();
+			// 438:3: -> ^( $altList EOB[\"<end-of-block>\"] )
+			{
+				// Grammars\\ANTLR.g3:438:6: ^( $altList EOB[\"<end-of-block>\"] )
+				{
+				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+				root_1 = (GrammarAST)adaptor.BecomeRoot(blkRoot, root_1);
+
+				adaptor.AddChild(root_1, stream_retval.NextTree());
+				adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EOB, "<end-of-block>"));
+
+				adaptor.AddChild(root_0, root_1);
+				}
+
+			}
+
+			retval.tree = root_0;
+			}
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+			 currentBlockAST = save;
+		}
+		return retval;
+	}
+	// $ANTLR end "altList"
+
+	public class alternative_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "alternative"
+	// Grammars\\ANTLR.g3:442:0: alternative : ( -> EOA[\"<end-of-alt>\"] ) ( -> ALT[$start,\"ALT\"] ) ( (el+= element )+ -> ^( ( $el)+ ) | -> ^( EPSILON[$start,\"epsilon\"] ) ) ;
+	private ANTLRParser.alternative_return alternative(  )
+	{
+		ANTLRParser.alternative_return retval = new ANTLRParser.alternative_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		List list_el=null;
+		ANTLRParser.element_return el = default(ANTLRParser.element_return);
+		RewriteRuleSubtreeStream stream_element=new RewriteRuleSubtreeStream(adaptor,"rule element");
+
+			GrammarAST eoa = null;
+			GrammarAST altRoot = null;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:448:4: ( ( -> EOA[\"<end-of-alt>\"] ) ( -> ALT[$start,\"ALT\"] ) ( (el+= element )+ -> ^( ( $el)+ ) | -> ^( EPSILON[$start,\"epsilon\"] ) ) )
+			// Grammars\\ANTLR.g3:448:4: ( -> EOA[\"<end-of-alt>\"] ) ( -> ALT[$start,\"ALT\"] ) ( (el+= element )+ -> ^( ( $el)+ ) | -> ^( EPSILON[$start,\"epsilon\"] ) )
+			{
+			// Grammars\\ANTLR.g3:448:4: ( -> EOA[\"<end-of-alt>\"] )
+			// Grammars\\ANTLR.g3:448:6:
+			{
+
+
+
+			{
+			// AST REWRITE
+			// elements:
+			// token labels:
+			// rule labels: retval
+			// token list labels:
+			// rule list labels:
+			// wildcard labels:
+			if ( state.backtracking == 0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+			root_0 = (GrammarAST)adaptor.Nil();
+			// 448:6: -> EOA[\"<end-of-alt>\"]
+			{
+				adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(EOA, "<end-of-alt>"));
+
+			}
+
+			retval.tree = root_0;
+			}
+			}
+
+			}
+
+			if ( state.backtracking == 0 )
+			{
+				 eoa = ((GrammarAST)retval.tree);
+			}
+			// Grammars\\ANTLR.g3:450:3: ( -> ALT[$start,\"ALT\"] )
+			// Grammars\\ANTLR.g3:450:5:
+			{
+
+
+
+			{
+			// AST REWRITE
+			// elements:
+			// token labels:
+			// rule labels: retval
+			// token list labels:
+			// rule list labels:
+			// wildcard labels:
+			if ( state.backtracking == 0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+			root_0 = (GrammarAST)adaptor.Nil();
+			// 450:5: -> ALT[$start,\"ALT\"]
+			{
+				adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(ALT, ((IToken)retval.start), "ALT"));
+
+			}
+
+			retval.tree = root_0;
+			}
+			}
+
+			}
+
+			if ( state.backtracking == 0 )
+			{
+				 altRoot = ((GrammarAST)retval.tree);
+			}
+			// Grammars\\ANTLR.g3:453:3: ( (el+= element )+ -> ^( ( $el)+ ) | -> ^( EPSILON[$start,\"epsilon\"] ) )
+			int alt40=2;
+			int LA40_0 = input.LA(1);
+
+			if ( (LA40_0==ACTION||LA40_0==CHAR_LITERAL||LA40_0==FORCED_ACTION||LA40_0==LPAREN||LA40_0==NOT||LA40_0==RULE_REF||LA40_0==SEMPRED||LA40_0==STRING_LITERAL||LA40_0==TOKEN_REF||LA40_0==TREE_BEGIN||LA40_0==WILDCARD) )
+			{
+				alt40=1;
+			}
+			else if ( (LA40_0==OR||LA40_0==REWRITE||LA40_0==RPAREN||LA40_0==SEMI) )
+			{
+				alt40=2;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae = new NoViableAltException("", 40, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt40 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:453:5: (el+= element )+
+				{
+				// Grammars\\ANTLR.g3:453:5: (el+= element )+
+				int cnt39=0;
+				for ( ; ; )
+				{
+					int alt39=2;
+					int LA39_0 = input.LA(1);
+
+					if ( (LA39_0==ACTION||LA39_0==CHAR_LITERAL||LA39_0==FORCED_ACTION||LA39_0==LPAREN||LA39_0==NOT||LA39_0==RULE_REF||LA39_0==SEMPRED||LA39_0==STRING_LITERAL||LA39_0==TOKEN_REF||LA39_0==TREE_BEGIN||LA39_0==WILDCARD) )
+					{
+						alt39=1;
+					}
+
+
+					switch ( alt39 )
+					{
+					case 1:
+						// Grammars\\ANTLR.g3:453:7: el+= element
+						{
+						PushFollow(Follow._element_in_alternative1676);
+						el=element();
+
+						state._fsp--;
+						if (state.failed) return retval;
+						if ( state.backtracking == 0 ) stream_element.Add(el.Tree);
+						if (list_el==null) list_el=new ArrayList();
+						list_el.Add(el.Tree);
+
+
+						}
+						break;
+
+					default:
+						if ( cnt39 >= 1 )
+							goto loop39;
+
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						EarlyExitException eee39 = new EarlyExitException( 39, input );
+						throw eee39;
+					}
+					cnt39++;
+				}
+				loop39:
+					;
+
+
+
+
+				{
+				// AST REWRITE
+				// elements: el
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels: el
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+				RewriteRuleSubtreeStream stream_el=new RewriteRuleSubtreeStream(adaptor,"token el",list_el);
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 454:4: -> ^( ( $el)+ )
+				{
+					// Grammars\\ANTLR.g3:454:7: ^( ( $el)+ )
+					{
+					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+					root_1 = (GrammarAST)adaptor.BecomeRoot(altRoot, root_1);
+
+					if ( !(stream_el.HasNext) )
+					{
+						throw new RewriteEarlyExitException();
+					}
+					while ( stream_el.HasNext )
+					{
+						adaptor.AddChild(root_1, stream_el.NextTree());
+
+					}
+					stream_el.Reset();
+					adaptor.AddChild(root_1, eoa);
+
+					adaptor.AddChild(root_0, root_1);
+					}
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:456:4:
+				{
+
+
+
+				{
+				// AST REWRITE
+				// elements:
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 456:4: -> ^( EPSILON[$start,\"epsilon\"] )
+				{
+					// Grammars\\ANTLR.g3:456:7: ^( EPSILON[$start,\"epsilon\"] )
+					{
+					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+					root_1 = (GrammarAST)adaptor.BecomeRoot(altRoot, root_1);
+
+					adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EPSILON, ((IToken)retval.start), "epsilon"));
+					adaptor.AddChild(root_1, eoa);
+
+					adaptor.AddChild(root_0, root_1);
+					}
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+
+			}
+
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "alternative"
+
+	public class exceptionGroup_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "exceptionGroup"
+	// Grammars\\ANTLR.g3:460:0: exceptionGroup : ( ( exceptionHandler )+ ( finallyClause )? | finallyClause );
+	private ANTLRParser.exceptionGroup_return exceptionGroup(  )
+	{
+		ANTLRParser.exceptionGroup_return retval = new ANTLRParser.exceptionGroup_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		ANTLRParser.exceptionHandler_return exceptionHandler71 = default(ANTLRParser.exceptionHandler_return);
+		ANTLRParser.finallyClause_return finallyClause72 = default(ANTLRParser.finallyClause_return);
+		ANTLRParser.finallyClause_return finallyClause73 = default(ANTLRParser.finallyClause_return);
+
+
+		try
+		{
+			// Grammars\\ANTLR.g3:461:4: ( ( exceptionHandler )+ ( finallyClause )? | finallyClause )
+			int alt43=2;
+			int LA43_0 = input.LA(1);
+
+			if ( (LA43_0==CATCH) )
+			{
+				alt43=1;
+			}
+			else if ( (LA43_0==FINALLY) )
+			{
+				alt43=2;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae = new NoViableAltException("", 43, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt43 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:461:4: ( exceptionHandler )+ ( finallyClause )?
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				// Grammars\\ANTLR.g3:461:4: ( exceptionHandler )+
+				int cnt41=0;
+				for ( ; ; )
+				{
+					int alt41=2;
+					int LA41_0 = input.LA(1);
+
+					if ( (LA41_0==CATCH) )
+					{
+						alt41=1;
+					}
+
+
+					switch ( alt41 )
+					{
+					case 1:
+						// Grammars\\ANTLR.g3:461:6: exceptionHandler
+						{
+						PushFollow(Follow._exceptionHandler_in_exceptionGroup1729);
+						exceptionHandler71=exceptionHandler();
+
+						state._fsp--;
+						if (state.failed) return retval;
+						if ( state.backtracking == 0 ) adaptor.AddChild(root_0, exceptionHandler71.Tree);
+
+						}
+						break;
+
+					default:
+						if ( cnt41 >= 1 )
+							goto loop41;
+
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						EarlyExitException eee41 = new EarlyExitException( 41, input );
+						throw eee41;
+					}
+					cnt41++;
+				}
+				loop41:
+					;
+
+
+				// Grammars\\ANTLR.g3:461:26: ( finallyClause )?
+				int alt42=2;
+				int LA42_0 = input.LA(1);
+
+				if ( (LA42_0==FINALLY) )
+				{
+					alt42=1;
+				}
+				switch ( alt42 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:461:28: finallyClause
+					{
+					PushFollow(Follow._finallyClause_in_exceptionGroup1736);
+					finallyClause72=finallyClause();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, finallyClause72.Tree);
+
+					}
+					break;
+
+				}
+
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:462:4: finallyClause
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				PushFollow(Follow._finallyClause_in_exceptionGroup1744);
+				finallyClause73=finallyClause();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, finallyClause73.Tree);
+
+				}
+				break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "exceptionGroup"
+
+	public class exceptionHandler_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "exceptionHandler"
+	// Grammars\\ANTLR.g3:465:0: exceptionHandler : 'catch' ARG_ACTION ACTION ;
+	private ANTLRParser.exceptionHandler_return exceptionHandler(  )
+	{
+		ANTLRParser.exceptionHandler_return retval = new ANTLRParser.exceptionHandler_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken string_literal74=null;
+		IToken ARG_ACTION75=null;
+		IToken ACTION76=null;
+
+		GrammarAST string_literal74_tree=null;
+		GrammarAST ARG_ACTION75_tree=null;
+		GrammarAST ACTION76_tree=null;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:466:4: ( 'catch' ARG_ACTION ACTION )
+			// Grammars\\ANTLR.g3:466:4: 'catch' ARG_ACTION ACTION
+			{
+			root_0 = (GrammarAST)adaptor.Nil();
+
+			string_literal74=(IToken)Match(input,CATCH,Follow._CATCH_in_exceptionHandler1755); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) {
+			string_literal74_tree = (GrammarAST)adaptor.Create(string_literal74);
+			root_0 = (GrammarAST)adaptor.BecomeRoot(string_literal74_tree, root_0);
+			}
+			ARG_ACTION75=(IToken)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_exceptionHandler1758); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			ARG_ACTION75_tree = (GrammarAST)adaptor.Create(ARG_ACTION75);
+			adaptor.AddChild(root_0, ARG_ACTION75_tree);
+			}
+			ACTION76=(IToken)Match(input,ACTION,Follow._ACTION_in_exceptionHandler1760); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			ACTION76_tree = (GrammarAST)adaptor.Create(ACTION76);
+			adaptor.AddChild(root_0, ACTION76_tree);
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "exceptionHandler"
+
+	public class finallyClause_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "finallyClause"
+	// Grammars\\ANTLR.g3:469:0: finallyClause : 'finally' ACTION ;
+	private ANTLRParser.finallyClause_return finallyClause(  )
+	{
+		ANTLRParser.finallyClause_return retval = new ANTLRParser.finallyClause_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken string_literal77=null;
+		IToken ACTION78=null;
+
+		GrammarAST string_literal77_tree=null;
+		GrammarAST ACTION78_tree=null;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:470:4: ( 'finally' ACTION )
+			// Grammars\\ANTLR.g3:470:4: 'finally' ACTION
+			{
+			root_0 = (GrammarAST)adaptor.Nil();
+
+			string_literal77=(IToken)Match(input,FINALLY,Follow._FINALLY_in_finallyClause1771); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) {
+			string_literal77_tree = (GrammarAST)adaptor.Create(string_literal77);
+			root_0 = (GrammarAST)adaptor.BecomeRoot(string_literal77_tree, root_0);
+			}
+			ACTION78=(IToken)Match(input,ACTION,Follow._ACTION_in_finallyClause1774); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			ACTION78_tree = (GrammarAST)adaptor.Create(ACTION78);
+			adaptor.AddChild(root_0, ACTION78_tree);
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "finallyClause"
+
+	public class element_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "element"
+	// Grammars\\ANTLR.g3:473:0: element : elementNoOptionSpec ;
+	private ANTLRParser.element_return element(  )
+	{
+		ANTLRParser.element_return retval = new ANTLRParser.element_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		ANTLRParser.elementNoOptionSpec_return elementNoOptionSpec79 = default(ANTLRParser.elementNoOptionSpec_return);
+
+
+		try
+		{
+			// Grammars\\ANTLR.g3:474:4: ( elementNoOptionSpec )
+			// Grammars\\ANTLR.g3:474:4: elementNoOptionSpec
+			{
+			root_0 = (GrammarAST)adaptor.Nil();
+
+			PushFollow(Follow._elementNoOptionSpec_in_element1785);
+			elementNoOptionSpec79=elementNoOptionSpec();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, elementNoOptionSpec79.Tree);
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "element"
+
+	public class elementNoOptionSpec_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "elementNoOptionSpec"
+	// Grammars\\ANTLR.g3:477:0: elementNoOptionSpec : ( ( id ( ASSIGN | PLUS_ASSIGN ) ( atom | block ) ) (sub= ebnfSuffix[root_0,false] )? |a= atom (sub2= ebnfSuffix[$a.tree,false] )? | ebnf | FORCED_ACTION | ACTION |p= SEMPRED ( IMPLIES )? |t3= tree_ ) ;
+	private ANTLRParser.elementNoOptionSpec_return elementNoOptionSpec(  )
+	{
+		ANTLRParser.elementNoOptionSpec_return retval = new ANTLRParser.elementNoOptionSpec_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken p=null;
+		IToken ASSIGN81=null;
+		IToken PLUS_ASSIGN82=null;
+		IToken FORCED_ACTION86=null;
+		IToken ACTION87=null;
+		IToken IMPLIES88=null;
+		ANTLRParser.ebnfSuffix_return sub = default(ANTLRParser.ebnfSuffix_return);
+		ANTLRParser.atom_return a = default(ANTLRParser.atom_return);
+		ANTLRParser.ebnfSuffix_return sub2 = default(ANTLRParser.ebnfSuffix_return);
+		ANTLRParser.tree__return t3 = default(ANTLRParser.tree__return);
+		ANTLRParser.id_return id80 = default(ANTLRParser.id_return);
+		ANTLRParser.atom_return atom83 = default(ANTLRParser.atom_return);
+		ANTLRParser.block_return block84 = default(ANTLRParser.block_return);
+		ANTLRParser.ebnf_return ebnf85 = default(ANTLRParser.ebnf_return);
+
+		GrammarAST p_tree=null;
+		GrammarAST ASSIGN81_tree=null;
+		GrammarAST PLUS_ASSIGN82_tree=null;
+		GrammarAST FORCED_ACTION86_tree=null;
+		GrammarAST ACTION87_tree=null;
+		GrammarAST IMPLIES88_tree=null;
+
+
+			IntSet elements=null;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:482:4: ( ( ( id ( ASSIGN | PLUS_ASSIGN ) ( atom | block ) ) (sub= ebnfSuffix[root_0,false] )? |a= atom (sub2= ebnfSuffix[$a.tree,false] )? | ebnf | FORCED_ACTION | ACTION |p= SEMPRED ( IMPLIES )? |t3= tree_ ) )
+			// Grammars\\ANTLR.g3:482:4: ( ( id ( ASSIGN | PLUS_ASSIGN ) ( atom | block ) ) (sub= ebnfSuffix[root_0,false] )? |a= atom (sub2= ebnfSuffix[$a.tree,false] )? | ebnf | FORCED_ACTION | ACTION |p= SEMPRED ( IMPLIES )? |t3= tree_ )
+			{
+			root_0 = (GrammarAST)adaptor.Nil();
+
+			// Grammars\\ANTLR.g3:482:4: ( ( id ( ASSIGN | PLUS_ASSIGN ) ( atom | block ) ) (sub= ebnfSuffix[root_0,false] )? |a= atom (sub2= ebnfSuffix[$a.tree,false] )? | ebnf | FORCED_ACTION | ACTION |p= SEMPRED ( IMPLIES )? |t3= tree_ )
+			int alt49=7;
+			alt49 = dfa49.Predict(input);
+			switch ( alt49 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:482:6: ( id ( ASSIGN | PLUS_ASSIGN ) ( atom | block ) ) (sub= ebnfSuffix[root_0,false] )?
+				{
+				// Grammars\\ANTLR.g3:482:6: ( id ( ASSIGN | PLUS_ASSIGN ) ( atom | block ) )
+				// Grammars\\ANTLR.g3:482:8: id ( ASSIGN | PLUS_ASSIGN ) ( atom | block )
+				{
+				PushFollow(Follow._id_in_elementNoOptionSpec1805);
+				id80=id();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, id80.Tree);
+				// Grammars\\ANTLR.g3:482:11: ( ASSIGN | PLUS_ASSIGN )
+				int alt44=2;
+				int LA44_0 = input.LA(1);
+
+				if ( (LA44_0==ASSIGN) )
+				{
+					alt44=1;
+				}
+				else if ( (LA44_0==PLUS_ASSIGN) )
+				{
+					alt44=2;
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 44, 0, input);
+
+					throw nvae;
+				}
+				switch ( alt44 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:482:12: ASSIGN
+					{
+					ASSIGN81=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_elementNoOptionSpec1808); if (state.failed) return retval;
+					if ( state.backtracking == 0 ) {
+					ASSIGN81_tree = (GrammarAST)adaptor.Create(ASSIGN81);
+					root_0 = (GrammarAST)adaptor.BecomeRoot(ASSIGN81_tree, root_0);
+					}
+
+					}
+					break;
+				case 2:
+					// Grammars\\ANTLR.g3:482:20: PLUS_ASSIGN
+					{
+					PLUS_ASSIGN82=(IToken)Match(input,PLUS_ASSIGN,Follow._PLUS_ASSIGN_in_elementNoOptionSpec1811); if (state.failed) return retval;
+					if ( state.backtracking == 0 ) {
+					PLUS_ASSIGN82_tree = (GrammarAST)adaptor.Create(PLUS_ASSIGN82);
+					root_0 = (GrammarAST)adaptor.BecomeRoot(PLUS_ASSIGN82_tree, root_0);
+					}
+
+					}
+					break;
+
+				}
+
+				// Grammars\\ANTLR.g3:482:34: ( atom | block )
+				int alt45=2;
+				int LA45_0 = input.LA(1);
+
+				if ( (LA45_0==CHAR_LITERAL||LA45_0==NOT||LA45_0==RULE_REF||LA45_0==STRING_LITERAL||LA45_0==TOKEN_REF||LA45_0==WILDCARD) )
+				{
+					alt45=1;
+				}
+				else if ( (LA45_0==LPAREN) )
+				{
+					alt45=2;
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 45, 0, input);
+
+					throw nvae;
+				}
+				switch ( alt45 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:482:35: atom
+					{
+					PushFollow(Follow._atom_in_elementNoOptionSpec1816);
+					atom83=atom();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, atom83.Tree);
+
+					}
+					break;
+				case 2:
+					// Grammars\\ANTLR.g3:482:40: block
+					{
+					PushFollow(Follow._block_in_elementNoOptionSpec1818);
+					block84=block();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, block84.Tree);
+
+					}
+					break;
+
+				}
+
+
+				}
+
+				// Grammars\\ANTLR.g3:484:4: (sub= ebnfSuffix[root_0,false] )?
+				int alt46=2;
+				int LA46_0 = input.LA(1);
+
+				if ( (LA46_0==PLUS||LA46_0==QUESTION||LA46_0==STAR) )
+				{
+					alt46=1;
+				}
+				switch ( alt46 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:484:6: sub= ebnfSuffix[root_0,false]
+					{
+					PushFollow(Follow._ebnfSuffix_in_elementNoOptionSpec1833);
+					sub=ebnfSuffix(root_0, false);
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 )
+					{
+						root_0 = (sub!=null?((GrammarAST)sub.tree):null);
+					}
+
+					}
+					break;
+
+				}
+
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:486:5: a= atom (sub2= ebnfSuffix[$a.tree,false] )?
+				{
+				PushFollow(Follow._atom_in_elementNoOptionSpec1851);
+				a=atom();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, a.Tree);
+				// Grammars\\ANTLR.g3:487:4: (sub2= ebnfSuffix[$a.tree,false] )?
+				int alt47=2;
+				int LA47_0 = input.LA(1);
+
+				if ( (LA47_0==PLUS||LA47_0==QUESTION||LA47_0==STAR) )
+				{
+					alt47=1;
+				}
+				switch ( alt47 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:487:6: sub2= ebnfSuffix[$a.tree,false]
+					{
+					PushFollow(Follow._ebnfSuffix_in_elementNoOptionSpec1860);
+					sub2=ebnfSuffix((a!=null?((GrammarAST)a.tree):null), false);
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 )
+					{
+						root_0=(sub2!=null?((GrammarAST)sub2.tree):null);
+					}
+
+					}
+					break;
+
+				}
+
+
+				}
+				break;
+			case 3:
+				// Grammars\\ANTLR.g3:489:5: ebnf
+				{
+				PushFollow(Follow._ebnf_in_elementNoOptionSpec1876);
+				ebnf85=ebnf();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, ebnf85.Tree);
+
+				}
+				break;
+			case 4:
+				// Grammars\\ANTLR.g3:490:5: FORCED_ACTION
+				{
+				FORCED_ACTION86=(IToken)Match(input,FORCED_ACTION,Follow._FORCED_ACTION_in_elementNoOptionSpec1882); if (state.failed) return retval;
+				if ( state.backtracking==0 ) {
+				FORCED_ACTION86_tree = (GrammarAST)adaptor.Create(FORCED_ACTION86);
+				adaptor.AddChild(root_0, FORCED_ACTION86_tree);
+				}
+
+				}
+				break;
+			case 5:
+				// Grammars\\ANTLR.g3:491:5: ACTION
+				{
+				ACTION87=(IToken)Match(input,ACTION,Follow._ACTION_in_elementNoOptionSpec1888); if (state.failed) return retval;
+				if ( state.backtracking==0 ) {
+				ACTION87_tree = (GrammarAST)adaptor.Create(ACTION87);
+				adaptor.AddChild(root_0, ACTION87_tree);
+				}
+
+				}
+				break;
+			case 6:
+				// Grammars\\ANTLR.g3:492:5: p= SEMPRED ( IMPLIES )?
+				{
+				p=(IToken)Match(input,SEMPRED,Follow._SEMPRED_in_elementNoOptionSpec1896); if (state.failed) return retval;
+				if ( state.backtracking==0 ) {
+				p_tree = (GrammarAST)adaptor.Create(p);
+				adaptor.AddChild(root_0, p_tree);
+				}
+				// Grammars\\ANTLR.g3:492:15: ( IMPLIES )?
+				int alt48=2;
+				int LA48_0 = input.LA(1);
+
+				if ( (LA48_0==IMPLIES) )
+				{
+					alt48=1;
+				}
+				switch ( alt48 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:492:17: IMPLIES
+					{
+					IMPLIES88=(IToken)Match(input,IMPLIES,Follow._IMPLIES_in_elementNoOptionSpec1900); if (state.failed) return retval;
+					if ( state.backtracking == 0 )
+					{
+						p.Type = GATED_SEMPRED;
+					}
+
+					}
+					break;
+
+				}
+
+				if ( state.backtracking == 0 )
+				{
+
+								Grammar.blocksWithSemPreds.Add(currentBlockAST);
+
+				}
+
+				}
+				break;
+			case 7:
+				// Grammars\\ANTLR.g3:496:5: t3= tree_
+				{
+				PushFollow(Follow._tree__in_elementNoOptionSpec1919);
+				t3=tree_();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, t3.Tree);
+
+				}
+				break;
+
+			}
+
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "elementNoOptionSpec"
+
+	public class atom_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "atom"
+	// Grammars\\ANTLR.g3:500:0: atom : ( range ( ROOT | BANG )? | (=> id w= WILDCARD ( terminal | ruleref ) | terminal | ruleref ) | notSet ( ROOT | BANG )? );
+	private ANTLRParser.atom_return atom(  )
+	{
+		ANTLRParser.atom_return retval = new ANTLRParser.atom_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken w=null;
+		IToken ROOT90=null;
+		IToken BANG91=null;
+		IToken ROOT98=null;
+		IToken BANG99=null;
+		ANTLRParser.range_return range89 = default(ANTLRParser.range_return);
+		ANTLRParser.id_return id92 = default(ANTLRParser.id_return);
+		ANTLRParser.terminal_return terminal93 = default(ANTLRParser.terminal_return);
+		ANTLRParser.ruleref_return ruleref94 = default(ANTLRParser.ruleref_return);
+		ANTLRParser.terminal_return terminal95 = default(ANTLRParser.terminal_return);
+		ANTLRParser.ruleref_return ruleref96 = default(ANTLRParser.ruleref_return);
+		ANTLRParser.notSet_return notSet97 = default(ANTLRParser.notSet_return);
+
+		GrammarAST w_tree=null;
+		GrammarAST ROOT90_tree=null;
+		GrammarAST BANG91_tree=null;
+		GrammarAST ROOT98_tree=null;
+		GrammarAST BANG99_tree=null;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:501:4: ( range ( ROOT | BANG )? | (=> id w= WILDCARD ( terminal | ruleref ) | terminal | ruleref ) | notSet ( ROOT | BANG )? )
+			int alt54=3;
+			switch ( input.LA(1) )
+			{
+			case CHAR_LITERAL:
+				{
+				int LA54_1 = input.LA(2);
+
+				if ( (LA54_1==RANGE) )
+				{
+					alt54=1;
+				}
+				else if ( (LA54_1==ACTION||LA54_1==BANG||LA54_1==CHAR_LITERAL||LA54_1==FORCED_ACTION||LA54_1==LPAREN||(LA54_1>=NOT && LA54_1<=OPEN_ELEMENT_OPTION)||LA54_1==OR||LA54_1==PLUS||LA54_1==QUESTION||(LA54_1>=REWRITE && LA54_1<=RPAREN)||LA54_1==RULE_REF||(LA54_1>=SEMI && LA54_1<=SEMPRED)||LA54_1==STAR||LA54_1==STRING_LITERAL||LA54_1==TOKEN_REF||LA54_1==TREE_BEGIN||LA54_1==WILDCARD) )
+				{
+					alt54=2;
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 54, 1, input);
+
+					throw nvae;
+				}
+				}
+				break;
+			case RULE_REF:
+			case STRING_LITERAL:
+			case TOKEN_REF:
+			case WILDCARD:
+				{
+				alt54=2;
+				}
+				break;
+			case NOT:
+				{
+				alt54=3;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 54, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt54 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:501:4: range ( ROOT | BANG )?
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				PushFollow(Follow._range_in_atom1934);
+				range89=range();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, range89.Tree);
+				// Grammars\\ANTLR.g3:501:10: ( ROOT | BANG )?
+				int alt50=3;
+				int LA50_0 = input.LA(1);
+
+				if ( (LA50_0==ROOT) )
+				{
+					alt50=1;
+				}
+				else if ( (LA50_0==BANG) )
+				{
+					alt50=2;
+				}
+				switch ( alt50 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:501:11: ROOT
+					{
+					ROOT90=(IToken)Match(input,ROOT,Follow._ROOT_in_atom1937); if (state.failed) return retval;
+					if ( state.backtracking == 0 ) {
+					ROOT90_tree = (GrammarAST)adaptor.Create(ROOT90);
+					root_0 = (GrammarAST)adaptor.BecomeRoot(ROOT90_tree, root_0);
+					}
+
+					}
+					break;
+				case 2:
+					// Grammars\\ANTLR.g3:501:17: BANG
+					{
+					BANG91=(IToken)Match(input,BANG,Follow._BANG_in_atom1940); if (state.failed) return retval;
+					if ( state.backtracking == 0 ) {
+					BANG91_tree = (GrammarAST)adaptor.Create(BANG91);
+					root_0 = (GrammarAST)adaptor.BecomeRoot(BANG91_tree, root_0);
+					}
+
+					}
+					break;
+
+				}
+
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:502:4: (=> id w= WILDCARD ( terminal | ruleref ) | terminal | ruleref )
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				// Grammars\\ANTLR.g3:502:4: (=> id w= WILDCARD ( terminal | ruleref ) | terminal | ruleref )
+				int alt52=3;
+				alt52 = dfa52.Predict(input);
+				switch ( alt52 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:505:4: => id w= WILDCARD ( terminal | ruleref )
+					{
+
+					PushFollow(Follow._id_in_atom1980);
+					id92=id();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, id92.Tree);
+					w=(IToken)Match(input,WILDCARD,Follow._WILDCARD_in_atom1984); if (state.failed) return retval;
+					if ( state.backtracking == 0 ) {
+					w_tree = (GrammarAST)adaptor.Create(w);
+					root_0 = (GrammarAST)adaptor.BecomeRoot(w_tree, root_0);
+					}
+					// Grammars\\ANTLR.g3:507:19: ( terminal | ruleref )
+					int alt51=2;
+					int LA51_0 = input.LA(1);
+
+					if ( (LA51_0==CHAR_LITERAL||LA51_0==STRING_LITERAL||LA51_0==TOKEN_REF||LA51_0==WILDCARD) )
+					{
+						alt51=1;
+					}
+					else if ( (LA51_0==RULE_REF) )
+					{
+						alt51=2;
+					}
+					else
+					{
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae = new NoViableAltException("", 51, 0, input);
+
+						throw nvae;
+					}
+					switch ( alt51 )
+					{
+					case 1:
+						// Grammars\\ANTLR.g3:507:20: terminal
+						{
+						PushFollow(Follow._terminal_in_atom1988);
+						terminal93=terminal();
+
+						state._fsp--;
+						if (state.failed) return retval;
+						if ( state.backtracking == 0 ) adaptor.AddChild(root_0, terminal93.Tree);
+
+						}
+						break;
+					case 2:
+						// Grammars\\ANTLR.g3:507:29: ruleref
+						{
+						PushFollow(Follow._ruleref_in_atom1990);
+						ruleref94=ruleref();
+
+						state._fsp--;
+						if (state.failed) return retval;
+						if ( state.backtracking == 0 ) adaptor.AddChild(root_0, ruleref94.Tree);
+
+						}
+						break;
+
+					}
+
+					if ( state.backtracking == 0 )
+					{
+						w.Type = DOT;
+					}
+
+					}
+					break;
+				case 2:
+					// Grammars\\ANTLR.g3:508:5: terminal
+					{
+					PushFollow(Follow._terminal_in_atom1999);
+					terminal95=terminal();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, terminal95.Tree);
+
+					}
+					break;
+				case 3:
+					// Grammars\\ANTLR.g3:509:5: ruleref
+					{
+					PushFollow(Follow._ruleref_in_atom2005);
+					ruleref96=ruleref();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, ruleref96.Tree);
+
+					}
+					break;
+
+				}
+
+
+				}
+				break;
+			case 3:
+				// Grammars\\ANTLR.g3:511:4: notSet ( ROOT | BANG )?
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				PushFollow(Follow._notSet_in_atom2014);
+				notSet97=notSet();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, notSet97.Tree);
+				// Grammars\\ANTLR.g3:511:11: ( ROOT | BANG )?
+				int alt53=3;
+				int LA53_0 = input.LA(1);
+
+				if ( (LA53_0==ROOT) )
+				{
+					alt53=1;
+				}
+				else if ( (LA53_0==BANG) )
+				{
+					alt53=2;
+				}
+				switch ( alt53 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:511:12: ROOT
+					{
+					ROOT98=(IToken)Match(input,ROOT,Follow._ROOT_in_atom2017); if (state.failed) return retval;
+					if ( state.backtracking == 0 ) {
+					ROOT98_tree = (GrammarAST)adaptor.Create(ROOT98);
+					root_0 = (GrammarAST)adaptor.BecomeRoot(ROOT98_tree, root_0);
+					}
+
+					}
+					break;
+				case 2:
+					// Grammars\\ANTLR.g3:511:18: BANG
+					{
+					BANG99=(IToken)Match(input,BANG,Follow._BANG_in_atom2020); if (state.failed) return retval;
+					if ( state.backtracking == 0 ) {
+					BANG99_tree = (GrammarAST)adaptor.Create(BANG99);
+					root_0 = (GrammarAST)adaptor.BecomeRoot(BANG99_tree, root_0);
+					}
+
+					}
+					break;
+
+				}
+
+
+				}
+				break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "atom"
+
+	public class ruleref_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "ruleref"
+	// Grammars\\ANTLR.g3:514:0: ruleref : rr= RULE_REF ( ARG_ACTION )? ( ROOT | BANG )? ;
+	private ANTLRParser.ruleref_return ruleref(  )
+	{
+		ANTLRParser.ruleref_return retval = new ANTLRParser.ruleref_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken rr=null;
+		IToken ARG_ACTION100=null;
+		IToken ROOT101=null;
+		IToken BANG102=null;
+
+		GrammarAST rr_tree=null;
+		GrammarAST ARG_ACTION100_tree=null;
+		GrammarAST ROOT101_tree=null;
+		GrammarAST BANG102_tree=null;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:515:4: (rr= RULE_REF ( ARG_ACTION )? ( ROOT | BANG )? )
+			// Grammars\\ANTLR.g3:515:4: rr= RULE_REF ( ARG_ACTION )? ( ROOT | BANG )?
+			{
+			root_0 = (GrammarAST)adaptor.Nil();
+
+			rr=(IToken)Match(input,RULE_REF,Follow._RULE_REF_in_ruleref2036); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) {
+			rr_tree = (GrammarAST)adaptor.Create(rr);
+			root_0 = (GrammarAST)adaptor.BecomeRoot(rr_tree, root_0);
+			}
+			// Grammars\\ANTLR.g3:515:17: ( ARG_ACTION )?
+			int alt55=2;
+			int LA55_0 = input.LA(1);
+
+			if ( (LA55_0==ARG_ACTION) )
+			{
+				alt55=1;
+			}
+			switch ( alt55 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:515:19: ARG_ACTION
+				{
+				ARG_ACTION100=(IToken)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_ruleref2041); if (state.failed) return retval;
+				if ( state.backtracking==0 ) {
+				ARG_ACTION100_tree = (GrammarAST)adaptor.Create(ARG_ACTION100);
+				adaptor.AddChild(root_0, ARG_ACTION100_tree);
+				}
+
+				}
+				break;
+
+			}
+
+			// Grammars\\ANTLR.g3:515:33: ( ROOT | BANG )?
+			int alt56=3;
+			int LA56_0 = input.LA(1);
+
+			if ( (LA56_0==ROOT) )
+			{
+				alt56=1;
+			}
+			else if ( (LA56_0==BANG) )
+			{
+				alt56=2;
+			}
+			switch ( alt56 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:515:34: ROOT
+				{
+				ROOT101=(IToken)Match(input,ROOT,Follow._ROOT_in_ruleref2047); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) {
+				ROOT101_tree = (GrammarAST)adaptor.Create(ROOT101);
+				root_0 = (GrammarAST)adaptor.BecomeRoot(ROOT101_tree, root_0);
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:515:40: BANG
+				{
+				BANG102=(IToken)Match(input,BANG,Follow._BANG_in_ruleref2050); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) {
+				BANG102_tree = (GrammarAST)adaptor.Create(BANG102);
+				root_0 = (GrammarAST)adaptor.BecomeRoot(BANG102_tree, root_0);
+				}
+
+				}
+				break;
+
+			}
+
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "ruleref"
+
+	public class notSet_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "notSet"
+	// Grammars\\ANTLR.g3:518:0: notSet : NOT ( notTerminal | block ) ;
+	private ANTLRParser.notSet_return notSet(  )
+	{
+		ANTLRParser.notSet_return retval = new ANTLRParser.notSet_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken NOT103=null;
+		ANTLRParser.notTerminal_return notTerminal104 = default(ANTLRParser.notTerminal_return);
+		ANTLRParser.block_return block105 = default(ANTLRParser.block_return);
+
+		GrammarAST NOT103_tree=null;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:519:4: ( NOT ( notTerminal | block ) )
+			// Grammars\\ANTLR.g3:519:4: NOT ( notTerminal | block )
+			{
+			root_0 = (GrammarAST)adaptor.Nil();
+
+			NOT103=(IToken)Match(input,NOT,Follow._NOT_in_notSet2064); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) {
+			NOT103_tree = (GrammarAST)adaptor.Create(NOT103);
+			root_0 = (GrammarAST)adaptor.BecomeRoot(NOT103_tree, root_0);
+			}
+			// Grammars\\ANTLR.g3:520:3: ( notTerminal | block )
+			int alt57=2;
+			int LA57_0 = input.LA(1);
+
+			if ( (LA57_0==CHAR_LITERAL||LA57_0==STRING_LITERAL||LA57_0==TOKEN_REF) )
+			{
+				alt57=1;
+			}
+			else if ( (LA57_0==LPAREN) )
+			{
+				alt57=2;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae = new NoViableAltException("", 57, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt57 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:520:5: notTerminal
+				{
+				PushFollow(Follow._notTerminal_in_notSet2071);
+				notTerminal104=notTerminal();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, notTerminal104.Tree);
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:521:5: block
+				{
+				PushFollow(Follow._block_in_notSet2077);
+				block105=block();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, block105.Tree);
+
+				}
+				break;
+
+			}
+
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "notSet"
+
+	public class treeRoot_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "treeRoot"
+	// Grammars\\ANTLR.g3:525:0: treeRoot : ( id ( ASSIGN | PLUS_ASSIGN ) ( atom | block ) | atom | block ) ;
+	private ANTLRParser.treeRoot_return treeRoot(  )
+	{
+		ANTLRParser.treeRoot_return retval = new ANTLRParser.treeRoot_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken ASSIGN107=null;
+		IToken PLUS_ASSIGN108=null;
+		ANTLRParser.id_return id106 = default(ANTLRParser.id_return);
+		ANTLRParser.atom_return atom109 = default(ANTLRParser.atom_return);
+		ANTLRParser.block_return block110 = default(ANTLRParser.block_return);
+		ANTLRParser.atom_return atom111 = default(ANTLRParser.atom_return);
+		ANTLRParser.block_return block112 = default(ANTLRParser.block_return);
+
+		GrammarAST ASSIGN107_tree=null;
+		GrammarAST PLUS_ASSIGN108_tree=null;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:526:4: ( ( id ( ASSIGN | PLUS_ASSIGN ) ( atom | block ) | atom | block ) )
+			// Grammars\\ANTLR.g3:526:4: ( id ( ASSIGN | PLUS_ASSIGN ) ( atom | block ) | atom | block )
+			{
+			root_0 = (GrammarAST)adaptor.Nil();
+
+			if ( state.backtracking == 0 )
+			{
+				atTreeRoot=true;
+			}
+			// Grammars\\ANTLR.g3:527:3: ( id ( ASSIGN | PLUS_ASSIGN ) ( atom | block ) | atom | block )
+			int alt60=3;
+			switch ( input.LA(1) )
+			{
+			case TOKEN_REF:
+				{
+				int LA60_1 = input.LA(2);
+
+				if ( (LA60_1==ASSIGN||LA60_1==PLUS_ASSIGN) )
+				{
+					alt60=1;
+				}
+				else if ( (LA60_1==ACTION||LA60_1==ARG_ACTION||LA60_1==BANG||LA60_1==CHAR_LITERAL||LA60_1==FORCED_ACTION||LA60_1==LPAREN||(LA60_1>=NOT && LA60_1<=OPEN_ELEMENT_OPTION)||LA60_1==ROOT||LA60_1==RULE_REF||LA60_1==SEMPRED||LA60_1==STRING_LITERAL||LA60_1==TOKEN_REF||LA60_1==TREE_BEGIN||LA60_1==WILDCARD) )
+				{
+					alt60=2;
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 60, 1, input);
+
+					throw nvae;
+				}
+				}
+				break;
+			case RULE_REF:
+				{
+				int LA60_2 = input.LA(2);
+
+				if ( (LA60_2==ASSIGN||LA60_2==PLUS_ASSIGN) )
+				{
+					alt60=1;
+				}
+				else if ( (LA60_2==ACTION||LA60_2==ARG_ACTION||LA60_2==BANG||LA60_2==CHAR_LITERAL||LA60_2==FORCED_ACTION||LA60_2==LPAREN||LA60_2==NOT||LA60_2==ROOT||LA60_2==RULE_REF||LA60_2==SEMPRED||LA60_2==STRING_LITERAL||LA60_2==TOKEN_REF||LA60_2==TREE_BEGIN||LA60_2==WILDCARD) )
+				{
+					alt60=2;
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 60, 2, input);
+
+					throw nvae;
+				}
+				}
+				break;
+			case CHAR_LITERAL:
+			case NOT:
+			case STRING_LITERAL:
+			case WILDCARD:
+				{
+				alt60=2;
+				}
+				break;
+			case LPAREN:
+				{
+				alt60=3;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 60, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt60 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:527:5: id ( ASSIGN | PLUS_ASSIGN ) ( atom | block )
+				{
+				PushFollow(Follow._id_in_treeRoot2098);
+				id106=id();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, id106.Tree);
+				// Grammars\\ANTLR.g3:527:8: ( ASSIGN | PLUS_ASSIGN )
+				int alt58=2;
+				int LA58_0 = input.LA(1);
+
+				if ( (LA58_0==ASSIGN) )
+				{
+					alt58=1;
+				}
+				else if ( (LA58_0==PLUS_ASSIGN) )
+				{
+					alt58=2;
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 58, 0, input);
+
+					throw nvae;
+				}
+				switch ( alt58 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:527:9: ASSIGN
+					{
+					ASSIGN107=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_treeRoot2101); if (state.failed) return retval;
+					if ( state.backtracking == 0 ) {
+					ASSIGN107_tree = (GrammarAST)adaptor.Create(ASSIGN107);
+					root_0 = (GrammarAST)adaptor.BecomeRoot(ASSIGN107_tree, root_0);
+					}
+
+					}
+					break;
+				case 2:
+					// Grammars\\ANTLR.g3:527:17: PLUS_ASSIGN
+					{
+					PLUS_ASSIGN108=(IToken)Match(input,PLUS_ASSIGN,Follow._PLUS_ASSIGN_in_treeRoot2104); if (state.failed) return retval;
+					if ( state.backtracking == 0 ) {
+					PLUS_ASSIGN108_tree = (GrammarAST)adaptor.Create(PLUS_ASSIGN108);
+					root_0 = (GrammarAST)adaptor.BecomeRoot(PLUS_ASSIGN108_tree, root_0);
+					}
+
+					}
+					break;
+
+				}
+
+				// Grammars\\ANTLR.g3:527:31: ( atom | block )
+				int alt59=2;
+				int LA59_0 = input.LA(1);
+
+				if ( (LA59_0==CHAR_LITERAL||LA59_0==NOT||LA59_0==RULE_REF||LA59_0==STRING_LITERAL||LA59_0==TOKEN_REF||LA59_0==WILDCARD) )
+				{
+					alt59=1;
+				}
+				else if ( (LA59_0==LPAREN) )
+				{
+					alt59=2;
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 59, 0, input);
+
+					throw nvae;
+				}
+				switch ( alt59 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:527:32: atom
+					{
+					PushFollow(Follow._atom_in_treeRoot2109);
+					atom109=atom();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, atom109.Tree);
+
+					}
+					break;
+				case 2:
+					// Grammars\\ANTLR.g3:527:37: block
+					{
+					PushFollow(Follow._block_in_treeRoot2111);
+					block110=block();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, block110.Tree);
+
+					}
+					break;
+
+				}
+
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:528:5: atom
+				{
+				PushFollow(Follow._atom_in_treeRoot2118);
+				atom111=atom();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, atom111.Tree);
+
+				}
+				break;
+			case 3:
+				// Grammars\\ANTLR.g3:529:5: block
+				{
+				PushFollow(Follow._block_in_treeRoot2124);
+				block112=block();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, block112.Tree);
+
+				}
+				break;
+
+			}
+
+			if ( state.backtracking == 0 )
+			{
+				atTreeRoot=false;
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "treeRoot"
+
+	public class tree__return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "tree_"
+	// Grammars\\ANTLR.g3:534:0: tree_ : TREE_BEGIN treeRoot ( element )+ RPAREN ;
+	private ANTLRParser.tree__return tree_(  )
+	{
+		ANTLRParser.tree__return retval = new ANTLRParser.tree__return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken TREE_BEGIN113=null;
+		IToken RPAREN116=null;
+		ANTLRParser.treeRoot_return treeRoot114 = default(ANTLRParser.treeRoot_return);
+		ANTLRParser.element_return element115 = default(ANTLRParser.element_return);
+
+		GrammarAST TREE_BEGIN113_tree=null;
+		GrammarAST RPAREN116_tree=null;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:535:4: ( TREE_BEGIN treeRoot ( element )+ RPAREN )
+			// Grammars\\ANTLR.g3:535:4: TREE_BEGIN treeRoot ( element )+ RPAREN
+			{
+			root_0 = (GrammarAST)adaptor.Nil();
+
+			TREE_BEGIN113=(IToken)Match(input,TREE_BEGIN,Follow._TREE_BEGIN_in_tree_2143); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) {
+			TREE_BEGIN113_tree = (GrammarAST)adaptor.Create(TREE_BEGIN113);
+			root_0 = (GrammarAST)adaptor.BecomeRoot(TREE_BEGIN113_tree, root_0);
+			}
+			PushFollow(Follow._treeRoot_in_tree_2148);
+			treeRoot114=treeRoot();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, treeRoot114.Tree);
+			// Grammars\\ANTLR.g3:536:12: ( element )+
+			int cnt61=0;
+			for ( ; ; )
+			{
+				int alt61=2;
+				int LA61_0 = input.LA(1);
+
+				if ( (LA61_0==ACTION||LA61_0==CHAR_LITERAL||LA61_0==FORCED_ACTION||LA61_0==LPAREN||LA61_0==NOT||LA61_0==RULE_REF||LA61_0==SEMPRED||LA61_0==STRING_LITERAL||LA61_0==TOKEN_REF||LA61_0==TREE_BEGIN||LA61_0==WILDCARD) )
+				{
+					alt61=1;
+				}
+
+
+				switch ( alt61 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:536:14: element
+					{
+					PushFollow(Follow._element_in_tree_2152);
+					element115=element();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, element115.Tree);
+
+					}
+					break;
+
+				default:
+					if ( cnt61 >= 1 )
+						goto loop61;
+
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					EarlyExitException eee61 = new EarlyExitException( 61, input );
+					throw eee61;
+				}
+				cnt61++;
+			}
+			loop61:
+				;
+
+
+			RPAREN116=(IToken)Match(input,RPAREN,Follow._RPAREN_in_tree_2159); if (state.failed) return retval;
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "tree_"
+
+	public class ebnf_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "ebnf"
+	// Grammars\\ANTLR.g3:541:0: ebnf : block ( QUESTION -> ^( OPTIONAL[$start,\"?\"] block ) | STAR -> ^( CLOSURE[$start,\"*\"] block ) | PLUS -> ^( POSITIVE_CLOSURE[$start,\"+\"] block ) | IMPLIES -> {GrammarType == COMBINED_GRAMMAR && char.IsUpper(currentRuleName[0])}? ^( SYNPRED[$start,\"=>\"] block ) ->| ROOT -> ^( ROOT block ) | BANG -> ^( BANG block ) | -> block ) ;
+	private ANTLRParser.ebnf_return ebnf(  )
+	{
+		ANTLRParser.ebnf_return retval = new ANTLRParser.ebnf_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken QUESTION118=null;
+		IToken STAR119=null;
+		IToken PLUS120=null;
+		IToken IMPLIES121=null;
+		IToken ROOT122=null;
+		IToken BANG123=null;
+		ANTLRParser.block_return block117 = default(ANTLRParser.block_return);
+
+		GrammarAST QUESTION118_tree=null;
+		GrammarAST STAR119_tree=null;
+		GrammarAST PLUS120_tree=null;
+		GrammarAST IMPLIES121_tree=null;
+		GrammarAST ROOT122_tree=null;
+		GrammarAST BANG123_tree=null;
+		RewriteRuleITokenStream stream_QUESTION=new RewriteRuleITokenStream(adaptor,"token QUESTION");
+		RewriteRuleITokenStream stream_STAR=new RewriteRuleITokenStream(adaptor,"token STAR");
+		RewriteRuleITokenStream stream_PLUS=new RewriteRuleITokenStream(adaptor,"token PLUS");
+		RewriteRuleITokenStream stream_IMPLIES=new RewriteRuleITokenStream(adaptor,"token IMPLIES");
+		RewriteRuleITokenStream stream_ROOT=new RewriteRuleITokenStream(adaptor,"token ROOT");
+		RewriteRuleITokenStream stream_BANG=new RewriteRuleITokenStream(adaptor,"token BANG");
+		RewriteRuleSubtreeStream stream_block=new RewriteRuleSubtreeStream(adaptor,"rule block");
+		try
+		{
+			// Grammars\\ANTLR.g3:542:4: ( block ( QUESTION -> ^( OPTIONAL[$start,\"?\"] block ) | STAR -> ^( CLOSURE[$start,\"*\"] block ) | PLUS -> ^( POSITIVE_CLOSURE[$start,\"+\"] block ) | IMPLIES -> {GrammarType == COMBINED_GRAMMAR && char.IsUpper(currentRuleName[0])}? ^( SYNPRED[$start,\"=>\"] block ) ->| ROOT -> ^( ROOT block ) | BANG -> ^( BANG block ) | -> block ) )
+			// Grammars\\ANTLR.g3:542:4: block ( QUESTION -> ^( OPTIONAL[$start,\"?\"] block ) | STAR -> ^( CLOSURE[$start,\"*\"] block ) | PLUS -> ^( POSITIVE_CLOSURE[$start,\"+\"] block ) | IMPLIES -> {GrammarType == COMBINED_GRAMMAR && char.IsUpper(currentRuleName[0])}? ^( SYNPRED[$start,\"=>\"] block ) ->| ROOT -> ^( ROOT block ) | BANG -> ^( BANG block ) | -> block )
+			{
+			PushFollow(Follow._block_in_ebnf2173);
+			block117=block();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_block.Add(block117.Tree);
+			// Grammars\\ANTLR.g3:543:3: ( QUESTION -> ^( OPTIONAL[$start,\"?\"] block ) | STAR -> ^( CLOSURE[$start,\"*\"] block ) | PLUS -> ^( POSITIVE_CLOSURE[$start,\"+\"] block ) | IMPLIES -> {GrammarType == COMBINED_GRAMMAR && char.IsUpper(currentRuleName[0])}? ^( SYNPRED[$start,\"=>\"] block ) ->| ROOT -> ^( ROOT block ) | BANG -> ^( BANG block ) | -> block )
+			int alt62=7;
+			switch ( input.LA(1) )
+			{
+			case QUESTION:
+				{
+				alt62=1;
+				}
+				break;
+			case STAR:
+				{
+				alt62=2;
+				}
+				break;
+			case PLUS:
+				{
+				alt62=3;
+				}
+				break;
+			case IMPLIES:
+				{
+				alt62=4;
+				}
+				break;
+			case ROOT:
+				{
+				alt62=5;
+				}
+				break;
+			case BANG:
+				{
+				alt62=6;
+				}
+				break;
+			case ACTION:
+			case CHAR_LITERAL:
+			case FORCED_ACTION:
+			case LPAREN:
+			case NOT:
+			case OR:
+			case REWRITE:
+			case RPAREN:
+			case RULE_REF:
+			case SEMI:
+			case SEMPRED:
+			case STRING_LITERAL:
+			case TOKEN_REF:
+			case TREE_BEGIN:
+			case WILDCARD:
+				{
+				alt62=7;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 62, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt62 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:543:5: QUESTION
+				{
+				QUESTION118=(IToken)Match(input,QUESTION,Follow._QUESTION_in_ebnf2179); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_QUESTION.Add(QUESTION118);
+
+
+
+				{
+				// AST REWRITE
+				// elements: block
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 544:4: -> ^( OPTIONAL[$start,\"?\"] block )
+				{
+					// Grammars\\ANTLR.g3:544:7: ^( OPTIONAL[$start,\"?\"] block )
+					{
+					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(OPTIONAL, ((IToken)retval.start), "?"), root_1);
+
+					adaptor.AddChild(root_1, stream_block.NextTree());
+
+					adaptor.AddChild(root_0, root_1);
+					}
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:545:5: STAR
+				{
+				STAR119=(IToken)Match(input,STAR,Follow._STAR_in_ebnf2197); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_STAR.Add(STAR119);
+
+
+
+				{
+				// AST REWRITE
+				// elements: block
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 546:4: -> ^( CLOSURE[$start,\"*\"] block )
+				{
+					// Grammars\\ANTLR.g3:546:7: ^( CLOSURE[$start,\"*\"] block )
+					{
+					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(CLOSURE, ((IToken)retval.start), "*"), root_1);
+
+					adaptor.AddChild(root_1, stream_block.NextTree());
+
+					adaptor.AddChild(root_0, root_1);
+					}
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 3:
+				// Grammars\\ANTLR.g3:547:5: PLUS
+				{
+				PLUS120=(IToken)Match(input,PLUS,Follow._PLUS_in_ebnf2215); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_PLUS.Add(PLUS120);
+
+
+
+				{
+				// AST REWRITE
+				// elements: block
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 548:4: -> ^( POSITIVE_CLOSURE[$start,\"+\"] block )
+				{
+					// Grammars\\ANTLR.g3:548:7: ^( POSITIVE_CLOSURE[$start,\"+\"] block )
+					{
+					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(POSITIVE_CLOSURE, ((IToken)retval.start), "+"), root_1);
+
+					adaptor.AddChild(root_1, stream_block.NextTree());
+
+					adaptor.AddChild(root_0, root_1);
+					}
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 4:
+				// Grammars\\ANTLR.g3:549:5: IMPLIES
+				{
+				IMPLIES121=(IToken)Match(input,IMPLIES,Follow._IMPLIES_in_ebnf2233); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_IMPLIES.Add(IMPLIES121);
+
+
+
+				{
+				// AST REWRITE
+				// elements: block
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 551:4: -> {GrammarType == COMBINED_GRAMMAR && char.IsUpper(currentRuleName[0])}? ^( SYNPRED[$start,\"=>\"] block )
+				if (GrammarType == COMBINED_GRAMMAR && char.IsUpper(currentRuleName[0]))
+				{
+					// Grammars\\ANTLR.g3:551:78: ^( SYNPRED[$start,\"=>\"] block )
+					{
+					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(SYNPRED, ((IToken)retval.start), "=>"), root_1);
+
+					adaptor.AddChild(root_1, stream_block.NextTree());
+
+					adaptor.AddChild(root_0, root_1);
+					}
+
+				}
+				else // 553:4: ->
+				{
+					adaptor.AddChild(root_0, createSynSemPredFromBlock((block117!=null?((GrammarAST)block117.tree):null), SYN_SEMPRED));
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 5:
+				// Grammars\\ANTLR.g3:554:5: ROOT
+				{
+				ROOT122=(IToken)Match(input,ROOT,Follow._ROOT_in_ebnf2269); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_ROOT.Add(ROOT122);
+
+
+
+				{
+				// AST REWRITE
+				// elements: ROOT, block
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 555:4: -> ^( ROOT block )
+				{
+					// Grammars\\ANTLR.g3:555:7: ^( ROOT block )
+					{
+					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+					root_1 = (GrammarAST)adaptor.BecomeRoot(stream_ROOT.NextNode(), root_1);
+
+					adaptor.AddChild(root_1, stream_block.NextTree());
+
+					adaptor.AddChild(root_0, root_1);
+					}
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 6:
+				// Grammars\\ANTLR.g3:556:5: BANG
+				{
+				BANG123=(IToken)Match(input,BANG,Follow._BANG_in_ebnf2286); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_BANG.Add(BANG123);
+
+
+
+				{
+				// AST REWRITE
+				// elements: BANG, block
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 557:4: -> ^( BANG block )
+				{
+					// Grammars\\ANTLR.g3:557:7: ^( BANG block )
+					{
+					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+					root_1 = (GrammarAST)adaptor.BecomeRoot(stream_BANG.NextNode(), root_1);
+
+					adaptor.AddChild(root_1, stream_block.NextTree());
+
+					adaptor.AddChild(root_0, root_1);
+					}
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 7:
+				// Grammars\\ANTLR.g3:559:4:
+				{
+
+
+
+				{
+				// AST REWRITE
+				// elements: block
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 559:4: -> block
+				{
+					adaptor.AddChild(root_0, stream_block.NextTree());
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+
+			}
+
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "ebnf"
+
+	public class range_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "range"
+	// Grammars\\ANTLR.g3:563:0: range : c1= CHAR_LITERAL RANGE c2= CHAR_LITERAL -> ^( CHAR_RANGE[$c1,\"..\"] $c1 $c2) ;
+	private ANTLRParser.range_return range(  )
+	{
+		ANTLRParser.range_return retval = new ANTLRParser.range_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken c1=null;
+		IToken c2=null;
+		IToken RANGE124=null;
+
+		GrammarAST c1_tree=null;
+		GrammarAST c2_tree=null;
+		GrammarAST RANGE124_tree=null;
+		RewriteRuleITokenStream stream_CHAR_LITERAL=new RewriteRuleITokenStream(adaptor,"token CHAR_LITERAL");
+		RewriteRuleITokenStream stream_RANGE=new RewriteRuleITokenStream(adaptor,"token RANGE");
+
+		try
+		{
+			// Grammars\\ANTLR.g3:564:4: (c1= CHAR_LITERAL RANGE c2= CHAR_LITERAL -> ^( CHAR_RANGE[$c1,\"..\"] $c1 $c2) )
+			// Grammars\\ANTLR.g3:564:4: c1= CHAR_LITERAL RANGE c2= CHAR_LITERAL
+			{
+			c1=(IToken)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_range2325); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_CHAR_LITERAL.Add(c1);
+
+			RANGE124=(IToken)Match(input,RANGE,Follow._RANGE_in_range2327); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_RANGE.Add(RANGE124);
+
+			c2=(IToken)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_range2331); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_CHAR_LITERAL.Add(c2);
+
+
+
+			{
+			// AST REWRITE
+			// elements: c1, c2
+			// token labels: c1, c2
+			// rule labels: retval
+			// token list labels:
+			// rule list labels:
+			// wildcard labels:
+			if ( state.backtracking == 0 ) {
+			retval.tree = root_0;
+			RewriteRuleITokenStream stream_c1=new RewriteRuleITokenStream(adaptor,"token c1",c1);
+			RewriteRuleITokenStream stream_c2=new RewriteRuleITokenStream(adaptor,"token c2",c2);
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+			root_0 = (GrammarAST)adaptor.Nil();
+			// 565:3: -> ^( CHAR_RANGE[$c1,\"..\"] $c1 $c2)
+			{
+				// Grammars\\ANTLR.g3:565:6: ^( CHAR_RANGE[$c1,\"..\"] $c1 $c2)
+				{
+				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+				root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(CHAR_RANGE, c1, ".."), root_1);
+
+				adaptor.AddChild(root_1, stream_c1.NextNode());
+				adaptor.AddChild(root_1, stream_c2.NextNode());
+
+				adaptor.AddChild(root_0, root_1);
+				}
+
+			}
+
+			retval.tree = root_0;
+			}
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "range"
+
+	public class terminal_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "terminal"
+	// Grammars\\ANTLR.g3:568:0: terminal : (cl= CHAR_LITERAL ( elementOptions[$cl.tree] )? ( ROOT | BANG )? |tr= TOKEN_REF ( elementOptions[$tr.tree] )? ( ARG_ACTION )? ( ROOT | BANG )? |sl= STRING_LITERAL ( elementOptions[$sl.tree] )? ( ROOT | BANG )? |wi= WILDCARD ( ROOT | BANG )? );
+	private ANTLRParser.terminal_return terminal(  )
+	{
+		ANTLRParser.terminal_return retval = new ANTLRParser.terminal_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken cl=null;
+		IToken tr=null;
+		IToken sl=null;
+		IToken wi=null;
+		IToken ROOT126=null;
+		IToken BANG127=null;
+		IToken ARG_ACTION129=null;
+		IToken ROOT130=null;
+		IToken BANG131=null;
+		IToken ROOT133=null;
+		IToken BANG134=null;
+		IToken ROOT135=null;
+		IToken BANG136=null;
+		ANTLRParser.elementOptions_return elementOptions125 = default(ANTLRParser.elementOptions_return);
+		ANTLRParser.elementOptions_return elementOptions128 = default(ANTLRParser.elementOptions_return);
+		ANTLRParser.elementOptions_return elementOptions132 = default(ANTLRParser.elementOptions_return);
+
+		GrammarAST cl_tree=null;
+		GrammarAST tr_tree=null;
+		GrammarAST sl_tree=null;
+		GrammarAST wi_tree=null;
+		GrammarAST ROOT126_tree=null;
+		GrammarAST BANG127_tree=null;
+		GrammarAST ARG_ACTION129_tree=null;
+		GrammarAST ROOT130_tree=null;
+		GrammarAST BANG131_tree=null;
+		GrammarAST ROOT133_tree=null;
+		GrammarAST BANG134_tree=null;
+		GrammarAST ROOT135_tree=null;
+		GrammarAST BANG136_tree=null;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:569:4: (cl= CHAR_LITERAL ( elementOptions[$cl.tree] )? ( ROOT | BANG )? |tr= TOKEN_REF ( elementOptions[$tr.tree] )? ( ARG_ACTION )? ( ROOT | BANG )? |sl= STRING_LITERAL ( elementOptions[$sl.tree] )? ( ROOT | BANG )? |wi= WILDCARD ( ROOT | BANG )? )
+			int alt71=4;
+			switch ( input.LA(1) )
+			{
+			case CHAR_LITERAL:
+				{
+				alt71=1;
+				}
+				break;
+			case TOKEN_REF:
+				{
+				alt71=2;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt71=3;
+				}
+				break;
+			case WILDCARD:
+				{
+				alt71=4;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 71, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt71 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:569:4: cl= CHAR_LITERAL ( elementOptions[$cl.tree] )? ( ROOT | BANG )?
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				cl=(IToken)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_terminal2359); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) {
+				cl_tree = (GrammarAST)adaptor.Create(cl);
+				root_0 = (GrammarAST)adaptor.BecomeRoot(cl_tree, root_0);
+				}
+				// Grammars\\ANTLR.g3:569:21: ( elementOptions[$cl.tree] )?
+				int alt63=2;
+				int LA63_0 = input.LA(1);
+
+				if ( (LA63_0==OPEN_ELEMENT_OPTION) )
+				{
+					alt63=1;
+				}
+				switch ( alt63 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:569:23: elementOptions[$cl.tree]
+					{
+					PushFollow(Follow._elementOptions_in_terminal2364);
+					elementOptions125=elementOptions(cl_tree);
+
+					state._fsp--;
+					if (state.failed) return retval;
+
+					}
+					break;
+
+				}
+
+				// Grammars\\ANTLR.g3:569:52: ( ROOT | BANG )?
+				int alt64=3;
+				int LA64_0 = input.LA(1);
+
+				if ( (LA64_0==ROOT) )
+				{
+					alt64=1;
+				}
+				else if ( (LA64_0==BANG) )
+				{
+					alt64=2;
+				}
+				switch ( alt64 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:569:53: ROOT
+					{
+					ROOT126=(IToken)Match(input,ROOT,Follow._ROOT_in_terminal2372); if (state.failed) return retval;
+					if ( state.backtracking == 0 ) {
+					ROOT126_tree = (GrammarAST)adaptor.Create(ROOT126);
+					root_0 = (GrammarAST)adaptor.BecomeRoot(ROOT126_tree, root_0);
+					}
+
+					}
+					break;
+				case 2:
+					// Grammars\\ANTLR.g3:569:59: BANG
+					{
+					BANG127=(IToken)Match(input,BANG,Follow._BANG_in_terminal2375); if (state.failed) return retval;
+					if ( state.backtracking == 0 ) {
+					BANG127_tree = (GrammarAST)adaptor.Create(BANG127);
+					root_0 = (GrammarAST)adaptor.BecomeRoot(BANG127_tree, root_0);
+					}
+
+					}
+					break;
+
+				}
+
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:571:4: tr= TOKEN_REF ( elementOptions[$tr.tree] )? ( ARG_ACTION )? ( ROOT | BANG )?
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				tr=(IToken)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_terminal2386); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) {
+				tr_tree = (GrammarAST)adaptor.Create(tr);
+				root_0 = (GrammarAST)adaptor.BecomeRoot(tr_tree, root_0);
+				}
+				// Grammars\\ANTLR.g3:572:3: ( elementOptions[$tr.tree] )?
+				int alt65=2;
+				int LA65_0 = input.LA(1);
+
+				if ( (LA65_0==OPEN_ELEMENT_OPTION) )
+				{
+					alt65=1;
+				}
+				switch ( alt65 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:572:5: elementOptions[$tr.tree]
+					{
+					PushFollow(Follow._elementOptions_in_terminal2393);
+					elementOptions128=elementOptions(tr_tree);
+
+					state._fsp--;
+					if (state.failed) return retval;
+
+					}
+					break;
+
+				}
+
+				// Grammars\\ANTLR.g3:573:3: ( ARG_ACTION )?
+				int alt66=2;
+				int LA66_0 = input.LA(1);
+
+				if ( (LA66_0==ARG_ACTION) )
+				{
+					alt66=1;
+				}
+				switch ( alt66 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:573:5: ARG_ACTION
+					{
+					ARG_ACTION129=(IToken)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_terminal2404); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					ARG_ACTION129_tree = (GrammarAST)adaptor.Create(ARG_ACTION129);
+					adaptor.AddChild(root_0, ARG_ACTION129_tree);
+					}
+
+					}
+					break;
+
+				}
+
+				// Grammars\\ANTLR.g3:574:3: ( ROOT | BANG )?
+				int alt67=3;
+				int LA67_0 = input.LA(1);
+
+				if ( (LA67_0==ROOT) )
+				{
+					alt67=1;
+				}
+				else if ( (LA67_0==BANG) )
+				{
+					alt67=2;
+				}
+				switch ( alt67 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:574:4: ROOT
+					{
+					ROOT130=(IToken)Match(input,ROOT,Follow._ROOT_in_terminal2413); if (state.failed) return retval;
+					if ( state.backtracking == 0 ) {
+					ROOT130_tree = (GrammarAST)adaptor.Create(ROOT130);
+					root_0 = (GrammarAST)adaptor.BecomeRoot(ROOT130_tree, root_0);
+					}
+
+					}
+					break;
+				case 2:
+					// Grammars\\ANTLR.g3:574:10: BANG
+					{
+					BANG131=(IToken)Match(input,BANG,Follow._BANG_in_terminal2416); if (state.failed) return retval;
+					if ( state.backtracking == 0 ) {
+					BANG131_tree = (GrammarAST)adaptor.Create(BANG131);
+					root_0 = (GrammarAST)adaptor.BecomeRoot(BANG131_tree, root_0);
+					}
+
+					}
+					break;
+
+				}
+
+
+				}
+				break;
+			case 3:
+				// Grammars\\ANTLR.g3:576:4: sl= STRING_LITERAL ( elementOptions[$sl.tree] )? ( ROOT | BANG )?
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				sl=(IToken)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_terminal2427); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) {
+				sl_tree = (GrammarAST)adaptor.Create(sl);
+				root_0 = (GrammarAST)adaptor.BecomeRoot(sl_tree, root_0);
+				}
+				// Grammars\\ANTLR.g3:576:23: ( elementOptions[$sl.tree] )?
+				int alt68=2;
+				int LA68_0 = input.LA(1);
+
+				if ( (LA68_0==OPEN_ELEMENT_OPTION) )
+				{
+					alt68=1;
+				}
+				switch ( alt68 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:576:25: elementOptions[$sl.tree]
+					{
+					PushFollow(Follow._elementOptions_in_terminal2432);
+					elementOptions132=elementOptions(sl_tree);
+
+					state._fsp--;
+					if (state.failed) return retval;
+
+					}
+					break;
+
+				}
+
+				// Grammars\\ANTLR.g3:576:54: ( ROOT | BANG )?
+				int alt69=3;
+				int LA69_0 = input.LA(1);
+
+				if ( (LA69_0==ROOT) )
+				{
+					alt69=1;
+				}
+				else if ( (LA69_0==BANG) )
+				{
+					alt69=2;
+				}
+				switch ( alt69 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:576:55: ROOT
+					{
+					ROOT133=(IToken)Match(input,ROOT,Follow._ROOT_in_terminal2440); if (state.failed) return retval;
+					if ( state.backtracking == 0 ) {
+					ROOT133_tree = (GrammarAST)adaptor.Create(ROOT133);
+					root_0 = (GrammarAST)adaptor.BecomeRoot(ROOT133_tree, root_0);
+					}
+
+					}
+					break;
+				case 2:
+					// Grammars\\ANTLR.g3:576:61: BANG
+					{
+					BANG134=(IToken)Match(input,BANG,Follow._BANG_in_terminal2443); if (state.failed) return retval;
+					if ( state.backtracking == 0 ) {
+					BANG134_tree = (GrammarAST)adaptor.Create(BANG134);
+					root_0 = (GrammarAST)adaptor.BecomeRoot(BANG134_tree, root_0);
+					}
+
+					}
+					break;
+
+				}
+
+
+				}
+				break;
+			case 4:
+				// Grammars\\ANTLR.g3:578:4: wi= WILDCARD ( ROOT | BANG )?
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				wi=(IToken)Match(input,WILDCARD,Follow._WILDCARD_in_terminal2454); if (state.failed) return retval;
+				if ( state.backtracking==0 ) {
+				wi_tree = (GrammarAST)adaptor.Create(wi);
+				adaptor.AddChild(root_0, wi_tree);
+				}
+				// Grammars\\ANTLR.g3:578:16: ( ROOT | BANG )?
+				int alt70=3;
+				int LA70_0 = input.LA(1);
+
+				if ( (LA70_0==ROOT) )
+				{
+					alt70=1;
+				}
+				else if ( (LA70_0==BANG) )
+				{
+					alt70=2;
+				}
+				switch ( alt70 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:578:17: ROOT
+					{
+					ROOT135=(IToken)Match(input,ROOT,Follow._ROOT_in_terminal2457); if (state.failed) return retval;
+					if ( state.backtracking == 0 ) {
+					ROOT135_tree = (GrammarAST)adaptor.Create(ROOT135);
+					root_0 = (GrammarAST)adaptor.BecomeRoot(ROOT135_tree, root_0);
+					}
+
+					}
+					break;
+				case 2:
+					// Grammars\\ANTLR.g3:578:23: BANG
+					{
+					BANG136=(IToken)Match(input,BANG,Follow._BANG_in_terminal2460); if (state.failed) return retval;
+					if ( state.backtracking == 0 ) {
+					BANG136_tree = (GrammarAST)adaptor.Create(BANG136);
+					root_0 = (GrammarAST)adaptor.BecomeRoot(BANG136_tree, root_0);
+					}
+
+					}
+					break;
+
+				}
+
+				if ( state.backtracking == 0 )
+				{
+
+								if ( atTreeRoot )
+								{
+									ErrorManager.syntaxError(
+										ErrorManager.MSG_WILDCARD_AS_ROOT,Grammar,wi,null,null);
+								}
+
+				}
+
+				}
+				break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "terminal"
+
+	public class elementOptions_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "elementOptions"
+	// Grammars\\ANTLR.g3:588:0: elementOptions[GrammarAST terminalAST] : ( OPEN_ELEMENT_OPTION defaultNodeOption[terminalAST] CLOSE_ELEMENT_OPTION | OPEN_ELEMENT_OPTION elementOption[terminalAST] ( SEMI elementOption[terminalAST] )* CLOSE_ELEMENT_OPTION );
+	private ANTLRParser.elementOptions_return elementOptions( GrammarAST terminalAST )
+	{
+		ANTLRParser.elementOptions_return retval = new ANTLRParser.elementOptions_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken OPEN_ELEMENT_OPTION137=null;
+		IToken CLOSE_ELEMENT_OPTION139=null;
+		IToken OPEN_ELEMENT_OPTION140=null;
+		IToken SEMI142=null;
+		IToken CLOSE_ELEMENT_OPTION144=null;
+		ANTLRParser.defaultNodeOption_return defaultNodeOption138 = default(ANTLRParser.defaultNodeOption_return);
+		ANTLRParser.elementOption_return elementOption141 = default(ANTLRParser.elementOption_return);
+		ANTLRParser.elementOption_return elementOption143 = default(ANTLRParser.elementOption_return);
+
+		GrammarAST OPEN_ELEMENT_OPTION137_tree=null;
+		GrammarAST CLOSE_ELEMENT_OPTION139_tree=null;
+		GrammarAST OPEN_ELEMENT_OPTION140_tree=null;
+		GrammarAST SEMI142_tree=null;
+		GrammarAST CLOSE_ELEMENT_OPTION144_tree=null;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:589:4: ( OPEN_ELEMENT_OPTION defaultNodeOption[terminalAST] CLOSE_ELEMENT_OPTION | OPEN_ELEMENT_OPTION elementOption[terminalAST] ( SEMI elementOption[terminalAST] )* CLOSE_ELEMENT_OPTION )
+			int alt73=2;
+			int LA73_0 = input.LA(1);
+
+			if ( (LA73_0==OPEN_ELEMENT_OPTION) )
+			{
+				int LA73_1 = input.LA(2);
+
+				if ( (LA73_1==TOKEN_REF) )
+				{
+					int LA73_2 = input.LA(3);
+
+					if ( (LA73_2==CLOSE_ELEMENT_OPTION||LA73_2==WILDCARD) )
+					{
+						alt73=1;
+					}
+					else if ( (LA73_2==ASSIGN) )
+					{
+						alt73=2;
+					}
+					else
+					{
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae = new NoViableAltException("", 73, 2, input);
+
+						throw nvae;
+					}
+				}
+				else if ( (LA73_1==RULE_REF) )
+				{
+					int LA73_3 = input.LA(3);
+
+					if ( (LA73_3==CLOSE_ELEMENT_OPTION||LA73_3==WILDCARD) )
+					{
+						alt73=1;
+					}
+					else if ( (LA73_3==ASSIGN) )
+					{
+						alt73=2;
+					}
+					else
+					{
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae = new NoViableAltException("", 73, 3, input);
+
+						throw nvae;
+					}
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 73, 1, input);
+
+					throw nvae;
+				}
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae = new NoViableAltException("", 73, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt73 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:589:4: OPEN_ELEMENT_OPTION defaultNodeOption[terminalAST] CLOSE_ELEMENT_OPTION
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				OPEN_ELEMENT_OPTION137=(IToken)Match(input,OPEN_ELEMENT_OPTION,Follow._OPEN_ELEMENT_OPTION_in_elementOptions2479); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) {
+				OPEN_ELEMENT_OPTION137_tree = (GrammarAST)adaptor.Create(OPEN_ELEMENT_OPTION137);
+				root_0 = (GrammarAST)adaptor.BecomeRoot(OPEN_ELEMENT_OPTION137_tree, root_0);
+				}
+				PushFollow(Follow._defaultNodeOption_in_elementOptions2482);
+				defaultNodeOption138=defaultNodeOption(terminalAST);
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, defaultNodeOption138.Tree);
+				CLOSE_ELEMENT_OPTION139=(IToken)Match(input,CLOSE_ELEMENT_OPTION,Follow._CLOSE_ELEMENT_OPTION_in_elementOptions2485); if (state.failed) return retval;
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:590:4: OPEN_ELEMENT_OPTION elementOption[terminalAST] ( SEMI elementOption[terminalAST] )* CLOSE_ELEMENT_OPTION
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				OPEN_ELEMENT_OPTION140=(IToken)Match(input,OPEN_ELEMENT_OPTION,Follow._OPEN_ELEMENT_OPTION_in_elementOptions2491); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) {
+				OPEN_ELEMENT_OPTION140_tree = (GrammarAST)adaptor.Create(OPEN_ELEMENT_OPTION140);
+				root_0 = (GrammarAST)adaptor.BecomeRoot(OPEN_ELEMENT_OPTION140_tree, root_0);
+				}
+				PushFollow(Follow._elementOption_in_elementOptions2494);
+				elementOption141=elementOption(terminalAST);
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, elementOption141.Tree);
+				// Grammars\\ANTLR.g3:590:52: ( SEMI elementOption[terminalAST] )*
+				for ( ; ; )
+				{
+					int alt72=2;
+					int LA72_0 = input.LA(1);
+
+					if ( (LA72_0==SEMI) )
+					{
+						alt72=1;
+					}
+
+
+					switch ( alt72 )
+					{
+					case 1:
+						// Grammars\\ANTLR.g3:590:53: SEMI elementOption[terminalAST]
+						{
+						SEMI142=(IToken)Match(input,SEMI,Follow._SEMI_in_elementOptions2498); if (state.failed) return retval;
+						PushFollow(Follow._elementOption_in_elementOptions2501);
+						elementOption143=elementOption(terminalAST);
+
+						state._fsp--;
+						if (state.failed) return retval;
+						if ( state.backtracking == 0 ) adaptor.AddChild(root_0, elementOption143.Tree);
+
+						}
+						break;
+
+					default:
+						goto loop72;
+					}
+				}
+
+				loop72:
+					;
+
+
+				CLOSE_ELEMENT_OPTION144=(IToken)Match(input,CLOSE_ELEMENT_OPTION,Follow._CLOSE_ELEMENT_OPTION_in_elementOptions2506); if (state.failed) return retval;
+
+				}
+				break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "elementOptions"
+
+	public class defaultNodeOption_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "defaultNodeOption"
+	// Grammars\\ANTLR.g3:593:0: defaultNodeOption[GrammarAST terminalAST] : i= id ( WILDCARD i2= id )* ;
+	private ANTLRParser.defaultNodeOption_return defaultNodeOption( GrammarAST terminalAST )
+	{
+		ANTLRParser.defaultNodeOption_return retval = new ANTLRParser.defaultNodeOption_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken WILDCARD145=null;
+		ANTLRParser.id_return i = default(ANTLRParser.id_return);
+		ANTLRParser.id_return i2 = default(ANTLRParser.id_return);
+
+		GrammarAST WILDCARD145_tree=null;
+
+
+		StringBuffer buf = new StringBuffer();
+
+		try
+		{
+			// Grammars\\ANTLR.g3:598:4: (i= id ( WILDCARD i2= id )* )
+			// Grammars\\ANTLR.g3:598:4: i= id ( WILDCARD i2= id )*
+			{
+			root_0 = (GrammarAST)adaptor.Nil();
+
+			PushFollow(Follow._id_in_defaultNodeOption2526);
+			i=id();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, i.Tree);
+			if ( state.backtracking == 0 )
+			{
+				buf.Append((i!=null?input.ToString(i.start,i.stop):null));
+			}
+			// Grammars\\ANTLR.g3:598:32: ( WILDCARD i2= id )*
+			for ( ; ; )
+			{
+				int alt74=2;
+				int LA74_0 = input.LA(1);
+
+				if ( (LA74_0==WILDCARD) )
+				{
+					alt74=1;
+				}
+
+
+				switch ( alt74 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:598:33: WILDCARD i2= id
+					{
+					WILDCARD145=(IToken)Match(input,WILDCARD,Follow._WILDCARD_in_defaultNodeOption2531); if (state.failed) return retval;
+					if ( state.backtracking==0 ) {
+					WILDCARD145_tree = (GrammarAST)adaptor.Create(WILDCARD145);
+					adaptor.AddChild(root_0, WILDCARD145_tree);
+					}
+					PushFollow(Follow._id_in_defaultNodeOption2535);
+					i2=id();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, i2.Tree);
+					if ( state.backtracking == 0 )
+					{
+						buf.Append("."+(i2!=null?input.ToString(i2.start,i2.stop):null));
+					}
+
+					}
+					break;
+
+				default:
+					goto loop74;
+				}
+			}
+
+			loop74:
+				;
+
+
+			if ( state.backtracking == 0 )
+			{
+				terminalAST.setTerminalOption(Grammar,Grammar.defaultTokenOption,buf.ToString());
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "defaultNodeOption"
+
+	public class elementOption_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "elementOption"
+	// Grammars\\ANTLR.g3:602:0: elementOption[GrammarAST terminalAST] : a= id ASSIGN (b= id |s= STRING_LITERAL ) ;
+	private ANTLRParser.elementOption_return elementOption( GrammarAST terminalAST )
+	{
+		ANTLRParser.elementOption_return retval = new ANTLRParser.elementOption_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken s=null;
+		IToken ASSIGN146=null;
+		ANTLRParser.id_return a = default(ANTLRParser.id_return);
+		ANTLRParser.id_return b = default(ANTLRParser.id_return);
+
+		GrammarAST s_tree=null;
+		GrammarAST ASSIGN146_tree=null;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:603:4: (a= id ASSIGN (b= id |s= STRING_LITERAL ) )
+			// Grammars\\ANTLR.g3:603:4: a= id ASSIGN (b= id |s= STRING_LITERAL )
+			{
+			root_0 = (GrammarAST)adaptor.Nil();
+
+			PushFollow(Follow._id_in_elementOption2557);
+			a=id();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, a.Tree);
+			ASSIGN146=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_elementOption2559); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) {
+			ASSIGN146_tree = (GrammarAST)adaptor.Create(ASSIGN146);
+			root_0 = (GrammarAST)adaptor.BecomeRoot(ASSIGN146_tree, root_0);
+			}
+			// Grammars\\ANTLR.g3:603:17: (b= id |s= STRING_LITERAL )
+			int alt75=2;
+			int LA75_0 = input.LA(1);
+
+			if ( (LA75_0==RULE_REF||LA75_0==TOKEN_REF) )
+			{
+				alt75=1;
+			}
+			else if ( (LA75_0==STRING_LITERAL) )
+			{
+				alt75=2;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae = new NoViableAltException("", 75, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt75 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:603:18: b= id
+				{
+				PushFollow(Follow._id_in_elementOption2565);
+				b=id();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, b.Tree);
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:603:23: s= STRING_LITERAL
+				{
+				s=(IToken)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_elementOption2569); if (state.failed) return retval;
+				if ( state.backtracking==0 ) {
+				s_tree = (GrammarAST)adaptor.Create(s);
+				adaptor.AddChild(root_0, s_tree);
+				}
+
+				}
+				break;
+
+			}
+
+			if ( state.backtracking == 0 )
+			{
+
+						object v = ((b!=null?((GrammarAST)b.tree):null)!=null)?(b!=null?input.ToString(b.start,b.stop):null):(s!=null?s.Text:null);
+						terminalAST.setTerminalOption(Grammar,(a!=null?input.ToString(a.start,a.stop):null),v);
+
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "elementOption"
+
+	public class ebnfSuffix_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "ebnfSuffix"
+	// Grammars\\ANTLR.g3:610:0: ebnfSuffix[GrammarAST elemAST, bool inRewrite] : ( -> BLOCK[\"BLOCK\"] ) ( -> ^( ALT[\"ALT\"] EOA[\"<end-of-alt>\"] ) ) ( QUESTION -> OPTIONAL[$elemAST.Token,\"?\"] | STAR -> CLOSURE[$elemAST.Token,\"*\"] | PLUS -> POSITIVE_CLOSURE[$elemAST.Token,\"+\"] ) -> ^( $ebnfSuffix ^( EOB[$elemAST.Token, \"<end-of-block>\"] ) ) ;
+	private ANTLRParser.ebnfSuffix_return ebnfSuffix( GrammarAST elemAST, bool inRewrite )
+	{
+		ANTLRParser.ebnfSuffix_return retval = new ANTLRParser.ebnfSuffix_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken QUESTION147=null;
+		IToken STAR148=null;
+		IToken PLUS149=null;
+
+		GrammarAST QUESTION147_tree=null;
+		GrammarAST STAR148_tree=null;
+		GrammarAST PLUS149_tree=null;
+		RewriteRuleITokenStream stream_QUESTION=new RewriteRuleITokenStream(adaptor,"token QUESTION");
+		RewriteRuleITokenStream stream_STAR=new RewriteRuleITokenStream(adaptor,"token STAR");
+		RewriteRuleITokenStream stream_PLUS=new RewriteRuleITokenStream(adaptor,"token PLUS");
+
+
+		GrammarAST blkRoot=null;
+		GrammarAST alt=null;
+		GrammarAST save = currentBlockAST;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:621:4: ( ( -> BLOCK[\"BLOCK\"] ) ( -> ^( ALT[\"ALT\"] EOA[\"<end-of-alt>\"] ) ) ( QUESTION -> OPTIONAL[$elemAST.Token,\"?\"] | STAR -> CLOSURE[$elemAST.Token,\"*\"] | PLUS -> POSITIVE_CLOSURE[$elemAST.Token,\"+\"] ) -> ^( $ebnfSuffix ^( EOB[$elemAST.Token, \"<end-of-block>\"] ) ) )
+			// Grammars\\ANTLR.g3:621:4: ( -> BLOCK[\"BLOCK\"] ) ( -> ^( ALT[\"ALT\"] EOA[\"<end-of-alt>\"] ) ) ( QUESTION -> OPTIONAL[$elemAST.Token,\"?\"] | STAR -> CLOSURE[$elemAST.Token,\"*\"] | PLUS -> POSITIVE_CLOSURE[$elemAST.Token,\"+\"] )
+			{
+			// Grammars\\ANTLR.g3:621:4: ( -> BLOCK[\"BLOCK\"] )
+			// Grammars\\ANTLR.g3:621:6:
+			{
+
+
+
+			{
+			// AST REWRITE
+			// elements:
+			// token labels:
+			// rule labels: retval
+			// token list labels:
+			// rule list labels:
+			// wildcard labels:
+			if ( state.backtracking == 0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+			root_0 = (GrammarAST)adaptor.Nil();
+			// 621:6: -> BLOCK[\"BLOCK\"]
+			{
+				adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(BLOCK, "BLOCK"));
+
+			}
+
+			retval.tree = root_0;
+			}
+			}
+
+			}
+
+			if ( state.backtracking == 0 )
+			{
+				 blkRoot = (GrammarAST)((GrammarAST)retval.tree).GetChild(0); currentBlockAST = blkRoot;
+			}
+			// Grammars\\ANTLR.g3:624:3: ( -> ^( ALT[\"ALT\"] EOA[\"<end-of-alt>\"] ) )
+			// Grammars\\ANTLR.g3:625:4:
+			{
+
+
+
+			{
+			// AST REWRITE
+			// elements:
+			// token labels:
+			// rule labels: retval
+			// token list labels:
+			// rule list labels:
+			// wildcard labels:
+			if ( state.backtracking == 0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+			root_0 = (GrammarAST)adaptor.Nil();
+			// 625:4: -> ^( ALT[\"ALT\"] EOA[\"<end-of-alt>\"] )
+			{
+				// Grammars\\ANTLR.g3:625:7: ^( ALT[\"ALT\"] EOA[\"<end-of-alt>\"] )
+				{
+				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+				root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(ALT, "ALT"), root_1);
+
+				adaptor.AddChild(root_1, elemAST);
+				adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EOA, "<end-of-alt>"));
+
+				adaptor.AddChild(root_0, root_1);
+				}
+
+			}
+
+			retval.tree = root_0;
+			}
+			}
+
+			}
+
+			if ( state.backtracking == 0 )
+			{
+
+							alt = (GrammarAST)((GrammarAST)retval.tree).GetChild(0);
+							if ( !inRewrite )
+								prefixWithSynPred(alt);
+
+			}
+			// Grammars\\ANTLR.g3:632:3: ( QUESTION -> OPTIONAL[$elemAST.Token,\"?\"] | STAR -> CLOSURE[$elemAST.Token,\"*\"] | PLUS -> POSITIVE_CLOSURE[$elemAST.Token,\"+\"] )
+			int alt76=3;
+			switch ( input.LA(1) )
+			{
+			case QUESTION:
+				{
+				alt76=1;
+				}
+				break;
+			case STAR:
+				{
+				alt76=2;
+				}
+				break;
+			case PLUS:
+				{
+				alt76=3;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 76, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt76 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:632:5: QUESTION
+				{
+				QUESTION147=(IToken)Match(input,QUESTION,Follow._QUESTION_in_ebnfSuffix2643); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_QUESTION.Add(QUESTION147);
+
+
+
+				{
+				// AST REWRITE
+				// elements:
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 633:4: -> OPTIONAL[$elemAST.Token,\"?\"]
+				{
+					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(OPTIONAL, elemAST.Token, "?"));
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:634:5: STAR
+				{
+				STAR148=(IToken)Match(input,STAR,Follow._STAR_in_ebnfSuffix2657); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_STAR.Add(STAR148);
+
+
+
+				{
+				// AST REWRITE
+				// elements:
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 635:4: -> CLOSURE[$elemAST.Token,\"*\"]
+				{
+					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(CLOSURE, elemAST.Token, "*"));
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 3:
+				// Grammars\\ANTLR.g3:636:5: PLUS
+				{
+				PLUS149=(IToken)Match(input,PLUS,Follow._PLUS_in_ebnfSuffix2671); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_PLUS.Add(PLUS149);
+
+
+
+				{
+				// AST REWRITE
+				// elements:
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 637:4: -> POSITIVE_CLOSURE[$elemAST.Token,\"+\"]
+				{
+					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(POSITIVE_CLOSURE, elemAST.Token, "+"));
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+
+			}
+
+
+
+			{
+			// AST REWRITE
+			// elements: ebnfSuffix
+			// token labels:
+			// rule labels: retval
+			// token list labels:
+			// rule list labels:
+			// wildcard labels:
+			if ( state.backtracking == 0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+			root_0 = (GrammarAST)adaptor.Nil();
+			// 639:3: -> ^( $ebnfSuffix ^( EOB[$elemAST.Token, \"<end-of-block>\"] ) )
+			{
+				// Grammars\\ANTLR.g3:639:6: ^( $ebnfSuffix ^( EOB[$elemAST.Token, \"<end-of-block>\"] ) )
+				{
+				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+				root_1 = (GrammarAST)adaptor.BecomeRoot(stream_retval.NextNode(), root_1);
+
+				// Grammars\\ANTLR.g3:639:20: ^( EOB[$elemAST.Token, \"<end-of-block>\"] )
+				{
+				GrammarAST root_2 = (GrammarAST)adaptor.Nil();
+				root_2 = (GrammarAST)adaptor.BecomeRoot(blkRoot, root_2);
+
+				adaptor.AddChild(root_2, alt);
+				adaptor.AddChild(root_2, (GrammarAST)adaptor.Create(EOB, elemAST.Token, "<end-of-block>"));
+
+				adaptor.AddChild(root_1, root_2);
+				}
+
+				adaptor.AddChild(root_0, root_1);
+				}
+
+			}
+
+			retval.tree = root_0;
+			}
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+			if ( state.backtracking == 0 )
+			{
+
+				currentBlockAST = save;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "ebnfSuffix"
+
+	public class notTerminal_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "notTerminal"
+	// Grammars\\ANTLR.g3:642:0: notTerminal : (cl= CHAR_LITERAL |tr= TOKEN_REF | STRING_LITERAL );
+	private ANTLRParser.notTerminal_return notTerminal(  )
+	{
+		ANTLRParser.notTerminal_return retval = new ANTLRParser.notTerminal_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken cl=null;
+		IToken tr=null;
+		IToken STRING_LITERAL150=null;
+
+		GrammarAST cl_tree=null;
+		GrammarAST tr_tree=null;
+		GrammarAST STRING_LITERAL150_tree=null;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:643:4: (cl= CHAR_LITERAL |tr= TOKEN_REF | STRING_LITERAL )
+			int alt77=3;
+			switch ( input.LA(1) )
+			{
+			case CHAR_LITERAL:
+				{
+				alt77=1;
+				}
+				break;
+			case TOKEN_REF:
+				{
+				alt77=2;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt77=3;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 77, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt77 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:643:4: cl= CHAR_LITERAL
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				cl=(IToken)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_notTerminal2714); if (state.failed) return retval;
+				if ( state.backtracking==0 ) {
+				cl_tree = (GrammarAST)adaptor.Create(cl);
+				adaptor.AddChild(root_0, cl_tree);
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:644:4: tr= TOKEN_REF
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				tr=(IToken)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_notTerminal2721); if (state.failed) return retval;
+				if ( state.backtracking==0 ) {
+				tr_tree = (GrammarAST)adaptor.Create(tr);
+				adaptor.AddChild(root_0, tr_tree);
+				}
+
+				}
+				break;
+			case 3:
+				// Grammars\\ANTLR.g3:645:4: STRING_LITERAL
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				STRING_LITERAL150=(IToken)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_notTerminal2726); if (state.failed) return retval;
+				if ( state.backtracking==0 ) {
+				STRING_LITERAL150_tree = (GrammarAST)adaptor.Create(STRING_LITERAL150);
+				adaptor.AddChild(root_0, STRING_LITERAL150_tree);
+				}
+
+				}
+				break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "notTerminal"
+
+	public class idList_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "idList"
+	// Grammars\\ANTLR.g3:648:0: idList : id ( COMMA id )* ;
+	private ANTLRParser.idList_return idList(  )
+	{
+		ANTLRParser.idList_return retval = new ANTLRParser.idList_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken COMMA152=null;
+		ANTLRParser.id_return id151 = default(ANTLRParser.id_return);
+		ANTLRParser.id_return id153 = default(ANTLRParser.id_return);
+
+		GrammarAST COMMA152_tree=null;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:649:4: ( id ( COMMA id )* )
+			// Grammars\\ANTLR.g3:649:4: id ( COMMA id )*
+			{
+			root_0 = (GrammarAST)adaptor.Nil();
+
+			PushFollow(Follow._id_in_idList2737);
+			id151=id();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, id151.Tree);
+			// Grammars\\ANTLR.g3:649:7: ( COMMA id )*
+			for ( ; ; )
+			{
+				int alt78=2;
+				int LA78_0 = input.LA(1);
+
+				if ( (LA78_0==COMMA) )
+				{
+					alt78=1;
+				}
+
+
+				switch ( alt78 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:649:8: COMMA id
+					{
+					COMMA152=(IToken)Match(input,COMMA,Follow._COMMA_in_idList2740); if (state.failed) return retval;
+					PushFollow(Follow._id_in_idList2743);
+					id153=id();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, id153.Tree);
+
+					}
+					break;
+
+				default:
+					goto loop78;
+				}
+			}
+
+			loop78:
+				;
+
+
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "idList"
+
+	public class id_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "id"
+	// Grammars\\ANTLR.g3:652:0: id : ( TOKEN_REF -> ID[$TOKEN_REF] | RULE_REF -> ID[$RULE_REF] );
+	private ANTLRParser.id_return id(  )
+	{
+		ANTLRParser.id_return retval = new ANTLRParser.id_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken TOKEN_REF154=null;
+		IToken RULE_REF155=null;
+
+		GrammarAST TOKEN_REF154_tree=null;
+		GrammarAST RULE_REF155_tree=null;
+		RewriteRuleITokenStream stream_TOKEN_REF=new RewriteRuleITokenStream(adaptor,"token TOKEN_REF");
+		RewriteRuleITokenStream stream_RULE_REF=new RewriteRuleITokenStream(adaptor,"token RULE_REF");
+
+		try
+		{
+			// Grammars\\ANTLR.g3:653:4: ( TOKEN_REF -> ID[$TOKEN_REF] | RULE_REF -> ID[$RULE_REF] )
+			int alt79=2;
+			int LA79_0 = input.LA(1);
+
+			if ( (LA79_0==TOKEN_REF) )
+			{
+				alt79=1;
+			}
+			else if ( (LA79_0==RULE_REF) )
+			{
+				alt79=2;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae = new NoViableAltException("", 79, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt79 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:653:4: TOKEN_REF
+				{
+				TOKEN_REF154=(IToken)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_id2756); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_TOKEN_REF.Add(TOKEN_REF154);
+
+
+
+				{
+				// AST REWRITE
+				// elements:
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 654:3: -> ID[$TOKEN_REF]
+				{
+					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(ID, TOKEN_REF154));
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:655:4: RULE_REF
+				{
+				RULE_REF155=(IToken)Match(input,RULE_REF,Follow._RULE_REF_in_id2768); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_RULE_REF.Add(RULE_REF155);
+
+
+
+				{
+				// AST REWRITE
+				// elements:
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 656:3: -> ID[$RULE_REF]
+				{
+					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(ID, RULE_REF155));
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "id"
+
+	public class rewrite_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "rewrite"
+	// Grammars\\ANTLR.g3:661:0: rewrite : ( ( rewrite_with_sempred )* REWRITE rewrite_alternative -> ( rewrite_with_sempred )* ^( REWRITE rewrite_alternative ) |);
+	private ANTLRParser.rewrite_return rewrite(  )
+	{
+		ANTLRParser.rewrite_return retval = new ANTLRParser.rewrite_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken REWRITE157=null;
+		ANTLRParser.rewrite_with_sempred_return rewrite_with_sempred156 = default(ANTLRParser.rewrite_with_sempred_return);
+		ANTLRParser.rewrite_alternative_return rewrite_alternative158 = default(ANTLRParser.rewrite_alternative_return);
+
+		GrammarAST REWRITE157_tree=null;
+		RewriteRuleITokenStream stream_REWRITE=new RewriteRuleITokenStream(adaptor,"token REWRITE");
+		RewriteRuleSubtreeStream stream_rewrite_with_sempred=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_with_sempred");
+		RewriteRuleSubtreeStream stream_rewrite_alternative=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_alternative");
+		try
+		{
+			// Grammars\\ANTLR.g3:662:4: ( ( rewrite_with_sempred )* REWRITE rewrite_alternative -> ( rewrite_with_sempred )* ^( REWRITE rewrite_alternative ) |)
+			int alt81=2;
+			int LA81_0 = input.LA(1);
+
+			if ( (LA81_0==REWRITE) )
+			{
+				alt81=1;
+			}
+			else if ( (LA81_0==OR||LA81_0==RPAREN||LA81_0==SEMI) )
+			{
+				alt81=2;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae = new NoViableAltException("", 81, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt81 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:662:4: ( rewrite_with_sempred )* REWRITE rewrite_alternative
+				{
+				// Grammars\\ANTLR.g3:662:4: ( rewrite_with_sempred )*
+				for ( ; ; )
+				{
+					int alt80=2;
+					int LA80_0 = input.LA(1);
+
+					if ( (LA80_0==REWRITE) )
+					{
+						int LA80_1 = input.LA(2);
+
+						if ( (LA80_1==SEMPRED) )
+						{
+							alt80=1;
+						}
+
+
+					}
+
+
+					switch ( alt80 )
+					{
+					case 1:
+						// Grammars\\ANTLR.g3:662:0: rewrite_with_sempred
+						{
+						PushFollow(Follow._rewrite_with_sempred_in_rewrite2788);
+						rewrite_with_sempred156=rewrite_with_sempred();
+
+						state._fsp--;
+						if (state.failed) return retval;
+						if ( state.backtracking == 0 ) stream_rewrite_with_sempred.Add(rewrite_with_sempred156.Tree);
+
+						}
+						break;
+
+					default:
+						goto loop80;
+					}
+				}
+
+				loop80:
+					;
+
+
+				REWRITE157=(IToken)Match(input,REWRITE,Follow._REWRITE_in_rewrite2793); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_REWRITE.Add(REWRITE157);
+
+				PushFollow(Follow._rewrite_alternative_in_rewrite2795);
+				rewrite_alternative158=rewrite_alternative();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_rewrite_alternative.Add(rewrite_alternative158.Tree);
+
+
+				{
+				// AST REWRITE
+				// elements: rewrite_with_sempred, REWRITE, rewrite_alternative
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 664:3: -> ( rewrite_with_sempred )* ^( REWRITE rewrite_alternative )
+				{
+					// Grammars\\ANTLR.g3:664:6: ( rewrite_with_sempred )*
+					while ( stream_rewrite_with_sempred.HasNext )
+					{
+						adaptor.AddChild(root_0, stream_rewrite_with_sempred.NextTree());
+
+					}
+					stream_rewrite_with_sempred.Reset();
+					// Grammars\\ANTLR.g3:664:28: ^( REWRITE rewrite_alternative )
+					{
+					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+					root_1 = (GrammarAST)adaptor.BecomeRoot(stream_REWRITE.NextNode(), root_1);
+
+					adaptor.AddChild(root_1, stream_rewrite_alternative.NextTree());
+
+					adaptor.AddChild(root_0, root_1);
+					}
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:666:2:
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+
+
+				}
+				break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite"
+
+	public class rewrite_with_sempred_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "rewrite_with_sempred"
+	// Grammars\\ANTLR.g3:668:0: rewrite_with_sempred : REWRITE SEMPRED rewrite_alternative ;
+	private ANTLRParser.rewrite_with_sempred_return rewrite_with_sempred(  )
+	{
+		ANTLRParser.rewrite_with_sempred_return retval = new ANTLRParser.rewrite_with_sempred_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken REWRITE159=null;
+		IToken SEMPRED160=null;
+		ANTLRParser.rewrite_alternative_return rewrite_alternative161 = default(ANTLRParser.rewrite_alternative_return);
+
+		GrammarAST REWRITE159_tree=null;
+		GrammarAST SEMPRED160_tree=null;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:669:4: ( REWRITE SEMPRED rewrite_alternative )
+			// Grammars\\ANTLR.g3:669:4: REWRITE SEMPRED rewrite_alternative
+			{
+			root_0 = (GrammarAST)adaptor.Nil();
+
+			REWRITE159=(IToken)Match(input,REWRITE,Follow._REWRITE_in_rewrite_with_sempred2822); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) {
+			REWRITE159_tree = (GrammarAST)adaptor.Create(REWRITE159);
+			root_0 = (GrammarAST)adaptor.BecomeRoot(REWRITE159_tree, root_0);
+			}
+			SEMPRED160=(IToken)Match(input,SEMPRED,Follow._SEMPRED_in_rewrite_with_sempred2825); if (state.failed) return retval;
+			if ( state.backtracking==0 ) {
+			SEMPRED160_tree = (GrammarAST)adaptor.Create(SEMPRED160);
+			adaptor.AddChild(root_0, SEMPRED160_tree);
+			}
+			PushFollow(Follow._rewrite_alternative_in_rewrite_with_sempred2827);
+			rewrite_alternative161=rewrite_alternative();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, rewrite_alternative161.Tree);
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_with_sempred"
+
+	public class rewrite_block_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "rewrite_block"
+	// Grammars\\ANTLR.g3:672:0: rewrite_block : LPAREN rewrite_alternative RPAREN -> ^( BLOCK[$LPAREN,\"BLOCK\"] rewrite_alternative EOB[$RPAREN,\"<end-of-block>\"] ) ;
+	private ANTLRParser.rewrite_block_return rewrite_block(  )
+	{
+		ANTLRParser.rewrite_block_return retval = new ANTLRParser.rewrite_block_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken LPAREN162=null;
+		IToken RPAREN164=null;
+		ANTLRParser.rewrite_alternative_return rewrite_alternative163 = default(ANTLRParser.rewrite_alternative_return);
+
+		GrammarAST LPAREN162_tree=null;
+		GrammarAST RPAREN164_tree=null;
+		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
+		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
+		RewriteRuleSubtreeStream stream_rewrite_alternative=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_alternative");
+		try
+		{
+			// Grammars\\ANTLR.g3:673:4: ( LPAREN rewrite_alternative RPAREN -> ^( BLOCK[$LPAREN,\"BLOCK\"] rewrite_alternative EOB[$RPAREN,\"<end-of-block>\"] ) )
+			// Grammars\\ANTLR.g3:673:4: LPAREN rewrite_alternative RPAREN
+			{
+			LPAREN162=(IToken)Match(input,LPAREN,Follow._LPAREN_in_rewrite_block2838); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_LPAREN.Add(LPAREN162);
+
+			PushFollow(Follow._rewrite_alternative_in_rewrite_block2842);
+			rewrite_alternative163=rewrite_alternative();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_rewrite_alternative.Add(rewrite_alternative163.Tree);
+			RPAREN164=(IToken)Match(input,RPAREN,Follow._RPAREN_in_rewrite_block2846); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_RPAREN.Add(RPAREN164);
+
+
+
+			{
+			// AST REWRITE
+			// elements: rewrite_alternative
+			// token labels:
+			// rule labels: retval
+			// token list labels:
+			// rule list labels:
+			// wildcard labels:
+			if ( state.backtracking == 0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+			root_0 = (GrammarAST)adaptor.Nil();
+			// 676:3: -> ^( BLOCK[$LPAREN,\"BLOCK\"] rewrite_alternative EOB[$RPAREN,\"<end-of-block>\"] )
+			{
+				// Grammars\\ANTLR.g3:676:6: ^( BLOCK[$LPAREN,\"BLOCK\"] rewrite_alternative EOB[$RPAREN,\"<end-of-block>\"] )
+				{
+				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+				root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(BLOCK, LPAREN162, "BLOCK"), root_1);
+
+				adaptor.AddChild(root_1, stream_rewrite_alternative.NextTree());
+				adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EOB, RPAREN164, "<end-of-block>"));
+
+				adaptor.AddChild(root_0, root_1);
+				}
+
+			}
+
+			retval.tree = root_0;
+			}
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_block"
+
+	public class rewrite_alternative_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "rewrite_alternative"
+	// Grammars\\ANTLR.g3:679:0: rewrite_alternative options {k=1; } : ({...}? => rewrite_template |{...}? => ( rewrite_element )+ -> {!stream_rewrite_element.HasNext}? ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] ) -> ^( ALT[LT(1),\"ALT\"] ( rewrite_element )+ EOA[\"<end-of-alt>\"] ) | -> ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] ) |{...}? ETC );
+	private ANTLRParser.rewrite_alternative_return rewrite_alternative(  )
+	{
+		ANTLRParser.rewrite_alternative_return retval = new ANTLRParser.rewrite_alternative_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken ETC167=null;
+		ANTLRParser.rewrite_template_return rewrite_template165 = default(ANTLRParser.rewrite_template_return);
+		ANTLRParser.rewrite_element_return rewrite_element166 = default(ANTLRParser.rewrite_element_return);
+
+		GrammarAST ETC167_tree=null;
+		RewriteRuleSubtreeStream stream_rewrite_element=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_element");
+		try
+		{
+			// Grammars\\ANTLR.g3:681:4: ({...}? => rewrite_template |{...}? => ( rewrite_element )+ -> {!stream_rewrite_element.HasNext}? ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] ) -> ^( ALT[LT(1),\"ALT\"] ( rewrite_element )+ EOA[\"<end-of-alt>\"] ) | -> ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] ) |{...}? ETC )
+			int alt83=4;
+			alt83 = dfa83.Predict(input);
+			switch ( alt83 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:681:4: {...}? => rewrite_template
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				if ( !((Grammar.BuildTemplate)) )
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					throw new FailedPredicateException(input, "rewrite_alternative", "Grammar.BuildTemplate");
+				}
+				PushFollow(Follow._rewrite_template_in_rewrite_alternative2882);
+				rewrite_template165=rewrite_template();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, rewrite_template165.Tree);
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:683:4: {...}? => ( rewrite_element )+
+				{
+				if ( !((Grammar.BuildAST)) )
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					throw new FailedPredicateException(input, "rewrite_alternative", "Grammar.BuildAST");
+				}
+				// Grammars\\ANTLR.g3:683:27: ( rewrite_element )+
+				int cnt82=0;
+				for ( ; ; )
+				{
+					int alt82=2;
+					int LA82_0 = input.LA(1);
+
+					if ( (LA82_0==ACTION||LA82_0==CHAR_LITERAL||LA82_0==DOLLAR||LA82_0==LPAREN||LA82_0==RULE_REF||LA82_0==STRING_LITERAL||LA82_0==TOKEN_REF||LA82_0==TREE_BEGIN) )
+					{
+						alt82=1;
+					}
+
+
+					switch ( alt82 )
+					{
+					case 1:
+						// Grammars\\ANTLR.g3:683:29: rewrite_element
+						{
+						PushFollow(Follow._rewrite_element_in_rewrite_alternative2894);
+						rewrite_element166=rewrite_element();
+
+						state._fsp--;
+						if (state.failed) return retval;
+						if ( state.backtracking == 0 ) stream_rewrite_element.Add(rewrite_element166.Tree);
+
+						}
+						break;
+
+					default:
+						if ( cnt82 >= 1 )
+							goto loop82;
+
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						EarlyExitException eee82 = new EarlyExitException( 82, input );
+						throw eee82;
+					}
+					cnt82++;
+				}
+				loop82:
+					;
+
+
+
+
+				{
+				// AST REWRITE
+				// elements: rewrite_element
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 684:3: -> {!stream_rewrite_element.HasNext}? ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] )
+				if (!stream_rewrite_element.HasNext)
+				{
+					// Grammars\\ANTLR.g3:684:41: ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] )
+					{
+					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(ALT, LT(1), "ALT"), root_1);
+
+					adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EPSILON, "epsilon"));
+					adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EOA, "<end-of-alt>"));
+
+					adaptor.AddChild(root_0, root_1);
+					}
+
+				}
+				else // 685:3: -> ^( ALT[LT(1),\"ALT\"] ( rewrite_element )+ EOA[\"<end-of-alt>\"] )
+				{
+					// Grammars\\ANTLR.g3:685:6: ^( ALT[LT(1),\"ALT\"] ( rewrite_element )+ EOA[\"<end-of-alt>\"] )
+					{
+					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(ALT, LT(1), "ALT"), root_1);
+
+					if ( !(stream_rewrite_element.HasNext) )
+					{
+						throw new RewriteEarlyExitException();
+					}
+					while ( stream_rewrite_element.HasNext )
+					{
+						adaptor.AddChild(root_1, stream_rewrite_element.NextTree());
+
+					}
+					stream_rewrite_element.Reset();
+					adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EOA, "<end-of-alt>"));
+
+					adaptor.AddChild(root_0, root_1);
+					}
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 3:
+				// Grammars\\ANTLR.g3:688:3:
+				{
+
+
+
+				{
+				// AST REWRITE
+				// elements:
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 688:3: -> ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] )
+				{
+					// Grammars\\ANTLR.g3:688:6: ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] )
+					{
+					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(ALT, LT(1), "ALT"), root_1);
+
+					adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EPSILON, "epsilon"));
+					adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EOA, "<end-of-alt>"));
+
+					adaptor.AddChild(root_0, root_1);
+					}
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 4:
+				// Grammars\\ANTLR.g3:689:4: {...}? ETC
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				if ( !((Grammar.BuildAST)) )
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					throw new FailedPredicateException(input, "rewrite_alternative", "Grammar.BuildAST");
+				}
+				ETC167=(IToken)Match(input,ETC,Follow._ETC_in_rewrite_alternative2955); if (state.failed) return retval;
+				if ( state.backtracking==0 ) {
+				ETC167_tree = (GrammarAST)adaptor.Create(ETC167);
+				adaptor.AddChild(root_0, ETC167_tree);
+				}
+
+				}
+				break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_alternative"
+
+	public class rewrite_element_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "rewrite_element"
+	// Grammars\\ANTLR.g3:692:0: rewrite_element : ( (t= rewrite_atom -> $t) (subrule= ebnfSuffix[$t.tree,true] -> $subrule)? | rewrite_ebnf | (tr= rewrite_tree -> $tr) (subrule= ebnfSuffix[$tr.tree,true] -> $subrule)? );
+	private ANTLRParser.rewrite_element_return rewrite_element(  )
+	{
+		ANTLRParser.rewrite_element_return retval = new ANTLRParser.rewrite_element_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		ANTLRParser.rewrite_atom_return t = default(ANTLRParser.rewrite_atom_return);
+		ANTLRParser.ebnfSuffix_return subrule = default(ANTLRParser.ebnfSuffix_return);
+		ANTLRParser.rewrite_tree_return tr = default(ANTLRParser.rewrite_tree_return);
+		ANTLRParser.rewrite_ebnf_return rewrite_ebnf168 = default(ANTLRParser.rewrite_ebnf_return);
+
+		RewriteRuleSubtreeStream stream_rewrite_atom=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_atom");
+		RewriteRuleSubtreeStream stream_ebnfSuffix=new RewriteRuleSubtreeStream(adaptor,"rule ebnfSuffix");
+		RewriteRuleSubtreeStream stream_rewrite_tree=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_tree");
+		try
+		{
+			// Grammars\\ANTLR.g3:693:4: ( (t= rewrite_atom -> $t) (subrule= ebnfSuffix[$t.tree,true] -> $subrule)? | rewrite_ebnf | (tr= rewrite_tree -> $tr) (subrule= ebnfSuffix[$tr.tree,true] -> $subrule)? )
+			int alt86=3;
+			switch ( input.LA(1) )
+			{
+			case ACTION:
+			case CHAR_LITERAL:
+			case DOLLAR:
+			case RULE_REF:
+			case STRING_LITERAL:
+			case TOKEN_REF:
+				{
+				alt86=1;
+				}
+				break;
+			case LPAREN:
+				{
+				alt86=2;
+				}
+				break;
+			case TREE_BEGIN:
+				{
+				alt86=3;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 86, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt86 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:693:4: (t= rewrite_atom -> $t) (subrule= ebnfSuffix[$t.tree,true] -> $subrule)?
+				{
+				// Grammars\\ANTLR.g3:693:4: (t= rewrite_atom -> $t)
+				// Grammars\\ANTLR.g3:693:6: t= rewrite_atom
+				{
+				PushFollow(Follow._rewrite_atom_in_rewrite_element2970);
+				t=rewrite_atom();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_rewrite_atom.Add(t.Tree);
+
+
+				{
+				// AST REWRITE
+				// elements: t
+				// token labels:
+				// rule labels: t, retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_t=new RewriteRuleSubtreeStream(adaptor,"rule t",t!=null?t.tree:null);
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 694:4: -> $t
+				{
+					adaptor.AddChild(root_0, stream_t.NextTree());
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+
+				// Grammars\\ANTLR.g3:696:3: (subrule= ebnfSuffix[$t.tree,true] -> $subrule)?
+				int alt84=2;
+				int LA84_0 = input.LA(1);
+
+				if ( (LA84_0==PLUS||LA84_0==QUESTION||LA84_0==STAR) )
+				{
+					alt84=1;
+				}
+				switch ( alt84 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:696:5: subrule= ebnfSuffix[$t.tree,true]
+					{
+					PushFollow(Follow._ebnfSuffix_in_rewrite_element2990);
+					subrule=ebnfSuffix((t!=null?((GrammarAST)t.tree):null), true);
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) stream_ebnfSuffix.Add(subrule.Tree);
+
+
+					{
+					// AST REWRITE
+					// elements: subrule
+					// token labels:
+					// rule labels: subrule, retval
+					// token list labels:
+					// rule list labels:
+					// wildcard labels:
+					if ( state.backtracking == 0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_subrule=new RewriteRuleSubtreeStream(adaptor,"rule subrule",subrule!=null?subrule.tree:null);
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+					root_0 = (GrammarAST)adaptor.Nil();
+					// 697:4: -> $subrule
+					{
+						adaptor.AddChild(root_0, stream_subrule.NextTree());
+
+					}
+
+					retval.tree = root_0;
+					}
+					}
+
+					}
+					break;
+
+				}
+
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:699:4: rewrite_ebnf
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				PushFollow(Follow._rewrite_ebnf_in_rewrite_element3009);
+				rewrite_ebnf168=rewrite_ebnf();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, rewrite_ebnf168.Tree);
+
+				}
+				break;
+			case 3:
+				// Grammars\\ANTLR.g3:700:4: (tr= rewrite_tree -> $tr) (subrule= ebnfSuffix[$tr.tree,true] -> $subrule)?
+				{
+				// Grammars\\ANTLR.g3:700:4: (tr= rewrite_tree -> $tr)
+				// Grammars\\ANTLR.g3:700:6: tr= rewrite_tree
+				{
+				PushFollow(Follow._rewrite_tree_in_rewrite_element3018);
+				tr=rewrite_tree();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_rewrite_tree.Add(tr.Tree);
+
+
+				{
+				// AST REWRITE
+				// elements: tr
+				// token labels:
+				// rule labels: tr, retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_tr=new RewriteRuleSubtreeStream(adaptor,"rule tr",tr!=null?tr.tree:null);
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 701:4: -> $tr
+				{
+					adaptor.AddChild(root_0, stream_tr.NextTree());
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+
+				// Grammars\\ANTLR.g3:703:3: (subrule= ebnfSuffix[$tr.tree,true] -> $subrule)?
+				int alt85=2;
+				int LA85_0 = input.LA(1);
+
+				if ( (LA85_0==PLUS||LA85_0==QUESTION||LA85_0==STAR) )
+				{
+					alt85=1;
+				}
+				switch ( alt85 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:703:5: subrule= ebnfSuffix[$tr.tree,true]
+					{
+					PushFollow(Follow._ebnfSuffix_in_rewrite_element3038);
+					subrule=ebnfSuffix((tr!=null?((GrammarAST)tr.tree):null), true);
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) stream_ebnfSuffix.Add(subrule.Tree);
+
+
+					{
+					// AST REWRITE
+					// elements: subrule
+					// token labels:
+					// rule labels: subrule, retval
+					// token list labels:
+					// rule list labels:
+					// wildcard labels:
+					if ( state.backtracking == 0 ) {
+					retval.tree = root_0;
+					RewriteRuleSubtreeStream stream_subrule=new RewriteRuleSubtreeStream(adaptor,"rule subrule",subrule!=null?subrule.tree:null);
+					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+					root_0 = (GrammarAST)adaptor.Nil();
+					// 704:4: -> $subrule
+					{
+						adaptor.AddChild(root_0, stream_subrule.NextTree());
+
+					}
+
+					retval.tree = root_0;
+					}
+					}
+
+					}
+					break;
+
+				}
+
+
+				}
+				break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_element"
+
+	public class rewrite_atom_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "rewrite_atom"
+	// Grammars\\ANTLR.g3:708:0: rewrite_atom : ( (tr= TOKEN_REF -> $tr) ( elementOptions[(GrammarAST)$tree.GetChild(0)] )? ( ARG_ACTION )? -> ^( $rewrite_atom ( ARG_ACTION )? ) |rr= RULE_REF | (cl= CHAR_LITERAL -> $cl) ( elementOptions[(GrammarAST)$tree.GetChild(0)] )? | (sl= STRING_LITERAL -> $sl) (eo= elementOptions[(GrammarAST)$tree.GetChild(0)] )? |d= DOLLAR i= id -> LABEL[$i.start,$i.text] | ACTION );
+	private ANTLRParser.rewrite_atom_return rewrite_atom(  )
+	{
+		ANTLRParser.rewrite_atom_return retval = new ANTLRParser.rewrite_atom_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken tr=null;
+		IToken rr=null;
+		IToken cl=null;
+		IToken sl=null;
+		IToken d=null;
+		IToken ARG_ACTION170=null;
+		IToken ACTION172=null;
+		ANTLRParser.elementOptions_return eo = default(ANTLRParser.elementOptions_return);
+		ANTLRParser.id_return i = default(ANTLRParser.id_return);
+		ANTLRParser.elementOptions_return elementOptions169 = default(ANTLRParser.elementOptions_return);
+		ANTLRParser.elementOptions_return elementOptions171 = default(ANTLRParser.elementOptions_return);
+
+		GrammarAST tr_tree=null;
+		GrammarAST rr_tree=null;
+		GrammarAST cl_tree=null;
+		GrammarAST sl_tree=null;
+		GrammarAST d_tree=null;
+		GrammarAST ARG_ACTION170_tree=null;
+		GrammarAST ACTION172_tree=null;
+		RewriteRuleITokenStream stream_TOKEN_REF=new RewriteRuleITokenStream(adaptor,"token TOKEN_REF");
+		RewriteRuleITokenStream stream_ARG_ACTION=new RewriteRuleITokenStream(adaptor,"token ARG_ACTION");
+		RewriteRuleITokenStream stream_CHAR_LITERAL=new RewriteRuleITokenStream(adaptor,"token CHAR_LITERAL");
+		RewriteRuleITokenStream stream_STRING_LITERAL=new RewriteRuleITokenStream(adaptor,"token STRING_LITERAL");
+		RewriteRuleITokenStream stream_DOLLAR=new RewriteRuleITokenStream(adaptor,"token DOLLAR");
+		RewriteRuleSubtreeStream stream_elementOptions=new RewriteRuleSubtreeStream(adaptor,"rule elementOptions");
+		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
+
+		GrammarAST subrule=null;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:713:4: ( (tr= TOKEN_REF -> $tr) ( elementOptions[(GrammarAST)$tree.GetChild(0)] )? ( ARG_ACTION )? -> ^( $rewrite_atom ( ARG_ACTION )? ) |rr= RULE_REF | (cl= CHAR_LITERAL -> $cl) ( elementOptions[(GrammarAST)$tree.GetChild(0)] )? | (sl= STRING_LITERAL -> $sl) (eo= elementOptions[(GrammarAST)$tree.GetChild(0)] )? |d= DOLLAR i= id -> LABEL[$i.start,$i.text] | ACTION )
+			int alt91=6;
+			switch ( input.LA(1) )
+			{
+			case TOKEN_REF:
+				{
+				alt91=1;
+				}
+				break;
+			case RULE_REF:
+				{
+				alt91=2;
+				}
+				break;
+			case CHAR_LITERAL:
+				{
+				alt91=3;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt91=4;
+				}
+				break;
+			case DOLLAR:
+				{
+				alt91=5;
+				}
+				break;
+			case ACTION:
+				{
+				alt91=6;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 91, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt91 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:713:4: (tr= TOKEN_REF -> $tr) ( elementOptions[(GrammarAST)$tree.GetChild(0)] )? ( ARG_ACTION )?
+				{
+				// Grammars\\ANTLR.g3:713:4: (tr= TOKEN_REF -> $tr)
+				// Grammars\\ANTLR.g3:713:6: tr= TOKEN_REF
+				{
+				tr=(IToken)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_rewrite_atom3072); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_TOKEN_REF.Add(tr);
+
+
+
+				{
+				// AST REWRITE
+				// elements: tr
+				// token labels: tr
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleITokenStream stream_tr=new RewriteRuleITokenStream(adaptor,"token tr",tr);
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 714:4: -> $tr
+				{
+					adaptor.AddChild(root_0, stream_tr.NextNode());
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+
+				// Grammars\\ANTLR.g3:716:3: ( elementOptions[(GrammarAST)$tree.GetChild(0)] )?
+				int alt87=2;
+				int LA87_0 = input.LA(1);
+
+				if ( (LA87_0==OPEN_ELEMENT_OPTION) )
+				{
+					alt87=1;
+				}
+				switch ( alt87 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:716:4: elementOptions[(GrammarAST)$tree.GetChild(0)]
+					{
+					PushFollow(Follow._elementOptions_in_rewrite_atom3089);
+					elementOptions169=elementOptions((GrammarAST)((GrammarAST)retval.tree).GetChild(0));
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) stream_elementOptions.Add(elementOptions169.Tree);
+
+					}
+					break;
+
+				}
+
+				// Grammars\\ANTLR.g3:716:52: ( ARG_ACTION )?
+				int alt88=2;
+				int LA88_0 = input.LA(1);
+
+				if ( (LA88_0==ARG_ACTION) )
+				{
+					alt88=1;
+				}
+				switch ( alt88 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:716:53: ARG_ACTION
+					{
+					ARG_ACTION170=(IToken)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rewrite_atom3095); if (state.failed) return retval;
+					if ( state.backtracking == 0 ) stream_ARG_ACTION.Add(ARG_ACTION170);
+
+
+					}
+					break;
+
+				}
+
+
+
+				{
+				// AST REWRITE
+				// elements: rewrite_atom, ARG_ACTION
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 717:3: -> ^( $rewrite_atom ( ARG_ACTION )? )
+				{
+					// Grammars\\ANTLR.g3:717:6: ^( $rewrite_atom ( ARG_ACTION )? )
+					{
+					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+					root_1 = (GrammarAST)adaptor.BecomeRoot(stream_retval.NextNode(), root_1);
+
+					// Grammars\\ANTLR.g3:717:22: ( ARG_ACTION )?
+					if ( stream_ARG_ACTION.HasNext )
+					{
+						adaptor.AddChild(root_1, stream_ARG_ACTION.NextNode());
+
+					}
+					stream_ARG_ACTION.Reset();
+
+					adaptor.AddChild(root_0, root_1);
+					}
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:718:4: rr= RULE_REF
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				rr=(IToken)Match(input,RULE_REF,Follow._RULE_REF_in_rewrite_atom3117); if (state.failed) return retval;
+				if ( state.backtracking==0 ) {
+				rr_tree = (GrammarAST)adaptor.Create(rr);
+				adaptor.AddChild(root_0, rr_tree);
+				}
+
+				}
+				break;
+			case 3:
+				// Grammars\\ANTLR.g3:719:4: (cl= CHAR_LITERAL -> $cl) ( elementOptions[(GrammarAST)$tree.GetChild(0)] )?
+				{
+				// Grammars\\ANTLR.g3:719:4: (cl= CHAR_LITERAL -> $cl)
+				// Grammars\\ANTLR.g3:719:6: cl= CHAR_LITERAL
+				{
+				cl=(IToken)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_rewrite_atom3126); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_CHAR_LITERAL.Add(cl);
+
+
+
+				{
+				// AST REWRITE
+				// elements: cl
+				// token labels: cl
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleITokenStream stream_cl=new RewriteRuleITokenStream(adaptor,"token cl",cl);
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 720:4: -> $cl
+				{
+					adaptor.AddChild(root_0, stream_cl.NextNode());
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+
+				// Grammars\\ANTLR.g3:722:3: ( elementOptions[(GrammarAST)$tree.GetChild(0)] )?
+				int alt89=2;
+				int LA89_0 = input.LA(1);
+
+				if ( (LA89_0==OPEN_ELEMENT_OPTION) )
+				{
+					alt89=1;
+				}
+				switch ( alt89 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:722:4: elementOptions[(GrammarAST)$tree.GetChild(0)]
+					{
+					PushFollow(Follow._elementOptions_in_rewrite_atom3143);
+					elementOptions171=elementOptions((GrammarAST)((GrammarAST)retval.tree).GetChild(0));
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) stream_elementOptions.Add(elementOptions171.Tree);
+
+					}
+					break;
+
+				}
+
+
+				}
+				break;
+			case 4:
+				// Grammars\\ANTLR.g3:723:4: (sl= STRING_LITERAL -> $sl) (eo= elementOptions[(GrammarAST)$tree.GetChild(0)] )?
+				{
+				// Grammars\\ANTLR.g3:723:4: (sl= STRING_LITERAL -> $sl)
+				// Grammars\\ANTLR.g3:723:6: sl= STRING_LITERAL
+				{
+				sl=(IToken)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_rewrite_atom3155); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_STRING_LITERAL.Add(sl);
+
+
+
+				{
+				// AST REWRITE
+				// elements: sl
+				// token labels: sl
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleITokenStream stream_sl=new RewriteRuleITokenStream(adaptor,"token sl",sl);
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 724:4: -> $sl
+				{
+					adaptor.AddChild(root_0, stream_sl.NextNode());
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+
+				// Grammars\\ANTLR.g3:726:3: (eo= elementOptions[(GrammarAST)$tree.GetChild(0)] )?
+				int alt90=2;
+				int LA90_0 = input.LA(1);
+
+				if ( (LA90_0==OPEN_ELEMENT_OPTION) )
+				{
+					alt90=1;
+				}
+				switch ( alt90 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:726:4: eo= elementOptions[(GrammarAST)$tree.GetChild(0)]
+					{
+					PushFollow(Follow._elementOptions_in_rewrite_atom3174);
+					eo=elementOptions((GrammarAST)((GrammarAST)retval.tree).GetChild(0));
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) stream_elementOptions.Add(eo.Tree);
+
+					}
+					break;
+
+				}
+
+
+				}
+				break;
+			case 5:
+				// Grammars\\ANTLR.g3:727:4: d= DOLLAR i= id
+				{
+				d=(IToken)Match(input,DOLLAR,Follow._DOLLAR_in_rewrite_atom3184); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_DOLLAR.Add(d);
+
+				PushFollow(Follow._id_in_rewrite_atom3188);
+				i=id();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_id.Add(i.Tree);
+
+
+				{
+				// AST REWRITE
+				// elements:
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 728:3: -> LABEL[$i.start,$i.text]
+				{
+					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(LABEL, (i!=null?((IToken)i.start):null), (i!=null?input.ToString(i.start,i.stop):null)));
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 6:
+				// Grammars\\ANTLR.g3:729:4: ACTION
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				ACTION172=(IToken)Match(input,ACTION,Follow._ACTION_in_rewrite_atom3201); if (state.failed) return retval;
+				if ( state.backtracking==0 ) {
+				ACTION172_tree = (GrammarAST)adaptor.Create(ACTION172);
+				adaptor.AddChild(root_0, ACTION172_tree);
+				}
+
+				}
+				break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_atom"
+
+	public class rewrite_ebnf_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "rewrite_ebnf"
+	// Grammars\\ANTLR.g3:732:0: rewrite_ebnf : b= rewrite_block ( QUESTION -> ^( OPTIONAL[$b.start,\"?\"] $b) | STAR -> ^( CLOSURE[$b.start,\"*\"] $b) | PLUS -> ^( POSITIVE_CLOSURE[$b.start,\"+\"] $b) ) ;
+	private ANTLRParser.rewrite_ebnf_return rewrite_ebnf(  )
+	{
+		ANTLRParser.rewrite_ebnf_return retval = new ANTLRParser.rewrite_ebnf_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken QUESTION173=null;
+		IToken STAR174=null;
+		IToken PLUS175=null;
+		ANTLRParser.rewrite_block_return b = default(ANTLRParser.rewrite_block_return);
+
+		GrammarAST QUESTION173_tree=null;
+		GrammarAST STAR174_tree=null;
+		GrammarAST PLUS175_tree=null;
+		RewriteRuleITokenStream stream_QUESTION=new RewriteRuleITokenStream(adaptor,"token QUESTION");
+		RewriteRuleITokenStream stream_STAR=new RewriteRuleITokenStream(adaptor,"token STAR");
+		RewriteRuleITokenStream stream_PLUS=new RewriteRuleITokenStream(adaptor,"token PLUS");
+		RewriteRuleSubtreeStream stream_rewrite_block=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_block");
+		try
+		{
+			// Grammars\\ANTLR.g3:733:4: (b= rewrite_block ( QUESTION -> ^( OPTIONAL[$b.start,\"?\"] $b) | STAR -> ^( CLOSURE[$b.start,\"*\"] $b) | PLUS -> ^( POSITIVE_CLOSURE[$b.start,\"+\"] $b) ) )
+			// Grammars\\ANTLR.g3:733:4: b= rewrite_block ( QUESTION -> ^( OPTIONAL[$b.start,\"?\"] $b) | STAR -> ^( CLOSURE[$b.start,\"*\"] $b) | PLUS -> ^( POSITIVE_CLOSURE[$b.start,\"+\"] $b) )
+			{
+			PushFollow(Follow._rewrite_block_in_rewrite_ebnf3214);
+			b=rewrite_block();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_rewrite_block.Add(b.Tree);
+			// Grammars\\ANTLR.g3:734:3: ( QUESTION -> ^( OPTIONAL[$b.start,\"?\"] $b) | STAR -> ^( CLOSURE[$b.start,\"*\"] $b) | PLUS -> ^( POSITIVE_CLOSURE[$b.start,\"+\"] $b) )
+			int alt92=3;
+			switch ( input.LA(1) )
+			{
+			case QUESTION:
+				{
+				alt92=1;
+				}
+				break;
+			case STAR:
+				{
+				alt92=2;
+				}
+				break;
+			case PLUS:
+				{
+				alt92=3;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 92, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt92 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:734:5: QUESTION
+				{
+				QUESTION173=(IToken)Match(input,QUESTION,Follow._QUESTION_in_rewrite_ebnf3220); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_QUESTION.Add(QUESTION173);
+
+
+
+				{
+				// AST REWRITE
+				// elements: b
+				// token labels:
+				// rule labels: b, retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"rule b",b!=null?b.tree:null);
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 735:4: -> ^( OPTIONAL[$b.start,\"?\"] $b)
+				{
+					// Grammars\\ANTLR.g3:735:7: ^( OPTIONAL[$b.start,\"?\"] $b)
+					{
+					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(OPTIONAL, (b!=null?((IToken)b.start):null), "?"), root_1);
+
+					adaptor.AddChild(root_1, stream_b.NextTree());
+
+					adaptor.AddChild(root_0, root_1);
+					}
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:736:5: STAR
+				{
+				STAR174=(IToken)Match(input,STAR,Follow._STAR_in_rewrite_ebnf3239); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_STAR.Add(STAR174);
+
+
+
+				{
+				// AST REWRITE
+				// elements: b
+				// token labels:
+				// rule labels: b, retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"rule b",b!=null?b.tree:null);
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 737:4: -> ^( CLOSURE[$b.start,\"*\"] $b)
+				{
+					// Grammars\\ANTLR.g3:737:7: ^( CLOSURE[$b.start,\"*\"] $b)
+					{
+					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(CLOSURE, (b!=null?((IToken)b.start):null), "*"), root_1);
+
+					adaptor.AddChild(root_1, stream_b.NextTree());
+
+					adaptor.AddChild(root_0, root_1);
+					}
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 3:
+				// Grammars\\ANTLR.g3:738:5: PLUS
+				{
+				PLUS175=(IToken)Match(input,PLUS,Follow._PLUS_in_rewrite_ebnf3258); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_PLUS.Add(PLUS175);
+
+
+
+				{
+				// AST REWRITE
+				// elements: b
+				// token labels:
+				// rule labels: b, retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"rule b",b!=null?b.tree:null);
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 739:4: -> ^( POSITIVE_CLOSURE[$b.start,\"+\"] $b)
+				{
+					// Grammars\\ANTLR.g3:739:7: ^( POSITIVE_CLOSURE[$b.start,\"+\"] $b)
+					{
+					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(POSITIVE_CLOSURE, (b!=null?((IToken)b.start):null), "+"), root_1);
+
+					adaptor.AddChild(root_1, stream_b.NextTree());
+
+					adaptor.AddChild(root_0, root_1);
+					}
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+
+			}
+
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_ebnf"
+
+	public class rewrite_tree_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "rewrite_tree"
+	// Grammars\\ANTLR.g3:743:0: rewrite_tree : TREE_BEGIN rewrite_atom ( rewrite_element )* RPAREN ;
+	private ANTLRParser.rewrite_tree_return rewrite_tree(  )
+	{
+		ANTLRParser.rewrite_tree_return retval = new ANTLRParser.rewrite_tree_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken TREE_BEGIN176=null;
+		IToken RPAREN179=null;
+		ANTLRParser.rewrite_atom_return rewrite_atom177 = default(ANTLRParser.rewrite_atom_return);
+		ANTLRParser.rewrite_element_return rewrite_element178 = default(ANTLRParser.rewrite_element_return);
+
+		GrammarAST TREE_BEGIN176_tree=null;
+		GrammarAST RPAREN179_tree=null;
+
+		try
+		{
+			// Grammars\\ANTLR.g3:744:4: ( TREE_BEGIN rewrite_atom ( rewrite_element )* RPAREN )
+			// Grammars\\ANTLR.g3:744:4: TREE_BEGIN rewrite_atom ( rewrite_element )* RPAREN
+			{
+			root_0 = (GrammarAST)adaptor.Nil();
+
+			TREE_BEGIN176=(IToken)Match(input,TREE_BEGIN,Follow._TREE_BEGIN_in_rewrite_tree3286); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) {
+			TREE_BEGIN176_tree = (GrammarAST)adaptor.Create(TREE_BEGIN176);
+			root_0 = (GrammarAST)adaptor.BecomeRoot(TREE_BEGIN176_tree, root_0);
+			}
+			PushFollow(Follow._rewrite_atom_in_rewrite_tree3292);
+			rewrite_atom177=rewrite_atom();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, rewrite_atom177.Tree);
+			// Grammars\\ANTLR.g3:745:17: ( rewrite_element )*
+			for ( ; ; )
+			{
+				int alt93=2;
+				int LA93_0 = input.LA(1);
+
+				if ( (LA93_0==ACTION||LA93_0==CHAR_LITERAL||LA93_0==DOLLAR||LA93_0==LPAREN||LA93_0==RULE_REF||LA93_0==STRING_LITERAL||LA93_0==TOKEN_REF||LA93_0==TREE_BEGIN) )
+				{
+					alt93=1;
+				}
+
+
+				switch ( alt93 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:745:19: rewrite_element
+					{
+					PushFollow(Follow._rewrite_element_in_rewrite_tree3296);
+					rewrite_element178=rewrite_element();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, rewrite_element178.Tree);
+
+					}
+					break;
+
+				default:
+					goto loop93;
+				}
+			}
+
+			loop93:
+				;
+
+
+			RPAREN179=(IToken)Match(input,RPAREN,Follow._RPAREN_in_rewrite_tree3303); if (state.failed) return retval;
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_tree"
+
+	public class rewrite_template_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "rewrite_template"
+	// Grammars\\ANTLR.g3:761:0: public rewrite_template options {k=1; } : ({...}? => ( rewrite_template_head -> rewrite_template_head ) (st= DOUBLE_QUOTE_STRING_LITERAL |st= DOUBLE_ANGLE_STRING_LITERAL ) | rewrite_template_head | rewrite_indirect_template_head | ACTION );
+	public ANTLRParser.rewrite_template_return rewrite_template(  )
+	{
+		ANTLRParser.rewrite_template_return retval = new ANTLRParser.rewrite_template_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken st=null;
+		IToken ACTION183=null;
+		ANTLRParser.rewrite_template_head_return rewrite_template_head180 = default(ANTLRParser.rewrite_template_head_return);
+		ANTLRParser.rewrite_template_head_return rewrite_template_head181 = default(ANTLRParser.rewrite_template_head_return);
+		ANTLRParser.rewrite_indirect_template_head_return rewrite_indirect_template_head182 = default(ANTLRParser.rewrite_indirect_template_head_return);
+
+		GrammarAST st_tree=null;
+		GrammarAST ACTION183_tree=null;
+		RewriteRuleITokenStream stream_DOUBLE_QUOTE_STRING_LITERAL=new RewriteRuleITokenStream(adaptor,"token DOUBLE_QUOTE_STRING_LITERAL");
+		RewriteRuleITokenStream stream_DOUBLE_ANGLE_STRING_LITERAL=new RewriteRuleITokenStream(adaptor,"token DOUBLE_ANGLE_STRING_LITERAL");
+		RewriteRuleSubtreeStream stream_rewrite_template_head=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_template_head");
+		try
+		{
+			// Grammars\\ANTLR.g3:764:3: ({...}? => ( rewrite_template_head -> rewrite_template_head ) (st= DOUBLE_QUOTE_STRING_LITERAL |st= DOUBLE_ANGLE_STRING_LITERAL ) | rewrite_template_head | rewrite_indirect_template_head | ACTION )
+			int alt95=4;
+			switch ( input.LA(1) )
+			{
+			case TOKEN_REF:
+				{
+				int LA95_1 = input.LA(2);
+
+				if ( ((LT(1).Text.Equals("template"))) )
+				{
+					alt95=1;
+				}
+				else if ( (true) )
+				{
+					alt95=2;
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 95, 1, input);
+
+					throw nvae;
+				}
+				}
+				break;
+			case RULE_REF:
+				{
+				int LA95_2 = input.LA(2);
+
+				if ( ((LT(1).Text.Equals("template"))) )
+				{
+					alt95=1;
+				}
+				else if ( (true) )
+				{
+					alt95=2;
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 95, 2, input);
+
+					throw nvae;
+				}
+				}
+				break;
+			case LPAREN:
+				{
+				alt95=3;
+				}
+				break;
+			case ACTION:
+				{
+				alt95=4;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 95, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt95 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:764:3: {...}? => ( rewrite_template_head -> rewrite_template_head ) (st= DOUBLE_QUOTE_STRING_LITERAL |st= DOUBLE_ANGLE_STRING_LITERAL )
+				{
+				if ( !((LT(1).Text.Equals("template"))) )
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					throw new FailedPredicateException(input, "rewrite_template", "LT(1).Text.Equals(\"template\")");
+				}
+				// Grammars\\ANTLR.g3:765:3: ( rewrite_template_head -> rewrite_template_head )
+				// Grammars\\ANTLR.g3:765:5: rewrite_template_head
+				{
+				PushFollow(Follow._rewrite_template_head_in_rewrite_template3338);
+				rewrite_template_head180=rewrite_template_head();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_rewrite_template_head.Add(rewrite_template_head180.Tree);
+
+
+				{
+				// AST REWRITE
+				// elements: rewrite_template_head
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 766:4: -> rewrite_template_head
+				{
+					adaptor.AddChild(root_0, stream_rewrite_template_head.NextTree());
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+
+				// Grammars\\ANTLR.g3:768:3: (st= DOUBLE_QUOTE_STRING_LITERAL |st= DOUBLE_ANGLE_STRING_LITERAL )
+				int alt94=2;
+				int LA94_0 = input.LA(1);
+
+				if ( (LA94_0==DOUBLE_QUOTE_STRING_LITERAL) )
+				{
+					alt94=1;
+				}
+				else if ( (LA94_0==DOUBLE_ANGLE_STRING_LITERAL) )
+				{
+					alt94=2;
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 94, 0, input);
+
+					throw nvae;
+				}
+				switch ( alt94 )
+				{
+				case 1:
+					// Grammars\\ANTLR.g3:768:5: st= DOUBLE_QUOTE_STRING_LITERAL
+					{
+					st=(IToken)Match(input,DOUBLE_QUOTE_STRING_LITERAL,Follow._DOUBLE_QUOTE_STRING_LITERAL_in_rewrite_template3357); if (state.failed) return retval;
+					if ( state.backtracking == 0 ) stream_DOUBLE_QUOTE_STRING_LITERAL.Add(st);
+
+
+					}
+					break;
+				case 2:
+					// Grammars\\ANTLR.g3:768:38: st= DOUBLE_ANGLE_STRING_LITERAL
+					{
+					st=(IToken)Match(input,DOUBLE_ANGLE_STRING_LITERAL,Follow._DOUBLE_ANGLE_STRING_LITERAL_in_rewrite_template3363); if (state.failed) return retval;
+					if ( state.backtracking == 0 ) stream_DOUBLE_ANGLE_STRING_LITERAL.Add(st);
+
+
+					}
+					break;
+
+				}
+
+				if ( state.backtracking == 0 )
+				{
+					 adaptor.AddChild( ((GrammarAST)retval.tree).GetChild(0), adaptor.Create(st) );
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:772:3: rewrite_template_head
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				PushFollow(Follow._rewrite_template_head_in_rewrite_template3378);
+				rewrite_template_head181=rewrite_template_head();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, rewrite_template_head181.Tree);
+
+				}
+				break;
+			case 3:
+				// Grammars\\ANTLR.g3:775:3: rewrite_indirect_template_head
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				PushFollow(Follow._rewrite_indirect_template_head_in_rewrite_template3387);
+				rewrite_indirect_template_head182=rewrite_indirect_template_head();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, rewrite_indirect_template_head182.Tree);
+
+				}
+				break;
+			case 4:
+				// Grammars\\ANTLR.g3:778:3: ACTION
+				{
+				root_0 = (GrammarAST)adaptor.Nil();
+
+				ACTION183=(IToken)Match(input,ACTION,Follow._ACTION_in_rewrite_template3396); if (state.failed) return retval;
+				if ( state.backtracking==0 ) {
+				ACTION183_tree = (GrammarAST)adaptor.Create(ACTION183);
+				adaptor.AddChild(root_0, ACTION183_tree);
+				}
+
+				}
+				break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_template"
+
+	public class rewrite_template_head_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "rewrite_template_head"
+	// Grammars\\ANTLR.g3:782:0: rewrite_template_head : id lp= LPAREN rewrite_template_args RPAREN -> ^( TEMPLATE[$lp,\"TEMPLATE\"] id rewrite_template_args ) ;
+	private ANTLRParser.rewrite_template_head_return rewrite_template_head(  )
+	{
+		ANTLRParser.rewrite_template_head_return retval = new ANTLRParser.rewrite_template_head_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken lp=null;
+		IToken RPAREN186=null;
+		ANTLRParser.id_return id184 = default(ANTLRParser.id_return);
+		ANTLRParser.rewrite_template_args_return rewrite_template_args185 = default(ANTLRParser.rewrite_template_args_return);
+
+		GrammarAST lp_tree=null;
+		GrammarAST RPAREN186_tree=null;
+		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
+		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
+		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
+		RewriteRuleSubtreeStream stream_rewrite_template_args=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_template_args");
+		try
+		{
+			// Grammars\\ANTLR.g3:783:4: ( id lp= LPAREN rewrite_template_args RPAREN -> ^( TEMPLATE[$lp,\"TEMPLATE\"] id rewrite_template_args ) )
+			// Grammars\\ANTLR.g3:783:4: id lp= LPAREN rewrite_template_args RPAREN
+			{
+			PushFollow(Follow._id_in_rewrite_template_head3409);
+			id184=id();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_id.Add(id184.Tree);
+			lp=(IToken)Match(input,LPAREN,Follow._LPAREN_in_rewrite_template_head3413); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_LPAREN.Add(lp);
+
+			PushFollow(Follow._rewrite_template_args_in_rewrite_template_head3417);
+			rewrite_template_args185=rewrite_template_args();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_rewrite_template_args.Add(rewrite_template_args185.Tree);
+			RPAREN186=(IToken)Match(input,RPAREN,Follow._RPAREN_in_rewrite_template_head3421); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_RPAREN.Add(RPAREN186);
+
+
+
+			{
+			// AST REWRITE
+			// elements: id, rewrite_template_args
+			// token labels:
+			// rule labels: retval
+			// token list labels:
+			// rule list labels:
+			// wildcard labels:
+			if ( state.backtracking == 0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+			root_0 = (GrammarAST)adaptor.Nil();
+			// 786:3: -> ^( TEMPLATE[$lp,\"TEMPLATE\"] id rewrite_template_args )
+			{
+				// Grammars\\ANTLR.g3:786:6: ^( TEMPLATE[$lp,\"TEMPLATE\"] id rewrite_template_args )
+				{
+				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+				root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(TEMPLATE, lp, "TEMPLATE"), root_1);
+
+				adaptor.AddChild(root_1, stream_id.NextTree());
+				adaptor.AddChild(root_1, stream_rewrite_template_args.NextTree());
+
+				adaptor.AddChild(root_0, root_1);
+				}
+
+			}
+
+			retval.tree = root_0;
+			}
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_template_head"
+
+	public class rewrite_indirect_template_head_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "rewrite_indirect_template_head"
+	// Grammars\\ANTLR.g3:790:0: rewrite_indirect_template_head : lp= LPAREN ACTION RPAREN LPAREN rewrite_template_args RPAREN -> ^( TEMPLATE[$lp,\"TEMPLATE\"] ACTION rewrite_template_args ) ;
+	private ANTLRParser.rewrite_indirect_template_head_return rewrite_indirect_template_head(  )
+	{
+		ANTLRParser.rewrite_indirect_template_head_return retval = new ANTLRParser.rewrite_indirect_template_head_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken lp=null;
+		IToken ACTION187=null;
+		IToken RPAREN188=null;
+		IToken LPAREN189=null;
+		IToken RPAREN191=null;
+		ANTLRParser.rewrite_template_args_return rewrite_template_args190 = default(ANTLRParser.rewrite_template_args_return);
+
+		GrammarAST lp_tree=null;
+		GrammarAST ACTION187_tree=null;
+		GrammarAST RPAREN188_tree=null;
+		GrammarAST LPAREN189_tree=null;
+		GrammarAST RPAREN191_tree=null;
+		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
+		RewriteRuleITokenStream stream_ACTION=new RewriteRuleITokenStream(adaptor,"token ACTION");
+		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
+		RewriteRuleSubtreeStream stream_rewrite_template_args=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_template_args");
+		try
+		{
+			// Grammars\\ANTLR.g3:791:4: (lp= LPAREN ACTION RPAREN LPAREN rewrite_template_args RPAREN -> ^( TEMPLATE[$lp,\"TEMPLATE\"] ACTION rewrite_template_args ) )
+			// Grammars\\ANTLR.g3:791:4: lp= LPAREN ACTION RPAREN LPAREN rewrite_template_args RPAREN
+			{
+			lp=(IToken)Match(input,LPAREN,Follow._LPAREN_in_rewrite_indirect_template_head3449); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_LPAREN.Add(lp);
+
+			ACTION187=(IToken)Match(input,ACTION,Follow._ACTION_in_rewrite_indirect_template_head3453); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_ACTION.Add(ACTION187);
+
+			RPAREN188=(IToken)Match(input,RPAREN,Follow._RPAREN_in_rewrite_indirect_template_head3457); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_RPAREN.Add(RPAREN188);
+
+			LPAREN189=(IToken)Match(input,LPAREN,Follow._LPAREN_in_rewrite_indirect_template_head3461); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_LPAREN.Add(LPAREN189);
+
+			PushFollow(Follow._rewrite_template_args_in_rewrite_indirect_template_head3463);
+			rewrite_template_args190=rewrite_template_args();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_rewrite_template_args.Add(rewrite_template_args190.Tree);
+			RPAREN191=(IToken)Match(input,RPAREN,Follow._RPAREN_in_rewrite_indirect_template_head3465); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_RPAREN.Add(RPAREN191);
+
+
+
+			{
+			// AST REWRITE
+			// elements: ACTION, rewrite_template_args
+			// token labels:
+			// rule labels: retval
+			// token list labels:
+			// rule list labels:
+			// wildcard labels:
+			if ( state.backtracking == 0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+			root_0 = (GrammarAST)adaptor.Nil();
+			// 795:3: -> ^( TEMPLATE[$lp,\"TEMPLATE\"] ACTION rewrite_template_args )
+			{
+				// Grammars\\ANTLR.g3:795:6: ^( TEMPLATE[$lp,\"TEMPLATE\"] ACTION rewrite_template_args )
+				{
+				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+				root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(TEMPLATE, lp, "TEMPLATE"), root_1);
+
+				adaptor.AddChild(root_1, stream_ACTION.NextNode());
+				adaptor.AddChild(root_1, stream_rewrite_template_args.NextTree());
+
+				adaptor.AddChild(root_0, root_1);
+				}
+
+			}
+
+			retval.tree = root_0;
+			}
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_indirect_template_head"
+
+	public class rewrite_template_args_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "rewrite_template_args"
+	// Grammars\\ANTLR.g3:798:0: rewrite_template_args : ( rewrite_template_arg ( COMMA rewrite_template_arg )* -> ^( ARGLIST[\"ARGLIST\"] ( rewrite_template_arg )+ ) | -> ARGLIST[\"ARGLIST\"] );
+	private ANTLRParser.rewrite_template_args_return rewrite_template_args(  )
+	{
+		ANTLRParser.rewrite_template_args_return retval = new ANTLRParser.rewrite_template_args_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken COMMA193=null;
+		ANTLRParser.rewrite_template_arg_return rewrite_template_arg192 = default(ANTLRParser.rewrite_template_arg_return);
+		ANTLRParser.rewrite_template_arg_return rewrite_template_arg194 = default(ANTLRParser.rewrite_template_arg_return);
+
+		GrammarAST COMMA193_tree=null;
+		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
+		RewriteRuleSubtreeStream stream_rewrite_template_arg=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_template_arg");
+		try
+		{
+			// Grammars\\ANTLR.g3:799:4: ( rewrite_template_arg ( COMMA rewrite_template_arg )* -> ^( ARGLIST[\"ARGLIST\"] ( rewrite_template_arg )+ ) | -> ARGLIST[\"ARGLIST\"] )
+			int alt97=2;
+			int LA97_0 = input.LA(1);
+
+			if ( (LA97_0==RULE_REF||LA97_0==TOKEN_REF) )
+			{
+				alt97=1;
+			}
+			else if ( (LA97_0==RPAREN) )
+			{
+				alt97=2;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae = new NoViableAltException("", 97, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt97 )
+			{
+			case 1:
+				// Grammars\\ANTLR.g3:799:4: rewrite_template_arg ( COMMA rewrite_template_arg )*
+				{
+				PushFollow(Follow._rewrite_template_arg_in_rewrite_template_args3489);
+				rewrite_template_arg192=rewrite_template_arg();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_rewrite_template_arg.Add(rewrite_template_arg192.Tree);
+				// Grammars\\ANTLR.g3:799:25: ( COMMA rewrite_template_arg )*
+				for ( ; ; )
+				{
+					int alt96=2;
+					int LA96_0 = input.LA(1);
+
+					if ( (LA96_0==COMMA) )
+					{
+						alt96=1;
+					}
+
+
+					switch ( alt96 )
+					{
+					case 1:
+						// Grammars\\ANTLR.g3:799:26: COMMA rewrite_template_arg
+						{
+						COMMA193=(IToken)Match(input,COMMA,Follow._COMMA_in_rewrite_template_args3492); if (state.failed) return retval;
+						if ( state.backtracking == 0 ) stream_COMMA.Add(COMMA193);
+
+						PushFollow(Follow._rewrite_template_arg_in_rewrite_template_args3494);
+						rewrite_template_arg194=rewrite_template_arg();
+
+						state._fsp--;
+						if (state.failed) return retval;
+						if ( state.backtracking == 0 ) stream_rewrite_template_arg.Add(rewrite_template_arg194.Tree);
+
+						}
+						break;
+
+					default:
+						goto loop96;
+					}
+				}
+
+				loop96:
+					;
+
+
+
+
+				{
+				// AST REWRITE
+				// elements: rewrite_template_arg
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 800:3: -> ^( ARGLIST[\"ARGLIST\"] ( rewrite_template_arg )+ )
+				{
+					// Grammars\\ANTLR.g3:800:6: ^( ARGLIST[\"ARGLIST\"] ( rewrite_template_arg )+ )
+					{
+					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(ARGLIST, "ARGLIST"), root_1);
+
+					if ( !(stream_rewrite_template_arg.HasNext) )
+					{
+						throw new RewriteEarlyExitException();
+					}
+					while ( stream_rewrite_template_arg.HasNext )
+					{
+						adaptor.AddChild(root_1, stream_rewrite_template_arg.NextTree());
+
+					}
+					stream_rewrite_template_arg.Reset();
+
+					adaptor.AddChild(root_0, root_1);
+					}
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLR.g3:802:3:
+				{
+
+
+
+				{
+				// AST REWRITE
+				// elements:
+				// token labels:
+				// rule labels: retval
+				// token list labels:
+				// rule list labels:
+				// wildcard labels:
+				if ( state.backtracking == 0 ) {
+				retval.tree = root_0;
+				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+				root_0 = (GrammarAST)adaptor.Nil();
+				// 802:3: -> ARGLIST[\"ARGLIST\"]
+				{
+					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(ARGLIST, "ARGLIST"));
+
+				}
+
+				retval.tree = root_0;
+				}
+				}
+
+				}
+				break;
+
+			}
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_template_args"
+
+	public class rewrite_template_arg_return : ParserRuleReturnScope
+	{
+		public GrammarAST tree;
+		public override object Tree { get { return tree; } }
+	}
+
+	// $ANTLR start "rewrite_template_arg"
+	// Grammars\\ANTLR.g3:805:0: rewrite_template_arg : id a= ASSIGN ACTION -> ^( ARG[$a,\"ARG\"] id ACTION ) ;
+	private ANTLRParser.rewrite_template_arg_return rewrite_template_arg(  )
+	{
+		ANTLRParser.rewrite_template_arg_return retval = new ANTLRParser.rewrite_template_arg_return();
+		retval.start = input.LT(1);
+
+		GrammarAST root_0 = null;
+
+		IToken a=null;
+		IToken ACTION196=null;
+		ANTLRParser.id_return id195 = default(ANTLRParser.id_return);
+
+		GrammarAST a_tree=null;
+		GrammarAST ACTION196_tree=null;
+		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
+		RewriteRuleITokenStream stream_ACTION=new RewriteRuleITokenStream(adaptor,"token ACTION");
+		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
+		try
+		{
+			// Grammars\\ANTLR.g3:806:4: ( id a= ASSIGN ACTION -> ^( ARG[$a,\"ARG\"] id ACTION ) )
+			// Grammars\\ANTLR.g3:806:4: id a= ASSIGN ACTION
+			{
+			PushFollow(Follow._id_in_rewrite_template_arg3529);
+			id195=id();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_id.Add(id195.Tree);
+			a=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_rewrite_template_arg3533); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_ASSIGN.Add(a);
+
+			ACTION196=(IToken)Match(input,ACTION,Follow._ACTION_in_rewrite_template_arg3535); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_ACTION.Add(ACTION196);
+
+
+
+			{
+			// AST REWRITE
+			// elements: id, ACTION
+			// token labels:
+			// rule labels: retval
+			// token list labels:
+			// rule list labels:
+			// wildcard labels:
+			if ( state.backtracking == 0 ) {
+			retval.tree = root_0;
+			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+
+			root_0 = (GrammarAST)adaptor.Nil();
+			// 807:3: -> ^( ARG[$a,\"ARG\"] id ACTION )
+			{
+				// Grammars\\ANTLR.g3:807:6: ^( ARG[$a,\"ARG\"] id ACTION )
+				{
+				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
+				root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(ARG, a, "ARG"), root_1);
+
+				adaptor.AddChild(root_1, stream_id.NextTree());
+				adaptor.AddChild(root_1, stream_ACTION.NextNode());
+
+				adaptor.AddChild(root_0, root_1);
+				}
+
+			}
+
+			retval.tree = root_0;
+			}
+			}
+
+			}
+
+			retval.stop = input.LT(-1);
+
+			if ( state.backtracking == 0 ) {
+
+			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
+			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
+
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_template_arg"
+
+	// $ANTLR start synpred1_ANTLR
+	public void synpred1_ANTLR_fragment()
+	{
+		// Grammars\\ANTLR.g3:505:4: ({...}? id WILDCARD ( terminal | ruleref ) )
+		// Grammars\\ANTLR.g3:505:5: {...}? id WILDCARD ( terminal | ruleref )
+		{
+		if ( !((LT(1).CharPositionInLine+LT(1).Text.Length==LT(2).CharPositionInLine&&
+					 LT(2).CharPositionInLine+1==LT(3).CharPositionInLine)) )
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			throw new FailedPredicateException(input, "synpred1_ANTLR", "LT(1).CharPositionInLine+LT(1).Text.Length==LT(2).CharPositionInLine&&\n\t\t\t LT(2).CharPositionInLine+1==LT(3).CharPositionInLine");
+		}
+		PushFollow(Follow._id_in_synpred1_ANTLR1964);
+		id();
+
+		state._fsp--;
+		if (state.failed) return ;
+		Match(input,WILDCARD,Follow._WILDCARD_in_synpred1_ANTLR1966); if (state.failed) return ;
+		// Grammars\\ANTLR.g3:506:72: ( terminal | ruleref )
+		int alt98=2;
+		int LA98_0 = input.LA(1);
+
+		if ( (LA98_0==CHAR_LITERAL||LA98_0==STRING_LITERAL||LA98_0==TOKEN_REF||LA98_0==WILDCARD) )
+		{
+			alt98=1;
+		}
+		else if ( (LA98_0==RULE_REF) )
+		{
+			alt98=2;
+		}
+		else
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			NoViableAltException nvae = new NoViableAltException("", 98, 0, input);
+
+			throw nvae;
+		}
+		switch ( alt98 )
+		{
+		case 1:
+			// Grammars\\ANTLR.g3:506:73: terminal
+			{
+			PushFollow(Follow._terminal_in_synpred1_ANTLR1969);
+			terminal();
+
+			state._fsp--;
+			if (state.failed) return ;
+
+			}
+			break;
+		case 2:
+			// Grammars\\ANTLR.g3:506:82: ruleref
+			{
+			PushFollow(Follow._ruleref_in_synpred1_ANTLR1971);
+			ruleref();
+
+			state._fsp--;
+			if (state.failed) return ;
+
+			}
+			break;
+
+		}
+
+
+		}
+	}
+	// $ANTLR end synpred1_ANTLR
+	#endregion
+
+	// Delegated rules
+
+	#region Synpreds
+	public bool synpred1_ANTLR()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred1_ANTLR_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+
+	#endregion
+
+	#region DFA
+	DFA49 dfa49;
+	DFA52 dfa52;
+	DFA83 dfa83;
+
+	protected override void InitDFAs()
+	{
+		base.InitDFAs();
+		dfa49 = new DFA49( this );
+		dfa52 = new DFA52( this, new SpecialStateTransitionHandler( specialStateTransition52 ) );
+		dfa83 = new DFA83( this, new SpecialStateTransitionHandler( specialStateTransition83 ) );
+	}
+
+	class DFA49 : DFA
+	{
+
+		const string DFA49_eotS =
+			"\xA\xFFFF";
+		const string DFA49_eofS =
+			"\xA\xFFFF";
+		const string DFA49_minS =
+			"\x3\x4\x7\xFFFF";
+		const string DFA49_maxS =
+			"\x3\x5F\x7\xFFFF";
+		const string DFA49_acceptS =
+			"\x3\xFFFF\x1\x2\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x1";
+		const string DFA49_specialS =
+			"\xA\xFFFF}>";
+		static readonly string[] DFA49_transitionS =
+			{
+				"\x1\x6\xD\xFFFF\x1\x3\x14\xFFFF\x1\x5\xB\xFFFF\x1\x4\x3\xFFFF\x1\x3"+
+				"\x15\xFFFF\x1\x2\x2\xFFFF\x1\x7\x4\xFFFF\x1\x3\x4\xFFFF\x1\x1\x2\xFFFF"+
+				"\x1\x8\x1\xFFFF\x1\x3",
+				"\x1\x3\x6\xFFFF\x1\x3\x1\xFFFF\x1\x9\x1\xFFFF\x1\x3\x2\xFFFF\x1\x3\x14"+
+				"\xFFFF\x1\x3\xB\xFFFF\x1\x3\x3\xFFFF\x2\x3\x2\xFFFF\x1\x3\x2\xFFFF\x1"+
+				"\x3\x1\x9\x4\xFFFF\x1\x3\x4\xFFFF\x3\x3\x1\xFFFF\x1\x3\x1\xFFFF\x2\x3"+
+				"\x2\xFFFF\x1\x3\x1\xFFFF\x1\x3\x4\xFFFF\x1\x3\x2\xFFFF\x1\x3\x1\xFFFF"+
+				"\x1\x3",
+				"\x1\x3\x6\xFFFF\x1\x3\x1\xFFFF\x1\x9\x1\xFFFF\x1\x3\x2\xFFFF\x1\x3\x14"+
+				"\xFFFF\x1\x3\xB\xFFFF\x1\x3\x3\xFFFF\x1\x3\x3\xFFFF\x1\x3\x2\xFFFF\x1"+
+				"\x3\x1\x9\x4\xFFFF\x1\x3\x4\xFFFF\x3\x3\x1\xFFFF\x1\x3\x1\xFFFF\x2\x3"+
+				"\x2\xFFFF\x1\x3\x1\xFFFF\x1\x3\x4\xFFFF\x1\x3\x2\xFFFF\x1\x3\x1\xFFFF"+
+				"\x1\x3",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				""
+			};
+
+		static readonly short[] DFA49_eot = DFA.UnpackEncodedString(DFA49_eotS);
+		static readonly short[] DFA49_eof = DFA.UnpackEncodedString(DFA49_eofS);
+		static readonly char[] DFA49_min = DFA.UnpackEncodedStringToUnsignedChars(DFA49_minS);
+		static readonly char[] DFA49_max = DFA.UnpackEncodedStringToUnsignedChars(DFA49_maxS);
+		static readonly short[] DFA49_accept = DFA.UnpackEncodedString(DFA49_acceptS);
+		static readonly short[] DFA49_special = DFA.UnpackEncodedString(DFA49_specialS);
+		static readonly short[][] DFA49_transition;
+
+		static DFA49()
+		{
+			int numStates = DFA49_transitionS.Length;
+			DFA49_transition = new short[numStates][];
+			for ( int i=0; i < numStates; i++ )
+			{
+				DFA49_transition[i] = DFA.UnpackEncodedString(DFA49_transitionS[i]);
+			}
+		}
+
+		public DFA49( BaseRecognizer recognizer )
+		{
+			this.recognizer = recognizer;
+			this.decisionNumber = 49;
+			this.eot = DFA49_eot;
+			this.eof = DFA49_eof;
+			this.min = DFA49_min;
+			this.max = DFA49_max;
+			this.accept = DFA49_accept;
+			this.special = DFA49_special;
+			this.transition = DFA49_transition;
+		}
+		public override string GetDescription()
+		{
+			return "482:4: ( ( id ( ASSIGN | PLUS_ASSIGN ) ( atom | block ) ) (sub= ebnfSuffix[root_0,false] )? |a= atom (sub2= ebnfSuffix[$a.tree,false] )? | ebnf | FORCED_ACTION | ACTION |p= SEMPRED ( IMPLIES )? |t3= tree_ )";
+		}
+	}
+
+	class DFA52 : DFA
+	{
+
+		const string DFA52_eotS =
+			"\x12\xFFFF";
+		const string DFA52_eofS =
+			"\x12\xFFFF";
+		const string DFA52_minS =
+			"\x1\x12\x2\x4\x1\xFFFF\x2\x4\x1\xFFFF\xA\x0\x1\xFFFF";
+		const string DFA52_maxS =
+			"\x3\x5F\x1\xFFFF\x2\x5F\x1\xFFFF\xA\x0\x1\xFFFF";
+		const string DFA52_acceptS =
+			"\x3\xFFFF\x1\x2\x2\xFFFF\x1\x3\xA\xFFFF\x1\x1";
+		const string DFA52_specialS =
+			"\x7\xFFFF\x1\x0\x1\x1\x1\x2\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9"+
+			"\x1\xFFFF}>";
+		static readonly string[] DFA52_transitionS =
+			{
+				"\x1\x3\x3A\xFFFF\x1\x2\x7\xFFFF\x1\x3\x4\xFFFF\x1\x1\x4\xFFFF\x1\x3",
+				"\x1\x3\x6\xFFFF\x1\x3\x3\xFFFF\x1\x3\x2\xFFFF\x1\x3\x14\xFFFF\x1\x3"+
+				"\xB\xFFFF\x1\x3\x3\xFFFF\x2\x3\x2\xFFFF\x1\x3\x2\xFFFF\x1\x3\x5\xFFFF"+
+				"\x1\x3\x4\xFFFF\x3\x3\x1\xFFFF\x1\x3\x1\xFFFF\x2\x3\x2\xFFFF\x1\x3\x1"+
+				"\xFFFF\x1\x3\x4\xFFFF\x1\x3\x2\xFFFF\x1\x3\x1\xFFFF\x1\x4",
+				"\x1\x6\x6\xFFFF\x1\x6\x3\xFFFF\x1\x6\x2\xFFFF\x1\x6\x14\xFFFF\x1\x6"+
+				"\xB\xFFFF\x1\x6\x3\xFFFF\x1\x6\x3\xFFFF\x1\x6\x2\xFFFF\x1\x6\x5\xFFFF"+
+				"\x1\x6\x4\xFFFF\x3\x6\x1\xFFFF\x1\x6\x1\xFFFF\x2\x6\x2\xFFFF\x1\x6\x1"+
+				"\xFFFF\x1\x6\x4\xFFFF\x1\x6\x2\xFFFF\x1\x6\x1\xFFFF\x1\x5",
+				"",
+				"\x1\x3\xA\xFFFF\x1\x3\x2\xFFFF\x1\x7\x14\xFFFF\x1\x3\xB\xFFFF\x1\x3"+
+				"\x3\xFFFF\x1\x3\x3\xFFFF\x1\x3\x2\xFFFF\x1\x3\x5\xFFFF\x1\x3\x4\xFFFF"+
+				"\x3\x3\x1\xFFFF\x1\xB\x1\xFFFF\x2\x3\x2\xFFFF\x1\x3\x1\xFFFF\x1\x9\x4"+
+				"\xFFFF\x1\x8\x2\xFFFF\x1\x3\x1\xFFFF\x1\xA",
+				"\x1\x6\xA\xFFFF\x1\x6\x2\xFFFF\x1\xC\x14\xFFFF\x1\x6\xB\xFFFF\x1\x6"+
+				"\x3\xFFFF\x1\x6\x3\xFFFF\x1\x6\x2\xFFFF\x1\x6\x5\xFFFF\x1\x6\x4\xFFFF"+
+				"\x3\x6\x1\xFFFF\x1\x10\x1\xFFFF\x2\x6\x2\xFFFF\x1\x6\x1\xFFFF\x1\xE"+
+				"\x4\xFFFF\x1\xD\x2\xFFFF\x1\x6\x1\xFFFF\x1\xF",
+				"",
+				"\x1\xFFFF",
+				"\x1\xFFFF",
+				"\x1\xFFFF",
+				"\x1\xFFFF",
+				"\x1\xFFFF",
+				"\x1\xFFFF",
+				"\x1\xFFFF",
+				"\x1\xFFFF",
+				"\x1\xFFFF",
+				"\x1\xFFFF",
+				""
+			};
+
+		static readonly short[] DFA52_eot = DFA.UnpackEncodedString(DFA52_eotS);
+		static readonly short[] DFA52_eof = DFA.UnpackEncodedString(DFA52_eofS);
+		static readonly char[] DFA52_min = DFA.UnpackEncodedStringToUnsignedChars(DFA52_minS);
+		static readonly char[] DFA52_max = DFA.UnpackEncodedStringToUnsignedChars(DFA52_maxS);
+		static readonly short[] DFA52_accept = DFA.UnpackEncodedString(DFA52_acceptS);
+		static readonly short[] DFA52_special = DFA.UnpackEncodedString(DFA52_specialS);
+		static readonly short[][] DFA52_transition;
+
+		static DFA52()
+		{
+			int numStates = DFA52_transitionS.Length;
+			DFA52_transition = new short[numStates][];
+			for ( int i=0; i < numStates; i++ )
+			{
+				DFA52_transition[i] = DFA.UnpackEncodedString(DFA52_transitionS[i]);
+			}
+		}
+
+		public DFA52( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
+			: base( specialStateTransition )	{
+			this.recognizer = recognizer;
+			this.decisionNumber = 52;
+			this.eot = DFA52_eot;
+			this.eof = DFA52_eof;
+			this.min = DFA52_min;
+			this.max = DFA52_max;
+			this.accept = DFA52_accept;
+			this.special = DFA52_special;
+			this.transition = DFA52_transition;
+		}
+		public override string GetDescription()
+		{
+			return "502:4: (=> id w= WILDCARD ( terminal | ruleref ) | terminal | ruleref )";
+		}
+	}
+
+	int specialStateTransition52( DFA dfa, int s, IIntStream _input )
+	{
+		ITokenStream input = (ITokenStream)_input;
+		int _s = s;
+		switch ( s )
+		{
+
+			case 0:
+				int LA52_7 = input.LA(1);
+
+
+				int index52_7 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred1_ANTLR()) ) {s = 17;}
+
+				else if ( (true) ) {s = 3;}
+
+
+				input.Seek(index52_7);
+				if ( s>=0 ) return s;
+				break;
+
+			case 1:
+				int LA52_8 = input.LA(1);
+
+
+				int index52_8 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred1_ANTLR()) ) {s = 17;}
+
+				else if ( (true) ) {s = 3;}
+
+
+				input.Seek(index52_8);
+				if ( s>=0 ) return s;
+				break;
+
+			case 2:
+				int LA52_9 = input.LA(1);
+
+
+				int index52_9 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred1_ANTLR()) ) {s = 17;}
+
+				else if ( (true) ) {s = 3;}
+
+
+				input.Seek(index52_9);
+				if ( s>=0 ) return s;
+				break;
+
+			case 3:
+				int LA52_10 = input.LA(1);
+
+
+				int index52_10 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred1_ANTLR()) ) {s = 17;}
+
+				else if ( (true) ) {s = 3;}
+
+
+				input.Seek(index52_10);
+				if ( s>=0 ) return s;
+				break;
+
+			case 4:
+				int LA52_11 = input.LA(1);
+
+
+				int index52_11 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred1_ANTLR()) ) {s = 17;}
+
+				else if ( (true) ) {s = 3;}
+
+
+				input.Seek(index52_11);
+				if ( s>=0 ) return s;
+				break;
+
+			case 5:
+				int LA52_12 = input.LA(1);
+
+
+				int index52_12 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred1_ANTLR()) ) {s = 17;}
+
+				else if ( (true) ) {s = 6;}
+
+
+				input.Seek(index52_12);
+				if ( s>=0 ) return s;
+				break;
+
+			case 6:
+				int LA52_13 = input.LA(1);
+
+
+				int index52_13 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred1_ANTLR()) ) {s = 17;}
+
+				else if ( (true) ) {s = 6;}
+
+
+				input.Seek(index52_13);
+				if ( s>=0 ) return s;
+				break;
+
+			case 7:
+				int LA52_14 = input.LA(1);
+
+
+				int index52_14 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred1_ANTLR()) ) {s = 17;}
+
+				else if ( (true) ) {s = 6;}
+
+
+				input.Seek(index52_14);
+				if ( s>=0 ) return s;
+				break;
+
+			case 8:
+				int LA52_15 = input.LA(1);
+
+
+				int index52_15 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred1_ANTLR()) ) {s = 17;}
+
+				else if ( (true) ) {s = 6;}
+
+
+				input.Seek(index52_15);
+				if ( s>=0 ) return s;
+				break;
+
+			case 9:
+				int LA52_16 = input.LA(1);
+
+
+				int index52_16 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred1_ANTLR()) ) {s = 17;}
+
+				else if ( (true) ) {s = 6;}
+
+
+				input.Seek(index52_16);
+				if ( s>=0 ) return s;
+				break;
+		}
+		if (state.backtracking>0) {state.failed=true; return -1;}
+		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 52, _s, input);
+		dfa.Error(nvae);
+		throw nvae;
+	}
+	class DFA83 : DFA
+	{
+
+		const string DFA83_eotS =
+			"\xF\xFFFF";
+		const string DFA83_eofS =
+			"\xF\xFFFF";
+		const string DFA83_minS =
+			"\x1\x4\x4\x0\xA\xFFFF";
+		const string DFA83_maxS =
+			"\x1\x5D\x4\x0\xA\xFFFF";
+		const string DFA83_acceptS =
+			"\x5\xFFFF\x1\x2\x3\xFFFF\x1\x3\x3\xFFFF\x1\x4\x1\x1";
+		const string DFA83_specialS =
+			"\x1\x0\x1\x1\x1\x2\x1\x3\x1\x4\xA\xFFFF}>";
+		static readonly string[] DFA83_transitionS =
+			{
+				"\x1\x4\xD\xFFFF\x1\x5\x9\xFFFF\x1\x5\x8\xFFFF\x1\xD\xD\xFFFF\x1\x3\x7"+
+				"\xFFFF\x1\x9\xD\xFFFF\x1\x9\x1\xFFFF\x1\x9\x1\xFFFF\x1\x2\x1\xFFFF\x1"+
+				"\x9\x5\xFFFF\x1\x5\x4\xFFFF\x1\x1\x2\xFFFF\x1\x5",
+				"\x1\xFFFF",
+				"\x1\xFFFF",
+				"\x1\xFFFF",
+				"\x1\xFFFF",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				""
+			};
+
+		static readonly short[] DFA83_eot = DFA.UnpackEncodedString(DFA83_eotS);
+		static readonly short[] DFA83_eof = DFA.UnpackEncodedString(DFA83_eofS);
+		static readonly char[] DFA83_min = DFA.UnpackEncodedStringToUnsignedChars(DFA83_minS);
+		static readonly char[] DFA83_max = DFA.UnpackEncodedStringToUnsignedChars(DFA83_maxS);
+		static readonly short[] DFA83_accept = DFA.UnpackEncodedString(DFA83_acceptS);
+		static readonly short[] DFA83_special = DFA.UnpackEncodedString(DFA83_specialS);
+		static readonly short[][] DFA83_transition;
+
+		static DFA83()
+		{
+			int numStates = DFA83_transitionS.Length;
+			DFA83_transition = new short[numStates][];
+			for ( int i=0; i < numStates; i++ )
+			{
+				DFA83_transition[i] = DFA.UnpackEncodedString(DFA83_transitionS[i]);
+			}
+		}
+
+		public DFA83( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
+			: base( specialStateTransition )	{
+			this.recognizer = recognizer;
+			this.decisionNumber = 83;
+			this.eot = DFA83_eot;
+			this.eof = DFA83_eof;
+			this.min = DFA83_min;
+			this.max = DFA83_max;
+			this.accept = DFA83_accept;
+			this.special = DFA83_special;
+			this.transition = DFA83_transition;
+		}
+		public override string GetDescription()
+		{
+			return "679:0: rewrite_alternative options {k=1; } : ({...}? => rewrite_template |{...}? => ( rewrite_element )+ -> {!stream_rewrite_element.HasNext}? ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] ) -> ^( ALT[LT(1),\"ALT\"] ( rewrite_element )+ EOA[\"<end-of-alt>\"] ) | -> ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] ) |{...}? ETC );";
+		}
+	}
+
+	int specialStateTransition83( DFA dfa, int s, IIntStream _input )
+	{
+		ITokenStream input = (ITokenStream)_input;
+		int _s = s;
+		switch ( s )
+		{
+
+			case 0:
+				int LA83_0 = input.LA(1);
+
+
+				int index83_0 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (LA83_0==TOKEN_REF) && ((((Grammar.BuildTemplate)&&(LT(1).Text.Equals("template")))||(Grammar.BuildTemplate)||(Grammar.BuildAST)||((Grammar.BuildTemplate)&&(LT(1).Text.Equals("template")))||((Grammar.BuildTemplate)&&(LT(1).Text.Equals("template")))||((Grammar.BuildTemplate)&&(LT(1).Text.Equals("template")))))) {s = 1;}
+
+				else if ( (LA83_0==RULE_REF) && ((((Grammar.BuildTemplate)&&(LT(1).Text.Equals("template")))||(Grammar.BuildTemplate)||(Grammar.BuildAST)||((Grammar.BuildTemplate)&&(LT(1).Text.Equals("template")))||((Grammar.BuildTemplate)&&(LT(1).Text.Equals("template")))||((Grammar.BuildTemplate)&&(LT(1).Text.Equals("template")))))) {s = 2;}
+
+				else if ( (LA83_0==LPAREN) && (((Grammar.BuildTemplate)||(Grammar.BuildAST)))) {s = 3;}
+
+				else if ( (LA83_0==ACTION) && (((Grammar.BuildTemplate)||(Grammar.BuildAST)))) {s = 4;}
+
+				else if ( (LA83_0==CHAR_LITERAL||LA83_0==DOLLAR||LA83_0==STRING_LITERAL||LA83_0==TREE_BEGIN) && ((Grammar.BuildAST))) {s = 5;}
+
+				else if ( (LA83_0==OR||LA83_0==REWRITE||LA83_0==RPAREN||LA83_0==SEMI) ) {s = 9;}
+
+				else if ( (LA83_0==ETC) ) {s = 13;}
+
+
+				input.Seek(index83_0);
+				if ( s>=0 ) return s;
+				break;
+
+			case 1:
+				int LA83_1 = input.LA(1);
+
+
+				int index83_1 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( ((((Grammar.BuildTemplate)&&(LT(1).Text.Equals("template")))||(Grammar.BuildTemplate))) ) {s = 14;}
+
+				else if ( ((Grammar.BuildAST)) ) {s = 5;}
+
+
+				input.Seek(index83_1);
+				if ( s>=0 ) return s;
+				break;
+
+			case 2:
+				int LA83_2 = input.LA(1);
+
+
+				int index83_2 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( ((((Grammar.BuildTemplate)&&(LT(1).Text.Equals("template")))||(Grammar.BuildTemplate))) ) {s = 14;}
+
+				else if ( ((Grammar.BuildAST)) ) {s = 5;}
+
+
+				input.Seek(index83_2);
+				if ( s>=0 ) return s;
+				break;
+
+			case 3:
+				int LA83_3 = input.LA(1);
+
+
+				int index83_3 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( ((Grammar.BuildTemplate)) ) {s = 14;}
+
+				else if ( ((Grammar.BuildAST)) ) {s = 5;}
+
+
+				input.Seek(index83_3);
+				if ( s>=0 ) return s;
+				break;
+
+			case 4:
+				int LA83_4 = input.LA(1);
+
+
+				int index83_4 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( ((Grammar.BuildTemplate)) ) {s = 14;}
+
+				else if ( ((Grammar.BuildAST)) ) {s = 5;}
+
+
+				input.Seek(index83_4);
+				if ( s>=0 ) return s;
+				break;
+		}
+		if (state.backtracking>0) {state.failed=true; return -1;}
+		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 83, _s, input);
+		dfa.Error(nvae);
+		throw nvae;
+	}
+
+	#endregion
+
+	#region Follow Sets
+	public static class Follow
+	{
+		public static readonly BitSet _ACTION_in_grammar_308 = new BitSet(new ulong[]{0x1002040008000000UL,0x10000000UL});
+		public static readonly BitSet _DOC_COMMENT_in_grammar_319 = new BitSet(new ulong[]{0x1002040008000000UL,0x10000000UL});
+		public static readonly BitSet _grammarType_in_grammar_329 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
+		public static readonly BitSet _id_in_grammar_333 = new BitSet(new ulong[]{0x0UL,0x8000UL});
+		public static readonly BitSet _SEMI_in_grammar_337 = new BitSet(new ulong[]{0x400210008000200UL,0xC00600EUL});
+		public static readonly BitSet _optionsSpec_in_grammar_343 = new BitSet(new ulong[]{0x400210008000200UL,0xC00600EUL});
+		public static readonly BitSet _delegateGrammars_in_grammar_357 = new BitSet(new ulong[]{0x400210008000200UL,0xC00600EUL});
+		public static readonly BitSet _tokensSpec_in_grammar_366 = new BitSet(new ulong[]{0x400210008000200UL,0xC00600EUL});
+		public static readonly BitSet _attrScopes_in_grammar_374 = new BitSet(new ulong[]{0x400210008000200UL,0xC00600EUL});
+		public static readonly BitSet _actions_in_grammar_381 = new BitSet(new ulong[]{0x400210008000200UL,0xC00600EUL});
+		public static readonly BitSet _rules_in_grammar_389 = new BitSet(new ulong[]{0x0UL});
+		public static readonly BitSet _EOF_in_grammar_393 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _LEXER_in_grammarType444 = new BitSet(new ulong[]{0x40000000000UL});
+		public static readonly BitSet _GRAMMAR_in_grammarType449 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _PARSER_in_grammarType472 = new BitSet(new ulong[]{0x40000000000UL});
+		public static readonly BitSet _GRAMMAR_in_grammarType476 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _TREE_in_grammarType497 = new BitSet(new ulong[]{0x40000000000UL});
+		public static readonly BitSet _GRAMMAR_in_grammarType503 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _GRAMMAR_in_grammarType526 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _action_in_actions553 = new BitSet(new ulong[]{0x202UL});
+		public static readonly BitSet _AMPERSAND_in_action568 = new BitSet(new ulong[]{0x1002000000000000UL,0x4002000UL});
+		public static readonly BitSet _actionScopeName_in_action572 = new BitSet(new ulong[]{0x400000UL});
+		public static readonly BitSet _COLON_in_action574 = new BitSet(new ulong[]{0x400000UL});
+		public static readonly BitSet _COLON_in_action577 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
+		public static readonly BitSet _id_in_action582 = new BitSet(new ulong[]{0x10UL});
+		public static readonly BitSet _ACTION_in_action584 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _id_in_actionScopeName597 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _LEXER_in_actionScopeName604 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _PARSER_in_actionScopeName618 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _OPTIONS_in_optionsSpec640 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
+		public static readonly BitSet _option_in_optionsSpec644 = new BitSet(new ulong[]{0x0UL,0x8000UL});
+		public static readonly BitSet _SEMI_in_optionsSpec647 = new BitSet(new ulong[]{0x0UL,0x4002040UL});
+		public static readonly BitSet _RCURLY_in_optionsSpec652 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _id_in_option665 = new BitSet(new ulong[]{0x2000UL});
+		public static readonly BitSet _ASSIGN_in_option667 = new BitSet(new ulong[]{0x800000040000UL,0x4282000UL});
+		public static readonly BitSet _optionValue_in_option670 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _id_in_optionValue691 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _STRING_LITERAL_in_optionValue703 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _CHAR_LITERAL_in_optionValue712 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _INT_in_optionValue723 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _STAR_in_optionValue743 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _IMPORT_in_delegateGrammars768 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
+		public static readonly BitSet _delegateGrammar_in_delegateGrammars771 = new BitSet(new ulong[]{0x1000000UL,0x8000UL});
+		public static readonly BitSet _COMMA_in_delegateGrammars774 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
+		public static readonly BitSet _delegateGrammar_in_delegateGrammars777 = new BitSet(new ulong[]{0x1000000UL,0x8000UL});
+		public static readonly BitSet _SEMI_in_delegateGrammars781 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _id_in_delegateGrammar795 = new BitSet(new ulong[]{0x2000UL});
+		public static readonly BitSet _ASSIGN_in_delegateGrammar797 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
+		public static readonly BitSet _id_in_delegateGrammar802 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _id_in_delegateGrammar811 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _TOKENS_in_tokensSpec838 = new BitSet(new ulong[]{0x0UL,0x4000000UL});
+		public static readonly BitSet _tokenSpec_in_tokensSpec846 = new BitSet(new ulong[]{0x0UL,0x4000040UL});
+		public static readonly BitSet _RCURLY_in_tokensSpec853 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _TOKEN_REF_in_tokenSpec865 = new BitSet(new ulong[]{0x2000UL,0x8000UL});
+		public static readonly BitSet _ASSIGN_in_tokenSpec869 = new BitSet(new ulong[]{0x40000UL,0x200000UL});
+		public static readonly BitSet _set_in_tokenSpec872 = new BitSet(new ulong[]{0x0UL,0x8000UL});
+		public static readonly BitSet _SEMI_in_tokenSpec881 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _attrScope_in_attrScopes894 = new BitSet(new ulong[]{0x2UL,0x4000UL});
+		public static readonly BitSet _SCOPE_in_attrScope907 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
+		public static readonly BitSet _id_in_attrScope910 = new BitSet(new ulong[]{0x210UL});
+		public static readonly BitSet _ruleActions_in_attrScope912 = new BitSet(new ulong[]{0x10UL});
+		public static readonly BitSet _ACTION_in_attrScope915 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _rule_in_rules928 = new BitSet(new ulong[]{0x400210008000202UL,0xC00600EUL});
+		public static readonly BitSet _DOC_COMMENT_in_rule958 = new BitSet(new ulong[]{0x10000000000UL,0x400200EUL});
+		public static readonly BitSet _PROTECTED_in_rule971 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
+		public static readonly BitSet _PUBLIC_in_rule980 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
+		public static readonly BitSet _PRIVATE_in_rule990 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
+		public static readonly BitSet _FRAGMENT_in_rule999 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
+		public static readonly BitSet _id_in_rule1011 = new BitSet(new ulong[]{0x400000000408A00UL,0x2004100UL});
+		public static readonly BitSet _BANG_in_rule1021 = new BitSet(new ulong[]{0x400000000400A00UL,0x2004100UL});
+		public static readonly BitSet _ARG_ACTION_in_rule1032 = new BitSet(new ulong[]{0x400000000400200UL,0x2004100UL});
+		public static readonly BitSet _RETURNS_in_rule1041 = new BitSet(new ulong[]{0x800UL});
+		public static readonly BitSet _ARG_ACTION_in_rule1045 = new BitSet(new ulong[]{0x400000000400200UL,0x2004000UL});
+		public static readonly BitSet _throwsSpec_in_rule1055 = new BitSet(new ulong[]{0x400000000400200UL,0x4000UL});
+		public static readonly BitSet _optionsSpec_in_rule1064 = new BitSet(new ulong[]{0x400200UL,0x4000UL});
+		public static readonly BitSet _ruleScopeSpec_in_rule1073 = new BitSet(new ulong[]{0x400200UL});
+		public static readonly BitSet _ruleActions_in_rule1078 = new BitSet(new ulong[]{0x400000UL});
+		public static readonly BitSet _COLON_in_rule1084 = new BitSet(new ulong[]{0x888008000040010UL,0xA4212200UL});
+		public static readonly BitSet _altList_in_rule1088 = new BitSet(new ulong[]{0x0UL,0x8000UL});
+		public static readonly BitSet _SEMI_in_rule1093 = new BitSet(new ulong[]{0x4000020002UL});
+		public static readonly BitSet _exceptionGroup_in_rule1101 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ruleAction_in_ruleActions1243 = new BitSet(new ulong[]{0x202UL});
+		public static readonly BitSet _AMPERSAND_in_ruleAction1258 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
+		public static readonly BitSet _id_in_ruleAction1261 = new BitSet(new ulong[]{0x10UL});
+		public static readonly BitSet _ACTION_in_ruleAction1263 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _THROWS_in_throwsSpec1274 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
+		public static readonly BitSet _id_in_throwsSpec1277 = new BitSet(new ulong[]{0x1000002UL});
+		public static readonly BitSet _COMMA_in_throwsSpec1281 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
+		public static readonly BitSet _id_in_throwsSpec1284 = new BitSet(new ulong[]{0x1000002UL});
+		public static readonly BitSet _SCOPE_in_ruleScopeSpec1300 = new BitSet(new ulong[]{0x210UL});
+		public static readonly BitSet _ruleActions_in_ruleScopeSpec1302 = new BitSet(new ulong[]{0x10UL});
+		public static readonly BitSet _ACTION_in_ruleScopeSpec1305 = new BitSet(new ulong[]{0x2UL,0x4000UL});
+		public static readonly BitSet _SCOPE_in_ruleScopeSpec1314 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
+		public static readonly BitSet _idList_in_ruleScopeSpec1316 = new BitSet(new ulong[]{0x0UL,0x8000UL});
+		public static readonly BitSet _SEMI_in_ruleScopeSpec1318 = new BitSet(new ulong[]{0x2UL,0x4000UL});
+		public static readonly BitSet _LPAREN_in_block1361 = new BitSet(new ulong[]{0xC88008000440210UL,0xA4212A00UL});
+		public static readonly BitSet _optionsSpec_in_block1399 = new BitSet(new ulong[]{0x400200UL});
+		public static readonly BitSet _ruleActions_in_block1410 = new BitSet(new ulong[]{0x400000UL});
+		public static readonly BitSet _COLON_in_block1418 = new BitSet(new ulong[]{0x888008000040010UL,0xA4212A00UL});
+		public static readonly BitSet _ACTION_in_block1424 = new BitSet(new ulong[]{0x400000UL});
+		public static readonly BitSet _COLON_in_block1426 = new BitSet(new ulong[]{0x888008000040010UL,0xA4212A00UL});
+		public static readonly BitSet _alternative_in_block1438 = new BitSet(new ulong[]{0x800000000000000UL,0xA00UL});
+		public static readonly BitSet _rewrite_in_block1442 = new BitSet(new ulong[]{0x800000000000000UL,0x800UL});
+		public static readonly BitSet _OR_in_block1452 = new BitSet(new ulong[]{0x888008000040010UL,0xA4212A00UL});
+		public static readonly BitSet _alternative_in_block1456 = new BitSet(new ulong[]{0x800000000000000UL,0xA00UL});
+		public static readonly BitSet _rewrite_in_block1460 = new BitSet(new ulong[]{0x800000000000000UL,0x800UL});
+		public static readonly BitSet _RPAREN_in_block1477 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _alternative_in_altList1541 = new BitSet(new ulong[]{0x800000000000000UL,0x200UL});
+		public static readonly BitSet _rewrite_in_altList1545 = new BitSet(new ulong[]{0x800000000000002UL});
+		public static readonly BitSet _OR_in_altList1572 = new BitSet(new ulong[]{0x888008000040010UL,0xA4212200UL});
+		public static readonly BitSet _alternative_in_altList1576 = new BitSet(new ulong[]{0x800000000000000UL,0x200UL});
+		public static readonly BitSet _rewrite_in_altList1580 = new BitSet(new ulong[]{0x800000000000002UL});
+		public static readonly BitSet _element_in_alternative1676 = new BitSet(new ulong[]{0x88008000040012UL,0xA4212000UL});
+		public static readonly BitSet _exceptionHandler_in_exceptionGroup1729 = new BitSet(new ulong[]{0x4000020002UL});
+		public static readonly BitSet _finallyClause_in_exceptionGroup1736 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _finallyClause_in_exceptionGroup1744 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _CATCH_in_exceptionHandler1755 = new BitSet(new ulong[]{0x800UL});
+		public static readonly BitSet _ARG_ACTION_in_exceptionHandler1758 = new BitSet(new ulong[]{0x10UL});
+		public static readonly BitSet _ACTION_in_exceptionHandler1760 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _FINALLY_in_finallyClause1771 = new BitSet(new ulong[]{0x10UL});
+		public static readonly BitSet _ACTION_in_finallyClause1774 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _elementNoOptionSpec_in_element1785 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _id_in_elementNoOptionSpec1805 = new BitSet(new ulong[]{0x8000000000002000UL});
+		public static readonly BitSet _ASSIGN_in_elementNoOptionSpec1808 = new BitSet(new ulong[]{0x88000000040000UL,0x84202000UL});
+		public static readonly BitSet _PLUS_ASSIGN_in_elementNoOptionSpec1811 = new BitSet(new ulong[]{0x88000000040000UL,0x84202000UL});
+		public static readonly BitSet _atom_in_elementNoOptionSpec1816 = new BitSet(new ulong[]{0x4000000000000002UL,0x80010UL});
+		public static readonly BitSet _block_in_elementNoOptionSpec1818 = new BitSet(new ulong[]{0x4000000000000002UL,0x80010UL});
+		public static readonly BitSet _ebnfSuffix_in_elementNoOptionSpec1833 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _atom_in_elementNoOptionSpec1851 = new BitSet(new ulong[]{0x4000000000000002UL,0x80010UL});
+		public static readonly BitSet _ebnfSuffix_in_elementNoOptionSpec1860 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ebnf_in_elementNoOptionSpec1876 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _FORCED_ACTION_in_elementNoOptionSpec1882 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ACTION_in_elementNoOptionSpec1888 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _SEMPRED_in_elementNoOptionSpec1896 = new BitSet(new ulong[]{0x100000000002UL});
+		public static readonly BitSet _IMPLIES_in_elementNoOptionSpec1900 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _tree__in_elementNoOptionSpec1919 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _range_in_atom1934 = new BitSet(new ulong[]{0x8002UL,0x400UL});
+		public static readonly BitSet _ROOT_in_atom1937 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _BANG_in_atom1940 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _id_in_atom1980 = new BitSet(new ulong[]{0x0UL,0x80000000UL});
+		public static readonly BitSet _WILDCARD_in_atom1984 = new BitSet(new ulong[]{0x40000UL,0x84202000UL});
+		public static readonly BitSet _terminal_in_atom1988 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ruleref_in_atom1990 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _terminal_in_atom1999 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ruleref_in_atom2005 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _notSet_in_atom2014 = new BitSet(new ulong[]{0x8002UL,0x400UL});
+		public static readonly BitSet _ROOT_in_atom2017 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _BANG_in_atom2020 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _RULE_REF_in_ruleref2036 = new BitSet(new ulong[]{0x8802UL,0x400UL});
+		public static readonly BitSet _ARG_ACTION_in_ruleref2041 = new BitSet(new ulong[]{0x8002UL,0x400UL});
+		public static readonly BitSet _ROOT_in_ruleref2047 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _BANG_in_ruleref2050 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _NOT_in_notSet2064 = new BitSet(new ulong[]{0x8000000040000UL,0x4200000UL});
+		public static readonly BitSet _notTerminal_in_notSet2071 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _block_in_notSet2077 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _id_in_treeRoot2098 = new BitSet(new ulong[]{0x8000000000002000UL});
+		public static readonly BitSet _ASSIGN_in_treeRoot2101 = new BitSet(new ulong[]{0x88000000040000UL,0x84202000UL});
+		public static readonly BitSet _PLUS_ASSIGN_in_treeRoot2104 = new BitSet(new ulong[]{0x88000000040000UL,0x84202000UL});
+		public static readonly BitSet _atom_in_treeRoot2109 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _block_in_treeRoot2111 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _atom_in_treeRoot2118 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _block_in_treeRoot2124 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _TREE_BEGIN_in_tree_2143 = new BitSet(new ulong[]{0x88000000040000UL,0x84202000UL});
+		public static readonly BitSet _treeRoot_in_tree_2148 = new BitSet(new ulong[]{0x88008000040010UL,0xA4212000UL});
+		public static readonly BitSet _element_in_tree_2152 = new BitSet(new ulong[]{0x88008000040010UL,0xA4212800UL});
+		public static readonly BitSet _RPAREN_in_tree_2159 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _block_in_ebnf2173 = new BitSet(new ulong[]{0x4000100000008002UL,0x80410UL});
+		public static readonly BitSet _QUESTION_in_ebnf2179 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _STAR_in_ebnf2197 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _PLUS_in_ebnf2215 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _IMPLIES_in_ebnf2233 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ROOT_in_ebnf2269 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _BANG_in_ebnf2286 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _CHAR_LITERAL_in_range2325 = new BitSet(new ulong[]{0x0UL,0x20UL});
+		public static readonly BitSet _RANGE_in_range2327 = new BitSet(new ulong[]{0x40000UL});
+		public static readonly BitSet _CHAR_LITERAL_in_range2331 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _CHAR_LITERAL_in_terminal2359 = new BitSet(new ulong[]{0x100000000008002UL,0x400UL});
+		public static readonly BitSet _elementOptions_in_terminal2364 = new BitSet(new ulong[]{0x8002UL,0x400UL});
+		public static readonly BitSet _ROOT_in_terminal2372 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _BANG_in_terminal2375 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _TOKEN_REF_in_terminal2386 = new BitSet(new ulong[]{0x100000000008802UL,0x400UL});
+		public static readonly BitSet _elementOptions_in_terminal2393 = new BitSet(new ulong[]{0x8802UL,0x400UL});
+		public static readonly BitSet _ARG_ACTION_in_terminal2404 = new BitSet(new ulong[]{0x8002UL,0x400UL});
+		public static readonly BitSet _ROOT_in_terminal2413 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _BANG_in_terminal2416 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _STRING_LITERAL_in_terminal2427 = new BitSet(new ulong[]{0x100000000008002UL,0x400UL});
+		public static readonly BitSet _elementOptions_in_terminal2432 = new BitSet(new ulong[]{0x8002UL,0x400UL});
+		public static readonly BitSet _ROOT_in_terminal2440 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _BANG_in_terminal2443 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _WILDCARD_in_terminal2454 = new BitSet(new ulong[]{0x8002UL,0x400UL});
+		public static readonly BitSet _ROOT_in_terminal2457 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _BANG_in_terminal2460 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _OPEN_ELEMENT_OPTION_in_elementOptions2479 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
+		public static readonly BitSet _defaultNodeOption_in_elementOptions2482 = new BitSet(new ulong[]{0x100000UL});
+		public static readonly BitSet _CLOSE_ELEMENT_OPTION_in_elementOptions2485 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _OPEN_ELEMENT_OPTION_in_elementOptions2491 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
+		public static readonly BitSet _elementOption_in_elementOptions2494 = new BitSet(new ulong[]{0x100000UL,0x8000UL});
+		public static readonly BitSet _SEMI_in_elementOptions2498 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
+		public static readonly BitSet _elementOption_in_elementOptions2501 = new BitSet(new ulong[]{0x100000UL,0x8000UL});
+		public static readonly BitSet _CLOSE_ELEMENT_OPTION_in_elementOptions2506 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _id_in_defaultNodeOption2526 = new BitSet(new ulong[]{0x2UL,0x80000000UL});
+		public static readonly BitSet _WILDCARD_in_defaultNodeOption2531 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
+		public static readonly BitSet _id_in_defaultNodeOption2535 = new BitSet(new ulong[]{0x2UL,0x80000000UL});
+		public static readonly BitSet _id_in_elementOption2557 = new BitSet(new ulong[]{0x2000UL});
+		public static readonly BitSet _ASSIGN_in_elementOption2559 = new BitSet(new ulong[]{0x0UL,0x4202000UL});
+		public static readonly BitSet _id_in_elementOption2565 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _STRING_LITERAL_in_elementOption2569 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _QUESTION_in_ebnfSuffix2643 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _STAR_in_ebnfSuffix2657 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _PLUS_in_ebnfSuffix2671 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _CHAR_LITERAL_in_notTerminal2714 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _TOKEN_REF_in_notTerminal2721 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _STRING_LITERAL_in_notTerminal2726 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _id_in_idList2737 = new BitSet(new ulong[]{0x1000002UL});
+		public static readonly BitSet _COMMA_in_idList2740 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
+		public static readonly BitSet _id_in_idList2743 = new BitSet(new ulong[]{0x1000002UL});
+		public static readonly BitSet _TOKEN_REF_in_id2756 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _RULE_REF_in_id2768 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _rewrite_with_sempred_in_rewrite2788 = new BitSet(new ulong[]{0x0UL,0x200UL});
+		public static readonly BitSet _REWRITE_in_rewrite2793 = new BitSet(new ulong[]{0x8002010040010UL,0x24202000UL});
+		public static readonly BitSet _rewrite_alternative_in_rewrite2795 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _REWRITE_in_rewrite_with_sempred2822 = new BitSet(new ulong[]{0x0UL,0x10000UL});
+		public static readonly BitSet _SEMPRED_in_rewrite_with_sempred2825 = new BitSet(new ulong[]{0x8002010040010UL,0x24202000UL});
+		public static readonly BitSet _rewrite_alternative_in_rewrite_with_sempred2827 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _LPAREN_in_rewrite_block2838 = new BitSet(new ulong[]{0x8002010040010UL,0x24202800UL});
+		public static readonly BitSet _rewrite_alternative_in_rewrite_block2842 = new BitSet(new ulong[]{0x0UL,0x800UL});
+		public static readonly BitSet _RPAREN_in_rewrite_block2846 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _rewrite_template_in_rewrite_alternative2882 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _rewrite_element_in_rewrite_alternative2894 = new BitSet(new ulong[]{0x8000010040012UL,0x24202000UL});
+		public static readonly BitSet _ETC_in_rewrite_alternative2955 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _rewrite_atom_in_rewrite_element2970 = new BitSet(new ulong[]{0x4000000000000002UL,0x80010UL});
+		public static readonly BitSet _ebnfSuffix_in_rewrite_element2990 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _rewrite_ebnf_in_rewrite_element3009 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _rewrite_tree_in_rewrite_element3018 = new BitSet(new ulong[]{0x4000000000000002UL,0x80010UL});
+		public static readonly BitSet _ebnfSuffix_in_rewrite_element3038 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _TOKEN_REF_in_rewrite_atom3072 = new BitSet(new ulong[]{0x100000000000802UL});
+		public static readonly BitSet _elementOptions_in_rewrite_atom3089 = new BitSet(new ulong[]{0x802UL});
+		public static readonly BitSet _ARG_ACTION_in_rewrite_atom3095 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _RULE_REF_in_rewrite_atom3117 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _CHAR_LITERAL_in_rewrite_atom3126 = new BitSet(new ulong[]{0x100000000000002UL});
+		public static readonly BitSet _elementOptions_in_rewrite_atom3143 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _STRING_LITERAL_in_rewrite_atom3155 = new BitSet(new ulong[]{0x100000000000002UL});
+		public static readonly BitSet _elementOptions_in_rewrite_atom3174 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _DOLLAR_in_rewrite_atom3184 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
+		public static readonly BitSet _id_in_rewrite_atom3188 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ACTION_in_rewrite_atom3201 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _rewrite_block_in_rewrite_ebnf3214 = new BitSet(new ulong[]{0x4000000000000000UL,0x80010UL});
+		public static readonly BitSet _QUESTION_in_rewrite_ebnf3220 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _STAR_in_rewrite_ebnf3239 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _PLUS_in_rewrite_ebnf3258 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _TREE_BEGIN_in_rewrite_tree3286 = new BitSet(new ulong[]{0x10040010UL,0x4202000UL});
+		public static readonly BitSet _rewrite_atom_in_rewrite_tree3292 = new BitSet(new ulong[]{0x8000010040010UL,0x24202800UL});
+		public static readonly BitSet _rewrite_element_in_rewrite_tree3296 = new BitSet(new ulong[]{0x8000010040010UL,0x24202800UL});
+		public static readonly BitSet _RPAREN_in_rewrite_tree3303 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _rewrite_template_head_in_rewrite_template3338 = new BitSet(new ulong[]{0xC0000000UL});
+		public static readonly BitSet _DOUBLE_QUOTE_STRING_LITERAL_in_rewrite_template3357 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _DOUBLE_ANGLE_STRING_LITERAL_in_rewrite_template3363 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _rewrite_template_head_in_rewrite_template3378 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _rewrite_indirect_template_head_in_rewrite_template3387 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ACTION_in_rewrite_template3396 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _id_in_rewrite_template_head3409 = new BitSet(new ulong[]{0x8000000000000UL});
+		public static readonly BitSet _LPAREN_in_rewrite_template_head3413 = new BitSet(new ulong[]{0x0UL,0x4002800UL});
+		public static readonly BitSet _rewrite_template_args_in_rewrite_template_head3417 = new BitSet(new ulong[]{0x0UL,0x800UL});
+		public static readonly BitSet _RPAREN_in_rewrite_template_head3421 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _LPAREN_in_rewrite_indirect_template_head3449 = new BitSet(new ulong[]{0x10UL});
+		public static readonly BitSet _ACTION_in_rewrite_indirect_template_head3453 = new BitSet(new ulong[]{0x0UL,0x800UL});
+		public static readonly BitSet _RPAREN_in_rewrite_indirect_template_head3457 = new BitSet(new ulong[]{0x8000000000000UL});
+		public static readonly BitSet _LPAREN_in_rewrite_indirect_template_head3461 = new BitSet(new ulong[]{0x0UL,0x4002800UL});
+		public static readonly BitSet _rewrite_template_args_in_rewrite_indirect_template_head3463 = new BitSet(new ulong[]{0x0UL,0x800UL});
+		public static readonly BitSet _RPAREN_in_rewrite_indirect_template_head3465 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _rewrite_template_arg_in_rewrite_template_args3489 = new BitSet(new ulong[]{0x1000002UL});
+		public static readonly BitSet _COMMA_in_rewrite_template_args3492 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
+		public static readonly BitSet _rewrite_template_arg_in_rewrite_template_args3494 = new BitSet(new ulong[]{0x1000002UL});
+		public static readonly BitSet _id_in_rewrite_template_arg3529 = new BitSet(new ulong[]{0x2000UL});
+		public static readonly BitSet _ASSIGN_in_rewrite_template_arg3533 = new BitSet(new ulong[]{0x10UL});
+		public static readonly BitSet _ACTION_in_rewrite_template_arg3535 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _id_in_synpred1_ANTLR1964 = new BitSet(new ulong[]{0x0UL,0x80000000UL});
+		public static readonly BitSet _WILDCARD_in_synpred1_ANTLR1966 = new BitSet(new ulong[]{0x40000UL,0x84202000UL});
+		public static readonly BitSet _terminal_in_synpred1_ANTLR1969 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ruleref_in_synpred1_ANTLR1971 = new BitSet(new ulong[]{0x2UL});
+
+	}
+	#endregion
+}
+
+} // namespace Antlr3.Grammars
diff --git a/Antlr3/Grammars/ANTLRParserHelper.cs b/Antlr3/Grammars/ANTLRParserHelper.cs
new file mode 100644
index 0000000..820c344
--- /dev/null
+++ b/Antlr3/Grammars/ANTLRParserHelper.cs
@@ -0,0 +1,368 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Grammar conversion to ANTLR v3 and C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *	notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	notice, this list of conditions and the following disclaimer in the
+ *	documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *	derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Grammars
+{
+    using System;
+    using Antlr.Runtime;
+    using Antlr.Runtime.JavaExtensions;
+    using Antlr.Runtime.Tree;
+
+    using ErrorManager = Antlr3.Tool.ErrorManager;
+    using Grammar = Antlr3.Tool.Grammar;
+    using GrammarAST = Antlr3.Tool.GrammarAST;
+    using IToken = Antlr.Runtime.IToken;
+    using RecognitionException = Antlr.Runtime.RecognitionException;
+
+    partial class ANTLRParser
+    {
+        protected string currentRuleName = null;
+        protected GrammarAST currentBlockAST = null;
+        protected bool atTreeRoot; // are we matching a tree root in tree grammar?
+
+        class GrammarASTErrorNode : GrammarAST
+        {
+            public IIntStream input;
+            public IToken start;
+            public IToken stop;
+            public RecognitionException trappedException;
+
+            public GrammarASTErrorNode( ITokenStream input, IToken start, IToken stop,
+                                   RecognitionException e )
+            {
+                //System.out.println("start: "+start+", stop: "+stop);
+                if ( stop == null ||
+                     ( stop.TokenIndex < start.TokenIndex &&
+                      stop.Type != TokenConstants.EOF ) )
+                {
+                    // sometimes resync does not consume a token (when LT(1) is
+                    // in follow set.  So, stop will be 1 to left to start. adjust.
+                    // Also handle case where start is the first token and no token
+                    // is consumed during recovery; LT(-1) will return null.
+                    stop = start;
+                }
+                this.input = input;
+                this.start = start;
+                this.stop = stop;
+                this.trappedException = e;
+            }
+
+            #region Properties
+            public override bool IsNil
+            {
+                get
+                {
+                    return false;
+                }
+            }
+
+            public override string Text
+            {
+                get
+                {
+                    string badText = null;
+                    if ( start is IToken )
+                    {
+                        int i = ( (IToken)start ).TokenIndex;
+                        int j = ( (IToken)stop ).TokenIndex;
+                        if ( ( (IToken)stop ).Type == TokenConstants.EOF )
+                        {
+                            j = ( (ITokenStream)input ).Size();
+                        }
+                        badText = ( (ITokenStream)input ).ToString( i, j );
+                    }
+                    else if ( start is ITree )
+                    {
+                        badText = ( (ITreeNodeStream)input ).ToString( start, stop );
+                    }
+                    else
+                    {
+                        // people should subclass if they alter the tree type so this
+                        // next one is for sure correct.
+                        badText = "<unknown>";
+                    }
+                    return badText;
+                }
+                set
+                {
+                }
+            }
+
+            public override int Type
+            {
+                get
+                {
+                    return TokenConstants.INVALID_TOKEN_TYPE;
+                }
+                set
+                {
+                }
+            }
+            #endregion
+
+            public override string ToString()
+            {
+                if ( trappedException is MissingTokenException )
+                {
+                    return "<missing type: " +
+                           ( (MissingTokenException)trappedException ).GetMissingType() +
+                           ">";
+                }
+                else if ( trappedException is UnwantedTokenException )
+                {
+                    return "<extraneous: " +
+                           ( (UnwantedTokenException)trappedException ).UnexpectedToken +
+                           ", resync=" + Text + ">";
+                }
+                else if ( trappedException is MismatchedTokenException )
+                {
+                    return "<mismatched token: " + trappedException.token + ", resync=" + Text + ">";
+                }
+                else if ( trappedException is NoViableAltException )
+                {
+                    return "<unexpected: " + trappedException.token +
+                           ", resync=" + Text + ">";
+                }
+                return "<error: " + Text + ">";
+            }
+        }
+
+        internal class grammar_Adaptor : CommonTreeAdaptor
+        {
+            ANTLRParser _outer;
+
+            public grammar_Adaptor( ANTLRParser outer )
+            {
+                _outer = outer;
+            }
+            public override object Create( IToken payload )
+            {
+                GrammarAST t = new GrammarAST( payload );
+                if ( _outer != null )
+                    t.enclosingRuleName = _outer.currentRuleName;
+                return t;
+            }
+            public override object ErrorNode( ITokenStream input, IToken start, IToken stop, RecognitionException e )
+            {
+                GrammarAST t = new GrammarASTErrorNode( input, start, stop, e );
+                if ( _outer != null )
+                    t.enclosingRuleName = _outer.currentRuleName;
+                return t;
+            }
+        }
+
+        public Grammar Grammar
+        {
+            get;
+            set;
+        }
+
+        public int GrammarType
+        {
+            get;
+            set;
+        }
+
+        public string FileName
+        {
+            get;
+            set;
+        }
+
+        int LA( int i )
+        {
+            return input.LA( i );
+        }
+
+        IToken LT( int k )
+        {
+            return input.LT( k );
+        }
+
+        protected override void Initialize()
+        {
+            TreeAdaptor = new grammar_Adaptor( this );
+            base.Initialize();
+        }
+
+        protected virtual GrammarAST setToBlockWithSet( GrammarAST b )
+        {
+            /*
+             * alt = ^(ALT["ALT"] {b} EOA["EOA"])
+             * prefixWithSynpred( alt )
+             * return ^(BLOCK["BLOCK"] {alt} EOB["<end-of-block>"])
+             */
+            GrammarAST alt = (GrammarAST)adaptor.Create( ALT, "ALT" );
+            adaptor.AddChild( alt, b );
+            adaptor.AddChild( alt, adaptor.Create( EOA, "<end-of-alt>" ) );
+
+            prefixWithSynPred( alt );
+
+            GrammarAST block = (GrammarAST)adaptor.Create( BLOCK, "BLOCK" );
+            adaptor.AddChild( block, alt );
+            adaptor.AddChild( alt, adaptor.Create( EOB, "<end-of-block>" ) );
+
+            return block;
+        }
+
+        /** Create a copy of the alt and make it into a BLOCK; all actions,
+         *  labels, tree operators, rewrites are removed.
+         */
+        protected virtual GrammarAST createBlockFromDupAlt( GrammarAST alt )
+        {
+            /*
+             * ^(BLOCK["BLOCK"] {GrammarAST.dupTreeNoActions(alt)} EOB["<end-of-block>"])
+             */
+            GrammarAST nalt = GrammarAST.dupTreeNoActions( alt, null );
+
+            GrammarAST block = (GrammarAST)adaptor.Create( BLOCK, "BLOCK" );
+            adaptor.AddChild( block, nalt );
+            adaptor.AddChild( block, adaptor.Create( EOB, "<end-of-block>" ) );
+
+            return block;
+        }
+
+        /** Rewrite alt to have a synpred as first element;
+         *  (xxx)=>xxx
+         *  but only if they didn't specify one manually.
+         */
+        protected virtual void prefixWithSynPred( GrammarAST alt )
+        {
+            // if they want backtracking and it's not a lexer rule in combined grammar
+            string autoBacktrack = (string)Grammar.getBlockOption( currentBlockAST, "backtrack" );
+            if ( autoBacktrack == null )
+            {
+                autoBacktrack = (string)Grammar.getOption( "backtrack" );
+            }
+            if ( autoBacktrack != null && autoBacktrack.Equals( "true" ) &&
+                 !( GrammarType == COMBINED_GRAMMAR &&
+                 char.IsUpper( currentRuleName[0] ) ) &&
+                 alt.GetChild( 0 ).Type != SYN_SEMPRED )
+            {
+                // duplicate alt and make a synpred block around that dup'd alt
+                GrammarAST synpredBlockAST = createBlockFromDupAlt( alt );
+
+                // Create a BACKTRACK_SEMPRED node as if user had typed this in
+                // Effectively we replace (xxx)=>xxx with {synpredxxx}? xxx
+                GrammarAST synpredAST = createSynSemPredFromBlock( synpredBlockAST,
+                                                                  BACKTRACK_SEMPRED );
+
+                // insert BACKTRACK_SEMPRED as first element of alt
+                //synpredAST.getLastSibling().setNextSibling( alt.getFirstChild() );
+                //synpredAST.addChild( alt.getFirstChild() );
+                //alt.setFirstChild( synpredAST );
+                GrammarAST[] children = alt.getChildrenAsArray();
+                adaptor.SetChild( alt, 0, synpredAST );
+                for ( int i = 0; i < children.Length; i++ )
+                {
+                    if ( i < children.Length - 1 )
+                        adaptor.SetChild( alt, i + 1, children[i] );
+                    else
+                        adaptor.AddChild( alt, children[i] );
+                }
+            }
+        }
+
+        protected virtual GrammarAST createSynSemPredFromBlock( GrammarAST synpredBlockAST, int synpredTokenType )
+        {
+            // add grammar fragment to a list so we can make fake rules for them later.
+            string predName = Grammar.defineSyntacticPredicate( synpredBlockAST, currentRuleName );
+            // convert (alpha)=> into {synpredN}? where N is some pred count
+            // during code gen we convert to function call with templates
+            string synpredinvoke = predName;
+            GrammarAST p = (GrammarAST)adaptor.Create( synpredTokenType, synpredinvoke );
+            // track how many decisions have synpreds
+            Grammar.blocksWithSynPreds.Add( currentBlockAST );
+            return p;
+        }
+
+        public virtual GrammarAST createSimpleRuleAST( string name, GrammarAST block, bool fragment )
+        {
+            GrammarAST modifier = null;
+            if ( fragment )
+            {
+                modifier = (GrammarAST)adaptor.Create( FRAGMENT, "fragment" );
+            }
+
+            /*
+             * EOBAST = block.getLastChild()
+             * ^(RULE[block,"rule"] ID["name"] {modifier} ARG["ARG"] RET["RET"] SCOPE["scope"] {block} EOR[EOBAST,"<end-of-rule>"])
+             */
+            GrammarAST rule = (GrammarAST)adaptor.Create( RULE, block.Token, "rule" );
+
+            adaptor.AddChild( rule, adaptor.Create( ID, name ) );
+            if ( modifier != null )
+                adaptor.AddChild( rule, modifier );
+            adaptor.AddChild( rule, adaptor.Create( ARG, "ARG" ) );
+            adaptor.AddChild( rule, adaptor.Create( RET, "RET" ) );
+            adaptor.AddChild( rule, adaptor.Create( SCOPE, "scope" ) );
+            adaptor.AddChild( rule, block );
+            adaptor.AddChild( rule, adaptor.Create( EOR, block.getLastChild().Token, "<end-of-rule>" ) );
+
+            return rule;
+        }
+
+        public override void ReportError( RecognitionException ex )
+        {
+            //Token token = null;
+            //try
+            //{
+            //    token = LT( 1 );
+            //}
+            //catch ( TokenStreamException tse )
+            //{
+            //    ErrorManager.internalError( "can't get token???", tse );
+            //}
+            IToken token = ex.token;
+            ErrorManager.syntaxError(
+                ErrorManager.MSG_SYNTAX_ERROR,
+                Grammar,
+                token,
+                "antlr: " + ex.ToString(),
+                ex );
+        }
+
+        public virtual void cleanup( GrammarAST root )
+        {
+            if ( GrammarType == LEXER_GRAMMAR )
+            {
+                string filter = (string)Grammar.getOption( "filter" );
+                GrammarAST tokensRuleAST =
+                    Grammar.addArtificialMatchTokensRule(
+                        root,
+                        Grammar.lexerRuleNamesInCombined,
+                        Grammar.getDelegateNames(),
+                        filter != null && filter.Equals( "true" ) );
+            }
+        }
+    }
+}
diff --git a/Antlr3/Grammars/ANTLRTreePrinter.cs b/Antlr3/Grammars/ANTLRTreePrinter.cs
new file mode 100644
index 0000000..8e3da11
--- /dev/null
+++ b/Antlr3/Grammars/ANTLRTreePrinter.cs
@@ -0,0 +1,3926 @@
+// $ANTLR 3.1.2 Grammars\\ANTLRTreePrinter.g3 2009-03-07 09:00:04
+
+// The variable 'variable' is assigned but its value is never used.
+#pragma warning disable 219
+// Unreachable code detected.
+#pragma warning disable 162
+
+
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+using Antlr3.Tool;
+
+
+using System.Collections.Generic;
+using Antlr.Runtime;
+using Antlr.Runtime.Tree;
+using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;using Stack = System.Collections.Generic.Stack<object>;
+using List = System.Collections.IList;
+using ArrayList = System.Collections.Generic.List<object>;
+
+namespace Antlr3.Grammars
+{
+/** Print out a grammar (no pretty printing).
+ *
+ *  Terence Parr
+ *  University of San Francisco
+ *  August 19, 2003
+ */
+public partial class ANTLRTreePrinter : TreeParser
+{
+	public static readonly string[] tokenNames = new string[] {
+		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", "ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARG_ACTION", "ARGLIST", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", "CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", "COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", "DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", "EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", "GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", "LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", "NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", "OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", "RET", "RETURNS", "REWRITE", "ROOT", "RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", "SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYN_SEMPRED", "SYNPRED", "TEMPLATE", "THROWS", "TOKEN_REF", "TOKENS", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", "WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT"
+	};
+	public const int EOF=-1;
+	public const int ACTION=4;
+	public const int ACTION_CHAR_LITERAL=5;
+	public const int ACTION_ESC=6;
+	public const int ACTION_STRING_LITERAL=7;
+	public const int ALT=8;
+	public const int AMPERSAND=9;
+	public const int ARG=10;
+	public const int ARG_ACTION=11;
+	public const int ARGLIST=12;
+	public const int ASSIGN=13;
+	public const int BACKTRACK_SEMPRED=14;
+	public const int BANG=15;
+	public const int BLOCK=16;
+	public const int CATCH=17;
+	public const int CHAR_LITERAL=18;
+	public const int CHAR_RANGE=19;
+	public const int CLOSE_ELEMENT_OPTION=20;
+	public const int CLOSURE=21;
+	public const int COLON=22;
+	public const int COMBINED_GRAMMAR=23;
+	public const int COMMA=24;
+	public const int COMMENT=25;
+	public const int DIGIT=26;
+	public const int DOC_COMMENT=27;
+	public const int DOLLAR=28;
+	public const int DOT=29;
+	public const int DOUBLE_ANGLE_STRING_LITERAL=30;
+	public const int DOUBLE_QUOTE_STRING_LITERAL=31;
+	public const int EOA=32;
+	public const int EOB=33;
+	public const int EOR=34;
+	public const int EPSILON=35;
+	public const int ESC=36;
+	public const int ETC=37;
+	public const int FINALLY=38;
+	public const int FORCED_ACTION=39;
+	public const int FRAGMENT=40;
+	public const int GATED_SEMPRED=41;
+	public const int GRAMMAR=42;
+	public const int ID=43;
+	public const int IMPLIES=44;
+	public const int IMPORT=45;
+	public const int INITACTION=46;
+	public const int INT=47;
+	public const int LABEL=48;
+	public const int LEXER=49;
+	public const int LEXER_GRAMMAR=50;
+	public const int LPAREN=51;
+	public const int ML_COMMENT=52;
+	public const int NESTED_ACTION=53;
+	public const int NESTED_ARG_ACTION=54;
+	public const int NOT=55;
+	public const int OPEN_ELEMENT_OPTION=56;
+	public const int OPTIONAL=57;
+	public const int OPTIONS=58;
+	public const int OR=59;
+	public const int PARSER=60;
+	public const int PARSER_GRAMMAR=61;
+	public const int PLUS=62;
+	public const int PLUS_ASSIGN=63;
+	public const int POSITIVE_CLOSURE=64;
+	public const int PRIVATE=65;
+	public const int PROTECTED=66;
+	public const int PUBLIC=67;
+	public const int QUESTION=68;
+	public const int RANGE=69;
+	public const int RCURLY=70;
+	public const int RET=71;
+	public const int RETURNS=72;
+	public const int REWRITE=73;
+	public const int ROOT=74;
+	public const int RPAREN=75;
+	public const int RULE=76;
+	public const int RULE_REF=77;
+	public const int SCOPE=78;
+	public const int SEMI=79;
+	public const int SEMPRED=80;
+	public const int SL_COMMENT=81;
+	public const int SRC=82;
+	public const int STAR=83;
+	public const int STRAY_BRACKET=84;
+	public const int STRING_LITERAL=85;
+	public const int SYN_SEMPRED=86;
+	public const int SYNPRED=87;
+	public const int TEMPLATE=88;
+	public const int THROWS=89;
+	public const int TOKEN_REF=90;
+	public const int TOKENS=91;
+	public const int TREE=92;
+	public const int TREE_BEGIN=93;
+	public const int TREE_GRAMMAR=94;
+	public const int WILDCARD=95;
+	public const int WS=96;
+	public const int WS_LOOP=97;
+	public const int WS_OPT=98;
+	public const int XDIGIT=99;
+
+	// delegates
+	// delegators
+
+	public ANTLRTreePrinter( ITreeNodeStream input )
+		: this( input, new RecognizerSharedState() )
+	{
+	}
+	public ANTLRTreePrinter( ITreeNodeStream input, RecognizerSharedState state )
+		: base( input, state )
+	{
+	}
+
+
+	public override string[] GetTokenNames() { return ANTLRTreePrinter.tokenNames; }
+	public override string GrammarFileName { get { return "Grammars\\ANTLRTreePrinter.g3"; } }
+
+
+	#region Rules
+
+	// $ANTLR start "toString"
+	// Grammars\\ANTLRTreePrinter.g3:89:0: public toString[Grammar g, bool showActions] returns [string s=null] : ( grammar_ | rule | alternative | element | single_rewrite | EOR ) ;
+	public string toString( Grammar g, bool showActions )
+	{
+
+		string s = null;
+
+
+			grammar = g;
+			this.showActions = showActions;
+
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:95:4: ( ( grammar_ | rule | alternative | element | single_rewrite | EOR ) )
+			// Grammars\\ANTLRTreePrinter.g3:95:4: ( grammar_ | rule | alternative | element | single_rewrite | EOR )
+			{
+			// Grammars\\ANTLRTreePrinter.g3:95:4: ( grammar_ | rule | alternative | element | single_rewrite | EOR )
+			int alt1=6;
+			switch ( input.LA(1) )
+			{
+			case COMBINED_GRAMMAR:
+			case LEXER_GRAMMAR:
+			case PARSER_GRAMMAR:
+			case TREE_GRAMMAR:
+				{
+				alt1=1;
+				}
+				break;
+			case RULE:
+				{
+				alt1=2;
+				}
+				break;
+			case ALT:
+				{
+				alt1=3;
+				}
+				break;
+			case ACTION:
+			case ASSIGN:
+			case BACKTRACK_SEMPRED:
+			case BANG:
+			case BLOCK:
+			case CHAR_LITERAL:
+			case CHAR_RANGE:
+			case CLOSURE:
+			case DOT:
+			case EPSILON:
+			case FORCED_ACTION:
+			case GATED_SEMPRED:
+			case LABEL:
+			case NOT:
+			case OPTIONAL:
+			case PLUS_ASSIGN:
+			case POSITIVE_CLOSURE:
+			case RANGE:
+			case ROOT:
+			case RULE_REF:
+			case SEMPRED:
+			case STRING_LITERAL:
+			case SYN_SEMPRED:
+			case SYNPRED:
+			case TOKEN_REF:
+			case TREE_BEGIN:
+			case WILDCARD:
+				{
+				alt1=4;
+				}
+				break;
+			case REWRITE:
+				{
+				alt1=5;
+				}
+				break;
+			case EOR:
+				{
+				alt1=6;
+				}
+				break;
+			default:
+				{
+					NoViableAltException nvae = new NoViableAltException("", 1, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt1 )
+			{
+			case 1:
+				// Grammars\\ANTLRTreePrinter.g3:95:6: grammar_
+				{
+				PushFollow(Follow._grammar__in_toString72);
+				grammar_();
+
+				state._fsp--;
+
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLRTreePrinter.g3:96:5: rule
+				{
+				PushFollow(Follow._rule_in_toString78);
+				rule();
+
+				state._fsp--;
+
+
+				}
+				break;
+			case 3:
+				// Grammars\\ANTLRTreePrinter.g3:97:5: alternative
+				{
+				PushFollow(Follow._alternative_in_toString84);
+				alternative();
+
+				state._fsp--;
+
+
+				}
+				break;
+			case 4:
+				// Grammars\\ANTLRTreePrinter.g3:98:5: element
+				{
+				PushFollow(Follow._element_in_toString90);
+				element();
+
+				state._fsp--;
+
+
+				}
+				break;
+			case 5:
+				// Grammars\\ANTLRTreePrinter.g3:99:5: single_rewrite
+				{
+				PushFollow(Follow._single_rewrite_in_toString96);
+				single_rewrite();
+
+				state._fsp--;
+
+
+				}
+				break;
+			case 6:
+				// Grammars\\ANTLRTreePrinter.g3:100:5: EOR
+				{
+				Match(input,EOR,Follow._EOR_in_toString102);
+				s="EOR";
+
+				}
+				break;
+
+			}
+
+			return normalize(buf.ToString());
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return s;
+	}
+	// $ANTLR end "toString"
+
+
+	// $ANTLR start "grammar_"
+	// Grammars\\ANTLRTreePrinter.g3:107:0: grammar_ : ( ^( LEXER_GRAMMAR grammarSpec[\"lexer \" ] ) | ^( PARSER_GRAMMAR grammarSpec[\"parser \"] ) | ^( TREE_GRAMMAR grammarSpec[\"tree \"] ) | ^( COMBINED_GRAMMAR grammarSpec[\"\"] ) );
+	private void grammar_(  )
+	{
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:108:4: ( ^( LEXER_GRAMMAR grammarSpec[\"lexer \" ] ) | ^( PARSER_GRAMMAR grammarSpec[\"parser \"] ) | ^( TREE_GRAMMAR grammarSpec[\"tree \"] ) | ^( COMBINED_GRAMMAR grammarSpec[\"\"] ) )
+			int alt2=4;
+			switch ( input.LA(1) )
+			{
+			case LEXER_GRAMMAR:
+				{
+				alt2=1;
+				}
+				break;
+			case PARSER_GRAMMAR:
+				{
+				alt2=2;
+				}
+				break;
+			case TREE_GRAMMAR:
+				{
+				alt2=3;
+				}
+				break;
+			case COMBINED_GRAMMAR:
+				{
+				alt2=4;
+				}
+				break;
+			default:
+				{
+					NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt2 )
+			{
+			case 1:
+				// Grammars\\ANTLRTreePrinter.g3:108:4: ^( LEXER_GRAMMAR grammarSpec[\"lexer \" ] )
+				{
+				Match(input,LEXER_GRAMMAR,Follow._LEXER_GRAMMAR_in_grammar_127);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._grammarSpec_in_grammar_129);
+				grammarSpec("lexer ");
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLRTreePrinter.g3:109:4: ^( PARSER_GRAMMAR grammarSpec[\"parser \"] )
+				{
+				Match(input,PARSER_GRAMMAR,Follow._PARSER_GRAMMAR_in_grammar_139);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._grammarSpec_in_grammar_141);
+				grammarSpec("parser ");
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 3:
+				// Grammars\\ANTLRTreePrinter.g3:110:4: ^( TREE_GRAMMAR grammarSpec[\"tree \"] )
+				{
+				Match(input,TREE_GRAMMAR,Follow._TREE_GRAMMAR_in_grammar_151);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._grammarSpec_in_grammar_153);
+				grammarSpec("tree ");
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 4:
+				// Grammars\\ANTLRTreePrinter.g3:111:4: ^( COMBINED_GRAMMAR grammarSpec[\"\"] )
+				{
+				Match(input,COMBINED_GRAMMAR,Follow._COMBINED_GRAMMAR_in_grammar_163);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._grammarSpec_in_grammar_165);
+				grammarSpec("");
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "grammar_"
+
+
+	// $ANTLR start "attrScope"
+	// Grammars\\ANTLRTreePrinter.g3:114:0: attrScope : ^( 'scope' ID ( ruleAction )* ACTION ) ;
+	private void attrScope(  )
+	{
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:115:4: ( ^( 'scope' ID ( ruleAction )* ACTION ) )
+			// Grammars\\ANTLRTreePrinter.g3:115:4: ^( 'scope' ID ( ruleAction )* ACTION )
+			{
+			Match(input,SCOPE,Follow._SCOPE_in_attrScope181);
+
+			Match(input, TokenConstants.DOWN, null);
+			Match(input,ID,Follow._ID_in_attrScope183);
+			// Grammars\\ANTLRTreePrinter.g3:115:18: ( ruleAction )*
+			for ( ; ; )
+			{
+				int alt3=2;
+				int LA3_0 = input.LA(1);
+
+				if ( (LA3_0==AMPERSAND) )
+				{
+					alt3=1;
+				}
+
+
+				switch ( alt3 )
+				{
+				case 1:
+					// Grammars\\ANTLRTreePrinter.g3:115:0: ruleAction
+					{
+					PushFollow(Follow._ruleAction_in_attrScope185);
+					ruleAction();
+
+					state._fsp--;
+
+
+					}
+					break;
+
+				default:
+					goto loop3;
+				}
+			}
+
+			loop3:
+				;
+
+
+			Match(input,ACTION,Follow._ACTION_in_attrScope188);
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "attrScope"
+
+
+	// $ANTLR start "grammarSpec"
+	// Grammars\\ANTLRTreePrinter.g3:118:0: grammarSpec[string gtype] : id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( actions )? rules ;
+	private void grammarSpec( string gtype )
+	{
+		GrammarAST id=null;
+		GrammarAST cmt=null;
+
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:119:4: (id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( actions )? rules )
+			// Grammars\\ANTLRTreePrinter.g3:119:4: id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( actions )? rules
+			{
+			id=(GrammarAST)Match(input,ID,Follow._ID_in_grammarSpec204);
+			@out(gtype+"grammar "+(id!=null?id.Text:null));
+			// Grammars\\ANTLRTreePrinter.g3:120:3: (cmt= DOC_COMMENT )?
+			int alt4=2;
+			int LA4_0 = input.LA(1);
+
+			if ( (LA4_0==DOC_COMMENT) )
+			{
+				alt4=1;
+			}
+			switch ( alt4 )
+			{
+			case 1:
+				// Grammars\\ANTLRTreePrinter.g3:120:4: cmt= DOC_COMMENT
+				{
+				cmt=(GrammarAST)Match(input,DOC_COMMENT,Follow._DOC_COMMENT_in_grammarSpec213);
+				@out((cmt!=null?cmt.Text:null)+"\n");
+
+				}
+				break;
+
+			}
+
+			// Grammars\\ANTLRTreePrinter.g3:121:3: ( optionsSpec )?
+			int alt5=2;
+			int LA5_0 = input.LA(1);
+
+			if ( (LA5_0==OPTIONS) )
+			{
+				alt5=1;
+			}
+			switch ( alt5 )
+			{
+			case 1:
+				// Grammars\\ANTLRTreePrinter.g3:121:4: optionsSpec
+				{
+				PushFollow(Follow._optionsSpec_in_grammarSpec223);
+				optionsSpec();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			@out(";\n");
+			// Grammars\\ANTLRTreePrinter.g3:122:3: ( delegateGrammars )?
+			int alt6=2;
+			int LA6_0 = input.LA(1);
+
+			if ( (LA6_0==IMPORT) )
+			{
+				alt6=1;
+			}
+			switch ( alt6 )
+			{
+			case 1:
+				// Grammars\\ANTLRTreePrinter.g3:122:4: delegateGrammars
+				{
+				PushFollow(Follow._delegateGrammars_in_grammarSpec232);
+				delegateGrammars();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			// Grammars\\ANTLRTreePrinter.g3:123:3: ( tokensSpec )?
+			int alt7=2;
+			int LA7_0 = input.LA(1);
+
+			if ( (LA7_0==TOKENS) )
+			{
+				alt7=1;
+			}
+			switch ( alt7 )
+			{
+			case 1:
+				// Grammars\\ANTLRTreePrinter.g3:123:4: tokensSpec
+				{
+				PushFollow(Follow._tokensSpec_in_grammarSpec239);
+				tokensSpec();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			// Grammars\\ANTLRTreePrinter.g3:124:3: ( attrScope )*
+			for ( ; ; )
+			{
+				int alt8=2;
+				int LA8_0 = input.LA(1);
+
+				if ( (LA8_0==SCOPE) )
+				{
+					alt8=1;
+				}
+
+
+				switch ( alt8 )
+				{
+				case 1:
+					// Grammars\\ANTLRTreePrinter.g3:124:4: attrScope
+					{
+					PushFollow(Follow._attrScope_in_grammarSpec246);
+					attrScope();
+
+					state._fsp--;
+
+
+					}
+					break;
+
+				default:
+					goto loop8;
+				}
+			}
+
+			loop8:
+				;
+
+
+			// Grammars\\ANTLRTreePrinter.g3:125:3: ( actions )?
+			int alt9=2;
+			int LA9_0 = input.LA(1);
+
+			if ( (LA9_0==AMPERSAND) )
+			{
+				alt9=1;
+			}
+			switch ( alt9 )
+			{
+			case 1:
+				// Grammars\\ANTLRTreePrinter.g3:125:4: actions
+				{
+				PushFollow(Follow._actions_in_grammarSpec253);
+				actions();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			PushFollow(Follow._rules_in_grammarSpec259);
+			rules();
+
+			state._fsp--;
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "grammarSpec"
+
+
+	// $ANTLR start "actions"
+	// Grammars\\ANTLRTreePrinter.g3:129:0: actions : ( action )+ ;
+	private void actions(  )
+	{
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:130:4: ( ( action )+ )
+			// Grammars\\ANTLRTreePrinter.g3:130:4: ( action )+
+			{
+			// Grammars\\ANTLRTreePrinter.g3:130:4: ( action )+
+			int cnt10=0;
+			for ( ; ; )
+			{
+				int alt10=2;
+				int LA10_0 = input.LA(1);
+
+				if ( (LA10_0==AMPERSAND) )
+				{
+					alt10=1;
+				}
+
+
+				switch ( alt10 )
+				{
+				case 1:
+					// Grammars\\ANTLRTreePrinter.g3:130:6: action
+					{
+					PushFollow(Follow._action_in_actions272);
+					action();
+
+					state._fsp--;
+
+
+					}
+					break;
+
+				default:
+					if ( cnt10 >= 1 )
+						goto loop10;
+
+					EarlyExitException eee10 = new EarlyExitException( 10, input );
+					throw eee10;
+				}
+				cnt10++;
+			}
+			loop10:
+				;
+
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "actions"
+
+
+	// $ANTLR start "action"
+	// Grammars\\ANTLRTreePrinter.g3:133:0: action : ^( AMPERSAND id1= ID (id2= ID a1= ACTION |a2= ACTION ) ) ;
+	private void action(  )
+	{
+		GrammarAST id1=null;
+		GrammarAST id2=null;
+		GrammarAST a1=null;
+		GrammarAST a2=null;
+
+
+			string scope=null, name=null;
+			string action=null;
+
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:139:4: ( ^( AMPERSAND id1= ID (id2= ID a1= ACTION |a2= ACTION ) ) )
+			// Grammars\\ANTLRTreePrinter.g3:139:4: ^( AMPERSAND id1= ID (id2= ID a1= ACTION |a2= ACTION ) )
+			{
+			Match(input,AMPERSAND,Follow._AMPERSAND_in_action293);
+
+			Match(input, TokenConstants.DOWN, null);
+			id1=(GrammarAST)Match(input,ID,Follow._ID_in_action297);
+			// Grammars\\ANTLRTreePrinter.g3:140:4: (id2= ID a1= ACTION |a2= ACTION )
+			int alt11=2;
+			int LA11_0 = input.LA(1);
+
+			if ( (LA11_0==ID) )
+			{
+				alt11=1;
+			}
+			else if ( (LA11_0==ACTION) )
+			{
+				alt11=2;
+			}
+			else
+			{
+				NoViableAltException nvae = new NoViableAltException("", 11, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt11 )
+			{
+			case 1:
+				// Grammars\\ANTLRTreePrinter.g3:140:6: id2= ID a1= ACTION
+				{
+				id2=(GrammarAST)Match(input,ID,Follow._ID_in_action306);
+				a1=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_action310);
+				scope=(id1!=null?id1.Text:null); name=(a1!=null?a1.Text:null); action=(a1!=null?a1.Text:null);
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLRTreePrinter.g3:142:6: a2= ACTION
+				{
+				a2=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_action325);
+				scope=null; name=(id1!=null?id1.Text:null); action=(a2!=null?a2.Text:null);
+
+				}
+				break;
+
+			}
+
+
+			Match(input, TokenConstants.UP, null);
+
+						if ( showActions )
+						{
+							@out("@"+(scope!=null?scope+"::":"")+name+action);
+						}
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "action"
+
+
+	// $ANTLR start "optionsSpec"
+	// Grammars\\ANTLRTreePrinter.g3:154:0: optionsSpec : ^( OPTIONS ( option )+ ) ;
+	private void optionsSpec(  )
+	{
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:155:4: ( ^( OPTIONS ( option )+ ) )
+			// Grammars\\ANTLRTreePrinter.g3:155:4: ^( OPTIONS ( option )+ )
+			{
+			Match(input,OPTIONS,Follow._OPTIONS_in_optionsSpec357);
+
+			@out(" options {");
+
+			Match(input, TokenConstants.DOWN, null);
+			// Grammars\\ANTLRTreePrinter.g3:156:4: ( option )+
+			int cnt12=0;
+			for ( ; ; )
+			{
+				int alt12=2;
+				int LA12_0 = input.LA(1);
+
+				if ( (LA12_0==ASSIGN) )
+				{
+					alt12=1;
+				}
+
+
+				switch ( alt12 )
+				{
+				case 1:
+					// Grammars\\ANTLRTreePrinter.g3:156:5: option
+					{
+					PushFollow(Follow._option_in_optionsSpec365);
+					option();
+
+					state._fsp--;
+
+					@out("; ");
+
+					}
+					break;
+
+				default:
+					if ( cnt12 >= 1 )
+						goto loop12;
+
+					EarlyExitException eee12 = new EarlyExitException( 12, input );
+					throw eee12;
+				}
+				cnt12++;
+			}
+			loop12:
+				;
+
+
+			@out("} ");
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "optionsSpec"
+
+
+	// $ANTLR start "option"
+	// Grammars\\ANTLRTreePrinter.g3:161:0: option : ^( ASSIGN id= ID optionValue ) ;
+	private void option(  )
+	{
+		GrammarAST id=null;
+
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:162:4: ( ^( ASSIGN id= ID optionValue ) )
+			// Grammars\\ANTLRTreePrinter.g3:162:4: ^( ASSIGN id= ID optionValue )
+			{
+			Match(input,ASSIGN,Follow._ASSIGN_in_option391);
+
+			Match(input, TokenConstants.DOWN, null);
+			id=(GrammarAST)Match(input,ID,Follow._ID_in_option395);
+			@out((id!=null?id.Text:null)+"=");
+			PushFollow(Follow._optionValue_in_option399);
+			optionValue();
+
+			state._fsp--;
+
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "option"
+
+
+	// $ANTLR start "optionValue"
+	// Grammars\\ANTLRTreePrinter.g3:165:0: optionValue : (id= ID |s= STRING_LITERAL |c= CHAR_LITERAL |i= INT );
+	private void optionValue(  )
+	{
+		GrammarAST id=null;
+		GrammarAST s=null;
+		GrammarAST c=null;
+		GrammarAST i=null;
+
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:166:4: (id= ID |s= STRING_LITERAL |c= CHAR_LITERAL |i= INT )
+			int alt13=4;
+			switch ( input.LA(1) )
+			{
+			case ID:
+				{
+				alt13=1;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt13=2;
+				}
+				break;
+			case CHAR_LITERAL:
+				{
+				alt13=3;
+				}
+				break;
+			case INT:
+				{
+				alt13=4;
+				}
+				break;
+			default:
+				{
+					NoViableAltException nvae = new NoViableAltException("", 13, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt13 )
+			{
+			case 1:
+				// Grammars\\ANTLRTreePrinter.g3:166:4: id= ID
+				{
+				id=(GrammarAST)Match(input,ID,Follow._ID_in_optionValue414);
+				@out((id!=null?id.Text:null));
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLRTreePrinter.g3:167:4: s= STRING_LITERAL
+				{
+				s=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_optionValue434);
+				@out((s!=null?s.Text:null));
+
+				}
+				break;
+			case 3:
+				// Grammars\\ANTLRTreePrinter.g3:168:4: c= CHAR_LITERAL
+				{
+				c=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_optionValue443);
+				@out((c!=null?c.Text:null));
+
+				}
+				break;
+			case 4:
+				// Grammars\\ANTLRTreePrinter.g3:169:4: i= INT
+				{
+				i=(GrammarAST)Match(input,INT,Follow._INT_in_optionValue454);
+				@out((i!=null?i.Text:null));
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "optionValue"
+
+
+	// $ANTLR start "delegateGrammars"
+	// Grammars\\ANTLRTreePrinter.g3:185:0: delegateGrammars : ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ ) ;
+	private void delegateGrammars(  )
+	{
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:186:4: ( ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ ) )
+			// Grammars\\ANTLRTreePrinter.g3:186:4: ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ )
+			{
+			Match(input,IMPORT,Follow._IMPORT_in_delegateGrammars484);
+
+			Match(input, TokenConstants.DOWN, null);
+			// Grammars\\ANTLRTreePrinter.g3:186:16: ( ^( ASSIGN ID ID ) | ID )+
+			int cnt14=0;
+			for ( ; ; )
+			{
+				int alt14=3;
+				int LA14_0 = input.LA(1);
+
+				if ( (LA14_0==ASSIGN) )
+				{
+					alt14=1;
+				}
+				else if ( (LA14_0==ID) )
+				{
+					alt14=2;
+				}
+
+
+				switch ( alt14 )
+				{
+				case 1:
+					// Grammars\\ANTLRTreePrinter.g3:186:18: ^( ASSIGN ID ID )
+					{
+					Match(input,ASSIGN,Follow._ASSIGN_in_delegateGrammars489);
+
+					Match(input, TokenConstants.DOWN, null);
+					Match(input,ID,Follow._ID_in_delegateGrammars491);
+					Match(input,ID,Follow._ID_in_delegateGrammars493);
+
+					Match(input, TokenConstants.UP, null);
+
+					}
+					break;
+				case 2:
+					// Grammars\\ANTLRTreePrinter.g3:186:36: ID
+					{
+					Match(input,ID,Follow._ID_in_delegateGrammars498);
+
+					}
+					break;
+
+				default:
+					if ( cnt14 >= 1 )
+						goto loop14;
+
+					EarlyExitException eee14 = new EarlyExitException( 14, input );
+					throw eee14;
+				}
+				cnt14++;
+			}
+			loop14:
+				;
+
+
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "delegateGrammars"
+
+
+	// $ANTLR start "tokensSpec"
+	// Grammars\\ANTLRTreePrinter.g3:189:0: tokensSpec : ^( TOKENS ( tokenSpec )+ ) ;
+	private void tokensSpec(  )
+	{
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:190:4: ( ^( TOKENS ( tokenSpec )+ ) )
+			// Grammars\\ANTLRTreePrinter.g3:190:4: ^( TOKENS ( tokenSpec )+ )
+			{
+			Match(input,TOKENS,Follow._TOKENS_in_tokensSpec516);
+
+			Match(input, TokenConstants.DOWN, null);
+			// Grammars\\ANTLRTreePrinter.g3:190:14: ( tokenSpec )+
+			int cnt15=0;
+			for ( ; ; )
+			{
+				int alt15=2;
+				int LA15_0 = input.LA(1);
+
+				if ( (LA15_0==ASSIGN||LA15_0==TOKEN_REF) )
+				{
+					alt15=1;
+				}
+
+
+				switch ( alt15 )
+				{
+				case 1:
+					// Grammars\\ANTLRTreePrinter.g3:190:16: tokenSpec
+					{
+					PushFollow(Follow._tokenSpec_in_tokensSpec520);
+					tokenSpec();
+
+					state._fsp--;
+
+
+					}
+					break;
+
+				default:
+					if ( cnt15 >= 1 )
+						goto loop15;
+
+					EarlyExitException eee15 = new EarlyExitException( 15, input );
+					throw eee15;
+				}
+				cnt15++;
+			}
+			loop15:
+				;
+
+
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "tokensSpec"
+
+
+	// $ANTLR start "tokenSpec"
+	// Grammars\\ANTLRTreePrinter.g3:193:0: tokenSpec : ( TOKEN_REF | ^( ASSIGN TOKEN_REF ( STRING_LITERAL | CHAR_LITERAL ) ) );
+	private void tokenSpec(  )
+	{
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:194:4: ( TOKEN_REF | ^( ASSIGN TOKEN_REF ( STRING_LITERAL | CHAR_LITERAL ) ) )
+			int alt16=2;
+			int LA16_0 = input.LA(1);
+
+			if ( (LA16_0==TOKEN_REF) )
+			{
+				alt16=1;
+			}
+			else if ( (LA16_0==ASSIGN) )
+			{
+				alt16=2;
+			}
+			else
+			{
+				NoViableAltException nvae = new NoViableAltException("", 16, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt16 )
+			{
+			case 1:
+				// Grammars\\ANTLRTreePrinter.g3:194:4: TOKEN_REF
+				{
+				Match(input,TOKEN_REF,Follow._TOKEN_REF_in_tokenSpec536);
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLRTreePrinter.g3:195:4: ^( ASSIGN TOKEN_REF ( STRING_LITERAL | CHAR_LITERAL ) )
+				{
+				Match(input,ASSIGN,Follow._ASSIGN_in_tokenSpec543);
+
+				Match(input, TokenConstants.DOWN, null);
+				Match(input,TOKEN_REF,Follow._TOKEN_REF_in_tokenSpec545);
+				if ( input.LA(1)==CHAR_LITERAL||input.LA(1)==STRING_LITERAL )
+				{
+					input.Consume();
+					state.errorRecovery=false;
+				}
+				else
+				{
+					MismatchedSetException mse = new MismatchedSetException(null,input);
+					throw mse;
+				}
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "tokenSpec"
+
+
+	// $ANTLR start "rules"
+	// Grammars\\ANTLRTreePrinter.g3:198:0: rules : ( rule )+ ;
+	private void rules(  )
+	{
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:199:4: ( ( rule )+ )
+			// Grammars\\ANTLRTreePrinter.g3:199:4: ( rule )+
+			{
+			// Grammars\\ANTLRTreePrinter.g3:199:4: ( rule )+
+			int cnt17=0;
+			for ( ; ; )
+			{
+				int alt17=2;
+				int LA17_0 = input.LA(1);
+
+				if ( (LA17_0==RULE) )
+				{
+					alt17=1;
+				}
+
+
+				switch ( alt17 )
+				{
+				case 1:
+					// Grammars\\ANTLRTreePrinter.g3:199:6: rule
+					{
+					PushFollow(Follow._rule_in_rules566);
+					rule();
+
+					state._fsp--;
+
+
+					}
+					break;
+
+				default:
+					if ( cnt17 >= 1 )
+						goto loop17;
+
+					EarlyExitException eee17 = new EarlyExitException( 17, input );
+					throw eee17;
+				}
+				cnt17++;
+			}
+			loop17:
+				;
+
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "rules"
+
+
+	// $ANTLR start "rule"
+	// Grammars\\ANTLRTreePrinter.g3:202:0: rule : ^( RULE id= ID ( modifier )? ^( ARG (arg= ARG_ACTION )? ) ^( RET (ret= ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ruleAction )* b= block[false] ( exceptionGroup )? EOR ) ;
+	private void rule(  )
+	{
+		GrammarAST id=null;
+		GrammarAST arg=null;
+		GrammarAST ret=null;
+		ANTLRTreePrinter.block_return b = default(ANTLRTreePrinter.block_return);
+
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:203:4: ( ^( RULE id= ID ( modifier )? ^( ARG (arg= ARG_ACTION )? ) ^( RET (ret= ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ruleAction )* b= block[false] ( exceptionGroup )? EOR ) )
+			// Grammars\\ANTLRTreePrinter.g3:203:4: ^( RULE id= ID ( modifier )? ^( ARG (arg= ARG_ACTION )? ) ^( RET (ret= ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ruleAction )* b= block[false] ( exceptionGroup )? EOR )
+			{
+			Match(input,RULE,Follow._RULE_in_rule582);
+
+			Match(input, TokenConstants.DOWN, null);
+			id=(GrammarAST)Match(input,ID,Follow._ID_in_rule586);
+			// Grammars\\ANTLRTreePrinter.g3:204:4: ( modifier )?
+			int alt18=2;
+			int LA18_0 = input.LA(1);
+
+			if ( (LA18_0==FRAGMENT||(LA18_0>=PRIVATE && LA18_0<=PUBLIC)) )
+			{
+				alt18=1;
+			}
+			switch ( alt18 )
+			{
+			case 1:
+				// Grammars\\ANTLRTreePrinter.g3:204:5: modifier
+				{
+				PushFollow(Follow._modifier_in_rule592);
+				modifier();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			@out((id!=null?id.Text:null));
+			Match(input,ARG,Follow._ARG_in_rule605);
+
+			if ( input.LA(1)==TokenConstants.DOWN )
+			{
+				Match(input, TokenConstants.DOWN, null);
+				// Grammars\\ANTLRTreePrinter.g3:206:10: (arg= ARG_ACTION )?
+				int alt19=2;
+				int LA19_0 = input.LA(1);
+
+				if ( (LA19_0==ARG_ACTION) )
+				{
+					alt19=1;
+				}
+				switch ( alt19 )
+				{
+				case 1:
+					// Grammars\\ANTLRTreePrinter.g3:206:11: arg= ARG_ACTION
+					{
+					arg=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule610);
+					@out("["+(arg!=null?arg.Text:null)+"]");
+
+					}
+					break;
+
+				}
+
+
+				Match(input, TokenConstants.UP, null);
+			}
+			Match(input,RET,Follow._RET_in_rule623);
+
+			if ( input.LA(1)==TokenConstants.DOWN )
+			{
+				Match(input, TokenConstants.DOWN, null);
+				// Grammars\\ANTLRTreePrinter.g3:207:10: (ret= ARG_ACTION )?
+				int alt20=2;
+				int LA20_0 = input.LA(1);
+
+				if ( (LA20_0==ARG_ACTION) )
+				{
+					alt20=1;
+				}
+				switch ( alt20 )
+				{
+				case 1:
+					// Grammars\\ANTLRTreePrinter.g3:207:11: ret= ARG_ACTION
+					{
+					ret=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule628);
+					@out(" returns ["+(ret!=null?ret.Text:null)+"]");
+
+					}
+					break;
+
+				}
+
+
+				Match(input, TokenConstants.UP, null);
+			}
+			// Grammars\\ANTLRTreePrinter.g3:208:4: ( throwsSpec )?
+			int alt21=2;
+			int LA21_0 = input.LA(1);
+
+			if ( (LA21_0==THROWS) )
+			{
+				alt21=1;
+			}
+			switch ( alt21 )
+			{
+			case 1:
+				// Grammars\\ANTLRTreePrinter.g3:208:5: throwsSpec
+				{
+				PushFollow(Follow._throwsSpec_in_rule641);
+				throwsSpec();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			// Grammars\\ANTLRTreePrinter.g3:209:4: ( optionsSpec )?
+			int alt22=2;
+			int LA22_0 = input.LA(1);
+
+			if ( (LA22_0==OPTIONS) )
+			{
+				alt22=1;
+			}
+			switch ( alt22 )
+			{
+			case 1:
+				// Grammars\\ANTLRTreePrinter.g3:209:5: optionsSpec
+				{
+				PushFollow(Follow._optionsSpec_in_rule649);
+				optionsSpec();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			// Grammars\\ANTLRTreePrinter.g3:210:4: ( ruleScopeSpec )?
+			int alt23=2;
+			int LA23_0 = input.LA(1);
+
+			if ( (LA23_0==SCOPE) )
+			{
+				alt23=1;
+			}
+			switch ( alt23 )
+			{
+			case 1:
+				// Grammars\\ANTLRTreePrinter.g3:210:5: ruleScopeSpec
+				{
+				PushFollow(Follow._ruleScopeSpec_in_rule657);
+				ruleScopeSpec();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			// Grammars\\ANTLRTreePrinter.g3:211:4: ( ruleAction )*
+			for ( ; ; )
+			{
+				int alt24=2;
+				int LA24_0 = input.LA(1);
+
+				if ( (LA24_0==AMPERSAND) )
+				{
+					alt24=1;
+				}
+
+
+				switch ( alt24 )
+				{
+				case 1:
+					// Grammars\\ANTLRTreePrinter.g3:211:5: ruleAction
+					{
+					PushFollow(Follow._ruleAction_in_rule665);
+					ruleAction();
+
+					state._fsp--;
+
+
+					}
+					break;
+
+				default:
+					goto loop24;
+				}
+			}
+
+			loop24:
+				;
+
+
+			@out(" :");
+
+							if ( input.LA(5) == NOT || input.LA(5) == ASSIGN )
+								@out(" ");
+
+			PushFollow(Follow._block_in_rule684);
+			b=block(false);
+
+			state._fsp--;
+
+			// Grammars\\ANTLRTreePrinter.g3:218:4: ( exceptionGroup )?
+			int alt25=2;
+			int LA25_0 = input.LA(1);
+
+			if ( (LA25_0==CATCH||LA25_0==FINALLY) )
+			{
+				alt25=1;
+			}
+			switch ( alt25 )
+			{
+			case 1:
+				// Grammars\\ANTLRTreePrinter.g3:218:5: exceptionGroup
+				{
+				PushFollow(Follow._exceptionGroup_in_rule691);
+				exceptionGroup();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			Match(input,EOR,Follow._EOR_in_rule698);
+			@out(";\n");
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "rule"
+
+
+	// $ANTLR start "ruleAction"
+	// Grammars\\ANTLRTreePrinter.g3:223:0: ruleAction : ^( AMPERSAND id= ID a= ACTION ) ;
+	private void ruleAction(  )
+	{
+		GrammarAST id=null;
+		GrammarAST a=null;
+
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:224:4: ( ^( AMPERSAND id= ID a= ACTION ) )
+			// Grammars\\ANTLRTreePrinter.g3:224:4: ^( AMPERSAND id= ID a= ACTION )
+			{
+			Match(input,AMPERSAND,Follow._AMPERSAND_in_ruleAction716);
+
+			Match(input, TokenConstants.DOWN, null);
+			id=(GrammarAST)Match(input,ID,Follow._ID_in_ruleAction720);
+			a=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_ruleAction724);
+
+			Match(input, TokenConstants.UP, null);
+			if ( showActions ) @out("@"+(id!=null?id.Text:null)+"{"+(a!=null?a.Text:null)+"}");
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "ruleAction"
+
+	public class modifier_return : TreeRuleReturnScope
+	{
+	}
+
+	// $ANTLR start "modifier"
+	// Grammars\\ANTLRTreePrinter.g3:228:0: modifier : ( 'protected' | 'public' | 'private' | 'fragment' );
+	private ANTLRTreePrinter.modifier_return modifier(  )
+	{
+		ANTLRTreePrinter.modifier_return retval = new ANTLRTreePrinter.modifier_return();
+		retval.start = input.LT(1);
+
+		@out(((GrammarAST)retval.start).Text); @out(" ");
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:231:4: ( 'protected' | 'public' | 'private' | 'fragment' )
+			// Grammars\\ANTLRTreePrinter.g3:
+			{
+			if ( input.LA(1)==FRAGMENT||(input.LA(1)>=PRIVATE && input.LA(1)<=PUBLIC) )
+			{
+				input.Consume();
+				state.errorRecovery=false;
+			}
+			else
+			{
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				throw mse;
+			}
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "modifier"
+
+
+	// $ANTLR start "throwsSpec"
+	// Grammars\\ANTLRTreePrinter.g3:237:0: throwsSpec : ^( 'throws' ( ID )+ ) ;
+	private void throwsSpec(  )
+	{
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:238:4: ( ^( 'throws' ( ID )+ ) )
+			// Grammars\\ANTLRTreePrinter.g3:238:4: ^( 'throws' ( ID )+ )
+			{
+			Match(input,THROWS,Follow._THROWS_in_throwsSpec773);
+
+			Match(input, TokenConstants.DOWN, null);
+			// Grammars\\ANTLRTreePrinter.g3:238:15: ( ID )+
+			int cnt26=0;
+			for ( ; ; )
+			{
+				int alt26=2;
+				int LA26_0 = input.LA(1);
+
+				if ( (LA26_0==ID) )
+				{
+					alt26=1;
+				}
+
+
+				switch ( alt26 )
+				{
+				case 1:
+					// Grammars\\ANTLRTreePrinter.g3:238:0: ID
+					{
+					Match(input,ID,Follow._ID_in_throwsSpec775);
+
+					}
+					break;
+
+				default:
+					if ( cnt26 >= 1 )
+						goto loop26;
+
+					EarlyExitException eee26 = new EarlyExitException( 26, input );
+					throw eee26;
+				}
+				cnt26++;
+			}
+			loop26:
+				;
+
+
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "throwsSpec"
+
+
+	// $ANTLR start "ruleScopeSpec"
+	// Grammars\\ANTLRTreePrinter.g3:241:0: ruleScopeSpec : ^( 'scope' ( ruleAction )* ( ACTION )? ( ID )* ) ;
+	private void ruleScopeSpec(  )
+	{
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:242:4: ( ^( 'scope' ( ruleAction )* ( ACTION )? ( ID )* ) )
+			// Grammars\\ANTLRTreePrinter.g3:242:4: ^( 'scope' ( ruleAction )* ( ACTION )? ( ID )* )
+			{
+			Match(input,SCOPE,Follow._SCOPE_in_ruleScopeSpec790);
+
+			if ( input.LA(1)==TokenConstants.DOWN )
+			{
+				Match(input, TokenConstants.DOWN, null);
+				// Grammars\\ANTLRTreePrinter.g3:242:15: ( ruleAction )*
+				for ( ; ; )
+				{
+					int alt27=2;
+					int LA27_0 = input.LA(1);
+
+					if ( (LA27_0==AMPERSAND) )
+					{
+						alt27=1;
+					}
+
+
+					switch ( alt27 )
+					{
+					case 1:
+						// Grammars\\ANTLRTreePrinter.g3:242:0: ruleAction
+						{
+						PushFollow(Follow._ruleAction_in_ruleScopeSpec792);
+						ruleAction();
+
+						state._fsp--;
+
+
+						}
+						break;
+
+					default:
+						goto loop27;
+					}
+				}
+
+				loop27:
+					;
+
+
+				// Grammars\\ANTLRTreePrinter.g3:242:27: ( ACTION )?
+				int alt28=2;
+				int LA28_0 = input.LA(1);
+
+				if ( (LA28_0==ACTION) )
+				{
+					alt28=1;
+				}
+				switch ( alt28 )
+				{
+				case 1:
+					// Grammars\\ANTLRTreePrinter.g3:242:28: ACTION
+					{
+					Match(input,ACTION,Follow._ACTION_in_ruleScopeSpec796);
+
+					}
+					break;
+
+				}
+
+				// Grammars\\ANTLRTreePrinter.g3:242:37: ( ID )*
+				for ( ; ; )
+				{
+					int alt29=2;
+					int LA29_0 = input.LA(1);
+
+					if ( (LA29_0==ID) )
+					{
+						alt29=1;
+					}
+
+
+					switch ( alt29 )
+					{
+					case 1:
+						// Grammars\\ANTLRTreePrinter.g3:242:39: ID
+						{
+						Match(input,ID,Follow._ID_in_ruleScopeSpec802);
+
+						}
+						break;
+
+					default:
+						goto loop29;
+					}
+				}
+
+				loop29:
+					;
+
+
+
+				Match(input, TokenConstants.UP, null);
+			}
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "ruleScopeSpec"
+
+	public class block_return : TreeRuleReturnScope
+	{
+	}
+
+	// $ANTLR start "block"
+	// Grammars\\ANTLRTreePrinter.g3:245:0: block[bool forceParens] : ^( BLOCK ( optionsSpec )? alternative rewrite ( alternative rewrite )* EOB ) ;
+	private ANTLRTreePrinter.block_return block( bool forceParens )
+	{
+		ANTLRTreePrinter.block_return retval = new ANTLRTreePrinter.block_return();
+		retval.start = input.LT(1);
+
+
+		int numAlts = countAltsForBlock(((GrammarAST)retval.start));
+
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:250:4: ( ^( BLOCK ( optionsSpec )? alternative rewrite ( alternative rewrite )* EOB ) )
+			// Grammars\\ANTLRTreePrinter.g3:250:4: ^( BLOCK ( optionsSpec )? alternative rewrite ( alternative rewrite )* EOB )
+			{
+			Match(input,BLOCK,Follow._BLOCK_in_block826);
+
+
+							if ( forceParens||numAlts>1 )
+							{
+								//for ( Antlr.Runtime.Tree.Tree parent = ((GrammarAST)retval.start).getParent(); parent != null && parent.getType() != RULE; parent = parent.getParent() )
+								//{
+								//	if ( parent.getType() == BLOCK && countAltsForBlock((GrammarAST)parent) > 1 )
+								//	{
+								//		@out(" ");
+								//		break;
+								//	}
+								//}
+								@out(" (");
+							}
+
+
+			Match(input, TokenConstants.DOWN, null);
+			// Grammars\\ANTLRTreePrinter.g3:265:4: ( optionsSpec )?
+			int alt30=2;
+			int LA30_0 = input.LA(1);
+
+			if ( (LA30_0==OPTIONS) )
+			{
+				alt30=1;
+			}
+			switch ( alt30 )
+			{
+			case 1:
+				// Grammars\\ANTLRTreePrinter.g3:265:5: optionsSpec
+				{
+				PushFollow(Follow._optionsSpec_in_block837);
+				optionsSpec();
+
+				state._fsp--;
+
+				@out(" :");
+
+				}
+				break;
+
+			}
+
+			PushFollow(Follow._alternative_in_block847);
+			alternative();
+
+			state._fsp--;
+
+			PushFollow(Follow._rewrite_in_block849);
+			rewrite();
+
+			state._fsp--;
+
+			// Grammars\\ANTLRTreePrinter.g3:266:24: ( alternative rewrite )*
+			for ( ; ; )
+			{
+				int alt31=2;
+				int LA31_0 = input.LA(1);
+
+				if ( (LA31_0==ALT) )
+				{
+					alt31=1;
+				}
+
+
+				switch ( alt31 )
+				{
+				case 1:
+					// Grammars\\ANTLRTreePrinter.g3:266:26: alternative rewrite
+					{
+					@out("|");
+					PushFollow(Follow._alternative_in_block855);
+					alternative();
+
+					state._fsp--;
+
+					PushFollow(Follow._rewrite_in_block857);
+					rewrite();
+
+					state._fsp--;
+
+
+					}
+					break;
+
+				default:
+					goto loop31;
+				}
+			}
+
+			loop31:
+				;
+
+
+			Match(input,EOB,Follow._EOB_in_block865);
+			if ( forceParens||numAlts>1 ) @out(")");
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "block"
+
+
+	// $ANTLR start "alternative"
+	// Grammars\\ANTLRTreePrinter.g3:271:0: alternative : ^( ALT ( element )+ EOA ) ;
+	private void alternative(  )
+	{
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:272:4: ( ^( ALT ( element )+ EOA ) )
+			// Grammars\\ANTLRTreePrinter.g3:272:4: ^( ALT ( element )+ EOA )
+			{
+			Match(input,ALT,Follow._ALT_in_alternative887);
+
+			Match(input, TokenConstants.DOWN, null);
+			// Grammars\\ANTLRTreePrinter.g3:272:11: ( element )+
+			int cnt32=0;
+			for ( ; ; )
+			{
+				int alt32=2;
+				int LA32_0 = input.LA(1);
+
+				if ( (LA32_0==ACTION||(LA32_0>=ASSIGN && LA32_0<=BLOCK)||(LA32_0>=CHAR_LITERAL && LA32_0<=CHAR_RANGE)||LA32_0==CLOSURE||LA32_0==DOT||LA32_0==EPSILON||LA32_0==FORCED_ACTION||LA32_0==GATED_SEMPRED||LA32_0==LABEL||LA32_0==NOT||LA32_0==OPTIONAL||(LA32_0>=PLUS_ASSIGN && LA32_0<=POSITIVE_CLOSURE)||LA32_0==RANGE||LA32_0==ROOT||LA32_0==RULE_REF||LA32_0==SEMPRED||(LA32_0>=STRING_LITERAL && LA32_0<=SYNPRED)||LA32_0==TOKEN_REF||LA32_0==TREE_BEGIN||LA32_0==WILDCARD) )
+				{
+					alt32=1;
+				}
+
+
+				switch ( alt32 )
+				{
+				case 1:
+					// Grammars\\ANTLRTreePrinter.g3:272:12: element
+					{
+					PushFollow(Follow._element_in_alternative890);
+					element();
+
+					state._fsp--;
+
+
+					}
+					break;
+
+				default:
+					if ( cnt32 >= 1 )
+						goto loop32;
+
+					EarlyExitException eee32 = new EarlyExitException( 32, input );
+					throw eee32;
+				}
+				cnt32++;
+			}
+			loop32:
+				;
+
+
+			Match(input,EOA,Follow._EOA_in_alternative894);
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "alternative"
+
+
+	// $ANTLR start "exceptionGroup"
+	// Grammars\\ANTLRTreePrinter.g3:275:0: exceptionGroup : ( ( exceptionHandler )+ ( finallyClause )? | finallyClause );
+	private void exceptionGroup(  )
+	{
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:276:4: ( ( exceptionHandler )+ ( finallyClause )? | finallyClause )
+			int alt35=2;
+			int LA35_0 = input.LA(1);
+
+			if ( (LA35_0==CATCH) )
+			{
+				alt35=1;
+			}
+			else if ( (LA35_0==FINALLY) )
+			{
+				alt35=2;
+			}
+			else
+			{
+				NoViableAltException nvae = new NoViableAltException("", 35, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt35 )
+			{
+			case 1:
+				// Grammars\\ANTLRTreePrinter.g3:276:4: ( exceptionHandler )+ ( finallyClause )?
+				{
+				// Grammars\\ANTLRTreePrinter.g3:276:4: ( exceptionHandler )+
+				int cnt33=0;
+				for ( ; ; )
+				{
+					int alt33=2;
+					int LA33_0 = input.LA(1);
+
+					if ( (LA33_0==CATCH) )
+					{
+						alt33=1;
+					}
+
+
+					switch ( alt33 )
+					{
+					case 1:
+						// Grammars\\ANTLRTreePrinter.g3:276:6: exceptionHandler
+						{
+						PushFollow(Follow._exceptionHandler_in_exceptionGroup909);
+						exceptionHandler();
+
+						state._fsp--;
+
+
+						}
+						break;
+
+					default:
+						if ( cnt33 >= 1 )
+							goto loop33;
+
+						EarlyExitException eee33 = new EarlyExitException( 33, input );
+						throw eee33;
+					}
+					cnt33++;
+				}
+				loop33:
+					;
+
+
+				// Grammars\\ANTLRTreePrinter.g3:276:26: ( finallyClause )?
+				int alt34=2;
+				int LA34_0 = input.LA(1);
+
+				if ( (LA34_0==FINALLY) )
+				{
+					alt34=1;
+				}
+				switch ( alt34 )
+				{
+				case 1:
+					// Grammars\\ANTLRTreePrinter.g3:276:27: finallyClause
+					{
+					PushFollow(Follow._finallyClause_in_exceptionGroup915);
+					finallyClause();
+
+					state._fsp--;
+
+
+					}
+					break;
+
+				}
+
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLRTreePrinter.g3:277:4: finallyClause
+				{
+				PushFollow(Follow._finallyClause_in_exceptionGroup922);
+				finallyClause();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "exceptionGroup"
+
+
+	// $ANTLR start "exceptionHandler"
+	// Grammars\\ANTLRTreePrinter.g3:280:0: exceptionHandler : ^( 'catch' ARG_ACTION ACTION ) ;
+	private void exceptionHandler(  )
+	{
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:281:4: ( ^( 'catch' ARG_ACTION ACTION ) )
+			// Grammars\\ANTLRTreePrinter.g3:281:4: ^( 'catch' ARG_ACTION ACTION )
+			{
+			Match(input,CATCH,Follow._CATCH_in_exceptionHandler934);
+
+			Match(input, TokenConstants.DOWN, null);
+			Match(input,ARG_ACTION,Follow._ARG_ACTION_in_exceptionHandler936);
+			Match(input,ACTION,Follow._ACTION_in_exceptionHandler938);
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "exceptionHandler"
+
+
+	// $ANTLR start "finallyClause"
+	// Grammars\\ANTLRTreePrinter.g3:284:0: finallyClause : ^( 'finally' ACTION ) ;
+	private void finallyClause(  )
+	{
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:285:4: ( ^( 'finally' ACTION ) )
+			// Grammars\\ANTLRTreePrinter.g3:285:4: ^( 'finally' ACTION )
+			{
+			Match(input,FINALLY,Follow._FINALLY_in_finallyClause951);
+
+			Match(input, TokenConstants.DOWN, null);
+			Match(input,ACTION,Follow._ACTION_in_finallyClause953);
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "finallyClause"
+
+
+	// $ANTLR start "single_rewrite"
+	// Grammars\\ANTLRTreePrinter.g3:288:0: single_rewrite : ^( REWRITE ( SEMPRED )? ( alternative | rewrite_template | ETC | ACTION ) ) ;
+	private void single_rewrite(  )
+	{
+		GrammarAST SEMPRED1=null;
+		GrammarAST ACTION2=null;
+
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:289:4: ( ^( REWRITE ( SEMPRED )? ( alternative | rewrite_template | ETC | ACTION ) ) )
+			// Grammars\\ANTLRTreePrinter.g3:289:4: ^( REWRITE ( SEMPRED )? ( alternative | rewrite_template | ETC | ACTION ) )
+			{
+			Match(input,REWRITE,Follow._REWRITE_in_single_rewrite967);
+
+			@out(" ->");
+
+			Match(input, TokenConstants.DOWN, null);
+			// Grammars\\ANTLRTreePrinter.g3:290:4: ( SEMPRED )?
+			int alt36=2;
+			int LA36_0 = input.LA(1);
+
+			if ( (LA36_0==SEMPRED) )
+			{
+				alt36=1;
+			}
+			switch ( alt36 )
+			{
+			case 1:
+				// Grammars\\ANTLRTreePrinter.g3:290:6: SEMPRED
+				{
+				SEMPRED1=(GrammarAST)Match(input,SEMPRED,Follow._SEMPRED_in_single_rewrite976);
+				@out(" {"+(SEMPRED1!=null?SEMPRED1.Text:null)+"}?");
+
+				}
+				break;
+
+			}
+
+			// Grammars\\ANTLRTreePrinter.g3:292:4: ( alternative | rewrite_template | ETC | ACTION )
+			int alt37=4;
+			switch ( input.LA(1) )
+			{
+			case ALT:
+				{
+				alt37=1;
+				}
+				break;
+			case TEMPLATE:
+				{
+				alt37=2;
+				}
+				break;
+			case ETC:
+				{
+				alt37=3;
+				}
+				break;
+			case ACTION:
+				{
+				alt37=4;
+				}
+				break;
+			default:
+				{
+					NoViableAltException nvae = new NoViableAltException("", 37, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt37 )
+			{
+			case 1:
+				// Grammars\\ANTLRTreePrinter.g3:292:6: alternative
+				{
+				PushFollow(Follow._alternative_in_single_rewrite991);
+				alternative();
+
+				state._fsp--;
+
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLRTreePrinter.g3:293:6: rewrite_template
+				{
+				PushFollow(Follow._rewrite_template_in_single_rewrite998);
+				rewrite_template();
+
+				state._fsp--;
+
+
+				}
+				break;
+			case 3:
+				// Grammars\\ANTLRTreePrinter.g3:294:6: ETC
+				{
+				Match(input,ETC,Follow._ETC_in_single_rewrite1005);
+				@out("...");
+
+				}
+				break;
+			case 4:
+				// Grammars\\ANTLRTreePrinter.g3:295:6: ACTION
+				{
+				ACTION2=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_single_rewrite1014);
+				@out(" {"+(ACTION2!=null?ACTION2.Text:null)+"}");
+
+				}
+				break;
+
+			}
+
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "single_rewrite"
+
+
+	// $ANTLR start "rewrite_template"
+	// Grammars\\ANTLRTreePrinter.g3:300:0: rewrite_template : ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? ) ;
+	private void rewrite_template(  )
+	{
+		GrammarAST id=null;
+		GrammarAST ind=null;
+		GrammarAST arg=null;
+		GrammarAST a=null;
+		GrammarAST DOUBLE_QUOTE_STRING_LITERAL3=null;
+		GrammarAST DOUBLE_ANGLE_STRING_LITERAL4=null;
+
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:301:4: ( ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? ) )
+			// Grammars\\ANTLRTreePrinter.g3:301:4: ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? )
+			{
+			Match(input,TEMPLATE,Follow._TEMPLATE_in_rewrite_template1038);
+
+			Match(input, TokenConstants.DOWN, null);
+			// Grammars\\ANTLRTreePrinter.g3:302:4: (id= ID |ind= ACTION )
+			int alt38=2;
+			int LA38_0 = input.LA(1);
+
+			if ( (LA38_0==ID) )
+			{
+				alt38=1;
+			}
+			else if ( (LA38_0==ACTION) )
+			{
+				alt38=2;
+			}
+			else
+			{
+				NoViableAltException nvae = new NoViableAltException("", 38, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt38 )
+			{
+			case 1:
+				// Grammars\\ANTLRTreePrinter.g3:302:6: id= ID
+				{
+				id=(GrammarAST)Match(input,ID,Follow._ID_in_rewrite_template1047);
+				@out(" "+(id!=null?id.Text:null));
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLRTreePrinter.g3:303:6: ind= ACTION
+				{
+				ind=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_rewrite_template1058);
+				@out(" ({"+(ind!=null?ind.Text:null)+"})");
+
+				}
+				break;
+
+			}
+
+			Match(input,ARGLIST,Follow._ARGLIST_in_rewrite_template1072);
+
+			@out("(");
+
+			if ( input.LA(1)==TokenConstants.DOWN )
+			{
+				Match(input, TokenConstants.DOWN, null);
+				// Grammars\\ANTLRTreePrinter.g3:307:5: ( ^( ARG arg= ID a= ACTION ) )*
+				for ( ; ; )
+				{
+					int alt39=2;
+					int LA39_0 = input.LA(1);
+
+					if ( (LA39_0==ARG) )
+					{
+						alt39=1;
+					}
+
+
+					switch ( alt39 )
+					{
+					case 1:
+						// Grammars\\ANTLRTreePrinter.g3:307:7: ^( ARG arg= ID a= ACTION )
+						{
+						Match(input,ARG,Follow._ARG_in_rewrite_template1088);
+
+						Match(input, TokenConstants.DOWN, null);
+						arg=(GrammarAST)Match(input,ID,Follow._ID_in_rewrite_template1092);
+						@out((arg!=null?arg.Text:null)+"=");
+						a=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_rewrite_template1104);
+						@out((a!=null?a.Text:null));
+
+						Match(input, TokenConstants.UP, null);
+
+						}
+						break;
+
+					default:
+						goto loop39;
+					}
+				}
+
+				loop39:
+					;
+
+
+				@out(")");
+
+				Match(input, TokenConstants.UP, null);
+			}
+			// Grammars\\ANTLRTreePrinter.g3:313:4: ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )?
+			int alt40=3;
+			int LA40_0 = input.LA(1);
+
+			if ( (LA40_0==DOUBLE_QUOTE_STRING_LITERAL) )
+			{
+				alt40=1;
+			}
+			else if ( (LA40_0==DOUBLE_ANGLE_STRING_LITERAL) )
+			{
+				alt40=2;
+			}
+			switch ( alt40 )
+			{
+			case 1:
+				// Grammars\\ANTLRTreePrinter.g3:313:6: DOUBLE_QUOTE_STRING_LITERAL
+				{
+				DOUBLE_QUOTE_STRING_LITERAL3=(GrammarAST)Match(input,DOUBLE_QUOTE_STRING_LITERAL,Follow._DOUBLE_QUOTE_STRING_LITERAL_in_rewrite_template1140);
+				@out(" "+(DOUBLE_QUOTE_STRING_LITERAL3!=null?DOUBLE_QUOTE_STRING_LITERAL3.Text:null));
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLRTreePrinter.g3:314:6: DOUBLE_ANGLE_STRING_LITERAL
+				{
+				DOUBLE_ANGLE_STRING_LITERAL4=(GrammarAST)Match(input,DOUBLE_ANGLE_STRING_LITERAL,Follow._DOUBLE_ANGLE_STRING_LITERAL_in_rewrite_template1149);
+				@out(" "+(DOUBLE_ANGLE_STRING_LITERAL4!=null?DOUBLE_ANGLE_STRING_LITERAL4.Text:null));
+
+				}
+				break;
+
+			}
+
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "rewrite_template"
+
+
+	// $ANTLR start "rewrite"
+	// Grammars\\ANTLRTreePrinter.g3:319:0: rewrite : ( single_rewrite )* ;
+	private void rewrite(  )
+	{
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:320:4: ( ( single_rewrite )* )
+			// Grammars\\ANTLRTreePrinter.g3:320:4: ( single_rewrite )*
+			{
+			// Grammars\\ANTLRTreePrinter.g3:320:4: ( single_rewrite )*
+			for ( ; ; )
+			{
+				int alt41=2;
+				int LA41_0 = input.LA(1);
+
+				if ( (LA41_0==REWRITE) )
+				{
+					alt41=1;
+				}
+
+
+				switch ( alt41 )
+				{
+				case 1:
+					// Grammars\\ANTLRTreePrinter.g3:320:5: single_rewrite
+					{
+					PushFollow(Follow._single_rewrite_in_rewrite1173);
+					single_rewrite();
+
+					state._fsp--;
+
+
+					}
+					break;
+
+				default:
+					goto loop41;
+				}
+			}
+
+			loop41:
+				;
+
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "rewrite"
+
+
+	// $ANTLR start "element"
+	// Grammars\\ANTLRTreePrinter.g3:323:0: element : ( ^( ROOT element ) | ^( BANG element ) | atom | ^( NOT element ) | ^( RANGE atom atom ) | ^( CHAR_RANGE atom atom ) | ^( ASSIGN id= ID element ) | ^( PLUS_ASSIGN id2= ID element ) | ebnf | tree_ | ^( SYNPRED block[true] ) |a= ACTION |a2= FORCED_ACTION |pred= SEMPRED |spred= SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) |gpred= GATED_SEMPRED | EPSILON );
+	private void element(  )
+	{
+		GrammarAST id=null;
+		GrammarAST id2=null;
+		GrammarAST a=null;
+		GrammarAST a2=null;
+		GrammarAST pred=null;
+		GrammarAST spred=null;
+		GrammarAST gpred=null;
+
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:324:4: ( ^( ROOT element ) | ^( BANG element ) | atom | ^( NOT element ) | ^( RANGE atom atom ) | ^( CHAR_RANGE atom atom ) | ^( ASSIGN id= ID element ) | ^( PLUS_ASSIGN id2= ID element ) | ebnf | tree_ | ^( SYNPRED block[true] ) |a= ACTION |a2= FORCED_ACTION |pred= SEMPRED |spred= SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) |gpred= GATED_SEMPRED | EPSILON )
+			int alt43=18;
+			switch ( input.LA(1) )
+			{
+			case ROOT:
+				{
+				alt43=1;
+				}
+				break;
+			case BANG:
+				{
+				alt43=2;
+				}
+				break;
+			case CHAR_LITERAL:
+			case DOT:
+			case LABEL:
+			case RULE_REF:
+			case STRING_LITERAL:
+			case TOKEN_REF:
+			case WILDCARD:
+				{
+				alt43=3;
+				}
+				break;
+			case NOT:
+				{
+				alt43=4;
+				}
+				break;
+			case RANGE:
+				{
+				alt43=5;
+				}
+				break;
+			case CHAR_RANGE:
+				{
+				alt43=6;
+				}
+				break;
+			case ASSIGN:
+				{
+				alt43=7;
+				}
+				break;
+			case PLUS_ASSIGN:
+				{
+				alt43=8;
+				}
+				break;
+			case BLOCK:
+			case CLOSURE:
+			case OPTIONAL:
+			case POSITIVE_CLOSURE:
+				{
+				alt43=9;
+				}
+				break;
+			case TREE_BEGIN:
+				{
+				alt43=10;
+				}
+				break;
+			case SYNPRED:
+				{
+				alt43=11;
+				}
+				break;
+			case ACTION:
+				{
+				alt43=12;
+				}
+				break;
+			case FORCED_ACTION:
+				{
+				alt43=13;
+				}
+				break;
+			case SEMPRED:
+				{
+				alt43=14;
+				}
+				break;
+			case SYN_SEMPRED:
+				{
+				alt43=15;
+				}
+				break;
+			case BACKTRACK_SEMPRED:
+				{
+				alt43=16;
+				}
+				break;
+			case GATED_SEMPRED:
+				{
+				alt43=17;
+				}
+				break;
+			case EPSILON:
+				{
+				alt43=18;
+				}
+				break;
+			default:
+				{
+					NoViableAltException nvae = new NoViableAltException("", 43, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt43 )
+			{
+			case 1:
+				// Grammars\\ANTLRTreePrinter.g3:324:4: ^( ROOT element )
+				{
+				Match(input,ROOT,Follow._ROOT_in_element1187);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._element_in_element1189);
+				element();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLRTreePrinter.g3:325:4: ^( BANG element )
+				{
+				Match(input,BANG,Follow._BANG_in_element1196);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._element_in_element1198);
+				element();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 3:
+				// Grammars\\ANTLRTreePrinter.g3:326:4: atom
+				{
+				PushFollow(Follow._atom_in_element1204);
+				atom();
+
+				state._fsp--;
+
+
+				}
+				break;
+			case 4:
+				// Grammars\\ANTLRTreePrinter.g3:327:4: ^( NOT element )
+				{
+				Match(input,NOT,Follow._NOT_in_element1210);
+
+				@out("~");
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._element_in_element1214);
+				element();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 5:
+				// Grammars\\ANTLRTreePrinter.g3:328:4: ^( RANGE atom atom )
+				{
+				Match(input,RANGE,Follow._RANGE_in_element1221);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._atom_in_element1223);
+				atom();
+
+				state._fsp--;
+
+				@out("..");
+				PushFollow(Follow._atom_in_element1227);
+				atom();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 6:
+				// Grammars\\ANTLRTreePrinter.g3:329:4: ^( CHAR_RANGE atom atom )
+				{
+				Match(input,CHAR_RANGE,Follow._CHAR_RANGE_in_element1234);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._atom_in_element1236);
+				atom();
+
+				state._fsp--;
+
+				@out("..");
+				PushFollow(Follow._atom_in_element1240);
+				atom();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 7:
+				// Grammars\\ANTLRTreePrinter.g3:330:4: ^( ASSIGN id= ID element )
+				{
+				Match(input,ASSIGN,Follow._ASSIGN_in_element1247);
+
+				Match(input, TokenConstants.DOWN, null);
+				id=(GrammarAST)Match(input,ID,Follow._ID_in_element1251);
+				@out((id!=null?id.Text:null)+"=");
+				PushFollow(Follow._element_in_element1255);
+				element();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 8:
+				// Grammars\\ANTLRTreePrinter.g3:331:4: ^( PLUS_ASSIGN id2= ID element )
+				{
+				Match(input,PLUS_ASSIGN,Follow._PLUS_ASSIGN_in_element1262);
+
+				Match(input, TokenConstants.DOWN, null);
+				id2=(GrammarAST)Match(input,ID,Follow._ID_in_element1266);
+				@out((id2!=null?id2.Text:null)+"+=");
+				PushFollow(Follow._element_in_element1270);
+				element();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 9:
+				// Grammars\\ANTLRTreePrinter.g3:332:4: ebnf
+				{
+				PushFollow(Follow._ebnf_in_element1276);
+				ebnf();
+
+				state._fsp--;
+
+
+				}
+				break;
+			case 10:
+				// Grammars\\ANTLRTreePrinter.g3:333:4: tree_
+				{
+				PushFollow(Follow._tree__in_element1281);
+				tree_();
+
+				state._fsp--;
+
+
+				}
+				break;
+			case 11:
+				// Grammars\\ANTLRTreePrinter.g3:334:4: ^( SYNPRED block[true] )
+				{
+				Match(input,SYNPRED,Follow._SYNPRED_in_element1288);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._block_in_element1290);
+				block(true);
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+				@out("=>");
+
+				}
+				break;
+			case 12:
+				// Grammars\\ANTLRTreePrinter.g3:335:4: a= ACTION
+				{
+				a=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_element1302);
+				if ( showActions ) {@out("{"); @out((a!=null?a.Text:null)); @out("}");}
+
+				}
+				break;
+			case 13:
+				// Grammars\\ANTLRTreePrinter.g3:336:4: a2= FORCED_ACTION
+				{
+				a2=(GrammarAST)Match(input,FORCED_ACTION,Follow._FORCED_ACTION_in_element1312);
+				if ( showActions ) {@out("{{"); @out((a2!=null?a2.Text:null)); @out("}}");}
+
+				}
+				break;
+			case 14:
+				// Grammars\\ANTLRTreePrinter.g3:337:4: pred= SEMPRED
+				{
+				pred=(GrammarAST)Match(input,SEMPRED,Follow._SEMPRED_in_element1322);
+
+							if ( showActions )
+							{
+								@out("{");
+								@out((pred!=null?pred.Text:null));
+								@out("}?");
+							}
+							else
+							{
+								@out("{...}?");
+							}
+
+
+				}
+				break;
+			case 15:
+				// Grammars\\ANTLRTreePrinter.g3:350:4: spred= SYN_SEMPRED
+				{
+				spred=(GrammarAST)Match(input,SYN_SEMPRED,Follow._SYN_SEMPRED_in_element1333);
+
+							string name = (spred!=null?spred.Text:null);
+							GrammarAST predAST=grammar.getSyntacticPredicate(name);
+							block(predAST, true);
+							@out("=>");
+
+
+				}
+				break;
+			case 16:
+				// Grammars\\ANTLRTreePrinter.g3:357:4: ^( BACKTRACK_SEMPRED ( . )* )
+				{
+				Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_element1343);
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null);
+					// Grammars\\ANTLRTreePrinter.g3:357:24: ( . )*
+					for ( ; ; )
+					{
+						int alt42=2;
+						int LA42_0 = input.LA(1);
+
+						if ( ((LA42_0>=ACTION && LA42_0<=XDIGIT)) )
+						{
+							alt42=1;
+						}
+						else if ( (LA42_0==UP) )
+						{
+							alt42=2;
+						}
+
+
+						switch ( alt42 )
+						{
+						case 1:
+							// Grammars\\ANTLRTreePrinter.g3:357:0: .
+							{
+							MatchAny(input);
+
+							}
+							break;
+
+						default:
+							goto loop42;
+						}
+					}
+
+					loop42:
+						;
+
+
+
+					Match(input, TokenConstants.UP, null);
+				}
+
+				}
+				break;
+			case 17:
+				// Grammars\\ANTLRTreePrinter.g3:358:4: gpred= GATED_SEMPRED
+				{
+				gpred=(GrammarAST)Match(input,GATED_SEMPRED,Follow._GATED_SEMPRED_in_element1355);
+
+						if ( showActions ) {@out("{"); @out((gpred!=null?gpred.Text:null)); @out("}? =>");}
+						else {@out("{...}? =>");}
+
+
+				}
+				break;
+			case 18:
+				// Grammars\\ANTLRTreePrinter.g3:363:4: EPSILON
+				{
+				Match(input,EPSILON,Follow._EPSILON_in_element1364);
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "element"
+
+
+	// $ANTLR start "ebnf"
+	// Grammars\\ANTLRTreePrinter.g3:366:0: ebnf : ( block[true] | ^( OPTIONAL block[true] ) | ^( CLOSURE block[true] ) | ^( POSITIVE_CLOSURE block[true] ) );
+	private void ebnf(  )
+	{
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:367:4: ( block[true] | ^( OPTIONAL block[true] ) | ^( CLOSURE block[true] ) | ^( POSITIVE_CLOSURE block[true] ) )
+			int alt44=4;
+			switch ( input.LA(1) )
+			{
+			case BLOCK:
+				{
+				alt44=1;
+				}
+				break;
+			case OPTIONAL:
+				{
+				alt44=2;
+				}
+				break;
+			case CLOSURE:
+				{
+				alt44=3;
+				}
+				break;
+			case POSITIVE_CLOSURE:
+				{
+				alt44=4;
+				}
+				break;
+			default:
+				{
+					NoViableAltException nvae = new NoViableAltException("", 44, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt44 )
+			{
+			case 1:
+				// Grammars\\ANTLRTreePrinter.g3:367:4: block[true]
+				{
+				PushFollow(Follow._block_in_ebnf1375);
+				block(true);
+
+				state._fsp--;
+
+				@out(" ");
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLRTreePrinter.g3:368:4: ^( OPTIONAL block[true] )
+				{
+				Match(input,OPTIONAL,Follow._OPTIONAL_in_ebnf1385);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._block_in_ebnf1387);
+				block(true);
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+				@out("? ");
+
+				}
+				break;
+			case 3:
+				// Grammars\\ANTLRTreePrinter.g3:369:4: ^( CLOSURE block[true] )
+				{
+				Match(input,CLOSURE,Follow._CLOSURE_in_ebnf1399);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._block_in_ebnf1401);
+				block(true);
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+				@out("* ");
+
+				}
+				break;
+			case 4:
+				// Grammars\\ANTLRTreePrinter.g3:370:4: ^( POSITIVE_CLOSURE block[true] )
+				{
+				Match(input,POSITIVE_CLOSURE,Follow._POSITIVE_CLOSURE_in_ebnf1414);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._block_in_ebnf1416);
+				block(true);
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+				@out("+ ");
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "ebnf"
+
+
+	// $ANTLR start "tree_"
+	// Grammars\\ANTLRTreePrinter.g3:373:0: tree_ : ^( TREE_BEGIN element ( element )* ) ;
+	private void tree_(  )
+	{
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:374:4: ( ^( TREE_BEGIN element ( element )* ) )
+			// Grammars\\ANTLRTreePrinter.g3:374:4: ^( TREE_BEGIN element ( element )* )
+			{
+			Match(input,TREE_BEGIN,Follow._TREE_BEGIN_in_tree_1433);
+
+			@out(" ^(");
+
+			Match(input, TokenConstants.DOWN, null);
+			PushFollow(Follow._element_in_tree_1437);
+			element();
+
+			state._fsp--;
+
+			// Grammars\\ANTLRTreePrinter.g3:374:40: ( element )*
+			for ( ; ; )
+			{
+				int alt45=2;
+				int LA45_0 = input.LA(1);
+
+				if ( (LA45_0==ACTION||(LA45_0>=ASSIGN && LA45_0<=BLOCK)||(LA45_0>=CHAR_LITERAL && LA45_0<=CHAR_RANGE)||LA45_0==CLOSURE||LA45_0==DOT||LA45_0==EPSILON||LA45_0==FORCED_ACTION||LA45_0==GATED_SEMPRED||LA45_0==LABEL||LA45_0==NOT||LA45_0==OPTIONAL||(LA45_0>=PLUS_ASSIGN && LA45_0<=POSITIVE_CLOSURE)||LA45_0==RANGE||LA45_0==ROOT||LA45_0==RULE_REF||LA45_0==SEMPRED||(LA45_0>=STRING_LITERAL && LA45_0<=SYNPRED)||LA45_0==TOKEN_REF||LA45_0==TREE_BEGIN||LA45_0==WILDCARD) )
+				{
+					alt45=1;
+				}
+
+
+				switch ( alt45 )
+				{
+				case 1:
+					// Grammars\\ANTLRTreePrinter.g3:374:41: element
+					{
+					PushFollow(Follow._element_in_tree_1440);
+					element();
+
+					state._fsp--;
+
+
+					}
+					break;
+
+				default:
+					goto loop45;
+				}
+			}
+
+			loop45:
+				;
+
+
+			@out(") ");
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "tree_"
+
+	public class atom_return : TreeRuleReturnScope
+	{
+	}
+
+	// $ANTLR start "atom"
+	// Grammars\\ANTLRTreePrinter.g3:377:0: atom : ( ( ^( RULE_REF (rarg= ARG_ACTION )? ( ast_suffix )? ) | ^( TOKEN_REF (targ= ARG_ACTION )? ( ast_suffix )? ) | ^( CHAR_LITERAL ( ast_suffix )? ) | ^( STRING_LITERAL ( ast_suffix )? ) | ^( WILDCARD ( ast_suffix )? ) ) | LABEL | ^( DOT ID atom ) );
+	private ANTLRTreePrinter.atom_return atom(  )
+	{
+		ANTLRTreePrinter.atom_return retval = new ANTLRTreePrinter.atom_return();
+		retval.start = input.LT(1);
+
+		GrammarAST rarg=null;
+		GrammarAST targ=null;
+		GrammarAST LABEL5=null;
+		GrammarAST ID6=null;
+
+		@out(" ");
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:380:4: ( ( ^( RULE_REF (rarg= ARG_ACTION )? ( ast_suffix )? ) | ^( TOKEN_REF (targ= ARG_ACTION )? ( ast_suffix )? ) | ^( CHAR_LITERAL ( ast_suffix )? ) | ^( STRING_LITERAL ( ast_suffix )? ) | ^( WILDCARD ( ast_suffix )? ) ) | LABEL | ^( DOT ID atom ) )
+			int alt54=3;
+			switch ( input.LA(1) )
+			{
+			case CHAR_LITERAL:
+			case RULE_REF:
+			case STRING_LITERAL:
+			case TOKEN_REF:
+			case WILDCARD:
+				{
+				alt54=1;
+				}
+				break;
+			case LABEL:
+				{
+				alt54=2;
+				}
+				break;
+			case DOT:
+				{
+				alt54=3;
+				}
+				break;
+			default:
+				{
+					NoViableAltException nvae = new NoViableAltException("", 54, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt54 )
+			{
+			case 1:
+				// Grammars\\ANTLRTreePrinter.g3:380:4: ( ^( RULE_REF (rarg= ARG_ACTION )? ( ast_suffix )? ) | ^( TOKEN_REF (targ= ARG_ACTION )? ( ast_suffix )? ) | ^( CHAR_LITERAL ( ast_suffix )? ) | ^( STRING_LITERAL ( ast_suffix )? ) | ^( WILDCARD ( ast_suffix )? ) )
+				{
+				// Grammars\\ANTLRTreePrinter.g3:380:4: ( ^( RULE_REF (rarg= ARG_ACTION )? ( ast_suffix )? ) | ^( TOKEN_REF (targ= ARG_ACTION )? ( ast_suffix )? ) | ^( CHAR_LITERAL ( ast_suffix )? ) | ^( STRING_LITERAL ( ast_suffix )? ) | ^( WILDCARD ( ast_suffix )? ) )
+				int alt53=5;
+				switch ( input.LA(1) )
+				{
+				case RULE_REF:
+					{
+					alt53=1;
+					}
+					break;
+				case TOKEN_REF:
+					{
+					alt53=2;
+					}
+					break;
+				case CHAR_LITERAL:
+					{
+					alt53=3;
+					}
+					break;
+				case STRING_LITERAL:
+					{
+					alt53=4;
+					}
+					break;
+				case WILDCARD:
+					{
+					alt53=5;
+					}
+					break;
+				default:
+					{
+						NoViableAltException nvae = new NoViableAltException("", 53, 0, input);
+
+						throw nvae;
+					}
+				}
+
+				switch ( alt53 )
+				{
+				case 1:
+					// Grammars\\ANTLRTreePrinter.g3:380:6: ^( RULE_REF (rarg= ARG_ACTION )? ( ast_suffix )? )
+					{
+					Match(input,RULE_REF,Follow._RULE_REF_in_atom1466);
+
+					@out(((GrammarAST)retval.start).ToString());
+
+					if ( input.LA(1)==TokenConstants.DOWN )
+					{
+						Match(input, TokenConstants.DOWN, null);
+						// Grammars\\ANTLRTreePrinter.g3:381:5: (rarg= ARG_ACTION )?
+						int alt46=2;
+						int LA46_0 = input.LA(1);
+
+						if ( (LA46_0==ARG_ACTION) )
+						{
+							alt46=1;
+						}
+						switch ( alt46 )
+						{
+						case 1:
+							// Grammars\\ANTLRTreePrinter.g3:381:6: rarg= ARG_ACTION
+							{
+							rarg=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1478);
+							@out("["+rarg.ToString()+"]");
+
+							}
+							break;
+
+						}
+
+						// Grammars\\ANTLRTreePrinter.g3:382:5: ( ast_suffix )?
+						int alt47=2;
+						int LA47_0 = input.LA(1);
+
+						if ( (LA47_0==BANG||LA47_0==ROOT) )
+						{
+							alt47=1;
+						}
+						switch ( alt47 )
+						{
+						case 1:
+							// Grammars\\ANTLRTreePrinter.g3:382:6: ast_suffix
+							{
+							PushFollow(Follow._ast_suffix_in_atom1489);
+							ast_suffix();
+
+							state._fsp--;
+
+
+							}
+							break;
+
+						}
+
+
+						Match(input, TokenConstants.UP, null);
+					}
+
+					}
+					break;
+				case 2:
+					// Grammars\\ANTLRTreePrinter.g3:384:5: ^( TOKEN_REF (targ= ARG_ACTION )? ( ast_suffix )? )
+					{
+					Match(input,TOKEN_REF,Follow._TOKEN_REF_in_atom1504);
+
+					@out(((GrammarAST)retval.start).ToString());
+
+					if ( input.LA(1)==TokenConstants.DOWN )
+					{
+						Match(input, TokenConstants.DOWN, null);
+						// Grammars\\ANTLRTreePrinter.g3:385:5: (targ= ARG_ACTION )?
+						int alt48=2;
+						int LA48_0 = input.LA(1);
+
+						if ( (LA48_0==ARG_ACTION) )
+						{
+							alt48=1;
+						}
+						switch ( alt48 )
+						{
+						case 1:
+							// Grammars\\ANTLRTreePrinter.g3:385:6: targ= ARG_ACTION
+							{
+							targ=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1517);
+							@out("["+targ.ToString()+"]");
+
+							}
+							break;
+
+						}
+
+						// Grammars\\ANTLRTreePrinter.g3:386:5: ( ast_suffix )?
+						int alt49=2;
+						int LA49_0 = input.LA(1);
+
+						if ( (LA49_0==BANG||LA49_0==ROOT) )
+						{
+							alt49=1;
+						}
+						switch ( alt49 )
+						{
+						case 1:
+							// Grammars\\ANTLRTreePrinter.g3:386:6: ast_suffix
+							{
+							PushFollow(Follow._ast_suffix_in_atom1529);
+							ast_suffix();
+
+							state._fsp--;
+
+
+							}
+							break;
+
+						}
+
+
+						Match(input, TokenConstants.UP, null);
+					}
+
+					}
+					break;
+				case 3:
+					// Grammars\\ANTLRTreePrinter.g3:388:5: ^( CHAR_LITERAL ( ast_suffix )? )
+					{
+					Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_atom1544);
+
+					@out(((GrammarAST)retval.start).ToString());
+
+					if ( input.LA(1)==TokenConstants.DOWN )
+					{
+						Match(input, TokenConstants.DOWN, null);
+						// Grammars\\ANTLRTreePrinter.g3:389:5: ( ast_suffix )?
+						int alt50=2;
+						int LA50_0 = input.LA(1);
+
+						if ( (LA50_0==BANG||LA50_0==ROOT) )
+						{
+							alt50=1;
+						}
+						switch ( alt50 )
+						{
+						case 1:
+							// Grammars\\ANTLRTreePrinter.g3:389:6: ast_suffix
+							{
+							PushFollow(Follow._ast_suffix_in_atom1553);
+							ast_suffix();
+
+							state._fsp--;
+
+
+							}
+							break;
+
+						}
+
+
+						Match(input, TokenConstants.UP, null);
+					}
+
+					}
+					break;
+				case 4:
+					// Grammars\\ANTLRTreePrinter.g3:391:5: ^( STRING_LITERAL ( ast_suffix )? )
+					{
+					Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_atom1568);
+
+					@out(((GrammarAST)retval.start).ToString());
+
+					if ( input.LA(1)==TokenConstants.DOWN )
+					{
+						Match(input, TokenConstants.DOWN, null);
+						// Grammars\\ANTLRTreePrinter.g3:392:5: ( ast_suffix )?
+						int alt51=2;
+						int LA51_0 = input.LA(1);
+
+						if ( (LA51_0==BANG||LA51_0==ROOT) )
+						{
+							alt51=1;
+						}
+						switch ( alt51 )
+						{
+						case 1:
+							// Grammars\\ANTLRTreePrinter.g3:392:6: ast_suffix
+							{
+							PushFollow(Follow._ast_suffix_in_atom1577);
+							ast_suffix();
+
+							state._fsp--;
+
+
+							}
+							break;
+
+						}
+
+
+						Match(input, TokenConstants.UP, null);
+					}
+
+					}
+					break;
+				case 5:
+					// Grammars\\ANTLRTreePrinter.g3:394:5: ^( WILDCARD ( ast_suffix )? )
+					{
+					Match(input,WILDCARD,Follow._WILDCARD_in_atom1592);
+
+					@out(((GrammarAST)retval.start).ToString());
+
+					if ( input.LA(1)==TokenConstants.DOWN )
+					{
+						Match(input, TokenConstants.DOWN, null);
+						// Grammars\\ANTLRTreePrinter.g3:395:5: ( ast_suffix )?
+						int alt52=2;
+						int LA52_0 = input.LA(1);
+
+						if ( (LA52_0==BANG||LA52_0==ROOT) )
+						{
+							alt52=1;
+						}
+						switch ( alt52 )
+						{
+						case 1:
+							// Grammars\\ANTLRTreePrinter.g3:395:6: ast_suffix
+							{
+							PushFollow(Follow._ast_suffix_in_atom1602);
+							ast_suffix();
+
+							state._fsp--;
+
+
+							}
+							break;
+
+						}
+
+
+						Match(input, TokenConstants.UP, null);
+					}
+
+					}
+					break;
+
+				}
+
+				@out(" ");
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLRTreePrinter.g3:399:4: LABEL
+				{
+				LABEL5=(GrammarAST)Match(input,LABEL,Follow._LABEL_in_atom1622);
+				@out(" $"+(LABEL5!=null?LABEL5.Text:null));
+
+				}
+				break;
+			case 3:
+				// Grammars\\ANTLRTreePrinter.g3:400:4: ^( DOT ID atom )
+				{
+				Match(input,DOT,Follow._DOT_in_atom1631);
+
+				Match(input, TokenConstants.DOWN, null);
+				ID6=(GrammarAST)Match(input,ID,Follow._ID_in_atom1633);
+				@out((ID6!=null?ID6.Text:null)+".");
+				PushFollow(Follow._atom_in_atom1637);
+				atom();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "atom"
+
+
+	// $ANTLR start "ast_suffix"
+	// Grammars\\ANTLRTreePrinter.g3:403:0: ast_suffix : ( ROOT | BANG );
+	private void ast_suffix(  )
+	{
+		try
+		{
+			// Grammars\\ANTLRTreePrinter.g3:404:4: ( ROOT | BANG )
+			int alt55=2;
+			int LA55_0 = input.LA(1);
+
+			if ( (LA55_0==ROOT) )
+			{
+				alt55=1;
+			}
+			else if ( (LA55_0==BANG) )
+			{
+				alt55=2;
+			}
+			else
+			{
+				NoViableAltException nvae = new NoViableAltException("", 55, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt55 )
+			{
+			case 1:
+				// Grammars\\ANTLRTreePrinter.g3:404:4: ROOT
+				{
+				Match(input,ROOT,Follow._ROOT_in_ast_suffix1650);
+				@out("^");
+
+				}
+				break;
+			case 2:
+				// Grammars\\ANTLRTreePrinter.g3:405:4: BANG
+				{
+				Match(input,BANG,Follow._BANG_in_ast_suffix1657);
+				@out("!");
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "ast_suffix"
+	#endregion
+
+	// Delegated rules
+
+	#region Synpreds
+	#endregion
+
+	#region DFA
+
+	protected override void InitDFAs()
+	{
+		base.InitDFAs();
+	}
+
+	#endregion
+
+	#region Follow Sets
+	public static class Follow
+	{
+		public static readonly BitSet _grammar__in_toString72 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _rule_in_toString78 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _alternative_in_toString84 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _element_in_toString90 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _single_rewrite_in_toString96 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _EOR_in_toString102 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _LEXER_GRAMMAR_in_grammar_127 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _grammarSpec_in_grammar_129 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _PARSER_GRAMMAR_in_grammar_139 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _grammarSpec_in_grammar_141 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _TREE_GRAMMAR_in_grammar_151 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _grammarSpec_in_grammar_153 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _COMBINED_GRAMMAR_in_grammar_163 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _grammarSpec_in_grammar_165 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _SCOPE_in_attrScope181 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_attrScope183 = new BitSet(new ulong[]{0x210UL});
+		public static readonly BitSet _ruleAction_in_attrScope185 = new BitSet(new ulong[]{0x210UL});
+		public static readonly BitSet _ACTION_in_attrScope188 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ID_in_grammarSpec204 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
+		public static readonly BitSet _DOC_COMMENT_in_grammarSpec213 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
+		public static readonly BitSet _optionsSpec_in_grammarSpec223 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
+		public static readonly BitSet _delegateGrammars_in_grammarSpec232 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
+		public static readonly BitSet _tokensSpec_in_grammarSpec239 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
+		public static readonly BitSet _attrScope_in_grammarSpec246 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
+		public static readonly BitSet _actions_in_grammarSpec253 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
+		public static readonly BitSet _rules_in_grammarSpec259 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _action_in_actions272 = new BitSet(new ulong[]{0x202UL});
+		public static readonly BitSet _AMPERSAND_in_action293 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_action297 = new BitSet(new ulong[]{0x80000000010UL});
+		public static readonly BitSet _ID_in_action306 = new BitSet(new ulong[]{0x10UL});
+		public static readonly BitSet _ACTION_in_action310 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ACTION_in_action325 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _OPTIONS_in_optionsSpec357 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _option_in_optionsSpec365 = new BitSet(new ulong[]{0x2008UL});
+		public static readonly BitSet _ASSIGN_in_option391 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_option395 = new BitSet(new ulong[]{0x880000040000UL,0x200000UL});
+		public static readonly BitSet _optionValue_in_option399 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ID_in_optionValue414 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _STRING_LITERAL_in_optionValue434 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _CHAR_LITERAL_in_optionValue443 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _INT_in_optionValue454 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _IMPORT_in_delegateGrammars484 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ASSIGN_in_delegateGrammars489 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_delegateGrammars491 = new BitSet(new ulong[]{0x80000000000UL});
+		public static readonly BitSet _ID_in_delegateGrammars493 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ID_in_delegateGrammars498 = new BitSet(new ulong[]{0x80000002008UL});
+		public static readonly BitSet _TOKENS_in_tokensSpec516 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _tokenSpec_in_tokensSpec520 = new BitSet(new ulong[]{0x2008UL,0x4000000UL});
+		public static readonly BitSet _TOKEN_REF_in_tokenSpec536 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ASSIGN_in_tokenSpec543 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _TOKEN_REF_in_tokenSpec545 = new BitSet(new ulong[]{0x40000UL,0x200000UL});
+		public static readonly BitSet _set_in_tokenSpec547 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _rule_in_rules566 = new BitSet(new ulong[]{0x400200008000202UL,0x8005000UL});
+		public static readonly BitSet _RULE_in_rule582 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_rule586 = new BitSet(new ulong[]{0x10000000400UL,0xEUL});
+		public static readonly BitSet _modifier_in_rule592 = new BitSet(new ulong[]{0x400UL});
+		public static readonly BitSet _ARG_in_rule605 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_ACTION_in_rule610 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _RET_in_rule623 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_ACTION_in_rule628 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _throwsSpec_in_rule641 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
+		public static readonly BitSet _optionsSpec_in_rule649 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
+		public static readonly BitSet _ruleScopeSpec_in_rule657 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
+		public static readonly BitSet _ruleAction_in_rule665 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
+		public static readonly BitSet _block_in_rule684 = new BitSet(new ulong[]{0x4400020000UL});
+		public static readonly BitSet _exceptionGroup_in_rule691 = new BitSet(new ulong[]{0x400000000UL});
+		public static readonly BitSet _EOR_in_rule698 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _AMPERSAND_in_ruleAction716 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_ruleAction720 = new BitSet(new ulong[]{0x10UL});
+		public static readonly BitSet _ACTION_in_ruleAction724 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _set_in_modifier746 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _THROWS_in_throwsSpec773 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_throwsSpec775 = new BitSet(new ulong[]{0x80000000008UL});
+		public static readonly BitSet _SCOPE_in_ruleScopeSpec790 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ruleAction_in_ruleScopeSpec792 = new BitSet(new ulong[]{0x80000000218UL});
+		public static readonly BitSet _ACTION_in_ruleScopeSpec796 = new BitSet(new ulong[]{0x80000000008UL});
+		public static readonly BitSet _ID_in_ruleScopeSpec802 = new BitSet(new ulong[]{0x80000000008UL});
+		public static readonly BitSet _BLOCK_in_block826 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _optionsSpec_in_block837 = new BitSet(new ulong[]{0x100UL});
+		public static readonly BitSet _alternative_in_block847 = new BitSet(new ulong[]{0x200000100UL,0x200UL});
+		public static readonly BitSet _rewrite_in_block849 = new BitSet(new ulong[]{0x200000100UL});
+		public static readonly BitSet _alternative_in_block855 = new BitSet(new ulong[]{0x200000100UL,0x200UL});
+		public static readonly BitSet _rewrite_in_block857 = new BitSet(new ulong[]{0x200000100UL});
+		public static readonly BitSet _EOB_in_block865 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ALT_in_alternative887 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _element_in_alternative890 = new BitSet(new ulong[]{0x86810289202DE210UL,0xA4E16421UL});
+		public static readonly BitSet _EOA_in_alternative894 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _exceptionHandler_in_exceptionGroup909 = new BitSet(new ulong[]{0x4000020002UL});
+		public static readonly BitSet _finallyClause_in_exceptionGroup915 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _finallyClause_in_exceptionGroup922 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _CATCH_in_exceptionHandler934 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_ACTION_in_exceptionHandler936 = new BitSet(new ulong[]{0x10UL});
+		public static readonly BitSet _ACTION_in_exceptionHandler938 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _FINALLY_in_finallyClause951 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ACTION_in_finallyClause953 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _REWRITE_in_single_rewrite967 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _SEMPRED_in_single_rewrite976 = new BitSet(new ulong[]{0x2000000110UL,0x1000000UL});
+		public static readonly BitSet _alternative_in_single_rewrite991 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _rewrite_template_in_single_rewrite998 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ETC_in_single_rewrite1005 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ACTION_in_single_rewrite1014 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _TEMPLATE_in_rewrite_template1038 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_rewrite_template1047 = new BitSet(new ulong[]{0x1000UL});
+		public static readonly BitSet _ACTION_in_rewrite_template1058 = new BitSet(new ulong[]{0x1000UL});
+		public static readonly BitSet _ARGLIST_in_rewrite_template1072 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_in_rewrite_template1088 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_rewrite_template1092 = new BitSet(new ulong[]{0x10UL});
+		public static readonly BitSet _ACTION_in_rewrite_template1104 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _DOUBLE_QUOTE_STRING_LITERAL_in_rewrite_template1140 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _DOUBLE_ANGLE_STRING_LITERAL_in_rewrite_template1149 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _single_rewrite_in_rewrite1173 = new BitSet(new ulong[]{0x2UL,0x200UL});
+		public static readonly BitSet _ROOT_in_element1187 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _element_in_element1189 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _BANG_in_element1196 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _element_in_element1198 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _atom_in_element1204 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _NOT_in_element1210 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _element_in_element1214 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _RANGE_in_element1221 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _atom_in_element1223 = new BitSet(new ulong[]{0x1000020040000UL,0x84202000UL});
+		public static readonly BitSet _atom_in_element1227 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _CHAR_RANGE_in_element1234 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _atom_in_element1236 = new BitSet(new ulong[]{0x1000020040000UL,0x84202000UL});
+		public static readonly BitSet _atom_in_element1240 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ASSIGN_in_element1247 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_element1251 = new BitSet(new ulong[]{0x86810289202DE210UL,0xA4E16421UL});
+		public static readonly BitSet _element_in_element1255 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _PLUS_ASSIGN_in_element1262 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_element1266 = new BitSet(new ulong[]{0x86810289202DE210UL,0xA4E16421UL});
+		public static readonly BitSet _element_in_element1270 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ebnf_in_element1276 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _tree__in_element1281 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _SYNPRED_in_element1288 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _block_in_element1290 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ACTION_in_element1302 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _FORCED_ACTION_in_element1312 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _SEMPRED_in_element1322 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _SYN_SEMPRED_in_element1333 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _BACKTRACK_SEMPRED_in_element1343 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _GATED_SEMPRED_in_element1355 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _EPSILON_in_element1364 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _block_in_ebnf1375 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _OPTIONAL_in_ebnf1385 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _block_in_ebnf1387 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _CLOSURE_in_ebnf1399 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _block_in_ebnf1401 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _POSITIVE_CLOSURE_in_ebnf1414 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _block_in_ebnf1416 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _TREE_BEGIN_in_tree_1433 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _element_in_tree_1437 = new BitSet(new ulong[]{0x86810289202DE218UL,0xA4E16421UL});
+		public static readonly BitSet _element_in_tree_1440 = new BitSet(new ulong[]{0x86810289202DE218UL,0xA4E16421UL});
+		public static readonly BitSet _RULE_REF_in_atom1466 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_ACTION_in_atom1478 = new BitSet(new ulong[]{0x8008UL,0x400UL});
+		public static readonly BitSet _ast_suffix_in_atom1489 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _TOKEN_REF_in_atom1504 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_ACTION_in_atom1517 = new BitSet(new ulong[]{0x8008UL,0x400UL});
+		public static readonly BitSet _ast_suffix_in_atom1529 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _CHAR_LITERAL_in_atom1544 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ast_suffix_in_atom1553 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _STRING_LITERAL_in_atom1568 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ast_suffix_in_atom1577 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _WILDCARD_in_atom1592 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ast_suffix_in_atom1602 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _LABEL_in_atom1622 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _DOT_in_atom1631 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_atom1633 = new BitSet(new ulong[]{0x1000020040000UL,0x84202000UL});
+		public static readonly BitSet _atom_in_atom1637 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ROOT_in_ast_suffix1650 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _BANG_in_ast_suffix1657 = new BitSet(new ulong[]{0x2UL});
+
+	}
+	#endregion
+}
+
+} // namespace Antlr3.Grammars
diff --git a/Antlr3/Grammars/ANTLRTreePrinter.g3 b/Antlr3/Grammars/ANTLRTreePrinter.g3
new file mode 100644
index 0000000..165a488
--- /dev/null
+++ b/Antlr3/Grammars/ANTLRTreePrinter.g3
@@ -0,0 +1,406 @@
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/** Print out a grammar (no pretty printing).
+ *
+ *  Terence Parr
+ *  University of San Francisco
+ *  August 19, 2003
+ */
+tree grammar ANTLRTreePrinter;
+
+options
+{
+	language=CSharp3;
+	tokenVocab = ANTLR;
+	ASTLabelType = GrammarAST;
+}
+
+@namespace{Antlr3.Grammars}
+
+@header
+{
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+using Antlr3.Tool;
+}
+
+/** Call this to figure out how to print */
+public
+toString[Grammar g, bool showActions] returns [string s=null]
+@init
+{
+	grammar = g;
+	this.showActions = showActions;
+}
+	:	(	grammar_
+		|	rule
+		|	alternative
+		|	element
+		|	single_rewrite
+		|	EOR {s="EOR";}
+		)
+		{return normalize(buf.ToString());}
+	;
+
+// --------------
+
+grammar_
+	:	^( LEXER_GRAMMAR grammarSpec["lexer " ] )
+	|	^( PARSER_GRAMMAR grammarSpec["parser "] )
+	|	^( TREE_GRAMMAR grammarSpec["tree "] )
+	|	^( COMBINED_GRAMMAR grammarSpec[""] )
+	;
+
+attrScope
+	:	^( 'scope' ID ruleAction* ACTION )
+	;
+
+grammarSpec[string gtype]
+	:	id=ID {@out(gtype+"grammar "+$id.text);}
+		(cmt=DOC_COMMENT {@out($cmt.text+"\n");} )?
+		(optionsSpec)? {@out(";\n");}
+		(delegateGrammars)?
+		(tokensSpec)?
+		(attrScope)*
+		(actions)?
+		rules
+	;
+
+actions
+	:	( action )+
+	;
+
+action
+@init
+{
+	string scope=null, name=null;
+	string action=null;
+}
+	:	^(	AMPERSAND id1=ID
+			(	id2=ID a1=ACTION
+				{scope=$id1.text; name=$a1.text; action=$a1.text;}
+			|	a2=ACTION
+				{scope=null; name=$id1.text; action=$a2.text;}
+			)
+		)
+		{
+			if ( showActions )
+			{
+				@out("@"+(scope!=null?scope+"::":"")+name+action);
+			}
+		}
+	;
+
+optionsSpec
+	:	^(	OPTIONS {@out(" options {");}
+			(option {@out("; ");})+
+			{@out("} ");}
+		)
+	;
+
+option
+	:	^( ASSIGN id=ID {@out($id.text+"=");} optionValue )
+	;
+
+optionValue
+	:	id=ID            {@out($id.text);}
+	|	s=STRING_LITERAL {@out($s.text);}
+	|	c=CHAR_LITERAL   {@out($c.text);}
+	|	i=INT            {@out($i.text);}
+//	|   charSet
+	;
+
+/*
+charSet
+	:   #( CHARSET charSetElement )
+	;
+
+charSetElement
+	:   c:CHAR_LITERAL {out(#c.getText());}
+	|   #( OR c1:CHAR_LITERAL c2:CHAR_LITERAL )
+	|   #( RANGE c3:CHAR_LITERAL c4:CHAR_LITERAL )
+	;
+*/
+
+delegateGrammars
+	:	^( 'import' ( ^(ASSIGN ID ID) | ID )+ )
+	;
+
+tokensSpec
+	:	^( TOKENS ( tokenSpec )+ )
+	;
+
+tokenSpec
+	:	TOKEN_REF
+	|	^( ASSIGN TOKEN_REF (STRING_LITERAL|CHAR_LITERAL) )
+	;
+
+rules
+	:	( rule )+
+	;
+
+rule
+	:	^(	RULE id=ID
+			(modifier)?
+			{@out($id.text);}
+			^(ARG (arg=ARG_ACTION {@out("["+$arg.text+"]");} )? )
+			^(RET (ret=ARG_ACTION {@out(" returns ["+$ret.text+"]");} )? )
+			(throwsSpec)?
+			(optionsSpec)?
+			(ruleScopeSpec)?
+			(ruleAction)*
+			{@out(" :");}
+			{
+				if ( input.LA(5) == NOT || input.LA(5) == ASSIGN )
+					@out(" ");
+			}
+			b=block[false]
+			(exceptionGroup)?
+			EOR {@out(";\n");}
+		)
+	;
+
+ruleAction
+	:	^(AMPERSAND id=ID a=ACTION )
+		{if ( showActions ) @out("@"+$id.text+"{"+$a.text+"}");}
+	;
+
+modifier
+@init
+{@out($modifier.start.Text); @out(" ");}
+	:	'protected'
+	|	'public'
+	|	'private'
+	|	'fragment'
+	;
+
+throwsSpec
+	:	^('throws' ID+)
+	;
+
+ruleScopeSpec
+	:	^( 'scope' ruleAction* (ACTION)? ( ID )* )
+	;
+
+block[bool forceParens]
+@init
+{
+int numAlts = countAltsForBlock($start);
+}
+	:	^(	BLOCK
+			{
+				if ( forceParens||numAlts>1 )
+				{
+					//for ( Antlr.Runtime.Tree.Tree parent = $start.getParent(); parent != null && parent.getType() != RULE; parent = parent.getParent() )
+					//{
+					//	if ( parent.getType() == BLOCK && countAltsForBlock((GrammarAST)parent) > 1 )
+					//	{
+					//		@out(" ");
+					//		break;
+					//	}
+					//}
+					@out(" (");
+				}
+			}
+			(optionsSpec {@out(" :");} )?
+			alternative rewrite ( {@out("|");} alternative rewrite )*
+			EOB   {if ( forceParens||numAlts>1 ) @out(")");}
+		 )
+	;
+
+alternative
+	:	^( ALT (element)+ EOA )
+	;
+
+exceptionGroup
+	:	( exceptionHandler )+ (finallyClause)?
+	|	finallyClause
+	;
+
+exceptionHandler
+	:	^('catch' ARG_ACTION ACTION)
+	;
+
+finallyClause
+	:	^('finally' ACTION)
+	;
+
+single_rewrite
+	:	^(	REWRITE {@out(" ->");}
+			(	SEMPRED {@out(" {"+$SEMPRED.text+"}?");}
+			)?
+			(	alternative
+			|	rewrite_template
+			|	ETC {@out("...");}
+			|	ACTION {@out(" {"+$ACTION.text+"}");}
+			)
+		)
+	;
+
+rewrite_template
+	:	^(	TEMPLATE
+			(	id=ID {@out(" "+$id.text);}
+			|	ind=ACTION {@out(" ({"+$ind.text+"})");}
+			)
+			^(	ARGLIST
+				{@out("(");}
+				(	^(	ARG arg=ID {@out($arg.text+"=");}
+						a=ACTION   {@out($a.text);}
+					)
+				)*
+				{@out(")");}
+			)
+			(	DOUBLE_QUOTE_STRING_LITERAL {@out(" "+$DOUBLE_QUOTE_STRING_LITERAL.text);}
+			|	DOUBLE_ANGLE_STRING_LITERAL {@out(" "+$DOUBLE_ANGLE_STRING_LITERAL.text);}
+			)?
+		)
+	;
+
+rewrite
+	:	(single_rewrite)*
+	;
+
+element
+	:	^(ROOT element)
+	|	^(BANG element)
+	|	atom
+	|	^(NOT {@out("~");} element)
+	|	^(RANGE atom {@out("..");} atom)
+	|	^(CHAR_RANGE atom {@out("..");} atom)
+	|	^(ASSIGN id=ID {@out($id.text+"=");} element)
+	|	^(PLUS_ASSIGN id2=ID {@out($id2.text+"+=");} element)
+	|	ebnf
+	|	tree_
+	|	^( SYNPRED block[true] ) {@out("=>");}
+	|	a=ACTION  {if ( showActions ) {@out("{"); @out($a.text); @out("}");}}
+	|	a2=FORCED_ACTION  {if ( showActions ) {@out("{{"); @out($a2.text); @out("}}");}}
+	|	pred=SEMPRED
+		{
+			if ( showActions )
+			{
+				@out("{");
+				@out($pred.text);
+				@out("}?");
+			}
+			else
+			{
+				@out("{...}?");
+			}
+		}
+	|	spred=SYN_SEMPRED
+		{
+			string name = $spred.text;
+			GrammarAST predAST=grammar.getSyntacticPredicate(name);
+			block(predAST, true);
+			@out("=>");
+		}
+	|	^(BACKTRACK_SEMPRED .*) // don't print anything (auto backtrack stuff)
+	|	gpred=GATED_SEMPRED
+		{
+		if ( showActions ) {@out("{"); @out($gpred.text); @out("}? =>");}
+		else {@out("{...}? =>");}
+		}
+	|	EPSILON
+	;
+
+ebnf
+	:	block[true] {@out(" ");}
+	|	^( OPTIONAL block[true] ) {@out("? ");}
+	|	^( CLOSURE block[true] )  {@out("* ");}
+	|	^( POSITIVE_CLOSURE block[true] ) {@out("+ ");}
+	;
+
+tree_
+	:	^(TREE_BEGIN {@out(" ^(");} element (element)* {@out(") ");} )
+	;
+
+atom
+@init
+{@out(" ");}
+	:	(	^(	RULE_REF		{@out($start.ToString());}
+				(rarg=ARG_ACTION	{@out("["+$rarg.ToString()+"]");})?
+				(ast_suffix)?
+			)
+		|	^(	TOKEN_REF		{@out($start.ToString());}
+				(targ=ARG_ACTION	{@out("["+$targ.ToString()+"]");} )?
+				(ast_suffix)?
+			)
+		|	^(	CHAR_LITERAL	{@out($start.ToString());}
+				(ast_suffix)?
+			)
+		|	^(	STRING_LITERAL	{@out($start.ToString());}
+				(ast_suffix)?
+			)
+		|	^(	WILDCARD		{@out($start.ToString());}
+				(ast_suffix)?
+			)
+		)
+		{@out(" ");}
+	|	LABEL {@out(" $"+$LABEL.text);} // used in -> rewrites
+	|	^(DOT ID {@out($ID.text+".");} atom) // scope override on rule
+	;
+
+ast_suffix
+	:	ROOT {@out("^");}
+	|	BANG  {@out("!");}
+	;
diff --git a/Antlr3/Grammars/ANTLRTreePrinterHelper.cs b/Antlr3/Grammars/ANTLRTreePrinterHelper.cs
new file mode 100644
index 0000000..0bb4fb5
--- /dev/null
+++ b/Antlr3/Grammars/ANTLRTreePrinterHelper.cs
@@ -0,0 +1,104 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Grammar conversion to ANTLR v3 and C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *	notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	notice, this list of conditions and the following disclaimer in the
+ *	documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *	derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Grammars
+{
+    using Antlr.Runtime;
+    using Antlr3.Tool;
+
+    using CommonTreeNodeStream = Antlr.Runtime.Tree.CommonTreeNodeStream;
+    using RecognitionException = Antlr.Runtime.RecognitionException;
+    using StringBuilder = System.Text.StringBuilder;
+
+    partial class ANTLRTreePrinter
+    {
+        protected Grammar grammar;
+        protected bool showActions;
+        protected StringBuilder buf = new StringBuilder( 300 );
+
+        public ANTLRTreePrinter.block_return block( GrammarAST t, bool forceParens )
+        {
+            ANTLRTreePrinter other = new ANTLRTreePrinter( new CommonTreeNodeStream( t ) );
+            return other.block( forceParens );
+        }
+        public int countAltsForBlock(GrammarAST t)
+        {
+            int n = 0;
+            for ( int i = 0; i < t.ChildCount; i++ )
+            {
+                if ( t.GetChild( i ).Type == ALT )
+                    n++;
+            }
+
+            return n;
+        }
+
+        public virtual void @out( string s )
+        {
+            buf.Append( s );
+        }
+
+        public override void ReportError( RecognitionException ex )
+        {
+            IToken token = null;
+            if ( ex is MismatchedTokenException )
+            {
+                token = ( (MismatchedTokenException)ex ).token;
+            }
+            else if ( ex is NoViableAltException )
+            {
+                token = ( (NoViableAltException)ex ).token;
+            }
+            ErrorManager.syntaxError(
+                ErrorManager.MSG_SYNTAX_ERROR,
+                grammar,
+                token,
+                "antlr.print: " + ex.ToString(),
+                ex );
+        }
+
+        /** Normalize a grammar print out by removing all double spaces
+         *  and trailing/beginning stuff.  FOr example, convert
+         *
+         *  ( A  |  B  |  C )*
+         *
+         *  to
+         *
+         *  ( A | B | C )*
+         */
+        public static string normalize( string g )
+        {
+            // the trim appears to take just the last \n off
+            return string.Join( " ", g.Split( new char[] { ' ' }, System.StringSplitOptions.RemoveEmptyEntries ) ).Trim();
+        }
+    }
+}
diff --git a/Antlr3/Grammars/ActionAnalysisLexer.cs b/Antlr3/Grammars/ActionAnalysisLexer.cs
new file mode 100644
index 0000000..3bc0bbc
--- /dev/null
+++ b/Antlr3/Grammars/ActionAnalysisLexer.cs
@@ -0,0 +1,504 @@
+// $ANTLR 3.1.2 Grammars\\ActionAnalysisLexer.g3 2009-03-07 08:57:34
+
+// The variable 'variable' is assigned but its value is never used.
+#pragma warning disable 219
+// Unreachable code detected.
+#pragma warning disable 162
+
+
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+using Antlr3.Tool;
+
+
+using System.Collections.Generic;
+using Antlr.Runtime;
+using Stack = System.Collections.Generic.Stack<object>;
+using List = System.Collections.IList;
+using ArrayList = System.Collections.Generic.List<object>;
+using Map = System.Collections.IDictionary;
+using HashMap = System.Collections.Generic.Dictionary<object, object>;
+namespace Antlr3.Grammars
+{
+/** We need to set Rule.referencedPredefinedRuleAttributes before
+ *  code generation.  This filter looks at an action in context of
+ *  its rule and outer alternative number and figures out which
+ *  rules have predefined prefs referenced.  I need this so I can
+ *  remove unusued labels.  This also tracks, for labeled rules,
+ *  which are referenced by actions.
+ */
+public partial class ActionAnalysisLexer : Lexer
+{
+	public const int EOF=-1;
+	public const int ID=4;
+	public const int X=5;
+	public const int X_Y=6;
+	public const int Y=7;
+
+    // delegates
+    // delegators
+
+	public ActionAnalysisLexer() {}
+	public ActionAnalysisLexer( ICharStream input )
+		: this( input, new RecognizerSharedState() )
+	{
+	}
+	public ActionAnalysisLexer( ICharStream input, RecognizerSharedState state )
+		: base( input, state )
+	{
+
+	}
+	public override string GrammarFileName { get { return "Grammars\\ActionAnalysisLexer.g3"; } }
+
+	public override IToken NextToken()
+	{
+		for ( ; ;)
+		{
+			if ( input.LA(1)==CharStreamConstants.EOF )
+			{
+				return TokenConstants.EOF_TOKEN;
+			}
+			state.token = null;
+			state.channel = TokenConstants.DEFAULT_CHANNEL;
+			state.tokenStartCharIndex = input.Index;
+			state.tokenStartCharPositionInLine = input.CharPositionInLine;
+			state.tokenStartLine = input.Line;
+			state.text = null;
+			try
+			{
+				int m = input.Mark();
+				state.backtracking=1;
+				state.failed=false;
+				mTokens();
+				state.backtracking=0;
+
+				if ( state.failed )
+				{
+					input.Rewind(m);
+					input.Consume();
+				}
+				else
+				{
+					Emit();
+					return state.token;
+				}
+			}
+			catch ( RecognitionException re )
+			{
+				// shouldn't happen in backtracking mode, but...
+				ReportError(re);
+				Recover(re);
+			}
+		}
+	}
+
+	public override void Memoize( IIntStream input, int ruleIndex, int ruleStartIndex )
+	{
+		if ( state.backtracking > 1 )
+			base.Memoize( input, ruleIndex, ruleStartIndex );
+	}
+
+	public override bool AlreadyParsedRule(IIntStream input, int ruleIndex)
+	{
+		if ( state.backtracking > 1 )
+			return base.AlreadyParsedRule(input, ruleIndex);
+
+		return false;
+	}// $ANTLR start "X_Y"
+	private void mX_Y()
+	{
+		try
+		{
+			int _type = X_Y;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken x=null;
+			IToken y=null;
+
+			// Grammars\\ActionAnalysisLexer.g3:92:4: ( '$' x= ID '.' y= ID {...}?)
+			// Grammars\\ActionAnalysisLexer.g3:92:4: '$' x= ID '.' y= ID {...}?
+			{
+			Match('$'); if (state.failed) return ;
+			int xStart57 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			x = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, xStart57, GetCharIndex()-1);
+			Match('.'); if (state.failed) return ;
+			int yStart63 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			y = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, yStart63, GetCharIndex()-1);
+			if ( !((enclosingRule!=null)) )
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				throw new FailedPredicateException(input, "X_Y", "enclosingRule!=null");
+			}
+			if ( state.backtracking==1 )
+			{
+
+							AttributeScope scope = null;
+							string refdRuleName = null;
+							if ( (x!=null?x.Text:null).Equals(enclosingRule.name) )
+							{
+								// ref to enclosing rule.
+								refdRuleName = (x!=null?x.Text:null);
+								scope = enclosingRule.getLocalAttributeScope((y!=null?y.Text:null));
+							}
+							else if ( enclosingRule.getRuleLabel((x!=null?x.Text:null))!=null )
+							{
+								// ref to rule label
+								Grammar.LabelElementPair pair = enclosingRule.getRuleLabel((x!=null?x.Text:null));
+								pair.actionReferencesLabel = true;
+								refdRuleName = pair.referencedRuleName;
+								Rule refdRule = grammar.getRule(refdRuleName);
+								if ( refdRule!=null )
+								{
+									scope = refdRule.getLocalAttributeScope((y!=null?y.Text:null));
+								}
+							}
+							else if ( enclosingRule.getRuleRefsInAlt(x.Text, outerAltNum)!=null )
+							{
+								// ref to rule referenced in this alt
+								refdRuleName = (x!=null?x.Text:null);
+								Rule refdRule = grammar.getRule(refdRuleName);
+								if ( refdRule!=null )
+								{
+									scope = refdRule.getLocalAttributeScope((y!=null?y.Text:null));
+								}
+							}
+							if ( scope!=null &&
+								 (scope.isPredefinedRuleScope||scope.isPredefinedLexerRuleScope) )
+							{
+								grammar.referenceRuleLabelPredefinedAttribute(refdRuleName);
+								//System.out.println("referenceRuleLabelPredefinedAttribute for "+refdRuleName);
+							}
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "X_Y"
+
+	// $ANTLR start "X"
+	private void mX()
+	{
+		try
+		{
+			int _type = X;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken ID1=null;
+
+			// Grammars\\ActionAnalysisLexer.g3:135:4: ( '$' ID {...}?)
+			// Grammars\\ActionAnalysisLexer.g3:135:4: '$' ID {...}?
+			{
+			Match('$'); if (state.failed) return ;
+			int ID1Start84 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			ID1 = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, ID1Start84, GetCharIndex()-1);
+			if ( !((enclosingRule!=null && enclosingRule.getRuleLabel((ID1!=null?ID1.Text:null))!=null)) )
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				throw new FailedPredicateException(input, "X", "enclosingRule!=null && enclosingRule.getRuleLabel($ID.text)!=null");
+			}
+			if ( state.backtracking==1 )
+			{
+
+							Grammar.LabelElementPair pair = enclosingRule.getRuleLabel((ID1!=null?ID1.Text:null));
+							pair.actionReferencesLabel = true;
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "X"
+
+	// $ANTLR start "Y"
+	private void mY()
+	{
+		try
+		{
+			int _type = Y;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken ID2=null;
+
+			// Grammars\\ActionAnalysisLexer.g3:144:4: ( '$' ID {...}?)
+			// Grammars\\ActionAnalysisLexer.g3:144:4: '$' ID {...}?
+			{
+			Match('$'); if (state.failed) return ;
+			int ID2Start106 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			ID2 = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, ID2Start106, GetCharIndex()-1);
+			if ( !((enclosingRule!=null && enclosingRule.getLocalAttributeScope((ID2!=null?ID2.Text:null))!=null)) )
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				throw new FailedPredicateException(input, "Y", "enclosingRule!=null && enclosingRule.getLocalAttributeScope($ID.text)!=null");
+			}
+			if ( state.backtracking==1 )
+			{
+
+							AttributeScope scope = enclosingRule.getLocalAttributeScope((ID2!=null?ID2.Text:null));
+							if ( scope!=null &&
+								 (scope.isPredefinedRuleScope||scope.isPredefinedLexerRuleScope) )
+							{
+								grammar.referenceRuleLabelPredefinedAttribute(enclosingRule.name);
+								//System.out.println("referenceRuleLabelPredefinedAttribute for "+(ID2!=null?ID2.Text:null));
+							}
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "Y"
+
+	// $ANTLR start "ID"
+	private void mID()
+	{
+		try
+		{
+			// Grammars\\ActionAnalysisLexer.g3:158:4: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
+			// Grammars\\ActionAnalysisLexer.g3:158:4: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
+			{
+			if ( (input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z') )
+			{
+				input.Consume();
+			state.failed=false;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				Recover(mse);
+				throw mse;}
+
+			// Grammars\\ActionAnalysisLexer.g3:158:28: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
+			for ( ; ; )
+			{
+				int alt1=2;
+				int LA1_0 = input.LA(1);
+
+				if ( ((LA1_0>='0' && LA1_0<='9')||(LA1_0>='A' && LA1_0<='Z')||LA1_0=='_'||(LA1_0>='a' && LA1_0<='z')) )
+				{
+					alt1=1;
+				}
+
+
+				switch ( alt1 )
+				{
+				case 1:
+					// Grammars\\ActionAnalysisLexer.g3:
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+
+				default:
+					goto loop1;
+				}
+			}
+
+			loop1:
+				;
+
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ID"
+
+	public override void mTokens()
+	{
+		// Grammars\\ActionAnalysisLexer.g3:1:41: ( X_Y | X | Y )
+		int alt2=3;
+		int LA2_0 = input.LA(1);
+
+		if ( (LA2_0=='$') )
+		{
+			int LA2_1 = input.LA(2);
+
+			if ( (synpred1_ActionAnalysisLexer()) )
+			{
+				alt2=1;
+			}
+			else if ( (synpred2_ActionAnalysisLexer()) )
+			{
+				alt2=2;
+			}
+			else if ( (true) )
+			{
+				alt2=3;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				NoViableAltException nvae = new NoViableAltException("", 2, 1, input);
+
+				throw nvae;
+			}
+		}
+		else
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
+
+			throw nvae;
+		}
+		switch ( alt2 )
+		{
+		case 1:
+			// Grammars\\ActionAnalysisLexer.g3:1:41: X_Y
+			{
+
+			mX_Y(); if (state.failed) return ;
+
+			}
+			break;
+		case 2:
+			// Grammars\\ActionAnalysisLexer.g3:1:45: X
+			{
+
+			mX(); if (state.failed) return ;
+
+			}
+			break;
+		case 3:
+			// Grammars\\ActionAnalysisLexer.g3:1:47: Y
+			{
+			mY(); if (state.failed) return ;
+
+			}
+			break;
+
+		}
+
+	}
+
+	// $ANTLR start synpred1_ActionAnalysisLexer
+	public void synpred1_ActionAnalysisLexer_fragment()
+	{
+		// Grammars\\ActionAnalysisLexer.g3:1:0: ( X_Y )
+		// Grammars\\ActionAnalysisLexer.g3:1:41: X_Y
+		{
+		mX_Y(); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred1_ActionAnalysisLexer
+
+	// $ANTLR start synpred2_ActionAnalysisLexer
+	public void synpred2_ActionAnalysisLexer_fragment()
+	{
+		// Grammars\\ActionAnalysisLexer.g3:1:0: ( X )
+		// Grammars\\ActionAnalysisLexer.g3:1:45: X
+		{
+		mX(); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred2_ActionAnalysisLexer
+
+	public bool synpred1_ActionAnalysisLexer()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred1_ActionAnalysisLexer_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred2_ActionAnalysisLexer()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred2_ActionAnalysisLexer_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+
+
+	#region DFA
+
+	protected override void InitDFAs()
+	{
+		base.InitDFAs();
+	}
+
+
+	#endregion
+
+}
+
+} // namespace Antlr3.Grammars
diff --git a/Antlr3/Grammars/ActionAnalysisLexer.g3 b/Antlr3/Grammars/ActionAnalysisLexer.g3
new file mode 100644
index 0000000..32524aa
--- /dev/null
+++ b/Antlr3/Grammars/ActionAnalysisLexer.g3
@@ -0,0 +1,159 @@
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+    notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+    derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/** We need to set Rule.referencedPredefinedRuleAttributes before
+ *  code generation.  This filter looks at an action in context of
+ *  its rule and outer alternative number and figures out which
+ *  rules have predefined prefs referenced.  I need this so I can
+ *  remove unusued labels.  This also tracks, for labeled rules,
+ *  which are referenced by actions.
+ */
+lexer grammar ActionAnalysisLexer;
+
+options
+{
+	language=CSharp3;
+	// try all non-fragment rules in order specified:
+	filter=true;
+}
+
+@header
+{
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+using Antlr3.Tool;
+}
+
+@lexer::namespace{Antlr3.Grammars}
+
+/**	$x.y	x is enclosing rule or rule ref or rule label
+ *			y is a return value, parameter, or predefined property.
+ */
+X_Y
+	:	'$' x=ID '.' y=ID {enclosingRule!=null}?
+		{
+			AttributeScope scope = null;
+			string refdRuleName = null;
+			if ( $x.text.Equals(enclosingRule.name) )
+			{
+				// ref to enclosing rule.
+				refdRuleName = $x.text;
+				scope = enclosingRule.getLocalAttributeScope($y.text);
+			}
+			else if ( enclosingRule.getRuleLabel($x.text)!=null )
+			{
+				// ref to rule label
+				Grammar.LabelElementPair pair = enclosingRule.getRuleLabel($x.text);
+				pair.actionReferencesLabel = true;
+				refdRuleName = pair.referencedRuleName;
+				Rule refdRule = grammar.getRule(refdRuleName);
+				if ( refdRule!=null )
+				{
+					scope = refdRule.getLocalAttributeScope($y.text);
+				}
+			}
+			else if ( enclosingRule.getRuleRefsInAlt(x.Text, outerAltNum)!=null )
+			{
+				// ref to rule referenced in this alt
+				refdRuleName = $x.text;
+				Rule refdRule = grammar.getRule(refdRuleName);
+				if ( refdRule!=null )
+				{
+					scope = refdRule.getLocalAttributeScope($y.text);
+				}
+			}
+			if ( scope!=null &&
+				 (scope.isPredefinedRuleScope||scope.isPredefinedLexerRuleScope) )
+			{
+				grammar.referenceRuleLabelPredefinedAttribute(refdRuleName);
+				//System.out.println("referenceRuleLabelPredefinedAttribute for "+refdRuleName);
+			}
+		}
+	;
+
+/** $x	x is an isolated rule label.  Just record that the label was referenced */
+X
+	:	'$' ID {enclosingRule!=null && enclosingRule.getRuleLabel($ID.text)!=null}?
+		{
+			Grammar.LabelElementPair pair = enclosingRule.getRuleLabel($ID.text);
+			pair.actionReferencesLabel = true;
+		}
+	;
+
+/** $y	y is a return value, parameter, or predefined property of current rule */
+Y
+	:	'$' ID {enclosingRule!=null && enclosingRule.getLocalAttributeScope($ID.text)!=null}?
+		{
+			AttributeScope scope = enclosingRule.getLocalAttributeScope($ID.text);
+			if ( scope!=null &&
+				 (scope.isPredefinedRuleScope||scope.isPredefinedLexerRuleScope) )
+			{
+				grammar.referenceRuleLabelPredefinedAttribute(enclosingRule.name);
+				//System.out.println("referenceRuleLabelPredefinedAttribute for "+$ID.text);
+			}
+		}
+	;
+
+fragment
+ID
+	:	('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*
+	;
diff --git a/Antlr3/Grammars/ActionAnalysisLexerHelper.cs b/Antlr3/Grammars/ActionAnalysisLexerHelper.cs
new file mode 100644
index 0000000..7cf2240
--- /dev/null
+++ b/Antlr3/Grammars/ActionAnalysisLexerHelper.cs
@@ -0,0 +1,64 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Grammar conversion to ANTLR v3 and C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *	notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	notice, this list of conditions and the following disclaimer in the
+ *	documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *	derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Grammars
+{
+    using Antlr.Runtime;
+    using Antlr3.Tool;
+
+    partial class ActionAnalysisLexer
+    {
+        Rule enclosingRule;
+        Grammar grammar;
+        IToken actionToken;
+        int outerAltNum = 0;
+
+        public ActionAnalysisLexer( Grammar grammar, string ruleName, GrammarAST actionAST )
+            : this( new ANTLRStringStream( actionAST.token.Text ) )
+        {
+            this.grammar = grammar;
+            this.enclosingRule = grammar.getLocallyDefinedRule( ruleName );
+            this.actionToken = actionAST.token;
+            this.outerAltNum = actionAST.outerAltNum;
+        }
+
+        public void analyze()
+        {
+            // System.out.println("###\naction="+actionToken);
+            IToken t;
+            do
+            {
+                t = NextToken();
+            } while ( t.Type != TokenConstants.EOF );
+        }
+    }
+}
diff --git a/Antlr3/Grammars/ActionTranslator.cs b/Antlr3/Grammars/ActionTranslator.cs
new file mode 100644
index 0000000..f1cbfaf
--- /dev/null
+++ b/Antlr3/Grammars/ActionTranslator.cs
@@ -0,0 +1,3816 @@
+// $ANTLR 3.1.2 Grammars\\ActionTranslator.g3 2009-03-07 08:57:31
+
+// The variable 'variable' is assigned but its value is never used.
+#pragma warning disable 219
+// Unreachable code detected.
+#pragma warning disable 162
+
+
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+using Antlr3.Tool;
+using StringTemplate = Antlr3.ST.StringTemplate;
+
+
+using System.Collections.Generic;
+using Antlr.Runtime;
+using Stack = System.Collections.Generic.Stack<object>;
+using List = System.Collections.IList;
+using ArrayList = System.Collections.Generic.List<object>;
+using Map = System.Collections.IDictionary;
+using HashMap = System.Collections.Generic.Dictionary<object, object>;
+namespace Antlr3.Grammars
+{
+public partial class ActionTranslator : Lexer
+{
+	public const int EOF=-1;
+	public const int ACTION=4;
+	public const int ARG=5;
+	public const int ATTR_VALUE_EXPR=6;
+	public const int DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR=7;
+	public const int DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR=8;
+	public const int DYNAMIC_SCOPE_ATTR=9;
+	public const int ENCLOSING_RULE_SCOPE_ATTR=10;
+	public const int ERROR_SCOPED_XY=11;
+	public const int ERROR_X=12;
+	public const int ERROR_XY=13;
+	public const int ESC=14;
+	public const int ID=15;
+	public const int INDIRECT_TEMPLATE_INSTANCE=16;
+	public const int INT=17;
+	public const int ISOLATED_DYNAMIC_SCOPE=18;
+	public const int ISOLATED_LEXER_RULE_REF=19;
+	public const int ISOLATED_TOKEN_REF=20;
+	public const int LABEL_REF=21;
+	public const int LOCAL_ATTR=22;
+	public const int RULE_SCOPE_ATTR=23;
+	public const int SCOPE_INDEX_EXPR=24;
+	public const int SET_ATTRIBUTE=25;
+	public const int SET_DYNAMIC_SCOPE_ATTR=26;
+	public const int SET_ENCLOSING_RULE_SCOPE_ATTR=27;
+	public const int SET_EXPR_ATTRIBUTE=28;
+	public const int SET_LOCAL_ATTR=29;
+	public const int SET_RULE_SCOPE_ATTR=30;
+	public const int SET_TOKEN_SCOPE_ATTR=31;
+	public const int TEMPLATE_EXPR=32;
+	public const int TEMPLATE_INSTANCE=33;
+	public const int TEXT=34;
+	public const int TOKEN_SCOPE_ATTR=35;
+	public const int UNKNOWN_SYNTAX=36;
+	public const int WS=37;
+
+    // delegates
+    // delegators
+
+	public ActionTranslator() {}
+	public ActionTranslator( ICharStream input )
+		: this( input, new RecognizerSharedState() )
+	{
+	}
+	public ActionTranslator( ICharStream input, RecognizerSharedState state )
+		: base( input, state )
+	{
+
+	}
+	public override string GrammarFileName { get { return "Grammars\\ActionTranslator.g3"; } }
+
+	public override IToken NextToken()
+	{
+		for ( ; ;)
+		{
+			if ( input.LA(1)==CharStreamConstants.EOF )
+			{
+				return TokenConstants.EOF_TOKEN;
+			}
+			state.token = null;
+			state.channel = TokenConstants.DEFAULT_CHANNEL;
+			state.tokenStartCharIndex = input.Index;
+			state.tokenStartCharPositionInLine = input.CharPositionInLine;
+			state.tokenStartLine = input.Line;
+			state.text = null;
+			try
+			{
+				int m = input.Mark();
+				state.backtracking=1;
+				state.failed=false;
+				mTokens();
+				state.backtracking=0;
+
+				if ( state.failed )
+				{
+					input.Rewind(m);
+					input.Consume();
+				}
+				else
+				{
+					Emit();
+					return state.token;
+				}
+			}
+			catch ( RecognitionException re )
+			{
+				// shouldn't happen in backtracking mode, but...
+				ReportError(re);
+				Recover(re);
+			}
+		}
+	}
+
+	public override void Memoize( IIntStream input, int ruleIndex, int ruleStartIndex )
+	{
+		if ( state.backtracking > 1 )
+			base.Memoize( input, ruleIndex, ruleStartIndex );
+	}
+
+	public override bool AlreadyParsedRule(IIntStream input, int ruleIndex)
+	{
+		if ( state.backtracking > 1 )
+			return base.AlreadyParsedRule(input, ruleIndex);
+
+		return false;
+	}// $ANTLR start "SET_ENCLOSING_RULE_SCOPE_ATTR"
+	private void mSET_ENCLOSING_RULE_SCOPE_ATTR()
+	{
+		try
+		{
+			int _type = SET_ENCLOSING_RULE_SCOPE_ATTR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken x=null;
+			IToken y=null;
+			IToken expr=null;
+
+			// Grammars\\ActionTranslator.g3:91:4: ( '$' x= ID '.' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?)
+			// Grammars\\ActionTranslator.g3:91:4: '$' x= ID '.' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?
+			{
+			Match('$'); if (state.failed) return ;
+			int xStart60 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			x = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, xStart60, GetCharIndex()-1);
+			Match('.'); if (state.failed) return ;
+			int yStart66 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			y = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, yStart66, GetCharIndex()-1);
+			// Grammars\\ActionTranslator.g3:91:22: ( WS )?
+			int alt1=2;
+			int LA1_0 = input.LA(1);
+
+			if ( ((LA1_0>='\t' && LA1_0<='\n')||LA1_0=='\r'||LA1_0==' ') )
+			{
+				alt1=1;
+			}
+			switch ( alt1 )
+			{
+			case 1:
+				// Grammars\\ActionTranslator.g3:91:0: WS
+				{
+				mWS(); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+			Match('='); if (state.failed) return ;
+			int exprStart75 = GetCharIndex();
+			mATTR_VALUE_EXPR(); if (state.failed) return ;
+			expr = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, exprStart75, GetCharIndex()-1);
+			Match(';'); if (state.failed) return ;
+			if ( !((enclosingRule!=null &&
+				                         (x!=null?x.Text:null).Equals(enclosingRule.name) &&
+				                         enclosingRule.getLocalAttributeScope((y!=null?y.Text:null))!=null)) )
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				throw new FailedPredicateException(input, "SET_ENCLOSING_RULE_SCOPE_ATTR", "enclosingRule!=null &&\r\n\t                         $x.text.Equals(enclosingRule.name) &&\r\n\t                         enclosingRule.getLocalAttributeScope($y.text)!=null");
+			}
+			if ( state.backtracking==1 )
+			{
+
+							StringTemplate st = null;
+							AttributeScope scope = enclosingRule.getLocalAttributeScope((y!=null?y.Text:null));
+							if ( scope.isPredefinedRuleScope )
+							{
+								if ( (y!=null?y.Text:null).Equals("st") || (y!=null?y.Text:null).Equals("tree") )
+								{
+									st = template("ruleSetPropertyRef_"+(y!=null?y.Text:null));
+									grammar.referenceRuleLabelPredefinedAttribute((x!=null?x.Text:null));
+									st.setAttribute("scope", (x!=null?x.Text:null));
+									st.setAttribute("attr", (y!=null?y.Text:null));
+									st.setAttribute("expr", translateAction((expr!=null?expr.Text:null)));
+								}
+								else
+								{
+									ErrorManager.grammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
+															  grammar,
+															  actionToken,
+															  (x!=null?x.Text:null),
+															  (y!=null?y.Text:null));
+								}
+							}
+							else if ( scope.isPredefinedLexerRuleScope )
+							{
+					    		// this is a better message to emit than the previous one...
+								ErrorManager.grammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
+														  grammar,
+														  actionToken,
+														  (x!=null?x.Text:null),
+														  (y!=null?y.Text:null));
+							}
+							else if ( scope.isParameterScope )
+							{
+								st = template("parameterSetAttributeRef");
+								st.setAttribute("attr", scope.getAttribute((y!=null?y.Text:null)));
+								st.setAttribute("expr", translateAction((expr!=null?expr.Text:null)));
+							}
+							else
+							{ // must be return value
+								st = template("returnSetAttributeRef");
+								st.setAttribute("ruleDescriptor", enclosingRule);
+								st.setAttribute("attr", scope.getAttribute((y!=null?y.Text:null)));
+								st.setAttribute("expr", translateAction((expr!=null?expr.Text:null)));
+							}
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "SET_ENCLOSING_RULE_SCOPE_ATTR"
+
+	// $ANTLR start "ENCLOSING_RULE_SCOPE_ATTR"
+	private void mENCLOSING_RULE_SCOPE_ATTR()
+	{
+		try
+		{
+			int _type = ENCLOSING_RULE_SCOPE_ATTR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken x=null;
+			IToken y=null;
+
+			// Grammars\\ActionTranslator.g3:143:4: ( '$' x= ID '.' y= ID {...}?)
+			// Grammars\\ActionTranslator.g3:143:4: '$' x= ID '.' y= ID {...}?
+			{
+			Match('$'); if (state.failed) return ;
+			int xStart107 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			x = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, xStart107, GetCharIndex()-1);
+			Match('.'); if (state.failed) return ;
+			int yStart113 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			y = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, yStart113, GetCharIndex()-1);
+			if ( !((enclosingRule!=null &&
+				                         (x!=null?x.Text:null).Equals(enclosingRule.name) &&
+				                         enclosingRule.getLocalAttributeScope((y!=null?y.Text:null))!=null)) )
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				throw new FailedPredicateException(input, "ENCLOSING_RULE_SCOPE_ATTR", "enclosingRule!=null &&\r\n\t                         $x.text.Equals(enclosingRule.name) &&\r\n\t                         enclosingRule.getLocalAttributeScope($y.text)!=null");
+			}
+			if ( state.backtracking==1 )
+			{
+
+							if ( isRuleRefInAlt((x!=null?x.Text:null)) )
+							{
+								ErrorManager.grammarError(ErrorManager.MSG_RULE_REF_AMBIG_WITH_RULE_IN_ALT,
+														  grammar,
+														  actionToken,
+														  (x!=null?x.Text:null));
+							}
+							StringTemplate st = null;
+							AttributeScope scope = enclosingRule.getLocalAttributeScope((y!=null?y.Text:null));
+							if ( scope.isPredefinedRuleScope )
+							{
+								st = template("rulePropertyRef_"+(y!=null?y.Text:null));
+								grammar.referenceRuleLabelPredefinedAttribute((x!=null?x.Text:null));
+								st.setAttribute("scope", (x!=null?x.Text:null));
+								st.setAttribute("attr", (y!=null?y.Text:null));
+							}
+							else if ( scope.isPredefinedLexerRuleScope )
+							{
+								// perhaps not the most precise error message to use, but...
+								ErrorManager.grammarError(ErrorManager.MSG_RULE_HAS_NO_ARGS,
+														  grammar,
+														  actionToken,
+														  (x!=null?x.Text:null));
+							}
+							else if ( scope.isParameterScope )
+							{
+								st = template("parameterAttributeRef");
+								st.setAttribute("attr", scope.getAttribute((y!=null?y.Text:null)));
+							}
+							else
+							{ // must be return value
+								st = template("returnAttributeRef");
+								st.setAttribute("ruleDescriptor", enclosingRule);
+								st.setAttribute("attr", scope.getAttribute((y!=null?y.Text:null)));
+							}
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ENCLOSING_RULE_SCOPE_ATTR"
+
+	// $ANTLR start "SET_TOKEN_SCOPE_ATTR"
+	private void mSET_TOKEN_SCOPE_ATTR()
+	{
+		try
+		{
+			int _type = SET_TOKEN_SCOPE_ATTR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken x=null;
+			IToken y=null;
+
+			// Grammars\\ActionTranslator.g3:188:4: ( '$' x= ID '.' y= ID ( WS )? '=' {...}?)
+			// Grammars\\ActionTranslator.g3:188:4: '$' x= ID '.' y= ID ( WS )? '=' {...}?
+			{
+			Match('$'); if (state.failed) return ;
+			int xStart139 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			x = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, xStart139, GetCharIndex()-1);
+			Match('.'); if (state.failed) return ;
+			int yStart145 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			y = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, yStart145, GetCharIndex()-1);
+			// Grammars\\ActionTranslator.g3:188:22: ( WS )?
+			int alt2=2;
+			int LA2_0 = input.LA(1);
+
+			if ( ((LA2_0>='\t' && LA2_0<='\n')||LA2_0=='\r'||LA2_0==' ') )
+			{
+				alt2=1;
+			}
+			switch ( alt2 )
+			{
+			case 1:
+				// Grammars\\ActionTranslator.g3:188:0: WS
+				{
+				mWS(); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+			Match('='); if (state.failed) return ;
+			if ( !((enclosingRule!=null && input.LA(1)!='=' &&
+				                         (enclosingRule.getTokenLabel((x!=null?x.Text:null))!=null||
+				                          isTokenRefInAlt((x!=null?x.Text:null))) &&
+				                         AttributeScope.tokenScope.getAttribute((y!=null?y.Text:null))!=null)) )
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				throw new FailedPredicateException(input, "SET_TOKEN_SCOPE_ATTR", "enclosingRule!=null && input.LA(1)!='=' &&\r\n\t                         (enclosingRule.getTokenLabel($x.text)!=null||\r\n\t                          isTokenRefInAlt($x.text)) &&\r\n\t                         AttributeScope.tokenScope.getAttribute($y.text)!=null");
+			}
+			if ( state.backtracking==1 )
+			{
+
+							ErrorManager.grammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
+													  grammar,
+													  actionToken,
+													  (x!=null?x.Text:null),
+													  (y!=null?y.Text:null));
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "SET_TOKEN_SCOPE_ATTR"
+
+	// $ANTLR start "TOKEN_SCOPE_ATTR"
+	private void mTOKEN_SCOPE_ATTR()
+	{
+		try
+		{
+			int _type = TOKEN_SCOPE_ATTR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken x=null;
+			IToken y=null;
+
+			// Grammars\\ActionTranslator.g3:207:4: ( '$' x= ID '.' y= ID {...}?)
+			// Grammars\\ActionTranslator.g3:207:4: '$' x= ID '.' y= ID {...}?
+			{
+			Match('$'); if (state.failed) return ;
+			int xStart184 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			x = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, xStart184, GetCharIndex()-1);
+			Match('.'); if (state.failed) return ;
+			int yStart190 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			y = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, yStart190, GetCharIndex()-1);
+			if ( !((enclosingRule!=null &&
+				                         (enclosingRule.getTokenLabel((x!=null?x.Text:null))!=null||
+				                          isTokenRefInAlt((x!=null?x.Text:null))) &&
+				                         AttributeScope.tokenScope.getAttribute((y!=null?y.Text:null))!=null &&
+				                         (grammar.type!=Grammar.LEXER ||
+				                         getElementLabel((x!=null?x.Text:null)).elementRef.token.Type==ANTLRParser.TOKEN_REF ||
+				                         getElementLabel((x!=null?x.Text:null)).elementRef.token.Type==ANTLRParser.STRING_LITERAL))) )
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				throw new FailedPredicateException(input, "TOKEN_SCOPE_ATTR", "enclosingRule!=null &&\r\n\t                         (enclosingRule.getTokenLabel($x.text)!=null||\r\n\t                          isTokenRefInAlt($x.text)) &&\r\n\t                         AttributeScope.tokenScope.getAttribute($y.text)!=null &&\r\n\t                         (grammar.type!=Grammar.LEXER ||\r\n\t                         getElementLabel($x.text).elementRef.token.Type==ANTLRParser.TOKEN_REF ||\r\n\t                         getElementLabel($x.text).elementRef.token.Type==ANTLRParser.STRING_LITERAL)");
+			}
+			if ( state.backtracking==1 )
+			{
+
+							string label = (x!=null?x.Text:null);
+							if ( enclosingRule.getTokenLabel((x!=null?x.Text:null))==null )
+							{
+								// $tokenref.attr  gotta get old label or compute new one
+								checkElementRefUniqueness((x!=null?x.Text:null), true);
+								label = enclosingRule.getElementLabel((x!=null?x.Text:null), outerAltNum, generator);
+								if ( label==null )
+								{
+									ErrorManager.grammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
+															  grammar,
+															  actionToken,
+															  "$"+(x!=null?x.Text:null)+"."+(y!=null?y.Text:null));
+									label = (x!=null?x.Text:null);
+								}
+							}
+							StringTemplate st = template("tokenLabelPropertyRef_"+(y!=null?y.Text:null));
+							st.setAttribute("scope", label);
+							st.setAttribute("attr", AttributeScope.tokenScope.getAttribute((y!=null?y.Text:null)));
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "TOKEN_SCOPE_ATTR"
+
+	// $ANTLR start "SET_RULE_SCOPE_ATTR"
+	private void mSET_RULE_SCOPE_ATTR()
+	{
+		try
+		{
+			int _type = SET_RULE_SCOPE_ATTR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken x=null;
+			IToken y=null;
+
+
+			Grammar.LabelElementPair pair=null;
+			string refdRuleName=null;
+
+			// Grammars\\ActionTranslator.g3:248:4: ( '$' x= ID '.' y= ID ( WS )? '=' {...}?{...}?)
+			// Grammars\\ActionTranslator.g3:248:4: '$' x= ID '.' y= ID ( WS )? '=' {...}?{...}?
+			{
+			Match('$'); if (state.failed) return ;
+			int xStart221 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			x = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, xStart221, GetCharIndex()-1);
+			Match('.'); if (state.failed) return ;
+			int yStart227 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			y = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, yStart227, GetCharIndex()-1);
+			// Grammars\\ActionTranslator.g3:248:22: ( WS )?
+			int alt3=2;
+			int LA3_0 = input.LA(1);
+
+			if ( ((LA3_0>='\t' && LA3_0<='\n')||LA3_0=='\r'||LA3_0==' ') )
+			{
+				alt3=1;
+			}
+			switch ( alt3 )
+			{
+			case 1:
+				// Grammars\\ActionTranslator.g3:248:0: WS
+				{
+				mWS(); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+			Match('='); if (state.failed) return ;
+			if ( !((enclosingRule!=null && input.LA(1)!='=')) )
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				throw new FailedPredicateException(input, "SET_RULE_SCOPE_ATTR", "enclosingRule!=null && input.LA(1)!='='");
+			}
+			if ( state.backtracking==1 )
+			{
+
+							pair = enclosingRule.getRuleLabel((x!=null?x.Text:null));
+							refdRuleName = (x!=null?x.Text:null);
+							if ( pair!=null )
+							{
+								refdRuleName = pair.referencedRuleName;
+							}
+
+			}
+			if ( !(((enclosingRule.getRuleLabel((x!=null?x.Text:null))!=null || isRuleRefInAlt((x!=null?x.Text:null))) &&
+				      getRuleLabelAttribute(enclosingRule.getRuleLabel((x!=null?x.Text:null))!=null?enclosingRule.getRuleLabel((x!=null?x.Text:null)).referencedRuleName:(x!=null?x.Text:null),(y!=null?y.Text:null))!=null)) )
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				throw new FailedPredicateException(input, "SET_RULE_SCOPE_ATTR", "(enclosingRule.getRuleLabel($x.text)!=null || isRuleRefInAlt($x.text)) &&\r\n\t      getRuleLabelAttribute(enclosingRule.getRuleLabel($x.text)!=null?enclosingRule.getRuleLabel($x.text).referencedRuleName:$x.text,$y.text)!=null");
+			}
+			if ( state.backtracking==1 )
+			{
+
+							ErrorManager.grammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
+													  grammar,
+													  actionToken,
+													  (x!=null?x.Text:null),
+													  (y!=null?y.Text:null));
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "SET_RULE_SCOPE_ATTR"
+
+	// $ANTLR start "RULE_SCOPE_ATTR"
+	private void mRULE_SCOPE_ATTR()
+	{
+		try
+		{
+			int _type = RULE_SCOPE_ATTR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken x=null;
+			IToken y=null;
+
+
+				Grammar.LabelElementPair pair=null;
+				string refdRuleName=null;
+
+			// Grammars\\ActionTranslator.g3:279:4: ( '$' x= ID '.' y= ID {...}?{...}?)
+			// Grammars\\ActionTranslator.g3:279:4: '$' x= ID '.' y= ID {...}?{...}?
+			{
+			Match('$'); if (state.failed) return ;
+			int xStart280 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			x = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, xStart280, GetCharIndex()-1);
+			Match('.'); if (state.failed) return ;
+			int yStart286 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			y = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, yStart286, GetCharIndex()-1);
+			if ( !((enclosingRule!=null)) )
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				throw new FailedPredicateException(input, "RULE_SCOPE_ATTR", "enclosingRule!=null");
+			}
+			if ( state.backtracking==1 )
+			{
+
+						pair = enclosingRule.getRuleLabel((x!=null?x.Text:null));
+						refdRuleName = (x!=null?x.Text:null);
+						if ( pair!=null ) {
+							refdRuleName = pair.referencedRuleName;
+						}
+
+			}
+			if ( !(((enclosingRule.getRuleLabel((x!=null?x.Text:null))!=null || isRuleRefInAlt((x!=null?x.Text:null))) &&
+				      getRuleLabelAttribute(enclosingRule.getRuleLabel((x!=null?x.Text:null))!=null?enclosingRule.getRuleLabel((x!=null?x.Text:null)).referencedRuleName:(x!=null?x.Text:null),(y!=null?y.Text:null))!=null)) )
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				throw new FailedPredicateException(input, "RULE_SCOPE_ATTR", "(enclosingRule.getRuleLabel($x.text)!=null || isRuleRefInAlt($x.text)) &&\r\n\t      getRuleLabelAttribute(enclosingRule.getRuleLabel($x.text)!=null?enclosingRule.getRuleLabel($x.text).referencedRuleName:$x.text,$y.text)!=null");
+			}
+			if ( state.backtracking==1 )
+			{
+
+							string label = (x!=null?x.Text:null);
+							if ( pair==null )
+							{
+								// $ruleref.attr  gotta get old label or compute new one
+								checkElementRefUniqueness((x!=null?x.Text:null), false);
+								label = enclosingRule.getElementLabel((x!=null?x.Text:null), outerAltNum, generator);
+								if ( label==null )
+								{
+									ErrorManager.grammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
+															  grammar,
+															  actionToken,
+															  "$"+(x!=null?x.Text:null)+"."+(y!=null?y.Text:null));
+									label = (x!=null?x.Text:null);
+								}
+							}
+							StringTemplate st;
+							Rule refdRule = grammar.getRule(refdRuleName);
+							AttributeScope scope = refdRule.getLocalAttributeScope((y!=null?y.Text:null));
+							if ( scope.isPredefinedRuleScope )
+							{
+								st = template("ruleLabelPropertyRef_"+(y!=null?y.Text:null));
+								grammar.referenceRuleLabelPredefinedAttribute(refdRuleName);
+								st.setAttribute("scope", label);
+								st.setAttribute("attr", (y!=null?y.Text:null));
+							}
+							else if ( scope.isPredefinedLexerRuleScope )
+							{
+								st = template("lexerRuleLabelPropertyRef_"+(y!=null?y.Text:null));
+								grammar.referenceRuleLabelPredefinedAttribute(refdRuleName);
+								st.setAttribute("scope", label);
+								st.setAttribute("attr", (y!=null?y.Text:null));
+							}
+							else if ( scope.isParameterScope )
+							{
+								// TODO: error!
+							}
+							else
+							{
+								st = template("ruleLabelRef");
+								st.setAttribute("referencedRule", refdRule);
+								st.setAttribute("scope", label);
+								st.setAttribute("attr", scope.getAttribute((y!=null?y.Text:null)));
+							}
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "RULE_SCOPE_ATTR"
+
+	// $ANTLR start "LABEL_REF"
+	private void mLABEL_REF()
+	{
+		try
+		{
+			int _type = LABEL_REF;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken ID1=null;
+
+			// Grammars\\ActionTranslator.g3:343:4: ( '$' ID {...}?)
+			// Grammars\\ActionTranslator.g3:343:4: '$' ID {...}?
+			{
+			Match('$'); if (state.failed) return ;
+			int ID1Start328 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			ID1 = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, ID1Start328, GetCharIndex()-1);
+			if ( !((enclosingRule!=null &&
+				            getElementLabel((ID1!=null?ID1.Text:null))!=null &&
+					        enclosingRule.getRuleLabel((ID1!=null?ID1.Text:null))==null)) )
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				throw new FailedPredicateException(input, "LABEL_REF", "enclosingRule!=null &&\r\n\t            getElementLabel($ID.text)!=null &&\r\n\t\t        enclosingRule.getRuleLabel($ID.text)==null");
+			}
+			if ( state.backtracking==1 )
+			{
+
+							StringTemplate st;
+							Grammar.LabelElementPair pair = getElementLabel((ID1!=null?ID1.Text:null));
+							if ( pair.type==Grammar.RULE_LIST_LABEL ||
+								  pair.type==Grammar.TOKEN_LIST_LABEL ||
+								  pair.type == Grammar.WILDCARD_TREE_LIST_LABEL )
+							{
+								st = template("listLabelRef");
+							}
+							else
+							{
+								st = template("tokenLabelRef");
+							}
+							st.setAttribute("label", (ID1!=null?ID1.Text:null));
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "LABEL_REF"
+
+	// $ANTLR start "ISOLATED_TOKEN_REF"
+	private void mISOLATED_TOKEN_REF()
+	{
+		try
+		{
+			int _type = ISOLATED_TOKEN_REF;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken ID2=null;
+
+			// Grammars\\ActionTranslator.g3:366:4: ( '$' ID {...}?)
+			// Grammars\\ActionTranslator.g3:366:4: '$' ID {...}?
+			{
+			Match('$'); if (state.failed) return ;
+			int ID2Start352 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			ID2 = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, ID2Start352, GetCharIndex()-1);
+			if ( !((grammar.type!=Grammar.LEXER && enclosingRule!=null && isTokenRefInAlt((ID2!=null?ID2.Text:null)))) )
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				throw new FailedPredicateException(input, "ISOLATED_TOKEN_REF", "grammar.type!=Grammar.LEXER && enclosingRule!=null && isTokenRefInAlt($ID.text)");
+			}
+			if ( state.backtracking==1 )
+			{
+
+							string label = enclosingRule.getElementLabel((ID2!=null?ID2.Text:null), outerAltNum, generator);
+							checkElementRefUniqueness((ID2!=null?ID2.Text:null), true);
+							if ( label==null )
+							{
+								ErrorManager.grammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
+														  grammar,
+														  actionToken,
+														  (ID2!=null?ID2.Text:null));
+							}
+							else
+							{
+								StringTemplate st = template("tokenLabelRef");
+								st.setAttribute("label", label);
+							}
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ISOLATED_TOKEN_REF"
+
+	// $ANTLR start "ISOLATED_LEXER_RULE_REF"
+	private void mISOLATED_LEXER_RULE_REF()
+	{
+		try
+		{
+			int _type = ISOLATED_LEXER_RULE_REF;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken ID3=null;
+
+			// Grammars\\ActionTranslator.g3:388:4: ( '$' ID {...}?)
+			// Grammars\\ActionTranslator.g3:388:4: '$' ID {...}?
+			{
+			Match('$'); if (state.failed) return ;
+			int ID3Start376 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			ID3 = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, ID3Start376, GetCharIndex()-1);
+			if ( !((grammar.type==Grammar.LEXER &&
+				             enclosingRule!=null &&
+				             isRuleRefInAlt((ID3!=null?ID3.Text:null)))) )
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				throw new FailedPredicateException(input, "ISOLATED_LEXER_RULE_REF", "grammar.type==Grammar.LEXER &&\r\n\t             enclosingRule!=null &&\r\n\t             isRuleRefInAlt($ID.text)");
+			}
+			if ( state.backtracking==1 )
+			{
+
+							string label = enclosingRule.getElementLabel((ID3!=null?ID3.Text:null), outerAltNum, generator);
+							checkElementRefUniqueness((ID3!=null?ID3.Text:null), false);
+							if ( label==null )
+							{
+								ErrorManager.grammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
+														  grammar,
+														  actionToken,
+														  (ID3!=null?ID3.Text:null));
+							}
+							else
+							{
+								StringTemplate st = template("lexerRuleLabel");
+								st.setAttribute("label", label);
+							}
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ISOLATED_LEXER_RULE_REF"
+
+	// $ANTLR start "SET_LOCAL_ATTR"
+	private void mSET_LOCAL_ATTR()
+	{
+		try
+		{
+			int _type = SET_LOCAL_ATTR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken expr=null;
+			IToken ID4=null;
+
+			// Grammars\\ActionTranslator.g3:422:4: ( '$' ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?)
+			// Grammars\\ActionTranslator.g3:422:4: '$' ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?
+			{
+			Match('$'); if (state.failed) return ;
+			int ID4Start400 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			ID4 = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, ID4Start400, GetCharIndex()-1);
+			// Grammars\\ActionTranslator.g3:422:11: ( WS )?
+			int alt4=2;
+			int LA4_0 = input.LA(1);
+
+			if ( ((LA4_0>='\t' && LA4_0<='\n')||LA4_0=='\r'||LA4_0==' ') )
+			{
+				alt4=1;
+			}
+			switch ( alt4 )
+			{
+			case 1:
+				// Grammars\\ActionTranslator.g3:422:0: WS
+				{
+				mWS(); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+			Match('='); if (state.failed) return ;
+			int exprStart409 = GetCharIndex();
+			mATTR_VALUE_EXPR(); if (state.failed) return ;
+			expr = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, exprStart409, GetCharIndex()-1);
+			Match(';'); if (state.failed) return ;
+			if ( !((enclosingRule!=null
+																&& enclosingRule.getLocalAttributeScope((ID4!=null?ID4.Text:null))!=null
+																&& !enclosingRule.getLocalAttributeScope((ID4!=null?ID4.Text:null)).isPredefinedLexerRuleScope)) )
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				throw new FailedPredicateException(input, "SET_LOCAL_ATTR", "enclosingRule!=null\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t&& enclosingRule.getLocalAttributeScope($ID.text)!=null\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t&& !enclosingRule.getLocalAttributeScope($ID.text).isPredefinedLexerRuleScope");
+			}
+			if ( state.backtracking==1 )
+			{
+
+							StringTemplate st;
+							AttributeScope scope = enclosingRule.getLocalAttributeScope((ID4!=null?ID4.Text:null));
+							if ( scope.isPredefinedRuleScope )
+							{
+								if ((ID4!=null?ID4.Text:null).Equals("tree") || (ID4!=null?ID4.Text:null).Equals("st"))
+								{
+									st = template("ruleSetPropertyRef_"+(ID4!=null?ID4.Text:null));
+									grammar.referenceRuleLabelPredefinedAttribute(enclosingRule.name);
+									st.setAttribute("scope", enclosingRule.name);
+									st.setAttribute("attr", (ID4!=null?ID4.Text:null));
+									st.setAttribute("expr", translateAction((expr!=null?expr.Text:null)));
+								}
+								else
+								{
+									ErrorManager.grammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
+															 grammar,
+															 actionToken,
+															 (ID4!=null?ID4.Text:null),
+															 "");
+								}
+							}
+							else if ( scope.isParameterScope )
+							{
+								st = template("parameterSetAttributeRef");
+								st.setAttribute("attr", scope.getAttribute((ID4!=null?ID4.Text:null)));
+								st.setAttribute("expr", translateAction((expr!=null?expr.Text:null)));
+							}
+							else
+							{
+								st = template("returnSetAttributeRef");
+								st.setAttribute("ruleDescriptor", enclosingRule);
+								st.setAttribute("attr", scope.getAttribute((ID4!=null?ID4.Text:null)));
+								st.setAttribute("expr", translateAction((expr!=null?expr.Text:null)));
+							}
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "SET_LOCAL_ATTR"
+
+	// $ANTLR start "LOCAL_ATTR"
+	private void mLOCAL_ATTR()
+	{
+		try
+		{
+			int _type = LOCAL_ATTR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken ID5=null;
+
+			// Grammars\\ActionTranslator.g3:464:4: ( '$' ID {...}?)
+			// Grammars\\ActionTranslator.g3:464:4: '$' ID {...}?
+			{
+			Match('$'); if (state.failed) return ;
+			int ID5Start432 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			ID5 = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, ID5Start432, GetCharIndex()-1);
+			if ( !((enclosingRule!=null && enclosingRule.getLocalAttributeScope((ID5!=null?ID5.Text:null))!=null)) )
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				throw new FailedPredicateException(input, "LOCAL_ATTR", "enclosingRule!=null && enclosingRule.getLocalAttributeScope($ID.text)!=null");
+			}
+			if ( state.backtracking==1 )
+			{
+
+							StringTemplate st;
+							AttributeScope scope = enclosingRule.getLocalAttributeScope((ID5!=null?ID5.Text:null));
+							if ( scope.isPredefinedRuleScope )
+							{
+								st = template("rulePropertyRef_"+(ID5!=null?ID5.Text:null));
+								grammar.referenceRuleLabelPredefinedAttribute(enclosingRule.name);
+								st.setAttribute("scope", enclosingRule.name);
+								st.setAttribute("attr", (ID5!=null?ID5.Text:null));
+							}
+							else if ( scope.isPredefinedLexerRuleScope )
+							{
+								st = template("lexerRulePropertyRef_"+(ID5!=null?ID5.Text:null));
+								st.setAttribute("scope", enclosingRule.name);
+								st.setAttribute("attr", (ID5!=null?ID5.Text:null));
+							}
+							else if ( scope.isParameterScope )
+							{
+								st = template("parameterAttributeRef");
+								st.setAttribute("attr", scope.getAttribute((ID5!=null?ID5.Text:null)));
+							}
+							else
+							{
+								st = template("returnAttributeRef");
+								st.setAttribute("ruleDescriptor", enclosingRule);
+								st.setAttribute("attr", scope.getAttribute((ID5!=null?ID5.Text:null)));
+							}
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "LOCAL_ATTR"
+
+	// $ANTLR start "SET_DYNAMIC_SCOPE_ATTR"
+	private void mSET_DYNAMIC_SCOPE_ATTR()
+	{
+		try
+		{
+			int _type = SET_DYNAMIC_SCOPE_ATTR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken x=null;
+			IToken y=null;
+			IToken expr=null;
+
+			// Grammars\\ActionTranslator.g3:509:4: ( '$' x= ID '::' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?)
+			// Grammars\\ActionTranslator.g3:509:4: '$' x= ID '::' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?
+			{
+			Match('$'); if (state.failed) return ;
+			int xStart458 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			x = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, xStart458, GetCharIndex()-1);
+			Match("::"); if (state.failed) return ;
+
+			int yStart464 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			y = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, yStart464, GetCharIndex()-1);
+			// Grammars\\ActionTranslator.g3:509:23: ( WS )?
+			int alt5=2;
+			int LA5_0 = input.LA(1);
+
+			if ( ((LA5_0>='\t' && LA5_0<='\n')||LA5_0=='\r'||LA5_0==' ') )
+			{
+				alt5=1;
+			}
+			switch ( alt5 )
+			{
+			case 1:
+				// Grammars\\ActionTranslator.g3:509:0: WS
+				{
+				mWS(); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+			Match('='); if (state.failed) return ;
+			int exprStart473 = GetCharIndex();
+			mATTR_VALUE_EXPR(); if (state.failed) return ;
+			expr = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, exprStart473, GetCharIndex()-1);
+			Match(';'); if (state.failed) return ;
+			if ( !((resolveDynamicScope((x!=null?x.Text:null))!=null &&
+									     resolveDynamicScope((x!=null?x.Text:null)).getAttribute((y!=null?y.Text:null))!=null)) )
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				throw new FailedPredicateException(input, "SET_DYNAMIC_SCOPE_ATTR", "resolveDynamicScope($x.text)!=null &&\r\n\t\t\t\t\t\t     resolveDynamicScope($x.text).getAttribute($y.text)!=null");
+			}
+			if ( state.backtracking==1 )
+			{
+
+							AttributeScope scope = resolveDynamicScope((x!=null?x.Text:null));
+							if ( scope!=null )
+							{
+								StringTemplate st = template("scopeSetAttributeRef");
+								st.setAttribute("scope", (x!=null?x.Text:null));
+								st.setAttribute("attr",  scope.getAttribute((y!=null?y.Text:null)));
+								st.setAttribute("expr",  translateAction((expr!=null?expr.Text:null)));
+							}
+							else
+							{
+								// error: invalid dynamic attribute
+							}
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "SET_DYNAMIC_SCOPE_ATTR"
+
+	// $ANTLR start "DYNAMIC_SCOPE_ATTR"
+	private void mDYNAMIC_SCOPE_ATTR()
+	{
+		try
+		{
+			int _type = DYNAMIC_SCOPE_ATTR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken x=null;
+			IToken y=null;
+
+			// Grammars\\ActionTranslator.g3:530:4: ( '$' x= ID '::' y= ID {...}?)
+			// Grammars\\ActionTranslator.g3:530:4: '$' x= ID '::' y= ID {...}?
+			{
+			Match('$'); if (state.failed) return ;
+			int xStart508 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			x = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, xStart508, GetCharIndex()-1);
+			Match("::"); if (state.failed) return ;
+
+			int yStart514 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			y = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, yStart514, GetCharIndex()-1);
+			if ( !((resolveDynamicScope((x!=null?x.Text:null))!=null &&
+									     resolveDynamicScope((x!=null?x.Text:null)).getAttribute((y!=null?y.Text:null))!=null)) )
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				throw new FailedPredicateException(input, "DYNAMIC_SCOPE_ATTR", "resolveDynamicScope($x.text)!=null &&\r\n\t\t\t\t\t\t     resolveDynamicScope($x.text).getAttribute($y.text)!=null");
+			}
+			if ( state.backtracking==1 )
+			{
+
+							AttributeScope scope = resolveDynamicScope((x!=null?x.Text:null));
+							if ( scope!=null )
+							{
+								StringTemplate st = template("scopeAttributeRef");
+								st.setAttribute("scope", (x!=null?x.Text:null));
+								st.setAttribute("attr",  scope.getAttribute((y!=null?y.Text:null)));
+							}
+							else
+							{
+								// error: invalid dynamic attribute
+							}
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "DYNAMIC_SCOPE_ATTR"
+
+	// $ANTLR start "ERROR_SCOPED_XY"
+	private void mERROR_SCOPED_XY()
+	{
+		try
+		{
+			int _type = ERROR_SCOPED_XY;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken x=null;
+			IToken y=null;
+
+			// Grammars\\ActionTranslator.g3:551:4: ( '$' x= ID '::' y= ID )
+			// Grammars\\ActionTranslator.g3:551:4: '$' x= ID '::' y= ID
+			{
+			Match('$'); if (state.failed) return ;
+			int xStart548 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			x = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, xStart548, GetCharIndex()-1);
+			Match("::"); if (state.failed) return ;
+
+			int yStart554 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			y = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, yStart554, GetCharIndex()-1);
+			if ( state.backtracking==1 )
+			{
+
+						chunks.Add(Text);
+						generator.issueInvalidScopeError((x!=null?x.Text:null),(y!=null?y.Text:null),
+						                                 enclosingRule,actionToken,
+						                                 outerAltNum);
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ERROR_SCOPED_XY"
+
+	// $ANTLR start "DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR"
+	private void mDYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR()
+	{
+		try
+		{
+			int _type = DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken x=null;
+			IToken expr=null;
+			IToken y=null;
+
+			// Grammars\\ActionTranslator.g3:569:4: ( '$' x= ID '[' '-' expr= SCOPE_INDEX_EXPR ']' '::' y= ID )
+			// Grammars\\ActionTranslator.g3:569:4: '$' x= ID '[' '-' expr= SCOPE_INDEX_EXPR ']' '::' y= ID
+			{
+			Match('$'); if (state.failed) return ;
+			int xStart576 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			x = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, xStart576, GetCharIndex()-1);
+			Match('['); if (state.failed) return ;
+			Match('-'); if (state.failed) return ;
+			int exprStart584 = GetCharIndex();
+			mSCOPE_INDEX_EXPR(); if (state.failed) return ;
+			expr = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, exprStart584, GetCharIndex()-1);
+			Match(']'); if (state.failed) return ;
+			Match("::"); if (state.failed) return ;
+
+			int yStart592 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			y = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, yStart592, GetCharIndex()-1);
+			if ( state.backtracking==1 )
+			{
+
+							StringTemplate st = template("scopeAttributeRef");
+							st.setAttribute("scope",    (x!=null?x.Text:null));
+							st.setAttribute("attr",     resolveDynamicScope((x!=null?x.Text:null)).getAttribute((y!=null?y.Text:null)));
+							st.setAttribute("negIndex", (expr!=null?expr.Text:null));
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR"
+
+	// $ANTLR start "DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR"
+	private void mDYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR()
+	{
+		try
+		{
+			int _type = DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken x=null;
+			IToken expr=null;
+			IToken y=null;
+
+			// Grammars\\ActionTranslator.g3:580:4: ( '$' x= ID '[' expr= SCOPE_INDEX_EXPR ']' '::' y= ID )
+			// Grammars\\ActionTranslator.g3:580:4: '$' x= ID '[' expr= SCOPE_INDEX_EXPR ']' '::' y= ID
+			{
+			Match('$'); if (state.failed) return ;
+			int xStart616 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			x = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, xStart616, GetCharIndex()-1);
+			Match('['); if (state.failed) return ;
+			int exprStart622 = GetCharIndex();
+			mSCOPE_INDEX_EXPR(); if (state.failed) return ;
+			expr = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, exprStart622, GetCharIndex()-1);
+			Match(']'); if (state.failed) return ;
+			Match("::"); if (state.failed) return ;
+
+			int yStart630 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			y = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, yStart630, GetCharIndex()-1);
+			if ( state.backtracking==1 )
+			{
+
+							StringTemplate st = template("scopeAttributeRef");
+							st.setAttribute("scope", (x!=null?x.Text:null));
+							st.setAttribute("attr",  resolveDynamicScope((x!=null?x.Text:null)).getAttribute((y!=null?y.Text:null)));
+							st.setAttribute("index", (expr!=null?expr.Text:null));
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR"
+
+	// $ANTLR start "SCOPE_INDEX_EXPR"
+	private void mSCOPE_INDEX_EXPR()
+	{
+		try
+		{
+			// Grammars\\ActionTranslator.g3:592:4: ( (~ ']' )+ )
+			// Grammars\\ActionTranslator.g3:592:4: (~ ']' )+
+			{
+			// Grammars\\ActionTranslator.g3:592:4: (~ ']' )+
+			int cnt6=0;
+			for ( ; ; )
+			{
+				int alt6=2;
+				int LA6_0 = input.LA(1);
+
+				if ( ((LA6_0>='\u0000' && LA6_0<='\\')||(LA6_0>='^' && LA6_0<='\uFFFF')) )
+				{
+					alt6=1;
+				}
+
+
+				switch ( alt6 )
+				{
+				case 1:
+					// Grammars\\ActionTranslator.g3:
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+
+				default:
+					if ( cnt6 >= 1 )
+						goto loop6;
+
+					if (state.backtracking>0) {state.failed=true; return ;}
+					EarlyExitException eee6 = new EarlyExitException( 6, input );
+					throw eee6;
+				}
+				cnt6++;
+			}
+			loop6:
+				;
+
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "SCOPE_INDEX_EXPR"
+
+	// $ANTLR start "ISOLATED_DYNAMIC_SCOPE"
+	private void mISOLATED_DYNAMIC_SCOPE()
+	{
+		try
+		{
+			int _type = ISOLATED_DYNAMIC_SCOPE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken ID6=null;
+
+			// Grammars\\ActionTranslator.g3:601:4: ( '$' ID {...}?)
+			// Grammars\\ActionTranslator.g3:601:4: '$' ID {...}?
+			{
+			Match('$'); if (state.failed) return ;
+			int ID6Start673 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			ID6 = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, ID6Start673, GetCharIndex()-1);
+			if ( !((resolveDynamicScope((ID6!=null?ID6.Text:null))!=null)) )
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				throw new FailedPredicateException(input, "ISOLATED_DYNAMIC_SCOPE", "resolveDynamicScope($ID.text)!=null");
+			}
+			if ( state.backtracking==1 )
+			{
+
+							StringTemplate st = template("isolatedDynamicScopeRef");
+							st.setAttribute("scope", (ID6!=null?ID6.Text:null));
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ISOLATED_DYNAMIC_SCOPE"
+
+	// $ANTLR start "TEMPLATE_INSTANCE"
+	private void mTEMPLATE_INSTANCE()
+	{
+		try
+		{
+			int _type = TEMPLATE_INSTANCE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ActionTranslator.g3:614:4: ( '%' ID '(' ( ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )? )? ')' )
+			// Grammars\\ActionTranslator.g3:614:4: '%' ID '(' ( ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )? )? ')'
+			{
+			Match('%'); if (state.failed) return ;
+			mID(); if (state.failed) return ;
+			Match('('); if (state.failed) return ;
+			// Grammars\\ActionTranslator.g3:614:15: ( ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )? )?
+			int alt11=2;
+			int LA11_0 = input.LA(1);
+
+			if ( ((LA11_0>='\t' && LA11_0<='\n')||LA11_0=='\r'||LA11_0==' '||(LA11_0>='A' && LA11_0<='Z')||LA11_0=='_'||(LA11_0>='a' && LA11_0<='z')) )
+			{
+				alt11=1;
+			}
+			switch ( alt11 )
+			{
+			case 1:
+				// Grammars\\ActionTranslator.g3:614:17: ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )?
+				{
+				// Grammars\\ActionTranslator.g3:614:17: ( WS )?
+				int alt7=2;
+				int LA7_0 = input.LA(1);
+
+				if ( ((LA7_0>='\t' && LA7_0<='\n')||LA7_0=='\r'||LA7_0==' ') )
+				{
+					alt7=1;
+				}
+				switch ( alt7 )
+				{
+				case 1:
+					// Grammars\\ActionTranslator.g3:614:0: WS
+					{
+					mWS(); if (state.failed) return ;
+
+					}
+					break;
+
+				}
+
+				mARG(); if (state.failed) return ;
+				// Grammars\\ActionTranslator.g3:614:25: ( ',' ( WS )? ARG )*
+				for ( ; ; )
+				{
+					int alt9=2;
+					int LA9_0 = input.LA(1);
+
+					if ( (LA9_0==',') )
+					{
+						alt9=1;
+					}
+
+
+					switch ( alt9 )
+					{
+					case 1:
+						// Grammars\\ActionTranslator.g3:614:26: ',' ( WS )? ARG
+						{
+						Match(','); if (state.failed) return ;
+						// Grammars\\ActionTranslator.g3:614:30: ( WS )?
+						int alt8=2;
+						int LA8_0 = input.LA(1);
+
+						if ( ((LA8_0>='\t' && LA8_0<='\n')||LA8_0=='\r'||LA8_0==' ') )
+						{
+							alt8=1;
+						}
+						switch ( alt8 )
+						{
+						case 1:
+							// Grammars\\ActionTranslator.g3:614:0: WS
+							{
+							mWS(); if (state.failed) return ;
+
+							}
+							break;
+
+						}
+
+						mARG(); if (state.failed) return ;
+
+						}
+						break;
+
+					default:
+						goto loop9;
+					}
+				}
+
+				loop9:
+					;
+
+
+				// Grammars\\ActionTranslator.g3:614:40: ( WS )?
+				int alt10=2;
+				int LA10_0 = input.LA(1);
+
+				if ( ((LA10_0>='\t' && LA10_0<='\n')||LA10_0=='\r'||LA10_0==' ') )
+				{
+					alt10=1;
+				}
+				switch ( alt10 )
+				{
+				case 1:
+					// Grammars\\ActionTranslator.g3:614:0: WS
+					{
+					mWS(); if (state.failed) return ;
+
+					}
+					break;
+
+				}
+
+
+				}
+				break;
+
+			}
+
+			Match(')'); if (state.failed) return ;
+			if ( state.backtracking==1 )
+			{
+
+							string action = Text.Substring( 1, Text.Length - 1 );
+							string ruleName = "<outside-of-rule>";
+							if ( enclosingRule!=null )
+							{
+								ruleName = enclosingRule.name;
+							}
+							StringTemplate st =
+								generator.translateTemplateConstructor(ruleName,
+																	   outerAltNum,
+																	   actionToken,
+																	   action);
+							if ( st!=null )
+							{
+								chunks.Add(st);
+							}
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "TEMPLATE_INSTANCE"
+
+	// $ANTLR start "INDIRECT_TEMPLATE_INSTANCE"
+	private void mINDIRECT_TEMPLATE_INSTANCE()
+	{
+		try
+		{
+			int _type = INDIRECT_TEMPLATE_INSTANCE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ActionTranslator.g3:637:4: ( '%' '(' ACTION ')' '(' ( ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )? )? ')' )
+			// Grammars\\ActionTranslator.g3:637:4: '%' '(' ACTION ')' '(' ( ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )? )? ')'
+			{
+			Match('%'); if (state.failed) return ;
+			Match('('); if (state.failed) return ;
+			mACTION(); if (state.failed) return ;
+			Match(')'); if (state.failed) return ;
+			Match('('); if (state.failed) return ;
+			// Grammars\\ActionTranslator.g3:637:27: ( ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )? )?
+			int alt16=2;
+			int LA16_0 = input.LA(1);
+
+			if ( ((LA16_0>='\t' && LA16_0<='\n')||LA16_0=='\r'||LA16_0==' '||(LA16_0>='A' && LA16_0<='Z')||LA16_0=='_'||(LA16_0>='a' && LA16_0<='z')) )
+			{
+				alt16=1;
+			}
+			switch ( alt16 )
+			{
+			case 1:
+				// Grammars\\ActionTranslator.g3:637:29: ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )?
+				{
+				// Grammars\\ActionTranslator.g3:637:29: ( WS )?
+				int alt12=2;
+				int LA12_0 = input.LA(1);
+
+				if ( ((LA12_0>='\t' && LA12_0<='\n')||LA12_0=='\r'||LA12_0==' ') )
+				{
+					alt12=1;
+				}
+				switch ( alt12 )
+				{
+				case 1:
+					// Grammars\\ActionTranslator.g3:637:0: WS
+					{
+					mWS(); if (state.failed) return ;
+
+					}
+					break;
+
+				}
+
+				mARG(); if (state.failed) return ;
+				// Grammars\\ActionTranslator.g3:637:37: ( ',' ( WS )? ARG )*
+				for ( ; ; )
+				{
+					int alt14=2;
+					int LA14_0 = input.LA(1);
+
+					if ( (LA14_0==',') )
+					{
+						alt14=1;
+					}
+
+
+					switch ( alt14 )
+					{
+					case 1:
+						// Grammars\\ActionTranslator.g3:637:38: ',' ( WS )? ARG
+						{
+						Match(','); if (state.failed) return ;
+						// Grammars\\ActionTranslator.g3:637:42: ( WS )?
+						int alt13=2;
+						int LA13_0 = input.LA(1);
+
+						if ( ((LA13_0>='\t' && LA13_0<='\n')||LA13_0=='\r'||LA13_0==' ') )
+						{
+							alt13=1;
+						}
+						switch ( alt13 )
+						{
+						case 1:
+							// Grammars\\ActionTranslator.g3:637:0: WS
+							{
+							mWS(); if (state.failed) return ;
+
+							}
+							break;
+
+						}
+
+						mARG(); if (state.failed) return ;
+
+						}
+						break;
+
+					default:
+						goto loop14;
+					}
+				}
+
+				loop14:
+					;
+
+
+				// Grammars\\ActionTranslator.g3:637:52: ( WS )?
+				int alt15=2;
+				int LA15_0 = input.LA(1);
+
+				if ( ((LA15_0>='\t' && LA15_0<='\n')||LA15_0=='\r'||LA15_0==' ') )
+				{
+					alt15=1;
+				}
+				switch ( alt15 )
+				{
+				case 1:
+					// Grammars\\ActionTranslator.g3:637:0: WS
+					{
+					mWS(); if (state.failed) return ;
+
+					}
+					break;
+
+				}
+
+
+				}
+				break;
+
+			}
+
+			Match(')'); if (state.failed) return ;
+			if ( state.backtracking==1 )
+			{
+
+							string action = Text.Substring( 1, Text.Length - 1 );
+							StringTemplate st =
+								generator.translateTemplateConstructor(enclosingRule.name,
+																	   outerAltNum,
+																	   actionToken,
+																	   action);
+							chunks.Add(st);
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "INDIRECT_TEMPLATE_INSTANCE"
+
+	// $ANTLR start "ARG"
+	private void mARG()
+	{
+		try
+		{
+			// Grammars\\ActionTranslator.g3:651:7: ( ID '=' ACTION )
+			// Grammars\\ActionTranslator.g3:651:7: ID '=' ACTION
+			{
+			mID(); if (state.failed) return ;
+			Match('='); if (state.failed) return ;
+			mACTION(); if (state.failed) return ;
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ARG"
+
+	// $ANTLR start "SET_EXPR_ATTRIBUTE"
+	private void mSET_EXPR_ATTRIBUTE()
+	{
+		try
+		{
+			int _type = SET_EXPR_ATTRIBUTE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken a=null;
+			IToken expr=null;
+			IToken ID7=null;
+
+			// Grammars\\ActionTranslator.g3:656:4: ( '%' a= ACTION '.' ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' )
+			// Grammars\\ActionTranslator.g3:656:4: '%' a= ACTION '.' ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';'
+			{
+			Match('%'); if (state.failed) return ;
+			int aStart823 = GetCharIndex();
+			mACTION(); if (state.failed) return ;
+			a = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, aStart823, GetCharIndex()-1);
+			Match('.'); if (state.failed) return ;
+			int ID7Start827 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			ID7 = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, ID7Start827, GetCharIndex()-1);
+			// Grammars\\ActionTranslator.g3:656:24: ( WS )?
+			int alt17=2;
+			int LA17_0 = input.LA(1);
+
+			if ( ((LA17_0>='\t' && LA17_0<='\n')||LA17_0=='\r'||LA17_0==' ') )
+			{
+				alt17=1;
+			}
+			switch ( alt17 )
+			{
+			case 1:
+				// Grammars\\ActionTranslator.g3:656:0: WS
+				{
+				mWS(); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+			Match('='); if (state.failed) return ;
+			int exprStart836 = GetCharIndex();
+			mATTR_VALUE_EXPR(); if (state.failed) return ;
+			expr = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, exprStart836, GetCharIndex()-1);
+			Match(';'); if (state.failed) return ;
+			if ( state.backtracking==1 )
+			{
+
+							StringTemplate st = template("actionSetAttribute");
+							string action = (a!=null?a.Text:null);
+							action = action.Substring( 1, action.Length - 2 ); // stuff inside {...}
+							st.setAttribute("st", translateAction(action));
+							st.setAttribute("attrName", (ID7!=null?ID7.Text:null));
+							st.setAttribute("expr", translateAction((expr!=null?expr.Text:null)));
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "SET_EXPR_ATTRIBUTE"
+
+	// $ANTLR start "SET_ATTRIBUTE"
+	private void mSET_ATTRIBUTE()
+	{
+		try
+		{
+			int _type = SET_ATTRIBUTE;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken x=null;
+			IToken y=null;
+			IToken expr=null;
+
+			// Grammars\\ActionTranslator.g3:673:4: ( '%' x= ID '.' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' )
+			// Grammars\\ActionTranslator.g3:673:4: '%' x= ID '.' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';'
+			{
+			Match('%'); if (state.failed) return ;
+			int xStart863 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			x = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, xStart863, GetCharIndex()-1);
+			Match('.'); if (state.failed) return ;
+			int yStart869 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			y = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, yStart869, GetCharIndex()-1);
+			// Grammars\\ActionTranslator.g3:673:22: ( WS )?
+			int alt18=2;
+			int LA18_0 = input.LA(1);
+
+			if ( ((LA18_0>='\t' && LA18_0<='\n')||LA18_0=='\r'||LA18_0==' ') )
+			{
+				alt18=1;
+			}
+			switch ( alt18 )
+			{
+			case 1:
+				// Grammars\\ActionTranslator.g3:673:0: WS
+				{
+				mWS(); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+			Match('='); if (state.failed) return ;
+			int exprStart878 = GetCharIndex();
+			mATTR_VALUE_EXPR(); if (state.failed) return ;
+			expr = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, exprStart878, GetCharIndex()-1);
+			Match(';'); if (state.failed) return ;
+			if ( state.backtracking==1 )
+			{
+
+							StringTemplate st = template("actionSetAttribute");
+							st.setAttribute("st", (x!=null?x.Text:null));
+							st.setAttribute("attrName", (y!=null?y.Text:null));
+							st.setAttribute("expr", translateAction((expr!=null?expr.Text:null)));
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "SET_ATTRIBUTE"
+
+	// $ANTLR start "ATTR_VALUE_EXPR"
+	private void mATTR_VALUE_EXPR()
+	{
+		try
+		{
+			// Grammars\\ActionTranslator.g3:686:4: (~ '=' (~ ';' )* )
+			// Grammars\\ActionTranslator.g3:686:4: ~ '=' (~ ';' )*
+			{
+			if ( (input.LA(1)>='\u0000' && input.LA(1)<='<')||(input.LA(1)>='>' && input.LA(1)<='\uFFFF') )
+			{
+				input.Consume();
+			state.failed=false;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				Recover(mse);
+				throw mse;}
+
+			// Grammars\\ActionTranslator.g3:686:9: (~ ';' )*
+			for ( ; ; )
+			{
+				int alt19=2;
+				int LA19_0 = input.LA(1);
+
+				if ( ((LA19_0>='\u0000' && LA19_0<=':')||(LA19_0>='<' && LA19_0<='\uFFFF')) )
+				{
+					alt19=1;
+				}
+
+
+				switch ( alt19 )
+				{
+				case 1:
+					// Grammars\\ActionTranslator.g3:
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+
+				default:
+					goto loop19;
+				}
+			}
+
+			loop19:
+				;
+
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ATTR_VALUE_EXPR"
+
+	// $ANTLR start "TEMPLATE_EXPR"
+	private void mTEMPLATE_EXPR()
+	{
+		try
+		{
+			int _type = TEMPLATE_EXPR;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken a=null;
+
+			// Grammars\\ActionTranslator.g3:691:4: ( '%' a= ACTION )
+			// Grammars\\ActionTranslator.g3:691:4: '%' a= ACTION
+			{
+			Match('%'); if (state.failed) return ;
+			int aStart927 = GetCharIndex();
+			mACTION(); if (state.failed) return ;
+			a = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, aStart927, GetCharIndex()-1);
+			if ( state.backtracking==1 )
+			{
+
+							StringTemplate st = template("actionStringConstructor");
+							string action = (a!=null?a.Text:null);
+							action = action.Substring( 1, action.Length - 2 ); // stuff inside {...}
+							st.setAttribute("stringExpr", translateAction(action));
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "TEMPLATE_EXPR"
+
+	// $ANTLR start "ACTION"
+	private void mACTION()
+	{
+		try
+		{
+			// Grammars\\ActionTranslator.g3:703:4: ( '{' ( options {greedy=false; } : . )* '}' )
+			// Grammars\\ActionTranslator.g3:703:4: '{' ( options {greedy=false; } : . )* '}'
+			{
+			Match('{'); if (state.failed) return ;
+			// Grammars\\ActionTranslator.g3:703:8: ( options {greedy=false; } : . )*
+			for ( ; ; )
+			{
+				int alt20=2;
+				int LA20_0 = input.LA(1);
+
+				if ( (LA20_0=='}') )
+				{
+					alt20=2;
+				}
+				else if ( ((LA20_0>='\u0000' && LA20_0<='|')||(LA20_0>='~' && LA20_0<='\uFFFF')) )
+				{
+					alt20=1;
+				}
+
+
+				switch ( alt20 )
+				{
+				case 1:
+					// Grammars\\ActionTranslator.g3:703:33: .
+					{
+					MatchAny(); if (state.failed) return ;
+
+					}
+					break;
+
+				default:
+					goto loop20;
+				}
+			}
+
+			loop20:
+				;
+
+
+			Match('}'); if (state.failed) return ;
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ACTION"
+
+	// $ANTLR start "ESC"
+	private void mESC()
+	{
+		try
+		{
+			int _type = ESC;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ActionTranslator.g3:707:4: ( '\\\\' '$' | '\\\\' '%' | '\\\\' ~ ( '$' | '%' ) )
+			int alt21=3;
+			int LA21_0 = input.LA(1);
+
+			if ( (LA21_0=='\\') )
+			{
+				int LA21_1 = input.LA(2);
+
+				if ( (LA21_1=='$') )
+				{
+					alt21=1;
+				}
+				else if ( (LA21_1=='%') )
+				{
+					alt21=2;
+				}
+				else if ( ((LA21_1>='\u0000' && LA21_1<='#')||(LA21_1>='&' && LA21_1<='\uFFFF')) )
+				{
+					alt21=3;
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return ;}
+					NoViableAltException nvae = new NoViableAltException("", 21, 1, input);
+
+					throw nvae;
+				}
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				NoViableAltException nvae = new NoViableAltException("", 21, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt21 )
+			{
+			case 1:
+				// Grammars\\ActionTranslator.g3:707:4: '\\\\' '$'
+				{
+				Match('\\'); if (state.failed) return ;
+				Match('$'); if (state.failed) return ;
+				if ( state.backtracking==1 )
+				{
+					chunks.Add("$");
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\ActionTranslator.g3:708:4: '\\\\' '%'
+				{
+				Match('\\'); if (state.failed) return ;
+				Match('%'); if (state.failed) return ;
+				if ( state.backtracking==1 )
+				{
+					chunks.Add("%");
+				}
+
+				}
+				break;
+			case 3:
+				// Grammars\\ActionTranslator.g3:709:4: '\\\\' ~ ( '$' | '%' )
+				{
+				Match('\\'); if (state.failed) return ;
+				input.Consume();
+				state.failed=false;
+				if ( state.backtracking==1 )
+				{
+					chunks.Add(Text);
+				}
+
+				}
+				break;
+
+			}
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ESC"
+
+	// $ANTLR start "ERROR_XY"
+	private void mERROR_XY()
+	{
+		try
+		{
+			int _type = ERROR_XY;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken x=null;
+			IToken y=null;
+
+			// Grammars\\ActionTranslator.g3:713:4: ( '$' x= ID '.' y= ID )
+			// Grammars\\ActionTranslator.g3:713:4: '$' x= ID '.' y= ID
+			{
+			Match('$'); if (state.failed) return ;
+			int xStart1016 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			x = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, xStart1016, GetCharIndex()-1);
+			Match('.'); if (state.failed) return ;
+			int yStart1022 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			y = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, yStart1022, GetCharIndex()-1);
+			if ( state.backtracking==1 )
+			{
+
+							chunks.Add(Text);
+							generator.issueInvalidAttributeError((x!=null?x.Text:null),(y!=null?y.Text:null),
+																 enclosingRule,actionToken,
+																 outerAltNum);
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ERROR_XY"
+
+	// $ANTLR start "ERROR_X"
+	private void mERROR_X()
+	{
+		try
+		{
+			int _type = ERROR_X;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			IToken x=null;
+
+			// Grammars\\ActionTranslator.g3:723:4: ( '$' x= ID )
+			// Grammars\\ActionTranslator.g3:723:4: '$' x= ID
+			{
+			Match('$'); if (state.failed) return ;
+			int xStart1042 = GetCharIndex();
+			mID(); if (state.failed) return ;
+			x = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, xStart1042, GetCharIndex()-1);
+			if ( state.backtracking==1 )
+			{
+
+							chunks.Add(Text);
+							generator.issueInvalidAttributeError((x!=null?x.Text:null),
+																 enclosingRule,actionToken,
+																 outerAltNum);
+
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ERROR_X"
+
+	// $ANTLR start "UNKNOWN_SYNTAX"
+	private void mUNKNOWN_SYNTAX()
+	{
+		try
+		{
+			int _type = UNKNOWN_SYNTAX;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ActionTranslator.g3:733:4: ( '$' | '%' ( ID | '.' | '(' | ')' | ',' | '{' | '}' | '\"' )* )
+			int alt23=2;
+			int LA23_0 = input.LA(1);
+
+			if ( (LA23_0=='$') )
+			{
+				alt23=1;
+			}
+			else if ( (LA23_0=='%') )
+			{
+				alt23=2;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				NoViableAltException nvae = new NoViableAltException("", 23, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt23 )
+			{
+			case 1:
+				// Grammars\\ActionTranslator.g3:733:4: '$'
+				{
+				Match('$'); if (state.failed) return ;
+				if ( state.backtracking==1 )
+				{
+
+								chunks.Add(Text);
+								// shouldn't need an error here.  Just accept $ if it doesn't look like anything
+
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\ActionTranslator.g3:738:4: '%' ( ID | '.' | '(' | ')' | ',' | '{' | '}' | '\"' )*
+				{
+				Match('%'); if (state.failed) return ;
+				// Grammars\\ActionTranslator.g3:738:8: ( ID | '.' | '(' | ')' | ',' | '{' | '}' | '\"' )*
+				for ( ; ; )
+				{
+					int alt22=9;
+					alt22 = dfa22.Predict(input);
+					switch ( alt22 )
+					{
+					case 1:
+						// Grammars\\ActionTranslator.g3:738:9: ID
+						{
+						mID(); if (state.failed) return ;
+
+						}
+						break;
+					case 2:
+						// Grammars\\ActionTranslator.g3:738:12: '.'
+						{
+						Match('.'); if (state.failed) return ;
+
+						}
+						break;
+					case 3:
+						// Grammars\\ActionTranslator.g3:738:16: '('
+						{
+						Match('('); if (state.failed) return ;
+
+						}
+						break;
+					case 4:
+						// Grammars\\ActionTranslator.g3:738:20: ')'
+						{
+						Match(')'); if (state.failed) return ;
+
+						}
+						break;
+					case 5:
+						// Grammars\\ActionTranslator.g3:738:24: ','
+						{
+						Match(','); if (state.failed) return ;
+
+						}
+						break;
+					case 6:
+						// Grammars\\ActionTranslator.g3:738:28: '{'
+						{
+						Match('{'); if (state.failed) return ;
+
+						}
+						break;
+					case 7:
+						// Grammars\\ActionTranslator.g3:738:32: '}'
+						{
+						Match('}'); if (state.failed) return ;
+
+						}
+						break;
+					case 8:
+						// Grammars\\ActionTranslator.g3:738:36: '\"'
+						{
+						Match('\"'); if (state.failed) return ;
+
+						}
+						break;
+
+					default:
+						goto loop22;
+					}
+				}
+
+				loop22:
+					;
+
+
+				if ( state.backtracking==1 )
+				{
+
+								chunks.Add(Text);
+								ErrorManager.grammarError(ErrorManager.MSG_INVALID_TEMPLATE_ACTION,
+														  grammar,
+														  actionToken,
+														  Text);
+
+				}
+
+				}
+				break;
+
+			}
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "UNKNOWN_SYNTAX"
+
+	// $ANTLR start "TEXT"
+	private void mTEXT()
+	{
+		try
+		{
+			int _type = TEXT;
+			int _channel = DEFAULT_TOKEN_CHANNEL;
+			// Grammars\\ActionTranslator.g3:749:4: ( (~ ( '$' | '%' | '\\\\' ) )+ )
+			// Grammars\\ActionTranslator.g3:749:4: (~ ( '$' | '%' | '\\\\' ) )+
+			{
+			// Grammars\\ActionTranslator.g3:749:4: (~ ( '$' | '%' | '\\\\' ) )+
+			int cnt24=0;
+			for ( ; ; )
+			{
+				int alt24=2;
+				int LA24_0 = input.LA(1);
+
+				if ( ((LA24_0>='\u0000' && LA24_0<='#')||(LA24_0>='&' && LA24_0<='[')||(LA24_0>=']' && LA24_0<='\uFFFF')) )
+				{
+					alt24=1;
+				}
+
+
+				switch ( alt24 )
+				{
+				case 1:
+					// Grammars\\ActionTranslator.g3:
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+
+				default:
+					if ( cnt24 >= 1 )
+						goto loop24;
+
+					if (state.backtracking>0) {state.failed=true; return ;}
+					EarlyExitException eee24 = new EarlyExitException( 24, input );
+					throw eee24;
+				}
+				cnt24++;
+			}
+			loop24:
+				;
+
+
+			if ( state.backtracking==1 )
+			{
+				chunks.Add(Text);
+			}
+
+			}
+
+			state.type = _type;
+			state.channel = _channel;
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "TEXT"
+
+	// $ANTLR start "ID"
+	private void mID()
+	{
+		try
+		{
+			// Grammars\\ActionTranslator.g3:754:4: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
+			// Grammars\\ActionTranslator.g3:754:4: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
+			{
+			if ( (input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z') )
+			{
+				input.Consume();
+			state.failed=false;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				Recover(mse);
+				throw mse;}
+
+			// Grammars\\ActionTranslator.g3:754:28: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
+			for ( ; ; )
+			{
+				int alt25=2;
+				int LA25_0 = input.LA(1);
+
+				if ( ((LA25_0>='0' && LA25_0<='9')||(LA25_0>='A' && LA25_0<='Z')||LA25_0=='_'||(LA25_0>='a' && LA25_0<='z')) )
+				{
+					alt25=1;
+				}
+
+
+				switch ( alt25 )
+				{
+				case 1:
+					// Grammars\\ActionTranslator.g3:
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+
+				default:
+					goto loop25;
+				}
+			}
+
+			loop25:
+				;
+
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "ID"
+
+	// $ANTLR start "INT"
+	private void mINT()
+	{
+		try
+		{
+			// Grammars\\ActionTranslator.g3:759:4: ( ( '0' .. '9' )+ )
+			// Grammars\\ActionTranslator.g3:759:4: ( '0' .. '9' )+
+			{
+			// Grammars\\ActionTranslator.g3:759:4: ( '0' .. '9' )+
+			int cnt26=0;
+			for ( ; ; )
+			{
+				int alt26=2;
+				int LA26_0 = input.LA(1);
+
+				if ( ((LA26_0>='0' && LA26_0<='9')) )
+				{
+					alt26=1;
+				}
+
+
+				switch ( alt26 )
+				{
+				case 1:
+					// Grammars\\ActionTranslator.g3:
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+
+				default:
+					if ( cnt26 >= 1 )
+						goto loop26;
+
+					if (state.backtracking>0) {state.failed=true; return ;}
+					EarlyExitException eee26 = new EarlyExitException( 26, input );
+					throw eee26;
+				}
+				cnt26++;
+			}
+			loop26:
+				;
+
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "INT"
+
+	// $ANTLR start "WS"
+	private void mWS()
+	{
+		try
+		{
+			// Grammars\\ActionTranslator.g3:764:4: ( ( ' ' | '\\t' | '\\n' | '\\r' )+ )
+			// Grammars\\ActionTranslator.g3:764:4: ( ' ' | '\\t' | '\\n' | '\\r' )+
+			{
+			// Grammars\\ActionTranslator.g3:764:4: ( ' ' | '\\t' | '\\n' | '\\r' )+
+			int cnt27=0;
+			for ( ; ; )
+			{
+				int alt27=2;
+				int LA27_0 = input.LA(1);
+
+				if ( ((LA27_0>='\t' && LA27_0<='\n')||LA27_0=='\r'||LA27_0==' ') )
+				{
+					alt27=1;
+				}
+
+
+				switch ( alt27 )
+				{
+				case 1:
+					// Grammars\\ActionTranslator.g3:
+					{
+					input.Consume();
+					state.failed=false;
+
+					}
+					break;
+
+				default:
+					if ( cnt27 >= 1 )
+						goto loop27;
+
+					if (state.backtracking>0) {state.failed=true; return ;}
+					EarlyExitException eee27 = new EarlyExitException( 27, input );
+					throw eee27;
+				}
+				cnt27++;
+			}
+			loop27:
+				;
+
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "WS"
+
+	public override void mTokens()
+	{
+		// Grammars\\ActionTranslator.g3:1:41: ( SET_ENCLOSING_RULE_SCOPE_ATTR | ENCLOSING_RULE_SCOPE_ATTR | SET_TOKEN_SCOPE_ATTR | TOKEN_SCOPE_ATTR | SET_RULE_SCOPE_ATTR | RULE_SCOPE_ATTR | LABEL_REF | ISOLATED_TOKEN_REF | ISOLATED_LEXER_RULE_REF | SET_LOCAL_ATTR | LOCAL_ATTR | SET_DYNAMIC_SCOPE_ATTR | DYNAMIC_SCOPE_ATTR | ERROR_SCOPED_XY | DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR | DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR | ISOLATED_DYNAMIC_SCOPE | TEMPLATE_INSTANCE | INDIRECT_TEMPLATE_INSTANCE | SET_EXPR_ATTRIBUTE | SET_ATTRIBUTE | TEMPLATE_EXPR | ESC | ERROR_XY | ERROR_X | UNKNOWN_SYNTAX | TEXT )
+		int alt28=27;
+		alt28 = dfa28.Predict(input);
+		switch ( alt28 )
+		{
+		case 1:
+			// Grammars\\ActionTranslator.g3:1:41: SET_ENCLOSING_RULE_SCOPE_ATTR
+			{
+
+			mSET_ENCLOSING_RULE_SCOPE_ATTR(); if (state.failed) return ;
+
+			}
+			break;
+		case 2:
+			// Grammars\\ActionTranslator.g3:1:71: ENCLOSING_RULE_SCOPE_ATTR
+			{
+
+			mENCLOSING_RULE_SCOPE_ATTR(); if (state.failed) return ;
+
+			}
+			break;
+		case 3:
+			// Grammars\\ActionTranslator.g3:1:97: SET_TOKEN_SCOPE_ATTR
+			{
+
+			mSET_TOKEN_SCOPE_ATTR(); if (state.failed) return ;
+
+			}
+			break;
+		case 4:
+			// Grammars\\ActionTranslator.g3:1:118: TOKEN_SCOPE_ATTR
+			{
+
+			mTOKEN_SCOPE_ATTR(); if (state.failed) return ;
+
+			}
+			break;
+		case 5:
+			// Grammars\\ActionTranslator.g3:1:135: SET_RULE_SCOPE_ATTR
+			{
+
+			mSET_RULE_SCOPE_ATTR(); if (state.failed) return ;
+
+			}
+			break;
+		case 6:
+			// Grammars\\ActionTranslator.g3:1:155: RULE_SCOPE_ATTR
+			{
+
+			mRULE_SCOPE_ATTR(); if (state.failed) return ;
+
+			}
+			break;
+		case 7:
+			// Grammars\\ActionTranslator.g3:1:171: LABEL_REF
+			{
+
+			mLABEL_REF(); if (state.failed) return ;
+
+			}
+			break;
+		case 8:
+			// Grammars\\ActionTranslator.g3:1:181: ISOLATED_TOKEN_REF
+			{
+
+			mISOLATED_TOKEN_REF(); if (state.failed) return ;
+
+			}
+			break;
+		case 9:
+			// Grammars\\ActionTranslator.g3:1:200: ISOLATED_LEXER_RULE_REF
+			{
+
+			mISOLATED_LEXER_RULE_REF(); if (state.failed) return ;
+
+			}
+			break;
+		case 10:
+			// Grammars\\ActionTranslator.g3:1:224: SET_LOCAL_ATTR
+			{
+
+			mSET_LOCAL_ATTR(); if (state.failed) return ;
+
+			}
+			break;
+		case 11:
+			// Grammars\\ActionTranslator.g3:1:239: LOCAL_ATTR
+			{
+
+			mLOCAL_ATTR(); if (state.failed) return ;
+
+			}
+			break;
+		case 12:
+			// Grammars\\ActionTranslator.g3:1:250: SET_DYNAMIC_SCOPE_ATTR
+			{
+
+			mSET_DYNAMIC_SCOPE_ATTR(); if (state.failed) return ;
+
+			}
+			break;
+		case 13:
+			// Grammars\\ActionTranslator.g3:1:273: DYNAMIC_SCOPE_ATTR
+			{
+
+			mDYNAMIC_SCOPE_ATTR(); if (state.failed) return ;
+
+			}
+			break;
+		case 14:
+			// Grammars\\ActionTranslator.g3:1:292: ERROR_SCOPED_XY
+			{
+
+			mERROR_SCOPED_XY(); if (state.failed) return ;
+
+			}
+			break;
+		case 15:
+			// Grammars\\ActionTranslator.g3:1:308: DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR
+			{
+
+			mDYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR(); if (state.failed) return ;
+
+			}
+			break;
+		case 16:
+			// Grammars\\ActionTranslator.g3:1:344: DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR
+			{
+
+			mDYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR(); if (state.failed) return ;
+
+			}
+			break;
+		case 17:
+			// Grammars\\ActionTranslator.g3:1:380: ISOLATED_DYNAMIC_SCOPE
+			{
+
+			mISOLATED_DYNAMIC_SCOPE(); if (state.failed) return ;
+
+			}
+			break;
+		case 18:
+			// Grammars\\ActionTranslator.g3:1:403: TEMPLATE_INSTANCE
+			{
+
+			mTEMPLATE_INSTANCE(); if (state.failed) return ;
+
+			}
+			break;
+		case 19:
+			// Grammars\\ActionTranslator.g3:1:421: INDIRECT_TEMPLATE_INSTANCE
+			{
+
+			mINDIRECT_TEMPLATE_INSTANCE(); if (state.failed) return ;
+
+			}
+			break;
+		case 20:
+			// Grammars\\ActionTranslator.g3:1:448: SET_EXPR_ATTRIBUTE
+			{
+
+			mSET_EXPR_ATTRIBUTE(); if (state.failed) return ;
+
+			}
+			break;
+		case 21:
+			// Grammars\\ActionTranslator.g3:1:467: SET_ATTRIBUTE
+			{
+
+			mSET_ATTRIBUTE(); if (state.failed) return ;
+
+			}
+			break;
+		case 22:
+			// Grammars\\ActionTranslator.g3:1:481: TEMPLATE_EXPR
+			{
+
+			mTEMPLATE_EXPR(); if (state.failed) return ;
+
+			}
+			break;
+		case 23:
+			// Grammars\\ActionTranslator.g3:1:495: ESC
+			{
+
+			mESC(); if (state.failed) return ;
+
+			}
+			break;
+		case 24:
+			// Grammars\\ActionTranslator.g3:1:499: ERROR_XY
+			{
+
+			mERROR_XY(); if (state.failed) return ;
+
+			}
+			break;
+		case 25:
+			// Grammars\\ActionTranslator.g3:1:508: ERROR_X
+			{
+
+			mERROR_X(); if (state.failed) return ;
+
+			}
+			break;
+		case 26:
+			// Grammars\\ActionTranslator.g3:1:516: UNKNOWN_SYNTAX
+			{
+
+			mUNKNOWN_SYNTAX(); if (state.failed) return ;
+
+			}
+			break;
+		case 27:
+			// Grammars\\ActionTranslator.g3:1:531: TEXT
+			{
+			mTEXT(); if (state.failed) return ;
+
+			}
+			break;
+
+		}
+
+	}
+
+	// $ANTLR start synpred1_ActionTranslator
+	public void synpred1_ActionTranslator_fragment()
+	{
+		// Grammars\\ActionTranslator.g3:1:0: ( SET_ENCLOSING_RULE_SCOPE_ATTR )
+		// Grammars\\ActionTranslator.g3:1:41: SET_ENCLOSING_RULE_SCOPE_ATTR
+		{
+		mSET_ENCLOSING_RULE_SCOPE_ATTR(); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred1_ActionTranslator
+
+	// $ANTLR start synpred10_ActionTranslator
+	public void synpred10_ActionTranslator_fragment()
+	{
+		// Grammars\\ActionTranslator.g3:1:0: ( SET_LOCAL_ATTR )
+		// Grammars\\ActionTranslator.g3:1:224: SET_LOCAL_ATTR
+		{
+		mSET_LOCAL_ATTR(); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred10_ActionTranslator
+
+	// $ANTLR start synpred11_ActionTranslator
+	public void synpred11_ActionTranslator_fragment()
+	{
+		// Grammars\\ActionTranslator.g3:1:0: ( LOCAL_ATTR )
+		// Grammars\\ActionTranslator.g3:1:239: LOCAL_ATTR
+		{
+		mLOCAL_ATTR(); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred11_ActionTranslator
+
+	// $ANTLR start synpred12_ActionTranslator
+	public void synpred12_ActionTranslator_fragment()
+	{
+		// Grammars\\ActionTranslator.g3:1:0: ( SET_DYNAMIC_SCOPE_ATTR )
+		// Grammars\\ActionTranslator.g3:1:250: SET_DYNAMIC_SCOPE_ATTR
+		{
+		mSET_DYNAMIC_SCOPE_ATTR(); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred12_ActionTranslator
+
+	// $ANTLR start synpred13_ActionTranslator
+	public void synpred13_ActionTranslator_fragment()
+	{
+		// Grammars\\ActionTranslator.g3:1:0: ( DYNAMIC_SCOPE_ATTR )
+		// Grammars\\ActionTranslator.g3:1:273: DYNAMIC_SCOPE_ATTR
+		{
+		mDYNAMIC_SCOPE_ATTR(); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred13_ActionTranslator
+
+	// $ANTLR start synpred14_ActionTranslator
+	public void synpred14_ActionTranslator_fragment()
+	{
+		// Grammars\\ActionTranslator.g3:1:0: ( ERROR_SCOPED_XY )
+		// Grammars\\ActionTranslator.g3:1:292: ERROR_SCOPED_XY
+		{
+		mERROR_SCOPED_XY(); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred14_ActionTranslator
+
+	// $ANTLR start synpred15_ActionTranslator
+	public void synpred15_ActionTranslator_fragment()
+	{
+		// Grammars\\ActionTranslator.g3:1:0: ( DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR )
+		// Grammars\\ActionTranslator.g3:1:308: DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR
+		{
+		mDYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR(); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred15_ActionTranslator
+
+	// $ANTLR start synpred16_ActionTranslator
+	public void synpred16_ActionTranslator_fragment()
+	{
+		// Grammars\\ActionTranslator.g3:1:0: ( DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR )
+		// Grammars\\ActionTranslator.g3:1:344: DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR
+		{
+		mDYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR(); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred16_ActionTranslator
+
+	// $ANTLR start synpred17_ActionTranslator
+	public void synpred17_ActionTranslator_fragment()
+	{
+		// Grammars\\ActionTranslator.g3:1:0: ( ISOLATED_DYNAMIC_SCOPE )
+		// Grammars\\ActionTranslator.g3:1:380: ISOLATED_DYNAMIC_SCOPE
+		{
+		mISOLATED_DYNAMIC_SCOPE(); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred17_ActionTranslator
+
+	// $ANTLR start synpred18_ActionTranslator
+	public void synpred18_ActionTranslator_fragment()
+	{
+		// Grammars\\ActionTranslator.g3:1:0: ( TEMPLATE_INSTANCE )
+		// Grammars\\ActionTranslator.g3:1:403: TEMPLATE_INSTANCE
+		{
+		mTEMPLATE_INSTANCE(); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred18_ActionTranslator
+
+	// $ANTLR start synpred19_ActionTranslator
+	public void synpred19_ActionTranslator_fragment()
+	{
+		// Grammars\\ActionTranslator.g3:1:0: ( INDIRECT_TEMPLATE_INSTANCE )
+		// Grammars\\ActionTranslator.g3:1:421: INDIRECT_TEMPLATE_INSTANCE
+		{
+		mINDIRECT_TEMPLATE_INSTANCE(); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred19_ActionTranslator
+
+	// $ANTLR start synpred2_ActionTranslator
+	public void synpred2_ActionTranslator_fragment()
+	{
+		// Grammars\\ActionTranslator.g3:1:0: ( ENCLOSING_RULE_SCOPE_ATTR )
+		// Grammars\\ActionTranslator.g3:1:71: ENCLOSING_RULE_SCOPE_ATTR
+		{
+		mENCLOSING_RULE_SCOPE_ATTR(); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred2_ActionTranslator
+
+	// $ANTLR start synpred20_ActionTranslator
+	public void synpred20_ActionTranslator_fragment()
+	{
+		// Grammars\\ActionTranslator.g3:1:0: ( SET_EXPR_ATTRIBUTE )
+		// Grammars\\ActionTranslator.g3:1:448: SET_EXPR_ATTRIBUTE
+		{
+		mSET_EXPR_ATTRIBUTE(); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred20_ActionTranslator
+
+	// $ANTLR start synpred21_ActionTranslator
+	public void synpred21_ActionTranslator_fragment()
+	{
+		// Grammars\\ActionTranslator.g3:1:0: ( SET_ATTRIBUTE )
+		// Grammars\\ActionTranslator.g3:1:467: SET_ATTRIBUTE
+		{
+		mSET_ATTRIBUTE(); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred21_ActionTranslator
+
+	// $ANTLR start synpred22_ActionTranslator
+	public void synpred22_ActionTranslator_fragment()
+	{
+		// Grammars\\ActionTranslator.g3:1:0: ( TEMPLATE_EXPR )
+		// Grammars\\ActionTranslator.g3:1:481: TEMPLATE_EXPR
+		{
+		mTEMPLATE_EXPR(); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred22_ActionTranslator
+
+	// $ANTLR start synpred24_ActionTranslator
+	public void synpred24_ActionTranslator_fragment()
+	{
+		// Grammars\\ActionTranslator.g3:1:0: ( ERROR_XY )
+		// Grammars\\ActionTranslator.g3:1:499: ERROR_XY
+		{
+		mERROR_XY(); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred24_ActionTranslator
+
+	// $ANTLR start synpred25_ActionTranslator
+	public void synpred25_ActionTranslator_fragment()
+	{
+		// Grammars\\ActionTranslator.g3:1:0: ( ERROR_X )
+		// Grammars\\ActionTranslator.g3:1:508: ERROR_X
+		{
+		mERROR_X(); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred25_ActionTranslator
+
+	// $ANTLR start synpred26_ActionTranslator
+	public void synpred26_ActionTranslator_fragment()
+	{
+		// Grammars\\ActionTranslator.g3:1:0: ( UNKNOWN_SYNTAX )
+		// Grammars\\ActionTranslator.g3:1:516: UNKNOWN_SYNTAX
+		{
+		mUNKNOWN_SYNTAX(); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred26_ActionTranslator
+
+	// $ANTLR start synpred3_ActionTranslator
+	public void synpred3_ActionTranslator_fragment()
+	{
+		// Grammars\\ActionTranslator.g3:1:0: ( SET_TOKEN_SCOPE_ATTR )
+		// Grammars\\ActionTranslator.g3:1:97: SET_TOKEN_SCOPE_ATTR
+		{
+		mSET_TOKEN_SCOPE_ATTR(); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred3_ActionTranslator
+
+	// $ANTLR start synpred4_ActionTranslator
+	public void synpred4_ActionTranslator_fragment()
+	{
+		// Grammars\\ActionTranslator.g3:1:0: ( TOKEN_SCOPE_ATTR )
+		// Grammars\\ActionTranslator.g3:1:118: TOKEN_SCOPE_ATTR
+		{
+		mTOKEN_SCOPE_ATTR(); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred4_ActionTranslator
+
+	// $ANTLR start synpred5_ActionTranslator
+	public void synpred5_ActionTranslator_fragment()
+	{
+		// Grammars\\ActionTranslator.g3:1:0: ( SET_RULE_SCOPE_ATTR )
+		// Grammars\\ActionTranslator.g3:1:135: SET_RULE_SCOPE_ATTR
+		{
+		mSET_RULE_SCOPE_ATTR(); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred5_ActionTranslator
+
+	// $ANTLR start synpred6_ActionTranslator
+	public void synpred6_ActionTranslator_fragment()
+	{
+		// Grammars\\ActionTranslator.g3:1:0: ( RULE_SCOPE_ATTR )
+		// Grammars\\ActionTranslator.g3:1:155: RULE_SCOPE_ATTR
+		{
+		mRULE_SCOPE_ATTR(); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred6_ActionTranslator
+
+	// $ANTLR start synpred7_ActionTranslator
+	public void synpred7_ActionTranslator_fragment()
+	{
+		// Grammars\\ActionTranslator.g3:1:0: ( LABEL_REF )
+		// Grammars\\ActionTranslator.g3:1:171: LABEL_REF
+		{
+		mLABEL_REF(); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred7_ActionTranslator
+
+	// $ANTLR start synpred8_ActionTranslator
+	public void synpred8_ActionTranslator_fragment()
+	{
+		// Grammars\\ActionTranslator.g3:1:0: ( ISOLATED_TOKEN_REF )
+		// Grammars\\ActionTranslator.g3:1:181: ISOLATED_TOKEN_REF
+		{
+		mISOLATED_TOKEN_REF(); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred8_ActionTranslator
+
+	// $ANTLR start synpred9_ActionTranslator
+	public void synpred9_ActionTranslator_fragment()
+	{
+		// Grammars\\ActionTranslator.g3:1:0: ( ISOLATED_LEXER_RULE_REF )
+		// Grammars\\ActionTranslator.g3:1:200: ISOLATED_LEXER_RULE_REF
+		{
+		mISOLATED_LEXER_RULE_REF(); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred9_ActionTranslator
+
+	public bool synpred1_ActionTranslator()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred1_ActionTranslator_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred2_ActionTranslator()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred2_ActionTranslator_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred3_ActionTranslator()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred3_ActionTranslator_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred4_ActionTranslator()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred4_ActionTranslator_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred5_ActionTranslator()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred5_ActionTranslator_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred6_ActionTranslator()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred6_ActionTranslator_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred7_ActionTranslator()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred7_ActionTranslator_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred8_ActionTranslator()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred8_ActionTranslator_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred9_ActionTranslator()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred9_ActionTranslator_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred10_ActionTranslator()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred10_ActionTranslator_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred11_ActionTranslator()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred11_ActionTranslator_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred12_ActionTranslator()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred12_ActionTranslator_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred13_ActionTranslator()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred13_ActionTranslator_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred14_ActionTranslator()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred14_ActionTranslator_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred15_ActionTranslator()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred15_ActionTranslator_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred16_ActionTranslator()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred16_ActionTranslator_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred17_ActionTranslator()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred17_ActionTranslator_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred24_ActionTranslator()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred24_ActionTranslator_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred25_ActionTranslator()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred25_ActionTranslator_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred26_ActionTranslator()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred26_ActionTranslator_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred18_ActionTranslator()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred18_ActionTranslator_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred19_ActionTranslator()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred19_ActionTranslator_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred20_ActionTranslator()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred20_ActionTranslator_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred21_ActionTranslator()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred21_ActionTranslator_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred22_ActionTranslator()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred22_ActionTranslator_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+
+
+	#region DFA
+	DFA22 dfa22;
+	DFA28 dfa28;
+
+	protected override void InitDFAs()
+	{
+		base.InitDFAs();
+		dfa22 = new DFA22( this );
+		dfa28 = new DFA28( this, new SpecialStateTransitionHandler( specialStateTransition28 ) );
+	}
+
+	class DFA22 : DFA
+	{
+
+		const string DFA22_eotS =
+			"\x1\x1\x9\xFFFF";
+		const string DFA22_eofS =
+			"\xA\xFFFF";
+		const string DFA22_minS =
+			"\x1\x22\x9\xFFFF";
+		const string DFA22_maxS =
+			"\x1\x7D\x9\xFFFF";
+		const string DFA22_acceptS =
+			"\x1\xFFFF\x1\x9\x1\x1\x1\x2\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8";
+		const string DFA22_specialS =
+			"\xA\xFFFF}>";
+		static readonly string[] DFA22_transitionS =
+			{
+				"\x1\x9\x5\xFFFF\x1\x4\x1\x5\x2\xFFFF\x1\x6\x1\xFFFF\x1\x3\x12\xFFFF"+
+				"\x1A\x2\x4\xFFFF\x1\x2\x1\xFFFF\x1A\x2\x1\x7\x1\xFFFF\x1\x8",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				""
+			};
+
+		static readonly short[] DFA22_eot = DFA.UnpackEncodedString(DFA22_eotS);
+		static readonly short[] DFA22_eof = DFA.UnpackEncodedString(DFA22_eofS);
+		static readonly char[] DFA22_min = DFA.UnpackEncodedStringToUnsignedChars(DFA22_minS);
+		static readonly char[] DFA22_max = DFA.UnpackEncodedStringToUnsignedChars(DFA22_maxS);
+		static readonly short[] DFA22_accept = DFA.UnpackEncodedString(DFA22_acceptS);
+		static readonly short[] DFA22_special = DFA.UnpackEncodedString(DFA22_specialS);
+		static readonly short[][] DFA22_transition;
+
+		static DFA22()
+		{
+			int numStates = DFA22_transitionS.Length;
+			DFA22_transition = new short[numStates][];
+			for ( int i=0; i < numStates; i++ )
+			{
+				DFA22_transition[i] = DFA.UnpackEncodedString(DFA22_transitionS[i]);
+			}
+		}
+
+		public DFA22( BaseRecognizer recognizer )
+		{
+			this.recognizer = recognizer;
+			this.decisionNumber = 22;
+			this.eot = DFA22_eot;
+			this.eof = DFA22_eof;
+			this.min = DFA22_min;
+			this.max = DFA22_max;
+			this.accept = DFA22_accept;
+			this.special = DFA22_special;
+			this.transition = DFA22_transition;
+		}
+		public override string GetDescription()
+		{
+			return "()* loopback of 738:8: ( ID | '.' | '(' | ')' | ',' | '{' | '}' | '\"' )*";
+		}
+	}
+
+	class DFA28 : DFA
+	{
+
+		const string DFA28_eotS =
+			"\x1E\xFFFF";
+		const string DFA28_eofS =
+			"\x1E\xFFFF";
+		const string DFA28_minS =
+			"\x2\x0\x14\xFFFF\x1\x0\x7\xFFFF";
+		const string DFA28_maxS =
+			"\x1\xFFFF\x1\x0\x14\xFFFF\x1\x0\x7\xFFFF";
+		const string DFA28_acceptS =
+			"\x2\xFFFF\x1\x1\x1\x2\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9\x1\xA"+
+			"\x1\xB\x1\xC\x1\xD\x1\xE\x1\xF\x1\x10\x1\x11\x1\x18\x1\x19\x1\x1A\x1"+
+			"\xFFFF\x1\x12\x1\x13\x1\x14\x1\x15\x1\x16\x1\x17\x1\x1B";
+		const string DFA28_specialS =
+			"\x1\x0\x1\x1\x14\xFFFF\x1\x2\x7\xFFFF}>";
+		static readonly string[] DFA28_transitionS =
+			{
+				"\x24\x1D\x1\x1\x1\x16\x36\x1D\x1\x1C\xFFA3\x1D",
+				"\x1\xFFFF",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"\x1\xFFFF",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				""
+			};
+
+		static readonly short[] DFA28_eot = DFA.UnpackEncodedString(DFA28_eotS);
+		static readonly short[] DFA28_eof = DFA.UnpackEncodedString(DFA28_eofS);
+		static readonly char[] DFA28_min = DFA.UnpackEncodedStringToUnsignedChars(DFA28_minS);
+		static readonly char[] DFA28_max = DFA.UnpackEncodedStringToUnsignedChars(DFA28_maxS);
+		static readonly short[] DFA28_accept = DFA.UnpackEncodedString(DFA28_acceptS);
+		static readonly short[] DFA28_special = DFA.UnpackEncodedString(DFA28_specialS);
+		static readonly short[][] DFA28_transition;
+
+		static DFA28()
+		{
+			int numStates = DFA28_transitionS.Length;
+			DFA28_transition = new short[numStates][];
+			for ( int i=0; i < numStates; i++ )
+			{
+				DFA28_transition[i] = DFA.UnpackEncodedString(DFA28_transitionS[i]);
+			}
+		}
+
+		public DFA28( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
+			: base( specialStateTransition )	{
+			this.recognizer = recognizer;
+			this.decisionNumber = 28;
+			this.eot = DFA28_eot;
+			this.eof = DFA28_eof;
+			this.min = DFA28_min;
+			this.max = DFA28_max;
+			this.accept = DFA28_accept;
+			this.special = DFA28_special;
+			this.transition = DFA28_transition;
+		}
+		public override string GetDescription()
+		{
+			return "1:0: Tokens options {k=1; backtrack=true; } : ( SET_ENCLOSING_RULE_SCOPE_ATTR | ENCLOSING_RULE_SCOPE_ATTR | SET_TOKEN_SCOPE_ATTR | TOKEN_SCOPE_ATTR | SET_RULE_SCOPE_ATTR | RULE_SCOPE_ATTR | LABEL_REF | ISOLATED_TOKEN_REF | ISOLATED_LEXER_RULE_REF | SET_LOCAL_ATTR | LOCAL_ATTR | SET_DYNAMIC_SCOPE_ATTR | DYNAMIC_SCOPE_ATTR | ERROR_SCOPED_XY | DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR | DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR | ISOLATED_DYNAMIC_SCOPE | TEMPLATE_INSTANCE | INDIRECT_TEMPLATE_INSTANCE | SET_EXPR_ATTRIBUTE | SET_ATTRIBUTE | TEMPLATE_EXPR | ESC | ERROR_XY | ERROR_X | UNKNOWN_SYNTAX | TEXT );";
+		}
+	}
+
+	int specialStateTransition28( DFA dfa, int s, IIntStream _input )
+	{
+		IIntStream input = _input;
+		int _s = s;
+		switch ( s )
+		{
+
+			case 0:
+				int LA28_0 = input.LA(1);
+
+				s = -1;
+				if ( (LA28_0=='$') ) {s = 1;}
+
+				else if ( (LA28_0=='%') ) {s = 22;}
+
+				else if ( (LA28_0=='\\') ) {s = 28;}
+
+				else if ( ((LA28_0>='\u0000' && LA28_0<='#')||(LA28_0>='&' && LA28_0<='[')||(LA28_0>=']' && LA28_0<='\uFFFF')) ) {s = 29;}
+
+				if ( s>=0 ) return s;
+				break;
+
+			case 1:
+				int LA28_1 = input.LA(1);
+
+
+				int index28_1 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred1_ActionTranslator()) ) {s = 2;}
+
+				else if ( (synpred2_ActionTranslator()) ) {s = 3;}
+
+				else if ( (synpred3_ActionTranslator()) ) {s = 4;}
+
+				else if ( (synpred4_ActionTranslator()) ) {s = 5;}
+
+				else if ( (synpred5_ActionTranslator()) ) {s = 6;}
+
+				else if ( (synpred6_ActionTranslator()) ) {s = 7;}
+
+				else if ( (synpred7_ActionTranslator()) ) {s = 8;}
+
+				else if ( (synpred8_ActionTranslator()) ) {s = 9;}
+
+				else if ( (synpred9_ActionTranslator()) ) {s = 10;}
+
+				else if ( (synpred10_ActionTranslator()) ) {s = 11;}
+
+				else if ( (synpred11_ActionTranslator()) ) {s = 12;}
+
+				else if ( (synpred12_ActionTranslator()) ) {s = 13;}
+
+				else if ( (synpred13_ActionTranslator()) ) {s = 14;}
+
+				else if ( (synpred14_ActionTranslator()) ) {s = 15;}
+
+				else if ( (synpred15_ActionTranslator()) ) {s = 16;}
+
+				else if ( (synpred16_ActionTranslator()) ) {s = 17;}
+
+				else if ( (synpred17_ActionTranslator()) ) {s = 18;}
+
+				else if ( (synpred24_ActionTranslator()) ) {s = 19;}
+
+				else if ( (synpred25_ActionTranslator()) ) {s = 20;}
+
+				else if ( (synpred26_ActionTranslator()) ) {s = 21;}
+
+
+				input.Seek(index28_1);
+				if ( s>=0 ) return s;
+				break;
+
+			case 2:
+				int LA28_22 = input.LA(1);
+
+
+				int index28_22 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred18_ActionTranslator()) ) {s = 23;}
+
+				else if ( (synpred19_ActionTranslator()) ) {s = 24;}
+
+				else if ( (synpred20_ActionTranslator()) ) {s = 25;}
+
+				else if ( (synpred21_ActionTranslator()) ) {s = 26;}
+
+				else if ( (synpred22_ActionTranslator()) ) {s = 27;}
+
+				else if ( (synpred26_ActionTranslator()) ) {s = 21;}
+
+
+				input.Seek(index28_22);
+				if ( s>=0 ) return s;
+				break;
+		}
+		if (state.backtracking>0) {state.failed=true; return -1;}
+		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 28, _s, input);
+		dfa.Error(nvae);
+		throw nvae;
+	}
+
+	#endregion
+
+}
+
+} // namespace Antlr3.Grammars
diff --git a/Antlr3/Grammars/ActionTranslator.g3 b/Antlr3/Grammars/ActionTranslator.g3
new file mode 100644
index 0000000..41c32e2
--- /dev/null
+++ b/Antlr3/Grammars/ActionTranslator.g3
@@ -0,0 +1,765 @@
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+    notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+    derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+lexer grammar ActionTranslator;
+
+options
+{
+	language=CSharp3;
+	// try all non-fragment rules in order specified
+	filter=true;
+	// output=template;  TODO: can we make tokens return templates somehow?
+}
+
+@lexer::header
+{
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+using Antlr3.Tool;
+using StringTemplate = Antlr3.ST.StringTemplate;
+}
+
+@lexer::namespace{Antlr3.Grammars}
+
+/**	$x.y	x is enclosing rule, y is a return value, parameter, or
+ * 			predefined property.
+ *
+ * 			r[int i] returns [int j]
+ * 				:	{$r.i, $r.j, $r.start, $r.stop, $r.st, $r.tree}
+ * 				;
+ */
+SET_ENCLOSING_RULE_SCOPE_ATTR
+	:	'$' x=ID '.' y=ID WS? '=' expr=ATTR_VALUE_EXPR ';'
+							{enclosingRule!=null &&
+	                         $x.text.Equals(enclosingRule.name) &&
+	                         enclosingRule.getLocalAttributeScope($y.text)!=null}?
+		//{JSystem.@out.println("found \$rule.attr");}
+		{
+			StringTemplate st = null;
+			AttributeScope scope = enclosingRule.getLocalAttributeScope($y.text);
+			if ( scope.isPredefinedRuleScope )
+			{
+				if ( $y.text.Equals("st") || $y.text.Equals("tree") )
+				{
+					st = template("ruleSetPropertyRef_"+$y.text);
+					grammar.referenceRuleLabelPredefinedAttribute($x.text);
+					st.setAttribute("scope", $x.text);
+					st.setAttribute("attr", $y.text);
+					st.setAttribute("expr", translateAction($expr.text));
+				}
+				else
+				{
+					ErrorManager.grammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
+											  grammar,
+											  actionToken,
+											  $x.text,
+											  $y.text);
+				}
+			}
+			else if ( scope.isPredefinedLexerRuleScope )
+			{
+	    		// this is a better message to emit than the previous one...
+				ErrorManager.grammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
+										  grammar,
+										  actionToken,
+										  $x.text,
+										  $y.text);
+			}
+			else if ( scope.isParameterScope )
+			{
+				st = template("parameterSetAttributeRef");
+				st.setAttribute("attr", scope.getAttribute($y.text));
+				st.setAttribute("expr", translateAction($expr.text));
+			}
+			else
+			{ // must be return value
+				st = template("returnSetAttributeRef");
+				st.setAttribute("ruleDescriptor", enclosingRule);
+				st.setAttribute("attr", scope.getAttribute($y.text));
+				st.setAttribute("expr", translateAction($expr.text));
+			}
+		}
+	;
+ENCLOSING_RULE_SCOPE_ATTR
+	:	'$' x=ID '.' y=ID	{enclosingRule!=null &&
+	                         $x.text.Equals(enclosingRule.name) &&
+	                         enclosingRule.getLocalAttributeScope($y.text)!=null}?
+		//{JSystem.@out.println("found \$rule.attr");}
+		{
+			if ( isRuleRefInAlt($x.text) )
+			{
+				ErrorManager.grammarError(ErrorManager.MSG_RULE_REF_AMBIG_WITH_RULE_IN_ALT,
+										  grammar,
+										  actionToken,
+										  $x.text);
+			}
+			StringTemplate st = null;
+			AttributeScope scope = enclosingRule.getLocalAttributeScope($y.text);
+			if ( scope.isPredefinedRuleScope )
+			{
+				st = template("rulePropertyRef_"+$y.text);
+				grammar.referenceRuleLabelPredefinedAttribute($x.text);
+				st.setAttribute("scope", $x.text);
+				st.setAttribute("attr", $y.text);
+			}
+			else if ( scope.isPredefinedLexerRuleScope )
+			{
+				// perhaps not the most precise error message to use, but...
+				ErrorManager.grammarError(ErrorManager.MSG_RULE_HAS_NO_ARGS,
+										  grammar,
+										  actionToken,
+										  $x.text);
+			}
+			else if ( scope.isParameterScope )
+			{
+				st = template("parameterAttributeRef");
+				st.setAttribute("attr", scope.getAttribute($y.text));
+			}
+			else
+			{ // must be return value
+				st = template("returnAttributeRef");
+				st.setAttribute("ruleDescriptor", enclosingRule);
+				st.setAttribute("attr", scope.getAttribute($y.text));
+			}
+		}
+	;
+
+/** Setting $tokenlabel.attr or $tokenref.attr where attr is predefined property of a token is an error. */
+SET_TOKEN_SCOPE_ATTR
+	:	'$' x=ID '.' y=ID WS? '='
+							 {enclosingRule!=null && input.LA(1)!='=' &&
+	                         (enclosingRule.getTokenLabel($x.text)!=null||
+	                          isTokenRefInAlt($x.text)) &&
+	                         AttributeScope.tokenScope.getAttribute($y.text)!=null}?
+		//{JSystem.@out.println("found \$tokenlabel.attr or \$tokenref.attr");}
+		{
+			ErrorManager.grammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
+									  grammar,
+									  actionToken,
+									  $x.text,
+									  $y.text);
+		}
+	;
+
+/** $tokenlabel.attr or $tokenref.attr where attr is predefined property of a token.
+ *  If in lexer grammar, only translate for strings and tokens (rule refs)
+ */
+TOKEN_SCOPE_ATTR
+	:	'$' x=ID '.' y=ID	{enclosingRule!=null &&
+	                         (enclosingRule.getTokenLabel($x.text)!=null||
+	                          isTokenRefInAlt($x.text)) &&
+	                         AttributeScope.tokenScope.getAttribute($y.text)!=null &&
+	                         (grammar.type!=Grammar.LEXER ||
+	                         getElementLabel($x.text).elementRef.token.Type==ANTLRParser.TOKEN_REF ||
+	                         getElementLabel($x.text).elementRef.token.Type==ANTLRParser.STRING_LITERAL)}?
+		// {JSystem.@out.println("found \$tokenlabel.attr or \$tokenref.attr");}
+		{
+			string label = $x.text;
+			if ( enclosingRule.getTokenLabel($x.text)==null )
+			{
+				// \$tokenref.attr  gotta get old label or compute new one
+				checkElementRefUniqueness($x.text, true);
+				label = enclosingRule.getElementLabel($x.text, outerAltNum, generator);
+				if ( label==null )
+				{
+					ErrorManager.grammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
+											  grammar,
+											  actionToken,
+											  "\$"+$x.text+"."+$y.text);
+					label = $x.text;
+				}
+			}
+			StringTemplate st = template("tokenLabelPropertyRef_"+$y.text);
+			st.setAttribute("scope", label);
+			st.setAttribute("attr", AttributeScope.tokenScope.getAttribute($y.text));
+		}
+	;
+
+/** Setting $rulelabel.attr or $ruleref.attr where attr is a predefined property is an error
+ *  This must also fail, if we try to access a local attribute's field, like $tree.scope = localObject
+ *  That must be handled by LOCAL_ATTR below. ANTLR only concerns itself with the top-level scope
+ *  attributes declared in scope {} or parameters, return values and the like.
+ */
+SET_RULE_SCOPE_ATTR
+@init
+{
+Grammar.LabelElementPair pair=null;
+string refdRuleName=null;
+}
+	:	'$' x=ID '.' y=ID WS? '=' {enclosingRule!=null && input.LA(1)!='='}?
+		{
+			pair = enclosingRule.getRuleLabel($x.text);
+			refdRuleName = $x.text;
+			if ( pair!=null )
+			{
+				refdRuleName = pair.referencedRuleName;
+			}
+		}
+		// supercomplicated because I can't exec the above action.
+		// This asserts that if it's a label or a ref to a rule proceed but only if the attribute
+		// is valid for that rule's scope
+		{(enclosingRule.getRuleLabel($x.text)!=null || isRuleRefInAlt($x.text)) &&
+	      getRuleLabelAttribute(enclosingRule.getRuleLabel($x.text)!=null?enclosingRule.getRuleLabel($x.text).referencedRuleName:$x.text,$y.text)!=null}?
+		//{JSystem.@out.println("found set \$rulelabel.attr or \$ruleref.attr: "+$x.text+"."+$y.text);}
+		{
+			ErrorManager.grammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
+									  grammar,
+									  actionToken,
+									  $x.text,
+									  $y.text);
+		}
+	;
+
+/** $rulelabel.attr or $ruleref.attr where attr is a predefined property*/
+RULE_SCOPE_ATTR
+@init
+{
+	Grammar.LabelElementPair pair=null;
+	string refdRuleName=null;
+}
+	:	'$' x=ID '.' y=ID {enclosingRule!=null}?
+		{
+		pair = enclosingRule.getRuleLabel($x.text);
+		refdRuleName = $x.text;
+		if ( pair!=null ) {
+			refdRuleName = pair.referencedRuleName;
+		}
+		}
+		// supercomplicated because I can't exec the above action.
+		// This asserts that if it's a label or a ref to a rule proceed but only if the attribute
+		// is valid for that rule's scope
+		{(enclosingRule.getRuleLabel($x.text)!=null || isRuleRefInAlt($x.text)) &&
+	      getRuleLabelAttribute(enclosingRule.getRuleLabel($x.text)!=null?enclosingRule.getRuleLabel($x.text).referencedRuleName:$x.text,$y.text)!=null}?
+		//{JSystem.@out.println("found \$rulelabel.attr or \$ruleref.attr: "+$x.text+"."+$y.text);}
+		{
+			string label = $x.text;
+			if ( pair==null )
+			{
+				// \$ruleref.attr  gotta get old label or compute new one
+				checkElementRefUniqueness($x.text, false);
+				label = enclosingRule.getElementLabel($x.text, outerAltNum, generator);
+				if ( label==null )
+				{
+					ErrorManager.grammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
+											  grammar,
+											  actionToken,
+											  "\$"+$x.text+"."+$y.text);
+					label = $x.text;
+				}
+			}
+			StringTemplate st;
+			Rule refdRule = grammar.getRule(refdRuleName);
+			AttributeScope scope = refdRule.getLocalAttributeScope($y.text);
+			if ( scope.isPredefinedRuleScope )
+			{
+				st = template("ruleLabelPropertyRef_"+$y.text);
+				grammar.referenceRuleLabelPredefinedAttribute(refdRuleName);
+				st.setAttribute("scope", label);
+				st.setAttribute("attr", $y.text);
+			}
+			else if ( scope.isPredefinedLexerRuleScope )
+			{
+				st = template("lexerRuleLabelPropertyRef_"+$y.text);
+				grammar.referenceRuleLabelPredefinedAttribute(refdRuleName);
+				st.setAttribute("scope", label);
+				st.setAttribute("attr", $y.text);
+			}
+			else if ( scope.isParameterScope )
+			{
+				// TODO: error!
+			}
+			else
+			{
+				st = template("ruleLabelRef");
+				st.setAttribute("referencedRule", refdRule);
+				st.setAttribute("scope", label);
+				st.setAttribute("attr", scope.getAttribute($y.text));
+			}
+		}
+	;
+
+
+/** $label	either a token label or token/rule list label like label+=expr */
+LABEL_REF
+	:	'$' ID {enclosingRule!=null &&
+	            getElementLabel($ID.text)!=null &&
+		        enclosingRule.getRuleLabel($ID.text)==null}?
+		// {JSystem.@out.println("found \$label");}
+		{
+			StringTemplate st;
+			Grammar.LabelElementPair pair = getElementLabel($ID.text);
+			if ( pair.type==Grammar.RULE_LIST_LABEL ||
+				  pair.type==Grammar.TOKEN_LIST_LABEL ||
+				  pair.type == Grammar.WILDCARD_TREE_LIST_LABEL )
+			{
+				st = template("listLabelRef");
+			}
+			else
+			{
+				st = template("tokenLabelRef");
+			}
+			st.setAttribute("label", $ID.text);
+		}
+	;
+
+/** $tokenref in a non-lexer grammar */
+ISOLATED_TOKEN_REF
+	:	'$' ID	{grammar.type!=Grammar.LEXER && enclosingRule!=null && isTokenRefInAlt($ID.text)}?
+		//{JSystem.@out.println("found \$tokenref");}
+		{
+			string label = enclosingRule.getElementLabel($ID.text, outerAltNum, generator);
+			checkElementRefUniqueness($ID.text, true);
+			if ( label==null )
+			{
+				ErrorManager.grammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
+										  grammar,
+										  actionToken,
+										  $ID.text);
+			}
+			else
+			{
+				StringTemplate st = template("tokenLabelRef");
+				st.setAttribute("label", label);
+			}
+		}
+	;
+
+/** $lexerruleref from within the lexer */
+ISOLATED_LEXER_RULE_REF
+	:	'$' ID	{grammar.type==Grammar.LEXER &&
+	             enclosingRule!=null &&
+	             isRuleRefInAlt($ID.text)}?
+		//{JSystem.@out.println("found \$lexerruleref");}
+		{
+			string label = enclosingRule.getElementLabel($ID.text, outerAltNum, generator);
+			checkElementRefUniqueness($ID.text, false);
+			if ( label==null )
+			{
+				ErrorManager.grammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
+										  grammar,
+										  actionToken,
+										  $ID.text);
+			}
+			else
+			{
+				StringTemplate st = template("lexerRuleLabel");
+				st.setAttribute("label", label);
+			}
+		}
+	;
+
+/**  $y 	return value, parameter, predefined rule property, or token/rule
+ *          reference within enclosing rule's outermost alt.
+ *          y must be a "local" reference; i.e., it must be referring to
+ *          something defined within the enclosing rule.
+ *
+ * 			r[int i] returns [int j]
+ * 				:	{$i, $j, $start, $stop, $st, $tree}
+ *              ;
+ *
+ *	TODO: this might get the dynamic scope's elements too.!!!!!!!!!
+ */
+SET_LOCAL_ATTR
+	:	'$' ID WS? '=' expr=ATTR_VALUE_EXPR ';' {enclosingRule!=null
+													&& enclosingRule.getLocalAttributeScope($ID.text)!=null
+													&& !enclosingRule.getLocalAttributeScope($ID.text).isPredefinedLexerRuleScope}?
+		//{JSystem.@out.println("found set \$localattr");}
+		{
+			StringTemplate st;
+			AttributeScope scope = enclosingRule.getLocalAttributeScope($ID.text);
+			if ( scope.isPredefinedRuleScope )
+			{
+				if ($ID.text.Equals("tree") || $ID.text.Equals("st"))
+				{
+					st = template("ruleSetPropertyRef_"+$ID.text);
+					grammar.referenceRuleLabelPredefinedAttribute(enclosingRule.name);
+					st.setAttribute("scope", enclosingRule.name);
+					st.setAttribute("attr", $ID.text);
+					st.setAttribute("expr", translateAction($expr.text));
+				}
+				else
+				{
+					ErrorManager.grammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
+											 grammar,
+											 actionToken,
+											 $ID.text,
+											 "");
+				}
+			}
+			else if ( scope.isParameterScope )
+			{
+				st = template("parameterSetAttributeRef");
+				st.setAttribute("attr", scope.getAttribute($ID.text));
+				st.setAttribute("expr", translateAction($expr.text));
+			}
+			else
+			{
+				st = template("returnSetAttributeRef");
+				st.setAttribute("ruleDescriptor", enclosingRule);
+				st.setAttribute("attr", scope.getAttribute($ID.text));
+				st.setAttribute("expr", translateAction($expr.text));
+			}
+		}
+	;
+LOCAL_ATTR
+	:	'$' ID {enclosingRule!=null && enclosingRule.getLocalAttributeScope($ID.text)!=null}?
+		//{JSystem.@out.println("found \$localattr");}
+		{
+			StringTemplate st;
+			AttributeScope scope = enclosingRule.getLocalAttributeScope($ID.text);
+			if ( scope.isPredefinedRuleScope )
+			{
+				st = template("rulePropertyRef_"+$ID.text);
+				grammar.referenceRuleLabelPredefinedAttribute(enclosingRule.name);
+				st.setAttribute("scope", enclosingRule.name);
+				st.setAttribute("attr", $ID.text);
+			}
+			else if ( scope.isPredefinedLexerRuleScope )
+			{
+				st = template("lexerRulePropertyRef_"+$ID.text);
+				st.setAttribute("scope", enclosingRule.name);
+				st.setAttribute("attr", $ID.text);
+			}
+			else if ( scope.isParameterScope )
+			{
+				st = template("parameterAttributeRef");
+				st.setAttribute("attr", scope.getAttribute($ID.text));
+			}
+			else
+			{
+				st = template("returnAttributeRef");
+				st.setAttribute("ruleDescriptor", enclosingRule);
+				st.setAttribute("attr", scope.getAttribute($ID.text));
+			}
+		}
+	;
+
+/**	$x::y	the only way to access the attributes within a dynamic scope
+ * 			regardless of whether or not you are in the defining rule.
+ *
+ * 			scope Symbols { List names; }
+ * 			r
+ * 			scope {int i;}
+ * 			scope Symbols;
+ * 				:	{$r::i=3;} s {$Symbols::names;}
+ * 				;
+ * 			s	:	{$r::i; $Symbols::names;}
+ * 				;
+ */
+SET_DYNAMIC_SCOPE_ATTR
+	:	'$' x=ID '::' y=ID WS? '=' expr=ATTR_VALUE_EXPR ';'
+						   {resolveDynamicScope($x.text)!=null &&
+						     resolveDynamicScope($x.text).getAttribute($y.text)!=null}?
+		//{JSystem.@out.println("found set \$scope::attr "+ $x.text + "::" + $y.text + " to " + $expr.text);}
+		{
+			AttributeScope scope = resolveDynamicScope($x.text);
+			if ( scope!=null )
+			{
+				StringTemplate st = template("scopeSetAttributeRef");
+				st.setAttribute("scope", $x.text);
+				st.setAttribute("attr",  scope.getAttribute($y.text));
+				st.setAttribute("expr",  translateAction($expr.text));
+			}
+			else
+			{
+				// error: invalid dynamic attribute
+			}
+		}
+	;
+
+DYNAMIC_SCOPE_ATTR
+	:	'$' x=ID '::' y=ID
+						   {resolveDynamicScope($x.text)!=null &&
+						     resolveDynamicScope($x.text).getAttribute($y.text)!=null}?
+		//{JSystem.@out.println("found \$scope::attr "+ $x.text + "::" + $y.text);}
+		{
+			AttributeScope scope = resolveDynamicScope($x.text);
+			if ( scope!=null )
+			{
+				StringTemplate st = template("scopeAttributeRef");
+				st.setAttribute("scope", $x.text);
+				st.setAttribute("attr",  scope.getAttribute($y.text));
+			}
+			else
+			{
+				// error: invalid dynamic attribute
+			}
+		}
+	;
+
+
+ERROR_SCOPED_XY
+	:	'$' x=ID '::' y=ID
+		{
+		chunks.Add(Text);
+		generator.issueInvalidScopeError($x.text,$y.text,
+		                                 enclosingRule,actionToken,
+		                                 outerAltNum);
+		}
+	;
+
+/**		To access deeper (than top of stack) scopes, use the notation:
+ *
+ * 		$x[-1]::y previous (just under top of stack)
+ * 		$x[-i]::y top of stack - i where the '-' MUST BE PRESENT;
+ * 				  i.e., i cannot simply be negative without the '-' sign!
+ * 		$x[i]::y  absolute index i (0..size-1)
+ * 		$x[0]::y  is the absolute 0 indexed element (bottom of the stack)
+ */
+DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR
+	:	'$' x=ID '[' '-' expr=SCOPE_INDEX_EXPR ']' '::' y=ID
+		// {JSystem.@out.println("found \$scope[-...]::attr");}
+		{
+			StringTemplate st = template("scopeAttributeRef");
+			st.setAttribute("scope",    $x.text);
+			st.setAttribute("attr",     resolveDynamicScope($x.text).getAttribute($y.text));
+			st.setAttribute("negIndex", $expr.text);
+		}
+	;
+
+DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR
+	:	'$' x=ID '[' expr=SCOPE_INDEX_EXPR ']' '::' y=ID
+		// {JSystem.@out.println("found \$scope[...]::attr");}
+		{
+			StringTemplate st = template("scopeAttributeRef");
+			st.setAttribute("scope", $x.text);
+			st.setAttribute("attr",  resolveDynamicScope($x.text).getAttribute($y.text));
+			st.setAttribute("index", $expr.text);
+		}
+	;
+
+fragment
+SCOPE_INDEX_EXPR
+	:	(~']')+
+	;
+
+/** $r		y is a rule's dynamic scope or a global shared scope.
+ * 			Isolated $rulename is not allowed unless it has a dynamic scope *and*
+ * 			there is no reference to rulename in the enclosing alternative,
+ * 			which would be ambiguous.  See TestAttributes.testAmbiguousRuleRef()
+ */
+ISOLATED_DYNAMIC_SCOPE
+	:	'$' ID {resolveDynamicScope($ID.text)!=null}?
+		// {JSystem.@out.println("found isolated \$scope where scope is a dynamic scope");}
+		{
+			StringTemplate st = template("isolatedDynamicScopeRef");
+			st.setAttribute("scope", $ID.text);
+		}
+	;
+
+// antlr.g then codegen.g does these first two currently.
+// don't want to duplicate that code.
+
+/** %foo(a={},b={},...) ctor */
+TEMPLATE_INSTANCE
+	:	'%' ID '(' ( WS? ARG (',' WS? ARG)* WS? )? ')'
+		// {JSystem.@out.println("found \%foo(args)");}
+		{
+			string action = $text.Substring( 1, $text.Length - 1 );
+			string ruleName = "<outside-of-rule>";
+			if ( enclosingRule!=null )
+			{
+				ruleName = enclosingRule.name;
+			}
+			StringTemplate st =
+				generator.translateTemplateConstructor(ruleName,
+													   outerAltNum,
+													   actionToken,
+													   action);
+			if ( st!=null )
+			{
+				chunks.Add(st);
+			}
+		}
+	;
+
+/** %({name-expr})(a={},...) indirect template ctor reference */
+INDIRECT_TEMPLATE_INSTANCE
+	:	'%' '(' ACTION ')' '(' ( WS? ARG (',' WS? ARG)* WS? )? ')'
+		// {JSystem.@out.println("found \%({...})(args)");}
+		{
+			string action = $text.Substring( 1, $text.Length - 1 );
+			StringTemplate st =
+				generator.translateTemplateConstructor(enclosingRule.name,
+													   outerAltNum,
+													   actionToken,
+													   action);
+			chunks.Add(st);
+		}
+	;
+
+fragment
+ARG	:	ID '=' ACTION
+	;
+
+/**	%{expr}.y = z; template attribute y of StringTemplate-typed expr to z */
+SET_EXPR_ATTRIBUTE
+	:	'%' a=ACTION '.' ID WS? '=' expr=ATTR_VALUE_EXPR ';'
+		// {JSystem.@out.println("found \%{expr}.y = z;");}
+		{
+			StringTemplate st = template("actionSetAttribute");
+			string action = $a.text;
+			action = action.Substring( 1, action.Length - 2 ); // stuff inside {...}
+			st.setAttribute("st", translateAction(action));
+			st.setAttribute("attrName", $ID.text);
+			st.setAttribute("expr", translateAction($expr.text));
+		}
+	;
+
+/*    %x.y = z; set template attribute y of x (always set never get attr)
+ *              to z [languages like python without ';' must still use the
+ *              ';' which the code generator is free to remove during code gen]
+ */
+SET_ATTRIBUTE
+	:	'%' x=ID '.' y=ID WS? '=' expr=ATTR_VALUE_EXPR ';'
+		// {JSystem.@out.println("found \%x.y = z;");}
+		{
+			StringTemplate st = template("actionSetAttribute");
+			st.setAttribute("st", $x.text);
+			st.setAttribute("attrName", $y.text);
+			st.setAttribute("expr", translateAction($expr.text));
+		}
+	;
+
+/** Don't allow an = as first char to prevent $x == 3; kind of stuff. */
+fragment
+ATTR_VALUE_EXPR
+	:	~'=' (~';')*
+	;
+
+/** %{string-expr} anonymous template from string expr */
+TEMPLATE_EXPR
+	:	'%' a=ACTION
+		// {JSystem.@out.println("found \%{expr}");}
+		{
+			StringTemplate st = template("actionStringConstructor");
+			string action = $a.text;
+			action = action.Substring( 1, action.Length - 2 ); // stuff inside {...}
+			st.setAttribute("stringExpr", translateAction(action));
+		}
+	;
+
+fragment
+ACTION
+	:	'{' (options {greedy=false;}:.)* '}'
+	;
+
+ESC
+	:	'\\' '$' {chunks.Add("\$");}
+	|	'\\' '%' {chunks.Add("\%");}
+	|	'\\' ~('$'|'%') {chunks.Add(Text);}
+	;
+
+ERROR_XY
+	:	'$' x=ID '.' y=ID
+		{
+			chunks.Add(Text);
+			generator.issueInvalidAttributeError($x.text,$y.text,
+												 enclosingRule,actionToken,
+												 outerAltNum);
+		}
+	;
+
+ERROR_X
+	:	'$' x=ID
+		{
+			chunks.Add(Text);
+			generator.issueInvalidAttributeError($x.text,
+												 enclosingRule,actionToken,
+												 outerAltNum);
+		}
+	;
+
+UNKNOWN_SYNTAX
+	:	'$'
+		{
+			chunks.Add(Text);
+			// shouldn't need an error here.  Just accept \$ if it doesn't look like anything
+		}
+	|	'%' (ID|'.'|'('|')'|','|'{'|'}'|'"')*
+		{
+			chunks.Add(Text);
+			ErrorManager.grammarError(ErrorManager.MSG_INVALID_TEMPLATE_ACTION,
+									  grammar,
+									  actionToken,
+									  Text);
+		}
+	;
+
+TEXT
+	:	~('$'|'%'|'\\')+ {chunks.Add(Text);}
+	;
+
+fragment
+ID
+	:	('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*
+	;
+
+fragment
+INT
+	:	'0'..'9'+
+	;
+
+fragment
+WS
+	:	(' '|'\t'|'\n'|'\r')+
+	;
diff --git a/Antlr3/Grammars/ActionTranslatorHelper.cs b/Antlr3/Grammars/ActionTranslatorHelper.cs
new file mode 100644
index 0000000..c25fab9
--- /dev/null
+++ b/Antlr3/Grammars/ActionTranslatorHelper.cs
@@ -0,0 +1,196 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Grammar conversion to ANTLR v3 and C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *	notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	notice, this list of conditions and the following disclaimer in the
+ *	documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *	derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Grammars
+{
+    using Antlr3.Codegen;
+
+    using ANTLRStringStream = Antlr.Runtime.ANTLRStringStream;
+    using ArrayList = System.Collections.ArrayList;
+    using Attribute = Antlr3.Tool.Attribute;
+    using AttributeScope = Antlr3.Tool.AttributeScope;
+    using CommonToken = Antlr.Runtime.CommonToken;
+    using ErrorManager = Antlr3.Tool.ErrorManager;
+    using Grammar = Antlr3.Tool.Grammar;
+    using GrammarAST = Antlr3.Tool.GrammarAST;
+    using IList = System.Collections.IList;
+    using IToken = Antlr.Runtime.IToken;
+    using Rule = Antlr3.Tool.Rule;
+    using StringBuilder = System.Text.StringBuilder;
+    using StringTemplate = Antlr3.ST.StringTemplate;
+    using TokenConstants = Antlr.Runtime.TokenConstants;
+
+    partial class ActionTranslator
+    {
+        public IList chunks = new ArrayList();
+        Rule enclosingRule;
+        int outerAltNum;
+        Grammar grammar;
+        CodeGenerator generator;
+        IToken actionToken;
+
+        public ActionTranslator( CodeGenerator generator,
+                                     string ruleName,
+                                     GrammarAST actionAST )
+            : this( new ANTLRStringStream( actionAST.token.Text ) )
+        {
+            this.generator = generator;
+            this.grammar = generator.grammar;
+            this.enclosingRule = grammar.getLocallyDefinedRule( ruleName );
+            this.actionToken = actionAST.token;
+            this.outerAltNum = actionAST.outerAltNum;
+        }
+
+        public ActionTranslator( CodeGenerator generator,
+                                     string ruleName,
+                                     IToken actionToken,
+                                     int outerAltNum )
+            : this( new ANTLRStringStream( actionToken.Text ) )
+        {
+            this.generator = generator;
+            grammar = generator.grammar;
+            this.enclosingRule = grammar.getRule( ruleName );
+            this.actionToken = actionToken;
+            this.outerAltNum = outerAltNum;
+        }
+
+        /** Return a list of strings and StringTemplate objects that
+         *  represent the translated action.
+         */
+        public IList translateToChunks()
+        {
+            // JSystem.@out.println("###\naction="+action);
+            IToken t;
+            do
+            {
+                t = NextToken();
+            } while ( t.Type != TokenConstants.EOF );
+            return chunks;
+        }
+
+        public string translate()
+        {
+            IList theChunks = translateToChunks();
+            //JSystem.@out.println("chunks="+a.chunks);
+            StringBuilder buf = new StringBuilder();
+            for ( int i = 0; i < theChunks.Count; i++ )
+            {
+                object o = (object)theChunks[i];
+                buf.Append( o );
+            }
+            //JSystem.@out.println("translated: "+buf.toString());
+            return buf.ToString();
+        }
+
+        public IList translateAction( string action )
+        {
+            string rname = null;
+            if ( enclosingRule != null )
+            {
+                rname = enclosingRule.name;
+            }
+            ActionTranslator translator =
+                new ActionTranslator( generator,
+                                          rname,
+                                          new CommonToken( ANTLRParser.ACTION, action ), outerAltNum );
+            return translator.translateToChunks();
+        }
+
+        public bool isTokenRefInAlt( string id )
+        {
+            return enclosingRule.getTokenRefsInAlt( id, outerAltNum ) != null;
+        }
+        public bool isRuleRefInAlt( string id )
+        {
+            return enclosingRule.getRuleRefsInAlt( id, outerAltNum ) != null;
+        }
+        public Grammar.LabelElementPair getElementLabel( string id )
+        {
+            return enclosingRule.getLabel( id );
+        }
+
+        public void checkElementRefUniqueness( string @ref, bool isToken )
+        {
+            IList refs = null;
+            if ( isToken )
+            {
+                refs = enclosingRule.getTokenRefsInAlt( @ref, outerAltNum );
+            }
+            else
+            {
+                refs = enclosingRule.getRuleRefsInAlt( @ref, outerAltNum );
+            }
+            if ( refs != null && refs.Count > 1 )
+            {
+                ErrorManager.grammarError( ErrorManager.MSG_NONUNIQUE_REF,
+                                          grammar,
+                                          actionToken,
+                                          @ref );
+            }
+        }
+
+        /** For \$rulelabel.name, return the Attribute found for name.  It
+         *  will be a predefined property or a return value.
+         */
+        public Attribute getRuleLabelAttribute( string ruleName, string attrName )
+        {
+            Rule r = grammar.getRule( ruleName );
+            AttributeScope scope = r.getLocalAttributeScope( attrName );
+            if ( scope != null && !scope.isParameterScope )
+            {
+                return scope.getAttribute( attrName );
+            }
+            return null;
+        }
+
+        AttributeScope resolveDynamicScope( string scopeName )
+        {
+            if ( grammar.getGlobalScope( scopeName ) != null )
+            {
+                return grammar.getGlobalScope( scopeName );
+            }
+            Rule scopeRule = grammar.getRule( scopeName );
+            if ( scopeRule != null )
+            {
+                return scopeRule.ruleScope;
+            }
+            return null; // not a valid dynamic scope
+        }
+
+        protected StringTemplate template( string name )
+        {
+            StringTemplate st = generator.Templates.getInstanceOf( name );
+            chunks.Add( st );
+            return st;
+        }
+    }
+}
diff --git a/Antlr3/Grammars/AssignTokenTypesWalker.cs b/Antlr3/Grammars/AssignTokenTypesWalker.cs
new file mode 100644
index 0000000..f2a6475
--- /dev/null
+++ b/Antlr3/Grammars/AssignTokenTypesWalker.cs
@@ -0,0 +1,3362 @@
+// $ANTLR 3.1.2 Grammars\\AssignTokenTypesWalker.g3 2009-03-07 09:00:06
+
+// The variable 'variable' is assigned but its value is never used.
+#pragma warning disable 219
+// Unreachable code detected.
+#pragma warning disable 162
+
+
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+using System;
+using Antlr3.Analysis;
+using Antlr3.Misc;
+using Antlr3.Tool;
+
+using BitSet = Antlr.Runtime.BitSet;
+using DFA = Antlr.Runtime.DFA;
+using HashMap = System.Collections.Generic.Dictionary<object, object>;
+using Map = System.Collections.IDictionary;
+
+
+using System.Collections.Generic;
+using Antlr.Runtime;
+using Antlr.Runtime.Tree;
+using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;using Stack = System.Collections.Generic.Stack<object>;
+using List = System.Collections.IList;
+using ArrayList = System.Collections.Generic.List<object>;
+
+namespace Antlr3.Grammars
+{
+/** [Warning: TJP says that this is probably out of date as of 11/19/2005,
+ *   but since it's probably still useful, I'll leave in.  Don't have energy
+ *   to update at the moment.]
+ *
+ *  Compute the token types for all literals and rules etc..  There are
+ *  a few different cases to consider for grammar types and a few situations
+ *  within.
+ *
+ *  CASE 1 : pure parser grammar
+ *	a) Any reference to a token gets a token type.
+ *  b) The tokens section may alias a token name to a string or char
+ *
+ *  CASE 2 : pure lexer grammar
+ *  a) Import token vocabulary if available. Set token types for any new tokens
+ *     to values above last imported token type
+ *  b) token rule definitions get token types if not already defined
+ *  c) literals do NOT get token types
+ *
+ *  CASE 3 : merged parser / lexer grammar
+ *	a) Any char or string literal gets a token type in a parser rule
+ *  b) Any reference to a token gets a token type if not referencing
+ *     a fragment lexer rule
+ *  c) The tokens section may alias a token name to a string or char
+ *     which must add a rule to the lexer
+ *  d) token rule definitions get token types if not already defined
+ *  e) token rule definitions may also alias a token name to a literal.
+ *     E.g., Rule 'FOR : "for";' will alias FOR to "for" in the sense that
+ *     references to either in the parser grammar will yield the token type
+ *
+ *  What this pass does:
+ *
+ *  0. Collects basic info about the grammar like grammar name and type;
+ *     Oh, I have go get the options in case they affect the token types.
+ *     E.g., tokenVocab option.
+ *     Imports any token vocab name/type pairs into a local hashtable.
+ *  1. Finds a list of all literals and token names.
+ *  2. Finds a list of all token name rule definitions;
+ *     no token rules implies pure parser.
+ *  3. Finds a list of all simple token rule defs of form "<NAME> : <literal>;"
+ *     and aliases them.
+ *  4. Walks token names table and assign types to any unassigned
+ *  5. Walks aliases and assign types to referenced literals
+ *  6. Walks literals, assigning types if untyped
+ *  4. Informs the Grammar object of the type definitions such as:
+ *     g.defineToken(<charliteral>, ttype);
+ *     g.defineToken(<stringliteral>, ttype);
+ *     g.defineToken(<tokenID>, ttype);
+ *     where some of the ttype values will be the same for aliases tokens.
+ */
+public partial class AssignTokenTypesWalker : TreeParser
+{
+	public static readonly string[] tokenNames = new string[] {
+		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", "ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARG_ACTION", "ARGLIST", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", "CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", "COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", "DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", "EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", "GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", "LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", "NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", "OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", "RET", "RETURNS", "REWRITE", "ROOT", "RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", "SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYN_SEMPRED", "SYNPRED", "TEMPLATE", "THROWS", "TOKEN_REF", "TOKENS", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", "WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT", "CHARSET"
+	};
+	public const int EOF=-1;
+	public const int ACTION=4;
+	public const int ACTION_CHAR_LITERAL=5;
+	public const int ACTION_ESC=6;
+	public const int ACTION_STRING_LITERAL=7;
+	public const int ALT=8;
+	public const int AMPERSAND=9;
+	public const int ARG=10;
+	public const int ARG_ACTION=11;
+	public const int ARGLIST=12;
+	public const int ASSIGN=13;
+	public const int BACKTRACK_SEMPRED=14;
+	public const int BANG=15;
+	public const int BLOCK=16;
+	public const int CATCH=17;
+	public const int CHAR_LITERAL=18;
+	public const int CHAR_RANGE=19;
+	public const int CLOSE_ELEMENT_OPTION=20;
+	public const int CLOSURE=21;
+	public const int COLON=22;
+	public const int COMBINED_GRAMMAR=23;
+	public const int COMMA=24;
+	public const int COMMENT=25;
+	public const int DIGIT=26;
+	public const int DOC_COMMENT=27;
+	public const int DOLLAR=28;
+	public const int DOT=29;
+	public const int DOUBLE_ANGLE_STRING_LITERAL=30;
+	public const int DOUBLE_QUOTE_STRING_LITERAL=31;
+	public const int EOA=32;
+	public const int EOB=33;
+	public const int EOR=34;
+	public const int EPSILON=35;
+	public const int ESC=36;
+	public const int ETC=37;
+	public const int FINALLY=38;
+	public const int FORCED_ACTION=39;
+	public const int FRAGMENT=40;
+	public const int GATED_SEMPRED=41;
+	public const int GRAMMAR=42;
+	public const int ID=43;
+	public const int IMPLIES=44;
+	public const int IMPORT=45;
+	public const int INITACTION=46;
+	public const int INT=47;
+	public const int LABEL=48;
+	public const int LEXER=49;
+	public const int LEXER_GRAMMAR=50;
+	public const int LPAREN=51;
+	public const int ML_COMMENT=52;
+	public const int NESTED_ACTION=53;
+	public const int NESTED_ARG_ACTION=54;
+	public const int NOT=55;
+	public const int OPEN_ELEMENT_OPTION=56;
+	public const int OPTIONAL=57;
+	public const int OPTIONS=58;
+	public const int OR=59;
+	public const int PARSER=60;
+	public const int PARSER_GRAMMAR=61;
+	public const int PLUS=62;
+	public const int PLUS_ASSIGN=63;
+	public const int POSITIVE_CLOSURE=64;
+	public const int PRIVATE=65;
+	public const int PROTECTED=66;
+	public const int PUBLIC=67;
+	public const int QUESTION=68;
+	public const int RANGE=69;
+	public const int RCURLY=70;
+	public const int RET=71;
+	public const int RETURNS=72;
+	public const int REWRITE=73;
+	public const int ROOT=74;
+	public const int RPAREN=75;
+	public const int RULE=76;
+	public const int RULE_REF=77;
+	public const int SCOPE=78;
+	public const int SEMI=79;
+	public const int SEMPRED=80;
+	public const int SL_COMMENT=81;
+	public const int SRC=82;
+	public const int STAR=83;
+	public const int STRAY_BRACKET=84;
+	public const int STRING_LITERAL=85;
+	public const int SYN_SEMPRED=86;
+	public const int SYNPRED=87;
+	public const int TEMPLATE=88;
+	public const int THROWS=89;
+	public const int TOKEN_REF=90;
+	public const int TOKENS=91;
+	public const int TREE=92;
+	public const int TREE_BEGIN=93;
+	public const int TREE_GRAMMAR=94;
+	public const int WILDCARD=95;
+	public const int WS=96;
+	public const int WS_LOOP=97;
+	public const int WS_OPT=98;
+	public const int XDIGIT=99;
+	public const int CHARSET=100;
+
+	// delegates
+	// delegators
+
+	public AssignTokenTypesWalker( ITreeNodeStream input )
+		: this( input, new RecognizerSharedState() )
+	{
+	}
+	public AssignTokenTypesWalker( ITreeNodeStream input, RecognizerSharedState state )
+		: base( input, state )
+	{
+	}
+
+
+	public override string[] GetTokenNames() { return AssignTokenTypesWalker.tokenNames; }
+	public override string GrammarFileName { get { return "Grammars\\AssignTokenTypesWalker.g3"; } }
+
+
+	#region Rules
+
+	// $ANTLR start "grammar_"
+	// Grammars\\AssignTokenTypesWalker.g3:139:0: public grammar_[Grammar g] : ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) ) ;
+	public void grammar_( Grammar g )
+	{
+
+			if ( state.backtracking == 0 )
+				init(g);
+
+		try
+		{
+			// Grammars\\AssignTokenTypesWalker.g3:145:4: ( ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) ) )
+			// Grammars\\AssignTokenTypesWalker.g3:145:4: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
+			{
+			// Grammars\\AssignTokenTypesWalker.g3:145:4: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
+			int alt1=4;
+			switch ( input.LA(1) )
+			{
+			case LEXER_GRAMMAR:
+				{
+				alt1=1;
+				}
+				break;
+			case PARSER_GRAMMAR:
+				{
+				alt1=2;
+				}
+				break;
+			case TREE_GRAMMAR:
+				{
+				alt1=3;
+				}
+				break;
+			case COMBINED_GRAMMAR:
+				{
+				alt1=4;
+				}
+				break;
+			default:
+				{
+					NoViableAltException nvae = new NoViableAltException("", 1, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt1 )
+			{
+			case 1:
+				// Grammars\\AssignTokenTypesWalker.g3:145:6: ^( LEXER_GRAMMAR grammarSpec )
+				{
+				Match(input,LEXER_GRAMMAR,Follow._LEXER_GRAMMAR_in_grammar_68);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._grammarSpec_in_grammar_73);
+				grammarSpec();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 2:
+				// Grammars\\AssignTokenTypesWalker.g3:146:5: ^( PARSER_GRAMMAR grammarSpec )
+				{
+				Match(input,PARSER_GRAMMAR,Follow._PARSER_GRAMMAR_in_grammar_83);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._grammarSpec_in_grammar_87);
+				grammarSpec();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 3:
+				// Grammars\\AssignTokenTypesWalker.g3:147:5: ^( TREE_GRAMMAR grammarSpec )
+				{
+				Match(input,TREE_GRAMMAR,Follow._TREE_GRAMMAR_in_grammar_97);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._grammarSpec_in_grammar_103);
+				grammarSpec();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 4:
+				// Grammars\\AssignTokenTypesWalker.g3:148:5: ^( COMBINED_GRAMMAR grammarSpec )
+				{
+				Match(input,COMBINED_GRAMMAR,Follow._COMBINED_GRAMMAR_in_grammar_113);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._grammarSpec_in_grammar_115);
+				grammarSpec();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+
+			}
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "grammar_"
+
+
+	// $ANTLR start "grammarSpec"
+	// Grammars\\AssignTokenTypesWalker.g3:152:0: grammarSpec : id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules ;
+	private void grammarSpec(  )
+	{
+		GrammarAST id=null;
+		GrammarAST cmt=null;
+
+		try
+		{
+			// Grammars\\AssignTokenTypesWalker.g3:153:4: (id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules )
+			// Grammars\\AssignTokenTypesWalker.g3:153:4: id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules
+			{
+			id=(GrammarAST)Match(input,ID,Follow._ID_in_grammarSpec134);
+			// Grammars\\AssignTokenTypesWalker.g3:154:3: (cmt= DOC_COMMENT )?
+			int alt2=2;
+			int LA2_0 = input.LA(1);
+
+			if ( (LA2_0==DOC_COMMENT) )
+			{
+				alt2=1;
+			}
+			switch ( alt2 )
+			{
+			case 1:
+				// Grammars\\AssignTokenTypesWalker.g3:154:4: cmt= DOC_COMMENT
+				{
+				cmt=(GrammarAST)Match(input,DOC_COMMENT,Follow._DOC_COMMENT_in_grammarSpec141);
+
+				}
+				break;
+
+			}
+
+			// Grammars\\AssignTokenTypesWalker.g3:155:3: ( optionsSpec )?
+			int alt3=2;
+			int LA3_0 = input.LA(1);
+
+			if ( (LA3_0==OPTIONS) )
+			{
+				alt3=1;
+			}
+			switch ( alt3 )
+			{
+			case 1:
+				// Grammars\\AssignTokenTypesWalker.g3:155:4: optionsSpec
+				{
+				PushFollow(Follow._optionsSpec_in_grammarSpec148);
+				optionsSpec();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			// Grammars\\AssignTokenTypesWalker.g3:156:3: ( delegateGrammars )?
+			int alt4=2;
+			int LA4_0 = input.LA(1);
+
+			if ( (LA4_0==IMPORT) )
+			{
+				alt4=1;
+			}
+			switch ( alt4 )
+			{
+			case 1:
+				// Grammars\\AssignTokenTypesWalker.g3:156:4: delegateGrammars
+				{
+				PushFollow(Follow._delegateGrammars_in_grammarSpec155);
+				delegateGrammars();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			// Grammars\\AssignTokenTypesWalker.g3:157:3: ( tokensSpec )?
+			int alt5=2;
+			int LA5_0 = input.LA(1);
+
+			if ( (LA5_0==TOKENS) )
+			{
+				alt5=1;
+			}
+			switch ( alt5 )
+			{
+			case 1:
+				// Grammars\\AssignTokenTypesWalker.g3:157:4: tokensSpec
+				{
+				PushFollow(Follow._tokensSpec_in_grammarSpec162);
+				tokensSpec();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			// Grammars\\AssignTokenTypesWalker.g3:158:3: ( attrScope )*
+			for ( ; ; )
+			{
+				int alt6=2;
+				int LA6_0 = input.LA(1);
+
+				if ( (LA6_0==SCOPE) )
+				{
+					alt6=1;
+				}
+
+
+				switch ( alt6 )
+				{
+				case 1:
+					// Grammars\\AssignTokenTypesWalker.g3:158:4: attrScope
+					{
+					PushFollow(Follow._attrScope_in_grammarSpec169);
+					attrScope();
+
+					state._fsp--;
+
+
+					}
+					break;
+
+				default:
+					goto loop6;
+				}
+			}
+
+			loop6:
+				;
+
+
+			// Grammars\\AssignTokenTypesWalker.g3:159:3: ( ^( AMPERSAND ( . )* ) )*
+			for ( ; ; )
+			{
+				int alt8=2;
+				int LA8_0 = input.LA(1);
+
+				if ( (LA8_0==AMPERSAND) )
+				{
+					alt8=1;
+				}
+
+
+				switch ( alt8 )
+				{
+				case 1:
+					// Grammars\\AssignTokenTypesWalker.g3:159:5: ^( AMPERSAND ( . )* )
+					{
+					Match(input,AMPERSAND,Follow._AMPERSAND_in_grammarSpec178);
+
+					if ( input.LA(1)==TokenConstants.DOWN )
+					{
+						Match(input, TokenConstants.DOWN, null);
+						// Grammars\\AssignTokenTypesWalker.g3:159:17: ( . )*
+						for ( ; ; )
+						{
+							int alt7=2;
+							int LA7_0 = input.LA(1);
+
+							if ( ((LA7_0>=ACTION && LA7_0<=CHARSET)) )
+							{
+								alt7=1;
+							}
+							else if ( (LA7_0==UP) )
+							{
+								alt7=2;
+							}
+
+
+							switch ( alt7 )
+							{
+							case 1:
+								// Grammars\\AssignTokenTypesWalker.g3:159:0: .
+								{
+								MatchAny(input);
+
+								}
+								break;
+
+							default:
+								goto loop7;
+							}
+						}
+
+						loop7:
+							;
+
+
+
+						Match(input, TokenConstants.UP, null);
+					}
+
+					}
+					break;
+
+				default:
+					goto loop8;
+				}
+			}
+
+			loop8:
+				;
+
+
+			PushFollow(Follow._rules_in_grammarSpec190);
+			rules();
+
+			state._fsp--;
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "grammarSpec"
+
+
+	// $ANTLR start "attrScope"
+	// Grammars\\AssignTokenTypesWalker.g3:163:0: attrScope : ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION ) ;
+	private void attrScope(  )
+	{
+		try
+		{
+			// Grammars\\AssignTokenTypesWalker.g3:164:4: ( ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION ) )
+			// Grammars\\AssignTokenTypesWalker.g3:164:4: ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION )
+			{
+			Match(input,SCOPE,Follow._SCOPE_in_attrScope203);
+
+			Match(input, TokenConstants.DOWN, null);
+			Match(input,ID,Follow._ID_in_attrScope205);
+			// Grammars\\AssignTokenTypesWalker.g3:164:18: ( ^( AMPERSAND ( . )* ) )*
+			for ( ; ; )
+			{
+				int alt10=2;
+				int LA10_0 = input.LA(1);
+
+				if ( (LA10_0==AMPERSAND) )
+				{
+					alt10=1;
+				}
+
+
+				switch ( alt10 )
+				{
+				case 1:
+					// Grammars\\AssignTokenTypesWalker.g3:164:20: ^( AMPERSAND ( . )* )
+					{
+					Match(input,AMPERSAND,Follow._AMPERSAND_in_attrScope210);
+
+					if ( input.LA(1)==TokenConstants.DOWN )
+					{
+						Match(input, TokenConstants.DOWN, null);
+						// Grammars\\AssignTokenTypesWalker.g3:164:32: ( . )*
+						for ( ; ; )
+						{
+							int alt9=2;
+							int LA9_0 = input.LA(1);
+
+							if ( ((LA9_0>=ACTION && LA9_0<=CHARSET)) )
+							{
+								alt9=1;
+							}
+							else if ( (LA9_0==UP) )
+							{
+								alt9=2;
+							}
+
+
+							switch ( alt9 )
+							{
+							case 1:
+								// Grammars\\AssignTokenTypesWalker.g3:164:0: .
+								{
+								MatchAny(input);
+
+								}
+								break;
+
+							default:
+								goto loop9;
+							}
+						}
+
+						loop9:
+							;
+
+
+
+						Match(input, TokenConstants.UP, null);
+					}
+
+					}
+					break;
+
+				default:
+					goto loop10;
+				}
+			}
+
+			loop10:
+				;
+
+
+			Match(input,ACTION,Follow._ACTION_in_attrScope219);
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "attrScope"
+
+
+	// $ANTLR start "optionsSpec"
+	// Grammars\\AssignTokenTypesWalker.g3:167:0: optionsSpec returns [Map opts=new HashMap()] : ^( OPTIONS ( option[$opts] )+ ) ;
+	private Map optionsSpec(  )
+	{
+
+		Map opts = new HashMap();
+
+		try
+		{
+			// Grammars\\AssignTokenTypesWalker.g3:168:4: ( ^( OPTIONS ( option[$opts] )+ ) )
+			// Grammars\\AssignTokenTypesWalker.g3:168:4: ^( OPTIONS ( option[$opts] )+ )
+			{
+			Match(input,OPTIONS,Follow._OPTIONS_in_optionsSpec238);
+
+			Match(input, TokenConstants.DOWN, null);
+			// Grammars\\AssignTokenTypesWalker.g3:168:15: ( option[$opts] )+
+			int cnt11=0;
+			for ( ; ; )
+			{
+				int alt11=2;
+				int LA11_0 = input.LA(1);
+
+				if ( (LA11_0==ASSIGN) )
+				{
+					alt11=1;
+				}
+
+
+				switch ( alt11 )
+				{
+				case 1:
+					// Grammars\\AssignTokenTypesWalker.g3:168:16: option[$opts]
+					{
+					PushFollow(Follow._option_in_optionsSpec241);
+					option(opts);
+
+					state._fsp--;
+
+
+					}
+					break;
+
+				default:
+					if ( cnt11 >= 1 )
+						goto loop11;
+
+					EarlyExitException eee11 = new EarlyExitException( 11, input );
+					throw eee11;
+				}
+				cnt11++;
+			}
+			loop11:
+				;
+
+
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return opts;
+	}
+	// $ANTLR end "optionsSpec"
+
+
+	// $ANTLR start "option"
+	// Grammars\\AssignTokenTypesWalker.g3:171:0: option[Map opts] : ^( ASSIGN ID optionValue ) ;
+	private void option( Map opts )
+	{
+		GrammarAST ID1=null;
+		AssignTokenTypesWalker.optionValue_return optionValue2 = default(AssignTokenTypesWalker.optionValue_return);
+
+		try
+		{
+			// Grammars\\AssignTokenTypesWalker.g3:172:4: ( ^( ASSIGN ID optionValue ) )
+			// Grammars\\AssignTokenTypesWalker.g3:172:4: ^( ASSIGN ID optionValue )
+			{
+			Match(input,ASSIGN,Follow._ASSIGN_in_option260);
+
+			Match(input, TokenConstants.DOWN, null);
+			ID1=(GrammarAST)Match(input,ID,Follow._ID_in_option262);
+			PushFollow(Follow._optionValue_in_option264);
+			optionValue2=optionValue();
+
+			state._fsp--;
+
+
+			Match(input, TokenConstants.UP, null);
+
+						string key = (ID1!=null?ID1.Text:null);
+						opts[key] = (optionValue2!=null?optionValue2.value:default(Object));
+						// check for grammar-level option to import vocabulary
+						if ( currentRuleName==null && key.Equals("tokenVocab") )
+						{
+							grammar.importTokenVocabulary(ID1,(string)(optionValue2!=null?optionValue2.value:default(Object)));
+						}
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "option"
+
+	public class optionValue_return : TreeRuleReturnScope
+	{
+		public Object value=null;
+	}
+
+	// $ANTLR start "optionValue"
+	// Grammars\\AssignTokenTypesWalker.g3:184:0: optionValue returns [Object value=null] : ( ID | STRING_LITERAL | CHAR_LITERAL | INT );
+	private AssignTokenTypesWalker.optionValue_return optionValue(  )
+	{
+		AssignTokenTypesWalker.optionValue_return retval = new AssignTokenTypesWalker.optionValue_return();
+		retval.start = input.LT(1);
+
+		GrammarAST INT3=null;
+
+
+			if ( state.backtracking == 0 )
+				retval.value = ((GrammarAST)retval.start).Text;
+
+		try
+		{
+			// Grammars\\AssignTokenTypesWalker.g3:190:4: ( ID | STRING_LITERAL | CHAR_LITERAL | INT )
+			int alt12=4;
+			switch ( input.LA(1) )
+			{
+			case ID:
+				{
+				alt12=1;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt12=2;
+				}
+				break;
+			case CHAR_LITERAL:
+				{
+				alt12=3;
+				}
+				break;
+			case INT:
+				{
+				alt12=4;
+				}
+				break;
+			default:
+				{
+					NoViableAltException nvae = new NoViableAltException("", 12, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt12 )
+			{
+			case 1:
+				// Grammars\\AssignTokenTypesWalker.g3:190:4: ID
+				{
+				Match(input,ID,Follow._ID_in_optionValue290);
+
+				}
+				break;
+			case 2:
+				// Grammars\\AssignTokenTypesWalker.g3:191:4: STRING_LITERAL
+				{
+				Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_optionValue295);
+
+				}
+				break;
+			case 3:
+				// Grammars\\AssignTokenTypesWalker.g3:192:4: CHAR_LITERAL
+				{
+				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_optionValue300);
+
+				}
+				break;
+			case 4:
+				// Grammars\\AssignTokenTypesWalker.g3:193:4: INT
+				{
+				INT3=(GrammarAST)Match(input,INT,Follow._INT_in_optionValue305);
+				 retval.value = int.Parse( (INT3!=null?INT3.Text:null) );
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "optionValue"
+
+
+	// $ANTLR start "charSet"
+	// Grammars\\AssignTokenTypesWalker.g3:198:0: charSet : ^( CHARSET charSetElement ) ;
+	private void charSet(  )
+	{
+		try
+		{
+			// Grammars\\AssignTokenTypesWalker.g3:199:4: ( ^( CHARSET charSetElement ) )
+			// Grammars\\AssignTokenTypesWalker.g3:199:4: ^( CHARSET charSetElement )
+			{
+			Match(input,CHARSET,Follow._CHARSET_in_charSet323);
+
+			Match(input, TokenConstants.DOWN, null);
+			PushFollow(Follow._charSetElement_in_charSet325);
+			charSetElement();
+
+			state._fsp--;
+
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "charSet"
+
+
+	// $ANTLR start "charSetElement"
+	// Grammars\\AssignTokenTypesWalker.g3:202:0: charSetElement : ( CHAR_LITERAL | ^( OR CHAR_LITERAL CHAR_LITERAL ) | ^( RANGE CHAR_LITERAL CHAR_LITERAL ) );
+	private void charSetElement(  )
+	{
+		try
+		{
+			// Grammars\\AssignTokenTypesWalker.g3:203:4: ( CHAR_LITERAL | ^( OR CHAR_LITERAL CHAR_LITERAL ) | ^( RANGE CHAR_LITERAL CHAR_LITERAL ) )
+			int alt13=3;
+			switch ( input.LA(1) )
+			{
+			case CHAR_LITERAL:
+				{
+				alt13=1;
+				}
+				break;
+			case OR:
+				{
+				alt13=2;
+				}
+				break;
+			case RANGE:
+				{
+				alt13=3;
+				}
+				break;
+			default:
+				{
+					NoViableAltException nvae = new NoViableAltException("", 13, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt13 )
+			{
+			case 1:
+				// Grammars\\AssignTokenTypesWalker.g3:203:4: CHAR_LITERAL
+				{
+				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_charSetElement338);
+
+				}
+				break;
+			case 2:
+				// Grammars\\AssignTokenTypesWalker.g3:204:4: ^( OR CHAR_LITERAL CHAR_LITERAL )
+				{
+				Match(input,OR,Follow._OR_in_charSetElement345);
+
+				Match(input, TokenConstants.DOWN, null);
+				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_charSetElement347);
+				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_charSetElement349);
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 3:
+				// Grammars\\AssignTokenTypesWalker.g3:205:4: ^( RANGE CHAR_LITERAL CHAR_LITERAL )
+				{
+				Match(input,RANGE,Follow._RANGE_in_charSetElement358);
+
+				Match(input, TokenConstants.DOWN, null);
+				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_charSetElement360);
+				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_charSetElement362);
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "charSetElement"
+
+
+	// $ANTLR start "delegateGrammars"
+	// Grammars\\AssignTokenTypesWalker.g3:208:0: delegateGrammars : ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ ) ;
+	private void delegateGrammars(  )
+	{
+		try
+		{
+			// Grammars\\AssignTokenTypesWalker.g3:209:4: ( ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ ) )
+			// Grammars\\AssignTokenTypesWalker.g3:209:4: ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ )
+			{
+			Match(input,IMPORT,Follow._IMPORT_in_delegateGrammars377);
+
+			Match(input, TokenConstants.DOWN, null);
+			// Grammars\\AssignTokenTypesWalker.g3:210:4: ( ^( ASSIGN ID ID ) | ID )+
+			int cnt14=0;
+			for ( ; ; )
+			{
+				int alt14=3;
+				int LA14_0 = input.LA(1);
+
+				if ( (LA14_0==ASSIGN) )
+				{
+					alt14=1;
+				}
+				else if ( (LA14_0==ID) )
+				{
+					alt14=2;
+				}
+
+
+				switch ( alt14 )
+				{
+				case 1:
+					// Grammars\\AssignTokenTypesWalker.g3:210:6: ^( ASSIGN ID ID )
+					{
+					Match(input,ASSIGN,Follow._ASSIGN_in_delegateGrammars385);
+
+					Match(input, TokenConstants.DOWN, null);
+					Match(input,ID,Follow._ID_in_delegateGrammars387);
+					Match(input,ID,Follow._ID_in_delegateGrammars389);
+
+					Match(input, TokenConstants.UP, null);
+
+					}
+					break;
+				case 2:
+					// Grammars\\AssignTokenTypesWalker.g3:211:6: ID
+					{
+					Match(input,ID,Follow._ID_in_delegateGrammars397);
+
+					}
+					break;
+
+				default:
+					if ( cnt14 >= 1 )
+						goto loop14;
+
+					EarlyExitException eee14 = new EarlyExitException( 14, input );
+					throw eee14;
+				}
+				cnt14++;
+			}
+			loop14:
+				;
+
+
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "delegateGrammars"
+
+
+	// $ANTLR start "tokensSpec"
+	// Grammars\\AssignTokenTypesWalker.g3:216:0: tokensSpec : ^( TOKENS ( tokenSpec )+ ) ;
+	private void tokensSpec(  )
+	{
+		try
+		{
+			// Grammars\\AssignTokenTypesWalker.g3:217:4: ( ^( TOKENS ( tokenSpec )+ ) )
+			// Grammars\\AssignTokenTypesWalker.g3:217:4: ^( TOKENS ( tokenSpec )+ )
+			{
+			Match(input,TOKENS,Follow._TOKENS_in_tokensSpec420);
+
+			Match(input, TokenConstants.DOWN, null);
+			// Grammars\\AssignTokenTypesWalker.g3:217:14: ( tokenSpec )+
+			int cnt15=0;
+			for ( ; ; )
+			{
+				int alt15=2;
+				int LA15_0 = input.LA(1);
+
+				if ( (LA15_0==ASSIGN||LA15_0==TOKEN_REF) )
+				{
+					alt15=1;
+				}
+
+
+				switch ( alt15 )
+				{
+				case 1:
+					// Grammars\\AssignTokenTypesWalker.g3:217:0: tokenSpec
+					{
+					PushFollow(Follow._tokenSpec_in_tokensSpec422);
+					tokenSpec();
+
+					state._fsp--;
+
+
+					}
+					break;
+
+				default:
+					if ( cnt15 >= 1 )
+						goto loop15;
+
+					EarlyExitException eee15 = new EarlyExitException( 15, input );
+					throw eee15;
+				}
+				cnt15++;
+			}
+			loop15:
+				;
+
+
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "tokensSpec"
+
+
+	// $ANTLR start "tokenSpec"
+	// Grammars\\AssignTokenTypesWalker.g3:220:0: tokenSpec : (t= TOKEN_REF | ^( ASSIGN t2= TOKEN_REF (s= STRING_LITERAL |c= CHAR_LITERAL ) ) );
+	private void tokenSpec(  )
+	{
+		GrammarAST t=null;
+		GrammarAST t2=null;
+		GrammarAST s=null;
+		GrammarAST c=null;
+
+		try
+		{
+			// Grammars\\AssignTokenTypesWalker.g3:221:4: (t= TOKEN_REF | ^( ASSIGN t2= TOKEN_REF (s= STRING_LITERAL |c= CHAR_LITERAL ) ) )
+			int alt17=2;
+			int LA17_0 = input.LA(1);
+
+			if ( (LA17_0==TOKEN_REF) )
+			{
+				alt17=1;
+			}
+			else if ( (LA17_0==ASSIGN) )
+			{
+				alt17=2;
+			}
+			else
+			{
+				NoViableAltException nvae = new NoViableAltException("", 17, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt17 )
+			{
+			case 1:
+				// Grammars\\AssignTokenTypesWalker.g3:221:4: t= TOKEN_REF
+				{
+				t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_tokenSpec438);
+				trackToken(t);
+
+				}
+				break;
+			case 2:
+				// Grammars\\AssignTokenTypesWalker.g3:222:4: ^( ASSIGN t2= TOKEN_REF (s= STRING_LITERAL |c= CHAR_LITERAL ) )
+				{
+				Match(input,ASSIGN,Follow._ASSIGN_in_tokenSpec458);
+
+				Match(input, TokenConstants.DOWN, null);
+				t2=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_tokenSpec465);
+				trackToken(t2);
+				// Grammars\\AssignTokenTypesWalker.g3:224:4: (s= STRING_LITERAL |c= CHAR_LITERAL )
+				int alt16=2;
+				int LA16_0 = input.LA(1);
+
+				if ( (LA16_0==STRING_LITERAL) )
+				{
+					alt16=1;
+				}
+				else if ( (LA16_0==CHAR_LITERAL) )
+				{
+					alt16=2;
+				}
+				else
+				{
+					NoViableAltException nvae = new NoViableAltException("", 16, 0, input);
+
+					throw nvae;
+				}
+				switch ( alt16 )
+				{
+				case 1:
+					// Grammars\\AssignTokenTypesWalker.g3:224:6: s= STRING_LITERAL
+					{
+					s=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_tokenSpec482);
+					trackString(s); alias(t2,s);
+
+					}
+					break;
+				case 2:
+					// Grammars\\AssignTokenTypesWalker.g3:225:6: c= CHAR_LITERAL
+					{
+					c=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_tokenSpec493);
+					trackString(c); alias(t2,c);
+
+					}
+					break;
+
+				}
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "tokenSpec"
+
+
+	// $ANTLR start "rules"
+	// Grammars\\AssignTokenTypesWalker.g3:230:0: rules : ( rule )+ ;
+	private void rules(  )
+	{
+		try
+		{
+			// Grammars\\AssignTokenTypesWalker.g3:231:4: ( ( rule )+ )
+			// Grammars\\AssignTokenTypesWalker.g3:231:4: ( rule )+
+			{
+			// Grammars\\AssignTokenTypesWalker.g3:231:4: ( rule )+
+			int cnt18=0;
+			for ( ; ; )
+			{
+				int alt18=2;
+				int LA18_0 = input.LA(1);
+
+				if ( (LA18_0==RULE) )
+				{
+					alt18=1;
+				}
+
+
+				switch ( alt18 )
+				{
+				case 1:
+					// Grammars\\AssignTokenTypesWalker.g3:231:0: rule
+					{
+					PushFollow(Follow._rule_in_rules517);
+					rule();
+
+					state._fsp--;
+
+
+					}
+					break;
+
+				default:
+					if ( cnt18 >= 1 )
+						goto loop18;
+
+					EarlyExitException eee18 = new EarlyExitException( 18, input );
+					throw eee18;
+				}
+				cnt18++;
+			}
+			loop18:
+				;
+
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "rules"
+
+
+	// $ANTLR start "rule"
+	// Grammars\\AssignTokenTypesWalker.g3:234:0: rule : ^( RULE id= ID (m= modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block ( exceptionGroup )? EOR ) ;
+	private void rule(  )
+	{
+		GrammarAST id=null;
+		AssignTokenTypesWalker.modifier_return m = default(AssignTokenTypesWalker.modifier_return);
+		AssignTokenTypesWalker.block_return b = default(AssignTokenTypesWalker.block_return);
+
+		try
+		{
+			// Grammars\\AssignTokenTypesWalker.g3:235:4: ( ^( RULE id= ID (m= modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block ( exceptionGroup )? EOR ) )
+			// Grammars\\AssignTokenTypesWalker.g3:235:4: ^( RULE id= ID (m= modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block ( exceptionGroup )? EOR )
+			{
+			Match(input,RULE,Follow._RULE_in_rule531);
+
+			Match(input, TokenConstants.DOWN, null);
+			id=(GrammarAST)Match(input,ID,Follow._ID_in_rule535);
+			currentRuleName=(id!=null?id.Text:null);
+			// Grammars\\AssignTokenTypesWalker.g3:236:4: (m= modifier )?
+			int alt19=2;
+			int LA19_0 = input.LA(1);
+
+			if ( (LA19_0==FRAGMENT||(LA19_0>=PRIVATE && LA19_0<=PUBLIC)) )
+			{
+				alt19=1;
+			}
+			switch ( alt19 )
+			{
+			case 1:
+				// Grammars\\AssignTokenTypesWalker.g3:236:5: m= modifier
+				{
+				PushFollow(Follow._modifier_in_rule545);
+				m=modifier();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			Match(input,ARG,Follow._ARG_in_rule553);
+
+			if ( input.LA(1)==TokenConstants.DOWN )
+			{
+				Match(input, TokenConstants.DOWN, null);
+				// Grammars\\AssignTokenTypesWalker.g3:237:10: ( ARG_ACTION )?
+				int alt20=2;
+				int LA20_0 = input.LA(1);
+
+				if ( (LA20_0==ARG_ACTION) )
+				{
+					alt20=1;
+				}
+				switch ( alt20 )
+				{
+				case 1:
+					// Grammars\\AssignTokenTypesWalker.g3:237:11: ARG_ACTION
+					{
+					Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule556);
+
+					}
+					break;
+
+				}
+
+
+				Match(input, TokenConstants.UP, null);
+			}
+			Match(input,RET,Follow._RET_in_rule565);
+
+			if ( input.LA(1)==TokenConstants.DOWN )
+			{
+				Match(input, TokenConstants.DOWN, null);
+				// Grammars\\AssignTokenTypesWalker.g3:238:10: ( ARG_ACTION )?
+				int alt21=2;
+				int LA21_0 = input.LA(1);
+
+				if ( (LA21_0==ARG_ACTION) )
+				{
+					alt21=1;
+				}
+				switch ( alt21 )
+				{
+				case 1:
+					// Grammars\\AssignTokenTypesWalker.g3:238:11: ARG_ACTION
+					{
+					Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule568);
+
+					}
+					break;
+
+				}
+
+
+				Match(input, TokenConstants.UP, null);
+			}
+			// Grammars\\AssignTokenTypesWalker.g3:239:4: ( throwsSpec )?
+			int alt22=2;
+			int LA22_0 = input.LA(1);
+
+			if ( (LA22_0==THROWS) )
+			{
+				alt22=1;
+			}
+			switch ( alt22 )
+			{
+			case 1:
+				// Grammars\\AssignTokenTypesWalker.g3:239:5: throwsSpec
+				{
+				PushFollow(Follow._throwsSpec_in_rule577);
+				throwsSpec();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			// Grammars\\AssignTokenTypesWalker.g3:240:4: ( optionsSpec )?
+			int alt23=2;
+			int LA23_0 = input.LA(1);
+
+			if ( (LA23_0==OPTIONS) )
+			{
+				alt23=1;
+			}
+			switch ( alt23 )
+			{
+			case 1:
+				// Grammars\\AssignTokenTypesWalker.g3:240:5: optionsSpec
+				{
+				PushFollow(Follow._optionsSpec_in_rule585);
+				optionsSpec();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			// Grammars\\AssignTokenTypesWalker.g3:241:4: ( ruleScopeSpec )?
+			int alt24=2;
+			int LA24_0 = input.LA(1);
+
+			if ( (LA24_0==SCOPE) )
+			{
+				alt24=1;
+			}
+			switch ( alt24 )
+			{
+			case 1:
+				// Grammars\\AssignTokenTypesWalker.g3:241:5: ruleScopeSpec
+				{
+				PushFollow(Follow._ruleScopeSpec_in_rule593);
+				ruleScopeSpec();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			// Grammars\\AssignTokenTypesWalker.g3:242:4: ( ^( AMPERSAND ( . )* ) )*
+			for ( ; ; )
+			{
+				int alt26=2;
+				int LA26_0 = input.LA(1);
+
+				if ( (LA26_0==AMPERSAND) )
+				{
+					alt26=1;
+				}
+
+
+				switch ( alt26 )
+				{
+				case 1:
+					// Grammars\\AssignTokenTypesWalker.g3:242:6: ^( AMPERSAND ( . )* )
+					{
+					Match(input,AMPERSAND,Follow._AMPERSAND_in_rule603);
+
+					if ( input.LA(1)==TokenConstants.DOWN )
+					{
+						Match(input, TokenConstants.DOWN, null);
+						// Grammars\\AssignTokenTypesWalker.g3:242:18: ( . )*
+						for ( ; ; )
+						{
+							int alt25=2;
+							int LA25_0 = input.LA(1);
+
+							if ( ((LA25_0>=ACTION && LA25_0<=CHARSET)) )
+							{
+								alt25=1;
+							}
+							else if ( (LA25_0==UP) )
+							{
+								alt25=2;
+							}
+
+
+							switch ( alt25 )
+							{
+							case 1:
+								// Grammars\\AssignTokenTypesWalker.g3:242:0: .
+								{
+								MatchAny(input);
+
+								}
+								break;
+
+							default:
+								goto loop25;
+							}
+						}
+
+						loop25:
+							;
+
+
+
+						Match(input, TokenConstants.UP, null);
+					}
+
+					}
+					break;
+
+				default:
+					goto loop26;
+				}
+			}
+
+			loop26:
+				;
+
+
+			PushFollow(Follow._block_in_rule617);
+			b=block();
+
+			state._fsp--;
+
+			// Grammars\\AssignTokenTypesWalker.g3:244:4: ( exceptionGroup )?
+			int alt27=2;
+			int LA27_0 = input.LA(1);
+
+			if ( (LA27_0==CATCH||LA27_0==FINALLY) )
+			{
+				alt27=1;
+			}
+			switch ( alt27 )
+			{
+			case 1:
+				// Grammars\\AssignTokenTypesWalker.g3:244:5: exceptionGroup
+				{
+				PushFollow(Follow._exceptionGroup_in_rule623);
+				exceptionGroup();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			Match(input,EOR,Follow._EOR_in_rule630);
+			trackTokenRule(id,(m!=null?((GrammarAST)m.start):null),(b!=null?((GrammarAST)b.start):null));
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "rule"
+
+	public class modifier_return : TreeRuleReturnScope
+	{
+	}
+
+	// $ANTLR start "modifier"
+	// Grammars\\AssignTokenTypesWalker.g3:250:0: modifier : ( 'protected' | 'public' | 'private' | 'fragment' );
+	private AssignTokenTypesWalker.modifier_return modifier(  )
+	{
+		AssignTokenTypesWalker.modifier_return retval = new AssignTokenTypesWalker.modifier_return();
+		retval.start = input.LT(1);
+
+		try
+		{
+			// Grammars\\AssignTokenTypesWalker.g3:251:4: ( 'protected' | 'public' | 'private' | 'fragment' )
+			// Grammars\\AssignTokenTypesWalker.g3:
+			{
+			if ( input.LA(1)==FRAGMENT||(input.LA(1)>=PRIVATE && input.LA(1)<=PUBLIC) )
+			{
+				input.Consume();
+				state.errorRecovery=false;
+			}
+			else
+			{
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				throw mse;
+			}
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "modifier"
+
+
+	// $ANTLR start "throwsSpec"
+	// Grammars\\AssignTokenTypesWalker.g3:257:0: throwsSpec : ^( 'throws' ( ID )+ ) ;
+	private void throwsSpec(  )
+	{
+		try
+		{
+			// Grammars\\AssignTokenTypesWalker.g3:258:4: ( ^( 'throws' ( ID )+ ) )
+			// Grammars\\AssignTokenTypesWalker.g3:258:4: ^( 'throws' ( ID )+ )
+			{
+			Match(input,THROWS,Follow._THROWS_in_throwsSpec677);
+
+			Match(input, TokenConstants.DOWN, null);
+			// Grammars\\AssignTokenTypesWalker.g3:258:15: ( ID )+
+			int cnt28=0;
+			for ( ; ; )
+			{
+				int alt28=2;
+				int LA28_0 = input.LA(1);
+
+				if ( (LA28_0==ID) )
+				{
+					alt28=1;
+				}
+
+
+				switch ( alt28 )
+				{
+				case 1:
+					// Grammars\\AssignTokenTypesWalker.g3:258:0: ID
+					{
+					Match(input,ID,Follow._ID_in_throwsSpec679);
+
+					}
+					break;
+
+				default:
+					if ( cnt28 >= 1 )
+						goto loop28;
+
+					EarlyExitException eee28 = new EarlyExitException( 28, input );
+					throw eee28;
+				}
+				cnt28++;
+			}
+			loop28:
+				;
+
+
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "throwsSpec"
+
+
+	// $ANTLR start "ruleScopeSpec"
+	// Grammars\\AssignTokenTypesWalker.g3:261:0: ruleScopeSpec : ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* ) ;
+	private void ruleScopeSpec(  )
+	{
+		try
+		{
+			// Grammars\\AssignTokenTypesWalker.g3:262:4: ( ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* ) )
+			// Grammars\\AssignTokenTypesWalker.g3:262:4: ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* )
+			{
+			Match(input,SCOPE,Follow._SCOPE_in_ruleScopeSpec694);
+
+			if ( input.LA(1)==TokenConstants.DOWN )
+			{
+				Match(input, TokenConstants.DOWN, null);
+				// Grammars\\AssignTokenTypesWalker.g3:262:15: ( ^( AMPERSAND ( . )* ) )*
+				for ( ; ; )
+				{
+					int alt30=2;
+					int LA30_0 = input.LA(1);
+
+					if ( (LA30_0==AMPERSAND) )
+					{
+						alt30=1;
+					}
+
+
+					switch ( alt30 )
+					{
+					case 1:
+						// Grammars\\AssignTokenTypesWalker.g3:262:17: ^( AMPERSAND ( . )* )
+						{
+						Match(input,AMPERSAND,Follow._AMPERSAND_in_ruleScopeSpec699);
+
+						if ( input.LA(1)==TokenConstants.DOWN )
+						{
+							Match(input, TokenConstants.DOWN, null);
+							// Grammars\\AssignTokenTypesWalker.g3:262:29: ( . )*
+							for ( ; ; )
+							{
+								int alt29=2;
+								int LA29_0 = input.LA(1);
+
+								if ( ((LA29_0>=ACTION && LA29_0<=CHARSET)) )
+								{
+									alt29=1;
+								}
+								else if ( (LA29_0==UP) )
+								{
+									alt29=2;
+								}
+
+
+								switch ( alt29 )
+								{
+								case 1:
+									// Grammars\\AssignTokenTypesWalker.g3:262:0: .
+									{
+									MatchAny(input);
+
+									}
+									break;
+
+								default:
+									goto loop29;
+								}
+							}
+
+							loop29:
+								;
+
+
+
+							Match(input, TokenConstants.UP, null);
+						}
+
+						}
+						break;
+
+					default:
+						goto loop30;
+					}
+				}
+
+				loop30:
+					;
+
+
+				// Grammars\\AssignTokenTypesWalker.g3:262:36: ( ACTION )?
+				int alt31=2;
+				int LA31_0 = input.LA(1);
+
+				if ( (LA31_0==ACTION) )
+				{
+					alt31=1;
+				}
+				switch ( alt31 )
+				{
+				case 1:
+					// Grammars\\AssignTokenTypesWalker.g3:262:37: ACTION
+					{
+					Match(input,ACTION,Follow._ACTION_in_ruleScopeSpec709);
+
+					}
+					break;
+
+				}
+
+				// Grammars\\AssignTokenTypesWalker.g3:262:46: ( ID )*
+				for ( ; ; )
+				{
+					int alt32=2;
+					int LA32_0 = input.LA(1);
+
+					if ( (LA32_0==ID) )
+					{
+						alt32=1;
+					}
+
+
+					switch ( alt32 )
+					{
+					case 1:
+						// Grammars\\AssignTokenTypesWalker.g3:262:48: ID
+						{
+						Match(input,ID,Follow._ID_in_ruleScopeSpec715);
+
+						}
+						break;
+
+					default:
+						goto loop32;
+					}
+				}
+
+				loop32:
+					;
+
+
+
+				Match(input, TokenConstants.UP, null);
+			}
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "ruleScopeSpec"
+
+	public class block_return : TreeRuleReturnScope
+	{
+	}
+
+	// $ANTLR start "block"
+	// Grammars\\AssignTokenTypesWalker.g3:265:0: block : ^( BLOCK ( optionsSpec )? ( alternative rewrite )+ EOB ) ;
+	private AssignTokenTypesWalker.block_return block(  )
+	{
+		AssignTokenTypesWalker.block_return retval = new AssignTokenTypesWalker.block_return();
+		retval.start = input.LT(1);
+
+		try
+		{
+			// Grammars\\AssignTokenTypesWalker.g3:266:4: ( ^( BLOCK ( optionsSpec )? ( alternative rewrite )+ EOB ) )
+			// Grammars\\AssignTokenTypesWalker.g3:266:4: ^( BLOCK ( optionsSpec )? ( alternative rewrite )+ EOB )
+			{
+			Match(input,BLOCK,Follow._BLOCK_in_block733);
+
+			Match(input, TokenConstants.DOWN, null);
+			// Grammars\\AssignTokenTypesWalker.g3:267:4: ( optionsSpec )?
+			int alt33=2;
+			int LA33_0 = input.LA(1);
+
+			if ( (LA33_0==OPTIONS) )
+			{
+				alt33=1;
+			}
+			switch ( alt33 )
+			{
+			case 1:
+				// Grammars\\AssignTokenTypesWalker.g3:267:5: optionsSpec
+				{
+				PushFollow(Follow._optionsSpec_in_block739);
+				optionsSpec();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			// Grammars\\AssignTokenTypesWalker.g3:268:4: ( alternative rewrite )+
+			int cnt34=0;
+			for ( ; ; )
+			{
+				int alt34=2;
+				int LA34_0 = input.LA(1);
+
+				if ( (LA34_0==ALT) )
+				{
+					alt34=1;
+				}
+
+
+				switch ( alt34 )
+				{
+				case 1:
+					// Grammars\\AssignTokenTypesWalker.g3:268:6: alternative rewrite
+					{
+					PushFollow(Follow._alternative_in_block748);
+					alternative();
+
+					state._fsp--;
+
+					PushFollow(Follow._rewrite_in_block750);
+					rewrite();
+
+					state._fsp--;
+
+
+					}
+					break;
+
+				default:
+					if ( cnt34 >= 1 )
+						goto loop34;
+
+					EarlyExitException eee34 = new EarlyExitException( 34, input );
+					throw eee34;
+				}
+				cnt34++;
+			}
+			loop34:
+				;
+
+
+			Match(input,EOB,Follow._EOB_in_block758);
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "block"
+
+
+	// $ANTLR start "alternative"
+	// Grammars\\AssignTokenTypesWalker.g3:273:0: alternative : ^( ALT ( element )+ EOA ) ;
+	private void alternative(  )
+	{
+		try
+		{
+			// Grammars\\AssignTokenTypesWalker.g3:274:4: ( ^( ALT ( element )+ EOA ) )
+			// Grammars\\AssignTokenTypesWalker.g3:274:4: ^( ALT ( element )+ EOA )
+			{
+			Match(input,ALT,Follow._ALT_in_alternative775);
+
+			Match(input, TokenConstants.DOWN, null);
+			// Grammars\\AssignTokenTypesWalker.g3:274:11: ( element )+
+			int cnt35=0;
+			for ( ; ; )
+			{
+				int alt35=2;
+				int LA35_0 = input.LA(1);
+
+				if ( (LA35_0==ACTION||(LA35_0>=ASSIGN && LA35_0<=BLOCK)||(LA35_0>=CHAR_LITERAL && LA35_0<=CHAR_RANGE)||LA35_0==CLOSURE||LA35_0==DOT||LA35_0==EPSILON||LA35_0==FORCED_ACTION||LA35_0==GATED_SEMPRED||LA35_0==NOT||LA35_0==OPTIONAL||(LA35_0>=PLUS_ASSIGN && LA35_0<=POSITIVE_CLOSURE)||LA35_0==RANGE||LA35_0==ROOT||LA35_0==RULE_REF||LA35_0==SEMPRED||(LA35_0>=STRING_LITERAL && LA35_0<=SYNPRED)||LA35_0==TOKEN_REF||LA35_0==TREE_BEGIN||LA35_0==WILDCARD) )
+				{
+					alt35=1;
+				}
+
+
+				switch ( alt35 )
+				{
+				case 1:
+					// Grammars\\AssignTokenTypesWalker.g3:274:12: element
+					{
+					PushFollow(Follow._element_in_alternative778);
+					element();
+
+					state._fsp--;
+
+
+					}
+					break;
+
+				default:
+					if ( cnt35 >= 1 )
+						goto loop35;
+
+					EarlyExitException eee35 = new EarlyExitException( 35, input );
+					throw eee35;
+				}
+				cnt35++;
+			}
+			loop35:
+				;
+
+
+			Match(input,EOA,Follow._EOA_in_alternative782);
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "alternative"
+
+
+	// $ANTLR start "exceptionGroup"
+	// Grammars\\AssignTokenTypesWalker.g3:277:0: exceptionGroup : ( ( exceptionHandler )+ ( finallyClause )? | finallyClause );
+	private void exceptionGroup(  )
+	{
+		try
+		{
+			// Grammars\\AssignTokenTypesWalker.g3:278:4: ( ( exceptionHandler )+ ( finallyClause )? | finallyClause )
+			int alt38=2;
+			int LA38_0 = input.LA(1);
+
+			if ( (LA38_0==CATCH) )
+			{
+				alt38=1;
+			}
+			else if ( (LA38_0==FINALLY) )
+			{
+				alt38=2;
+			}
+			else
+			{
+				NoViableAltException nvae = new NoViableAltException("", 38, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt38 )
+			{
+			case 1:
+				// Grammars\\AssignTokenTypesWalker.g3:278:4: ( exceptionHandler )+ ( finallyClause )?
+				{
+				// Grammars\\AssignTokenTypesWalker.g3:278:4: ( exceptionHandler )+
+				int cnt36=0;
+				for ( ; ; )
+				{
+					int alt36=2;
+					int LA36_0 = input.LA(1);
+
+					if ( (LA36_0==CATCH) )
+					{
+						alt36=1;
+					}
+
+
+					switch ( alt36 )
+					{
+					case 1:
+						// Grammars\\AssignTokenTypesWalker.g3:278:6: exceptionHandler
+						{
+						PushFollow(Follow._exceptionHandler_in_exceptionGroup797);
+						exceptionHandler();
+
+						state._fsp--;
+
+
+						}
+						break;
+
+					default:
+						if ( cnt36 >= 1 )
+							goto loop36;
+
+						EarlyExitException eee36 = new EarlyExitException( 36, input );
+						throw eee36;
+					}
+					cnt36++;
+				}
+				loop36:
+					;
+
+
+				// Grammars\\AssignTokenTypesWalker.g3:278:26: ( finallyClause )?
+				int alt37=2;
+				int LA37_0 = input.LA(1);
+
+				if ( (LA37_0==FINALLY) )
+				{
+					alt37=1;
+				}
+				switch ( alt37 )
+				{
+				case 1:
+					// Grammars\\AssignTokenTypesWalker.g3:278:27: finallyClause
+					{
+					PushFollow(Follow._finallyClause_in_exceptionGroup803);
+					finallyClause();
+
+					state._fsp--;
+
+
+					}
+					break;
+
+				}
+
+
+				}
+				break;
+			case 2:
+				// Grammars\\AssignTokenTypesWalker.g3:279:4: finallyClause
+				{
+				PushFollow(Follow._finallyClause_in_exceptionGroup810);
+				finallyClause();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "exceptionGroup"
+
+
+	// $ANTLR start "exceptionHandler"
+	// Grammars\\AssignTokenTypesWalker.g3:282:0: exceptionHandler : ^( 'catch' ARG_ACTION ACTION ) ;
+	private void exceptionHandler(  )
+	{
+		try
+		{
+			// Grammars\\AssignTokenTypesWalker.g3:283:4: ( ^( 'catch' ARG_ACTION ACTION ) )
+			// Grammars\\AssignTokenTypesWalker.g3:283:4: ^( 'catch' ARG_ACTION ACTION )
+			{
+			Match(input,CATCH,Follow._CATCH_in_exceptionHandler822);
+
+			Match(input, TokenConstants.DOWN, null);
+			Match(input,ARG_ACTION,Follow._ARG_ACTION_in_exceptionHandler824);
+			Match(input,ACTION,Follow._ACTION_in_exceptionHandler826);
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "exceptionHandler"
+
+
+	// $ANTLR start "finallyClause"
+	// Grammars\\AssignTokenTypesWalker.g3:286:0: finallyClause : ^( 'finally' ACTION ) ;
+	private void finallyClause(  )
+	{
+		try
+		{
+			// Grammars\\AssignTokenTypesWalker.g3:287:4: ( ^( 'finally' ACTION ) )
+			// Grammars\\AssignTokenTypesWalker.g3:287:4: ^( 'finally' ACTION )
+			{
+			Match(input,FINALLY,Follow._FINALLY_in_finallyClause839);
+
+			Match(input, TokenConstants.DOWN, null);
+			Match(input,ACTION,Follow._ACTION_in_finallyClause841);
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "finallyClause"
+
+
+	// $ANTLR start "rewrite"
+	// Grammars\\AssignTokenTypesWalker.g3:290:0: rewrite : ( ^( REWRITE ( . )* ) )* ;
+	private void rewrite(  )
+	{
+		try
+		{
+			// Grammars\\AssignTokenTypesWalker.g3:291:4: ( ( ^( REWRITE ( . )* ) )* )
+			// Grammars\\AssignTokenTypesWalker.g3:291:4: ( ^( REWRITE ( . )* ) )*
+			{
+			// Grammars\\AssignTokenTypesWalker.g3:291:4: ( ^( REWRITE ( . )* ) )*
+			for ( ; ; )
+			{
+				int alt40=2;
+				int LA40_0 = input.LA(1);
+
+				if ( (LA40_0==REWRITE) )
+				{
+					alt40=1;
+				}
+
+
+				switch ( alt40 )
+				{
+				case 1:
+					// Grammars\\AssignTokenTypesWalker.g3:291:6: ^( REWRITE ( . )* )
+					{
+					Match(input,REWRITE,Follow._REWRITE_in_rewrite856);
+
+					if ( input.LA(1)==TokenConstants.DOWN )
+					{
+						Match(input, TokenConstants.DOWN, null);
+						// Grammars\\AssignTokenTypesWalker.g3:291:16: ( . )*
+						for ( ; ; )
+						{
+							int alt39=2;
+							int LA39_0 = input.LA(1);
+
+							if ( ((LA39_0>=ACTION && LA39_0<=CHARSET)) )
+							{
+								alt39=1;
+							}
+							else if ( (LA39_0==UP) )
+							{
+								alt39=2;
+							}
+
+
+							switch ( alt39 )
+							{
+							case 1:
+								// Grammars\\AssignTokenTypesWalker.g3:291:0: .
+								{
+								MatchAny(input);
+
+								}
+								break;
+
+							default:
+								goto loop39;
+							}
+						}
+
+						loop39:
+							;
+
+
+
+						Match(input, TokenConstants.UP, null);
+					}
+
+					}
+					break;
+
+				default:
+					goto loop40;
+				}
+			}
+
+			loop40:
+				;
+
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "rewrite"
+
+
+	// $ANTLR start "element"
+	// Grammars\\AssignTokenTypesWalker.g3:294:0: element : ( ^( ROOT element ) | ^( BANG element ) | atom | ^( NOT element ) | ^( RANGE atom atom ) | ^( CHAR_RANGE atom atom ) | ^( ASSIGN ID element ) | ^( PLUS_ASSIGN ID element ) | ebnf | tree_ | ^( SYNPRED block ) | FORCED_ACTION | ACTION | SEMPRED | SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) | GATED_SEMPRED | EPSILON );
+	private void element(  )
+	{
+		try
+		{
+			// Grammars\\AssignTokenTypesWalker.g3:295:4: ( ^( ROOT element ) | ^( BANG element ) | atom | ^( NOT element ) | ^( RANGE atom atom ) | ^( CHAR_RANGE atom atom ) | ^( ASSIGN ID element ) | ^( PLUS_ASSIGN ID element ) | ebnf | tree_ | ^( SYNPRED block ) | FORCED_ACTION | ACTION | SEMPRED | SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) | GATED_SEMPRED | EPSILON )
+			int alt42=18;
+			switch ( input.LA(1) )
+			{
+			case ROOT:
+				{
+				alt42=1;
+				}
+				break;
+			case BANG:
+				{
+				alt42=2;
+				}
+				break;
+			case CHAR_LITERAL:
+			case DOT:
+			case RULE_REF:
+			case STRING_LITERAL:
+			case TOKEN_REF:
+			case WILDCARD:
+				{
+				alt42=3;
+				}
+				break;
+			case NOT:
+				{
+				alt42=4;
+				}
+				break;
+			case RANGE:
+				{
+				alt42=5;
+				}
+				break;
+			case CHAR_RANGE:
+				{
+				alt42=6;
+				}
+				break;
+			case ASSIGN:
+				{
+				alt42=7;
+				}
+				break;
+			case PLUS_ASSIGN:
+				{
+				alt42=8;
+				}
+				break;
+			case BLOCK:
+			case CLOSURE:
+			case OPTIONAL:
+			case POSITIVE_CLOSURE:
+				{
+				alt42=9;
+				}
+				break;
+			case TREE_BEGIN:
+				{
+				alt42=10;
+				}
+				break;
+			case SYNPRED:
+				{
+				alt42=11;
+				}
+				break;
+			case FORCED_ACTION:
+				{
+				alt42=12;
+				}
+				break;
+			case ACTION:
+				{
+				alt42=13;
+				}
+				break;
+			case SEMPRED:
+				{
+				alt42=14;
+				}
+				break;
+			case SYN_SEMPRED:
+				{
+				alt42=15;
+				}
+				break;
+			case BACKTRACK_SEMPRED:
+				{
+				alt42=16;
+				}
+				break;
+			case GATED_SEMPRED:
+				{
+				alt42=17;
+				}
+				break;
+			case EPSILON:
+				{
+				alt42=18;
+				}
+				break;
+			default:
+				{
+					NoViableAltException nvae = new NoViableAltException("", 42, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt42 )
+			{
+			case 1:
+				// Grammars\\AssignTokenTypesWalker.g3:295:4: ^( ROOT element )
+				{
+				Match(input,ROOT,Follow._ROOT_in_element875);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._element_in_element877);
+				element();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 2:
+				// Grammars\\AssignTokenTypesWalker.g3:296:4: ^( BANG element )
+				{
+				Match(input,BANG,Follow._BANG_in_element884);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._element_in_element886);
+				element();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 3:
+				// Grammars\\AssignTokenTypesWalker.g3:297:4: atom
+				{
+				PushFollow(Follow._atom_in_element892);
+				atom();
+
+				state._fsp--;
+
+
+				}
+				break;
+			case 4:
+				// Grammars\\AssignTokenTypesWalker.g3:298:4: ^( NOT element )
+				{
+				Match(input,NOT,Follow._NOT_in_element898);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._element_in_element900);
+				element();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 5:
+				// Grammars\\AssignTokenTypesWalker.g3:299:4: ^( RANGE atom atom )
+				{
+				Match(input,RANGE,Follow._RANGE_in_element907);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._atom_in_element909);
+				atom();
+
+				state._fsp--;
+
+				PushFollow(Follow._atom_in_element911);
+				atom();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 6:
+				// Grammars\\AssignTokenTypesWalker.g3:300:4: ^( CHAR_RANGE atom atom )
+				{
+				Match(input,CHAR_RANGE,Follow._CHAR_RANGE_in_element918);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._atom_in_element920);
+				atom();
+
+				state._fsp--;
+
+				PushFollow(Follow._atom_in_element922);
+				atom();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 7:
+				// Grammars\\AssignTokenTypesWalker.g3:301:4: ^( ASSIGN ID element )
+				{
+				Match(input,ASSIGN,Follow._ASSIGN_in_element929);
+
+				Match(input, TokenConstants.DOWN, null);
+				Match(input,ID,Follow._ID_in_element931);
+				PushFollow(Follow._element_in_element933);
+				element();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 8:
+				// Grammars\\AssignTokenTypesWalker.g3:302:4: ^( PLUS_ASSIGN ID element )
+				{
+				Match(input,PLUS_ASSIGN,Follow._PLUS_ASSIGN_in_element940);
+
+				Match(input, TokenConstants.DOWN, null);
+				Match(input,ID,Follow._ID_in_element942);
+				PushFollow(Follow._element_in_element944);
+				element();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 9:
+				// Grammars\\AssignTokenTypesWalker.g3:303:4: ebnf
+				{
+				PushFollow(Follow._ebnf_in_element950);
+				ebnf();
+
+				state._fsp--;
+
+
+				}
+				break;
+			case 10:
+				// Grammars\\AssignTokenTypesWalker.g3:304:4: tree_
+				{
+				PushFollow(Follow._tree__in_element955);
+				tree_();
+
+				state._fsp--;
+
+
+				}
+				break;
+			case 11:
+				// Grammars\\AssignTokenTypesWalker.g3:305:4: ^( SYNPRED block )
+				{
+				Match(input,SYNPRED,Follow._SYNPRED_in_element962);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._block_in_element964);
+				block();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 12:
+				// Grammars\\AssignTokenTypesWalker.g3:306:4: FORCED_ACTION
+				{
+				Match(input,FORCED_ACTION,Follow._FORCED_ACTION_in_element971);
+
+				}
+				break;
+			case 13:
+				// Grammars\\AssignTokenTypesWalker.g3:307:4: ACTION
+				{
+				Match(input,ACTION,Follow._ACTION_in_element976);
+
+				}
+				break;
+			case 14:
+				// Grammars\\AssignTokenTypesWalker.g3:308:4: SEMPRED
+				{
+				Match(input,SEMPRED,Follow._SEMPRED_in_element981);
+
+				}
+				break;
+			case 15:
+				// Grammars\\AssignTokenTypesWalker.g3:309:4: SYN_SEMPRED
+				{
+				Match(input,SYN_SEMPRED,Follow._SYN_SEMPRED_in_element986);
+
+				}
+				break;
+			case 16:
+				// Grammars\\AssignTokenTypesWalker.g3:310:4: ^( BACKTRACK_SEMPRED ( . )* )
+				{
+				Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_element992);
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null);
+					// Grammars\\AssignTokenTypesWalker.g3:310:24: ( . )*
+					for ( ; ; )
+					{
+						int alt41=2;
+						int LA41_0 = input.LA(1);
+
+						if ( ((LA41_0>=ACTION && LA41_0<=CHARSET)) )
+						{
+							alt41=1;
+						}
+						else if ( (LA41_0==UP) )
+						{
+							alt41=2;
+						}
+
+
+						switch ( alt41 )
+						{
+						case 1:
+							// Grammars\\AssignTokenTypesWalker.g3:310:0: .
+							{
+							MatchAny(input);
+
+							}
+							break;
+
+						default:
+							goto loop41;
+						}
+					}
+
+					loop41:
+						;
+
+
+
+					Match(input, TokenConstants.UP, null);
+				}
+
+				}
+				break;
+			case 17:
+				// Grammars\\AssignTokenTypesWalker.g3:311:4: GATED_SEMPRED
+				{
+				Match(input,GATED_SEMPRED,Follow._GATED_SEMPRED_in_element1001);
+
+				}
+				break;
+			case 18:
+				// Grammars\\AssignTokenTypesWalker.g3:312:4: EPSILON
+				{
+				Match(input,EPSILON,Follow._EPSILON_in_element1006);
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "element"
+
+
+	// $ANTLR start "ebnf"
+	// Grammars\\AssignTokenTypesWalker.g3:315:0: ebnf : ( block | ^( OPTIONAL block ) | ^( CLOSURE block ) | ^( POSITIVE_CLOSURE block ) );
+	private void ebnf(  )
+	{
+		try
+		{
+			// Grammars\\AssignTokenTypesWalker.g3:316:4: ( block | ^( OPTIONAL block ) | ^( CLOSURE block ) | ^( POSITIVE_CLOSURE block ) )
+			int alt43=4;
+			switch ( input.LA(1) )
+			{
+			case BLOCK:
+				{
+				alt43=1;
+				}
+				break;
+			case OPTIONAL:
+				{
+				alt43=2;
+				}
+				break;
+			case CLOSURE:
+				{
+				alt43=3;
+				}
+				break;
+			case POSITIVE_CLOSURE:
+				{
+				alt43=4;
+				}
+				break;
+			default:
+				{
+					NoViableAltException nvae = new NoViableAltException("", 43, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt43 )
+			{
+			case 1:
+				// Grammars\\AssignTokenTypesWalker.g3:316:4: block
+				{
+				PushFollow(Follow._block_in_ebnf1017);
+				block();
+
+				state._fsp--;
+
+
+				}
+				break;
+			case 2:
+				// Grammars\\AssignTokenTypesWalker.g3:317:4: ^( OPTIONAL block )
+				{
+				Match(input,OPTIONAL,Follow._OPTIONAL_in_ebnf1024);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._block_in_ebnf1026);
+				block();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 3:
+				// Grammars\\AssignTokenTypesWalker.g3:318:4: ^( CLOSURE block )
+				{
+				Match(input,CLOSURE,Follow._CLOSURE_in_ebnf1035);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._block_in_ebnf1037);
+				block();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 4:
+				// Grammars\\AssignTokenTypesWalker.g3:319:4: ^( POSITIVE_CLOSURE block )
+				{
+				Match(input,POSITIVE_CLOSURE,Follow._POSITIVE_CLOSURE_in_ebnf1046);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._block_in_ebnf1048);
+				block();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "ebnf"
+
+
+	// $ANTLR start "tree_"
+	// Grammars\\AssignTokenTypesWalker.g3:322:0: tree_ : ^( TREE_BEGIN ( element )+ ) ;
+	private void tree_(  )
+	{
+		try
+		{
+			// Grammars\\AssignTokenTypesWalker.g3:323:4: ( ^( TREE_BEGIN ( element )+ ) )
+			// Grammars\\AssignTokenTypesWalker.g3:323:4: ^( TREE_BEGIN ( element )+ )
+			{
+			Match(input,TREE_BEGIN,Follow._TREE_BEGIN_in_tree_1062);
+
+			Match(input, TokenConstants.DOWN, null);
+			// Grammars\\AssignTokenTypesWalker.g3:323:17: ( element )+
+			int cnt44=0;
+			for ( ; ; )
+			{
+				int alt44=2;
+				int LA44_0 = input.LA(1);
+
+				if ( (LA44_0==ACTION||(LA44_0>=ASSIGN && LA44_0<=BLOCK)||(LA44_0>=CHAR_LITERAL && LA44_0<=CHAR_RANGE)||LA44_0==CLOSURE||LA44_0==DOT||LA44_0==EPSILON||LA44_0==FORCED_ACTION||LA44_0==GATED_SEMPRED||LA44_0==NOT||LA44_0==OPTIONAL||(LA44_0>=PLUS_ASSIGN && LA44_0<=POSITIVE_CLOSURE)||LA44_0==RANGE||LA44_0==ROOT||LA44_0==RULE_REF||LA44_0==SEMPRED||(LA44_0>=STRING_LITERAL && LA44_0<=SYNPRED)||LA44_0==TOKEN_REF||LA44_0==TREE_BEGIN||LA44_0==WILDCARD) )
+				{
+					alt44=1;
+				}
+
+
+				switch ( alt44 )
+				{
+				case 1:
+					// Grammars\\AssignTokenTypesWalker.g3:323:0: element
+					{
+					PushFollow(Follow._element_in_tree_1064);
+					element();
+
+					state._fsp--;
+
+
+					}
+					break;
+
+				default:
+					if ( cnt44 >= 1 )
+						goto loop44;
+
+					EarlyExitException eee44 = new EarlyExitException( 44, input );
+					throw eee44;
+				}
+				cnt44++;
+			}
+			loop44:
+				;
+
+
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "tree_"
+
+
+	// $ANTLR start "atom"
+	// Grammars\\AssignTokenTypesWalker.g3:326:0: atom : ( ^( RULE_REF ( ARG_ACTION )? ) | ^(t= TOKEN_REF ( ARG_ACTION )? ) |c= CHAR_LITERAL |s= STRING_LITERAL | WILDCARD | ^( DOT ID atom ) );
+	private void atom(  )
+	{
+		GrammarAST t=null;
+		GrammarAST c=null;
+		GrammarAST s=null;
+
+		try
+		{
+			// Grammars\\AssignTokenTypesWalker.g3:327:4: ( ^( RULE_REF ( ARG_ACTION )? ) | ^(t= TOKEN_REF ( ARG_ACTION )? ) |c= CHAR_LITERAL |s= STRING_LITERAL | WILDCARD | ^( DOT ID atom ) )
+			int alt47=6;
+			switch ( input.LA(1) )
+			{
+			case RULE_REF:
+				{
+				alt47=1;
+				}
+				break;
+			case TOKEN_REF:
+				{
+				alt47=2;
+				}
+				break;
+			case CHAR_LITERAL:
+				{
+				alt47=3;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt47=4;
+				}
+				break;
+			case WILDCARD:
+				{
+				alt47=5;
+				}
+				break;
+			case DOT:
+				{
+				alt47=6;
+				}
+				break;
+			default:
+				{
+					NoViableAltException nvae = new NoViableAltException("", 47, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt47 )
+			{
+			case 1:
+				// Grammars\\AssignTokenTypesWalker.g3:327:4: ^( RULE_REF ( ARG_ACTION )? )
+				{
+				Match(input,RULE_REF,Follow._RULE_REF_in_atom1079);
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null);
+					// Grammars\\AssignTokenTypesWalker.g3:327:16: ( ARG_ACTION )?
+					int alt45=2;
+					int LA45_0 = input.LA(1);
+
+					if ( (LA45_0==ARG_ACTION) )
+					{
+						alt45=1;
+					}
+					switch ( alt45 )
+					{
+					case 1:
+						// Grammars\\AssignTokenTypesWalker.g3:327:17: ARG_ACTION
+						{
+						Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1082);
+
+						}
+						break;
+
+					}
+
+
+					Match(input, TokenConstants.UP, null);
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\AssignTokenTypesWalker.g3:328:4: ^(t= TOKEN_REF ( ARG_ACTION )? )
+				{
+				t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_atom1095);
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null);
+					// Grammars\\AssignTokenTypesWalker.g3:328:19: ( ARG_ACTION )?
+					int alt46=2;
+					int LA46_0 = input.LA(1);
+
+					if ( (LA46_0==ARG_ACTION) )
+					{
+						alt46=1;
+					}
+					switch ( alt46 )
+					{
+					case 1:
+						// Grammars\\AssignTokenTypesWalker.g3:328:20: ARG_ACTION
+						{
+						Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1098);
+
+						}
+						break;
+
+					}
+
+
+					Match(input, TokenConstants.UP, null);
+				}
+				trackToken(t);
+
+				}
+				break;
+			case 3:
+				// Grammars\\AssignTokenTypesWalker.g3:329:4: c= CHAR_LITERAL
+				{
+				c=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_atom1112);
+				trackString(c);
+
+				}
+				break;
+			case 4:
+				// Grammars\\AssignTokenTypesWalker.g3:330:4: s= STRING_LITERAL
+				{
+				s=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_atom1123);
+				trackString(s);
+
+				}
+				break;
+			case 5:
+				// Grammars\\AssignTokenTypesWalker.g3:331:4: WILDCARD
+				{
+				Match(input,WILDCARD,Follow._WILDCARD_in_atom1130);
+
+				}
+				break;
+			case 6:
+				// Grammars\\AssignTokenTypesWalker.g3:332:4: ^( DOT ID atom )
+				{
+				Match(input,DOT,Follow._DOT_in_atom1136);
+
+				Match(input, TokenConstants.DOWN, null);
+				Match(input,ID,Follow._ID_in_atom1138);
+				PushFollow(Follow._atom_in_atom1140);
+				atom();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "atom"
+
+
+	// $ANTLR start "ast_suffix"
+	// Grammars\\AssignTokenTypesWalker.g3:335:0: ast_suffix : ( ROOT | BANG );
+	private void ast_suffix(  )
+	{
+		try
+		{
+			// Grammars\\AssignTokenTypesWalker.g3:336:4: ( ROOT | BANG )
+			// Grammars\\AssignTokenTypesWalker.g3:
+			{
+			if ( input.LA(1)==BANG||input.LA(1)==ROOT )
+			{
+				input.Consume();
+				state.errorRecovery=false;
+			}
+			else
+			{
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				throw mse;
+			}
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "ast_suffix"
+	#endregion
+
+	// Delegated rules
+
+	#region Synpreds
+	#endregion
+
+	#region DFA
+
+	protected override void InitDFAs()
+	{
+		base.InitDFAs();
+	}
+
+	#endregion
+
+	#region Follow Sets
+	public static class Follow
+	{
+		public static readonly BitSet _LEXER_GRAMMAR_in_grammar_68 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _grammarSpec_in_grammar_73 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _PARSER_GRAMMAR_in_grammar_83 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _grammarSpec_in_grammar_87 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _TREE_GRAMMAR_in_grammar_97 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _grammarSpec_in_grammar_103 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _COMBINED_GRAMMAR_in_grammar_113 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _grammarSpec_in_grammar_115 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ID_in_grammarSpec134 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
+		public static readonly BitSet _DOC_COMMENT_in_grammarSpec141 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
+		public static readonly BitSet _optionsSpec_in_grammarSpec148 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
+		public static readonly BitSet _delegateGrammars_in_grammarSpec155 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
+		public static readonly BitSet _tokensSpec_in_grammarSpec162 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
+		public static readonly BitSet _attrScope_in_grammarSpec169 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
+		public static readonly BitSet _AMPERSAND_in_grammarSpec178 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _rules_in_grammarSpec190 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _SCOPE_in_attrScope203 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_attrScope205 = new BitSet(new ulong[]{0x210UL});
+		public static readonly BitSet _AMPERSAND_in_attrScope210 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ACTION_in_attrScope219 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _OPTIONS_in_optionsSpec238 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _option_in_optionsSpec241 = new BitSet(new ulong[]{0x2008UL});
+		public static readonly BitSet _ASSIGN_in_option260 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_option262 = new BitSet(new ulong[]{0x880000040000UL,0x200000UL});
+		public static readonly BitSet _optionValue_in_option264 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ID_in_optionValue290 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _STRING_LITERAL_in_optionValue295 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _CHAR_LITERAL_in_optionValue300 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _INT_in_optionValue305 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _CHARSET_in_charSet323 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _charSetElement_in_charSet325 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _CHAR_LITERAL_in_charSetElement338 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _OR_in_charSetElement345 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _CHAR_LITERAL_in_charSetElement347 = new BitSet(new ulong[]{0x40000UL});
+		public static readonly BitSet _CHAR_LITERAL_in_charSetElement349 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _RANGE_in_charSetElement358 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _CHAR_LITERAL_in_charSetElement360 = new BitSet(new ulong[]{0x40000UL});
+		public static readonly BitSet _CHAR_LITERAL_in_charSetElement362 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _IMPORT_in_delegateGrammars377 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ASSIGN_in_delegateGrammars385 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_delegateGrammars387 = new BitSet(new ulong[]{0x80000000000UL});
+		public static readonly BitSet _ID_in_delegateGrammars389 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ID_in_delegateGrammars397 = new BitSet(new ulong[]{0x80000002008UL});
+		public static readonly BitSet _TOKENS_in_tokensSpec420 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _tokenSpec_in_tokensSpec422 = new BitSet(new ulong[]{0x2008UL,0x4000000UL});
+		public static readonly BitSet _TOKEN_REF_in_tokenSpec438 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ASSIGN_in_tokenSpec458 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _TOKEN_REF_in_tokenSpec465 = new BitSet(new ulong[]{0x40000UL,0x200000UL});
+		public static readonly BitSet _STRING_LITERAL_in_tokenSpec482 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _CHAR_LITERAL_in_tokenSpec493 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _rule_in_rules517 = new BitSet(new ulong[]{0x400200008000202UL,0x8005000UL});
+		public static readonly BitSet _RULE_in_rule531 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_rule535 = new BitSet(new ulong[]{0x10000000400UL,0xEUL});
+		public static readonly BitSet _modifier_in_rule545 = new BitSet(new ulong[]{0x400UL});
+		public static readonly BitSet _ARG_in_rule553 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_ACTION_in_rule556 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _RET_in_rule565 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_ACTION_in_rule568 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _throwsSpec_in_rule577 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
+		public static readonly BitSet _optionsSpec_in_rule585 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
+		public static readonly BitSet _ruleScopeSpec_in_rule593 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
+		public static readonly BitSet _AMPERSAND_in_rule603 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _block_in_rule617 = new BitSet(new ulong[]{0x4400020000UL});
+		public static readonly BitSet _exceptionGroup_in_rule623 = new BitSet(new ulong[]{0x400000000UL});
+		public static readonly BitSet _EOR_in_rule630 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _set_in_modifier650 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _THROWS_in_throwsSpec677 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_throwsSpec679 = new BitSet(new ulong[]{0x80000000008UL});
+		public static readonly BitSet _SCOPE_in_ruleScopeSpec694 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _AMPERSAND_in_ruleScopeSpec699 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ACTION_in_ruleScopeSpec709 = new BitSet(new ulong[]{0x80000000008UL});
+		public static readonly BitSet _ID_in_ruleScopeSpec715 = new BitSet(new ulong[]{0x80000000008UL});
+		public static readonly BitSet _BLOCK_in_block733 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _optionsSpec_in_block739 = new BitSet(new ulong[]{0x100UL});
+		public static readonly BitSet _alternative_in_block748 = new BitSet(new ulong[]{0x200000100UL,0x200UL});
+		public static readonly BitSet _rewrite_in_block750 = new BitSet(new ulong[]{0x200000100UL});
+		public static readonly BitSet _EOB_in_block758 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ALT_in_alternative775 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _element_in_alternative778 = new BitSet(new ulong[]{0x86800289202DE210UL,0xA4E16421UL});
+		public static readonly BitSet _EOA_in_alternative782 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _exceptionHandler_in_exceptionGroup797 = new BitSet(new ulong[]{0x4000020002UL});
+		public static readonly BitSet _finallyClause_in_exceptionGroup803 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _finallyClause_in_exceptionGroup810 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _CATCH_in_exceptionHandler822 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_ACTION_in_exceptionHandler824 = new BitSet(new ulong[]{0x10UL});
+		public static readonly BitSet _ACTION_in_exceptionHandler826 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _FINALLY_in_finallyClause839 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ACTION_in_finallyClause841 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _REWRITE_in_rewrite856 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ROOT_in_element875 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _element_in_element877 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _BANG_in_element884 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _element_in_element886 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _atom_in_element892 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _NOT_in_element898 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _element_in_element900 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _RANGE_in_element907 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _atom_in_element909 = new BitSet(new ulong[]{0x20040000UL,0x84202000UL});
+		public static readonly BitSet _atom_in_element911 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _CHAR_RANGE_in_element918 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _atom_in_element920 = new BitSet(new ulong[]{0x20040000UL,0x84202000UL});
+		public static readonly BitSet _atom_in_element922 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ASSIGN_in_element929 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_element931 = new BitSet(new ulong[]{0x86800289202DE210UL,0xA4E16421UL});
+		public static readonly BitSet _element_in_element933 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _PLUS_ASSIGN_in_element940 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_element942 = new BitSet(new ulong[]{0x86800289202DE210UL,0xA4E16421UL});
+		public static readonly BitSet _element_in_element944 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ebnf_in_element950 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _tree__in_element955 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _SYNPRED_in_element962 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _block_in_element964 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _FORCED_ACTION_in_element971 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ACTION_in_element976 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _SEMPRED_in_element981 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _SYN_SEMPRED_in_element986 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _BACKTRACK_SEMPRED_in_element992 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _GATED_SEMPRED_in_element1001 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _EPSILON_in_element1006 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _block_in_ebnf1017 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _OPTIONAL_in_ebnf1024 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _block_in_ebnf1026 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _CLOSURE_in_ebnf1035 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _block_in_ebnf1037 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _POSITIVE_CLOSURE_in_ebnf1046 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _block_in_ebnf1048 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _TREE_BEGIN_in_tree_1062 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _element_in_tree_1064 = new BitSet(new ulong[]{0x86800289202DE218UL,0xA4E16421UL});
+		public static readonly BitSet _RULE_REF_in_atom1079 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_ACTION_in_atom1082 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _TOKEN_REF_in_atom1095 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_ACTION_in_atom1098 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _CHAR_LITERAL_in_atom1112 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _STRING_LITERAL_in_atom1123 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _WILDCARD_in_atom1130 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _DOT_in_atom1136 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_atom1138 = new BitSet(new ulong[]{0x20040000UL,0x84202000UL});
+		public static readonly BitSet _atom_in_atom1140 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _set_in_ast_suffix1153 = new BitSet(new ulong[]{0x2UL});
+
+	}
+	#endregion
+}
+
+} // namespace Antlr3.Grammars
diff --git a/Antlr3/Grammars/AssignTokenTypesWalker.g3 b/Antlr3/Grammars/AssignTokenTypesWalker.g3
new file mode 100644
index 0000000..cc3107b
--- /dev/null
+++ b/Antlr3/Grammars/AssignTokenTypesWalker.g3
@@ -0,0 +1,338 @@
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/** [Warning: TJP says that this is probably out of date as of 11/19/2005,
+ *   but since it's probably still useful, I'll leave in.  Don't have energy
+ *   to update at the moment.]
+ *
+ *  Compute the token types for all literals and rules etc..  There are
+ *  a few different cases to consider for grammar types and a few situations
+ *  within.
+ *
+ *  CASE 1 : pure parser grammar
+ *	a) Any reference to a token gets a token type.
+ *  b) The tokens section may alias a token name to a string or char
+ *
+ *  CASE 2 : pure lexer grammar
+ *  a) Import token vocabulary if available. Set token types for any new tokens
+ *     to values above last imported token type
+ *  b) token rule definitions get token types if not already defined
+ *  c) literals do NOT get token types
+ *
+ *  CASE 3 : merged parser / lexer grammar
+ *	a) Any char or string literal gets a token type in a parser rule
+ *  b) Any reference to a token gets a token type if not referencing
+ *     a fragment lexer rule
+ *  c) The tokens section may alias a token name to a string or char
+ *     which must add a rule to the lexer
+ *  d) token rule definitions get token types if not already defined
+ *  e) token rule definitions may also alias a token name to a literal.
+ *     E.g., Rule 'FOR : "for";' will alias FOR to "for" in the sense that
+ *     references to either in the parser grammar will yield the token type
+ *
+ *  What this pass does:
+ *
+ *  0. Collects basic info about the grammar like grammar name and type;
+ *     Oh, I have go get the options in case they affect the token types.
+ *     E.g., tokenVocab option.
+ *     Imports any token vocab name/type pairs into a local hashtable.
+ *  1. Finds a list of all literals and token names.
+ *  2. Finds a list of all token name rule definitions;
+ *     no token rules implies pure parser.
+ *  3. Finds a list of all simple token rule defs of form "<NAME> : <literal>;"
+ *     and aliases them.
+ *  4. Walks token names table and assign types to any unassigned
+ *  5. Walks aliases and assign types to referenced literals
+ *  6. Walks literals, assigning types if untyped
+ *  4. Informs the Grammar object of the type definitions such as:
+ *     g.defineToken(<charliteral>, ttype);
+ *     g.defineToken(<stringliteral>, ttype);
+ *     g.defineToken(<tokenID>, ttype);
+ *     where some of the ttype values will be the same for aliases tokens.
+ */
+tree grammar AssignTokenTypesWalker;
+
+options
+{
+	language=CSharp3;
+	tokenVocab = ANTLR;
+	ASTLabelType = GrammarAST;
+}
+
+@namespace{Antlr3.Grammars}
+
+@header
+{
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+using System;
+using Antlr3.Analysis;
+using Antlr3.Misc;
+using Antlr3.Tool;
+
+using BitSet = Antlr.Runtime.BitSet;
+using DFA = Antlr.Runtime.DFA;
+using HashMap = System.Collections.Generic.Dictionary<object, object>;
+using Map = System.Collections.IDictionary;
+}
+
+public
+grammar_[Grammar g]
+@init
+{
+	if ( state.backtracking == 0 )
+		init($g);
+}
+	:	(	^( LEXER_GRAMMAR 	  grammarSpec )
+		|	^( PARSER_GRAMMAR   grammarSpec )
+		|	^( TREE_GRAMMAR     grammarSpec )
+		|	^( COMBINED_GRAMMAR grammarSpec )
+		)
+	;
+
+grammarSpec
+	:	id=ID
+		(cmt=DOC_COMMENT)?
+		(optionsSpec)?
+		(delegateGrammars)?
+		(tokensSpec)?
+		(attrScope)*
+		( ^(AMPERSAND .*) )* // skip actions
+		rules
+	;
+
+attrScope
+	:	^( 'scope' ID ( ^(AMPERSAND .*) )* ACTION )
+	;
+
+optionsSpec returns [Map opts=new HashMap()]
+	:	^( OPTIONS (option[$opts])+ )
+	;
+
+option[Map opts]
+	:	^( ASSIGN ID optionValue )
+		{
+			string key = $ID.text;
+			$opts[key] = $optionValue.value;
+			// check for grammar-level option to import vocabulary
+			if ( currentRuleName==null && key.Equals("tokenVocab") )
+			{
+				grammar.importTokenVocabulary($ID,(string)$optionValue.value);
+			}
+		}
+	;
+
+optionValue returns [Object value=null]
+@init
+{
+	if ( state.backtracking == 0 )
+		$value = $start.Text;
+}
+	:	ID
+	|	STRING_LITERAL
+	|	CHAR_LITERAL
+	|	INT
+		{ $value = int.Parse( $INT.text ); }
+//  |   cs=charSet       {$value = $cs;} // return set AST in this case
+	;
+
+charSet
+	:	^( CHARSET charSetElement )
+	;
+
+charSetElement
+	:	CHAR_LITERAL
+	|	^( OR CHAR_LITERAL CHAR_LITERAL )
+	|	^( RANGE CHAR_LITERAL CHAR_LITERAL )
+	;
+
+delegateGrammars
+	:	^(	'import'
+			(	^(ASSIGN ID ID)
+			|	ID
+			)+
+		)
+	;
+
+tokensSpec
+	:	^( TOKENS tokenSpec+ )
+	;
+
+tokenSpec
+	:	t=TOKEN_REF            {trackToken($t);}
+	|	^(	ASSIGN
+			t2=TOKEN_REF       {trackToken($t2);}
+			( s=STRING_LITERAL {trackString($s); alias($t2,$s);}
+			| c=CHAR_LITERAL   {trackString($c); alias($t2,$c);}
+			)
+		)
+	;
+
+rules
+	:	rule+
+	;
+
+rule
+	:	^(	RULE id=ID {currentRuleName=$id.text;}
+			(m=modifier)?
+			^(ARG (ARG_ACTION)?)
+			^(RET (ARG_ACTION)?)
+			(throwsSpec)?
+			(optionsSpec)?
+			(ruleScopeSpec)?
+			( ^(AMPERSAND .*) )*
+			b=block
+			(exceptionGroup)?
+			EOR
+			{trackTokenRule($id,$m.start,$b.start);}
+		)
+	;
+
+modifier
+	:	'protected'
+	|	'public'
+	|	'private'
+	|	'fragment'
+	;
+
+throwsSpec
+	:	^('throws' ID+)
+	;
+
+ruleScopeSpec
+	:	^( 'scope' ( ^(AMPERSAND .*) )* (ACTION)? ( ID )* )
+	;
+
+block
+	:	^(	BLOCK
+			(optionsSpec)?
+			( alternative rewrite )+
+			EOB
+		)
+	;
+
+alternative
+	:	^( ALT (element)+ EOA )
+	;
+
+exceptionGroup
+	:	( exceptionHandler )+ (finallyClause)?
+	|	finallyClause
+	;
+
+exceptionHandler
+	:	^('catch' ARG_ACTION ACTION)
+	;
+
+finallyClause
+	:	^('finally' ACTION)
+	;
+
+rewrite
+	:	( ^(REWRITE .*) )*
+	;
+
+element
+	:	^(ROOT element)
+	|	^(BANG element)
+	|	atom
+	|	^(NOT element)
+	|	^(RANGE atom atom)
+	|	^(CHAR_RANGE atom atom)
+	|	^(ASSIGN ID element)
+	|	^(PLUS_ASSIGN ID element)
+	|	ebnf
+	|	tree_
+	|	^( SYNPRED block )
+	|	FORCED_ACTION
+	|	ACTION
+	|	SEMPRED
+	|	SYN_SEMPRED
+	|	^(BACKTRACK_SEMPRED .*)
+	|	GATED_SEMPRED
+	|	EPSILON
+	;
+
+ebnf
+	:	block
+	|	^( OPTIONAL block )
+	|	^( CLOSURE block )
+	|	^( POSITIVE_CLOSURE block )
+	;
+
+tree_
+	:	^(TREE_BEGIN element+)
+	;
+
+atom
+	:	^( RULE_REF (ARG_ACTION)? )
+	|	^( t=TOKEN_REF (ARG_ACTION )? ) {trackToken($t);}
+	|	c=CHAR_LITERAL   {trackString($c);}
+	|	s=STRING_LITERAL {trackString($s);}
+	|	WILDCARD
+	|	^(DOT ID atom) // scope override on rule
+	;
+
+ast_suffix
+	:	ROOT
+	|	BANG
+	;
diff --git a/Antlr3/Grammars/AssignTokenTypesWalkerHelper.cs b/Antlr3/Grammars/AssignTokenTypesWalkerHelper.cs
new file mode 100644
index 0000000..9dceb34
--- /dev/null
+++ b/Antlr3/Grammars/AssignTokenTypesWalkerHelper.cs
@@ -0,0 +1,160 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Grammar conversion to ANTLR v3 and C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *	notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	notice, this list of conditions and the following disclaimer in the
+ *	documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *	derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Grammars
+{
+    using System;
+    using Antlr.Runtime;
+    using Antlr.Runtime.Tree;
+    using Antlr3.Tool;
+
+    partial class AssignTokenTypesWalker
+    {
+        protected internal Grammar grammar;
+        protected String currentRuleName;
+
+        protected static GrammarAST stringAlias;
+        protected static GrammarAST charAlias;
+        protected static GrammarAST stringAlias2;
+        protected static GrammarAST charAlias2;
+
+        public override void ReportError( RecognitionException ex )
+        {
+            IToken token = null;
+            if ( ex is MismatchedTokenException )
+            {
+                token = ( (MismatchedTokenException)ex ).token;
+            }
+            else if ( ex is NoViableAltException )
+            {
+                token = ( (NoViableAltException)ex ).token;
+            }
+            ErrorManager.syntaxError(
+                ErrorManager.MSG_SYNTAX_ERROR,
+                grammar,
+                token,
+                "assign.types: " + ex.ToString(),
+                ex );
+        }
+
+
+        protected void initASTPatterns()
+        {
+            ITreeAdaptor adaptor = new ANTLRParser.grammar_Adaptor( null );
+
+            /*
+             * stringAlias = ^(BLOCK[] ^(ALT[] STRING_LITERAL[] EOA[]) EOB[])
+             */
+            stringAlias = (GrammarAST)adaptor.Create( BLOCK, "BLOCK" );
+            {
+                GrammarAST alt = (GrammarAST)adaptor.Create( ALT, "ALT" );
+                adaptor.AddChild( alt, adaptor.Create( STRING_LITERAL, "STRING_LITERAL" ) );
+                adaptor.AddChild( alt, adaptor.Create( EOA, "EOA" ) );
+                adaptor.AddChild( stringAlias, alt );
+            }
+            adaptor.AddChild( stringAlias, adaptor.Create( EOB, "EOB" ) );
+
+            /*
+             * charAlias = ^(BLOCK[] ^(ALT[] CHAR_LITERAL[] EOA[]) EOB[])
+             */
+            charAlias = (GrammarAST)adaptor.Create( BLOCK, "BLOCK" );
+            {
+                GrammarAST alt = (GrammarAST)adaptor.Create( ALT, "ALT" );
+                adaptor.AddChild( alt, adaptor.Create( CHAR_LITERAL, "CHAR_LITERAL" ) );
+                adaptor.AddChild( alt, adaptor.Create( EOA, "EOA" ) );
+                adaptor.AddChild( charAlias, alt );
+            }
+            adaptor.AddChild( charAlias, adaptor.Create( EOB, "EOB" ) );
+
+            /*
+             * stringAlias2 = ^(BLOCK[] ^(ALT[] STRING_LITERAL[] ACTION[] EOA[]) EOB[])
+             */
+            stringAlias2 = (GrammarAST)adaptor.Create( BLOCK, "BLOCK" );
+            {
+                GrammarAST alt = (GrammarAST)adaptor.Create( ALT, "ALT" );
+                adaptor.AddChild( alt, adaptor.Create( STRING_LITERAL, "STRING_LITERAL" ) );
+                adaptor.AddChild( alt, adaptor.Create( ACTION, "ACTION" ) );
+                adaptor.AddChild( alt, adaptor.Create( EOA, "EOA" ) );
+                adaptor.AddChild( stringAlias2, alt );
+            }
+            adaptor.AddChild( stringAlias2, adaptor.Create( EOB, "EOB" ) );
+
+            /*
+             * charAlias = ^(BLOCK[] ^(ALT[] CHAR_LITERAL[] ACTION[] EOA[]) EOB[])
+             */
+            charAlias2 = (GrammarAST)adaptor.Create( BLOCK, "BLOCK" );
+            {
+                GrammarAST alt = (GrammarAST)adaptor.Create( ALT, "ALT" );
+                adaptor.AddChild( alt, adaptor.Create( CHAR_LITERAL, "CHAR_LITERAL" ) );
+                adaptor.AddChild( alt, adaptor.Create( ACTION, "ACTION" ) );
+                adaptor.AddChild( alt, adaptor.Create( EOA, "EOA" ) );
+                adaptor.AddChild( charAlias2, alt );
+            }
+            adaptor.AddChild( charAlias2, adaptor.Create( EOB, "EOB" ) );
+        }
+
+        // Behavior moved to AssignTokenTypesBehavior
+        protected virtual void trackString( GrammarAST t )
+        {
+        }
+        protected virtual void trackToken( GrammarAST t )
+        {
+        }
+        protected virtual void trackTokenRule( GrammarAST t, GrammarAST modifier, GrammarAST block )
+        {
+        }
+        protected virtual void alias( GrammarAST t, GrammarAST s )
+        {
+        }
+        protected internal virtual void defineTokens( Grammar root )
+        {
+        }
+        protected virtual void defineStringLiteralsFromDelegates()
+        {
+        }
+        protected virtual void assignStringTypes( Grammar root )
+        {
+        }
+        protected virtual void aliasTokenIDsAndLiterals( Grammar root )
+        {
+        }
+        protected virtual void assignTokenIDTypes( Grammar root )
+        {
+        }
+        protected virtual void defineTokenNamesAndLiteralsInGrammar( Grammar root )
+        {
+        }
+        protected virtual void init( Grammar root )
+        {
+        }
+    }
+}
diff --git a/Antlr3/Grammars/CodeGenTreeWalker.cs b/Antlr3/Grammars/CodeGenTreeWalker.cs
new file mode 100644
index 0000000..60b6079
--- /dev/null
+++ b/Antlr3/Grammars/CodeGenTreeWalker.cs
@@ -0,0 +1,6173 @@
+// $ANTLR 3.1.2 Grammars\\CodeGenTreeWalker.g3 2009-03-08 16:36:01
+
+// The variable 'variable' is assigned but its value is never used.
+#pragma warning disable 219
+// Unreachable code detected.
+#pragma warning disable 162
+
+
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+using Antlr3.Analysis;
+using Antlr3.Misc;
+using Antlr3.Tool;
+
+using BitSet = Antlr.Runtime.BitSet;
+using DFA = Antlr.Runtime.DFA;
+using StringTemplate = Antlr3.ST.StringTemplate;
+using StringTemplateGroup = Antlr3.ST.StringTemplateGroup;
+using TokenWithIndex = Antlr.Runtime.CommonToken;
+
+
+using System.Collections.Generic;
+using Antlr.Runtime;
+using Antlr.Runtime.Tree;
+using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;using Stack = System.Collections.Generic.Stack<object>;
+using List = System.Collections.IList;
+using ArrayList = System.Collections.Generic.List<object>;
+using Map = System.Collections.IDictionary;
+using HashMap = System.Collections.Generic.Dictionary<object, object>;
+namespace Antlr3.Grammars
+{
+/** Walk a grammar and generate code by gradually building up
+ *  a bigger and bigger StringTemplate.
+ *
+ *  Terence Parr
+ *  University of San Francisco
+ *  June 15, 2004
+ */
+public partial class CodeGenTreeWalker : TreeParser
+{
+	public static readonly string[] tokenNames = new string[] {
+		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", "ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARG_ACTION", "ARGLIST", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", "CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", "COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", "DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", "EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", "GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", "LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", "NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", "OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", "RET", "RETURNS", "REWRITE", "ROOT", "RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", "SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYN_SEMPRED", "SYNPRED", "TEMPLATE", "THROWS", "TOKEN_REF", "TOKENS", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", "WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT"
+	};
+	public const int EOF=-1;
+	public const int ACTION=4;
+	public const int ACTION_CHAR_LITERAL=5;
+	public const int ACTION_ESC=6;
+	public const int ACTION_STRING_LITERAL=7;
+	public const int ALT=8;
+	public const int AMPERSAND=9;
+	public const int ARG=10;
+	public const int ARG_ACTION=11;
+	public const int ARGLIST=12;
+	public const int ASSIGN=13;
+	public const int BACKTRACK_SEMPRED=14;
+	public const int BANG=15;
+	public const int BLOCK=16;
+	public const int CATCH=17;
+	public const int CHAR_LITERAL=18;
+	public const int CHAR_RANGE=19;
+	public const int CLOSE_ELEMENT_OPTION=20;
+	public const int CLOSURE=21;
+	public const int COLON=22;
+	public const int COMBINED_GRAMMAR=23;
+	public const int COMMA=24;
+	public const int COMMENT=25;
+	public const int DIGIT=26;
+	public const int DOC_COMMENT=27;
+	public const int DOLLAR=28;
+	public const int DOT=29;
+	public const int DOUBLE_ANGLE_STRING_LITERAL=30;
+	public const int DOUBLE_QUOTE_STRING_LITERAL=31;
+	public const int EOA=32;
+	public const int EOB=33;
+	public const int EOR=34;
+	public const int EPSILON=35;
+	public const int ESC=36;
+	public const int ETC=37;
+	public const int FINALLY=38;
+	public const int FORCED_ACTION=39;
+	public const int FRAGMENT=40;
+	public const int GATED_SEMPRED=41;
+	public const int GRAMMAR=42;
+	public const int ID=43;
+	public const int IMPLIES=44;
+	public const int IMPORT=45;
+	public const int INITACTION=46;
+	public const int INT=47;
+	public const int LABEL=48;
+	public const int LEXER=49;
+	public const int LEXER_GRAMMAR=50;
+	public const int LPAREN=51;
+	public const int ML_COMMENT=52;
+	public const int NESTED_ACTION=53;
+	public const int NESTED_ARG_ACTION=54;
+	public const int NOT=55;
+	public const int OPEN_ELEMENT_OPTION=56;
+	public const int OPTIONAL=57;
+	public const int OPTIONS=58;
+	public const int OR=59;
+	public const int PARSER=60;
+	public const int PARSER_GRAMMAR=61;
+	public const int PLUS=62;
+	public const int PLUS_ASSIGN=63;
+	public const int POSITIVE_CLOSURE=64;
+	public const int PRIVATE=65;
+	public const int PROTECTED=66;
+	public const int PUBLIC=67;
+	public const int QUESTION=68;
+	public const int RANGE=69;
+	public const int RCURLY=70;
+	public const int RET=71;
+	public const int RETURNS=72;
+	public const int REWRITE=73;
+	public const int ROOT=74;
+	public const int RPAREN=75;
+	public const int RULE=76;
+	public const int RULE_REF=77;
+	public const int SCOPE=78;
+	public const int SEMI=79;
+	public const int SEMPRED=80;
+	public const int SL_COMMENT=81;
+	public const int SRC=82;
+	public const int STAR=83;
+	public const int STRAY_BRACKET=84;
+	public const int STRING_LITERAL=85;
+	public const int SYN_SEMPRED=86;
+	public const int SYNPRED=87;
+	public const int TEMPLATE=88;
+	public const int THROWS=89;
+	public const int TOKEN_REF=90;
+	public const int TOKENS=91;
+	public const int TREE=92;
+	public const int TREE_BEGIN=93;
+	public const int TREE_GRAMMAR=94;
+	public const int WILDCARD=95;
+	public const int WS=96;
+	public const int WS_LOOP=97;
+	public const int WS_OPT=98;
+	public const int XDIGIT=99;
+
+	// delegates
+	// delegators
+
+	public CodeGenTreeWalker( ITreeNodeStream input )
+		: this( input, new RecognizerSharedState() )
+	{
+	}
+	public CodeGenTreeWalker( ITreeNodeStream input, RecognizerSharedState state )
+		: base( input, state )
+	{
+	}
+
+
+	public override string[] GetTokenNames() { return CodeGenTreeWalker.tokenNames; }
+	public override string GrammarFileName { get { return "Grammars\\CodeGenTreeWalker.g3"; } }
+
+
+	#region Rules
+
+	// $ANTLR start "grammar_"
+	// Grammars\\CodeGenTreeWalker.g3:97:0: public grammar_[Grammar g,\r\n\t\tStringTemplate recognizerST,\r\n\t\tStringTemplate outputFileST,\r\n\t\tStringTemplate headerFileST] : ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) ) ;
+	public void grammar_( Grammar g, StringTemplate recognizerST, StringTemplate outputFileST, StringTemplate headerFileST )
+	{
+
+			if ( state.backtracking == 0 )
+			{
+				init(g);
+				this.recognizerST = recognizerST;
+				this.outputFileST = outputFileST;
+				this.headerFileST = headerFileST;
+				string superClass = (string)g.getOption("superClass");
+				outputOption = (string)g.getOption("output");
+				recognizerST.setAttribute("superClass", superClass);
+				if ( g.type!=Grammar.LEXER ) {
+					recognizerST.setAttribute("ASTLabelType", g.getOption("ASTLabelType"));
+				}
+				if ( g.type==Grammar.TREE_PARSER && g.getOption("ASTLabelType")==null ) {
+					ErrorManager.grammarWarning(ErrorManager.MSG_MISSING_AST_TYPE_IN_TREE_GRAMMAR,
+											   g,
+											   null,
+											   g.name);
+				}
+				if ( g.type!=Grammar.TREE_PARSER ) {
+					recognizerST.setAttribute("labelType", g.getOption("TokenLabelType"));
+				}
+				recognizerST.setAttribute("numRules", grammar.Rules.Count);
+				outputFileST.setAttribute("numRules", grammar.Rules.Count);
+				headerFileST.setAttribute("numRules", grammar.Rules.Count);
+			}
+
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:129:4: ( ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) ) )
+			// Grammars\\CodeGenTreeWalker.g3:129:4: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
+			{
+			// Grammars\\CodeGenTreeWalker.g3:129:4: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
+			int alt1=4;
+			switch ( input.LA(1) )
+			{
+			case LEXER_GRAMMAR:
+				{
+				alt1=1;
+				}
+				break;
+			case PARSER_GRAMMAR:
+				{
+				alt1=2;
+				}
+				break;
+			case TREE_GRAMMAR:
+				{
+				alt1=3;
+				}
+				break;
+			case COMBINED_GRAMMAR:
+				{
+				alt1=4;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return ;}
+					NoViableAltException nvae = new NoViableAltException("", 1, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt1 )
+			{
+			case 1:
+				// Grammars\\CodeGenTreeWalker.g3:129:6: ^( LEXER_GRAMMAR grammarSpec )
+				{
+				Match(input,LEXER_GRAMMAR,Follow._LEXER_GRAMMAR_in_grammar_66); if (state.failed) return ;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+				PushFollow(Follow._grammarSpec_in_grammar_68);
+				grammarSpec();
+
+				state._fsp--;
+				if (state.failed) return ;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return ;
+
+				}
+				break;
+			case 2:
+				// Grammars\\CodeGenTreeWalker.g3:130:5: ^( PARSER_GRAMMAR grammarSpec )
+				{
+				Match(input,PARSER_GRAMMAR,Follow._PARSER_GRAMMAR_in_grammar_78); if (state.failed) return ;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+				PushFollow(Follow._grammarSpec_in_grammar_80);
+				grammarSpec();
+
+				state._fsp--;
+				if (state.failed) return ;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return ;
+
+				}
+				break;
+			case 3:
+				// Grammars\\CodeGenTreeWalker.g3:131:5: ^( TREE_GRAMMAR grammarSpec )
+				{
+				Match(input,TREE_GRAMMAR,Follow._TREE_GRAMMAR_in_grammar_90); if (state.failed) return ;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+				PushFollow(Follow._grammarSpec_in_grammar_92);
+				grammarSpec();
+
+				state._fsp--;
+				if (state.failed) return ;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return ;
+
+				}
+				break;
+			case 4:
+				// Grammars\\CodeGenTreeWalker.g3:132:5: ^( COMBINED_GRAMMAR grammarSpec )
+				{
+				Match(input,COMBINED_GRAMMAR,Follow._COMBINED_GRAMMAR_in_grammar_102); if (state.failed) return ;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+				PushFollow(Follow._grammarSpec_in_grammar_104);
+				grammarSpec();
+
+				state._fsp--;
+				if (state.failed) return ;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "grammar_"
+
+
+	// $ANTLR start "attrScope"
+	// Grammars\\CodeGenTreeWalker.g3:136:0: attrScope : ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION ) ;
+	private void attrScope(  )
+	{
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:137:4: ( ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION ) )
+			// Grammars\\CodeGenTreeWalker.g3:137:4: ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION )
+			{
+			Match(input,SCOPE,Follow._SCOPE_in_attrScope123); if (state.failed) return ;
+
+			Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+			Match(input,ID,Follow._ID_in_attrScope125); if (state.failed) return ;
+			// Grammars\\CodeGenTreeWalker.g3:137:18: ( ^( AMPERSAND ( . )* ) )*
+			for ( ; ; )
+			{
+				int alt3=2;
+				int LA3_0 = input.LA(1);
+
+				if ( (LA3_0==AMPERSAND) )
+				{
+					alt3=1;
+				}
+
+
+				switch ( alt3 )
+				{
+				case 1:
+					// Grammars\\CodeGenTreeWalker.g3:137:20: ^( AMPERSAND ( . )* )
+					{
+					Match(input,AMPERSAND,Follow._AMPERSAND_in_attrScope130); if (state.failed) return ;
+
+					if ( input.LA(1)==TokenConstants.DOWN )
+					{
+						Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+						// Grammars\\CodeGenTreeWalker.g3:137:32: ( . )*
+						for ( ; ; )
+						{
+							int alt2=2;
+							int LA2_0 = input.LA(1);
+
+							if ( ((LA2_0>=ACTION && LA2_0<=XDIGIT)) )
+							{
+								alt2=1;
+							}
+							else if ( (LA2_0==UP) )
+							{
+								alt2=2;
+							}
+
+
+							switch ( alt2 )
+							{
+							case 1:
+								// Grammars\\CodeGenTreeWalker.g3:137:0: .
+								{
+								MatchAny(input); if (state.failed) return ;
+
+								}
+								break;
+
+							default:
+								goto loop2;
+							}
+						}
+
+						loop2:
+							;
+
+
+
+						Match(input, TokenConstants.UP, null); if (state.failed) return ;
+					}
+
+					}
+					break;
+
+				default:
+					goto loop3;
+				}
+			}
+
+			loop3:
+				;
+
+
+			Match(input,ACTION,Follow._ACTION_in_attrScope139); if (state.failed) return ;
+
+			Match(input, TokenConstants.UP, null); if (state.failed) return ;
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "attrScope"
+
+
+	// $ANTLR start "grammarSpec"
+	// Grammars\\CodeGenTreeWalker.g3:140:0: grammarSpec : name= ID (cmt= DOC_COMMENT )? ( ^( OPTIONS ( . )* ) )? ( ^( IMPORT ( . )* ) )? ( ^( TOKENS ( . )* ) )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules[recognizerST] ;
+	private void grammarSpec(  )
+	{
+		GrammarAST name=null;
+		GrammarAST cmt=null;
+
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:141:6: (name= ID (cmt= DOC_COMMENT )? ( ^( OPTIONS ( . )* ) )? ( ^( IMPORT ( . )* ) )? ( ^( TOKENS ( . )* ) )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules[recognizerST] )
+			// Grammars\\CodeGenTreeWalker.g3:141:6: name= ID (cmt= DOC_COMMENT )? ( ^( OPTIONS ( . )* ) )? ( ^( IMPORT ( . )* ) )? ( ^( TOKENS ( . )* ) )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules[recognizerST]
+			{
+			name=(GrammarAST)Match(input,ID,Follow._ID_in_grammarSpec156); if (state.failed) return ;
+			// Grammars\\CodeGenTreeWalker.g3:142:3: (cmt= DOC_COMMENT )?
+			int alt4=2;
+			int LA4_0 = input.LA(1);
+
+			if ( (LA4_0==DOC_COMMENT) )
+			{
+				alt4=1;
+			}
+			switch ( alt4 )
+			{
+			case 1:
+				// Grammars\\CodeGenTreeWalker.g3:142:5: cmt= DOC_COMMENT
+				{
+				cmt=(GrammarAST)Match(input,DOC_COMMENT,Follow._DOC_COMMENT_in_grammarSpec164); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+
+									outputFileST.setAttribute("docComment", (cmt!=null?cmt.Text:null));
+									headerFileST.setAttribute("docComment", (cmt!=null?cmt.Text:null));
+
+				}
+
+				}
+				break;
+
+			}
+
+			if ( state.backtracking == 0 )
+			{
+
+							recognizerST.setAttribute("name", grammar.getRecognizerName());
+							outputFileST.setAttribute("name", grammar.getRecognizerName());
+							headerFileST.setAttribute("name", grammar.getRecognizerName());
+							recognizerST.setAttribute("scopes", grammar.GlobalScopes);
+							headerFileST.setAttribute("scopes", grammar.GlobalScopes);
+
+			}
+			// Grammars\\CodeGenTreeWalker.g3:155:3: ( ^( OPTIONS ( . )* ) )?
+			int alt6=2;
+			int LA6_0 = input.LA(1);
+
+			if ( (LA6_0==OPTIONS) )
+			{
+				alt6=1;
+			}
+			switch ( alt6 )
+			{
+			case 1:
+				// Grammars\\CodeGenTreeWalker.g3:155:5: ^( OPTIONS ( . )* )
+				{
+				Match(input,OPTIONS,Follow._OPTIONS_in_grammarSpec185); if (state.failed) return ;
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+					// Grammars\\CodeGenTreeWalker.g3:155:15: ( . )*
+					for ( ; ; )
+					{
+						int alt5=2;
+						int LA5_0 = input.LA(1);
+
+						if ( ((LA5_0>=ACTION && LA5_0<=XDIGIT)) )
+						{
+							alt5=1;
+						}
+						else if ( (LA5_0==UP) )
+						{
+							alt5=2;
+						}
+
+
+						switch ( alt5 )
+						{
+						case 1:
+							// Grammars\\CodeGenTreeWalker.g3:155:0: .
+							{
+							MatchAny(input); if (state.failed) return ;
+
+							}
+							break;
+
+						default:
+							goto loop5;
+						}
+					}
+
+					loop5:
+						;
+
+
+
+					Match(input, TokenConstants.UP, null); if (state.failed) return ;
+				}
+
+				}
+				break;
+
+			}
+
+			// Grammars\\CodeGenTreeWalker.g3:156:3: ( ^( IMPORT ( . )* ) )?
+			int alt8=2;
+			int LA8_0 = input.LA(1);
+
+			if ( (LA8_0==IMPORT) )
+			{
+				alt8=1;
+			}
+			switch ( alt8 )
+			{
+			case 1:
+				// Grammars\\CodeGenTreeWalker.g3:156:5: ^( IMPORT ( . )* )
+				{
+				Match(input,IMPORT,Follow._IMPORT_in_grammarSpec199); if (state.failed) return ;
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+					// Grammars\\CodeGenTreeWalker.g3:156:14: ( . )*
+					for ( ; ; )
+					{
+						int alt7=2;
+						int LA7_0 = input.LA(1);
+
+						if ( ((LA7_0>=ACTION && LA7_0<=XDIGIT)) )
+						{
+							alt7=1;
+						}
+						else if ( (LA7_0==UP) )
+						{
+							alt7=2;
+						}
+
+
+						switch ( alt7 )
+						{
+						case 1:
+							// Grammars\\CodeGenTreeWalker.g3:156:0: .
+							{
+							MatchAny(input); if (state.failed) return ;
+
+							}
+							break;
+
+						default:
+							goto loop7;
+						}
+					}
+
+					loop7:
+						;
+
+
+
+					Match(input, TokenConstants.UP, null); if (state.failed) return ;
+				}
+
+				}
+				break;
+
+			}
+
+			// Grammars\\CodeGenTreeWalker.g3:157:3: ( ^( TOKENS ( . )* ) )?
+			int alt10=2;
+			int LA10_0 = input.LA(1);
+
+			if ( (LA10_0==TOKENS) )
+			{
+				alt10=1;
+			}
+			switch ( alt10 )
+			{
+			case 1:
+				// Grammars\\CodeGenTreeWalker.g3:157:5: ^( TOKENS ( . )* )
+				{
+				Match(input,TOKENS,Follow._TOKENS_in_grammarSpec213); if (state.failed) return ;
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+					// Grammars\\CodeGenTreeWalker.g3:157:14: ( . )*
+					for ( ; ; )
+					{
+						int alt9=2;
+						int LA9_0 = input.LA(1);
+
+						if ( ((LA9_0>=ACTION && LA9_0<=XDIGIT)) )
+						{
+							alt9=1;
+						}
+						else if ( (LA9_0==UP) )
+						{
+							alt9=2;
+						}
+
+
+						switch ( alt9 )
+						{
+						case 1:
+							// Grammars\\CodeGenTreeWalker.g3:157:0: .
+							{
+							MatchAny(input); if (state.failed) return ;
+
+							}
+							break;
+
+						default:
+							goto loop9;
+						}
+					}
+
+					loop9:
+						;
+
+
+
+					Match(input, TokenConstants.UP, null); if (state.failed) return ;
+				}
+
+				}
+				break;
+
+			}
+
+			// Grammars\\CodeGenTreeWalker.g3:158:3: ( attrScope )*
+			for ( ; ; )
+			{
+				int alt11=2;
+				int LA11_0 = input.LA(1);
+
+				if ( (LA11_0==SCOPE) )
+				{
+					alt11=1;
+				}
+
+
+				switch ( alt11 )
+				{
+				case 1:
+					// Grammars\\CodeGenTreeWalker.g3:158:4: attrScope
+					{
+					PushFollow(Follow._attrScope_in_grammarSpec225);
+					attrScope();
+
+					state._fsp--;
+					if (state.failed) return ;
+
+					}
+					break;
+
+				default:
+					goto loop11;
+				}
+			}
+
+			loop11:
+				;
+
+
+			// Grammars\\CodeGenTreeWalker.g3:159:3: ( ^( AMPERSAND ( . )* ) )*
+			for ( ; ; )
+			{
+				int alt13=2;
+				int LA13_0 = input.LA(1);
+
+				if ( (LA13_0==AMPERSAND) )
+				{
+					alt13=1;
+				}
+
+
+				switch ( alt13 )
+				{
+				case 1:
+					// Grammars\\CodeGenTreeWalker.g3:159:5: ^( AMPERSAND ( . )* )
+					{
+					Match(input,AMPERSAND,Follow._AMPERSAND_in_grammarSpec234); if (state.failed) return ;
+
+					if ( input.LA(1)==TokenConstants.DOWN )
+					{
+						Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+						// Grammars\\CodeGenTreeWalker.g3:159:17: ( . )*
+						for ( ; ; )
+						{
+							int alt12=2;
+							int LA12_0 = input.LA(1);
+
+							if ( ((LA12_0>=ACTION && LA12_0<=XDIGIT)) )
+							{
+								alt12=1;
+							}
+							else if ( (LA12_0==UP) )
+							{
+								alt12=2;
+							}
+
+
+							switch ( alt12 )
+							{
+							case 1:
+								// Grammars\\CodeGenTreeWalker.g3:159:0: .
+								{
+								MatchAny(input); if (state.failed) return ;
+
+								}
+								break;
+
+							default:
+								goto loop12;
+							}
+						}
+
+						loop12:
+							;
+
+
+
+						Match(input, TokenConstants.UP, null); if (state.failed) return ;
+					}
+
+					}
+					break;
+
+				default:
+					goto loop13;
+				}
+			}
+
+			loop13:
+				;
+
+
+			PushFollow(Follow._rules_in_grammarSpec245);
+			rules(recognizerST);
+
+			state._fsp--;
+			if (state.failed) return ;
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "grammarSpec"
+
+
+	// $ANTLR start "rules"
+	// Grammars\\CodeGenTreeWalker.g3:163:0: rules[StringTemplate recognizerST] : ( ( options {k=1; } :{...}? =>rST= rule | ^( RULE ( . )* ) ) )+ ;
+	private void rules( StringTemplate recognizerST )
+	{
+		CodeGenTreeWalker.rule_return rST = default(CodeGenTreeWalker.rule_return);
+
+
+			string ruleName = ((GrammarAST)input.LT(1)).GetChild(0).Text;
+			bool generated = grammar.generateMethodForRule(ruleName);
+
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:169:4: ( ( ( options {k=1; } :{...}? =>rST= rule | ^( RULE ( . )* ) ) )+ )
+			// Grammars\\CodeGenTreeWalker.g3:169:4: ( ( options {k=1; } :{...}? =>rST= rule | ^( RULE ( . )* ) ) )+
+			{
+			// Grammars\\CodeGenTreeWalker.g3:169:4: ( ( options {k=1; } :{...}? =>rST= rule | ^( RULE ( . )* ) ) )+
+			int cnt16=0;
+			for ( ; ; )
+			{
+				int alt16=2;
+				int LA16_0 = input.LA(1);
+
+				if ( (LA16_0==RULE) )
+				{
+					alt16=1;
+				}
+
+
+				switch ( alt16 )
+				{
+				case 1:
+					// Grammars\\CodeGenTreeWalker.g3:169:6: ( options {k=1; } :{...}? =>rST= rule | ^( RULE ( . )* ) )
+					{
+					// Grammars\\CodeGenTreeWalker.g3:169:6: ( options {k=1; } :{...}? =>rST= rule | ^( RULE ( . )* ) )
+					int alt15=2;
+					int LA15_0 = input.LA(1);
+
+					if ( (LA15_0==RULE) )
+					{
+						int LA15_1 = input.LA(2);
+
+						if ( ((generated)) )
+						{
+							alt15=1;
+						}
+						else if ( (true) )
+						{
+							alt15=2;
+						}
+						else
+						{
+							if (state.backtracking>0) {state.failed=true; return ;}
+							NoViableAltException nvae = new NoViableAltException("", 15, 1, input);
+
+							throw nvae;
+						}
+					}
+					else
+					{
+						if (state.backtracking>0) {state.failed=true; return ;}
+						NoViableAltException nvae = new NoViableAltException("", 15, 0, input);
+
+						throw nvae;
+					}
+					switch ( alt15 )
+					{
+					case 1:
+						// Grammars\\CodeGenTreeWalker.g3:170:5: {...}? =>rST= rule
+						{
+						if ( !((generated)) )
+						{
+							if (state.backtracking>0) {state.failed=true; return ;}
+							throw new FailedPredicateException(input, "rules", "generated");
+						}
+						PushFollow(Follow._rule_in_rules290);
+						rST=rule();
+
+						state._fsp--;
+						if (state.failed) return ;
+						if ( state.backtracking == 0 )
+						{
+
+												if ( (rST!=null?rST.code:default(StringTemplate)) != null )
+												{
+													recognizerST.setAttribute("rules", (rST!=null?rST.code:default(StringTemplate)));
+													outputFileST.setAttribute("rules", (rST!=null?rST.code:default(StringTemplate)));
+													headerFileST.setAttribute("rules", (rST!=null?rST.code:default(StringTemplate)));
+												}
+
+						}
+
+						}
+						break;
+					case 2:
+						// Grammars\\CodeGenTreeWalker.g3:180:6: ^( RULE ( . )* )
+						{
+						Match(input,RULE,Follow._RULE_in_rules304); if (state.failed) return ;
+
+						if ( input.LA(1)==TokenConstants.DOWN )
+						{
+							Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+							// Grammars\\CodeGenTreeWalker.g3:180:13: ( . )*
+							for ( ; ; )
+							{
+								int alt14=2;
+								int LA14_0 = input.LA(1);
+
+								if ( ((LA14_0>=ACTION && LA14_0<=XDIGIT)) )
+								{
+									alt14=1;
+								}
+								else if ( (LA14_0==UP) )
+								{
+									alt14=2;
+								}
+
+
+								switch ( alt14 )
+								{
+								case 1:
+									// Grammars\\CodeGenTreeWalker.g3:180:0: .
+									{
+									MatchAny(input); if (state.failed) return ;
+
+									}
+									break;
+
+								default:
+									goto loop14;
+								}
+							}
+
+							loop14:
+								;
+
+
+
+							Match(input, TokenConstants.UP, null); if (state.failed) return ;
+						}
+
+						}
+						break;
+
+					}
+
+
+									if ( input.LA(1) == RULE )
+									{
+										ruleName = ((GrammarAST)input.LT(1)).GetChild(0).Text;
+										//System.Diagnostics.Debug.Assert( ruleName == ((GrammarAST)input.LT(1)).enclosingRuleName );
+										generated = grammar.generateMethodForRule(ruleName);
+									}
+
+
+					}
+					break;
+
+				default:
+					if ( cnt16 >= 1 )
+						goto loop16;
+
+					if (state.backtracking>0) {state.failed=true; return ;}
+					EarlyExitException eee16 = new EarlyExitException( 16, input );
+					throw eee16;
+				}
+				cnt16++;
+			}
+			loop16:
+				;
+
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "rules"
+
+	public class rule_return : TreeRuleReturnScope
+	{
+		public StringTemplate code=null;
+	}
+
+	// $ANTLR start "rule"
+	// Grammars\\CodeGenTreeWalker.g3:193:0: rule returns [StringTemplate code=null] : ^( RULE id= ID (mod= modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block[\"ruleBlock\", dfa] ( exceptionGroup[$code] )? EOR ) ;
+	private CodeGenTreeWalker.rule_return rule(  )
+	{
+		CodeGenTreeWalker.rule_return retval = new CodeGenTreeWalker.rule_return();
+		retval.start = input.LT(1);
+
+		GrammarAST id=null;
+		CodeGenTreeWalker.modifier_return mod = default(CodeGenTreeWalker.modifier_return);
+		CodeGenTreeWalker.block_return b = default(CodeGenTreeWalker.block_return);
+
+
+			string initAction = null;
+			// get the dfa for the BLOCK
+			GrammarAST block2=(GrammarAST)((GrammarAST)retval.start).GetFirstChildWithType(BLOCK);
+			Antlr3.Analysis.DFA dfa=block2.LookaheadDFA;
+			// init blockNestingLevel so it's block level RULE_BLOCK_NESTING_LEVEL
+			// for alts of rule
+			blockNestingLevel = RULE_BLOCK_NESTING_LEVEL-1;
+			Rule ruleDescr = grammar.getRule(((GrammarAST)retval.start).GetChild(0).Text);
+			currentRuleName = ((GrammarAST)retval.start).GetChild(0).Text;
+
+			// For syn preds, we don't want any AST code etc... in there.
+			// Save old templates ptr and restore later.  Base templates include Dbg.
+			StringTemplateGroup saveGroup = templates;
+			if ( ruleDescr.isSynPred )
+			{
+				templates = generator.getBaseTemplates();
+			}
+
+			string description = string.Empty;
+
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:216:4: ( ^( RULE id= ID (mod= modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block[\"ruleBlock\", dfa] ( exceptionGroup[$code] )? EOR ) )
+			// Grammars\\CodeGenTreeWalker.g3:216:4: ^( RULE id= ID (mod= modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block[\"ruleBlock\", dfa] ( exceptionGroup[$code] )? EOR )
+			{
+			Match(input,RULE,Follow._RULE_in_rule345); if (state.failed) return retval;
+
+			Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+			id=(GrammarAST)Match(input,ID,Follow._ID_in_rule349); if (state.failed) return retval;
+			if ( state.backtracking == 0 )
+			{
+				 System.Diagnostics.Debug.Assert( currentRuleName == (id!=null?id.Text:null) );
+			}
+			// Grammars\\CodeGenTreeWalker.g3:218:4: (mod= modifier )?
+			int alt17=2;
+			int LA17_0 = input.LA(1);
+
+			if ( (LA17_0==FRAGMENT||(LA17_0>=PRIVATE && LA17_0<=PUBLIC)) )
+			{
+				alt17=1;
+			}
+			switch ( alt17 )
+			{
+			case 1:
+				// Grammars\\CodeGenTreeWalker.g3:218:5: mod= modifier
+				{
+				PushFollow(Follow._modifier_in_rule362);
+				mod=modifier();
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				}
+				break;
+
+			}
+
+			Match(input,ARG,Follow._ARG_in_rule370); if (state.failed) return retval;
+
+			if ( input.LA(1)==TokenConstants.DOWN )
+			{
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				// Grammars\\CodeGenTreeWalker.g3:219:10: ( ARG_ACTION )?
+				int alt18=2;
+				int LA18_0 = input.LA(1);
+
+				if ( (LA18_0==ARG_ACTION) )
+				{
+					alt18=1;
+				}
+				switch ( alt18 )
+				{
+				case 1:
+					// Grammars\\CodeGenTreeWalker.g3:219:11: ARG_ACTION
+					{
+					Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule373); if (state.failed) return retval;
+
+					}
+					break;
+
+				}
+
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+			}
+			Match(input,RET,Follow._RET_in_rule382); if (state.failed) return retval;
+
+			if ( input.LA(1)==TokenConstants.DOWN )
+			{
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				// Grammars\\CodeGenTreeWalker.g3:220:10: ( ARG_ACTION )?
+				int alt19=2;
+				int LA19_0 = input.LA(1);
+
+				if ( (LA19_0==ARG_ACTION) )
+				{
+					alt19=1;
+				}
+				switch ( alt19 )
+				{
+				case 1:
+					// Grammars\\CodeGenTreeWalker.g3:220:11: ARG_ACTION
+					{
+					Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule385); if (state.failed) return retval;
+
+					}
+					break;
+
+				}
+
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+			}
+			// Grammars\\CodeGenTreeWalker.g3:221:4: ( throwsSpec )?
+			int alt20=2;
+			int LA20_0 = input.LA(1);
+
+			if ( (LA20_0==THROWS) )
+			{
+				alt20=1;
+			}
+			switch ( alt20 )
+			{
+			case 1:
+				// Grammars\\CodeGenTreeWalker.g3:221:5: throwsSpec
+				{
+				PushFollow(Follow._throwsSpec_in_rule394);
+				throwsSpec();
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				}
+				break;
+
+			}
+
+			// Grammars\\CodeGenTreeWalker.g3:222:4: ( ^( OPTIONS ( . )* ) )?
+			int alt22=2;
+			int LA22_0 = input.LA(1);
+
+			if ( (LA22_0==OPTIONS) )
+			{
+				alt22=1;
+			}
+			switch ( alt22 )
+			{
+			case 1:
+				// Grammars\\CodeGenTreeWalker.g3:222:6: ^( OPTIONS ( . )* )
+				{
+				Match(input,OPTIONS,Follow._OPTIONS_in_rule404); if (state.failed) return retval;
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+					// Grammars\\CodeGenTreeWalker.g3:222:16: ( . )*
+					for ( ; ; )
+					{
+						int alt21=2;
+						int LA21_0 = input.LA(1);
+
+						if ( ((LA21_0>=ACTION && LA21_0<=XDIGIT)) )
+						{
+							alt21=1;
+						}
+						else if ( (LA21_0==UP) )
+						{
+							alt21=2;
+						}
+
+
+						switch ( alt21 )
+						{
+						case 1:
+							// Grammars\\CodeGenTreeWalker.g3:222:0: .
+							{
+							MatchAny(input); if (state.failed) return retval;
+
+							}
+							break;
+
+						default:
+							goto loop21;
+						}
+					}
+
+					loop21:
+						;
+
+
+
+					Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+				}
+
+				}
+				break;
+
+			}
+
+			// Grammars\\CodeGenTreeWalker.g3:223:4: ( ruleScopeSpec )?
+			int alt23=2;
+			int LA23_0 = input.LA(1);
+
+			if ( (LA23_0==SCOPE) )
+			{
+				alt23=1;
+			}
+			switch ( alt23 )
+			{
+			case 1:
+				// Grammars\\CodeGenTreeWalker.g3:223:5: ruleScopeSpec
+				{
+				PushFollow(Follow._ruleScopeSpec_in_rule417);
+				ruleScopeSpec();
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				}
+				break;
+
+			}
+
+			// Grammars\\CodeGenTreeWalker.g3:224:4: ( ^( AMPERSAND ( . )* ) )*
+			for ( ; ; )
+			{
+				int alt25=2;
+				int LA25_0 = input.LA(1);
+
+				if ( (LA25_0==AMPERSAND) )
+				{
+					alt25=1;
+				}
+
+
+				switch ( alt25 )
+				{
+				case 1:
+					// Grammars\\CodeGenTreeWalker.g3:224:6: ^( AMPERSAND ( . )* )
+					{
+					Match(input,AMPERSAND,Follow._AMPERSAND_in_rule427); if (state.failed) return retval;
+
+					if ( input.LA(1)==TokenConstants.DOWN )
+					{
+						Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+						// Grammars\\CodeGenTreeWalker.g3:224:18: ( . )*
+						for ( ; ; )
+						{
+							int alt24=2;
+							int LA24_0 = input.LA(1);
+
+							if ( ((LA24_0>=ACTION && LA24_0<=XDIGIT)) )
+							{
+								alt24=1;
+							}
+							else if ( (LA24_0==UP) )
+							{
+								alt24=2;
+							}
+
+
+							switch ( alt24 )
+							{
+							case 1:
+								// Grammars\\CodeGenTreeWalker.g3:224:0: .
+								{
+								MatchAny(input); if (state.failed) return retval;
+
+								}
+								break;
+
+							default:
+								goto loop24;
+							}
+						}
+
+						loop24:
+							;
+
+
+
+						Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+					}
+
+					}
+					break;
+
+				default:
+					goto loop25;
+				}
+			}
+
+			loop25:
+				;
+
+
+			PushFollow(Follow._block_in_rule441);
+			b=block("ruleBlock", dfa);
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 )
+			{
+
+								description =
+									grammar.grammarTreeToString((GrammarAST)((GrammarAST)retval.start).GetFirstChildWithType(BLOCK),
+																false);
+								description =
+									generator.target.getTargetStringLiteralFromString(description);
+								(b!=null?b.code:default(StringTemplate)).setAttribute("description", description);
+								// do not generate lexer rules in combined grammar
+								string stName = null;
+								if ( ruleDescr.isSynPred )
+								{
+									stName = "synpredRule";
+								}
+								else if ( grammar.type==Grammar.LEXER )
+								{
+									if ( currentRuleName.Equals(Grammar.ARTIFICIAL_TOKENS_RULENAME) )
+									{
+										stName = "tokensRule";
+									}
+									else
+									{
+										stName = "lexerRule";
+									}
+								}
+								else
+								{
+									if ( !(grammar.type==Grammar.COMBINED &&
+										 char.IsUpper(currentRuleName[0])) )
+									{
+										stName = "rule";
+									}
+								}
+								retval.code = templates.getInstanceOf(stName);
+								if ( retval.code.getName().Equals("rule") )
+								{
+									retval.code.setAttribute("emptyRule", grammar.isEmptyRule(block2));
+								}
+								retval.code.setAttribute("ruleDescriptor", ruleDescr);
+								string memo = (string)grammar.getBlockOption(((GrammarAST)retval.start),"memoize");
+								if ( memo==null )
+								{
+									memo = (string)grammar.getOption("memoize");
+								}
+								if ( memo!=null && memo.Equals("true") &&
+									 (stName.Equals("rule")||stName.Equals("lexerRule")) )
+								{
+									retval.code.setAttribute("memoize", memo!=null && memo.Equals("true"));
+								}
+
+			}
+			// Grammars\\CodeGenTreeWalker.g3:276:4: ( exceptionGroup[$code] )?
+			int alt26=2;
+			int LA26_0 = input.LA(1);
+
+			if ( (LA26_0==CATCH||LA26_0==FINALLY) )
+			{
+				alt26=1;
+			}
+			switch ( alt26 )
+			{
+			case 1:
+				// Grammars\\CodeGenTreeWalker.g3:276:5: exceptionGroup[$code]
+				{
+				PushFollow(Follow._exceptionGroup_in_rule454);
+				exceptionGroup(retval.code);
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				}
+				break;
+
+			}
+
+			Match(input,EOR,Follow._EOR_in_rule462); if (state.failed) return retval;
+
+			Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+			if ( state.backtracking == 0 )
+			{
+
+							if ( retval.code!=null )
+							{
+								if ( grammar.type==Grammar.LEXER )
+								{
+									bool naked =
+										currentRuleName.Equals(Grammar.ARTIFICIAL_TOKENS_RULENAME) ||
+										((mod!=null?((GrammarAST)mod.start):null)!=null&&(mod!=null?((GrammarAST)mod.start):null).Text.Equals(Grammar.FRAGMENT_RULE_MODIFIER));
+									retval.code.setAttribute("nakedBlock", naked);
+								}
+								else
+								{
+									description = grammar.grammarTreeToString(((GrammarAST)retval.start),false);
+									description = generator.target.getTargetStringLiteralFromString(description);
+									retval.code.setAttribute("description", description);
+								}
+								Rule theRule = grammar.getRule(currentRuleName);
+								generator.translateActionAttributeReferencesForSingleScope(
+									theRule,
+									theRule.Actions
+								);
+								retval.code.setAttribute("ruleName", currentRuleName);
+								retval.code.setAttribute("block", (b!=null?b.code:default(StringTemplate)));
+								if ( initAction!=null )
+								{
+									retval.code.setAttribute("initAction", initAction);
+								}
+							}
+
+			}
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+			 templates = saveGroup;
+		}
+		return retval;
+	}
+	// $ANTLR end "rule"
+
+	public class modifier_return : TreeRuleReturnScope
+	{
+	}
+
+	// $ANTLR start "modifier"
+	// Grammars\\CodeGenTreeWalker.g3:311:0: modifier : ( 'protected' | 'public' | 'private' | 'fragment' );
+	private CodeGenTreeWalker.modifier_return modifier(  )
+	{
+		CodeGenTreeWalker.modifier_return retval = new CodeGenTreeWalker.modifier_return();
+		retval.start = input.LT(1);
+
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:312:4: ( 'protected' | 'public' | 'private' | 'fragment' )
+			// Grammars\\CodeGenTreeWalker.g3:
+			{
+			if ( input.LA(1)==FRAGMENT||(input.LA(1)>=PRIVATE && input.LA(1)<=PUBLIC) )
+			{
+				input.Consume();
+				state.errorRecovery=false;state.failed=false;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				throw mse;
+			}
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "modifier"
+
+
+	// $ANTLR start "throwsSpec"
+	// Grammars\\CodeGenTreeWalker.g3:318:0: throwsSpec : ^( 'throws' ( ID )+ ) ;
+	private void throwsSpec(  )
+	{
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:319:4: ( ^( 'throws' ( ID )+ ) )
+			// Grammars\\CodeGenTreeWalker.g3:319:4: ^( 'throws' ( ID )+ )
+			{
+			Match(input,THROWS,Follow._THROWS_in_throwsSpec512); if (state.failed) return ;
+
+			Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+			// Grammars\\CodeGenTreeWalker.g3:319:15: ( ID )+
+			int cnt27=0;
+			for ( ; ; )
+			{
+				int alt27=2;
+				int LA27_0 = input.LA(1);
+
+				if ( (LA27_0==ID) )
+				{
+					alt27=1;
+				}
+
+
+				switch ( alt27 )
+				{
+				case 1:
+					// Grammars\\CodeGenTreeWalker.g3:319:0: ID
+					{
+					Match(input,ID,Follow._ID_in_throwsSpec514); if (state.failed) return ;
+
+					}
+					break;
+
+				default:
+					if ( cnt27 >= 1 )
+						goto loop27;
+
+					if (state.backtracking>0) {state.failed=true; return ;}
+					EarlyExitException eee27 = new EarlyExitException( 27, input );
+					throw eee27;
+				}
+				cnt27++;
+			}
+			loop27:
+				;
+
+
+
+			Match(input, TokenConstants.UP, null); if (state.failed) return ;
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "throwsSpec"
+
+
+	// $ANTLR start "ruleScopeSpec"
+	// Grammars\\CodeGenTreeWalker.g3:322:0: ruleScopeSpec : ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* ) ;
+	private void ruleScopeSpec(  )
+	{
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:323:4: ( ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* ) )
+			// Grammars\\CodeGenTreeWalker.g3:323:4: ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* )
+			{
+			Match(input,SCOPE,Follow._SCOPE_in_ruleScopeSpec529); if (state.failed) return ;
+
+			if ( input.LA(1)==TokenConstants.DOWN )
+			{
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+				// Grammars\\CodeGenTreeWalker.g3:323:15: ( ^( AMPERSAND ( . )* ) )*
+				for ( ; ; )
+				{
+					int alt29=2;
+					int LA29_0 = input.LA(1);
+
+					if ( (LA29_0==AMPERSAND) )
+					{
+						alt29=1;
+					}
+
+
+					switch ( alt29 )
+					{
+					case 1:
+						// Grammars\\CodeGenTreeWalker.g3:323:17: ^( AMPERSAND ( . )* )
+						{
+						Match(input,AMPERSAND,Follow._AMPERSAND_in_ruleScopeSpec534); if (state.failed) return ;
+
+						if ( input.LA(1)==TokenConstants.DOWN )
+						{
+							Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+							// Grammars\\CodeGenTreeWalker.g3:323:29: ( . )*
+							for ( ; ; )
+							{
+								int alt28=2;
+								int LA28_0 = input.LA(1);
+
+								if ( ((LA28_0>=ACTION && LA28_0<=XDIGIT)) )
+								{
+									alt28=1;
+								}
+								else if ( (LA28_0==UP) )
+								{
+									alt28=2;
+								}
+
+
+								switch ( alt28 )
+								{
+								case 1:
+									// Grammars\\CodeGenTreeWalker.g3:323:0: .
+									{
+									MatchAny(input); if (state.failed) return ;
+
+									}
+									break;
+
+								default:
+									goto loop28;
+								}
+							}
+
+							loop28:
+								;
+
+
+
+							Match(input, TokenConstants.UP, null); if (state.failed) return ;
+						}
+
+						}
+						break;
+
+					default:
+						goto loop29;
+					}
+				}
+
+				loop29:
+					;
+
+
+				// Grammars\\CodeGenTreeWalker.g3:323:36: ( ACTION )?
+				int alt30=2;
+				int LA30_0 = input.LA(1);
+
+				if ( (LA30_0==ACTION) )
+				{
+					alt30=1;
+				}
+				switch ( alt30 )
+				{
+				case 1:
+					// Grammars\\CodeGenTreeWalker.g3:323:37: ACTION
+					{
+					Match(input,ACTION,Follow._ACTION_in_ruleScopeSpec544); if (state.failed) return ;
+
+					}
+					break;
+
+				}
+
+				// Grammars\\CodeGenTreeWalker.g3:323:46: ( ID )*
+				for ( ; ; )
+				{
+					int alt31=2;
+					int LA31_0 = input.LA(1);
+
+					if ( (LA31_0==ID) )
+					{
+						alt31=1;
+					}
+
+
+					switch ( alt31 )
+					{
+					case 1:
+						// Grammars\\CodeGenTreeWalker.g3:323:48: ID
+						{
+						Match(input,ID,Follow._ID_in_ruleScopeSpec550); if (state.failed) return ;
+
+						}
+						break;
+
+					default:
+						goto loop31;
+					}
+				}
+
+				loop31:
+					;
+
+
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return ;
+			}
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "ruleScopeSpec"
+
+	public class block_return : TreeRuleReturnScope
+	{
+		public StringTemplate code=null;
+	}
+
+	// $ANTLR start "block"
+	// Grammars\\CodeGenTreeWalker.g3:326:0: block[string blockTemplateName, Antlr3.Analysis.DFA dfa] returns [StringTemplate code=null] options {k=1; } : ({...}? => setBlock | ^( BLOCK ( ^( OPTIONS ( . )* ) )? (alt= alternative rew= rewrite )+ EOB ) );
+	private CodeGenTreeWalker.block_return block( string blockTemplateName, Antlr3.Analysis.DFA dfa )
+	{
+		CodeGenTreeWalker.block_return retval = new CodeGenTreeWalker.block_return();
+		retval.start = input.LT(1);
+
+		CodeGenTreeWalker.alternative_return alt = default(CodeGenTreeWalker.alternative_return);
+		CodeGenTreeWalker.rewrite_return rew = default(CodeGenTreeWalker.rewrite_return);
+		CodeGenTreeWalker.setBlock_return setBlock1 = default(CodeGenTreeWalker.setBlock_return);
+
+
+			int altNum = 0;
+
+			blockNestingLevel++;
+			if ( state.backtracking == 0 )
+			{
+				StringTemplate decision = null;
+				if ( dfa != null )
+				{
+					retval.code = templates.getInstanceOf(blockTemplateName);
+					decision = generator.genLookaheadDecision(recognizerST,dfa);
+					retval.code.setAttribute("decision", decision);
+					retval.code.setAttribute("decisionNumber", dfa.DecisionNumber);
+					retval.code.setAttribute("maxK",dfa.MaxLookaheadDepth);
+					retval.code.setAttribute("maxAlt",dfa.NumberOfAlts);
+				}
+				else
+				{
+					retval.code = templates.getInstanceOf(blockTemplateName+"SingleAlt");
+				}
+				retval.code.setAttribute("blockLevel", blockNestingLevel);
+				retval.code.setAttribute("enclosingBlockLevel", blockNestingLevel-1);
+				altNum = 1;
+				if ( this.blockNestingLevel==RULE_BLOCK_NESTING_LEVEL ) {
+					this.outerAltNum=1;
+				}
+			}
+
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:358:4: ({...}? => setBlock | ^( BLOCK ( ^( OPTIONS ( . )* ) )? (alt= alternative rew= rewrite )+ EOB ) )
+			int alt35=2;
+			int LA35_0 = input.LA(1);
+
+			if ( (LA35_0==BLOCK) )
+			{
+				int LA35_1 = input.LA(2);
+
+				if ( ((((GrammarAST)retval.start).SetValue!=null)) )
+				{
+					alt35=1;
+				}
+				else if ( (true) )
+				{
+					alt35=2;
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 35, 1, input);
+
+					throw nvae;
+				}
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae = new NoViableAltException("", 35, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt35 )
+			{
+			case 1:
+				// Grammars\\CodeGenTreeWalker.g3:358:4: {...}? => setBlock
+				{
+				if ( !((((GrammarAST)retval.start).SetValue!=null)) )
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					throw new FailedPredicateException(input, "block", "$start.SetValue!=null");
+				}
+				PushFollow(Follow._setBlock_in_block591);
+				setBlock1=setBlock();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+
+								retval.code.setAttribute("alts",(setBlock1!=null?setBlock1.code:default(StringTemplate)));
+
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\CodeGenTreeWalker.g3:363:4: ^( BLOCK ( ^( OPTIONS ( . )* ) )? (alt= alternative rew= rewrite )+ EOB )
+				{
+				Match(input,BLOCK,Follow._BLOCK_in_block604); if (state.failed) return retval;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				// Grammars\\CodeGenTreeWalker.g3:364:4: ( ^( OPTIONS ( . )* ) )?
+				int alt33=2;
+				int LA33_0 = input.LA(1);
+
+				if ( (LA33_0==OPTIONS) )
+				{
+					alt33=1;
+				}
+				switch ( alt33 )
+				{
+				case 1:
+					// Grammars\\CodeGenTreeWalker.g3:364:6: ^( OPTIONS ( . )* )
+					{
+					Match(input,OPTIONS,Follow._OPTIONS_in_block612); if (state.failed) return retval;
+
+					if ( input.LA(1)==TokenConstants.DOWN )
+					{
+						Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+						// Grammars\\CodeGenTreeWalker.g3:364:16: ( . )*
+						for ( ; ; )
+						{
+							int alt32=2;
+							int LA32_0 = input.LA(1);
+
+							if ( ((LA32_0>=ACTION && LA32_0<=XDIGIT)) )
+							{
+								alt32=1;
+							}
+							else if ( (LA32_0==UP) )
+							{
+								alt32=2;
+							}
+
+
+							switch ( alt32 )
+							{
+							case 1:
+								// Grammars\\CodeGenTreeWalker.g3:364:0: .
+								{
+								MatchAny(input); if (state.failed) return retval;
+
+								}
+								break;
+
+							default:
+								goto loop32;
+							}
+						}
+
+						loop32:
+							;
+
+
+
+						Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+					}
+
+					}
+					break;
+
+				}
+
+				// Grammars\\CodeGenTreeWalker.g3:365:4: (alt= alternative rew= rewrite )+
+				int cnt34=0;
+				for ( ; ; )
+				{
+					int alt34=2;
+					int LA34_0 = input.LA(1);
+
+					if ( (LA34_0==ALT) )
+					{
+						alt34=1;
+					}
+
+
+					switch ( alt34 )
+					{
+					case 1:
+						// Grammars\\CodeGenTreeWalker.g3:365:6: alt= alternative rew= rewrite
+						{
+						PushFollow(Follow._alternative_in_block629);
+						alt=alternative();
+
+						state._fsp--;
+						if (state.failed) return retval;
+						PushFollow(Follow._rewrite_in_block633);
+						rew=rewrite();
+
+						state._fsp--;
+						if (state.failed) return retval;
+						if ( state.backtracking == 0 )
+						{
+
+												if ( this.blockNestingLevel==RULE_BLOCK_NESTING_LEVEL )
+												{
+													this.outerAltNum++;
+												}
+												// add the rewrite code as just another element in the alt :)
+												// (unless it's a " -> ..." rewrite
+												// ( -> ... )
+												bool etc =
+													(rew!=null?((GrammarAST)rew.start):null).Type==REWRITE &&
+													(rew!=null?((GrammarAST)rew.start):null).GetChild(0)!=null &&
+													(rew!=null?((GrammarAST)rew.start):null).GetChild(0).Type==ETC;
+												if ( (rew!=null?rew.code:default(StringTemplate))!=null && !etc )
+												{
+													(alt!=null?alt.code:default(StringTemplate)).setAttribute("rew", (rew!=null?rew.code:default(StringTemplate)));
+												}
+												// add this alt to the list of alts for this block
+												retval.code.setAttribute("alts",(alt!=null?alt.code:default(StringTemplate)));
+												(alt!=null?alt.code:default(StringTemplate)).setAttribute("altNum", altNum);
+												(alt!=null?alt.code:default(StringTemplate)).setAttribute("outerAlt", blockNestingLevel==RULE_BLOCK_NESTING_LEVEL);
+												altNum++;
+
+						}
+
+						}
+						break;
+
+					default:
+						if ( cnt34 >= 1 )
+							goto loop34;
+
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						EarlyExitException eee34 = new EarlyExitException( 34, input );
+						throw eee34;
+					}
+					cnt34++;
+				}
+				loop34:
+					;
+
+
+				Match(input,EOB,Follow._EOB_in_block650); if (state.failed) return retval;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+			 blockNestingLevel--;
+		}
+		return retval;
+	}
+	// $ANTLR end "block"
+
+	public class setBlock_return : TreeRuleReturnScope
+	{
+		public StringTemplate code=null;
+	}
+
+	// $ANTLR start "setBlock"
+	// Grammars\\CodeGenTreeWalker.g3:394:0: setBlock returns [StringTemplate code=null] : ^(s= BLOCK ( . )* ) ;
+	private CodeGenTreeWalker.setBlock_return setBlock(  )
+	{
+		CodeGenTreeWalker.setBlock_return retval = new CodeGenTreeWalker.setBlock_return();
+		retval.start = input.LT(1);
+
+		GrammarAST s=null;
+
+
+			StringTemplate setcode = null;
+			if ( state.backtracking == 0 )
+			{
+				if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL && grammar.BuildAST )
+				{
+					Rule r = grammar.getRule(currentRuleName);
+					currentAltHasASTRewrite = r.hasRewrite(outerAltNum);
+					if ( currentAltHasASTRewrite )
+					{
+						r.trackTokenReferenceInAlt(((GrammarAST)retval.start), outerAltNum);
+					}
+				}
+			}
+
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:411:4: ( ^(s= BLOCK ( . )* ) )
+			// Grammars\\CodeGenTreeWalker.g3:411:4: ^(s= BLOCK ( . )* )
+			{
+			s=(GrammarAST)Match(input,BLOCK,Follow._BLOCK_in_setBlock682); if (state.failed) return retval;
+
+			if ( input.LA(1)==TokenConstants.DOWN )
+			{
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				// Grammars\\CodeGenTreeWalker.g3:411:14: ( . )*
+				for ( ; ; )
+				{
+					int alt36=2;
+					int LA36_0 = input.LA(1);
+
+					if ( ((LA36_0>=ACTION && LA36_0<=XDIGIT)) )
+					{
+						alt36=1;
+					}
+					else if ( (LA36_0==UP) )
+					{
+						alt36=2;
+					}
+
+
+					switch ( alt36 )
+					{
+					case 1:
+						// Grammars\\CodeGenTreeWalker.g3:411:0: .
+						{
+						MatchAny(input); if (state.failed) return retval;
+
+						}
+						break;
+
+					default:
+						goto loop36;
+					}
+				}
+
+				loop36:
+					;
+
+
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+			}
+			if ( state.backtracking == 0 )
+			{
+
+							int i = ((TokenWithIndex)s.Token).TokenIndex;
+							if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL )
+							{
+								setcode = getTokenElementST("matchRuleBlockSet", "set", s, null, null);
+							}
+							else
+							{
+								setcode = getTokenElementST("matchSet", "set", s, null, null);
+							}
+							setcode.setAttribute("elementIndex", i);
+							if ( grammar.type!=Grammar.LEXER )
+							{
+								generator.generateLocalFOLLOW(s,"set",currentRuleName,i);
+							}
+							setcode.setAttribute("s",
+								generator.genSetExpr(templates,s.SetValue,1,false));
+							StringTemplate altcode=templates.getInstanceOf("alt");
+							altcode.setAttribute("elements.{el,line,pos}",
+												 setcode,
+												 s.Line,
+												 s.CharPositionInLine
+												);
+							altcode.setAttribute("altNum", 1);
+							altcode.setAttribute("outerAlt", blockNestingLevel==RULE_BLOCK_NESTING_LEVEL);
+							if ( !currentAltHasASTRewrite && grammar.BuildAST )
+							{
+								altcode.setAttribute("autoAST", true);
+							}
+							altcode.setAttribute("treeLevel", rewriteTreeNestingLevel);
+							retval.code = altcode;
+
+			}
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "setBlock"
+
+
+	// $ANTLR start "setAlternative"
+	// Grammars\\CodeGenTreeWalker.g3:446:0: setAlternative : ^( ALT ( setElement )+ EOA ) ;
+	private void setAlternative(  )
+	{
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:447:4: ( ^( ALT ( setElement )+ EOA ) )
+			// Grammars\\CodeGenTreeWalker.g3:447:4: ^( ALT ( setElement )+ EOA )
+			{
+			Match(input,ALT,Follow._ALT_in_setAlternative702); if (state.failed) return ;
+
+			Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+			// Grammars\\CodeGenTreeWalker.g3:447:10: ( setElement )+
+			int cnt37=0;
+			for ( ; ; )
+			{
+				int alt37=2;
+				int LA37_0 = input.LA(1);
+
+				if ( ((LA37_0>=CHAR_LITERAL && LA37_0<=CHAR_RANGE)||LA37_0==STRING_LITERAL||LA37_0==TOKEN_REF) )
+				{
+					alt37=1;
+				}
+
+
+				switch ( alt37 )
+				{
+				case 1:
+					// Grammars\\CodeGenTreeWalker.g3:447:0: setElement
+					{
+					PushFollow(Follow._setElement_in_setAlternative704);
+					setElement();
+
+					state._fsp--;
+					if (state.failed) return ;
+
+					}
+					break;
+
+				default:
+					if ( cnt37 >= 1 )
+						goto loop37;
+
+					if (state.backtracking>0) {state.failed=true; return ;}
+					EarlyExitException eee37 = new EarlyExitException( 37, input );
+					throw eee37;
+				}
+				cnt37++;
+			}
+			loop37:
+				;
+
+
+			Match(input,EOA,Follow._EOA_in_setAlternative707); if (state.failed) return ;
+
+			Match(input, TokenConstants.UP, null); if (state.failed) return ;
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "setAlternative"
+
+
+	// $ANTLR start "exceptionGroup"
+	// Grammars\\CodeGenTreeWalker.g3:450:0: exceptionGroup[StringTemplate ruleST] : ( ( exceptionHandler[$ruleST] )+ ( finallyClause[$ruleST] )? | finallyClause[$ruleST] );
+	private void exceptionGroup( StringTemplate ruleST )
+	{
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:451:4: ( ( exceptionHandler[$ruleST] )+ ( finallyClause[$ruleST] )? | finallyClause[$ruleST] )
+			int alt40=2;
+			int LA40_0 = input.LA(1);
+
+			if ( (LA40_0==CATCH) )
+			{
+				alt40=1;
+			}
+			else if ( (LA40_0==FINALLY) )
+			{
+				alt40=2;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				NoViableAltException nvae = new NoViableAltException("", 40, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt40 )
+			{
+			case 1:
+				// Grammars\\CodeGenTreeWalker.g3:451:4: ( exceptionHandler[$ruleST] )+ ( finallyClause[$ruleST] )?
+				{
+				// Grammars\\CodeGenTreeWalker.g3:451:4: ( exceptionHandler[$ruleST] )+
+				int cnt38=0;
+				for ( ; ; )
+				{
+					int alt38=2;
+					int LA38_0 = input.LA(1);
+
+					if ( (LA38_0==CATCH) )
+					{
+						alt38=1;
+					}
+
+
+					switch ( alt38 )
+					{
+					case 1:
+						// Grammars\\CodeGenTreeWalker.g3:451:6: exceptionHandler[$ruleST]
+						{
+						PushFollow(Follow._exceptionHandler_in_exceptionGroup722);
+						exceptionHandler(ruleST);
+
+						state._fsp--;
+						if (state.failed) return ;
+
+						}
+						break;
+
+					default:
+						if ( cnt38 >= 1 )
+							goto loop38;
+
+						if (state.backtracking>0) {state.failed=true; return ;}
+						EarlyExitException eee38 = new EarlyExitException( 38, input );
+						throw eee38;
+					}
+					cnt38++;
+				}
+				loop38:
+					;
+
+
+				// Grammars\\CodeGenTreeWalker.g3:451:35: ( finallyClause[$ruleST] )?
+				int alt39=2;
+				int LA39_0 = input.LA(1);
+
+				if ( (LA39_0==FINALLY) )
+				{
+					alt39=1;
+				}
+				switch ( alt39 )
+				{
+				case 1:
+					// Grammars\\CodeGenTreeWalker.g3:451:36: finallyClause[$ruleST]
+					{
+					PushFollow(Follow._finallyClause_in_exceptionGroup729);
+					finallyClause(ruleST);
+
+					state._fsp--;
+					if (state.failed) return ;
+
+					}
+					break;
+
+				}
+
+
+				}
+				break;
+			case 2:
+				// Grammars\\CodeGenTreeWalker.g3:452:4: finallyClause[$ruleST]
+				{
+				PushFollow(Follow._finallyClause_in_exceptionGroup737);
+				finallyClause(ruleST);
+
+				state._fsp--;
+				if (state.failed) return ;
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "exceptionGroup"
+
+
+	// $ANTLR start "exceptionHandler"
+	// Grammars\\CodeGenTreeWalker.g3:455:0: exceptionHandler[StringTemplate ruleST] : ^( 'catch' ARG_ACTION ACTION ) ;
+	private void exceptionHandler( StringTemplate ruleST )
+	{
+		GrammarAST ACTION2=null;
+		GrammarAST ARG_ACTION3=null;
+
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:456:4: ( ^( 'catch' ARG_ACTION ACTION ) )
+			// Grammars\\CodeGenTreeWalker.g3:456:4: ^( 'catch' ARG_ACTION ACTION )
+			{
+			Match(input,CATCH,Follow._CATCH_in_exceptionHandler751); if (state.failed) return ;
+
+			Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+			ARG_ACTION3=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_exceptionHandler753); if (state.failed) return ;
+			ACTION2=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_exceptionHandler755); if (state.failed) return ;
+
+			Match(input, TokenConstants.UP, null); if (state.failed) return ;
+			if ( state.backtracking == 0 )
+			{
+
+							List chunks = generator.translateAction(currentRuleName,ACTION2);
+							ruleST.setAttribute("exceptions.{decl,action}",(ARG_ACTION3!=null?ARG_ACTION3.Text:null),chunks);
+
+			}
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "exceptionHandler"
+
+
+	// $ANTLR start "finallyClause"
+	// Grammars\\CodeGenTreeWalker.g3:463:0: finallyClause[StringTemplate ruleST] : ^( 'finally' ACTION ) ;
+	private void finallyClause( StringTemplate ruleST )
+	{
+		GrammarAST ACTION4=null;
+
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:464:4: ( ^( 'finally' ACTION ) )
+			// Grammars\\CodeGenTreeWalker.g3:464:4: ^( 'finally' ACTION )
+			{
+			Match(input,FINALLY,Follow._FINALLY_in_finallyClause773); if (state.failed) return ;
+
+			Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+			ACTION4=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_finallyClause775); if (state.failed) return ;
+
+			Match(input, TokenConstants.UP, null); if (state.failed) return ;
+			if ( state.backtracking == 0 )
+			{
+
+							List chunks = generator.translateAction(currentRuleName,ACTION4);
+							ruleST.setAttribute("finally",chunks);
+
+			}
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "finallyClause"
+
+	public class alternative_return : TreeRuleReturnScope
+	{
+		public StringTemplate code;
+	}
+
+	// $ANTLR start "alternative"
+	// Grammars\\CodeGenTreeWalker.g3:471:0: alternative returns [StringTemplate code] : ^(a= ALT (e= element[null,null] )+ EOA ) ;
+	private CodeGenTreeWalker.alternative_return alternative(  )
+	{
+		CodeGenTreeWalker.alternative_return retval = new CodeGenTreeWalker.alternative_return();
+		retval.start = input.LT(1);
+
+		GrammarAST a=null;
+		CodeGenTreeWalker.element_return e = default(CodeGenTreeWalker.element_return);
+
+
+			if ( state.backtracking == 0 )
+			{
+				retval.code = templates.getInstanceOf("alt");
+				/*
+				// TODO: can we use Rule.altsWithRewrites???
+				if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL ) {
+					GrammarAST aRewriteNode = #alternative.findFirstType(REWRITE);
+					if ( grammar.buildAST() &&
+						 (aRewriteNode!=null||
+						 (#alternative.getNextSibling()!=null &&
+						  #alternative.getNextSibling().getType()==REWRITE)) )
+					{
+						currentAltHasASTRewrite = true;
+					}
+					else {
+						currentAltHasASTRewrite = false;
+					}
+				}
+				*/
+				if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL && grammar.BuildAST )
+				{
+					Rule r = grammar.getRule(currentRuleName);
+					currentAltHasASTRewrite = r.hasRewrite(outerAltNum);
+				}
+				string description = grammar.grammarTreeToString(((GrammarAST)retval.start), false);
+				description = generator.target.getTargetStringLiteralFromString(description);
+				retval.code.setAttribute("description", description);
+				retval.code.setAttribute("treeLevel", rewriteTreeNestingLevel);
+				if ( !currentAltHasASTRewrite && grammar.BuildAST )
+				{
+					retval.code.setAttribute("autoAST", true);
+				}
+			}
+
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:508:4: ( ^(a= ALT (e= element[null,null] )+ EOA ) )
+			// Grammars\\CodeGenTreeWalker.g3:508:4: ^(a= ALT (e= element[null,null] )+ EOA )
+			{
+			a=(GrammarAST)Match(input,ALT,Follow._ALT_in_alternative804); if (state.failed) return retval;
+
+			Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+			// Grammars\\CodeGenTreeWalker.g3:509:4: (e= element[null,null] )+
+			int cnt41=0;
+			for ( ; ; )
+			{
+				int alt41=2;
+				int LA41_0 = input.LA(1);
+
+				if ( (LA41_0==ACTION||(LA41_0>=ASSIGN && LA41_0<=BLOCK)||(LA41_0>=CHAR_LITERAL && LA41_0<=CHAR_RANGE)||LA41_0==CLOSURE||LA41_0==DOT||LA41_0==EPSILON||LA41_0==FORCED_ACTION||LA41_0==GATED_SEMPRED||LA41_0==NOT||LA41_0==OPTIONAL||(LA41_0>=PLUS_ASSIGN && LA41_0<=POSITIVE_CLOSURE)||LA41_0==ROOT||LA41_0==RULE_REF||LA41_0==SEMPRED||(LA41_0>=STRING_LITERAL && LA41_0<=SYNPRED)||LA41_0==TOKEN_REF||LA41_0==TREE_BEGIN||LA41_0==WILDCARD) )
+				{
+					alt41=1;
+				}
+
+
+				switch ( alt41 )
+				{
+				case 1:
+					// Grammars\\CodeGenTreeWalker.g3:510:5: e= element[null,null]
+					{
+					PushFollow(Follow._element_in_alternative817);
+					e=element(null, null);
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 )
+					{
+
+											if ( e!=null )
+											{
+												retval.code.setAttribute("elements.{el,line,pos}",
+																  (e!=null?e.code:default(StringTemplate)),
+																  (e!=null?((GrammarAST)e.start):null).Line,
+																  (e!=null?((GrammarAST)e.start):null).CharPositionInLine
+																 );
+											}
+
+					}
+
+					}
+					break;
+
+				default:
+					if ( cnt41 >= 1 )
+						goto loop41;
+
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					EarlyExitException eee41 = new EarlyExitException( 41, input );
+					throw eee41;
+				}
+				cnt41++;
+			}
+			loop41:
+				;
+
+
+			Match(input,EOA,Follow._EOA_in_alternative835); if (state.failed) return retval;
+
+			Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "alternative"
+
+	public class element_return : TreeRuleReturnScope
+	{
+		public StringTemplate code=null;
+	}
+
+	// $ANTLR start "element"
+	// Grammars\\CodeGenTreeWalker.g3:526:0: element[GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null] options {k=1; } : ( ^( ROOT e= element[label,$ROOT] ) | ^( BANG e= element[label,$BANG] ) | ^(n= NOT notElement[$n, $label, $astSuffix] ) | ^( ASSIGN alabel= ID e= element[$alabel,$astSuffix] ) | ^( PLUS_ASSIGN label2= ID e= element[$label2,$astSuffix] ) | ^( CHAR_RANGE a= CHAR_LITERAL b= CHAR_LITERAL ) |=> ebnf | atom[null, $label, $astSuffix] | tree_ | element_action | (sp= SEMPRED |sp= GATED_SEMPRED ) | SYN_SEMPRED | ^( SYNPRED ( . )* ) | ^( BACKTRACK_SEMPRED ( . )* ) | EPSILON );
+	private CodeGenTreeWalker.element_return element( GrammarAST label, GrammarAST astSuffix )
+	{
+		CodeGenTreeWalker.element_return retval = new CodeGenTreeWalker.element_return();
+		retval.start = input.LT(1);
+
+		GrammarAST n=null;
+		GrammarAST alabel=null;
+		GrammarAST label2=null;
+		GrammarAST a=null;
+		GrammarAST b=null;
+		GrammarAST sp=null;
+		GrammarAST ROOT5=null;
+		GrammarAST BANG6=null;
+		CodeGenTreeWalker.element_return e = default(CodeGenTreeWalker.element_return);
+		StringTemplate notElement7 = default(StringTemplate);
+		CodeGenTreeWalker.ebnf_return ebnf8 = default(CodeGenTreeWalker.ebnf_return);
+		CodeGenTreeWalker.atom_return atom9 = default(CodeGenTreeWalker.atom_return);
+		CodeGenTreeWalker.tree__return tree_10 = default(CodeGenTreeWalker.tree__return);
+		CodeGenTreeWalker.element_action_return element_action11 = default(CodeGenTreeWalker.element_action_return);
+
+
+			IIntSet elements=null;
+			GrammarAST ast = null;
+
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:533:4: ( ^( ROOT e= element[label,$ROOT] ) | ^( BANG e= element[label,$BANG] ) | ^(n= NOT notElement[$n, $label, $astSuffix] ) | ^( ASSIGN alabel= ID e= element[$alabel,$astSuffix] ) | ^( PLUS_ASSIGN label2= ID e= element[$label2,$astSuffix] ) | ^( CHAR_RANGE a= CHAR_LITERAL b= CHAR_LITERAL ) |=> ebnf | atom[null, $label, $astSuffix] | tree_ | element_action | (sp= SEMPRED |sp= GATED_SEMPRED ) | SYN_SEMPRED | ^( SYNPRED ( . )* ) | ^( BACKTRACK_SEMPRED ( . )* ) | EPSILON )
+			int alt45=15;
+			alt45 = dfa45.Predict(input);
+			switch ( alt45 )
+			{
+			case 1:
+				// Grammars\\CodeGenTreeWalker.g3:533:4: ^( ROOT e= element[label,$ROOT] )
+				{
+				ROOT5=(GrammarAST)Match(input,ROOT,Follow._ROOT_in_element870); if (state.failed) return retval;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				PushFollow(Follow._element_in_element874);
+				e=element(label, ROOT5);
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+					 retval.code = (e!=null?e.code:default(StringTemplate));
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\CodeGenTreeWalker.g3:536:4: ^( BANG e= element[label,$BANG] )
+				{
+				BANG6=(GrammarAST)Match(input,BANG,Follow._BANG_in_element887); if (state.failed) return retval;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				PushFollow(Follow._element_in_element891);
+				e=element(label, BANG6);
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+					 retval.code = (e!=null?e.code:default(StringTemplate));
+				}
+
+				}
+				break;
+			case 3:
+				// Grammars\\CodeGenTreeWalker.g3:539:4: ^(n= NOT notElement[$n, $label, $astSuffix] )
+				{
+				n=(GrammarAST)Match(input,NOT,Follow._NOT_in_element907); if (state.failed) return retval;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				PushFollow(Follow._notElement_in_element909);
+				notElement7=notElement(n, label, astSuffix);
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+					 retval.code = notElement7;
+				}
+
+				}
+				break;
+			case 4:
+				// Grammars\\CodeGenTreeWalker.g3:542:4: ^( ASSIGN alabel= ID e= element[$alabel,$astSuffix] )
+				{
+				Match(input,ASSIGN,Follow._ASSIGN_in_element924); if (state.failed) return retval;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				alabel=(GrammarAST)Match(input,ID,Follow._ID_in_element928); if (state.failed) return retval;
+				PushFollow(Follow._element_in_element932);
+				e=element(alabel, astSuffix);
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+					 retval.code = (e!=null?e.code:default(StringTemplate));
+				}
+
+				}
+				break;
+			case 5:
+				// Grammars\\CodeGenTreeWalker.g3:545:4: ^( PLUS_ASSIGN label2= ID e= element[$label2,$astSuffix] )
+				{
+				Match(input,PLUS_ASSIGN,Follow._PLUS_ASSIGN_in_element947); if (state.failed) return retval;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				label2=(GrammarAST)Match(input,ID,Follow._ID_in_element951); if (state.failed) return retval;
+				PushFollow(Follow._element_in_element955);
+				e=element(label2, astSuffix);
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+					 retval.code = (e!=null?e.code:default(StringTemplate));
+				}
+
+				}
+				break;
+			case 6:
+				// Grammars\\CodeGenTreeWalker.g3:548:4: ^( CHAR_RANGE a= CHAR_LITERAL b= CHAR_LITERAL )
+				{
+				Match(input,CHAR_RANGE,Follow._CHAR_RANGE_in_element969); if (state.failed) return retval;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				a=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_element973); if (state.failed) return retval;
+				b=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_element977); if (state.failed) return retval;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+
+								retval.code = templates.getInstanceOf("charRangeRef");
+								string low = generator.target.getTargetCharLiteralFromANTLRCharLiteral(generator,(a!=null?a.Text:null));
+								string high = generator.target.getTargetCharLiteralFromANTLRCharLiteral(generator,(b!=null?b.Text:null));
+								retval.code.setAttribute("a", low);
+								retval.code.setAttribute("b", high);
+								if ( label!=null )
+								{
+									retval.code.setAttribute("label", label.Text);
+								}
+
+				}
+
+				}
+				break;
+			case 7:
+				// Grammars\\CodeGenTreeWalker.g3:561:4: => ebnf
+				{
+
+				PushFollow(Follow._ebnf_in_element1006);
+				ebnf8=ebnf();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+					 retval.code = (ebnf8!=null?ebnf8.code:default(StringTemplate));
+				}
+
+				}
+				break;
+			case 8:
+				// Grammars\\CodeGenTreeWalker.g3:564:4: atom[null, $label, $astSuffix]
+				{
+				PushFollow(Follow._atom_in_element1016);
+				atom9=atom(null, label, astSuffix);
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+					 retval.code = (atom9!=null?atom9.code:default(StringTemplate));
+				}
+
+				}
+				break;
+			case 9:
+				// Grammars\\CodeGenTreeWalker.g3:567:4: tree_
+				{
+				PushFollow(Follow._tree__in_element1027);
+				tree_10=tree_();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+					 retval.code = (tree_10!=null?tree_10.code:default(StringTemplate));
+				}
+
+				}
+				break;
+			case 10:
+				// Grammars\\CodeGenTreeWalker.g3:570:4: element_action
+				{
+				PushFollow(Follow._element_action_in_element1037);
+				element_action11=element_action();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+					 retval.code = (element_action11!=null?element_action11.code:default(StringTemplate));
+				}
+
+				}
+				break;
+			case 11:
+				// Grammars\\CodeGenTreeWalker.g3:573:6: (sp= SEMPRED |sp= GATED_SEMPRED )
+				{
+				// Grammars\\CodeGenTreeWalker.g3:573:6: (sp= SEMPRED |sp= GATED_SEMPRED )
+				int alt42=2;
+				int LA42_0 = input.LA(1);
+
+				if ( (LA42_0==SEMPRED) )
+				{
+					alt42=1;
+				}
+				else if ( (LA42_0==GATED_SEMPRED) )
+				{
+					alt42=2;
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 42, 0, input);
+
+					throw nvae;
+				}
+				switch ( alt42 )
+				{
+				case 1:
+					// Grammars\\CodeGenTreeWalker.g3:573:7: sp= SEMPRED
+					{
+					sp=(GrammarAST)Match(input,SEMPRED,Follow._SEMPRED_in_element1052); if (state.failed) return retval;
+
+					}
+					break;
+				case 2:
+					// Grammars\\CodeGenTreeWalker.g3:573:18: sp= GATED_SEMPRED
+					{
+					sp=(GrammarAST)Match(input,GATED_SEMPRED,Follow._GATED_SEMPRED_in_element1056); if (state.failed) return retval;
+
+					}
+					break;
+
+				}
+
+				if ( state.backtracking == 0 )
+				{
+
+								retval.code = templates.getInstanceOf("validateSemanticPredicate");
+								retval.code.setAttribute("pred", generator.translateAction(currentRuleName,sp));
+								string description = generator.target.getTargetStringLiteralFromString((sp!=null?sp.Text:null));
+								retval.code.setAttribute("description", description);
+
+				}
+
+				}
+				break;
+			case 12:
+				// Grammars\\CodeGenTreeWalker.g3:581:4: SYN_SEMPRED
+				{
+				Match(input,SYN_SEMPRED,Follow._SYN_SEMPRED_in_element1067); if (state.failed) return retval;
+
+				}
+				break;
+			case 13:
+				// Grammars\\CodeGenTreeWalker.g3:583:4: ^( SYNPRED ( . )* )
+				{
+				Match(input,SYNPRED,Follow._SYNPRED_in_element1075); if (state.failed) return retval;
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+					// Grammars\\CodeGenTreeWalker.g3:583:14: ( . )*
+					for ( ; ; )
+					{
+						int alt43=2;
+						int LA43_0 = input.LA(1);
+
+						if ( ((LA43_0>=ACTION && LA43_0<=XDIGIT)) )
+						{
+							alt43=1;
+						}
+						else if ( (LA43_0==UP) )
+						{
+							alt43=2;
+						}
+
+
+						switch ( alt43 )
+						{
+						case 1:
+							// Grammars\\CodeGenTreeWalker.g3:583:0: .
+							{
+							MatchAny(input); if (state.failed) return retval;
+
+							}
+							break;
+
+						default:
+							goto loop43;
+						}
+					}
+
+					loop43:
+						;
+
+
+
+					Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+				}
+
+				}
+				break;
+			case 14:
+				// Grammars\\CodeGenTreeWalker.g3:585:4: ^( BACKTRACK_SEMPRED ( . )* )
+				{
+				Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_element1086); if (state.failed) return retval;
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+					// Grammars\\CodeGenTreeWalker.g3:585:24: ( . )*
+					for ( ; ; )
+					{
+						int alt44=2;
+						int LA44_0 = input.LA(1);
+
+						if ( ((LA44_0>=ACTION && LA44_0<=XDIGIT)) )
+						{
+							alt44=1;
+						}
+						else if ( (LA44_0==UP) )
+						{
+							alt44=2;
+						}
+
+
+						switch ( alt44 )
+						{
+						case 1:
+							// Grammars\\CodeGenTreeWalker.g3:585:0: .
+							{
+							MatchAny(input); if (state.failed) return retval;
+
+							}
+							break;
+
+						default:
+							goto loop44;
+						}
+					}
+
+					loop44:
+						;
+
+
+
+					Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+				}
+
+				}
+				break;
+			case 15:
+				// Grammars\\CodeGenTreeWalker.g3:587:6: EPSILON
+				{
+				Match(input,EPSILON,Follow._EPSILON_in_element1098); if (state.failed) return retval;
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "element"
+
+	public class element_action_return : TreeRuleReturnScope
+	{
+		public StringTemplate code=null;
+	}
+
+	// $ANTLR start "element_action"
+	// Grammars\\CodeGenTreeWalker.g3:590:0: element_action returns [StringTemplate code=null] : (act= ACTION |act2= FORCED_ACTION );
+	private CodeGenTreeWalker.element_action_return element_action(  )
+	{
+		CodeGenTreeWalker.element_action_return retval = new CodeGenTreeWalker.element_action_return();
+		retval.start = input.LT(1);
+
+		GrammarAST act=null;
+		GrammarAST act2=null;
+
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:591:4: (act= ACTION |act2= FORCED_ACTION )
+			int alt46=2;
+			int LA46_0 = input.LA(1);
+
+			if ( (LA46_0==ACTION) )
+			{
+				alt46=1;
+			}
+			else if ( (LA46_0==FORCED_ACTION) )
+			{
+				alt46=2;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae = new NoViableAltException("", 46, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt46 )
+			{
+			case 1:
+				// Grammars\\CodeGenTreeWalker.g3:591:4: act= ACTION
+				{
+				act=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_element_action1115); if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+
+								retval.code = templates.getInstanceOf("execAction");
+								retval.code.setAttribute("action", generator.translateAction(currentRuleName,act));
+
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\CodeGenTreeWalker.g3:596:4: act2= FORCED_ACTION
+				{
+				act2=(GrammarAST)Match(input,FORCED_ACTION,Follow._FORCED_ACTION_in_element_action1126); if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+
+								retval.code = templates.getInstanceOf("execForcedAction");
+								retval.code.setAttribute("action", generator.translateAction(currentRuleName,act2));
+
+				}
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "element_action"
+
+
+	// $ANTLR start "notElement"
+	// Grammars\\CodeGenTreeWalker.g3:603:0: notElement[GrammarAST n, GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null] : (assign_c= CHAR_LITERAL |assign_s= STRING_LITERAL |assign_t= TOKEN_REF | ^(assign_st= BLOCK ( . )* ) ) ;
+	private StringTemplate notElement( GrammarAST n, GrammarAST label, GrammarAST astSuffix )
+	{
+
+		StringTemplate code = null;
+
+		GrammarAST assign_c=null;
+		GrammarAST assign_s=null;
+		GrammarAST assign_t=null;
+		GrammarAST assign_st=null;
+
+
+			IIntSet elements=null;
+			string labelText = null;
+			if ( label!=null )
+			{
+				labelText = label.Text;
+			}
+
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:613:4: ( (assign_c= CHAR_LITERAL |assign_s= STRING_LITERAL |assign_t= TOKEN_REF | ^(assign_st= BLOCK ( . )* ) ) )
+			// Grammars\\CodeGenTreeWalker.g3:613:4: (assign_c= CHAR_LITERAL |assign_s= STRING_LITERAL |assign_t= TOKEN_REF | ^(assign_st= BLOCK ( . )* ) )
+			{
+			// Grammars\\CodeGenTreeWalker.g3:613:4: (assign_c= CHAR_LITERAL |assign_s= STRING_LITERAL |assign_t= TOKEN_REF | ^(assign_st= BLOCK ( . )* ) )
+			int alt48=4;
+			switch ( input.LA(1) )
+			{
+			case CHAR_LITERAL:
+				{
+				alt48=1;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt48=2;
+				}
+				break;
+			case TOKEN_REF:
+				{
+				alt48=3;
+				}
+				break;
+			case BLOCK:
+				{
+				alt48=4;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return code;}
+					NoViableAltException nvae = new NoViableAltException("", 48, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt48 )
+			{
+			case 1:
+				// Grammars\\CodeGenTreeWalker.g3:613:6: assign_c= CHAR_LITERAL
+				{
+				assign_c=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_notElement1155); if (state.failed) return code;
+				if ( state.backtracking == 0 )
+				{
+
+									int ttype=0;
+									if ( grammar.type==Grammar.LEXER )
+									{
+										ttype = Grammar.getCharValueFromGrammarCharLiteral((assign_c!=null?assign_c.Text:null));
+									}
+									else
+									{
+										ttype = grammar.getTokenType((assign_c!=null?assign_c.Text:null));
+									}
+									elements = grammar.complement(ttype);
+
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\CodeGenTreeWalker.g3:626:5: assign_s= STRING_LITERAL
+				{
+				assign_s=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_notElement1168); if (state.failed) return code;
+				if ( state.backtracking == 0 )
+				{
+
+									int ttype=0;
+									if ( grammar.type==Grammar.LEXER )
+									{
+										// TODO: error!
+									}
+									else
+									{
+										ttype = grammar.getTokenType((assign_s!=null?assign_s.Text:null));
+									}
+									elements = grammar.complement(ttype);
+
+				}
+
+				}
+				break;
+			case 3:
+				// Grammars\\CodeGenTreeWalker.g3:639:5: assign_t= TOKEN_REF
+				{
+				assign_t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_notElement1181); if (state.failed) return code;
+				if ( state.backtracking == 0 )
+				{
+
+									int ttype = grammar.getTokenType((assign_t!=null?assign_t.Text:null));
+									elements = grammar.complement(ttype);
+
+				}
+
+				}
+				break;
+			case 4:
+				// Grammars\\CodeGenTreeWalker.g3:644:5: ^(assign_st= BLOCK ( . )* )
+				{
+				assign_st=(GrammarAST)Match(input,BLOCK,Follow._BLOCK_in_notElement1195); if (state.failed) return code;
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null); if (state.failed) return code;
+					// Grammars\\CodeGenTreeWalker.g3:644:23: ( . )*
+					for ( ; ; )
+					{
+						int alt47=2;
+						int LA47_0 = input.LA(1);
+
+						if ( ((LA47_0>=ACTION && LA47_0<=XDIGIT)) )
+						{
+							alt47=1;
+						}
+						else if ( (LA47_0==UP) )
+						{
+							alt47=2;
+						}
+
+
+						switch ( alt47 )
+						{
+						case 1:
+							// Grammars\\CodeGenTreeWalker.g3:644:0: .
+							{
+							MatchAny(input); if (state.failed) return code;
+
+							}
+							break;
+
+						default:
+							goto loop47;
+						}
+					}
+
+					loop47:
+						;
+
+
+
+					Match(input, TokenConstants.UP, null); if (state.failed) return code;
+				}
+				if ( state.backtracking == 0 )
+				{
+
+									elements = assign_st.SetValue;
+									elements = grammar.complement(elements);
+
+				}
+
+				}
+				break;
+
+			}
+
+			if ( state.backtracking == 0 )
+			{
+
+							code = getTokenElementST("matchSet",
+													 "set",
+													 (GrammarAST)n.GetChild(0),
+													 astSuffix,
+													 labelText);
+							code.setAttribute("s",generator.genSetExpr(templates,elements,1,false));
+							int i = ((TokenWithIndex)n.Token).TokenIndex;
+							code.setAttribute("elementIndex", i);
+							if ( grammar.type!=Grammar.LEXER )
+							{
+								generator.generateLocalFOLLOW(n,"set",currentRuleName,i);
+							}
+
+			}
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return code;
+	}
+	// $ANTLR end "notElement"
+
+	public class ebnf_return : TreeRuleReturnScope
+	{
+		public StringTemplate code=null;
+	}
+
+	// $ANTLR start "ebnf"
+	// Grammars\\CodeGenTreeWalker.g3:666:0: ebnf returns [StringTemplate code=null] : (blk= block[\"block\", dfa] | ^( OPTIONAL blk= block[\"optionalBlock\", dfa] ) | ^( CLOSURE blk= block[\"closureBlock\", dfa] ) | ^( POSITIVE_CLOSURE blk= block[\"positiveClosureBlock\", dfa] ) ) ;
+	private CodeGenTreeWalker.ebnf_return ebnf(  )
+	{
+		CodeGenTreeWalker.ebnf_return retval = new CodeGenTreeWalker.ebnf_return();
+		retval.start = input.LT(1);
+
+		CodeGenTreeWalker.block_return blk = default(CodeGenTreeWalker.block_return);
+
+
+			Antlr3.Analysis.DFA dfa=null;
+			GrammarAST b = (GrammarAST)((GrammarAST)retval.start).GetChild(0);
+			GrammarAST eob = (GrammarAST)b.getLastChild(); // loops will use EOB DFA
+
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:673:4: ( (blk= block[\"block\", dfa] | ^( OPTIONAL blk= block[\"optionalBlock\", dfa] ) | ^( CLOSURE blk= block[\"closureBlock\", dfa] ) | ^( POSITIVE_CLOSURE blk= block[\"positiveClosureBlock\", dfa] ) ) )
+			// Grammars\\CodeGenTreeWalker.g3:673:4: (blk= block[\"block\", dfa] | ^( OPTIONAL blk= block[\"optionalBlock\", dfa] ) | ^( CLOSURE blk= block[\"closureBlock\", dfa] ) | ^( POSITIVE_CLOSURE blk= block[\"positiveClosureBlock\", dfa] ) )
+			{
+			// Grammars\\CodeGenTreeWalker.g3:673:4: (blk= block[\"block\", dfa] | ^( OPTIONAL blk= block[\"optionalBlock\", dfa] ) | ^( CLOSURE blk= block[\"closureBlock\", dfa] ) | ^( POSITIVE_CLOSURE blk= block[\"positiveClosureBlock\", dfa] ) )
+			int alt49=4;
+			switch ( input.LA(1) )
+			{
+			case BLOCK:
+				{
+				alt49=1;
+				}
+				break;
+			case OPTIONAL:
+				{
+				alt49=2;
+				}
+				break;
+			case CLOSURE:
+				{
+				alt49=3;
+				}
+				break;
+			case POSITIVE_CLOSURE:
+				{
+				alt49=4;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 49, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt49 )
+			{
+			case 1:
+				// Grammars\\CodeGenTreeWalker.g3:673:6: blk= block[\"block\", dfa]
+				{
+				if ( state.backtracking == 0 )
+				{
+					 dfa = ((GrammarAST)retval.start).LookaheadDFA;
+				}
+				PushFollow(Follow._block_in_ebnf1241);
+				blk=block("block", dfa);
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+					 retval.code = (blk!=null?blk.code:default(StringTemplate));
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\CodeGenTreeWalker.g3:676:5: ^( OPTIONAL blk= block[\"optionalBlock\", dfa] )
+				{
+				if ( state.backtracking == 0 )
+				{
+					 dfa = ((GrammarAST)retval.start).LookaheadDFA;
+				}
+				Match(input,OPTIONAL,Follow._OPTIONAL_in_ebnf1260); if (state.failed) return retval;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				PushFollow(Follow._block_in_ebnf1264);
+				blk=block("optionalBlock", dfa);
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+					 retval.code = (blk!=null?blk.code:default(StringTemplate));
+				}
+
+				}
+				break;
+			case 3:
+				// Grammars\\CodeGenTreeWalker.g3:679:5: ^( CLOSURE blk= block[\"closureBlock\", dfa] )
+				{
+				if ( state.backtracking == 0 )
+				{
+					 dfa = eob.LookaheadDFA;
+				}
+				Match(input,CLOSURE,Follow._CLOSURE_in_ebnf1285); if (state.failed) return retval;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				PushFollow(Follow._block_in_ebnf1289);
+				blk=block("closureBlock", dfa);
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+					 retval.code = (blk!=null?blk.code:default(StringTemplate));
+				}
+
+				}
+				break;
+			case 4:
+				// Grammars\\CodeGenTreeWalker.g3:682:5: ^( POSITIVE_CLOSURE blk= block[\"positiveClosureBlock\", dfa] )
+				{
+				if ( state.backtracking == 0 )
+				{
+					 dfa = eob.LookaheadDFA;
+				}
+				Match(input,POSITIVE_CLOSURE,Follow._POSITIVE_CLOSURE_in_ebnf1310); if (state.failed) return retval;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				PushFollow(Follow._block_in_ebnf1314);
+				blk=block("positiveClosureBlock", dfa);
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+					 retval.code = (blk!=null?blk.code:default(StringTemplate));
+				}
+
+				}
+				break;
+
+			}
+
+			if ( state.backtracking == 0 )
+			{
+
+							string description = grammar.grammarTreeToString(((GrammarAST)retval.start), false);
+							description = generator.target.getTargetStringLiteralFromString(description);
+							retval.code.setAttribute("description", description);
+
+			}
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "ebnf"
+
+	public class tree__return : TreeRuleReturnScope
+	{
+		public StringTemplate code;
+	}
+
+	// $ANTLR start "tree_"
+	// Grammars\\CodeGenTreeWalker.g3:693:0: tree_ returns [StringTemplate code] : ^( TREE_BEGIN el= element[null,rootSuffix] (=>act= element_action )* (el= element[null,null] )* ) ;
+	private CodeGenTreeWalker.tree__return tree_(  )
+	{
+		CodeGenTreeWalker.tree__return retval = new CodeGenTreeWalker.tree__return();
+		retval.start = input.LT(1);
+
+		CodeGenTreeWalker.element_return el = default(CodeGenTreeWalker.element_return);
+		CodeGenTreeWalker.element_action_return act = default(CodeGenTreeWalker.element_action_return);
+
+
+			rewriteTreeNestingLevel++;
+			GrammarAST rootSuffix = null;
+			if ( state.backtracking == 0 )
+			{
+				retval.code = templates.getInstanceOf("tree");
+				NFAState afterDOWN = (NFAState)((GrammarAST)retval.start).NFATreeDownState.getTransition(0).target;
+				LookaheadSet s = grammar.LOOK(afterDOWN);
+				if ( s.member(Label.UP) ) {
+					// nullable child list if we can see the UP as the next token
+					// we need an "if ( input.LA(1)==Token.DOWN )" gate around
+					// the child list.
+					retval.code.setAttribute("nullableChildList", "true");
+				}
+				retval.code.setAttribute("enclosingTreeLevel", rewriteTreeNestingLevel-1);
+				retval.code.setAttribute("treeLevel", rewriteTreeNestingLevel);
+				Rule r = grammar.getRule(currentRuleName);
+				if ( grammar.BuildAST && !r.hasRewrite(outerAltNum) ) {
+					rootSuffix = new GrammarAST(ROOT,"ROOT");
+				}
+			}
+
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:717:4: ( ^( TREE_BEGIN el= element[null,rootSuffix] (=>act= element_action )* (el= element[null,null] )* ) )
+			// Grammars\\CodeGenTreeWalker.g3:717:4: ^( TREE_BEGIN el= element[null,rootSuffix] (=>act= element_action )* (el= element[null,null] )* )
+			{
+			Match(input,TREE_BEGIN,Follow._TREE_BEGIN_in_tree_1352); if (state.failed) return retval;
+
+			Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+			PushFollow(Follow._element_in_tree_1359);
+			el=element(null, rootSuffix);
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 )
+			{
+
+								retval.code.setAttribute("root.{el,line,pos}",
+												  (el!=null?el.code:default(StringTemplate)),
+												  (el!=null?((GrammarAST)el.start):null).Line,
+												  (el!=null?((GrammarAST)el.start):null).CharPositionInLine
+												  );
+
+			}
+			// Grammars\\CodeGenTreeWalker.g3:729:4: (=>act= element_action )*
+			for ( ; ; )
+			{
+				int alt50=2;
+				int LA50_0 = input.LA(1);
+
+				if ( (LA50_0==ACTION) )
+				{
+					int LA50_2 = input.LA(2);
+
+					if ( (synpred2_CodeGenTreeWalker()) )
+					{
+						alt50=1;
+					}
+
+
+				}
+				else if ( (LA50_0==FORCED_ACTION) )
+				{
+					int LA50_3 = input.LA(2);
+
+					if ( (synpred2_CodeGenTreeWalker()) )
+					{
+						alt50=1;
+					}
+
+
+				}
+
+
+				switch ( alt50 )
+				{
+				case 1:
+					// Grammars\\CodeGenTreeWalker.g3:729:6: =>act= element_action
+					{
+
+					PushFollow(Follow._element_action_in_tree_1396);
+					act=element_action();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 )
+					{
+
+											retval.code.setAttribute("actionsAfterRoot.{el,line,pos}",
+															  (act!=null?act.code:default(StringTemplate)),
+															  (act!=null?((GrammarAST)act.start):null).Line,
+															  (act!=null?((GrammarAST)act.start):null).CharPositionInLine
+															);
+
+					}
+
+					}
+					break;
+
+				default:
+					goto loop50;
+				}
+			}
+
+			loop50:
+				;
+
+
+			// Grammars\\CodeGenTreeWalker.g3:739:4: (el= element[null,null] )*
+			for ( ; ; )
+			{
+				int alt51=2;
+				int LA51_0 = input.LA(1);
+
+				if ( (LA51_0==ACTION||(LA51_0>=ASSIGN && LA51_0<=BLOCK)||(LA51_0>=CHAR_LITERAL && LA51_0<=CHAR_RANGE)||LA51_0==CLOSURE||LA51_0==DOT||LA51_0==EPSILON||LA51_0==FORCED_ACTION||LA51_0==GATED_SEMPRED||LA51_0==NOT||LA51_0==OPTIONAL||(LA51_0>=PLUS_ASSIGN && LA51_0<=POSITIVE_CLOSURE)||LA51_0==ROOT||LA51_0==RULE_REF||LA51_0==SEMPRED||(LA51_0>=STRING_LITERAL && LA51_0<=SYNPRED)||LA51_0==TOKEN_REF||LA51_0==TREE_BEGIN||LA51_0==WILDCARD) )
+				{
+					alt51=1;
+				}
+
+
+				switch ( alt51 )
+				{
+				case 1:
+					// Grammars\\CodeGenTreeWalker.g3:739:7: el= element[null,null]
+					{
+					PushFollow(Follow._element_in_tree_1418);
+					el=element(null, null);
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 )
+					{
+
+										 retval.code.setAttribute("children.{el,line,pos}",
+														  (el!=null?el.code:default(StringTemplate)),
+														  (el!=null?((GrammarAST)el.start):null).Line,
+														  (el!=null?((GrammarAST)el.start):null).CharPositionInLine
+														  );
+
+					}
+
+					}
+					break;
+
+				default:
+					goto loop51;
+				}
+			}
+
+			loop51:
+				;
+
+
+
+			Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+			 rewriteTreeNestingLevel--;
+		}
+		return retval;
+	}
+	// $ANTLR end "tree_"
+
+	public class atom_return : TreeRuleReturnScope
+	{
+		public StringTemplate code=null;
+	}
+
+	// $ANTLR start "atom"
+	// Grammars\\CodeGenTreeWalker.g3:752:0: atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null] : ( ^(r= RULE_REF (rarg= ARG_ACTION )? ) | ^(t= TOKEN_REF (targ= ARG_ACTION )? ) |c= CHAR_LITERAL |s= STRING_LITERAL |w= WILDCARD | ^( DOT ID a= atom[$ID, label, astSuffix] ) | set[label,astSuffix] );
+	private CodeGenTreeWalker.atom_return atom( GrammarAST scope, GrammarAST label, GrammarAST astSuffix )
+	{
+		CodeGenTreeWalker.atom_return retval = new CodeGenTreeWalker.atom_return();
+		retval.start = input.LT(1);
+
+		GrammarAST r=null;
+		GrammarAST rarg=null;
+		GrammarAST t=null;
+		GrammarAST targ=null;
+		GrammarAST c=null;
+		GrammarAST s=null;
+		GrammarAST w=null;
+		GrammarAST ID12=null;
+		CodeGenTreeWalker.atom_return a = default(CodeGenTreeWalker.atom_return);
+		StringTemplate set13 = default(StringTemplate);
+
+
+			string labelText=null;
+			if ( state.backtracking == 0 )
+			{
+				if ( label!=null )
+				{
+					labelText = label.Text;
+				}
+				if ( grammar.type!=Grammar.LEXER &&
+					 (((GrammarAST)retval.start).Type==RULE_REF||((GrammarAST)retval.start).Type==TOKEN_REF||
+					  ((GrammarAST)retval.start).Type==CHAR_LITERAL||((GrammarAST)retval.start).Type==STRING_LITERAL) )
+				{
+					Rule encRule = grammar.getRule(((GrammarAST)((GrammarAST)retval.start)).enclosingRuleName);
+					if ( encRule!=null && encRule.hasRewrite(outerAltNum) && astSuffix!=null )
+					{
+						ErrorManager.grammarError(ErrorManager.MSG_AST_OP_IN_ALT_WITH_REWRITE,
+												  grammar,
+												  ((GrammarAST)((GrammarAST)retval.start)).Token,
+												  ((GrammarAST)((GrammarAST)retval.start)).enclosingRuleName,
+												  outerAltNum);
+						astSuffix = null;
+					}
+				}
+			}
+
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:780:6: ( ^(r= RULE_REF (rarg= ARG_ACTION )? ) | ^(t= TOKEN_REF (targ= ARG_ACTION )? ) |c= CHAR_LITERAL |s= STRING_LITERAL |w= WILDCARD | ^( DOT ID a= atom[$ID, label, astSuffix] ) | set[label,astSuffix] )
+			int alt54=7;
+			switch ( input.LA(1) )
+			{
+			case RULE_REF:
+				{
+				alt54=1;
+				}
+				break;
+			case TOKEN_REF:
+				{
+				alt54=2;
+				}
+				break;
+			case CHAR_LITERAL:
+				{
+				alt54=3;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt54=4;
+				}
+				break;
+			case WILDCARD:
+				{
+				alt54=5;
+				}
+				break;
+			case DOT:
+				{
+				alt54=6;
+				}
+				break;
+			case BLOCK:
+				{
+				alt54=7;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 54, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt54 )
+			{
+			case 1:
+				// Grammars\\CodeGenTreeWalker.g3:780:6: ^(r= RULE_REF (rarg= ARG_ACTION )? )
+				{
+				r=(GrammarAST)Match(input,RULE_REF,Follow._RULE_REF_in_atom1469); if (state.failed) return retval;
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+					// Grammars\\CodeGenTreeWalker.g3:780:20: (rarg= ARG_ACTION )?
+					int alt52=2;
+					int LA52_0 = input.LA(1);
+
+					if ( (LA52_0==ARG_ACTION) )
+					{
+						alt52=1;
+					}
+					switch ( alt52 )
+					{
+					case 1:
+						// Grammars\\CodeGenTreeWalker.g3:780:21: rarg= ARG_ACTION
+						{
+						rarg=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1474); if (state.failed) return retval;
+
+						}
+						break;
+
+					}
+
+
+					Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+				}
+				if ( state.backtracking == 0 )
+				{
+
+								grammar.checkRuleReference(scope, r, rarg, currentRuleName);
+								string scopeName = null;
+								if ( scope!=null ) {
+									scopeName = scope.Text;
+								}
+								Rule rdef = grammar.getRule(scopeName, (r!=null?r.Text:null));
+								// don't insert label=r() if label.attr not used, no ret value, ...
+								if ( !rdef.HasReturnValue ) {
+									labelText = null;
+								}
+								retval.code = getRuleElementST("ruleRef", (r!=null?r.Text:null), r, astSuffix, labelText);
+								retval.code.setAttribute("rule", rdef);
+								if ( scope!=null ) { // scoped rule ref
+									Grammar scopeG = grammar.composite.getGrammar(scope.Text);
+									retval.code.setAttribute("scope", scopeG);
+								}
+								else if ( rdef.grammar != this.grammar ) { // nonlocal
+									// if rule definition is not in this grammar, it's nonlocal
+									IList<Grammar> rdefDelegates = rdef.grammar.getDelegates();
+									if ( rdefDelegates.Contains(this.grammar) ) {
+										retval.code.setAttribute("scope", rdef.grammar);
+									}
+									else {
+										// defining grammar is not a delegate, scope all the
+										// back to root, which has delegate methods for all
+										// rules.  Don't use scope if we are root.
+										if ( this.grammar != rdef.grammar.composite.delegateGrammarTreeRoot.grammar ) {
+											retval.code.setAttribute("scope",
+															  rdef.grammar.composite.delegateGrammarTreeRoot.grammar);
+										}
+									}
+								}
+
+								if ( rarg!=null ) {
+									List args = generator.translateAction(currentRuleName,rarg);
+									retval.code.setAttribute("args", args);
+								}
+								int i = ((TokenWithIndex)r.Token).TokenIndex;
+								retval.code.setAttribute("elementIndex", i);
+								generator.generateLocalFOLLOW(r,(r!=null?r.Text:null),currentRuleName,i);
+								r.code = retval.code;
+
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\CodeGenTreeWalker.g3:825:4: ^(t= TOKEN_REF (targ= ARG_ACTION )? )
+				{
+				t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_atom1492); if (state.failed) return retval;
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+					// Grammars\\CodeGenTreeWalker.g3:825:19: (targ= ARG_ACTION )?
+					int alt53=2;
+					int LA53_0 = input.LA(1);
+
+					if ( (LA53_0==ARG_ACTION) )
+					{
+						alt53=1;
+					}
+					switch ( alt53 )
+					{
+					case 1:
+						// Grammars\\CodeGenTreeWalker.g3:825:20: targ= ARG_ACTION
+						{
+						targ=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1497); if (state.failed) return retval;
+
+						}
+						break;
+
+					}
+
+
+					Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+				}
+				if ( state.backtracking == 0 )
+				{
+
+								if ( currentAltHasASTRewrite && t.terminalOptions!=null &&
+									t.terminalOptions[Grammar.defaultTokenOption]!=null )
+								{
+									ErrorManager.grammarError(ErrorManager.MSG_HETERO_ILLEGAL_IN_REWRITE_ALT,
+															grammar,
+															((GrammarAST)(t)).Token,
+															(t!=null?t.Text:null));
+								}
+								grammar.checkRuleReference(scope, t, targ, currentRuleName);
+								if ( grammar.type==Grammar.LEXER )
+								{
+									if ( grammar.getTokenType((t!=null?t.Text:null))==Label.EOF )
+									{
+										retval.code = templates.getInstanceOf("lexerMatchEOF");
+									}
+									else
+									{
+										retval.code = templates.getInstanceOf("lexerRuleRef");
+										if ( isListLabel(labelText) )
+										{
+											retval.code = templates.getInstanceOf("lexerRuleRefAndListLabel");
+										}
+										string scopeName = null;
+										if ( scope!=null )
+										{
+											scopeName = scope.Text;
+										}
+										Rule rdef2 = grammar.getRule(scopeName, (t!=null?t.Text:null));
+										retval.code.setAttribute("rule", rdef2);
+										if ( scope!=null )
+										{ // scoped rule ref
+											Grammar scopeG = grammar.composite.getGrammar(scope.Text);
+											retval.code.setAttribute("scope", scopeG);
+										}
+										else if ( rdef2.grammar != this.grammar )
+										{ // nonlocal
+											// if rule definition is not in this grammar, it's nonlocal
+											retval.code.setAttribute("scope", rdef2.grammar);
+										}
+										if ( targ!=null )
+										{
+											List args = generator.translateAction(currentRuleName,targ);
+											retval.code.setAttribute("args", args);
+										}
+									}
+									int i = ((TokenWithIndex)t.Token).TokenIndex;
+									retval.code.setAttribute("elementIndex", i);
+									if ( label!=null )
+										retval.code.setAttribute("label", labelText);
+								}
+								else
+								{
+									retval.code = getTokenElementST("tokenRef", (t!=null?t.Text:null), t, astSuffix, labelText);
+									string tokenLabel =
+										generator.getTokenTypeAsTargetLabel(grammar.getTokenType(t.Text));
+									retval.code.setAttribute("token",tokenLabel);
+									if ( !currentAltHasASTRewrite && t.terminalOptions!=null )
+									{
+										retval.code.setAttribute("hetero",t.terminalOptions[Grammar.defaultTokenOption]);
+									}
+									int i = ((TokenWithIndex)t.Token).TokenIndex;
+									retval.code.setAttribute("elementIndex", i);
+									generator.generateLocalFOLLOW(t,tokenLabel,currentRuleName,i);
+								}
+								t.code = retval.code;
+
+				}
+
+				}
+				break;
+			case 3:
+				// Grammars\\CodeGenTreeWalker.g3:894:4: c= CHAR_LITERAL
+				{
+				c=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_atom1513); if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+
+								if ( grammar.type==Grammar.LEXER )
+								{
+									retval.code = templates.getInstanceOf("charRef");
+									retval.code.setAttribute("char",
+									   generator.target.getTargetCharLiteralFromANTLRCharLiteral(generator,(c!=null?c.Text:null)));
+									if ( label!=null )
+									{
+										retval.code.setAttribute("label", labelText);
+									}
+								}
+								else { // else it's a token type reference
+									retval.code = getTokenElementST("tokenRef", "char_literal", c, astSuffix, labelText);
+									string tokenLabel = generator.getTokenTypeAsTargetLabel(grammar.getTokenType((c!=null?c.Text:null)));
+									retval.code.setAttribute("token",tokenLabel);
+									if ( c.terminalOptions!=null ) {
+										retval.code.setAttribute("hetero",c.terminalOptions[Grammar.defaultTokenOption]);
+									}
+									int i = ((TokenWithIndex)c.Token).TokenIndex;
+									retval.code.setAttribute("elementIndex", i);
+									generator.generateLocalFOLLOW(c,tokenLabel,currentRuleName,i);
+								}
+
+				}
+
+				}
+				break;
+			case 4:
+				// Grammars\\CodeGenTreeWalker.g3:919:4: s= STRING_LITERAL
+				{
+				s=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_atom1526); if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+
+								if ( grammar.type==Grammar.LEXER )
+								{
+									retval.code = templates.getInstanceOf("lexerStringRef");
+									retval.code.setAttribute("string",
+										generator.target.getTargetStringLiteralFromANTLRStringLiteral(generator,(s!=null?s.Text:null)));
+									if ( label!=null )
+									{
+										retval.code.setAttribute("label", labelText);
+									}
+								}
+								else
+								{ // else it's a token type reference
+									retval.code = getTokenElementST("tokenRef", "string_literal", s, astSuffix, labelText);
+									string tokenLabel =
+										generator.getTokenTypeAsTargetLabel(grammar.getTokenType((s!=null?s.Text:null)));
+									retval.code.setAttribute("token",tokenLabel);
+									if ( s.terminalOptions!=null )
+									{
+										retval.code.setAttribute("hetero",s.terminalOptions[Grammar.defaultTokenOption]);
+									}
+									int i = ((TokenWithIndex)s.Token).TokenIndex;
+									retval.code.setAttribute("elementIndex", i);
+									generator.generateLocalFOLLOW(s,tokenLabel,currentRuleName,i);
+								}
+
+				}
+
+				}
+				break;
+			case 5:
+				// Grammars\\CodeGenTreeWalker.g3:947:4: w= WILDCARD
+				{
+				w=(GrammarAST)Match(input,WILDCARD,Follow._WILDCARD_in_atom1538); if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+
+								retval.code = getWildcardST(w,astSuffix,labelText);
+								retval.code.setAttribute("elementIndex", ((TokenWithIndex)w.Token).TokenIndex);
+
+				}
+
+				}
+				break;
+			case 6:
+				// Grammars\\CodeGenTreeWalker.g3:953:4: ^( DOT ID a= atom[$ID, label, astSuffix] )
+				{
+				Match(input,DOT,Follow._DOT_in_atom1549); if (state.failed) return retval;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				ID12=(GrammarAST)Match(input,ID,Follow._ID_in_atom1551); if (state.failed) return retval;
+				PushFollow(Follow._atom_in_atom1555);
+				a=atom(ID12, label, astSuffix);
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+					 retval.code = (a!=null?a.code:default(StringTemplate));
+				}
+
+				}
+				break;
+			case 7:
+				// Grammars\\CodeGenTreeWalker.g3:956:4: set[label,astSuffix]
+				{
+				PushFollow(Follow._set_in_atom1568);
+				set13=set(label, astSuffix);
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+					 retval.code = set13;
+				}
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "atom"
+
+
+	// $ANTLR start "ast_suffix"
+	// Grammars\\CodeGenTreeWalker.g3:960:0: ast_suffix : ( ROOT | BANG );
+	private void ast_suffix(  )
+	{
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:961:4: ( ROOT | BANG )
+			// Grammars\\CodeGenTreeWalker.g3:
+			{
+			if ( input.LA(1)==BANG||input.LA(1)==ROOT )
+			{
+				input.Consume();
+				state.errorRecovery=false;state.failed=false;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				throw mse;
+			}
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "ast_suffix"
+
+
+	// $ANTLR start "set"
+	// Grammars\\CodeGenTreeWalker.g3:965:0: set[GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null] : ^(s= BLOCK ( . )* ) ;
+	private StringTemplate set( GrammarAST label, GrammarAST astSuffix )
+	{
+
+		StringTemplate code = null;
+
+		GrammarAST s=null;
+
+
+			string labelText=null;
+			if ( label!=null )
+			{
+				labelText = label.Text;
+			}
+
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:974:4: ( ^(s= BLOCK ( . )* ) )
+			// Grammars\\CodeGenTreeWalker.g3:974:4: ^(s= BLOCK ( . )* )
+			{
+			s=(GrammarAST)Match(input,BLOCK,Follow._BLOCK_in_set1613); if (state.failed) return code;
+
+			if ( input.LA(1)==TokenConstants.DOWN )
+			{
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return code;
+				// Grammars\\CodeGenTreeWalker.g3:974:14: ( . )*
+				for ( ; ; )
+				{
+					int alt55=2;
+					int LA55_0 = input.LA(1);
+
+					if ( ((LA55_0>=ACTION && LA55_0<=XDIGIT)) )
+					{
+						alt55=1;
+					}
+					else if ( (LA55_0==UP) )
+					{
+						alt55=2;
+					}
+
+
+					switch ( alt55 )
+					{
+					case 1:
+						// Grammars\\CodeGenTreeWalker.g3:974:0: .
+						{
+						MatchAny(input); if (state.failed) return code;
+
+						}
+						break;
+
+					default:
+						goto loop55;
+					}
+				}
+
+				loop55:
+					;
+
+
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return code;
+			}
+			if ( state.backtracking == 0 )
+			{
+
+							code = getTokenElementST("matchSet", "set", s, astSuffix, labelText);
+							int i = ((TokenWithIndex)s.Token).TokenIndex;
+							code.setAttribute("elementIndex", i);
+							if ( grammar.type!=Grammar.LEXER )
+							{
+								generator.generateLocalFOLLOW(s,"set",currentRuleName,i);
+							}
+							code.setAttribute("s", generator.genSetExpr(templates,s.SetValue,1,false));
+
+			}
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return code;
+	}
+	// $ANTLR end "set"
+
+
+	// $ANTLR start "setElement"
+	// Grammars\\CodeGenTreeWalker.g3:987:0: setElement : ( CHAR_LITERAL | TOKEN_REF | STRING_LITERAL | ^( CHAR_RANGE CHAR_LITERAL CHAR_LITERAL ) );
+	private void setElement(  )
+	{
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:988:4: ( CHAR_LITERAL | TOKEN_REF | STRING_LITERAL | ^( CHAR_RANGE CHAR_LITERAL CHAR_LITERAL ) )
+			int alt56=4;
+			switch ( input.LA(1) )
+			{
+			case CHAR_LITERAL:
+				{
+				alt56=1;
+				}
+				break;
+			case TOKEN_REF:
+				{
+				alt56=2;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt56=3;
+				}
+				break;
+			case CHAR_RANGE:
+				{
+				alt56=4;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return ;}
+					NoViableAltException nvae = new NoViableAltException("", 56, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt56 )
+			{
+			case 1:
+				// Grammars\\CodeGenTreeWalker.g3:988:4: CHAR_LITERAL
+				{
+				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_setElement1633); if (state.failed) return ;
+
+				}
+				break;
+			case 2:
+				// Grammars\\CodeGenTreeWalker.g3:989:4: TOKEN_REF
+				{
+				Match(input,TOKEN_REF,Follow._TOKEN_REF_in_setElement1638); if (state.failed) return ;
+
+				}
+				break;
+			case 3:
+				// Grammars\\CodeGenTreeWalker.g3:990:4: STRING_LITERAL
+				{
+				Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_setElement1643); if (state.failed) return ;
+
+				}
+				break;
+			case 4:
+				// Grammars\\CodeGenTreeWalker.g3:991:4: ^( CHAR_RANGE CHAR_LITERAL CHAR_LITERAL )
+				{
+				Match(input,CHAR_RANGE,Follow._CHAR_RANGE_in_setElement1649); if (state.failed) return ;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_setElement1651); if (state.failed) return ;
+				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_setElement1653); if (state.failed) return ;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "setElement"
+
+	public class rewrite_return : TreeRuleReturnScope
+	{
+		public StringTemplate code=null;
+	}
+
+	// $ANTLR start "rewrite"
+	// Grammars\\CodeGenTreeWalker.g3:996:0: rewrite returns [StringTemplate code=null] : ( ^(r= REWRITE (pred= SEMPRED )? alt= rewrite_alternative ) )* ;
+	private CodeGenTreeWalker.rewrite_return rewrite(  )
+	{
+		CodeGenTreeWalker.rewrite_return retval = new CodeGenTreeWalker.rewrite_return();
+		retval.start = input.LT(1);
+
+		GrammarAST r=null;
+		GrammarAST pred=null;
+		StringTemplate alt = default(StringTemplate);
+
+
+			if ( state.backtracking == 0 )
+			{
+				if ( ((GrammarAST)retval.start).Type==REWRITE )
+				{
+					if ( generator.grammar.BuildTemplate )
+					{
+						retval.code = templates.getInstanceOf("rewriteTemplate");
+					}
+					else
+					{
+						retval.code = templates.getInstanceOf("rewriteCode");
+						retval.code.setAttribute("treeLevel", OUTER_REWRITE_NESTING_LEVEL);
+						retval.code.setAttribute("rewriteBlockLevel", OUTER_REWRITE_NESTING_LEVEL);
+						retval.code.setAttribute("referencedElementsDeep",
+										  getTokenTypesAsTargetLabels(((GrammarAST)retval.start).rewriteRefsDeep));
+						HashSet<string> tokenLabels =
+							grammar.getLabels(((GrammarAST)retval.start).rewriteRefsDeep, Grammar.TOKEN_LABEL);
+						HashSet<string> tokenListLabels =
+							grammar.getLabels(((GrammarAST)retval.start).rewriteRefsDeep, Grammar.TOKEN_LIST_LABEL);
+						HashSet<string> ruleLabels =
+							grammar.getLabels(((GrammarAST)retval.start).rewriteRefsDeep, Grammar.RULE_LABEL);
+						HashSet<string> ruleListLabels =
+							grammar.getLabels(((GrammarAST)retval.start).rewriteRefsDeep, Grammar.RULE_LIST_LABEL);
+						HashSet<string> wildcardLabels =
+							grammar.getLabels(((GrammarAST)retval.start).rewriteRefsDeep, Grammar.WILDCARD_TREE_LABEL);
+						HashSet<string> wildcardListLabels =
+							grammar.getLabels(((GrammarAST)retval.start).rewriteRefsDeep, Grammar.WILDCARD_TREE_LIST_LABEL);
+						// just in case they ref r for "previous value", make a stream
+						// from retval.tree
+						StringTemplate retvalST = templates.getInstanceOf("prevRuleRootRef");
+						ruleLabels.Add(retvalST.ToString());
+						retval.code.setAttribute("referencedTokenLabels", tokenLabels);
+						retval.code.setAttribute("referencedTokenListLabels", tokenListLabels);
+						retval.code.setAttribute("referencedRuleLabels", ruleLabels);
+						retval.code.setAttribute("referencedRuleListLabels", ruleListLabels);
+						retval.code.setAttribute("referencedWildcardLabels", wildcardLabels);
+						retval.code.setAttribute("referencedWildcardListLabels", wildcardListLabels);
+					}
+				}
+				else
+				{
+						retval.code = templates.getInstanceOf("noRewrite");
+						retval.code.setAttribute("treeLevel", OUTER_REWRITE_NESTING_LEVEL);
+						retval.code.setAttribute("rewriteBlockLevel", OUTER_REWRITE_NESTING_LEVEL);
+				}
+			}
+
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:1046:4: ( ( ^(r= REWRITE (pred= SEMPRED )? alt= rewrite_alternative ) )* )
+			// Grammars\\CodeGenTreeWalker.g3:1046:4: ( ^(r= REWRITE (pred= SEMPRED )? alt= rewrite_alternative ) )*
+			{
+			// Grammars\\CodeGenTreeWalker.g3:1046:4: ( ^(r= REWRITE (pred= SEMPRED )? alt= rewrite_alternative ) )*
+			for ( ; ; )
+			{
+				int alt58=2;
+				int LA58_0 = input.LA(1);
+
+				if ( (LA58_0==REWRITE) )
+				{
+					alt58=1;
+				}
+
+
+				switch ( alt58 )
+				{
+				case 1:
+					// Grammars\\CodeGenTreeWalker.g3:1047:4: ^(r= REWRITE (pred= SEMPRED )? alt= rewrite_alternative )
+					{
+					if ( state.backtracking == 0 )
+					{
+						rewriteRuleRefs = new HashSet<object>();
+					}
+					r=(GrammarAST)Match(input,REWRITE,Follow._REWRITE_in_rewrite1690); if (state.failed) return retval;
+
+					Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+					// Grammars\\CodeGenTreeWalker.g3:1048:17: (pred= SEMPRED )?
+					int alt57=2;
+					int LA57_0 = input.LA(1);
+
+					if ( (LA57_0==SEMPRED) )
+					{
+						alt57=1;
+					}
+					switch ( alt57 )
+					{
+					case 1:
+						// Grammars\\CodeGenTreeWalker.g3:1048:18: pred= SEMPRED
+						{
+						pred=(GrammarAST)Match(input,SEMPRED,Follow._SEMPRED_in_rewrite1695); if (state.failed) return retval;
+
+						}
+						break;
+
+					}
+
+					PushFollow(Follow._rewrite_alternative_in_rewrite1701);
+					alt=rewrite_alternative();
+
+					state._fsp--;
+					if (state.failed) return retval;
+
+					Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+					if ( state.backtracking == 0 )
+					{
+
+										rewriteBlockNestingLevel = OUTER_REWRITE_NESTING_LEVEL;
+										List predChunks = null;
+										if ( pred!=null )
+										{
+											//predText = #pred.getText();
+											predChunks = generator.translateAction(currentRuleName,pred);
+										}
+										string description =
+											grammar.grammarTreeToString(r,false);
+										description = generator.target.getTargetStringLiteralFromString(description);
+										retval.code.setAttribute("alts.{pred,alt,description}",
+														  predChunks,
+														  alt,
+														  description);
+										pred=null;
+
+					}
+
+					}
+					break;
+
+				default:
+					goto loop58;
+				}
+			}
+
+			loop58:
+				;
+
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite"
+
+
+	// $ANTLR start "rewrite_block"
+	// Grammars\\CodeGenTreeWalker.g3:1069:0: rewrite_block[string blockTemplateName] returns [StringTemplate code=null] : ^( BLOCK alt= rewrite_alternative EOB ) ;
+	private StringTemplate rewrite_block( string blockTemplateName )
+	{
+
+		StringTemplate code = null;
+
+		GrammarAST BLOCK14=null;
+		StringTemplate alt = default(StringTemplate);
+
+
+			rewriteBlockNestingLevel++;
+			StringTemplate save_currentBlockST = currentBlockST;
+			if ( state.backtracking == 0 )
+			{
+				code = templates.getInstanceOf(blockTemplateName);
+				currentBlockST = code;
+				code.setAttribute("rewriteBlockLevel", rewriteBlockNestingLevel);
+			}
+
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:1081:4: ( ^( BLOCK alt= rewrite_alternative EOB ) )
+			// Grammars\\CodeGenTreeWalker.g3:1081:4: ^( BLOCK alt= rewrite_alternative EOB )
+			{
+			BLOCK14=(GrammarAST)Match(input,BLOCK,Follow._BLOCK_in_rewrite_block1736); if (state.failed) return code;
+
+			if ( state.backtracking == 0 )
+			{
+
+								currentBlockST.setAttribute("referencedElementsDeep",
+									getTokenTypesAsTargetLabels(BLOCK14.rewriteRefsDeep));
+								currentBlockST.setAttribute("referencedElements",
+									getTokenTypesAsTargetLabels(BLOCK14.rewriteRefsShallow));
+
+			}
+
+			Match(input, TokenConstants.DOWN, null); if (state.failed) return code;
+			PushFollow(Follow._rewrite_alternative_in_rewrite_block1748);
+			alt=rewrite_alternative();
+
+			state._fsp--;
+			if (state.failed) return code;
+			Match(input,EOB,Follow._EOB_in_rewrite_block1753); if (state.failed) return code;
+
+			Match(input, TokenConstants.UP, null); if (state.failed) return code;
+			if ( state.backtracking == 0 )
+			{
+
+							code.setAttribute("alt", alt);
+
+			}
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+			 rewriteBlockNestingLevel--; currentBlockST = save_currentBlockST;
+		}
+		return code;
+	}
+	// $ANTLR end "rewrite_block"
+
+
+	// $ANTLR start "rewrite_alternative"
+	// Grammars\\CodeGenTreeWalker.g3:1097:0: rewrite_alternative returns [StringTemplate code=null] : ({...}? ^(a= ALT ( (el= rewrite_element )+ | EPSILON ) EOA ) |{...}? rewrite_template | ETC );
+	private StringTemplate rewrite_alternative(  )
+	{
+
+		StringTemplate code = null;
+
+		GrammarAST a=null;
+		CodeGenTreeWalker.rewrite_element_return el = default(CodeGenTreeWalker.rewrite_element_return);
+		StringTemplate rewrite_template15 = default(StringTemplate);
+
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:1098:4: ({...}? ^(a= ALT ( (el= rewrite_element )+ | EPSILON ) EOA ) |{...}? rewrite_template | ETC )
+			int alt61=3;
+			switch ( input.LA(1) )
+			{
+			case ALT:
+				{
+				int LA61_1 = input.LA(2);
+
+				if ( (LA61_1==DOWN) )
+				{
+					int LA61_4 = input.LA(3);
+
+					if ( (LA61_4==EPSILON) )
+					{
+						int LA61_5 = input.LA(4);
+
+						if ( (LA61_5==EOA) )
+						{
+							int LA61_7 = input.LA(5);
+
+							if ( (LA61_7==UP) )
+							{
+								int LA61_8 = input.LA(6);
+
+								if ( ((generator.grammar.BuildAST)) )
+								{
+									alt61=1;
+								}
+								else if ( ((generator.grammar.BuildTemplate)) )
+								{
+									alt61=2;
+								}
+								else
+								{
+									if (state.backtracking>0) {state.failed=true; return code;}
+									NoViableAltException nvae = new NoViableAltException("", 61, 8, input);
+
+									throw nvae;
+								}
+							}
+							else
+							{
+								if (state.backtracking>0) {state.failed=true; return code;}
+								NoViableAltException nvae = new NoViableAltException("", 61, 7, input);
+
+								throw nvae;
+							}
+						}
+						else
+						{
+							if (state.backtracking>0) {state.failed=true; return code;}
+							NoViableAltException nvae = new NoViableAltException("", 61, 5, input);
+
+							throw nvae;
+						}
+					}
+					else if ( (LA61_4==ACTION||LA61_4==CHAR_LITERAL||LA61_4==CLOSURE||LA61_4==LABEL||LA61_4==OPTIONAL||LA61_4==POSITIVE_CLOSURE||LA61_4==RULE_REF||LA61_4==STRING_LITERAL||LA61_4==TOKEN_REF||LA61_4==TREE_BEGIN) )
+					{
+						alt61=1;
+					}
+					else
+					{
+						if (state.backtracking>0) {state.failed=true; return code;}
+						NoViableAltException nvae = new NoViableAltException("", 61, 4, input);
+
+						throw nvae;
+					}
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return code;}
+					NoViableAltException nvae = new NoViableAltException("", 61, 1, input);
+
+					throw nvae;
+				}
+				}
+				break;
+			case ACTION:
+			case TEMPLATE:
+				{
+				alt61=2;
+				}
+				break;
+			case ETC:
+				{
+				alt61=3;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return code;}
+					NoViableAltException nvae = new NoViableAltException("", 61, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt61 )
+			{
+			case 1:
+				// Grammars\\CodeGenTreeWalker.g3:1098:4: {...}? ^(a= ALT ( (el= rewrite_element )+ | EPSILON ) EOA )
+				{
+				if ( !((generator.grammar.BuildAST)) )
+				{
+					if (state.backtracking>0) {state.failed=true; return code;}
+					throw new FailedPredicateException(input, "rewrite_alternative", "generator.grammar.BuildAST");
+				}
+				a=(GrammarAST)Match(input,ALT,Follow._ALT_in_rewrite_alternative1788); if (state.failed) return code;
+
+				if ( state.backtracking == 0 )
+				{
+					code =templates.getInstanceOf("rewriteElementList");
+				}
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return code;
+				// Grammars\\CodeGenTreeWalker.g3:1100:4: ( (el= rewrite_element )+ | EPSILON )
+				int alt60=2;
+				int LA60_0 = input.LA(1);
+
+				if ( (LA60_0==ACTION||LA60_0==CHAR_LITERAL||LA60_0==CLOSURE||LA60_0==LABEL||LA60_0==OPTIONAL||LA60_0==POSITIVE_CLOSURE||LA60_0==RULE_REF||LA60_0==STRING_LITERAL||LA60_0==TOKEN_REF||LA60_0==TREE_BEGIN) )
+				{
+					alt60=1;
+				}
+				else if ( (LA60_0==EPSILON) )
+				{
+					alt60=2;
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return code;}
+					NoViableAltException nvae = new NoViableAltException("", 60, 0, input);
+
+					throw nvae;
+				}
+				switch ( alt60 )
+				{
+				case 1:
+					// Grammars\\CodeGenTreeWalker.g3:1100:6: (el= rewrite_element )+
+					{
+					// Grammars\\CodeGenTreeWalker.g3:1100:6: (el= rewrite_element )+
+					int cnt59=0;
+					for ( ; ; )
+					{
+						int alt59=2;
+						int LA59_0 = input.LA(1);
+
+						if ( (LA59_0==ACTION||LA59_0==CHAR_LITERAL||LA59_0==CLOSURE||LA59_0==LABEL||LA59_0==OPTIONAL||LA59_0==POSITIVE_CLOSURE||LA59_0==RULE_REF||LA59_0==STRING_LITERAL||LA59_0==TOKEN_REF||LA59_0==TREE_BEGIN) )
+						{
+							alt59=1;
+						}
+
+
+						switch ( alt59 )
+						{
+						case 1:
+							// Grammars\\CodeGenTreeWalker.g3:1101:6: el= rewrite_element
+							{
+							PushFollow(Follow._rewrite_element_in_rewrite_alternative1806);
+							el=rewrite_element();
+
+							state._fsp--;
+							if (state.failed) return code;
+							if ( state.backtracking == 0 )
+							{
+								code.setAttribute("elements.{el,line,pos}",
+																		(el!=null?el.code:default(StringTemplate)),
+																		(el!=null?((GrammarAST)el.start):null).Line,
+																		(el!=null?((GrammarAST)el.start):null).CharPositionInLine
+																		);
+
+							}
+
+							}
+							break;
+
+						default:
+							if ( cnt59 >= 1 )
+								goto loop59;
+
+							if (state.backtracking>0) {state.failed=true; return code;}
+							EarlyExitException eee59 = new EarlyExitException( 59, input );
+							throw eee59;
+						}
+						cnt59++;
+					}
+					loop59:
+						;
+
+
+
+					}
+					break;
+				case 2:
+					// Grammars\\CodeGenTreeWalker.g3:1109:6: EPSILON
+					{
+					Match(input,EPSILON,Follow._EPSILON_in_rewrite_alternative1827); if (state.failed) return code;
+					if ( state.backtracking == 0 )
+					{
+						code.setAttribute("elements.{el,line,pos}",
+														   templates.getInstanceOf("rewriteEmptyAlt"),
+														   a.Line,
+														   a.CharPositionInLine
+														   );
+
+					}
+
+					}
+					break;
+
+				}
+
+				Match(input,EOA,Follow._EOA_in_rewrite_alternative1843); if (state.failed) return code;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return code;
+
+				}
+				break;
+			case 2:
+				// Grammars\\CodeGenTreeWalker.g3:1120:4: {...}? rewrite_template
+				{
+				if ( !((generator.grammar.BuildTemplate)) )
+				{
+					if (state.backtracking>0) {state.failed=true; return code;}
+					throw new FailedPredicateException(input, "rewrite_alternative", "generator.grammar.BuildTemplate");
+				}
+				PushFollow(Follow._rewrite_template_in_rewrite_alternative1856);
+				rewrite_template15=rewrite_template();
+
+				state._fsp--;
+				if (state.failed) return code;
+				if ( state.backtracking == 0 )
+				{
+					 code = rewrite_template15;
+				}
+
+				}
+				break;
+			case 3:
+				// Grammars\\CodeGenTreeWalker.g3:1124:3: ETC
+				{
+				Match(input,ETC,Follow._ETC_in_rewrite_alternative1869); if (state.failed) return code;
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return code;
+	}
+	// $ANTLR end "rewrite_alternative"
+
+	public class rewrite_element_return : TreeRuleReturnScope
+	{
+		public StringTemplate code=null;
+	}
+
+	// $ANTLR start "rewrite_element"
+	// Grammars\\CodeGenTreeWalker.g3:1127:0: rewrite_element returns [StringTemplate code=null] : ( rewrite_atom[false] | rewrite_ebnf | rewrite_tree );
+	private CodeGenTreeWalker.rewrite_element_return rewrite_element(  )
+	{
+		CodeGenTreeWalker.rewrite_element_return retval = new CodeGenTreeWalker.rewrite_element_return();
+		retval.start = input.LT(1);
+
+		CodeGenTreeWalker.rewrite_atom_return rewrite_atom16 = default(CodeGenTreeWalker.rewrite_atom_return);
+		CodeGenTreeWalker.rewrite_ebnf_return rewrite_ebnf17 = default(CodeGenTreeWalker.rewrite_ebnf_return);
+		CodeGenTreeWalker.rewrite_tree_return rewrite_tree18 = default(CodeGenTreeWalker.rewrite_tree_return);
+
+
+			IIntSet elements=null;
+			GrammarAST ast = null;
+
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:1133:4: ( rewrite_atom[false] | rewrite_ebnf | rewrite_tree )
+			int alt62=3;
+			switch ( input.LA(1) )
+			{
+			case ACTION:
+			case CHAR_LITERAL:
+			case LABEL:
+			case RULE_REF:
+			case STRING_LITERAL:
+			case TOKEN_REF:
+				{
+				alt62=1;
+				}
+				break;
+			case CLOSURE:
+			case OPTIONAL:
+			case POSITIVE_CLOSURE:
+				{
+				alt62=2;
+				}
+				break;
+			case TREE_BEGIN:
+				{
+				alt62=3;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 62, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt62 )
+			{
+			case 1:
+				// Grammars\\CodeGenTreeWalker.g3:1133:4: rewrite_atom[false]
+				{
+				PushFollow(Follow._rewrite_atom_in_rewrite_element1889);
+				rewrite_atom16=rewrite_atom(false);
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+					 retval.code = (rewrite_atom16!=null?rewrite_atom16.code:default(StringTemplate));
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\CodeGenTreeWalker.g3:1135:4: rewrite_ebnf
+				{
+				PushFollow(Follow._rewrite_ebnf_in_rewrite_element1899);
+				rewrite_ebnf17=rewrite_ebnf();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+					 retval.code = (rewrite_ebnf17!=null?rewrite_ebnf17.code:default(StringTemplate));
+				}
+
+				}
+				break;
+			case 3:
+				// Grammars\\CodeGenTreeWalker.g3:1137:4: rewrite_tree
+				{
+				PushFollow(Follow._rewrite_tree_in_rewrite_element1908);
+				rewrite_tree18=rewrite_tree();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+					 retval.code = (rewrite_tree18!=null?rewrite_tree18.code:default(StringTemplate));
+				}
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_element"
+
+	public class rewrite_ebnf_return : TreeRuleReturnScope
+	{
+		public StringTemplate code=null;
+	}
+
+	// $ANTLR start "rewrite_ebnf"
+	// Grammars\\CodeGenTreeWalker.g3:1141:0: rewrite_ebnf returns [StringTemplate code=null] : ( ^( OPTIONAL rewrite_block[\"rewriteOptionalBlock\"] ) | ^( CLOSURE rewrite_block[\"rewriteClosureBlock\"] ) | ^( POSITIVE_CLOSURE rewrite_block[\"rewritePositiveClosureBlock\"] ) );
+	private CodeGenTreeWalker.rewrite_ebnf_return rewrite_ebnf(  )
+	{
+		CodeGenTreeWalker.rewrite_ebnf_return retval = new CodeGenTreeWalker.rewrite_ebnf_return();
+		retval.start = input.LT(1);
+
+		StringTemplate rewrite_block19 = default(StringTemplate);
+		StringTemplate rewrite_block20 = default(StringTemplate);
+		StringTemplate rewrite_block21 = default(StringTemplate);
+
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:1142:4: ( ^( OPTIONAL rewrite_block[\"rewriteOptionalBlock\"] ) | ^( CLOSURE rewrite_block[\"rewriteClosureBlock\"] ) | ^( POSITIVE_CLOSURE rewrite_block[\"rewritePositiveClosureBlock\"] ) )
+			int alt63=3;
+			switch ( input.LA(1) )
+			{
+			case OPTIONAL:
+				{
+				alt63=1;
+				}
+				break;
+			case CLOSURE:
+				{
+				alt63=2;
+				}
+				break;
+			case POSITIVE_CLOSURE:
+				{
+				alt63=3;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 63, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt63 )
+			{
+			case 1:
+				// Grammars\\CodeGenTreeWalker.g3:1142:4: ^( OPTIONAL rewrite_block[\"rewriteOptionalBlock\"] )
+				{
+				Match(input,OPTIONAL,Follow._OPTIONAL_in_rewrite_ebnf1929); if (state.failed) return retval;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				PushFollow(Follow._rewrite_block_in_rewrite_ebnf1931);
+				rewrite_block19=rewrite_block("rewriteOptionalBlock");
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+					 retval.code = rewrite_block19;
+				}
+				if ( state.backtracking == 0 )
+				{
+
+								string description = grammar.grammarTreeToString(((GrammarAST)retval.start), false);
+								description = generator.target.getTargetStringLiteralFromString(description);
+								retval.code.setAttribute("description", description);
+
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\CodeGenTreeWalker.g3:1149:4: ^( CLOSURE rewrite_block[\"rewriteClosureBlock\"] )
+				{
+				Match(input,CLOSURE,Follow._CLOSURE_in_rewrite_ebnf1949); if (state.failed) return retval;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				PushFollow(Follow._rewrite_block_in_rewrite_ebnf1951);
+				rewrite_block20=rewrite_block("rewriteClosureBlock");
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+					 retval.code = rewrite_block20;
+				}
+				if ( state.backtracking == 0 )
+				{
+
+								string description = grammar.grammarTreeToString(((GrammarAST)retval.start), false);
+								description = generator.target.getTargetStringLiteralFromString(description);
+								retval.code.setAttribute("description", description);
+
+				}
+
+				}
+				break;
+			case 3:
+				// Grammars\\CodeGenTreeWalker.g3:1156:4: ^( POSITIVE_CLOSURE rewrite_block[\"rewritePositiveClosureBlock\"] )
+				{
+				Match(input,POSITIVE_CLOSURE,Follow._POSITIVE_CLOSURE_in_rewrite_ebnf1969); if (state.failed) return retval;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				PushFollow(Follow._rewrite_block_in_rewrite_ebnf1971);
+				rewrite_block21=rewrite_block("rewritePositiveClosureBlock");
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+					 retval.code = rewrite_block21;
+				}
+				if ( state.backtracking == 0 )
+				{
+
+								string description = grammar.grammarTreeToString(((GrammarAST)retval.start), false);
+								description = generator.target.getTargetStringLiteralFromString(description);
+								retval.code.setAttribute("description", description);
+
+				}
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_ebnf"
+
+	public class rewrite_tree_return : TreeRuleReturnScope
+	{
+		public StringTemplate code;
+	}
+
+	// $ANTLR start "rewrite_tree"
+	// Grammars\\CodeGenTreeWalker.g3:1165:0: rewrite_tree returns [StringTemplate code] : ^( TREE_BEGIN r= rewrite_atom[true] (el= rewrite_element )* ) ;
+	private CodeGenTreeWalker.rewrite_tree_return rewrite_tree(  )
+	{
+		CodeGenTreeWalker.rewrite_tree_return retval = new CodeGenTreeWalker.rewrite_tree_return();
+		retval.start = input.LT(1);
+
+		CodeGenTreeWalker.rewrite_atom_return r = default(CodeGenTreeWalker.rewrite_atom_return);
+		CodeGenTreeWalker.rewrite_element_return el = default(CodeGenTreeWalker.rewrite_element_return);
+
+
+			rewriteTreeNestingLevel++;
+			if ( state.backtracking == 0 )
+			{
+				retval.code = templates.getInstanceOf("rewriteTree");
+				retval.code.setAttribute("treeLevel", rewriteTreeNestingLevel);
+				retval.code.setAttribute("enclosingTreeLevel", rewriteTreeNestingLevel-1);
+			}
+
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:1176:4: ( ^( TREE_BEGIN r= rewrite_atom[true] (el= rewrite_element )* ) )
+			// Grammars\\CodeGenTreeWalker.g3:1176:4: ^( TREE_BEGIN r= rewrite_atom[true] (el= rewrite_element )* )
+			{
+			Match(input,TREE_BEGIN,Follow._TREE_BEGIN_in_rewrite_tree2004); if (state.failed) return retval;
+
+			Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+			PushFollow(Follow._rewrite_atom_in_rewrite_tree2011);
+			r=rewrite_atom(true);
+
+			state._fsp--;
+			if (state.failed) return retval;
+			if ( state.backtracking == 0 )
+			{
+
+								retval.code.setAttribute("root.{el,line,pos}",
+												   (r!=null?r.code:default(StringTemplate)),
+												   (r!=null?((GrammarAST)r.start):null).Line,
+												   (r!=null?((GrammarAST)r.start):null).CharPositionInLine
+												  );
+
+			}
+			// Grammars\\CodeGenTreeWalker.g3:1185:4: (el= rewrite_element )*
+			for ( ; ; )
+			{
+				int alt64=2;
+				int LA64_0 = input.LA(1);
+
+				if ( (LA64_0==ACTION||LA64_0==CHAR_LITERAL||LA64_0==CLOSURE||LA64_0==LABEL||LA64_0==OPTIONAL||LA64_0==POSITIVE_CLOSURE||LA64_0==RULE_REF||LA64_0==STRING_LITERAL||LA64_0==TOKEN_REF||LA64_0==TREE_BEGIN) )
+				{
+					alt64=1;
+				}
+
+
+				switch ( alt64 )
+				{
+				case 1:
+					// Grammars\\CodeGenTreeWalker.g3:1186:6: el= rewrite_element
+					{
+					PushFollow(Follow._rewrite_element_in_rewrite_tree2031);
+					el=rewrite_element();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 )
+					{
+
+										retval.code.setAttribute("children.{el,line,pos}",
+															(el!=null?el.code:default(StringTemplate)),
+															(el!=null?((GrammarAST)el.start):null).Line,
+															(el!=null?((GrammarAST)el.start):null).CharPositionInLine
+															);
+
+					}
+
+					}
+					break;
+
+				default:
+					goto loop64;
+				}
+			}
+
+			loop64:
+				;
+
+
+
+			Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+			if ( state.backtracking == 0 )
+			{
+
+							string description = grammar.grammarTreeToString(((GrammarAST)retval.start), false);
+							description = generator.target.getTargetStringLiteralFromString(description);
+							retval.code.setAttribute("description", description);
+
+			}
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+			 rewriteTreeNestingLevel--;
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_tree"
+
+	public class rewrite_atom_return : TreeRuleReturnScope
+	{
+		public StringTemplate code=null;
+	}
+
+	// $ANTLR start "rewrite_atom"
+	// Grammars\\CodeGenTreeWalker.g3:1204:0: rewrite_atom[bool isRoot] returns [StringTemplate code=null] : (r= RULE_REF | ( ^(tk= TOKEN_REF (arg= ARG_ACTION )? ) |cl= CHAR_LITERAL |sl= STRING_LITERAL ) | LABEL | ACTION );
+	private CodeGenTreeWalker.rewrite_atom_return rewrite_atom( bool isRoot )
+	{
+		CodeGenTreeWalker.rewrite_atom_return retval = new CodeGenTreeWalker.rewrite_atom_return();
+		retval.start = input.LT(1);
+
+		GrammarAST r=null;
+		GrammarAST tk=null;
+		GrammarAST arg=null;
+		GrammarAST cl=null;
+		GrammarAST sl=null;
+		GrammarAST LABEL22=null;
+		GrammarAST ACTION23=null;
+
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:1205:6: (r= RULE_REF | ( ^(tk= TOKEN_REF (arg= ARG_ACTION )? ) |cl= CHAR_LITERAL |sl= STRING_LITERAL ) | LABEL | ACTION )
+			int alt67=4;
+			switch ( input.LA(1) )
+			{
+			case RULE_REF:
+				{
+				alt67=1;
+				}
+				break;
+			case CHAR_LITERAL:
+			case STRING_LITERAL:
+			case TOKEN_REF:
+				{
+				alt67=2;
+				}
+				break;
+			case LABEL:
+				{
+				alt67=3;
+				}
+				break;
+			case ACTION:
+				{
+				alt67=4;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 67, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt67 )
+			{
+			case 1:
+				// Grammars\\CodeGenTreeWalker.g3:1205:6: r= RULE_REF
+				{
+				r=(GrammarAST)Match(input,RULE_REF,Follow._RULE_REF_in_rewrite_atom2076); if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+
+								string ruleRefName = (r!=null?r.Text:null);
+								string stName = "rewriteRuleRef";
+								if ( isRoot )
+								{
+									stName += "Root";
+								}
+								retval.code = templates.getInstanceOf(stName);
+								retval.code.setAttribute("rule", ruleRefName);
+								if ( grammar.getRule(ruleRefName)==null )
+								{
+									ErrorManager.grammarError(ErrorManager.MSG_UNDEFINED_RULE_REF,
+															  grammar,
+															  ((GrammarAST)(r)).Token,
+															  ruleRefName);
+									retval.code = new StringTemplate(); // blank; no code gen
+								}
+								else if ( grammar.getRule(currentRuleName)
+											 .getRuleRefsInAlt(ruleRefName,outerAltNum)==null )
+								{
+									ErrorManager.grammarError(ErrorManager.MSG_REWRITE_ELEMENT_NOT_PRESENT_ON_LHS,
+															  grammar,
+															  ((GrammarAST)(r)).Token,
+															  ruleRefName);
+									retval.code = new StringTemplate(); // blank; no code gen
+								}
+								else
+								{
+									// track all rule refs as we must copy 2nd ref to rule and beyond
+									if ( !rewriteRuleRefs.Contains(ruleRefName) )
+									{
+										rewriteRuleRefs.Add(ruleRefName);
+									}
+								}
+
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\CodeGenTreeWalker.g3:1243:3: ( ^(tk= TOKEN_REF (arg= ARG_ACTION )? ) |cl= CHAR_LITERAL |sl= STRING_LITERAL )
+				{
+				// Grammars\\CodeGenTreeWalker.g3:1243:3: ( ^(tk= TOKEN_REF (arg= ARG_ACTION )? ) |cl= CHAR_LITERAL |sl= STRING_LITERAL )
+				int alt66=3;
+				switch ( input.LA(1) )
+				{
+				case TOKEN_REF:
+					{
+					alt66=1;
+					}
+					break;
+				case CHAR_LITERAL:
+					{
+					alt66=2;
+					}
+					break;
+				case STRING_LITERAL:
+					{
+					alt66=3;
+					}
+					break;
+				default:
+					{
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae = new NoViableAltException("", 66, 0, input);
+
+						throw nvae;
+					}
+				}
+
+				switch ( alt66 )
+				{
+				case 1:
+					// Grammars\\CodeGenTreeWalker.g3:1243:5: ^(tk= TOKEN_REF (arg= ARG_ACTION )? )
+					{
+					tk=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_rewrite_atom2093); if (state.failed) return retval;
+
+					if ( input.LA(1)==TokenConstants.DOWN )
+					{
+						Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+						// Grammars\\CodeGenTreeWalker.g3:1243:20: (arg= ARG_ACTION )?
+						int alt65=2;
+						int LA65_0 = input.LA(1);
+
+						if ( (LA65_0==ARG_ACTION) )
+						{
+							alt65=1;
+						}
+						switch ( alt65 )
+						{
+						case 1:
+							// Grammars\\CodeGenTreeWalker.g3:1243:21: arg= ARG_ACTION
+							{
+							arg=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rewrite_atom2098); if (state.failed) return retval;
+
+							}
+							break;
+
+						}
+
+
+						Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+					}
+
+					}
+					break;
+				case 2:
+					// Grammars\\CodeGenTreeWalker.g3:1244:5: cl= CHAR_LITERAL
+					{
+					cl=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_rewrite_atom2109); if (state.failed) return retval;
+
+					}
+					break;
+				case 3:
+					// Grammars\\CodeGenTreeWalker.g3:1245:5: sl= STRING_LITERAL
+					{
+					sl=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_rewrite_atom2117); if (state.failed) return retval;
+
+					}
+					break;
+
+				}
+
+				if ( state.backtracking == 0 )
+				{
+
+								GrammarAST term = (tk) ?? (cl) ?? (sl);
+								string tokenName = ((GrammarAST)retval.start).Token.Text;
+								string stName = "rewriteTokenRef";
+								Rule rule = grammar.getRule(currentRuleName);
+								ICollection<string> tokenRefsInAlt = rule.getTokenRefsInAlt(outerAltNum);
+								bool createNewNode = !tokenRefsInAlt.Contains(tokenName) || arg!=null;
+								object hetero = null;
+								if ( term.terminalOptions!=null )
+								{
+									hetero = term.terminalOptions[Grammar.defaultTokenOption];
+								}
+								if ( createNewNode )
+								{
+									stName = "rewriteImaginaryTokenRef";
+								}
+								if ( isRoot )
+								{
+									stName += "Root";
+								}
+								retval.code = templates.getInstanceOf(stName);
+								retval.code.setAttribute("hetero", hetero);
+								if ( arg!=null )
+								{
+									List args = generator.translateAction(currentRuleName,arg);
+									retval.code.setAttribute("args", args);
+								}
+								retval.code.setAttribute("elementIndex", ((TokenWithIndex)((GrammarAST)retval.start).Token).TokenIndex);
+								int ttype = grammar.getTokenType(tokenName);
+								string tok = generator.getTokenTypeAsTargetLabel(ttype);
+								retval.code.setAttribute("token", tok);
+								if ( grammar.getTokenType(tokenName)==Label.INVALID )
+								{
+									ErrorManager.grammarError(ErrorManager.MSG_UNDEFINED_TOKEN_REF_IN_REWRITE,
+															  grammar,
+															  ((GrammarAST)(((GrammarAST)retval.start))).Token,
+															  tokenName);
+									retval.code = new StringTemplate(); // blank; no code gen
+								}
+
+				}
+
+				}
+				break;
+			case 3:
+				// Grammars\\CodeGenTreeWalker.g3:1288:4: LABEL
+				{
+				LABEL22=(GrammarAST)Match(input,LABEL,Follow._LABEL_in_rewrite_atom2131); if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+
+								string labelName = (LABEL22!=null?LABEL22.Text:null);
+								Rule rule = grammar.getRule(currentRuleName);
+								Grammar.LabelElementPair pair = rule.getLabel(labelName);
+								if ( labelName.Equals(currentRuleName) )
+								{
+									// special case; ref to old value via $ rule
+									if ( rule.hasRewrite(outerAltNum) &&
+										 rule.getRuleRefsInAlt(outerAltNum).Contains(labelName) )
+									{
+										ErrorManager.grammarError(ErrorManager.MSG_RULE_REF_AMBIG_WITH_RULE_IN_ALT,
+																  grammar,
+																  ((GrammarAST)(LABEL22)).Token,
+																  labelName);
+									}
+									StringTemplate labelST = templates.getInstanceOf("prevRuleRootRef");
+									retval.code = templates.getInstanceOf("rewriteRuleLabelRef"+(isRoot?"Root":""));
+									retval.code.setAttribute("label", labelST);
+								}
+								else if ( pair==null )
+								{
+									ErrorManager.grammarError(ErrorManager.MSG_UNDEFINED_LABEL_REF_IN_REWRITE,
+															  grammar,
+															  ((GrammarAST)(LABEL22)).Token,
+															  labelName);
+									retval.code = new StringTemplate();
+								}
+								else
+								{
+									string stName = null;
+									switch ( pair.type )
+									{
+									case Grammar.TOKEN_LABEL :
+										stName = "rewriteTokenLabelRef";
+										break;
+									case Grammar.WILDCARD_TREE_LABEL :
+										stName = "rewriteWildcardLabelRef";
+										break;
+									case Grammar.WILDCARD_TREE_LIST_LABEL:
+										stName = "rewriteRuleListLabelRef"; // acts like rule ref list for ref
+										break;
+									case Grammar.RULE_LABEL :
+										stName = "rewriteRuleLabelRef";
+										break;
+									case Grammar.TOKEN_LIST_LABEL :
+										stName = "rewriteTokenListLabelRef";
+										break;
+									case Grammar.RULE_LIST_LABEL :
+										stName = "rewriteRuleListLabelRef";
+										break;
+									}
+									if ( isRoot )
+									{
+										stName += "Root";
+									}
+									retval.code = templates.getInstanceOf(stName);
+									retval.code.setAttribute("label", labelName);
+								}
+
+				}
+
+				}
+				break;
+			case 4:
+				// Grammars\\CodeGenTreeWalker.g3:1349:4: ACTION
+				{
+				ACTION23=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_rewrite_atom2141); if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+
+								// actions in rewrite rules yield a tree object
+								string actText = (ACTION23!=null?ACTION23.Text:null);
+								List chunks = generator.translateAction(currentRuleName,ACTION23);
+								retval.code = templates.getInstanceOf("rewriteNodeAction"+(isRoot?"Root":""));
+								retval.code.setAttribute("action", chunks);
+
+				}
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_atom"
+
+
+	// $ANTLR start "rewrite_template"
+	// Grammars\\CodeGenTreeWalker.g3:1360:0: public rewrite_template returns [StringTemplate code=null] : ( ^( ALT EPSILON EOA ) | ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? ) |act= ACTION );
+	public StringTemplate rewrite_template(  )
+	{
+
+		StringTemplate code = null;
+
+		GrammarAST id=null;
+		GrammarAST ind=null;
+		GrammarAST arg=null;
+		GrammarAST a=null;
+		GrammarAST act=null;
+		GrammarAST DOUBLE_QUOTE_STRING_LITERAL24=null;
+		GrammarAST DOUBLE_ANGLE_STRING_LITERAL25=null;
+
+		try
+		{
+			// Grammars\\CodeGenTreeWalker.g3:1361:4: ( ^( ALT EPSILON EOA ) | ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? ) |act= ACTION )
+			int alt71=3;
+			switch ( input.LA(1) )
+			{
+			case ALT:
+				{
+				alt71=1;
+				}
+				break;
+			case TEMPLATE:
+				{
+				alt71=2;
+				}
+				break;
+			case ACTION:
+				{
+				alt71=3;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return code;}
+					NoViableAltException nvae = new NoViableAltException("", 71, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt71 )
+			{
+			case 1:
+				// Grammars\\CodeGenTreeWalker.g3:1361:4: ^( ALT EPSILON EOA )
+				{
+				Match(input,ALT,Follow._ALT_in_rewrite_template2164); if (state.failed) return code;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return code;
+				Match(input,EPSILON,Follow._EPSILON_in_rewrite_template2166); if (state.failed) return code;
+				Match(input,EOA,Follow._EOA_in_rewrite_template2168); if (state.failed) return code;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return code;
+				if ( state.backtracking == 0 )
+				{
+					code =templates.getInstanceOf("rewriteEmptyTemplate");
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\CodeGenTreeWalker.g3:1362:4: ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? )
+				{
+				Match(input,TEMPLATE,Follow._TEMPLATE_in_rewrite_template2179); if (state.failed) return code;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return code;
+				// Grammars\\CodeGenTreeWalker.g3:1362:16: (id= ID |ind= ACTION )
+				int alt68=2;
+				int LA68_0 = input.LA(1);
+
+				if ( (LA68_0==ID) )
+				{
+					alt68=1;
+				}
+				else if ( (LA68_0==ACTION) )
+				{
+					alt68=2;
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return code;}
+					NoViableAltException nvae = new NoViableAltException("", 68, 0, input);
+
+					throw nvae;
+				}
+				switch ( alt68 )
+				{
+				case 1:
+					// Grammars\\CodeGenTreeWalker.g3:1362:17: id= ID
+					{
+					id=(GrammarAST)Match(input,ID,Follow._ID_in_rewrite_template2184); if (state.failed) return code;
+
+					}
+					break;
+				case 2:
+					// Grammars\\CodeGenTreeWalker.g3:1362:23: ind= ACTION
+					{
+					ind=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_rewrite_template2188); if (state.failed) return code;
+
+					}
+					break;
+
+				}
+
+				if ( state.backtracking == 0 )
+				{
+
+									if ( id!=null && (id!=null?id.Text:null).Equals("template") )
+									{
+											code = templates.getInstanceOf("rewriteInlineTemplate");
+									}
+									else if ( id!=null )
+									{
+											code = templates.getInstanceOf("rewriteExternalTemplate");
+											code.setAttribute("name", (id!=null?id.Text:null));
+									}
+									else if ( ind!=null )
+									{ // must be %({expr})(args)
+										code = templates.getInstanceOf("rewriteIndirectTemplate");
+										List chunks=generator.translateAction(currentRuleName,ind);
+										code.setAttribute("expr", chunks);
+									}
+
+				}
+				Match(input,ARGLIST,Follow._ARGLIST_in_rewrite_template2201); if (state.failed) return code;
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null); if (state.failed) return code;
+					// Grammars\\CodeGenTreeWalker.g3:1381:5: ( ^( ARG arg= ID a= ACTION ) )*
+					for ( ; ; )
+					{
+						int alt69=2;
+						int LA69_0 = input.LA(1);
+
+						if ( (LA69_0==ARG) )
+						{
+							alt69=1;
+						}
+
+
+						switch ( alt69 )
+						{
+						case 1:
+							// Grammars\\CodeGenTreeWalker.g3:1381:7: ^( ARG arg= ID a= ACTION )
+							{
+							Match(input,ARG,Follow._ARG_in_rewrite_template2211); if (state.failed) return code;
+
+							Match(input, TokenConstants.DOWN, null); if (state.failed) return code;
+							arg=(GrammarAST)Match(input,ID,Follow._ID_in_rewrite_template2215); if (state.failed) return code;
+							a=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_rewrite_template2219); if (state.failed) return code;
+							if ( state.backtracking == 0 )
+							{
+
+														// must set alt num here rather than in define.g
+														// because actions like %foo(name={$ID.text}) aren't
+														// broken up yet into trees.
+														a.outerAltNum = this.outerAltNum;
+														List chunks = generator.translateAction(currentRuleName,a);
+														code.setAttribute("args.{name,value}", (arg!=null?arg.Text:null), chunks);
+
+							}
+
+							Match(input, TokenConstants.UP, null); if (state.failed) return code;
+
+							}
+							break;
+
+						default:
+							goto loop69;
+						}
+					}
+
+					loop69:
+						;
+
+
+
+					Match(input, TokenConstants.UP, null); if (state.failed) return code;
+				}
+				// Grammars\\CodeGenTreeWalker.g3:1393:4: ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )?
+				int alt70=3;
+				int LA70_0 = input.LA(1);
+
+				if ( (LA70_0==DOUBLE_QUOTE_STRING_LITERAL) )
+				{
+					alt70=1;
+				}
+				else if ( (LA70_0==DOUBLE_ANGLE_STRING_LITERAL) )
+				{
+					alt70=2;
+				}
+				switch ( alt70 )
+				{
+				case 1:
+					// Grammars\\CodeGenTreeWalker.g3:1393:6: DOUBLE_QUOTE_STRING_LITERAL
+					{
+					DOUBLE_QUOTE_STRING_LITERAL24=(GrammarAST)Match(input,DOUBLE_QUOTE_STRING_LITERAL,Follow._DOUBLE_QUOTE_STRING_LITERAL_in_rewrite_template2252); if (state.failed) return code;
+					if ( state.backtracking == 0 )
+					{
+
+											string sl = (DOUBLE_QUOTE_STRING_LITERAL24!=null?DOUBLE_QUOTE_STRING_LITERAL24.Text:null);
+											string t = sl.Substring( 1, sl.Length - 2 ); // strip quotes
+											t = generator.target.getTargetStringLiteralFromString(t);
+											code.setAttribute("template",t);
+
+					}
+
+					}
+					break;
+				case 2:
+					// Grammars\\CodeGenTreeWalker.g3:1400:6: DOUBLE_ANGLE_STRING_LITERAL
+					{
+					DOUBLE_ANGLE_STRING_LITERAL25=(GrammarAST)Match(input,DOUBLE_ANGLE_STRING_LITERAL,Follow._DOUBLE_ANGLE_STRING_LITERAL_in_rewrite_template2265); if (state.failed) return code;
+					if ( state.backtracking == 0 )
+					{
+
+											string sl = (DOUBLE_ANGLE_STRING_LITERAL25!=null?DOUBLE_ANGLE_STRING_LITERAL25.Text:null);
+											string t = sl.Substring( 2, sl.Length - 4 ); // strip double angle quotes
+											t = generator.target.getTargetStringLiteralFromString(t);
+											code.setAttribute("template",t);
+
+					}
+
+					}
+					break;
+
+				}
+
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return code;
+
+				}
+				break;
+			case 3:
+				// Grammars\\CodeGenTreeWalker.g3:1410:4: act= ACTION
+				{
+				act=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_rewrite_template2289); if (state.failed) return code;
+				if ( state.backtracking == 0 )
+				{
+
+								// set alt num for same reason as ARGLIST above
+								act.outerAltNum = this.outerAltNum;
+								code =templates.getInstanceOf("rewriteAction");
+								code.setAttribute("action",
+												  generator.translateAction(currentRuleName,act));
+
+				}
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return code;
+	}
+	// $ANTLR end "rewrite_template"
+
+	// $ANTLR start synpred1_CodeGenTreeWalker
+	public void synpred1_CodeGenTreeWalker_fragment()
+	{
+		// Grammars\\CodeGenTreeWalker.g3:561:4: ({...}? ( BLOCK | OPTIONAL | CLOSURE | POSITIVE_CLOSURE ) )
+		// Grammars\\CodeGenTreeWalker.g3:561:5: {...}? ( BLOCK | OPTIONAL | CLOSURE | POSITIVE_CLOSURE )
+		{
+		if ( !((((GrammarAST)input.LT(1)).SetValue==null)) )
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			throw new FailedPredicateException(input, "synpred1_CodeGenTreeWalker", "((GrammarAST)input.LT(1)).SetValue==null");
+		}
+		if ( input.LA(1)==BLOCK||input.LA(1)==CLOSURE||input.LA(1)==OPTIONAL||input.LA(1)==POSITIVE_CLOSURE )
+		{
+			input.Consume();
+			state.errorRecovery=false;state.failed=false;
+		}
+		else
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			MismatchedSetException mse = new MismatchedSetException(null,input);
+			throw mse;
+		}
+
+
+		}
+	}
+	// $ANTLR end synpred1_CodeGenTreeWalker
+
+	// $ANTLR start synpred2_CodeGenTreeWalker
+	public void synpred2_CodeGenTreeWalker_fragment()
+	{
+		// Grammars\\CodeGenTreeWalker.g3:729:6: ( element_action )
+		// Grammars\\CodeGenTreeWalker.g3:729:7: element_action
+		{
+		PushFollow(Follow._element_action_in_synpred2_CodeGenTreeWalker1385);
+		element_action();
+
+		state._fsp--;
+		if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred2_CodeGenTreeWalker
+	#endregion
+
+	// Delegated rules
+
+	#region Synpreds
+	public bool synpred1_CodeGenTreeWalker()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred1_CodeGenTreeWalker_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+	public bool synpred2_CodeGenTreeWalker()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred2_CodeGenTreeWalker_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+
+	#endregion
+
+	#region DFA
+	DFA45 dfa45;
+
+	protected override void InitDFAs()
+	{
+		base.InitDFAs();
+		dfa45 = new DFA45( this, new SpecialStateTransitionHandler( specialStateTransition45 ) );
+	}
+
+	class DFA45 : DFA
+	{
+
+		const string DFA45_eotS =
+			"\x1A\xFFFF";
+		const string DFA45_eofS =
+			"\x1A\xFFFF";
+		const string DFA45_minS =
+			"\x1\x4\x6\xFFFF\x1\x0\x12\xFFFF";
+		const string DFA45_maxS =
+			"\x1\x5F\x6\xFFFF\x1\x0\x12\xFFFF";
+		const string DFA45_acceptS =
+			"\x1\xFFFF\x1\x1\x1\x2\x1\x3\x1\x4\x1\x5\x1\x6\x1\xFFFF\x3\x7\x1\x8\x5"+
+			"\xFFFF\x1\x9\x1\xA\x1\xFFFF\x1\xB\x1\xFFFF\x1\xC\x1\xD\x1\xE\x1\xF";
+		const string DFA45_specialS =
+			"\x1\x0\x6\xFFFF\x1\x1\x12\xFFFF}>";
+		static readonly string[] DFA45_transitionS =
+			{
+				"\x1\x12\x8\xFFFF\x1\x4\x1\x18\x1\x2\x1\x7\x1\xFFFF\x1\xB\x1\x6\x1\xFFFF"+
+				"\x1\x9\x7\xFFFF\x1\xB\x5\xFFFF\x1\x19\x3\xFFFF\x1\x12\x1\xFFFF\x1\x14"+
+				"\xD\xFFFF\x1\x3\x1\xFFFF\x1\x8\x5\xFFFF\x1\x5\x1\xA\x9\xFFFF\x1\x1\x2"+
+				"\xFFFF\x1\xB\x2\xFFFF\x1\x14\x4\xFFFF\x1\xB\x1\x16\x1\x17\x2\xFFFF\x1"+
+				"\xB\x2\xFFFF\x1\x11\x1\xFFFF\x1\xB",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"\x1\xFFFF",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				""
+			};
+
+		static readonly short[] DFA45_eot = DFA.UnpackEncodedString(DFA45_eotS);
+		static readonly short[] DFA45_eof = DFA.UnpackEncodedString(DFA45_eofS);
+		static readonly char[] DFA45_min = DFA.UnpackEncodedStringToUnsignedChars(DFA45_minS);
+		static readonly char[] DFA45_max = DFA.UnpackEncodedStringToUnsignedChars(DFA45_maxS);
+		static readonly short[] DFA45_accept = DFA.UnpackEncodedString(DFA45_acceptS);
+		static readonly short[] DFA45_special = DFA.UnpackEncodedString(DFA45_specialS);
+		static readonly short[][] DFA45_transition;
+
+		static DFA45()
+		{
+			int numStates = DFA45_transitionS.Length;
+			DFA45_transition = new short[numStates][];
+			for ( int i=0; i < numStates; i++ )
+			{
+				DFA45_transition[i] = DFA.UnpackEncodedString(DFA45_transitionS[i]);
+			}
+		}
+
+		public DFA45( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
+			: base( specialStateTransition )	{
+			this.recognizer = recognizer;
+			this.decisionNumber = 45;
+			this.eot = DFA45_eot;
+			this.eof = DFA45_eof;
+			this.min = DFA45_min;
+			this.max = DFA45_max;
+			this.accept = DFA45_accept;
+			this.special = DFA45_special;
+			this.transition = DFA45_transition;
+		}
+		public override string GetDescription()
+		{
+			return "526:0: element[GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null] options {k=1; } : ( ^( ROOT e= element[label,$ROOT] ) | ^( BANG e= element[label,$BANG] ) | ^(n= NOT notElement[$n, $label, $astSuffix] ) | ^( ASSIGN alabel= ID e= element[$alabel,$astSuffix] ) | ^( PLUS_ASSIGN label2= ID e= element[$label2,$astSuffix] ) | ^( CHAR_RANGE a= CHAR_LITERAL b= CHAR_LITERAL ) |=> ebnf | atom[null, $label, $astSuffix] | tree_ | element_action | (sp= SEMPRED |sp= GATED_SEMPRED ) | SYN_SEMPRED | ^( SYNPRED ( . )* ) | ^( BACKTRACK_SEMPRED ( . )* ) | EPSILON );";
+		}
+	}
+
+	int specialStateTransition45( DFA dfa, int s, IIntStream _input )
+	{
+		ITreeNodeStream input = (ITreeNodeStream)_input;
+		int _s = s;
+		switch ( s )
+		{
+
+			case 0:
+				int LA45_0 = input.LA(1);
+
+
+				int index45_0 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (LA45_0==ROOT) ) {s = 1;}
+
+				else if ( (LA45_0==BANG) ) {s = 2;}
+
+				else if ( (LA45_0==NOT) ) {s = 3;}
+
+				else if ( (LA45_0==ASSIGN) ) {s = 4;}
+
+				else if ( (LA45_0==PLUS_ASSIGN) ) {s = 5;}
+
+				else if ( (LA45_0==CHAR_RANGE) ) {s = 6;}
+
+				else if ( (LA45_0==BLOCK) ) {s = 7;}
+
+				else if ( (LA45_0==OPTIONAL) && (synpred1_CodeGenTreeWalker())) {s = 8;}
+
+				else if ( (LA45_0==CLOSURE) && (synpred1_CodeGenTreeWalker())) {s = 9;}
+
+				else if ( (LA45_0==POSITIVE_CLOSURE) && (synpred1_CodeGenTreeWalker())) {s = 10;}
+
+				else if ( (LA45_0==CHAR_LITERAL||LA45_0==DOT||LA45_0==RULE_REF||LA45_0==STRING_LITERAL||LA45_0==TOKEN_REF||LA45_0==WILDCARD) ) {s = 11;}
+
+				else if ( (LA45_0==TREE_BEGIN) ) {s = 17;}
+
+				else if ( (LA45_0==ACTION||LA45_0==FORCED_ACTION) ) {s = 18;}
+
+				else if ( (LA45_0==GATED_SEMPRED||LA45_0==SEMPRED) ) {s = 20;}
+
+				else if ( (LA45_0==SYN_SEMPRED) ) {s = 22;}
+
+				else if ( (LA45_0==SYNPRED) ) {s = 23;}
+
+				else if ( (LA45_0==BACKTRACK_SEMPRED) ) {s = 24;}
+
+				else if ( (LA45_0==EPSILON) ) {s = 25;}
+
+
+				input.Seek(index45_0);
+				if ( s>=0 ) return s;
+				break;
+
+			case 1:
+				int LA45_7 = input.LA(1);
+
+
+				int index45_7 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred1_CodeGenTreeWalker()) ) {s = 10;}
+
+				else if ( (true) ) {s = 11;}
+
+
+				input.Seek(index45_7);
+				if ( s>=0 ) return s;
+				break;
+		}
+		if (state.backtracking>0) {state.failed=true; return -1;}
+		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 45, _s, input);
+		dfa.Error(nvae);
+		throw nvae;
+	}
+
+	#endregion
+
+	#region Follow Sets
+	public static class Follow
+	{
+		public static readonly BitSet _LEXER_GRAMMAR_in_grammar_66 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _grammarSpec_in_grammar_68 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _PARSER_GRAMMAR_in_grammar_78 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _grammarSpec_in_grammar_80 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _TREE_GRAMMAR_in_grammar_90 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _grammarSpec_in_grammar_92 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _COMBINED_GRAMMAR_in_grammar_102 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _grammarSpec_in_grammar_104 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _SCOPE_in_attrScope123 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_attrScope125 = new BitSet(new ulong[]{0x210UL});
+		public static readonly BitSet _AMPERSAND_in_attrScope130 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ACTION_in_attrScope139 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ID_in_grammarSpec156 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
+		public static readonly BitSet _DOC_COMMENT_in_grammarSpec164 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
+		public static readonly BitSet _OPTIONS_in_grammarSpec185 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _IMPORT_in_grammarSpec199 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _TOKENS_in_grammarSpec213 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _attrScope_in_grammarSpec225 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
+		public static readonly BitSet _AMPERSAND_in_grammarSpec234 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _rules_in_grammarSpec245 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _rule_in_rules290 = new BitSet(new ulong[]{0x2UL,0x1000UL});
+		public static readonly BitSet _RULE_in_rules304 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _RULE_in_rule345 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_rule349 = new BitSet(new ulong[]{0x10000000400UL,0xEUL});
+		public static readonly BitSet _modifier_in_rule362 = new BitSet(new ulong[]{0x400UL});
+		public static readonly BitSet _ARG_in_rule370 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_ACTION_in_rule373 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _RET_in_rule382 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_ACTION_in_rule385 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _throwsSpec_in_rule394 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
+		public static readonly BitSet _OPTIONS_in_rule404 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ruleScopeSpec_in_rule417 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
+		public static readonly BitSet _AMPERSAND_in_rule427 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _block_in_rule441 = new BitSet(new ulong[]{0x4400020000UL});
+		public static readonly BitSet _exceptionGroup_in_rule454 = new BitSet(new ulong[]{0x400000000UL});
+		public static readonly BitSet _EOR_in_rule462 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _set_in_modifier485 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _THROWS_in_throwsSpec512 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_throwsSpec514 = new BitSet(new ulong[]{0x80000000008UL});
+		public static readonly BitSet _SCOPE_in_ruleScopeSpec529 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _AMPERSAND_in_ruleScopeSpec534 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ACTION_in_ruleScopeSpec544 = new BitSet(new ulong[]{0x80000000008UL});
+		public static readonly BitSet _ID_in_ruleScopeSpec550 = new BitSet(new ulong[]{0x80000000008UL});
+		public static readonly BitSet _setBlock_in_block591 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _BLOCK_in_block604 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _OPTIONS_in_block612 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _alternative_in_block629 = new BitSet(new ulong[]{0x200000100UL,0x200UL});
+		public static readonly BitSet _rewrite_in_block633 = new BitSet(new ulong[]{0x200000100UL,0x200UL});
+		public static readonly BitSet _EOB_in_block650 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _BLOCK_in_setBlock682 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ALT_in_setAlternative702 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _setElement_in_setAlternative704 = new BitSet(new ulong[]{0x1000C0000UL,0x4200000UL});
+		public static readonly BitSet _EOA_in_setAlternative707 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _exceptionHandler_in_exceptionGroup722 = new BitSet(new ulong[]{0x4000020002UL});
+		public static readonly BitSet _finallyClause_in_exceptionGroup729 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _finallyClause_in_exceptionGroup737 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _CATCH_in_exceptionHandler751 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_ACTION_in_exceptionHandler753 = new BitSet(new ulong[]{0x10UL});
+		public static readonly BitSet _ACTION_in_exceptionHandler755 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _FINALLY_in_finallyClause773 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ACTION_in_finallyClause775 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ALT_in_alternative804 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _element_in_alternative817 = new BitSet(new ulong[]{0x86800289202DE210UL,0xA4E16401UL});
+		public static readonly BitSet _EOA_in_alternative835 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ROOT_in_element870 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _element_in_element874 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _BANG_in_element887 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _element_in_element891 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _NOT_in_element907 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _notElement_in_element909 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ASSIGN_in_element924 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_element928 = new BitSet(new ulong[]{0x86800289202DE210UL,0xA4E16401UL});
+		public static readonly BitSet _element_in_element932 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _PLUS_ASSIGN_in_element947 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_element951 = new BitSet(new ulong[]{0x86800289202DE210UL,0xA4E16401UL});
+		public static readonly BitSet _element_in_element955 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _CHAR_RANGE_in_element969 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _CHAR_LITERAL_in_element973 = new BitSet(new ulong[]{0x40000UL});
+		public static readonly BitSet _CHAR_LITERAL_in_element977 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ebnf_in_element1006 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _atom_in_element1016 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _tree__in_element1027 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _element_action_in_element1037 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _SEMPRED_in_element1052 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _GATED_SEMPRED_in_element1056 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _SYN_SEMPRED_in_element1067 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _SYNPRED_in_element1075 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _BACKTRACK_SEMPRED_in_element1086 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _EPSILON_in_element1098 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ACTION_in_element_action1115 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _FORCED_ACTION_in_element_action1126 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _CHAR_LITERAL_in_notElement1155 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _STRING_LITERAL_in_notElement1168 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _TOKEN_REF_in_notElement1181 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _BLOCK_in_notElement1195 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _block_in_ebnf1241 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _OPTIONAL_in_ebnf1260 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _block_in_ebnf1264 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _CLOSURE_in_ebnf1285 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _block_in_ebnf1289 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _POSITIVE_CLOSURE_in_ebnf1310 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _block_in_ebnf1314 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _TREE_BEGIN_in_tree_1352 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _element_in_tree_1359 = new BitSet(new ulong[]{0x86800289202DE218UL,0xA4E16401UL});
+		public static readonly BitSet _element_action_in_tree_1396 = new BitSet(new ulong[]{0x86800289202DE218UL,0xA4E16401UL});
+		public static readonly BitSet _element_in_tree_1418 = new BitSet(new ulong[]{0x86800289202DE218UL,0xA4E16401UL});
+		public static readonly BitSet _RULE_REF_in_atom1469 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_ACTION_in_atom1474 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _TOKEN_REF_in_atom1492 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_ACTION_in_atom1497 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _CHAR_LITERAL_in_atom1513 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _STRING_LITERAL_in_atom1526 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _WILDCARD_in_atom1538 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _DOT_in_atom1549 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_atom1551 = new BitSet(new ulong[]{0x20050000UL,0x84202000UL});
+		public static readonly BitSet _atom_in_atom1555 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _set_in_atom1568 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _set_in_ast_suffix1584 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _BLOCK_in_set1613 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _CHAR_LITERAL_in_setElement1633 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _TOKEN_REF_in_setElement1638 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _STRING_LITERAL_in_setElement1643 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _CHAR_RANGE_in_setElement1649 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _CHAR_LITERAL_in_setElement1651 = new BitSet(new ulong[]{0x40000UL});
+		public static readonly BitSet _CHAR_LITERAL_in_setElement1653 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _REWRITE_in_rewrite1690 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _SEMPRED_in_rewrite1695 = new BitSet(new ulong[]{0x2000000110UL,0x1000000UL});
+		public static readonly BitSet _rewrite_alternative_in_rewrite1701 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _BLOCK_in_rewrite_block1736 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _rewrite_alternative_in_rewrite_block1748 = new BitSet(new ulong[]{0x200000000UL});
+		public static readonly BitSet _EOB_in_rewrite_block1753 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ALT_in_rewrite_alternative1788 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _rewrite_element_in_rewrite_alternative1806 = new BitSet(new ulong[]{0x201000100240010UL,0x24202001UL});
+		public static readonly BitSet _EPSILON_in_rewrite_alternative1827 = new BitSet(new ulong[]{0x100000000UL});
+		public static readonly BitSet _EOA_in_rewrite_alternative1843 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _rewrite_template_in_rewrite_alternative1856 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ETC_in_rewrite_alternative1869 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _rewrite_atom_in_rewrite_element1889 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _rewrite_ebnf_in_rewrite_element1899 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _rewrite_tree_in_rewrite_element1908 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _OPTIONAL_in_rewrite_ebnf1929 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _rewrite_block_in_rewrite_ebnf1931 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _CLOSURE_in_rewrite_ebnf1949 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _rewrite_block_in_rewrite_ebnf1951 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _POSITIVE_CLOSURE_in_rewrite_ebnf1969 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _rewrite_block_in_rewrite_ebnf1971 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _TREE_BEGIN_in_rewrite_tree2004 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _rewrite_atom_in_rewrite_tree2011 = new BitSet(new ulong[]{0x201000100240018UL,0x24202001UL});
+		public static readonly BitSet _rewrite_element_in_rewrite_tree2031 = new BitSet(new ulong[]{0x201000100240018UL,0x24202001UL});
+		public static readonly BitSet _RULE_REF_in_rewrite_atom2076 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _TOKEN_REF_in_rewrite_atom2093 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_ACTION_in_rewrite_atom2098 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _CHAR_LITERAL_in_rewrite_atom2109 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _STRING_LITERAL_in_rewrite_atom2117 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _LABEL_in_rewrite_atom2131 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ACTION_in_rewrite_atom2141 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ALT_in_rewrite_template2164 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _EPSILON_in_rewrite_template2166 = new BitSet(new ulong[]{0x100000000UL});
+		public static readonly BitSet _EOA_in_rewrite_template2168 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _TEMPLATE_in_rewrite_template2179 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_rewrite_template2184 = new BitSet(new ulong[]{0x1000UL});
+		public static readonly BitSet _ACTION_in_rewrite_template2188 = new BitSet(new ulong[]{0x1000UL});
+		public static readonly BitSet _ARGLIST_in_rewrite_template2201 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_in_rewrite_template2211 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_rewrite_template2215 = new BitSet(new ulong[]{0x10UL});
+		public static readonly BitSet _ACTION_in_rewrite_template2219 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _DOUBLE_QUOTE_STRING_LITERAL_in_rewrite_template2252 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _DOUBLE_ANGLE_STRING_LITERAL_in_rewrite_template2265 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ACTION_in_rewrite_template2289 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _set_in_synpred1_CodeGenTreeWalker991 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _element_action_in_synpred2_CodeGenTreeWalker1385 = new BitSet(new ulong[]{0x2UL});
+
+	}
+	#endregion
+}
+
+} // namespace Antlr3.Grammars
diff --git a/Antlr3/Grammars/CodeGenTreeWalker.g3 b/Antlr3/Grammars/CodeGenTreeWalker.g3
new file mode 100644
index 0000000..035b491
--- /dev/null
+++ b/Antlr3/Grammars/CodeGenTreeWalker.g3
@@ -0,0 +1,1418 @@
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/** Walk a grammar and generate code by gradually building up
+ *  a bigger and bigger StringTemplate.
+ *
+ *  Terence Parr
+ *  University of San Francisco
+ *  June 15, 2004
+ */
+tree grammar CodeGenTreeWalker;
+
+options
+{
+	language=CSharp3;
+	tokenVocab = ANTLR;
+	ASTLabelType=GrammarAST;
+}
+
+@header
+{
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+using Antlr3.Analysis;
+using Antlr3.Misc;
+using Antlr3.Tool;
+
+using BitSet = Antlr.Runtime.BitSet;
+using DFA = Antlr.Runtime.DFA;
+using StringTemplate = Antlr3.ST.StringTemplate;
+using StringTemplateGroup = Antlr3.ST.StringTemplateGroup;
+using TokenWithIndex = Antlr.Runtime.CommonToken;
+}
+
+@namespace{Antlr3.Grammars}
+
+public
+grammar_[Grammar g,
+		StringTemplate recognizerST,
+		StringTemplate outputFileST,
+		StringTemplate headerFileST]
+@init
+{
+	if ( state.backtracking == 0 )
+	{
+		init(g);
+		this.recognizerST = recognizerST;
+		this.outputFileST = outputFileST;
+		this.headerFileST = headerFileST;
+		string superClass = (string)g.getOption("superClass");
+		outputOption = (string)g.getOption("output");
+		recognizerST.setAttribute("superClass", superClass);
+		if ( g.type!=Grammar.LEXER ) {
+			recognizerST.setAttribute("ASTLabelType", g.getOption("ASTLabelType"));
+		}
+		if ( g.type==Grammar.TREE_PARSER && g.getOption("ASTLabelType")==null ) {
+			ErrorManager.grammarWarning(ErrorManager.MSG_MISSING_AST_TYPE_IN_TREE_GRAMMAR,
+									   g,
+									   null,
+									   g.name);
+		}
+		if ( g.type!=Grammar.TREE_PARSER ) {
+			recognizerST.setAttribute("labelType", g.getOption("TokenLabelType"));
+		}
+		$recognizerST.setAttribute("numRules", grammar.Rules.Count);
+		$outputFileST.setAttribute("numRules", grammar.Rules.Count);
+		$headerFileST.setAttribute("numRules", grammar.Rules.Count);
+	}
+}
+	:	(	^( LEXER_GRAMMAR grammarSpec )
+		|	^( PARSER_GRAMMAR grammarSpec )
+		|	^( TREE_GRAMMAR grammarSpec )
+		|	^( COMBINED_GRAMMAR grammarSpec )
+		)
+	;
+
+attrScope
+	:	^( 'scope' ID ( ^(AMPERSAND .*) )* ACTION )
+	;
+
+grammarSpec
+	:   name=ID
+		(	cmt=DOC_COMMENT
+			{
+				outputFileST.setAttribute("docComment", $cmt.text);
+				headerFileST.setAttribute("docComment", $cmt.text);
+			}
+		)?
+		{
+			recognizerST.setAttribute("name", grammar.getRecognizerName());
+			outputFileST.setAttribute("name", grammar.getRecognizerName());
+			headerFileST.setAttribute("name", grammar.getRecognizerName());
+			recognizerST.setAttribute("scopes", grammar.GlobalScopes);
+			headerFileST.setAttribute("scopes", grammar.GlobalScopes);
+		}
+		( ^(OPTIONS .*) )?
+		( ^(IMPORT .*) )?
+		( ^(TOKENS .*) )?
+		(attrScope)*
+		( ^(AMPERSAND .*) )*
+		rules[recognizerST]
+	;
+
+rules[StringTemplate recognizerST]
+@init
+{
+	string ruleName = ((GrammarAST)input.LT(1)).GetChild(0).Text;
+	bool generated = grammar.generateMethodForRule(ruleName);
+}
+	:	(	(	options {k=1;} :
+				{generated}? =>
+				rST=rule
+				{
+					if ( $rST.code != null )
+					{
+						recognizerST.setAttribute("rules", $rST.code);
+						outputFileST.setAttribute("rules", $rST.code);
+						headerFileST.setAttribute("rules", $rST.code);
+					}
+				}
+			|	^(RULE .*)
+			)
+			{{
+				if ( input.LA(1) == RULE )
+				{
+					ruleName = ((GrammarAST)input.LT(1)).GetChild(0).Text;
+					//System.Diagnostics.Debug.Assert( ruleName == ((GrammarAST)input.LT(1)).enclosingRuleName );
+					generated = grammar.generateMethodForRule(ruleName);
+				}
+			}}
+		)+
+	;
+
+rule returns [StringTemplate code=null]
+@init
+{
+	string initAction = null;
+	// get the dfa for the BLOCK
+	GrammarAST block2=(GrammarAST)$start.GetFirstChildWithType(BLOCK);
+	Antlr3.Analysis.DFA dfa=block2.LookaheadDFA;
+	// init blockNestingLevel so it's block level RULE_BLOCK_NESTING_LEVEL
+	// for alts of rule
+	blockNestingLevel = RULE_BLOCK_NESTING_LEVEL-1;
+	Rule ruleDescr = grammar.getRule($start.GetChild(0).Text);
+	currentRuleName = $start.GetChild(0).Text;
+
+	// For syn preds, we don't want any AST code etc... in there.
+	// Save old templates ptr and restore later.  Base templates include Dbg.
+	StringTemplateGroup saveGroup = templates;
+	if ( ruleDescr.isSynPred )
+	{
+		templates = generator.getBaseTemplates();
+	}
+
+	string description = string.Empty;
+}
+	:	^(	RULE id=ID
+			{ System.Diagnostics.Debug.Assert( currentRuleName == $id.text ); }
+			(mod=modifier)?
+			^(ARG (ARG_ACTION)?)
+			^(RET (ARG_ACTION)?)
+			(throwsSpec)?
+			( ^(OPTIONS .*) )?
+			(ruleScopeSpec)?
+			( ^(AMPERSAND .*) )*
+			b=block["ruleBlock", dfa]
+			{
+				description =
+					grammar.grammarTreeToString((GrammarAST)$start.GetFirstChildWithType(BLOCK),
+												false);
+				description =
+					generator.target.getTargetStringLiteralFromString(description);
+				$b.code.setAttribute("description", description);
+				// do not generate lexer rules in combined grammar
+				string stName = null;
+				if ( ruleDescr.isSynPred )
+				{
+					stName = "synpredRule";
+				}
+				else if ( grammar.type==Grammar.LEXER )
+				{
+					if ( currentRuleName.Equals(Grammar.ARTIFICIAL_TOKENS_RULENAME) )
+					{
+						stName = "tokensRule";
+					}
+					else
+					{
+						stName = "lexerRule";
+					}
+				}
+				else
+				{
+					if ( !(grammar.type==Grammar.COMBINED &&
+						 char.IsUpper(currentRuleName[0])) )
+					{
+						stName = "rule";
+					}
+				}
+				$code = templates.getInstanceOf(stName);
+				if ( $code.getName().Equals("rule") )
+				{
+					$code.setAttribute("emptyRule", grammar.isEmptyRule(block2));
+				}
+				$code.setAttribute("ruleDescriptor", ruleDescr);
+				string memo = (string)grammar.getBlockOption($start,"memoize");
+				if ( memo==null )
+				{
+					memo = (string)grammar.getOption("memoize");
+				}
+				if ( memo!=null && memo.Equals("true") &&
+					 (stName.Equals("rule")||stName.Equals("lexerRule")) )
+				{
+					$code.setAttribute("memoize", memo!=null && memo.Equals("true"));
+				}
+			}
+
+			(exceptionGroup[$code])?
+			EOR
+		)
+		{
+			if ( $code!=null )
+			{
+				if ( grammar.type==Grammar.LEXER )
+				{
+					bool naked =
+						currentRuleName.Equals(Grammar.ARTIFICIAL_TOKENS_RULENAME) ||
+						($mod.start!=null&&$mod.start.Text.Equals(Grammar.FRAGMENT_RULE_MODIFIER));
+					$code.setAttribute("nakedBlock", naked);
+				}
+				else
+				{
+					description = grammar.grammarTreeToString($start,false);
+					description = generator.target.getTargetStringLiteralFromString(description);
+					$code.setAttribute("description", description);
+				}
+				Rule theRule = grammar.getRule(currentRuleName);
+				generator.translateActionAttributeReferencesForSingleScope(
+					theRule,
+					theRule.Actions
+				);
+				$code.setAttribute("ruleName", currentRuleName);
+				$code.setAttribute("block", $b.code);
+				if ( initAction!=null )
+				{
+					$code.setAttribute("initAction", initAction);
+				}
+			}
+		}
+	;
+finally { templates = saveGroup; }
+
+modifier
+	:	'protected'
+	|	'public'
+	|	'private'
+	|	'fragment'
+	;
+
+throwsSpec
+	:	^('throws' ID+)
+	;
+
+ruleScopeSpec
+	:	^( 'scope' ( ^(AMPERSAND .*) )* (ACTION)? ( ID )* )
+	;
+
+block[string blockTemplateName, Antlr3.Analysis.DFA dfa]
+	 returns [StringTemplate code=null]
+options { k=1; }
+@init
+{
+	int altNum = 0;
+
+	blockNestingLevel++;
+	if ( state.backtracking == 0 )
+	{
+		StringTemplate decision = null;
+		if ( $dfa != null )
+		{
+			$code = templates.getInstanceOf($blockTemplateName);
+			decision = generator.genLookaheadDecision(recognizerST,$dfa);
+			$code.setAttribute("decision", decision);
+			$code.setAttribute("decisionNumber", $dfa.DecisionNumber);
+			$code.setAttribute("maxK",$dfa.MaxLookaheadDepth);
+			$code.setAttribute("maxAlt",$dfa.NumberOfAlts);
+		}
+		else
+		{
+			$code = templates.getInstanceOf($blockTemplateName+"SingleAlt");
+		}
+		$code.setAttribute("blockLevel", blockNestingLevel);
+		$code.setAttribute("enclosingBlockLevel", blockNestingLevel-1);
+		altNum = 1;
+		if ( this.blockNestingLevel==RULE_BLOCK_NESTING_LEVEL ) {
+			this.outerAltNum=1;
+		}
+	}
+}
+	:	{$start.SetValue!=null}? => setBlock
+		{
+			$code.setAttribute("alts",$setBlock.code);
+		}
+
+	|	^(  BLOCK
+			( ^(OPTIONS .*) )? // ignore
+			( alt=alternative rew=rewrite
+				{
+					if ( this.blockNestingLevel==RULE_BLOCK_NESTING_LEVEL )
+					{
+						this.outerAltNum++;
+					}
+					// add the rewrite code as just another element in the alt :)
+					// (unless it's a " -> ..." rewrite
+					// ( -> ... )
+					bool etc =
+						$rew.start.Type==REWRITE &&
+						$rew.start.GetChild(0)!=null &&
+						$rew.start.GetChild(0).Type==ETC;
+					if ( $rew.code!=null && !etc )
+					{
+						$alt.code.setAttribute("rew", $rew.code);
+					}
+					// add this alt to the list of alts for this block
+					$code.setAttribute("alts",$alt.code);
+					$alt.code.setAttribute("altNum", altNum);
+					$alt.code.setAttribute("outerAlt", blockNestingLevel==RULE_BLOCK_NESTING_LEVEL);
+					altNum++;
+				}
+			)+
+			EOB
+		 )
+	;
+finally { blockNestingLevel--; }
+
+setBlock returns [StringTemplate code=null]
+@init
+{
+	StringTemplate setcode = null;
+	if ( state.backtracking == 0 )
+	{
+		if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL && grammar.BuildAST )
+		{
+			Rule r = grammar.getRule(currentRuleName);
+			currentAltHasASTRewrite = r.hasRewrite(outerAltNum);
+			if ( currentAltHasASTRewrite )
+			{
+				r.trackTokenReferenceInAlt($start, outerAltNum);
+			}
+		}
+	}
+}
+	:	^(s=BLOCK .*)
+		{
+			int i = ((TokenWithIndex)$s.Token).TokenIndex;
+			if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL )
+			{
+				setcode = getTokenElementST("matchRuleBlockSet", "set", $s, null, null);
+			}
+			else
+			{
+				setcode = getTokenElementST("matchSet", "set", $s, null, null);
+			}
+			setcode.setAttribute("elementIndex", i);
+			if ( grammar.type!=Grammar.LEXER )
+			{
+				generator.generateLocalFOLLOW($s,"set",currentRuleName,i);
+			}
+			setcode.setAttribute("s",
+				generator.genSetExpr(templates,$s.SetValue,1,false));
+			StringTemplate altcode=templates.getInstanceOf("alt");
+			altcode.setAttribute("elements.{el,line,pos}",
+								 setcode,
+								 $s.Line,
+								 $s.CharPositionInLine
+								);
+			altcode.setAttribute("altNum", 1);
+			altcode.setAttribute("outerAlt", blockNestingLevel==RULE_BLOCK_NESTING_LEVEL);
+			if ( !currentAltHasASTRewrite && grammar.BuildAST )
+			{
+				altcode.setAttribute("autoAST", true);
+			}
+			altcode.setAttribute("treeLevel", rewriteTreeNestingLevel);
+			$code = altcode;
+		}
+	;
+
+setAlternative
+	:	^(ALT setElement+ EOA)
+	;
+
+exceptionGroup[StringTemplate ruleST]
+	:	( exceptionHandler[$ruleST] )+ (finallyClause[$ruleST])?
+	|	finallyClause[$ruleST]
+	;
+
+exceptionHandler[StringTemplate ruleST]
+	:	^('catch' ARG_ACTION ACTION)
+		{
+			List chunks = generator.translateAction(currentRuleName,$ACTION);
+			$ruleST.setAttribute("exceptions.{decl,action}",$ARG_ACTION.text,chunks);
+		}
+	;
+
+finallyClause[StringTemplate ruleST]
+	:	^('finally' ACTION)
+		{
+			List chunks = generator.translateAction(currentRuleName,$ACTION);
+			$ruleST.setAttribute("finally",chunks);
+		}
+	;
+
+alternative returns [StringTemplate code]
+@init
+{
+	if ( state.backtracking == 0 )
+	{
+		$code = templates.getInstanceOf("alt");
+		/*
+		// TODO: can we use Rule.altsWithRewrites???
+		if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL ) {
+			GrammarAST aRewriteNode = #alternative.findFirstType(REWRITE);
+			if ( grammar.buildAST() &&
+				 (aRewriteNode!=null||
+				 (#alternative.getNextSibling()!=null &&
+				  #alternative.getNextSibling().getType()==REWRITE)) )
+			{
+				currentAltHasASTRewrite = true;
+			}
+			else {
+				currentAltHasASTRewrite = false;
+			}
+		}
+		*/
+		if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL && grammar.BuildAST )
+		{
+			Rule r = grammar.getRule(currentRuleName);
+			currentAltHasASTRewrite = r.hasRewrite(outerAltNum);
+		}
+		string description = grammar.grammarTreeToString($start, false);
+		description = generator.target.getTargetStringLiteralFromString(description);
+		$code.setAttribute("description", description);
+		$code.setAttribute("treeLevel", rewriteTreeNestingLevel);
+		if ( !currentAltHasASTRewrite && grammar.BuildAST )
+		{
+			$code.setAttribute("autoAST", true);
+		}
+	}
+}
+	:	^(	a=ALT
+			(
+				e=element[null,null]
+				{
+					if ( e!=null )
+					{
+						$code.setAttribute("elements.{el,line,pos}",
+										  $e.code,
+										  $e.start.Line,
+										  $e.start.CharPositionInLine
+										 );
+					}
+				}
+			)+
+			EOA
+		)
+	;
+
+element[GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null]
+options { k=1; }
+@init
+{
+	IIntSet elements=null;
+	GrammarAST ast = null;
+}
+	:	^(ROOT e=element[label,$ROOT])
+		{ $code = $e.code; }
+
+	|	^(BANG e=element[label,$BANG])
+		{ $code = $e.code; }
+
+	|	^( n=NOT notElement[$n, $label, $astSuffix] )
+		{ $code = $notElement.code; }
+
+	|	^( ASSIGN alabel=ID e=element[$alabel,$astSuffix] )
+		{ $code = $e.code; }
+
+	|	^( PLUS_ASSIGN label2=ID e=element[$label2,$astSuffix] )
+		{ $code = $e.code; }
+
+	|	^(CHAR_RANGE a=CHAR_LITERAL b=CHAR_LITERAL)
+		{
+			$code = templates.getInstanceOf("charRangeRef");
+			string low = generator.target.getTargetCharLiteralFromANTLRCharLiteral(generator,$a.text);
+			string high = generator.target.getTargetCharLiteralFromANTLRCharLiteral(generator,$b.text);
+			$code.setAttribute("a", low);
+			$code.setAttribute("b", high);
+			if ( label!=null )
+			{
+				$code.setAttribute("label", $label.Text);
+			}
+		}
+
+	|	({((GrammarAST)input.LT(1)).SetValue==null}? (BLOCK|OPTIONAL|CLOSURE|POSITIVE_CLOSURE)) => /*{$start.getSetValue()==null}?*/ ebnf
+		{ $code = $ebnf.code; }
+
+	|	atom[null, $label, $astSuffix]
+		{ $code = $atom.code; }
+
+	|	tree_
+		{ $code = $tree_.code; }
+
+	|	element_action
+		{ $code = $element_action.code; }
+
+	|   (sp=SEMPRED|sp=GATED_SEMPRED)
+		{
+			$code = templates.getInstanceOf("validateSemanticPredicate");
+			$code.setAttribute("pred", generator.translateAction(currentRuleName,$sp));
+			string description = generator.target.getTargetStringLiteralFromString($sp.text);
+			$code.setAttribute("description", description);
+		}
+
+	|	SYN_SEMPRED // used only in lookahead; don't generate validating pred
+
+	|	^(SYNPRED .*)
+
+	|	^(BACKTRACK_SEMPRED .*)
+
+	|   EPSILON
+	;
+
+element_action returns [StringTemplate code=null]
+	:	act=ACTION
+		{
+			$code = templates.getInstanceOf("execAction");
+			$code.setAttribute("action", generator.translateAction(currentRuleName,$act));
+		}
+	|	act2=FORCED_ACTION
+		{
+			$code = templates.getInstanceOf("execForcedAction");
+			$code.setAttribute("action", generator.translateAction(currentRuleName,$act2));
+		}
+	;
+
+notElement[GrammarAST n, GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null]
+@init
+{
+	IIntSet elements=null;
+	string labelText = null;
+	if ( label!=null )
+	{
+		labelText = label.Text;
+	}
+}
+	:	(	assign_c=CHAR_LITERAL
+			{
+				int ttype=0;
+				if ( grammar.type==Grammar.LEXER )
+				{
+					ttype = Grammar.getCharValueFromGrammarCharLiteral($assign_c.text);
+				}
+				else
+				{
+					ttype = grammar.getTokenType($assign_c.text);
+				}
+				elements = grammar.complement(ttype);
+			}
+		|	assign_s=STRING_LITERAL
+			{
+				int ttype=0;
+				if ( grammar.type==Grammar.LEXER )
+				{
+					// TODO: error!
+				}
+				else
+				{
+					ttype = grammar.getTokenType($assign_s.text);
+				}
+				elements = grammar.complement(ttype);
+			}
+		|	assign_t=TOKEN_REF
+			{
+				int ttype = grammar.getTokenType($assign_t.text);
+				elements = grammar.complement(ttype);
+			}
+		|	^(assign_st=BLOCK .*)
+			{
+				elements = $assign_st.SetValue;
+				elements = grammar.complement(elements);
+			}
+		)
+		{
+			$code = getTokenElementST("matchSet",
+									 "set",
+									 (GrammarAST)$n.GetChild(0),
+									 astSuffix,
+									 labelText);
+			$code.setAttribute("s",generator.genSetExpr(templates,elements,1,false));
+			int i = ((TokenWithIndex)n.Token).TokenIndex;
+			$code.setAttribute("elementIndex", i);
+			if ( grammar.type!=Grammar.LEXER )
+			{
+				generator.generateLocalFOLLOW(n,"set",currentRuleName,i);
+			}
+		}
+	;
+
+ebnf returns [StringTemplate code=null]
+@init
+{
+	Antlr3.Analysis.DFA dfa=null;
+	GrammarAST b = (GrammarAST)$start.GetChild(0);
+	GrammarAST eob = (GrammarAST)b.getLastChild(); // loops will use EOB DFA
+}
+	:	(	{ dfa = $start.LookaheadDFA; }
+			blk=block["block", dfa]
+			{ $code = $blk.code; }
+		|	{ dfa = $start.LookaheadDFA; }
+			^( OPTIONAL blk=block["optionalBlock", dfa] )
+			{ $code = $blk.code; }
+		|	{ dfa = eob.LookaheadDFA; }
+			^( CLOSURE blk=block["closureBlock", dfa] )
+			{ $code = $blk.code; }
+		|	{ dfa = eob.LookaheadDFA; }
+			^( POSITIVE_CLOSURE blk=block["positiveClosureBlock", dfa] )
+			{ $code = $blk.code; }
+		)
+		{
+			string description = grammar.grammarTreeToString($start, false);
+			description = generator.target.getTargetStringLiteralFromString(description);
+			$code.setAttribute("description", description);
+		}
+	;
+
+tree_ returns [StringTemplate code]
+@init
+{
+	rewriteTreeNestingLevel++;
+	GrammarAST rootSuffix = null;
+	if ( state.backtracking == 0 )
+	{
+		$code = templates.getInstanceOf("tree");
+		NFAState afterDOWN = (NFAState)$start.NFATreeDownState.getTransition(0).target;
+		LookaheadSet s = grammar.LOOK(afterDOWN);
+		if ( s.member(Label.UP) ) {
+			// nullable child list if we can see the UP as the next token
+			// we need an "if ( input.LA(1)==Token.DOWN )" gate around
+			// the child list.
+			$code.setAttribute("nullableChildList", "true");
+		}
+		$code.setAttribute("enclosingTreeLevel", rewriteTreeNestingLevel-1);
+		$code.setAttribute("treeLevel", rewriteTreeNestingLevel);
+		Rule r = grammar.getRule(currentRuleName);
+		if ( grammar.BuildAST && !r.hasRewrite(outerAltNum) ) {
+			rootSuffix = new GrammarAST(ROOT,"ROOT");
+		}
+	}
+}
+	:	^(	TREE_BEGIN
+			el=element[null,rootSuffix]
+			{
+				$code.setAttribute("root.{el,line,pos}",
+								  $el.code,
+								  $el.start.Line,
+								  $el.start.CharPositionInLine
+								  );
+			}
+			// push all the immediately-following actions out before children
+			// so actions aren't guarded by the "if (input.LA(1)==Token.DOWN)"
+			// guard in generated code.
+			(	(element_action) =>
+				act=element_action
+				{
+					$code.setAttribute("actionsAfterRoot.{el,line,pos}",
+									  $act.code,
+									  $act.start.Line,
+									  $act.start.CharPositionInLine
+									);
+				}
+			)*
+			(	 el=element[null,null]
+				 {
+				 $code.setAttribute("children.{el,line,pos}",
+								  $el.code,
+								  $el.start.Line,
+								  $el.start.CharPositionInLine
+								  );
+				 }
+			)*
+		)
+	;
+finally { rewriteTreeNestingLevel--; }
+
+atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
+	returns [StringTemplate code=null]
+@init
+{
+	string labelText=null;
+	if ( state.backtracking == 0 )
+	{
+		if ( label!=null )
+		{
+			labelText = label.Text;
+		}
+		if ( grammar.type!=Grammar.LEXER &&
+			 ($start.Type==RULE_REF||$start.Type==TOKEN_REF||
+			  $start.Type==CHAR_LITERAL||$start.Type==STRING_LITERAL) )
+		{
+			Rule encRule = grammar.getRule(((GrammarAST)$start).enclosingRuleName);
+			if ( encRule!=null && encRule.hasRewrite(outerAltNum) && astSuffix!=null )
+			{
+				ErrorManager.grammarError(ErrorManager.MSG_AST_OP_IN_ALT_WITH_REWRITE,
+										  grammar,
+										  ((GrammarAST)$start).Token,
+										  ((GrammarAST)$start).enclosingRuleName,
+										  outerAltNum);
+				astSuffix = null;
+			}
+		}
+	}
+}
+	:   ^( r=RULE_REF (rarg=ARG_ACTION)? )
+		{
+			grammar.checkRuleReference(scope, $r, $rarg, currentRuleName);
+			string scopeName = null;
+			if ( scope!=null ) {
+				scopeName = scope.Text;
+			}
+			Rule rdef = grammar.getRule(scopeName, $r.text);
+			// don't insert label=r() if $label.attr not used, no ret value, ...
+			if ( !rdef.HasReturnValue ) {
+				labelText = null;
+			}
+			$code = getRuleElementST("ruleRef", $r.text, $r, astSuffix, labelText);
+			$code.setAttribute("rule", rdef);
+			if ( scope!=null ) { // scoped rule ref
+				Grammar scopeG = grammar.composite.getGrammar(scope.Text);
+				$code.setAttribute("scope", scopeG);
+			}
+			else if ( rdef.grammar != this.grammar ) { // nonlocal
+				// if rule definition is not in this grammar, it's nonlocal
+				IList<Grammar> rdefDelegates = rdef.grammar.getDelegates();
+				if ( rdefDelegates.Contains(this.grammar) ) {
+					$code.setAttribute("scope", rdef.grammar);
+				}
+				else {
+					// defining grammar is not a delegate, scope all the
+					// back to root, which has delegate methods for all
+					// rules.  Don't use scope if we are root.
+					if ( this.grammar != rdef.grammar.composite.delegateGrammarTreeRoot.grammar ) {
+						$code.setAttribute("scope",
+										  rdef.grammar.composite.delegateGrammarTreeRoot.grammar);
+					}
+				}
+			}
+
+			if ( $rarg!=null ) {
+				List args = generator.translateAction(currentRuleName,$rarg);
+				$code.setAttribute("args", args);
+			}
+			int i = ((TokenWithIndex)r.Token).TokenIndex;
+			$code.setAttribute("elementIndex", i);
+			generator.generateLocalFOLLOW($r,$r.text,currentRuleName,i);
+			$r.code = $code;
+		}
+
+	|	^( t=TOKEN_REF (targ=ARG_ACTION)? )
+		{
+			if ( currentAltHasASTRewrite && $t.terminalOptions!=null &&
+				$t.terminalOptions[Grammar.defaultTokenOption]!=null )
+			{
+				ErrorManager.grammarError(ErrorManager.MSG_HETERO_ILLEGAL_IN_REWRITE_ALT,
+										grammar,
+										((GrammarAST)($t)).Token,
+										$t.text);
+			}
+			grammar.checkRuleReference(scope, $t, $targ, currentRuleName);
+			if ( grammar.type==Grammar.LEXER )
+			{
+				if ( grammar.getTokenType($t.text)==Label.EOF )
+				{
+					$code = templates.getInstanceOf("lexerMatchEOF");
+				}
+				else
+				{
+					$code = templates.getInstanceOf("lexerRuleRef");
+					if ( isListLabel(labelText) )
+					{
+						$code = templates.getInstanceOf("lexerRuleRefAndListLabel");
+					}
+					string scopeName = null;
+					if ( scope!=null )
+					{
+						scopeName = scope.Text;
+					}
+					Rule rdef2 = grammar.getRule(scopeName, $t.text);
+					$code.setAttribute("rule", rdef2);
+					if ( scope!=null )
+					{ // scoped rule ref
+						Grammar scopeG = grammar.composite.getGrammar(scope.Text);
+						$code.setAttribute("scope", scopeG);
+					}
+					else if ( rdef2.grammar != this.grammar )
+					{ // nonlocal
+						// if rule definition is not in this grammar, it's nonlocal
+						$code.setAttribute("scope", rdef2.grammar);
+					}
+					if ( $targ!=null )
+					{
+						List args = generator.translateAction(currentRuleName,$targ);
+						$code.setAttribute("args", args);
+					}
+				}
+				int i = ((TokenWithIndex)$t.Token).TokenIndex;
+				$code.setAttribute("elementIndex", i);
+				if ( label!=null )
+					$code.setAttribute("label", labelText);
+			}
+			else
+			{
+				$code = getTokenElementST("tokenRef", $t.text, $t, astSuffix, labelText);
+				string tokenLabel =
+					generator.getTokenTypeAsTargetLabel(grammar.getTokenType(t.Text));
+				$code.setAttribute("token",tokenLabel);
+				if ( !currentAltHasASTRewrite && $t.terminalOptions!=null )
+				{
+					$code.setAttribute("hetero",$t.terminalOptions[Grammar.defaultTokenOption]);
+				}
+				int i = ((TokenWithIndex)$t.Token).TokenIndex;
+				$code.setAttribute("elementIndex", i);
+				generator.generateLocalFOLLOW($t,tokenLabel,currentRuleName,i);
+			}
+			$t.code = $code;
+		}
+
+	|	c=CHAR_LITERAL
+		{
+			if ( grammar.type==Grammar.LEXER )
+			{
+				$code = templates.getInstanceOf("charRef");
+				$code.setAttribute("char",
+				   generator.target.getTargetCharLiteralFromANTLRCharLiteral(generator,$c.text));
+				if ( label!=null )
+				{
+					$code.setAttribute("label", labelText);
+				}
+			}
+			else { // else it's a token type reference
+				$code = getTokenElementST("tokenRef", "char_literal", $c, astSuffix, labelText);
+				string tokenLabel = generator.getTokenTypeAsTargetLabel(grammar.getTokenType($c.text));
+				$code.setAttribute("token",tokenLabel);
+				if ( $c.terminalOptions!=null ) {
+					$code.setAttribute("hetero",$c.terminalOptions[Grammar.defaultTokenOption]);
+				}
+				int i = ((TokenWithIndex)$c.Token).TokenIndex;
+				$code.setAttribute("elementIndex", i);
+				generator.generateLocalFOLLOW($c,tokenLabel,currentRuleName,i);
+			}
+		}
+
+	|	s=STRING_LITERAL
+		{
+			if ( grammar.type==Grammar.LEXER )
+			{
+				$code = templates.getInstanceOf("lexerStringRef");
+				$code.setAttribute("string",
+					generator.target.getTargetStringLiteralFromANTLRStringLiteral(generator,$s.text));
+				if ( label!=null )
+				{
+					$code.setAttribute("label", labelText);
+				}
+			}
+			else
+			{ // else it's a token type reference
+				$code = getTokenElementST("tokenRef", "string_literal", $s, astSuffix, labelText);
+				string tokenLabel =
+					generator.getTokenTypeAsTargetLabel(grammar.getTokenType($s.text));
+				$code.setAttribute("token",tokenLabel);
+				if ( $s.terminalOptions!=null )
+				{
+					$code.setAttribute("hetero",$s.terminalOptions[Grammar.defaultTokenOption]);
+				}
+				int i = ((TokenWithIndex)$s.Token).TokenIndex;
+				$code.setAttribute("elementIndex", i);
+				generator.generateLocalFOLLOW($s,tokenLabel,currentRuleName,i);
+			}
+		}
+
+	|	w=WILDCARD
+		{
+			$code = getWildcardST($w,astSuffix,labelText);
+			$code.setAttribute("elementIndex", ((TokenWithIndex)$w.Token).TokenIndex);
+		}
+
+	|	^(DOT ID a=atom[$ID, label, astSuffix]) // scope override on rule or token
+		{ $code = $a.code; }
+
+	|	set[label,astSuffix]
+		{ $code = $set.code; }
+	;
+
+ast_suffix
+	:	ROOT
+	|	BANG
+	;
+
+set[GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null]
+@init
+{
+	string labelText=null;
+	if ( $label!=null )
+	{
+		labelText = $label.Text;
+	}
+}
+	:	^(s=BLOCK .*) // only care that it's a BLOCK with setValue!=null
+		{
+			$code = getTokenElementST("matchSet", "set", $s, astSuffix, labelText);
+			int i = ((TokenWithIndex)$s.Token).TokenIndex;
+			$code.setAttribute("elementIndex", i);
+			if ( grammar.type!=Grammar.LEXER )
+			{
+				generator.generateLocalFOLLOW($s,"set",currentRuleName,i);
+			}
+			$code.setAttribute("s", generator.genSetExpr(templates,$s.SetValue,1,false));
+		}
+	;
+
+setElement
+	:	CHAR_LITERAL
+	|	TOKEN_REF
+	|	STRING_LITERAL
+	|	^(CHAR_RANGE CHAR_LITERAL CHAR_LITERAL)
+	;
+
+// REWRITE stuff
+
+rewrite returns [StringTemplate code=null]
+@init
+{
+	if ( state.backtracking == 0 )
+	{
+		if ( $start.Type==REWRITE )
+		{
+			if ( generator.grammar.BuildTemplate )
+			{
+				$code = templates.getInstanceOf("rewriteTemplate");
+			}
+			else
+			{
+				$code = templates.getInstanceOf("rewriteCode");
+				$code.setAttribute("treeLevel", OUTER_REWRITE_NESTING_LEVEL);
+				$code.setAttribute("rewriteBlockLevel", OUTER_REWRITE_NESTING_LEVEL);
+				$code.setAttribute("referencedElementsDeep",
+								  getTokenTypesAsTargetLabels($start.rewriteRefsDeep));
+				HashSet<string> tokenLabels =
+					grammar.getLabels($start.rewriteRefsDeep, Grammar.TOKEN_LABEL);
+				HashSet<string> tokenListLabels =
+					grammar.getLabels($start.rewriteRefsDeep, Grammar.TOKEN_LIST_LABEL);
+				HashSet<string> ruleLabels =
+					grammar.getLabels($start.rewriteRefsDeep, Grammar.RULE_LABEL);
+				HashSet<string> ruleListLabels =
+					grammar.getLabels($start.rewriteRefsDeep, Grammar.RULE_LIST_LABEL);
+				HashSet<string> wildcardLabels =
+					grammar.getLabels($start.rewriteRefsDeep, Grammar.WILDCARD_TREE_LABEL);
+				HashSet<string> wildcardListLabels =
+					grammar.getLabels($start.rewriteRefsDeep, Grammar.WILDCARD_TREE_LIST_LABEL);
+				// just in case they ref $r for "previous value", make a stream
+				// from retval.tree
+				StringTemplate retvalST = templates.getInstanceOf("prevRuleRootRef");
+				ruleLabels.Add(retvalST.ToString());
+				$code.setAttribute("referencedTokenLabels", tokenLabels);
+				$code.setAttribute("referencedTokenListLabels", tokenListLabels);
+				$code.setAttribute("referencedRuleLabels", ruleLabels);
+				$code.setAttribute("referencedRuleListLabels", ruleListLabels);
+				$code.setAttribute("referencedWildcardLabels", wildcardLabels);
+				$code.setAttribute("referencedWildcardListLabels", wildcardListLabels);
+			}
+		}
+		else
+		{
+				$code = templates.getInstanceOf("noRewrite");
+				$code.setAttribute("treeLevel", OUTER_REWRITE_NESTING_LEVEL);
+				$code.setAttribute("rewriteBlockLevel", OUTER_REWRITE_NESTING_LEVEL);
+		}
+	}
+}
+	:	(
+			{rewriteRuleRefs = new HashSet<object>();}
+			^( r=REWRITE (pred=SEMPRED)? alt=rewrite_alternative )
+			{
+				rewriteBlockNestingLevel = OUTER_REWRITE_NESTING_LEVEL;
+				List predChunks = null;
+				if ( $pred!=null )
+				{
+					//predText = #pred.getText();
+					predChunks = generator.translateAction(currentRuleName,$pred);
+				}
+				string description =
+					grammar.grammarTreeToString($r,false);
+				description = generator.target.getTargetStringLiteralFromString(description);
+				$code.setAttribute("alts.{pred,alt,description}",
+								  predChunks,
+								  alt,
+								  description);
+				pred=null;
+			}
+		)*
+	;
+
+rewrite_block[string blockTemplateName] returns [StringTemplate code=null]
+@init
+{
+	rewriteBlockNestingLevel++;
+	StringTemplate save_currentBlockST = currentBlockST;
+	if ( state.backtracking == 0 )
+	{
+		$code = templates.getInstanceOf(blockTemplateName);
+		currentBlockST = $code;
+		$code.setAttribute("rewriteBlockLevel", rewriteBlockNestingLevel);
+	}
+}
+	:	^(	BLOCK
+			{
+				currentBlockST.setAttribute("referencedElementsDeep",
+					getTokenTypesAsTargetLabels($BLOCK.rewriteRefsDeep));
+				currentBlockST.setAttribute("referencedElements",
+					getTokenTypesAsTargetLabels($BLOCK.rewriteRefsShallow));
+			}
+			alt=rewrite_alternative
+			EOB
+		)
+		{
+			$code.setAttribute("alt", $alt.code);
+		}
+	;
+finally { rewriteBlockNestingLevel--; currentBlockST = save_currentBlockST; }
+
+rewrite_alternative returns [StringTemplate code=null]
+	:	{generator.grammar.BuildAST}?
+		^(	a=ALT {$code=templates.getInstanceOf("rewriteElementList");}
+			(	(
+					el=rewrite_element
+					{$code.setAttribute("elements.{el,line,pos}",
+										$el.code,
+										$el.start.Line,
+										$el.start.CharPositionInLine
+										);
+					}
+				)+
+			|	EPSILON
+				{$code.setAttribute("elements.{el,line,pos}",
+								   templates.getInstanceOf("rewriteEmptyAlt"),
+								   $a.Line,
+								   $a.CharPositionInLine
+								   );
+				}
+			)
+			EOA
+		 )
+
+	|	{generator.grammar.BuildTemplate}? rewrite_template
+		{ $code = $rewrite_template.code; }
+
+	|	// reproduce same input (only AST at moment)
+		ETC
+	;
+
+rewrite_element returns [StringTemplate code=null]
+@init
+{
+	IIntSet elements=null;
+	GrammarAST ast = null;
+}
+	:	rewrite_atom[false]
+		{ $code = $rewrite_atom.code; }
+	|	rewrite_ebnf
+		{ $code = $rewrite_ebnf.code; }
+	|	rewrite_tree
+		{ $code = $rewrite_tree.code; }
+	;
+
+rewrite_ebnf returns [StringTemplate code=null]
+	:	^( OPTIONAL rewrite_block["rewriteOptionalBlock"] )
+		{ $code = $rewrite_block.code; }
+		{
+			string description = grammar.grammarTreeToString($start, false);
+			description = generator.target.getTargetStringLiteralFromString(description);
+			$code.setAttribute("description", description);
+		}
+	|	^( CLOSURE rewrite_block["rewriteClosureBlock"] )
+		{ $code = $rewrite_block.code; }
+		{
+			string description = grammar.grammarTreeToString($start, false);
+			description = generator.target.getTargetStringLiteralFromString(description);
+			$code.setAttribute("description", description);
+		}
+	|	^( POSITIVE_CLOSURE rewrite_block["rewritePositiveClosureBlock"] )
+		{ $code = $rewrite_block.code; }
+		{
+			string description = grammar.grammarTreeToString($start, false);
+			description = generator.target.getTargetStringLiteralFromString(description);
+			$code.setAttribute("description", description);
+		}
+	;
+
+rewrite_tree returns [StringTemplate code]
+@init
+{
+	rewriteTreeNestingLevel++;
+	if ( state.backtracking == 0 )
+	{
+		$code = templates.getInstanceOf("rewriteTree");
+		$code.setAttribute("treeLevel", rewriteTreeNestingLevel);
+		$code.setAttribute("enclosingTreeLevel", rewriteTreeNestingLevel-1);
+	}
+}
+	:	^(	TREE_BEGIN
+			r=rewrite_atom[true]
+			{
+				$code.setAttribute("root.{el,line,pos}",
+								   $r.code,
+								   $r.start.Line,
+								   $r.start.CharPositionInLine
+								  );
+			}
+			(
+			  el=rewrite_element
+			  {
+				$code.setAttribute("children.{el,line,pos}",
+									$el.code,
+									$el.start.Line,
+									$el.start.CharPositionInLine
+									);
+			  }
+			)*
+		)
+		{
+			string description = grammar.grammarTreeToString($start, false);
+			description = generator.target.getTargetStringLiteralFromString(description);
+			$code.setAttribute("description", description);
+		}
+	;
+finally { rewriteTreeNestingLevel--; }
+
+rewrite_atom[bool isRoot] returns [StringTemplate code=null]
+	:   r=RULE_REF
+		{
+			string ruleRefName = $r.text;
+			string stName = "rewriteRuleRef";
+			if ( isRoot )
+			{
+				stName += "Root";
+			}
+			$code = templates.getInstanceOf(stName);
+			$code.setAttribute("rule", ruleRefName);
+			if ( grammar.getRule(ruleRefName)==null )
+			{
+				ErrorManager.grammarError(ErrorManager.MSG_UNDEFINED_RULE_REF,
+										  grammar,
+										  ((GrammarAST)($r)).Token,
+										  ruleRefName);
+				$code = new StringTemplate(); // blank; no code gen
+			}
+			else if ( grammar.getRule(currentRuleName)
+						 .getRuleRefsInAlt(ruleRefName,outerAltNum)==null )
+			{
+				ErrorManager.grammarError(ErrorManager.MSG_REWRITE_ELEMENT_NOT_PRESENT_ON_LHS,
+										  grammar,
+										  ((GrammarAST)($r)).Token,
+										  ruleRefName);
+				$code = new StringTemplate(); // blank; no code gen
+			}
+			else
+			{
+				// track all rule refs as we must copy 2nd ref to rule and beyond
+				if ( !rewriteRuleRefs.Contains(ruleRefName) )
+				{
+					rewriteRuleRefs.Add(ruleRefName);
+				}
+			}
+		}
+
+	|
+		(	^(tk=TOKEN_REF (arg=ARG_ACTION)?)
+		|	cl=CHAR_LITERAL
+		|	sl=STRING_LITERAL
+		)
+		{
+			GrammarAST term = ($tk) ?? ($cl) ?? ($sl);
+			string tokenName = $start.Token.Text;
+			string stName = "rewriteTokenRef";
+			Rule rule = grammar.getRule(currentRuleName);
+			ICollection<string> tokenRefsInAlt = rule.getTokenRefsInAlt(outerAltNum);
+			bool createNewNode = !tokenRefsInAlt.Contains(tokenName) || $arg!=null;
+			object hetero = null;
+			if ( term.terminalOptions!=null )
+			{
+				hetero = term.terminalOptions[Grammar.defaultTokenOption];
+			}
+			if ( createNewNode )
+			{
+				stName = "rewriteImaginaryTokenRef";
+			}
+			if ( isRoot )
+			{
+				stName += "Root";
+			}
+			$code = templates.getInstanceOf(stName);
+			$code.setAttribute("hetero", hetero);
+			if ( $arg!=null )
+			{
+				List args = generator.translateAction(currentRuleName,$arg);
+				$code.setAttribute("args", args);
+			}
+			$code.setAttribute("elementIndex", ((TokenWithIndex)$start.Token).TokenIndex);
+			int ttype = grammar.getTokenType(tokenName);
+			string tok = generator.getTokenTypeAsTargetLabel(ttype);
+			$code.setAttribute("token", tok);
+			if ( grammar.getTokenType(tokenName)==Label.INVALID )
+			{
+				ErrorManager.grammarError(ErrorManager.MSG_UNDEFINED_TOKEN_REF_IN_REWRITE,
+										  grammar,
+										  ((GrammarAST)($start)).Token,
+										  tokenName);
+				$code = new StringTemplate(); // blank; no code gen
+			}
+		}
+
+	|	LABEL
+		{
+			string labelName = $LABEL.text;
+			Rule rule = grammar.getRule(currentRuleName);
+			Grammar.LabelElementPair pair = rule.getLabel(labelName);
+			if ( labelName.Equals(currentRuleName) )
+			{
+				// special case; ref to old value via $ rule
+				if ( rule.hasRewrite(outerAltNum) &&
+					 rule.getRuleRefsInAlt(outerAltNum).Contains(labelName) )
+				{
+					ErrorManager.grammarError(ErrorManager.MSG_RULE_REF_AMBIG_WITH_RULE_IN_ALT,
+											  grammar,
+											  ((GrammarAST)($LABEL)).Token,
+											  labelName);
+				}
+				StringTemplate labelST = templates.getInstanceOf("prevRuleRootRef");
+				$code = templates.getInstanceOf("rewriteRuleLabelRef"+(isRoot?"Root":""));
+				$code.setAttribute("label", labelST);
+			}
+			else if ( pair==null )
+			{
+				ErrorManager.grammarError(ErrorManager.MSG_UNDEFINED_LABEL_REF_IN_REWRITE,
+										  grammar,
+										  ((GrammarAST)($LABEL)).Token,
+										  labelName);
+				$code = new StringTemplate();
+			}
+			else
+			{
+				string stName = null;
+				switch ( pair.type )
+				{
+				case Grammar.TOKEN_LABEL :
+					stName = "rewriteTokenLabelRef";
+					break;
+				case Grammar.WILDCARD_TREE_LABEL :
+					stName = "rewriteWildcardLabelRef";
+					break;
+				case Grammar.WILDCARD_TREE_LIST_LABEL:
+					stName = "rewriteRuleListLabelRef"; // acts like rule ref list for ref
+					break;
+				case Grammar.RULE_LABEL :
+					stName = "rewriteRuleLabelRef";
+					break;
+				case Grammar.TOKEN_LIST_LABEL :
+					stName = "rewriteTokenListLabelRef";
+					break;
+				case Grammar.RULE_LIST_LABEL :
+					stName = "rewriteRuleListLabelRef";
+					break;
+				}
+				if ( isRoot )
+				{
+					stName += "Root";
+				}
+				$code = templates.getInstanceOf(stName);
+				$code.setAttribute("label", labelName);
+			}
+		}
+
+	|	ACTION
+		{
+			// actions in rewrite rules yield a tree object
+			string actText = $ACTION.text;
+			List chunks = generator.translateAction(currentRuleName,$ACTION);
+			$code = templates.getInstanceOf("rewriteNodeAction"+(isRoot?"Root":""));
+			$code.setAttribute("action", chunks);
+		}
+	;
+
+public
+rewrite_template returns [StringTemplate code=null]
+	:	^( ALT EPSILON EOA ) {$code=templates.getInstanceOf("rewriteEmptyTemplate");}
+	|	^(	TEMPLATE (id=ID|ind=ACTION)
+			{
+				if ( $id!=null && $id.text.Equals("template") )
+				{
+						$code = templates.getInstanceOf("rewriteInlineTemplate");
+				}
+				else if ( $id!=null )
+				{
+						$code = templates.getInstanceOf("rewriteExternalTemplate");
+						$code.setAttribute("name", $id.text);
+				}
+				else if ( $ind!=null )
+				{ // must be \%({expr})(args)
+					$code = templates.getInstanceOf("rewriteIndirectTemplate");
+					List chunks=generator.translateAction(currentRuleName,$ind);
+					$code.setAttribute("expr", chunks);
+				}
+			}
+			^(	ARGLIST
+				(	^( ARG arg=ID a=ACTION
+					{
+						// must set alt num here rather than in define.g
+						// because actions like \%foo(name={\$ID.text}) aren't
+						// broken up yet into trees.
+						$a.outerAltNum = this.outerAltNum;
+						List chunks = generator.translateAction(currentRuleName,$a);
+						$code.setAttribute("args.{name,value}", $arg.text, chunks);
+					}
+					)
+				)*
+			)
+			(	DOUBLE_QUOTE_STRING_LITERAL
+				{
+					string sl = $DOUBLE_QUOTE_STRING_LITERAL.text;
+					string t = sl.Substring( 1, sl.Length - 2 ); // strip quotes
+					t = generator.target.getTargetStringLiteralFromString(t);
+					$code.setAttribute("template",t);
+				}
+			|	DOUBLE_ANGLE_STRING_LITERAL
+				{
+					string sl = $DOUBLE_ANGLE_STRING_LITERAL.text;
+					string t = sl.Substring( 2, sl.Length - 4 ); // strip double angle quotes
+					t = generator.target.getTargetStringLiteralFromString(t);
+					$code.setAttribute("template",t);
+				}
+			)?
+		)
+
+	|	act=ACTION
+		{
+			// set alt num for same reason as ARGLIST above
+			$act.outerAltNum = this.outerAltNum;
+			$code=templates.getInstanceOf("rewriteAction");
+			$code.setAttribute("action",
+							  generator.translateAction(currentRuleName,$act));
+		}
+	;
diff --git a/Antlr3/Grammars/CodeGenTreeWalkerHelper.cs b/Antlr3/Grammars/CodeGenTreeWalkerHelper.cs
new file mode 100644
index 0000000..7139487
--- /dev/null
+++ b/Antlr3/Grammars/CodeGenTreeWalkerHelper.cs
@@ -0,0 +1,285 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Grammar conversion to ANTLR v3 and C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *	notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	notice, this list of conditions and the following disclaimer in the
+ *	documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *	derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Grammars
+{
+    using System.Collections.Generic;
+    using Antlr.Runtime.JavaExtensions;
+    using Antlr3.Codegen;
+
+    using CommonToken = Antlr.Runtime.CommonToken;
+    using Console = System.Console;
+    using ErrorManager = Antlr3.Tool.ErrorManager;
+    using Grammar = Antlr3.Tool.Grammar;
+    using GrammarAST = Antlr3.Tool.GrammarAST;
+    using IToken = Antlr.Runtime.IToken;
+    using MismatchedTokenException = Antlr.Runtime.MismatchedTokenException;
+    using NoViableAltException = Antlr.Runtime.NoViableAltException;
+    using RecognitionException = Antlr.Runtime.RecognitionException;
+    using Rule = Antlr3.Tool.Rule;
+    using StringTemplate = Antlr3.ST.StringTemplate;
+    using StringTemplateGroup = Antlr3.ST.StringTemplateGroup;
+
+    partial class CodeGenTreeWalker
+    {
+        protected const int RULE_BLOCK_NESTING_LEVEL = 0;
+        protected const int OUTER_REWRITE_NESTING_LEVEL = 0;
+
+        protected internal string currentRuleName = null;
+        protected int blockNestingLevel = 0;
+        protected int rewriteBlockNestingLevel = 0;
+        protected internal int outerAltNum = 0;
+        protected StringTemplate currentBlockST = null;
+        protected bool currentAltHasASTRewrite = false;
+        protected int rewriteTreeNestingLevel = 0;
+        protected HashSet<object> rewriteRuleRefs = null;
+
+        public override void ReportError( RecognitionException ex )
+        {
+            IToken token = null;
+            if ( ex is MismatchedTokenException )
+            {
+                token = ( (MismatchedTokenException)ex ).token;
+            }
+            else if ( ex is NoViableAltException )
+            {
+                token = ( (NoViableAltException)ex ).token;
+            }
+            ErrorManager.syntaxError(
+                ErrorManager.MSG_SYNTAX_ERROR,
+                grammar,
+                token,
+                "codegen: " + ex.ToString(),
+                ex );
+        }
+
+        public void reportError( string s )
+        {
+            Console.Out.WriteLine( "codegen: error: " + s );
+        }
+
+        protected CodeGenerator generator;
+        protected Grammar grammar;
+        protected StringTemplateGroup templates;
+
+        /** The overall lexer/parser template; simulate dynamically scoped
+         *  attributes by making this an instance var of the walker.
+         */
+        protected StringTemplate recognizerST;
+
+        protected StringTemplate outputFileST;
+        protected StringTemplate headerFileST;
+
+        protected string outputOption = "";
+
+        protected StringTemplate getWildcardST( GrammarAST elementAST, GrammarAST ast_suffix, string label )
+        {
+            string name = "wildcard";
+            if ( grammar.type == Grammar.LEXER )
+            {
+                name = "wildcardChar";
+            }
+            return getTokenElementST( name, name, elementAST, ast_suffix, label );
+        }
+
+        protected StringTemplate getRuleElementST( string name,
+                                                  string ruleTargetName,
+                                                  GrammarAST elementAST,
+                                                  GrammarAST ast_suffix,
+                                                  string label )
+        {
+            string suffix = getSTSuffix( elementAST, ast_suffix, label );
+            name += suffix;
+            // if we're building trees and there is no label, gen a label
+            // unless we're in a synpred rule.
+            Rule r = grammar.getRule( currentRuleName );
+            if ( ( grammar.BuildAST || suffix.Length > 0 ) && label == null &&
+                 ( r == null || !r.isSynPred ) )
+            {
+                // we will need a label to do the AST or tracking, make one
+                label = generator.createUniqueLabel( ruleTargetName );
+                CommonToken labelTok = new CommonToken( ANTLRParser.ID, label );
+                grammar.defineRuleRefLabel( currentRuleName, labelTok, elementAST );
+            }
+            StringTemplate elementST = templates.getInstanceOf( name );
+            if ( label != null )
+            {
+                elementST.setAttribute( "label", label );
+            }
+            return elementST;
+        }
+
+        protected StringTemplate getTokenElementST( string name,
+                                                   string elementName,
+                                                   GrammarAST elementAST,
+                                                   GrammarAST ast_suffix,
+                                                   string label )
+        {
+            bool tryUnchecked = false;
+            if ( name == "matchSet" && !string.IsNullOrEmpty( elementAST.enclosingRuleName ) && char.IsUpper( elementAST.enclosingRuleName[0] ) )
+            {
+                if ( ( elementAST.Parent.Type == ANTLRLexer.ALT && elementAST.Parent.Parent.Parent.Type == RULE && elementAST.Parent.Parent.ChildCount == 2 )
+                    || ( elementAST.Parent.Type == ANTLRLexer.NOT && elementAST.Parent.Parent.Parent.Parent.Type == RULE && elementAST.Parent.Parent.Parent.ChildCount == 2 ) )
+                {
+                    // single alt at the start of the rule needs to be checked
+                }
+                else
+                {
+                    tryUnchecked = true;
+                }
+            }
+
+            string suffix = getSTSuffix( elementAST, ast_suffix, label );
+            // if we're building trees and there is no label, gen a label
+            // unless we're in a synpred rule.
+            Rule r = grammar.getRule( currentRuleName );
+            if ( ( grammar.BuildAST || suffix.Length > 0 ) && label == null &&
+                 ( r == null || !r.isSynPred ) )
+            {
+                label = generator.createUniqueLabel( elementName );
+                CommonToken labelTok = new CommonToken( ANTLRParser.ID, label );
+                grammar.defineTokenRefLabel( currentRuleName, labelTok, elementAST );
+            }
+
+            StringTemplate elementST = null;
+            if ( tryUnchecked && templates.isDefined( name + "Unchecked" + suffix ) )
+                elementST = templates.getInstanceOf( name + "Unchecked" + suffix );
+            if ( elementST == null )
+                elementST = templates.getInstanceOf( name + suffix );
+
+            if ( label != null )
+            {
+                elementST.setAttribute( "label", label );
+            }
+            return elementST;
+        }
+
+        public bool isListLabel( string label )
+        {
+            bool hasListLabel = false;
+            if ( label != null )
+            {
+                Rule r = grammar.getRule( currentRuleName );
+                //String stName = null;
+                if ( r != null )
+                {
+                    Grammar.LabelElementPair pair = r.getLabel( label );
+                    if ( pair != null &&
+                         ( pair.type == Grammar.TOKEN_LIST_LABEL ||
+                          pair.type == Grammar.RULE_LIST_LABEL ||
+                          pair.type == Grammar.WILDCARD_TREE_LIST_LABEL ) )
+                    {
+                        hasListLabel = true;
+                    }
+                }
+            }
+            return hasListLabel;
+        }
+
+        /** Return a non-empty template name suffix if the token is to be
+         *  tracked, added to a tree, or both.
+         */
+        protected string getSTSuffix( GrammarAST elementAST, GrammarAST ast_suffix, string label )
+        {
+            if ( grammar.type == Grammar.LEXER )
+            {
+                return "";
+            }
+            // handle list label stuff; make element use "Track"
+
+            string operatorPart = "";
+            string rewritePart = "";
+            string listLabelPart = "";
+            Rule ruleDescr = grammar.getRule( currentRuleName );
+            if ( ast_suffix != null && !ruleDescr.isSynPred )
+            {
+                if ( ast_suffix.Type == ANTLRParser.ROOT )
+                {
+                    operatorPart = "RuleRoot";
+                }
+                else if ( ast_suffix.Type == ANTLRParser.BANG )
+                {
+                    operatorPart = "Bang";
+                }
+            }
+            if ( currentAltHasASTRewrite && elementAST.Type != WILDCARD )
+            {
+                rewritePart = "Track";
+            }
+            if ( isListLabel( label ) )
+            {
+                listLabelPart = "AndListLabel";
+            }
+            string STsuffix = operatorPart + rewritePart + listLabelPart;
+            //JSystem.@out.println("suffix = "+STsuffix);
+
+            return STsuffix;
+        }
+
+        /** Convert rewrite AST lists to target labels list */
+        protected IList<string> getTokenTypesAsTargetLabels( HashSet<GrammarAST> refs )
+        {
+            if ( refs == null || refs.Count == 0 )
+            {
+                return null;
+            }
+            IList<string> labels = new List<string>( refs.Count );
+            foreach ( GrammarAST t in refs )
+            {
+                string label;
+                if ( t.Type == ANTLRParser.RULE_REF )
+                {
+                    label = t.Text;
+                }
+                else if ( t.Type == ANTLRParser.LABEL )
+                {
+                    label = t.Text;
+                }
+                else
+                {
+                    // must be char or string literal
+                    label = generator.getTokenTypeAsTargetLabel(
+                                grammar.getTokenType( t.Text ) );
+                }
+                labels.Add( label );
+            }
+            return labels;
+        }
+
+        public void init( Grammar g )
+        {
+            this.grammar = g;
+            this.generator = grammar.CodeGenerator;
+            this.templates = generator.Templates;
+        }
+    }
+}
diff --git a/Antlr3/Grammars/DefineGrammarItemsWalker.cs b/Antlr3/Grammars/DefineGrammarItemsWalker.cs
new file mode 100644
index 0000000..aefb9f9
--- /dev/null
+++ b/Antlr3/Grammars/DefineGrammarItemsWalker.cs
@@ -0,0 +1,4893 @@
+// $ANTLR 3.1.2 Grammars\\DefineGrammarItemsWalker.g3 2009-03-08 16:36:55
+
+// The variable 'variable' is assigned but its value is never used.
+#pragma warning disable 219
+// Unreachable code detected.
+#pragma warning disable 162
+
+
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+using System;
+
+using Antlr3.Tool;
+using boolean = System.Boolean;
+using Character = java.lang.Character;
+using Utils = Antlr3.Misc.Utils;
+
+
+using System.Collections.Generic;
+using Antlr.Runtime;
+using Antlr.Runtime.Tree;
+using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;using Stack = System.Collections.Generic.Stack<object>;
+using List = System.Collections.IList;
+using ArrayList = System.Collections.Generic.List<object>;
+using Map = System.Collections.IDictionary;
+using HashMap = System.Collections.Generic.Dictionary<object, object>;
+namespace Antlr3.Grammars
+{
+public partial class DefineGrammarItemsWalker : TreeParser
+{
+	public static readonly string[] tokenNames = new string[] {
+		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", "ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARG_ACTION", "ARGLIST", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", "CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", "COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", "DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", "EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", "GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", "LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", "NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", "OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", "RET", "RETURNS", "REWRITE", "ROOT", "RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", "SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYN_SEMPRED", "SYNPRED", "TEMPLATE", "THROWS", "TOKEN_REF", "TOKENS", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", "WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT"
+	};
+	public const int EOF=-1;
+	public const int ACTION=4;
+	public const int ACTION_CHAR_LITERAL=5;
+	public const int ACTION_ESC=6;
+	public const int ACTION_STRING_LITERAL=7;
+	public const int ALT=8;
+	public const int AMPERSAND=9;
+	public const int ARG=10;
+	public const int ARG_ACTION=11;
+	public const int ARGLIST=12;
+	public const int ASSIGN=13;
+	public const int BACKTRACK_SEMPRED=14;
+	public const int BANG=15;
+	public const int BLOCK=16;
+	public const int CATCH=17;
+	public const int CHAR_LITERAL=18;
+	public const int CHAR_RANGE=19;
+	public const int CLOSE_ELEMENT_OPTION=20;
+	public const int CLOSURE=21;
+	public const int COLON=22;
+	public const int COMBINED_GRAMMAR=23;
+	public const int COMMA=24;
+	public const int COMMENT=25;
+	public const int DIGIT=26;
+	public const int DOC_COMMENT=27;
+	public const int DOLLAR=28;
+	public const int DOT=29;
+	public const int DOUBLE_ANGLE_STRING_LITERAL=30;
+	public const int DOUBLE_QUOTE_STRING_LITERAL=31;
+	public const int EOA=32;
+	public const int EOB=33;
+	public const int EOR=34;
+	public const int EPSILON=35;
+	public const int ESC=36;
+	public const int ETC=37;
+	public const int FINALLY=38;
+	public const int FORCED_ACTION=39;
+	public const int FRAGMENT=40;
+	public const int GATED_SEMPRED=41;
+	public const int GRAMMAR=42;
+	public const int ID=43;
+	public const int IMPLIES=44;
+	public const int IMPORT=45;
+	public const int INITACTION=46;
+	public const int INT=47;
+	public const int LABEL=48;
+	public const int LEXER=49;
+	public const int LEXER_GRAMMAR=50;
+	public const int LPAREN=51;
+	public const int ML_COMMENT=52;
+	public const int NESTED_ACTION=53;
+	public const int NESTED_ARG_ACTION=54;
+	public const int NOT=55;
+	public const int OPEN_ELEMENT_OPTION=56;
+	public const int OPTIONAL=57;
+	public const int OPTIONS=58;
+	public const int OR=59;
+	public const int PARSER=60;
+	public const int PARSER_GRAMMAR=61;
+	public const int PLUS=62;
+	public const int PLUS_ASSIGN=63;
+	public const int POSITIVE_CLOSURE=64;
+	public const int PRIVATE=65;
+	public const int PROTECTED=66;
+	public const int PUBLIC=67;
+	public const int QUESTION=68;
+	public const int RANGE=69;
+	public const int RCURLY=70;
+	public const int RET=71;
+	public const int RETURNS=72;
+	public const int REWRITE=73;
+	public const int ROOT=74;
+	public const int RPAREN=75;
+	public const int RULE=76;
+	public const int RULE_REF=77;
+	public const int SCOPE=78;
+	public const int SEMI=79;
+	public const int SEMPRED=80;
+	public const int SL_COMMENT=81;
+	public const int SRC=82;
+	public const int STAR=83;
+	public const int STRAY_BRACKET=84;
+	public const int STRING_LITERAL=85;
+	public const int SYN_SEMPRED=86;
+	public const int SYNPRED=87;
+	public const int TEMPLATE=88;
+	public const int THROWS=89;
+	public const int TOKEN_REF=90;
+	public const int TOKENS=91;
+	public const int TREE=92;
+	public const int TREE_BEGIN=93;
+	public const int TREE_GRAMMAR=94;
+	public const int WILDCARD=95;
+	public const int WS=96;
+	public const int WS_LOOP=97;
+	public const int WS_OPT=98;
+	public const int XDIGIT=99;
+
+	// delegates
+	// delegators
+
+	protected class AttributeScopeActions_scope
+	{
+		public static void PushScope( DefineGrammarItemsWalker grammar )
+		{
+			grammar.AttributeScopeActions_stack.Push( new AttributeScopeActions_scope() );
+		}
+		public static void PopScope( DefineGrammarItemsWalker grammar )
+		{
+			grammar.AttributeScopeActions_stack.Pop();
+		}
+
+		public Dictionary<GrammarAST, GrammarAST> actions;
+	}
+	protected Stack<AttributeScopeActions_scope> AttributeScopeActions_stack = new Stack<AttributeScopeActions_scope>();
+
+	public DefineGrammarItemsWalker( ITreeNodeStream input )
+		: this( input, new RecognizerSharedState() )
+	{
+	}
+	public DefineGrammarItemsWalker( ITreeNodeStream input, RecognizerSharedState state )
+		: base( input, state )
+	{
+	}
+
+
+	public override string[] GetTokenNames() { return DefineGrammarItemsWalker.tokenNames; }
+	public override string GrammarFileName { get { return "Grammars\\DefineGrammarItemsWalker.g3"; } }
+
+
+	#region Rules
+	public class grammar__return : TreeRuleReturnScope
+	{
+	}
+
+	// $ANTLR start "grammar_"
+	// Grammars\\DefineGrammarItemsWalker.g3:91:0: public grammar_[Grammar g] : ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) );
+	public DefineGrammarItemsWalker.grammar__return grammar_( Grammar g )
+	{
+		DefineGrammarItemsWalker.grammar__return retval = new DefineGrammarItemsWalker.grammar__return();
+		retval.start = input.LT(1);
+
+
+		grammar = g;
+		root = ((GrammarAST)retval.start);
+
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:101:4: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
+			int alt1=4;
+			switch ( input.LA(1) )
+			{
+			case LEXER_GRAMMAR:
+				{
+				alt1=1;
+				}
+				break;
+			case PARSER_GRAMMAR:
+				{
+				alt1=2;
+				}
+				break;
+			case TREE_GRAMMAR:
+				{
+				alt1=3;
+				}
+				break;
+			case COMBINED_GRAMMAR:
+				{
+				alt1=4;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 1, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt1 )
+			{
+			case 1:
+				// Grammars\\DefineGrammarItemsWalker.g3:101:4: ^( LEXER_GRAMMAR grammarSpec )
+				{
+				Match(input,LEXER_GRAMMAR,Follow._LEXER_GRAMMAR_in_grammar_77); if (state.failed) return retval;
+
+				if ( state.backtracking == 0 )
+				{
+					grammar.type = Grammar.LEXER;
+				}
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				PushFollow(Follow._grammarSpec_in_grammar_83);
+				grammarSpec();
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+
+				}
+				break;
+			case 2:
+				// Grammars\\DefineGrammarItemsWalker.g3:102:4: ^( PARSER_GRAMMAR grammarSpec )
+				{
+				Match(input,PARSER_GRAMMAR,Follow._PARSER_GRAMMAR_in_grammar_92); if (state.failed) return retval;
+
+				if ( state.backtracking == 0 )
+				{
+					grammar.type = Grammar.PARSER;
+				}
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				PushFollow(Follow._grammarSpec_in_grammar_97);
+				grammarSpec();
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+
+				}
+				break;
+			case 3:
+				// Grammars\\DefineGrammarItemsWalker.g3:103:4: ^( TREE_GRAMMAR grammarSpec )
+				{
+				Match(input,TREE_GRAMMAR,Follow._TREE_GRAMMAR_in_grammar_106); if (state.failed) return retval;
+
+				if ( state.backtracking == 0 )
+				{
+					grammar.type = Grammar.TREE_PARSER;
+				}
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				PushFollow(Follow._grammarSpec_in_grammar_111);
+				grammarSpec();
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+
+				}
+				break;
+			case 4:
+				// Grammars\\DefineGrammarItemsWalker.g3:104:4: ^( COMBINED_GRAMMAR grammarSpec )
+				{
+				Match(input,COMBINED_GRAMMAR,Follow._COMBINED_GRAMMAR_in_grammar_120); if (state.failed) return retval;
+
+				if ( state.backtracking == 0 )
+				{
+					grammar.type = Grammar.COMBINED;
+				}
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				PushFollow(Follow._grammarSpec_in_grammar_125);
+				grammarSpec();
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+
+				}
+				break;
+
+			}
+			if ( state.backtracking == 0 )
+			{
+
+				finish();
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "grammar_"
+
+
+	// $ANTLR start "attrScope"
+	// Grammars\\DefineGrammarItemsWalker.g3:107:0: attrScope : ^( 'scope' name= ID ( attrScopeAction )* attrs= ACTION ) ;
+	private void attrScope(  )
+	{
+		AttributeScopeActions_scope.PushScope(this);
+
+		GrammarAST name=null;
+		GrammarAST attrs=null;
+
+
+			((AttributeScopeActions_scope)AttributeScopeActions_stack.Peek()).actions = new Dictionary<GrammarAST, GrammarAST>();
+
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:113:4: ( ^( 'scope' name= ID ( attrScopeAction )* attrs= ACTION ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:113:4: ^( 'scope' name= ID ( attrScopeAction )* attrs= ACTION )
+			{
+			Match(input,SCOPE,Follow._SCOPE_in_attrScope150); if (state.failed) return ;
+
+			Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+			name=(GrammarAST)Match(input,ID,Follow._ID_in_attrScope154); if (state.failed) return ;
+			// Grammars\\DefineGrammarItemsWalker.g3:113:23: ( attrScopeAction )*
+			for ( ; ; )
+			{
+				int alt2=2;
+				int LA2_0 = input.LA(1);
+
+				if ( (LA2_0==AMPERSAND) )
+				{
+					alt2=1;
+				}
+
+
+				switch ( alt2 )
+				{
+				case 1:
+					// Grammars\\DefineGrammarItemsWalker.g3:113:0: attrScopeAction
+					{
+					PushFollow(Follow._attrScopeAction_in_attrScope156);
+					attrScopeAction();
+
+					state._fsp--;
+					if (state.failed) return ;
+
+					}
+					break;
+
+				default:
+					goto loop2;
+				}
+			}
+
+			loop2:
+				;
+
+
+			attrs=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_attrScope161); if (state.failed) return ;
+
+			Match(input, TokenConstants.UP, null); if (state.failed) return ;
+			if ( state.backtracking == 0 )
+			{
+
+							AttributeScope scope = grammar.defineGlobalScope((name!=null?name.Text:null),attrs.token);
+							scope.isDynamicGlobalScope = true;
+							scope.addAttributes((attrs!=null?attrs.Text:null), ';');
+							foreach ( var action in ((AttributeScopeActions_scope)AttributeScopeActions_stack.Peek()).actions )
+								scope.DefineNamedAction( action.Key, action.Value );
+
+			}
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+			AttributeScopeActions_scope.PopScope(this);
+
+		}
+		return ;
+	}
+	// $ANTLR end "attrScope"
+
+
+	// $ANTLR start "attrScopeAction"
+	// Grammars\\DefineGrammarItemsWalker.g3:123:0: attrScopeAction : ^( AMPERSAND ID ACTION ) ;
+	private void attrScopeAction(  )
+	{
+		GrammarAST ID1=null;
+		GrammarAST ACTION2=null;
+
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:124:4: ( ^( AMPERSAND ID ACTION ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:124:4: ^( AMPERSAND ID ACTION )
+			{
+			Match(input,AMPERSAND,Follow._AMPERSAND_in_attrScopeAction179); if (state.failed) return ;
+
+			Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+			ID1=(GrammarAST)Match(input,ID,Follow._ID_in_attrScopeAction181); if (state.failed) return ;
+			ACTION2=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_attrScopeAction183); if (state.failed) return ;
+
+			Match(input, TokenConstants.UP, null); if (state.failed) return ;
+			if ( state.backtracking == 0 )
+			{
+
+							((AttributeScopeActions_scope)AttributeScopeActions_stack.Peek()).actions.Add( ID1, ACTION2 );
+
+			}
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "attrScopeAction"
+
+
+	// $ANTLR start "grammarSpec"
+	// Grammars\\DefineGrammarItemsWalker.g3:130:0: grammarSpec : id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( actions )? rules ;
+	private void grammarSpec(  )
+	{
+		GrammarAST id=null;
+		GrammarAST cmt=null;
+
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:131:4: (id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( actions )? rules )
+			// Grammars\\DefineGrammarItemsWalker.g3:131:4: id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( actions )? rules
+			{
+			id=(GrammarAST)Match(input,ID,Follow._ID_in_grammarSpec201); if (state.failed) return ;
+			// Grammars\\DefineGrammarItemsWalker.g3:132:3: (cmt= DOC_COMMENT )?
+			int alt3=2;
+			int LA3_0 = input.LA(1);
+
+			if ( (LA3_0==DOC_COMMENT) )
+			{
+				alt3=1;
+			}
+			switch ( alt3 )
+			{
+			case 1:
+				// Grammars\\DefineGrammarItemsWalker.g3:132:4: cmt= DOC_COMMENT
+				{
+				cmt=(GrammarAST)Match(input,DOC_COMMENT,Follow._DOC_COMMENT_in_grammarSpec208); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+			// Grammars\\DefineGrammarItemsWalker.g3:133:3: ( optionsSpec )?
+			int alt4=2;
+			int LA4_0 = input.LA(1);
+
+			if ( (LA4_0==OPTIONS) )
+			{
+				alt4=1;
+			}
+			switch ( alt4 )
+			{
+			case 1:
+				// Grammars\\DefineGrammarItemsWalker.g3:133:5: optionsSpec
+				{
+				PushFollow(Follow._optionsSpec_in_grammarSpec216);
+				optionsSpec();
+
+				state._fsp--;
+				if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+			// Grammars\\DefineGrammarItemsWalker.g3:134:3: ( delegateGrammars )?
+			int alt5=2;
+			int LA5_0 = input.LA(1);
+
+			if ( (LA5_0==IMPORT) )
+			{
+				alt5=1;
+			}
+			switch ( alt5 )
+			{
+			case 1:
+				// Grammars\\DefineGrammarItemsWalker.g3:134:4: delegateGrammars
+				{
+				PushFollow(Follow._delegateGrammars_in_grammarSpec224);
+				delegateGrammars();
+
+				state._fsp--;
+				if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+			// Grammars\\DefineGrammarItemsWalker.g3:135:3: ( tokensSpec )?
+			int alt6=2;
+			int LA6_0 = input.LA(1);
+
+			if ( (LA6_0==TOKENS) )
+			{
+				alt6=1;
+			}
+			switch ( alt6 )
+			{
+			case 1:
+				// Grammars\\DefineGrammarItemsWalker.g3:135:4: tokensSpec
+				{
+				PushFollow(Follow._tokensSpec_in_grammarSpec231);
+				tokensSpec();
+
+				state._fsp--;
+				if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+			// Grammars\\DefineGrammarItemsWalker.g3:136:3: ( attrScope )*
+			for ( ; ; )
+			{
+				int alt7=2;
+				int LA7_0 = input.LA(1);
+
+				if ( (LA7_0==SCOPE) )
+				{
+					alt7=1;
+				}
+
+
+				switch ( alt7 )
+				{
+				case 1:
+					// Grammars\\DefineGrammarItemsWalker.g3:136:4: attrScope
+					{
+					PushFollow(Follow._attrScope_in_grammarSpec238);
+					attrScope();
+
+					state._fsp--;
+					if (state.failed) return ;
+
+					}
+					break;
+
+				default:
+					goto loop7;
+				}
+			}
+
+			loop7:
+				;
+
+
+			// Grammars\\DefineGrammarItemsWalker.g3:137:3: ( actions )?
+			int alt8=2;
+			int LA8_0 = input.LA(1);
+
+			if ( (LA8_0==AMPERSAND) )
+			{
+				alt8=1;
+			}
+			switch ( alt8 )
+			{
+			case 1:
+				// Grammars\\DefineGrammarItemsWalker.g3:137:4: actions
+				{
+				PushFollow(Follow._actions_in_grammarSpec245);
+				actions();
+
+				state._fsp--;
+				if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+			PushFollow(Follow._rules_in_grammarSpec251);
+			rules();
+
+			state._fsp--;
+			if (state.failed) return ;
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "grammarSpec"
+
+
+	// $ANTLR start "actions"
+	// Grammars\\DefineGrammarItemsWalker.g3:141:0: actions : ( action )+ ;
+	private void actions(  )
+	{
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:142:4: ( ( action )+ )
+			// Grammars\\DefineGrammarItemsWalker.g3:142:4: ( action )+
+			{
+			// Grammars\\DefineGrammarItemsWalker.g3:142:4: ( action )+
+			int cnt9=0;
+			for ( ; ; )
+			{
+				int alt9=2;
+				int LA9_0 = input.LA(1);
+
+				if ( (LA9_0==AMPERSAND) )
+				{
+					alt9=1;
+				}
+
+
+				switch ( alt9 )
+				{
+				case 1:
+					// Grammars\\DefineGrammarItemsWalker.g3:142:6: action
+					{
+					PushFollow(Follow._action_in_actions264);
+					action();
+
+					state._fsp--;
+					if (state.failed) return ;
+
+					}
+					break;
+
+				default:
+					if ( cnt9 >= 1 )
+						goto loop9;
+
+					if (state.backtracking>0) {state.failed=true; return ;}
+					EarlyExitException eee9 = new EarlyExitException( 9, input );
+					throw eee9;
+				}
+				cnt9++;
+			}
+			loop9:
+				;
+
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "actions"
+
+
+	// $ANTLR start "action"
+	// Grammars\\DefineGrammarItemsWalker.g3:145:0: action : ^(amp= AMPERSAND id1= ID (id2= ID a1= ACTION |a2= ACTION ) ) ;
+	private void action(  )
+	{
+		GrammarAST amp=null;
+		GrammarAST id1=null;
+		GrammarAST id2=null;
+		GrammarAST a1=null;
+		GrammarAST a2=null;
+
+
+			string scope=null;
+			GrammarAST nameAST=null, actionAST=null;
+
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:151:4: ( ^(amp= AMPERSAND id1= ID (id2= ID a1= ACTION |a2= ACTION ) ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:151:4: ^(amp= AMPERSAND id1= ID (id2= ID a1= ACTION |a2= ACTION ) )
+			{
+			amp=(GrammarAST)Match(input,AMPERSAND,Follow._AMPERSAND_in_action286); if (state.failed) return ;
+
+			Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+			id1=(GrammarAST)Match(input,ID,Follow._ID_in_action290); if (state.failed) return ;
+			// Grammars\\DefineGrammarItemsWalker.g3:152:4: (id2= ID a1= ACTION |a2= ACTION )
+			int alt10=2;
+			int LA10_0 = input.LA(1);
+
+			if ( (LA10_0==ID) )
+			{
+				alt10=1;
+			}
+			else if ( (LA10_0==ACTION) )
+			{
+				alt10=2;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				NoViableAltException nvae = new NoViableAltException("", 10, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt10 )
+			{
+			case 1:
+				// Grammars\\DefineGrammarItemsWalker.g3:152:6: id2= ID a1= ACTION
+				{
+				id2=(GrammarAST)Match(input,ID,Follow._ID_in_action299); if (state.failed) return ;
+				a1=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_action303); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+					scope=(id1!=null?id1.Text:null); nameAST=id2; actionAST=a1;
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\DefineGrammarItemsWalker.g3:154:6: a2= ACTION
+				{
+				a2=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_action319); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+					scope=null; nameAST=id1; actionAST=a2;
+				}
+
+				}
+				break;
+
+			}
+
+
+			Match(input, TokenConstants.UP, null); if (state.failed) return ;
+			if ( state.backtracking == 0 )
+			{
+
+						 grammar.defineNamedAction(amp,scope,nameAST,actionAST);
+
+			}
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "action"
+
+
+	// $ANTLR start "optionsSpec"
+	// Grammars\\DefineGrammarItemsWalker.g3:163:0: optionsSpec : ^( OPTIONS ( . )* ) ;
+	private void optionsSpec(  )
+	{
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:164:4: ( ^( OPTIONS ( . )* ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:164:4: ^( OPTIONS ( . )* )
+			{
+			Match(input,OPTIONS,Follow._OPTIONS_in_optionsSpec353); if (state.failed) return ;
+
+			if ( input.LA(1)==TokenConstants.DOWN )
+			{
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+				// Grammars\\DefineGrammarItemsWalker.g3:164:14: ( . )*
+				for ( ; ; )
+				{
+					int alt11=2;
+					int LA11_0 = input.LA(1);
+
+					if ( ((LA11_0>=ACTION && LA11_0<=XDIGIT)) )
+					{
+						alt11=1;
+					}
+					else if ( (LA11_0==UP) )
+					{
+						alt11=2;
+					}
+
+
+					switch ( alt11 )
+					{
+					case 1:
+						// Grammars\\DefineGrammarItemsWalker.g3:164:0: .
+						{
+						MatchAny(input); if (state.failed) return ;
+
+						}
+						break;
+
+					default:
+						goto loop11;
+					}
+				}
+
+				loop11:
+					;
+
+
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return ;
+			}
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "optionsSpec"
+
+
+	// $ANTLR start "delegateGrammars"
+	// Grammars\\DefineGrammarItemsWalker.g3:167:0: delegateGrammars : ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ ) ;
+	private void delegateGrammars(  )
+	{
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:168:4: ( ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:168:4: ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ )
+			{
+			Match(input,IMPORT,Follow._IMPORT_in_delegateGrammars370); if (state.failed) return ;
+
+			Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+			// Grammars\\DefineGrammarItemsWalker.g3:168:16: ( ^( ASSIGN ID ID ) | ID )+
+			int cnt12=0;
+			for ( ; ; )
+			{
+				int alt12=3;
+				int LA12_0 = input.LA(1);
+
+				if ( (LA12_0==ASSIGN) )
+				{
+					alt12=1;
+				}
+				else if ( (LA12_0==ID) )
+				{
+					alt12=2;
+				}
+
+
+				switch ( alt12 )
+				{
+				case 1:
+					// Grammars\\DefineGrammarItemsWalker.g3:168:18: ^( ASSIGN ID ID )
+					{
+					Match(input,ASSIGN,Follow._ASSIGN_in_delegateGrammars375); if (state.failed) return ;
+
+					Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+					Match(input,ID,Follow._ID_in_delegateGrammars377); if (state.failed) return ;
+					Match(input,ID,Follow._ID_in_delegateGrammars379); if (state.failed) return ;
+
+					Match(input, TokenConstants.UP, null); if (state.failed) return ;
+
+					}
+					break;
+				case 2:
+					// Grammars\\DefineGrammarItemsWalker.g3:168:36: ID
+					{
+					Match(input,ID,Follow._ID_in_delegateGrammars384); if (state.failed) return ;
+
+					}
+					break;
+
+				default:
+					if ( cnt12 >= 1 )
+						goto loop12;
+
+					if (state.backtracking>0) {state.failed=true; return ;}
+					EarlyExitException eee12 = new EarlyExitException( 12, input );
+					throw eee12;
+				}
+				cnt12++;
+			}
+			loop12:
+				;
+
+
+
+			Match(input, TokenConstants.UP, null); if (state.failed) return ;
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "delegateGrammars"
+
+
+	// $ANTLR start "tokensSpec"
+	// Grammars\\DefineGrammarItemsWalker.g3:171:0: tokensSpec : ^( TOKENS ( tokenSpec )+ ) ;
+	private void tokensSpec(  )
+	{
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:172:4: ( ^( TOKENS ( tokenSpec )+ ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:172:4: ^( TOKENS ( tokenSpec )+ )
+			{
+			Match(input,TOKENS,Follow._TOKENS_in_tokensSpec402); if (state.failed) return ;
+
+			Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+			// Grammars\\DefineGrammarItemsWalker.g3:172:14: ( tokenSpec )+
+			int cnt13=0;
+			for ( ; ; )
+			{
+				int alt13=2;
+				int LA13_0 = input.LA(1);
+
+				if ( (LA13_0==ASSIGN||LA13_0==TOKEN_REF) )
+				{
+					alt13=1;
+				}
+
+
+				switch ( alt13 )
+				{
+				case 1:
+					// Grammars\\DefineGrammarItemsWalker.g3:172:16: tokenSpec
+					{
+					PushFollow(Follow._tokenSpec_in_tokensSpec406);
+					tokenSpec();
+
+					state._fsp--;
+					if (state.failed) return ;
+
+					}
+					break;
+
+				default:
+					if ( cnt13 >= 1 )
+						goto loop13;
+
+					if (state.backtracking>0) {state.failed=true; return ;}
+					EarlyExitException eee13 = new EarlyExitException( 13, input );
+					throw eee13;
+				}
+				cnt13++;
+			}
+			loop13:
+				;
+
+
+
+			Match(input, TokenConstants.UP, null); if (state.failed) return ;
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "tokensSpec"
+
+
+	// $ANTLR start "tokenSpec"
+	// Grammars\\DefineGrammarItemsWalker.g3:175:0: tokenSpec : (t= TOKEN_REF | ^( ASSIGN TOKEN_REF ( STRING_LITERAL | CHAR_LITERAL ) ) );
+	private void tokenSpec(  )
+	{
+		GrammarAST t=null;
+
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:176:4: (t= TOKEN_REF | ^( ASSIGN TOKEN_REF ( STRING_LITERAL | CHAR_LITERAL ) ) )
+			int alt14=2;
+			int LA14_0 = input.LA(1);
+
+			if ( (LA14_0==TOKEN_REF) )
+			{
+				alt14=1;
+			}
+			else if ( (LA14_0==ASSIGN) )
+			{
+				alt14=2;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				NoViableAltException nvae = new NoViableAltException("", 14, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt14 )
+			{
+			case 1:
+				// Grammars\\DefineGrammarItemsWalker.g3:176:4: t= TOKEN_REF
+				{
+				t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_tokenSpec424); if (state.failed) return ;
+
+				}
+				break;
+			case 2:
+				// Grammars\\DefineGrammarItemsWalker.g3:177:4: ^( ASSIGN TOKEN_REF ( STRING_LITERAL | CHAR_LITERAL ) )
+				{
+				Match(input,ASSIGN,Follow._ASSIGN_in_tokenSpec431); if (state.failed) return ;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+				Match(input,TOKEN_REF,Follow._TOKEN_REF_in_tokenSpec436); if (state.failed) return ;
+				if ( input.LA(1)==CHAR_LITERAL||input.LA(1)==STRING_LITERAL )
+				{
+					input.Consume();
+					state.errorRecovery=false;state.failed=false;
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return ;}
+					MismatchedSetException mse = new MismatchedSetException(null,input);
+					throw mse;
+				}
+
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "tokenSpec"
+
+
+	// $ANTLR start "rules"
+	// Grammars\\DefineGrammarItemsWalker.g3:185:0: rules : ( rule )+ ;
+	private void rules(  )
+	{
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:186:4: ( ( rule )+ )
+			// Grammars\\DefineGrammarItemsWalker.g3:186:4: ( rule )+
+			{
+			// Grammars\\DefineGrammarItemsWalker.g3:186:4: ( rule )+
+			int cnt15=0;
+			for ( ; ; )
+			{
+				int alt15=2;
+				int LA15_0 = input.LA(1);
+
+				if ( (LA15_0==RULE) )
+				{
+					alt15=1;
+				}
+
+
+				switch ( alt15 )
+				{
+				case 1:
+					// Grammars\\DefineGrammarItemsWalker.g3:186:0: rule
+					{
+					PushFollow(Follow._rule_in_rules471);
+					rule();
+
+					state._fsp--;
+					if (state.failed) return ;
+
+					}
+					break;
+
+				default:
+					if ( cnt15 >= 1 )
+						goto loop15;
+
+					if (state.backtracking>0) {state.failed=true; return ;}
+					EarlyExitException eee15 = new EarlyExitException( 15, input );
+					throw eee15;
+				}
+				cnt15++;
+			}
+			loop15:
+				;
+
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "rules"
+
+	public class rule_return : TreeRuleReturnScope
+	{
+	}
+
+	// $ANTLR start "rule"
+	// Grammars\\DefineGrammarItemsWalker.g3:189:0: rule : ^( RULE id= ID ( modifier )? ^( ARG (args= ARG_ACTION )? ) ^( RET (ret= ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec[r] )? ( ruleAction[r] )* b= block ( exceptionGroup )? EOR ) ;
+	private DefineGrammarItemsWalker.rule_return rule(  )
+	{
+		DefineGrammarItemsWalker.rule_return retval = new DefineGrammarItemsWalker.rule_return();
+		retval.start = input.LT(1);
+
+		GrammarAST id=null;
+		GrammarAST args=null;
+		GrammarAST ret=null;
+		GrammarAST RULE3=null;
+		DefineGrammarItemsWalker.block_return b = default(DefineGrammarItemsWalker.block_return);
+		DefineGrammarItemsWalker.modifier_return modifier4 = default(DefineGrammarItemsWalker.modifier_return);
+		HashSet<string> throwsSpec5 = default(HashSet<string>);
+
+
+			string name=null;
+			IDictionary<string,object> opts=null;
+			Rule r = null;
+
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:196:5: ( ^( RULE id= ID ( modifier )? ^( ARG (args= ARG_ACTION )? ) ^( RET (ret= ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec[r] )? ( ruleAction[r] )* b= block ( exceptionGroup )? EOR ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:196:5: ^( RULE id= ID ( modifier )? ^( ARG (args= ARG_ACTION )? ) ^( RET (ret= ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec[r] )? ( ruleAction[r] )* b= block ( exceptionGroup )? EOR )
+			{
+			RULE3=(GrammarAST)Match(input,RULE,Follow._RULE_in_rule491); if (state.failed) return retval;
+
+			Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+			id=(GrammarAST)Match(input,ID,Follow._ID_in_rule495); if (state.failed) return retval;
+			if ( state.backtracking == 0 )
+			{
+				opts = RULE3.BlockOptions;
+			}
+			// Grammars\\DefineGrammarItemsWalker.g3:197:4: ( modifier )?
+			int alt16=2;
+			int LA16_0 = input.LA(1);
+
+			if ( (LA16_0==FRAGMENT||(LA16_0>=PRIVATE && LA16_0<=PUBLIC)) )
+			{
+				alt16=1;
+			}
+			switch ( alt16 )
+			{
+			case 1:
+				// Grammars\\DefineGrammarItemsWalker.g3:197:5: modifier
+				{
+				PushFollow(Follow._modifier_in_rule503);
+				modifier4=modifier();
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				}
+				break;
+
+			}
+
+			Match(input,ARG,Follow._ARG_in_rule512); if (state.failed) return retval;
+
+			if ( input.LA(1)==TokenConstants.DOWN )
+			{
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				// Grammars\\DefineGrammarItemsWalker.g3:198:11: (args= ARG_ACTION )?
+				int alt17=2;
+				int LA17_0 = input.LA(1);
+
+				if ( (LA17_0==ARG_ACTION) )
+				{
+					alt17=1;
+				}
+				switch ( alt17 )
+				{
+				case 1:
+					// Grammars\\DefineGrammarItemsWalker.g3:198:12: args= ARG_ACTION
+					{
+					args=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule517); if (state.failed) return retval;
+
+					}
+					break;
+
+				}
+
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+			}
+			Match(input,RET,Follow._RET_in_rule528); if (state.failed) return retval;
+
+			if ( input.LA(1)==TokenConstants.DOWN )
+			{
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				// Grammars\\DefineGrammarItemsWalker.g3:199:11: (ret= ARG_ACTION )?
+				int alt18=2;
+				int LA18_0 = input.LA(1);
+
+				if ( (LA18_0==ARG_ACTION) )
+				{
+					alt18=1;
+				}
+				switch ( alt18 )
+				{
+				case 1:
+					// Grammars\\DefineGrammarItemsWalker.g3:199:12: ret= ARG_ACTION
+					{
+					ret=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule533); if (state.failed) return retval;
+
+					}
+					break;
+
+				}
+
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+			}
+			// Grammars\\DefineGrammarItemsWalker.g3:200:4: ( throwsSpec )?
+			int alt19=2;
+			int LA19_0 = input.LA(1);
+
+			if ( (LA19_0==THROWS) )
+			{
+				alt19=1;
+			}
+			switch ( alt19 )
+			{
+			case 1:
+				// Grammars\\DefineGrammarItemsWalker.g3:200:5: throwsSpec
+				{
+				PushFollow(Follow._throwsSpec_in_rule543);
+				throwsSpec5=throwsSpec();
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				}
+				break;
+
+			}
+
+			// Grammars\\DefineGrammarItemsWalker.g3:201:4: ( optionsSpec )?
+			int alt20=2;
+			int LA20_0 = input.LA(1);
+
+			if ( (LA20_0==OPTIONS) )
+			{
+				alt20=1;
+			}
+			switch ( alt20 )
+			{
+			case 1:
+				// Grammars\\DefineGrammarItemsWalker.g3:201:5: optionsSpec
+				{
+				PushFollow(Follow._optionsSpec_in_rule551);
+				optionsSpec();
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				}
+				break;
+
+			}
+
+			if ( state.backtracking == 0 )
+			{
+
+								name = (id!=null?id.Text:null);
+								currentRuleName = name;
+								if ( Character.isUpperCase(name[0]) && grammar.type==Grammar.COMBINED )
+								{
+									// a merged grammar spec, track lexer rules and send to another grammar
+									grammar.defineLexerRuleFoundInParser(id.token, ((GrammarAST)retval.start));
+								}
+								else
+								{
+									int numAlts = countAltsForRule(((GrammarAST)retval.start));
+									grammar.defineRule(id.Token, (modifier4!=null?modifier4.mod:default(string)), opts, ((GrammarAST)retval.start), args, numAlts);
+									r = grammar.getRule(name);
+									if ( args!=null )
+									{
+										r.parameterScope = grammar.createParameterScope(name,args.Token);
+										r.parameterScope.addAttributes((args!=null?args.Text:null), ',');
+									}
+									if ( ret!=null )
+									{
+										r.returnScope = grammar.createReturnScope(name,ret.token);
+										r.returnScope.addAttributes((ret!=null?ret.Text:null), ',');
+									}
+									if ( throwsSpec5 != null )
+									{
+										foreach ( string exception in throwsSpec5 )
+											r.throwsSpec.Add( exception );
+									}
+								}
+
+			}
+			// Grammars\\DefineGrammarItemsWalker.g3:232:4: ( ruleScopeSpec[r] )?
+			int alt21=2;
+			int LA21_0 = input.LA(1);
+
+			if ( (LA21_0==SCOPE) )
+			{
+				alt21=1;
+			}
+			switch ( alt21 )
+			{
+			case 1:
+				// Grammars\\DefineGrammarItemsWalker.g3:232:5: ruleScopeSpec[r]
+				{
+				PushFollow(Follow._ruleScopeSpec_in_rule564);
+				ruleScopeSpec(r);
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				}
+				break;
+
+			}
+
+			// Grammars\\DefineGrammarItemsWalker.g3:233:4: ( ruleAction[r] )*
+			for ( ; ; )
+			{
+				int alt22=2;
+				int LA22_0 = input.LA(1);
+
+				if ( (LA22_0==AMPERSAND) )
+				{
+					alt22=1;
+				}
+
+
+				switch ( alt22 )
+				{
+				case 1:
+					// Grammars\\DefineGrammarItemsWalker.g3:233:5: ruleAction[r]
+					{
+					PushFollow(Follow._ruleAction_in_rule573);
+					ruleAction(r);
+
+					state._fsp--;
+					if (state.failed) return retval;
+
+					}
+					break;
+
+				default:
+					goto loop22;
+				}
+			}
+
+			loop22:
+				;
+
+
+			if ( state.backtracking == 0 )
+			{
+				 this.blockLevel=0;
+			}
+			PushFollow(Follow._block_in_rule588);
+			b=block();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			// Grammars\\DefineGrammarItemsWalker.g3:236:4: ( exceptionGroup )?
+			int alt23=2;
+			int LA23_0 = input.LA(1);
+
+			if ( (LA23_0==CATCH||LA23_0==FINALLY) )
+			{
+				alt23=1;
+			}
+			switch ( alt23 )
+			{
+			case 1:
+				// Grammars\\DefineGrammarItemsWalker.g3:236:5: exceptionGroup
+				{
+				PushFollow(Follow._exceptionGroup_in_rule594);
+				exceptionGroup();
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				}
+				break;
+
+			}
+
+			Match(input,EOR,Follow._EOR_in_rule601); if (state.failed) return retval;
+			if ( state.backtracking == 0 )
+			{
+
+								// copy rule options into the block AST, which is where
+								// the analysis will look for k option etc...
+								(b!=null?((GrammarAST)b.start):null).setBlockOptions( opts );
+
+			}
+
+			Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "rule"
+
+
+	// $ANTLR start "ruleAction"
+	// Grammars\\DefineGrammarItemsWalker.g3:246:0: ruleAction[Rule r] : ^(amp= AMPERSAND id= ID a= ACTION ) ;
+	private void ruleAction( Rule r )
+	{
+		GrammarAST amp=null;
+		GrammarAST id=null;
+		GrammarAST a=null;
+
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:247:4: ( ^(amp= AMPERSAND id= ID a= ACTION ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:247:4: ^(amp= AMPERSAND id= ID a= ACTION )
+			{
+			amp=(GrammarAST)Match(input,AMPERSAND,Follow._AMPERSAND_in_ruleAction625); if (state.failed) return ;
+
+			Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+			id=(GrammarAST)Match(input,ID,Follow._ID_in_ruleAction629); if (state.failed) return ;
+			a=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_ruleAction633); if (state.failed) return ;
+
+			Match(input, TokenConstants.UP, null); if (state.failed) return ;
+			if ( state.backtracking == 0 )
+			{
+				if (r!=null) r.defineNamedAction(amp,id,a);
+			}
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "ruleAction"
+
+	public class modifier_return : TreeRuleReturnScope
+	{
+		public string mod;
+	}
+
+	// $ANTLR start "modifier"
+	// Grammars\\DefineGrammarItemsWalker.g3:250:0: modifier returns [string mod] : ( 'protected' | 'public' | 'private' | 'fragment' );
+	private DefineGrammarItemsWalker.modifier_return modifier(  )
+	{
+		DefineGrammarItemsWalker.modifier_return retval = new DefineGrammarItemsWalker.modifier_return();
+		retval.start = input.LT(1);
+
+
+			retval.mod = ((GrammarAST)retval.start).Token.Text;
+
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:255:4: ( 'protected' | 'public' | 'private' | 'fragment' )
+			// Grammars\\DefineGrammarItemsWalker.g3:
+			{
+			if ( input.LA(1)==FRAGMENT||(input.LA(1)>=PRIVATE && input.LA(1)<=PUBLIC) )
+			{
+				input.Consume();
+				state.errorRecovery=false;state.failed=false;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				throw mse;
+			}
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "modifier"
+
+
+	// $ANTLR start "throwsSpec"
+	// Grammars\\DefineGrammarItemsWalker.g3:261:0: throwsSpec returns [HashSet<string> exceptions] : ^( 'throws' ( ID )+ ) ;
+	private HashSet<string> throwsSpec(  )
+	{
+
+		HashSet<string> exceptions = default(HashSet<string>);
+
+		GrammarAST ID6=null;
+
+
+			exceptions = new HashSet<string>();
+
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:266:4: ( ^( 'throws' ( ID )+ ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:266:4: ^( 'throws' ( ID )+ )
+			{
+			Match(input,THROWS,Follow._THROWS_in_throwsSpec693); if (state.failed) return exceptions;
+
+			Match(input, TokenConstants.DOWN, null); if (state.failed) return exceptions;
+			// Grammars\\DefineGrammarItemsWalker.g3:266:15: ( ID )+
+			int cnt24=0;
+			for ( ; ; )
+			{
+				int alt24=2;
+				int LA24_0 = input.LA(1);
+
+				if ( (LA24_0==ID) )
+				{
+					alt24=1;
+				}
+
+
+				switch ( alt24 )
+				{
+				case 1:
+					// Grammars\\DefineGrammarItemsWalker.g3:266:16: ID
+					{
+					ID6=(GrammarAST)Match(input,ID,Follow._ID_in_throwsSpec696); if (state.failed) return exceptions;
+					if ( state.backtracking == 0 )
+					{
+						exceptions.Add((ID6!=null?ID6.Text:null));
+					}
+
+					}
+					break;
+
+				default:
+					if ( cnt24 >= 1 )
+						goto loop24;
+
+					if (state.backtracking>0) {state.failed=true; return exceptions;}
+					EarlyExitException eee24 = new EarlyExitException( 24, input );
+					throw eee24;
+				}
+				cnt24++;
+			}
+			loop24:
+				;
+
+
+
+			Match(input, TokenConstants.UP, null); if (state.failed) return exceptions;
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return exceptions;
+	}
+	// $ANTLR end "throwsSpec"
+
+
+	// $ANTLR start "ruleScopeSpec"
+	// Grammars\\DefineGrammarItemsWalker.g3:269:0: ruleScopeSpec[Rule r] : ^( 'scope' ( ( attrScopeAction )* attrs= ACTION )? (uses= ID )* ) ;
+	private void ruleScopeSpec( Rule r )
+	{
+		AttributeScopeActions_scope.PushScope(this);
+
+		GrammarAST attrs=null;
+		GrammarAST uses=null;
+
+
+			((AttributeScopeActions_scope)AttributeScopeActions_stack.Peek()).actions = new Dictionary<GrammarAST, GrammarAST>();
+
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:275:4: ( ^( 'scope' ( ( attrScopeAction )* attrs= ACTION )? (uses= ID )* ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:275:4: ^( 'scope' ( ( attrScopeAction )* attrs= ACTION )? (uses= ID )* )
+			{
+			Match(input,SCOPE,Follow._SCOPE_in_ruleScopeSpec726); if (state.failed) return ;
+
+			if ( input.LA(1)==TokenConstants.DOWN )
+			{
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+				// Grammars\\DefineGrammarItemsWalker.g3:276:4: ( ( attrScopeAction )* attrs= ACTION )?
+				int alt26=2;
+				int LA26_0 = input.LA(1);
+
+				if ( (LA26_0==ACTION||LA26_0==AMPERSAND) )
+				{
+					alt26=1;
+				}
+				switch ( alt26 )
+				{
+				case 1:
+					// Grammars\\DefineGrammarItemsWalker.g3:276:6: ( attrScopeAction )* attrs= ACTION
+					{
+					// Grammars\\DefineGrammarItemsWalker.g3:276:6: ( attrScopeAction )*
+					for ( ; ; )
+					{
+						int alt25=2;
+						int LA25_0 = input.LA(1);
+
+						if ( (LA25_0==AMPERSAND) )
+						{
+							alt25=1;
+						}
+
+
+						switch ( alt25 )
+						{
+						case 1:
+							// Grammars\\DefineGrammarItemsWalker.g3:276:0: attrScopeAction
+							{
+							PushFollow(Follow._attrScopeAction_in_ruleScopeSpec733);
+							attrScopeAction();
+
+							state._fsp--;
+							if (state.failed) return ;
+
+							}
+							break;
+
+						default:
+							goto loop25;
+						}
+					}
+
+					loop25:
+						;
+
+
+					attrs=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_ruleScopeSpec738); if (state.failed) return ;
+					if ( state.backtracking == 0 )
+					{
+
+											r.ruleScope = grammar.createRuleScope(r.name,attrs.token);
+											r.ruleScope.isDynamicRuleScope = true;
+											r.ruleScope.addAttributes((attrs!=null?attrs.Text:null), ';');
+											foreach ( var action in ((AttributeScopeActions_scope)AttributeScopeActions_stack.Peek()).actions )
+												r.ruleScope.DefineNamedAction( action.Key, action.Value );
+
+					}
+
+					}
+					break;
+
+				}
+
+				// Grammars\\DefineGrammarItemsWalker.g3:285:4: (uses= ID )*
+				for ( ; ; )
+				{
+					int alt27=2;
+					int LA27_0 = input.LA(1);
+
+					if ( (LA27_0==ID) )
+					{
+						alt27=1;
+					}
+
+
+					switch ( alt27 )
+					{
+					case 1:
+						// Grammars\\DefineGrammarItemsWalker.g3:285:6: uses= ID
+						{
+						uses=(GrammarAST)Match(input,ID,Follow._ID_in_ruleScopeSpec759); if (state.failed) return ;
+						if ( state.backtracking == 0 )
+						{
+
+												if ( grammar.getGlobalScope((uses!=null?uses.Text:null))==null ) {
+												ErrorManager.grammarError(ErrorManager.MSG_UNKNOWN_DYNAMIC_SCOPE,
+												grammar,
+												uses.token,
+												(uses!=null?uses.Text:null));
+												}
+												else {
+												if ( r.useScopes==null ) {r.useScopes=new List<string>();}
+												r.useScopes.Add((uses!=null?uses.Text:null));
+												}
+
+						}
+
+						}
+						break;
+
+					default:
+						goto loop27;
+					}
+				}
+
+				loop27:
+					;
+
+
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return ;
+			}
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+			AttributeScopeActions_scope.PopScope(this);
+
+		}
+		return ;
+	}
+	// $ANTLR end "ruleScopeSpec"
+
+	public class block_return : TreeRuleReturnScope
+	{
+	}
+
+	// $ANTLR start "block"
+	// Grammars\\DefineGrammarItemsWalker.g3:302:0: block : ^( BLOCK ( optionsSpec )? ( blockAction )* ( alternative rewrite )+ EOB ) ;
+	private DefineGrammarItemsWalker.block_return block(  )
+	{
+		DefineGrammarItemsWalker.block_return retval = new DefineGrammarItemsWalker.block_return();
+		retval.start = input.LT(1);
+
+
+			// must run during backtracking
+			this.blockLevel++;
+			if ( blockLevel == 1 )
+				this.outerAltNum=1;
+
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:310:4: ( ^( BLOCK ( optionsSpec )? ( blockAction )* ( alternative rewrite )+ EOB ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:310:4: ^( BLOCK ( optionsSpec )? ( blockAction )* ( alternative rewrite )+ EOB )
+			{
+			Match(input,BLOCK,Follow._BLOCK_in_block793); if (state.failed) return retval;
+
+			Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+			// Grammars\\DefineGrammarItemsWalker.g3:311:4: ( optionsSpec )?
+			int alt28=2;
+			int LA28_0 = input.LA(1);
+
+			if ( (LA28_0==OPTIONS) )
+			{
+				alt28=1;
+			}
+			switch ( alt28 )
+			{
+			case 1:
+				// Grammars\\DefineGrammarItemsWalker.g3:311:5: optionsSpec
+				{
+				PushFollow(Follow._optionsSpec_in_block799);
+				optionsSpec();
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				}
+				break;
+
+			}
+
+			// Grammars\\DefineGrammarItemsWalker.g3:312:4: ( blockAction )*
+			for ( ; ; )
+			{
+				int alt29=2;
+				int LA29_0 = input.LA(1);
+
+				if ( (LA29_0==AMPERSAND) )
+				{
+					alt29=1;
+				}
+
+
+				switch ( alt29 )
+				{
+				case 1:
+					// Grammars\\DefineGrammarItemsWalker.g3:312:5: blockAction
+					{
+					PushFollow(Follow._blockAction_in_block807);
+					blockAction();
+
+					state._fsp--;
+					if (state.failed) return retval;
+
+					}
+					break;
+
+				default:
+					goto loop29;
+				}
+			}
+
+			loop29:
+				;
+
+
+			// Grammars\\DefineGrammarItemsWalker.g3:313:4: ( alternative rewrite )+
+			int cnt30=0;
+			for ( ; ; )
+			{
+				int alt30=2;
+				int LA30_0 = input.LA(1);
+
+				if ( (LA30_0==ALT) )
+				{
+					alt30=1;
+				}
+
+
+				switch ( alt30 )
+				{
+				case 1:
+					// Grammars\\DefineGrammarItemsWalker.g3:313:6: alternative rewrite
+					{
+					PushFollow(Follow._alternative_in_block816);
+					alternative();
+
+					state._fsp--;
+					if (state.failed) return retval;
+					PushFollow(Follow._rewrite_in_block818);
+					rewrite();
+
+					state._fsp--;
+					if (state.failed) return retval;
+
+										if ( this.blockLevel == 1 )
+											this.outerAltNum++;
+
+
+					}
+					break;
+
+				default:
+					if ( cnt30 >= 1 )
+						goto loop30;
+
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					EarlyExitException eee30 = new EarlyExitException( 30, input );
+					throw eee30;
+				}
+				cnt30++;
+			}
+			loop30:
+				;
+
+
+			Match(input,EOB,Follow._EOB_in_block835); if (state.failed) return retval;
+
+			Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+			 blockLevel--;
+		}
+		return retval;
+	}
+	// $ANTLR end "block"
+
+
+	// $ANTLR start "blockAction"
+	// Grammars\\DefineGrammarItemsWalker.g3:325:0: blockAction : ^(amp= AMPERSAND id= ID a= ACTION ) ;
+	private void blockAction(  )
+	{
+		GrammarAST amp=null;
+		GrammarAST id=null;
+		GrammarAST a=null;
+
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:326:4: ( ^(amp= AMPERSAND id= ID a= ACTION ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:326:4: ^(amp= AMPERSAND id= ID a= ACTION )
+			{
+			amp=(GrammarAST)Match(input,AMPERSAND,Follow._AMPERSAND_in_blockAction859); if (state.failed) return ;
+
+			Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+			id=(GrammarAST)Match(input,ID,Follow._ID_in_blockAction863); if (state.failed) return ;
+			a=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_blockAction867); if (state.failed) return ;
+
+			Match(input, TokenConstants.UP, null); if (state.failed) return ;
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "blockAction"
+
+	public class alternative_return : TreeRuleReturnScope
+	{
+	}
+
+	// $ANTLR start "alternative"
+	// Grammars\\DefineGrammarItemsWalker.g3:329:0: alternative : ^( ALT ( element )+ EOA ) ;
+	private DefineGrammarItemsWalker.alternative_return alternative(  )
+	{
+		DefineGrammarItemsWalker.alternative_return retval = new DefineGrammarItemsWalker.alternative_return();
+		retval.start = input.LT(1);
+
+
+			if ( state.backtracking == 0 )
+			{
+				if ( grammar.type!=Grammar.LEXER && grammar.getOption("output")!=null && blockLevel==1 )
+				{
+					GrammarAST aRewriteNode = ((GrammarAST)retval.start).findFirstType(REWRITE); // alt itself has rewrite?
+					GrammarAST rewriteAST = (GrammarAST)((GrammarAST)retval.start).Parent.GetChild(((GrammarAST)retval.start).ChildIndex + 1);
+					// we have a rewrite if alt uses it inside subrule or this alt has one
+					// but don't count -> ... rewrites, which mean "do default auto construction"
+					if ( aRewriteNode!=null||
+						 (rewriteAST!=null &&
+						  rewriteAST.Type==REWRITE &&
+						  rewriteAST.GetChild(0)!=null &&
+						  rewriteAST.GetChild(0).Type!=ETC) )
+					{
+						Rule r = grammar.getRule(currentRuleName);
+						r.trackAltsWithRewrites(((GrammarAST)retval.start),this.outerAltNum);
+					}
+				}
+			}
+
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:352:4: ( ^( ALT ( element )+ EOA ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:352:4: ^( ALT ( element )+ EOA )
+			{
+			Match(input,ALT,Follow._ALT_in_alternative888); if (state.failed) return retval;
+
+			Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+			// Grammars\\DefineGrammarItemsWalker.g3:352:11: ( element )+
+			int cnt31=0;
+			for ( ; ; )
+			{
+				int alt31=2;
+				int LA31_0 = input.LA(1);
+
+				if ( (LA31_0==ACTION||(LA31_0>=ASSIGN && LA31_0<=BLOCK)||(LA31_0>=CHAR_LITERAL && LA31_0<=CHAR_RANGE)||LA31_0==CLOSURE||LA31_0==DOT||LA31_0==EPSILON||LA31_0==FORCED_ACTION||LA31_0==GATED_SEMPRED||LA31_0==NOT||LA31_0==OPTIONAL||(LA31_0>=PLUS_ASSIGN && LA31_0<=POSITIVE_CLOSURE)||LA31_0==RANGE||LA31_0==ROOT||LA31_0==RULE_REF||LA31_0==SEMPRED||(LA31_0>=STRING_LITERAL && LA31_0<=SYNPRED)||LA31_0==TOKEN_REF||LA31_0==TREE_BEGIN||LA31_0==WILDCARD) )
+				{
+					alt31=1;
+				}
+
+
+				switch ( alt31 )
+				{
+				case 1:
+					// Grammars\\DefineGrammarItemsWalker.g3:352:12: element
+					{
+					PushFollow(Follow._element_in_alternative891);
+					element();
+
+					state._fsp--;
+					if (state.failed) return retval;
+
+					}
+					break;
+
+				default:
+					if ( cnt31 >= 1 )
+						goto loop31;
+
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					EarlyExitException eee31 = new EarlyExitException( 31, input );
+					throw eee31;
+				}
+				cnt31++;
+			}
+			loop31:
+				;
+
+
+			Match(input,EOA,Follow._EOA_in_alternative895); if (state.failed) return retval;
+
+			Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "alternative"
+
+
+	// $ANTLR start "exceptionGroup"
+	// Grammars\\DefineGrammarItemsWalker.g3:355:0: exceptionGroup : ( ( exceptionHandler )+ ( finallyClause )? | finallyClause );
+	private void exceptionGroup(  )
+	{
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:356:4: ( ( exceptionHandler )+ ( finallyClause )? | finallyClause )
+			int alt34=2;
+			int LA34_0 = input.LA(1);
+
+			if ( (LA34_0==CATCH) )
+			{
+				alt34=1;
+			}
+			else if ( (LA34_0==FINALLY) )
+			{
+				alt34=2;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				NoViableAltException nvae = new NoViableAltException("", 34, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt34 )
+			{
+			case 1:
+				// Grammars\\DefineGrammarItemsWalker.g3:356:4: ( exceptionHandler )+ ( finallyClause )?
+				{
+				// Grammars\\DefineGrammarItemsWalker.g3:356:4: ( exceptionHandler )+
+				int cnt32=0;
+				for ( ; ; )
+				{
+					int alt32=2;
+					int LA32_0 = input.LA(1);
+
+					if ( (LA32_0==CATCH) )
+					{
+						alt32=1;
+					}
+
+
+					switch ( alt32 )
+					{
+					case 1:
+						// Grammars\\DefineGrammarItemsWalker.g3:356:6: exceptionHandler
+						{
+						PushFollow(Follow._exceptionHandler_in_exceptionGroup910);
+						exceptionHandler();
+
+						state._fsp--;
+						if (state.failed) return ;
+
+						}
+						break;
+
+					default:
+						if ( cnt32 >= 1 )
+							goto loop32;
+
+						if (state.backtracking>0) {state.failed=true; return ;}
+						EarlyExitException eee32 = new EarlyExitException( 32, input );
+						throw eee32;
+					}
+					cnt32++;
+				}
+				loop32:
+					;
+
+
+				// Grammars\\DefineGrammarItemsWalker.g3:356:26: ( finallyClause )?
+				int alt33=2;
+				int LA33_0 = input.LA(1);
+
+				if ( (LA33_0==FINALLY) )
+				{
+					alt33=1;
+				}
+				switch ( alt33 )
+				{
+				case 1:
+					// Grammars\\DefineGrammarItemsWalker.g3:356:27: finallyClause
+					{
+					PushFollow(Follow._finallyClause_in_exceptionGroup916);
+					finallyClause();
+
+					state._fsp--;
+					if (state.failed) return ;
+
+					}
+					break;
+
+				}
+
+
+				}
+				break;
+			case 2:
+				// Grammars\\DefineGrammarItemsWalker.g3:357:4: finallyClause
+				{
+				PushFollow(Follow._finallyClause_in_exceptionGroup923);
+				finallyClause();
+
+				state._fsp--;
+				if (state.failed) return ;
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "exceptionGroup"
+
+
+	// $ANTLR start "exceptionHandler"
+	// Grammars\\DefineGrammarItemsWalker.g3:360:0: exceptionHandler : ^( 'catch' ARG_ACTION ACTION ) ;
+	private void exceptionHandler(  )
+	{
+		GrammarAST ACTION7=null;
+
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:361:6: ( ^( 'catch' ARG_ACTION ACTION ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:361:6: ^( 'catch' ARG_ACTION ACTION )
+			{
+			Match(input,CATCH,Follow._CATCH_in_exceptionHandler937); if (state.failed) return ;
+
+			Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+			Match(input,ARG_ACTION,Follow._ARG_ACTION_in_exceptionHandler939); if (state.failed) return ;
+			ACTION7=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_exceptionHandler941); if (state.failed) return ;
+
+			Match(input, TokenConstants.UP, null); if (state.failed) return ;
+			if ( state.backtracking == 0 )
+			{
+				trackInlineAction(ACTION7);
+			}
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "exceptionHandler"
+
+
+	// $ANTLR start "finallyClause"
+	// Grammars\\DefineGrammarItemsWalker.g3:364:0: finallyClause : ^( 'finally' ACTION ) ;
+	private void finallyClause(  )
+	{
+		GrammarAST ACTION8=null;
+
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:365:7: ( ^( 'finally' ACTION ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:365:7: ^( 'finally' ACTION )
+			{
+			Match(input,FINALLY,Follow._FINALLY_in_finallyClause959); if (state.failed) return ;
+
+			Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+			ACTION8=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_finallyClause961); if (state.failed) return ;
+
+			Match(input, TokenConstants.UP, null); if (state.failed) return ;
+			if ( state.backtracking == 0 )
+			{
+				trackInlineAction(ACTION8);
+			}
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "finallyClause"
+
+	public class element_return : TreeRuleReturnScope
+	{
+	}
+
+	// $ANTLR start "element"
+	// Grammars\\DefineGrammarItemsWalker.g3:368:0: element : ( ^( ROOT element ) | ^( BANG element ) | atom[null] | ^( NOT element ) | ^( RANGE atom[null] atom[null] ) | ^( CHAR_RANGE atom[null] atom[null] ) | ^( ASSIGN id= ID el= element ) | ^( PLUS_ASSIGN id2= ID a2= element ) | ebnf | tree_ | ^( SYNPRED block ) |act= ACTION |act2= FORCED_ACTION | SEMPRED | SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) | GATED_SEMPRED | EPSILON );
+	private DefineGrammarItemsWalker.element_return element(  )
+	{
+		DefineGrammarItemsWalker.element_return retval = new DefineGrammarItemsWalker.element_return();
+		retval.start = input.LT(1);
+
+		GrammarAST id=null;
+		GrammarAST id2=null;
+		GrammarAST act=null;
+		GrammarAST act2=null;
+		GrammarAST SEMPRED9=null;
+		GrammarAST GATED_SEMPRED10=null;
+		DefineGrammarItemsWalker.element_return el = default(DefineGrammarItemsWalker.element_return);
+		DefineGrammarItemsWalker.element_return a2 = default(DefineGrammarItemsWalker.element_return);
+
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:369:6: ( ^( ROOT element ) | ^( BANG element ) | atom[null] | ^( NOT element ) | ^( RANGE atom[null] atom[null] ) | ^( CHAR_RANGE atom[null] atom[null] ) | ^( ASSIGN id= ID el= element ) | ^( PLUS_ASSIGN id2= ID a2= element ) | ebnf | tree_ | ^( SYNPRED block ) |act= ACTION |act2= FORCED_ACTION | SEMPRED | SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) | GATED_SEMPRED | EPSILON )
+			int alt36=18;
+			alt36 = dfa36.Predict(input);
+			switch ( alt36 )
+			{
+			case 1:
+				// Grammars\\DefineGrammarItemsWalker.g3:369:6: ^( ROOT element )
+				{
+				Match(input,ROOT,Follow._ROOT_in_element978); if (state.failed) return retval;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				PushFollow(Follow._element_in_element980);
+				element();
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+
+				}
+				break;
+			case 2:
+				// Grammars\\DefineGrammarItemsWalker.g3:370:6: ^( BANG element )
+				{
+				Match(input,BANG,Follow._BANG_in_element989); if (state.failed) return retval;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				PushFollow(Follow._element_in_element991);
+				element();
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+
+				}
+				break;
+			case 3:
+				// Grammars\\DefineGrammarItemsWalker.g3:371:6: atom[null]
+				{
+				PushFollow(Follow._atom_in_element999);
+				atom(null);
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				}
+				break;
+			case 4:
+				// Grammars\\DefineGrammarItemsWalker.g3:372:6: ^( NOT element )
+				{
+				Match(input,NOT,Follow._NOT_in_element1008); if (state.failed) return retval;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				PushFollow(Follow._element_in_element1010);
+				element();
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+
+				}
+				break;
+			case 5:
+				// Grammars\\DefineGrammarItemsWalker.g3:373:6: ^( RANGE atom[null] atom[null] )
+				{
+				Match(input,RANGE,Follow._RANGE_in_element1019); if (state.failed) return retval;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				PushFollow(Follow._atom_in_element1021);
+				atom(null);
+
+				state._fsp--;
+				if (state.failed) return retval;
+				PushFollow(Follow._atom_in_element1024);
+				atom(null);
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+
+				}
+				break;
+			case 6:
+				// Grammars\\DefineGrammarItemsWalker.g3:374:6: ^( CHAR_RANGE atom[null] atom[null] )
+				{
+				Match(input,CHAR_RANGE,Follow._CHAR_RANGE_in_element1034); if (state.failed) return retval;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				PushFollow(Follow._atom_in_element1036);
+				atom(null);
+
+				state._fsp--;
+				if (state.failed) return retval;
+				PushFollow(Follow._atom_in_element1039);
+				atom(null);
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+
+				}
+				break;
+			case 7:
+				// Grammars\\DefineGrammarItemsWalker.g3:375:4: ^( ASSIGN id= ID el= element )
+				{
+				Match(input,ASSIGN,Follow._ASSIGN_in_element1048); if (state.failed) return retval;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				id=(GrammarAST)Match(input,ID,Follow._ID_in_element1052); if (state.failed) return retval;
+				PushFollow(Follow._element_in_element1056);
+				el=element();
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+
+									GrammarAST e = (el!=null?((GrammarAST)el.start):null);
+									if ( e.Type==ANTLRParser.ROOT || e.Type==ANTLRParser.BANG )
+									{
+										e = (GrammarAST)e.GetChild(0);
+									}
+									if ( e.Type==RULE_REF)
+									{
+										grammar.defineRuleRefLabel(currentRuleName,id.token,e);
+									}
+									else if ( e.Type==WILDCARD && grammar.type==Grammar.TREE_PARSER )
+									{
+										grammar.defineWildcardTreeLabel(currentRuleName,id.token,e);
+									}
+									else
+									{
+										grammar.defineTokenRefLabel(currentRuleName,id.Token,e);
+									}
+
+				}
+
+				}
+				break;
+			case 8:
+				// Grammars\\DefineGrammarItemsWalker.g3:395:4: ^( PLUS_ASSIGN id2= ID a2= element )
+				{
+				Match(input,PLUS_ASSIGN,Follow._PLUS_ASSIGN_in_element1069); if (state.failed) return retval;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				id2=(GrammarAST)Match(input,ID,Follow._ID_in_element1073); if (state.failed) return retval;
+				PushFollow(Follow._element_in_element1077);
+				a2=element();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+
+									GrammarAST a = (a2!=null?((GrammarAST)a2.start):null);
+									if ( a.Type==ANTLRParser.ROOT || a.Type==ANTLRParser.BANG )
+									{
+										a = (GrammarAST)a.GetChild(0);
+									}
+									if ( a.Type==RULE_REF )
+									{
+										grammar.defineRuleListLabel(currentRuleName,id2.Token,a);
+									}
+									else if ( a.Type == WILDCARD && grammar.type == Grammar.TREE_PARSER )
+									{
+										grammar.defineWildcardTreeListLabel( currentRuleName, id2.token, a );
+									}
+									else
+									{
+										grammar.defineTokenListLabel(currentRuleName,id2.Token,a);
+									}
+
+				}
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+
+				}
+				break;
+			case 9:
+				// Grammars\\DefineGrammarItemsWalker.g3:416:6: ebnf
+				{
+				PushFollow(Follow._ebnf_in_element1094);
+				ebnf();
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				}
+				break;
+			case 10:
+				// Grammars\\DefineGrammarItemsWalker.g3:417:6: tree_
+				{
+				PushFollow(Follow._tree__in_element1101);
+				tree_();
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				}
+				break;
+			case 11:
+				// Grammars\\DefineGrammarItemsWalker.g3:418:6: ^( SYNPRED block )
+				{
+				Match(input,SYNPRED,Follow._SYNPRED_in_element1110); if (state.failed) return retval;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				PushFollow(Follow._block_in_element1112);
+				block();
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+
+				}
+				break;
+			case 12:
+				// Grammars\\DefineGrammarItemsWalker.g3:419:6: act= ACTION
+				{
+				act=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_element1123); if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+
+								act.outerAltNum = this.outerAltNum;
+								trackInlineAction(act);
+
+				}
+
+				}
+				break;
+			case 13:
+				// Grammars\\DefineGrammarItemsWalker.g3:424:6: act2= FORCED_ACTION
+				{
+				act2=(GrammarAST)Match(input,FORCED_ACTION,Follow._FORCED_ACTION_in_element1136); if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+
+								act2.outerAltNum = this.outerAltNum;
+								trackInlineAction(act2);
+
+				}
+
+				}
+				break;
+			case 14:
+				// Grammars\\DefineGrammarItemsWalker.g3:429:6: SEMPRED
+				{
+				SEMPRED9=(GrammarAST)Match(input,SEMPRED,Follow._SEMPRED_in_element1147); if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+
+								SEMPRED9.outerAltNum = this.outerAltNum;
+								trackInlineAction(SEMPRED9);
+
+				}
+
+				}
+				break;
+			case 15:
+				// Grammars\\DefineGrammarItemsWalker.g3:434:6: SYN_SEMPRED
+				{
+				Match(input,SYN_SEMPRED,Follow._SYN_SEMPRED_in_element1158); if (state.failed) return retval;
+
+				}
+				break;
+			case 16:
+				// Grammars\\DefineGrammarItemsWalker.g3:435:6: ^( BACKTRACK_SEMPRED ( . )* )
+				{
+				Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_element1166); if (state.failed) return retval;
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+					// Grammars\\DefineGrammarItemsWalker.g3:435:26: ( . )*
+					for ( ; ; )
+					{
+						int alt35=2;
+						int LA35_0 = input.LA(1);
+
+						if ( ((LA35_0>=ACTION && LA35_0<=XDIGIT)) )
+						{
+							alt35=1;
+						}
+						else if ( (LA35_0==UP) )
+						{
+							alt35=2;
+						}
+
+
+						switch ( alt35 )
+						{
+						case 1:
+							// Grammars\\DefineGrammarItemsWalker.g3:435:0: .
+							{
+							MatchAny(input); if (state.failed) return retval;
+
+							}
+							break;
+
+						default:
+							goto loop35;
+						}
+					}
+
+					loop35:
+						;
+
+
+
+					Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+				}
+
+				}
+				break;
+			case 17:
+				// Grammars\\DefineGrammarItemsWalker.g3:436:6: GATED_SEMPRED
+				{
+				GATED_SEMPRED10=(GrammarAST)Match(input,GATED_SEMPRED,Follow._GATED_SEMPRED_in_element1177); if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+
+								GATED_SEMPRED10.outerAltNum = this.outerAltNum;
+								trackInlineAction(GATED_SEMPRED10);
+
+				}
+
+				}
+				break;
+			case 18:
+				// Grammars\\DefineGrammarItemsWalker.g3:441:6: EPSILON
+				{
+				Match(input,EPSILON,Follow._EPSILON_in_element1188); if (state.failed) return retval;
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "element"
+
+
+	// $ANTLR start "ebnf"
+	// Grammars\\DefineGrammarItemsWalker.g3:444:0: ebnf : (=> dotLoop | block | ^( OPTIONAL block ) | ^( CLOSURE block ) | ^( POSITIVE_CLOSURE block ) );
+	private void ebnf(  )
+	{
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:445:4: (=> dotLoop | block | ^( OPTIONAL block ) | ^( CLOSURE block ) | ^( POSITIVE_CLOSURE block ) )
+			int alt37=5;
+			alt37 = dfa37.Predict(input);
+			switch ( alt37 )
+			{
+			case 1:
+				// Grammars\\DefineGrammarItemsWalker.g3:445:4: => dotLoop
+				{
+
+				PushFollow(Follow._dotLoop_in_ebnf1206);
+				dotLoop();
+
+				state._fsp--;
+				if (state.failed) return ;
+
+				}
+				break;
+			case 2:
+				// Grammars\\DefineGrammarItemsWalker.g3:446:4: block
+				{
+				PushFollow(Follow._block_in_ebnf1212);
+				block();
+
+				state._fsp--;
+				if (state.failed) return ;
+
+				}
+				break;
+			case 3:
+				// Grammars\\DefineGrammarItemsWalker.g3:447:4: ^( OPTIONAL block )
+				{
+				Match(input,OPTIONAL,Follow._OPTIONAL_in_ebnf1219); if (state.failed) return ;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+				PushFollow(Follow._block_in_ebnf1221);
+				block();
+
+				state._fsp--;
+				if (state.failed) return ;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return ;
+
+				}
+				break;
+			case 4:
+				// Grammars\\DefineGrammarItemsWalker.g3:448:4: ^( CLOSURE block )
+				{
+				Match(input,CLOSURE,Follow._CLOSURE_in_ebnf1230); if (state.failed) return ;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+				PushFollow(Follow._block_in_ebnf1232);
+				block();
+
+				state._fsp--;
+				if (state.failed) return ;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return ;
+
+				}
+				break;
+			case 5:
+				// Grammars\\DefineGrammarItemsWalker.g3:449:4: ^( POSITIVE_CLOSURE block )
+				{
+				Match(input,POSITIVE_CLOSURE,Follow._POSITIVE_CLOSURE_in_ebnf1241); if (state.failed) return ;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+				PushFollow(Follow._block_in_ebnf1243);
+				block();
+
+				state._fsp--;
+				if (state.failed) return ;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "ebnf"
+
+	public class dotLoop_return : TreeRuleReturnScope
+	{
+	}
+
+	// $ANTLR start "dotLoop"
+	// Grammars\\DefineGrammarItemsWalker.g3:454:0: dotLoop : ( ^( CLOSURE dotBlock ) | ^( POSITIVE_CLOSURE dotBlock ) ) ;
+	private DefineGrammarItemsWalker.dotLoop_return dotLoop(  )
+	{
+		DefineGrammarItemsWalker.dotLoop_return retval = new DefineGrammarItemsWalker.dotLoop_return();
+		retval.start = input.LT(1);
+
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:455:4: ( ( ^( CLOSURE dotBlock ) | ^( POSITIVE_CLOSURE dotBlock ) ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:455:4: ( ^( CLOSURE dotBlock ) | ^( POSITIVE_CLOSURE dotBlock ) )
+			{
+			// Grammars\\DefineGrammarItemsWalker.g3:455:4: ( ^( CLOSURE dotBlock ) | ^( POSITIVE_CLOSURE dotBlock ) )
+			int alt38=2;
+			int LA38_0 = input.LA(1);
+
+			if ( (LA38_0==CLOSURE) )
+			{
+				alt38=1;
+			}
+			else if ( (LA38_0==POSITIVE_CLOSURE) )
+			{
+				alt38=2;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae = new NoViableAltException("", 38, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt38 )
+			{
+			case 1:
+				// Grammars\\DefineGrammarItemsWalker.g3:455:6: ^( CLOSURE dotBlock )
+				{
+				Match(input,CLOSURE,Follow._CLOSURE_in_dotLoop1262); if (state.failed) return retval;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				PushFollow(Follow._dotBlock_in_dotLoop1264);
+				dotBlock();
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+
+				}
+				break;
+			case 2:
+				// Grammars\\DefineGrammarItemsWalker.g3:456:5: ^( POSITIVE_CLOSURE dotBlock )
+				{
+				Match(input,POSITIVE_CLOSURE,Follow._POSITIVE_CLOSURE_in_dotLoop1274); if (state.failed) return retval;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+				PushFollow(Follow._dotBlock_in_dotLoop1276);
+				dotBlock();
+
+				state._fsp--;
+				if (state.failed) return retval;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+
+				}
+				break;
+
+			}
+
+			if ( state.backtracking == 0 )
+			{
+
+							GrammarAST block = (GrammarAST)((GrammarAST)retval.start).GetChild(0);
+							IDictionary<string, object> opts=new Dictionary<string, object>();
+							opts["greedy"] = "false";
+							if ( grammar.type!=Grammar.LEXER )
+							{
+								// parser grammars assume k=1 for .* loops
+								// otherwise they (analysis?) look til EOF!
+								opts["k"] = 1;
+							}
+							block.setOptions(grammar,opts);
+
+			}
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "dotLoop"
+
+
+	// $ANTLR start "dotBlock"
+	// Grammars\\DefineGrammarItemsWalker.g3:472:0: dotBlock : ^( BLOCK ^( ALT WILDCARD EOA ) EOB ) ;
+	private void dotBlock(  )
+	{
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:473:4: ( ^( BLOCK ^( ALT WILDCARD EOA ) EOB ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:473:4: ^( BLOCK ^( ALT WILDCARD EOA ) EOB )
+			{
+			Match(input,BLOCK,Follow._BLOCK_in_dotBlock1299); if (state.failed) return ;
+
+			Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+			Match(input,ALT,Follow._ALT_in_dotBlock1303); if (state.failed) return ;
+
+			Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+			Match(input,WILDCARD,Follow._WILDCARD_in_dotBlock1305); if (state.failed) return ;
+			Match(input,EOA,Follow._EOA_in_dotBlock1307); if (state.failed) return ;
+
+			Match(input, TokenConstants.UP, null); if (state.failed) return ;
+			Match(input,EOB,Follow._EOB_in_dotBlock1311); if (state.failed) return ;
+
+			Match(input, TokenConstants.UP, null); if (state.failed) return ;
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "dotBlock"
+
+
+	// $ANTLR start "tree_"
+	// Grammars\\DefineGrammarItemsWalker.g3:476:0: tree_ : ^( TREE_BEGIN ( element )+ ) ;
+	private void tree_(  )
+	{
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:477:4: ( ^( TREE_BEGIN ( element )+ ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:477:4: ^( TREE_BEGIN ( element )+ )
+			{
+			Match(input,TREE_BEGIN,Follow._TREE_BEGIN_in_tree_1325); if (state.failed) return ;
+
+			Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+			// Grammars\\DefineGrammarItemsWalker.g3:477:17: ( element )+
+			int cnt39=0;
+			for ( ; ; )
+			{
+				int alt39=2;
+				int LA39_0 = input.LA(1);
+
+				if ( (LA39_0==ACTION||(LA39_0>=ASSIGN && LA39_0<=BLOCK)||(LA39_0>=CHAR_LITERAL && LA39_0<=CHAR_RANGE)||LA39_0==CLOSURE||LA39_0==DOT||LA39_0==EPSILON||LA39_0==FORCED_ACTION||LA39_0==GATED_SEMPRED||LA39_0==NOT||LA39_0==OPTIONAL||(LA39_0>=PLUS_ASSIGN && LA39_0<=POSITIVE_CLOSURE)||LA39_0==RANGE||LA39_0==ROOT||LA39_0==RULE_REF||LA39_0==SEMPRED||(LA39_0>=STRING_LITERAL && LA39_0<=SYNPRED)||LA39_0==TOKEN_REF||LA39_0==TREE_BEGIN||LA39_0==WILDCARD) )
+				{
+					alt39=1;
+				}
+
+
+				switch ( alt39 )
+				{
+				case 1:
+					// Grammars\\DefineGrammarItemsWalker.g3:477:0: element
+					{
+					PushFollow(Follow._element_in_tree_1327);
+					element();
+
+					state._fsp--;
+					if (state.failed) return ;
+
+					}
+					break;
+
+				default:
+					if ( cnt39 >= 1 )
+						goto loop39;
+
+					if (state.backtracking>0) {state.failed=true; return ;}
+					EarlyExitException eee39 = new EarlyExitException( 39, input );
+					throw eee39;
+				}
+				cnt39++;
+			}
+			loop39:
+				;
+
+
+
+			Match(input, TokenConstants.UP, null); if (state.failed) return ;
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "tree_"
+
+
+	// $ANTLR start "atom"
+	// Grammars\\DefineGrammarItemsWalker.g3:480:0: atom[GrammarAST scope_] : ( ^(rr= RULE_REF (rarg= ARG_ACTION )? ) | ^(t= TOKEN_REF (targ= ARG_ACTION )? ) |c= CHAR_LITERAL |s= STRING_LITERAL | WILDCARD | ^( DOT ID atom[$ID] ) );
+	private void atom( GrammarAST scope_ )
+	{
+		GrammarAST rr=null;
+		GrammarAST rarg=null;
+		GrammarAST t=null;
+		GrammarAST targ=null;
+		GrammarAST c=null;
+		GrammarAST s=null;
+		GrammarAST ID11=null;
+
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:481:4: ( ^(rr= RULE_REF (rarg= ARG_ACTION )? ) | ^(t= TOKEN_REF (targ= ARG_ACTION )? ) |c= CHAR_LITERAL |s= STRING_LITERAL | WILDCARD | ^( DOT ID atom[$ID] ) )
+			int alt42=6;
+			switch ( input.LA(1) )
+			{
+			case RULE_REF:
+				{
+				alt42=1;
+				}
+				break;
+			case TOKEN_REF:
+				{
+				alt42=2;
+				}
+				break;
+			case CHAR_LITERAL:
+				{
+				alt42=3;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt42=4;
+				}
+				break;
+			case WILDCARD:
+				{
+				alt42=5;
+				}
+				break;
+			case DOT:
+				{
+				alt42=6;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return ;}
+					NoViableAltException nvae = new NoViableAltException("", 42, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt42 )
+			{
+			case 1:
+				// Grammars\\DefineGrammarItemsWalker.g3:481:4: ^(rr= RULE_REF (rarg= ARG_ACTION )? )
+				{
+				rr=(GrammarAST)Match(input,RULE_REF,Follow._RULE_REF_in_atom1345); if (state.failed) return ;
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+					// Grammars\\DefineGrammarItemsWalker.g3:481:19: (rarg= ARG_ACTION )?
+					int alt40=2;
+					int LA40_0 = input.LA(1);
+
+					if ( (LA40_0==ARG_ACTION) )
+					{
+						alt40=1;
+					}
+					switch ( alt40 )
+					{
+					case 1:
+						// Grammars\\DefineGrammarItemsWalker.g3:481:20: rarg= ARG_ACTION
+						{
+						rarg=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1350); if (state.failed) return ;
+
+						}
+						break;
+
+					}
+
+
+					Match(input, TokenConstants.UP, null); if (state.failed) return ;
+				}
+				if ( state.backtracking == 0 )
+				{
+
+								grammar.altReferencesRule( currentRuleName, scope_, rr, this.outerAltNum );
+								if ( rarg != null )
+								{
+									rarg.outerAltNum = this.outerAltNum;
+									trackInlineAction(rarg);
+								}
+
+				}
+
+				}
+				break;
+			case 2:
+				// Grammars\\DefineGrammarItemsWalker.g3:490:4: ^(t= TOKEN_REF (targ= ARG_ACTION )? )
+				{
+				t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_atom1367); if (state.failed) return ;
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+					// Grammars\\DefineGrammarItemsWalker.g3:490:19: (targ= ARG_ACTION )?
+					int alt41=2;
+					int LA41_0 = input.LA(1);
+
+					if ( (LA41_0==ARG_ACTION) )
+					{
+						alt41=1;
+					}
+					switch ( alt41 )
+					{
+					case 1:
+						// Grammars\\DefineGrammarItemsWalker.g3:490:20: targ= ARG_ACTION
+						{
+						targ=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1372); if (state.failed) return ;
+
+						}
+						break;
+
+					}
+
+
+					Match(input, TokenConstants.UP, null); if (state.failed) return ;
+				}
+				if ( state.backtracking == 0 )
+				{
+
+								if ( targ != null )
+								{
+									targ.outerAltNum = this.outerAltNum;
+									trackInlineAction(targ);
+								}
+								if ( grammar.type == Grammar.LEXER )
+								{
+									grammar.altReferencesRule( currentRuleName, scope_, t, this.outerAltNum );
+								}
+								else
+								{
+									grammar.altReferencesTokenID( currentRuleName, t, this.outerAltNum );
+								}
+
+				}
+
+				}
+				break;
+			case 3:
+				// Grammars\\DefineGrammarItemsWalker.g3:506:4: c= CHAR_LITERAL
+				{
+				c=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_atom1388); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+
+								if ( grammar.type != Grammar.LEXER )
+								{
+									Rule rule = grammar.getRule(currentRuleName);
+									if ( rule != null )
+										rule.trackTokenReferenceInAlt(c, outerAltNum);
+								}
+
+				}
+
+				}
+				break;
+			case 4:
+				// Grammars\\DefineGrammarItemsWalker.g3:515:4: s= STRING_LITERAL
+				{
+				s=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_atom1399); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+
+								if ( grammar.type != Grammar.LEXER )
+								{
+									Rule rule = grammar.getRule(currentRuleName);
+									if ( rule!=null )
+										rule.trackTokenReferenceInAlt(s, outerAltNum);
+								}
+
+				}
+
+				}
+				break;
+			case 5:
+				// Grammars\\DefineGrammarItemsWalker.g3:524:4: WILDCARD
+				{
+				Match(input,WILDCARD,Follow._WILDCARD_in_atom1409); if (state.failed) return ;
+
+				}
+				break;
+			case 6:
+				// Grammars\\DefineGrammarItemsWalker.g3:525:4: ^( DOT ID atom[$ID] )
+				{
+				Match(input,DOT,Follow._DOT_in_atom1415); if (state.failed) return ;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+				ID11=(GrammarAST)Match(input,ID,Follow._ID_in_atom1417); if (state.failed) return ;
+				PushFollow(Follow._atom_in_atom1419);
+				atom(ID11);
+
+				state._fsp--;
+				if (state.failed) return ;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "atom"
+
+
+	// $ANTLR start "ast_suffix"
+	// Grammars\\DefineGrammarItemsWalker.g3:528:0: ast_suffix : ( ROOT | BANG );
+	private void ast_suffix(  )
+	{
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:529:4: ( ROOT | BANG )
+			// Grammars\\DefineGrammarItemsWalker.g3:
+			{
+			if ( input.LA(1)==BANG||input.LA(1)==ROOT )
+			{
+				input.Consume();
+				state.errorRecovery=false;state.failed=false;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				throw mse;
+			}
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "ast_suffix"
+
+	public class rewrite_return : TreeRuleReturnScope
+	{
+	}
+
+	// $ANTLR start "rewrite"
+	// Grammars\\DefineGrammarItemsWalker.g3:533:0: rewrite : ( ^( REWRITE (pred= SEMPRED )? rewrite_alternative ) )* ;
+	private DefineGrammarItemsWalker.rewrite_return rewrite(  )
+	{
+		DefineGrammarItemsWalker.rewrite_return retval = new DefineGrammarItemsWalker.rewrite_return();
+		retval.start = input.LT(1);
+
+		GrammarAST pred=null;
+
+
+			currentRewriteRule = ((GrammarAST)retval.start); // has to execute during backtracking
+			if ( state.backtracking == 0 )
+			{
+				if ( grammar.BuildAST )
+					((GrammarAST)retval.start).rewriteRefsDeep = new HashSet<GrammarAST>();
+			}
+
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:543:4: ( ( ^( REWRITE (pred= SEMPRED )? rewrite_alternative ) )* )
+			// Grammars\\DefineGrammarItemsWalker.g3:543:4: ( ^( REWRITE (pred= SEMPRED )? rewrite_alternative ) )*
+			{
+			// Grammars\\DefineGrammarItemsWalker.g3:543:4: ( ^( REWRITE (pred= SEMPRED )? rewrite_alternative ) )*
+			for ( ; ; )
+			{
+				int alt44=2;
+				int LA44_0 = input.LA(1);
+
+				if ( (LA44_0==REWRITE) )
+				{
+					alt44=1;
+				}
+
+
+				switch ( alt44 )
+				{
+				case 1:
+					// Grammars\\DefineGrammarItemsWalker.g3:544:4: ^( REWRITE (pred= SEMPRED )? rewrite_alternative )
+					{
+					Match(input,REWRITE,Follow._REWRITE_in_rewrite1461); if (state.failed) return retval;
+
+					Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+					// Grammars\\DefineGrammarItemsWalker.g3:544:15: (pred= SEMPRED )?
+					int alt43=2;
+					int LA43_0 = input.LA(1);
+
+					if ( (LA43_0==SEMPRED) )
+					{
+						alt43=1;
+					}
+					switch ( alt43 )
+					{
+					case 1:
+						// Grammars\\DefineGrammarItemsWalker.g3:544:16: pred= SEMPRED
+						{
+						pred=(GrammarAST)Match(input,SEMPRED,Follow._SEMPRED_in_rewrite1466); if (state.failed) return retval;
+
+						}
+						break;
+
+					}
+
+					PushFollow(Follow._rewrite_alternative_in_rewrite1470);
+					rewrite_alternative();
+
+					state._fsp--;
+					if (state.failed) return retval;
+
+					Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+					if ( state.backtracking == 0 )
+					{
+
+										if ( pred != null )
+										{
+											pred.outerAltNum = this.outerAltNum;
+											trackInlineAction(pred);
+										}
+
+					}
+
+					}
+					break;
+
+				default:
+					goto loop44;
+				}
+			}
+
+			loop44:
+				;
+
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite"
+
+	public class rewrite_block_return : TreeRuleReturnScope
+	{
+	}
+
+	// $ANTLR start "rewrite_block"
+	// Grammars\\DefineGrammarItemsWalker.g3:556:0: rewrite_block : ^( BLOCK rewrite_alternative EOB ) ;
+	private DefineGrammarItemsWalker.rewrite_block_return rewrite_block(  )
+	{
+		DefineGrammarItemsWalker.rewrite_block_return retval = new DefineGrammarItemsWalker.rewrite_block_return();
+		retval.start = input.LT(1);
+
+
+			GrammarAST enclosingBlock = currentRewriteBlock;
+			if ( state.backtracking == 0 )
+			{
+				// don't do if guessing
+				currentRewriteBlock=((GrammarAST)retval.start); // pts to BLOCK node
+				currentRewriteBlock.rewriteRefsShallow = new HashSet<GrammarAST>();
+				currentRewriteBlock.rewriteRefsDeep = new HashSet<GrammarAST>();
+			}
+
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:568:6: ( ^( BLOCK rewrite_alternative EOB ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:568:6: ^( BLOCK rewrite_alternative EOB )
+			{
+			Match(input,BLOCK,Follow._BLOCK_in_rewrite_block1505); if (state.failed) return retval;
+
+			Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+			PushFollow(Follow._rewrite_alternative_in_rewrite_block1507);
+			rewrite_alternative();
+
+			state._fsp--;
+			if (state.failed) return retval;
+			Match(input,EOB,Follow._EOB_in_rewrite_block1509); if (state.failed) return retval;
+
+			Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+			if ( state.backtracking == 0 )
+			{
+
+							// copy the element refs in this block to the surrounding block
+							if ( enclosingBlock != null )
+							{
+								foreach ( var item in currentRewriteBlock.rewriteRefsShallow )
+									enclosingBlock.rewriteRefsDeep.Add( item );
+							}
+							//currentRewriteBlock = enclosingBlock; // restore old BLOCK ptr
+
+			}
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+			 currentRewriteBlock = enclosingBlock;
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_block"
+
+
+	// $ANTLR start "rewrite_alternative"
+	// Grammars\\DefineGrammarItemsWalker.g3:582:0: rewrite_alternative : ({...}? => ^(a= ALT ( ( rewrite_element )+ | EPSILON ) EOA ) |{...}? => rewrite_template | ETC {...}?);
+	private void rewrite_alternative(  )
+	{
+		GrammarAST a=null;
+
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:583:4: ({...}? => ^(a= ALT ( ( rewrite_element )+ | EPSILON ) EOA ) |{...}? => rewrite_template | ETC {...}?)
+			int alt47=3;
+			int LA47_0 = input.LA(1);
+
+			if ( (LA47_0==ALT) && (((grammar.BuildAST)||(grammar.BuildTemplate))))
+			{
+				int LA47_1 = input.LA(2);
+
+				if ( (LA47_1==DOWN) && (((grammar.BuildAST)||(grammar.BuildTemplate))))
+				{
+					int LA47_4 = input.LA(3);
+
+					if ( (LA47_4==EPSILON) && (((grammar.BuildTemplate)||(grammar.BuildAST))))
+					{
+						int LA47_5 = input.LA(4);
+
+						if ( (LA47_5==EOA) && (((grammar.BuildTemplate)||(grammar.BuildAST))))
+						{
+							int LA47_7 = input.LA(5);
+
+							if ( (LA47_7==UP) && (((grammar.BuildTemplate)||(grammar.BuildAST))))
+							{
+								int LA47_8 = input.LA(6);
+
+								if ( ((grammar.BuildAST)) )
+								{
+									alt47=1;
+								}
+								else if ( ((grammar.BuildTemplate)) )
+								{
+									alt47=2;
+								}
+								else
+								{
+									if (state.backtracking>0) {state.failed=true; return ;}
+									NoViableAltException nvae = new NoViableAltException("", 47, 8, input);
+
+									throw nvae;
+								}
+							}
+							else
+							{
+								if (state.backtracking>0) {state.failed=true; return ;}
+								NoViableAltException nvae = new NoViableAltException("", 47, 7, input);
+
+								throw nvae;
+							}
+						}
+						else
+						{
+							if (state.backtracking>0) {state.failed=true; return ;}
+							NoViableAltException nvae = new NoViableAltException("", 47, 5, input);
+
+							throw nvae;
+						}
+					}
+					else if ( (LA47_4==ACTION||LA47_4==CHAR_LITERAL||LA47_4==CLOSURE||LA47_4==LABEL||LA47_4==OPTIONAL||LA47_4==POSITIVE_CLOSURE||LA47_4==RULE_REF||LA47_4==STRING_LITERAL||LA47_4==TOKEN_REF||LA47_4==TREE_BEGIN) && ((grammar.BuildAST)))
+					{
+						alt47=1;
+					}
+					else
+					{
+						if (state.backtracking>0) {state.failed=true; return ;}
+						NoViableAltException nvae = new NoViableAltException("", 47, 4, input);
+
+						throw nvae;
+					}
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return ;}
+					NoViableAltException nvae = new NoViableAltException("", 47, 1, input);
+
+					throw nvae;
+				}
+			}
+			else if ( (LA47_0==ACTION||LA47_0==TEMPLATE) && ((grammar.BuildTemplate)))
+			{
+				alt47=2;
+			}
+			else if ( (LA47_0==ETC) )
+			{
+				alt47=3;
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return ;}
+				NoViableAltException nvae = new NoViableAltException("", 47, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt47 )
+			{
+			case 1:
+				// Grammars\\DefineGrammarItemsWalker.g3:583:4: {...}? => ^(a= ALT ( ( rewrite_element )+ | EPSILON ) EOA )
+				{
+				if ( !((grammar.BuildAST)) )
+				{
+					if (state.backtracking>0) {state.failed=true; return ;}
+					throw new FailedPredicateException(input, "rewrite_alternative", "grammar.BuildAST");
+				}
+				a=(GrammarAST)Match(input,ALT,Follow._ALT_in_rewrite_alternative1541); if (state.failed) return ;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+				// Grammars\\DefineGrammarItemsWalker.g3:583:36: ( ( rewrite_element )+ | EPSILON )
+				int alt46=2;
+				int LA46_0 = input.LA(1);
+
+				if ( (LA46_0==ACTION||LA46_0==CHAR_LITERAL||LA46_0==CLOSURE||LA46_0==LABEL||LA46_0==OPTIONAL||LA46_0==POSITIVE_CLOSURE||LA46_0==RULE_REF||LA46_0==STRING_LITERAL||LA46_0==TOKEN_REF||LA46_0==TREE_BEGIN) )
+				{
+					alt46=1;
+				}
+				else if ( (LA46_0==EPSILON) )
+				{
+					alt46=2;
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return ;}
+					NoViableAltException nvae = new NoViableAltException("", 46, 0, input);
+
+					throw nvae;
+				}
+				switch ( alt46 )
+				{
+				case 1:
+					// Grammars\\DefineGrammarItemsWalker.g3:583:38: ( rewrite_element )+
+					{
+					// Grammars\\DefineGrammarItemsWalker.g3:583:38: ( rewrite_element )+
+					int cnt45=0;
+					for ( ; ; )
+					{
+						int alt45=2;
+						int LA45_0 = input.LA(1);
+
+						if ( (LA45_0==ACTION||LA45_0==CHAR_LITERAL||LA45_0==CLOSURE||LA45_0==LABEL||LA45_0==OPTIONAL||LA45_0==POSITIVE_CLOSURE||LA45_0==RULE_REF||LA45_0==STRING_LITERAL||LA45_0==TOKEN_REF||LA45_0==TREE_BEGIN) )
+						{
+							alt45=1;
+						}
+
+
+						switch ( alt45 )
+						{
+						case 1:
+							// Grammars\\DefineGrammarItemsWalker.g3:583:40: rewrite_element
+							{
+							PushFollow(Follow._rewrite_element_in_rewrite_alternative1547);
+							rewrite_element();
+
+							state._fsp--;
+							if (state.failed) return ;
+
+							}
+							break;
+
+						default:
+							if ( cnt45 >= 1 )
+								goto loop45;
+
+							if (state.backtracking>0) {state.failed=true; return ;}
+							EarlyExitException eee45 = new EarlyExitException( 45, input );
+							throw eee45;
+						}
+						cnt45++;
+					}
+					loop45:
+						;
+
+
+
+					}
+					break;
+				case 2:
+					// Grammars\\DefineGrammarItemsWalker.g3:583:61: EPSILON
+					{
+					Match(input,EPSILON,Follow._EPSILON_in_rewrite_alternative1554); if (state.failed) return ;
+
+					}
+					break;
+
+				}
+
+				Match(input,EOA,Follow._EOA_in_rewrite_alternative1558); if (state.failed) return ;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return ;
+
+				}
+				break;
+			case 2:
+				// Grammars\\DefineGrammarItemsWalker.g3:584:4: {...}? => rewrite_template
+				{
+				if ( !((grammar.BuildTemplate)) )
+				{
+					if (state.backtracking>0) {state.failed=true; return ;}
+					throw new FailedPredicateException(input, "rewrite_alternative", "grammar.BuildTemplate");
+				}
+				PushFollow(Follow._rewrite_template_in_rewrite_alternative1569);
+				rewrite_template();
+
+				state._fsp--;
+				if (state.failed) return ;
+
+				}
+				break;
+			case 3:
+				// Grammars\\DefineGrammarItemsWalker.g3:585:4: ETC {...}?
+				{
+				Match(input,ETC,Follow._ETC_in_rewrite_alternative1574); if (state.failed) return ;
+				if ( !((this.blockLevel==1)) )
+				{
+					if (state.backtracking>0) {state.failed=true; return ;}
+					throw new FailedPredicateException(input, "rewrite_alternative", "this.blockLevel==1");
+				}
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "rewrite_alternative"
+
+
+	// $ANTLR start "rewrite_element"
+	// Grammars\\DefineGrammarItemsWalker.g3:588:0: rewrite_element : ( rewrite_atom | rewrite_ebnf | rewrite_tree );
+	private void rewrite_element(  )
+	{
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:589:4: ( rewrite_atom | rewrite_ebnf | rewrite_tree )
+			int alt48=3;
+			switch ( input.LA(1) )
+			{
+			case ACTION:
+			case CHAR_LITERAL:
+			case LABEL:
+			case RULE_REF:
+			case STRING_LITERAL:
+			case TOKEN_REF:
+				{
+				alt48=1;
+				}
+				break;
+			case CLOSURE:
+			case OPTIONAL:
+			case POSITIVE_CLOSURE:
+				{
+				alt48=2;
+				}
+				break;
+			case TREE_BEGIN:
+				{
+				alt48=3;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return ;}
+					NoViableAltException nvae = new NoViableAltException("", 48, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt48 )
+			{
+			case 1:
+				// Grammars\\DefineGrammarItemsWalker.g3:589:4: rewrite_atom
+				{
+				PushFollow(Follow._rewrite_atom_in_rewrite_element1588);
+				rewrite_atom();
+
+				state._fsp--;
+				if (state.failed) return ;
+
+				}
+				break;
+			case 2:
+				// Grammars\\DefineGrammarItemsWalker.g3:590:4: rewrite_ebnf
+				{
+				PushFollow(Follow._rewrite_ebnf_in_rewrite_element1593);
+				rewrite_ebnf();
+
+				state._fsp--;
+				if (state.failed) return ;
+
+				}
+				break;
+			case 3:
+				// Grammars\\DefineGrammarItemsWalker.g3:591:4: rewrite_tree
+				{
+				PushFollow(Follow._rewrite_tree_in_rewrite_element1598);
+				rewrite_tree();
+
+				state._fsp--;
+				if (state.failed) return ;
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "rewrite_element"
+
+
+	// $ANTLR start "rewrite_ebnf"
+	// Grammars\\DefineGrammarItemsWalker.g3:594:0: rewrite_ebnf : ( ^( OPTIONAL rewrite_block ) | ^( CLOSURE rewrite_block ) | ^( POSITIVE_CLOSURE rewrite_block ) );
+	private void rewrite_ebnf(  )
+	{
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:595:4: ( ^( OPTIONAL rewrite_block ) | ^( CLOSURE rewrite_block ) | ^( POSITIVE_CLOSURE rewrite_block ) )
+			int alt49=3;
+			switch ( input.LA(1) )
+			{
+			case OPTIONAL:
+				{
+				alt49=1;
+				}
+				break;
+			case CLOSURE:
+				{
+				alt49=2;
+				}
+				break;
+			case POSITIVE_CLOSURE:
+				{
+				alt49=3;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return ;}
+					NoViableAltException nvae = new NoViableAltException("", 49, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt49 )
+			{
+			case 1:
+				// Grammars\\DefineGrammarItemsWalker.g3:595:4: ^( OPTIONAL rewrite_block )
+				{
+				Match(input,OPTIONAL,Follow._OPTIONAL_in_rewrite_ebnf1611); if (state.failed) return ;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+				PushFollow(Follow._rewrite_block_in_rewrite_ebnf1613);
+				rewrite_block();
+
+				state._fsp--;
+				if (state.failed) return ;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return ;
+
+				}
+				break;
+			case 2:
+				// Grammars\\DefineGrammarItemsWalker.g3:596:4: ^( CLOSURE rewrite_block )
+				{
+				Match(input,CLOSURE,Follow._CLOSURE_in_rewrite_ebnf1622); if (state.failed) return ;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+				PushFollow(Follow._rewrite_block_in_rewrite_ebnf1624);
+				rewrite_block();
+
+				state._fsp--;
+				if (state.failed) return ;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return ;
+
+				}
+				break;
+			case 3:
+				// Grammars\\DefineGrammarItemsWalker.g3:597:4: ^( POSITIVE_CLOSURE rewrite_block )
+				{
+				Match(input,POSITIVE_CLOSURE,Follow._POSITIVE_CLOSURE_in_rewrite_ebnf1633); if (state.failed) return ;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+				PushFollow(Follow._rewrite_block_in_rewrite_ebnf1635);
+				rewrite_block();
+
+				state._fsp--;
+				if (state.failed) return ;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "rewrite_ebnf"
+
+
+	// $ANTLR start "rewrite_tree"
+	// Grammars\\DefineGrammarItemsWalker.g3:600:0: rewrite_tree : ^( TREE_BEGIN rewrite_atom ( rewrite_element )* ) ;
+	private void rewrite_tree(  )
+	{
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:601:6: ( ^( TREE_BEGIN rewrite_atom ( rewrite_element )* ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:601:6: ^( TREE_BEGIN rewrite_atom ( rewrite_element )* )
+			{
+			Match(input,TREE_BEGIN,Follow._TREE_BEGIN_in_rewrite_tree1652); if (state.failed) return ;
+
+			Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+			PushFollow(Follow._rewrite_atom_in_rewrite_tree1654);
+			rewrite_atom();
+
+			state._fsp--;
+			if (state.failed) return ;
+			// Grammars\\DefineGrammarItemsWalker.g3:601:33: ( rewrite_element )*
+			for ( ; ; )
+			{
+				int alt50=2;
+				int LA50_0 = input.LA(1);
+
+				if ( (LA50_0==ACTION||LA50_0==CHAR_LITERAL||LA50_0==CLOSURE||LA50_0==LABEL||LA50_0==OPTIONAL||LA50_0==POSITIVE_CLOSURE||LA50_0==RULE_REF||LA50_0==STRING_LITERAL||LA50_0==TOKEN_REF||LA50_0==TREE_BEGIN) )
+				{
+					alt50=1;
+				}
+
+
+				switch ( alt50 )
+				{
+				case 1:
+					// Grammars\\DefineGrammarItemsWalker.g3:601:35: rewrite_element
+					{
+					PushFollow(Follow._rewrite_element_in_rewrite_tree1658);
+					rewrite_element();
+
+					state._fsp--;
+					if (state.failed) return ;
+
+					}
+					break;
+
+				default:
+					goto loop50;
+				}
+			}
+
+			loop50:
+				;
+
+
+
+			Match(input, TokenConstants.UP, null); if (state.failed) return ;
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "rewrite_tree"
+
+	public class rewrite_atom_return : TreeRuleReturnScope
+	{
+	}
+
+	// $ANTLR start "rewrite_atom"
+	// Grammars\\DefineGrammarItemsWalker.g3:604:0: rewrite_atom : ( RULE_REF | ( ^( TOKEN_REF ( ARG_ACTION )? ) | CHAR_LITERAL | STRING_LITERAL ) | LABEL | ACTION );
+	private DefineGrammarItemsWalker.rewrite_atom_return rewrite_atom(  )
+	{
+		DefineGrammarItemsWalker.rewrite_atom_return retval = new DefineGrammarItemsWalker.rewrite_atom_return();
+		retval.start = input.LT(1);
+
+		GrammarAST ARG_ACTION12=null;
+		GrammarAST ACTION13=null;
+
+
+			if ( state.backtracking == 0 )
+			{
+				Rule r = grammar.getRule(currentRuleName);
+				var tokenRefsInAlt = r.getTokenRefsInAlt(outerAltNum);
+				boolean imaginary =
+					((GrammarAST)retval.start).Type==TOKEN_REF &&
+					!tokenRefsInAlt.Contains(((GrammarAST)retval.start).Text);
+				if ( !imaginary && grammar.BuildAST &&
+					 (((GrammarAST)retval.start).Type==RULE_REF ||
+					  ((GrammarAST)retval.start).Type==LABEL ||
+					  ((GrammarAST)retval.start).Type==TOKEN_REF ||
+					  ((GrammarAST)retval.start).Type==CHAR_LITERAL ||
+					  ((GrammarAST)retval.start).Type==STRING_LITERAL) )
+				{
+					// track per block and for entire rewrite rule
+					if ( currentRewriteBlock!=null )
+					{
+						currentRewriteBlock.rewriteRefsShallow.Add(((GrammarAST)retval.start));
+						currentRewriteBlock.rewriteRefsDeep.Add(((GrammarAST)retval.start));
+					}
+					currentRewriteRule.rewriteRefsDeep.Add(((GrammarAST)retval.start));
+				}
+			}
+
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:631:4: ( RULE_REF | ( ^( TOKEN_REF ( ARG_ACTION )? ) | CHAR_LITERAL | STRING_LITERAL ) | LABEL | ACTION )
+			int alt53=4;
+			switch ( input.LA(1) )
+			{
+			case RULE_REF:
+				{
+				alt53=1;
+				}
+				break;
+			case CHAR_LITERAL:
+			case STRING_LITERAL:
+			case TOKEN_REF:
+				{
+				alt53=2;
+				}
+				break;
+			case LABEL:
+				{
+				alt53=3;
+				}
+				break;
+			case ACTION:
+				{
+				alt53=4;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return retval;}
+					NoViableAltException nvae = new NoViableAltException("", 53, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt53 )
+			{
+			case 1:
+				// Grammars\\DefineGrammarItemsWalker.g3:631:4: RULE_REF
+				{
+				Match(input,RULE_REF,Follow._RULE_REF_in_rewrite_atom1679); if (state.failed) return retval;
+
+				}
+				break;
+			case 2:
+				// Grammars\\DefineGrammarItemsWalker.g3:632:4: ( ^( TOKEN_REF ( ARG_ACTION )? ) | CHAR_LITERAL | STRING_LITERAL )
+				{
+				// Grammars\\DefineGrammarItemsWalker.g3:632:4: ( ^( TOKEN_REF ( ARG_ACTION )? ) | CHAR_LITERAL | STRING_LITERAL )
+				int alt52=3;
+				switch ( input.LA(1) )
+				{
+				case TOKEN_REF:
+					{
+					alt52=1;
+					}
+					break;
+				case CHAR_LITERAL:
+					{
+					alt52=2;
+					}
+					break;
+				case STRING_LITERAL:
+					{
+					alt52=3;
+					}
+					break;
+				default:
+					{
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae = new NoViableAltException("", 52, 0, input);
+
+						throw nvae;
+					}
+				}
+
+				switch ( alt52 )
+				{
+				case 1:
+					// Grammars\\DefineGrammarItemsWalker.g3:632:6: ^( TOKEN_REF ( ARG_ACTION )? )
+					{
+					Match(input,TOKEN_REF,Follow._TOKEN_REF_in_rewrite_atom1689); if (state.failed) return retval;
+
+					if ( input.LA(1)==TokenConstants.DOWN )
+					{
+						Match(input, TokenConstants.DOWN, null); if (state.failed) return retval;
+						// Grammars\\DefineGrammarItemsWalker.g3:633:5: ( ARG_ACTION )?
+						int alt51=2;
+						int LA51_0 = input.LA(1);
+
+						if ( (LA51_0==ARG_ACTION) )
+						{
+							alt51=1;
+						}
+						switch ( alt51 )
+						{
+						case 1:
+							// Grammars\\DefineGrammarItemsWalker.g3:633:7: ARG_ACTION
+							{
+							ARG_ACTION12=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rewrite_atom1697); if (state.failed) return retval;
+							if ( state.backtracking == 0 )
+							{
+
+														ARG_ACTION12.outerAltNum = this.outerAltNum;
+														trackInlineAction(ARG_ACTION12);
+
+							}
+
+							}
+							break;
+
+						}
+
+
+						Match(input, TokenConstants.UP, null); if (state.failed) return retval;
+					}
+
+					}
+					break;
+				case 2:
+					// Grammars\\DefineGrammarItemsWalker.g3:640:5: CHAR_LITERAL
+					{
+					Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_rewrite_atom1722); if (state.failed) return retval;
+
+					}
+					break;
+				case 3:
+					// Grammars\\DefineGrammarItemsWalker.g3:641:5: STRING_LITERAL
+					{
+					Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_rewrite_atom1728); if (state.failed) return retval;
+
+					}
+					break;
+
+				}
+
+
+				}
+				break;
+			case 3:
+				// Grammars\\DefineGrammarItemsWalker.g3:643:4: LABEL
+				{
+				Match(input,LABEL,Follow._LABEL_in_rewrite_atom1737); if (state.failed) return retval;
+
+				}
+				break;
+			case 4:
+				// Grammars\\DefineGrammarItemsWalker.g3:644:4: ACTION
+				{
+				ACTION13=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_rewrite_atom1742); if (state.failed) return retval;
+				if ( state.backtracking == 0 )
+				{
+
+								ACTION13.outerAltNum = this.outerAltNum;
+								trackInlineAction(ACTION13);
+
+				}
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite_atom"
+
+
+	// $ANTLR start "rewrite_template"
+	// Grammars\\DefineGrammarItemsWalker.g3:651:0: rewrite_template : ( ^( ALT EPSILON EOA ) | ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? ) |act= ACTION );
+	private void rewrite_template(  )
+	{
+		GrammarAST id=null;
+		GrammarAST ind=null;
+		GrammarAST arg=null;
+		GrammarAST a=null;
+		GrammarAST act=null;
+
+		try
+		{
+			// Grammars\\DefineGrammarItemsWalker.g3:652:4: ( ^( ALT EPSILON EOA ) | ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? ) |act= ACTION )
+			int alt57=3;
+			switch ( input.LA(1) )
+			{
+			case ALT:
+				{
+				alt57=1;
+				}
+				break;
+			case TEMPLATE:
+				{
+				alt57=2;
+				}
+				break;
+			case ACTION:
+				{
+				alt57=3;
+				}
+				break;
+			default:
+				{
+					if (state.backtracking>0) {state.failed=true; return ;}
+					NoViableAltException nvae = new NoViableAltException("", 57, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt57 )
+			{
+			case 1:
+				// Grammars\\DefineGrammarItemsWalker.g3:652:4: ^( ALT EPSILON EOA )
+				{
+				Match(input,ALT,Follow._ALT_in_rewrite_template1759); if (state.failed) return ;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+				Match(input,EPSILON,Follow._EPSILON_in_rewrite_template1761); if (state.failed) return ;
+				Match(input,EOA,Follow._EOA_in_rewrite_template1763); if (state.failed) return ;
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return ;
+
+				}
+				break;
+			case 2:
+				// Grammars\\DefineGrammarItemsWalker.g3:653:4: ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? )
+				{
+				Match(input,TEMPLATE,Follow._TEMPLATE_in_rewrite_template1772); if (state.failed) return ;
+
+				Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+				// Grammars\\DefineGrammarItemsWalker.g3:653:16: (id= ID |ind= ACTION )
+				int alt54=2;
+				int LA54_0 = input.LA(1);
+
+				if ( (LA54_0==ID) )
+				{
+					alt54=1;
+				}
+				else if ( (LA54_0==ACTION) )
+				{
+					alt54=2;
+				}
+				else
+				{
+					if (state.backtracking>0) {state.failed=true; return ;}
+					NoViableAltException nvae = new NoViableAltException("", 54, 0, input);
+
+					throw nvae;
+				}
+				switch ( alt54 )
+				{
+				case 1:
+					// Grammars\\DefineGrammarItemsWalker.g3:653:17: id= ID
+					{
+					id=(GrammarAST)Match(input,ID,Follow._ID_in_rewrite_template1777); if (state.failed) return ;
+
+					}
+					break;
+				case 2:
+					// Grammars\\DefineGrammarItemsWalker.g3:653:23: ind= ACTION
+					{
+					ind=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_rewrite_template1781); if (state.failed) return ;
+
+					}
+					break;
+
+				}
+
+				Match(input,ARGLIST,Follow._ARGLIST_in_rewrite_template1789); if (state.failed) return ;
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+					// Grammars\\DefineGrammarItemsWalker.g3:655:5: ( ^( ARG arg= ID a= ACTION ) )*
+					for ( ; ; )
+					{
+						int alt55=2;
+						int LA55_0 = input.LA(1);
+
+						if ( (LA55_0==ARG) )
+						{
+							alt55=1;
+						}
+
+
+						switch ( alt55 )
+						{
+						case 1:
+							// Grammars\\DefineGrammarItemsWalker.g3:655:7: ^( ARG arg= ID a= ACTION )
+							{
+							Match(input,ARG,Follow._ARG_in_rewrite_template1799); if (state.failed) return ;
+
+							Match(input, TokenConstants.DOWN, null); if (state.failed) return ;
+							arg=(GrammarAST)Match(input,ID,Follow._ID_in_rewrite_template1803); if (state.failed) return ;
+							a=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_rewrite_template1807); if (state.failed) return ;
+
+							Match(input, TokenConstants.UP, null); if (state.failed) return ;
+							if ( state.backtracking == 0 )
+							{
+
+														a.outerAltNum = this.outerAltNum;
+														trackInlineAction(a);
+
+							}
+
+							}
+							break;
+
+						default:
+							goto loop55;
+						}
+					}
+
+					loop55:
+						;
+
+
+
+					Match(input, TokenConstants.UP, null); if (state.failed) return ;
+				}
+				if ( state.backtracking == 0 )
+				{
+
+									if ( ind!=null )
+									{
+										ind.outerAltNum = this.outerAltNum;
+										trackInlineAction(ind);
+									}
+
+				}
+				// Grammars\\DefineGrammarItemsWalker.g3:669:4: ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )?
+				int alt56=2;
+				int LA56_0 = input.LA(1);
+
+				if ( ((LA56_0>=DOUBLE_ANGLE_STRING_LITERAL && LA56_0<=DOUBLE_QUOTE_STRING_LITERAL)) )
+				{
+					alt56=1;
+				}
+				switch ( alt56 )
+				{
+				case 1:
+					// Grammars\\DefineGrammarItemsWalker.g3:
+					{
+					if ( (input.LA(1)>=DOUBLE_ANGLE_STRING_LITERAL && input.LA(1)<=DOUBLE_QUOTE_STRING_LITERAL) )
+					{
+						input.Consume();
+						state.errorRecovery=false;state.failed=false;
+					}
+					else
+					{
+						if (state.backtracking>0) {state.failed=true; return ;}
+						MismatchedSetException mse = new MismatchedSetException(null,input);
+						throw mse;
+					}
+
+
+					}
+					break;
+
+				}
+
+
+				Match(input, TokenConstants.UP, null); if (state.failed) return ;
+
+				}
+				break;
+			case 3:
+				// Grammars\\DefineGrammarItemsWalker.g3:673:4: act= ACTION
+				{
+				act=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_rewrite_template1864); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+
+								act.outerAltNum = this.outerAltNum;
+								trackInlineAction(act);
+
+				}
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "rewrite_template"
+
+	// $ANTLR start synpred1_DefineGrammarItemsWalker
+	public void synpred1_DefineGrammarItemsWalker_fragment()
+	{
+		// Grammars\\DefineGrammarItemsWalker.g3:445:4: ( dotLoop )
+		// Grammars\\DefineGrammarItemsWalker.g3:445:5: dotLoop
+		{
+		PushFollow(Follow._dotLoop_in_synpred1_DefineGrammarItemsWalker1201);
+		dotLoop();
+
+		state._fsp--;
+		if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred1_DefineGrammarItemsWalker
+	#endregion
+
+	// Delegated rules
+
+	#region Synpreds
+	public bool synpred1_DefineGrammarItemsWalker()
+	{
+		state.backtracking++;
+		int start = input.Mark();
+		try
+		{
+			synpred1_DefineGrammarItemsWalker_fragment(); // can never throw exception
+		}
+		catch ( RecognitionException re )
+		{
+			System.Console.Error.WriteLine("impossible: "+re);
+		}
+		bool success = !state.failed;
+		input.Rewind(start);
+		state.backtracking--;
+		state.failed=false;
+		return success;
+	}
+
+	#endregion
+
+	#region DFA
+	DFA36 dfa36;
+	DFA37 dfa37;
+
+	protected override void InitDFAs()
+	{
+		base.InitDFAs();
+		dfa36 = new DFA36( this );
+		dfa37 = new DFA37( this, new SpecialStateTransitionHandler( specialStateTransition37 ) );
+	}
+
+	class DFA36 : DFA
+	{
+
+		const string DFA36_eotS =
+			"\x13\xFFFF";
+		const string DFA36_eofS =
+			"\x13\xFFFF";
+		const string DFA36_minS =
+			"\x1\x4\x12\xFFFF";
+		const string DFA36_maxS =
+			"\x1\x5F\x12\xFFFF";
+		const string DFA36_acceptS =
+			"\x1\xFFFF\x1\x1\x1\x2\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9\x1\xA"+
+			"\x1\xB\x1\xC\x1\xD\x1\xE\x1\xF\x1\x10\x1\x11\x1\x12";
+		const string DFA36_specialS =
+			"\x13\xFFFF}>";
+		static readonly string[] DFA36_transitionS =
+			{
+				"\x1\xC\x8\xFFFF\x1\x7\x1\x10\x1\x2\x1\x9\x1\xFFFF\x1\x3\x1\x6\x1\xFFFF"+
+				"\x1\x9\x7\xFFFF\x1\x3\x5\xFFFF\x1\x12\x3\xFFFF\x1\xD\x1\xFFFF\x1\x11"+
+				"\xD\xFFFF\x1\x4\x1\xFFFF\x1\x9\x5\xFFFF\x1\x8\x1\x9\x4\xFFFF\x1\x5\x4"+
+				"\xFFFF\x1\x1\x2\xFFFF\x1\x3\x2\xFFFF\x1\xE\x4\xFFFF\x1\x3\x1\xF\x1\xB"+
+				"\x2\xFFFF\x1\x3\x2\xFFFF\x1\xA\x1\xFFFF\x1\x3",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				""
+			};
+
+		static readonly short[] DFA36_eot = DFA.UnpackEncodedString(DFA36_eotS);
+		static readonly short[] DFA36_eof = DFA.UnpackEncodedString(DFA36_eofS);
+		static readonly char[] DFA36_min = DFA.UnpackEncodedStringToUnsignedChars(DFA36_minS);
+		static readonly char[] DFA36_max = DFA.UnpackEncodedStringToUnsignedChars(DFA36_maxS);
+		static readonly short[] DFA36_accept = DFA.UnpackEncodedString(DFA36_acceptS);
+		static readonly short[] DFA36_special = DFA.UnpackEncodedString(DFA36_specialS);
+		static readonly short[][] DFA36_transition;
+
+		static DFA36()
+		{
+			int numStates = DFA36_transitionS.Length;
+			DFA36_transition = new short[numStates][];
+			for ( int i=0; i < numStates; i++ )
+			{
+				DFA36_transition[i] = DFA.UnpackEncodedString(DFA36_transitionS[i]);
+			}
+		}
+
+		public DFA36( BaseRecognizer recognizer )
+		{
+			this.recognizer = recognizer;
+			this.decisionNumber = 36;
+			this.eot = DFA36_eot;
+			this.eof = DFA36_eof;
+			this.min = DFA36_min;
+			this.max = DFA36_max;
+			this.accept = DFA36_accept;
+			this.special = DFA36_special;
+			this.transition = DFA36_transition;
+		}
+		public override string GetDescription()
+		{
+			return "368:0: element : ( ^( ROOT element ) | ^( BANG element ) | atom[null] | ^( NOT element ) | ^( RANGE atom[null] atom[null] ) | ^( CHAR_RANGE atom[null] atom[null] ) | ^( ASSIGN id= ID el= element ) | ^( PLUS_ASSIGN id2= ID a2= element ) | ebnf | tree_ | ^( SYNPRED block ) |act= ACTION |act2= FORCED_ACTION | SEMPRED | SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) | GATED_SEMPRED | EPSILON );";
+		}
+	}
+
+	class DFA37 : DFA
+	{
+
+		const string DFA37_eotS =
+			"\x1E\xFFFF";
+		const string DFA37_eofS =
+			"\x1E\xFFFF";
+		const string DFA37_minS =
+			"\x1\x10\x2\x2\x2\xFFFF\x2\x10\x2\x2\x2\x8\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF"+
+			"\x4\x4\x2\x3\x2\x8\x4\x3\x2\x0\x1\xFFFF";
+		const string DFA37_maxS =
+			"\x1\x40\x2\x2\x2\xFFFF\x2\x10\x2\x2\x2\x3A\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF"+
+			"\x4\x5F\x2\x3\x2\x49\x4\x3\x2\x0\x1\xFFFF";
+		const string DFA37_acceptS =
+			"\x3\xFFFF\x1\x2\x1\x3\x7\xFFFF\x1\x4\x1\xFFFF\x1\x5\xE\xFFFF\x1\x1";
+		const string DFA37_specialS =
+			"\x1B\xFFFF\x1\x0\x1\x1\x1\xFFFF}>";
+		static readonly string[] DFA37_transitionS =
+			{
+				"\x1\x3\x4\xFFFF\x1\x1\x23\xFFFF\x1\x4\x6\xFFFF\x1\x2",
+				"\x1\x5",
+				"\x1\x6",
+				"",
+				"",
+				"\x1\x7",
+				"\x1\x8",
+				"\x1\x9",
+				"\x1\xA",
+				"\x1\xB\x1\xC\x30\xFFFF\x1\xC",
+				"\x1\xD\x1\xE\x30\xFFFF\x1\xE",
+				"\x1\xF",
+				"",
+				"\x1\x10",
+				"",
+				"\x1\xC\x8\xFFFF\x4\xC\x1\xFFFF\x2\xC\x1\xFFFF\x1\xC\x7\xFFFF\x1\xC\x5"+
+				"\xFFFF\x1\xC\x3\xFFFF\x1\xC\x1\xFFFF\x1\xC\xD\xFFFF\x1\xC\x1\xFFFF\x1"+
+				"\xC\x5\xFFFF\x2\xC\x4\xFFFF\x1\xC\x4\xFFFF\x1\xC\x2\xFFFF\x1\xC\x2\xFFFF"+
+				"\x1\xC\x4\xFFFF\x3\xC\x2\xFFFF\x1\xC\x2\xFFFF\x1\xC\x1\xFFFF\x1\x11",
+				"\x1\xE\x8\xFFFF\x4\xE\x1\xFFFF\x2\xE\x1\xFFFF\x1\xE\x7\xFFFF\x1\xE\x5"+
+				"\xFFFF\x1\xE\x3\xFFFF\x1\xE\x1\xFFFF\x1\xE\xD\xFFFF\x1\xE\x1\xFFFF\x1"+
+				"\xE\x5\xFFFF\x2\xE\x4\xFFFF\x1\xE\x4\xFFFF\x1\xE\x2\xFFFF\x1\xE\x2\xFFFF"+
+				"\x1\xE\x4\xFFFF\x3\xE\x2\xFFFF\x1\xE\x2\xFFFF\x1\xE\x1\xFFFF\x1\x12",
+				"\x1\xC\x8\xFFFF\x4\xC\x1\xFFFF\x2\xC\x1\xFFFF\x1\xC\x7\xFFFF\x1\xC\x2"+
+				"\xFFFF\x1\x13\x2\xFFFF\x1\xC\x3\xFFFF\x1\xC\x1\xFFFF\x1\xC\xD\xFFFF"+
+				"\x1\xC\x1\xFFFF\x1\xC\x5\xFFFF\x2\xC\x4\xFFFF\x1\xC\x4\xFFFF\x1\xC\x2"+
+				"\xFFFF\x1\xC\x2\xFFFF\x1\xC\x4\xFFFF\x3\xC\x2\xFFFF\x1\xC\x2\xFFFF\x1"+
+				"\xC\x1\xFFFF\x1\xC",
+				"\x1\xE\x8\xFFFF\x4\xE\x1\xFFFF\x2\xE\x1\xFFFF\x1\xE\x7\xFFFF\x1\xE\x2"+
+				"\xFFFF\x1\x14\x2\xFFFF\x1\xE\x3\xFFFF\x1\xE\x1\xFFFF\x1\xE\xD\xFFFF"+
+				"\x1\xE\x1\xFFFF\x1\xE\x5\xFFFF\x2\xE\x4\xFFFF\x1\xE\x4\xFFFF\x1\xE\x2"+
+				"\xFFFF\x1\xE\x2\xFFFF\x1\xE\x4\xFFFF\x3\xE\x2\xFFFF\x1\xE\x2\xFFFF\x1"+
+				"\xE\x1\xFFFF\x1\xE",
+				"\x1\x15",
+				"\x1\x16",
+				"\x1\xC\x18\xFFFF\x1\x17\x27\xFFFF\x1\xC",
+				"\x1\xE\x18\xFFFF\x1\x18\x27\xFFFF\x1\xE",
+				"\x1\x19",
+				"\x1\x1A",
+				"\x1\x1B",
+				"\x1\x1C",
+				"\x1\xFFFF",
+				"\x1\xFFFF",
+				""
+			};
+
+		static readonly short[] DFA37_eot = DFA.UnpackEncodedString(DFA37_eotS);
+		static readonly short[] DFA37_eof = DFA.UnpackEncodedString(DFA37_eofS);
+		static readonly char[] DFA37_min = DFA.UnpackEncodedStringToUnsignedChars(DFA37_minS);
+		static readonly char[] DFA37_max = DFA.UnpackEncodedStringToUnsignedChars(DFA37_maxS);
+		static readonly short[] DFA37_accept = DFA.UnpackEncodedString(DFA37_acceptS);
+		static readonly short[] DFA37_special = DFA.UnpackEncodedString(DFA37_specialS);
+		static readonly short[][] DFA37_transition;
+
+		static DFA37()
+		{
+			int numStates = DFA37_transitionS.Length;
+			DFA37_transition = new short[numStates][];
+			for ( int i=0; i < numStates; i++ )
+			{
+				DFA37_transition[i] = DFA.UnpackEncodedString(DFA37_transitionS[i]);
+			}
+		}
+
+		public DFA37( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
+			: base( specialStateTransition )	{
+			this.recognizer = recognizer;
+			this.decisionNumber = 37;
+			this.eot = DFA37_eot;
+			this.eof = DFA37_eof;
+			this.min = DFA37_min;
+			this.max = DFA37_max;
+			this.accept = DFA37_accept;
+			this.special = DFA37_special;
+			this.transition = DFA37_transition;
+		}
+		public override string GetDescription()
+		{
+			return "444:0: ebnf : (=> dotLoop | block | ^( OPTIONAL block ) | ^( CLOSURE block ) | ^( POSITIVE_CLOSURE block ) );";
+		}
+	}
+
+	int specialStateTransition37( DFA dfa, int s, IIntStream _input )
+	{
+		ITreeNodeStream input = (ITreeNodeStream)_input;
+		int _s = s;
+		switch ( s )
+		{
+
+			case 0:
+				int LA37_27 = input.LA(1);
+
+
+				int index37_27 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred1_DefineGrammarItemsWalker()) ) {s = 29;}
+
+				else if ( (true) ) {s = 12;}
+
+
+				input.Seek(index37_27);
+				if ( s>=0 ) return s;
+				break;
+
+			case 1:
+				int LA37_28 = input.LA(1);
+
+
+				int index37_28 = input.Index;
+				input.Rewind();
+				s = -1;
+				if ( (synpred1_DefineGrammarItemsWalker()) ) {s = 29;}
+
+				else if ( (true) ) {s = 14;}
+
+
+				input.Seek(index37_28);
+				if ( s>=0 ) return s;
+				break;
+		}
+		if (state.backtracking>0) {state.failed=true; return -1;}
+		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 37, _s, input);
+		dfa.Error(nvae);
+		throw nvae;
+	}
+
+	#endregion
+
+	#region Follow Sets
+	public static class Follow
+	{
+		public static readonly BitSet _LEXER_GRAMMAR_in_grammar_77 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _grammarSpec_in_grammar_83 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _PARSER_GRAMMAR_in_grammar_92 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _grammarSpec_in_grammar_97 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _TREE_GRAMMAR_in_grammar_106 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _grammarSpec_in_grammar_111 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _COMBINED_GRAMMAR_in_grammar_120 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _grammarSpec_in_grammar_125 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _SCOPE_in_attrScope150 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_attrScope154 = new BitSet(new ulong[]{0x210UL});
+		public static readonly BitSet _attrScopeAction_in_attrScope156 = new BitSet(new ulong[]{0x210UL});
+		public static readonly BitSet _ACTION_in_attrScope161 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _AMPERSAND_in_attrScopeAction179 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_attrScopeAction181 = new BitSet(new ulong[]{0x10UL});
+		public static readonly BitSet _ACTION_in_attrScopeAction183 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ID_in_grammarSpec201 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
+		public static readonly BitSet _DOC_COMMENT_in_grammarSpec208 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
+		public static readonly BitSet _optionsSpec_in_grammarSpec216 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
+		public static readonly BitSet _delegateGrammars_in_grammarSpec224 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
+		public static readonly BitSet _tokensSpec_in_grammarSpec231 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
+		public static readonly BitSet _attrScope_in_grammarSpec238 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
+		public static readonly BitSet _actions_in_grammarSpec245 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
+		public static readonly BitSet _rules_in_grammarSpec251 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _action_in_actions264 = new BitSet(new ulong[]{0x202UL});
+		public static readonly BitSet _AMPERSAND_in_action286 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_action290 = new BitSet(new ulong[]{0x80000000010UL});
+		public static readonly BitSet _ID_in_action299 = new BitSet(new ulong[]{0x10UL});
+		public static readonly BitSet _ACTION_in_action303 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ACTION_in_action319 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _OPTIONS_in_optionsSpec353 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _IMPORT_in_delegateGrammars370 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ASSIGN_in_delegateGrammars375 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_delegateGrammars377 = new BitSet(new ulong[]{0x80000000000UL});
+		public static readonly BitSet _ID_in_delegateGrammars379 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ID_in_delegateGrammars384 = new BitSet(new ulong[]{0x80000002008UL});
+		public static readonly BitSet _TOKENS_in_tokensSpec402 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _tokenSpec_in_tokensSpec406 = new BitSet(new ulong[]{0x2008UL,0x4000000UL});
+		public static readonly BitSet _TOKEN_REF_in_tokenSpec424 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ASSIGN_in_tokenSpec431 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _TOKEN_REF_in_tokenSpec436 = new BitSet(new ulong[]{0x40000UL,0x200000UL});
+		public static readonly BitSet _set_in_tokenSpec441 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _rule_in_rules471 = new BitSet(new ulong[]{0x400200008000202UL,0x8005000UL});
+		public static readonly BitSet _RULE_in_rule491 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_rule495 = new BitSet(new ulong[]{0x10000000400UL,0xEUL});
+		public static readonly BitSet _modifier_in_rule503 = new BitSet(new ulong[]{0x400UL});
+		public static readonly BitSet _ARG_in_rule512 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_ACTION_in_rule517 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _RET_in_rule528 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_ACTION_in_rule533 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _throwsSpec_in_rule543 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
+		public static readonly BitSet _optionsSpec_in_rule551 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
+		public static readonly BitSet _ruleScopeSpec_in_rule564 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
+		public static readonly BitSet _ruleAction_in_rule573 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
+		public static readonly BitSet _block_in_rule588 = new BitSet(new ulong[]{0x4400020000UL});
+		public static readonly BitSet _exceptionGroup_in_rule594 = new BitSet(new ulong[]{0x400000000UL});
+		public static readonly BitSet _EOR_in_rule601 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _AMPERSAND_in_ruleAction625 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_ruleAction629 = new BitSet(new ulong[]{0x10UL});
+		public static readonly BitSet _ACTION_in_ruleAction633 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _set_in_modifier657 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _THROWS_in_throwsSpec693 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_throwsSpec696 = new BitSet(new ulong[]{0x80000000008UL});
+		public static readonly BitSet _SCOPE_in_ruleScopeSpec726 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _attrScopeAction_in_ruleScopeSpec733 = new BitSet(new ulong[]{0x210UL});
+		public static readonly BitSet _ACTION_in_ruleScopeSpec738 = new BitSet(new ulong[]{0x80000000008UL});
+		public static readonly BitSet _ID_in_ruleScopeSpec759 = new BitSet(new ulong[]{0x80000000008UL});
+		public static readonly BitSet _BLOCK_in_block793 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _optionsSpec_in_block799 = new BitSet(new ulong[]{0x300UL});
+		public static readonly BitSet _blockAction_in_block807 = new BitSet(new ulong[]{0x300UL});
+		public static readonly BitSet _alternative_in_block816 = new BitSet(new ulong[]{0x200000300UL,0x200UL});
+		public static readonly BitSet _rewrite_in_block818 = new BitSet(new ulong[]{0x200000300UL});
+		public static readonly BitSet _EOB_in_block835 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _AMPERSAND_in_blockAction859 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_blockAction863 = new BitSet(new ulong[]{0x10UL});
+		public static readonly BitSet _ACTION_in_blockAction867 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ALT_in_alternative888 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _element_in_alternative891 = new BitSet(new ulong[]{0x86800289202DE210UL,0xA4E16421UL});
+		public static readonly BitSet _EOA_in_alternative895 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _exceptionHandler_in_exceptionGroup910 = new BitSet(new ulong[]{0x4000020002UL});
+		public static readonly BitSet _finallyClause_in_exceptionGroup916 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _finallyClause_in_exceptionGroup923 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _CATCH_in_exceptionHandler937 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_ACTION_in_exceptionHandler939 = new BitSet(new ulong[]{0x10UL});
+		public static readonly BitSet _ACTION_in_exceptionHandler941 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _FINALLY_in_finallyClause959 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ACTION_in_finallyClause961 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ROOT_in_element978 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _element_in_element980 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _BANG_in_element989 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _element_in_element991 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _atom_in_element999 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _NOT_in_element1008 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _element_in_element1010 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _RANGE_in_element1019 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _atom_in_element1021 = new BitSet(new ulong[]{0x20040000UL,0x84202000UL});
+		public static readonly BitSet _atom_in_element1024 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _CHAR_RANGE_in_element1034 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _atom_in_element1036 = new BitSet(new ulong[]{0x20040000UL,0x84202000UL});
+		public static readonly BitSet _atom_in_element1039 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ASSIGN_in_element1048 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_element1052 = new BitSet(new ulong[]{0x86800289202DE210UL,0xA4E16421UL});
+		public static readonly BitSet _element_in_element1056 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _PLUS_ASSIGN_in_element1069 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_element1073 = new BitSet(new ulong[]{0x86800289202DE210UL,0xA4E16421UL});
+		public static readonly BitSet _element_in_element1077 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ebnf_in_element1094 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _tree__in_element1101 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _SYNPRED_in_element1110 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _block_in_element1112 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ACTION_in_element1123 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _FORCED_ACTION_in_element1136 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _SEMPRED_in_element1147 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _SYN_SEMPRED_in_element1158 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _BACKTRACK_SEMPRED_in_element1166 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _GATED_SEMPRED_in_element1177 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _EPSILON_in_element1188 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _dotLoop_in_ebnf1206 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _block_in_ebnf1212 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _OPTIONAL_in_ebnf1219 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _block_in_ebnf1221 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _CLOSURE_in_ebnf1230 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _block_in_ebnf1232 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _POSITIVE_CLOSURE_in_ebnf1241 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _block_in_ebnf1243 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _CLOSURE_in_dotLoop1262 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _dotBlock_in_dotLoop1264 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _POSITIVE_CLOSURE_in_dotLoop1274 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _dotBlock_in_dotLoop1276 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _BLOCK_in_dotBlock1299 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ALT_in_dotBlock1303 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _WILDCARD_in_dotBlock1305 = new BitSet(new ulong[]{0x100000000UL});
+		public static readonly BitSet _EOA_in_dotBlock1307 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _EOB_in_dotBlock1311 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _TREE_BEGIN_in_tree_1325 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _element_in_tree_1327 = new BitSet(new ulong[]{0x86800289202DE218UL,0xA4E16421UL});
+		public static readonly BitSet _RULE_REF_in_atom1345 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_ACTION_in_atom1350 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _TOKEN_REF_in_atom1367 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_ACTION_in_atom1372 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _CHAR_LITERAL_in_atom1388 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _STRING_LITERAL_in_atom1399 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _WILDCARD_in_atom1409 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _DOT_in_atom1415 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_atom1417 = new BitSet(new ulong[]{0x20040000UL,0x84202000UL});
+		public static readonly BitSet _atom_in_atom1419 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _set_in_ast_suffix1433 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _REWRITE_in_rewrite1461 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _SEMPRED_in_rewrite1466 = new BitSet(new ulong[]{0x2000000110UL,0x1000000UL});
+		public static readonly BitSet _rewrite_alternative_in_rewrite1470 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _BLOCK_in_rewrite_block1505 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _rewrite_alternative_in_rewrite_block1507 = new BitSet(new ulong[]{0x200000000UL});
+		public static readonly BitSet _EOB_in_rewrite_block1509 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ALT_in_rewrite_alternative1541 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _rewrite_element_in_rewrite_alternative1547 = new BitSet(new ulong[]{0x201000100240010UL,0x24202001UL});
+		public static readonly BitSet _EPSILON_in_rewrite_alternative1554 = new BitSet(new ulong[]{0x100000000UL});
+		public static readonly BitSet _EOA_in_rewrite_alternative1558 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _rewrite_template_in_rewrite_alternative1569 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ETC_in_rewrite_alternative1574 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _rewrite_atom_in_rewrite_element1588 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _rewrite_ebnf_in_rewrite_element1593 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _rewrite_tree_in_rewrite_element1598 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _OPTIONAL_in_rewrite_ebnf1611 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _rewrite_block_in_rewrite_ebnf1613 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _CLOSURE_in_rewrite_ebnf1622 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _rewrite_block_in_rewrite_ebnf1624 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _POSITIVE_CLOSURE_in_rewrite_ebnf1633 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _rewrite_block_in_rewrite_ebnf1635 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _TREE_BEGIN_in_rewrite_tree1652 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _rewrite_atom_in_rewrite_tree1654 = new BitSet(new ulong[]{0x201000100240018UL,0x24202001UL});
+		public static readonly BitSet _rewrite_element_in_rewrite_tree1658 = new BitSet(new ulong[]{0x201000100240018UL,0x24202001UL});
+		public static readonly BitSet _RULE_REF_in_rewrite_atom1679 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _TOKEN_REF_in_rewrite_atom1689 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_ACTION_in_rewrite_atom1697 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _CHAR_LITERAL_in_rewrite_atom1722 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _STRING_LITERAL_in_rewrite_atom1728 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _LABEL_in_rewrite_atom1737 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ACTION_in_rewrite_atom1742 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ALT_in_rewrite_template1759 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _EPSILON_in_rewrite_template1761 = new BitSet(new ulong[]{0x100000000UL});
+		public static readonly BitSet _EOA_in_rewrite_template1763 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _TEMPLATE_in_rewrite_template1772 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_rewrite_template1777 = new BitSet(new ulong[]{0x1000UL});
+		public static readonly BitSet _ACTION_in_rewrite_template1781 = new BitSet(new ulong[]{0x1000UL});
+		public static readonly BitSet _ARGLIST_in_rewrite_template1789 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_in_rewrite_template1799 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_rewrite_template1803 = new BitSet(new ulong[]{0x10UL});
+		public static readonly BitSet _ACTION_in_rewrite_template1807 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _set_in_rewrite_template1838 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ACTION_in_rewrite_template1864 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _dotLoop_in_synpred1_DefineGrammarItemsWalker1201 = new BitSet(new ulong[]{0x2UL});
+
+	}
+	#endregion
+}
+
+} // namespace Antlr3.Grammars
diff --git a/Antlr3/Grammars/DefineGrammarItemsWalker.g3 b/Antlr3/Grammars/DefineGrammarItemsWalker.g3
new file mode 100644
index 0000000..1c09e89
--- /dev/null
+++ b/Antlr3/Grammars/DefineGrammarItemsWalker.g3
@@ -0,0 +1,678 @@
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+tree grammar DefineGrammarItemsWalker;
+
+options
+{
+	language = CSharp3;
+	tokenVocab = ANTLR;
+	ASTLabelType = GrammarAST;
+}
+
+scope AttributeScopeActions
+{
+	Dictionary<GrammarAST, GrammarAST> actions;
+}
+
+@header
+{
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+using System;
+
+using Antlr3.Tool;
+using boolean = System.Boolean;
+using Character = java.lang.Character;
+using Utils = Antlr3.Misc.Utils;
+}
+
+@namespace{Antlr3.Grammars}
+
+public
+grammar_[Grammar g]
+@init
+{
+grammar = $g;
+root = $start;
+}
+@after
+{
+finish();
+}
+	:	^( LEXER_GRAMMAR	{grammar.type = Grammar.LEXER;} 		grammarSpec )
+	|	^( PARSER_GRAMMAR	{grammar.type = Grammar.PARSER;}		grammarSpec )
+	|	^( TREE_GRAMMAR		{grammar.type = Grammar.TREE_PARSER;}	grammarSpec )
+	|	^( COMBINED_GRAMMAR	{grammar.type = Grammar.COMBINED;}		grammarSpec )
+	;
+
+attrScope
+scope AttributeScopeActions;
+@init
+{
+	$AttributeScopeActions::actions = new Dictionary<GrammarAST, GrammarAST>();
+}
+	:	^( 'scope' name=ID attrScopeAction* attrs=ACTION )
+		{
+			AttributeScope scope = grammar.defineGlobalScope($name.text,$attrs.token);
+			scope.isDynamicGlobalScope = true;
+			scope.addAttributes($attrs.text, ';');
+			foreach ( var action in $AttributeScopeActions::actions )
+				scope.DefineNamedAction( action.Key, action.Value );
+		}
+	;
+
+attrScopeAction
+	:	^(AMPERSAND ID ACTION)
+		{
+			$AttributeScopeActions::actions.Add( $ID, $ACTION );
+		}
+	;
+
+grammarSpec
+	:	id=ID
+		(cmt=DOC_COMMENT)?
+		( optionsSpec )?
+		(delegateGrammars)?
+		(tokensSpec)?
+		(attrScope)*
+		(actions)?
+		rules
+	;
+
+actions
+	:	( action )+
+	;
+
+action
+@init
+{
+	string scope=null;
+	GrammarAST nameAST=null, actionAST=null;
+}
+	:	^(amp=AMPERSAND id1=ID
+			( id2=ID a1=ACTION
+			  {scope=$id1.text; nameAST=$id2; actionAST=$a1;}
+			| a2=ACTION
+			  {scope=null; nameAST=$id1; actionAST=$a2;}
+			)
+		 )
+		 {
+		 grammar.defineNamedAction($amp,scope,nameAST,actionAST);
+		 }
+	;
+
+optionsSpec
+	:	^(OPTIONS .*)
+	;
+
+delegateGrammars
+	:	^( 'import' ( ^(ASSIGN ID ID) | ID )+ )
+	;
+
+tokensSpec
+	:	^( TOKENS ( tokenSpec )+ )
+	;
+
+tokenSpec
+	:	t=TOKEN_REF
+	|	^(	ASSIGN
+			TOKEN_REF
+			(	STRING_LITERAL
+			|	CHAR_LITERAL
+			)
+		 )
+	;
+
+rules
+	:	rule+
+	;
+
+rule
+@init
+{
+	string name=null;
+	IDictionary<string,object> opts=null;
+	Rule r = null;
+}
+	:		^( RULE id=ID {opts = $RULE.BlockOptions;}
+			(modifier)?
+			^( ARG (args=ARG_ACTION)? )
+			^( RET (ret=ARG_ACTION)? )
+			(throwsSpec)?
+			(optionsSpec)?
+			{
+				name = $id.text;
+				currentRuleName = name;
+				if ( Character.isUpperCase(name[0]) && grammar.type==Grammar.COMBINED )
+				{
+					// a merged grammar spec, track lexer rules and send to another grammar
+					grammar.defineLexerRuleFoundInParser($id.token, $start);
+				}
+				else
+				{
+					int numAlts = countAltsForRule($start);
+					grammar.defineRule($id.Token, $modifier.mod, opts, $start, $args, numAlts);
+					r = grammar.getRule(name);
+					if ( $args!=null )
+					{
+						r.parameterScope = grammar.createParameterScope(name,$args.Token);
+						r.parameterScope.addAttributes($args.text, ',');
+					}
+					if ( $ret!=null )
+					{
+						r.returnScope = grammar.createReturnScope(name,$ret.token);
+						r.returnScope.addAttributes($ret.text, ',');
+					}
+					if ( $throwsSpec.exceptions != null )
+					{
+						foreach ( string exception in $throwsSpec.exceptions )
+							r.throwsSpec.Add( exception );
+					}
+				}
+			}
+			(ruleScopeSpec[r])?
+			(ruleAction[r])*
+			{ this.blockLevel=0; }
+			b=block
+			(exceptionGroup)?
+			EOR
+			{
+				// copy rule options into the block AST, which is where
+				// the analysis will look for k option etc...
+				$b.start.setBlockOptions( opts );
+			}
+		)
+	;
+
+ruleAction[Rule r]
+	:	^(amp=AMPERSAND id=ID a=ACTION ) {if (r!=null) r.defineNamedAction($amp,$id,$a);}
+	;
+
+modifier returns [string mod]
+@init
+{
+	$mod = $start.Token.Text;
+}
+	:	'protected'
+	|	'public'
+	|	'private'
+	|	'fragment'
+	;
+
+throwsSpec returns [HashSet<string> exceptions]
+@init
+{
+	$exceptions = new HashSet<string>();
+}
+	:	^('throws' (ID {$exceptions.Add($ID.text);})+ )
+	;
+
+ruleScopeSpec[Rule r]
+scope AttributeScopeActions;
+@init
+{
+	$AttributeScopeActions::actions = new Dictionary<GrammarAST, GrammarAST>();
+}
+	:	^(	'scope'
+			(	attrScopeAction* attrs=ACTION
+				{
+					r.ruleScope = grammar.createRuleScope(r.name,$attrs.token);
+					r.ruleScope.isDynamicRuleScope = true;
+					r.ruleScope.addAttributes($attrs.text, ';');
+					foreach ( var action in $AttributeScopeActions::actions )
+						r.ruleScope.DefineNamedAction( action.Key, action.Value );
+				}
+			)?
+			(	uses=ID
+				{
+					if ( grammar.getGlobalScope($uses.text)==null ) {
+					ErrorManager.grammarError(ErrorManager.MSG_UNKNOWN_DYNAMIC_SCOPE,
+					grammar,
+					$uses.token,
+					$uses.text);
+					}
+					else {
+					if ( r.useScopes==null ) {r.useScopes=new List<string>();}
+					r.useScopes.Add($uses.text);
+					}
+				}
+			)*
+		)
+	;
+
+block
+@init
+{
+	// must run during backtracking
+	this.blockLevel++;
+	if ( blockLevel == 1 )
+		this.outerAltNum=1;
+}
+	:	^(	BLOCK
+			(optionsSpec)?
+			(blockAction)*
+			(	alternative rewrite
+				{{
+					if ( this.blockLevel == 1 )
+						this.outerAltNum++;
+				}}
+			)+
+			EOB
+		 )
+	;
+finally { blockLevel--; }
+
+// TODO: this does nothing now! subrules cannot have init actions. :(
+blockAction
+	:	^(amp=AMPERSAND id=ID a=ACTION ) // {r.defineAction(#amp,#id,#a);}
+	;
+
+alternative
+@init
+{
+	if ( state.backtracking == 0 )
+	{
+		if ( grammar.type!=Grammar.LEXER && grammar.getOption("output")!=null && blockLevel==1 )
+		{
+			GrammarAST aRewriteNode = $start.findFirstType(REWRITE); // alt itself has rewrite?
+			GrammarAST rewriteAST = (GrammarAST)$start.Parent.GetChild($start.ChildIndex + 1);
+			// we have a rewrite if alt uses it inside subrule or this alt has one
+			// but don't count -> ... rewrites, which mean "do default auto construction"
+			if ( aRewriteNode!=null||
+				 (rewriteAST!=null &&
+				  rewriteAST.Type==REWRITE &&
+				  rewriteAST.GetChild(0)!=null &&
+				  rewriteAST.GetChild(0).Type!=ETC) )
+			{
+				Rule r = grammar.getRule(currentRuleName);
+				r.trackAltsWithRewrites($start,this.outerAltNum);
+			}
+		}
+	}
+}
+	:	^( ALT (element)+ EOA )
+	;
+
+exceptionGroup
+	:	( exceptionHandler )+ (finallyClause)?
+	|	finallyClause
+	;
+
+exceptionHandler
+	:   ^('catch' ARG_ACTION ACTION) {trackInlineAction($ACTION);}
+	;
+
+finallyClause
+	:    ^('finally' ACTION) {trackInlineAction($ACTION);}
+	;
+
+element
+	:   ^(ROOT element)
+	|   ^(BANG element)
+	|   atom[null]
+	|   ^(NOT element)
+	|   ^(RANGE atom[null] atom[null])
+	|   ^(CHAR_RANGE atom[null] atom[null])
+	|	^(	ASSIGN id=ID el=element)
+			{
+				GrammarAST e = $el.start;
+				if ( e.Type==ANTLRParser.ROOT || e.Type==ANTLRParser.BANG )
+				{
+					e = (GrammarAST)e.GetChild(0);
+				}
+				if ( e.Type==RULE_REF)
+				{
+					grammar.defineRuleRefLabel(currentRuleName,$id.token,e);
+				}
+				else if ( e.Type==WILDCARD && grammar.type==Grammar.TREE_PARSER )
+				{
+					grammar.defineWildcardTreeLabel(currentRuleName,$id.token,e);
+				}
+				else
+				{
+					grammar.defineTokenRefLabel(currentRuleName,$id.Token,e);
+				}
+			}
+	|	^(	PLUS_ASSIGN id2=ID a2=element
+			{
+				GrammarAST a = $a2.start;
+				if ( a.Type==ANTLRParser.ROOT || a.Type==ANTLRParser.BANG )
+				{
+					a = (GrammarAST)a.GetChild(0);
+				}
+				if ( a.Type==RULE_REF )
+				{
+					grammar.defineRuleListLabel(currentRuleName,$id2.Token,a);
+				}
+				else if ( a.Type == WILDCARD && grammar.type == Grammar.TREE_PARSER )
+				{
+					grammar.defineWildcardTreeListLabel( currentRuleName, $id2.token, a );
+				}
+				else
+				{
+					grammar.defineTokenListLabel(currentRuleName,$id2.Token,a);
+				}
+			}
+		 )
+	|   ebnf
+	|   tree_
+	|   ^( SYNPRED block )
+	|   act=ACTION
+		{
+			$act.outerAltNum = this.outerAltNum;
+			trackInlineAction($act);
+		}
+	|   act2=FORCED_ACTION
+		{
+			$act2.outerAltNum = this.outerAltNum;
+			trackInlineAction($act2);
+		}
+	|   SEMPRED
+		{
+			$SEMPRED.outerAltNum = this.outerAltNum;
+			trackInlineAction($SEMPRED);
+		}
+	|   SYN_SEMPRED
+	|   ^(BACKTRACK_SEMPRED .*)
+	|   GATED_SEMPRED
+		{
+			$GATED_SEMPRED.outerAltNum = this.outerAltNum;
+			trackInlineAction($GATED_SEMPRED);
+		}
+	|   EPSILON
+	;
+
+ebnf
+	:	(dotLoop) => dotLoop // .* or .+
+	|	block
+	|	^( OPTIONAL block )
+	|	^( CLOSURE block )
+	|	^( POSITIVE_CLOSURE block )
+	;
+
+/** Track the .* and .+ idioms and make them nongreedy by default.
+ */
+dotLoop
+	:	(	^( CLOSURE dotBlock )
+		|	^( POSITIVE_CLOSURE dotBlock )
+		)
+		{
+			GrammarAST block = (GrammarAST)$start.GetChild(0);
+			IDictionary<string, object> opts=new Dictionary<string, object>();
+			opts["greedy"] = "false";
+			if ( grammar.type!=Grammar.LEXER )
+			{
+				// parser grammars assume k=1 for .* loops
+				// otherwise they (analysis?) look til EOF!
+				opts["k"] = 1;
+			}
+			block.setOptions(grammar,opts);
+		}
+	;
+
+dotBlock
+	:	^( BLOCK ^( ALT WILDCARD EOA ) EOB )
+	;
+
+tree_
+	:	^(TREE_BEGIN element+)
+	;
+
+atom[GrammarAST scope_]
+	:	^( rr=RULE_REF (rarg=ARG_ACTION)? )
+		{
+			grammar.altReferencesRule( currentRuleName, $scope_, $rr, this.outerAltNum );
+			if ( $rarg != null )
+			{
+				$rarg.outerAltNum = this.outerAltNum;
+				trackInlineAction($rarg);
+			}
+		}
+	|	^( t=TOKEN_REF (targ=ARG_ACTION )? )
+		{
+			if ( $targ != null )
+			{
+				$targ.outerAltNum = this.outerAltNum;
+				trackInlineAction($targ);
+			}
+			if ( grammar.type == Grammar.LEXER )
+			{
+				grammar.altReferencesRule( currentRuleName, $scope_, $t, this.outerAltNum );
+			}
+			else
+			{
+				grammar.altReferencesTokenID( currentRuleName, $t, this.outerAltNum );
+			}
+		}
+	|	c=CHAR_LITERAL
+		{
+			if ( grammar.type != Grammar.LEXER )
+			{
+				Rule rule = grammar.getRule(currentRuleName);
+				if ( rule != null )
+					rule.trackTokenReferenceInAlt($c, outerAltNum);
+			}
+		}
+	|	s=STRING_LITERAL
+		{
+			if ( grammar.type != Grammar.LEXER )
+			{
+				Rule rule = grammar.getRule(currentRuleName);
+				if ( rule!=null )
+					rule.trackTokenReferenceInAlt($s, outerAltNum);
+			}
+		}
+	|	WILDCARD
+	|	^(DOT ID atom[$ID]) // scope override on rule
+	;
+
+ast_suffix
+	:	ROOT
+	|	BANG
+	;
+
+rewrite
+@init
+{
+	currentRewriteRule = $start; // has to execute during backtracking
+	if ( state.backtracking == 0 )
+	{
+		if ( grammar.BuildAST )
+			$start.rewriteRefsDeep = new HashSet<GrammarAST>();
+	}
+}
+	:	(
+			^( REWRITE (pred=SEMPRED)? rewrite_alternative )
+			{
+				if ( $pred != null )
+				{
+					$pred.outerAltNum = this.outerAltNum;
+					trackInlineAction($pred);
+				}
+			}
+		)*
+		//{System.out.println("-> refs = "+#rewrite.rewriteRefs);}
+	;
+
+rewrite_block
+@init
+{
+	GrammarAST enclosingBlock = currentRewriteBlock;
+	if ( state.backtracking == 0 )
+	{
+		// don't do if guessing
+		currentRewriteBlock=$start; // pts to BLOCK node
+		currentRewriteBlock.rewriteRefsShallow = new HashSet<GrammarAST>();
+		currentRewriteBlock.rewriteRefsDeep = new HashSet<GrammarAST>();
+	}
+}
+	:   ^( BLOCK rewrite_alternative EOB )
+		//{System.out.println("atoms="+currentRewriteBlock.rewriteRefs);}
+		{
+			// copy the element refs in this block to the surrounding block
+			if ( enclosingBlock != null )
+			{
+				foreach ( var item in currentRewriteBlock.rewriteRefsShallow )
+					enclosingBlock.rewriteRefsDeep.Add( item );
+			}
+			//currentRewriteBlock = enclosingBlock; // restore old BLOCK ptr
+		}
+	;
+finally { currentRewriteBlock = enclosingBlock; }
+
+rewrite_alternative
+	:	{grammar.BuildAST}? => ^( a=ALT ( ( rewrite_element )+ | EPSILON ) EOA )
+	|	{grammar.BuildTemplate}? => rewrite_template
+	|	ETC {this.blockLevel==1}? // only valid as outermost rewrite
+	;
+
+rewrite_element
+	:	rewrite_atom
+	|	rewrite_ebnf
+	|	rewrite_tree
+	;
+
+rewrite_ebnf
+	:	^( OPTIONAL rewrite_block )
+	|	^( CLOSURE rewrite_block )
+	|	^( POSITIVE_CLOSURE rewrite_block )
+	;
+
+rewrite_tree
+	:   ^(	TREE_BEGIN rewrite_atom ( rewrite_element )* )
+	;
+
+rewrite_atom
+@init
+{
+	if ( state.backtracking == 0 )
+	{
+		Rule r = grammar.getRule(currentRuleName);
+		var tokenRefsInAlt = r.getTokenRefsInAlt(outerAltNum);
+		boolean imaginary =
+			$start.Type==TOKEN_REF &&
+			!tokenRefsInAlt.Contains($start.Text);
+		if ( !imaginary && grammar.BuildAST &&
+			 ($start.Type==RULE_REF ||
+			  $start.Type==LABEL ||
+			  $start.Type==TOKEN_REF ||
+			  $start.Type==CHAR_LITERAL ||
+			  $start.Type==STRING_LITERAL) )
+		{
+			// track per block and for entire rewrite rule
+			if ( currentRewriteBlock!=null )
+			{
+				currentRewriteBlock.rewriteRefsShallow.Add($start);
+				currentRewriteBlock.rewriteRefsDeep.Add($start);
+			}
+			currentRewriteRule.rewriteRefsDeep.Add($start);
+		}
+	}
+}
+	:	RULE_REF
+	|	(	^(	TOKEN_REF
+				(	ARG_ACTION
+					{
+						$ARG_ACTION.outerAltNum = this.outerAltNum;
+						trackInlineAction($ARG_ACTION);
+					}
+				)?
+			)
+		|	CHAR_LITERAL
+		|	STRING_LITERAL
+		)
+	|	LABEL
+	|	ACTION
+		{
+			$ACTION.outerAltNum = this.outerAltNum;
+			trackInlineAction($ACTION);
+		}
+	;
+
+rewrite_template
+	:	^(	ALT EPSILON EOA )
+	|	^(	TEMPLATE (id=ID|ind=ACTION)
+			^( ARGLIST
+				(	^( ARG arg=ID a=ACTION )
+					{
+						$a.outerAltNum = this.outerAltNum;
+						trackInlineAction($a);
+					}
+				)*
+			)
+			{
+				if ( $ind!=null )
+				{
+					$ind.outerAltNum = this.outerAltNum;
+					trackInlineAction($ind);
+				}
+			}
+			(	DOUBLE_QUOTE_STRING_LITERAL
+			|	DOUBLE_ANGLE_STRING_LITERAL
+			)?
+		)
+	|	act=ACTION
+		{
+			$act.outerAltNum = this.outerAltNum;
+			trackInlineAction($act);
+		}
+	;
diff --git a/Antlr3/Grammars/DefineGrammarItemsWalkerHelper.cs b/Antlr3/Grammars/DefineGrammarItemsWalkerHelper.cs
new file mode 100644
index 0000000..4560706
--- /dev/null
+++ b/Antlr3/Grammars/DefineGrammarItemsWalkerHelper.cs
@@ -0,0 +1,113 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Grammar conversion to ANTLR v3 and C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *	notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	notice, this list of conditions and the following disclaimer in the
+ *	documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *	derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Grammars
+{
+    using System;
+    using Antlr.Runtime.JavaExtensions;
+    using Antlr.Runtime.Tree;
+    using Antlr3.Tool;
+
+    partial class DefineGrammarItemsWalker
+    {
+        protected Grammar grammar;
+        protected GrammarAST root;
+        protected String currentRuleName;
+        protected GrammarAST currentRewriteBlock;
+        protected GrammarAST currentRewriteRule;
+        protected int outerAltNum = 0;
+        protected int blockLevel = 0;
+
+        public int countAltsForRule( CommonTree t )
+        {
+            return CountNodes( ALT, t );
+        }
+        int CountNodes( int nodeType, CommonTree tree )
+        {
+            int i = ( tree.Type == nodeType ) ? 1 : 0;
+
+            var children = tree.Children;
+            if ( children != null )
+            {
+                foreach ( CommonTree child in children )
+                    i += CountNodes( nodeType, child );
+            }
+
+            return i;
+        }
+
+        protected void finish()
+        {
+            trimGrammar();
+        }
+
+        /** Remove any lexer rules from a COMBINED; already passed to lexer */
+        protected void trimGrammar()
+        {
+            if ( grammar.type != Grammar.COMBINED )
+            {
+                return;
+            }
+            // form is (header ... ) ( grammar ID (scope ...) ... ( rule ... ) ( rule ... ) ... )
+            GrammarAST p = root;
+            // find the grammar spec
+            while ( !p.Text.Equals( "grammar" ) )
+            {
+                p = (GrammarAST)p.getNextSibling();
+            }
+            for ( int i = 0; i < p.ChildCount; i++ )
+            {
+                if ( p.GetChild( i ).Type != RULE )
+                    continue;
+
+                string ruleName = p.GetChild( i ).GetChild( 0 ).Text;
+                //System.out.println("rule "+ruleName+" prev="+prev.getText());
+                if ( char.IsUpper( ruleName[0] ) )
+                {
+                    // remove lexer rule
+                    p.DeleteChild( i );
+                    i--;
+                }
+            }
+            //System.out.println("root after removal is: "+root.toStringList());
+        }
+
+        protected void trackInlineAction( GrammarAST actionAST )
+        {
+            Rule r = grammar.getRule( currentRuleName );
+            if ( r != null )
+            {
+                r.trackInlineAction( actionAST );
+            }
+        }
+    }
+}
diff --git a/Antlr3/Grammars/TreeToNFAConverter.cs b/Antlr3/Grammars/TreeToNFAConverter.cs
new file mode 100644
index 0000000..7fd9629
--- /dev/null
+++ b/Antlr3/Grammars/TreeToNFAConverter.cs
@@ -0,0 +1,5025 @@
+// $ANTLR 3.1.2 Grammars\\TreeToNFAConverter.g3 2009-03-08 16:36:57
+
+// The variable 'variable' is assigned but its value is never used.
+#pragma warning disable 219
+// Unreachable code detected.
+#pragma warning disable 162
+
+
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+using Antlr3.Analysis;
+using Antlr3.Misc;
+using Antlr3.Tool;
+
+using BitSet = Antlr.Runtime.BitSet;
+using DFA = Antlr.Runtime.DFA;
+
+
+using System.Collections.Generic;
+using Antlr.Runtime;
+using Antlr.Runtime.Tree;
+using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;using Stack = System.Collections.Generic.Stack<object>;
+using List = System.Collections.IList;
+using ArrayList = System.Collections.Generic.List<object>;
+
+namespace Antlr3.Grammars
+{
+/** Build an NFA from a tree representing an ANTLR grammar. */
+public partial class TreeToNFAConverter : TreeParser
+{
+	public static readonly string[] tokenNames = new string[] {
+		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", "ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARG_ACTION", "ARGLIST", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", "CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", "COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", "DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", "EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", "GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", "LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", "NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", "OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", "RET", "RETURNS", "REWRITE", "ROOT", "RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", "SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYN_SEMPRED", "SYNPRED", "TEMPLATE", "THROWS", "TOKEN_REF", "TOKENS", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", "WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT"
+	};
+	public const int EOF=-1;
+	public const int ACTION=4;
+	public const int ACTION_CHAR_LITERAL=5;
+	public const int ACTION_ESC=6;
+	public const int ACTION_STRING_LITERAL=7;
+	public const int ALT=8;
+	public const int AMPERSAND=9;
+	public const int ARG=10;
+	public const int ARG_ACTION=11;
+	public const int ARGLIST=12;
+	public const int ASSIGN=13;
+	public const int BACKTRACK_SEMPRED=14;
+	public const int BANG=15;
+	public const int BLOCK=16;
+	public const int CATCH=17;
+	public const int CHAR_LITERAL=18;
+	public const int CHAR_RANGE=19;
+	public const int CLOSE_ELEMENT_OPTION=20;
+	public const int CLOSURE=21;
+	public const int COLON=22;
+	public const int COMBINED_GRAMMAR=23;
+	public const int COMMA=24;
+	public const int COMMENT=25;
+	public const int DIGIT=26;
+	public const int DOC_COMMENT=27;
+	public const int DOLLAR=28;
+	public const int DOT=29;
+	public const int DOUBLE_ANGLE_STRING_LITERAL=30;
+	public const int DOUBLE_QUOTE_STRING_LITERAL=31;
+	public const int EOA=32;
+	public const int EOB=33;
+	public const int EOR=34;
+	public const int EPSILON=35;
+	public const int ESC=36;
+	public const int ETC=37;
+	public const int FINALLY=38;
+	public const int FORCED_ACTION=39;
+	public const int FRAGMENT=40;
+	public const int GATED_SEMPRED=41;
+	public const int GRAMMAR=42;
+	public const int ID=43;
+	public const int IMPLIES=44;
+	public const int IMPORT=45;
+	public const int INITACTION=46;
+	public const int INT=47;
+	public const int LABEL=48;
+	public const int LEXER=49;
+	public const int LEXER_GRAMMAR=50;
+	public const int LPAREN=51;
+	public const int ML_COMMENT=52;
+	public const int NESTED_ACTION=53;
+	public const int NESTED_ARG_ACTION=54;
+	public const int NOT=55;
+	public const int OPEN_ELEMENT_OPTION=56;
+	public const int OPTIONAL=57;
+	public const int OPTIONS=58;
+	public const int OR=59;
+	public const int PARSER=60;
+	public const int PARSER_GRAMMAR=61;
+	public const int PLUS=62;
+	public const int PLUS_ASSIGN=63;
+	public const int POSITIVE_CLOSURE=64;
+	public const int PRIVATE=65;
+	public const int PROTECTED=66;
+	public const int PUBLIC=67;
+	public const int QUESTION=68;
+	public const int RANGE=69;
+	public const int RCURLY=70;
+	public const int RET=71;
+	public const int RETURNS=72;
+	public const int REWRITE=73;
+	public const int ROOT=74;
+	public const int RPAREN=75;
+	public const int RULE=76;
+	public const int RULE_REF=77;
+	public const int SCOPE=78;
+	public const int SEMI=79;
+	public const int SEMPRED=80;
+	public const int SL_COMMENT=81;
+	public const int SRC=82;
+	public const int STAR=83;
+	public const int STRAY_BRACKET=84;
+	public const int STRING_LITERAL=85;
+	public const int SYN_SEMPRED=86;
+	public const int SYNPRED=87;
+	public const int TEMPLATE=88;
+	public const int THROWS=89;
+	public const int TOKEN_REF=90;
+	public const int TOKENS=91;
+	public const int TREE=92;
+	public const int TREE_BEGIN=93;
+	public const int TREE_GRAMMAR=94;
+	public const int WILDCARD=95;
+	public const int WS=96;
+	public const int WS_LOOP=97;
+	public const int WS_OPT=98;
+	public const int XDIGIT=99;
+
+	// delegates
+	// delegators
+
+	public TreeToNFAConverter( ITreeNodeStream input )
+		: this( input, new RecognizerSharedState() )
+	{
+	}
+	public TreeToNFAConverter( ITreeNodeStream input, RecognizerSharedState state )
+		: base( input, state )
+	{
+	}
+
+
+	public override string[] GetTokenNames() { return TreeToNFAConverter.tokenNames; }
+	public override string GrammarFileName { get { return "Grammars\\TreeToNFAConverter.g3"; } }
+
+
+	#region Rules
+
+	// $ANTLR start "grammar_"
+	// Grammars\\TreeToNFAConverter.g3:88:0: public grammar_ : ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) ) ;
+	public void grammar_(  )
+	{
+		try
+		{
+			// Grammars\\TreeToNFAConverter.g3:93:4: ( ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) ) )
+			// Grammars\\TreeToNFAConverter.g3:93:4: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
+			{
+			// Grammars\\TreeToNFAConverter.g3:93:4: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
+			int alt1=4;
+			switch ( input.LA(1) )
+			{
+			case LEXER_GRAMMAR:
+				{
+				alt1=1;
+				}
+				break;
+			case PARSER_GRAMMAR:
+				{
+				alt1=2;
+				}
+				break;
+			case TREE_GRAMMAR:
+				{
+				alt1=3;
+				}
+				break;
+			case COMBINED_GRAMMAR:
+				{
+				alt1=4;
+				}
+				break;
+			default:
+				{
+					NoViableAltException nvae = new NoViableAltException("", 1, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt1 )
+			{
+			case 1:
+				// Grammars\\TreeToNFAConverter.g3:93:6: ^( LEXER_GRAMMAR grammarSpec )
+				{
+				Match(input,LEXER_GRAMMAR,Follow._LEXER_GRAMMAR_in_grammar_67);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._grammarSpec_in_grammar_69);
+				grammarSpec();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 2:
+				// Grammars\\TreeToNFAConverter.g3:94:5: ^( PARSER_GRAMMAR grammarSpec )
+				{
+				Match(input,PARSER_GRAMMAR,Follow._PARSER_GRAMMAR_in_grammar_79);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._grammarSpec_in_grammar_81);
+				grammarSpec();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 3:
+				// Grammars\\TreeToNFAConverter.g3:95:5: ^( TREE_GRAMMAR grammarSpec )
+				{
+				Match(input,TREE_GRAMMAR,Follow._TREE_GRAMMAR_in_grammar_91);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._grammarSpec_in_grammar_93);
+				grammarSpec();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 4:
+				// Grammars\\TreeToNFAConverter.g3:96:5: ^( COMBINED_GRAMMAR grammarSpec )
+				{
+				Match(input,COMBINED_GRAMMAR,Follow._COMBINED_GRAMMAR_in_grammar_103);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._grammarSpec_in_grammar_105);
+				grammarSpec();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+
+			}
+
+
+			}
+
+
+				finish();
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "grammar_"
+
+
+	// $ANTLR start "attrScope"
+	// Grammars\\TreeToNFAConverter.g3:100:0: attrScope : ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION ) ;
+	private void attrScope(  )
+	{
+		try
+		{
+			// Grammars\\TreeToNFAConverter.g3:101:4: ( ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION ) )
+			// Grammars\\TreeToNFAConverter.g3:101:4: ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION )
+			{
+			Match(input,SCOPE,Follow._SCOPE_in_attrScope124);
+
+			Match(input, TokenConstants.DOWN, null);
+			Match(input,ID,Follow._ID_in_attrScope126);
+			// Grammars\\TreeToNFAConverter.g3:101:18: ( ^( AMPERSAND ( . )* ) )*
+			for ( ; ; )
+			{
+				int alt3=2;
+				int LA3_0 = input.LA(1);
+
+				if ( (LA3_0==AMPERSAND) )
+				{
+					alt3=1;
+				}
+
+
+				switch ( alt3 )
+				{
+				case 1:
+					// Grammars\\TreeToNFAConverter.g3:101:20: ^( AMPERSAND ( . )* )
+					{
+					Match(input,AMPERSAND,Follow._AMPERSAND_in_attrScope131);
+
+					if ( input.LA(1)==TokenConstants.DOWN )
+					{
+						Match(input, TokenConstants.DOWN, null);
+						// Grammars\\TreeToNFAConverter.g3:101:32: ( . )*
+						for ( ; ; )
+						{
+							int alt2=2;
+							int LA2_0 = input.LA(1);
+
+							if ( ((LA2_0>=ACTION && LA2_0<=XDIGIT)) )
+							{
+								alt2=1;
+							}
+							else if ( (LA2_0==UP) )
+							{
+								alt2=2;
+							}
+
+
+							switch ( alt2 )
+							{
+							case 1:
+								// Grammars\\TreeToNFAConverter.g3:101:0: .
+								{
+								MatchAny(input);
+
+								}
+								break;
+
+							default:
+								goto loop2;
+							}
+						}
+
+						loop2:
+							;
+
+
+
+						Match(input, TokenConstants.UP, null);
+					}
+
+					}
+					break;
+
+				default:
+					goto loop3;
+				}
+			}
+
+			loop3:
+				;
+
+
+			Match(input,ACTION,Follow._ACTION_in_attrScope140);
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "attrScope"
+
+
+	// $ANTLR start "grammarSpec"
+	// Grammars\\TreeToNFAConverter.g3:104:0: grammarSpec : ID (cmt= DOC_COMMENT )? ( ^( OPTIONS ( . )* ) )? ( ^( IMPORT ( . )* ) )? ( ^( TOKENS ( . )* ) )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules ;
+	private void grammarSpec(  )
+	{
+		GrammarAST cmt=null;
+
+		try
+		{
+			// Grammars\\TreeToNFAConverter.g3:105:4: ( ID (cmt= DOC_COMMENT )? ( ^( OPTIONS ( . )* ) )? ( ^( IMPORT ( . )* ) )? ( ^( TOKENS ( . )* ) )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules )
+			// Grammars\\TreeToNFAConverter.g3:105:4: ID (cmt= DOC_COMMENT )? ( ^( OPTIONS ( . )* ) )? ( ^( IMPORT ( . )* ) )? ( ^( TOKENS ( . )* ) )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules
+			{
+			Match(input,ID,Follow._ID_in_grammarSpec153);
+			// Grammars\\TreeToNFAConverter.g3:106:3: (cmt= DOC_COMMENT )?
+			int alt4=2;
+			int LA4_0 = input.LA(1);
+
+			if ( (LA4_0==DOC_COMMENT) )
+			{
+				alt4=1;
+			}
+			switch ( alt4 )
+			{
+			case 1:
+				// Grammars\\TreeToNFAConverter.g3:106:4: cmt= DOC_COMMENT
+				{
+				cmt=(GrammarAST)Match(input,DOC_COMMENT,Follow._DOC_COMMENT_in_grammarSpec160);
+
+				}
+				break;
+
+			}
+
+			// Grammars\\TreeToNFAConverter.g3:107:3: ( ^( OPTIONS ( . )* ) )?
+			int alt6=2;
+			int LA6_0 = input.LA(1);
+
+			if ( (LA6_0==OPTIONS) )
+			{
+				alt6=1;
+			}
+			switch ( alt6 )
+			{
+			case 1:
+				// Grammars\\TreeToNFAConverter.g3:107:5: ^( OPTIONS ( . )* )
+				{
+				Match(input,OPTIONS,Follow._OPTIONS_in_grammarSpec169);
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null);
+					// Grammars\\TreeToNFAConverter.g3:107:15: ( . )*
+					for ( ; ; )
+					{
+						int alt5=2;
+						int LA5_0 = input.LA(1);
+
+						if ( ((LA5_0>=ACTION && LA5_0<=XDIGIT)) )
+						{
+							alt5=1;
+						}
+						else if ( (LA5_0==UP) )
+						{
+							alt5=2;
+						}
+
+
+						switch ( alt5 )
+						{
+						case 1:
+							// Grammars\\TreeToNFAConverter.g3:107:0: .
+							{
+							MatchAny(input);
+
+							}
+							break;
+
+						default:
+							goto loop5;
+						}
+					}
+
+					loop5:
+						;
+
+
+
+					Match(input, TokenConstants.UP, null);
+				}
+
+				}
+				break;
+
+			}
+
+			// Grammars\\TreeToNFAConverter.g3:108:3: ( ^( IMPORT ( . )* ) )?
+			int alt8=2;
+			int LA8_0 = input.LA(1);
+
+			if ( (LA8_0==IMPORT) )
+			{
+				alt8=1;
+			}
+			switch ( alt8 )
+			{
+			case 1:
+				// Grammars\\TreeToNFAConverter.g3:108:5: ^( IMPORT ( . )* )
+				{
+				Match(input,IMPORT,Follow._IMPORT_in_grammarSpec183);
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null);
+					// Grammars\\TreeToNFAConverter.g3:108:14: ( . )*
+					for ( ; ; )
+					{
+						int alt7=2;
+						int LA7_0 = input.LA(1);
+
+						if ( ((LA7_0>=ACTION && LA7_0<=XDIGIT)) )
+						{
+							alt7=1;
+						}
+						else if ( (LA7_0==UP) )
+						{
+							alt7=2;
+						}
+
+
+						switch ( alt7 )
+						{
+						case 1:
+							// Grammars\\TreeToNFAConverter.g3:108:0: .
+							{
+							MatchAny(input);
+
+							}
+							break;
+
+						default:
+							goto loop7;
+						}
+					}
+
+					loop7:
+						;
+
+
+
+					Match(input, TokenConstants.UP, null);
+				}
+
+				}
+				break;
+
+			}
+
+			// Grammars\\TreeToNFAConverter.g3:109:3: ( ^( TOKENS ( . )* ) )?
+			int alt10=2;
+			int LA10_0 = input.LA(1);
+
+			if ( (LA10_0==TOKENS) )
+			{
+				alt10=1;
+			}
+			switch ( alt10 )
+			{
+			case 1:
+				// Grammars\\TreeToNFAConverter.g3:109:5: ^( TOKENS ( . )* )
+				{
+				Match(input,TOKENS,Follow._TOKENS_in_grammarSpec197);
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null);
+					// Grammars\\TreeToNFAConverter.g3:109:14: ( . )*
+					for ( ; ; )
+					{
+						int alt9=2;
+						int LA9_0 = input.LA(1);
+
+						if ( ((LA9_0>=ACTION && LA9_0<=XDIGIT)) )
+						{
+							alt9=1;
+						}
+						else if ( (LA9_0==UP) )
+						{
+							alt9=2;
+						}
+
+
+						switch ( alt9 )
+						{
+						case 1:
+							// Grammars\\TreeToNFAConverter.g3:109:0: .
+							{
+							MatchAny(input);
+
+							}
+							break;
+
+						default:
+							goto loop9;
+						}
+					}
+
+					loop9:
+						;
+
+
+
+					Match(input, TokenConstants.UP, null);
+				}
+
+				}
+				break;
+
+			}
+
+			// Grammars\\TreeToNFAConverter.g3:110:3: ( attrScope )*
+			for ( ; ; )
+			{
+				int alt11=2;
+				int LA11_0 = input.LA(1);
+
+				if ( (LA11_0==SCOPE) )
+				{
+					alt11=1;
+				}
+
+
+				switch ( alt11 )
+				{
+				case 1:
+					// Grammars\\TreeToNFAConverter.g3:110:4: attrScope
+					{
+					PushFollow(Follow._attrScope_in_grammarSpec209);
+					attrScope();
+
+					state._fsp--;
+
+
+					}
+					break;
+
+				default:
+					goto loop11;
+				}
+			}
+
+			loop11:
+				;
+
+
+			// Grammars\\TreeToNFAConverter.g3:111:3: ( ^( AMPERSAND ( . )* ) )*
+			for ( ; ; )
+			{
+				int alt13=2;
+				int LA13_0 = input.LA(1);
+
+				if ( (LA13_0==AMPERSAND) )
+				{
+					alt13=1;
+				}
+
+
+				switch ( alt13 )
+				{
+				case 1:
+					// Grammars\\TreeToNFAConverter.g3:111:5: ^( AMPERSAND ( . )* )
+					{
+					Match(input,AMPERSAND,Follow._AMPERSAND_in_grammarSpec218);
+
+					if ( input.LA(1)==TokenConstants.DOWN )
+					{
+						Match(input, TokenConstants.DOWN, null);
+						// Grammars\\TreeToNFAConverter.g3:111:17: ( . )*
+						for ( ; ; )
+						{
+							int alt12=2;
+							int LA12_0 = input.LA(1);
+
+							if ( ((LA12_0>=ACTION && LA12_0<=XDIGIT)) )
+							{
+								alt12=1;
+							}
+							else if ( (LA12_0==UP) )
+							{
+								alt12=2;
+							}
+
+
+							switch ( alt12 )
+							{
+							case 1:
+								// Grammars\\TreeToNFAConverter.g3:111:0: .
+								{
+								MatchAny(input);
+
+								}
+								break;
+
+							default:
+								goto loop12;
+							}
+						}
+
+						loop12:
+							;
+
+
+
+						Match(input, TokenConstants.UP, null);
+					}
+
+					}
+					break;
+
+				default:
+					goto loop13;
+				}
+			}
+
+			loop13:
+				;
+
+
+			PushFollow(Follow._rules_in_grammarSpec230);
+			rules();
+
+			state._fsp--;
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "grammarSpec"
+
+
+	// $ANTLR start "rules"
+	// Grammars\\TreeToNFAConverter.g3:115:0: rules : ( rule )+ ;
+	private void rules(  )
+	{
+		try
+		{
+			// Grammars\\TreeToNFAConverter.g3:116:4: ( ( rule )+ )
+			// Grammars\\TreeToNFAConverter.g3:116:4: ( rule )+
+			{
+			// Grammars\\TreeToNFAConverter.g3:116:4: ( rule )+
+			int cnt14=0;
+			for ( ; ; )
+			{
+				int alt14=2;
+				int LA14_0 = input.LA(1);
+
+				if ( (LA14_0==RULE) )
+				{
+					alt14=1;
+				}
+
+
+				switch ( alt14 )
+				{
+				case 1:
+					// Grammars\\TreeToNFAConverter.g3:116:0: rule
+					{
+					PushFollow(Follow._rule_in_rules241);
+					rule();
+
+					state._fsp--;
+
+
+					}
+					break;
+
+				default:
+					if ( cnt14 >= 1 )
+						goto loop14;
+
+					EarlyExitException eee14 = new EarlyExitException( 14, input );
+					throw eee14;
+				}
+				cnt14++;
+			}
+			loop14:
+				;
+
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "rules"
+
+	public class rule_return : TreeRuleReturnScope
+	{
+	}
+
+	// $ANTLR start "rule"
+	// Grammars\\TreeToNFAConverter.g3:119:0: rule : ^( RULE id= ID ( modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block ( exceptionGroup )? EOR ) ;
+	private TreeToNFAConverter.rule_return rule(  )
+	{
+		TreeToNFAConverter.rule_return retval = new TreeToNFAConverter.rule_return();
+		retval.start = input.LT(1);
+
+		GrammarAST id=null;
+		TreeToNFAConverter.block_return b = default(TreeToNFAConverter.block_return);
+
+		try
+		{
+			// Grammars\\TreeToNFAConverter.g3:120:4: ( ^( RULE id= ID ( modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block ( exceptionGroup )? EOR ) )
+			// Grammars\\TreeToNFAConverter.g3:120:4: ^( RULE id= ID ( modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block ( exceptionGroup )? EOR )
+			{
+			Match(input,RULE,Follow._RULE_in_rule255);
+
+			Match(input, TokenConstants.DOWN, null);
+			id=(GrammarAST)Match(input,ID,Follow._ID_in_rule259);
+
+							currentRuleName = (id!=null?id.Text:null);
+							factory.setCurrentRule( grammar.getLocallyDefinedRule(currentRuleName) );
+
+			// Grammars\\TreeToNFAConverter.g3:125:4: ( modifier )?
+			int alt15=2;
+			int LA15_0 = input.LA(1);
+
+			if ( (LA15_0==FRAGMENT||(LA15_0>=PRIVATE && LA15_0<=PUBLIC)) )
+			{
+				alt15=1;
+			}
+			switch ( alt15 )
+			{
+			case 1:
+				// Grammars\\TreeToNFAConverter.g3:125:5: modifier
+				{
+				PushFollow(Follow._modifier_in_rule270);
+				modifier();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			Match(input,ARG,Follow._ARG_in_rule278);
+
+			if ( input.LA(1)==TokenConstants.DOWN )
+			{
+				Match(input, TokenConstants.DOWN, null);
+				// Grammars\\TreeToNFAConverter.g3:126:10: ( ARG_ACTION )?
+				int alt16=2;
+				int LA16_0 = input.LA(1);
+
+				if ( (LA16_0==ARG_ACTION) )
+				{
+					alt16=1;
+				}
+				switch ( alt16 )
+				{
+				case 1:
+					// Grammars\\TreeToNFAConverter.g3:126:11: ARG_ACTION
+					{
+					Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule281);
+
+					}
+					break;
+
+				}
+
+
+				Match(input, TokenConstants.UP, null);
+			}
+			Match(input,RET,Follow._RET_in_rule290);
+
+			if ( input.LA(1)==TokenConstants.DOWN )
+			{
+				Match(input, TokenConstants.DOWN, null);
+				// Grammars\\TreeToNFAConverter.g3:127:10: ( ARG_ACTION )?
+				int alt17=2;
+				int LA17_0 = input.LA(1);
+
+				if ( (LA17_0==ARG_ACTION) )
+				{
+					alt17=1;
+				}
+				switch ( alt17 )
+				{
+				case 1:
+					// Grammars\\TreeToNFAConverter.g3:127:11: ARG_ACTION
+					{
+					Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule293);
+
+					}
+					break;
+
+				}
+
+
+				Match(input, TokenConstants.UP, null);
+			}
+			// Grammars\\TreeToNFAConverter.g3:128:4: ( throwsSpec )?
+			int alt18=2;
+			int LA18_0 = input.LA(1);
+
+			if ( (LA18_0==THROWS) )
+			{
+				alt18=1;
+			}
+			switch ( alt18 )
+			{
+			case 1:
+				// Grammars\\TreeToNFAConverter.g3:128:5: throwsSpec
+				{
+				PushFollow(Follow._throwsSpec_in_rule302);
+				throwsSpec();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			// Grammars\\TreeToNFAConverter.g3:129:4: ( ^( OPTIONS ( . )* ) )?
+			int alt20=2;
+			int LA20_0 = input.LA(1);
+
+			if ( (LA20_0==OPTIONS) )
+			{
+				alt20=1;
+			}
+			switch ( alt20 )
+			{
+			case 1:
+				// Grammars\\TreeToNFAConverter.g3:129:6: ^( OPTIONS ( . )* )
+				{
+				Match(input,OPTIONS,Follow._OPTIONS_in_rule312);
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null);
+					// Grammars\\TreeToNFAConverter.g3:129:16: ( . )*
+					for ( ; ; )
+					{
+						int alt19=2;
+						int LA19_0 = input.LA(1);
+
+						if ( ((LA19_0>=ACTION && LA19_0<=XDIGIT)) )
+						{
+							alt19=1;
+						}
+						else if ( (LA19_0==UP) )
+						{
+							alt19=2;
+						}
+
+
+						switch ( alt19 )
+						{
+						case 1:
+							// Grammars\\TreeToNFAConverter.g3:129:0: .
+							{
+							MatchAny(input);
+
+							}
+							break;
+
+						default:
+							goto loop19;
+						}
+					}
+
+					loop19:
+						;
+
+
+
+					Match(input, TokenConstants.UP, null);
+				}
+
+				}
+				break;
+
+			}
+
+			// Grammars\\TreeToNFAConverter.g3:130:4: ( ruleScopeSpec )?
+			int alt21=2;
+			int LA21_0 = input.LA(1);
+
+			if ( (LA21_0==SCOPE) )
+			{
+				alt21=1;
+			}
+			switch ( alt21 )
+			{
+			case 1:
+				// Grammars\\TreeToNFAConverter.g3:130:6: ruleScopeSpec
+				{
+				PushFollow(Follow._ruleScopeSpec_in_rule326);
+				ruleScopeSpec();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			// Grammars\\TreeToNFAConverter.g3:131:4: ( ^( AMPERSAND ( . )* ) )*
+			for ( ; ; )
+			{
+				int alt23=2;
+				int LA23_0 = input.LA(1);
+
+				if ( (LA23_0==AMPERSAND) )
+				{
+					alt23=1;
+				}
+
+
+				switch ( alt23 )
+				{
+				case 1:
+					// Grammars\\TreeToNFAConverter.g3:131:6: ^( AMPERSAND ( . )* )
+					{
+					Match(input,AMPERSAND,Follow._AMPERSAND_in_rule337);
+
+					if ( input.LA(1)==TokenConstants.DOWN )
+					{
+						Match(input, TokenConstants.DOWN, null);
+						// Grammars\\TreeToNFAConverter.g3:131:18: ( . )*
+						for ( ; ; )
+						{
+							int alt22=2;
+							int LA22_0 = input.LA(1);
+
+							if ( ((LA22_0>=ACTION && LA22_0<=XDIGIT)) )
+							{
+								alt22=1;
+							}
+							else if ( (LA22_0==UP) )
+							{
+								alt22=2;
+							}
+
+
+							switch ( alt22 )
+							{
+							case 1:
+								// Grammars\\TreeToNFAConverter.g3:131:0: .
+								{
+								MatchAny(input);
+
+								}
+								break;
+
+							default:
+								goto loop22;
+							}
+						}
+
+						loop22:
+							;
+
+
+
+						Match(input, TokenConstants.UP, null);
+					}
+
+					}
+					break;
+
+				default:
+					goto loop23;
+				}
+			}
+
+			loop23:
+				;
+
+
+			PushFollow(Follow._block_in_rule351);
+			b=block();
+
+			state._fsp--;
+
+			// Grammars\\TreeToNFAConverter.g3:133:4: ( exceptionGroup )?
+			int alt24=2;
+			int LA24_0 = input.LA(1);
+
+			if ( (LA24_0==CATCH||LA24_0==FINALLY) )
+			{
+				alt24=1;
+			}
+			switch ( alt24 )
+			{
+			case 1:
+				// Grammars\\TreeToNFAConverter.g3:133:5: exceptionGroup
+				{
+				PushFollow(Follow._exceptionGroup_in_rule357);
+				exceptionGroup();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			Match(input,EOR,Follow._EOR_in_rule364);
+
+							StateCluster g = (b!=null?b.g:default(StateCluster));
+							if ( (b!=null?((GrammarAST)b.start):null).SetValue!=null )
+							{
+								// if block comes back as a set not BLOCK, make it
+								// a single ALT block
+								g = factory.build_AlternativeBlockFromSet(g);
+							}
+							if ( char.IsLower(currentRuleName[0]) ||
+								 grammar.type==Grammar.LEXER )
+							{
+								// attach start node to block for this rule
+								Rule thisR = grammar.getLocallyDefinedRule(currentRuleName);
+								NFAState start = thisR.startState;
+								start.associatedASTNode = id;
+								start.addTransition(new Transition(Label.EPSILON, g.left));
+
+								// track decision if > 1 alts
+								if ( grammar.getNumberOfAltsForDecisionNFA(g.left)>1 )
+								{
+									g.left.Description = grammar.grammarTreeToString(((GrammarAST)retval.start),false);
+									g.left.setDecisionASTNode((b!=null?((GrammarAST)b.start):null));
+									int d = grammar.assignDecisionNumber( g.left );
+									grammar.setDecisionNFA( d, g.left );
+									grammar.setDecisionBlockAST(d, (b!=null?((GrammarAST)b.start):null));
+								}
+
+								// hook to end of rule node
+								NFAState end = thisR.stopState;
+								g.right.addTransition(new Transition(Label.EPSILON,end));
+							}
+
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "rule"
+
+
+	// $ANTLR start "modifier"
+	// Grammars\\TreeToNFAConverter.g3:170:0: modifier : ( 'protected' | 'public' | 'private' | 'fragment' );
+	private void modifier(  )
+	{
+		try
+		{
+			// Grammars\\TreeToNFAConverter.g3:171:4: ( 'protected' | 'public' | 'private' | 'fragment' )
+			// Grammars\\TreeToNFAConverter.g3:
+			{
+			if ( input.LA(1)==FRAGMENT||(input.LA(1)>=PRIVATE && input.LA(1)<=PUBLIC) )
+			{
+				input.Consume();
+				state.errorRecovery=false;
+			}
+			else
+			{
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				throw mse;
+			}
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "modifier"
+
+
+	// $ANTLR start "throwsSpec"
+	// Grammars\\TreeToNFAConverter.g3:177:0: throwsSpec : ^( 'throws' ( ID )+ ) ;
+	private void throwsSpec(  )
+	{
+		try
+		{
+			// Grammars\\TreeToNFAConverter.g3:178:4: ( ^( 'throws' ( ID )+ ) )
+			// Grammars\\TreeToNFAConverter.g3:178:4: ^( 'throws' ( ID )+ )
+			{
+			Match(input,THROWS,Follow._THROWS_in_throwsSpec411);
+
+			Match(input, TokenConstants.DOWN, null);
+			// Grammars\\TreeToNFAConverter.g3:178:15: ( ID )+
+			int cnt25=0;
+			for ( ; ; )
+			{
+				int alt25=2;
+				int LA25_0 = input.LA(1);
+
+				if ( (LA25_0==ID) )
+				{
+					alt25=1;
+				}
+
+
+				switch ( alt25 )
+				{
+				case 1:
+					// Grammars\\TreeToNFAConverter.g3:178:0: ID
+					{
+					Match(input,ID,Follow._ID_in_throwsSpec413);
+
+					}
+					break;
+
+				default:
+					if ( cnt25 >= 1 )
+						goto loop25;
+
+					EarlyExitException eee25 = new EarlyExitException( 25, input );
+					throw eee25;
+				}
+				cnt25++;
+			}
+			loop25:
+				;
+
+
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "throwsSpec"
+
+
+	// $ANTLR start "ruleScopeSpec"
+	// Grammars\\TreeToNFAConverter.g3:181:0: ruleScopeSpec : ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* ) ;
+	private void ruleScopeSpec(  )
+	{
+		try
+		{
+			// Grammars\\TreeToNFAConverter.g3:182:4: ( ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* ) )
+			// Grammars\\TreeToNFAConverter.g3:182:4: ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* )
+			{
+			Match(input,SCOPE,Follow._SCOPE_in_ruleScopeSpec428);
+
+			if ( input.LA(1)==TokenConstants.DOWN )
+			{
+				Match(input, TokenConstants.DOWN, null);
+				// Grammars\\TreeToNFAConverter.g3:182:15: ( ^( AMPERSAND ( . )* ) )*
+				for ( ; ; )
+				{
+					int alt27=2;
+					int LA27_0 = input.LA(1);
+
+					if ( (LA27_0==AMPERSAND) )
+					{
+						alt27=1;
+					}
+
+
+					switch ( alt27 )
+					{
+					case 1:
+						// Grammars\\TreeToNFAConverter.g3:182:17: ^( AMPERSAND ( . )* )
+						{
+						Match(input,AMPERSAND,Follow._AMPERSAND_in_ruleScopeSpec433);
+
+						if ( input.LA(1)==TokenConstants.DOWN )
+						{
+							Match(input, TokenConstants.DOWN, null);
+							// Grammars\\TreeToNFAConverter.g3:182:29: ( . )*
+							for ( ; ; )
+							{
+								int alt26=2;
+								int LA26_0 = input.LA(1);
+
+								if ( ((LA26_0>=ACTION && LA26_0<=XDIGIT)) )
+								{
+									alt26=1;
+								}
+								else if ( (LA26_0==UP) )
+								{
+									alt26=2;
+								}
+
+
+								switch ( alt26 )
+								{
+								case 1:
+									// Grammars\\TreeToNFAConverter.g3:182:0: .
+									{
+									MatchAny(input);
+
+									}
+									break;
+
+								default:
+									goto loop26;
+								}
+							}
+
+							loop26:
+								;
+
+
+
+							Match(input, TokenConstants.UP, null);
+						}
+
+						}
+						break;
+
+					default:
+						goto loop27;
+					}
+				}
+
+				loop27:
+					;
+
+
+				// Grammars\\TreeToNFAConverter.g3:182:36: ( ACTION )?
+				int alt28=2;
+				int LA28_0 = input.LA(1);
+
+				if ( (LA28_0==ACTION) )
+				{
+					alt28=1;
+				}
+				switch ( alt28 )
+				{
+				case 1:
+					// Grammars\\TreeToNFAConverter.g3:182:37: ACTION
+					{
+					Match(input,ACTION,Follow._ACTION_in_ruleScopeSpec443);
+
+					}
+					break;
+
+				}
+
+				// Grammars\\TreeToNFAConverter.g3:182:46: ( ID )*
+				for ( ; ; )
+				{
+					int alt29=2;
+					int LA29_0 = input.LA(1);
+
+					if ( (LA29_0==ID) )
+					{
+						alt29=1;
+					}
+
+
+					switch ( alt29 )
+					{
+					case 1:
+						// Grammars\\TreeToNFAConverter.g3:182:48: ID
+						{
+						Match(input,ID,Follow._ID_in_ruleScopeSpec449);
+
+						}
+						break;
+
+					default:
+						goto loop29;
+					}
+				}
+
+				loop29:
+					;
+
+
+
+				Match(input, TokenConstants.UP, null);
+			}
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "ruleScopeSpec"
+
+	public class block_return : TreeRuleReturnScope
+	{
+		public StateCluster g = null;
+	}
+
+	// $ANTLR start "block"
+	// Grammars\\TreeToNFAConverter.g3:185:0: block returns [StateCluster g = null] : ({...}? => set | ^( BLOCK ( ^( OPTIONS ( . )* ) )? (a= alternative rewrite )+ EOB ) );
+	private TreeToNFAConverter.block_return block(  )
+	{
+		TreeToNFAConverter.block_return retval = new TreeToNFAConverter.block_return();
+		retval.start = input.LT(1);
+
+		StateCluster a = default(StateCluster);
+		TreeToNFAConverter.set_return set1 = default(TreeToNFAConverter.set_return);
+
+
+			List<StateCluster> alts = new List<StateCluster>();
+			this.blockLevel++;
+			if ( this.blockLevel==1 )
+				this.outerAltNum=1;
+
+		try
+		{
+			// Grammars\\TreeToNFAConverter.g3:193:4: ({...}? => set | ^( BLOCK ( ^( OPTIONS ( . )* ) )? (a= alternative rewrite )+ EOB ) )
+			int alt33=2;
+			int LA33_0 = input.LA(1);
+
+			if ( (LA33_0==BLOCK) )
+			{
+				int LA33_1 = input.LA(2);
+
+				if ( ((grammar.isValidSet(this,((GrammarAST)retval.start)) &&
+						 !currentRuleName.Equals(Grammar.ARTIFICIAL_TOKENS_RULENAME))) )
+				{
+					alt33=1;
+				}
+				else if ( (true) )
+				{
+					alt33=2;
+				}
+				else
+				{
+					NoViableAltException nvae = new NoViableAltException("", 33, 1, input);
+
+					throw nvae;
+				}
+			}
+			else
+			{
+				NoViableAltException nvae = new NoViableAltException("", 33, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt33 )
+			{
+			case 1:
+				// Grammars\\TreeToNFAConverter.g3:193:4: {...}? => set
+				{
+				if ( !((grammar.isValidSet(this,((GrammarAST)retval.start)) &&
+						 !currentRuleName.Equals(Grammar.ARTIFICIAL_TOKENS_RULENAME))) )
+				{
+					throw new FailedPredicateException(input, "block", "grammar.isValidSet(this,$start) &&\r\n\t\t !currentRuleName.Equals(Grammar.ARTIFICIAL_TOKENS_RULENAME)");
+				}
+				PushFollow(Follow._set_in_block480);
+				set1=set();
+
+				state._fsp--;
+
+				retval.g = (set1!=null?set1.g:default(StateCluster));
+
+				}
+				break;
+			case 2:
+				// Grammars\\TreeToNFAConverter.g3:197:4: ^( BLOCK ( ^( OPTIONS ( . )* ) )? (a= alternative rewrite )+ EOB )
+				{
+				Match(input,BLOCK,Follow._BLOCK_in_block490);
+
+				Match(input, TokenConstants.DOWN, null);
+				// Grammars\\TreeToNFAConverter.g3:197:13: ( ^( OPTIONS ( . )* ) )?
+				int alt31=2;
+				int LA31_0 = input.LA(1);
+
+				if ( (LA31_0==OPTIONS) )
+				{
+					alt31=1;
+				}
+				switch ( alt31 )
+				{
+				case 1:
+					// Grammars\\TreeToNFAConverter.g3:197:15: ^( OPTIONS ( . )* )
+					{
+					Match(input,OPTIONS,Follow._OPTIONS_in_block495);
+
+					if ( input.LA(1)==TokenConstants.DOWN )
+					{
+						Match(input, TokenConstants.DOWN, null);
+						// Grammars\\TreeToNFAConverter.g3:197:25: ( . )*
+						for ( ; ; )
+						{
+							int alt30=2;
+							int LA30_0 = input.LA(1);
+
+							if ( ((LA30_0>=ACTION && LA30_0<=XDIGIT)) )
+							{
+								alt30=1;
+							}
+							else if ( (LA30_0==UP) )
+							{
+								alt30=2;
+							}
+
+
+							switch ( alt30 )
+							{
+							case 1:
+								// Grammars\\TreeToNFAConverter.g3:197:0: .
+								{
+								MatchAny(input);
+
+								}
+								break;
+
+							default:
+								goto loop30;
+							}
+						}
+
+						loop30:
+							;
+
+
+
+						Match(input, TokenConstants.UP, null);
+					}
+
+					}
+					break;
+
+				}
+
+				// Grammars\\TreeToNFAConverter.g3:198:4: (a= alternative rewrite )+
+				int cnt32=0;
+				for ( ; ; )
+				{
+					int alt32=2;
+					int LA32_0 = input.LA(1);
+
+					if ( (LA32_0==ALT) )
+					{
+						alt32=1;
+					}
+
+
+					switch ( alt32 )
+					{
+					case 1:
+						// Grammars\\TreeToNFAConverter.g3:198:6: a= alternative rewrite
+						{
+						PushFollow(Follow._alternative_in_block511);
+						a=alternative();
+
+						state._fsp--;
+
+						PushFollow(Follow._rewrite_in_block513);
+						rewrite();
+
+						state._fsp--;
+
+
+											alts.Add(a);
+
+
+											if ( blockLevel == 1 )
+												outerAltNum++;
+
+
+						}
+						break;
+
+					default:
+						if ( cnt32 >= 1 )
+							goto loop32;
+
+						EarlyExitException eee32 = new EarlyExitException( 32, input );
+						throw eee32;
+					}
+					cnt32++;
+				}
+				loop32:
+					;
+
+
+				Match(input,EOB,Follow._EOB_in_block536);
+
+				Match(input, TokenConstants.UP, null);
+				retval.g = factory.build_AlternativeBlock(alts);
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+			 blockLevel--;
+		}
+		return retval;
+	}
+	// $ANTLR end "block"
+
+
+	// $ANTLR start "alternative"
+	// Grammars\\TreeToNFAConverter.g3:213:0: alternative returns [StateCluster g=null] : ^( ALT (e= element )+ EOA ) ;
+	private StateCluster alternative(  )
+	{
+
+		StateCluster g = null;
+
+		TreeToNFAConverter.element_return e = default(TreeToNFAConverter.element_return);
+
+		try
+		{
+			// Grammars\\TreeToNFAConverter.g3:214:4: ( ^( ALT (e= element )+ EOA ) )
+			// Grammars\\TreeToNFAConverter.g3:214:4: ^( ALT (e= element )+ EOA )
+			{
+			Match(input,ALT,Follow._ALT_in_alternative565);
+
+			Match(input, TokenConstants.DOWN, null);
+			// Grammars\\TreeToNFAConverter.g3:214:11: (e= element )+
+			int cnt34=0;
+			for ( ; ; )
+			{
+				int alt34=2;
+				int LA34_0 = input.LA(1);
+
+				if ( (LA34_0==ACTION||(LA34_0>=ASSIGN && LA34_0<=BLOCK)||(LA34_0>=CHAR_LITERAL && LA34_0<=CHAR_RANGE)||LA34_0==CLOSURE||LA34_0==DOT||LA34_0==EPSILON||LA34_0==FORCED_ACTION||LA34_0==GATED_SEMPRED||LA34_0==NOT||LA34_0==OPTIONAL||(LA34_0>=PLUS_ASSIGN && LA34_0<=POSITIVE_CLOSURE)||LA34_0==RANGE||LA34_0==ROOT||LA34_0==RULE_REF||LA34_0==SEMPRED||(LA34_0>=STRING_LITERAL && LA34_0<=SYNPRED)||LA34_0==TOKEN_REF||LA34_0==TREE_BEGIN||LA34_0==WILDCARD) )
+				{
+					alt34=1;
+				}
+
+
+				switch ( alt34 )
+				{
+				case 1:
+					// Grammars\\TreeToNFAConverter.g3:214:12: e= element
+					{
+					PushFollow(Follow._element_in_alternative570);
+					e=element();
+
+					state._fsp--;
+
+					g = factory.build_AB(g,(e!=null?e.g:default(StateCluster)));
+
+					}
+					break;
+
+				default:
+					if ( cnt34 >= 1 )
+						goto loop34;
+
+					EarlyExitException eee34 = new EarlyExitException( 34, input );
+					throw eee34;
+				}
+				cnt34++;
+			}
+			loop34:
+				;
+
+
+			Match(input,EOA,Follow._EOA_in_alternative577);
+
+			Match(input, TokenConstants.UP, null);
+
+						if (g==null) { // if alt was a list of actions or whatever
+							g = factory.build_Epsilon();
+						}
+						else {
+							factory.optimizeAlternative(g);
+						}
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return g;
+	}
+	// $ANTLR end "alternative"
+
+
+	// $ANTLR start "exceptionGroup"
+	// Grammars\\TreeToNFAConverter.g3:225:0: exceptionGroup : ( ( exceptionHandler )+ ( finallyClause )? | finallyClause );
+	private void exceptionGroup(  )
+	{
+		try
+		{
+			// Grammars\\TreeToNFAConverter.g3:226:4: ( ( exceptionHandler )+ ( finallyClause )? | finallyClause )
+			int alt37=2;
+			int LA37_0 = input.LA(1);
+
+			if ( (LA37_0==CATCH) )
+			{
+				alt37=1;
+			}
+			else if ( (LA37_0==FINALLY) )
+			{
+				alt37=2;
+			}
+			else
+			{
+				NoViableAltException nvae = new NoViableAltException("", 37, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt37 )
+			{
+			case 1:
+				// Grammars\\TreeToNFAConverter.g3:226:4: ( exceptionHandler )+ ( finallyClause )?
+				{
+				// Grammars\\TreeToNFAConverter.g3:226:4: ( exceptionHandler )+
+				int cnt35=0;
+				for ( ; ; )
+				{
+					int alt35=2;
+					int LA35_0 = input.LA(1);
+
+					if ( (LA35_0==CATCH) )
+					{
+						alt35=1;
+					}
+
+
+					switch ( alt35 )
+					{
+					case 1:
+						// Grammars\\TreeToNFAConverter.g3:226:6: exceptionHandler
+						{
+						PushFollow(Follow._exceptionHandler_in_exceptionGroup596);
+						exceptionHandler();
+
+						state._fsp--;
+
+
+						}
+						break;
+
+					default:
+						if ( cnt35 >= 1 )
+							goto loop35;
+
+						EarlyExitException eee35 = new EarlyExitException( 35, input );
+						throw eee35;
+					}
+					cnt35++;
+				}
+				loop35:
+					;
+
+
+				// Grammars\\TreeToNFAConverter.g3:226:26: ( finallyClause )?
+				int alt36=2;
+				int LA36_0 = input.LA(1);
+
+				if ( (LA36_0==FINALLY) )
+				{
+					alt36=1;
+				}
+				switch ( alt36 )
+				{
+				case 1:
+					// Grammars\\TreeToNFAConverter.g3:226:27: finallyClause
+					{
+					PushFollow(Follow._finallyClause_in_exceptionGroup602);
+					finallyClause();
+
+					state._fsp--;
+
+
+					}
+					break;
+
+				}
+
+
+				}
+				break;
+			case 2:
+				// Grammars\\TreeToNFAConverter.g3:227:4: finallyClause
+				{
+				PushFollow(Follow._finallyClause_in_exceptionGroup609);
+				finallyClause();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "exceptionGroup"
+
+
+	// $ANTLR start "exceptionHandler"
+	// Grammars\\TreeToNFAConverter.g3:230:0: exceptionHandler : ^( 'catch' ARG_ACTION ACTION ) ;
+	private void exceptionHandler(  )
+	{
+		try
+		{
+			// Grammars\\TreeToNFAConverter.g3:231:7: ( ^( 'catch' ARG_ACTION ACTION ) )
+			// Grammars\\TreeToNFAConverter.g3:231:7: ^( 'catch' ARG_ACTION ACTION )
+			{
+			Match(input,CATCH,Follow._CATCH_in_exceptionHandler624);
+
+			Match(input, TokenConstants.DOWN, null);
+			Match(input,ARG_ACTION,Follow._ARG_ACTION_in_exceptionHandler626);
+			Match(input,ACTION,Follow._ACTION_in_exceptionHandler628);
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "exceptionHandler"
+
+
+	// $ANTLR start "finallyClause"
+	// Grammars\\TreeToNFAConverter.g3:234:0: finallyClause : ^( 'finally' ACTION ) ;
+	private void finallyClause(  )
+	{
+		try
+		{
+			// Grammars\\TreeToNFAConverter.g3:235:7: ( ^( 'finally' ACTION ) )
+			// Grammars\\TreeToNFAConverter.g3:235:7: ^( 'finally' ACTION )
+			{
+			Match(input,FINALLY,Follow._FINALLY_in_finallyClause644);
+
+			Match(input, TokenConstants.DOWN, null);
+			Match(input,ACTION,Follow._ACTION_in_finallyClause646);
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "finallyClause"
+
+	public class rewrite_return : TreeRuleReturnScope
+	{
+	}
+
+	// $ANTLR start "rewrite"
+	// Grammars\\TreeToNFAConverter.g3:238:0: rewrite : ( ^( REWRITE ( . )* ) )* ;
+	private TreeToNFAConverter.rewrite_return rewrite(  )
+	{
+		TreeToNFAConverter.rewrite_return retval = new TreeToNFAConverter.rewrite_return();
+		retval.start = input.LT(1);
+
+		try
+		{
+			// Grammars\\TreeToNFAConverter.g3:239:4: ( ( ^( REWRITE ( . )* ) )* )
+			// Grammars\\TreeToNFAConverter.g3:239:4: ( ^( REWRITE ( . )* ) )*
+			{
+			// Grammars\\TreeToNFAConverter.g3:239:4: ( ^( REWRITE ( . )* ) )*
+			for ( ; ; )
+			{
+				int alt39=2;
+				int LA39_0 = input.LA(1);
+
+				if ( (LA39_0==REWRITE) )
+				{
+					alt39=1;
+				}
+
+
+				switch ( alt39 )
+				{
+				case 1:
+					// Grammars\\TreeToNFAConverter.g3:240:4: ^( REWRITE ( . )* )
+					{
+
+									if ( grammar.getOption("output")==null )
+									{
+										ErrorManager.grammarError(ErrorManager.MSG_REWRITE_OR_OP_WITH_NO_OUTPUT_OPTION,
+																  grammar, ((GrammarAST)retval.start).Token, currentRuleName);
+									}
+
+					Match(input,REWRITE,Follow._REWRITE_in_rewrite669);
+
+					if ( input.LA(1)==TokenConstants.DOWN )
+					{
+						Match(input, TokenConstants.DOWN, null);
+						// Grammars\\TreeToNFAConverter.g3:247:14: ( . )*
+						for ( ; ; )
+						{
+							int alt38=2;
+							int LA38_0 = input.LA(1);
+
+							if ( ((LA38_0>=ACTION && LA38_0<=XDIGIT)) )
+							{
+								alt38=1;
+							}
+							else if ( (LA38_0==UP) )
+							{
+								alt38=2;
+							}
+
+
+							switch ( alt38 )
+							{
+							case 1:
+								// Grammars\\TreeToNFAConverter.g3:247:0: .
+								{
+								MatchAny(input);
+
+								}
+								break;
+
+							default:
+								goto loop38;
+							}
+						}
+
+						loop38:
+							;
+
+
+
+						Match(input, TokenConstants.UP, null);
+					}
+
+					}
+					break;
+
+				default:
+					goto loop39;
+				}
+			}
+
+			loop39:
+				;
+
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "rewrite"
+
+	public class element_return : TreeRuleReturnScope
+	{
+		public StateCluster g=null;
+	}
+
+	// $ANTLR start "element"
+	// Grammars\\TreeToNFAConverter.g3:251:0: element returns [StateCluster g=null] : ( ^( ROOT e= element ) | ^( BANG e= element ) | ^( ASSIGN ID e= element ) | ^( PLUS_ASSIGN ID e= element ) | ^( RANGE a= atom[null] b= atom[null] ) | ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL ) | atom_or_notatom | ebnf | tree_ | ^( SYNPRED block ) | ACTION | FORCED_ACTION |pred= SEMPRED |spred= SYN_SEMPRED | ^(bpred= BACKTRACK_SEMPRED ( . )* ) |gpred= GATED_SEMPRED | EPSILON );
+	private TreeToNFAConverter.element_return element(  )
+	{
+		TreeToNFAConverter.element_return retval = new TreeToNFAConverter.element_return();
+		retval.start = input.LT(1);
+
+		GrammarAST c1=null;
+		GrammarAST c2=null;
+		GrammarAST pred=null;
+		GrammarAST spred=null;
+		GrammarAST bpred=null;
+		GrammarAST gpred=null;
+		GrammarAST ACTION5=null;
+		GrammarAST FORCED_ACTION6=null;
+		TreeToNFAConverter.element_return e = default(TreeToNFAConverter.element_return);
+		TreeToNFAConverter.atom_return a = default(TreeToNFAConverter.atom_return);
+		TreeToNFAConverter.atom_return b = default(TreeToNFAConverter.atom_return);
+		StateCluster atom_or_notatom2 = default(StateCluster);
+		TreeToNFAConverter.ebnf_return ebnf3 = default(TreeToNFAConverter.ebnf_return);
+		TreeToNFAConverter.tree__return tree_4 = default(TreeToNFAConverter.tree__return);
+
+		try
+		{
+			// Grammars\\TreeToNFAConverter.g3:252:6: ( ^( ROOT e= element ) | ^( BANG e= element ) | ^( ASSIGN ID e= element ) | ^( PLUS_ASSIGN ID e= element ) | ^( RANGE a= atom[null] b= atom[null] ) | ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL ) | atom_or_notatom | ebnf | tree_ | ^( SYNPRED block ) | ACTION | FORCED_ACTION |pred= SEMPRED |spred= SYN_SEMPRED | ^(bpred= BACKTRACK_SEMPRED ( . )* ) |gpred= GATED_SEMPRED | EPSILON )
+			int alt41=17;
+			alt41 = dfa41.Predict(input);
+			switch ( alt41 )
+			{
+			case 1:
+				// Grammars\\TreeToNFAConverter.g3:252:6: ^( ROOT e= element )
+				{
+				Match(input,ROOT,Follow._ROOT_in_element696);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._element_in_element700);
+				e=element();
+
+				state._fsp--;
+
+				retval.g = (e!=null?e.g:default(StateCluster));
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 2:
+				// Grammars\\TreeToNFAConverter.g3:253:6: ^( BANG e= element )
+				{
+				Match(input,BANG,Follow._BANG_in_element711);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._element_in_element715);
+				e=element();
+
+				state._fsp--;
+
+				retval.g = (e!=null?e.g:default(StateCluster));
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 3:
+				// Grammars\\TreeToNFAConverter.g3:254:4: ^( ASSIGN ID e= element )
+				{
+				Match(input,ASSIGN,Follow._ASSIGN_in_element724);
+
+				Match(input, TokenConstants.DOWN, null);
+				Match(input,ID,Follow._ID_in_element726);
+				PushFollow(Follow._element_in_element730);
+				e=element();
+
+				state._fsp--;
+
+				retval.g = (e!=null?e.g:default(StateCluster));
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 4:
+				// Grammars\\TreeToNFAConverter.g3:255:4: ^( PLUS_ASSIGN ID e= element )
+				{
+				Match(input,PLUS_ASSIGN,Follow._PLUS_ASSIGN_in_element739);
+
+				Match(input, TokenConstants.DOWN, null);
+				Match(input,ID,Follow._ID_in_element741);
+				PushFollow(Follow._element_in_element745);
+				e=element();
+
+				state._fsp--;
+
+				retval.g = (e!=null?e.g:default(StateCluster));
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 5:
+				// Grammars\\TreeToNFAConverter.g3:256:6: ^( RANGE a= atom[null] b= atom[null] )
+				{
+				Match(input,RANGE,Follow._RANGE_in_element756);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._atom_in_element760);
+				a=atom(null);
+
+				state._fsp--;
+
+				PushFollow(Follow._atom_in_element765);
+				b=atom(null);
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+				retval.g = factory.build_Range(grammar.getTokenType((a!=null?(input.TokenStream.ToString(
+				  input.TreeAdaptor.GetTokenStartIndex(a.start),
+				  input.TreeAdaptor.GetTokenStopIndex(a.start))):null)),
+												 grammar.getTokenType((b!=null?(input.TokenStream.ToString(
+				  input.TreeAdaptor.GetTokenStartIndex(b.start),
+				  input.TreeAdaptor.GetTokenStopIndex(b.start))):null)));
+
+				}
+				break;
+			case 6:
+				// Grammars\\TreeToNFAConverter.g3:259:6: ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL )
+				{
+				Match(input,CHAR_RANGE,Follow._CHAR_RANGE_in_element779);
+
+				Match(input, TokenConstants.DOWN, null);
+				c1=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_element783);
+				c2=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_element787);
+
+				Match(input, TokenConstants.UP, null);
+
+						if ( grammar.type==Grammar.LEXER ) {
+							retval.g = factory.build_CharRange((c1!=null?c1.Text:null), (c2!=null?c2.Text:null));
+						}
+
+
+				}
+				break;
+			case 7:
+				// Grammars\\TreeToNFAConverter.g3:265:6: atom_or_notatom
+				{
+				PushFollow(Follow._atom_or_notatom_in_element799);
+				atom_or_notatom2=atom_or_notatom();
+
+				state._fsp--;
+
+				retval.g = atom_or_notatom2;
+
+				}
+				break;
+			case 8:
+				// Grammars\\TreeToNFAConverter.g3:266:6: ebnf
+				{
+				PushFollow(Follow._ebnf_in_element808);
+				ebnf3=ebnf();
+
+				state._fsp--;
+
+				retval.g = (ebnf3!=null?ebnf3.g:default(StateCluster));
+
+				}
+				break;
+			case 9:
+				// Grammars\\TreeToNFAConverter.g3:267:6: tree_
+				{
+				PushFollow(Follow._tree__in_element817);
+				tree_4=tree_();
+
+				state._fsp--;
+
+				retval.g = (tree_4!=null?tree_4.g:default(StateCluster));
+
+				}
+				break;
+			case 10:
+				// Grammars\\TreeToNFAConverter.g3:268:6: ^( SYNPRED block )
+				{
+				Match(input,SYNPRED,Follow._SYNPRED_in_element828);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._block_in_element830);
+				block();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+			case 11:
+				// Grammars\\TreeToNFAConverter.g3:269:6: ACTION
+				{
+				ACTION5=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_element839);
+				retval.g = factory.build_Action(ACTION5);
+
+				}
+				break;
+			case 12:
+				// Grammars\\TreeToNFAConverter.g3:270:6: FORCED_ACTION
+				{
+				FORCED_ACTION6=(GrammarAST)Match(input,FORCED_ACTION,Follow._FORCED_ACTION_in_element848);
+				retval.g = factory.build_Action(FORCED_ACTION6);
+
+				}
+				break;
+			case 13:
+				// Grammars\\TreeToNFAConverter.g3:271:6: pred= SEMPRED
+				{
+				pred=(GrammarAST)Match(input,SEMPRED,Follow._SEMPRED_in_element859);
+				retval.g = factory.build_SemanticPredicate(pred);
+
+				}
+				break;
+			case 14:
+				// Grammars\\TreeToNFAConverter.g3:272:6: spred= SYN_SEMPRED
+				{
+				spred=(GrammarAST)Match(input,SYN_SEMPRED,Follow._SYN_SEMPRED_in_element870);
+				retval.g = factory.build_SemanticPredicate(spred);
+
+				}
+				break;
+			case 15:
+				// Grammars\\TreeToNFAConverter.g3:273:6: ^(bpred= BACKTRACK_SEMPRED ( . )* )
+				{
+				bpred=(GrammarAST)Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_element882);
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null);
+					// Grammars\\TreeToNFAConverter.g3:273:32: ( . )*
+					for ( ; ; )
+					{
+						int alt40=2;
+						int LA40_0 = input.LA(1);
+
+						if ( ((LA40_0>=ACTION && LA40_0<=XDIGIT)) )
+						{
+							alt40=1;
+						}
+						else if ( (LA40_0==UP) )
+						{
+							alt40=2;
+						}
+
+
+						switch ( alt40 )
+						{
+						case 1:
+							// Grammars\\TreeToNFAConverter.g3:273:0: .
+							{
+							MatchAny(input);
+
+							}
+							break;
+
+						default:
+							goto loop40;
+						}
+					}
+
+					loop40:
+						;
+
+
+
+					Match(input, TokenConstants.UP, null);
+				}
+				retval.g = factory.build_SemanticPredicate(bpred);
+
+				}
+				break;
+			case 16:
+				// Grammars\\TreeToNFAConverter.g3:274:6: gpred= GATED_SEMPRED
+				{
+				gpred=(GrammarAST)Match(input,GATED_SEMPRED,Follow._GATED_SEMPRED_in_element897);
+				retval.g = factory.build_SemanticPredicate(gpred);
+
+				}
+				break;
+			case 17:
+				// Grammars\\TreeToNFAConverter.g3:275:6: EPSILON
+				{
+				Match(input,EPSILON,Follow._EPSILON_in_element906);
+				retval.g = factory.build_Epsilon();
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "element"
+
+	public class ebnf_return : TreeRuleReturnScope
+	{
+		public StateCluster g=null;
+	}
+
+	// $ANTLR start "ebnf"
+	// Grammars\\TreeToNFAConverter.g3:278:0: ebnf returns [StateCluster g=null] : ({...}? => set |b= block | ^( OPTIONAL b= block ) | ^( CLOSURE b= block ) | ^( POSITIVE_CLOSURE b= block ) );
+	private TreeToNFAConverter.ebnf_return ebnf(  )
+	{
+		TreeToNFAConverter.ebnf_return retval = new TreeToNFAConverter.ebnf_return();
+		retval.start = input.LT(1);
+
+		TreeToNFAConverter.block_return b = default(TreeToNFAConverter.block_return);
+		TreeToNFAConverter.set_return set7 = default(TreeToNFAConverter.set_return);
+
+
+			GrammarAST blk = ((GrammarAST)retval.start);
+			if ( blk.Type!=BLOCK ) {
+				blk = (GrammarAST)blk.GetChild(0);
+			}
+			GrammarAST eob = blk.getLastChild();
+
+		try
+		{
+			// Grammars\\TreeToNFAConverter.g3:287:4: ({...}? => set |b= block | ^( OPTIONAL b= block ) | ^( CLOSURE b= block ) | ^( POSITIVE_CLOSURE b= block ) )
+			int alt42=5;
+			switch ( input.LA(1) )
+			{
+			case BLOCK:
+				{
+				int LA42_1 = input.LA(2);
+
+				if ( ((grammar.isValidSet(this,((GrammarAST)retval.start)))) )
+				{
+					alt42=1;
+				}
+				else if ( (true) )
+				{
+					alt42=2;
+				}
+				else
+				{
+					NoViableAltException nvae = new NoViableAltException("", 42, 1, input);
+
+					throw nvae;
+				}
+				}
+				break;
+			case OPTIONAL:
+				{
+				alt42=3;
+				}
+				break;
+			case CLOSURE:
+				{
+				alt42=4;
+				}
+				break;
+			case POSITIVE_CLOSURE:
+				{
+				alt42=5;
+				}
+				break;
+			default:
+				{
+					NoViableAltException nvae = new NoViableAltException("", 42, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt42 )
+			{
+			case 1:
+				// Grammars\\TreeToNFAConverter.g3:287:4: {...}? => set
+				{
+				if ( !((grammar.isValidSet(this,((GrammarAST)retval.start)))) )
+				{
+					throw new FailedPredicateException(input, "ebnf", "grammar.isValidSet(this,$start)");
+				}
+				PushFollow(Follow._set_in_ebnf932);
+				set7=set();
+
+				state._fsp--;
+
+				retval.g = (set7!=null?set7.g:default(StateCluster));
+
+				}
+				break;
+			case 2:
+				// Grammars\\TreeToNFAConverter.g3:289:4: b= block
+				{
+				PushFollow(Follow._block_in_ebnf942);
+				b=block();
+
+				state._fsp--;
+
+
+							// track decision if > 1 alts
+							if ( grammar.getNumberOfAltsForDecisionNFA((b!=null?b.g:default(StateCluster)).left)>1 )
+							{
+								(b!=null?b.g:default(StateCluster)).left.Description = grammar.grammarTreeToString(blk,false);
+								(b!=null?b.g:default(StateCluster)).left.setDecisionASTNode(blk);
+								int d = grammar.assignDecisionNumber( (b!=null?b.g:default(StateCluster)).left );
+								grammar.setDecisionNFA( d, (b!=null?b.g:default(StateCluster)).left );
+								grammar.setDecisionBlockAST(d, blk);
+							}
+							retval.g = (b!=null?b.g:default(StateCluster));
+
+
+				}
+				break;
+			case 3:
+				// Grammars\\TreeToNFAConverter.g3:302:4: ^( OPTIONAL b= block )
+				{
+				Match(input,OPTIONAL,Follow._OPTIONAL_in_ebnf953);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._block_in_ebnf957);
+				b=block();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+							StateCluster bg = (b!=null?b.g:default(StateCluster));
+							if ( blk.SetValue!=null )
+							{
+								// if block comes back SET not BLOCK, make it
+								// a single ALT block
+								bg = factory.build_AlternativeBlockFromSet(bg);
+							}
+							retval.g = factory.build_Aoptional(bg);
+							retval.g.left.Description = grammar.grammarTreeToString(((GrammarAST)retval.start),false);
+							// there is always at least one alt even if block has just 1 alt
+							int d = grammar.assignDecisionNumber( retval.g.left );
+							grammar.setDecisionNFA(d, retval.g.left);
+							grammar.setDecisionBlockAST(d, blk);
+							retval.g.left.setDecisionASTNode(((GrammarAST)retval.start));
+
+
+				}
+				break;
+			case 4:
+				// Grammars\\TreeToNFAConverter.g3:319:4: ^( CLOSURE b= block )
+				{
+				Match(input,CLOSURE,Follow._CLOSURE_in_ebnf970);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._block_in_ebnf974);
+				b=block();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+							StateCluster bg = (b!=null?b.g:default(StateCluster));
+							if ( blk.SetValue!=null )
+							{
+								bg = factory.build_AlternativeBlockFromSet(bg);
+							}
+							retval.g = factory.build_Astar(bg);
+							// track the loop back / exit decision point
+							bg.right.Description = "()* loopback of "+grammar.grammarTreeToString(((GrammarAST)retval.start),false);
+							int d = grammar.assignDecisionNumber( bg.right );
+							grammar.setDecisionNFA(d, bg.right);
+							grammar.setDecisionBlockAST(d, blk);
+							bg.right.setDecisionASTNode(eob);
+							// make block entry state also have same decision for interpreting grammar
+							NFAState altBlockState = (NFAState)retval.g.left.getTransition(0).target;
+							altBlockState.setDecisionASTNode(((GrammarAST)retval.start));
+							altBlockState.DecisionNumber = d;
+							retval.g.left.DecisionNumber = d; // this is the bypass decision (2 alts)
+							retval.g.left.setDecisionASTNode(((GrammarAST)retval.start));
+
+
+				}
+				break;
+			case 5:
+				// Grammars\\TreeToNFAConverter.g3:340:4: ^( POSITIVE_CLOSURE b= block )
+				{
+				Match(input,POSITIVE_CLOSURE,Follow._POSITIVE_CLOSURE_in_ebnf987);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._block_in_ebnf991);
+				b=block();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+
+							StateCluster bg = (b!=null?b.g:default(StateCluster));
+							if ( blk.SetValue!=null )
+							{
+								bg = factory.build_AlternativeBlockFromSet(bg);
+							}
+							retval.g = factory.build_Aplus(bg);
+							// don't make a decision on left edge, can reuse loop end decision
+							// track the loop back / exit decision point
+							bg.right.Description = "()+ loopback of "+grammar.grammarTreeToString(((GrammarAST)retval.start),false);
+							int d = grammar.assignDecisionNumber( bg.right );
+							grammar.setDecisionNFA(d, bg.right);
+							grammar.setDecisionBlockAST(d, blk);
+							bg.right.setDecisionASTNode(eob);
+							// make block entry state also have same decision for interpreting grammar
+							NFAState altBlockState = (NFAState)retval.g.left.getTransition(0).target;
+							altBlockState.setDecisionASTNode(((GrammarAST)retval.start));
+							altBlockState.DecisionNumber = d;
+
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "ebnf"
+
+	public class tree__return : TreeRuleReturnScope
+	{
+		public StateCluster g=null;
+	}
+
+	// $ANTLR start "tree_"
+	// Grammars\\TreeToNFAConverter.g3:362:0: tree_ returns [StateCluster g=null] : ^( TREE_BEGIN e= element (e= element )* ) ;
+	private TreeToNFAConverter.tree__return tree_(  )
+	{
+		TreeToNFAConverter.tree__return retval = new TreeToNFAConverter.tree__return();
+		retval.start = input.LT(1);
+
+		TreeToNFAConverter.element_return e = default(TreeToNFAConverter.element_return);
+
+
+			StateCluster down=null, up=null;
+
+		try
+		{
+			// Grammars\\TreeToNFAConverter.g3:367:4: ( ^( TREE_BEGIN e= element (e= element )* ) )
+			// Grammars\\TreeToNFAConverter.g3:367:4: ^( TREE_BEGIN e= element (e= element )* )
+			{
+			Match(input,TREE_BEGIN,Follow._TREE_BEGIN_in_tree_1019);
+
+			Match(input, TokenConstants.DOWN, null);
+			PushFollow(Follow._element_in_tree_1026);
+			e=element();
+
+			state._fsp--;
+
+			 retval.g = (e!=null?e.g:default(StateCluster));
+
+							down = factory.build_Atom(Label.DOWN, (e!=null?((GrammarAST)e.start):null));
+							// TODO set following states for imaginary nodes?
+							//el.followingNFAState = down.right;
+							retval.g = factory.build_AB(retval.g,down);
+
+			// Grammars\\TreeToNFAConverter.g3:375:4: (e= element )*
+			for ( ; ; )
+			{
+				int alt43=2;
+				int LA43_0 = input.LA(1);
+
+				if ( (LA43_0==ACTION||(LA43_0>=ASSIGN && LA43_0<=BLOCK)||(LA43_0>=CHAR_LITERAL && LA43_0<=CHAR_RANGE)||LA43_0==CLOSURE||LA43_0==DOT||LA43_0==EPSILON||LA43_0==FORCED_ACTION||LA43_0==GATED_SEMPRED||LA43_0==NOT||LA43_0==OPTIONAL||(LA43_0>=PLUS_ASSIGN && LA43_0<=POSITIVE_CLOSURE)||LA43_0==RANGE||LA43_0==ROOT||LA43_0==RULE_REF||LA43_0==SEMPRED||(LA43_0>=STRING_LITERAL && LA43_0<=SYNPRED)||LA43_0==TOKEN_REF||LA43_0==TREE_BEGIN||LA43_0==WILDCARD) )
+				{
+					alt43=1;
+				}
+
+
+				switch ( alt43 )
+				{
+				case 1:
+					// Grammars\\TreeToNFAConverter.g3:375:6: e= element
+					{
+					PushFollow(Follow._element_in_tree_1042);
+					e=element();
+
+					state._fsp--;
+
+					retval.g = factory.build_AB(retval.g,(e!=null?e.g:default(StateCluster)));
+
+					}
+					break;
+
+				default:
+					goto loop43;
+				}
+			}
+
+			loop43:
+				;
+
+
+
+							up = factory.build_Atom(Label.UP, (e!=null?((GrammarAST)e.start):null));
+							//el.followingNFAState = up.right;
+							retval.g = factory.build_AB(retval.g,up);
+							// tree roots point at right edge of DOWN for LOOK computation later
+							((GrammarAST)retval.start).NFATreeDownState = down.left;
+
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "tree_"
+
+
+	// $ANTLR start "atom_or_notatom"
+	// Grammars\\TreeToNFAConverter.g3:386:0: atom_or_notatom returns [StateCluster g=null] : ( atom[null] | ^(n= NOT (c= CHAR_LITERAL (ast1= ast_suffix )? |t= TOKEN_REF (ast3= ast_suffix )? | set ) ) );
+	private StateCluster atom_or_notatom(  )
+	{
+
+		StateCluster g = null;
+
+		GrammarAST n=null;
+		GrammarAST c=null;
+		GrammarAST t=null;
+		TreeToNFAConverter.set_return set9 = default(TreeToNFAConverter.set_return);
+		TreeToNFAConverter.atom_return atom8 = default(TreeToNFAConverter.atom_return);
+
+		try
+		{
+			// Grammars\\TreeToNFAConverter.g3:387:4: ( atom[null] | ^(n= NOT (c= CHAR_LITERAL (ast1= ast_suffix )? |t= TOKEN_REF (ast3= ast_suffix )? | set ) ) )
+			int alt47=2;
+			int LA47_0 = input.LA(1);
+
+			if ( (LA47_0==CHAR_LITERAL||LA47_0==DOT||LA47_0==RULE_REF||LA47_0==STRING_LITERAL||LA47_0==TOKEN_REF||LA47_0==WILDCARD) )
+			{
+				alt47=1;
+			}
+			else if ( (LA47_0==NOT) )
+			{
+				alt47=2;
+			}
+			else
+			{
+				NoViableAltException nvae = new NoViableAltException("", 47, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt47 )
+			{
+			case 1:
+				// Grammars\\TreeToNFAConverter.g3:387:4: atom[null]
+				{
+				PushFollow(Follow._atom_in_atom_or_notatom1071);
+				atom8=atom(null);
+
+				state._fsp--;
+
+				g = (atom8!=null?atom8.g:default(StateCluster));
+
+				}
+				break;
+			case 2:
+				// Grammars\\TreeToNFAConverter.g3:388:4: ^(n= NOT (c= CHAR_LITERAL (ast1= ast_suffix )? |t= TOKEN_REF (ast3= ast_suffix )? | set ) )
+				{
+				n=(GrammarAST)Match(input,NOT,Follow._NOT_in_atom_or_notatom1083);
+
+				Match(input, TokenConstants.DOWN, null);
+				// Grammars\\TreeToNFAConverter.g3:389:4: (c= CHAR_LITERAL (ast1= ast_suffix )? |t= TOKEN_REF (ast3= ast_suffix )? | set )
+				int alt46=3;
+				switch ( input.LA(1) )
+				{
+				case CHAR_LITERAL:
+					{
+					alt46=1;
+					}
+					break;
+				case TOKEN_REF:
+					{
+					alt46=2;
+					}
+					break;
+				case BLOCK:
+					{
+					alt46=3;
+					}
+					break;
+				default:
+					{
+						NoViableAltException nvae = new NoViableAltException("", 46, 0, input);
+
+						throw nvae;
+					}
+				}
+
+				switch ( alt46 )
+				{
+				case 1:
+					// Grammars\\TreeToNFAConverter.g3:389:6: c= CHAR_LITERAL (ast1= ast_suffix )?
+					{
+					c=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_atom_or_notatom1092);
+					// Grammars\\TreeToNFAConverter.g3:389:21: (ast1= ast_suffix )?
+					int alt44=2;
+					int LA44_0 = input.LA(1);
+
+					if ( (LA44_0==BANG||LA44_0==ROOT) )
+					{
+						alt44=1;
+					}
+					switch ( alt44 )
+					{
+					case 1:
+						// Grammars\\TreeToNFAConverter.g3:389:22: ast1= ast_suffix
+						{
+						PushFollow(Follow._ast_suffix_in_atom_or_notatom1097);
+						ast_suffix();
+
+						state._fsp--;
+
+
+						}
+						break;
+
+					}
+
+
+										int ttype=0;
+										if ( grammar.type==Grammar.LEXER )
+										{
+											ttype = Grammar.getCharValueFromGrammarCharLiteral((c!=null?c.Text:null));
+										}
+										else
+										{
+											ttype = grammar.getTokenType((c!=null?c.Text:null));
+										}
+										IIntSet notAtom = grammar.complement(ttype);
+										if ( notAtom.isNil() )
+										{
+											ErrorManager.grammarError(
+												ErrorManager.MSG_EMPTY_COMPLEMENT,
+												grammar,
+												c.Token,
+												(c!=null?c.Text:null));
+										}
+										g =factory.build_Set(notAtom,n);
+
+
+					}
+					break;
+				case 2:
+					// Grammars\\TreeToNFAConverter.g3:411:6: t= TOKEN_REF (ast3= ast_suffix )?
+					{
+					t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_atom_or_notatom1114);
+					// Grammars\\TreeToNFAConverter.g3:411:18: (ast3= ast_suffix )?
+					int alt45=2;
+					int LA45_0 = input.LA(1);
+
+					if ( (LA45_0==BANG||LA45_0==ROOT) )
+					{
+						alt45=1;
+					}
+					switch ( alt45 )
+					{
+					case 1:
+						// Grammars\\TreeToNFAConverter.g3:411:19: ast3= ast_suffix
+						{
+						PushFollow(Follow._ast_suffix_in_atom_or_notatom1119);
+						ast_suffix();
+
+						state._fsp--;
+
+
+						}
+						break;
+
+					}
+
+
+										int ttype=0;
+										IIntSet notAtom = null;
+										if ( grammar.type==Grammar.LEXER )
+										{
+											notAtom = grammar.getSetFromRule(this,(t!=null?t.Text:null));
+											if ( notAtom==null )
+											{
+												ErrorManager.grammarError(
+													ErrorManager.MSG_RULE_INVALID_SET,
+													grammar,
+													t.Token,
+													(t!=null?t.Text:null));
+											}
+											else
+											{
+												notAtom = grammar.complement(notAtom);
+											}
+										}
+										else
+										{
+											ttype = grammar.getTokenType((t!=null?t.Text:null));
+											notAtom = grammar.complement(ttype);
+										}
+										if ( notAtom==null || notAtom.isNil() )
+										{
+											ErrorManager.grammarError(
+												ErrorManager.MSG_EMPTY_COMPLEMENT,
+												grammar,
+												t.Token,
+												(t!=null?t.Text:null));
+										}
+										g =factory.build_Set(notAtom,n);
+
+
+					}
+					break;
+				case 3:
+					// Grammars\\TreeToNFAConverter.g3:446:6: set
+					{
+					PushFollow(Follow._set_in_atom_or_notatom1134);
+					set9=set();
+
+					state._fsp--;
+
+					g = (set9!=null?set9.g:default(StateCluster));
+
+										GrammarAST stNode = (GrammarAST)n.GetChild(0);
+										//IIntSet notSet = grammar.complement(stNode.SetValue);
+										// let code generator complement the sets
+										IIntSet s = stNode.SetValue;
+										stNode.setSetValue(s);
+										// let code gen do the complement again; here we compute
+										// for NFA construction
+										s = grammar.complement(s);
+										if ( s.isNil() )
+										{
+											ErrorManager.grammarError(
+												ErrorManager.MSG_EMPTY_COMPLEMENT,
+												grammar,
+												n.Token);
+										}
+										g =factory.build_Set(s,n);
+
+
+					}
+					break;
+
+				}
+
+				n.followingNFAState = g.right;
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return g;
+	}
+	// $ANTLR end "atom_or_notatom"
+
+	public class atom_return : TreeRuleReturnScope
+	{
+		public StateCluster g=null;
+	}
+
+	// $ANTLR start "atom"
+	// Grammars\\TreeToNFAConverter.g3:470:0: atom[string scopeName] returns [StateCluster g=null] : ( ^(r= RULE_REF (rarg= ARG_ACTION )? (as1= ast_suffix )? ) | ^(t= TOKEN_REF (targ= ARG_ACTION )? (as2= ast_suffix )? ) | ^(c= CHAR_LITERAL (as3= ast_suffix )? ) | ^(s= STRING_LITERAL (as4= ast_suffix )? ) | ^(w= WILDCARD (as5= ast_suffix )? ) | ^( DOT scope_= ID a= atom[$scope_.text] ) );
+	private TreeToNFAConverter.atom_return atom( string scopeName )
+	{
+		TreeToNFAConverter.atom_return retval = new TreeToNFAConverter.atom_return();
+		retval.start = input.LT(1);
+
+		GrammarAST r=null;
+		GrammarAST rarg=null;
+		GrammarAST t=null;
+		GrammarAST targ=null;
+		GrammarAST c=null;
+		GrammarAST s=null;
+		GrammarAST w=null;
+		GrammarAST scope_=null;
+		TreeToNFAConverter.atom_return a = default(TreeToNFAConverter.atom_return);
+
+		try
+		{
+			// Grammars\\TreeToNFAConverter.g3:471:4: ( ^(r= RULE_REF (rarg= ARG_ACTION )? (as1= ast_suffix )? ) | ^(t= TOKEN_REF (targ= ARG_ACTION )? (as2= ast_suffix )? ) | ^(c= CHAR_LITERAL (as3= ast_suffix )? ) | ^(s= STRING_LITERAL (as4= ast_suffix )? ) | ^(w= WILDCARD (as5= ast_suffix )? ) | ^( DOT scope_= ID a= atom[$scope_.text] ) )
+			int alt55=6;
+			switch ( input.LA(1) )
+			{
+			case RULE_REF:
+				{
+				alt55=1;
+				}
+				break;
+			case TOKEN_REF:
+				{
+				alt55=2;
+				}
+				break;
+			case CHAR_LITERAL:
+				{
+				alt55=3;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt55=4;
+				}
+				break;
+			case WILDCARD:
+				{
+				alt55=5;
+				}
+				break;
+			case DOT:
+				{
+				alt55=6;
+				}
+				break;
+			default:
+				{
+					NoViableAltException nvae = new NoViableAltException("", 55, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt55 )
+			{
+			case 1:
+				// Grammars\\TreeToNFAConverter.g3:471:4: ^(r= RULE_REF (rarg= ARG_ACTION )? (as1= ast_suffix )? )
+				{
+				r=(GrammarAST)Match(input,RULE_REF,Follow._RULE_REF_in_atom1176);
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null);
+					// Grammars\\TreeToNFAConverter.g3:471:18: (rarg= ARG_ACTION )?
+					int alt48=2;
+					int LA48_0 = input.LA(1);
+
+					if ( (LA48_0==ARG_ACTION) )
+					{
+						alt48=1;
+					}
+					switch ( alt48 )
+					{
+					case 1:
+						// Grammars\\TreeToNFAConverter.g3:471:19: rarg= ARG_ACTION
+						{
+						rarg=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1181);
+
+						}
+						break;
+
+					}
+
+					// Grammars\\TreeToNFAConverter.g3:471:37: (as1= ast_suffix )?
+					int alt49=2;
+					int LA49_0 = input.LA(1);
+
+					if ( (LA49_0==BANG||LA49_0==ROOT) )
+					{
+						alt49=1;
+					}
+					switch ( alt49 )
+					{
+					case 1:
+						// Grammars\\TreeToNFAConverter.g3:471:38: as1= ast_suffix
+						{
+						PushFollow(Follow._ast_suffix_in_atom1188);
+						ast_suffix();
+
+						state._fsp--;
+
+
+						}
+						break;
+
+					}
+
+
+					Match(input, TokenConstants.UP, null);
+				}
+
+							NFAState start = grammar.getRuleStartState(scopeName,(r!=null?r.Text:null));
+							if ( start!=null )
+							{
+								Rule rr = grammar.getRule(scopeName,(r!=null?r.Text:null));
+								retval.g = factory.build_RuleRef(rr, start);
+								r.followingNFAState = retval.g.right;
+								r._nfaStartState = retval.g.left;
+								if ( retval.g.left.getTransition(0) is RuleClosureTransition
+									&& grammar.type!=Grammar.LEXER )
+								{
+									addFollowTransition((r!=null?r.Text:null), retval.g.right);
+								}
+								// else rule ref got inlined to a set
+							}
+
+
+				}
+				break;
+			case 2:
+				// Grammars\\TreeToNFAConverter.g3:489:4: ^(t= TOKEN_REF (targ= ARG_ACTION )? (as2= ast_suffix )? )
+				{
+				t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_atom1206);
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null);
+					// Grammars\\TreeToNFAConverter.g3:489:20: (targ= ARG_ACTION )?
+					int alt50=2;
+					int LA50_0 = input.LA(1);
+
+					if ( (LA50_0==ARG_ACTION) )
+					{
+						alt50=1;
+					}
+					switch ( alt50 )
+					{
+					case 1:
+						// Grammars\\TreeToNFAConverter.g3:489:21: targ= ARG_ACTION
+						{
+						targ=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1212);
+
+						}
+						break;
+
+					}
+
+					// Grammars\\TreeToNFAConverter.g3:489:39: (as2= ast_suffix )?
+					int alt51=2;
+					int LA51_0 = input.LA(1);
+
+					if ( (LA51_0==BANG||LA51_0==ROOT) )
+					{
+						alt51=1;
+					}
+					switch ( alt51 )
+					{
+					case 1:
+						// Grammars\\TreeToNFAConverter.g3:489:40: as2= ast_suffix
+						{
+						PushFollow(Follow._ast_suffix_in_atom1219);
+						ast_suffix();
+
+						state._fsp--;
+
+
+						}
+						break;
+
+					}
+
+
+					Match(input, TokenConstants.UP, null);
+				}
+
+							if ( grammar.type==Grammar.LEXER )
+							{
+								NFAState start = grammar.getRuleStartState(scopeName,(t!=null?t.Text:null));
+								if ( start!=null )
+								{
+									Rule rr = grammar.getRule(scopeName,t.Text);
+									retval.g = factory.build_RuleRef(rr, start);
+									t._nfaStartState = retval.g.left;
+									// don't add FOLLOW transitions in the lexer;
+									// only exact context should be used.
+								}
+							}
+							else
+							{
+								retval.g = factory.build_Atom(t);
+								t.followingNFAState = retval.g.right;
+							}
+
+
+				}
+				break;
+			case 3:
+				// Grammars\\TreeToNFAConverter.g3:510:4: ^(c= CHAR_LITERAL (as3= ast_suffix )? )
+				{
+				c=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_atom1237);
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null);
+					// Grammars\\TreeToNFAConverter.g3:510:23: (as3= ast_suffix )?
+					int alt52=2;
+					int LA52_0 = input.LA(1);
+
+					if ( (LA52_0==BANG||LA52_0==ROOT) )
+					{
+						alt52=1;
+					}
+					switch ( alt52 )
+					{
+					case 1:
+						// Grammars\\TreeToNFAConverter.g3:510:24: as3= ast_suffix
+						{
+						PushFollow(Follow._ast_suffix_in_atom1243);
+						ast_suffix();
+
+						state._fsp--;
+
+
+						}
+						break;
+
+					}
+
+
+					Match(input, TokenConstants.UP, null);
+				}
+
+							if ( grammar.type==Grammar.LEXER )
+							{
+								retval.g = factory.build_CharLiteralAtom(c);
+							}
+							else
+							{
+								retval.g = factory.build_Atom(c);
+								c.followingNFAState = retval.g.right;
+							}
+
+
+				}
+				break;
+			case 4:
+				// Grammars\\TreeToNFAConverter.g3:523:4: ^(s= STRING_LITERAL (as4= ast_suffix )? )
+				{
+				s=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_atom1261);
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null);
+					// Grammars\\TreeToNFAConverter.g3:523:25: (as4= ast_suffix )?
+					int alt53=2;
+					int LA53_0 = input.LA(1);
+
+					if ( (LA53_0==BANG||LA53_0==ROOT) )
+					{
+						alt53=1;
+					}
+					switch ( alt53 )
+					{
+					case 1:
+						// Grammars\\TreeToNFAConverter.g3:523:26: as4= ast_suffix
+						{
+						PushFollow(Follow._ast_suffix_in_atom1267);
+						ast_suffix();
+
+						state._fsp--;
+
+
+						}
+						break;
+
+					}
+
+
+					Match(input, TokenConstants.UP, null);
+				}
+
+							if ( grammar.type==Grammar.LEXER )
+							{
+								retval.g = factory.build_StringLiteralAtom(s);
+							}
+							else
+							{
+								retval.g = factory.build_Atom(s);
+								s.followingNFAState = retval.g.right;
+							}
+
+
+				}
+				break;
+			case 5:
+				// Grammars\\TreeToNFAConverter.g3:536:4: ^(w= WILDCARD (as5= ast_suffix )? )
+				{
+				w=(GrammarAST)Match(input,WILDCARD,Follow._WILDCARD_in_atom1285);
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null);
+					// Grammars\\TreeToNFAConverter.g3:536:18: (as5= ast_suffix )?
+					int alt54=2;
+					int LA54_0 = input.LA(1);
+
+					if ( (LA54_0==BANG||LA54_0==ROOT) )
+					{
+						alt54=1;
+					}
+					switch ( alt54 )
+					{
+					case 1:
+						// Grammars\\TreeToNFAConverter.g3:536:19: as5= ast_suffix
+						{
+						PushFollow(Follow._ast_suffix_in_atom1290);
+						ast_suffix();
+
+						state._fsp--;
+
+
+						}
+						break;
+
+					}
+
+
+					Match(input, TokenConstants.UP, null);
+				}
+
+								if ( nfa.grammar.type == Grammar.TREE_PARSER
+									&& (w.ChildIndex > 0 || w.Parent.GetChild(1).Type == EOA) )
+								{
+									retval.g = factory.build_WildcardTree( w );
+								}
+								else
+								{
+									retval.g = factory.build_Wildcard( w );
+								}
+
+
+				}
+				break;
+			case 6:
+				// Grammars\\TreeToNFAConverter.g3:549:4: ^( DOT scope_= ID a= atom[$scope_.text] )
+				{
+				Match(input,DOT,Follow._DOT_in_atom1307);
+
+				Match(input, TokenConstants.DOWN, null);
+				scope_=(GrammarAST)Match(input,ID,Follow._ID_in_atom1311);
+				PushFollow(Follow._atom_in_atom1315);
+				a=atom((scope_!=null?scope_.Text:null));
+
+				state._fsp--;
+
+				retval.g = (a!=null?a.g:default(StateCluster));
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "atom"
+
+
+	// $ANTLR start "ast_suffix"
+	// Grammars\\TreeToNFAConverter.g3:552:0: ast_suffix : ( ROOT | BANG );
+	private void ast_suffix(  )
+	{
+		try
+		{
+			// Grammars\\TreeToNFAConverter.g3:553:4: ( ROOT | BANG )
+			// Grammars\\TreeToNFAConverter.g3:
+			{
+			if ( input.LA(1)==BANG||input.LA(1)==ROOT )
+			{
+				input.Consume();
+				state.errorRecovery=false;
+			}
+			else
+			{
+				MismatchedSetException mse = new MismatchedSetException(null,input);
+				throw mse;
+			}
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "ast_suffix"
+
+	public class set_return : TreeRuleReturnScope
+	{
+		public StateCluster g=null;
+	}
+
+	// $ANTLR start "set"
+	// Grammars\\TreeToNFAConverter.g3:557:0: set returns [StateCluster g=null] : ^(b= BLOCK ( ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? setElement[elements] EOA ) )+ EOB ) ;
+	private TreeToNFAConverter.set_return set(  )
+	{
+		TreeToNFAConverter.set_return retval = new TreeToNFAConverter.set_return();
+		retval.start = input.LT(1);
+
+		GrammarAST b=null;
+
+
+			IIntSet elements=new IntervalSet();
+			if ( state.backtracking == 0 )
+				((GrammarAST)retval.start).setSetValue(elements); // track set for use by code gen
+
+		try
+		{
+			// Grammars\\TreeToNFAConverter.g3:564:4: ( ^(b= BLOCK ( ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? setElement[elements] EOA ) )+ EOB ) )
+			// Grammars\\TreeToNFAConverter.g3:564:4: ^(b= BLOCK ( ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? setElement[elements] EOA ) )+ EOB )
+			{
+			b=(GrammarAST)Match(input,BLOCK,Follow._BLOCK_in_set1361);
+
+			Match(input, TokenConstants.DOWN, null);
+			// Grammars\\TreeToNFAConverter.g3:565:6: ( ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? setElement[elements] EOA ) )+
+			int cnt58=0;
+			for ( ; ; )
+			{
+				int alt58=2;
+				int LA58_0 = input.LA(1);
+
+				if ( (LA58_0==ALT) )
+				{
+					alt58=1;
+				}
+
+
+				switch ( alt58 )
+				{
+				case 1:
+					// Grammars\\TreeToNFAConverter.g3:565:7: ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? setElement[elements] EOA )
+					{
+					Match(input,ALT,Follow._ALT_in_set1370);
+
+					Match(input, TokenConstants.DOWN, null);
+					// Grammars\\TreeToNFAConverter.g3:565:13: ( ^( BACKTRACK_SEMPRED ( . )* ) )?
+					int alt57=2;
+					int LA57_0 = input.LA(1);
+
+					if ( (LA57_0==BACKTRACK_SEMPRED) )
+					{
+						alt57=1;
+					}
+					switch ( alt57 )
+					{
+					case 1:
+						// Grammars\\TreeToNFAConverter.g3:565:15: ^( BACKTRACK_SEMPRED ( . )* )
+						{
+						Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_set1375);
+
+						if ( input.LA(1)==TokenConstants.DOWN )
+						{
+							Match(input, TokenConstants.DOWN, null);
+							// Grammars\\TreeToNFAConverter.g3:565:35: ( . )*
+							for ( ; ; )
+							{
+								int alt56=2;
+								int LA56_0 = input.LA(1);
+
+								if ( ((LA56_0>=ACTION && LA56_0<=XDIGIT)) )
+								{
+									alt56=1;
+								}
+								else if ( (LA56_0==UP) )
+								{
+									alt56=2;
+								}
+
+
+								switch ( alt56 )
+								{
+								case 1:
+									// Grammars\\TreeToNFAConverter.g3:565:0: .
+									{
+									MatchAny(input);
+
+									}
+									break;
+
+								default:
+									goto loop56;
+								}
+							}
+
+							loop56:
+								;
+
+
+
+							Match(input, TokenConstants.UP, null);
+						}
+
+						}
+						break;
+
+					}
+
+					PushFollow(Follow._setElement_in_set1384);
+					setElement(elements);
+
+					state._fsp--;
+
+					Match(input,EOA,Follow._EOA_in_set1387);
+
+					Match(input, TokenConstants.UP, null);
+
+					}
+					break;
+
+				default:
+					if ( cnt58 >= 1 )
+						goto loop58;
+
+					EarlyExitException eee58 = new EarlyExitException( 58, input );
+					throw eee58;
+				}
+				cnt58++;
+			}
+			loop58:
+				;
+
+
+			Match(input,EOB,Follow._EOB_in_set1397);
+
+			Match(input, TokenConstants.UP, null);
+
+					retval.g = factory.build_Set(elements,b);
+					b.followingNFAState = retval.g.right;
+					b.setSetValue(elements); // track set value of this block
+
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return retval;
+	}
+	// $ANTLR end "set"
+
+
+	// $ANTLR start "setRule"
+	// Grammars\\TreeToNFAConverter.g3:576:0: setRule returns [IIntSet elements=new IntervalSet()] : ^( RULE id= ID ( modifier )? ARG RET ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ^( BLOCK ( ^( OPTIONS ( . )* ) )? ( ^( ALT ( BACKTRACK_SEMPRED )? setElement[elements] EOA ) )+ EOB ) ( exceptionGroup )? EOR ) ;
+	private IIntSet setRule(  )
+	{
+
+		IIntSet elements = new IntervalSet();
+
+		GrammarAST id=null;
+
+
+			IIntSet s=null;
+
+		try
+		{
+			// Grammars\\TreeToNFAConverter.g3:581:4: ( ^( RULE id= ID ( modifier )? ARG RET ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ^( BLOCK ( ^( OPTIONS ( . )* ) )? ( ^( ALT ( BACKTRACK_SEMPRED )? setElement[elements] EOA ) )+ EOB ) ( exceptionGroup )? EOR ) )
+			// Grammars\\TreeToNFAConverter.g3:581:4: ^( RULE id= ID ( modifier )? ARG RET ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ^( BLOCK ( ^( OPTIONS ( . )* ) )? ( ^( ALT ( BACKTRACK_SEMPRED )? setElement[elements] EOA ) )+ EOB ) ( exceptionGroup )? EOR )
+			{
+			Match(input,RULE,Follow._RULE_in_setRule1431);
+
+			Match(input, TokenConstants.DOWN, null);
+			id=(GrammarAST)Match(input,ID,Follow._ID_in_setRule1435);
+			// Grammars\\TreeToNFAConverter.g3:581:18: ( modifier )?
+			int alt59=2;
+			int LA59_0 = input.LA(1);
+
+			if ( (LA59_0==FRAGMENT||(LA59_0>=PRIVATE && LA59_0<=PUBLIC)) )
+			{
+				alt59=1;
+			}
+			switch ( alt59 )
+			{
+			case 1:
+				// Grammars\\TreeToNFAConverter.g3:581:19: modifier
+				{
+				PushFollow(Follow._modifier_in_setRule1438);
+				modifier();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			Match(input,ARG,Follow._ARG_in_setRule1442);
+			Match(input,RET,Follow._RET_in_setRule1444);
+			// Grammars\\TreeToNFAConverter.g3:581:38: ( ^( OPTIONS ( . )* ) )?
+			int alt61=2;
+			int LA61_0 = input.LA(1);
+
+			if ( (LA61_0==OPTIONS) )
+			{
+				alt61=1;
+			}
+			switch ( alt61 )
+			{
+			case 1:
+				// Grammars\\TreeToNFAConverter.g3:581:40: ^( OPTIONS ( . )* )
+				{
+				Match(input,OPTIONS,Follow._OPTIONS_in_setRule1449);
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null);
+					// Grammars\\TreeToNFAConverter.g3:581:50: ( . )*
+					for ( ; ; )
+					{
+						int alt60=2;
+						int LA60_0 = input.LA(1);
+
+						if ( ((LA60_0>=ACTION && LA60_0<=XDIGIT)) )
+						{
+							alt60=1;
+						}
+						else if ( (LA60_0==UP) )
+						{
+							alt60=2;
+						}
+
+
+						switch ( alt60 )
+						{
+						case 1:
+							// Grammars\\TreeToNFAConverter.g3:581:0: .
+							{
+							MatchAny(input);
+
+							}
+							break;
+
+						default:
+							goto loop60;
+						}
+					}
+
+					loop60:
+						;
+
+
+
+					Match(input, TokenConstants.UP, null);
+				}
+
+				}
+				break;
+
+			}
+
+			// Grammars\\TreeToNFAConverter.g3:581:57: ( ruleScopeSpec )?
+			int alt62=2;
+			int LA62_0 = input.LA(1);
+
+			if ( (LA62_0==SCOPE) )
+			{
+				alt62=1;
+			}
+			switch ( alt62 )
+			{
+			case 1:
+				// Grammars\\TreeToNFAConverter.g3:581:59: ruleScopeSpec
+				{
+				PushFollow(Follow._ruleScopeSpec_in_setRule1460);
+				ruleScopeSpec();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			// Grammars\\TreeToNFAConverter.g3:582:4: ( ^( AMPERSAND ( . )* ) )*
+			for ( ; ; )
+			{
+				int alt64=2;
+				int LA64_0 = input.LA(1);
+
+				if ( (LA64_0==AMPERSAND) )
+				{
+					alt64=1;
+				}
+
+
+				switch ( alt64 )
+				{
+				case 1:
+					// Grammars\\TreeToNFAConverter.g3:582:6: ^( AMPERSAND ( . )* )
+					{
+					Match(input,AMPERSAND,Follow._AMPERSAND_in_setRule1471);
+
+					if ( input.LA(1)==TokenConstants.DOWN )
+					{
+						Match(input, TokenConstants.DOWN, null);
+						// Grammars\\TreeToNFAConverter.g3:582:18: ( . )*
+						for ( ; ; )
+						{
+							int alt63=2;
+							int LA63_0 = input.LA(1);
+
+							if ( ((LA63_0>=ACTION && LA63_0<=XDIGIT)) )
+							{
+								alt63=1;
+							}
+							else if ( (LA63_0==UP) )
+							{
+								alt63=2;
+							}
+
+
+							switch ( alt63 )
+							{
+							case 1:
+								// Grammars\\TreeToNFAConverter.g3:582:0: .
+								{
+								MatchAny(input);
+
+								}
+								break;
+
+							default:
+								goto loop63;
+							}
+						}
+
+						loop63:
+							;
+
+
+
+						Match(input, TokenConstants.UP, null);
+					}
+
+					}
+					break;
+
+				default:
+					goto loop64;
+				}
+			}
+
+			loop64:
+				;
+
+
+			Match(input,BLOCK,Follow._BLOCK_in_setRule1485);
+
+			Match(input, TokenConstants.DOWN, null);
+			// Grammars\\TreeToNFAConverter.g3:583:13: ( ^( OPTIONS ( . )* ) )?
+			int alt66=2;
+			int LA66_0 = input.LA(1);
+
+			if ( (LA66_0==OPTIONS) )
+			{
+				alt66=1;
+			}
+			switch ( alt66 )
+			{
+			case 1:
+				// Grammars\\TreeToNFAConverter.g3:583:15: ^( OPTIONS ( . )* )
+				{
+				Match(input,OPTIONS,Follow._OPTIONS_in_setRule1490);
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null);
+					// Grammars\\TreeToNFAConverter.g3:583:25: ( . )*
+					for ( ; ; )
+					{
+						int alt65=2;
+						int LA65_0 = input.LA(1);
+
+						if ( ((LA65_0>=ACTION && LA65_0<=XDIGIT)) )
+						{
+							alt65=1;
+						}
+						else if ( (LA65_0==UP) )
+						{
+							alt65=2;
+						}
+
+
+						switch ( alt65 )
+						{
+						case 1:
+							// Grammars\\TreeToNFAConverter.g3:583:0: .
+							{
+							MatchAny(input);
+
+							}
+							break;
+
+						default:
+							goto loop65;
+						}
+					}
+
+					loop65:
+						;
+
+
+
+					Match(input, TokenConstants.UP, null);
+				}
+
+				}
+				break;
+
+			}
+
+			// Grammars\\TreeToNFAConverter.g3:584:7: ( ^( ALT ( BACKTRACK_SEMPRED )? setElement[elements] EOA ) )+
+			int cnt68=0;
+			for ( ; ; )
+			{
+				int alt68=2;
+				int LA68_0 = input.LA(1);
+
+				if ( (LA68_0==ALT) )
+				{
+					alt68=1;
+				}
+
+
+				switch ( alt68 )
+				{
+				case 1:
+					// Grammars\\TreeToNFAConverter.g3:584:9: ^( ALT ( BACKTRACK_SEMPRED )? setElement[elements] EOA )
+					{
+					Match(input,ALT,Follow._ALT_in_setRule1508);
+
+					Match(input, TokenConstants.DOWN, null);
+					// Grammars\\TreeToNFAConverter.g3:584:15: ( BACKTRACK_SEMPRED )?
+					int alt67=2;
+					int LA67_0 = input.LA(1);
+
+					if ( (LA67_0==BACKTRACK_SEMPRED) )
+					{
+						alt67=1;
+					}
+					switch ( alt67 )
+					{
+					case 1:
+						// Grammars\\TreeToNFAConverter.g3:584:16: BACKTRACK_SEMPRED
+						{
+						Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_setRule1511);
+
+						}
+						break;
+
+					}
+
+					PushFollow(Follow._setElement_in_setRule1515);
+					setElement(elements);
+
+					state._fsp--;
+
+					Match(input,EOA,Follow._EOA_in_setRule1518);
+
+					Match(input, TokenConstants.UP, null);
+
+					}
+					break;
+
+				default:
+					if ( cnt68 >= 1 )
+						goto loop68;
+
+					EarlyExitException eee68 = new EarlyExitException( 68, input );
+					throw eee68;
+				}
+				cnt68++;
+			}
+			loop68:
+				;
+
+
+			Match(input,EOB,Follow._EOB_in_setRule1530);
+
+			Match(input, TokenConstants.UP, null);
+			// Grammars\\TreeToNFAConverter.g3:587:4: ( exceptionGroup )?
+			int alt69=2;
+			int LA69_0 = input.LA(1);
+
+			if ( (LA69_0==CATCH||LA69_0==FINALLY) )
+			{
+				alt69=1;
+			}
+			switch ( alt69 )
+			{
+			case 1:
+				// Grammars\\TreeToNFAConverter.g3:587:5: exceptionGroup
+				{
+				PushFollow(Follow._exceptionGroup_in_setRule1542);
+				exceptionGroup();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			Match(input,EOR,Follow._EOR_in_setRule1549);
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			 throw re;
+		}
+		finally
+		{
+		}
+		return elements;
+	}
+	// $ANTLR end "setRule"
+
+
+	// $ANTLR start "setElement"
+	// Grammars\\TreeToNFAConverter.g3:593:0: setElement[IIntSet elements] : (c= CHAR_LITERAL |t= TOKEN_REF |s= STRING_LITERAL | ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL ) |gset= set | ^( NOT setElement[ns] ) );
+	private void setElement( IIntSet elements )
+	{
+		GrammarAST c=null;
+		GrammarAST t=null;
+		GrammarAST s=null;
+		GrammarAST c1=null;
+		GrammarAST c2=null;
+		TreeToNFAConverter.set_return gset = default(TreeToNFAConverter.set_return);
+
+
+			int ttype;
+			IIntSet ns=null;
+
+		try
+		{
+			// Grammars\\TreeToNFAConverter.g3:599:4: (c= CHAR_LITERAL |t= TOKEN_REF |s= STRING_LITERAL | ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL ) |gset= set | ^( NOT setElement[ns] ) )
+			int alt70=6;
+			switch ( input.LA(1) )
+			{
+			case CHAR_LITERAL:
+				{
+				alt70=1;
+				}
+				break;
+			case TOKEN_REF:
+				{
+				alt70=2;
+				}
+				break;
+			case STRING_LITERAL:
+				{
+				alt70=3;
+				}
+				break;
+			case CHAR_RANGE:
+				{
+				alt70=4;
+				}
+				break;
+			case BLOCK:
+				{
+				alt70=5;
+				}
+				break;
+			case NOT:
+				{
+				alt70=6;
+				}
+				break;
+			default:
+				{
+					NoViableAltException nvae = new NoViableAltException("", 70, 0, input);
+
+					throw nvae;
+				}
+			}
+
+			switch ( alt70 )
+			{
+			case 1:
+				// Grammars\\TreeToNFAConverter.g3:599:4: c= CHAR_LITERAL
+				{
+				c=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_setElement1578);
+
+							if ( grammar.type==Grammar.LEXER )
+							{
+								ttype = Grammar.getCharValueFromGrammarCharLiteral((c!=null?c.Text:null));
+							}
+							else
+							{
+								ttype = grammar.getTokenType((c!=null?c.Text:null));
+							}
+							if ( elements.member(ttype) )
+							{
+								ErrorManager.grammarError(
+									ErrorManager.MSG_DUPLICATE_SET_ENTRY,
+									grammar,
+									c.Token,
+									(c!=null?c.Text:null));
+							}
+							elements.Add(ttype);
+
+
+				}
+				break;
+			case 2:
+				// Grammars\\TreeToNFAConverter.g3:619:4: t= TOKEN_REF
+				{
+				t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_setElement1589);
+
+							if ( grammar.type==Grammar.LEXER )
+							{
+								// recursively will invoke this rule to match elements in target rule ref
+								IIntSet ruleSet = grammar.getSetFromRule(this,(t!=null?t.Text:null));
+								if ( ruleSet==null )
+								{
+									ErrorManager.grammarError(
+										ErrorManager.MSG_RULE_INVALID_SET,
+										grammar,
+										t.Token,
+										(t!=null?t.Text:null));
+								}
+								else
+								{
+									elements.addAll(ruleSet);
+								}
+							}
+							else
+							{
+								ttype = grammar.getTokenType((t!=null?t.Text:null));
+								if ( elements.member(ttype) )
+								{
+									ErrorManager.grammarError(
+										ErrorManager.MSG_DUPLICATE_SET_ENTRY,
+										grammar,
+										t.Token,
+										(t!=null?t.Text:null));
+								}
+								elements.Add(ttype);
+							}
+
+
+				}
+				break;
+			case 3:
+				// Grammars\\TreeToNFAConverter.g3:653:4: s= STRING_LITERAL
+				{
+				s=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_setElement1601);
+
+							ttype = grammar.getTokenType((s!=null?s.Text:null));
+							if ( elements.member(ttype) )
+							{
+								ErrorManager.grammarError(
+									ErrorManager.MSG_DUPLICATE_SET_ENTRY,
+									grammar,
+									s.Token,
+									(s!=null?s.Text:null));
+							}
+							elements.Add(ttype);
+
+
+				}
+				break;
+			case 4:
+				// Grammars\\TreeToNFAConverter.g3:666:4: ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL )
+				{
+				Match(input,CHAR_RANGE,Follow._CHAR_RANGE_in_setElement1611);
+
+				Match(input, TokenConstants.DOWN, null);
+				c1=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_setElement1615);
+				c2=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_setElement1619);
+
+				Match(input, TokenConstants.UP, null);
+
+							if ( grammar.type==Grammar.LEXER )
+							{
+								int a = Grammar.getCharValueFromGrammarCharLiteral((c1!=null?c1.Text:null));
+								int b = Grammar.getCharValueFromGrammarCharLiteral((c2!=null?c2.Text:null));
+								elements.addAll(IntervalSet.of(a,b));
+							}
+
+
+				}
+				break;
+			case 5:
+				// Grammars\\TreeToNFAConverter.g3:676:4: gset= set
+				{
+				PushFollow(Follow._set_in_setElement1632);
+				gset=set();
+
+				state._fsp--;
+
+
+							Transition setTrans = (gset!=null?gset.g:default(StateCluster)).left.getTransition(0);
+							elements.addAll(setTrans.label.Set);
+
+
+				}
+				break;
+			case 6:
+				// Grammars\\TreeToNFAConverter.g3:682:4: ^( NOT setElement[ns] )
+				{
+				Match(input,NOT,Follow._NOT_in_setElement1644);
+
+				ns=new IntervalSet();
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._setElement_in_setElement1651);
+				setElement(ns);
+
+				state._fsp--;
+
+
+								IIntSet not = grammar.complement(ns);
+								elements.addAll(not);
+
+
+				Match(input, TokenConstants.UP, null);
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			ReportError(re);
+			Recover(input,re);
+		}
+		finally
+		{
+		}
+		return ;
+	}
+	// $ANTLR end "setElement"
+
+
+	// $ANTLR start "testBlockAsSet"
+	// Grammars\\TreeToNFAConverter.g3:698:0: testBlockAsSet returns [int alts=0] : ^( BLOCK ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+ EOB ) ;
+	private int testBlockAsSet(  )
+	{
+
+		int alts = 0;
+
+		int testSetElement10 = default(int);
+
+
+			inTest++;
+
+		try
+		{
+			// Grammars\\TreeToNFAConverter.g3:703:4: ( ^( BLOCK ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+ EOB ) )
+			// Grammars\\TreeToNFAConverter.g3:703:4: ^( BLOCK ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+ EOB )
+			{
+			Match(input,BLOCK,Follow._BLOCK_in_testBlockAsSet1685);
+
+			Match(input, TokenConstants.DOWN, null);
+			// Grammars\\TreeToNFAConverter.g3:704:4: ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+
+			int cnt72=0;
+			for ( ; ; )
+			{
+				int alt72=2;
+				int LA72_0 = input.LA(1);
+
+				if ( (LA72_0==ALT) )
+				{
+					alt72=1;
+				}
+
+
+				switch ( alt72 )
+				{
+				case 1:
+					// Grammars\\TreeToNFAConverter.g3:704:6: ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA )
+					{
+					Match(input,ALT,Follow._ALT_in_testBlockAsSet1693);
+
+					Match(input, TokenConstants.DOWN, null);
+					// Grammars\\TreeToNFAConverter.g3:704:12: ( BACKTRACK_SEMPRED )?
+					int alt71=2;
+					int LA71_0 = input.LA(1);
+
+					if ( (LA71_0==BACKTRACK_SEMPRED) )
+					{
+						alt71=1;
+					}
+					switch ( alt71 )
+					{
+					case 1:
+						// Grammars\\TreeToNFAConverter.g3:704:13: BACKTRACK_SEMPRED
+						{
+						Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_testBlockAsSet1696);
+
+						}
+						break;
+
+					}
+
+					PushFollow(Follow._testSetElement_in_testBlockAsSet1700);
+					testSetElement10=testSetElement();
+
+					state._fsp--;
+
+					alts += testSetElement10;
+					Match(input,EOA,Follow._EOA_in_testBlockAsSet1704);
+
+					Match(input, TokenConstants.UP, null);
+
+					}
+					break;
+
+				default:
+					if ( cnt72 >= 1 )
+						goto loop72;
+
+					EarlyExitException eee72 = new EarlyExitException( 72, input );
+					throw eee72;
+				}
+				cnt72++;
+			}
+			loop72:
+				;
+
+
+			Match(input,EOB,Follow._EOB_in_testBlockAsSet1716);
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			 throw re;
+		}
+		finally
+		{
+			 inTest--;
+		}
+		return alts;
+	}
+	// $ANTLR end "testBlockAsSet"
+
+
+	// $ANTLR start "testSetRule"
+	// Grammars\\TreeToNFAConverter.g3:712:0: testSetRule returns [int alts=0] : ^( RULE id= ID ( modifier )? ARG RET ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ^( BLOCK ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+ EOB ) ( exceptionGroup )? EOR ) ;
+	private int testSetRule(  )
+	{
+
+		int alts = 0;
+
+		GrammarAST id=null;
+		int testSetElement11 = default(int);
+
+
+			inTest++;
+
+		try
+		{
+			// Grammars\\TreeToNFAConverter.g3:717:4: ( ^( RULE id= ID ( modifier )? ARG RET ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ^( BLOCK ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+ EOB ) ( exceptionGroup )? EOR ) )
+			// Grammars\\TreeToNFAConverter.g3:717:4: ^( RULE id= ID ( modifier )? ARG RET ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ^( BLOCK ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+ EOB ) ( exceptionGroup )? EOR )
+			{
+			Match(input,RULE,Follow._RULE_in_testSetRule1751);
+
+			Match(input, TokenConstants.DOWN, null);
+			id=(GrammarAST)Match(input,ID,Follow._ID_in_testSetRule1755);
+			// Grammars\\TreeToNFAConverter.g3:717:18: ( modifier )?
+			int alt73=2;
+			int LA73_0 = input.LA(1);
+
+			if ( (LA73_0==FRAGMENT||(LA73_0>=PRIVATE && LA73_0<=PUBLIC)) )
+			{
+				alt73=1;
+			}
+			switch ( alt73 )
+			{
+			case 1:
+				// Grammars\\TreeToNFAConverter.g3:717:19: modifier
+				{
+				PushFollow(Follow._modifier_in_testSetRule1758);
+				modifier();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			Match(input,ARG,Follow._ARG_in_testSetRule1762);
+			Match(input,RET,Follow._RET_in_testSetRule1764);
+			// Grammars\\TreeToNFAConverter.g3:717:38: ( ^( OPTIONS ( . )* ) )?
+			int alt75=2;
+			int LA75_0 = input.LA(1);
+
+			if ( (LA75_0==OPTIONS) )
+			{
+				alt75=1;
+			}
+			switch ( alt75 )
+			{
+			case 1:
+				// Grammars\\TreeToNFAConverter.g3:717:40: ^( OPTIONS ( . )* )
+				{
+				Match(input,OPTIONS,Follow._OPTIONS_in_testSetRule1769);
+
+				if ( input.LA(1)==TokenConstants.DOWN )
+				{
+					Match(input, TokenConstants.DOWN, null);
+					// Grammars\\TreeToNFAConverter.g3:717:50: ( . )*
+					for ( ; ; )
+					{
+						int alt74=2;
+						int LA74_0 = input.LA(1);
+
+						if ( ((LA74_0>=ACTION && LA74_0<=XDIGIT)) )
+						{
+							alt74=1;
+						}
+						else if ( (LA74_0==UP) )
+						{
+							alt74=2;
+						}
+
+
+						switch ( alt74 )
+						{
+						case 1:
+							// Grammars\\TreeToNFAConverter.g3:717:0: .
+							{
+							MatchAny(input);
+
+							}
+							break;
+
+						default:
+							goto loop74;
+						}
+					}
+
+					loop74:
+						;
+
+
+
+					Match(input, TokenConstants.UP, null);
+				}
+
+				}
+				break;
+
+			}
+
+			// Grammars\\TreeToNFAConverter.g3:717:57: ( ruleScopeSpec )?
+			int alt76=2;
+			int LA76_0 = input.LA(1);
+
+			if ( (LA76_0==SCOPE) )
+			{
+				alt76=1;
+			}
+			switch ( alt76 )
+			{
+			case 1:
+				// Grammars\\TreeToNFAConverter.g3:717:59: ruleScopeSpec
+				{
+				PushFollow(Follow._ruleScopeSpec_in_testSetRule1780);
+				ruleScopeSpec();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			// Grammars\\TreeToNFAConverter.g3:718:4: ( ^( AMPERSAND ( . )* ) )*
+			for ( ; ; )
+			{
+				int alt78=2;
+				int LA78_0 = input.LA(1);
+
+				if ( (LA78_0==AMPERSAND) )
+				{
+					alt78=1;
+				}
+
+
+				switch ( alt78 )
+				{
+				case 1:
+					// Grammars\\TreeToNFAConverter.g3:718:6: ^( AMPERSAND ( . )* )
+					{
+					Match(input,AMPERSAND,Follow._AMPERSAND_in_testSetRule1791);
+
+					if ( input.LA(1)==TokenConstants.DOWN )
+					{
+						Match(input, TokenConstants.DOWN, null);
+						// Grammars\\TreeToNFAConverter.g3:718:18: ( . )*
+						for ( ; ; )
+						{
+							int alt77=2;
+							int LA77_0 = input.LA(1);
+
+							if ( ((LA77_0>=ACTION && LA77_0<=XDIGIT)) )
+							{
+								alt77=1;
+							}
+							else if ( (LA77_0==UP) )
+							{
+								alt77=2;
+							}
+
+
+							switch ( alt77 )
+							{
+							case 1:
+								// Grammars\\TreeToNFAConverter.g3:718:0: .
+								{
+								MatchAny(input);
+
+								}
+								break;
+
+							default:
+								goto loop77;
+							}
+						}
+
+						loop77:
+							;
+
+
+
+						Match(input, TokenConstants.UP, null);
+					}
+
+					}
+					break;
+
+				default:
+					goto loop78;
+				}
+			}
+
+			loop78:
+				;
+
+
+			Match(input,BLOCK,Follow._BLOCK_in_testSetRule1805);
+
+			Match(input, TokenConstants.DOWN, null);
+			// Grammars\\TreeToNFAConverter.g3:720:5: ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+
+			int cnt80=0;
+			for ( ; ; )
+			{
+				int alt80=2;
+				int LA80_0 = input.LA(1);
+
+				if ( (LA80_0==ALT) )
+				{
+					alt80=1;
+				}
+
+
+				switch ( alt80 )
+				{
+				case 1:
+					// Grammars\\TreeToNFAConverter.g3:720:7: ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA )
+					{
+					Match(input,ALT,Follow._ALT_in_testSetRule1814);
+
+					Match(input, TokenConstants.DOWN, null);
+					// Grammars\\TreeToNFAConverter.g3:720:13: ( BACKTRACK_SEMPRED )?
+					int alt79=2;
+					int LA79_0 = input.LA(1);
+
+					if ( (LA79_0==BACKTRACK_SEMPRED) )
+					{
+						alt79=1;
+					}
+					switch ( alt79 )
+					{
+					case 1:
+						// Grammars\\TreeToNFAConverter.g3:720:14: BACKTRACK_SEMPRED
+						{
+						Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_testSetRule1817);
+
+						}
+						break;
+
+					}
+
+					PushFollow(Follow._testSetElement_in_testSetRule1821);
+					testSetElement11=testSetElement();
+
+					state._fsp--;
+
+					alts += testSetElement11;
+					Match(input,EOA,Follow._EOA_in_testSetRule1825);
+
+					Match(input, TokenConstants.UP, null);
+
+					}
+					break;
+
+				default:
+					if ( cnt80 >= 1 )
+						goto loop80;
+
+					EarlyExitException eee80 = new EarlyExitException( 80, input );
+					throw eee80;
+				}
+				cnt80++;
+			}
+			loop80:
+				;
+
+
+			Match(input,EOB,Follow._EOB_in_testSetRule1839);
+
+			Match(input, TokenConstants.UP, null);
+			// Grammars\\TreeToNFAConverter.g3:724:4: ( exceptionGroup )?
+			int alt81=2;
+			int LA81_0 = input.LA(1);
+
+			if ( (LA81_0==CATCH||LA81_0==FINALLY) )
+			{
+				alt81=1;
+			}
+			switch ( alt81 )
+			{
+			case 1:
+				// Grammars\\TreeToNFAConverter.g3:724:5: exceptionGroup
+				{
+				PushFollow(Follow._exceptionGroup_in_testSetRule1850);
+				exceptionGroup();
+
+				state._fsp--;
+
+
+				}
+				break;
+
+			}
+
+			Match(input,EOR,Follow._EOR_in_testSetRule1857);
+
+			Match(input, TokenConstants.UP, null);
+
+			}
+
+		}
+		catch ( RecognitionException re )
+		{
+			 throw re;
+		}
+		finally
+		{
+			 inTest--;
+		}
+		return alts;
+	}
+	// $ANTLR end "testSetRule"
+
+
+	// $ANTLR start "testSetElement"
+	// Grammars\\TreeToNFAConverter.g3:732:0: testSetElement returns [int alts=1] : (c= CHAR_LITERAL |t= TOKEN_REF |{...}? =>s= STRING_LITERAL | ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL ) | testBlockAsSet | ^( NOT tse= testSetElement ) );
+	private int testSetElement(  )
+	{
+
+		int alts = 1;
+
+		GrammarAST c=null;
+		GrammarAST t=null;
+		GrammarAST s=null;
+		GrammarAST c1=null;
+		GrammarAST c2=null;
+		int tse = default(int);
+		int testBlockAsSet12 = default(int);
+
+		try
+		{
+			// Grammars\\TreeToNFAConverter.g3:733:4: (c= CHAR_LITERAL |t= TOKEN_REF |{...}? =>s= STRING_LITERAL | ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL ) | testBlockAsSet | ^( NOT tse= testSetElement ) )
+			int alt82=6;
+			int LA82_0 = input.LA(1);
+
+			if ( (LA82_0==CHAR_LITERAL) )
+			{
+				alt82=1;
+			}
+			else if ( (LA82_0==TOKEN_REF) )
+			{
+				alt82=2;
+			}
+			else if ( (LA82_0==STRING_LITERAL) && ((grammar.type!=Grammar.LEXER)))
+			{
+				alt82=3;
+			}
+			else if ( (LA82_0==CHAR_RANGE) )
+			{
+				alt82=4;
+			}
+			else if ( (LA82_0==BLOCK) )
+			{
+				alt82=5;
+			}
+			else if ( (LA82_0==NOT) )
+			{
+				alt82=6;
+			}
+			else
+			{
+				NoViableAltException nvae = new NoViableAltException("", 82, 0, input);
+
+				throw nvae;
+			}
+			switch ( alt82 )
+			{
+			case 1:
+				// Grammars\\TreeToNFAConverter.g3:733:4: c= CHAR_LITERAL
+				{
+				c=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_testSetElement1889);
+
+				}
+				break;
+			case 2:
+				// Grammars\\TreeToNFAConverter.g3:734:4: t= TOKEN_REF
+				{
+				t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_testSetElement1896);
+
+							if ( grammar.type==Grammar.LEXER )
+							{
+								Rule rule = grammar.getRule((t!=null?t.Text:null));
+								if ( rule==null )
+								{
+									//throw new RecognitionException("invalid rule");
+									throw new RecognitionException();
+								}
+								// recursively will invoke this rule to match elements in target rule ref
+								alts += testSetRule(rule.tree);
+							}
+
+
+				}
+				break;
+			case 3:
+				// Grammars\\TreeToNFAConverter.g3:748:6: {...}? =>s= STRING_LITERAL
+				{
+				if ( !((grammar.type!=Grammar.LEXER)) )
+				{
+					throw new FailedPredicateException(input, "testSetElement", "grammar.type!=Grammar.LEXER");
+				}
+				s=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_testSetElement1913);
+
+				}
+				break;
+			case 4:
+				// Grammars\\TreeToNFAConverter.g3:749:4: ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL )
+				{
+				Match(input,CHAR_RANGE,Follow._CHAR_RANGE_in_testSetElement1919);
+
+				Match(input, TokenConstants.DOWN, null);
+				c1=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_testSetElement1923);
+				c2=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_testSetElement1927);
+
+				Match(input, TokenConstants.UP, null);
+				 alts = IntervalSet.of( Grammar.getCharValueFromGrammarCharLiteral((c1!=null?c1.Text:null)), Grammar.getCharValueFromGrammarCharLiteral((c2!=null?c2.Text:null)) ).size();
+
+				}
+				break;
+			case 5:
+				// Grammars\\TreeToNFAConverter.g3:751:6: testBlockAsSet
+				{
+				PushFollow(Follow._testBlockAsSet_in_testSetElement1939);
+				testBlockAsSet12=testBlockAsSet();
+
+				state._fsp--;
+
+				 alts = testBlockAsSet12;
+
+				}
+				break;
+			case 6:
+				// Grammars\\TreeToNFAConverter.g3:753:6: ^( NOT tse= testSetElement )
+				{
+				Match(input,NOT,Follow._NOT_in_testSetElement1952);
+
+				Match(input, TokenConstants.DOWN, null);
+				PushFollow(Follow._testSetElement_in_testSetElement1956);
+				tse=testSetElement();
+
+				state._fsp--;
+
+
+				Match(input, TokenConstants.UP, null);
+				 alts = grammar.TokenTypes.size() - tse;
+
+				}
+				break;
+
+			}
+		}
+		catch ( RecognitionException re )
+		{
+			 throw re;
+		}
+		finally
+		{
+		}
+		return alts;
+	}
+	// $ANTLR end "testSetElement"
+	#endregion
+
+	// Delegated rules
+
+	#region Synpreds
+	#endregion
+
+	#region DFA
+	DFA41 dfa41;
+
+	protected override void InitDFAs()
+	{
+		base.InitDFAs();
+		dfa41 = new DFA41( this );
+	}
+
+	class DFA41 : DFA
+	{
+
+		const string DFA41_eotS =
+			"\x12\xFFFF";
+		const string DFA41_eofS =
+			"\x12\xFFFF";
+		const string DFA41_minS =
+			"\x1\x4\x11\xFFFF";
+		const string DFA41_maxS =
+			"\x1\x5F\x11\xFFFF";
+		const string DFA41_acceptS =
+			"\x1\xFFFF\x1\x1\x1\x2\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9\x1\xA"+
+			"\x1\xB\x1\xC\x1\xD\x1\xE\x1\xF\x1\x10\x1\x11";
+		const string DFA41_specialS =
+			"\x12\xFFFF}>";
+		static readonly string[] DFA41_transitionS =
+			{
+				"\x1\xB\x8\xFFFF\x1\x3\x1\xF\x1\x2\x1\x8\x1\xFFFF\x1\x7\x1\x6\x1\xFFFF"+
+				"\x1\x8\x7\xFFFF\x1\x7\x5\xFFFF\x1\x11\x3\xFFFF\x1\xC\x1\xFFFF\x1\x10"+
+				"\xD\xFFFF\x1\x7\x1\xFFFF\x1\x8\x5\xFFFF\x1\x4\x1\x8\x4\xFFFF\x1\x5\x4"+
+				"\xFFFF\x1\x1\x2\xFFFF\x1\x7\x2\xFFFF\x1\xD\x4\xFFFF\x1\x7\x1\xE\x1\xA"+
+				"\x2\xFFFF\x1\x7\x2\xFFFF\x1\x9\x1\xFFFF\x1\x7",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				"",
+				""
+			};
+
+		static readonly short[] DFA41_eot = DFA.UnpackEncodedString(DFA41_eotS);
+		static readonly short[] DFA41_eof = DFA.UnpackEncodedString(DFA41_eofS);
+		static readonly char[] DFA41_min = DFA.UnpackEncodedStringToUnsignedChars(DFA41_minS);
+		static readonly char[] DFA41_max = DFA.UnpackEncodedStringToUnsignedChars(DFA41_maxS);
+		static readonly short[] DFA41_accept = DFA.UnpackEncodedString(DFA41_acceptS);
+		static readonly short[] DFA41_special = DFA.UnpackEncodedString(DFA41_specialS);
+		static readonly short[][] DFA41_transition;
+
+		static DFA41()
+		{
+			int numStates = DFA41_transitionS.Length;
+			DFA41_transition = new short[numStates][];
+			for ( int i=0; i < numStates; i++ )
+			{
+				DFA41_transition[i] = DFA.UnpackEncodedString(DFA41_transitionS[i]);
+			}
+		}
+
+		public DFA41( BaseRecognizer recognizer )
+		{
+			this.recognizer = recognizer;
+			this.decisionNumber = 41;
+			this.eot = DFA41_eot;
+			this.eof = DFA41_eof;
+			this.min = DFA41_min;
+			this.max = DFA41_max;
+			this.accept = DFA41_accept;
+			this.special = DFA41_special;
+			this.transition = DFA41_transition;
+		}
+		public override string GetDescription()
+		{
+			return "251:0: element returns [StateCluster g=null] : ( ^( ROOT e= element ) | ^( BANG e= element ) | ^( ASSIGN ID e= element ) | ^( PLUS_ASSIGN ID e= element ) | ^( RANGE a= atom[null] b= atom[null] ) | ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL ) | atom_or_notatom | ebnf | tree_ | ^( SYNPRED block ) | ACTION | FORCED_ACTION |pred= SEMPRED |spred= SYN_SEMPRED | ^(bpred= BACKTRACK_SEMPRED ( . )* ) |gpred= GATED_SEMPRED | EPSILON );";
+		}
+	}
+
+
+	#endregion
+
+	#region Follow Sets
+	public static class Follow
+	{
+		public static readonly BitSet _LEXER_GRAMMAR_in_grammar_67 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _grammarSpec_in_grammar_69 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _PARSER_GRAMMAR_in_grammar_79 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _grammarSpec_in_grammar_81 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _TREE_GRAMMAR_in_grammar_91 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _grammarSpec_in_grammar_93 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _COMBINED_GRAMMAR_in_grammar_103 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _grammarSpec_in_grammar_105 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _SCOPE_in_attrScope124 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_attrScope126 = new BitSet(new ulong[]{0x210UL});
+		public static readonly BitSet _AMPERSAND_in_attrScope131 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ACTION_in_attrScope140 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ID_in_grammarSpec153 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
+		public static readonly BitSet _DOC_COMMENT_in_grammarSpec160 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
+		public static readonly BitSet _OPTIONS_in_grammarSpec169 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _IMPORT_in_grammarSpec183 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _TOKENS_in_grammarSpec197 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _attrScope_in_grammarSpec209 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
+		public static readonly BitSet _AMPERSAND_in_grammarSpec218 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _rules_in_grammarSpec230 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _rule_in_rules241 = new BitSet(new ulong[]{0x400200008000202UL,0x8005000UL});
+		public static readonly BitSet _RULE_in_rule255 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_rule259 = new BitSet(new ulong[]{0x10000000400UL,0xEUL});
+		public static readonly BitSet _modifier_in_rule270 = new BitSet(new ulong[]{0x400UL});
+		public static readonly BitSet _ARG_in_rule278 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_ACTION_in_rule281 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _RET_in_rule290 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_ACTION_in_rule293 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _throwsSpec_in_rule302 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
+		public static readonly BitSet _OPTIONS_in_rule312 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ruleScopeSpec_in_rule326 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
+		public static readonly BitSet _AMPERSAND_in_rule337 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _block_in_rule351 = new BitSet(new ulong[]{0x4400020000UL});
+		public static readonly BitSet _exceptionGroup_in_rule357 = new BitSet(new ulong[]{0x400000000UL});
+		public static readonly BitSet _EOR_in_rule364 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _set_in_modifier384 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _THROWS_in_throwsSpec411 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_throwsSpec413 = new BitSet(new ulong[]{0x80000000008UL});
+		public static readonly BitSet _SCOPE_in_ruleScopeSpec428 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _AMPERSAND_in_ruleScopeSpec433 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ACTION_in_ruleScopeSpec443 = new BitSet(new ulong[]{0x80000000008UL});
+		public static readonly BitSet _ID_in_ruleScopeSpec449 = new BitSet(new ulong[]{0x80000000008UL});
+		public static readonly BitSet _set_in_block480 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _BLOCK_in_block490 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _OPTIONS_in_block495 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _alternative_in_block511 = new BitSet(new ulong[]{0x200000100UL,0x200UL});
+		public static readonly BitSet _rewrite_in_block513 = new BitSet(new ulong[]{0x200000100UL,0x200UL});
+		public static readonly BitSet _EOB_in_block536 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ALT_in_alternative565 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _element_in_alternative570 = new BitSet(new ulong[]{0x86800289202DE210UL,0xA4E16421UL});
+		public static readonly BitSet _EOA_in_alternative577 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _exceptionHandler_in_exceptionGroup596 = new BitSet(new ulong[]{0x4000020002UL});
+		public static readonly BitSet _finallyClause_in_exceptionGroup602 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _finallyClause_in_exceptionGroup609 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _CATCH_in_exceptionHandler624 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_ACTION_in_exceptionHandler626 = new BitSet(new ulong[]{0x10UL});
+		public static readonly BitSet _ACTION_in_exceptionHandler628 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _FINALLY_in_finallyClause644 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ACTION_in_finallyClause646 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _REWRITE_in_rewrite669 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ROOT_in_element696 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _element_in_element700 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _BANG_in_element711 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _element_in_element715 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ASSIGN_in_element724 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_element726 = new BitSet(new ulong[]{0x86800289202DE210UL,0xA4E16421UL});
+		public static readonly BitSet _element_in_element730 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _PLUS_ASSIGN_in_element739 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_element741 = new BitSet(new ulong[]{0x86800289202DE210UL,0xA4E16421UL});
+		public static readonly BitSet _element_in_element745 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _RANGE_in_element756 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _atom_in_element760 = new BitSet(new ulong[]{0x20040000UL,0x84202000UL});
+		public static readonly BitSet _atom_in_element765 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _CHAR_RANGE_in_element779 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _CHAR_LITERAL_in_element783 = new BitSet(new ulong[]{0x40000UL});
+		public static readonly BitSet _CHAR_LITERAL_in_element787 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _atom_or_notatom_in_element799 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ebnf_in_element808 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _tree__in_element817 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _SYNPRED_in_element828 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _block_in_element830 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _ACTION_in_element839 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _FORCED_ACTION_in_element848 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _SEMPRED_in_element859 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _SYN_SEMPRED_in_element870 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _BACKTRACK_SEMPRED_in_element882 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _GATED_SEMPRED_in_element897 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _EPSILON_in_element906 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _set_in_ebnf932 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _block_in_ebnf942 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _OPTIONAL_in_ebnf953 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _block_in_ebnf957 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _CLOSURE_in_ebnf970 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _block_in_ebnf974 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _POSITIVE_CLOSURE_in_ebnf987 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _block_in_ebnf991 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _TREE_BEGIN_in_tree_1019 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _element_in_tree_1026 = new BitSet(new ulong[]{0x86800289202DE218UL,0xA4E16421UL});
+		public static readonly BitSet _element_in_tree_1042 = new BitSet(new ulong[]{0x86800289202DE218UL,0xA4E16421UL});
+		public static readonly BitSet _atom_in_atom_or_notatom1071 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _NOT_in_atom_or_notatom1083 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _CHAR_LITERAL_in_atom_or_notatom1092 = new BitSet(new ulong[]{0x8008UL,0x400UL});
+		public static readonly BitSet _ast_suffix_in_atom_or_notatom1097 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _TOKEN_REF_in_atom_or_notatom1114 = new BitSet(new ulong[]{0x8008UL,0x400UL});
+		public static readonly BitSet _ast_suffix_in_atom_or_notatom1119 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _set_in_atom_or_notatom1134 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _RULE_REF_in_atom1176 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_ACTION_in_atom1181 = new BitSet(new ulong[]{0x8008UL,0x400UL});
+		public static readonly BitSet _ast_suffix_in_atom1188 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _TOKEN_REF_in_atom1206 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ARG_ACTION_in_atom1212 = new BitSet(new ulong[]{0x8008UL,0x400UL});
+		public static readonly BitSet _ast_suffix_in_atom1219 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _CHAR_LITERAL_in_atom1237 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ast_suffix_in_atom1243 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _STRING_LITERAL_in_atom1261 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ast_suffix_in_atom1267 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _WILDCARD_in_atom1285 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ast_suffix_in_atom1290 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _DOT_in_atom1307 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_atom1311 = new BitSet(new ulong[]{0x20040000UL,0x84202000UL});
+		public static readonly BitSet _atom_in_atom1315 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _set_in_ast_suffix1332 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _BLOCK_in_set1361 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ALT_in_set1370 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _BACKTRACK_SEMPRED_in_set1375 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _setElement_in_set1384 = new BitSet(new ulong[]{0x100000000UL});
+		public static readonly BitSet _EOA_in_set1387 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _EOB_in_set1397 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _RULE_in_setRule1431 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_setRule1435 = new BitSet(new ulong[]{0x10000000400UL,0xEUL});
+		public static readonly BitSet _modifier_in_setRule1438 = new BitSet(new ulong[]{0x400UL});
+		public static readonly BitSet _ARG_in_setRule1442 = new BitSet(new ulong[]{0x0UL,0x80UL});
+		public static readonly BitSet _RET_in_setRule1444 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
+		public static readonly BitSet _OPTIONS_in_setRule1449 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ruleScopeSpec_in_setRule1460 = new BitSet(new ulong[]{0x10200UL});
+		public static readonly BitSet _AMPERSAND_in_setRule1471 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _BLOCK_in_setRule1485 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _OPTIONS_in_setRule1490 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ALT_in_setRule1508 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _BACKTRACK_SEMPRED_in_setRule1511 = new BitSet(new ulong[]{0x800000000D0000UL,0x4200000UL});
+		public static readonly BitSet _setElement_in_setRule1515 = new BitSet(new ulong[]{0x100000000UL});
+		public static readonly BitSet _EOA_in_setRule1518 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _EOB_in_setRule1530 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _exceptionGroup_in_setRule1542 = new BitSet(new ulong[]{0x400000000UL});
+		public static readonly BitSet _EOR_in_setRule1549 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _CHAR_LITERAL_in_setElement1578 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _TOKEN_REF_in_setElement1589 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _STRING_LITERAL_in_setElement1601 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _CHAR_RANGE_in_setElement1611 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _CHAR_LITERAL_in_setElement1615 = new BitSet(new ulong[]{0x40000UL});
+		public static readonly BitSet _CHAR_LITERAL_in_setElement1619 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _set_in_setElement1632 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _NOT_in_setElement1644 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _setElement_in_setElement1651 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _BLOCK_in_testBlockAsSet1685 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ALT_in_testBlockAsSet1693 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _BACKTRACK_SEMPRED_in_testBlockAsSet1696 = new BitSet(new ulong[]{0x800000000D0000UL,0x4200000UL});
+		public static readonly BitSet _testSetElement_in_testBlockAsSet1700 = new BitSet(new ulong[]{0x100000000UL});
+		public static readonly BitSet _EOA_in_testBlockAsSet1704 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _EOB_in_testBlockAsSet1716 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _RULE_in_testSetRule1751 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ID_in_testSetRule1755 = new BitSet(new ulong[]{0x10000000400UL,0xEUL});
+		public static readonly BitSet _modifier_in_testSetRule1758 = new BitSet(new ulong[]{0x400UL});
+		public static readonly BitSet _ARG_in_testSetRule1762 = new BitSet(new ulong[]{0x0UL,0x80UL});
+		public static readonly BitSet _RET_in_testSetRule1764 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
+		public static readonly BitSet _OPTIONS_in_testSetRule1769 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ruleScopeSpec_in_testSetRule1780 = new BitSet(new ulong[]{0x10200UL});
+		public static readonly BitSet _AMPERSAND_in_testSetRule1791 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _BLOCK_in_testSetRule1805 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _ALT_in_testSetRule1814 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _BACKTRACK_SEMPRED_in_testSetRule1817 = new BitSet(new ulong[]{0x800000000D0000UL,0x4200000UL});
+		public static readonly BitSet _testSetElement_in_testSetRule1821 = new BitSet(new ulong[]{0x100000000UL});
+		public static readonly BitSet _EOA_in_testSetRule1825 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _EOB_in_testSetRule1839 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _exceptionGroup_in_testSetRule1850 = new BitSet(new ulong[]{0x400000000UL});
+		public static readonly BitSet _EOR_in_testSetRule1857 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _CHAR_LITERAL_in_testSetElement1889 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _TOKEN_REF_in_testSetElement1896 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _STRING_LITERAL_in_testSetElement1913 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _CHAR_RANGE_in_testSetElement1919 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _CHAR_LITERAL_in_testSetElement1923 = new BitSet(new ulong[]{0x40000UL});
+		public static readonly BitSet _CHAR_LITERAL_in_testSetElement1927 = new BitSet(new ulong[]{0x8UL});
+		public static readonly BitSet _testBlockAsSet_in_testSetElement1939 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _NOT_in_testSetElement1952 = new BitSet(new ulong[]{0x4UL});
+		public static readonly BitSet _testSetElement_in_testSetElement1956 = new BitSet(new ulong[]{0x8UL});
+
+	}
+	#endregion
+}
+
+} // namespace Antlr3.Grammars
diff --git a/Antlr3/Grammars/TreeToNFAConverter.g3 b/Antlr3/Grammars/TreeToNFAConverter.g3
new file mode 100644
index 0000000..4612cab
--- /dev/null
+++ b/Antlr3/Grammars/TreeToNFAConverter.g3
@@ -0,0 +1,756 @@
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/** Build an NFA from a tree representing an ANTLR grammar. */
+tree grammar TreeToNFAConverter;
+
+options
+{
+	language=CSharp3;
+	tokenVocab = ANTLR;
+	ASTLabelType = GrammarAST;
+}
+
+@header
+{
+/*
+ [The "BSD licence"]
+ Copyright (c) 2005-2008 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3 and C#:
+ Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+using Antlr3.Analysis;
+using Antlr3.Misc;
+using Antlr3.Tool;
+
+using BitSet = Antlr.Runtime.BitSet;
+using DFA = Antlr.Runtime.DFA;
+}
+
+@namespace{Antlr3.Grammars}
+
+public
+grammar_
+@after
+{
+	finish();
+}
+	:	(	^( LEXER_GRAMMAR grammarSpec )
+		|	^( PARSER_GRAMMAR grammarSpec )
+		|	^( TREE_GRAMMAR grammarSpec )
+		|	^( COMBINED_GRAMMAR grammarSpec )
+		)
+	;
+
+attrScope
+	:	^( 'scope' ID ( ^(AMPERSAND .*) )* ACTION )
+	;
+
+grammarSpec
+	:	ID
+		(cmt=DOC_COMMENT)?
+		( ^(OPTIONS .*) )?
+		( ^(IMPORT .*) )?
+		( ^(TOKENS .*) )?
+		(attrScope)*
+		( ^(AMPERSAND .*) )* // skip actions
+		rules
+	;
+
+rules
+	: rule+
+	;
+
+rule
+	:	^(	RULE id=ID
+			{
+				currentRuleName = $id.text;
+				factory.setCurrentRule( grammar.getLocallyDefinedRule(currentRuleName) );
+			}
+			(modifier)?
+			^(ARG (ARG_ACTION)?)
+			^(RET (ARG_ACTION)?)
+			(throwsSpec)?
+			( ^(OPTIONS .*) )?
+			( ruleScopeSpec )?
+			( ^(AMPERSAND .*) )*
+			b=block
+			(exceptionGroup)?
+			EOR
+			{
+				StateCluster g = $b.g;
+				if ( $b.start.SetValue!=null )
+				{
+					// if block comes back as a set not BLOCK, make it
+					// a single ALT block
+					g = factory.build_AlternativeBlockFromSet(g);
+				}
+				if ( char.IsLower(currentRuleName[0]) ||
+					 grammar.type==Grammar.LEXER )
+				{
+					// attach start node to block for this rule
+					Rule thisR = grammar.getLocallyDefinedRule(currentRuleName);
+					NFAState start = thisR.startState;
+					start.associatedASTNode = $id;
+					start.addTransition(new Transition(Label.EPSILON, g.left));
+
+					// track decision if > 1 alts
+					if ( grammar.getNumberOfAltsForDecisionNFA(g.left)>1 )
+					{
+						g.left.Description = grammar.grammarTreeToString($start,false);
+						g.left.setDecisionASTNode($b.start);
+						int d = grammar.assignDecisionNumber( g.left );
+						grammar.setDecisionNFA( d, g.left );
+						grammar.setDecisionBlockAST(d, $b.start);
+					}
+
+					// hook to end of rule node
+					NFAState end = thisR.stopState;
+					g.right.addTransition(new Transition(Label.EPSILON,end));
+				}
+			}
+		)
+	;
+
+modifier
+	:	'protected'
+	|	'public'
+	|	'private'
+	|	'fragment'
+	;
+
+throwsSpec
+	:	^('throws' ID+)
+	;
+
+ruleScopeSpec
+	:	^( 'scope' ( ^(AMPERSAND .*) )* (ACTION)? ( ID )* )
+	;
+
+block returns [StateCluster g = null]
+@init
+{
+	List<StateCluster> alts = new List<StateCluster>();
+	this.blockLevel++;
+	if ( this.blockLevel==1 )
+		this.outerAltNum=1;
+}
+	:	{grammar.isValidSet(this,$start) &&
+		 !currentRuleName.Equals(Grammar.ARTIFICIAL_TOKENS_RULENAME)}? =>
+		set {$g = $set.g;}
+
+	|	^(	BLOCK ( ^(OPTIONS .*) )?
+			(	a=alternative rewrite
+				{
+					alts.Add($a.g);
+				}
+				{{
+					if ( blockLevel == 1 )
+						outerAltNum++;
+				}}
+			)+
+			EOB
+		)
+		{$g = factory.build_AlternativeBlock(alts);}
+	;
+finally { blockLevel--; }
+
+alternative returns [StateCluster g=null]
+	:	^( ALT (e=element {$g = factory.build_AB($g,$e.g);} )+ EOA )
+		{
+			if ($g==null) { // if alt was a list of actions or whatever
+				$g = factory.build_Epsilon();
+			}
+			else {
+				factory.optimizeAlternative($g);
+			}
+		}
+	;
+
+exceptionGroup
+	:	( exceptionHandler )+ (finallyClause)?
+	|	finallyClause
+	;
+
+exceptionHandler
+	:    ^('catch' ARG_ACTION ACTION)
+	;
+
+finallyClause
+	:    ^('finally' ACTION)
+	;
+
+rewrite
+	:	(
+			{
+				if ( grammar.getOption("output")==null )
+				{
+					ErrorManager.grammarError(ErrorManager.MSG_REWRITE_OR_OP_WITH_NO_OUTPUT_OPTION,
+											  grammar, $start.Token, currentRuleName);
+				}
+			}
+			^(REWRITE .*)
+		)*
+	;
+
+element returns [StateCluster g=null]
+	:   ^(ROOT e=element {$g = $e.g;})
+	|   ^(BANG e=element {$g = $e.g;})
+	|	^(ASSIGN ID e=element {$g = $e.g;})
+	|	^(PLUS_ASSIGN ID e=element {$g = $e.g;})
+	|   ^(RANGE a=atom[null] b=atom[null])
+		{$g = factory.build_Range(grammar.getTokenType($a.text),
+								 grammar.getTokenType($b.text));}
+	|   ^(CHAR_RANGE c1=CHAR_LITERAL c2=CHAR_LITERAL)
+		{
+		if ( grammar.type==Grammar.LEXER ) {
+			$g = factory.build_CharRange($c1.text, $c2.text);
+		}
+		}
+	|   atom_or_notatom {$g = $atom_or_notatom.g;}
+	|   ebnf {$g = $ebnf.g;}
+	|   tree_ {$g = $tree_.g;}
+	|   ^( SYNPRED block )
+	|   ACTION {$g = factory.build_Action($ACTION);}
+	|   FORCED_ACTION {$g = factory.build_Action($FORCED_ACTION);}
+	|   pred=SEMPRED {$g = factory.build_SemanticPredicate($pred);}
+	|   spred=SYN_SEMPRED {$g = factory.build_SemanticPredicate($spred);}
+	|   ^(bpred=BACKTRACK_SEMPRED .*) {$g = factory.build_SemanticPredicate($bpred);}
+	|   gpred=GATED_SEMPRED {$g = factory.build_SemanticPredicate($gpred);}
+	|   EPSILON {$g = factory.build_Epsilon();}
+	;
+
+ebnf returns [StateCluster g=null]
+@init
+{
+	GrammarAST blk = $start;
+	if ( blk.Type!=BLOCK ) {
+		blk = (GrammarAST)blk.GetChild(0);
+	}
+	GrammarAST eob = blk.getLastChild();
+}
+	:	{grammar.isValidSet(this,$start)}? => set {$g = $set.g;}
+
+	|	b=block
+		{
+			// track decision if > 1 alts
+			if ( grammar.getNumberOfAltsForDecisionNFA($b.g.left)>1 )
+			{
+				$b.g.left.Description = grammar.grammarTreeToString(blk,false);
+				$b.g.left.setDecisionASTNode(blk);
+				int d = grammar.assignDecisionNumber( $b.g.left );
+				grammar.setDecisionNFA( d, $b.g.left );
+				grammar.setDecisionBlockAST(d, blk);
+			}
+			$g = $b.g;
+		}
+	|	^( OPTIONAL b=block )
+		{
+			StateCluster bg = $b.g;
+			if ( blk.SetValue!=null )
+			{
+				// if block comes back SET not BLOCK, make it
+				// a single ALT block
+				bg = factory.build_AlternativeBlockFromSet(bg);
+			}
+			$g = factory.build_Aoptional(bg);
+			$g.left.Description = grammar.grammarTreeToString($start,false);
+			// there is always at least one alt even if block has just 1 alt
+			int d = grammar.assignDecisionNumber( $g.left );
+			grammar.setDecisionNFA(d, $g.left);
+			grammar.setDecisionBlockAST(d, blk);
+			$g.left.setDecisionASTNode($start);
+		}
+	|	^( CLOSURE b=block )
+		{
+			StateCluster bg = $b.g;
+			if ( blk.SetValue!=null )
+			{
+				bg = factory.build_AlternativeBlockFromSet(bg);
+			}
+			$g = factory.build_Astar(bg);
+			// track the loop back / exit decision point
+			bg.right.Description = "()* loopback of "+grammar.grammarTreeToString($start,false);
+			int d = grammar.assignDecisionNumber( bg.right );
+			grammar.setDecisionNFA(d, bg.right);
+			grammar.setDecisionBlockAST(d, blk);
+			bg.right.setDecisionASTNode(eob);
+			// make block entry state also have same decision for interpreting grammar
+			NFAState altBlockState = (NFAState)$g.left.getTransition(0).target;
+			altBlockState.setDecisionASTNode($start);
+			altBlockState.DecisionNumber = d;
+			$g.left.DecisionNumber = d; // this is the bypass decision (2 alts)
+			$g.left.setDecisionASTNode($start);
+		}
+	|	^( POSITIVE_CLOSURE b=block )
+		{
+			StateCluster bg = $b.g;
+			if ( blk.SetValue!=null )
+			{
+				bg = factory.build_AlternativeBlockFromSet(bg);
+			}
+			$g = factory.build_Aplus(bg);
+			// don't make a decision on left edge, can reuse loop end decision
+			// track the loop back / exit decision point
+			bg.right.Description = "()+ loopback of "+grammar.grammarTreeToString($start,false);
+			int d = grammar.assignDecisionNumber( bg.right );
+			grammar.setDecisionNFA(d, bg.right);
+			grammar.setDecisionBlockAST(d, blk);
+			bg.right.setDecisionASTNode(eob);
+			// make block entry state also have same decision for interpreting grammar
+			NFAState altBlockState = (NFAState)$g.left.getTransition(0).target;
+			altBlockState.setDecisionASTNode($start);
+			altBlockState.DecisionNumber = d;
+		}
+	;
+
+tree_ returns [StateCluster g=null]
+@init
+{
+	StateCluster down=null, up=null;
+}
+	:	^(	TREE_BEGIN
+			e=element { $g = $e.g; }
+			{
+				down = factory.build_Atom(Label.DOWN, $e.start);
+				// TODO set following states for imaginary nodes?
+				//el.followingNFAState = down.right;
+				$g = factory.build_AB($g,down);
+			}
+			( e=element {$g = factory.build_AB($g,$e.g);} )*
+			{
+				up = factory.build_Atom(Label.UP, $e.start);
+				//el.followingNFAState = up.right;
+				$g = factory.build_AB($g,up);
+				// tree roots point at right edge of DOWN for LOOK computation later
+				$start.NFATreeDownState = down.left;
+			}
+		)
+	;
+
+atom_or_notatom returns [StateCluster g=null]
+	:	atom[null] {$g = $atom.g;}
+	|	^(	n=NOT
+			(	c=CHAR_LITERAL (ast1=ast_suffix)?
+				{
+					int ttype=0;
+					if ( grammar.type==Grammar.LEXER )
+					{
+						ttype = Grammar.getCharValueFromGrammarCharLiteral($c.text);
+					}
+					else
+					{
+						ttype = grammar.getTokenType($c.text);
+					}
+					IIntSet notAtom = grammar.complement(ttype);
+					if ( notAtom.isNil() )
+					{
+						ErrorManager.grammarError(
+							ErrorManager.MSG_EMPTY_COMPLEMENT,
+							grammar,
+							$c.Token,
+							$c.text);
+					}
+					$g=factory.build_Set(notAtom,$n);
+				}
+			|	t=TOKEN_REF (ast3=ast_suffix)?
+				{
+					int ttype=0;
+					IIntSet notAtom = null;
+					if ( grammar.type==Grammar.LEXER )
+					{
+						notAtom = grammar.getSetFromRule(this,$t.text);
+						if ( notAtom==null )
+						{
+							ErrorManager.grammarError(
+								ErrorManager.MSG_RULE_INVALID_SET,
+								grammar,
+								$t.Token,
+								$t.text);
+						}
+						else
+						{
+							notAtom = grammar.complement(notAtom);
+						}
+					}
+					else
+					{
+						ttype = grammar.getTokenType($t.text);
+						notAtom = grammar.complement(ttype);
+					}
+					if ( notAtom==null || notAtom.isNil() )
+					{
+						ErrorManager.grammarError(
+							ErrorManager.MSG_EMPTY_COMPLEMENT,
+							grammar,
+							$t.Token,
+							$t.text);
+					}
+					$g=factory.build_Set(notAtom,$n);
+				}
+			|	set {$g = $set.g;}
+				{
+					GrammarAST stNode = (GrammarAST)$n.GetChild(0);
+					//IIntSet notSet = grammar.complement(stNode.SetValue);
+					// let code generator complement the sets
+					IIntSet s = stNode.SetValue;
+					stNode.setSetValue(s);
+					// let code gen do the complement again; here we compute
+					// for NFA construction
+					s = grammar.complement(s);
+					if ( s.isNil() )
+					{
+						ErrorManager.grammarError(
+							ErrorManager.MSG_EMPTY_COMPLEMENT,
+							grammar,
+							$n.Token);
+					}
+					$g=factory.build_Set(s,$n);
+				}
+			)
+			{$n.followingNFAState = $g.right;}
+		)
+	;
+
+atom[string scopeName] returns [StateCluster g=null]
+	:	^( r=RULE_REF (rarg=ARG_ACTION)? (as1=ast_suffix)? )
+		{
+			NFAState start = grammar.getRuleStartState(scopeName,$r.text);
+			if ( start!=null )
+			{
+				Rule rr = grammar.getRule(scopeName,$r.text);
+				$g = factory.build_RuleRef(rr, start);
+				r.followingNFAState = $g.right;
+				r._nfaStartState = $g.left;
+				if ( $g.left.getTransition(0) is RuleClosureTransition
+					&& grammar.type!=Grammar.LEXER )
+				{
+					addFollowTransition($r.text, $g.right);
+				}
+				// else rule ref got inlined to a set
+			}
+		}
+
+	|	^( t=TOKEN_REF  (targ=ARG_ACTION)? (as2=ast_suffix)? )
+		{
+			if ( grammar.type==Grammar.LEXER )
+			{
+				NFAState start = grammar.getRuleStartState(scopeName,$t.text);
+				if ( start!=null )
+				{
+					Rule rr = grammar.getRule(scopeName,t.Text);
+					$g = factory.build_RuleRef(rr, start);
+					t._nfaStartState = $g.left;
+					// don't add FOLLOW transitions in the lexer;
+					// only exact context should be used.
+				}
+			}
+			else
+			{
+				$g = factory.build_Atom(t);
+				t.followingNFAState = $g.right;
+			}
+		}
+
+	|	^( c=CHAR_LITERAL  (as3=ast_suffix)? )
+		{
+			if ( grammar.type==Grammar.LEXER )
+			{
+				$g = factory.build_CharLiteralAtom(c);
+			}
+			else
+			{
+				$g = factory.build_Atom(c);
+				c.followingNFAState = $g.right;
+			}
+		}
+
+	|	^( s=STRING_LITERAL  (as4=ast_suffix)? )
+		{
+			if ( grammar.type==Grammar.LEXER )
+			{
+				$g = factory.build_StringLiteralAtom(s);
+			}
+			else
+			{
+				$g = factory.build_Atom(s);
+				s.followingNFAState = $g.right;
+			}
+		}
+
+	|	^(	w=WILDCARD (as5=ast_suffix)? )
+			{
+				if ( nfa.grammar.type == Grammar.TREE_PARSER
+					&& (w.ChildIndex > 0 || w.Parent.GetChild(1).Type == EOA) )
+				{
+					$g = factory.build_WildcardTree( $w );
+				}
+				else
+				{
+					$g = factory.build_Wildcard( $w );
+				}
+			}
+
+	|	^( DOT scope_=ID a=atom[$scope_.text] {$g = $a.g;} ) // scope override
+	;
+
+ast_suffix
+	:	ROOT
+	|	BANG
+	;
+
+set returns [StateCluster g=null]
+@init
+{
+	IIntSet elements=new IntervalSet();
+	if ( state.backtracking == 0 )
+		$start.setSetValue(elements); // track set for use by code gen
+}
+	:	^( b=BLOCK
+		   (^(ALT ( ^(BACKTRACK_SEMPRED .*) )? setElement[elements] EOA))+
+		   EOB
+		 )
+		{
+		$g = factory.build_Set(elements,$b);
+		$b.followingNFAState = $g.right;
+		$b.setSetValue(elements); // track set value of this block
+		}
+		//{System.out.println("set elements="+elements.toString(grammar));}
+	;
+
+setRule returns [IIntSet elements=new IntervalSet()]
+@init
+{
+	IIntSet s=null;
+}
+	:	^( RULE id=ID (modifier)? ARG RET ( ^(OPTIONS .*) )? ( ruleScopeSpec )?
+			( ^(AMPERSAND .*) )*
+			^( BLOCK ( ^(OPTIONS .*) )?
+			   ( ^(ALT (BACKTRACK_SEMPRED)? setElement[elements] EOA) )+
+			   EOB
+			 )
+			(exceptionGroup)?
+			EOR
+		 )
+	;
+catch[RecognitionException re] { throw re; }
+
+setElement[IIntSet elements]
+@init
+{
+	int ttype;
+	IIntSet ns=null;
+}
+	:	c=CHAR_LITERAL
+		{
+			if ( grammar.type==Grammar.LEXER )
+			{
+				ttype = Grammar.getCharValueFromGrammarCharLiteral($c.text);
+			}
+			else
+			{
+				ttype = grammar.getTokenType($c.text);
+			}
+			if ( elements.member(ttype) )
+			{
+				ErrorManager.grammarError(
+					ErrorManager.MSG_DUPLICATE_SET_ENTRY,
+					grammar,
+					$c.Token,
+					$c.text);
+			}
+			elements.Add(ttype);
+		}
+	|	t=TOKEN_REF
+		{
+			if ( grammar.type==Grammar.LEXER )
+			{
+				// recursively will invoke this rule to match elements in target rule ref
+				IIntSet ruleSet = grammar.getSetFromRule(this,$t.text);
+				if ( ruleSet==null )
+				{
+					ErrorManager.grammarError(
+						ErrorManager.MSG_RULE_INVALID_SET,
+						grammar,
+						$t.Token,
+						$t.text);
+				}
+				else
+				{
+					elements.addAll(ruleSet);
+				}
+			}
+			else
+			{
+				ttype = grammar.getTokenType($t.text);
+				if ( elements.member(ttype) )
+				{
+					ErrorManager.grammarError(
+						ErrorManager.MSG_DUPLICATE_SET_ENTRY,
+						grammar,
+						$t.Token,
+						$t.text);
+				}
+				elements.Add(ttype);
+			}
+		}
+
+	|	s=STRING_LITERAL
+		{
+			ttype = grammar.getTokenType($s.text);
+			if ( elements.member(ttype) )
+			{
+				ErrorManager.grammarError(
+					ErrorManager.MSG_DUPLICATE_SET_ENTRY,
+					grammar,
+					$s.Token,
+					$s.text);
+			}
+			elements.Add(ttype);
+		}
+	|	^(CHAR_RANGE c1=CHAR_LITERAL c2=CHAR_LITERAL)
+		{
+			if ( grammar.type==Grammar.LEXER )
+			{
+				int a = Grammar.getCharValueFromGrammarCharLiteral($c1.text);
+				int b = Grammar.getCharValueFromGrammarCharLiteral($c2.text);
+				elements.addAll(IntervalSet.of(a,b));
+			}
+		}
+
+	|	gset=set
+		{
+			Transition setTrans = $gset.g.left.getTransition(0);
+			elements.addAll(setTrans.label.Set);
+		}
+
+	|	^(	NOT {ns=new IntervalSet();}
+			setElement[ns]
+			{
+				IIntSet not = grammar.complement(ns);
+				elements.addAll(not);
+			}
+		)
+	;
+
+/** Check to see if this block can be a set.  Can't have actions
+ *  etc...  Also can't be in a rule with a rewrite as we need
+ *  to track what's inside set for use in rewrite.
+ *
+ *  This should only be called from the helper function in TreeToNFAConverterHelper.cs
+ *  and from the rule testSetElement below.
+ */
+testBlockAsSet returns [int alts=0]
+@init
+{
+	inTest++;
+}
+	:	^(	BLOCK
+			(	^(ALT (BACKTRACK_SEMPRED)? testSetElement {{$alts += $testSetElement.alts;}} EOA)
+			)+
+			EOB
+		)
+	;
+catch[RecognitionException re] { throw re; }
+finally { inTest--; }
+
+testSetRule returns [int alts=0]
+@init
+{
+	inTest++;
+}
+	:	^(	RULE id=ID (modifier)? ARG RET ( ^(OPTIONS .*) )? ( ruleScopeSpec )?
+			( ^(AMPERSAND .*) )*
+			^(	BLOCK
+				(	^(ALT (BACKTRACK_SEMPRED)? testSetElement {{$alts += $testSetElement.alts;}} EOA)
+				)+
+				EOB
+			)
+			(exceptionGroup)?
+			EOR
+		)
+	;
+catch[RecognitionException re] { throw re; }
+finally { inTest--; }
+
+/** Match just an element; no ast suffix etc.. */
+testSetElement returns [int alts=1]
+	:	c=CHAR_LITERAL
+	|	t=TOKEN_REF
+		{{
+			if ( grammar.type==Grammar.LEXER )
+			{
+				Rule rule = grammar.getRule($t.text);
+				if ( rule==null )
+				{
+					//throw new RecognitionException("invalid rule");
+					throw new RecognitionException();
+				}
+				// recursively will invoke this rule to match elements in target rule ref
+				$alts += testSetRule(rule.tree);
+			}
+		}}
+	|   {grammar.type!=Grammar.LEXER}? => s=STRING_LITERAL
+	|	^(CHAR_RANGE c1=CHAR_LITERAL c2=CHAR_LITERAL)
+		{{ $alts = IntervalSet.of( Grammar.getCharValueFromGrammarCharLiteral($c1.text), Grammar.getCharValueFromGrammarCharLiteral($c2.text) ).size(); }}
+	|   testBlockAsSet
+		{{ $alts = $testBlockAsSet.alts; }}
+	|   ^( NOT tse=testSetElement )
+		{{ $alts = grammar.TokenTypes.size() - $tse.alts; }}
+	;
+catch[RecognitionException re] { throw re; }
diff --git a/Antlr3/Grammars/TreeToNFAConverterHelper.cs b/Antlr3/Grammars/TreeToNFAConverterHelper.cs
new file mode 100644
index 0000000..45f83c9
--- /dev/null
+++ b/Antlr3/Grammars/TreeToNFAConverterHelper.cs
@@ -0,0 +1,165 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Grammar conversion to ANTLR v3 and C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *	notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	notice, this list of conditions and the following disclaimer in the
+ *	documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *	derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Grammars
+{
+    using System.Collections.Generic;
+    using Antlr.Runtime;
+    using Antlr.Runtime.JavaExtensions;
+    using Antlr3.Analysis;
+    using Antlr3.Tool;
+
+    using ArrayList = System.Collections.Generic.List<object>;
+    using CommonTreeNodeStream = Antlr.Runtime.Tree.CommonTreeNodeStream;
+    using IIntSet = Antlr3.Misc.IIntSet;
+    using IList = System.Collections.IList;
+    using ITreeNodeStream = Antlr.Runtime.Tree.ITreeNodeStream;
+
+    partial class TreeToNFAConverter
+    {
+        /** Factory used to create nodes and submachines */
+        protected NFAFactory factory = null;
+
+        /** Which NFA object are we filling in? */
+        protected NFA nfa = null;
+
+        /** Which grammar are we converting an NFA for? */
+        protected Grammar grammar = null;
+
+        protected string currentRuleName = null;
+
+        protected int outerAltNum = 0;
+        protected int blockLevel = 0;
+
+        protected int inTest = 0;
+
+        public TreeToNFAConverter( Grammar g, NFA nfa, NFAFactory factory, ITreeNodeStream input )
+            : this( input )
+        {
+            this.grammar = g;
+            this.nfa = nfa;
+            this.factory = factory;
+        }
+
+        public IIntSet setRule( GrammarAST t )
+        {
+            TreeToNFAConverter other = new TreeToNFAConverter( grammar, nfa, factory, new CommonTreeNodeStream( t ) );
+
+            other.currentRuleName = currentRuleName;
+            other.outerAltNum = outerAltNum;
+            other.blockLevel = blockLevel;
+
+            return other.setRule();
+        }
+        internal int testBlockAsSet( GrammarAST t )
+        {
+            Rule r = grammar.getLocallyDefinedRule( currentRuleName );
+            if ( r.hasRewrite( outerAltNum ) )
+                return -1;
+
+            TreeToNFAConverter other = new TreeToNFAConverter( grammar, nfa, factory, new CommonTreeNodeStream( t ) );
+
+            other.currentRuleName = currentRuleName;
+            other.outerAltNum = outerAltNum;
+            other.blockLevel = blockLevel;
+
+            return other.testBlockAsSet();
+        }
+        public int testSetRule( GrammarAST t )
+        {
+            TreeToNFAConverter other = new TreeToNFAConverter( grammar, nfa, factory, new CommonTreeNodeStream( t ) );
+
+            other.currentRuleName = currentRuleName;
+            other.outerAltNum = outerAltNum;
+            other.blockLevel = blockLevel;
+
+            return other.testSetRule();
+        }
+
+        protected virtual void addFollowTransition( string ruleName, NFAState following )
+        {
+            //System.out.println("adding follow link to rule "+ruleName);
+            // find last link in FOLLOW chain emanating from rule
+            Rule r = grammar.getRule( ruleName );
+            NFAState end = r.stopState;
+            while ( end.getTransition( 1 ) != null )
+            {
+                end = (NFAState)end.getTransition( 1 ).target;
+            }
+            if ( end.getTransition( 0 ) != null )
+            {
+                // already points to a following node
+                // gotta add another node to keep edges to a max of 2
+                NFAState n = factory.newState();
+                Transition e = new Transition( Label.EPSILON, n );
+                end.addTransition( e );
+                end = n;
+            }
+            Transition followEdge = new Transition( Label.EPSILON, following );
+            end.addTransition( followEdge );
+        }
+
+        protected virtual void finish()
+        {
+            int numEntryPoints = factory.build_EOFStates( grammar.Rules );
+            if ( numEntryPoints == 0 )
+            {
+                ErrorManager.grammarWarning( ErrorManager.MSG_NO_GRAMMAR_START_RULE,
+                                           grammar,
+                                           null,
+                                           grammar.name );
+            }
+        }
+
+        public override void ReportError( RecognitionException ex )
+        {
+            if ( inTest > 0 )
+                throw ex;
+
+            IToken token = null;
+            if ( ex is MismatchedTokenException )
+            {
+                token = ( (MismatchedTokenException)ex ).token;
+            }
+            else if ( ex is NoViableAltException )
+            {
+                token = ( (NoViableAltException)ex ).token;
+            }
+            ErrorManager.syntaxError(
+                ErrorManager.MSG_SYNTAX_ERROR,
+                grammar,
+                token,
+                "buildnfa: " + ex.ToString(),
+                ex );
+        }
+    }
+}
diff --git a/Antlr3/Misc/Barrier.cs b/Antlr3/Misc/Barrier.cs
new file mode 100644
index 0000000..16ea4e9
--- /dev/null
+++ b/Antlr3/Misc/Barrier.cs
@@ -0,0 +1,87 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Misc
+{
+
+    /**A very simple barrier wait.  Once a thread has requested a
+     * wait on the barrier with waitForRelease, it cannot fool the
+     * barrier into releasing by "hitting" the barrier multiple times--
+     * the thread is blocked on the wait().
+     */
+    public class Barrier
+    {
+        protected int threshold;
+        protected int count = 0;
+
+        public Barrier( int t )
+        {
+            threshold = t;
+        }
+
+        public /*synchronized*/ void waitForRelease()
+        {
+            throw new System.NotImplementedException( "synchronized and confusing ??" );
+#if false
+            count++;
+            // The final thread to reach barrier resets barrier and
+            // releases all threads
+            if ( count == threshold )
+            {
+                // notify blocked threads that threshold has been reached
+                action(); // perform the requested operation
+                notifyAll();
+            }
+            else
+                while ( count < threshold )
+                {
+                    wait();
+                }
+#endif
+        }
+
+        private void wait()
+        {
+            throw new System.NotImplementedException();
+        }
+
+        private void notifyAll()
+        {
+            throw new System.NotImplementedException();
+        }
+
+        /** What to do when everyone reaches barrier */
+        public void action()
+        {
+        }
+    }
+}
diff --git a/Antlr3/Misc/BitSet.cs b/Antlr3/Misc/BitSet.cs
new file mode 100644
index 0000000..d793e9c
--- /dev/null
+++ b/Antlr3/Misc/BitSet.cs
@@ -0,0 +1,815 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Misc
+{
+    using System.Collections.Generic;
+    using System.Linq;
+    using Antlr.Runtime.JavaExtensions;
+
+    using ArgumentException = System.ArgumentException;
+    using Array = System.Array;
+    using Grammar = Antlr3.Tool.Grammar;
+    using ICloneable = System.ICloneable;
+    using IDictionary = System.Collections.IDictionary;
+    using IEnumerable = System.Collections.IEnumerable;
+    using IList = System.Collections.IList;
+    using Label = Antlr3.Analysis.Label;
+    using Math = System.Math;
+    using NotImplementedException = System.NotImplementedException;
+    using StringBuilder = System.Text.StringBuilder;
+
+    /**A BitSet to replace java.util.BitSet.
+     *
+     * Primary differences are that most set operators return new sets
+     * as opposed to oring and anding "in place".  Further, a number of
+     * operations were added.  I cannot contain a BitSet because there
+     * is no way to access the internal bits (which I need for speed)
+     * and, because it is final, I cannot subclass to add functionality.
+     * Consider defining set degree.  Without access to the bits, I must
+     * call a method n times to test the ith bit...ack!
+     *
+     * Also seems like or() from util is wrong when size of incoming set is bigger
+     * than this.bits.length.
+     *
+     * @author Terence Parr
+     */
+    public class BitSet : IIntSet, ICloneable
+    {
+        protected const int BITS = 64;    // number of bits / long
+        protected const int LOG_BITS = 6; // 2^6 == 64
+
+        /* We will often need to do a mod operator (i mod nbits).  Its
+         * turns out that, for powers of two, this mod operation is
+         * same as (i & (nbits-1)).  Since mod is slow, we use a
+         * precomputed mod mask to do the mod instead.
+         */
+        protected const int MOD_MASK = BITS - 1;
+
+        /** The actual data bits */
+        protected ulong[] bits;
+
+        /** Construct a bitset of size one word (64 bits) */
+        public BitSet() :
+            this( BITS )
+        {
+        }
+
+        /** Construction from a static array of longs */
+        public BitSet( ulong[] bits_ )
+        {
+            bits = bits_;
+        }
+
+        /** Construct a bitset given the size
+         * @param nbits The size of the bitset in bits
+         */
+        public BitSet( int nbits )
+        {
+            bits = new ulong[( ( nbits - 1 ) >> LOG_BITS ) + 1];
+        }
+
+        #region Properties
+        public bool IsNil
+        {
+            get
+            {
+                return isNil();
+            }
+        }
+        public int LengthInLongWords
+        {
+            get
+            {
+                return lengthInLongWords();
+            }
+        }
+        public int NumBits
+        {
+            get
+            {
+                return numBits();
+            }
+        }
+        public int Size
+        {
+            get
+            {
+                return size();
+            }
+        }
+        #endregion
+
+        /** or this element into this set (grow as necessary to accommodate) */
+        public virtual void add( int el )
+        {
+            //JSystem.@out.println("add("+el+")");
+            int n = wordNumber( el );
+            //JSystem.@out.println("word number is "+n);
+            //JSystem.@out.println("bits.length "+bits.length);
+            if ( n >= bits.Length )
+            {
+                growToInclude( el );
+            }
+            bits[n] |= bitMask( el );
+        }
+
+        public virtual void addAll( IIntSet set )
+        {
+            if ( set is BitSet )
+            {
+                this.orInPlace( (BitSet)set );
+            }
+            else if ( set is IntervalSet )
+            {
+                IntervalSet other = (IntervalSet)set;
+                // walk set and add each interval
+                foreach ( Interval I in other.intervals )
+                {
+                    this.orInPlace( BitSet.range( I.a, I.b ) );
+                }
+            }
+            else
+            {
+                throw new ArgumentException( "can't add " +
+                                                   set.GetType().Name +
+                                                   " to BitSet" );
+            }
+        }
+
+        public virtual void addAll( int[] elements )
+        {
+            if ( elements == null )
+            {
+                return;
+            }
+            for ( int i = 0; i < elements.Length; i++ )
+            {
+                int e = elements[i];
+                add( e );
+            }
+        }
+
+        public virtual void addAll( IEnumerable elements )
+        {
+            if ( elements == null )
+            {
+                return;
+            }
+            foreach ( object o in elements )
+            {
+                if ( !( o is int ) )
+                {
+                    throw new ArgumentException();
+                }
+                int eI = (int)o;
+                add( eI );
+            }
+            /*
+            int n = elements.size();
+            for (int i = 0; i < n; i++) {
+                Object o = elements.get(i);
+                if ( !(o instanceof Integer) ) {
+                    throw new IllegalArgumentException();
+                }
+                Integer eI = (Integer)o;
+                add(eI.intValue());
+            }
+             */
+        }
+
+        public virtual IIntSet and( IIntSet a )
+        {
+            BitSet s = (BitSet)this.Clone();
+            s.andInPlace( (BitSet)a );
+            return s;
+        }
+
+        public virtual void andInPlace( BitSet a )
+        {
+            int min = Math.Min( bits.Length, a.bits.Length );
+            for ( int i = min - 1; i >= 0; i-- )
+            {
+                bits[i] &= a.bits[i];
+            }
+            // clear all bits in this not present in a (if this bigger than a).
+            for ( int i = min; i < bits.Length; i++ )
+            {
+                bits[i] = 0;
+            }
+        }
+
+        private static ulong bitMask( int bitNumber )
+        {
+            int bitPosition = bitNumber & MOD_MASK; // bitNumber mod BITS
+            return 1UL << bitPosition;
+        }
+
+        public virtual void clear()
+        {
+            for ( int i = bits.Length - 1; i >= 0; i-- )
+            {
+                bits[i] = 0;
+            }
+        }
+
+        public virtual void clear( int el )
+        {
+            int n = wordNumber( el );
+            if ( n >= bits.Length )
+            {	// grow as necessary to accommodate
+                growToInclude( el );
+            }
+            bits[n] &= ~bitMask( el );
+        }
+
+        public virtual object Clone()
+        {
+            return new BitSet( (ulong[])bits.Clone() );
+        }
+        //public Object clone()
+        //{
+        //    BitSet s;
+        //    try
+        //    {
+        //        s = (BitSet)base.clone();
+        //        s.bits = new long[bits.Length];
+        //        JSystem.arraycopy( bits, 0, s.bits, 0, bits.Length );
+        //    }
+        //    catch ( CloneNotSupportedException e )
+        //    {
+        //        throw new InternalError();
+        //    }
+        //    return s;
+        //}
+
+        public virtual int size()
+        {
+            int deg = 0;
+            for ( int i = bits.Length - 1; i >= 0; i-- )
+            {
+                ulong word = bits[i];
+                if ( word != 0L )
+                {
+                    for ( int bit = BITS - 1; bit >= 0; bit-- )
+                    {
+                        if ( ( word & ( 1UL << bit ) ) != 0 )
+                        {
+                            deg++;
+                        }
+                    }
+                }
+            }
+            return deg;
+        }
+
+        public override int GetHashCode()
+        {
+            throw new System.NotImplementedException();
+        }
+
+        public override bool Equals( object other )
+        {
+            if ( other == null || !( other is BitSet ) )
+            {
+                return false;
+            }
+
+            BitSet otherSet = (BitSet)other;
+
+            int n = Math.Min( this.bits.Length, otherSet.bits.Length );
+
+            // for any bits in common, compare
+            for ( int i = 0; i < n; i++ )
+            {
+                if ( this.bits[i] != otherSet.bits[i] )
+                {
+                    return false;
+                }
+            }
+
+            // make sure any extra bits are off
+
+            if ( this.bits.Length > n )
+            {
+                for ( int i = n + 1; i < this.bits.Length; i++ )
+                {
+                    if ( this.bits[i] != 0 )
+                    {
+                        return false;
+                    }
+                }
+            }
+            else if ( otherSet.bits.Length > n )
+            {
+                for ( int i = n + 1; i < otherSet.bits.Length; i++ )
+                {
+                    if ( otherSet.bits[i] != 0 )
+                    {
+                        return false;
+                    }
+                }
+            }
+
+            return true;
+        }
+
+        /**
+         * Grows the set to a larger number of bits.
+         * @param bit element that must fit in set
+         */
+        public virtual void growToInclude( int bit )
+        {
+            int newSize = Math.Max( bits.Length << 1, numWordsToHold( bit ) );
+            ulong[] newbits = new ulong[newSize];
+            Array.Copy( bits, newbits, bits.Length );
+            bits = newbits;
+        }
+
+        public virtual bool member( int el )
+        {
+            int n = wordNumber( el );
+            if ( n >= bits.Length )
+                return false;
+            return ( bits[n] & bitMask( el ) ) != 0;
+        }
+
+        /** Get the first element you find and return it.  Return Label.INVALID
+         *  otherwise.
+         */
+        public virtual int getSingleElement()
+        {
+            for ( int i = 0; i < ( bits.Length << LOG_BITS ); i++ )
+            {
+                if ( member( i ) )
+                {
+                    return i;
+                }
+            }
+            return Label.INVALID;
+        }
+
+        public virtual bool isNil()
+        {
+            for ( int i = bits.Length - 1; i >= 0; i-- )
+            {
+                if ( bits[i] != 0 )
+                    return false;
+            }
+            return true;
+        }
+
+        public virtual IIntSet complement()
+        {
+            BitSet s = (BitSet)this.Clone();
+            s.notInPlace();
+            return s;
+        }
+
+        public virtual IIntSet complement( IIntSet set )
+        {
+            if ( set == null )
+            {
+                return this.complement();
+            }
+            return set.subtract( this );
+        }
+
+        public virtual void notInPlace()
+        {
+            for ( int i = bits.Length - 1; i >= 0; i-- )
+            {
+                bits[i] = ~bits[i];
+            }
+        }
+
+        /** complement bits in the range 0..maxBit. */
+        public virtual void notInPlace( int maxBit )
+        {
+            notInPlace( 0, maxBit );
+        }
+
+        /** complement bits in the range minBit..maxBit.*/
+        public virtual void notInPlace( int minBit, int maxBit )
+        {
+            // make sure that we have room for maxBit
+            growToInclude( maxBit );
+            for ( int i = minBit; i <= maxBit; i++ )
+            {
+                int n = wordNumber( i );
+                bits[n] ^= bitMask( i );
+            }
+        }
+
+        private /*final*/ int numWordsToHold( int el )
+        {
+            return ( el >> LOG_BITS ) + 1;
+        }
+
+        public static BitSet of( int el )
+        {
+            BitSet s = new BitSet( el + 1 );
+            s.add( el );
+            return s;
+        }
+
+        public static BitSet of<T>( T elements )
+            where T : IEnumerable<int>
+        {
+            BitSet s = new BitSet();
+            foreach ( int i in elements )
+            {
+                s.add( i );
+            }
+            return s;
+        }
+
+        public static BitSet of( IntervalSet set )
+        {
+            return of( (IIntSet)set );
+        }
+        public static BitSet of( IIntSet set )
+        {
+            if ( set == null )
+            {
+                return null;
+            }
+
+            if ( set is BitSet )
+            {
+                return (BitSet)set;
+            }
+            if ( set is IntervalSet )
+            {
+                BitSet s = new BitSet();
+                s.addAll( set );
+                return s;
+            }
+            throw new ArgumentException( "can't create BitSet from " + set.GetType().Name );
+        }
+
+        public static BitSet of( IDictionary elements )
+        {
+            return BitSet.of( elements.Keys.Cast<int>() );
+        }
+
+        public static BitSet of<TKey, TValue>( System.Collections.Generic.IDictionary<TKey, TValue> elements )
+        {
+            return BitSet.of( elements.Keys.Cast<int>() );
+        }
+
+        public static BitSet range( int a, int b )
+        {
+            BitSet s = new BitSet( b + 1 );
+            for ( int i = a; i <= b; i++ )
+            {
+                int n = wordNumber( i );
+                s.bits[n] |= bitMask( i );
+            }
+            return s;
+        }
+
+        /** return this | a in a new set */
+        public virtual IIntSet or( IIntSet a )
+        {
+            if ( a == null )
+            {
+                return this;
+            }
+            BitSet s = (BitSet)this.Clone();
+            s.orInPlace( (BitSet)a );
+            return s;
+        }
+
+        public virtual void orInPlace( BitSet a )
+        {
+            if ( a == null )
+            {
+                return;
+            }
+            // If this is smaller than a, grow this first
+            if ( a.bits.Length > bits.Length )
+            {
+                setSize( a.bits.Length );
+            }
+            int min = Math.Min( bits.Length, a.bits.Length );
+            for ( int i = min - 1; i >= 0; i-- )
+            {
+                bits[i] |= a.bits[i];
+            }
+        }
+
+        // remove this element from this set
+        public virtual void remove( int el )
+        {
+            int n = wordNumber( el );
+            if ( n >= bits.Length )
+            {
+                growToInclude( el );
+            }
+            bits[n] &= ~bitMask( el );
+        }
+
+        /**
+         * Sets the size of a set.
+         * @param nwords how many words the new set should be
+         */
+        private void setSize( int nwords )
+        {
+            ulong[] newbits = new ulong[nwords];
+            int n = Math.Min( nwords, bits.Length );
+            Array.Copy( bits, newbits, n );
+            bits = newbits;
+        }
+
+        public virtual int numBits()
+        {
+            return bits.Length << LOG_BITS; // num words * bits per word
+        }
+
+        /** return how much space is being used by the bits array not
+         *  how many actually have member bits on.
+         */
+        public virtual int lengthInLongWords()
+        {
+            return bits.Length;
+        }
+
+        /**Is this contained within a? */
+        public virtual bool subset( BitSet a )
+        {
+            if ( a == null )
+                return false;
+            return this.and( a ).Equals( this );
+        }
+
+        /**Subtract the elements of 'a' from 'this' in-place.
+         * Basically, just turn off all bits of 'this' that are in 'a'.
+         */
+        public virtual void subtractInPlace( BitSet a )
+        {
+            if ( a == null )
+                return;
+            // for all words of 'a', turn off corresponding bits of 'this'
+            for ( int i = 0; i < bits.Length && i < a.bits.Length; i++ )
+            {
+                bits[i] &= ~a.bits[i];
+            }
+        }
+
+        public virtual IIntSet subtract( IIntSet a )
+        {
+            if ( a == null || !( a is BitSet ) )
+                return null;
+
+            BitSet s = (BitSet)this.Clone();
+            s.subtractInPlace( (BitSet)a );
+            return s;
+        }
+
+        public virtual List<int> ToList()
+        {
+            throw new NotImplementedException( "BitSet.toList() unimplemented" );
+        }
+
+        public virtual int[] toArray()
+        {
+            int[] elems = new int[size()];
+            int en = 0;
+            for ( int i = 0; i < ( bits.Length << LOG_BITS ); i++ )
+            {
+                if ( member( i ) )
+                {
+                    elems[en++] = i;
+                }
+            }
+            return elems;
+        }
+
+        public virtual ulong[] toPackedArray()
+        {
+            return bits;
+        }
+
+        public override string ToString()
+        {
+            return ToString( null );
+        }
+
+        /** Transform a bit set into a string by formatting each element as an integer
+         * separator The string to put in between elements
+         * @return A commma-separated list of values
+         */
+        public virtual string ToString( Grammar g )
+        {
+            StringBuilder buf = new StringBuilder();
+            string separator = ",";
+            bool havePrintedAnElement = false;
+            buf.Append( '{' );
+
+            for ( int i = 0; i < ( bits.Length << LOG_BITS ); i++ )
+            {
+                if ( member( i ) )
+                {
+                    if ( i > 0 && havePrintedAnElement )
+                    {
+                        buf.Append( separator );
+                    }
+                    if ( g != null )
+                    {
+                        buf.Append( g.getTokenDisplayName( i ) );
+                    }
+                    else
+                    {
+                        buf.Append( i );
+                    }
+                    havePrintedAnElement = true;
+                }
+            }
+            buf.Append( '}' );
+            return buf.ToString();
+        }
+
+        /**Create a string representation where instead of integer elements, the
+         * ith element of vocabulary is displayed instead.  Vocabulary is a Vector
+         * of Strings.
+         * separator The string to put in between elements
+         * @return A commma-separated list of character constants.
+         */
+        public virtual string ToString( string separator, IList vocabulary )
+        {
+            if ( vocabulary == null )
+            {
+                return ToString( null );
+            }
+            string str = "";
+            for ( int i = 0; i < ( bits.Length << LOG_BITS ); i++ )
+            {
+                if ( member( i ) )
+                {
+                    if ( str.Length > 0 )
+                    {
+                        str += separator;
+                    }
+                    if ( i >= vocabulary.Count )
+                    {
+                        str += "'" + (char)i + "'";
+                    }
+                    else if ( vocabulary[i] == null )
+                    {
+                        str += "'" + (char)i + "'";
+                    }
+                    else
+                    {
+                        str += (string)vocabulary[i];
+                    }
+                }
+            }
+            return str;
+        }
+
+        /**
+         * Dump a comma-separated list of the words making up the bit set.
+         * Split each 64 bit number into two more manageable 32 bit numbers.
+         * This generates a comma-separated list of C++-like unsigned long constants.
+         */
+        public virtual string ToStringOfHalfWords()
+        {
+            StringBuilder s = new StringBuilder();
+            for ( int i = 0; i < bits.Length; i++ )
+            {
+                if ( i != 0 )
+                    s.Append( ", " );
+                ulong tmp = bits[i];
+                tmp &= 0xFFFFFFFFL;
+                s.Append( tmp );
+                s.Append( "UL" );
+                s.Append( ", " );
+                tmp = bits[i] >> 32;
+                tmp &= 0xFFFFFFFFL;
+                s.Append( tmp );
+                s.Append( "UL" );
+            }
+            return s.ToString();
+        }
+
+        /**
+         * Dump a comma-separated list of the words making up the bit set.
+         * This generates a comma-separated list of Java-like long int constants.
+         */
+        public virtual string ToStringOfWords()
+        {
+            StringBuilder s = new StringBuilder();
+            for ( int i = 0; i < bits.Length; i++ )
+            {
+                if ( i != 0 )
+                    s.Append( ", " );
+                s.Append( bits[i] );
+                s.Append( "L" );
+            }
+            return s.ToString();
+        }
+
+        public virtual string ToStringWithRanges()
+        {
+            return ToString();
+        }
+
+        private /*final*/ static int wordNumber( int bit )
+        {
+            return bit >> LOG_BITS; // bit / BITS
+        }
+
+        #region ICollection<int> Members
+
+        void ICollection<int>.Add( int item )
+        {
+            throw new System.NotImplementedException();
+        }
+
+        void ICollection<int>.Clear()
+        {
+            throw new System.NotImplementedException();
+        }
+
+        bool ICollection<int>.Contains( int item )
+        {
+            throw new System.NotImplementedException();
+        }
+
+        void ICollection<int>.CopyTo( int[] array, int arrayIndex )
+        {
+            throw new System.NotImplementedException();
+        }
+
+        int ICollection<int>.Count
+        {
+            get
+            {
+                throw new System.NotImplementedException();
+            }
+        }
+
+        bool ICollection<int>.IsReadOnly
+        {
+            get
+            {
+                throw new System.NotImplementedException();
+            }
+        }
+
+        bool ICollection<int>.Remove( int item )
+        {
+            throw new System.NotImplementedException();
+        }
+
+        #endregion
+
+        #region IEnumerable<int> Members
+
+        IEnumerator<int> IEnumerable<int>.GetEnumerator()
+        {
+            throw new System.NotImplementedException();
+        }
+
+        #endregion
+
+        #region IEnumerable Members
+
+        System.Collections.IEnumerator IEnumerable.GetEnumerator()
+        {
+            throw new System.NotImplementedException();
+        }
+
+        #endregion
+    }
+}
diff --git a/Antlr3/Misc/IntArrayList.cs b/Antlr3/Misc/IntArrayList.cs
new file mode 100644
index 0000000..3901333
--- /dev/null
+++ b/Antlr3/Misc/IntArrayList.cs
@@ -0,0 +1,201 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Misc
+{
+    using System.Collections.Generic;
+    using Antlr.Runtime.JavaExtensions;
+
+    using Array = System.Array;
+    using ICloneable = System.ICloneable;
+    using StringBuilder = System.Text.StringBuilder;
+
+    /** An ArrayList based upon int members.  Not quite a real implementation of a
+     *  modifiable list as I don't do, for example, add(index,element).
+     *  TODO: unused?
+     */
+    public class IntArrayList : List<object>, ICloneable
+    {
+        private const int DEFAULT_CAPACITY = 10;
+        protected int n = 0;
+        protected int[] elements = null;
+
+        public IntArrayList()
+            : this( DEFAULT_CAPACITY )
+        {
+        }
+
+        public IntArrayList( int initialCapacity )
+        {
+            elements = new int[initialCapacity];
+        }
+
+        IntArrayList( int[] elements, int n )
+        {
+            this.elements = elements;
+            this.n = n;
+        }
+
+        /** Set the ith element.  Like ArrayList, this does NOT affect size. */
+        public virtual int set( int i, int newValue )
+        {
+            if ( i >= n )
+            {
+                setSize( i ); // unlike definition of set in ArrayList, set size
+            }
+            int v = elements[i];
+            elements[i] = newValue;
+            return v;
+        }
+
+        public virtual bool add( int o )
+        {
+            if ( n >= elements.Length )
+            {
+                grow();
+            }
+            elements[n] = o;
+            n++;
+            return true;
+        }
+
+        public virtual void setSize( int newSize )
+        {
+            if ( newSize >= elements.Length )
+            {
+                ensureCapacity( newSize );
+            }
+            n = newSize;
+        }
+
+        protected virtual void grow()
+        {
+            ensureCapacity( ( elements.Length * 3 ) / 2 + 1 );
+        }
+
+        public virtual bool contains( int v )
+        {
+            for ( int i = 0; i < n; i++ )
+            {
+                int element = elements[i];
+                if ( element == v )
+                {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        public virtual void ensureCapacity( int newCapacity )
+        {
+            int oldCapacity = elements.Length;
+            if ( n >= oldCapacity )
+            {
+                int[] oldData = elements;
+                elements = new int[newCapacity];
+                Array.Copy( oldData, elements, n );
+            }
+        }
+
+        public virtual object get( int i )
+        {
+            return element( i );
+        }
+
+        public virtual int element( int i )
+        {
+            return elements[i];
+        }
+
+        public virtual int[] getElements()
+        {
+            int[] a = new int[n];
+            Array.Copy( elements, a, n );
+            return a;
+        }
+
+        public virtual int size()
+        {
+            return n;
+        }
+
+        public virtual int capacity()
+        {
+            return elements.Length;
+        }
+
+        public override bool Equals( object o )
+        {
+            if ( o == null )
+            {
+                return false;
+            }
+            IntArrayList other = (IntArrayList)o;
+            if ( this.size() != other.size() )
+            {
+                return false;
+            }
+            for ( int i = 0; i < n; i++ )
+            {
+                if ( elements[i] != other.elements[i] )
+                {
+                    return false;
+                }
+            }
+            return true;
+        }
+
+        public override int GetHashCode()
+        {
+            return ObjectExtensions.ShiftPrimeXOR( elements.GetHashCode(), n );
+        }
+
+        public virtual object Clone()
+        {
+            return new IntArrayList( (int[])elements.Clone(), n );
+        }
+
+        public override string ToString()
+        {
+            StringBuilder buf = new StringBuilder();
+            for ( int i = 0; i < n; i++ )
+            {
+                if ( i > 0 )
+                {
+                    buf.Append( ", " );
+                }
+                buf.Append( elements[i] );
+            }
+            return buf.ToString();
+        }
+    }
+}
diff --git a/Antlr3/Misc/IntSet.cs b/Antlr3/Misc/IntSet.cs
new file mode 100644
index 0000000..70d92de
--- /dev/null
+++ b/Antlr3/Misc/IntSet.cs
@@ -0,0 +1,91 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Misc
+{
+    using System.Collections.Generic;
+
+    using Grammar = Antlr3.Tool.Grammar;
+
+    /** A generic set of ints that has an efficient implementation, BitSet,
+     *  which is a compressed bitset and is useful for ints that
+     *  are small, for example less than 500 or so, and w/o many ranges.  For
+     *  ranges with large values like unicode char sets, this is not very efficient.
+     *  Consider using IntervalSet.  Not all methods in IntervalSet are implemented.
+     *
+     *  @see org.antlr.misc.BitSet
+     *  @see org.antlr.misc.IntervalSet
+     */
+    public interface IIntSet : ICollection<int>
+    {
+        /** Add an element to the set */
+        void add( int el );
+
+        /** Add all elements from incoming set to this set.  Can limit
+         *  to set of its own type.
+         */
+        void addAll( IIntSet set );
+
+        /** Return the intersection of this set with the argument, creating
+         *  a new set.
+         */
+        IIntSet and( IIntSet a );
+
+        IIntSet complement( IIntSet elements );
+
+        IIntSet or( IIntSet a );
+
+        IIntSet subtract( IIntSet a );
+
+        /** Return the size of this set (not the underlying implementation's
+         *  allocated memory size, for example).
+         */
+        int size();
+
+        bool isNil();
+
+        bool Equals( object obj );
+
+        int getSingleElement();
+
+        bool member( int el );
+
+        /** remove this element from this set */
+        void remove( int el );
+
+        List<int> ToList();
+
+        string ToString();
+
+        string ToString( Grammar g );
+    }
+}
diff --git a/Antlr3/Misc/Interval.cs b/Antlr3/Misc/Interval.cs
new file mode 100644
index 0000000..0270062
--- /dev/null
+++ b/Antlr3/Misc/Interval.cs
@@ -0,0 +1,181 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Misc
+{
+    using Math = System.Math;
+
+    /** An immutable inclusive interval a..b */
+    public class Interval
+    {
+        public const int INTERVAL_POOL_MAX_VALUE = 1000;
+
+        static Interval[] cache = new Interval[INTERVAL_POOL_MAX_VALUE + 1];
+
+        public int a;
+        public int b;
+
+        public static int creates = 0;
+        public static int misses = 0;
+        public static int hits = 0;
+        public static int outOfRange = 0;
+
+        public Interval( int a, int b )
+        {
+            this.a = a;
+            this.b = b;
+        }
+
+        /** Interval objects are used readonly so share all with the
+         *  same single value a==b up to some max size.  Use an array as a perfect hash.
+         *  Return shared object for 0..INTERVAL_POOL_MAX_VALUE or a new
+         *  Interval object with a..a in it.  On Java.g, 218623 IntervalSets
+         *  have a..a (set with 1 element).
+         */
+        public static Interval create( int a, int b )
+        {
+            //return new Interval(a,b);
+            // cache just a..a
+            if ( a != b || a < 0 || a > INTERVAL_POOL_MAX_VALUE )
+            {
+                return new Interval( a, b );
+            }
+            if ( cache[a] == null )
+            {
+                cache[a] = new Interval( a, a );
+            }
+            return cache[a];
+        }
+
+        public override int GetHashCode()
+        {
+            throw new System.NotImplementedException();
+        }
+
+        public override bool Equals( object o )
+        {
+            if ( o == null )
+            {
+                return false;
+            }
+            Interval other = (Interval)o;
+            return this.a == other.a && this.b == other.b;
+        }
+
+        /** Does this start completely before other? Disjoint */
+        public virtual bool startsBeforeDisjoint( Interval other )
+        {
+            return this.a < other.a && this.b < other.a;
+        }
+
+        /** Does this start at or before other? Nondisjoint */
+        public virtual bool startsBeforeNonDisjoint( Interval other )
+        {
+            return this.a <= other.a && this.b >= other.a;
+        }
+
+        /** Does this.a start after other.b? May or may not be disjoint */
+        public virtual bool startsAfter( Interval other )
+        {
+            return this.a > other.a;
+        }
+
+        /** Does this start completely after other? Disjoint */
+        public virtual bool startsAfterDisjoint( Interval other )
+        {
+            return this.a > other.b;
+        }
+
+        /** Does this start after other? NonDisjoint */
+        public virtual bool startsAfterNonDisjoint( Interval other )
+        {
+            return this.a > other.a && this.a <= other.b; // this.b>=other.b implied
+        }
+
+        /** Are both ranges disjoint? I.e., no overlap? */
+        public virtual bool disjoint( Interval other )
+        {
+            return startsBeforeDisjoint( other ) || startsAfterDisjoint( other );
+        }
+
+        /** Are two intervals adjacent such as 0..41 and 42..42? */
+        public virtual bool adjacent( Interval other )
+        {
+            return this.a == other.b + 1 || this.b == other.a - 1;
+        }
+
+        public virtual bool properlyContains( Interval other )
+        {
+            return other.a >= this.a && other.b <= this.b;
+        }
+
+        /** Return the interval computed from combining this and other */
+        public virtual Interval union( Interval other )
+        {
+            return Interval.create( Math.Min( a, other.a ), Math.Max( b, other.b ) );
+        }
+
+        /** Return the interval in common between this and o */
+        public virtual Interval intersection( Interval other )
+        {
+            return Interval.create( Math.Max( a, other.a ), Math.Min( b, other.b ) );
+        }
+
+        /** Return the interval with elements from this not in other;
+         *  other must not be totally enclosed (properly contained)
+         *  within this, which would result in two disjoint intervals
+         *  instead of the single one returned by this method.
+         */
+        public virtual Interval differenceNotProperlyContained( Interval other )
+        {
+            Interval diff = null;
+            // other.a to left of this.a (or same)
+            if ( other.startsBeforeNonDisjoint( this ) )
+            {
+                diff = Interval.create( Math.Max( this.a, other.b + 1 ),
+                                       this.b );
+            }
+
+            // other.a to right of this.a
+            else if ( other.startsAfterNonDisjoint( this ) )
+            {
+                diff = Interval.create( this.a, other.a - 1 );
+            }
+            return diff;
+        }
+
+        public override string ToString()
+        {
+            return a + ".." + b;
+        }
+    }
+}
diff --git a/Antlr3/Misc/IntervalSet.cs b/Antlr3/Misc/IntervalSet.cs
new file mode 100644
index 0000000..12815f9
--- /dev/null
+++ b/Antlr3/Misc/IntervalSet.cs
@@ -0,0 +1,895 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Misc
+{
+    using System.Collections.Generic;
+    using System.Linq;
+
+    using ArgumentException = System.ArgumentException;
+    using Grammar = Antlr3.Tool.Grammar;
+    using Label = Antlr3.Analysis.Label;
+    using NotImplementedException = System.NotImplementedException;
+    using StringBuilder = System.Text.StringBuilder;
+
+    /** A set of integers that relies on ranges being common to do
+     *  "run-length-encoded" like compression (if you view an IntSet like
+     *  a BitSet with runs of 0s and 1s).  Only ranges are recorded so that
+     *  a few ints up near value 1000 don't cause massive bitsets, just two
+     *  integer intervals.
+     *
+     *  element values may be negative.  Useful for sets of EPSILON and EOF.
+     *
+     *  0..9 char range is index pair ['\u0030','\u0039'].
+     *  Multiple ranges are encoded with multiple index pairs.  Isolated
+     *  elements are encoded with an index pair where both intervals are the same.
+     *
+     *  The ranges are ordered and disjoint so that 2..6 appears before 101..103.
+     */
+    public class IntervalSet : IIntSet
+    {
+        public static readonly IntervalSet COMPLETE_SET = IntervalSet.of( 0, Label.MAX_CHAR_VALUE );
+
+        /** The list of sorted, disjoint intervals. */
+        //protected List<Interval> intervals;
+        protected internal IList<Interval> intervals;
+
+        /** Create a set with no elements */
+        public IntervalSet()
+        {
+            //intervals = new ArrayList<Interval>( 2 ); // most sets are 1 or 2 elements
+            intervals = new List<Interval>( 2 ); // most sets are 1 or 2 elements
+        }
+
+        public IntervalSet( IList<Interval> intervals )
+        {
+            this.intervals = intervals;
+        }
+
+        #region Properties
+        public ICollection<Interval> Intervals
+        {
+            get
+            {
+                return getIntervals();
+            }
+        }
+        public int MaxElement
+        {
+            get
+            {
+                return getMaxElement();
+            }
+        }
+        public int MinElement
+        {
+            get
+            {
+                return getMinElement();
+            }
+        }
+        public int SingleElement
+        {
+            get
+            {
+                return getSingleElement();
+            }
+        }
+        public int Size
+        {
+            get
+            {
+                return size();
+            }
+        }
+        #endregion
+
+        /** Create a set with a single element, el. */
+        public static IntervalSet of( int a )
+        {
+            IntervalSet s = new IntervalSet();
+            s.add( a );
+            return s;
+        }
+
+        /** Create a set with all ints within range [a..b] (inclusive) */
+        public static IntervalSet of( int a, int b )
+        {
+            IntervalSet s = new IntervalSet();
+            s.add( a, b );
+            return s;
+        }
+
+        /** Add a single element to the set.  An isolated element is stored
+         *  as a range el..el.
+         */
+        public virtual void add( int el )
+        {
+            add( el, el );
+        }
+
+        /** Add interval; i.e., add all integers from a to b to set.
+         *  If b<a, do nothing.
+         *  Keep list in sorted order (by left range value).
+         *  If overlap, combine ranges.  For example,
+         *  If this is {1..5, 10..20}, adding 6..7 yields
+         *  {1..5, 6..7, 10..20}.  Adding 4..8 yields {1..8, 10..20}.
+         */
+        public virtual void add( int a, int b )
+        {
+            add( Interval.create( a, b ) );
+        }
+
+        // copy on write so we can cache a..a intervals and sets of that
+        protected virtual void add( Interval addition )
+        {
+            //JSystem.@out.println("add "+addition+" to "+intervals.toString());
+            if ( addition.b < addition.a )
+            {
+                return;
+            }
+            // find position in list
+            // Use iterators as we modify list in place
+            //for ( ListIterator iter = intervals.listIterator(); iter.hasNext(); )
+            for ( int i = 0; i < intervals.Count; i++ )
+            {
+                //Interval r = (Interval)iter.next();
+                Interval r = intervals[i];
+                if ( addition.Equals( r ) )
+                {
+                    return;
+                }
+                if ( addition.adjacent( r ) || !addition.disjoint( r ) )
+                {
+                    // next to each other, make a single larger interval
+                    Interval bigger = addition.union( r );
+                    intervals[i] = bigger;
+                    // make sure we didn't just create an interval that
+                    // should be merged with next interval in list
+                    if ( i < intervals.Count - 1 )
+                    {
+                        i++;
+                        Interval next = intervals[i];
+                        //Interval next = (Interval)iter.next();
+                        if ( bigger.adjacent( next ) || !bigger.disjoint( next ) )
+                        {
+                            // if we bump up against or overlap next, merge
+                            //iter.remove();   // remove this one
+                            intervals.RemoveAt( i );
+                            //iter.previous(); // move backwards to what we just set
+                            i--;
+                            //iter.set( bigger.union( next ) ); // set to 3 merged ones
+                            intervals[i] = bigger.union( next );
+                        }
+                    }
+                    return;
+                }
+                if ( addition.startsBeforeDisjoint( r ) )
+                {
+                    // insert before r
+                    //iter.previous();
+                    //iter.add( addition );
+                    intervals.Insert( i, addition );
+                    return;
+                }
+                // if disjoint and after r, a future iteration will handle it
+            }
+            // ok, must be after last interval (and disjoint from last interval)
+            // just add it
+            intervals.Add( addition );
+        }
+
+        /*
+        protected void add(Interval addition) {
+            //JSystem.@out.println("add "+addition+" to "+intervals.toString());
+            if ( addition.b<addition.a ) {
+                return;
+            }
+            // find position in list
+            //for (ListIterator iter = intervals.listIterator(); iter.hasNext();) {
+            int n = intervals.size();
+            for (int i=0; i<n; i++) {
+                Interval r = (Interval)intervals.get(i);
+                if ( addition.equals(r) ) {
+                    return;
+                }
+                if ( addition.adjacent(r) || !addition.disjoint(r) ) {
+                    // next to each other, make a single larger interval
+                    Interval bigger = addition.union(r);
+                    intervals.set(i, bigger);
+                    // make sure we didn't just create an interval that
+                    // should be merged with next interval in list
+                    if ( (i+1)<n ) {
+                        i++;
+                        Interval next = (Interval)intervals.get(i);
+                        if ( bigger.adjacent(next)||!bigger.disjoint(next) ) {
+                            // if we bump up against or overlap next, merge
+                            intervals.remove(i); // remove next one
+                            i--;
+                            intervals.set(i, bigger.union(next)); // set to 3 merged ones
+                        }
+                    }
+                    return;
+                }
+                if ( addition.startsBeforeDisjoint(r) ) {
+                    // insert before r
+                    intervals.add(i, addition);
+                    return;
+                }
+                // if disjoint and after r, a future iteration will handle it
+            }
+            // ok, must be after last interval (and disjoint from last interval)
+            // just add it
+            intervals.add(addition);
+        }
+    */
+
+        public virtual void addAll( IIntSet set )
+        {
+            if ( set == null )
+            {
+                return;
+            }
+            if ( !( set is IntervalSet ) )
+            {
+                throw new ArgumentException( "can't add non IntSet (" +
+                                                   set.GetType().Name +
+                                                   ") to IntervalSet" );
+            }
+            IntervalSet other = (IntervalSet)set;
+            // walk set and add each interval
+            int n = other.intervals.Count;
+            for ( int i = 0; i < n; i++ )
+            {
+                Interval I = (Interval)other.intervals[i];
+                this.add( I.a, I.b );
+            }
+        }
+
+        public virtual IIntSet complement( int minElement, int maxElement )
+        {
+            return this.complement( IntervalSet.of( minElement, maxElement ) );
+        }
+
+        /** Given the set of possible values (rather than, say UNICODE or MAXINT),
+         *  return a new set containing all elements in vocabulary, but not in
+         *  this.  The computation is (vocabulary - this).
+         *
+         *  'this' is assumed to be either a subset or equal to vocabulary.
+         */
+        public virtual IIntSet complement( IIntSet vocabulary )
+        {
+            if ( vocabulary == null )
+            {
+                return null; // nothing in common with null set
+            }
+            if ( !( vocabulary is IntervalSet ) )
+            {
+                throw new ArgumentException( "can't complement with non IntervalSet (" +
+                                                   vocabulary.GetType().Name + ")" );
+            }
+            IntervalSet vocabularyIS = ( (IntervalSet)vocabulary );
+            int maxElement = vocabularyIS.getMaxElement();
+
+            IntervalSet compl = new IntervalSet();
+            int n = intervals.Count;
+            if ( n == 0 )
+            {
+                return compl;
+            }
+            Interval first = (Interval)intervals[0];
+            // add a range from 0 to first.a constrained to vocab
+            if ( first.a > 0 )
+            {
+                IntervalSet s = IntervalSet.of( 0, first.a - 1 );
+                IntervalSet a = (IntervalSet)s.and( vocabularyIS );
+                compl.addAll( a );
+            }
+            for ( int i = 1; i < n; i++ )
+            { // from 2nd interval .. nth
+                Interval previous = (Interval)intervals[i - 1];
+                Interval current = (Interval)intervals[i];
+                IntervalSet s = IntervalSet.of( previous.b + 1, current.a - 1 );
+                IntervalSet a = (IntervalSet)s.and( vocabularyIS );
+                compl.addAll( a );
+            }
+            Interval last = (Interval)intervals[n - 1];
+            // add a range from last.b to maxElement constrained to vocab
+            if ( last.b < maxElement )
+            {
+                IntervalSet s = IntervalSet.of( last.b + 1, maxElement );
+                IntervalSet a = (IntervalSet)s.and( vocabularyIS );
+                compl.addAll( a );
+            }
+            return compl;
+        }
+
+        /** Compute this-other via this&~other.
+         *  Return a new set containing all elements in this but not in other.
+         *  other is assumed to be a subset of this;
+         *  anything that is in other but not in this will be ignored.
+         */
+        public virtual IIntSet subtract( IIntSet other )
+        {
+            // assume the whole unicode range here for the complement
+            // because it doesn't matter.  Anything beyond the max of this' set
+            // will be ignored since we are doing this & ~other.  The intersection
+            // will be empty.  The only problem would be when this' set max value
+            // goes beyond MAX_CHAR_VALUE, but hopefully the constant MAX_CHAR_VALUE
+            // will prevent this.
+            return this.and( ( (IntervalSet)other ).complement( COMPLETE_SET ) );
+        }
+
+        /** return a new set containing all elements in this but not in other.
+         *  Intervals may have to be broken up when ranges in this overlap
+         *  with ranges in other.  other is assumed to be a subset of this;
+         *  anything that is in other but not in this will be ignored.
+         *
+         *  Keep around, but 10-20-2005, I decided to make complement work w/o
+         *  subtract and so then subtract can simply be a&~b
+         *
+        public IntSet subtract(IntSet other) {
+            if ( other==null || !(other instanceof IntervalSet) ) {
+                return null; // nothing in common with null set
+            }
+
+            IntervalSet diff = new IntervalSet();
+
+            // iterate down both interval lists
+            ListIterator thisIter = this.intervals.listIterator();
+            ListIterator otherIter = ((IntervalSet)other).intervals.listIterator();
+            Interval mine=null;
+            Interval theirs=null;
+            if ( thisIter.hasNext() ) {
+                mine = (Interval)thisIter.next();
+            }
+            if ( otherIter.hasNext() ) {
+                theirs = (Interval)otherIter.next();
+            }
+            while ( mine!=null ) {
+                //JSystem.@out.println("mine="+mine+", theirs="+theirs);
+                // CASE 1: nothing in theirs removes a chunk from mine
+                if ( theirs==null || mine.disjoint(theirs) ) {
+                    // SUBCASE 1a: finished traversing theirs; keep adding mine now
+                    if ( theirs==null ) {
+                        // add everything in mine to difference since theirs done
+                        diff.add(mine);
+                        mine = null;
+                        if ( thisIter.hasNext() ) {
+                            mine = (Interval)thisIter.next();
+                        }
+                    }
+                    else {
+                        // SUBCASE 1b: mine is completely to the left of theirs
+                        // so we can add to difference; move mine, but not theirs
+                        if ( mine.startsBeforeDisjoint(theirs) ) {
+                            diff.add(mine);
+                            mine = null;
+                            if ( thisIter.hasNext() ) {
+                                mine = (Interval)thisIter.next();
+                            }
+                        }
+                        // SUBCASE 1c: theirs is completely to the left of mine
+                        else {
+                            // keep looking in theirs
+                            theirs = null;
+                            if ( otherIter.hasNext() ) {
+                                theirs = (Interval)otherIter.next();
+                            }
+                        }
+                    }
+                }
+                else {
+                    // CASE 2: theirs breaks mine into two chunks
+                    if ( mine.properlyContains(theirs) ) {
+                        // must add two intervals: stuff to left and stuff to right
+                        diff.add(mine.a, theirs.a-1);
+                        // don't actually add stuff to right yet as next 'theirs'
+                        // might overlap with it
+                        // The stuff to the right might overlap with next "theirs".
+                        // so it is considered next
+                        Interval right = new Interval(theirs.b+1, mine.b);
+                        mine = right;
+                        // move theirs forward
+                        theirs = null;
+                        if ( otherIter.hasNext() ) {
+                            theirs = (Interval)otherIter.next();
+                        }
+                    }
+
+                    // CASE 3: theirs covers mine; nothing to add to diff
+                    else if ( theirs.properlyContains(mine) ) {
+                        // nothing to add, theirs forces removal totally of mine
+                        // just move mine looking for an overlapping interval
+                        mine = null;
+                        if ( thisIter.hasNext() ) {
+                            mine = (Interval)thisIter.next();
+                        }
+                    }
+
+                    // CASE 4: non proper overlap
+                    else {
+                        // overlap, but not properly contained
+                        diff.add(mine.differenceNotProperlyContained(theirs));
+                        // update iterators
+                        boolean moveTheirs = true;
+                        if ( mine.startsBeforeNonDisjoint(theirs) ||
+                             theirs.b > mine.b )
+                        {
+                            // uh oh, right of theirs extends past right of mine
+                            // therefore could overlap with next of mine so don't
+                            // move theirs iterator yet
+                            moveTheirs = false;
+                        }
+                        // always move mine
+                        mine = null;
+                        if ( thisIter.hasNext() ) {
+                            mine = (Interval)thisIter.next();
+                        }
+                        if ( moveTheirs ) {
+                            theirs = null;
+                            if ( otherIter.hasNext() ) {
+                                theirs = (Interval)otherIter.next();
+                            }
+                        }
+                    }
+                }
+            }
+            return diff;
+        }
+         */
+
+        /** TODO: implement this! */
+        public IIntSet or( IIntSet a )
+        {
+            IntervalSet o = new IntervalSet();
+            o.addAll( this );
+            o.addAll( a );
+            //throw new NoSuchMethodError();
+            return o;
+        }
+
+        /** Return a new set with the intersection of this set with other.  Because
+         *  the intervals are sorted, we can use an iterator for each list and
+         *  just walk them together.  This is roughly O(min(n,m)) for interval
+         *  list lengths n and m.
+         */
+        public IIntSet and( IIntSet other )
+        {
+            if ( other == null )
+            { //|| !(other instanceof IntervalSet) ) {
+                return null; // nothing in common with null set
+            }
+
+            var myIntervals = this.intervals;
+            var theirIntervals = ( (IntervalSet)other ).intervals;
+            IntervalSet intersection = null;
+            int mySize = myIntervals.Count;
+            int theirSize = theirIntervals.Count;
+            int i = 0;
+            int j = 0;
+            // iterate down both interval lists looking for nondisjoint intervals
+            while ( i < mySize && j < theirSize )
+            {
+                Interval mine = (Interval)myIntervals[i];
+                Interval theirs = (Interval)theirIntervals[j];
+                //JSystem.@out.println("mine="+mine+" and theirs="+theirs);
+                if ( mine.startsBeforeDisjoint( theirs ) )
+                {
+                    // move this iterator looking for interval that might overlap
+                    i++;
+                }
+                else if ( theirs.startsBeforeDisjoint( mine ) )
+                {
+                    // move other iterator looking for interval that might overlap
+                    j++;
+                }
+                else if ( mine.properlyContains( theirs ) )
+                {
+                    // overlap, add intersection, get next theirs
+                    if ( intersection == null )
+                    {
+                        intersection = new IntervalSet();
+                    }
+                    intersection.add( mine.intersection( theirs ) );
+                    j++;
+                }
+                else if ( theirs.properlyContains( mine ) )
+                {
+                    // overlap, add intersection, get next mine
+                    if ( intersection == null )
+                    {
+                        intersection = new IntervalSet();
+                    }
+                    intersection.add( mine.intersection( theirs ) );
+                    i++;
+                }
+                else if ( !mine.disjoint( theirs ) )
+                {
+                    // overlap, add intersection
+                    if ( intersection == null )
+                    {
+                        intersection = new IntervalSet();
+                    }
+                    intersection.add( mine.intersection( theirs ) );
+                    // Move the iterator of lower range [a..b], but not
+                    // the upper range as it may contain elements that will collide
+                    // with the next iterator. So, if mine=[0..115] and
+                    // theirs=[115..200], then intersection is 115 and move mine
+                    // but not theirs as theirs may collide with the next range
+                    // in thisIter.
+                    // move both iterators to next ranges
+                    if ( mine.startsAfterNonDisjoint( theirs ) )
+                    {
+                        j++;
+                    }
+                    else if ( theirs.startsAfterNonDisjoint( mine ) )
+                    {
+                        i++;
+                    }
+                }
+            }
+            if ( intersection == null )
+            {
+                return new IntervalSet();
+            }
+            return intersection;
+        }
+
+        /** Is el in any range of this set? */
+        public virtual bool member( int el )
+        {
+            int n = intervals.Count;
+            for ( int i = 0; i < n; i++ )
+            {
+                Interval I = (Interval)intervals[i];
+                int a = I.a;
+                int b = I.b;
+                if ( el < a )
+                {
+                    break; // list is sorted and el is before this interval; not here
+                }
+                if ( el >= a && el <= b )
+                {
+                    return true; // found in this interval
+                }
+            }
+            return false;
+            /*
+                    for (ListIterator iter = intervals.listIterator(); iter.hasNext();) {
+                        Interval I = (Interval) iter.next();
+                        if ( el<I.a ) {
+                            break; // list is sorted and el is before this interval; not here
+                        }
+                        if ( el>=I.a && el<=I.b ) {
+                            return true; // found in this interval
+                        }
+                    }
+                    return false;
+                    */
+        }
+
+        /** return true if this set has no members */
+        public virtual bool isNil()
+        {
+            return intervals == null || intervals.Count == 0;
+        }
+
+        /** If this set is a single integer, return it otherwise Label.INVALID */
+        public virtual int getSingleElement()
+        {
+            if ( intervals != null && intervals.Count == 1 )
+            {
+                Interval I = (Interval)intervals[0];
+                if ( I.a == I.b )
+                {
+                    return I.a;
+                }
+            }
+            return Label.INVALID;
+        }
+
+        public virtual int getMaxElement()
+        {
+            if ( isNil() )
+            {
+                return Label.INVALID;
+            }
+            Interval last = (Interval)intervals[intervals.Count - 1];
+            return last.b;
+        }
+
+        /** Return minimum element >= 0 */
+        public virtual int getMinElement()
+        {
+            if ( isNil() )
+            {
+                return Label.INVALID;
+            }
+            int n = intervals.Count;
+            for ( int i = 0; i < n; i++ )
+            {
+                Interval I = (Interval)intervals[i];
+                int a = I.a;
+                int b = I.b;
+                for ( int v = a; v <= b; v++ )
+                {
+                    if ( v >= 0 )
+                        return v;
+                }
+            }
+            return Label.INVALID;
+        }
+
+        /** Return a list of Interval objects. */
+        public virtual IList<Interval> getIntervals()
+        {
+            return intervals;
+        }
+
+        /** Are two IntervalSets equal?  Because all intervals are sorted
+         *  and disjoint, equals is a simple linear walk over both lists
+         *  to make sure they are the same.  Interval.equals() is used
+         *  by the List.equals() method to check the ranges.
+         */
+        public override bool Equals( object obj )
+        {
+            if ( obj == null || !( obj is IntervalSet ) )
+            {
+                return false;
+            }
+            IntervalSet other = (IntervalSet)obj;
+            return intervals.SequenceEqual( other.intervals );
+        }
+
+        public override int GetHashCode()
+        {
+            return intervals.GetHashCode();
+        }
+
+        public override string ToString()
+        {
+            return ToString( null );
+        }
+
+        public virtual string ToString( Grammar g )
+        {
+            if ( this.intervals == null || this.intervals.Count == 0 )
+            {
+                return "{}";
+            }
+
+            StringBuilder buf = new StringBuilder();
+            if ( this.intervals.Count > 1 )
+            {
+                buf.Append( "{" );
+            }
+            foreach ( Interval I in intervals )
+            {
+                // element separation
+                if ( buf.Length > 1 )
+                    buf.Append( ", " );
+
+                int a = I.a;
+                int b = I.b;
+                if ( a == b )
+                {
+                    if ( g != null )
+                    {
+                        buf.Append( g.getTokenDisplayName( a ) );
+                    }
+                    else
+                    {
+                        buf.Append( a );
+                    }
+                }
+                else
+                {
+                    if ( g != null )
+                    {
+                        buf.Append( g.getTokenDisplayName( a ) + ".." + g.getTokenDisplayName( b ) );
+                    }
+                    else
+                    {
+                        buf.Append( a + ".." + b );
+                    }
+                }
+            }
+            if ( this.intervals.Count > 1 )
+            {
+                buf.Append( "}" );
+            }
+            return buf.ToString();
+        }
+
+        public virtual int size()
+        {
+            return intervals.Sum( interval => interval.b - interval.a + 1 );
+        }
+
+        public List<int> ToList()
+        {
+            int count = ( (IIntSet)this ).Count;
+            List<int> list = new List<int>( count );
+
+            foreach ( Interval interval in intervals )
+            {
+                for ( int i = interval.a; i <= interval.b; i++ )
+                    list.Add( i );
+            }
+
+            return list;
+        }
+
+        /** Get the ith element of ordered set.  Used only by RandomPhrase so
+         *  don't bother to implement if you're not doing that for a new
+         *  ANTLR code gen target.
+         */
+        public virtual int get( int i )
+        {
+            int n = intervals.Count;
+            int index = 0;
+            for ( int j = 0; j < n; j++ )
+            {
+                Interval I = (Interval)intervals[j];
+                int a = I.a;
+                int b = I.b;
+                for ( int v = a; v <= b; v++ )
+                {
+                    if ( index == i )
+                    {
+                        return v;
+                    }
+                    index++;
+                }
+            }
+            return -1;
+        }
+
+        public int[] toArray()
+        {
+            int[] values = new int[size()];
+            int n = intervals.Count;
+            int j = 0;
+            for ( int i = 0; i < n; i++ )
+            {
+                Interval I = (Interval)intervals[i];
+                int a = I.a;
+                int b = I.b;
+                for ( int v = a; v <= b; v++ )
+                {
+                    values[j] = v;
+                    j++;
+                }
+            }
+            return values;
+        }
+
+        public Antlr.Runtime.BitSet toRuntimeBitSet()
+        {
+            //org.antlr.runtime.BitSet s =
+            //    new org.antlr.runtime.BitSet( getMaxElement() + 1 );
+            Antlr.Runtime.BitSet s =
+                new Antlr.Runtime.BitSet( getMaxElement() + 1 );
+            int n = intervals.Count;
+            for ( int i = 0; i < n; i++ )
+            {
+                Interval I = (Interval)intervals[i];
+                int a = I.a;
+                int b = I.b;
+                for ( int v = a; v <= b; v++ )
+                {
+                    s.Add( v );
+                }
+            }
+            return s;
+        }
+
+        public virtual void remove( int el )
+        {
+            //throw new NoSuchMethodError("IntervalSet.remove() unimplemented");
+            throw new NotImplementedException();
+        }
+
+        /*
+        protected void finalize()
+        {
+            super.finalize();
+            JSystem.@out.println("size "+intervals.size()+" "+size());
+        }
+        */
+
+        #region ICollection<int> Members
+
+        void ICollection<int>.Add( int item )
+        {
+            add( item );
+        }
+
+        void ICollection<int>.Clear()
+        {
+            intervals.Clear();
+        }
+
+        bool ICollection<int>.Contains( int item )
+        {
+            return member( item );
+        }
+
+        void ICollection<int>.CopyTo( int[] array, int arrayIndex )
+        {
+            throw new NotImplementedException();
+        }
+
+        int ICollection<int>.Count
+        {
+            get
+            {
+                return intervals.Sum( interval => interval.b - interval.a + 1 );
+            }
+        }
+
+        bool ICollection<int>.IsReadOnly
+        {
+            get
+            {
+                return intervals.IsReadOnly;
+            }
+        }
+
+        bool ICollection<int>.Remove( int item )
+        {
+            remove( item );
+            return true;
+        }
+
+        #endregion
+
+        #region IEnumerable<int> Members
+
+        public IEnumerator<int> GetEnumerator()
+        {
+            return intervals.SelectMany( interval => Enumerable.Range( interval.a, interval.b - interval.a + 1 ) ).GetEnumerator();
+        }
+
+        #endregion
+
+        #region IEnumerable Members
+
+        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
+        {
+            return GetEnumerator();
+        }
+
+        #endregion
+    }
+}
diff --git a/Antlr3/Misc/MultiMap.cs b/Antlr3/Misc/MultiMap.cs
new file mode 100644
index 0000000..d873388
--- /dev/null
+++ b/Antlr3/Misc/MultiMap.cs
@@ -0,0 +1,67 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Misc
+{
+    using System.Collections.Generic;
+    using Antlr.Runtime.JavaExtensions;
+
+    /** A hash table that maps a key to a list of elements not just a single. */
+    public class MultiMap<K, V> : Dictionary<K, IList<V>>
+    {
+        public MultiMap()
+        {
+        }
+        public MultiMap( IEnumerable<KeyValuePair<K, V>> collection )
+        {
+            foreach ( var pair in collection )
+            {
+                map( pair.Key, pair.Value );
+            }
+        }
+
+        public void map( K key, V value )
+        {
+            IList<V> elementsForKey = this.get( key );
+            if ( elementsForKey == null )
+            {
+                elementsForKey = new List<V>();
+                this[key] = elementsForKey;
+            }
+            elementsForKey.Add( value );
+        }
+        public void Add( K key, V value )
+        {
+            map( key, value );
+        }
+    }
+}
diff --git a/Antlr3/Misc/OrderedHashSet.cs b/Antlr3/Misc/OrderedHashSet.cs
new file mode 100644
index 0000000..afb231b
--- /dev/null
+++ b/Antlr3/Misc/OrderedHashSet.cs
@@ -0,0 +1,197 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Misc
+{
+    using System.Collections.Generic;
+
+    using NotSupportedException = System.NotSupportedException;
+
+    /** A HashMap that remembers the order that the elements were added.
+     *  You can alter the ith element with set(i,value) too :)  Unique list.
+     *  I need the replace/set-element-i functionality so I'm subclassing
+     *  OrderedHashSet.
+     */
+    public class OrderedHashSet<T> : ICollection<T>
+    {
+        /** Track the elements as they are added to the set */
+        protected IList<T> _elements = new List<T>();
+
+        protected HashSet<T> _elementSet = new HashSet<T>();
+
+        public T get( int i )
+        {
+            return _elements[i];
+        }
+
+        /** Replace an existing value with a new value; updates the element
+         *  list and the hash table, but not the key as that has not changed.
+         */
+        public T set( int i, T value )
+        {
+            T oldElement = _elements[i];
+            _elements[i] = value; // update list
+
+            _elementSet.Remove( oldElement );
+            _elementSet.Add( value );
+
+            //throw new NotImplementedException();
+            //base.Remove( oldElement ); // now update the set: remove/add
+            //base.Add( value );
+            return oldElement;
+        }
+
+        /** Add a value to list; keep in hashtable for consistency also;
+         *  Key is object itself.  Good for say asking if a certain string is in
+         *  a list of strings.
+         */
+        public bool add( T value )
+        {
+            if ( _elementSet.Add( value ) )
+            {
+                _elements.Add( value );
+                return true;
+            }
+
+            return false;
+            //throw new NotImplementedException();
+            //boolean result = base.add( value );
+            //if ( result )
+            //{  // only track if new element not in set
+            //    elements.add( (T)value );
+            //}
+            //return result;
+        }
+
+        public bool remove( T o )
+        {
+            throw new NotSupportedException();
+            /*
+            elements.remove(o);
+            return super.remove(o);
+            */
+        }
+
+        public void clear()
+        {
+            _elements.Clear();
+            _elementSet.Clear();
+        }
+
+        /** Return the List holding list of table elements.  Note that you are
+         *  NOT getting a copy so don't write to the list.
+         */
+        public IList<T> getElements()
+        {
+            return _elements;
+        }
+
+        public int size()
+        {
+            /*
+            if ( elements.size()!=super.size() ) {
+                ErrorManager.internalError("OrderedHashSet: elements and set size differs; "+
+                                           elements.size()+"!="+super.size());
+            }
+            */
+            return _elements.Count;
+        }
+
+        public override string ToString()
+        {
+            return _elements.ToString();
+        }
+
+        #region ICollection<T> Members
+
+        public void Add( T item )
+        {
+            this.add( item );
+        }
+
+        public void Clear()
+        {
+            this.clear();
+        }
+
+        public bool Contains( T item )
+        {
+            return _elementSet.Contains( item );
+        }
+
+        public void CopyTo( T[] array, int arrayIndex )
+        {
+            throw new System.NotImplementedException();
+        }
+
+        public int Count
+        {
+            get
+            {
+                return _elements.Count;
+            }
+        }
+
+        public bool IsReadOnly
+        {
+            get
+            {
+                throw new System.NotImplementedException();
+            }
+        }
+
+        public bool Remove( T item )
+        {
+            throw new System.NotImplementedException();
+        }
+
+        #endregion
+
+        #region IEnumerable<T> Members
+
+        public IEnumerator<T> GetEnumerator()
+        {
+            return _elements.GetEnumerator();
+        }
+
+        #endregion
+
+        #region IEnumerable Members
+
+        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
+        {
+            return GetEnumerator();
+        }
+
+        #endregion
+    }
+}
diff --git a/Antlr3/Misc/Utils.cs b/Antlr3/Misc/Utils.cs
new file mode 100644
index 0000000..5f2f7c8
--- /dev/null
+++ b/Antlr3/Misc/Utils.cs
@@ -0,0 +1,72 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Misc
+{
+    using System;
+
+    public static class Utils
+    {
+        /** Integer objects are immutable so share all Integers with the
+         *  same value up to some max size.  Use an array as a perfect hash.
+         *  Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new
+         *  Integer object with x in it.
+         */
+        [Obsolete]
+        public static int integer( int x )
+        {
+            //if ( x<0 || x>INTEGER_POOL_MAX_VALUE ) {
+            //    return new Integer(x);
+            //}
+            //if ( ints[x]==null ) {
+            //    ints[x] = new Integer(x);
+            //}
+            //return ints[x];
+            return x;
+        }
+
+        /** Given a source string, src,
+            a string to replace, replacee,
+            and a string to replace with, replacer,
+            return a new string w/ the replacing done.
+            You can use replacer==null to remove replacee from the string.
+
+            This should be faster than Java's String.replaceAll as that one
+            uses regex (I only want to play with strings anyway).
+        */
+        [Obsolete]
+        public static string replace( string src, string replacee, string replacer )
+        {
+            return src.Replace( replacee, replacer );
+        }
+    }
+}
diff --git a/Antlr3/Properties/AssemblyInfo.cs b/Antlr3/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..6938a65
--- /dev/null
+++ b/Antlr3/Properties/AssemblyInfo.cs
@@ -0,0 +1,68 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle( "Antlr3" )]
+[assembly: AssemblyDescription( "" )]
+[assembly: AssemblyConfiguration( "" )]
+[assembly: AssemblyCompany( "Pixel Mine, Inc." )]
+[assembly: AssemblyProduct( "Antlr3" )]
+[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2008" )]
+[assembly: AssemblyTrademark( "" )]
+[assembly: AssemblyCulture( "" )]
+
+// Setting ComVisible to false makes the types in this assembly not visible
+// to COM components.  If you need to access a type in this assembly from
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible( false )]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid( "1f192196-5fb0-4eea-91a1-e9249dd45317" )]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion( "3.2.17529.0" )]
+[assembly: AssemblyFileVersion( "3.2.17529.0" )]
diff --git a/Antlr3/Tool/ANTLRErrorListener.cs b/Antlr3/Tool/ANTLRErrorListener.cs
new file mode 100644
index 0000000..fae2156
--- /dev/null
+++ b/Antlr3/Tool/ANTLRErrorListener.cs
@@ -0,0 +1,49 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    /** Defines behavior of object able to handle error messages from ANTLR including
+     *  both tool errors like "can't write file" and grammar ambiguity warnings.
+     *  To avoid having to change tools that use ANTLR (like GUIs), I am
+     *  wrapping error data in Message objects and passing them to the listener.
+     *  In this way, users of this interface are less sensitive to changes in
+     *  the info I need for error messages.
+     */
+    public interface IANTLRErrorListener
+    {
+        void info( string msg );
+        void error( Message msg );
+        void warning( Message msg );
+        void error( ToolMessage msg );
+    }
+}
diff --git a/Antlr3/Tool/AssignTokenTypesBehavior.cs b/Antlr3/Tool/AssignTokenTypesBehavior.cs
new file mode 100644
index 0000000..3617ef8
--- /dev/null
+++ b/Antlr3/Tool/AssignTokenTypesBehavior.cs
@@ -0,0 +1,327 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using System.Collections.Generic;
+    using System.Linq;
+    using Antlr.Runtime.JavaExtensions;
+    using Antlr.Runtime.Tree;
+    using Antlr3.Grammars;
+
+    using Label = Antlr3.Analysis.Label;
+
+    /** Move all of the functionality from assign.types.g grammar file. */
+    public class AssignTokenTypesBehavior : AssignTokenTypesWalker
+    {
+        protected const int UNASSIGNED = -1;
+        protected const int UNASSIGNED_IN_PARSER_RULE = -2;
+
+        protected IDictionary<string, int> stringLiterals = new SortedList<string, int>();
+        protected IDictionary<string, int> tokens = new SortedList<string, int>();
+        protected IDictionary<string, string> aliases = new SortedList<string, string>();
+        protected IDictionary<string, string> aliasesReverseIndex = new Dictionary<string, string>();
+
+        public AssignTokenTypesBehavior( ITreeNodeStream input )
+            : base( input )
+        {
+        }
+
+        /** Track actual lexer rule defs so we don't get repeated token defs in
+         *  generated lexer.
+         */
+        protected HashSet<string> tokenRuleDefs = new HashSet<string>();
+
+        protected override void init( Grammar g )
+        {
+            this.grammar = g;
+            currentRuleName = null;
+            if ( stringAlias == null )
+            {
+                // only init once; can't statically init since we need astFactory
+                initASTPatterns();
+            }
+        }
+
+        /** Track string literals (could be in tokens{} section) */
+        protected override void trackString( GrammarAST t )
+        {
+            // if lexer, don't allow aliasing in tokens section
+            if ( currentRuleName == null && grammar.type == Grammar.LEXER )
+            {
+                ErrorManager.grammarError( ErrorManager.MSG_CANNOT_ALIAS_TOKENS_IN_LEXER,
+                                          grammar,
+                                          t.token,
+                                          t.Text );
+                return;
+            }
+            // in a plain parser grammar rule, cannot reference literals
+            // (unless defined previously via tokenVocab option)
+            // don't warn until we hit root grammar as may be defined there.
+            if ( grammar.IsRoot &&
+                 grammar.type == Grammar.PARSER &&
+                 grammar.getTokenType( t.Text ) == Label.INVALID )
+            {
+                ErrorManager.grammarError( ErrorManager.MSG_LITERAL_NOT_ASSOCIATED_WITH_LEXER_RULE,
+                                          grammar,
+                                          t.token,
+                                          t.Text );
+            }
+            // Don't record literals for lexers, they are things to match not tokens
+            if ( grammar.type == Grammar.LEXER )
+            {
+                return;
+            }
+            // otherwise add literal to token types if referenced from parser rule
+            // or in the tokens{} section
+            if ( ( currentRuleName == null ||
+                  char.IsLower( currentRuleName[0] ) ) &&
+                                                                    grammar.getTokenType( t.Text ) == Label.INVALID )
+            {
+                stringLiterals[t.Text] = UNASSIGNED_IN_PARSER_RULE;
+            }
+        }
+
+        protected override void trackToken( GrammarAST t )
+        {
+            // imported token names might exist, only add if new
+            // Might have ';'=4 in vocab import and SEMI=';'. Avoid
+            // setting to UNASSIGNED if we have loaded ';'/SEMI
+            if ( grammar.getTokenType( t.Text ) == Label.INVALID &&
+                 !tokens.ContainsKey( t.Text ) )
+            {
+                tokens[t.Text] = UNASSIGNED;
+            }
+        }
+
+        protected override void trackTokenRule( GrammarAST t,
+                                      GrammarAST modifier,
+                                      GrammarAST block )
+        {
+            // imported token names might exist, only add if new
+            if ( grammar.type == Grammar.LEXER || grammar.type == Grammar.COMBINED )
+            {
+                if ( !char.IsUpper( t.Text[0] ) )
+                {
+                    return;
+                }
+                if ( t.Text.Equals( Grammar.ARTIFICIAL_TOKENS_RULENAME ) )
+                {
+                    // don't add Tokens rule
+                    return;
+                }
+
+                // track all lexer rules so we can look for token refs w/o
+                // associated lexer rules.
+                grammar.composite.lexerRules.Add( t.Text );
+
+                int existing = grammar.getTokenType( t.Text );
+                if ( existing == Label.INVALID )
+                {
+                    tokens[t.Text] = UNASSIGNED;
+                }
+                // look for "<TOKEN> : <literal> ;" pattern
+                // (can have optional action last)
+                if ( block.hasSameTreeStructure( charAlias ) ||
+                     block.hasSameTreeStructure( stringAlias ) ||
+                     block.hasSameTreeStructure( charAlias2 ) ||
+                     block.hasSameTreeStructure( stringAlias2 ) )
+                {
+                    tokenRuleDefs.Add( t.Text );
+                    /*
+                Grammar parent = grammar.composite.getDelegator(grammar);
+                boolean importedByParserOrCombined =
+                    parent!=null &&
+                    (parent.type==Grammar.LEXER||parent.type==Grammar.PARSER);
+                    */
+                    if ( grammar.type == Grammar.COMBINED || grammar.type == Grammar.LEXER )
+                    {
+                        // only call this rule an alias if combined or lexer
+                        alias( t, (GrammarAST)block.GetChild( 0 ).GetChild( 0 ) );
+                    }
+                }
+            }
+            // else error
+        }
+
+        protected override void alias( GrammarAST t, GrammarAST s )
+        {
+            string tokenID = t.Text;
+            string literal = s.Text;
+            string prevAliasLiteralID = aliasesReverseIndex.get( literal );
+            if ( prevAliasLiteralID != null )
+            { // we've seen this literal before
+                if ( tokenID.Equals( prevAliasLiteralID ) )
+                {
+                    // duplicate but identical alias; might be tokens {A='a'} and
+                    // lexer rule A : 'a' ;  Is ok, just return
+                    return;
+                }
+
+                // give error unless both are rules (ok if one is in tokens section)
+                if ( !( tokenRuleDefs.Contains( tokenID ) && tokenRuleDefs.Contains( prevAliasLiteralID ) ) )
+                {
+                    // don't allow alias if A='a' in tokens section and B : 'a'; is rule.
+                    // Allow if both are rules.  Will get DFA nondeterminism error later.
+                    ErrorManager.grammarError( ErrorManager.MSG_TOKEN_ALIAS_CONFLICT,
+                                              grammar,
+                                              t.token,
+                                              tokenID + "=" + literal,
+                                              prevAliasLiteralID );
+                }
+                return; // don't do the alias
+            }
+            int existingLiteralType = grammar.getTokenType( literal );
+            if ( existingLiteralType != Label.INVALID )
+            {
+                // we've seen this before from a tokenVocab most likely
+                // don't assign a new token type; use existingLiteralType.
+                tokens[tokenID] = existingLiteralType;
+            }
+            string prevAliasTokenID = aliases.get( tokenID );
+            if ( prevAliasTokenID != null )
+            {
+                ErrorManager.grammarError( ErrorManager.MSG_TOKEN_ALIAS_REASSIGNMENT,
+                                          grammar,
+                                          t.token,
+                                          tokenID + "=" + literal,
+                                          prevAliasTokenID );
+                return; // don't do the alias
+            }
+            aliases[tokenID] = literal;
+            aliasesReverseIndex[literal] = tokenID;
+        }
+
+        protected internal override void defineTokens( Grammar root )
+        {
+            /*
+                System.out.println("stringLiterals="+stringLiterals);
+                System.out.println("tokens="+tokens);
+                System.out.println("aliases="+aliases);
+                System.out.println("aliasesReverseIndex="+aliasesReverseIndex);
+            */
+
+            assignTokenIDTypes( root );
+
+            aliasTokenIDsAndLiterals( root );
+
+            assignStringTypes( root );
+
+            /*
+                System.out.println("stringLiterals="+stringLiterals);
+                System.out.println("tokens="+tokens);
+                System.out.println("aliases="+aliases);
+            */
+            defineTokenNamesAndLiteralsInGrammar( root );
+        }
+
+        /*
+        protected void defineStringLiteralsFromDelegates() {
+             if ( grammar.getGrammarIsMaster() && grammar.type==Grammar.COMBINED ) {
+                 List<Grammar> delegates = grammar.getDelegates();
+                 System.out.println("delegates in master combined: "+delegates);
+                 for (int i = 0; i < delegates.size(); i++) {
+                     Grammar d = (Grammar) delegates.get(i);
+                     Set<String> literals = d.getStringLiterals();
+                     for (Iterator it = literals.iterator(); it.hasNext();) {
+                         String literal = (String) it.next();
+                         System.out.println("literal "+literal);
+                         int ttype = grammar.getTokenType(literal);
+                         grammar.defineLexerRuleForStringLiteral(literal, ttype);
+                     }
+                 }
+             }
+        }
+        */
+
+        protected override void assignStringTypes( Grammar root )
+        {
+            // walk string literals assigning types to unassigned ones
+            foreach ( var literal in stringLiterals.Where( pair => pair.Value < Label.MIN_TOKEN_TYPE ).ToArray() )
+            {
+                int type = root.getNewTokenType();
+                stringLiterals[literal.Key] = type;
+                // if string referenced in combined grammar parser rule,
+                // automatically define in the generated lexer
+                root.defineLexerRuleForStringLiteral( literal.Key, type );
+            }
+        }
+
+        protected override void aliasTokenIDsAndLiterals( Grammar root )
+        {
+            if ( root.type == Grammar.LEXER )
+            {
+                return; // strings/chars are never token types in LEXER
+            }
+            // walk aliases if any and assign types to aliased literals if literal
+            // was referenced
+            foreach ( var alias in aliases )
+            {
+                string tokenID = alias.Key;
+                string literal = alias.Value;
+                if ( literal[0] == '\'' && stringLiterals.ContainsKey( literal ) )
+                {
+                    stringLiterals[literal] = tokens.get( tokenID );
+                    // an alias still means you need a lexer rule for it
+                    int typeI = (int)tokens.get( tokenID );
+                    if ( !tokenRuleDefs.Contains( tokenID ) )
+                    {
+                        root.defineLexerRuleForAliasedStringLiteral( tokenID, literal, typeI );
+                    }
+                }
+            }
+        }
+
+        protected override void assignTokenIDTypes( Grammar root )
+        {
+            // walk token names, assigning values if unassigned
+            foreach ( var token in tokens.Where( pair => pair.Value == UNASSIGNED ).ToArray() )
+            {
+                tokens[token.Key] = root.getNewTokenType();
+            }
+        }
+
+        protected override void defineTokenNamesAndLiteralsInGrammar( Grammar root )
+        {
+            foreach ( var token in tokens )
+            {
+                root.defineToken( token.Key, token.Value );
+            }
+
+            foreach ( var lit in stringLiterals )
+            {
+                root.defineToken( lit.Key, lit.Value );
+            }
+        }
+
+    }
+}
diff --git a/Antlr3/Tool/Attribute.cs b/Antlr3/Tool/Attribute.cs
new file mode 100644
index 0000000..2695a8e
--- /dev/null
+++ b/Antlr3/Tool/Attribute.cs
@@ -0,0 +1,173 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using Antlr.Runtime.JavaExtensions;
+
+    /** Track the names of attributes define in arg lists, return values,
+     *  scope blocks etc...
+     */
+    public class Attribute
+    {
+        /** The entire declaration such as "String foo;" */
+        public string Decl
+        {
+            get;
+            set;
+        }
+
+        /** The type; might be empty such as for Python which has no static typing */
+        public string Type
+        {
+            get;
+            set;
+        }
+
+        /** The name of the attribute "foo" */
+        public string Name
+        {
+            get;
+            set;
+        }
+
+        /** The optional attribute intialization expression */
+        public string InitValue
+        {
+            get;
+            set;
+        }
+
+        public Attribute( string decl )
+        {
+            extractAttribute( decl );
+        }
+
+        public Attribute( string name, string decl )
+        {
+            this.Name = name;
+            this.Decl = decl;
+        }
+
+        /** For decls like "String foo" or "char *foo32[3]" compute the ID
+         *  and type declarations.  Also handle "int x=3" and 'T t = new T("foo")'
+         *  but if the separator is ',' you cannot use ',' in the initvalue.
+         *  AttributeScope.addAttributes takes care of the separation so we are
+         *  free here to use from '=' to end of string as the expression.
+         *
+         *  Set name, type, initvalue, and full decl instance vars.
+         */
+        protected virtual void extractAttribute( string decl )
+        {
+            if ( decl == null )
+            {
+                return;
+            }
+            bool inID = false;
+            int start = -1;
+            int rightEdgeOfDeclarator = decl.Length - 1;
+            int equalsIndex = decl.IndexOf( '=' );
+            if ( equalsIndex > 0 )
+            {
+                // everything after the '=' is the init value
+                this.InitValue = decl.Substring( equalsIndex + 1 );
+                rightEdgeOfDeclarator = equalsIndex - 1;
+            }
+            // walk backwards looking for start of an ID
+            for ( int i = rightEdgeOfDeclarator; i >= 0; i-- )
+            {
+                // if we haven't found the end yet, keep going
+                if ( !inID && char.IsLetterOrDigit( decl[i] ) )
+                {
+                    inID = true;
+                }
+                else if ( inID &&
+                          !( char.IsLetterOrDigit( decl[i] ) ||
+                           decl[i] == '_' ) )
+                {
+                    start = i + 1;
+                    break;
+                }
+            }
+            if ( start < 0 && inID )
+            {
+                start = 0;
+            }
+            if ( start < 0 )
+            {
+                ErrorManager.error( ErrorManager.MSG_CANNOT_FIND_ATTRIBUTE_NAME_IN_DECL, decl );
+            }
+            // walk forwards looking for end of an ID
+            int stop = -1;
+            for ( int i = start; i <= rightEdgeOfDeclarator; i++ )
+            {
+                // if we haven't found the end yet, keep going
+                if ( !( char.IsLetterOrDigit( decl[i] ) ||
+                    decl[i] == '_' ) )
+                {
+                    stop = i;
+                    break;
+                }
+                if ( i == rightEdgeOfDeclarator )
+                {
+                    stop = i + 1;
+                }
+            }
+
+            // the name is the last ID
+            this.Name = decl.Substring( start, stop - start );
+
+            // the type is the decl minus the ID (could be empty)
+            this.Type = decl.Substring( 0, start );
+            if ( stop <= rightEdgeOfDeclarator )
+            {
+                this.Type += decl.Substring( stop, rightEdgeOfDeclarator + 1 - stop );
+            }
+            this.Type = Type.Trim();
+            if ( this.Type.Length == 0 )
+            {
+                this.Type = null;
+            }
+
+            this.Decl = decl;
+        }
+
+        public override string ToString()
+        {
+            if ( InitValue != null )
+            {
+                return Type + " " + Name + "=" + InitValue;
+            }
+            return Type + " " + Name;
+        }
+    }
+}
diff --git a/Antlr3/Tool/AttributeScope.cs b/Antlr3/Tool/AttributeScope.cs
new file mode 100644
index 0000000..d4572f5
--- /dev/null
+++ b/Antlr3/Tool/AttributeScope.cs
@@ -0,0 +1,298 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using System.Collections.Generic;
+    using System.Linq;
+    using Antlr.Runtime.JavaExtensions;
+
+    using CodeGenerator = Antlr3.Codegen.CodeGenerator;
+    using IToken = Antlr.Runtime.IToken;
+
+    /** Track the attributes within a scope.  A named scoped has just its list
+     *  of attributes.  Each rule has potentially 3 scopes: return values,
+     *  parameters, and an implicitly-named scope (i.e., a scope defined in a rule).
+     *  Implicitly-defined scopes are named after the rule; rules and scopes then
+     *  must live in the same name space--no collisions allowed.
+     */
+    public class AttributeScope
+    {
+
+        /** All token scopes (token labels) share the same fixed scope of
+         *  of predefined attributes.  I keep this out of the runtime.Token
+         *  object to avoid a runtime space burden.
+         */
+        public static AttributeScope tokenScope = new AttributeScope( "Token", null );
+
+        static AttributeScope()
+        {
+            tokenScope.addAttribute( "text", null );
+            tokenScope.addAttribute( "type", null );
+            tokenScope.addAttribute( "line", null );
+            tokenScope.addAttribute( "index", null );
+            tokenScope.addAttribute( "pos", null );
+            tokenScope.addAttribute( "channel", null );
+            tokenScope.addAttribute( "tree", null );
+            tokenScope.addAttribute( "int", null );
+        }
+
+        /** This scope is associated with which input token (for error handling)? */
+        public IToken derivedFromToken;
+
+        public Grammar grammar;
+
+        /** The scope name */
+        private string name;
+
+        /** Not a rule scope, but visible to all rules "scope symbols { ...}" */
+        public bool isDynamicGlobalScope;
+
+        /** Visible to all rules, but defined in rule "scope { int i; }" */
+        public bool isDynamicRuleScope;
+
+        public bool isParameterScope;
+
+        public bool isReturnScope;
+
+        public bool isPredefinedRuleScope;
+
+        public bool isPredefinedLexerRuleScope;
+
+        IDictionary<string, GrammarAST> actions = new Dictionary<string, GrammarAST>();
+
+        /** The list of Attribute objects */
+
+        // until we have a list-ordered dictionary
+        //protected internal IDictionary<string, Attribute> attributes = new SortedList<string, Attribute>();
+        protected internal IList<Attribute> attributes = new List<Attribute>();
+
+        public AttributeScope( string name, IToken derivedFromToken )
+            : this( null, name, derivedFromToken )
+        {
+        }
+
+        public AttributeScope( Grammar grammar, string name, IToken derivedFromToken )
+        {
+            this.grammar = grammar;
+            this.name = name;
+            this.derivedFromToken = derivedFromToken;
+        }
+
+        #region Properties
+        public IDictionary<string, GrammarAST> Actions
+        {
+            get
+            {
+                return actions;
+            }
+        }
+        public ICollection<Attribute> Attributes
+        {
+            get
+            {
+                return getAttributes();
+            }
+        }
+        public int Count
+        {
+            get
+            {
+                return size();
+            }
+        }
+        public string Name
+        {
+            get
+            {
+                return getName();
+            }
+        }
+        #endregion
+
+        public virtual string getName()
+        {
+            if ( isParameterScope )
+            {
+                return name + "_parameter";
+            }
+            else if ( isReturnScope )
+            {
+                return name + "_return";
+            }
+            return name;
+        }
+
+        /** From a chunk of text holding the definitions of the attributes,
+         *  pull them apart and create an Attribute for each one.  Add to
+         *  the list of attributes for this scope.  Pass in the character
+         *  that terminates a definition such as ',' or ';'.  For example,
+         *
+         *  scope symbols {
+         *  	int n;
+         *  	List names;
+         *  }
+         *
+         *  would pass in definitions equal to the text in between {...} and
+         *  separator=';'.  It results in two Attribute objects.
+         */
+        public virtual void addAttributes( string definitions, int separator )
+        {
+            IList<string> attrs = new List<string>();
+            CodeGenerator.getListOfArgumentsFromAction( definitions, 0, -1, separator, attrs );
+            foreach ( string a in attrs )
+            {
+                Attribute attr = new Attribute( a );
+                if ( !isReturnScope && attr.InitValue != null )
+                {
+                    ErrorManager.grammarError( ErrorManager.MSG_ARG_INIT_VALUES_ILLEGAL,
+                                              grammar,
+                                              derivedFromToken,
+                                              attr.Name );
+                    attr.InitValue = null; // wipe it out
+                }
+                for ( int i = 0; i <= attributes.Count; i++ )
+                {
+                    if ( i < attributes.Count )
+                    {
+                        if ( attributes[i].Name == attr.Name )
+                        {
+                            attributes[i] = attr;
+                            break;
+                        }
+                    }
+                    else
+                    {
+                        attributes.Add( attr );
+                        // *must* break since the count changed
+                        break;
+                        //attributes.put( attr.Name, attr );
+                    }
+                }
+            }
+        }
+
+        public virtual void addAttribute( string name, string decl )
+        {
+            Attribute attr = new Attribute( name, decl );
+            for ( int i = 0; i <= attributes.Count; i++ )
+            {
+                if ( i < attributes.Count )
+                {
+                    if ( attributes[i].Name == attr.Name )
+                    {
+                        attributes[i] = attr;
+                        break;
+                    }
+                }
+                else
+                {
+                    attributes.Add( attr );
+                    // *must* break since the count changed
+                    break;
+                    //attributes.put( name, new Attribute( name, decl ) );
+                }
+            }
+        }
+
+        /** Given @scope::name {action} define it for this attribute scope. Later,
+         *  the code generator will ask for the actions table.
+         */
+        public void DefineNamedAction( GrammarAST nameAST, GrammarAST actionAST )
+        {
+            string actionName = nameAST.Text;
+            GrammarAST a;
+            if ( Actions.TryGetValue( actionName, out a ) && a != null )
+            {
+                ErrorManager.grammarError(
+                    ErrorManager.MSG_ACTION_REDEFINITION, grammar,
+                    nameAST.Token, nameAST.Text );
+            }
+            else
+            {
+                Actions[actionName] = actionAST;
+            }
+        }
+
+        public virtual Attribute getAttribute( string name )
+        {
+            return attributes.FirstOrDefault( attr => attr.Name == name );
+            //return (Attribute)attributes.get( name );
+        }
+
+        /** Used by templates to get all attributes */
+        public virtual IList<Attribute> getAttributes()
+        {
+            return attributes.ToArray();
+            //return attributes.Values.ToArray();
+
+            //IList<Attribute> a = new List<Attribute>();
+            //a.addAll( attributes.values() );
+            //return a;
+        }
+
+        /** Return the set of keys that collide from
+         *  this and other.
+         */
+        public virtual HashSet<object> intersection( AttributeScope other )
+        {
+            if ( other == null || other.Count == 0 || Count == 0 )
+            {
+                return null;
+            }
+            HashSet<object> inter = new HashSet<object>();
+            foreach ( Attribute attr in attributes )
+            {
+                string key = attr.Name;
+                if ( other.getAttribute( key ) != null )
+                {
+                    inter.Add( key );
+                }
+            }
+            if ( inter.Count == 0 )
+            {
+                return null;
+            }
+            return inter;
+        }
+
+        public virtual int size()
+        {
+            return attributes == null ? 0 : attributes.Count;
+        }
+
+        public override string ToString()
+        {
+            return ( isDynamicGlobalScope ? "global " : "" ) + Name + ":" + attributes;
+        }
+    }
+}
diff --git a/Antlr3/Tool/BuildDependencyGenerator.cs b/Antlr3/Tool/BuildDependencyGenerator.cs
new file mode 100644
index 0000000..377bd24
--- /dev/null
+++ b/Antlr3/Tool/BuildDependencyGenerator.cs
@@ -0,0 +1,282 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using System;
+    using System.Collections.Generic;
+    using System.Linq;
+
+    using ArrayList = System.Collections.Generic.List<object>;
+    using CodeGenerator = Antlr3.Codegen.CodeGenerator;
+    using FileInfo = System.IO.FileInfo;
+    using IList = System.Collections.IList;
+    using StringTemplate = Antlr3.ST.StringTemplate;
+    using StringTemplateGroup = Antlr3.ST.StringTemplateGroup;
+    using Tool = Antlr3.AntlrTool;
+
+    /** Given a grammar file, show the dependencies on .tokens etc...
+     *  Using ST, emit a simple "make compatible" list of dependencies.
+     *  For example, combined grammar T.g (no token import) generates:
+     *
+     *		TParser.java : T.g
+     * 		T.tokens : T.g
+     * 		T__g : T.g
+     *
+     *  For tree grammar TP with import of T.tokens:
+     *
+     * 		TP.g : T.tokens
+     * 		TP.java : TP.g
+     *
+     *  If "-lib libdir" is used on command-line with -depend, then include the
+     *  path like
+     *
+     * 		TP.g : libdir/T.tokens
+     *
+     *  Pay attention to -o as well:
+     *
+     * 		outputdir/TParser.java : T.g
+     *
+     *  So this output shows what the grammar depends on *and* what it generates.
+     *
+     *  Operate on one grammar file at a time.  If given a list of .g on the
+     *  command-line with -depend, just emit the dependencies.  The grammars
+     *  may depend on each other, but the order doesn't matter.  Build tools,
+     *  reading in this output, will know how to organize it.
+     *
+     *  This is a wee bit slow probably because the code generator has to load
+     *  all of its template files in order to figure out the file extension
+     *  for the generated recognizer.
+     *
+     *  This code was obvious until I removed redundant "./" on front of files
+     *  and had to escape spaces in filenames :(
+     */
+    public class BuildDependencyGenerator
+    {
+        protected string grammarFileName;
+        protected Tool tool;
+        protected Grammar grammar;
+        protected CodeGenerator generator;
+        protected StringTemplateGroup templates;
+
+        public BuildDependencyGenerator( Tool tool, string grammarFileName )
+        {
+            this.tool = tool;
+            this.grammarFileName = grammarFileName;
+            grammar = tool.getRootGrammar( grammarFileName );
+            string language = (string)grammar.getOption( "language" );
+            generator = new CodeGenerator( tool, grammar, language );
+            generator.loadTemplates( language );
+        }
+
+        /** From T.g return a list of File objects that
+         *  name files ANTLR will emit from T.g.
+         */
+        public virtual IList<string> getGeneratedFileList()
+        {
+            List<FileInfo> files = new List<FileInfo>();
+            System.IO.DirectoryInfo outputDir = tool.getOutputDirectory( grammarFileName );
+            if ( outputDir.Name.Equals( "." ) )
+            {
+                outputDir = null;
+            }
+            else if ( outputDir.Name.IndexOf( ' ' ) >= 0 )
+            { // has spaces?
+                string escSpaces = outputDir.ToString().Replace(
+                                                 " ",
+                                                 "\\ " );
+                outputDir = new System.IO.DirectoryInfo( escSpaces );
+            }
+            // add generated recognizer; e.g., TParser.java
+            string recognizer =
+                generator.getRecognizerFileName( grammar.name, grammar.type );
+            files.Add( new FileInfo( System.IO.Path.Combine( outputDir.FullName, recognizer ) ) );
+            // add output vocab file; e.g., T.tokens
+            files.Add( new FileInfo( System.IO.Path.Combine( outputDir.FullName, generator.VocabFileName ) ) );
+            // are we generating a .h file?
+            StringTemplate headerExtST = null;
+            if ( generator.Templates.isDefined( "headerFile" ) )
+            {
+                headerExtST = generator.Templates.getInstanceOf( "headerFileExtension" );
+                string suffix = Grammar.grammarTypeToFileNameSuffix[grammar.type];
+                string fileName = grammar.name + suffix + headerExtST.ToString();
+                files.Add( new FileInfo( System.IO.Path.Combine( outputDir.FullName, fileName ) ) );
+            }
+            if ( grammar.type == Grammar.COMBINED )
+            {
+                // add autogenerated lexer; e.g., TLexer.java TLexer.h TLexer.tokens
+                // don't add T__.g (just a temp file)
+                StringTemplate extST = generator.Templates.getInstanceOf( "codeFileExtension" );
+                string suffix = Grammar.grammarTypeToFileNameSuffix[Grammar.LEXER];
+                string lexer = grammar.name + suffix + extST.ToString();
+                files.Add( new FileInfo( System.IO.Path.Combine( outputDir.FullName, lexer ) ) );
+
+                // TLexer.h
+                if ( headerExtST != null )
+                {
+                    string header = grammar.name + suffix + headerExtST.ToString();
+                    files.Add( new FileInfo( System.IO.Path.Combine( outputDir.FullName, header ) ) );
+                }
+                // for combined, don't generate TLexer.tokens
+            }
+
+            // handle generated files for imported grammars
+            IList<Grammar> imports =
+                grammar.composite.getDelegates( grammar.composite.RootGrammar );
+            foreach ( Grammar g in imports )
+            {
+                outputDir = tool.getOutputDirectory( g.FileName );
+                string fname = groomQualifiedFileName( outputDir.ToString(), g.getRecognizerName() );
+                files.Add( new FileInfo( fname ) );
+            }
+
+            if ( files.Count == 0 )
+            {
+                return null;
+            }
+
+            return files.Select( info => info.FullName ).ToArray();
+        }
+
+        /** Return a list of File objects that name files ANTLR will read
+         *  to process T.g; for now, this can only be .tokens files and only
+         *  if they use the tokenVocab option.
+         */
+        public virtual IList<string> getDependenciesFileList()
+        {
+            IList<string> files = new List<string>();
+
+            // handle token vocabulary loads
+            string vocabName = (string)grammar.getOption( "tokenVocab" );
+            if ( vocabName != null )
+            {
+                FileInfo vocabFile = tool.getImportedVocabFile( vocabName );
+                System.IO.DirectoryInfo outputDir = vocabFile.Directory;
+                string fileName = groomQualifiedFileName( outputDir.Name, vocabFile.Name );
+                files.Add( fileName );
+            }
+
+            // handle imported grammars
+            IList<Grammar> imports =
+                grammar.composite.getDelegates( grammar.composite.RootGrammar );
+            foreach ( Grammar g in imports )
+            {
+                string libdir = tool.getLibraryDirectory();
+                string fileName = groomQualifiedFileName( libdir, g.fileName );
+                files.Add( fileName );
+            }
+
+            if ( files.Count == 0 )
+            {
+                return null;
+            }
+            return files;
+        }
+
+        public virtual StringTemplate getDependencies()
+        {
+            loadDependencyTemplates();
+            StringTemplate dependenciesST = templates.getInstanceOf( "dependencies" );
+            dependenciesST.setAttribute( "in", getDependenciesFileList() );
+            dependenciesST.setAttribute( "out", getGeneratedFileList() );
+            dependenciesST.setAttribute( "grammarFileName", grammar.fileName );
+            return dependenciesST;
+        }
+
+        public virtual void loadDependencyTemplates()
+        {
+            throw new NotImplementedException();
+            //if ( templates != null )
+            //{
+            //    return;
+            //}
+            //String fileName = "org/antlr/tool/templates/depend.stg";
+            //ClassLoader cl = Thread.currentThread().getContextClassLoader();
+            //InputStream @is = cl.getResourceAsStream( fileName );
+            //if ( @is == null )
+            //{
+            //    cl = typeof( ErrorManager ).getClassLoader();
+            //    @is = cl.getResourceAsStream( fileName );
+            //}
+            //if ( @is == null )
+            //{
+            //    ErrorManager.internalError( "Can't load dependency templates: " + fileName );
+            //    return;
+            //}
+            //BufferedReader br = null;
+            //try
+            //{
+            //    br = new BufferedReader( new InputStreamReader( @is ) );
+            //    templates = new StringTemplateGroup( br,
+            //                                        typeof( AngleBracketTemplateLexer ) );
+            //    br.close();
+            //}
+            //catch ( IOException ioe )
+            //{
+            //    ErrorManager.internalError( "error reading dependency templates file " + fileName, ioe );
+            //}
+            //finally
+            //{
+            //    if ( br != null )
+            //    {
+            //        try
+            //        {
+            //            br.close();
+            //        }
+            //        catch ( IOException ioe )
+            //        {
+            //            ErrorManager.internalError( "cannot close dependency templates file " + fileName, ioe );
+            //        }
+            //    }
+            //}
+        }
+
+        public virtual string groomQualifiedFileName( string outputDir, string fileName )
+        {
+            if ( outputDir.Equals( "." ) )
+            {
+                return fileName;
+            }
+            else if ( outputDir.IndexOf( ' ' ) >= 0 )
+            { // has spaces?
+                string escSpaces = outputDir.ToString().Replace(
+                                                 " ",
+                                                 "\\ " );
+                return System.IO.Path.Combine( escSpaces, fileName );
+            }
+            else
+            {
+                return System.IO.Path.Combine( outputDir, fileName );
+            }
+        }
+    }
+}
diff --git a/Antlr3/Tool/CompositeGrammar.cs b/Antlr3/Tool/CompositeGrammar.cs
new file mode 100644
index 0000000..371f1f7
--- /dev/null
+++ b/Antlr3/Tool/CompositeGrammar.cs
@@ -0,0 +1,609 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using System.Collections.Generic;
+    using System.Linq;
+    using Antlr.Runtime.JavaExtensions;
+    using Antlr3.Grammars;
+
+    using Label = Antlr3.Analysis.Label;
+    using NFAState = Antlr3.Analysis.NFAState;
+    using RecognitionException = Antlr.Runtime.RecognitionException;
+
+    /** A tree of component (delegate) grammars.
+     *
+     *  Rules defined in delegates are "inherited" like multi-inheritance
+     *  so you can override them.  All token types must be consistent across
+     *  rules from all delegate grammars, so they must be stored here in one
+     *  central place.
+     *
+     *  We have to start out assuming a composite grammar situation as we can't
+     *  look into the grammar files a priori to see if there is a delegate
+     *  statement.  Because of this, and to avoid duplicating token type tracking
+     *  in each grammar, even single noncomposite grammars use one of these objects
+     *  to track token types.
+     */
+    public class CompositeGrammar
+    {
+        public const int MIN_RULE_INDEX = 1;
+
+        public CompositeGrammarTree delegateGrammarTreeRoot;
+
+        /** Used during getRuleReferenceClosure to detect computation cycles */
+        protected HashSet<NFAState> refClosureBusy = new HashSet<NFAState>();
+
+        /** Used to assign state numbers; all grammars in composite share common
+         *  NFA space.  This NFA tracks state numbers number to state mapping.
+         */
+        public int stateCounter = 0;
+
+        /** The NFA states in the NFA built from rules across grammars in composite.
+         *  Maps state number to NFAState object.
+         *  This is a Vector instead of a List because I need to be able to grow
+         *  this properly.  After talking to Josh Bloch, Collections guy at Sun,
+         *  I decided this was easiest solution.
+         */
+        protected List<NFAState> numberToStateList = new List<NFAState>( 1000 );
+
+        /** Token names and literal tokens like "void" are uniquely indexed.
+         *  with -1 implying EOF.  Characters are different; they go from
+         *  -1 (EOF) to \uFFFE.  For example, 0 could be a binary byte you
+         *  want to lexer.  Labels of DFA/NFA transitions can be both tokens
+         *  and characters.  I use negative numbers for bookkeeping labels
+         *  like EPSILON. Char/String literals and token types overlap in the same
+         *  space, however.
+         */
+        protected internal int maxTokenType = Label.MIN_TOKEN_TYPE - 1;
+
+        /** Map token like ID (but not literals like "while") to its token type */
+        public IDictionary<string, int> tokenIDToTypeMap = new Dictionary<string, int>();
+
+        /** Map token literals like "while" to its token type.  It may be that
+         *  WHILE="while"=35, in which case both tokenIDToTypeMap and this
+         *  field will have entries both mapped to 35.
+         */
+        public IDictionary<string, int> stringLiteralToTypeMap = new Dictionary<string, int>();
+        /** Reverse index for stringLiteralToTypeMap */
+        public List<string> typeToStringLiteralList = new List<string>();
+
+        /** Map a token type to its token name.
+         *  Must subtract MIN_TOKEN_TYPE from index.
+         */
+        public List<string> typeToTokenList = new List<string>();
+
+        /** If combined or lexer grammar, track the rules.
+         * 	Track lexer rules so we can warn about undefined tokens.
+         *  This is combined set of lexer rules from all lexer grammars
+         *  seen in all imports.
+         */
+        protected internal HashSet<string> lexerRules = new HashSet<string>();
+
+        /** Rules are uniquely labeled from 1..n among all grammars */
+        protected internal int ruleIndex = MIN_RULE_INDEX;
+
+        /** Map a rule index to its name; use a Vector on purpose as new
+         *  collections stuff won't let me setSize and make it grow.  :(
+         *  I need a specific guaranteed index, which the Collections stuff
+         *  won't let me have.
+         */
+        protected internal List<Rule> ruleIndexToRuleList = new List<Rule>();
+
+        public bool watchNFAConversion = false;
+
+        protected virtual void initTokenSymbolTables()
+        {
+            // the faux token types take first NUM_FAUX_LABELS positions
+            // then we must have room for the predefined runtime token types
+            // like DOWN/UP used for tree parsing.
+            typeToTokenList.setSize( Label.NUM_FAUX_LABELS + Label.MIN_TOKEN_TYPE - 1 );
+            typeToTokenList[Label.NUM_FAUX_LABELS + Label.INVALID] = "<INVALID>";
+            typeToTokenList[Label.NUM_FAUX_LABELS + Label.EOT] = "<EOT>";
+            typeToTokenList[Label.NUM_FAUX_LABELS + Label.SEMPRED] = "<SEMPRED>";
+            typeToTokenList[Label.NUM_FAUX_LABELS + Label.SET] = "<SET>";
+            typeToTokenList[Label.NUM_FAUX_LABELS + Label.EPSILON] = Label.EPSILON_STR;
+            typeToTokenList[Label.NUM_FAUX_LABELS + Label.EOF] = "EOF";
+            typeToTokenList[Label.NUM_FAUX_LABELS + Label.EOR_TOKEN_TYPE - 1] = "<EOR>";
+            typeToTokenList[Label.NUM_FAUX_LABELS + Label.DOWN - 1] = "DOWN";
+            typeToTokenList[Label.NUM_FAUX_LABELS + Label.UP - 1] = "UP";
+            tokenIDToTypeMap["<INVALID>"] = Label.INVALID;
+            tokenIDToTypeMap["<EOT>"] = Label.EOT;
+            tokenIDToTypeMap["<SEMPRED>"] = Label.SEMPRED;
+            tokenIDToTypeMap["<SET>"] = Label.SET;
+            tokenIDToTypeMap["<EPSILON>"] = Label.EPSILON;
+            tokenIDToTypeMap["EOF"] = Label.EOF;
+            tokenIDToTypeMap["<EOR>"] = Label.EOR_TOKEN_TYPE;
+            tokenIDToTypeMap["DOWN"] = Label.DOWN;
+            tokenIDToTypeMap["UP"] = Label.UP;
+        }
+
+        public CompositeGrammar()
+        {
+            initTokenSymbolTables();
+        }
+
+        public CompositeGrammar( Grammar g )
+            : this()
+        {
+            setDelegationRoot( g );
+        }
+
+        #region Properties
+        public Grammar RootGrammar
+        {
+            get
+            {
+                return getRootGrammar();
+            }
+        }
+        #endregion
+
+        public virtual void setDelegationRoot( Grammar root )
+        {
+            delegateGrammarTreeRoot = new CompositeGrammarTree( root );
+            root.compositeTreeNode = delegateGrammarTreeRoot;
+        }
+
+        public virtual Rule getRule( string ruleName )
+        {
+            return delegateGrammarTreeRoot.getRule( ruleName );
+        }
+
+        public virtual object getOption( string key )
+        {
+            return delegateGrammarTreeRoot.getOption( key );
+        }
+
+        /** Add delegate grammar as child of delegator */
+#if WTF
+	public void addGrammar(Grammar delegator, Grammar delegate) {
+		if ( delegator.compositeTreeNode==null ) {
+			delegator.compositeTreeNode = new CompositeGrammarTree(delegator);
+		}
+		delegator.compositeTreeNode.addChild(new CompositeGrammarTree(delegate));
+
+		/*// find delegator in tree so we can add a child to it
+		CompositeGrammarTree t = delegateGrammarTreeRoot.findNode(delegator);
+		t.addChild();
+		*/
+		// make sure new grammar shares this composite
+		delegate.composite = this;
+	}
+#else
+        public virtual void addGrammar( Grammar delegator, Grammar @delegate )
+        {
+            throw new System.NotImplementedException();
+        }
+#endif
+
+        /** Get parent of this grammar */
+        public virtual Grammar getDelegator( Grammar g )
+        {
+            CompositeGrammarTree me = delegateGrammarTreeRoot.findNode( g );
+            if ( me == null )
+            {
+                return null; // not found
+            }
+            if ( me.parent != null )
+            {
+                return me.parent.grammar;
+            }
+            return null;
+        }
+
+        /** Get list of all delegates from all grammars in the delegate subtree of g.
+         *  The grammars are in delegation tree preorder.  Don't include g itself
+         *  in list as it is not a delegate of itself.
+         */
+        public virtual IList<Grammar> getDelegates( Grammar g )
+        {
+            CompositeGrammarTree t = delegateGrammarTreeRoot.findNode( g );
+            if ( t == null )
+            {
+                return null; // no delegates
+            }
+            IList<Grammar> grammars = t.getPostOrderedGrammarList();
+            grammars.RemoveAt( grammars.Count - 1 ); // remove g (last one)
+            return grammars;
+        }
+
+        public virtual IList<Grammar> getDirectDelegates( Grammar g )
+        {
+            CompositeGrammarTree t = delegateGrammarTreeRoot.findNode( g );
+            IList<CompositeGrammarTree> children = t.children;
+            if ( children == null )
+            {
+                return null;
+            }
+            IList<Grammar> grammars = new List<Grammar>();
+            for ( int i = 0; children != null && i < children.Count; i++ )
+            {
+                CompositeGrammarTree child = (CompositeGrammarTree)children[i];
+                grammars.Add( child.grammar );
+            }
+            return grammars;
+        }
+
+        /** Get delegates below direct delegates of g */
+        public virtual IList<Grammar> getIndirectDelegates( Grammar g )
+        {
+            //IList<Grammar> direct = getDirectDelegates( g );
+            //IList<Grammar> delegates = getDelegates( g );
+            //delegates.removeAll( direct );
+            //return delegates;
+            return getDelegates( g )
+                .Except( getDirectDelegates( g ) ?? Enumerable.Empty<Grammar>() )
+                .ToArray();
+        }
+
+        /** Return list of delegate grammars from root down to g.
+         *  Order is root, ..., g.parent.  (g not included).
+         */
+        public virtual IList<Grammar> getDelegators( Grammar g )
+        {
+            if ( g == delegateGrammarTreeRoot.grammar )
+            {
+                return null;
+            }
+            List<Grammar> grammars = new List<Grammar>();
+            CompositeGrammarTree t = delegateGrammarTreeRoot.findNode( g );
+            // walk backwards to root, collecting grammars
+            CompositeGrammarTree p = t.parent;
+            while ( p != null )
+            {
+                grammars.Insert( 0, p.grammar ); // add to head so in order later
+                p = p.parent;
+            }
+            return grammars;
+        }
+
+        /** Get set of rules for grammar g that need to have manual delegation
+         *  methods.  This is the list of rules collected from all direct/indirect
+         *  delegates minus rules overridden in grammar g.
+         *
+         *  This returns null except for the delegate root because it is the only
+         *  one that has to have a complete grammar rule interface.  The delegates
+         *  should not be instantiated directly for use as parsers (you can create
+         *  them to pass to the root parser's ctor as arguments).
+         */
+        public virtual HashSet<Rule> getDelegatedRules( Grammar g )
+        {
+            if ( g != delegateGrammarTreeRoot.grammar )
+            {
+                return null;
+            }
+            HashSet<Rule> rules = getAllImportedRules( g );
+            //for ( Iterator it = rules.iterator(); it.hasNext(); )
+            //{
+            //    Rule r = (Rule)it.next();
+            //    Rule localRule = g.getLocallyDefinedRule( r.name );
+            //    // if locally defined or it's not local but synpred, don't make
+            //    // a delegation method
+            //    if ( localRule != null || r.isSynPred )
+            //    {
+            //        it.remove(); // kill overridden rules
+            //    }
+            //}
+            foreach ( Rule r in rules.ToArray() )
+            {
+                Rule localRule = g.getLocallyDefinedRule( r.name );
+                // if locally defined or it's not local but synpred, don't make a delegation method
+                if ( localRule != null || r.isSynPred )
+                {
+                    // kill overridden rules
+                    rules.Remove( r );
+                }
+            }
+            return rules;
+        }
+
+        /** Get all rule definitions from all direct/indirect delegate grammars
+         *  of g.
+         */
+        public virtual HashSet<Rule> getAllImportedRules( Grammar g )
+        {
+            HashSet<string> ruleNames = new HashSet<string>();
+            HashSet<Rule> rules = new HashSet<Rule>();
+            CompositeGrammarTree subtreeRoot = delegateGrammarTreeRoot.findNode( g );
+            IList<Grammar> grammars = subtreeRoot.getPostOrderedGrammarList();
+            // walk all grammars
+            foreach ( Grammar grammar in grammars )
+            {
+                // for each rule in grammar, add to rules if no rule with that
+                // name as been seen.  (can't use removeAll; wrong hashcode/equals on Rule)
+                foreach ( Rule r in grammar.Rules )
+                {
+                    if ( !ruleNames.Contains( r.name ) )
+                    {
+                        ruleNames.Add( r.name ); // track that we've seen this
+                        rules.Add( r );
+                    }
+                }
+            }
+            return rules;
+        }
+
+        public virtual Grammar getRootGrammar()
+        {
+            if ( delegateGrammarTreeRoot == null )
+            {
+                return null;
+            }
+            return delegateGrammarTreeRoot.grammar;
+        }
+
+        public virtual Grammar getGrammar( string grammarName )
+        {
+            CompositeGrammarTree t = delegateGrammarTreeRoot.findNode( grammarName );
+            if ( t != null )
+            {
+                return t.grammar;
+            }
+            return null;
+        }
+
+        // NFA spans multiple grammars, must handle here
+
+        public virtual int getNewNFAStateNumber()
+        {
+            return stateCounter++;
+        }
+
+        public virtual void addState( NFAState state )
+        {
+            numberToStateList.setSize( state.stateNumber + 1 ); // make sure we have room
+            numberToStateList[state.stateNumber] = state;
+        }
+
+        public virtual NFAState getState( int s )
+        {
+            return (NFAState)numberToStateList[s];
+        }
+
+        public virtual void assignTokenTypes()
+        {
+            // ASSIGN TOKEN TYPES for all delegates (same walker)
+            //System.out.println("### assign types");
+            //ttypesWalker.setASTNodeClass( "org.antlr.tool.GrammarAST" );
+            IList<Grammar> grammars = delegateGrammarTreeRoot.getPostOrderedGrammarList();
+            for ( int i = 0; grammars != null && i < grammars.Count; i++ )
+            {
+                Grammar g = (Grammar)grammars[i];
+                AssignTokenTypesWalker ttypesWalker = new AssignTokenTypesBehavior( new Antlr.Runtime.Tree.CommonTreeNodeStream( g.Tree ) );
+                try
+                {
+                    //System.out.println("    walking "+g.name);
+                    ttypesWalker.grammar_( g );
+
+                    // the walker has filled literals, tokens, and alias tables.
+                    // now tell it to define them in the root grammar
+                    ttypesWalker.defineTokens( delegateGrammarTreeRoot.grammar );
+                }
+                catch ( RecognitionException re )
+                {
+                    ErrorManager.error( ErrorManager.MSG_BAD_AST_STRUCTURE,
+                                       re );
+                }
+            }
+        }
+
+        public virtual void defineGrammarSymbols()
+        {
+            delegateGrammarTreeRoot.trimLexerImportsIntoCombined();
+            IList<Grammar> grammars = delegateGrammarTreeRoot.getPostOrderedGrammarList();
+            for ( int i = 0; grammars != null && i < grammars.Count; i++ )
+            {
+                Grammar g = (Grammar)grammars[i];
+                g.defineGrammarSymbols();
+            }
+            for ( int i = 0; grammars != null && i < grammars.Count; i++ )
+            {
+                Grammar g = (Grammar)grammars[i];
+                g.checkNameSpaceAndActions();
+            }
+            minimizeRuleSet();
+        }
+
+        public virtual void createNFAs()
+        {
+            if ( ErrorManager.doNotAttemptAnalysis() )
+            {
+                return;
+            }
+            IList<Grammar> grammars = delegateGrammarTreeRoot.getPostOrderedGrammarList();
+            IList<string> names = new List<string>();
+            for ( int i = 0; i < grammars.Count; i++ )
+            {
+                Grammar g = (Grammar)grammars[i];
+                names.Add( g.name );
+            }
+            //System.out.println("### createNFAs for composite; grammars: "+names);
+            for ( int i = 0; grammars != null && i < grammars.Count; i++ )
+            {
+                Grammar g = (Grammar)grammars[i];
+                g.createRuleStartAndStopNFAStates();
+            }
+            for ( int i = 0; grammars != null && i < grammars.Count; i++ )
+            {
+                Grammar g = (Grammar)grammars[i];
+                g.buildNFA();
+            }
+        }
+
+        public virtual void minimizeRuleSet()
+        {
+            HashSet<string> ruleDefs = new HashSet<string>();
+            _minimizeRuleSet( ruleDefs, delegateGrammarTreeRoot );
+        }
+
+        public virtual void _minimizeRuleSet( HashSet<string> ruleDefs,
+                                     CompositeGrammarTree p )
+        {
+            HashSet<string> localRuleDefs = new HashSet<string>();
+            HashSet<string> overrides = new HashSet<string>();
+            // compute set of non-overridden rules for this delegate
+            foreach ( Rule r in p.grammar.Rules )
+            {
+                if ( !ruleDefs.Contains( r.name ) )
+                {
+                    localRuleDefs.Add( r.name );
+                }
+                else if ( !r.name.Equals( Grammar.ARTIFICIAL_TOKENS_RULENAME ) )
+                {
+                    // record any overridden rule 'cept tokens rule
+                    overrides.Add( r.name );
+                }
+            }
+            //System.out.println("rule defs for "+p.grammar.name+": "+localRuleDefs);
+            //System.out.println("overridden rule for "+p.grammar.name+": "+overrides);
+            p.grammar.overriddenRules = overrides;
+
+            // make set of all rules defined thus far walking delegation tree.
+            // the same rule in two delegates resolves in favor of first found
+            // in tree therefore second must not be included
+            ruleDefs.addAll( localRuleDefs );
+
+            // pass larger set of defined rules to delegates
+            if ( p.children != null )
+            {
+                foreach ( CompositeGrammarTree @delegate in p.children )
+                {
+                    _minimizeRuleSet( ruleDefs, @delegate );
+                }
+            }
+        }
+
+        /*
+        public void minimizeRuleSet() {
+            Set<Rule> refs = _minimizeRuleSet(delegateGrammarTreeRoot);
+            System.out.println("all rule refs: "+refs);
+        }
+
+        public Set<Rule> _minimizeRuleSet(CompositeGrammarTree p) {
+            Set<Rule> refs = new HashSet<Rule>();
+            for (GrammarAST refAST : p.grammar.ruleRefs) {
+                System.out.println("ref "+refAST.getText()+": "+refAST.NFAStartState+
+                                   " enclosing rule: "+refAST.NFAStartState.enclosingRule+
+                                   " invoking rule: "+((NFAState)refAST.NFAStartState.transition[0].target).enclosingRule);
+                refs.add(((NFAState)refAST.NFAStartState.transition[0].target).enclosingRule);
+            }
+
+            if ( p.children!=null ) {
+                for (CompositeGrammarTree delegate : p.children) {
+                    Set<Rule> delegateRuleRefs = _minimizeRuleSet(delegate);
+                    refs.addAll(delegateRuleRefs);
+                }
+            }
+
+            return refs;
+        }
+        */
+
+        /*
+        public void oldminimizeRuleSet() {
+            // first walk to remove all overridden rules
+            Set<String> ruleDefs = new HashSet<String>();
+            Set<String> ruleRefs = new HashSet<String>();
+            for (GrammarAST refAST : delegateGrammarTreeRoot.grammar.ruleRefs) {
+                String rname = refAST.getText();
+                ruleRefs.add(rname);
+            }
+            _minimizeRuleSet(ruleDefs,
+                             ruleRefs,
+                             delegateGrammarTreeRoot);
+            System.out.println("overall rule defs: "+ruleDefs);
+        }
+
+        public void _minimizeRuleSet(Set<String> ruleDefs,
+                                     Set<String> ruleRefs,
+                                     CompositeGrammarTree p) {
+            Set<String> localRuleDefs = new HashSet<String>();
+            for (Rule r : p.grammar.getRules()) {
+                if ( !ruleDefs.contains(r.name) ) {
+                    localRuleDefs.add(r.name);
+                    ruleDefs.add(r.name);
+                }
+            }
+            System.out.println("rule defs for "+p.grammar.name+": "+localRuleDefs);
+
+            // remove locally-defined rules not in ref set
+            // find intersection of local rules and references from delegator
+            // that is set of rules needed by delegator
+            Set<String> localRuleDefsSatisfyingRefsFromBelow = new HashSet<String>();
+            for (String r : ruleRefs) {
+                if ( localRuleDefs.contains(r) ) {
+                    localRuleDefsSatisfyingRefsFromBelow.add(r);
+                }
+            }
+
+            // now get list of refs from localRuleDefsSatisfyingRefsFromBelow.
+            // Those rules are also allowed in this delegate
+            for (GrammarAST refAST : p.grammar.ruleRefs) {
+                if ( localRuleDefsSatisfyingRefsFromBelow.contains(refAST.enclosingRuleName) ) {
+                    // found rule ref within needed rule
+                }
+            }
+
+            // remove rule refs not in the new rule def set
+
+            // walk all children, adding rules not already defined
+            if ( p.children!=null ) {
+                for (CompositeGrammarTree delegate : p.children) {
+                    _minimizeRuleSet(ruleDefs, ruleRefs, delegate);
+                }
+            }
+        }
+        */
+
+        /*
+        public void trackNFAStatesThatHaveLabeledEdge(Label label,
+                                                      NFAState stateWithLabeledEdge)
+        {
+            Set<NFAState> states = typeToNFAStatesWithEdgeOfTypeMap.get(label);
+            if ( states==null ) {
+                states = new HashSet<NFAState>();
+                typeToNFAStatesWithEdgeOfTypeMap.put(label, states);
+            }
+            states.add(stateWithLabeledEdge);
+        }
+
+        public Map<Label, Set<NFAState>> getTypeToNFAStatesWithEdgeOfTypeMap() {
+            return typeToNFAStatesWithEdgeOfTypeMap;
+        }
+
+        public Set<NFAState> getStatesWithEdge(Label label) {
+            return typeToNFAStatesWithEdgeOfTypeMap.get(label);
+        }
+    */
+    }
+}
diff --git a/Antlr3/Tool/CompositeGrammarTree.cs b/Antlr3/Tool/CompositeGrammarTree.cs
new file mode 100644
index 0000000..d37c2df
--- /dev/null
+++ b/Antlr3/Tool/CompositeGrammarTree.cs
@@ -0,0 +1,186 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using System.Collections.Generic;
+
+    /** A tree of grammars */
+    public class CompositeGrammarTree
+    {
+        protected internal IList<CompositeGrammarTree> children;
+        public Grammar grammar;
+
+        /** Who is the parent node of this node; if null, implies node is root */
+        public CompositeGrammarTree parent;
+
+        public CompositeGrammarTree( Grammar g )
+        {
+            grammar = g;
+        }
+
+        public virtual void addChild( CompositeGrammarTree t )
+        {
+            //System.out.println("add "+t.toStringTree()+" as child to "+this.toStringTree());
+            if ( t == null )
+            {
+                return; // do nothing upon addChild(null)
+            }
+            if ( children == null )
+            {
+                children = new List<CompositeGrammarTree>();
+            }
+            children.Add( t );
+            t.parent = this;
+        }
+
+        /** Find a rule by looking in current grammar then down towards the
+         *  delegate grammars.
+         */
+        public virtual Rule getRule( string ruleName )
+        {
+            Rule r = grammar.getLocallyDefinedRule( ruleName );
+            for ( int i = 0; r == null && children != null && i < children.Count; i++ )
+            {
+                CompositeGrammarTree child = children[i];
+                r = child.getRule( ruleName );
+            }
+            return r;
+        }
+
+        /** Find an option by looking up towards the root grammar rather than down */
+        public virtual object getOption( string key )
+        {
+            object o = grammar.getLocallyDefinedOption( key );
+            if ( o != null )
+            {
+                return o;
+            }
+            if ( parent != null )
+            {
+                return parent.getOption( key );
+            }
+            return null; // not found
+        }
+
+        public virtual CompositeGrammarTree findNode( Grammar g )
+        {
+            if ( g == null )
+            {
+                return null;
+            }
+            if ( this.grammar == g )
+            {
+                return this;
+            }
+            CompositeGrammarTree n = null;
+            for ( int i = 0; n == null && children != null && i < children.Count; i++ )
+            {
+                CompositeGrammarTree child = children[i];
+                n = child.findNode( g );
+            }
+            return n;
+        }
+
+        public virtual CompositeGrammarTree findNode( string grammarName )
+        {
+            if ( grammarName == null )
+            {
+                return null;
+            }
+            if ( grammarName.Equals( this.grammar.name ) )
+            {
+                return this;
+            }
+            CompositeGrammarTree n = null;
+            for ( int i = 0; n == null && children != null && i < children.Count; i++ )
+            {
+                CompositeGrammarTree child = children[i];
+                n = child.findNode( grammarName );
+            }
+            return n;
+        }
+
+        /** Return a postorder list of grammars; root is last in list */
+        public virtual IList<Grammar> getPostOrderedGrammarList()
+        {
+            IList<Grammar> grammars = new List<Grammar>();
+            _getPostOrderedGrammarList( grammars );
+            return grammars;
+        }
+
+        /** work for getPostOrderedGrammarList */
+        protected virtual void _getPostOrderedGrammarList( IList<Grammar> grammars )
+        {
+            for ( int i = 0; children != null && i < children.Count; i++ )
+            {
+                CompositeGrammarTree child = children[i];
+                child._getPostOrderedGrammarList( grammars );
+            }
+            grammars.Add( this.grammar );
+        }
+
+        /** Return a postorder list of grammars; root is last in list */
+        public virtual IList<Grammar> getPreOrderedGrammarList()
+        {
+            IList<Grammar> grammars = new List<Grammar>();
+            _getPreOrderedGrammarList( grammars );
+            return grammars;
+        }
+
+        protected virtual void _getPreOrderedGrammarList( IList<Grammar> grammars )
+        {
+            grammars.Add( this.grammar );
+            for ( int i = 0; children != null && i < children.Count; i++ )
+            {
+                CompositeGrammarTree child = children[i];
+                child._getPostOrderedGrammarList( grammars );
+            }
+        }
+
+        public virtual void trimLexerImportsIntoCombined()
+        {
+            CompositeGrammarTree p = this;
+            if ( p.grammar.type == Grammar.LEXER && p.parent != null &&
+                 p.parent.grammar.type == Grammar.COMBINED )
+            {
+                //System.out.println("wacking "+p.grammar.name+" from "+p.parent.grammar.name);
+                p.parent.children.Remove( this );
+            }
+            for ( int i = 0; children != null && i < children.Count; i++ )
+            {
+                CompositeGrammarTree child = children[i];
+                child.trimLexerImportsIntoCombined();
+            }
+        }
+    }
+}
diff --git a/Antlr3/Tool/DOTGenerator.cs b/Antlr3/Tool/DOTGenerator.cs
new file mode 100644
index 0000000..ef2c253
--- /dev/null
+++ b/Antlr3/Tool/DOTGenerator.cs
@@ -0,0 +1,488 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using System;
+    using System.Collections.Generic;
+    using System.Linq;
+    using Antlr.Runtime.JavaExtensions;
+    using Antlr3.Analysis;
+
+    using AngleBracketTemplateLexer = Antlr3.ST.Language.AngleBracketTemplateLexer;
+    using ANTLRParser = Antlr3.Grammars.ANTLRParser;
+    using IList = System.Collections.IList;
+    using StringBuffer = System.Text.StringBuilder;
+    using StringTemplate = Antlr3.ST.StringTemplate;
+    using StringTemplateGroup = Antlr3.ST.StringTemplateGroup;
+    using Tool = Antlr3.AntlrTool;
+
+    /** The DOT (part of graphviz) generation aspect. */
+    public class DOTGenerator
+    {
+        internal bool STRIP_NONREDUCED_STATES = false;
+
+        protected String arrowhead = "normal";
+        protected String rankdir = "LR";
+
+        /** Library of output templates; use <attrname> format */
+        public static StringTemplateGroup stlib =
+                new StringTemplateGroup( "toollib", typeof( AngleBracketTemplateLexer ) );
+
+        /** To prevent infinite recursion when walking state machines, record
+         *  which states we've visited.  Make a new set every time you start
+         *  walking in case you reuse this object.
+         */
+        protected ICollection<object> markedStates = null;
+
+        protected Grammar grammar;
+
+        /** This aspect is associated with a grammar */
+        public DOTGenerator( Grammar grammar )
+        {
+            this.grammar = grammar;
+        }
+
+        #region Properties
+        public string ArrowheadType
+        {
+            get
+            {
+                return getArrowheadType();
+            }
+        }
+        public string RankDir
+        {
+            get
+            {
+                return getRankdir();
+            }
+        }
+        #endregion
+
+        /** Return a String containing a DOT description that, when displayed,
+         *  will show the incoming state machine visually.  All nodes reachable
+         *  from startState will be included.
+         */
+        public virtual String getDOT( State startState )
+        {
+            if ( startState == null )
+            {
+                return null;
+            }
+            // The output DOT graph for visualization
+            StringTemplate dot = null;
+            markedStates = new HashSet<object>();
+            if ( startState is DFAState )
+            {
+                dot = stlib.getInstanceOf( "org/antlr/tool/templates/dot/dfa" );
+                dot.setAttribute( "startState",
+                        startState.stateNumber );
+                dot.setAttribute( "useBox",
+                                 Tool.internalOption_ShowNFAConfigsInDFA );
+                walkCreatingDFADOT( dot, (DFAState)startState );
+            }
+            else
+            {
+                dot = stlib.getInstanceOf( "org/antlr/tool/templates/dot/nfa" );
+                dot.setAttribute( "startState",
+                        startState.stateNumber );
+                walkRuleNFACreatingDOT( dot, startState );
+            }
+            dot.setAttribute( "rankdir", rankdir );
+            return dot.ToString();
+        }
+
+        /** Return a String containing a DOT description that, when displayed,
+         *  will show the incoming state machine visually.  All nodes reachable
+         *  from startState will be included.
+        public String getRuleNFADOT(State startState) {
+            // The output DOT graph for visualization
+            StringTemplate dot = stlib.getInstanceOf("org/antlr/tool/templates/dot/nfa");
+
+            markedStates = new HashSet();
+            dot.setAttribute("startState",
+                    Utils.integer(startState.stateNumber));
+            walkRuleNFACreatingDOT(dot, startState);
+            return dot.toString();
+        }
+         */
+
+        /** Do a depth-first walk of the state machine graph and
+         *  fill a DOT description template.  Keep filling the
+         *  states and edges attributes.
+         */
+        protected virtual void walkCreatingDFADOT( StringTemplate dot,
+                                          DFAState s )
+        {
+            if ( markedStates.Contains( s.stateNumber ) )
+            {
+                return; // already visited this node
+            }
+
+            markedStates.Add( s.stateNumber ); // mark this node as completed.
+
+            // first add this node
+            StringTemplate st;
+            if ( s.IsAcceptState )
+            {
+                st = stlib.getInstanceOf( "org/antlr/tool/templates/dot/stopstate" );
+            }
+            else
+            {
+                st = stlib.getInstanceOf( "org/antlr/tool/templates/dot/state" );
+            }
+            st.setAttribute( "name", getStateLabel( s ) );
+            dot.setAttribute( "states", st );
+
+            // make a DOT edge for each transition
+            for ( int i = 0; i < s.NumberOfTransitions; i++ )
+            {
+                Transition edge = (Transition)s.transition( i );
+                /*
+                System.out.println("dfa "+s.dfa.decisionNumber+
+                    " edge from s"+s.stateNumber+" ["+i+"] of "+s.getNumberOfTransitions());
+                */
+                if ( STRIP_NONREDUCED_STATES )
+                {
+                    if ( edge.target is DFAState &&
+                        ( (DFAState)edge.target ).AcceptStateReachable != DFA.REACHABLE_YES )
+                    {
+                        continue; // don't generate nodes for terminal states
+                    }
+                }
+                st = stlib.getInstanceOf( "org/antlr/tool/templates/dot/edge" );
+                st.setAttribute( "label", getEdgeLabel( edge ) );
+                st.setAttribute( "src", getStateLabel( s ) );
+                st.setAttribute( "target", getStateLabel( edge.target ) );
+                st.setAttribute( "arrowhead", arrowhead );
+                dot.setAttribute( "edges", st );
+                walkCreatingDFADOT( dot, (DFAState)edge.target ); // keep walkin'
+            }
+        }
+
+        /** Do a depth-first walk of the state machine graph and
+         *  fill a DOT description template.  Keep filling the
+         *  states and edges attributes.  We know this is an NFA
+         *  for a rule so don't traverse edges to other rules and
+         *  don't go past rule end state.
+         */
+        protected virtual void walkRuleNFACreatingDOT( StringTemplate dot,
+                                              State s )
+        {
+            if ( markedStates.Contains( s ) )
+            {
+                return; // already visited this node
+            }
+
+            markedStates.Add( s ); // mark this node as completed.
+
+            // first add this node
+            StringTemplate stateST;
+            if ( s.IsAcceptState )
+            {
+                stateST = stlib.getInstanceOf( "org/antlr/tool/templates/dot/stopstate" );
+            }
+            else
+            {
+                stateST = stlib.getInstanceOf( "org/antlr/tool/templates/dot/state" );
+            }
+            stateST.setAttribute( "name", getStateLabel( s ) );
+            dot.setAttribute( "states", stateST );
+
+            if ( s.IsAcceptState )
+            {
+                return; // don't go past end of rule node to the follow states
+            }
+
+            // special case: if decision point, then line up the alt start states
+            // unless it's an end of block
+            if ( ( (NFAState)s ).IsDecisionState )
+            {
+                GrammarAST n = ( (NFAState)s ).associatedASTNode;
+                if ( n != null && n.Type != ANTLRParser.EOB )
+                {
+                    StringTemplate rankST = stlib.getInstanceOf( "org/antlr/tool/templates/dot/decision-rank" );
+                    NFAState alt = (NFAState)s;
+                    while ( alt != null )
+                    {
+                        rankST.setAttribute( "states", getStateLabel( alt ) );
+                        if ( alt.transition[1] != null )
+                        {
+                            alt = (NFAState)alt.transition[1].target;
+                        }
+                        else
+                        {
+                            alt = null;
+                        }
+                    }
+                    dot.setAttribute( "decisionRanks", rankST );
+                }
+            }
+
+            // make a DOT edge for each transition
+            StringTemplate edgeST = null;
+            for ( int i = 0; i < s.NumberOfTransitions; i++ )
+            {
+                Transition edge = (Transition)s.getTransition( i );
+                if ( edge is RuleClosureTransition )
+                {
+                    RuleClosureTransition rr = ( (RuleClosureTransition)edge );
+                    // don't jump to other rules, but display edge to follow node
+                    edgeST = stlib.getInstanceOf( "org/antlr/tool/templates/dot/edge" );
+                    if ( rr.rule.grammar != grammar )
+                    {
+                        edgeST.setAttribute( "label", "<" + rr.rule.grammar.name + "." + rr.rule.name + ">" );
+                    }
+                    else
+                    {
+                        edgeST.setAttribute( "label", "<" + rr.rule.name + ">" );
+                    }
+                    edgeST.setAttribute( "src", getStateLabel( s ) );
+                    edgeST.setAttribute( "target", getStateLabel( rr.followState ) );
+                    edgeST.setAttribute( "arrowhead", arrowhead );
+                    dot.setAttribute( "edges", edgeST );
+                    walkRuleNFACreatingDOT( dot, rr.followState );
+                    continue;
+                }
+                if ( edge.IsAction )
+                {
+                    edgeST = stlib.getInstanceOf( "org/antlr/tool/templates/dot/action-edge" );
+                }
+                else if ( edge.IsEpsilon )
+                {
+                    edgeST = stlib.getInstanceOf( "org/antlr/tool/templates/dot/epsilon-edge" );
+                }
+                else
+                {
+                    edgeST = stlib.getInstanceOf( "org/antlr/tool/templates/dot/edge" );
+                }
+                edgeST.setAttribute( "label", getEdgeLabel( edge ) );
+                edgeST.setAttribute( "src", getStateLabel( s ) );
+                edgeST.setAttribute( "target", getStateLabel( edge.target ) );
+                edgeST.setAttribute( "arrowhead", arrowhead );
+                dot.setAttribute( "edges", edgeST );
+                walkRuleNFACreatingDOT( dot, edge.target ); // keep walkin'
+            }
+        }
+
+#if false
+        public void writeDOTFilesForAllRuleNFAs()
+        {
+            var rules = grammar.Rules;
+            foreach ( var r in rules )
+            {
+                String ruleName = r.name;
+                writeDOTFile(
+                        ruleName,
+                        getRuleNFADOT(grammar.getRuleStartState(ruleName)));
+            }
+        }
+#endif
+
+#if false
+        public void writeDOTFilesForAllDecisionDFAs()
+        {
+            // for debugging, create a DOT file for each decision in
+            // a directory named for the grammar.
+            File grammarDir = new File( grammar.name + "_DFAs" );
+            grammarDir.mkdirs();
+            IList decisionList = grammar.getDecisionNFAStartStateList();
+            if ( decisionList == null )
+            {
+                return;
+            }
+            int i = 1;
+            Iterator iter = decisionList.iterator();
+            foreach ( NFAState decisionState in decisionList )
+            {
+                DFA dfa = decisionState.getDecisionASTNode().getLookaheadDFA();
+                if ( dfa != null )
+                {
+                    String dot = getDOT( dfa.startState );
+                    writeDOTFile( grammarDir + "/dec-" + i, dot );
+                }
+                i++;
+            }
+        }
+#endif
+
+        /** Fix edge strings so they print out in DOT properly;
+         *  generate any gated predicates on edge too.
+         */
+        protected virtual String getEdgeLabel( Transition edge )
+        {
+            String label = edge.label.ToString( grammar );
+            label = label.Replace( "\\", "\\\\" );
+            label = label.Replace( "\"", "\\\"" );
+            label = label.Replace( "\n", "\\\\n" );
+            label = label.Replace( "\r", "" );
+            if ( label.Equals( Label.EPSILON_STR ) )
+            {
+                label = "e";
+            }
+            State target = edge.target;
+            if ( !edge.IsSemanticPredicate && target is DFAState )
+            {
+                // look for gated predicates; don't add gated to simple sempred edges
+                SemanticContext preds =
+                    ( (DFAState)target ).getGatedPredicatesInNFAConfigurations();
+                if ( preds != null )
+                {
+                    String predsStr = "";
+                    predsStr = "&&{" +
+                        preds.genExpr( grammar.generator,
+                                      grammar.generator.Templates, null ).ToString()
+                        + "}?";
+                    label += predsStr;
+                }
+            }
+            return label;
+        }
+
+        protected virtual String getStateLabel( State s )
+        {
+            if ( s == null )
+            {
+                return "null";
+            }
+            String stateLabel = s.stateNumber.ToString();
+            if ( s is DFAState )
+            {
+                StringBuffer buf = new StringBuffer( 250 );
+                buf.Append( 's' );
+                buf.Append( s.stateNumber );
+                if ( Tool.internalOption_ShowNFAConfigsInDFA )
+                {
+                    if ( s is DFAState )
+                    {
+                        if ( ( (DFAState)s ).abortedDueToRecursionOverflow )
+                        {
+                            buf.Append( "\\n" );
+                            buf.Append( "abortedDueToRecursionOverflow" );
+                        }
+                    }
+                    var alts = ( (DFAState)s ).AltSet;
+                    if ( alts != null )
+                    {
+                        buf.Append( "\\n" );
+                        // separate alts
+                        //List altList = new ArrayList();
+                        //altList.addAll( alts );
+                        //Collections.sort( altList );
+                        List<int> altList = alts.OrderBy( i => i ).ToList();
+                        ICollection<NFAConfiguration> configurations = ( (DFAState)s ).nfaConfigurations;
+                        for ( int altIndex = 0; altIndex < altList.Count; altIndex++ )
+                        {
+                            object altI = altList[altIndex];
+                            int alt = (int)altI;
+                            if ( altIndex > 0 )
+                            {
+                                buf.Append( "\\n" );
+                            }
+                            buf.Append( "alt" );
+                            buf.Append( alt );
+                            buf.Append( ':' );
+                            // get a list of configs for just this alt
+                            // it will help us print better later
+                            IList configsInAlt = new List<object>();
+                            foreach ( NFAConfiguration c in configurations )
+                            {
+                                if ( c.alt != alt )
+                                    continue;
+                                configsInAlt.Add( c );
+                            }
+                            int n = 0;
+                            for ( int cIndex = 0; cIndex < configsInAlt.Count; cIndex++ )
+                            {
+                                NFAConfiguration c =
+                                    (NFAConfiguration)configsInAlt[cIndex];
+                                n++;
+                                buf.Append( c.ToString( false ) );
+                                if ( ( cIndex + 1 ) < configsInAlt.Count )
+                                {
+                                    buf.Append( ", " );
+                                }
+                                if ( n % 5 == 0 && ( configsInAlt.Count - cIndex ) > 3 )
+                                {
+                                    buf.Append( "\\n" );
+                                }
+                            }
+                        }
+                    }
+                }
+                stateLabel = buf.ToString();
+            }
+            if ( ( s is NFAState ) && ( (NFAState)s ).IsDecisionState )
+            {
+                stateLabel = stateLabel + ",d=" +
+                        ( (NFAState)s ).DecisionNumber;
+                if ( ( (NFAState)s ).endOfBlockStateNumber != State.INVALID_STATE_NUMBER )
+                {
+                    stateLabel += ",eob=" + ( (NFAState)s ).endOfBlockStateNumber;
+                }
+            }
+            else if ( ( s is NFAState ) &&
+                ( (NFAState)s ).endOfBlockStateNumber != State.INVALID_STATE_NUMBER )
+            {
+                NFAState n = ( (NFAState)s );
+                stateLabel = stateLabel + ",eob=" + n.endOfBlockStateNumber;
+            }
+            else if ( s is DFAState && ( (DFAState)s ).IsAcceptState )
+            {
+                stateLabel = stateLabel +
+                        "=>" + ( (DFAState)s ).getUniquelyPredictedAlt();
+            }
+            return '"' + stateLabel + '"';
+        }
+
+        public virtual String getArrowheadType()
+        {
+            return arrowhead;
+        }
+
+        public virtual void setArrowheadType( String arrowhead )
+        {
+            this.arrowhead = arrowhead;
+        }
+
+        public virtual String getRankdir()
+        {
+            return rankdir;
+        }
+
+        public virtual void setRankdir( String rankdir )
+        {
+            this.rankdir = rankdir;
+        }
+    }
+}
diff --git a/Antlr3/Tool/ErrorManager.cs b/Antlr3/Tool/ErrorManager.cs
new file mode 100644
index 0000000..afe59d1
--- /dev/null
+++ b/Antlr3/Tool/ErrorManager.cs
@@ -0,0 +1,1141 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using System;
+    using System.Collections.Generic;
+    using Antlr.Runtime.JavaExtensions;
+    using Antlr3.Misc;
+
+    using AngleBracketTemplateLexer = Antlr3.ST.Language.AngleBracketTemplateLexer;
+    using CultureInfo = System.Globalization.CultureInfo;
+    using DecisionProbe = Antlr3.Analysis.DecisionProbe;
+    using DFAState = Antlr3.Analysis.DFAState;
+    using FieldAccessException = System.FieldAccessException;
+    using FieldInfo = System.Reflection.FieldInfo;
+    using ICollection = System.Collections.ICollection;
+    using IOException = System.IO.IOException;
+    using IStringTemplateErrorListener = Antlr3.ST.IStringTemplateErrorListener;
+    using IToken = Antlr.Runtime.IToken;
+    using NFAState = Antlr3.Analysis.NFAState;
+    using RecognitionException = Antlr.Runtime.RecognitionException;
+    using StackFrame = System.Diagnostics.StackFrame;
+    using StreamReader = System.IO.StreamReader;
+    using StringTemplate = Antlr3.ST.StringTemplate;
+    using StringTemplateGroup = Antlr3.ST.StringTemplateGroup;
+    using TargetInvocationException = System.Reflection.TargetInvocationException;
+    using Thread = System.Threading.Thread;
+    using Tool = Antlr3.AntlrTool;
+
+    public static class ErrorManager
+    {
+        // TOOL ERRORS
+        // file errors
+        public const int MSG_CANNOT_WRITE_FILE = 1;
+        public const int MSG_CANNOT_CLOSE_FILE = 2;
+        public const int MSG_CANNOT_FIND_TOKENS_FILE = 3;
+        public const int MSG_ERROR_READING_TOKENS_FILE = 4;
+        public const int MSG_DIR_NOT_FOUND = 5;
+        public const int MSG_OUTPUT_DIR_IS_FILE = 6;
+        public const int MSG_CANNOT_OPEN_FILE = 7;
+        public const int MSG_FILE_AND_GRAMMAR_NAME_DIFFER = 8;
+        public const int MSG_FILENAME_EXTENSION_ERROR = 9;
+
+        public const int MSG_INTERNAL_ERROR = 10;
+        public const int MSG_INTERNAL_WARNING = 11;
+        public const int MSG_ERROR_CREATING_ARTIFICIAL_RULE = 12;
+        public const int MSG_TOKENS_FILE_SYNTAX_ERROR = 13;
+        public const int MSG_CANNOT_GEN_DOT_FILE = 14;
+        public const int MSG_BAD_AST_STRUCTURE = 15;
+        public const int MSG_BAD_ACTION_AST_STRUCTURE = 16;
+
+        // code gen errors
+        public const int MSG_MISSING_CODE_GEN_TEMPLATES = 20;
+        public const int MSG_MISSING_CYCLIC_DFA_CODE_GEN_TEMPLATES = 21;
+        public const int MSG_CODE_GEN_TEMPLATES_INCOMPLETE = 22;
+        public const int MSG_CANNOT_CREATE_TARGET_GENERATOR = 23;
+        //public const int MSG_CANNOT_COMPUTE_SAMPLE_INPUT_SEQ = 24;
+
+        // GRAMMAR ERRORS
+        public const int MSG_SYNTAX_ERROR = 100;
+        public const int MSG_RULE_REDEFINITION = 101;
+        public const int MSG_LEXER_RULES_NOT_ALLOWED = 102;
+        public const int MSG_PARSER_RULES_NOT_ALLOWED = 103;
+        public const int MSG_CANNOT_FIND_ATTRIBUTE_NAME_IN_DECL = 104;
+        public const int MSG_NO_TOKEN_DEFINITION = 105;
+        public const int MSG_UNDEFINED_RULE_REF = 106;
+        public const int MSG_LITERAL_NOT_ASSOCIATED_WITH_LEXER_RULE = 107;
+        public const int MSG_CANNOT_ALIAS_TOKENS_IN_LEXER = 108;
+        public const int MSG_ATTRIBUTE_REF_NOT_IN_RULE = 111;
+        public const int MSG_INVALID_RULE_SCOPE_ATTRIBUTE_REF = 112;
+        public const int MSG_UNKNOWN_ATTRIBUTE_IN_SCOPE = 113;
+        public const int MSG_UNKNOWN_SIMPLE_ATTRIBUTE = 114;
+        public const int MSG_INVALID_RULE_PARAMETER_REF = 115;
+        public const int MSG_UNKNOWN_RULE_ATTRIBUTE = 116;
+        public const int MSG_ISOLATED_RULE_SCOPE = 117;
+        public const int MSG_SYMBOL_CONFLICTS_WITH_GLOBAL_SCOPE = 118;
+        public const int MSG_LABEL_CONFLICTS_WITH_RULE = 119;
+        public const int MSG_LABEL_CONFLICTS_WITH_TOKEN = 120;
+        public const int MSG_LABEL_CONFLICTS_WITH_RULE_SCOPE_ATTRIBUTE = 121;
+        public const int MSG_LABEL_CONFLICTS_WITH_RULE_ARG_RETVAL = 122;
+        public const int MSG_ATTRIBUTE_CONFLICTS_WITH_RULE = 123;
+        public const int MSG_ATTRIBUTE_CONFLICTS_WITH_RULE_ARG_RETVAL = 124;
+        public const int MSG_LABEL_TYPE_CONFLICT = 125;
+        public const int MSG_ARG_RETVAL_CONFLICT = 126;
+        public const int MSG_NONUNIQUE_REF = 127;
+        public const int MSG_FORWARD_ELEMENT_REF = 128;
+        public const int MSG_MISSING_RULE_ARGS = 129;
+        public const int MSG_RULE_HAS_NO_ARGS = 130;
+        public const int MSG_ARGS_ON_TOKEN_REF = 131;
+        public const int MSG_RULE_REF_AMBIG_WITH_RULE_IN_ALT = 132;
+        public const int MSG_ILLEGAL_OPTION = 133;
+        public const int MSG_LIST_LABEL_INVALID_UNLESS_RETVAL_STRUCT = 134;
+        public const int MSG_UNDEFINED_TOKEN_REF_IN_REWRITE = 135;
+        public const int MSG_REWRITE_ELEMENT_NOT_PRESENT_ON_LHS = 136;
+        public const int MSG_UNDEFINED_LABEL_REF_IN_REWRITE = 137;
+        public const int MSG_NO_GRAMMAR_START_RULE = 138;
+        public const int MSG_EMPTY_COMPLEMENT = 139;
+        public const int MSG_UNKNOWN_DYNAMIC_SCOPE = 140;
+        public const int MSG_UNKNOWN_DYNAMIC_SCOPE_ATTRIBUTE = 141;
+        public const int MSG_ISOLATED_RULE_ATTRIBUTE = 142;
+        public const int MSG_INVALID_ACTION_SCOPE = 143;
+        public const int MSG_ACTION_REDEFINITION = 144;
+        public const int MSG_DOUBLE_QUOTES_ILLEGAL = 145;
+        public const int MSG_INVALID_TEMPLATE_ACTION = 146;
+        public const int MSG_MISSING_ATTRIBUTE_NAME = 147;
+        public const int MSG_ARG_INIT_VALUES_ILLEGAL = 148;
+        public const int MSG_REWRITE_OR_OP_WITH_NO_OUTPUT_OPTION = 149;
+        public const int MSG_NO_RULES = 150;
+        public const int MSG_WRITE_TO_READONLY_ATTR = 151;
+        public const int MSG_MISSING_AST_TYPE_IN_TREE_GRAMMAR = 152;
+        public const int MSG_REWRITE_FOR_MULTI_ELEMENT_ALT = 153;
+        public const int MSG_RULE_INVALID_SET = 154;
+        public const int MSG_HETERO_ILLEGAL_IN_REWRITE_ALT = 155;
+        public const int MSG_NO_SUCH_GRAMMAR_SCOPE = 156;
+        public const int MSG_NO_SUCH_RULE_IN_SCOPE = 157;
+        public const int MSG_TOKEN_ALIAS_CONFLICT = 158;
+        public const int MSG_TOKEN_ALIAS_REASSIGNMENT = 159;
+        public const int MSG_TOKEN_VOCAB_IN_DELEGATE = 160;
+        public const int MSG_INVALID_IMPORT = 161;
+        public const int MSG_IMPORTED_TOKENS_RULE_EMPTY = 162;
+        public const int MSG_IMPORT_NAME_CLASH = 163;
+        public const int MSG_AST_OP_WITH_NON_AST_OUTPUT_OPTION = 164;
+        public const int MSG_AST_OP_IN_ALT_WITH_REWRITE = 165;
+        public const int MSG_WILDCARD_AS_ROOT = 166;
+        public const int MSG_CONFLICTING_OPTION_IN_TREE_FILTER = 167;
+
+
+        // GRAMMAR WARNINGS
+        public const int MSG_GRAMMAR_NONDETERMINISM = 200; // A predicts alts 1,2
+        public const int MSG_UNREACHABLE_ALTS = 201;       // nothing predicts alt i
+        public const int MSG_DANGLING_STATE = 202;        // no edges out of state
+        public const int MSG_INSUFFICIENT_PREDICATES = 203;
+        public const int MSG_DUPLICATE_SET_ENTRY = 204;    // (A|A)
+        public const int MSG_ANALYSIS_ABORTED = 205;
+        public const int MSG_RECURSION_OVERLOW = 206;
+        public const int MSG_LEFT_RECURSION = 207;
+        public const int MSG_UNREACHABLE_TOKENS = 208; // nothing predicts token
+        public const int MSG_TOKEN_NONDETERMINISM = 209; // alts of Tokens rule
+        public const int MSG_LEFT_RECURSION_CYCLES = 210;
+        public const int MSG_NONREGULAR_DECISION = 211;
+
+
+        public const int MAX_MESSAGE_NUMBER = 211;
+
+        /** Do not do perform analysis if one of these happens */
+        public static readonly BitSet ERRORS_FORCING_NO_ANALYSIS;
+        //public static readonly BitSet ERRORS_FORCING_NO_ANALYSIS = new BitSet() {
+        //    {
+        //        add(MSG_RULE_REDEFINITION);
+        //        add(MSG_UNDEFINED_RULE_REF);
+        //        add(MSG_LEFT_RECURSION_CYCLES);
+        //        add(MSG_REWRITE_OR_OP_WITH_NO_OUTPUT_OPTION);
+        //        add(MSG_NO_RULES);
+        //        add(MSG_NO_SUCH_GRAMMAR_SCOPE);
+        //        add(MSG_NO_SUCH_RULE_IN_SCOPE);
+        //        add(MSG_LEXER_RULES_NOT_ALLOWED);
+        //        // TODO: ...
+        //    }
+        //};
+
+        /** Do not do code gen if one of these happens */
+        public static readonly BitSet ERRORS_FORCING_NO_CODEGEN;
+        //public static readonly BitSet ERRORS_FORCING_NO_CODEGEN = new BitSet() {
+        //    {
+        //        add(MSG_NONREGULAR_DECISION);
+        //        add(MSG_RECURSION_OVERLOW);
+        //        add(MSG_UNREACHABLE_ALTS);
+        //        add(MSG_FILE_AND_GRAMMAR_NAME_DIFFER);
+        //        add(MSG_INVALID_IMPORT);
+        //        add(MSG_AST_OP_WITH_NON_AST_OUTPUT_OPTION);
+        //        // TODO: ...
+        //    }
+        //};
+
+        /** Only one error can be emitted for any entry in this table.
+         *  Map<String,Set> where the key is a method name like danglingState.
+         *  The set is whatever that method accepts or derives like a DFA.
+         */
+        public static readonly IDictionary<string, ICollection<object>> emitSingleError;
+        //public static readonly Map emitSingleError = new HashMap() {
+        //    {
+        //        put("danglingState", new HashSet());
+        //    }
+        //};
+
+
+        /** Messages should be sensitive to the locale. */
+        private static CultureInfo locale;
+        private static string formatName;
+
+        /** Each thread might need it's own error listener; e.g., a GUI with
+         *  multiple window frames holding multiple grammars.
+         */
+        private static Dictionary<Thread, IANTLRErrorListener> threadToListenerMap = new Dictionary<Thread, IANTLRErrorListener>();
+
+        public class ErrorState
+        {
+            public int errors;
+            public int warnings;
+            public int infos;
+
+            public BitSet errorMsgIDs = new BitSet();
+            public BitSet warningMsgIDs = new BitSet();
+        }
+
+        /** Track the number of errors regardless of the listener but track
+         *  per thread.
+         */
+        private static IDictionary<Thread, ErrorState> threadToErrorStateMap = new Dictionary<Thread, ErrorState>();
+
+        /** Each thread has its own ptr to a Tool object, which knows how
+         *  to panic, for example.  In a GUI, the thread might just throw an Error
+         *  to exit rather than the suicide System.exit.
+         */
+        private static IDictionary<Thread, Tool> threadToToolMap = new Dictionary<Thread, Tool>();
+
+        /** The group of templates that represent all possible ANTLR errors. */
+        private static StringTemplateGroup messages;
+        /** The group of templates that represent the current message format. */
+        private static StringTemplateGroup format;
+
+        /** From a msgID how can I get the name of the template that describes
+         *  the error or warning?
+         */
+        private static String[] idToMessageTemplateName = new String[MAX_MESSAGE_NUMBER + 1];
+
+        class DefaultErrorListener : IANTLRErrorListener
+        {
+            public virtual void info( String msg )
+            {
+                if ( formatWantsSingleLineMessage() )
+                {
+                    msg = msg.replaceAll( "\n", " " );
+                }
+                Console.Error.WriteLine( msg );
+            }
+
+            public virtual void error( Message msg )
+            {
+                String outputMsg = msg.ToString();
+                if ( formatWantsSingleLineMessage() )
+                {
+                    outputMsg = outputMsg.replaceAll( "\n", " " );
+                }
+                Console.Error.WriteLine( outputMsg );
+            }
+
+            public virtual void warning( Message msg )
+            {
+                String outputMsg = msg.ToString();
+                if ( formatWantsSingleLineMessage() )
+                {
+                    outputMsg = outputMsg.replaceAll( "\n", " " );
+                }
+                Console.Error.WriteLine( outputMsg );
+            }
+
+            public virtual void error( ToolMessage msg )
+            {
+                String outputMsg = msg.ToString();
+                if ( formatWantsSingleLineMessage() )
+                {
+                    outputMsg = outputMsg.replaceAll( "\n", " " );
+                }
+                Console.Error.WriteLine( outputMsg );
+            }
+        }
+
+        static IANTLRErrorListener theDefaultErrorListener = new DefaultErrorListener();
+        //static ANTLRErrorListener theDefaultErrorListener = new ANTLRErrorListener() {
+        //    public void info(String msg) {
+        //        if (formatWantsSingleLineMessage()) {
+        //            msg = msg.replaceAll("\n", " ");
+        //        }
+        //        System.err.println(msg);
+        //    }
+
+        //    public void error(Message msg) {
+        //        String outputMsg = msg.toString();
+        //        if (formatWantsSingleLineMessage()) {
+        //            outputMsg = outputMsg.replaceAll("\n", " ");
+        //        }
+        //        System.err.println(outputMsg);
+        //    }
+
+        //    public void warning(Message msg) {
+        //        String outputMsg = msg.toString();
+        //        if (formatWantsSingleLineMessage()) {
+        //            outputMsg = outputMsg.replaceAll("\n", " ");
+        //        }
+        //        System.err.println(outputMsg);
+        //    }
+
+        //    public void error(ToolMessage msg) {
+        //        String outputMsg = msg.toString();
+        //        if (formatWantsSingleLineMessage()) {
+        //            outputMsg = outputMsg.replaceAll("\n", " ");
+        //        }
+        //        System.err.println(outputMsg);
+        //    }
+        //};
+
+        class InitSTListener : IStringTemplateErrorListener
+        {
+            public virtual void error( String s, Exception e )
+            {
+                Console.Error.WriteLine( "ErrorManager init error: " + s );
+                if ( e != null )
+                {
+                    Console.Error.WriteLine( "exception: " + e );
+                }
+                /*
+                if ( e!=null ) {
+                    e.printStackTrace(System.err);
+                }
+                */
+            }
+            public virtual void warning( String s )
+            {
+                Console.Error.WriteLine( "ErrorManager init warning: " + s );
+            }
+            public virtual void debug( String s )
+            {
+            }
+        }
+
+        /** Handle all ST error listeners here (code gen, Grammar, and this class
+         *  use templates.
+         */
+        static IStringTemplateErrorListener initSTListener = new InitSTListener();
+        //static StringTemplateErrorListener initSTListener =
+        //    new StringTemplateErrorListener() {
+        //        public void error(String s, Throwable e) {
+        //            System.err.println("ErrorManager init error: "+s);
+        //            if ( e!=null ) {
+        //                System.err.println("exception: "+e);
+        //            }
+        //            /*
+        //            if ( e!=null ) {
+        //                e.printStackTrace(System.err);
+        //            }
+        //            */
+        //        }
+        //        public void warning(String s) {
+        //            System.err.println("ErrorManager init warning: "+s);
+        //        }
+        //        public void debug(String s) {}
+        //    };
+
+        class BlankSTListener : IStringTemplateErrorListener
+        {
+            public virtual void error( string msg, Exception e )
+            {
+            }
+            public virtual void warning( string msg )
+            {
+            }
+        }
+
+        /** During verification of the messages group file, don't gen errors.
+         *  I'll handle them here.  This is used only after file has loaded ok
+         *  and only for the messages STG.
+         */
+        static IStringTemplateErrorListener blankSTListener = new BlankSTListener();
+        //static StringTemplateErrorListener blankSTListener =
+        //    new StringTemplateErrorListener() {
+        //        public void error(String s, Throwable e) {}
+        //        public void warning(String s) {}
+        //        public void debug(String s) {}
+        //    };
+
+        class DefaultSTListener : IStringTemplateErrorListener
+        {
+            public virtual void error( String s, Exception e )
+            {
+                if ( e is TargetInvocationException )
+                {
+                    e = e.InnerException ?? e;
+                }
+                ErrorManager.error( ErrorManager.MSG_INTERNAL_ERROR, s, e );
+            }
+            public virtual void warning( String s )
+            {
+                ErrorManager.warning( ErrorManager.MSG_INTERNAL_WARNING, s );
+            }
+            public virtual void debug( String s )
+            {
+            }
+        }
+
+        /** Errors during initialization related to ST must all go to System.err.
+         */
+        static IStringTemplateErrorListener theDefaultSTListener = new DefaultSTListener();
+        //static StringTemplateErrorListener theDefaultSTListener =
+        //    new StringTemplateErrorListener() {
+        //    public void error(String s, Throwable e) {
+        //        if ( e instanceof InvocationTargetException ) {
+        //            e = ((InvocationTargetException)e).getTargetException();
+        //        }
+        //        ErrorManager.error(ErrorManager.MSG_INTERNAL_ERROR, s, e);
+        //    }
+        //    public void warning(String s) {
+        //        ErrorManager.warning(ErrorManager.MSG_INTERNAL_WARNING, s);
+        //    }
+        //    public void debug(String s) {
+        //    }
+        //};
+
+        static ErrorManager()
+        {
+            ERRORS_FORCING_NO_ANALYSIS = new BitSet();
+            ERRORS_FORCING_NO_ANALYSIS.add( MSG_RULE_REDEFINITION );
+            ERRORS_FORCING_NO_ANALYSIS.add( MSG_UNDEFINED_RULE_REF );
+            ERRORS_FORCING_NO_ANALYSIS.add( MSG_LEFT_RECURSION_CYCLES );
+            ERRORS_FORCING_NO_ANALYSIS.add( MSG_REWRITE_OR_OP_WITH_NO_OUTPUT_OPTION );
+            ERRORS_FORCING_NO_ANALYSIS.add( MSG_NO_RULES );
+            ERRORS_FORCING_NO_ANALYSIS.add( MSG_NO_SUCH_GRAMMAR_SCOPE );
+            ERRORS_FORCING_NO_ANALYSIS.add( MSG_NO_SUCH_RULE_IN_SCOPE );
+            ERRORS_FORCING_NO_ANALYSIS.add( MSG_LEXER_RULES_NOT_ALLOWED );
+            ERRORS_FORCING_NO_ANALYSIS.add( MSG_WILDCARD_AS_ROOT );
+            // TODO: ...
+
+            /** Do not do code gen if one of these happens */
+            ERRORS_FORCING_NO_CODEGEN = new BitSet();
+            ERRORS_FORCING_NO_CODEGEN.add( MSG_NONREGULAR_DECISION );
+            ERRORS_FORCING_NO_CODEGEN.add( MSG_RECURSION_OVERLOW );
+            ERRORS_FORCING_NO_CODEGEN.add( MSG_UNREACHABLE_ALTS );
+            ERRORS_FORCING_NO_CODEGEN.add( MSG_FILE_AND_GRAMMAR_NAME_DIFFER );
+            ERRORS_FORCING_NO_CODEGEN.add( MSG_INVALID_IMPORT );
+            ERRORS_FORCING_NO_CODEGEN.add( MSG_AST_OP_WITH_NON_AST_OUTPUT_OPTION );
+            // TODO: ...
+
+            /** Only one error can be emitted for any entry in this table.
+             *  Map<String,Set> where the key is a method name like danglingState.
+             *  The set is whatever that method accepts or derives like a DFA.
+             */
+            emitSingleError = new Dictionary<string, ICollection<object>>();
+            emitSingleError["danglingState"] = new HashSet<object>();
+
+            initIdToMessageNameMapping();
+            // it is inefficient to set the default locale here if another
+            // piece of code is going to set the locale, but that would
+            // require that a user call an init() function or something.  I prefer
+            // that this class be ready to go when loaded as I'm absentminded ;)
+            setLocale( CultureInfo.CurrentCulture );
+            // try to load the message format group
+            // the user might have specified one on the command line
+            // if not, or if the user has given an illegal value, we will fall back to "antlr"
+            setFormat( "antlr" );
+        }
+
+        public static IStringTemplateErrorListener getStringTemplateErrorListener()
+        {
+            return theDefaultSTListener;
+        }
+
+        /** We really only need a single locale for entire running ANTLR code
+         *  in a single VM.  Only pay attention to the language, not the country
+         *  so that French Canadians and French Frenchies all get the same
+         *  template file, fr.stg.  Just easier this way.
+         */
+        public static void setLocale( CultureInfo locale )
+        {
+            ErrorManager.locale = locale;
+            String language = locale.TwoLetterISOLanguageName;
+            //String fileName = "org/antlr/tool/templates/messages/languages/"+language+".stg";
+            string fileName = @"Tool\Templates\messages\languages\" + language + ".stg";
+            string streamName = "Antlr3." + fileName.Replace( '\\', '.' );
+            fileName = System.IO.Path.Combine( System.IO.Path.GetDirectoryName( typeof( ErrorManager ).Assembly.Location ), fileName );
+            //ClassLoader cl = Thread.currentThread().getContextClassLoader();
+            //InputStream @is = cl.getResourceAsStream(fileName);
+            System.IO.Stream @is;
+            if ( System.IO.File.Exists( fileName ) )
+                @is = new System.IO.MemoryStream( System.IO.File.ReadAllBytes( fileName ) );
+            else
+                @is = typeof( ErrorManager ).Assembly.GetManifestResourceStream( streamName );
+            //if ( @is==null ) {
+            //    cl = typeof(ErrorManager).getClassLoader();
+            //    @is = cl.getResourceAsStream(fileName);
+            //}
+            if ( @is==null && language.Equals(CultureInfo.GetCultureInfo("en-us").TwoLetterISOLanguageName) ) {
+                rawError("ANTLR installation corrupted; cannot find English messages file "+fileName);
+                panic();
+            }
+            else if ( @is==null ) {
+                //rawError("no such locale file "+fileName+" retrying with English locale");
+                setLocale(CultureInfo.GetCultureInfo("en-us")); // recurse on this rule, trying the US locale
+                return;
+            }
+            StreamReader br = null;
+            try {
+                br = new StreamReader(new System.IO.BufferedStream( @is ) );
+                messages = new StringTemplateGroup(br,
+                                                   typeof(AngleBracketTemplateLexer),
+                                                   initSTListener);
+                br.Close();
+            }
+            catch (IOException ioe) {
+                rawError("error reading message file "+fileName, ioe);
+            }
+            finally {
+                if ( br!=null ) {
+                    try {
+                        br.Close();
+                    }
+                    catch (IOException ioe) {
+                        rawError("cannot close message file "+fileName, ioe);
+                    }
+                }
+            }
+
+            messages.ErrorListener = blankSTListener;
+            bool messagesOK = verifyMessages();
+            if ( !messagesOK && language.Equals(CultureInfo.GetCultureInfo("en-us").TwoLetterISOLanguageName) ) {
+                rawError("ANTLR installation corrupted; English messages file "+language+".stg incomplete");
+                panic();
+            }
+            else if ( !messagesOK ) {
+                setLocale(CultureInfo.GetCultureInfo("en-us")); // try US to see if that will work
+            }
+        }
+
+        /** The format gets reset either from the Tool if the user supplied a command line option to that effect
+         *  Otherwise we just use the default "antlr".
+         */
+        public static void setFormat( String formatName )
+        {
+            ErrorManager.formatName = formatName;
+            //String fileName = "org/antlr/tool/templates/messages/formats/"+formatName+".stg";
+            string fileName = @"Tool\Templates\messages\formats\" + formatName + ".stg";
+            string streamName = "Antlr3." + fileName.Replace( '\\', '.' );
+            fileName = System.IO.Path.Combine( System.IO.Path.GetDirectoryName( typeof( ErrorManager ).Assembly.Location ), fileName );
+            //ClassLoader cl = Thread.currentThread().getContextClassLoader();
+            //InputStream is = cl.getResourceAsStream(fileName);
+            System.IO.Stream @is;
+            if ( System.IO.File.Exists( fileName ) )
+                @is = new System.IO.MemoryStream( System.IO.File.ReadAllBytes( fileName ) );
+            else
+                @is = typeof( ErrorManager ).Assembly.GetManifestResourceStream( streamName );
+            //if ( is==null ) {
+            //    cl = ErrorManager.class.getClassLoader();
+            //    is = cl.getResourceAsStream(fileName);
+            //}
+            if ( @is == null && formatName.Equals( "antlr" ) )
+            {
+                rawError( "ANTLR installation corrupted; cannot find ANTLR messages format file " + fileName );
+                panic();
+            }
+            else if ( @is == null )
+            {
+                rawError( "no such message format file " + fileName + " retrying with default ANTLR format" );
+                setFormat( "antlr" ); // recurse on this rule, trying the default message format
+                return;
+            }
+            StreamReader br = null;
+            try
+            {
+                br = new StreamReader( new System.IO.BufferedStream( @is ) );
+                format = new StringTemplateGroup( br,
+                                                   typeof( AngleBracketTemplateLexer ),
+                                                   initSTListener );
+            }
+            finally
+            {
+                try
+                {
+                    if ( br != null )
+                    {
+                        br.Close();
+                    }
+                }
+                catch ( IOException ioe )
+                {
+                    rawError( "cannot close message format file " + fileName, ioe );
+                }
+            }
+
+            format.ErrorListener = blankSTListener;
+            bool formatOK = verifyFormat();
+            if ( !formatOK && formatName.Equals( "antlr" ) )
+            {
+                rawError( "ANTLR installation corrupted; ANTLR messages format file " + formatName + ".stg incomplete" );
+                panic();
+            }
+            else if ( !formatOK )
+            {
+                setFormat( "antlr" ); // recurse on this rule, trying the default message format
+            }
+        }
+
+        /** Encodes the error handling found in setLocale, but does not trigger
+         *  panics, which would make GUI tools die if ANTLR's installation was
+         *  a bit screwy.  Duplicated code...ick.
+        public static Locale getLocaleForValidMessages(Locale locale) {
+            ErrorManager.locale = locale;
+            String language = locale.getLanguage();
+            String fileName = "org/antlr/tool/templates/messages/"+language+".stg";
+            ClassLoader cl = Thread.currentThread().getContextClassLoader();
+            InputStream is = cl.getResourceAsStream(fileName);
+            if ( is==null && language.equals(Locale.US.getLanguage()) ) {
+                return null;
+            }
+            else if ( is==null ) {
+                return getLocaleForValidMessages(Locale.US); // recurse on this rule, trying the US locale
+            }
+
+            boolean messagesOK = verifyMessages();
+            if ( !messagesOK && language.equals(Locale.US.getLanguage()) ) {
+                return null;
+            }
+            else if ( !messagesOK ) {
+                return getLocaleForValidMessages(Locale.US); // try US to see if that will work
+            }
+            return true;
+        }
+         */
+
+        /** In general, you'll want all errors to go to a single spot.
+         *  However, in a GUI, you might have two frames up with two
+         *  different grammars.  Two threads might launch to process the
+         *  grammars--you would want errors to go to different objects
+         *  depending on the thread.  I store a single listener per
+         *  thread.
+         */
+        public static void setErrorListener( IANTLRErrorListener listener )
+        {
+            threadToListenerMap[Thread.CurrentThread] = listener;
+        }
+
+        public static void removeErrorListener()
+        {
+            threadToListenerMap.Remove( Thread.CurrentThread );
+        }
+
+        public static void setTool( Tool tool )
+        {
+            threadToToolMap[Thread.CurrentThread] = tool;
+        }
+
+        /** Given a message ID, return a StringTemplate that somebody can fill
+         *  with data.  We need to convert the int ID to the name of a template
+         *  in the messages ST group.
+         */
+        public static StringTemplate getMessage( int msgID )
+        {
+            String msgName = idToMessageTemplateName[msgID];
+            return messages.getInstanceOf( msgName );
+        }
+        public static String getMessageType( int msgID )
+        {
+            if ( getErrorState().warningMsgIDs.member( msgID ) )
+            {
+                return messages.getInstanceOf( "warning" ).ToString();
+            }
+            else if ( getErrorState().errorMsgIDs.member( msgID ) )
+            {
+                return messages.getInstanceOf( "error" ).ToString();
+            }
+            assertTrue( false, "Assertion failed! Message ID " + msgID + " created but is not present in errorMsgIDs or warningMsgIDs." );
+            return "";
+        }
+
+        /** Return a StringTemplate that refers to the current format used for
+         * emitting messages.
+         */
+        public static StringTemplate getLocationFormat()
+        {
+            return format.getInstanceOf( "location" );
+        }
+        public static StringTemplate getReportFormat()
+        {
+            return format.getInstanceOf( "report" );
+        }
+        public static StringTemplate getMessageFormat()
+        {
+            return format.getInstanceOf( "message" );
+        }
+        public static bool formatWantsSingleLineMessage()
+        {
+            return format.getInstanceOf( "wantsSingleLineMessage" ).ToString().Equals( "true" );
+        }
+
+        public static IANTLRErrorListener getErrorListener()
+        {
+            IANTLRErrorListener el =
+                (IANTLRErrorListener)threadToListenerMap.get( Thread.CurrentThread );
+            if ( el == null )
+            {
+                return theDefaultErrorListener;
+            }
+            return el;
+        }
+
+        public static ErrorState getErrorState()
+        {
+            ErrorState ec =
+                (ErrorState)threadToErrorStateMap.get( Thread.CurrentThread );
+            if ( ec == null )
+            {
+                ec = new ErrorState();
+                threadToErrorStateMap[Thread.CurrentThread] = ec;
+            }
+            return ec;
+        }
+
+        public static int getNumErrors()
+        {
+            return getErrorState().errors;
+        }
+
+        public static void resetErrorState()
+        {
+            threadToListenerMap = new Dictionary<Thread, IANTLRErrorListener>();
+            ErrorState ec = new ErrorState();
+            threadToErrorStateMap[Thread.CurrentThread] = ec;
+        }
+
+        public static void info( String msg )
+        {
+            getErrorState().infos++;
+            getErrorListener().info( msg );
+        }
+
+        public static void error( int msgID )
+        {
+            getErrorState().errors++;
+            getErrorState().errorMsgIDs.add( msgID );
+            getErrorListener().error( new ToolMessage( msgID ) );
+        }
+
+        public static void error( int msgID, Exception e )
+        {
+            getErrorState().errors++;
+            getErrorState().errorMsgIDs.add( msgID );
+            getErrorListener().error( new ToolMessage( msgID, e ) );
+        }
+
+        public static void error( int msgID, Object arg )
+        {
+            getErrorState().errors++;
+            getErrorState().errorMsgIDs.add( msgID );
+            getErrorListener().error( new ToolMessage( msgID, arg ) );
+        }
+
+        public static void error( int msgID, Object arg, Object arg2 )
+        {
+            getErrorState().errors++;
+            getErrorState().errorMsgIDs.add( msgID );
+            getErrorListener().error( new ToolMessage( msgID, arg, arg2 ) );
+        }
+
+        public static void error( int msgID, Object arg, Exception e )
+        {
+            getErrorState().errors++;
+            getErrorState().errorMsgIDs.add( msgID );
+            getErrorListener().error( new ToolMessage( msgID, arg, e ) );
+        }
+
+        public static void warning( int msgID, Object arg )
+        {
+            getErrorState().warnings++;
+            getErrorState().warningMsgIDs.add( msgID );
+            getErrorListener().warning( new ToolMessage( msgID, arg ) );
+        }
+
+        public static void nondeterminism( DecisionProbe probe,
+                                          DFAState d )
+        {
+            getErrorState().warnings++;
+            Message msg = new GrammarNonDeterminismMessage( probe, d );
+            getErrorState().warningMsgIDs.add( msg.msgID );
+            getErrorListener().warning( msg );
+        }
+
+        public static void danglingState( DecisionProbe probe,
+                                         DFAState d )
+        {
+            getErrorState().errors++;
+            Message msg = new GrammarDanglingStateMessage( probe, d );
+            getErrorState().errorMsgIDs.add( msg.msgID );
+            ICollection<object> seen = (ICollection<object>)emitSingleError.get( "danglingState" );
+            if ( !seen.Contains( d.dfa.decisionNumber + "|" + d.AltSet ) )
+            {
+                getErrorListener().error( msg );
+                // we've seen this decision and this alt set; never again
+                seen.Add( d.dfa.decisionNumber + "|" + d.AltSet );
+            }
+        }
+
+        public static void analysisAborted( DecisionProbe probe )
+        {
+            getErrorState().warnings++;
+            Message msg = new GrammarAnalysisAbortedMessage( probe );
+            getErrorState().warningMsgIDs.add( msg.msgID );
+            getErrorListener().warning( msg );
+        }
+
+        public static void unreachableAlts( DecisionProbe probe,
+                                           IEnumerable<int> alts )
+        {
+            getErrorState().errors++;
+            Message msg = new GrammarUnreachableAltsMessage( probe, alts );
+            getErrorState().errorMsgIDs.add( msg.msgID );
+            getErrorListener().error( msg );
+        }
+
+        public static void insufficientPredicates( DecisionProbe probe,
+                                                  DFAState d,
+                                                  IDictionary<int, ICollection<IToken>> altToUncoveredLocations )
+        {
+            getErrorState().warnings++;
+            Message msg = new GrammarInsufficientPredicatesMessage( probe, d, altToUncoveredLocations );
+            getErrorState().warningMsgIDs.add( msg.msgID );
+            getErrorListener().warning( msg );
+        }
+
+        public static void nonLLStarDecision( DecisionProbe probe )
+        {
+            getErrorState().errors++;
+            Message msg = new NonRegularDecisionMessage( probe, probe.NonDeterministicAlts );
+            getErrorState().errorMsgIDs.add( msg.msgID );
+            getErrorListener().error( msg );
+        }
+
+        public static void recursionOverflow( DecisionProbe probe,
+                                             DFAState sampleBadState,
+                                             int alt,
+                                             ICollection<string> targetRules,
+                                             ICollection<ICollection<NFAState>> callSiteStates )
+        {
+            getErrorState().errors++;
+            Message msg = new RecursionOverflowMessage( probe, sampleBadState, alt,
+                                             targetRules, callSiteStates );
+            getErrorState().errorMsgIDs.add( msg.msgID );
+            getErrorListener().error( msg );
+        }
+
+        /*
+        // TODO: we can remove I think.  All detected now with cycles check.
+        public static void leftRecursion(DecisionProbe probe,
+                                         int alt,
+                                         Collection targetRules,
+                                         Collection callSiteStates)
+        {
+            getErrorState().warnings++;
+            Message msg = new LeftRecursionMessage(probe, alt, targetRules, callSiteStates);
+            getErrorState().warningMsgIDs.add(msg.msgID);
+            getErrorListener().warning(msg);
+        }
+        */
+
+        public static void leftRecursionCycles( ICollection cycles )
+        {
+            getErrorState().errors++;
+            Message msg = new LeftRecursionCyclesMessage( cycles );
+            getErrorState().errorMsgIDs.add( msg.msgID );
+            getErrorListener().warning( msg );
+        }
+
+        public static void grammarError( int msgID,
+                                        Grammar g,
+                                        IToken token,
+                                        Object arg,
+                                        Object arg2 )
+        {
+            getErrorState().errors++;
+            Message msg = new GrammarSemanticsMessage( msgID, g, token, arg, arg2 );
+            getErrorState().errorMsgIDs.add( msgID );
+            getErrorListener().error( msg );
+        }
+
+        public static void grammarError( int msgID,
+                                        Grammar g,
+                                        IToken token,
+                                        Object arg )
+        {
+            grammarError( msgID, g, token, arg, null );
+        }
+
+        public static void grammarError( int msgID,
+                                        Grammar g,
+                                        IToken token )
+        {
+            grammarError( msgID, g, token, null, null );
+        }
+
+        public static void grammarWarning( int msgID,
+                                          Grammar g,
+                                          IToken token,
+                                          Object arg,
+                                          Object arg2 )
+        {
+            getErrorState().warnings++;
+            Message msg = new GrammarSemanticsMessage( msgID, g, token, arg, arg2 );
+            getErrorState().warningMsgIDs.add( msgID );
+            getErrorListener().warning( msg );
+        }
+
+        public static void grammarWarning( int msgID,
+                                          Grammar g,
+                                          IToken token,
+                                          Object arg )
+        {
+            grammarWarning( msgID, g, token, arg, null );
+        }
+
+        public static void grammarWarning( int msgID,
+                                          Grammar g,
+                                          IToken token )
+        {
+            grammarWarning( msgID, g, token, null, null );
+        }
+
+        public static void syntaxError( int msgID,
+                                       Grammar grammar,
+                                       IToken token,
+                                       Object arg,
+                                       RecognitionException re )
+        {
+            getErrorState().errors++;
+            getErrorState().errorMsgIDs.add( msgID );
+            getErrorListener().error(
+                new GrammarSyntaxMessage( msgID, grammar, token, arg, re )
+            );
+        }
+
+        public static void internalError( Object error, Exception e )
+        {
+            StackFrame location = getLastNonErrorManagerCodeLocation( e );
+            String msg = "Exception " + e + "@" + location + ": " + error;
+            ErrorManager.error( MSG_INTERNAL_ERROR, msg );
+        }
+
+        public static void internalError( Object error )
+        {
+            StackFrame location =
+                getLastNonErrorManagerCodeLocation( new Exception() );
+            String msg = location + ": " + error;
+            ErrorManager.error( MSG_INTERNAL_ERROR, msg );
+        }
+
+        public static bool doNotAttemptAnalysis()
+        {
+            return !getErrorState().errorMsgIDs.and( ERRORS_FORCING_NO_ANALYSIS ).isNil();
+        }
+
+        public static bool doNotAttemptCodeGen()
+        {
+            return doNotAttemptAnalysis() ||
+                   !getErrorState().errorMsgIDs.and( ERRORS_FORCING_NO_CODEGEN ).isNil();
+        }
+
+        /** Return first non ErrorManager code location for generating messages */
+        private static StackFrame getLastNonErrorManagerCodeLocation( Exception e )
+        {
+            StackFrame[] stack = e.getStackTrace();
+            int i = 0;
+            for ( ; i < stack.Length; i++ )
+            {
+                StackFrame t = stack[i];
+                if ( t.ToString().IndexOf( "ErrorManager" ) < 0 )
+                {
+                    break;
+                }
+            }
+            StackFrame location = stack[i];
+            return location;
+        }
+
+        // A S S E R T I O N  C O D E
+
+        public static void assertTrue( bool condition, String message )
+        {
+            if ( !condition )
+            {
+                internalError( message );
+            }
+        }
+
+        // S U P P O R T  C O D E
+
+        static bool initIdToMessageNameMapping()
+        {
+            // make sure a message exists, even if it's just to indicate a problem
+            for ( int i = 0; i < idToMessageTemplateName.Length; i++ )
+            {
+                idToMessageTemplateName[i] = "INVALID MESSAGE ID: " + i;
+            }
+            // get list of fields and use it to fill in idToMessageTemplateName mapping
+            FieldInfo[] fields = typeof( ErrorManager ).GetFields();
+            for ( int i = 0; i < fields.Length; i++ )
+            {
+                FieldInfo f = fields[i];
+                String fieldName = f.Name;
+                if ( !fieldName.StartsWith( "MSG_" ) )
+                {
+                    continue;
+                }
+                String templateName =
+                    fieldName.Substring( "MSG_".Length );
+                int msgID = 0;
+                try
+                {
+                    // get the constant value from this class object
+                    msgID = (int)f.GetValue( null );
+                    //msgID = f.getInt( typeof( ErrorManager ) );
+                }
+                catch ( FieldAccessException /*iae*/ )
+                {
+                    Console.Out.WriteLine( "cannot get const value for " + f.Name );
+                    continue;
+                }
+                if ( fieldName.StartsWith( "MSG_" ) )
+                {
+                    idToMessageTemplateName[msgID] = templateName;
+                }
+            }
+            return true;
+        }
+
+        /** Use reflection to find list of MSG_ fields and then verify a
+         *  template exists for each one from the locale's group.
+         */
+        static bool verifyMessages()
+        {
+            bool ok = true;
+            FieldInfo[] fields = typeof( ErrorManager ).GetFields();
+            for ( int i = 0; i < fields.Length; i++ )
+            {
+                FieldInfo f = fields[i];
+                String fieldName = f.Name;
+                String templateName =
+                    fieldName.Substring( "MSG_".Length );
+                if ( fieldName.StartsWith( "MSG_" ) )
+                {
+                    if ( !messages.isDefined( templateName ) )
+                    {
+                        Console.Out.WriteLine( "Message " + templateName + " in locale " +
+                                           locale + " not found" );
+                        ok = false;
+                    }
+                }
+            }
+            // check for special templates
+            if ( !messages.isDefined( "warning" ) )
+            {
+                Console.Error.WriteLine( "Message template 'warning' not found in locale " + locale );
+                ok = false;
+            }
+            if ( !messages.isDefined( "error" ) )
+            {
+                Console.Error.WriteLine( "Message template 'error' not found in locale " + locale );
+                ok = false;
+            }
+            return ok;
+        }
+
+        /** Verify the message format template group */
+        static bool verifyFormat()
+        {
+            bool ok = true;
+            if ( !format.isDefined( "location" ) )
+            {
+                Console.Error.WriteLine( "Format template 'location' not found in " + formatName );
+                ok = false;
+            }
+            if ( !format.isDefined( "message" ) )
+            {
+                Console.Error.WriteLine( "Format template 'message' not found in " + formatName );
+                ok = false;
+            }
+            if ( !format.isDefined( "report" ) )
+            {
+                Console.Error.WriteLine( "Format template 'report' not found in " + formatName );
+                ok = false;
+            }
+            return ok;
+        }
+
+        /** If there are errors during ErrorManager init, we have no choice
+         *  but to go to System.err.
+         */
+        static void rawError( String msg )
+        {
+            Console.Error.WriteLine( msg );
+        }
+
+        static void rawError( String msg, Exception e )
+        {
+            rawError( msg );
+            e.printStackTrace( Console.Error );
+        }
+
+        /** I *think* this will allow Tool subclasses to exit gracefully
+         *  for GUIs etc...
+         */
+        public static void panic()
+        {
+            Tool tool = (Tool)threadToToolMap.get( Thread.CurrentThread );
+            if ( tool == null )
+            {
+                // no tool registered, exit
+                throw new java.lang.Error( "ANTLR ErrorManager panic" );
+            }
+            else
+            {
+                tool.panic();
+            }
+        }
+    }
+}
diff --git a/Antlr3/Tool/FASerializer.cs b/Antlr3/Tool/FASerializer.cs
new file mode 100644
index 0000000..bbac3db
--- /dev/null
+++ b/Antlr3/Tool/FASerializer.cs
@@ -0,0 +1,252 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using System.Collections.Generic;
+    using Antlr3.Analysis;
+
+    using IList = System.Collections.IList;
+    using StringBuilder = System.Text.StringBuilder;
+
+    /** An aspect of FA (finite automata) that knows how to dump them to serialized
+     *  strings.
+     */
+    public class FASerializer
+    {
+        /** To prevent infinite recursion when walking state machines, record
+         *  which states we've visited.  Make a new set every time you start
+         *  walking in case you reuse this object.  Multiple threads will trash
+         *  this shared variable.  Use a different FASerializer per thread.
+         */
+        protected HashSet<State> markedStates;
+
+        /** Each state we walk will get a new state number for serialization
+         *  purposes.  This is the variable that tracks state numbers.
+         */
+        protected int stateCounter = 0;
+
+        /** Rather than add a new instance variable to NFA and DFA just for
+         *  serializing machines, map old state numbers to new state numbers
+         *  by a State object -> Integer new state number HashMap.
+         */
+        protected IDictionary<State, int> stateNumberTranslator;
+
+        protected Grammar grammar;
+
+        /** This aspect is associated with a grammar; used to get token names */
+        public FASerializer( Grammar grammar )
+        {
+            this.grammar = grammar;
+        }
+
+        public virtual string serialize( State s )
+        {
+            if ( s == null )
+            {
+                return "<no automaton>";
+            }
+            return serialize( s, true );
+        }
+
+        /** Return a string representation of a state machine.  Two identical
+         *  NFAs or DFAs will have identical serialized representations.  The
+         *  state numbers inside the state are not used; instead, a new number
+         *  is computed and because the serialization will walk the two
+         *  machines using the same specific algorithm, then the state numbers
+         *  will be identical.  Accept states are distinguished from regular
+         *  states.
+         */
+        public virtual string serialize( State s, bool renumber )
+        {
+            markedStates = new HashSet<State>();
+            stateCounter = 0;
+            if ( renumber )
+            {
+                stateNumberTranslator = new Dictionary<State, int>();
+                walkFANormalizingStateNumbers( s );
+            }
+            List<string> lines = new List<string>();
+            if ( s.NumberOfTransitions > 0 )
+            {
+                walkSerializingFA( lines, s );
+            }
+            else
+            {
+                // special case: s0 is an accept
+                string s0 = getStateString( 0, s );
+                lines.Add( s0 + "\n" );
+            }
+            StringBuilder buf = new StringBuilder( 0 );
+            // sort lines to normalize; makes states come out ordered
+            // and then ordered by edge labels then by target state number :)
+            //Collections.sort( lines );
+            lines.Sort( System.StringComparer.Ordinal );
+            for ( int i = 0; i < lines.Count; i++ )
+            {
+                string line = (string)lines[i];
+                buf.Append( line );
+            }
+            return buf.ToString();
+        }
+
+        /** In stateNumberTranslator, get a map from State to new, normalized
+         *  state number.  Used by walkSerializingFA to make sure any two
+         *  identical state machines will serialize the same way.
+         */
+        protected virtual void walkFANormalizingStateNumbers( State s )
+        {
+            if ( s == null )
+            {
+                ErrorManager.internalError( "null state s" );
+                return;
+            }
+            if ( stateNumberTranslator.ContainsKey( s ) )
+            {
+                return; // already did this state
+            }
+            // assign a new state number for this node if there isn't one
+            stateNumberTranslator[s] = stateCounter;
+            stateCounter++;
+
+            // visit nodes pointed to by each transition;
+            for ( int i = 0; i < s.NumberOfTransitions; i++ )
+            {
+                Transition edge = (Transition)s.getTransition( i );
+                walkFANormalizingStateNumbers( edge.target ); // keep walkin'
+                // if this transition is a rule reference, the node "following" this state
+                // will not be found and appear to be not in graph.  Must explicitly jump
+                // to it, but don't "draw" an edge.
+                if ( edge is RuleClosureTransition )
+                {
+                    walkFANormalizingStateNumbers( ( (RuleClosureTransition)edge ).followState );
+                }
+            }
+        }
+
+        protected virtual void walkSerializingFA( IList lines, State s )
+        {
+            if ( markedStates.Contains( s ) )
+            {
+                return; // already visited this node
+            }
+
+            markedStates.Add( s ); // mark this node as completed.
+
+            int normalizedStateNumber = s.stateNumber;
+            if ( stateNumberTranslator != null )
+            {
+                normalizedStateNumber = stateNumberTranslator[s];
+            }
+
+            string stateStr = getStateString( normalizedStateNumber, s );
+
+            // depth first walk each transition, printing its edge first
+            for ( int i = 0; i < s.NumberOfTransitions; i++ )
+            {
+                Transition edge = (Transition)s.getTransition( i );
+                StringBuilder buf = new StringBuilder();
+                buf.Append( stateStr );
+                if ( edge.IsAction )
+                {
+                    buf.Append( "-{}->" );
+                }
+                else if ( edge.IsEpsilon )
+                {
+                    buf.Append( "->" );
+                }
+                else if ( edge.IsSemanticPredicate )
+                {
+                    buf.Append( "-{" + edge.label.SemanticContext + "}?->" );
+                }
+                else
+                {
+                    string predsStr = "";
+                    if ( edge.target is DFAState )
+                    {
+                        // look for gated predicates; don't add gated to simple sempred edges
+                        SemanticContext preds =
+                            ( (DFAState)edge.target ).getGatedPredicatesInNFAConfigurations();
+                        if ( preds != null )
+                        {
+                            predsStr = "&&{" +
+                                preds.genExpr( grammar.generator,
+                                              grammar.generator.Templates, null ).ToString()
+                                + "}?";
+                        }
+                    }
+                    buf.Append( "-" + edge.label.ToString( grammar ) + predsStr + "->" );
+                }
+
+                int normalizedTargetStateNumber = edge.target.stateNumber;
+                if ( stateNumberTranslator != null )
+                {
+                    normalizedTargetStateNumber = stateNumberTranslator[edge.target];
+                }
+                buf.Append( getStateString( normalizedTargetStateNumber, edge.target ) );
+                buf.Append( "\n" );
+                lines.Add( buf.ToString() );
+
+                // walk this transition
+                walkSerializingFA( lines, edge.target );
+
+                // if this transition is a rule reference, the node "following" this state
+                // will not be found and appear to be not in graph.  Must explicitly jump
+                // to it, but don't "draw" an edge.
+                if ( edge is RuleClosureTransition )
+                {
+                    walkSerializingFA( lines, ( (RuleClosureTransition)edge ).followState );
+                }
+            }
+
+        }
+
+        private string getStateString( int n, State s )
+        {
+            string stateStr = ".s" + n;
+            if ( s.IsAcceptState )
+            {
+                if ( s is DFAState )
+                {
+                    stateStr = ":s" + n + "=>" + ( (DFAState)s ).getUniquelyPredictedAlt();
+                }
+                else
+                {
+                    stateStr = ":s" + n;
+                }
+            }
+            return stateStr;
+        }
+
+
+    }
+}
diff --git a/Antlr3/Tool/Grammar.cs b/Antlr3/Tool/Grammar.cs
new file mode 100644
index 0000000..58ed19d
--- /dev/null
+++ b/Antlr3/Tool/Grammar.cs
@@ -0,0 +1,3850 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using System.Collections.Generic;
+    using System.Linq;
+    using Antlr.Runtime.JavaExtensions;
+    using Antlr3.Analysis;
+    using Antlr3.Grammars;
+    using Antlr3.Misc;
+
+    using AngleBracketTemplateLexer = Antlr3.ST.Language.AngleBracketTemplateLexer;
+    using Character = java.lang.Character;
+    using CodeGenerator = Antlr3.Codegen.CodeGenerator;
+    using CommonToken = Antlr.Runtime.CommonToken;
+    using Console = System.Console;
+    using DateTime = System.DateTime;
+    using Exception = System.Exception;
+    using FileReader = java.io.FileReader;
+    using ICollection = System.Collections.ICollection;
+    using IDictionary = System.Collections.IDictionary;
+    using IList = System.Collections.IList;
+    using IOException = System.IO.IOException;
+    using IToken = Antlr.Runtime.IToken;
+    using ITree = Antlr.Runtime.Tree.ITree;
+    using LinkedHashMap = System.Collections.Generic.SortedList<object, object>;
+    using Math = System.Math;
+    using RecognitionException = Antlr.Runtime.RecognitionException;
+    using StreamTokenizer = java.io.StreamTokenizer;
+    using StringBuilder = System.Text.StringBuilder;
+    using StringReader = System.IO.StringReader;
+    using StringTemplate = Antlr3.ST.StringTemplate;
+    using TextReader = System.IO.TextReader;
+    using TextWriter = System.IO.TextWriter;
+    using TimeSpan = System.TimeSpan;
+    using TokenConstants = Antlr.Runtime.TokenConstants;
+    using Tool = Antlr3.AntlrTool;
+
+    /** Represents a grammar in memory. */
+    public class Grammar
+    {
+        public const string SYNPRED_RULE_PREFIX = "synpred";
+
+        public const string GRAMMAR_FILE_EXTENSION = ".g";
+
+        /** used for generating lexer temp files */
+        public const string LEXER_GRAMMAR_FILE_EXTENSION = ".g";
+
+        public const int INITIAL_DECISION_LIST_SIZE = 300;
+        public const int INVALID_RULE_INDEX = -1;
+
+        // the various kinds of labels. t=type, id=ID, types+=type ids+=ID
+        public const int RULE_LABEL = 1;
+        public const int TOKEN_LABEL = 2;
+        public const int RULE_LIST_LABEL = 3;
+        public const int TOKEN_LIST_LABEL = 4;
+        public const int CHAR_LABEL = 5; // used in lexer for x='a'
+        public const int WILDCARD_TREE_LABEL = 6; // Used in tree grammar x=.
+        public const int WILDCARD_TREE_LIST_LABEL = 7; // Used in tree grammar x+=.
+
+        public static string[] LabelTypeToString = { "<invalid>", "rule", "token", "rule-list", "token-list", "wildcard-tree", "wildcard-tree-list" };
+
+        public const string ARTIFICIAL_TOKENS_RULENAME = "Tokens";
+        public const string FRAGMENT_RULE_MODIFIER = "fragment";
+
+        public const string SYNPREDGATE_ACTION_NAME = "synpredgate";
+
+        /** When converting ANTLR char and string literals, here is the
+         *  value set of escape chars.
+         */
+        public static int[] ANTLRLiteralEscapedCharValue = new int[255];
+
+        /** Given a char, we need to be able to show as an ANTLR literal.
+         */
+        public static string[] ANTLRLiteralCharValueEscape = new string[255];
+
+        static Grammar()
+        {
+            ANTLRLiteralEscapedCharValue['n'] = '\n';
+            ANTLRLiteralEscapedCharValue['r'] = '\r';
+            ANTLRLiteralEscapedCharValue['t'] = '\t';
+            ANTLRLiteralEscapedCharValue['b'] = '\b';
+            ANTLRLiteralEscapedCharValue['f'] = '\f';
+            ANTLRLiteralEscapedCharValue['\\'] = '\\';
+            ANTLRLiteralEscapedCharValue['\''] = '\'';
+            ANTLRLiteralEscapedCharValue['"'] = '"';
+            ANTLRLiteralCharValueEscape['\n'] = "\\n";
+            ANTLRLiteralCharValueEscape['\r'] = "\\r";
+            ANTLRLiteralCharValueEscape['\t'] = "\\t";
+            ANTLRLiteralCharValueEscape['\b'] = "\\b";
+            ANTLRLiteralCharValueEscape['\f'] = "\\f";
+            ANTLRLiteralCharValueEscape['\\'] = "\\\\";
+            ANTLRLiteralCharValueEscape['\''] = "\\'";
+        }
+
+        public const int LEXER = 1;
+        public const int PARSER = 2;
+        public const int TREE_PARSER = 3;
+        public const int COMBINED = 4;
+        public static readonly string[] grammarTypeToString =
+            new string[]
+            {
+		        "<invalid>",
+		        "lexer",
+		        "parser",
+		        "tree",
+		        "combined"
+	        };
+
+        public static readonly string[] grammarTypeToFileNameSuffix =
+            new string[]
+            {
+                "<invalid>",
+                "Lexer",
+                "Parser",
+                "", // no suffix for tree grammars
+                "Parser" // if combined grammar, gen Parser and Lexer will be done later
+            };
+
+        /** Set of valid imports.  E.g., can only import a tree parser into
+         *  another tree parser.  Maps delegate to set of delegator grammar types.
+         *  validDelegations.get(LEXER) gives list of the kinds of delegators
+         *  that can import lexers.
+         */
+        public static MultiMap<int, int> validDelegations =
+            new MultiMap<int, int>()
+            {
+                { LEXER, LEXER },
+                { LEXER, PARSER },
+                { LEXER, COMBINED },
+
+                { PARSER, PARSER },
+                { PARSER, COMBINED },
+
+                { TREE_PARSER, TREE_PARSER },
+                // allow COMBINED
+                //{ COMBINED, COMBINED }
+            };
+
+        /** This is the buffer of *all* tokens found in the grammar file
+         *  including whitespace tokens etc...  I use this to extract
+         *  lexer rules from combined grammars.
+         */
+        private Antlr.Runtime.CommonTokenStream tokenBuffer;
+        public const string IGNORE_STRING_IN_GRAMMAR_FILE_NAME = "__";
+        public const string AUTO_GENERATED_TOKEN_NAME_PREFIX = "T__";
+
+        public /*static*/ class Decision
+        {
+            public int decision;
+            public NFAState startState;
+            public GrammarAST blockAST;
+            public DFA dfa;
+        }
+
+        public class LabelElementPair
+        {
+            public Grammar _outer;
+            public IToken label;
+            public GrammarAST elementRef;
+            public string referencedRuleName;
+            /** Has an action referenced the label?  Set by ActionAnalysis.g
+             *  Currently only set for rule labels.
+             */
+            public bool actionReferencesLabel;
+            public int type; // in {RULE_LABEL,TOKEN_LABEL,RULE_LIST_LABEL,TOKEN_LIST_LABEL}
+            public LabelElementPair( Grammar outer, IToken label, GrammarAST elementRef )
+            {
+                this._outer = outer;
+                this.label = label;
+                this.elementRef = elementRef;
+                this.referencedRuleName = elementRef.Text;
+            }
+            public Rule getReferencedRule()
+            {
+                return _outer.getRule( referencedRuleName );
+            }
+            public override string ToString()
+            {
+                return elementRef.ToString();
+            }
+        }
+
+        /** What name did the user provide for this grammar? */
+        public string name;
+
+        /** What type of grammar is this: lexer, parser, tree walker */
+        public int type;
+
+        /** A list of options specified at the grammar level such as language=Java.
+         *  The value can be an AST for complicated values such as character sets.
+         *  There may be code generator specific options in here.  I do no
+         *  interpretation of the key/value pairs...they are simply available for
+         *  who wants them.
+         */
+        protected IDictionary<string, object> options;
+
+        public static readonly HashSet<string> legalLexerOptions =
+            new HashSet<string>()
+            {
+                "language",
+                "tokenVocab",
+                "TokenLabelType",
+                "superClass",
+                "filter",
+                "k",
+                "backtrack",
+                "memoize"
+            };
+
+        public static readonly HashSet<string> legalParserOptions =
+            new HashSet<string>()
+            {
+                "language",
+                "tokenVocab",
+                "output",
+                "rewrite",
+                "ASTLabelType",
+                "TokenLabelType",
+                "superClass",
+                "k",
+                "backtrack",
+                "memoize"
+            };
+
+        public static readonly HashSet<string> legalTreeParserOptions =
+            new HashSet<string>()
+            {
+                "language",
+                "tokenVocab",
+                "output",
+                "rewrite",
+                "ASTLabelType",
+                "TokenLabelType",
+                "superClass",
+                "k",
+                "backtrack",
+                "memoize",
+                "filter",
+            };
+
+        public static readonly HashSet<string> doNotCopyOptionsToLexer =
+            new HashSet<string>()
+            {
+                "output",
+                "ASTLabelType",
+                "superClass",
+                "k",
+                "backtrack",
+                "memoize",
+                "rewrite"
+            };
+
+        public static readonly IDictionary<string, object> defaultOptions =
+            new Dictionary<string, object>()
+            {
+                { "language", "Java" }
+            };
+
+        public static readonly HashSet<string> legalBlockOptions =
+            new HashSet<string>()
+            {
+                "k",
+                "greedy",
+                "backtrack",
+                "memoize"
+            };
+
+        /** What are the default options for a subrule? */
+        public static readonly IDictionary<string, object> defaultBlockOptions =
+            new Dictionary<string, object>()
+            {
+                { "greedy", "true" }
+            };
+
+        public static readonly IDictionary<string, object> defaultLexerBlockOptions =
+            new Dictionary<string, object>()
+            {
+                { "greedy", "true" }
+            };
+
+        // Token options are here to avoid contaminating Token object in runtime
+
+        /** Legal options for terminal refs like ID<node=MyVarNode> */
+        public static readonly HashSet<string> legalTokenOptions =
+            new HashSet<string>()
+            {
+                defaultTokenOption
+            };
+
+        public const string defaultTokenOption = "node";
+
+        /** Is there a global fixed lookahead set for this grammar?
+         *  If 0, nothing specified.  -1 implies we have not looked at
+         *  the options table yet to set k.
+         */
+        protected int global_k = -1;
+
+        /** Map a scope to a map of name:action pairs.
+         *  Map<String, Map<String,GrammarAST>>
+         *  The code generator will use this to fill holes in the output files.
+         *  I track the AST node for the action in case I need the line number
+         *  for errors.
+         */
+        protected Dictionary<string, IDictionary<string, object>> actions = new Dictionary<string, IDictionary<string, object>>();
+
+        /** The NFA that represents the grammar with edges labelled with tokens
+         *  or epsilon.  It is more suitable to analysis than an AST representation.
+         */
+        public NFA nfa;
+
+        protected NFAFactory factory;
+
+        /** If this grammar is part of a larger composite grammar via delegate
+         *  statement, then this points at the composite.  The composite holds
+         *  a global list of rules, token types, decision numbers, etc...
+         */
+        public CompositeGrammar composite;
+
+        /** A pointer back into grammar tree.  Needed so we can add delegates. */
+        public CompositeGrammarTree compositeTreeNode;
+
+        /** If this is a delegate of another grammar, this is the label used
+         *  as an instance var by that grammar to point at this grammar. null
+         *  if no label was specified in the delegate statement.
+         */
+        public string label;
+
+        /** TODO: hook this to the charVocabulary option */
+        protected IIntSet charVocabulary = null;
+
+        /** For ANTLRWorks, we want to be able to map a line:col to a specific
+         *  decision DFA so it can display DFA.
+         */
+        Dictionary<string, DFA> lineColumnToLookaheadDFAMap = new Dictionary<string, DFA>();
+
+        public Tool tool;
+
+        /** The unique set of all rule references in any rule; set of tree node
+         *  objects so two refs to same rule can exist but at different line/position.
+         */
+        protected internal HashSet<GrammarAST> ruleRefs = new HashSet<GrammarAST>();
+
+        protected internal HashSet<GrammarAST> scopedRuleRefs = new HashSet<GrammarAST>();
+
+        /** The unique set of all token ID references in any rule */
+        protected internal HashSet<IToken> tokenIDRefs = new HashSet<IToken>();
+
+        /** Be able to assign a number to every decision in grammar;
+         *  decisions in 1..n
+         */
+        protected int decisionCount = 0;
+
+        /** A list of all rules that are in any left-recursive cycle.  There
+         *  could be multiple cycles, but this is a flat list of all problematic
+         *  rules.
+         */
+        protected internal HashSet<Rule> leftRecursiveRules;
+
+        /** An external tool requests that DFA analysis abort prematurely.  Stops
+         *  at DFA granularity, which are limited to a DFA size and time computation
+         *  as failsafe.
+         */
+        protected bool externalAnalysisAbort;
+
+        /** When we read in a grammar, we track the list of syntactic predicates
+         *  and build faux rules for them later.  See my blog entry Dec 2, 2005:
+         *  http://www.antlr.org/blog/antlr3/lookahead.tml
+         *  This maps the name (we make up) for a pred to the AST grammar fragment.
+         */
+        protected SortedList<string, GrammarAST> nameToSynpredASTMap;
+
+        /** At least one rule has memoize=true */
+        public bool atLeastOneRuleMemoizes;
+
+        /** At least one backtrack=true in rule or decision or grammar. */
+        public bool atLeastOneBacktrackOption;
+
+        /** Was this created from a COMBINED grammar? */
+        public bool implicitLexer;
+
+        /** Map a rule to it's Rule object */
+        protected SortedList<string, Rule> nameToRuleMap = new SortedList<string, Rule>();
+
+        /** If this rule is a delegate, some rules might be overridden; don't
+         *  want to gen code for them.
+         */
+        public HashSet<string> overriddenRules = new HashSet<string>();
+
+        /** The list of all rules referenced in this grammar, not defined here,
+         *  and defined in a delegate grammar.  Not all of these will be generated
+         *  in the recognizer for this file; only those that are affected by rule
+         *  definitions in this grammar.  I am not sure the Java target will need
+         *  this but I'm leaving in case other targets need it.
+         *  @see NameSpaceChecker.lookForReferencesToUndefinedSymbols()
+         */
+        protected internal HashSet<Rule> delegatedRuleReferences = new HashSet<Rule>();
+
+        /** The ANTLRParser tracks lexer rules when reading combined grammars
+         *  so we can build the Tokens rule.
+         */
+        public IList<string> lexerRuleNamesInCombined = new List<string>();
+
+        /** Track the scopes defined outside of rules and the scopes associated
+         *  with all rules (even if empty).
+         */
+        protected IDictionary<string, AttributeScope> scopes = new Dictionary<string, AttributeScope>();
+
+        /** An AST that records entire input grammar with all rules.  A simple
+         *  grammar with one rule, "grammar t; a : A | B ;", looks like:
+         * ( grammar t ( rule a ( BLOCK ( ALT A ) ( ALT B ) ) <end-of-rule> ) )
+         */
+        protected GrammarAST grammarTree = null;
+
+        /** Each subrule/rule is a decision point and we must track them so we
+         *  can go back later and build DFA predictors for them.  This includes
+         *  all the rules, subrules, optional blocks, ()+, ()* etc...
+         */
+        protected List<Decision> indexToDecision =
+            new List<Decision>( INITIAL_DECISION_LIST_SIZE );
+
+        /** If non-null, this is the code generator we will use to generate
+         *  recognizers in the target language.
+         */
+        protected internal CodeGenerator generator;
+
+        public NameSpaceChecker nameSpaceChecker;
+
+        public LL1Analyzer ll1Analyzer;
+
+        /** For merged lexer/parsers, we must construct a separate lexer spec.
+         *  This is the template for lexer; put the literals first then the
+         *  regular rules.  We don't need to specify a token vocab import as
+         *  I make the new grammar import from the old all in memory; don't want
+         *  to force it to read from the disk.  Lexer grammar will have same
+         *  name as original grammar but will be in different filename.  Foo.g
+         *  with combined grammar will have FooParser.java generated and
+         *  Foo__.g with again Foo inside.  It will however generate FooLexer.java
+         *  as it's a lexer grammar.  A bit odd, but autogenerated.  Can tweak
+         *  later if we want.
+         */
+        protected StringTemplate lexerGrammarST =
+            new StringTemplate(
+                "lexer grammar <name>;\n" +
+                "<if(options)>" +
+                "options {\n" +
+                "  <options:{<it.name>=<it.value>;<\\n>}>\n" +
+                "}<\\n>\n" +
+                "<endif>\n" +
+                "<if(imports)>import <imports; separator=\", \">;<endif>\n" +
+                "<actionNames,actions:{n,a|@<n> {<a>}\n}>\n" +
+                "<literals:{<it.ruleName> : <it.literal> ;\n}>\n" +
+                "<rules>",
+                typeof( AngleBracketTemplateLexer )
+            );
+
+        /** What file name holds this grammar? */
+        protected internal string fileName;
+
+        /** How long in ms did it take to build DFAs for this grammar?
+         *  If this grammar is a combined grammar, it only records time for
+         *  the parser grammar component.  This only records the time to
+         *  do the LL(*) work; NFA->DFA conversion.
+         */
+        public TimeSpan DFACreationWallClockTimeInMS;
+
+        public int numberOfSemanticPredicates = 0;
+        public int numberOfManualLookaheadOptions = 0;
+        public HashSet<int> setOfNondeterministicDecisionNumbers = new HashSet<int>();
+        public HashSet<int> setOfNondeterministicDecisionNumbersResolvedWithPredicates =
+            new HashSet<int>();
+        public HashSet<DFA> setOfDFAWhoseAnalysisTimedOut = new HashSet<DFA>();
+
+        /** Track decisions with syn preds specified for reporting.
+         *  This is the a set of BLOCK type AST nodes.
+         */
+        public HashSet<GrammarAST> blocksWithSynPreds = new HashSet<GrammarAST>();
+
+        /** Track decisions that actually use the syn preds in the DFA.
+         *  Computed during NFA to DFA conversion.
+         */
+        public HashSet<DFA> decisionsWhoseDFAsUsesSynPreds = new HashSet<DFA>();
+
+        /** Track names of preds so we can avoid generating preds that aren't used
+         *  Computed during NFA to DFA conversion.  Just walk accept states
+         *  and look for synpreds because that is the only state target whose
+         *  incident edges can have synpreds.  Same is try for
+         *  decisionsWhoseDFAsUsesSynPreds.
+         */
+        public HashSet<string> synPredNamesUsedInDFA = new HashSet<string>();
+
+        /** Track decisions with syn preds specified for reporting.
+         *  This is the a set of BLOCK type AST nodes.
+         */
+        public HashSet<GrammarAST> blocksWithSemPreds = new HashSet<GrammarAST>();
+
+        /** Track decisions that actually use the syn preds in the DFA. */
+        public HashSet<DFA> decisionsWhoseDFAsUsesSemPreds = new HashSet<DFA>();
+
+        protected bool allDecisionDFACreated = false;
+
+        /** We need a way to detect when a lexer grammar is autogenerated from
+         *  another grammar or we are just sending in a string representing a
+         *  grammar.  We don't want to generate a .tokens file, for example,
+         *  in such cases.
+         */
+        protected bool builtFromString = false;
+
+        /** Factored out the sanity checking code; delegate to it. */
+        internal GrammarSanity sanity;
+
+        /** Create a grammar from file name.  */
+        public Grammar( Tool tool, string fileName, CompositeGrammar composite )
+        {
+            nameSpaceChecker = new NameSpaceChecker( this );
+            ll1Analyzer = new LL1Analyzer( this );
+            sanity = new GrammarSanity( this );
+
+            this.composite = composite;
+            Tool = tool;
+            FileName = fileName;
+            // ensure we have the composite set to something
+            if ( composite.delegateGrammarTreeRoot == null )
+            {
+                composite.setDelegationRoot( this );
+            }
+        }
+
+        /** Useful for when you are sure that you are not part of a composite
+         *  already.  Used in Interp/RandomPhrase and testing.
+         */
+        public Grammar()
+        {
+            nameSpaceChecker = new NameSpaceChecker( this );
+            ll1Analyzer = new LL1Analyzer( this );
+            sanity = new GrammarSanity( this );
+
+            builtFromString = true;
+            composite = new CompositeGrammar( this );
+        }
+
+        /** Used for testing; only useful on noncomposite grammars.*/
+        public Grammar( string grammarString )
+            : this( null, grammarString )
+        {
+        }
+
+        /** Used for testing and Interp/RandomPhrase.  Only useful on
+         *  noncomposite grammars.
+         */
+        public Grammar( Tool tool, string grammarString )
+            : this()
+        {
+            Tool = tool;
+            FileName = "<string>";
+            StringReader r = new StringReader( grammarString );
+            parseAndBuildAST( r );
+            composite.assignTokenTypes();
+            defineGrammarSymbols();
+            checkNameSpaceAndActions();
+        }
+
+        #region Properties
+        public IDictionary<string, IDictionary<string, object>> Actions
+        {
+            get
+            {
+                return actions;
+            }
+        }
+        /** If there is a char vocabulary, use it; else return min to max char
+         *  as defined by the target.  If no target, use max unicode char value.
+         */
+        public IIntSet AllCharValues
+        {
+            get
+            {
+                if ( charVocabulary != null )
+                {
+                    return charVocabulary;
+                }
+                IIntSet allChar = IntervalSet.of( Label.MIN_CHAR_VALUE, MaxCharValue );
+                return allChar;
+            }
+        }
+        public bool AllDecisionDFAHaveBeenCreated
+        {
+            get
+            {
+                return allDecisionDFACreated;
+            }
+        }
+        public bool BuildAST
+        {
+            get
+            {
+                string outputType = (string)getOption( "output" );
+                if ( outputType != null )
+                {
+                    return outputType.Equals( "AST" );
+                }
+                return false;
+            }
+        }
+        public bool BuildTemplate
+        {
+            get
+            {
+                string outputType = (string)getOption( "output" );
+                if ( outputType != null )
+                {
+                    return outputType.Equals( "template" );
+                }
+                return false;
+            }
+        }
+        public CodeGenerator CodeGenerator
+        {
+            get
+            {
+                return generator;
+            }
+        }
+        public ICollection<Rule> DelegatedRuleReferences
+        {
+            get
+            {
+                return getDelegatedRuleReferences();
+            }
+        }
+        public ICollection<Grammar> Delegates
+        {
+            get
+            {
+                return getDelegates();
+            }
+        }
+        /** Who's my direct parent grammar? */
+        public Grammar Delegator
+        {
+            get
+            {
+                return composite.getDelegator( this );
+            }
+        }
+        public ICollection<Grammar> Delegators
+        {
+            get
+            {
+                return getDelegators();
+            }
+        }
+        public ICollection<Grammar> DirectDelegates
+        {
+            get
+            {
+                return getDirectDelegates();
+            }
+        }
+        public string FileName
+        {
+            get
+            {
+                return fileName;
+            }
+            set
+            {
+                fileName = value;
+            }
+        }
+        public IDictionary<string, AttributeScope> GlobalScopes
+        {
+            get
+            {
+                return scopes;
+            }
+        }
+        public string GrammarTypeString
+        {
+            get
+            {
+                return grammarTypeToString[type];
+            }
+        }
+        public string ImplicitlyGeneratedLexerFileName
+        {
+            get
+            {
+                return name +
+                       IGNORE_STRING_IN_GRAMMAR_FILE_NAME +
+                       LEXER_GRAMMAR_FILE_EXTENSION;
+            }
+        }
+        public ICollection<Grammar> IndirectDelegates
+        {
+            get
+            {
+                return getIndirectDelegates();
+            }
+        }
+        public bool IsBuiltFromString
+        {
+            get
+            {
+                return builtFromString;
+            }
+        }
+        public bool IsRoot
+        {
+            get
+            {
+                return composite.delegateGrammarTreeRoot.grammar == this;
+            }
+        }
+        public IDictionary<string, DFA> LineColumnToLookaheadDFAMap
+        {
+            get
+            {
+                return lineColumnToLookaheadDFAMap;
+            }
+        }
+        /** What is the max char value possible for this grammar's target?  Use
+         *  unicode max if no target defined.
+         */
+        public int MaxCharValue
+        {
+            get
+            {
+                if ( generator != null )
+                {
+                    return generator.target.getMaxCharValue( generator );
+                }
+                else
+                {
+                    return Label.MAX_CHAR_VALUE;
+                }
+            }
+        }
+        /** How many token types have been allocated so far? */
+        public int MaxTokenType
+        {
+            get
+            {
+                return composite.maxTokenType;
+            }
+        }
+        public int MaxLookahead
+        {
+            get
+            {
+                return getGrammarMaxLookahead();
+            }
+        }
+        public int NumberOfDecisions
+        {
+            get
+            {
+                return decisionCount;
+            }
+        }
+        public string RecognizerName
+        {
+            get
+            {
+                return getRecognizerName();
+            }
+        }
+        public bool RewriteMode
+        {
+            get
+            {
+                string outputType = (string)getOption( "rewrite" );
+                if ( outputType != null )
+                {
+                    return outputType.Equals( "true" );
+                }
+                return false;
+            }
+        }
+        public ICollection<Rule> Rules
+        {
+            get
+            {
+                return nameToRuleMap.Values;
+            }
+        }
+        /** Get the list of ANTLR String literals */
+        public ICollection<string> StringLiterals
+        {
+            get
+            {
+                return composite.stringLiteralToTypeMap.Keys;
+            }
+        }
+        public IDictionary<string, GrammarAST> SyntacticPredicates
+        {
+            get
+            {
+                return nameToSynpredASTMap;
+            }
+        }
+        /** Get the list of tokens that are IDs like BLOCK and LPAREN */
+        public ICollection<string> TokenIDs
+        {
+            get
+            {
+                return composite.tokenIDToTypeMap.Keys;
+            }
+        }
+        /** Return a set of all possible token or char types for this grammar */
+        public IIntSet TokenTypes
+        {
+            get
+            {
+                if ( type == LEXER )
+                {
+                    return AllCharValues;
+                }
+                return IntervalSet.of( Label.MIN_TOKEN_TYPE, MaxTokenType );
+            }
+        }
+        public AntlrTool Tool
+        {
+            get
+            {
+                return tool;
+            }
+            set
+            {
+                tool = value;
+            }
+        }
+        public GrammarAST Tree
+        {
+            get
+            {
+                return grammarTree;
+            }
+        }
+        #endregion
+
+        [System.Obsolete]
+        public virtual void setFileName( string fileName )
+        {
+            FileName = fileName;
+        }
+
+        [System.Obsolete]
+        public string getFileName()
+        {
+            return FileName;
+        }
+
+        public virtual void setName( string name )
+        {
+            if ( name == null )
+            {
+                return;
+            }
+            // don't error check autogenerated files (those with '__' in them)
+            //String saneFile = fileName.replace( '\\', '/' );
+            //int lastSlash = saneFile.lastIndexOf( '/' );
+            //String onlyFileName = saneFile.substring( lastSlash + 1, fileName.length() );
+            //string onlyFileName = fileName;
+            //if ( builtFromString )
+            //{
+            //    string saneFile = fileName.Replace( '\\', '/' );
+            //    onlyFileName = saneFile.Split( '/' ).LastOrDefault();
+            //}
+            if ( !builtFromString )
+            {
+                string onlyFileName = System.IO.Path.GetFileName( fileName );
+                string onlyFileNameNoSuffix = System.IO.Path.GetFileNameWithoutExtension( onlyFileName );
+
+                //int lastDot = onlyFileName.lastIndexOf( '.' );
+                //String onlyFileNameNoSuffix = null;
+                if ( onlyFileNameNoSuffix == onlyFileName )
+                {
+                    ErrorManager.error( ErrorManager.MSG_FILENAME_EXTENSION_ERROR, fileName );
+                    onlyFileNameNoSuffix = onlyFileName + GRAMMAR_FILE_EXTENSION;
+                }
+                else
+                {
+                    //onlyFileNameNoSuffix = onlyFileName.substring( 0, lastDot );
+                }
+                if ( !name.Equals( onlyFileNameNoSuffix ) )
+                {
+                    ErrorManager.error( ErrorManager.MSG_FILE_AND_GRAMMAR_NAME_DIFFER,
+                                       name,
+                                       fileName );
+                }
+            }
+            this.name = name;
+        }
+
+        public virtual void setGrammarContent( string grammarString )
+        {
+            StringReader r = new StringReader( grammarString );
+            parseAndBuildAST( r );
+            composite.assignTokenTypes();
+            composite.defineGrammarSymbols();
+        }
+
+        public virtual void parseAndBuildAST()
+        {
+            using ( System.IO.TextReader reader = System.IO.File.OpenText( fileName ) )
+            {
+                parseAndBuildAST( reader );
+            }
+        }
+
+        class TokenStreamRewriteEngine : Antlr.Runtime.ITokenSource
+        {
+            Antlr.Runtime.ITokenSource _source;
+            int[] _discard;
+
+            public TokenStreamRewriteEngine( Antlr.Runtime.ITokenSource source )
+            {
+                _source = source;
+            }
+
+            public virtual void Discard( params int[] tokenKinds )
+            {
+                _discard = (int[])tokenKinds.Clone();
+            }
+
+            #region TokenSource Members
+            public IToken NextToken()
+            {
+                IToken next = _source.NextToken();
+                while ( next != null && _discard.Contains( next.Type ) )
+                    next = _source.NextToken();
+
+                return next;
+            }
+            public string SourceName
+            {
+                get
+                {
+                    return _source.SourceName;
+                }
+            }
+            public string[] TokenNames
+            {
+                get
+                {
+                    return _source.TokenNames;
+                }
+            }
+            #endregion
+        }
+
+        public virtual void parseAndBuildAST( TextReader r )
+        {
+            // BUILD AST FROM GRAMMAR
+            ANTLRLexer lexer = new ANTLRLexer( new Antlr.Runtime.ANTLRReaderStream( r ) );
+            lexer.Filename = this.FileName;
+            // use the rewrite engine because we want to buffer up all tokens
+            // in case they have a merged lexer/parser, send lexer rules to
+            // new grammar.
+            //lexer.setTokenObjectClass( "antlr.TokenWithIndex" );
+            tokenBuffer = new Antlr.Runtime.CommonTokenStream( lexer );
+            //tokenBuffer = new TokenStreamRewriteEngine( lexer );
+            //tokenBuffer.Discard( ANTLRParser.WS, ANTLRParser.ML_COMMENT, ANTLRParser.COMMENT, ANTLRParser.SL_COMMENT );
+            //tokenBuffer.discard( ANTLRParser.WS );
+            //tokenBuffer.discard( ANTLRParser.ML_COMMENT );
+            //tokenBuffer.discard( ANTLRParser.COMMENT );
+            //tokenBuffer.discard( ANTLRParser.SL_COMMENT );
+            ANTLRParser parser = new ANTLRParser( tokenBuffer );
+            parser.FileName = this.FileName;
+            ANTLRParser.grammar__return result = null;
+            try
+            {
+                result = parser.grammar_( this );
+            }
+            //catch ( TokenStreamException tse )
+            //{
+            //    ErrorManager.internalError( "unexpected stream error from parsing " + fileName, tse );
+            //}
+            catch ( RecognitionException re )
+            {
+                ErrorManager.internalError( "unexpected parser recognition error from " + fileName, re );
+            }
+
+            dealWithTreeFilterMode(); // tree grammar and filter=true?
+
+            if ( lexer.hasASTOperator && !BuildAST )
+            {
+                object value = getOption( "output" );
+                if ( value == null )
+                {
+                    ErrorManager.grammarWarning( ErrorManager.MSG_REWRITE_OR_OP_WITH_NO_OUTPUT_OPTION,
+                                                this, null );
+                    setOption( "output", "AST", null );
+                }
+                else
+                {
+                    ErrorManager.grammarError( ErrorManager.MSG_AST_OP_WITH_NON_AST_OUTPUT_OPTION,
+                                              this, null, value );
+                }
+            }
+
+            //grammarTree = (GrammarAST)parser.getAST();
+            grammarTree = (GrammarAST)result.tree;
+            FileName = lexer.Filename; // the lexer #src might change name
+            if ( grammarTree == null || grammarTree.findFirstType( ANTLRParser.RULE ) == null )
+            {
+                ErrorManager.error( ErrorManager.MSG_NO_RULES, FileName );
+                return;
+            }
+
+            // Get syn pred rules and add to existing tree
+            IList<GrammarAST> synpredRules =
+                getArtificialRulesForSyntacticPredicates( parser,
+                                                         nameToSynpredASTMap );
+            for ( int i = 0; i < synpredRules.Count; i++ )
+            {
+                GrammarAST rAST = (GrammarAST)synpredRules[i];
+                grammarTree.AddChild( rAST );
+            }
+        }
+
+        protected virtual void dealWithTreeFilterMode()
+        {
+            object filterMode = (string)getOption( "filter" );
+            if ( type == TREE_PARSER && filterMode != null && filterMode.ToString().Equals( "true" ) )
+            {
+                // check for conflicting options
+                // filter => backtrack=true
+                // filter&&output=AST => rewrite=true
+                // filter&&output!=AST => error
+                // any deviation from valid option set is an error
+                object backtrack = (string)getOption( "backtrack" );
+                object output = getOption( "output" );
+                object rewrite = getOption( "rewrite" );
+                if ( backtrack != null && !backtrack.ToString().Equals( "true" ) )
+                {
+                    ErrorManager.error( ErrorManager.MSG_CONFLICTING_OPTION_IN_TREE_FILTER,
+                                       "backtrack", backtrack );
+                }
+                if ( output != null && !output.ToString().Equals( "AST" ) )
+                {
+                    ErrorManager.error( ErrorManager.MSG_CONFLICTING_OPTION_IN_TREE_FILTER,
+                                       "output", output );
+                    setOption( "output", "", null );
+                }
+                if ( rewrite != null && !rewrite.ToString().Equals( "true" ) )
+                {
+                    ErrorManager.error( ErrorManager.MSG_CONFLICTING_OPTION_IN_TREE_FILTER,
+                                       "rewrite", rewrite );
+                }
+                // set options properly
+                setOption( "backtrack", true, null );
+                if ( output != null && output.ToString().Equals( "AST" ) )
+                {
+                    setOption( "rewrite", true, null );
+                }
+                // @synpredgate set to state.backtracking==1 by code gen when filter=true
+                // superClass set in template target::treeParser
+            }
+        }
+
+        public virtual void defineGrammarSymbols()
+        {
+            if ( Tool.internalOption_PrintGrammarTree )
+            {
+                Console.Out.WriteLine( grammarTree.ToStringList() );
+            }
+
+            // DEFINE RULES
+            //JSystem.@out.println("### define "+name+" rules");
+            DefineGrammarItemsWalker defineItemsWalker = new DefineGrammarItemsWalker( new Antlr.Runtime.Tree.CommonTreeNodeStream( grammarTree ) );
+            //defineItemsWalker.setASTNodeClass( "org.antlr.tool.GrammarAST" );
+            try
+            {
+                defineItemsWalker.grammar_( this );
+            }
+            catch ( RecognitionException re )
+            {
+                ErrorManager.error( ErrorManager.MSG_BAD_AST_STRUCTURE,
+                                   re );
+            }
+        }
+
+        /** ANALYZE ACTIONS, LOOKING FOR LABEL AND ATTR REFS, sanity check */
+        public virtual void checkNameSpaceAndActions()
+        {
+            examineAllExecutableActions();
+            checkAllRulesForUselessLabels();
+
+            nameSpaceChecker.checkConflicts();
+        }
+
+        /** Many imports are illegal such as lexer into a tree grammar */
+        public virtual bool validImport( Grammar @delegate )
+        {
+            IList<int> validDelegators = validDelegations.get( @delegate.type );
+            return validDelegators != null && validDelegators.Contains( this.type );
+        }
+
+        /** If the grammar is a combined grammar, return the text of the implicit
+         *  lexer grammar.
+         */
+        public virtual string getLexerGrammar()
+        {
+            if ( lexerGrammarST.getAttribute( "literals" ) == null &&
+                 lexerGrammarST.getAttribute( "rules" ) == null )
+            {
+                // if no rules, return nothing
+                return null;
+            }
+            lexerGrammarST.setAttribute( "name", name );
+            // if there are any actions set for lexer, pass them in
+            if ( actions.get( "lexer" ) != null )
+            {
+                lexerGrammarST.setAttribute( "actionNames",
+                                            ( (IDictionary)actions.get( "lexer" ) ).Keys );
+                lexerGrammarST.setAttribute( "actions",
+                                            ( (IDictionary)actions.get( "lexer" ) ).Values );
+            }
+            // make sure generated grammar has the same options
+            if ( options != null )
+            {
+                foreach ( var option in options )
+                {
+                    string optionName = option.Key;
+                    if ( !doNotCopyOptionsToLexer.Contains( optionName ) )
+                    {
+                        object value = option.Value;
+                        lexerGrammarST.setAttribute( "options.{name,value}", optionName, value );
+                    }
+                }
+            }
+            return lexerGrammarST.ToString();
+        }
+
+        [System.Obsolete]
+        public string getImplicitlyGeneratedLexerFileName()
+        {
+            return ImplicitlyGeneratedLexerFileName;
+        }
+
+        /** Get the name of the generated recognizer; may or may not be same
+         *  as grammar name.
+         *  Recognizer is TParser and TLexer from T if combined, else
+         *  just use T regardless of grammar type.
+         */
+        public virtual string getRecognizerName()
+        {
+            string suffix = "";
+            IList<Grammar> grammarsFromRootToMe = composite.getDelegators( this );
+            //JSystem.@out.println("grammarsFromRootToMe="+grammarsFromRootToMe);
+            string qualifiedName = name;
+            if ( grammarsFromRootToMe != null )
+            {
+                StringBuilder buf = new StringBuilder();
+                foreach ( Grammar g in grammarsFromRootToMe )
+                {
+                    buf.Append( g.name );
+                    buf.Append( '_' );
+                }
+                buf.Append( name );
+                qualifiedName = buf.ToString();
+            }
+            if ( type == Grammar.COMBINED ||
+                 ( type == Grammar.LEXER && implicitLexer ) )
+            {
+                suffix = Grammar.grammarTypeToFileNameSuffix[type];
+            }
+            return qualifiedName + suffix;
+        }
+
+        /** Parse a rule we add artificially that is a list of the other lexer
+         *  rules like this: "Tokens : ID | INT | SEMI ;"  nextToken() will invoke
+         *  this to set the current token.  Add char literals before
+         *  the rule references.
+         *
+         *  If in filter mode, we want every alt to backtrack and we need to
+         *  do k=1 to force the "first token def wins" rule.  Otherwise, the
+         *  longest-match rule comes into play with LL(*).
+         *
+         *  The ANTLRParser antlr.g file now invokes this when parsing a lexer
+         *  grammar, which I think is proper even though it peeks at the info
+         *  that later phases will (re)compute.  It gets a list of lexer rules
+         *  and builds a string representing the rule; then it creates a parser
+         *  and adds the resulting tree to the grammar's tree.
+         */
+        public GrammarAST addArtificialMatchTokensRule( GrammarAST grammarAST,
+                                                       IList<string> ruleNames,
+                                                       IList<string> delegateNames,
+                                                       bool filterMode )
+        {
+            StringTemplate matchTokenRuleST = null;
+            if ( filterMode )
+            {
+                matchTokenRuleST = new StringTemplate(
+                        ARTIFICIAL_TOKENS_RULENAME +
+                        " options {k=1; backtrack=true;} : <rules; separator=\"|\">;",
+                        typeof( AngleBracketTemplateLexer ) );
+            }
+            else
+            {
+                matchTokenRuleST = new StringTemplate(
+                        ARTIFICIAL_TOKENS_RULENAME + " : <rules; separator=\"|\">;",
+                        typeof( AngleBracketTemplateLexer ) );
+            }
+
+            // Now add token rule references
+            for ( int i = 0; i < ruleNames.Count; i++ )
+            {
+                string rname = (string)ruleNames[i];
+                matchTokenRuleST.setAttribute( "rules", rname );
+            }
+            for ( int i = 0; i < delegateNames.Count; i++ )
+            {
+                string dname = (string)delegateNames[i];
+                matchTokenRuleST.setAttribute( "rules", dname + ".Tokens" );
+            }
+            //JSystem.@out.println("tokens rule: "+matchTokenRuleST.toString());
+
+            //ANTLRLexer lexer = new ANTLRLexer( new StringReader( matchTokenRuleST.toString() ) );
+            //lexer.setTokenObjectClass( "antlr.TokenWithIndex" );
+            //TokenStreamRewriteEngine tokbuf =
+            //    new TokenStreamRewriteEngine( lexer );
+            //tokbuf.discard( ANTLRParser.WS );
+            //tokbuf.discard( ANTLRParser.ML_COMMENT );
+            //tokbuf.discard( ANTLRParser.COMMENT );
+            //tokbuf.discard( ANTLRParser.SL_COMMENT );
+            //ANTLRParser parser = new ANTLRParser( tokbuf );
+            ANTLRLexer lexer = new ANTLRLexer( new Antlr.Runtime.ANTLRStringStream( matchTokenRuleST.ToString() ) );
+            TokenStreamRewriteEngine tokbuf = new TokenStreamRewriteEngine( lexer );
+            tokbuf.Discard( ANTLRParser.WS, ANTLRParser.ML_COMMENT, ANTLRParser.COMMENT, ANTLRParser.SL_COMMENT );
+            ANTLRParser parser = new ANTLRParser( new Antlr.Runtime.CommonTokenStream( tokbuf ) );
+
+            parser.Grammar = this;
+            parser.GrammarType = ANTLRParser.LEXER_GRAMMAR;
+            ANTLRParser.rule_return result = null;
+            try
+            {
+                result = parser.rule();
+                if ( Tool.internalOption_PrintGrammarTree )
+                {
+                    Console.Out.WriteLine( "Tokens rule: " + ( (ITree)result.Tree ).ToStringTree() );
+                }
+                GrammarAST p = grammarAST;
+                while ( p.Type != ANTLRParser.LEXER_GRAMMAR )
+                {
+                    p = (GrammarAST)p.getNextSibling();
+                }
+                p.AddChild( (Antlr.Runtime.Tree.ITree)result.Tree );
+            }
+            catch ( Exception e )
+            {
+                ErrorManager.error( ErrorManager.MSG_ERROR_CREATING_ARTIFICIAL_RULE,
+                                   e );
+            }
+            return (GrammarAST)result.Tree;
+        }
+
+        /** for any syntactic predicates, we need to define rules for them; they will get
+         *  defined automatically like any other rule. :)
+         */
+        protected virtual IList<GrammarAST> getArtificialRulesForSyntacticPredicates( ANTLRParser parser,
+                                                                IDictionary<string, GrammarAST> nameToSynpredASTMap )
+        {
+            IList<GrammarAST> rules = new List<GrammarAST>();
+            if ( nameToSynpredASTMap == null )
+            {
+                return rules;
+            }
+            bool isLexer = grammarTree.Type == ANTLRParser.LEXER_GRAMMAR;
+            foreach ( var synpred in nameToSynpredASTMap )
+            {
+                string synpredName = synpred.Key;
+                GrammarAST fragmentAST = (GrammarAST)synpred.Value;
+                GrammarAST ruleAST =
+                    parser.createSimpleRuleAST( synpredName,
+                                               fragmentAST,
+                                               isLexer );
+                rules.Add( ruleAST );
+            }
+            return rules;
+        }
+
+        /** Walk the list of options, altering this Grammar object according
+         *  to any I recognize.
+        protected void processOptions() {
+            Iterator optionNames = options.keySet().iterator();
+            while (optionNames.hasNext()) {
+                String optionName = (String) optionNames.next();
+                Object value = options.get(optionName);
+                if ( optionName.equals("tokenVocab") ) {
+
+                }
+            }
+        }
+         */
+
+        /** Define all the rule begin/end NFAStates to solve forward reference
+         *  issues.  Critical for composite grammars too.
+         *  This is normally called on all root/delegates manually and then
+         *  buildNFA() is called afterwards because the NFA construction needs
+         *  to see rule start/stop states from potentially every grammar. Has
+         *  to be have these created a priori.  Testing routines will often
+         *  just call buildNFA(), which forces a call to this method if not
+         *  done already. Works ONLY for single noncomposite grammars.
+         */
+        public virtual void createRuleStartAndStopNFAStates()
+        {
+            //JSystem.@out.println("### createRuleStartAndStopNFAStates "+getGrammarTypeString()+" grammar "+name+" NFAs");
+            if ( nfa != null )
+            {
+                return;
+            }
+            nfa = new NFA( this );
+            factory = new NFAFactory( nfa );
+
+            foreach ( Rule r in Rules )
+            {
+                string ruleName = r.name;
+                NFAState ruleBeginState = factory.newState();
+                ruleBeginState.Description = "rule " + ruleName + " start";
+                ruleBeginState.enclosingRule = r;
+                r.startState = ruleBeginState;
+                NFAState ruleEndState = factory.newState();
+                ruleEndState.Description = "rule " + ruleName + " end";
+                ruleEndState.IsAcceptState = true;
+                ruleEndState.enclosingRule = r;
+                r.stopState = ruleEndState;
+            }
+        }
+
+        public virtual void buildNFA()
+        {
+            if ( nfa == null )
+            {
+                createRuleStartAndStopNFAStates();
+            }
+            if ( nfa.complete )
+            {
+                // don't let it create more than once; has side-effects
+                return;
+            }
+            //JSystem.@out.println("### build "+getGrammarTypeString()+" grammar "+name+" NFAs");
+            if ( Rules.Count == 0 )
+            {
+                return;
+            }
+
+            Antlr.Runtime.Tree.ITreeNodeStream input = new Antlr.Runtime.Tree.CommonTreeNodeStream( grammarTree );
+            TreeToNFAConverter nfaBuilder = new TreeToNFAConverter( this, nfa, factory, input );
+            try
+            {
+                nfaBuilder.grammar_();
+            }
+            catch ( RecognitionException re )
+            {
+                ErrorManager.error( ErrorManager.MSG_BAD_AST_STRUCTURE,
+                                   name,
+                                   re );
+            }
+            nfa.complete = true;
+        }
+
+        /** For each decision in this grammar, compute a single DFA using the
+         *  NFA states associated with the decision.  The DFA construction
+         *  determines whether or not the alternatives in the decision are
+         *  separable using a regular lookahead language.
+         *
+         *  Store the lookahead DFAs in the AST created from the user's grammar
+         *  so the code generator or whoever can easily access it.
+         *
+         *  This is a separate method because you might want to create a
+         *  Grammar without doing the expensive analysis.
+         */
+        public virtual void createLookaheadDFAs()
+        {
+            createLookaheadDFAs( true );
+        }
+
+        public virtual void createLookaheadDFAs( bool wackTempStructures )
+        {
+            if ( nfa == null )
+            {
+                buildNFA();
+            }
+
+            // CHECK FOR LEFT RECURSION; Make sure we can actually do analysis
+            checkAllRulesForLeftRecursion();
+
+            /*
+            // was there a severe problem while sniffing the grammar?
+            if ( ErrorManager.doNotAttemptAnalysis() ) {
+                return;
+            }
+            */
+
+            DateTime start = DateTime.Now;
+
+            //JSystem.@out.println("### create DFAs");
+            int numDecisions = NumberOfDecisions;
+            if ( NFAToDFAConverter.SINGLE_THREADED_NFA_CONVERSION )
+            {
+                for ( int decision = 1; decision <= numDecisions; decision++ )
+                {
+                    NFAState decisionStartState = getDecisionNFAStartState( decision );
+                    if ( leftRecursiveRules.Contains( decisionStartState.enclosingRule ) )
+                    {
+                        // don't bother to process decisions within left recursive rules.
+                        if ( composite.watchNFAConversion )
+                        {
+                            Console.Out.WriteLine( "ignoring decision " + decision +
+                                               " within left-recursive rule " + decisionStartState.enclosingRule.name );
+                        }
+                        continue;
+                    }
+                    if ( !externalAnalysisAbort && decisionStartState.NumberOfTransitions > 1 )
+                    {
+                        Rule r = decisionStartState.enclosingRule;
+                        if ( r.isSynPred && !synPredNamesUsedInDFA.Contains( r.name ) )
+                        {
+                            continue;
+                        }
+                        DFA dfa = null;
+                        // if k=* or k=1, try LL(1)
+                        if ( getUserMaxLookahead( decision ) == 0 ||
+                             getUserMaxLookahead( decision ) == 1 )
+                        {
+                            dfa = createLL_1_LookaheadDFA( decision );
+                        }
+                        if ( dfa == null )
+                        {
+                            if ( composite.watchNFAConversion )
+                            {
+                                Console.Out.WriteLine( "decision " + decision +
+                                                   " not suitable for LL(1)-optimized DFA analysis" );
+                            }
+                            dfa = createLookaheadDFA( decision, wackTempStructures );
+                        }
+                        if ( dfa.startState == null )
+                        {
+                            // something went wrong; wipe out DFA
+                            setLookaheadDFA( decision, null );
+                        }
+                        if ( Tool.internalOption_PrintDFA )
+                        {
+                            Console.Out.WriteLine( "DFA d=" + decision );
+                            FASerializer serializer = new FASerializer( nfa.grammar );
+                            string result = serializer.serialize( dfa.startState );
+                            Console.Out.WriteLine( result );
+                        }
+                    }
+                }
+            }
+            else
+            {
+                ErrorManager.info( "two-threaded DFA conversion" );
+                // create a barrier expecting n DFA and this main creation thread
+                Barrier barrier = new Barrier( 3 );
+                // assume 2 CPU for now
+                int midpoint = numDecisions / 2;
+                NFAConversionThread t1 =
+                    new NFAConversionThread( this, barrier, 1, midpoint );
+                new System.Threading.Thread( t1.run ).Start();
+                //new Thread( t1 ).start();
+                if ( midpoint == ( numDecisions / 2 ) )
+                {
+                    midpoint++;
+                }
+                NFAConversionThread t2 =
+                    new NFAConversionThread( this, barrier, midpoint, numDecisions );
+                new System.Threading.Thread( t2.run ).Start();
+                //new Thread( t2 ).start();
+                // wait for these two threads to finish
+                try
+                {
+                    barrier.waitForRelease();
+                }
+                //catch ( InterruptedException e )
+                //{
+                //    ErrorManager.internalError( "what the hell? DFA interruptus", e );
+                //}
+                catch
+                {
+                    throw new System.NotImplementedException();
+                }
+            }
+
+            DateTime stop = DateTime.Now;
+            DFACreationWallClockTimeInMS = stop - start;
+
+            // indicate that we've finished building DFA (even if #decisions==0)
+            allDecisionDFACreated = true;
+        }
+
+        public virtual DFA createLL_1_LookaheadDFA( int decision )
+        {
+            Decision d = getDecision( decision );
+            string enclosingRule = d.startState.enclosingRule.name;
+            Rule r = d.startState.enclosingRule;
+            NFAState decisionStartState = getDecisionNFAStartState( decision );
+
+            if ( composite.watchNFAConversion )
+            {
+                Console.Out.WriteLine( "--------------------\nattempting LL(1) DFA (d="
+                                   + decisionStartState.DecisionNumber + ") for " +
+                                   decisionStartState.Description );
+            }
+
+            if ( r.isSynPred && !synPredNamesUsedInDFA.Contains( enclosingRule ) )
+            {
+                return null;
+            }
+
+            // compute lookahead for each alt
+            int numAlts = getNumberOfAltsForDecisionNFA( decisionStartState );
+            LookaheadSet[] altLook = new LookaheadSet[numAlts + 1];
+            for ( int alt = 1; alt <= numAlts; alt++ )
+            {
+                int walkAlt =
+                    decisionStartState.translateDisplayAltToWalkAlt( alt );
+                NFAState altLeftEdge = getNFAStateForAltOfDecision( decisionStartState, walkAlt );
+                NFAState altStartState = (NFAState)altLeftEdge.transition[0].target;
+                //JSystem.@out.println("alt "+alt+" start state = "+altStartState.stateNumber);
+                altLook[alt] = ll1Analyzer.LOOK( altStartState );
+                //JSystem.@out.println("alt "+alt+": "+altLook[alt].toString(this));
+            }
+
+            // compare alt i with alt j for disjointness
+            bool decisionIsLL_1 = true;
+            for ( int i = 1; i <= numAlts; i++ )
+            {
+                for ( int j = i + 1; j <= numAlts; j++ )
+                {
+                    /*
+                    JSystem.@out.println("compare "+i+", "+j+": "+
+                                       altLook[i].toString(this)+" with "+
+                                       altLook[j].toString(this));
+                    */
+                    LookaheadSet collision = altLook[i].intersection( altLook[j] );
+                    if ( !collision.IsNil )
+                    {
+                        //JSystem.@out.println("collision (non-LL(1)): "+collision.toString(this));
+                        decisionIsLL_1 = false;
+                        goto outer;
+                    }
+                }
+            }
+
+        outer:
+            bool foundConfoundingPredicate =
+                ll1Analyzer.detectConfoundingPredicates( decisionStartState );
+            if ( decisionIsLL_1 && !foundConfoundingPredicate )
+            {
+                // build an LL(1) optimized DFA with edge for each altLook[i]
+                if ( NFAToDFAConverter.debug )
+                {
+                    Console.Out.WriteLine( "decision " + decision + " is simple LL(1)" );
+                }
+                DFA lookaheadDFA2 = new LL1DFA( decision, decisionStartState, altLook );
+                setLookaheadDFA( decision, lookaheadDFA2 );
+                updateLineColumnToLookaheadDFAMap( lookaheadDFA2 );
+                return lookaheadDFA2;
+            }
+
+            // not LL(1) but perhaps we can solve with simplified predicate search
+            // even if k=1 set manually, only resolve here if we have preds; i.e.,
+            // don't resolve etc...
+
+            /*
+            SemanticContext visiblePredicates =
+                ll1Analyzer.getPredicates(decisionStartState);
+            boolean foundConfoundingPredicate =
+                ll1Analyzer.detectConfoundingPredicates(decisionStartState);
+                */
+
+            // exit if not forced k=1 or we found a predicate situation we
+            // can't handle: predicates in rules invoked from this decision.
+            if ( getUserMaxLookahead( decision ) != 1 || // not manually set to k=1
+                 !getAutoBacktrackMode( decision ) ||
+                 foundConfoundingPredicate )
+            {
+                //JSystem.@out.println("trying LL(*)");
+                return null;
+            }
+
+            IList<IIntSet> edges = new List<IIntSet>();
+            for ( int i = 1; i < altLook.Length; i++ )
+            {
+                LookaheadSet s = altLook[i];
+                edges.Add( (IntervalSet)s.tokenTypeSet );
+            }
+            IList<IIntSet> disjoint = makeEdgeSetsDisjoint( edges );
+            //JSystem.@out.println("disjoint="+disjoint);
+
+            MultiMap<IntervalSet, int> edgeMap = new MultiMap<IntervalSet, int>();
+            for ( int i = 0; i < disjoint.Count; i++ )
+            {
+                IntervalSet ds = (IntervalSet)disjoint[i];
+                for ( int alt = 1; alt < altLook.Length; alt++ )
+                {
+                    LookaheadSet look = altLook[alt];
+                    if ( !ds.and( look.tokenTypeSet ).isNil() )
+                    {
+                        edgeMap.map( ds, alt );
+                    }
+                }
+            }
+            //JSystem.@out.println("edge map: "+edgeMap);
+
+            // TODO: how do we know we covered stuff?
+
+            // build an LL(1) optimized DFA with edge for each altLook[i]
+            DFA lookaheadDFA = new LL1DFA( decision, decisionStartState, edgeMap );
+            setLookaheadDFA( decision, lookaheadDFA );
+
+            // create map from line:col to decision DFA (for ANTLRWorks)
+            updateLineColumnToLookaheadDFAMap( lookaheadDFA );
+
+            return lookaheadDFA;
+        }
+
+        private void updateLineColumnToLookaheadDFAMap( DFA lookaheadDFA )
+        {
+            GrammarAST decisionAST = nfa.grammar.getDecisionBlockAST( lookaheadDFA.decisionNumber );
+            int line = decisionAST.Line;
+            int col = decisionAST.CharPositionInLine;
+            lineColumnToLookaheadDFAMap[line + ":" + col] = lookaheadDFA;
+        }
+
+        protected virtual IList<IIntSet> makeEdgeSetsDisjoint( IList<IIntSet> edges )
+        {
+            OrderedHashSet<IIntSet> disjointSets = new OrderedHashSet<IIntSet>();
+            // walk each incoming edge label/set and add to disjoint set
+            int numEdges = edges.Count;
+            for ( int e = 0; e < numEdges; e++ )
+            {
+                IntervalSet t = (IntervalSet)edges[e];
+                if ( disjointSets.Contains( t ) )
+                { // exact set present
+                    continue;
+                }
+
+                // compare t with set i for disjointness
+                IntervalSet remainder = t; // remainder starts out as whole set to add
+                int numDisjointElements = disjointSets.size();
+                for ( int i = 0; i < numDisjointElements; i++ )
+                {
+                    IntervalSet s_i = (IntervalSet)disjointSets.get( i );
+
+                    if ( t.and( s_i ).isNil() )
+                    { // nothing in common
+                        continue;
+                    }
+                    //JSystem.@out.println(label+" collides with "+rl);
+
+                    // For any (s_i, t) with s_i&t!=nil replace with (s_i-t, s_i&t)
+                    // (ignoring s_i-t if nil; don't put in list)
+
+                    // Replace existing s_i with intersection since we
+                    // know that will always be a non nil character class
+                    IntervalSet intersection = (IntervalSet)s_i.and( t );
+                    disjointSets.set( i, intersection );
+
+                    // Compute s_i-t to see what is in current set and not in incoming
+                    IIntSet existingMinusNewElements = s_i.subtract( t );
+                    //JSystem.@out.println(s_i+"-"+t+"="+existingMinusNewElements);
+                    if ( !existingMinusNewElements.isNil() )
+                    {
+                        // found a new character class, add to the end (doesn't affect
+                        // outer loop duration due to n computation a priori.
+                        disjointSets.add( existingMinusNewElements );
+                    }
+
+                    // anything left to add to the reachableLabels?
+                    remainder = (IntervalSet)t.subtract( s_i );
+                    if ( remainder.isNil() )
+                    {
+                        break; // nothing left to add to set.  done!
+                    }
+
+                    t = remainder;
+                }
+                if ( !remainder.isNil() )
+                {
+                    disjointSets.add( remainder );
+                }
+            }
+            return disjointSets.getElements();
+        }
+
+        public virtual DFA createLookaheadDFA( int decision, bool wackTempStructures )
+        {
+            Decision d = getDecision( decision );
+            string enclosingRule = d.startState.enclosingRule.name;
+            Rule r = d.startState.enclosingRule;
+
+            //JSystem.@out.println("createLookaheadDFA(): "+enclosingRule+" dec "+decision+"; synprednames prev used "+synPredNamesUsedInDFA);
+            NFAState decisionStartState = getDecisionNFAStartState( decision );
+            DateTime startDFA = DateTime.MinValue;
+            DateTime stopDFA = DateTime.MinValue;
+            if ( composite.watchNFAConversion )
+            {
+                Console.Out.WriteLine( "--------------------\nbuilding lookahead DFA (d="
+                                   + decisionStartState.DecisionNumber + ") for " +
+                                   decisionStartState.Description );
+                startDFA = DateTime.Now;
+            }
+
+            DFA lookaheadDFA = new DFA( decision, decisionStartState );
+            // Retry to create a simpler DFA if analysis failed (non-LL(*),
+            // recursion overflow, or time out).
+            bool failed =
+                lookaheadDFA.AnalysisTimedOut ||
+                lookaheadDFA.probe.IsNonLLStarDecision ||
+                lookaheadDFA.probe.AnalysisOverflowed;
+            if ( failed && lookaheadDFA.OkToRetryWithK1 )
+            {
+                // set k=1 option and try again.
+                // First, clean up tracking stuff
+                decisionsWhoseDFAsUsesSynPreds.Remove( lookaheadDFA );
+                // TODO: clean up synPredNamesUsedInDFA also (harder)
+                d.blockAST.setBlockOption( this, "k", 1 );
+                if ( composite.watchNFAConversion )
+                {
+                    Console.Out.Write( "trying decision " + decision +
+                                     " again with k=1; reason: " +
+                                     lookaheadDFA.ReasonForFailure );
+                }
+                lookaheadDFA = null; // make sure other memory is "free" before redoing
+                lookaheadDFA = new DFA( decision, decisionStartState );
+            }
+            if ( lookaheadDFA.AnalysisTimedOut )
+            { // did analysis bug out?
+                ErrorManager.internalError( "could not even do k=1 for decision " +
+                                           decision + "; reason: " +
+                                           lookaheadDFA.ReasonForFailure );
+            }
+
+
+            setLookaheadDFA( decision, lookaheadDFA );
+
+            if ( wackTempStructures )
+            {
+                foreach ( DFAState s in lookaheadDFA.UniqueStates.Values )
+                {
+                    s.reset();
+                }
+            }
+
+            // create map from line:col to decision DFA (for ANTLRWorks)
+            updateLineColumnToLookaheadDFAMap( lookaheadDFA );
+
+            if ( composite.watchNFAConversion )
+            {
+                stopDFA = DateTime.Now;
+                Console.Out.WriteLine( "cost: " + lookaheadDFA.NumberOfStates +
+                                   " states, " + (int)( stopDFA - startDFA ).TotalMilliseconds + " ms" );
+            }
+            //JSystem.@out.println("after create DFA; synPredNamesUsedInDFA="+synPredNamesUsedInDFA);
+            return lookaheadDFA;
+        }
+
+        /** Terminate DFA creation (grammar analysis).
+         */
+        public virtual void externallyAbortNFAToDFAConversion()
+        {
+            externalAnalysisAbort = true;
+        }
+
+        public virtual bool NFAToDFAConversionExternallyAborted()
+        {
+            return externalAnalysisAbort;
+        }
+
+        /** Return a new unique integer in the token type space */
+        public virtual int getNewTokenType()
+        {
+            composite.maxTokenType++;
+            return composite.maxTokenType;
+        }
+
+        /** Define a token at a particular token type value.  Blast an
+         *  old value with a new one.  This is called normal grammar processsing
+         *  and during import vocab operations to set tokens with specific values.
+         */
+        public virtual void defineToken( string text, int tokenType )
+        {
+            //JSystem.@out.println("defineToken("+text+", "+tokenType+")");
+            if ( composite.tokenIDToTypeMap.ContainsKey( text ) && composite.tokenIDToTypeMap[text] < TokenConstants.MIN_TOKEN_TYPE )
+            {
+                // already defined?  Must be predefined one like EOF;
+                // do nothing
+                return;
+            }
+            // the index in the typeToTokenList table is actually shifted to
+            // hold faux labels as you cannot have negative indices.
+            if ( text[0] == '\'' )
+            {
+                composite.stringLiteralToTypeMap[text] = tokenType;
+                // track in reverse index too
+                if ( tokenType >= composite.typeToStringLiteralList.Count )
+                {
+                    composite.typeToStringLiteralList.setSize( tokenType + 1 );
+                }
+                composite.typeToStringLiteralList[tokenType] = text;
+            }
+            else
+            { // must be a label like ID
+                composite.tokenIDToTypeMap[text] = tokenType;
+            }
+            int index = Label.NUM_FAUX_LABELS + tokenType - 1;
+            //JSystem.@out.println("defining "+name+" token "+text+" at type="+tokenType+", index="+index);
+            composite.maxTokenType = Math.Max( composite.maxTokenType, tokenType );
+            if ( index >= composite.typeToTokenList.Count )
+            {
+                composite.typeToTokenList.setSize( index + 1 );
+            }
+            string prevToken = (string)composite.typeToTokenList[index];
+            if ( prevToken == null || prevToken[0] == '\'' )
+            {
+                // only record if nothing there before or if thing before was a literal
+                composite.typeToTokenList[index] = text;
+            }
+        }
+
+        /** Define a new rule.  A new rule index is created by incrementing
+         *  ruleIndex.
+         */
+        public virtual void defineRule( IToken ruleToken,
+                               string modifier,
+                               IDictionary<string,object> options,
+                               GrammarAST tree,
+                               GrammarAST argActionAST,
+                               int numAlts )
+        {
+            string ruleName = ruleToken.Text;
+            if ( getLocallyDefinedRule( ruleName ) != null )
+            {
+                ErrorManager.grammarError( ErrorManager.MSG_RULE_REDEFINITION,
+                                          this, ruleToken, ruleName );
+                return;
+            }
+
+            if ( ( type == Grammar.PARSER || type == Grammar.TREE_PARSER ) &&
+                 char.IsUpper( ruleName[0] ) )
+            {
+                ErrorManager.grammarError( ErrorManager.MSG_LEXER_RULES_NOT_ALLOWED,
+                                          this, ruleToken, ruleName );
+                return;
+            }
+
+            Rule r = new Rule( this, ruleName, composite.ruleIndex, numAlts );
+            /*
+            JSystem.@out.println("defineRule("+ruleName+",modifier="+modifier+
+                               "): index="+r.index+", nalts="+numAlts);
+            */
+            r.modifier = modifier;
+            nameToRuleMap[ruleName] = r;
+            setRuleAST( ruleName, tree );
+            r.setOptions( options, ruleToken );
+            r.argActionAST = argActionAST;
+            composite.ruleIndexToRuleList.setSize( composite.ruleIndex + 1 );
+            composite.ruleIndexToRuleList[composite.ruleIndex] = r;
+            composite.ruleIndex++;
+            if ( ruleName.StartsWith( SYNPRED_RULE_PREFIX ) )
+            {
+                r.isSynPred = true;
+            }
+        }
+
+        /** Define a new predicate and get back its name for use in building
+         *  a semantic predicate reference to the syn pred.
+         */
+        public virtual string defineSyntacticPredicate( GrammarAST blockAST,
+                                               string currentRuleName )
+        {
+            if ( nameToSynpredASTMap == null )
+            {
+                nameToSynpredASTMap = new SortedList<string, GrammarAST>();
+            }
+            string predName =
+                SYNPRED_RULE_PREFIX + ( nameToSynpredASTMap.Count + 1 ) + "_" + name;
+            blockAST.setTreeEnclosingRuleNameDeeply( predName );
+            nameToSynpredASTMap[predName] = blockAST;
+            return predName;
+        }
+
+        [System.Obsolete]
+        public IDictionary<string, GrammarAST> getSyntacticPredicates()
+        {
+            return SyntacticPredicates;
+        }
+
+        public virtual GrammarAST getSyntacticPredicate( string name )
+        {
+            if ( nameToSynpredASTMap == null )
+            {
+                return null;
+            }
+
+            GrammarAST tree;
+            if ( nameToSynpredASTMap.TryGetValue( name, out tree ) )
+                return tree;
+
+            return null;
+        }
+
+        public virtual void synPredUsedInDFA( DFA dfa, SemanticContext semCtx )
+        {
+            decisionsWhoseDFAsUsesSynPreds.Add( dfa );
+            semCtx.trackUseOfSyntacticPredicates( this ); // walk ctx looking for preds
+        }
+
+        /*
+        public Set<Rule> getRuleNamesVisitedDuringLOOK() {
+            return rulesSensitiveToOtherRules;
+        }
+        */
+
+        /** Given @scope::name {action} define it for this grammar.  Later,
+         *  the code generator will ask for the actions table.  For composite
+         *  grammars, make sure header action propogates down to all delegates.
+         */
+        public virtual void defineNamedAction( GrammarAST ampersandAST,
+                                      string scope,
+                                      GrammarAST nameAST,
+                                      GrammarAST actionAST )
+        {
+            if ( scope == null )
+            {
+                scope = getDefaultActionScope( type );
+            }
+            //JSystem.@out.println("@"+scope+"::"+nameAST.getText()+"{"+actionAST.getText()+"}");
+            string actionName = nameAST.Text;
+            var scopeActions = actions.get( scope );
+            if ( scopeActions == null )
+            {
+                scopeActions = new Dictionary<string, object>();
+                actions[scope] = scopeActions;
+            }
+            GrammarAST a = (GrammarAST)scopeActions.get( actionName );
+            if ( a != null )
+            {
+                ErrorManager.grammarError(
+                    ErrorManager.MSG_ACTION_REDEFINITION, this,
+                    nameAST.Token, nameAST.Text );
+            }
+            else
+            {
+                scopeActions[actionName] = actionAST;
+            }
+            // propogate header (regardless of scope (lexer, parser, ...) ?
+            if ( this == composite.RootGrammar && actionName.Equals( "header" ) )
+            {
+                IList<Grammar> allgrammars = composite.RootGrammar.getDelegates();
+                foreach ( Grammar g in allgrammars )
+                {
+                    g.defineNamedAction( ampersandAST, scope, nameAST, actionAST );
+                }
+            }
+        }
+
+        [System.Obsolete]
+        public IDictionary<string, IDictionary<string, object>> getActions()
+        {
+            return Actions;
+        }
+
+        public virtual void setSynPredGateIfNotAlready( StringTemplate gateST )
+        {
+            string scope = getDefaultActionScope( type );
+            var actionsForGrammarScope = actions.get( scope );
+            // if no synpredgate action set by user then set
+            if ( actionsForGrammarScope == null || !actionsForGrammarScope.ContainsKey( Grammar.SYNPREDGATE_ACTION_NAME ) )
+            {
+                if ( actionsForGrammarScope == null )
+                {
+                    actionsForGrammarScope = new Dictionary<string, object>();
+                    actions[scope] = actionsForGrammarScope;
+                }
+                actionsForGrammarScope[Grammar.SYNPREDGATE_ACTION_NAME] = gateST;
+            }
+        }
+
+        /** Given a grammar type, what should be the default action scope?
+         *  If I say @members in a COMBINED grammar, for example, the
+         *  default scope should be "parser".
+         */
+        public virtual string getDefaultActionScope( int grammarType )
+        {
+            switch ( grammarType )
+            {
+            case Grammar.LEXER:
+                return "lexer";
+            case Grammar.PARSER:
+            case Grammar.COMBINED:
+                return "parser";
+            case Grammar.TREE_PARSER:
+                return "treeparser";
+            }
+            return null;
+        }
+
+        public virtual void defineLexerRuleFoundInParser( IToken ruleToken,
+                                                 GrammarAST ruleAST )
+        {
+            //JSystem.@out.println("rule tree is:\n"+ruleAST.toStringTree());
+            /*
+            String ruleText = tokenBuffer.toOriginalString(ruleAST.ruleStartTokenIndex,
+                                                   ruleAST.ruleStopTokenIndex);
+            */
+            // first, create the text of the rule
+            StringBuilder buf = new StringBuilder();
+            buf.Append( "// $ANTLR src \"" );
+            buf.Append( FileName );
+            buf.Append( "\" " );
+            buf.Append( ruleAST.Line );
+            buf.Append( "\n" );
+            for ( int i = ruleAST.TokenStartIndex;
+                 i <= ruleAST.TokenStopIndex && i < tokenBuffer.Size();
+                 i++ )
+            {
+                CommonToken t = (CommonToken)tokenBuffer.Get( i );
+                // undo the text deletions done by the lexer (ugh)
+                if ( t.Type == ANTLRParser.BLOCK )
+                {
+                    buf.Append( "(" );
+                }
+                else if ( t.Type == ANTLRParser.ACTION )
+                {
+                    buf.Append( "{" );
+                    buf.Append( t.Text );
+                    buf.Append( "}" );
+                }
+                else if ( t.Type == ANTLRParser.SEMPRED ||
+                          t.Type == ANTLRParser.SYN_SEMPRED ||
+                          t.Type == ANTLRParser.GATED_SEMPRED ||
+                          t.Type == ANTLRParser.BACKTRACK_SEMPRED )
+                {
+                    buf.Append( "{" );
+                    buf.Append( t.Text );
+                    buf.Append( "}?" );
+                }
+                else if ( t.Type == ANTLRParser.ARG_ACTION )
+                {
+                    buf.Append( "[" );
+                    buf.Append( t.Text );
+                    buf.Append( "]" );
+                }
+                else
+                {
+                    buf.Append( t.Text );
+                }
+            }
+            string ruleText = buf.ToString();
+            //JSystem.@out.println("[["+ruleText+"]]");
+            // now put the rule into the lexer grammar template
+            if ( IsRoot )
+            { // don't build lexers for delegates
+                lexerGrammarST.setAttribute( "rules", ruleText );
+            }
+            // track this lexer rule's name
+            composite.lexerRules.Add( ruleToken.Text );
+        }
+
+        /** If someone does PLUS='+' in the parser, must make sure we get
+         *  "PLUS : '+' ;" in lexer not "T73 : '+';"
+         */
+        public virtual void defineLexerRuleForAliasedStringLiteral( string tokenID,
+                                                           string literal,
+                                                           int tokenType )
+        {
+            if ( IsRoot )
+            { // don't build lexers for delegates
+                //JSystem.@out.println("defineLexerRuleForAliasedStringLiteral: "+literal+" "+tokenType);
+                lexerGrammarST.setAttribute( "literals.{ruleName,type,literal}",
+                                            tokenID,
+                                            tokenType,
+                                            literal );
+            }
+            // track this lexer rule's name
+            composite.lexerRules.Add( tokenID );
+        }
+
+        public virtual void defineLexerRuleForStringLiteral( string literal, int tokenType )
+        {
+            //JSystem.@out.println("defineLexerRuleForStringLiteral: "+literal+" "+tokenType);
+            // compute new token name like T237 and define it as having tokenType
+            string tokenID = computeTokenNameFromLiteral( tokenType, literal );
+            defineToken( tokenID, tokenType );
+            // tell implicit lexer to define a rule to match the literal
+            if ( IsRoot )
+            { // don't build lexers for delegates
+                lexerGrammarST.setAttribute( "literals.{ruleName,type,literal}",
+                                            tokenID,
+                                            tokenType,
+                                            literal );
+            }
+        }
+
+        public virtual Rule getLocallyDefinedRule( string ruleName )
+        {
+            Rule r;
+            if ( nameToRuleMap.TryGetValue( ruleName ?? string.Empty, out r ) )
+                return r;
+
+            return null;
+        }
+
+        public virtual Rule getRule( string ruleName )
+        {
+            Rule r = composite.getRule( ruleName );
+            /*
+            if ( r!=null && r.grammar != this ) {
+                JSystem.@out.println(name+".getRule("+ruleName+")="+r);
+            }
+            */
+            return r;
+        }
+
+        public virtual Rule getRule( string scopeName, string ruleName )
+        {
+            if ( scopeName != null )
+            { // scope override
+                Grammar scope = composite.getGrammar( scopeName );
+                if ( scope == null )
+                {
+                    return null;
+                }
+                return scope.getLocallyDefinedRule( ruleName );
+            }
+            return getRule( ruleName );
+        }
+
+        public virtual int getRuleIndex( string scopeName, string ruleName )
+        {
+            Rule r = getRule( scopeName, ruleName );
+            if ( r != null )
+            {
+                return r.index;
+            }
+            return INVALID_RULE_INDEX;
+        }
+
+        public virtual int getRuleIndex( string ruleName )
+        {
+            return getRuleIndex( null, ruleName );
+        }
+
+        public virtual string getRuleName( int ruleIndex )
+        {
+            Rule r = composite.ruleIndexToRuleList[ruleIndex];
+            if ( r != null )
+            {
+                return r.name;
+            }
+            return null;
+        }
+
+        /** Should codegen.g gen rule for ruleName?
+         * 	If synpred, only gen if used in a DFA.
+         *  If regular rule, only gen if not overridden in delegator
+         *  Always gen Tokens rule though.
+         */
+        public virtual bool generateMethodForRule( string ruleName )
+        {
+            if ( ruleName.Equals( ARTIFICIAL_TOKENS_RULENAME ) )
+            {
+                // always generate Tokens rule to satisfy lexer interface
+                // but it may have no alternatives.
+                return true;
+            }
+            if ( overriddenRules.Contains( ruleName ) )
+            {
+                // don't generate any overridden rules
+                return false;
+            }
+            // generate if non-synpred or synpred used in a DFA
+            Rule r = getLocallyDefinedRule( ruleName );
+            return !r.isSynPred ||
+                   ( r.isSynPred && synPredNamesUsedInDFA.Contains( ruleName ) );
+        }
+
+        public virtual AttributeScope defineGlobalScope( string name, IToken scopeAction )
+        {
+            AttributeScope scope = new AttributeScope( this, name, scopeAction );
+            scopes[name] = scope;
+            return scope;
+        }
+
+        public virtual AttributeScope createReturnScope( string ruleName, IToken retAction )
+        {
+            AttributeScope scope = new AttributeScope( this, ruleName, retAction );
+            scope.isReturnScope = true;
+            return scope;
+        }
+
+        public virtual AttributeScope createRuleScope( string ruleName, IToken scopeAction )
+        {
+            AttributeScope scope = new AttributeScope( this, ruleName, scopeAction );
+            scope.isDynamicRuleScope = true;
+            return scope;
+        }
+
+        public virtual AttributeScope createParameterScope( string ruleName, IToken argAction )
+        {
+            AttributeScope scope = new AttributeScope( this, ruleName, argAction );
+            scope.isParameterScope = true;
+            return scope;
+        }
+
+        /** Get a global scope */
+        public virtual AttributeScope getGlobalScope( string name )
+        {
+            return (AttributeScope)scopes.get( name );
+        }
+
+        [System.Obsolete]
+        public IDictionary<string, AttributeScope> getGlobalScopes()
+        {
+            return GlobalScopes;
+        }
+
+        /** Define a label defined in a rule r; check the validity then ask the
+         *  Rule object to actually define it.
+         */
+        protected virtual void defineLabel( Rule r, IToken label, GrammarAST element, int type )
+        {
+            bool err = nameSpaceChecker.checkForLabelTypeMismatch( r, label, type );
+            if ( err )
+            {
+                return;
+            }
+            r.defineLabel( label, element, type );
+        }
+
+        public virtual void defineTokenRefLabel( string ruleName,
+                                        IToken label,
+                                        GrammarAST tokenRef )
+        {
+            Rule r = getLocallyDefinedRule( ruleName );
+            if ( r != null )
+            {
+                if ( type == LEXER &&
+                     ( tokenRef.Type == ANTLRParser.CHAR_LITERAL ||
+                      tokenRef.Type == ANTLRParser.BLOCK ||
+                      tokenRef.Type == ANTLRParser.NOT ||
+                      tokenRef.Type == ANTLRParser.CHAR_RANGE ||
+                      tokenRef.Type == ANTLRParser.WILDCARD ) )
+                {
+                    defineLabel( r, label, tokenRef, CHAR_LABEL );
+                }
+                else
+                {
+                    defineLabel( r, label, tokenRef, TOKEN_LABEL );
+                }
+            }
+        }
+
+        public virtual void defineWildcardTreeLabel( string ruleName,
+                                               IToken label,
+                                               GrammarAST tokenRef )
+        {
+            Rule r = getLocallyDefinedRule( ruleName );
+            if ( r != null )
+            {
+                defineLabel( r, label, tokenRef, WILDCARD_TREE_LABEL );
+            }
+        }
+
+        public virtual void defineWildcardTreeListLabel( string ruleName, IToken label, GrammarAST tokenRef )
+        {
+            Rule r = getLocallyDefinedRule( ruleName );
+            if ( r != null )
+                defineLabel( r, label, tokenRef, WILDCARD_TREE_LIST_LABEL );
+        }
+
+        public virtual void defineRuleRefLabel( string ruleName,
+                                       IToken label,
+                                       GrammarAST ruleRef )
+        {
+            Rule r = getLocallyDefinedRule( ruleName );
+            if ( r != null )
+            {
+                defineLabel( r, label, ruleRef, RULE_LABEL );
+            }
+        }
+
+        public virtual void defineTokenListLabel( string ruleName,
+                                         IToken label,
+                                         GrammarAST element )
+        {
+            Rule r = getLocallyDefinedRule( ruleName );
+            if ( r != null )
+            {
+                defineLabel( r, label, element, TOKEN_LIST_LABEL );
+            }
+        }
+
+        public virtual void defineRuleListLabel( string ruleName,
+                                        IToken label,
+                                        GrammarAST element )
+        {
+            Rule r = getLocallyDefinedRule( ruleName );
+            if ( r != null )
+            {
+                if ( !r.HasMultipleReturnValues )
+                {
+                    ErrorManager.grammarError(
+                        ErrorManager.MSG_LIST_LABEL_INVALID_UNLESS_RETVAL_STRUCT, this,
+                        label, label.Text );
+                }
+                defineLabel( r, label, element, RULE_LIST_LABEL );
+            }
+        }
+
+        /** Given a set of all rewrite elements on right of ->, filter for
+         *  label types such as Grammar.TOKEN_LABEL, Grammar.TOKEN_LIST_LABEL, ...
+         *  Return a displayable token type name computed from the GrammarAST.
+         */
+        public virtual HashSet<string> getLabels( HashSet<GrammarAST> rewriteElements, int labelType )
+        {
+            HashSet<string> labels = new HashSet<string>();
+            foreach ( GrammarAST el in rewriteElements )
+            {
+                if ( el.Type == ANTLRParser.LABEL )
+                {
+                    string labelName = el.Text;
+                    Rule enclosingRule = getLocallyDefinedRule( el.enclosingRuleName );
+                    LabelElementPair pair = enclosingRule.getLabel( labelName );
+                    /*
+                    // if tree grammar and we have a wildcard, only notice it
+                    // when looking for rule labels not token label. x=. should
+                    // look like a rule ref since could be subtree.
+                    if ( type==TREE_PARSER && pair!=null &&
+                         pair.elementRef.getType()==ANTLRParser.WILDCARD )
+                    {
+                        if ( labelType==WILDCARD_TREE_LABEL ) {
+                            labels.add(labelName);
+                            continue;
+                        }
+                        else continue;
+                    }
+                     */
+                    // if valid label and type is what we're looking for
+                    // and not ref to old value val $rule, add to list
+                    if ( pair != null && pair.type == labelType &&
+                         !labelName.Equals( el.enclosingRuleName ) )
+                    {
+                        labels.Add( labelName );
+                    }
+                }
+            }
+            return labels;
+        }
+
+        /** Before generating code, we examine all actions that can have
+         *  $x.y and $y stuff in them because some code generation depends on
+         *  Rule.referencedPredefinedRuleAttributes.  I need to remove unused
+         *  rule labels for example.
+         */
+        protected virtual void examineAllExecutableActions()
+        {
+            foreach ( Rule r in Rules )
+            {
+                // walk all actions within the rule elements, args, and exceptions
+                var actions = r.InlineActions;
+                foreach ( GrammarAST actionAST in actions )
+                {
+                    ActionAnalysisLexer sniffer = new ActionAnalysisLexer( this, r.name, actionAST );
+                    sniffer.analyze();
+                }
+                // walk any named actions like @init, @after
+                IEnumerable<GrammarAST> namedActions = r.Actions.Values.Cast<GrammarAST>();
+                foreach ( GrammarAST actionAST in namedActions )
+                {
+                    ActionAnalysisLexer sniffer = new ActionAnalysisLexer( this, r.name, actionAST );
+                    sniffer.analyze();
+                }
+            }
+        }
+
+        /** Remove all labels on rule refs whose target rules have no return value.
+         *  Do this for all rules in grammar.
+         */
+        public virtual void checkAllRulesForUselessLabels()
+        {
+            if ( type == LEXER )
+                return;
+
+            foreach ( string ruleName in nameToRuleMap.Keys )
+            {
+                Rule r = getRule( ruleName );
+                removeUselessLabels( r.RuleLabels );
+                removeUselessLabels( r.RuleListLabels );
+            }
+        }
+
+        /** A label on a rule is useless if the rule has no return value, no
+         *  tree or template output, and it is not referenced in an action.
+         */
+        protected virtual void removeUselessLabels( IDictionary ruleToElementLabelPairMap )
+        {
+            if ( ruleToElementLabelPairMap == null )
+                return;
+
+            var tokill = from pair in ruleToElementLabelPairMap.Values.Cast<LabelElementPair>()
+                         let rule = getRule( pair.elementRef.Text )
+                         where rule != null && !rule.HasReturnValue && !pair.actionReferencesLabel
+                         select pair.label.Text;
+
+            foreach ( string label in tokill.ToArray() )
+                ruleToElementLabelPairMap.Remove( label );
+        }
+
+        /** Track a rule reference within an outermost alt of a rule.  Used
+         *  at the moment to decide if $ruleref refers to a unique rule ref in
+         *  the alt.  Rewrite rules force tracking of all rule AST results.
+         *
+         *  This data is also used to verify that all rules have been defined.
+         */
+        public virtual void altReferencesRule( string enclosingRuleName,
+                                      GrammarAST refScopeAST,
+                                      GrammarAST refAST,
+                                      int outerAltNum )
+        {
+            /* Do nothing for now; not sure need; track S.x as x
+            String scope = null;
+            Grammar scopeG = null;
+            if ( refScopeAST!=null ) {
+                if ( !scopedRuleRefs.contains(refScopeAST) ) {
+                    scopedRuleRefs.add(refScopeAST);
+                }
+                scope = refScopeAST.getText();
+            }
+            */
+            Rule r = getRule( enclosingRuleName );
+            if ( r == null )
+            {
+                return; // no error here; see NameSpaceChecker
+            }
+            r.trackRuleReferenceInAlt( refAST, outerAltNum );
+            IToken refToken = refAST.Token;
+            if ( !ruleRefs.Contains( refAST ) )
+            {
+                ruleRefs.Add( refAST );
+            }
+        }
+
+        /** Track a token reference within an outermost alt of a rule.  Used
+         *  to decide if $tokenref refers to a unique token ref in
+         *  the alt. Does not track literals!
+         *
+         *  Rewrite rules force tracking of all tokens.
+         */
+        public virtual void altReferencesTokenID( string ruleName, GrammarAST refAST, int outerAltNum )
+        {
+            Rule r = getLocallyDefinedRule( ruleName );
+            if ( r == null )
+            {
+                return;
+            }
+            r.trackTokenReferenceInAlt( refAST, outerAltNum );
+            if ( !tokenIDRefs.Contains( refAST.Token ) )
+            {
+                tokenIDRefs.Add( refAST.Token );
+            }
+        }
+
+        /** To yield smaller, more readable code, track which rules have their
+         *  predefined attributes accessed.  If the rule has no user-defined
+         *  return values, then don't generate the return value scope classes
+         *  etc...  Make the rule have void return value.  Don't track for lexer
+         *  rules.
+         */
+        public virtual void referenceRuleLabelPredefinedAttribute( string ruleName )
+        {
+            Rule r = getRule( ruleName );
+            if ( r != null && type != LEXER )
+            {
+                // indicate that an action ref'd an attr unless it's in a lexer
+                // so that $ID.text refs don't force lexer rules to define
+                // return values...Token objects are created by the caller instead.
+                r.referencedPredefinedRuleAttributes = true;
+            }
+        }
+
+        public virtual IList checkAllRulesForLeftRecursion()
+        {
+            return (IList)sanity.checkAllRulesForLeftRecursion();
+        }
+
+        /** Return a list of left-recursive rules; no analysis can be done
+         *  successfully on these.  Useful to skip these rules then and also
+         *  for ANTLRWorks to highlight them.
+         */
+        public virtual HashSet<Rule> getLeftRecursiveRules()
+        {
+            if ( nfa == null )
+            {
+                buildNFA();
+            }
+            if ( leftRecursiveRules != null )
+            {
+                return leftRecursiveRules;
+            }
+            sanity.checkAllRulesForLeftRecursion();
+            return leftRecursiveRules;
+        }
+
+        public virtual void checkRuleReference( GrammarAST scopeAST,
+                                       GrammarAST refAST,
+                                       GrammarAST argsAST,
+                                       string currentRuleName )
+        {
+            sanity.checkRuleReference( scopeAST, refAST, argsAST, currentRuleName );
+        }
+
+        /** Rules like "a : ;" and "a : {...} ;" should not generate
+         *  try/catch blocks for RecognitionException.  To detect this
+         *  it's probably ok to just look for any reference to an atom
+         *  that can match some input.  W/o that, the rule is unlikey to have
+         *  any else.
+         */
+        public virtual bool isEmptyRule( GrammarAST block )
+        {
+            foreach ( ITree node in GrammarAST.Descendants(block) )
+            {
+                switch ( node.Type )
+                {
+                case ANTLRParser.TOKEN_REF:
+                case ANTLRParser.STRING_LITERAL:
+                case ANTLRParser.CHAR_LITERAL:
+                case ANTLRParser.WILDCARD:
+                case ANTLRParser.RULE_REF:
+                    return false;
+
+                default:
+                    continue;
+                }
+            }
+
+            return false;
+        }
+
+        public virtual bool isAtomTokenType( int ttype )
+        {
+            return ttype == ANTLRParser.WILDCARD ||
+                   ttype == ANTLRParser.CHAR_LITERAL ||
+                   ttype == ANTLRParser.CHAR_RANGE ||
+                   ttype == ANTLRParser.STRING_LITERAL ||
+                   ttype == ANTLRParser.NOT ||
+                   ( type != LEXER && ttype == ANTLRParser.TOKEN_REF );
+        }
+
+        public virtual int getTokenType( string tokenName )
+        {
+            int i;
+            if ( tokenName[0] == '\'' )
+            {
+                if ( composite.stringLiteralToTypeMap.TryGetValue( tokenName, out i ) )
+                    return i;
+            }
+            else
+            {
+                // must be a label like ID
+                if ( composite.tokenIDToTypeMap.TryGetValue( tokenName, out i ) )
+                    return i;
+            }
+
+            return Label.INVALID;
+        }
+
+        [System.Obsolete]
+        public ICollection<string> getTokenIDs()
+        {
+            return TokenIDs;
+        }
+
+        /** Return an ordered integer list of token types that have no
+         *  corresponding token ID like INT or KEYWORD_BEGIN; for stuff
+         *  like 'begin'.
+         */
+        public virtual ICollection getTokenTypesWithoutID()
+        {
+            IList types = new List<object>();
+            for ( int t = Label.MIN_TOKEN_TYPE; t <= MaxTokenType; t++ )
+            {
+                string name = getTokenDisplayName( t );
+                if ( name[0] == '\'' )
+                {
+                    types.Add( t );
+                }
+            }
+            return types;
+        }
+
+        /** Get a list of all token IDs and literals that have an associated
+         *  token type.
+         */
+        public virtual HashSet<string> getTokenDisplayNames()
+        {
+            HashSet<string> names = new HashSet<string>();
+            for ( int t = Label.MIN_TOKEN_TYPE; t <= MaxTokenType; t++ )
+            {
+                names.Add( getTokenDisplayName( t ) );
+            }
+            return names;
+        }
+
+        /** Given a literal like (the 3 char sequence with single quotes) 'a',
+         *  return the int value of 'a'. Convert escape sequences here also.
+         *  ANTLR's antlr.g parser does not convert escape sequences.
+         *
+         *  11/26/2005: I changed literals to always be '...' even for strings.
+         *  This routine still works though.
+         */
+        public static int getCharValueFromGrammarCharLiteral( string literal )
+        {
+            switch ( literal.Length )
+            {
+            case 3:
+                // 'x'
+                return literal[1]; // no escape char
+            case 4:
+                // '\x'  (antlr lexer will catch invalid char)
+                if ( char.IsDigit( literal[2] ) )
+                {
+                    ErrorManager.error( ErrorManager.MSG_SYNTAX_ERROR,
+                                       "invalid char literal: " + literal );
+                    return -1;
+                }
+                int escChar = literal[2];
+                int charVal = ANTLRLiteralEscapedCharValue[escChar];
+                if ( charVal == 0 )
+                {
+                    // Unnecessary escapes like '\{' should just yield {
+                    return escChar;
+                }
+                return charVal;
+            case 8:
+                // '\u1234'
+                string unicodeChars = literal.Substring( 3, literal.Length - 1 - 3 );
+                //return Integer.parseInt( unicodeChars, 16 );
+                return int.Parse( unicodeChars, System.Globalization.NumberStyles.AllowHexSpecifier );
+            default:
+                ErrorManager.error( ErrorManager.MSG_SYNTAX_ERROR,
+                                   "invalid char literal: " + literal );
+                return -1;
+            }
+        }
+
+        /** ANTLR does not convert escape sequences during the parse phase because
+         *  it could not know how to print String/char literals back out when
+         *  printing grammars etc...  Someone in China might use the real unicode
+         *  char in a literal as it will display on their screen; when printing
+         *  back out, I could not know whether to display or use a unicode escape.
+         *
+         *  This routine converts a string literal with possible escape sequences
+         *  into a pure string of 16-bit char values.  Escapes and unicode \u0000
+         *  specs are converted to pure chars.  return in a buffer; people may
+         *  want to walk/manipulate further.
+         *
+         *  The NFA construction routine must know the actual char values.
+         */
+        public static StringBuilder getUnescapedStringFromGrammarStringLiteral( string literal )
+        {
+            //JSystem.@out.println("escape: ["+literal+"]");
+            StringBuilder buf = new StringBuilder();
+            int last = literal.Length - 1; // skip quotes on outside
+            for ( int i = 1; i < last; i++ )
+            {
+                char c = literal[i];
+                if ( c == '\\' )
+                {
+                    i++;
+                    c = literal[i];
+                    if ( char.ToUpperInvariant( c ) == 'U' )
+                    {
+                        // \u0000
+                        i++;
+                        string unicodeChars = literal.Substring( i, 4 );
+                        // parse the unicode 16 bit hex value
+                        //int val = Integer.parseInt( unicodeChars, 16 );
+                        int val = int.Parse( unicodeChars, System.Globalization.NumberStyles.AllowHexSpecifier );
+                        i += 4 - 1; // loop will inc by 1; only jump 3 then
+                        buf.Append( (char)val );
+                    }
+                    else if ( char.IsDigit( c ) )
+                    {
+                        ErrorManager.error( ErrorManager.MSG_SYNTAX_ERROR,
+                                           "invalid char literal: " + literal );
+                        buf.Append( "\\" + (char)c );
+                    }
+                    else
+                    {
+                        buf.Append( (char)ANTLRLiteralEscapedCharValue[c] ); // normal \x escape
+                    }
+                }
+                else
+                {
+                    buf.Append( c ); // simple char x
+                }
+            }
+            //JSystem.@out.println("string: ["+buf.toString()+"]");
+            return buf;
+        }
+
+        /** Pull your token definitions from an existing grammar in memory.
+         *  You must use Grammar() ctor then this method then setGrammarContent()
+         *  to make this work.  This was useful primarily for testing and
+         *  interpreting grammars until I added import grammar functionality.
+         *  When you import a grammar you implicitly import its vocabulary as well
+         *  and keep the same token type values.
+         *
+         *  Returns the max token type found.
+         */
+        public virtual int importTokenVocabulary( Grammar importFromGr )
+        {
+            var importedTokenIDs = importFromGr.TokenIDs;
+            foreach ( string tokenID in importedTokenIDs )
+            {
+                int tokenType = importFromGr.getTokenType( tokenID );
+                composite.maxTokenType = Math.Max( composite.maxTokenType, tokenType );
+                if ( tokenType >= Label.MIN_TOKEN_TYPE )
+                {
+                    //JSystem.@out.println("import token from grammar "+tokenID+"="+tokenType);
+                    defineToken( tokenID, tokenType );
+                }
+            }
+            return composite.maxTokenType; // return max found
+        }
+
+        /** Import the rules/tokens of a delegate grammar. All delegate grammars are
+         *  read during the ctor of first Grammar created.
+         *
+         *  Do not create NFA here because NFA construction needs to hook up with
+         *  overridden rules in delegation root grammar.
+         */
+        public virtual void importGrammar( GrammarAST grammarNameAST, string label )
+        {
+            string grammarName = grammarNameAST.Text;
+            //JSystem.@out.println("import "+gfile.getName());
+            string gname = grammarName + GRAMMAR_FILE_EXTENSION;
+            TextReader br = null;
+            try
+            {
+                string fullName = tool.getLibraryFile( gname );
+                //FileReader fr = new FileReader( fullName );
+                //br = new BufferedReader( fr );
+                br = new StringReader( System.IO.File.ReadAllText( fullName ) );
+                Grammar delegateGrammar = null;
+                delegateGrammar = new Grammar( tool, gname, composite );
+                delegateGrammar.label = label;
+
+                addDelegateGrammar( delegateGrammar );
+
+                delegateGrammar.parseAndBuildAST( br );
+                if ( !validImport( delegateGrammar ) )
+                {
+                    ErrorManager.grammarError( ErrorManager.MSG_INVALID_IMPORT,
+                                              this,
+                                              grammarNameAST.token,
+                                              this,
+                                              delegateGrammar );
+                    return;
+                }
+                if ( this.type == COMBINED &&
+                     ( delegateGrammar.name.Equals( this.name + grammarTypeToFileNameSuffix[LEXER] ) ||
+                      delegateGrammar.name.Equals( this.name + grammarTypeToFileNameSuffix[PARSER] ) ) )
+                {
+                    ErrorManager.grammarError( ErrorManager.MSG_IMPORT_NAME_CLASH,
+                                              this,
+                                              grammarNameAST.token,
+                                              this,
+                                              delegateGrammar );
+                    return;
+                }
+                if ( delegateGrammar.grammarTree != null )
+                {
+                    // we have a valid grammar
+                    // deal with combined grammars
+                    if ( delegateGrammar.type == LEXER && this.type == COMBINED )
+                    {
+                        // ooops, we wasted some effort; tell lexer to read it in
+                        // later
+                        lexerGrammarST.setAttribute( "imports", grammarName );
+                        // but, this parser grammar will need the vocab
+                        // so add to composite anyway so we suck in the tokens later
+                    }
+                }
+                //JSystem.@out.println("Got grammar:\n"+delegateGrammar);
+            }
+            catch ( IOException ioe )
+            {
+                ErrorManager.error( ErrorManager.MSG_CANNOT_OPEN_FILE,
+                                   gname,
+                                   ioe );
+            }
+            finally
+            {
+                if ( br != null )
+                {
+                    try
+                    {
+                        br.Close();
+                    }
+                    catch ( IOException ioe )
+                    {
+                        ErrorManager.error( ErrorManager.MSG_CANNOT_CLOSE_FILE,
+                                           gname,
+                                           ioe );
+                    }
+                }
+            }
+        }
+
+        /** add new delegate to composite tree */
+        protected virtual void addDelegateGrammar( Grammar delegateGrammar )
+        {
+            CompositeGrammarTree t = composite.delegateGrammarTreeRoot.findNode( this );
+            t.addChild( new CompositeGrammarTree( delegateGrammar ) );
+            // make sure new grammar shares this composite
+            delegateGrammar.composite = this.composite;
+        }
+
+        /** Load a vocab file <vocabName>.tokens and return max token type found. */
+        public virtual int importTokenVocabulary( GrammarAST tokenVocabOptionAST,
+                                         string vocabName )
+        {
+            if ( !IsRoot )
+            {
+                ErrorManager.grammarWarning( ErrorManager.MSG_TOKEN_VOCAB_IN_DELEGATE,
+                                            this,
+                                            tokenVocabOptionAST.token,
+                                            name );
+                return composite.maxTokenType;
+            }
+
+            System.IO.FileInfo fullFile = tool.getImportedVocabFile( vocabName );
+            try
+            {
+                FileReader fr = new FileReader( fullFile.FullName );
+                java.io.BufferedReader br = new java.io.BufferedReader( fr );
+                StreamTokenizer tokenizer = new StreamTokenizer( br );
+                tokenizer.parseNumbers();
+                tokenizer.wordChars( '_', '_' );
+                tokenizer.eolIsSignificant( true );
+                tokenizer.slashSlashComments( true );
+                tokenizer.slashStarComments( true );
+                tokenizer.ordinaryChar( '=' );
+                tokenizer.quoteChar( '\'' );
+                tokenizer.whitespaceChars( ' ', ' ' );
+                tokenizer.whitespaceChars( '\t', '\t' );
+                int lineNum = 1;
+                int token = tokenizer.nextToken();
+                while ( token != StreamTokenizer.TT_EOF )
+                {
+                    string tokenID;
+                    if ( token == StreamTokenizer.TT_WORD )
+                    {
+                        tokenID = tokenizer.sval;
+                    }
+                    else if ( token == '\'' )
+                    {
+                        tokenID = "'" + tokenizer.sval + "'";
+                    }
+                    else
+                    {
+                        ErrorManager.error( ErrorManager.MSG_TOKENS_FILE_SYNTAX_ERROR,
+                                           vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,
+                                           lineNum );
+                        while ( tokenizer.nextToken() != StreamTokenizer.TT_EOL )
+                        {
+                            ;
+                        }
+                        token = tokenizer.nextToken();
+                        continue;
+                    }
+                    token = tokenizer.nextToken();
+                    if ( token != '=' )
+                    {
+                        ErrorManager.error( ErrorManager.MSG_TOKENS_FILE_SYNTAX_ERROR,
+                                           vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,
+                                           lineNum );
+                        while ( tokenizer.nextToken() != StreamTokenizer.TT_EOL )
+                        {
+                            ;
+                        }
+                        token = tokenizer.nextToken();
+                        continue;
+                    }
+                    token = tokenizer.nextToken(); // skip '='
+                    if ( token != StreamTokenizer.TT_NUMBER )
+                    {
+                        ErrorManager.error( ErrorManager.MSG_TOKENS_FILE_SYNTAX_ERROR,
+                                           vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,
+                                           lineNum );
+                        while ( tokenizer.nextToken() != StreamTokenizer.TT_EOL )
+                        {
+                            ;
+                        }
+                        token = tokenizer.nextToken();
+                        continue;
+                    }
+                    int tokenType = (int)tokenizer.nval;
+                    token = tokenizer.nextToken();
+                    //JSystem.@out.println("import "+tokenID+"="+tokenType);
+                    composite.maxTokenType = Math.Max( composite.maxTokenType, tokenType );
+                    defineToken( tokenID, tokenType );
+                    lineNum++;
+                    if ( token != StreamTokenizer.TT_EOL )
+                    {
+                        ErrorManager.error( ErrorManager.MSG_TOKENS_FILE_SYNTAX_ERROR,
+                                           vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,
+                                           lineNum );
+                        while ( tokenizer.nextToken() != StreamTokenizer.TT_EOL )
+                        {
+                            ;
+                        }
+                        token = tokenizer.nextToken();
+                        continue;
+                    }
+                    token = tokenizer.nextToken(); // skip newline
+                }
+                br.close();
+            }
+            catch ( java.io.FileNotFoundException /*fnfe*/ )
+            {
+                ErrorManager.error( ErrorManager.MSG_CANNOT_FIND_TOKENS_FILE,
+                                   fullFile );
+            }
+            catch ( IOException ioe )
+            {
+                ErrorManager.error( ErrorManager.MSG_ERROR_READING_TOKENS_FILE,
+                                   fullFile,
+                                   ioe );
+            }
+            catch ( Exception e )
+            {
+                ErrorManager.error( ErrorManager.MSG_ERROR_READING_TOKENS_FILE,
+                                   fullFile,
+                                   e );
+            }
+            return composite.maxTokenType;
+        }
+
+        /** Given a token type, get a meaningful name for it such as the ID
+         *  or string literal.  If this is a lexer and the ttype is in the
+         *  char vocabulary, compute an ANTLR-valid (possibly escaped) char literal.
+         */
+        public virtual string getTokenDisplayName( int ttype )
+        {
+            string tokenName = null;
+            int index = 0;
+            // inside any target's char range and is lexer grammar?
+            if ( this.type == LEXER &&
+                 ttype >= Label.MIN_CHAR_VALUE && ttype <= Label.MAX_CHAR_VALUE )
+            {
+                return getANTLRCharLiteralForChar( ttype );
+            }
+            // faux label?
+            else if ( ttype < 0 )
+            {
+                tokenName = (string)composite.typeToTokenList[Label.NUM_FAUX_LABELS + ttype];
+            }
+            else
+            {
+                // compute index in typeToTokenList for ttype
+                index = ttype - 1; // normalize to 0..n-1
+                index += Label.NUM_FAUX_LABELS;     // jump over faux tokens
+
+                if ( index < composite.typeToTokenList.Count )
+                {
+                    tokenName = (string)composite.typeToTokenList[index];
+                    if ( tokenName != null &&
+                         tokenName.StartsWith( AUTO_GENERATED_TOKEN_NAME_PREFIX ) )
+                    {
+                        tokenName = composite.typeToStringLiteralList[ttype];
+                    }
+                }
+                else
+                {
+                    tokenName = ttype.ToString(); // String.valueOf( ttype );
+                }
+            }
+            //JSystem.@out.println("getTokenDisplayName ttype="+ttype+", index="+index+", name="+tokenName);
+            return tokenName;
+        }
+
+        [System.Obsolete]
+        public ICollection<string> getStringLiterals()
+        {
+            return StringLiterals;
+        }
+
+        [System.Obsolete]
+        public string getGrammarTypeString()
+        {
+            return GrammarTypeString;
+        }
+
+        public virtual int getGrammarMaxLookahead()
+        {
+            if ( global_k >= 0 )
+            {
+                return global_k;
+            }
+            object k = getOption( "k" );
+            if ( k == null )
+            {
+                global_k = 0;
+            }
+            else if ( k is int )
+            {
+                int kI = (int)k;
+                global_k = kI;
+            }
+            else
+            {
+                // must be String "*"
+                if ( k.Equals( "*" ) )
+                {  // this the default anyway
+                    global_k = 0;
+                }
+            }
+            return global_k;
+        }
+
+        /** Save the option key/value pair and process it; return the key
+         *  or null if invalid option.
+         */
+        public virtual string setOption( string key, object value, IToken optionsStartToken )
+        {
+            if ( legalOption( key ) )
+            {
+                ErrorManager.grammarError( ErrorManager.MSG_ILLEGAL_OPTION,
+                                          this,
+                                          optionsStartToken,
+                                          key );
+                return null;
+            }
+            if ( !optionIsValid( key, value ) )
+            {
+                return null;
+            }
+            if ( key == "backtrack" && value.ToString() == "true" )
+            {
+                composite.getRootGrammar().atLeastOneBacktrackOption = true;
+            }
+            if ( options == null )
+            {
+                options = new Dictionary<string, object>();
+            }
+            options[key] = value;
+            return key;
+        }
+
+        public virtual bool legalOption( string key )
+        {
+            switch ( type )
+            {
+            case LEXER:
+                return !legalLexerOptions.Contains( key );
+            case PARSER:
+                return !legalParserOptions.Contains( key );
+            case TREE_PARSER:
+                return !legalTreeParserOptions.Contains( key );
+            default:
+                return !legalParserOptions.Contains( key );
+            }
+        }
+
+        public virtual void setOptions( IDictionary<string, object> options, IToken optionsStartToken )
+        {
+            if ( options == null )
+            {
+                this.options = null;
+                return;
+            }
+            //Set keys = options.keySet();
+            //for ( Iterator it = keys.iterator(); it.hasNext(); )
+            //{
+            //    String optionName = (String)it.next();
+            //    object optionValue = options.get( optionName );
+            //    String stored = setOption( optionName, optionValue, optionsStartToken );
+            //    if ( stored == null )
+            //    {
+            //        it.remove();
+            //    }
+            //}
+            foreach ( string optionName in options.Keys.ToArray() )
+            {
+                object optionValue = options.get( optionName );
+                string stored = setOption( optionName, optionValue, optionsStartToken );
+                if ( stored == null )
+                    options.Remove( optionName );
+            }
+        }
+
+        public virtual object getOption( string key )
+        {
+            return composite.getOption( key );
+        }
+
+        public virtual object getLocallyDefinedOption( string key )
+        {
+            object value = null;
+            if ( options != null )
+            {
+                value = options.get( key );
+            }
+            if ( value == null )
+            {
+                value = defaultOptions.get( key );
+            }
+            return value;
+        }
+
+        public virtual object getBlockOption( GrammarAST blockAST, string key )
+        {
+            string v = (string)blockAST.getBlockOption( key );
+            if ( v != null )
+            {
+                return v;
+            }
+            if ( type == Grammar.LEXER )
+            {
+                return defaultLexerBlockOptions.get( key );
+            }
+            return defaultBlockOptions.get( key );
+        }
+
+        public virtual int getUserMaxLookahead( int decision )
+        {
+            int user_k = 0;
+            GrammarAST blockAST = nfa.grammar.getDecisionBlockAST( decision );
+            object k = blockAST.getBlockOption( "k" );
+            if ( k == null )
+            {
+                user_k = nfa.grammar.MaxLookahead;
+                return user_k;
+            }
+            if ( k is int )
+            {
+                int kI = (int)k;
+                user_k = kI;
+            }
+            else
+            {
+                // must be String "*"
+                if ( k.Equals( "*" ) )
+                {
+                    user_k = 0;
+                }
+            }
+            return user_k;
+        }
+
+        public virtual bool getAutoBacktrackMode( int decision )
+        {
+            NFAState decisionNFAStartState = getDecisionNFAStartState( decision );
+            string autoBacktrack =
+                (string)getBlockOption( decisionNFAStartState.associatedASTNode, "backtrack" );
+
+            if ( autoBacktrack == null )
+            {
+                autoBacktrack = (string)nfa.grammar.getOption( "backtrack" );
+            }
+            return autoBacktrack != null && autoBacktrack.Equals( "true" );
+        }
+
+        public virtual bool optionIsValid( string key, object value )
+        {
+            return true;
+        }
+
+        [System.Obsolete]
+        public bool buildAST()
+        {
+            return BuildAST;
+        }
+
+        [System.Obsolete]
+        public bool rewriteMode()
+        {
+            return RewriteMode;
+        }
+
+        [System.Obsolete]
+        public bool isBuiltFromString()
+        {
+            return IsBuiltFromString;
+        }
+
+        [System.Obsolete]
+        public virtual bool buildTemplate()
+        {
+            return BuildTemplate;
+        }
+
+        [System.Obsolete]
+        public ICollection<Rule> getRules()
+        {
+            return Rules;
+        }
+
+        /** Get the set of Rules that need to have manual delegations
+         *  like "void rule() { importedGrammar.rule(); }"
+         *
+         *  If this grammar is master, get list of all rule definitions from all
+         *  delegate grammars.  Only master has complete interface from combined
+         *  grammars...we will generated delegates as helper objects.
+         *
+         *  Composite grammars that are not the root/master do not have complete
+         *  interfaces.  It is not my intention that people use subcomposites.
+         *  Only the outermost grammar should be used from outside code.  The
+         *  other grammar components are specifically generated to work only
+         *  with the master/root.
+         *
+         *  delegatedRules = imported - overridden
+         */
+        public virtual HashSet<Rule> getDelegatedRules()
+        {
+            return composite.getDelegatedRules( this );
+        }
+
+        /** Get set of all rules imported from all delegate grammars even if
+         *  indirectly delegated.
+         */
+        public virtual HashSet<Rule> getAllImportedRules()
+        {
+            return composite.getAllImportedRules( this );
+        }
+
+        /** Get list of all delegates from all grammars directly or indirectly
+         *  imported into this grammar.
+         */
+        public virtual IList<Grammar> getDelegates()
+        {
+            return composite.getDelegates( this );
+        }
+
+        public virtual IList<string> getDelegateNames()
+        {
+            // compute delegates:{Grammar g | return g.name;}
+            IList<string> names = new List<string>();
+            IList<Grammar> delegates = composite.getDelegates( this );
+            if ( delegates != null )
+            {
+                foreach ( Grammar g in delegates )
+                {
+                    names.Add( g.name );
+                }
+            }
+            return names;
+        }
+
+        public virtual IList<Grammar> getDirectDelegates()
+        {
+            return composite.getDirectDelegates( this );
+        }
+
+        /** Get delegates below direct delegates */
+        public virtual IList<Grammar> getIndirectDelegates()
+        {
+            return composite.getIndirectDelegates( this );
+        }
+
+        /** Get list of all delegators.  This amounts to the grammars on the path
+         *  to the root of the delegation tree.
+         */
+        public virtual IList<Grammar> getDelegators()
+        {
+            return composite.getDelegators( this );
+        }
+
+        [System.Obsolete]
+        public Grammar getDelegator()
+        {
+            return Delegator;
+        }
+
+        public virtual HashSet<Rule> getDelegatedRuleReferences()
+        {
+            return delegatedRuleReferences;
+        }
+
+        [System.Obsolete]
+        public bool getGrammarIsRoot()
+        {
+            return IsRoot;
+        }
+
+        public virtual void setRuleAST( string ruleName, GrammarAST t )
+        {
+            Rule r = getLocallyDefinedRule( ruleName );
+            if ( r != null )
+            {
+                r.tree = t;
+                r.EORNode = t.getLastChild();
+            }
+        }
+
+        public virtual NFAState getRuleStartState( string ruleName )
+        {
+            return getRuleStartState( null, ruleName );
+        }
+
+        public virtual NFAState getRuleStartState( string scopeName, string ruleName )
+        {
+            Rule r = getRule( scopeName, ruleName );
+            if ( r != null )
+            {
+                //JSystem.@out.println("getRuleStartState("+scopeName+", "+ruleName+")="+r.startState);
+                return r.startState;
+            }
+            //JSystem.@out.println("getRuleStartState("+scopeName+", "+ruleName+")=null");
+            return null;
+        }
+
+        public virtual string getRuleModifier( string ruleName )
+        {
+            Rule r = getRule( ruleName );
+            if ( r != null )
+            {
+                return r.modifier;
+            }
+            return null;
+        }
+
+        public virtual NFAState getRuleStopState( string ruleName )
+        {
+            Rule r = getRule( ruleName );
+            if ( r != null )
+            {
+                return r.stopState;
+            }
+            return null;
+        }
+
+        public virtual int assignDecisionNumber( NFAState state )
+        {
+            decisionCount++;
+            state.DecisionNumber = decisionCount;
+            return decisionCount;
+        }
+
+        protected internal virtual Decision getDecision( int decision )
+        {
+            int index = decision - 1;
+            if ( index >= indexToDecision.Count )
+            {
+                return null;
+            }
+            Decision d = (Decision)indexToDecision[index];
+            return d;
+        }
+
+        protected virtual Decision createDecision( int decision )
+        {
+            int index = decision - 1;
+            if ( index < indexToDecision.Count )
+            {
+                return getDecision( decision ); // don't recreate
+            }
+            Decision d = new Decision();
+            d.decision = decision;
+            indexToDecision.setSize( NumberOfDecisions );
+            indexToDecision[index] = d;
+            return d;
+        }
+
+        public virtual IList getDecisionNFAStartStateList()
+        {
+            IList states = new List<object>( 100 );
+            for ( int d = 0; d < indexToDecision.Count; d++ )
+            {
+                Decision dec = (Decision)indexToDecision[d];
+                states.Add( dec.startState );
+            }
+            return states;
+        }
+
+        public virtual NFAState getDecisionNFAStartState( int decision )
+        {
+            Decision d = getDecision( decision );
+            if ( d == null )
+            {
+                return null;
+            }
+            return d.startState;
+        }
+
+        public virtual DFA getLookaheadDFA( int decision )
+        {
+            Decision d = getDecision( decision );
+            if ( d == null )
+            {
+                return null;
+            }
+            return d.dfa;
+        }
+
+        public virtual GrammarAST getDecisionBlockAST( int decision )
+        {
+            Decision d = getDecision( decision );
+            if ( d == null )
+            {
+                return null;
+            }
+            return d.blockAST;
+        }
+
+        /** returns a list of column numbers for all decisions
+         *  on a particular line so ANTLRWorks choose the decision
+         *  depending on the location of the cursor (otherwise,
+         *  ANTLRWorks has to give the *exact* location which
+         *  is not easy from the user point of view).
+         *
+         *  This is not particularly fast as it walks entire line:col->DFA map
+         *  looking for a prefix of "line:".
+         */
+        public virtual IList getLookaheadDFAColumnsForLineInFile( int line )
+        {
+            string prefix = line + ":";
+            IList columns = new List<object>();
+            foreach ( string key in lineColumnToLookaheadDFAMap.Keys )
+            {
+                if ( key.StartsWith( prefix ) )
+                {
+                    columns.Add( int.Parse( key.Substring( prefix.Length ) ) );
+                }
+            }
+            return columns;
+        }
+
+        /** Useful for ANTLRWorks to map position in file to the DFA for display */
+        public virtual DFA getLookaheadDFAFromPositionInFile( int line, int col )
+        {
+            return (DFA)lineColumnToLookaheadDFAMap.get( line.ToString() + ":" + col.ToString() );
+        }
+
+        [System.Obsolete]
+        public IDictionary<string, DFA> getLineColumnToLookaheadDFAMap()
+        {
+            return LineColumnToLookaheadDFAMap;
+        }
+
+        /*
+        public void setDecisionOptions(int decision, Map options) {
+            Decision d = createDecision(decision);
+            d.options = options;
+        }
+
+        public void setDecisionOption(int decision, String name, Object value) {
+            Decision d = getDecision(decision);
+            if ( d!=null ) {
+                if ( d.options==null ) {
+                    d.options = new HashMap();
+                }
+                d.options.put(name,value);
+            }
+        }
+
+        public Map getDecisionOptions(int decision) {
+            Decision d = getDecision(decision);
+            if ( d==null ) {
+                return null;
+            }
+            return d.options;
+        }
+        */
+
+        [System.Obsolete]
+        public int getNumberOfDecisions()
+        {
+            return NumberOfDecisions;
+        }
+
+        public virtual int getNumberOfCyclicDecisions()
+        {
+            int n = 0;
+            for ( int i = 1; i <= NumberOfDecisions; i++ )
+            {
+                Decision d = getDecision( i );
+                if ( d.dfa != null && d.dfa.IsCyclic )
+                {
+                    n++;
+                }
+            }
+            return n;
+        }
+
+        /** Set the lookahead DFA for a particular decision.  This means
+         *  that the appropriate AST node must updated to have the new lookahead
+         *  DFA.  This method could be used to properly set the DFAs without
+         *  using the createLookaheadDFAs() method.  You could do this
+         *
+         *    Grammar g = new Grammar("...");
+         *    g.setLookahead(1, dfa1);
+         *    g.setLookahead(2, dfa2);
+         *    ...
+         */
+        public virtual void setLookaheadDFA( int decision, DFA lookaheadDFA )
+        {
+            Decision d = createDecision( decision );
+            d.dfa = lookaheadDFA;
+            GrammarAST ast = d.startState.associatedASTNode;
+            ast.setLookaheadDFA( lookaheadDFA );
+        }
+
+        public virtual void setDecisionNFA( int decision, NFAState state )
+        {
+            Decision d = createDecision( decision );
+            d.startState = state;
+        }
+
+        public virtual void setDecisionBlockAST( int decision, GrammarAST blockAST )
+        {
+            //JSystem.@out.println("setDecisionBlockAST("+decision+", "+blockAST.token);
+            Decision d = createDecision( decision );
+            d.blockAST = blockAST;
+        }
+
+        [System.Obsolete]
+        public bool allDecisionDFAHaveBeenCreated()
+        {
+            return AllDecisionDFAHaveBeenCreated;
+        }
+
+        [System.Obsolete]
+        public int getMaxTokenType()
+        {
+            return MaxTokenType;
+        }
+
+        [System.Obsolete]
+        public int getMaxCharValue()
+        {
+            return MaxCharValue;
+        }
+
+        [System.Obsolete]
+        public IIntSet getTokenTypes()
+        {
+            return TokenTypes;
+        }
+
+        [System.Obsolete]
+        public IIntSet getAllCharValues()
+        {
+            return AllCharValues;
+        }
+
+        /** Return a string representing the escaped char for code c.  E.g., If c
+         *  has value 0x100, you will get "\u0100".  ASCII gets the usual
+         *  char (non-hex) representation.  Control characters are spit out
+         *  as unicode.  While this is specially set up for returning Java strings,
+         *  it can be used by any language target that has the same syntax. :)
+         *
+         *  11/26/2005: I changed this to use double quotes, consistent with antlr.g
+         *  12/09/2005: I changed so everything is single quotes
+         */
+        public static string getANTLRCharLiteralForChar( int c )
+        {
+            if ( c < Label.MIN_CHAR_VALUE )
+            {
+                ErrorManager.internalError( "invalid char value " + c );
+                return "'<INVALID>'";
+            }
+            if ( c < ANTLRLiteralCharValueEscape.Length && ANTLRLiteralCharValueEscape[c] != null )
+            {
+                return '\'' + ANTLRLiteralCharValueEscape[c] + '\'';
+            }
+            if ( Character.UnicodeBlock.of( (char)c ) == Character.UnicodeBlock.BASIC_LATIN &&
+                 !Character.isISOControl( (char)c ) )
+            {
+                if ( c == '\\' )
+                {
+                    return "'\\\\'";
+                }
+                if ( c == '\'' )
+                {
+                    return "'\\''";
+                }
+                return "'" + (char)c + "'";
+            }
+            // turn on the bit above max "\uFFFF" value so that we pad with zeros
+            // then only take last 4 digits
+            string hex = c.ToString( "X4" ); //Integer.toHexString( c | 0x10000 ).toUpperCase().substring( 1, 5 );
+            string unicodeStr = "'\\u" + hex + "'";
+            return unicodeStr;
+        }
+
+        /** For lexer grammars, return everything in unicode not in set.
+         *  For parser and tree grammars, return everything in token space
+         *  from MIN_TOKEN_TYPE to last valid token type or char value.
+         */
+        public virtual IIntSet complement( IIntSet set )
+        {
+            //JSystem.@out.println("complement "+set.toString(this));
+            //JSystem.@out.println("vocabulary "+getTokenTypes().toString(this));
+            IIntSet c = set.complement( TokenTypes );
+            //JSystem.@out.println("result="+c.toString(this));
+            return c;
+        }
+
+        public virtual IIntSet complement( int atom )
+        {
+            return complement( IntervalSet.of( atom ) );
+        }
+
+        /** Given set tree like ( SET A B ), check that A and B
+         *  are both valid sets themselves, else we must tree like a BLOCK
+         */
+        public virtual bool isValidSet( TreeToNFAConverter nfabuilder, GrammarAST t )
+        {
+            bool valid = true;
+            try
+            {
+                //JSystem.@out.println("parse BLOCK as set tree: "+t.toStringTree());
+                int alts = nfabuilder.testBlockAsSet( t );
+                valid = ( alts > 1 );
+            }
+            catch ( RecognitionException /*re*/ )
+            {
+                // The rule did not parse as a set, return false; ignore exception
+                valid = false;
+            }
+            //JSystem.@out.println("valid? "+valid);
+            return valid;
+        }
+
+        /** Get the set equivalent (if any) of the indicated rule from this
+         *  grammar.  Mostly used in the lexer to do ~T for some fragment rule
+         *  T.  If the rule AST has a SET use that.  If the rule is a single char
+         *  convert it to a set and return.  If rule is not a simple set (w/o actions)
+         *  then return null.
+         *  Rules have AST form:
+         *
+         *		^( RULE ID modifier ARG RET SCOPE block EOR )
+         */
+        public virtual IIntSet getSetFromRule( TreeToNFAConverter nfabuilder, string ruleName )
+        {
+            Rule r = getRule( ruleName );
+            if ( r == null )
+            {
+                return null;
+            }
+            IIntSet elements = null;
+            //JSystem.@out.println("parsed tree: "+r.tree.toStringTree());
+            elements = nfabuilder.setRule( r.tree );
+            //JSystem.@out.println("elements="+elements);
+            return elements;
+        }
+
+        /** Decisions are linked together with transition(1).  Count how
+         *  many there are.  This is here rather than in NFAState because
+         *  a grammar decides how NFAs are put together to form a decision.
+         */
+        public virtual int getNumberOfAltsForDecisionNFA( NFAState decisionState )
+        {
+            if ( decisionState == null )
+            {
+                return 0;
+            }
+            int n = 1;
+            NFAState p = decisionState;
+            while ( p.transition[1] != null )
+            {
+                n++;
+                p = (NFAState)p.transition[1].target;
+            }
+            return n;
+        }
+
+        /** Get the ith alternative (1..n) from a decision; return null when
+         *  an invalid alt is requested.  I must count in to find the right
+         *  alternative number.  For (A|B), you get NFA structure (roughly):
+         *
+         *  o->o-A->o
+         *  |
+         *  o->o-B->o
+         *
+         *  This routine returns the leftmost state for each alt.  So alt=1, returns
+         *  the upperleft most state in this structure.
+         */
+        public virtual NFAState getNFAStateForAltOfDecision( NFAState decisionState, int alt )
+        {
+            if ( decisionState == null || alt <= 0 )
+            {
+                return null;
+            }
+            int n = 1;
+            NFAState p = decisionState;
+            while ( p != null )
+            {
+                if ( n == alt )
+                {
+                    return p;
+                }
+                n++;
+                Transition next = p.transition[1];
+                p = null;
+                if ( next != null )
+                {
+                    p = (NFAState)next.target;
+                }
+            }
+            return null;
+        }
+
+        /*
+        public void computeRuleFOLLOWSets() {
+            if ( getNumberOfDecisions()==0 ) {
+                createNFAs();
+            }
+            for (Iterator it = getRules().iterator(); it.hasNext();) {
+                Rule r = (Rule)it.next();
+                if ( r.isSynPred ) {
+                    continue;
+                }
+                LookaheadSet s = ll1Analyzer.FOLLOW(r);
+                JSystem.@out.println("FOLLOW("+r.name+")="+s);
+            }
+        }
+        */
+
+        public virtual LookaheadSet FIRST( NFAState s )
+        {
+            return ll1Analyzer.FIRST( s );
+        }
+
+        public virtual LookaheadSet LOOK( NFAState s )
+        {
+            return ll1Analyzer.LOOK( s );
+        }
+
+        public virtual void setCodeGenerator( CodeGenerator generator )
+        {
+            this.generator = generator;
+        }
+
+        [System.Obsolete]
+        public CodeGenerator getCodeGenerator()
+        {
+            return CodeGenerator;
+        }
+
+        [System.Obsolete]
+        public GrammarAST getGrammarTree()
+        {
+            return Tree;
+        }
+
+        [System.Obsolete]
+        public Tool getTool()
+        {
+            return Tool;
+        }
+
+        [System.Obsolete]
+        public void setTool( Tool tool )
+        {
+            Tool = tool;
+        }
+
+        /** given a token type and the text of the literal, come up with a
+         *  decent token type label.  For now it's just T<type>.  Actually,
+         *  if there is an aliased name from tokens like PLUS='+', use it.
+         */
+        public virtual string computeTokenNameFromLiteral( int tokenType, string literal )
+        {
+            return AUTO_GENERATED_TOKEN_NAME_PREFIX + tokenType;
+        }
+
+        public override string ToString()
+        {
+            return grammarTreeToString( grammarTree );
+        }
+
+        public virtual string grammarTreeToString( GrammarAST t )
+        {
+            return grammarTreeToString( t, true );
+        }
+
+        public virtual string grammarTreeToString( GrammarAST t, bool showActions )
+        {
+            string s = null;
+            try
+            {
+                s = t.Line + ":" + (t.CharPositionInLine+1) + ": ";
+                s += new ANTLRTreePrinter( new Antlr.Runtime.Tree.CommonTreeNodeStream( t ) ).toString( this, showActions );
+            }
+            catch ( Exception /*e*/ )
+            {
+                s = "<invalid or missing tree structure>";
+            }
+            return s;
+        }
+
+        public virtual void printGrammar( TextWriter output )
+        {
+            ANTLRTreePrinter printer = new ANTLRTreePrinter( new Antlr.Runtime.Tree.CommonTreeNodeStream( grammarTree ) );
+            //printer.setASTNodeClass( "org.antlr.tool.GrammarAST" );
+            try
+            {
+                string g = printer.toString( this, false );
+                output.WriteLine( g );
+            }
+            catch ( RecognitionException re )
+            {
+                ErrorManager.error( ErrorManager.MSG_SYNTAX_ERROR, re );
+            }
+        }
+
+    }
+}
diff --git a/Antlr3/Tool/GrammarAST.cs b/Antlr3/Tool/GrammarAST.cs
new file mode 100644
index 0000000..2fc4e54
--- /dev/null
+++ b/Antlr3/Tool/GrammarAST.cs
@@ -0,0 +1,598 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using System.Collections.Generic;
+    using System.Linq;
+    using Antlr.Runtime.JavaExtensions;
+    using Antlr3.Extensions;
+
+    using ANTLRParser = Antlr3.Grammars.ANTLRParser;
+    using CommonToken = Antlr.Runtime.CommonToken;
+    using DFA = Antlr3.Analysis.DFA;
+    using IIntSet = Antlr3.Misc.IIntSet;
+    using IToken = Antlr.Runtime.IToken;
+    using ITree = Antlr.Runtime.Tree.ITree;
+    using NFAState = Antlr3.Analysis.NFAState;
+    using StringTemplate = Antlr3.ST.StringTemplate;
+
+    /** Grammars are first converted to ASTs using this class and then are
+     *  converted to NFAs via a tree walker.
+     *
+     *  The reader may notice that I have made a very non-OO decision in this
+     *  class to track variables for many different kinds of nodes.  It wastes
+     *  space for nodes that don't need the values and OO principles cry out
+     *  for a new class type for each kind of node in my tree.  I am doing this
+     *  on purpose for a variety of reasons.  I don't like using the type
+     *  system for different node types; it yields too many damn class files
+     *  which I hate.  Perhaps if I put them all in one file.  Most importantly
+     *  though I hate all the type casting that would have to go on.  I would
+     *  have all sorts of extra work to do.  Ick.  Anyway, I'm doing all this
+     *  on purpose, not out of ignorance. ;)
+     */
+    public class GrammarAST : Antlr.Runtime.Tree.CommonTree
+    {
+        static int count = 0;
+
+        public int ID = ++count;
+
+        /** This AST node was created from what token? */
+        //public Token token = null;
+
+        public string enclosingRuleName;
+
+        /** If this is a decision node, what is the lookahead DFA? */
+        public DFA lookaheadDFA = null;
+
+        /** What NFA start state was built from this node? */
+        public NFAState _nfaStartState = null;
+
+        /** This is used for TREE_BEGIN nodes to point into
+         *  the NFA.  TREE_BEGINs point at left edge of DOWN for LOOK computation
+         *  purposes (Nullable tree child list needs special code gen when matching).
+         */
+        public NFAState NFATreeDownState = null;
+
+        /** Rule ref nodes, token refs, set, and NOT set refs need to track their
+         *  location in the generated NFA so that local FOLLOW sets can be
+         *  computed during code gen for automatic error recovery.
+         */
+        public NFAState followingNFAState = null;
+
+        /** If this is a SET node, what are the elements? */
+        protected IIntSet setValue = null;
+
+        /** If this is a BLOCK node, track options here */
+        protected IDictionary<string, object> blockOptions;
+
+        /** If this is a BLOCK node for a rewrite rule, track referenced
+         *  elements here.  Don't track elements in nested subrules.
+         */
+        public HashSet<GrammarAST> rewriteRefsShallow;
+
+        /*	If REWRITE node, track EVERY element and label ref to right of ->
+         *  for this rewrite rule.  There could be multiple of these per
+         *  rule:
+         *
+         *     a : ( ... -> ... | ... -> ... ) -> ... ;
+         *
+         *  We may need a list of all refs to do definitions for whole rewrite
+         *  later.
+         *
+         *  If BLOCK then tracks every element at that level and below.
+         */
+        public HashSet<GrammarAST> rewriteRefsDeep;
+
+        public IDictionary<string, object> terminalOptions;
+
+        /** if this is an ACTION node, this is the outermost enclosing
+         *  alt num in rule.  For actions, define.g sets these (used to
+         *  be codegen.g).  We need these set so we can examine actions
+         *  early, before code gen, for refs to rule predefined properties
+         *  and rule labels.  For most part define.g sets outerAltNum, but
+         *  codegen.g does the ones for %foo(a={$ID.text}) type refs as
+         *  the {$ID...} is not seen as an action until code gen pulls apart.
+         */
+        public int outerAltNum;
+
+        /** if this is a TOKEN_REF or RULE_REF node, this is the code StringTemplate
+         *  generated for this node.  We need to update it later to add
+         *  a label if someone does $tokenref or $ruleref in an action.
+         */
+        public StringTemplate code;
+
+        public GrammarAST()
+        {
+        }
+
+        public GrammarAST( int t, string txt )
+        {
+            initialize( t, txt );
+        }
+
+        public GrammarAST( IToken token )
+        {
+            initialize( token );
+        }
+
+        #region Properties
+        public IDictionary<string, object> BlockOptions
+        {
+            get
+            {
+                return getBlockOptions();
+            }
+            set
+            {
+                setBlockOptions( value );
+            }
+        }
+        public GrammarAST LastChild
+        {
+            get
+            {
+                if ( ChildCount == 0 )
+                    return null;
+                return (GrammarAST)GetChild( ChildCount - 1 );
+            }
+        }
+        public GrammarAST LastSibling
+        {
+            get
+            {
+                ITree parent = Parent;
+                if ( parent == null )
+                    return null;
+                return (GrammarAST)parent.GetChild( parent.ChildCount - 1 );
+            }
+        }
+        public DFA LookaheadDFA
+        {
+            get
+            {
+                return getLookaheadDFA();
+            }
+            set
+            {
+                setLookaheadDFA( value );
+            }
+        }
+        public NFAState NFAStartState
+        {
+            get
+            {
+                return getNFAStartState();
+            }
+            set
+            {
+                setNFAStartState( value );
+            }
+        }
+        public IIntSet SetValue
+        {
+            get
+            {
+                return getSetValue();
+            }
+            set
+            {
+                setSetValue( value );
+            }
+        }
+        #endregion
+
+        public IDictionary<string, object> getBlockOptions()
+        {
+            return blockOptions;
+        }
+
+        public void setBlockOptions( IDictionary<string, object> value )
+        {
+            blockOptions = value;
+        }
+
+        public virtual void initialize( int i, string s )
+        {
+            token = new CommonToken( i, s );
+        }
+
+        public virtual void initialize( ITree ast )
+        {
+            GrammarAST t = ( (GrammarAST)ast );
+            this.token = t.token;
+            this.enclosingRuleName = t.enclosingRuleName;
+            this.TokenStartIndex = ast.TokenStartIndex;
+            this.TokenStopIndex = ast.TokenStopIndex;
+            this.setValue = t.setValue;
+            this.blockOptions = t.blockOptions;
+            this.outerAltNum = t.outerAltNum;
+        }
+
+        public virtual void initialize( IToken token )
+        {
+            this.token = token;
+        }
+
+        public virtual DFA getLookaheadDFA()
+        {
+            return lookaheadDFA;
+        }
+
+        public virtual void setLookaheadDFA( DFA lookaheadDFA )
+        {
+            this.lookaheadDFA = lookaheadDFA;
+        }
+
+        public virtual NFAState getNFAStartState()
+        {
+            return _nfaStartState;
+        }
+
+        public virtual void setNFAStartState( NFAState nfaStartState )
+        {
+            this._nfaStartState = nfaStartState;
+        }
+
+        /** Save the option key/value pair and process it; return the key
+         *  or null if invalid option.
+         */
+        public virtual string setBlockOption( Grammar grammar, string key, object value )
+        {
+            if ( blockOptions == null )
+            {
+                blockOptions = new Dictionary<string, object>();
+            }
+            return setOption( blockOptions, Grammar.legalBlockOptions, grammar, key, value );
+        }
+
+        public virtual string setTerminalOption( Grammar grammar, string key, object value )
+        {
+            if ( terminalOptions == null )
+            {
+                terminalOptions = new Dictionary<string, object>();
+            }
+            return setOption( terminalOptions, Grammar.legalTokenOptions, grammar, key, value );
+        }
+
+        public virtual string setOption( IDictionary<string, object> options, HashSet<string> legalOptions, Grammar grammar, string key, object value )
+        {
+            if ( !legalOptions.Contains( key ) )
+            {
+                ErrorManager.grammarError( ErrorManager.MSG_ILLEGAL_OPTION,
+                                          grammar,
+                                          token,
+                                          key );
+                return null;
+            }
+            if ( value is string )
+            {
+                string vs = (string)value;
+                if ( vs[0] == '"' )
+                {
+                    value = vs.Substring( 1, vs.Length - 2 ); // strip quotes
+                }
+            }
+            if ( key.Equals( "k" ) )
+            {
+                grammar.numberOfManualLookaheadOptions++;
+            }
+            if ( key == "backtrack" && value.ToString() == "true" )
+            {
+                grammar.composite.getRootGrammar().atLeastOneBacktrackOption = true;
+            }
+            options[key] = value;
+            return key;
+        }
+
+        public virtual object getBlockOption( string key )
+        {
+            object value = null;
+            if ( blockOptions != null )
+            {
+                value = blockOptions.get( key );
+            }
+            return value;
+        }
+
+        public virtual void setOptions( Grammar grammar, IDictionary<string, object> options )
+        {
+            if ( options == null )
+            {
+                this.blockOptions = null;
+                return;
+            }
+            foreach ( string optionName in options.Keys.ToArray() )
+            {
+                string stored = setBlockOption( grammar, optionName, options.get( optionName ) );
+                if ( stored == null )
+                    options.Remove( optionName );
+            }
+        }
+
+        public override string Text
+        {
+            get
+            {
+                if ( token == null )
+                    return string.Empty;
+
+                return token.Text;
+            }
+            set
+            {
+                token.Text = value;
+            }
+        }
+        public override int Type
+        {
+            get
+            {
+                if ( token == null )
+                    return -1;
+
+                return token.Type;
+            }
+            set
+            {
+                token.Type = value;
+            }
+        }
+        public override int Line
+        {
+            get
+            {
+                int line = 0;
+                if ( token != null )
+                {
+                    line = token.Line;
+                }
+                if ( line == 0 )
+                {
+                    ITree child = this.GetChild( 0 );
+                    if ( child != null )
+                    {
+                        line = child.Line;
+                    }
+                }
+                return line;
+            }
+            set
+            {
+                token.Line = value;
+            }
+        }
+        public override int CharPositionInLine
+        {
+            get
+            {
+                int col = 0;
+                if ( token != null )
+                {
+                    col = token.CharPositionInLine;
+                }
+                if ( col == 0 )
+                {
+                    ITree child = this.GetChild( 0 );
+                    if ( child != null )
+                    {
+                        col = child.CharPositionInLine;
+                    }
+                }
+                return col;
+            }
+            set
+            {
+                token.CharPositionInLine = value;
+            }
+        }
+
+        public virtual IIntSet getSetValue()
+        {
+            return setValue;
+        }
+
+        public virtual void setSetValue( IIntSet setValue )
+        {
+            this.setValue = setValue;
+        }
+
+        public virtual GrammarAST getLastChild()
+        {
+            return LastChild;
+        }
+
+        public virtual GrammarAST getLastSibling()
+        {
+            return LastSibling;
+        }
+
+        public virtual GrammarAST[] getChildrenAsArray()
+        {
+            return Children.CastListDown<GrammarAST, ITree>().ToArray();
+        }
+
+        // used in enumerating the descendants of a node
+        static readonly GrammarAST DescendantDownNode = new GrammarAST( Antlr.Runtime.TokenConstants.DOWN, "DOWN" );
+        static readonly GrammarAST DescendantUpNode = new GrammarAST( Antlr.Runtime.TokenConstants.UP, "UP" );
+
+        public static IEnumerable<ITree> Descendants( ITree root )
+        {
+            return Descendants( root, false );
+        }
+        public static IEnumerable<ITree> Descendants( ITree root, bool insertDownUpNodes )
+        {
+            int count = root.ChildCount;
+
+            if ( insertDownUpNodes )
+            {
+                yield return root;
+
+                yield return DescendantDownNode;
+
+                for ( int i = 0; i < count; i++ )
+                {
+                    ITree child = root.GetChild( i );
+                    foreach ( ITree subchild in Descendants( child, true ) )
+                        yield return subchild;
+                }
+
+                yield return DescendantUpNode;
+            }
+            else
+            {
+                for ( int i = 0; i < count; i++ )
+                {
+                    ITree child = root.GetChild( i );
+
+                    yield return child;
+
+                    foreach ( ITree subchild in Descendants( child, false ) )
+                        yield return subchild;
+                }
+            }
+        }
+
+        /** Return a reference to the first node (depth-first) that has
+         *  token type ttype.  Assume 'this' is a root node; don't visit siblings
+         *  of root.  Return null if no node found with ttype.
+         */
+        public GrammarAST findFirstType( int ttype )
+        {
+            // check this node (the root) first
+            if ( this.Type == ttype )
+                return this;
+
+            // else check children
+            return Descendants( this ).OfType<GrammarAST>().FirstOrDefault( child => child.Type == ttype );
+        }
+
+        /** Make nodes unique based upon Token so we can add them to a Set; if
+         *  not a GrammarAST, check type.
+         */
+        public override bool Equals( object ast )
+        {
+            if ( this == ast )
+            {
+                return true;
+            }
+
+            GrammarAST t = (GrammarAST)ast;
+            if ( t == null )
+            {
+                ITree a = ast as ITree;
+                return a != null && Type == a.Type;
+            }
+
+            return token.Line == t.Line &&
+                   token.CharPositionInLine == t.CharPositionInLine;
+        }
+
+        public override int GetHashCode()
+        {
+            return ObjectExtensions.ShiftPrimeXOR( token.Line, token.CharPositionInLine );
+        }
+
+        /** See if tree has exact token types and structure; no text */
+        public bool hasSameTreeStructure( ITree other )
+        {
+            // check roots first.
+            if ( Type != other.Type )
+                return false;
+
+            // if roots match, do full list match test on children.
+            return Descendants( this, true ).SequenceEqual( Descendants( other, true ), ( a, b ) => a.Type == b.Type );
+        }
+
+        public static GrammarAST dup( ITree t )
+        {
+            if ( t == null )
+            {
+                return null;
+            }
+            GrammarAST dup_t = new GrammarAST();
+            dup_t.initialize( t );
+            return dup_t;
+        }
+
+        public override ITree DupNode()
+        {
+            return dup( this );
+        }
+
+        static IEnumerable<GrammarAST> GetChildrenForDupTree( GrammarAST t )
+        {
+            for ( int i = 0; i < t.ChildCount; i++ )
+            {
+                GrammarAST child = (GrammarAST)t.GetChild( i );
+                int ttype = child.Type;
+                if ( ttype == ANTLRParser.REWRITE )
+                {
+                    continue;
+                }
+                else if ( ttype == ANTLRParser.BANG || ttype == ANTLRParser.ROOT )
+                {
+                    foreach ( GrammarAST subchild in GetChildrenForDupTree( child ) )
+                        yield return subchild;
+                }
+                else
+                {
+                    yield return child;
+                }
+            }
+        }
+
+        /**Duplicate a tree, assuming this is a root node of a tree--
+         * duplicate that node and what's below; ignore siblings of root node.
+         */
+        public static GrammarAST dupTreeNoActions( GrammarAST t, GrammarAST parent )
+        {
+            GrammarAST d = (GrammarAST)t.DupNode();
+            foreach ( GrammarAST subchild in GetChildrenForDupTree( t ) )
+                d.AddChild( dupTreeNoActions( subchild, d ) );
+
+            return d;
+        }
+
+        public void setTreeEnclosingRuleNameDeeply( string rname )
+        {
+            enclosingRuleName = rname;
+            foreach ( GrammarAST child in Descendants( this ).OfType<GrammarAST>() )
+                child.enclosingRuleName = rname;
+        }
+
+        internal string ToStringList()
+        {
+            throw new System.NotImplementedException();
+        }
+    }
+}
diff --git a/Antlr3/Tool/GrammarAnalysisAbortedMessage.cs b/Antlr3/Tool/GrammarAnalysisAbortedMessage.cs
new file mode 100644
index 0000000..f83ec94
--- /dev/null
+++ b/Antlr3/Tool/GrammarAnalysisAbortedMessage.cs
@@ -0,0 +1,69 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using DecisionProbe = Antlr3.Analysis.DecisionProbe;
+    using StringTemplate = Antlr3.ST.StringTemplate;
+
+    /** Reports the condition that ANTLR's LL(*) analysis engine terminated
+     *  early.
+     */
+    public class GrammarAnalysisAbortedMessage : Message
+    {
+        public DecisionProbe probe;
+
+        public GrammarAnalysisAbortedMessage( DecisionProbe probe )
+            : base( ErrorManager.MSG_ANALYSIS_ABORTED )
+        {
+            this.probe = probe;
+        }
+
+        public override string ToString()
+        {
+            GrammarAST decisionASTNode = probe.dfa.DecisionASTNode;
+            line = decisionASTNode.Line;
+            charPositionInLine = decisionASTNode.CharPositionInLine;
+            string fileName = probe.dfa.nfa.grammar.FileName;
+            if ( fileName != null )
+            {
+                file = fileName;
+            }
+            StringTemplate st = getMessageTemplate();
+            st.setAttribute( "enclosingRule",
+                            probe.dfa.NFADecisionStartState.enclosingRule.name );
+
+            return base.ToString( st );
+        }
+
+    }
+}
diff --git a/Antlr3/Tool/GrammarDanglingStateMessage.cs b/Antlr3/Tool/GrammarDanglingStateMessage.cs
new file mode 100644
index 0000000..3614c4c
--- /dev/null
+++ b/Antlr3/Tool/GrammarDanglingStateMessage.cs
@@ -0,0 +1,82 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using System.Collections.Generic;
+    using Antlr.Runtime.JavaExtensions;
+
+    using DecisionProbe = Antlr3.Analysis.DecisionProbe;
+    using DFAState = Antlr3.Analysis.DFAState;
+    using StringTemplate = Antlr3.ST.StringTemplate;
+
+    /** Reports a potential parsing issue with a decision; the decision is
+     *  nondeterministic in some way.
+     */
+    public class GrammarDanglingStateMessage : Message
+    {
+        public DecisionProbe probe;
+        public DFAState problemState;
+
+        public GrammarDanglingStateMessage( DecisionProbe probe,
+                                           DFAState problemState )
+            : base( ErrorManager.MSG_DANGLING_STATE )
+        {
+            this.probe = probe;
+            this.problemState = problemState;
+        }
+
+        public override string ToString()
+        {
+            GrammarAST decisionASTNode = probe.dfa.DecisionASTNode;
+            line = decisionASTNode.Line;
+            charPositionInLine = decisionASTNode.CharPositionInLine;
+            string fileName = probe.dfa.nfa.grammar.FileName;
+            if ( fileName != null )
+            {
+                file = fileName;
+            }
+            var labels = probe.getSampleNonDeterministicInputSequence( problemState );
+            string input = probe.getInputSequenceDisplay( labels );
+            StringTemplate st = getMessageTemplate();
+            List<int> alts = new List<int>();
+            alts.addAll( problemState.AltSet );
+            alts.Sort();
+            //Collections.sort(alts);
+            st.setAttribute( "danglingAlts", alts );
+            st.setAttribute( "input", input );
+
+            return base.ToString( st );
+        }
+
+    }
+}
diff --git a/Antlr3/Tool/GrammarInsufficientPredicatesMessage.cs b/Antlr3/Tool/GrammarInsufficientPredicatesMessage.cs
new file mode 100644
index 0000000..5439b50
--- /dev/null
+++ b/Antlr3/Tool/GrammarInsufficientPredicatesMessage.cs
@@ -0,0 +1,99 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using System.Collections.Generic;
+    using Antlr.Runtime.JavaExtensions;
+    using Antlr3.Analysis;
+
+    using IToken = Antlr.Runtime.IToken;
+    using StringTemplate = Antlr3.ST.StringTemplate;
+
+    public class GrammarInsufficientPredicatesMessage : Message
+    {
+        public DecisionProbe probe;
+        public IDictionary<int, ICollection<IToken>> altToLocations;
+        public DFAState problemState;
+
+        public GrammarInsufficientPredicatesMessage( DecisionProbe probe,
+                                                    DFAState problemState,
+                                                    IDictionary<int, ICollection<IToken>> altToLocations )
+            : base( ErrorManager.MSG_INSUFFICIENT_PREDICATES )
+        {
+            this.probe = probe;
+            this.problemState = problemState;
+            this.altToLocations = altToLocations;
+        }
+
+        public override string ToString()
+        {
+            GrammarAST decisionASTNode = probe.dfa.DecisionASTNode;
+            line = decisionASTNode.Line;
+            charPositionInLine = decisionASTNode.CharPositionInLine;
+            string fileName = probe.dfa.nfa.grammar.FileName;
+            if ( fileName != null )
+            {
+                file = fileName;
+            }
+            StringTemplate st = getMessageTemplate();
+            // convert to string key to avoid 3.1 ST bug
+            var altToLocationsWithStringKey = new SortedList<string, ICollection<IToken>>();
+            List<int> alts = new List<int>();
+            alts.addAll( altToLocations.Keys );
+            alts.Sort();
+            //Collections.sort(alts);
+            foreach ( int altI in alts )
+            {
+                altToLocationsWithStringKey[altI.ToString()] = altToLocations.get( altI );
+                /*
+                List<String> tokens = new ArrayList<String>();
+                for (Token t : altToLocations.get(altI)) {
+                    tokens.add(t.toString());
+                }
+                Collections.sort(tokens);
+                System.out.println("tokens=\n"+tokens);
+                */
+            }
+            st.setAttribute( "altToLocations", altToLocationsWithStringKey );
+
+            var sampleInputLabels = problemState.dfa.probe.getSampleNonDeterministicInputSequence( problemState );
+            string input = problemState.dfa.probe.getInputSequenceDisplay( sampleInputLabels );
+            st.setAttribute( "upon", input );
+
+            st.setAttribute( "hasPredicateBlockedByAction", problemState.dfa.hasPredicateBlockedByAction );
+
+            return base.ToString( st );
+        }
+
+    }
+}
diff --git a/Antlr3/Tool/GrammarNonDeterminismMessage.cs b/Antlr3/Tool/GrammarNonDeterminismMessage.cs
new file mode 100644
index 0000000..c8be261
--- /dev/null
+++ b/Antlr3/Tool/GrammarNonDeterminismMessage.cs
@@ -0,0 +1,146 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using System;
+    using Antlr.Runtime.JavaExtensions;
+
+    using DecisionProbe = Antlr3.Analysis.DecisionProbe;
+    using DFAState = Antlr3.Analysis.DFAState;
+    using IList = System.Collections.IList;
+    using NFAState = Antlr3.Analysis.NFAState;
+    using StringTemplate = Antlr3.ST.StringTemplate;
+
+    /** Reports a potential parsing issue with a decision; the decision is
+     *  nondeterministic in some way.
+     */
+    public class GrammarNonDeterminismMessage : Message
+    {
+        public DecisionProbe probe;
+        public DFAState problemState;
+
+        public GrammarNonDeterminismMessage( DecisionProbe probe,
+                                            DFAState problemState )
+            : base( ErrorManager.MSG_GRAMMAR_NONDETERMINISM )
+        {
+            this.probe = probe;
+            this.problemState = problemState;
+            // flip msg ID if alts are actually token refs in Tokens rule
+            if ( probe.dfa.IsTokensRuleDecision )
+            {
+                setMessageID( ErrorManager.MSG_TOKEN_NONDETERMINISM );
+            }
+        }
+
+        public override String ToString()
+        {
+            GrammarAST decisionASTNode = probe.dfa.DecisionASTNode;
+            line = decisionASTNode.Line;
+            charPositionInLine = decisionASTNode.CharPositionInLine;
+            String fileName = probe.dfa.nfa.grammar.FileName;
+            if ( fileName != null )
+            {
+                file = fileName;
+            }
+
+            StringTemplate st = getMessageTemplate();
+            // Now fill template with information about problemState
+            var labels = probe.getSampleNonDeterministicInputSequence( problemState );
+            String input = probe.getInputSequenceDisplay( labels );
+            st.setAttribute( "input", input );
+
+            if ( probe.dfa.IsTokensRuleDecision )
+            {
+                var disabledAlts = probe.getDisabledAlternatives( problemState );
+                foreach ( int altI in disabledAlts )
+                {
+                    String tokenName =
+                        probe.getTokenNameForTokensRuleAlt( (int)altI );
+                    // reset the line/col to the token definition (pick last one)
+                    NFAState ruleStart =
+                        probe.dfa.nfa.grammar.getRuleStartState( tokenName );
+                    line = ruleStart.associatedASTNode.Line;
+                    charPositionInLine = ruleStart.associatedASTNode.CharPositionInLine;
+                    st.setAttribute( "disabled", tokenName );
+                }
+            }
+            else
+            {
+                st.setAttribute( "disabled", probe.getDisabledAlternatives( problemState ) );
+            }
+
+            IList nondetAlts = probe.getNonDeterministicAltsForState( problemState );
+            NFAState nfaStart = probe.dfa.NFADecisionStartState;
+            // all state paths have to begin with same NFA state
+            int firstAlt = 0;
+            if ( nondetAlts != null )
+            {
+                foreach ( int displayAltI in nondetAlts )
+                {
+                    if ( DecisionProbe.verbose )
+                    {
+                        int tracePathAlt =
+                            nfaStart.translateDisplayAltToWalkAlt( (int)displayAltI );
+                        if ( firstAlt == 0 )
+                        {
+                            firstAlt = tracePathAlt;
+                        }
+                        IList path =
+                            probe.getNFAPathStatesForAlt( firstAlt,
+                                                         tracePathAlt,
+                                                         labels );
+                        st.setAttribute( "paths.{alt,states}",
+                                        displayAltI, path );
+                    }
+                    else
+                    {
+                        if ( probe.dfa.IsTokensRuleDecision )
+                        {
+                            // alts are token rules, convert to the names instead of numbers
+                            String tokenName =
+                                probe.getTokenNameForTokensRuleAlt( (int)displayAltI );
+                            st.setAttribute( "conflictingTokens", tokenName );
+                        }
+                        else
+                        {
+                            st.setAttribute( "conflictingAlts", displayAltI );
+                        }
+                    }
+                }
+            }
+            st.setAttribute( "hasPredicateBlockedByAction", problemState.dfa.hasPredicateBlockedByAction );
+            return base.ToString( st );
+        }
+
+    }
+}
diff --git a/Antlr3/Tool/GrammarReport.cs b/Antlr3/Tool/GrammarReport.cs
new file mode 100644
index 0000000..c776872
--- /dev/null
+++ b/Antlr3/Tool/GrammarReport.cs
@@ -0,0 +1,425 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using System.Collections.Generic;
+    using System.Linq;
+    using Antlr.Runtime.JavaExtensions;
+
+    using DFA = Antlr3.Analysis.DFA;
+    using Stats = Antlr.Runtime.Misc.Stats;
+    using StringBuilder = System.Text.StringBuilder;
+
+    public class GrammarReport
+    {
+        /** Because I may change the stats, I need to track that for later
+         *  computations to be consistent.
+         */
+        public const string Version = "4";
+        public const string GRAMMAR_STATS_FILENAME = "grammar.stats";
+        public const int NUM_GRAMMAR_STATS = 41;
+
+        public static readonly string newline = System.Environment.NewLine; //System.getProperty("line.separator");
+
+        public Grammar grammar;
+
+        public GrammarReport( Grammar grammar )
+        {
+            this.grammar = grammar;
+        }
+
+        /** Create a single-line stats report about this grammar suitable to
+         *  send to the notify page at antlr.org
+         */
+        public virtual string toNotifyString()
+        {
+            StringBuilder buf = new StringBuilder();
+            buf.Append( Version );
+            buf.Append( '\t' );
+            buf.Append( grammar.name );
+            buf.Append( '\t' );
+            buf.Append( grammar.GrammarTypeString );
+            buf.Append( '\t' );
+            buf.Append( grammar.getOption( "language" ) );
+            int totalNonSynPredProductions = 0;
+            int totalNonSynPredRules = 0;
+            foreach ( Rule r in grammar.Rules )
+            {
+                if ( !r.name.ToUpperInvariant()
+                    .StartsWith( Grammar.SYNPRED_RULE_PREFIX.ToUpperInvariant() ) )
+                {
+                    totalNonSynPredProductions += r.numberOfAlts;
+                    totalNonSynPredRules++;
+                }
+            }
+            buf.Append( '\t' );
+            buf.Append( totalNonSynPredRules );
+            buf.Append( '\t' );
+            buf.Append( totalNonSynPredProductions );
+            int numACyclicDecisions =
+                grammar.NumberOfDecisions - grammar.getNumberOfCyclicDecisions();
+            int[] depths = new int[numACyclicDecisions];
+            int[] acyclicDFAStates = new int[numACyclicDecisions];
+            int[] cyclicDFAStates = new int[grammar.getNumberOfCyclicDecisions()];
+            int acyclicIndex = 0;
+            int cyclicIndex = 0;
+            int numLL1 = 0;
+            int numDec = 0;
+            for ( int i = 1; i <= grammar.NumberOfDecisions; i++ )
+            {
+                Grammar.Decision d = grammar.getDecision( i );
+                if ( d.dfa == null )
+                {
+                    continue;
+                }
+                numDec++;
+                if ( !d.dfa.IsCyclic )
+                {
+                    int maxk = d.dfa.MaxLookaheadDepth;
+                    if ( maxk == 1 )
+                    {
+                        numLL1++;
+                    }
+                    depths[acyclicIndex] = maxk;
+                    acyclicDFAStates[acyclicIndex] = d.dfa.NumberOfStates;
+                    acyclicIndex++;
+                }
+                else
+                {
+                    cyclicDFAStates[cyclicIndex] = d.dfa.NumberOfStates;
+                    cyclicIndex++;
+                }
+            }
+            buf.Append( '\t' );
+            buf.Append( numDec );
+            buf.Append( '\t' );
+            buf.Append( grammar.getNumberOfCyclicDecisions() );
+            buf.Append( '\t' );
+            buf.Append( numLL1 );
+            buf.Append( '\t' );
+            buf.Append( depths.Min() );
+            buf.Append( '\t' );
+            buf.Append( depths.Max() );
+            buf.Append( '\t' );
+            buf.Append( depths.Average() );
+            buf.Append( '\t' );
+            buf.Append( Stats.Stddev( depths ) );
+            buf.Append( '\t' );
+            buf.Append( acyclicDFAStates.Min() );
+            buf.Append( '\t' );
+            buf.Append( acyclicDFAStates.Max() );
+            buf.Append( '\t' );
+            buf.Append( acyclicDFAStates.Average() );
+            buf.Append( '\t' );
+            buf.Append( Stats.Stddev( acyclicDFAStates ) );
+            buf.Append( '\t' );
+            buf.Append( acyclicDFAStates.Sum() );
+            buf.Append( '\t' );
+            buf.Append( cyclicDFAStates.Min() );
+            buf.Append( '\t' );
+            buf.Append( cyclicDFAStates.Max() );
+            buf.Append( '\t' );
+            buf.Append( cyclicDFAStates.Average() );
+            buf.Append( '\t' );
+            buf.Append( Stats.Stddev( cyclicDFAStates ) );
+            buf.Append( '\t' );
+            buf.Append( cyclicDFAStates.Sum() );
+            buf.Append( '\t' );
+            buf.Append( grammar.TokenTypes.size() );
+            buf.Append( '\t' );
+            buf.Append( grammar.DFACreationWallClockTimeInMS );
+            buf.Append( '\t' );
+            buf.Append( grammar.numberOfSemanticPredicates );
+            buf.Append( '\t' );
+            buf.Append( grammar.numberOfManualLookaheadOptions );
+            buf.Append( '\t' );
+            buf.Append( grammar.setOfNondeterministicDecisionNumbers.Count );
+            buf.Append( '\t' );
+            buf.Append( grammar.setOfNondeterministicDecisionNumbersResolvedWithPredicates.Count );
+            buf.Append( '\t' );
+            buf.Append( grammar.setOfDFAWhoseAnalysisTimedOut.Count );
+            buf.Append( '\t' );
+            buf.Append( ErrorManager.getErrorState().errors );
+            buf.Append( '\t' );
+            buf.Append( ErrorManager.getErrorState().warnings );
+            buf.Append( '\t' );
+            buf.Append( ErrorManager.getErrorState().infos );
+            buf.Append( '\t' );
+            var synpreds = grammar.SyntacticPredicates;
+            int num_synpreds = synpreds != null ? synpreds.Count : 0;
+            buf.Append( num_synpreds );
+            buf.Append( '\t' );
+            buf.Append( grammar.blocksWithSynPreds.Count );
+            buf.Append( '\t' );
+            buf.Append( grammar.decisionsWhoseDFAsUsesSynPreds.Count );
+            buf.Append( '\t' );
+            buf.Append( grammar.blocksWithSemPreds.Count );
+            buf.Append( '\t' );
+            buf.Append( grammar.decisionsWhoseDFAsUsesSemPreds.Count );
+            buf.Append( '\t' );
+            string output = (string)grammar.getOption( "output" );
+            if ( output == null )
+            {
+                output = "none";
+            }
+            buf.Append( output );
+            buf.Append( '\t' );
+            object k = grammar.getOption( "k" );
+            if ( k == null )
+            {
+                k = "none";
+            }
+            buf.Append( k );
+            buf.Append( '\t' );
+            string backtrack = (string)grammar.getOption( "backtrack" );
+            if ( backtrack == null )
+            {
+                backtrack = "false";
+            }
+            buf.Append( backtrack );
+            return buf.ToString();
+        }
+
+        public virtual string getBacktrackingReport()
+        {
+            StringBuilder buf = new StringBuilder();
+            buf.Append( "Backtracking report:" );
+            buf.Append( newline );
+            buf.Append( "Number of decisions that backtrack: " );
+            buf.Append( grammar.decisionsWhoseDFAsUsesSynPreds.Count );
+            buf.Append( newline );
+            buf.Append( getDFALocations( grammar.decisionsWhoseDFAsUsesSynPreds ) );
+            return buf.ToString();
+        }
+
+        public virtual string getAnalysisTimeoutReport()
+        {
+            StringBuilder buf = new StringBuilder();
+            buf.Append( "NFA conversion early termination report:" );
+            buf.Append( newline );
+            buf.Append( "Number of NFA conversions that terminated early: " );
+            buf.Append( grammar.setOfDFAWhoseAnalysisTimedOut.Count );
+            buf.Append( newline );
+            buf.Append( getDFALocations( grammar.setOfDFAWhoseAnalysisTimedOut ) );
+            return buf.ToString();
+        }
+
+        protected virtual string getDFALocations( HashSet<DFA> dfas )
+        {
+            HashSet<int> decisions = new HashSet<int>();
+            StringBuilder buf = new StringBuilder();
+            foreach ( DFA dfa in dfas )
+            {
+                // if we aborted a DFA and redid with k=1, the backtrackin
+                if ( decisions.Contains( dfa.decisionNumber ) )
+                {
+                    continue;
+                }
+                decisions.Add( dfa.decisionNumber );
+                buf.Append( "Rule " );
+                buf.Append( dfa.decisionNFAStartState.enclosingRule.name );
+                buf.Append( " decision " );
+                buf.Append( dfa.decisionNumber );
+                buf.Append( " location " );
+                GrammarAST decisionAST =
+                    dfa.decisionNFAStartState.associatedASTNode;
+                buf.Append( decisionAST.Line );
+                buf.Append( ":" );
+                buf.Append( decisionAST.CharPositionInLine );
+                buf.Append( newline );
+            }
+            return buf.ToString();
+        }
+
+        /** Given a stats line suitable for sending to the antlr.org site,
+         *  return a human-readable version.  Return null if there is a
+         *  problem with the data.
+         */
+        public override string ToString()
+        {
+            return toString( toNotifyString() );
+        }
+
+        protected static string[] decodeReportData( string data )
+        {
+            string[] fields = new string[NUM_GRAMMAR_STATS];
+            StringTokenizer st = new StringTokenizer( data, "\t" );
+            int i = 0;
+            while ( st.hasMoreTokens() )
+            {
+                fields[i] = st.nextToken();
+                i++;
+            }
+            if ( i != NUM_GRAMMAR_STATS )
+            {
+                return null;
+            }
+            return fields;
+        }
+
+        public static string toString( string notifyDataLine )
+        {
+            string[] fields = decodeReportData( notifyDataLine );
+            if ( fields == null )
+            {
+                return null;
+            }
+            StringBuilder buf = new StringBuilder();
+            buf.Append( "ANTLR Grammar Report; Stats Version " );
+            buf.Append( fields[0] );
+            buf.Append( '\n' );
+            buf.Append( "Grammar: " );
+            buf.Append( fields[1] );
+            buf.Append( '\n' );
+            buf.Append( "Type: " );
+            buf.Append( fields[2] );
+            buf.Append( '\n' );
+            buf.Append( "Target language: " );
+            buf.Append( fields[3] );
+            buf.Append( '\n' );
+            buf.Append( "Output: " );
+            buf.Append( fields[38] );
+            buf.Append( '\n' );
+            buf.Append( "Grammar option k: " );
+            buf.Append( fields[39] );
+            buf.Append( '\n' );
+            buf.Append( "Grammar option backtrack: " );
+            buf.Append( fields[40] );
+            buf.Append( '\n' );
+            buf.Append( "Rules: " );
+            buf.Append( fields[4] );
+            buf.Append( '\n' );
+            buf.Append( "Productions: " );
+            buf.Append( fields[5] );
+            buf.Append( '\n' );
+            buf.Append( "Decisions: " );
+            buf.Append( fields[6] );
+            buf.Append( '\n' );
+            buf.Append( "Cyclic DFA decisions: " );
+            buf.Append( fields[7] );
+            buf.Append( '\n' );
+            buf.Append( "LL(1) decisions: " );
+            buf.Append( fields[8] );
+            buf.Append( '\n' );
+            buf.Append( "Min fixed k: " );
+            buf.Append( fields[9] );
+            buf.Append( '\n' );
+            buf.Append( "Max fixed k: " );
+            buf.Append( fields[10] );
+            buf.Append( '\n' );
+            buf.Append( "Average fixed k: " );
+            buf.Append( fields[11] );
+            buf.Append( '\n' );
+            buf.Append( "Standard deviation of fixed k: " );
+            buf.Append( fields[12] );
+            buf.Append( '\n' );
+            buf.Append( "Min acyclic DFA states: " );
+            buf.Append( fields[13] );
+            buf.Append( '\n' );
+            buf.Append( "Max acyclic DFA states: " );
+            buf.Append( fields[14] );
+            buf.Append( '\n' );
+            buf.Append( "Average acyclic DFA states: " );
+            buf.Append( fields[15] );
+            buf.Append( '\n' );
+            buf.Append( "Standard deviation of acyclic DFA states: " );
+            buf.Append( fields[16] );
+            buf.Append( '\n' );
+            buf.Append( "Total acyclic DFA states: " );
+            buf.Append( fields[17] );
+            buf.Append( '\n' );
+            buf.Append( "Min cyclic DFA states: " );
+            buf.Append( fields[18] );
+            buf.Append( '\n' );
+            buf.Append( "Max cyclic DFA states: " );
+            buf.Append( fields[19] );
+            buf.Append( '\n' );
+            buf.Append( "Average cyclic DFA states: " );
+            buf.Append( fields[20] );
+            buf.Append( '\n' );
+            buf.Append( "Standard deviation of cyclic DFA states: " );
+            buf.Append( fields[21] );
+            buf.Append( '\n' );
+            buf.Append( "Total cyclic DFA states: " );
+            buf.Append( fields[22] );
+            buf.Append( '\n' );
+            buf.Append( "Vocabulary size: " );
+            buf.Append( fields[23] );
+            buf.Append( '\n' );
+            buf.Append( "DFA creation time in ms: " );
+            buf.Append( fields[24] );
+            buf.Append( '\n' );
+            buf.Append( "Number of semantic predicates found: " );
+            buf.Append( fields[25] );
+            buf.Append( '\n' );
+            buf.Append( "Number of manual fixed lookahead k=value options: " );
+            buf.Append( fields[26] );
+            buf.Append( '\n' );
+            buf.Append( "Number of nondeterministic decisions: " );
+            buf.Append( fields[27] );
+            buf.Append( '\n' );
+            buf.Append( "Number of nondeterministic decisions resolved with predicates: " );
+            buf.Append( fields[28] );
+            buf.Append( '\n' );
+            buf.Append( "Number of DFA conversions terminated early: " );
+            buf.Append( fields[29] );
+            buf.Append( '\n' );
+            buf.Append( "Number of errors: " );
+            buf.Append( fields[30] );
+            buf.Append( '\n' );
+            buf.Append( "Number of warnings: " );
+            buf.Append( fields[31] );
+            buf.Append( '\n' );
+            buf.Append( "Number of infos: " );
+            buf.Append( fields[32] );
+            buf.Append( '\n' );
+            buf.Append( "Number of syntactic predicates found: " );
+            buf.Append( fields[33] );
+            buf.Append( '\n' );
+            buf.Append( "Decisions with syntactic predicates: " );
+            buf.Append( fields[34] );
+            buf.Append( '\n' );
+            buf.Append( "Decision DFAs using syntactic predicates: " );
+            buf.Append( fields[35] );
+            buf.Append( '\n' );
+            buf.Append( "Decisions with semantic predicates: " );
+            buf.Append( fields[36] );
+            buf.Append( '\n' );
+            buf.Append( "Decision DFAs using semantic predicates: " );
+            buf.Append( fields[37] );
+            buf.Append( '\n' );
+            return buf.ToString();
+        }
+
+    }
+}
diff --git a/Antlr3/Tool/GrammarSanity.cs b/Antlr3/Tool/GrammarSanity.cs
new file mode 100644
index 0000000..e40ba1d
--- /dev/null
+++ b/Antlr3/Tool/GrammarSanity.cs
@@ -0,0 +1,367 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using System.Collections.Generic;
+    using Antlr.Runtime.JavaExtensions;
+
+    using ANTLRParser = Antlr3.Grammars.ANTLRParser;
+    using NFAState = Antlr3.Analysis.NFAState;
+    using RuleClosureTransition = Antlr3.Analysis.RuleClosureTransition;
+    using Transition = Antlr3.Analysis.Transition;
+
+    /** Factor out routines that check sanity of rules, alts, grammars, etc.. */
+    public class GrammarSanity
+    {
+        /** The checkForLeftRecursion method needs to track what rules it has
+         *  visited to track infinite recursion.
+         */
+        protected HashSet<Rule> visitedDuringRecursionCheck = null;
+
+        protected Grammar grammar;
+        public GrammarSanity( Grammar grammar )
+        {
+            this.grammar = grammar;
+        }
+
+        /** Check all rules for infinite left recursion before analysis. Return list
+         *  of troublesome rule cycles.  This method has two side-effects: it notifies
+         *  the error manager that we have problems and it sets the list of
+         *  recursive rules that we should ignore during analysis.
+         */
+        public virtual IList<HashSet<Rule>> checkAllRulesForLeftRecursion()
+        {
+            grammar.buildNFA(); // make sure we have NFAs
+            grammar.leftRecursiveRules = new HashSet<Rule>();
+            List<HashSet<Rule>> listOfRecursiveCycles = new List<HashSet<Rule>>();
+            for ( int i = 0; i < grammar.composite.ruleIndexToRuleList.Count; i++ )
+            {
+                Rule r = grammar.composite.ruleIndexToRuleList[i];
+                if ( r != null )
+                {
+                    visitedDuringRecursionCheck = new HashSet<Rule>();
+                    visitedDuringRecursionCheck.Add( r );
+                    HashSet<object> visitedStates = new HashSet<object>();
+                    traceStatesLookingForLeftRecursion( r.startState,
+                                                       visitedStates,
+                                                       listOfRecursiveCycles );
+                }
+            }
+            if ( listOfRecursiveCycles.Count > 0 )
+            {
+                ErrorManager.leftRecursionCycles( listOfRecursiveCycles );
+            }
+            return listOfRecursiveCycles;
+        }
+
+        /** From state s, look for any transition to a rule that is currently
+         *  being traced.  When tracing r, visitedDuringRecursionCheck has r
+         *  initially.  If you reach an accept state, return but notify the
+         *  invoking rule that it is nullable, which implies that invoking
+         *  rule must look at follow transition for that invoking state.
+         *  The visitedStates tracks visited states within a single rule so
+         *  we can avoid epsilon-loop-induced infinite recursion here.  Keep
+         *  filling the cycles in listOfRecursiveCycles and also, as a
+         *  side-effect, set leftRecursiveRules.
+         */
+        protected virtual bool traceStatesLookingForLeftRecursion( NFAState s,
+                                                             HashSet<object> visitedStates,
+                                                             IList<HashSet<Rule>> listOfRecursiveCycles )
+        {
+            if ( s.IsAcceptState )
+            {
+                // this rule must be nullable!
+                // At least one epsilon edge reached accept state
+                return true;
+            }
+            if ( visitedStates.Contains( s ) )
+            {
+                // within same rule, we've hit same state; quit looping
+                return false;
+            }
+            visitedStates.Add( s );
+            bool stateReachesAcceptState = false;
+            Transition t0 = s.transition[0];
+            if ( t0 is RuleClosureTransition )
+            {
+                RuleClosureTransition refTrans = (RuleClosureTransition)t0;
+                Rule refRuleDef = refTrans.rule;
+                //String targetRuleName = ((NFAState)t0.target).getEnclosingRule();
+                if ( visitedDuringRecursionCheck.Contains( refRuleDef ) )
+                {
+                    // record left-recursive rule, but don't go back in
+                    grammar.leftRecursiveRules.Add( refRuleDef );
+                    /*
+                    System.out.println("already visited "+refRuleDef+", calling from "+
+                                       s.enclosingRule);
+                                       */
+                    addRulesToCycle( refRuleDef,
+                                    s.enclosingRule,
+                                    listOfRecursiveCycles );
+                }
+                else
+                {
+                    // must visit if not already visited; send new visitedStates set
+                    visitedDuringRecursionCheck.Add( refRuleDef );
+                    bool callReachedAcceptState =
+                        traceStatesLookingForLeftRecursion( (NFAState)t0.target,
+                                                           new HashSet<object>(),
+                                                           listOfRecursiveCycles );
+                    // we're back from visiting that rule
+                    visitedDuringRecursionCheck.Remove( refRuleDef );
+                    // must keep going in this rule then
+                    if ( callReachedAcceptState )
+                    {
+                        NFAState followingState =
+                            ( (RuleClosureTransition)t0 ).followState;
+                        stateReachesAcceptState |=
+                            traceStatesLookingForLeftRecursion( followingState,
+                                                               visitedStates,
+                                                               listOfRecursiveCycles );
+                    }
+                }
+            }
+            else if ( t0.label.IsEpsilon || t0.label.IsSemanticPredicate )
+            {
+                stateReachesAcceptState |=
+                    traceStatesLookingForLeftRecursion( (NFAState)t0.target, visitedStates, listOfRecursiveCycles );
+            }
+            // else it has a labeled edge
+
+            // now do the other transition if it exists
+            Transition t1 = s.transition[1];
+            if ( t1 != null )
+            {
+                stateReachesAcceptState |=
+                    traceStatesLookingForLeftRecursion( (NFAState)t1.target,
+                                                       visitedStates,
+                                                       listOfRecursiveCycles );
+            }
+            return stateReachesAcceptState;
+        }
+
+        /** enclosingRuleName calls targetRuleName, find the cycle containing
+         *  the target and add the caller.  Find the cycle containing the caller
+         *  and add the target.  If no cycles contain either, then create a new
+         *  cycle.  listOfRecursiveCycles is List<Set<String>> that holds a list
+         *  of cycles (sets of rule names).
+         */
+        protected virtual void addRulesToCycle( Rule targetRule,
+                                       Rule enclosingRule,
+                                       IList<HashSet<Rule>> listOfRecursiveCycles )
+        {
+            bool foundCycle = false;
+            for ( int i = 0; i < listOfRecursiveCycles.Count; i++ )
+            {
+                HashSet<Rule> rulesInCycle = listOfRecursiveCycles[i];
+                // ensure both rules are in same cycle
+                if ( rulesInCycle.Contains( targetRule ) )
+                {
+                    rulesInCycle.Add( enclosingRule );
+                    foundCycle = true;
+                }
+                if ( rulesInCycle.Contains( enclosingRule ) )
+                {
+                    rulesInCycle.Add( targetRule );
+                    foundCycle = true;
+                }
+            }
+            if ( !foundCycle )
+            {
+                HashSet<Rule> cycle = new HashSet<Rule>();
+                cycle.Add( targetRule );
+                cycle.Add( enclosingRule );
+                listOfRecursiveCycles.Add( cycle );
+            }
+        }
+
+        public virtual void checkRuleReference( GrammarAST scopeAST,
+                                       GrammarAST refAST,
+                                       GrammarAST argsAST,
+                                       string currentRuleName )
+        {
+            Rule r = grammar.getRule( refAST.Text );
+            if ( refAST.Type == ANTLRParser.RULE_REF )
+            {
+                if ( argsAST != null )
+                {
+                    // rule[args]; ref has args
+                    if ( r != null && r.argActionAST == null )
+                    {
+                        // but rule def has no args
+                        ErrorManager.grammarError(
+                            ErrorManager.MSG_RULE_HAS_NO_ARGS,
+                            grammar,
+                            argsAST.Token,
+                            r.name );
+                    }
+                }
+                else
+                {
+                    // rule ref has no args
+                    if ( r != null && r.argActionAST != null )
+                    {
+                        // but rule def has args
+                        ErrorManager.grammarError(
+                            ErrorManager.MSG_MISSING_RULE_ARGS,
+                            grammar,
+                            refAST.Token,
+                            r.name );
+                    }
+                }
+            }
+            else if ( refAST.Type == ANTLRParser.TOKEN_REF )
+            {
+                if ( grammar.type != Grammar.LEXER )
+                {
+                    if ( argsAST != null )
+                    {
+                        // args on a token ref not in a lexer rule
+                        ErrorManager.grammarError(
+                            ErrorManager.MSG_ARGS_ON_TOKEN_REF,
+                            grammar,
+                            refAST.Token,
+                            refAST.Text );
+                    }
+                    return; // ignore token refs in nonlexers
+                }
+                if ( argsAST != null )
+                {
+                    // tokenRef[args]; ref has args
+                    if ( r != null && r.argActionAST == null )
+                    {
+                        // but token rule def has no args
+                        ErrorManager.grammarError(
+                            ErrorManager.MSG_RULE_HAS_NO_ARGS,
+                            grammar,
+                            argsAST.Token,
+                            r.name );
+                    }
+                }
+                else
+                {
+                    // token ref has no args
+                    if ( r != null && r.argActionAST != null )
+                    {
+                        // but token rule def has args
+                        ErrorManager.grammarError(
+                            ErrorManager.MSG_MISSING_RULE_ARGS,
+                            grammar,
+                            refAST.Token,
+                            r.name );
+                    }
+                }
+            }
+        }
+
+        /** Rules in tree grammar that use -> rewrites and are spitting out
+         *  templates via output=template and then use rewrite=true must only
+         *  use -> on alts that are simple nodes or trees or single rule refs
+         *  that match either nodes or trees.  The altAST is the ALT node
+         *  for an ALT.  Verify that its first child is simple.  Must be either
+         *  ( ALT ^( A B ) <end-of-alt> ) or ( ALT A <end-of-alt> ) or
+         *  other element.
+         *
+         *  Ignore predicates in front and labels.
+         */
+        public virtual void ensureAltIsSimpleNodeOrTree( GrammarAST altAST,
+                                                GrammarAST elementAST,
+                                                int outerAltNum )
+        {
+            if ( isValidSimpleElementNode( elementAST ) )
+            {
+                GrammarAST next = (GrammarAST)elementAST.getNextSibling();
+                if ( !isNextNonActionElementEOA( next ) )
+                {
+                    ErrorManager.grammarWarning( ErrorManager.MSG_REWRITE_FOR_MULTI_ELEMENT_ALT,
+                                                grammar,
+                                                next.token,
+                                                outerAltNum );
+                }
+                return;
+            }
+            switch ( elementAST.Type )
+            {
+            case ANTLRParser.ASSIGN:		// labels ok on non-rule refs
+            case ANTLRParser.PLUS_ASSIGN:
+                if ( isValidSimpleElementNode( (GrammarAST)elementAST.GetChild( 1 ) ) )
+                {
+                    return;
+                }
+                break;
+            case ANTLRParser.ACTION:		// skip past actions
+            case ANTLRParser.SEMPRED:
+            case ANTLRParser.SYN_SEMPRED:
+            case ANTLRParser.BACKTRACK_SEMPRED:
+            case ANTLRParser.GATED_SEMPRED:
+                ensureAltIsSimpleNodeOrTree( altAST,
+                                            (GrammarAST)elementAST.getNextSibling(),
+                                            outerAltNum );
+                return;
+            }
+            ErrorManager.grammarWarning( ErrorManager.MSG_REWRITE_FOR_MULTI_ELEMENT_ALT,
+                                        grammar,
+                                        elementAST.token,
+                                        outerAltNum );
+        }
+
+        protected virtual bool isValidSimpleElementNode( GrammarAST t )
+        {
+            switch ( t.Type )
+            {
+            case ANTLRParser.TREE_BEGIN:
+            case ANTLRParser.TOKEN_REF:
+            case ANTLRParser.CHAR_LITERAL:
+            case ANTLRParser.STRING_LITERAL:
+            case ANTLRParser.WILDCARD:
+                return true;
+            default:
+                return false;
+            }
+        }
+
+        protected virtual bool isNextNonActionElementEOA( GrammarAST t )
+        {
+            while ( t.Type == ANTLRParser.ACTION ||
+                    t.Type == ANTLRParser.SEMPRED )
+            {
+                t = (GrammarAST)t.getNextSibling();
+            }
+            if ( t.Type == ANTLRParser.EOA )
+            {
+                return true;
+            }
+            return false;
+        }
+    }
+}
diff --git a/Antlr3/Tool/GrammarSemanticsMessage.cs b/Antlr3/Tool/GrammarSemanticsMessage.cs
new file mode 100644
index 0000000..3ea4f3b
--- /dev/null
+++ b/Antlr3/Tool/GrammarSemanticsMessage.cs
@@ -0,0 +1,100 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using IToken = Antlr.Runtime.IToken;
+    using StringTemplate = Antlr3.ST.StringTemplate;
+
+    /** A problem with the symbols and/or meaning of a grammar such as rule
+     *  redefinition.
+     */
+    public class GrammarSemanticsMessage : Message
+    {
+        public Grammar g;
+        /** Most of the time, we'll have a token such as an undefined rule ref
+         *  and so this will be set.
+         */
+        public IToken offendingToken;
+
+        public GrammarSemanticsMessage( int msgID,
+                              Grammar g,
+                              IToken offendingToken )
+            : this( msgID, g, offendingToken, null, null )
+        {
+        }
+
+        public GrammarSemanticsMessage( int msgID,
+                              Grammar g,
+                              IToken offendingToken,
+                              object arg )
+            : this( msgID, g, offendingToken, arg, null )
+        {
+        }
+
+        public GrammarSemanticsMessage( int msgID,
+                              Grammar g,
+                              IToken offendingToken,
+                              object arg,
+                              object arg2 )
+            : base( msgID, arg, arg2 )
+        {
+            this.g = g;
+            this.offendingToken = offendingToken;
+        }
+
+        public override string ToString()
+        {
+            line = 0;
+            charPositionInLine = 0;
+            if ( offendingToken != null )
+            {
+                line = offendingToken.Line;
+                charPositionInLine = offendingToken.CharPositionInLine;
+            }
+            if ( g != null )
+            {
+                file = g.FileName;
+            }
+            StringTemplate st = getMessageTemplate();
+            if ( arg != null )
+            {
+                st.setAttribute( "arg", arg );
+            }
+            if ( arg2 != null )
+            {
+                st.setAttribute( "arg2", arg2 );
+            }
+            return base.ToString( st );
+        }
+    }
+}
diff --git a/Antlr3/Tool/GrammarSyntaxMessage.cs b/Antlr3/Tool/GrammarSyntaxMessage.cs
new file mode 100644
index 0000000..46cb1c4
--- /dev/null
+++ b/Antlr3/Tool/GrammarSyntaxMessage.cs
@@ -0,0 +1,94 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using System;
+
+    using IToken = Antlr.Runtime.IToken;
+    using RecognitionException = Antlr.Runtime.RecognitionException;
+    using StringTemplate = Antlr3.ST.StringTemplate;
+
+    /** A problem with the syntax of your antlr grammar such as
+     *  "The '{' came as a complete surprise to me at this point in your program"
+     */
+    public class GrammarSyntaxMessage : Message
+    {
+        public Grammar g;
+        /** Most of the time, we'll have a token and so this will be set. */
+        public IToken offendingToken;
+        public RecognitionException exception;
+
+        public GrammarSyntaxMessage( int msgID,
+                                    Grammar grammar,
+                                    IToken offendingToken,
+                                    RecognitionException exception )
+            : this( msgID, grammar, offendingToken, null, exception )
+        {
+        }
+
+        public GrammarSyntaxMessage( int msgID,
+                                    Grammar grammar,
+                                    IToken offendingToken,
+                                    Object arg,
+                                    RecognitionException exception )
+            : base( msgID, arg, null )
+        {
+            this.offendingToken = offendingToken;
+            this.exception = exception;
+            this.g = grammar;
+        }
+
+        public override String ToString()
+        {
+            line = 0;
+            charPositionInLine = 0;
+            if ( offendingToken != null )
+            {
+                line = offendingToken.Line;
+                charPositionInLine = offendingToken.CharPositionInLine;
+            }
+            // TODO: actually set the right Grammar instance to get the filename
+            // TODO: have to update all v2 grammar files for this. or use errormanager and tool to get the current grammar
+            if ( g != null )
+            {
+                file = g.FileName;
+            }
+            StringTemplate st = getMessageTemplate();
+            if ( arg != null )
+            {
+                st.setAttribute( "arg", arg );
+            }
+            return base.ToString( st );
+        }
+    }
+}
diff --git a/Antlr3/Tool/GrammarUnreachableAltsMessage.cs b/Antlr3/Tool/GrammarUnreachableAltsMessage.cs
new file mode 100644
index 0000000..adceb42
--- /dev/null
+++ b/Antlr3/Tool/GrammarUnreachableAltsMessage.cs
@@ -0,0 +1,101 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using System;
+    using System.Collections.Generic;
+    using System.Linq;
+
+    using DecisionProbe = Antlr3.Analysis.DecisionProbe;
+    using NFAState = Antlr3.Analysis.NFAState;
+    using StringTemplate = Antlr3.ST.StringTemplate;
+
+    /** Reports a potential parsing issue with a decision; the decision is
+     *  nondeterministic in some way.
+     */
+    public class GrammarUnreachableAltsMessage : Message
+    {
+        public DecisionProbe probe;
+        public int[] alts;
+
+        public GrammarUnreachableAltsMessage( DecisionProbe probe,
+                                             IEnumerable<int> alts )
+            : base( ErrorManager.MSG_UNREACHABLE_ALTS )
+        {
+            this.probe = probe;
+            this.alts = alts.ToArray();
+            // flip msg ID if alts are actually token refs in Tokens rule
+            if ( probe.dfa.IsTokensRuleDecision )
+            {
+                setMessageID( ErrorManager.MSG_UNREACHABLE_TOKENS );
+            }
+        }
+
+        public override String ToString()
+        {
+            GrammarAST decisionASTNode = probe.dfa.DecisionASTNode;
+            line = decisionASTNode.Line;
+            charPositionInLine = decisionASTNode.CharPositionInLine;
+            String fileName = probe.dfa.nfa.grammar.FileName;
+            if ( fileName != null )
+            {
+                file = fileName;
+            }
+
+            StringTemplate st = getMessageTemplate();
+
+            if ( probe.dfa.IsTokensRuleDecision )
+            {
+                // alts are token rules, convert to the names instead of numbers
+                for ( int i = 0; i < alts.Length; i++ )
+                {
+                    int altI = alts[i];
+                    String tokenName = probe.getTokenNameForTokensRuleAlt( altI );
+                    // reset the line/col to the token definition
+                    NFAState ruleStart = probe.dfa.nfa.grammar.getRuleStartState( tokenName );
+                    line = ruleStart.associatedASTNode.Line;
+                    charPositionInLine = ruleStart.associatedASTNode.CharPositionInLine;
+                    st.setAttribute( "tokens", tokenName );
+                }
+            }
+            else
+            {
+                // regular alt numbers, show the alts
+                st.setAttribute( "alts", alts );
+            }
+
+            return base.ToString( st );
+        }
+
+    }
+}
diff --git a/Antlr3/Tool/Interpreter.cs b/Antlr3/Tool/Interpreter.cs
new file mode 100644
index 0000000..23f8cd4
--- /dev/null
+++ b/Antlr3/Tool/Interpreter.cs
@@ -0,0 +1,519 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using System;
+    using System.Collections.Generic;
+    using System.Linq;
+    using Antlr.Runtime;
+    using Antlr.Runtime.JavaExtensions;
+    using Antlr3.Analysis;
+
+    using BlankDebugEventListener = Antlr.Runtime.Debug.BlankDebugEventListener;
+    using IDebugEventListener = Antlr.Runtime.Debug.IDebugEventListener;
+    using DFA = Antlr3.Analysis.DFA;
+    using IList = System.Collections.IList;
+    using IntervalSet = Antlr3.Misc.IntervalSet;
+    using ParseTree = Antlr.Runtime.Tree.ParseTree;
+    using ParseTreeBuilder = Antlr.Runtime.Debug.ParseTreeBuilder;
+
+    /** The recognition interpreter/engine for grammars.  Separated
+     *  out of Grammar as it's related, but technically not a Grammar function.
+     *  You create an interpreter for a grammar and an input stream.  This object
+     *  can act as a TokenSource so that you can hook up two grammars (via
+     *  a CommonTokenStream) to lex/parse.  Being a token source only makes sense
+     *  for a lexer grammar of course.
+     */
+    public class Interpreter : ITokenSource
+    {
+        protected Grammar grammar;
+        protected IIntStream input;
+
+        /** A lexer listener that just creates token objects as they
+         *  are matched.  scan() use this listener to get a single object.
+         *  To get a stream of tokens, you must call scan() multiple times,
+         *  recording the token object result after each call.
+         */
+        class LexerActionGetTokenType : BlankDebugEventListener
+        {
+            Interpreter outer;
+            public CommonToken token;
+            Grammar g;
+
+            public LexerActionGetTokenType( Interpreter outer, Grammar g )
+            {
+                this.outer = outer;
+                this.g = g;
+            }
+
+            public override void ExitRule( String grammarFileName, String ruleName )
+            {
+                if ( !ruleName.Equals( Grammar.ARTIFICIAL_TOKENS_RULENAME ) )
+                {
+                    int type = g.getTokenType( ruleName );
+                    int channel = TokenConstants.DEFAULT_CHANNEL;
+                    token = new CommonToken( (ICharStream)outer.input, type, channel, 0, 0 );
+                }
+            }
+        }
+
+        public Interpreter( Grammar grammar, IIntStream input )
+        {
+            this.grammar = grammar;
+            this.input = input;
+        }
+
+        public string[] TokenNames
+        {
+            get
+            {
+                return grammar.TokenIDs.ToArray();
+            }
+        }
+
+        public virtual IToken NextToken()
+        {
+            if ( grammar.type != Grammar.LEXER )
+            {
+                return null;
+            }
+            if ( input.LA( 1 ) == CharStreamConstants.EOF )
+            {
+                return TokenConstants.EOF_TOKEN;
+            }
+            int start = input.Index;
+            int charPos = ( (ICharStream)input ).CharPositionInLine;
+            CommonToken token = null;
+            while ( input.LA( 1 ) != CharStreamConstants.EOF )
+            {
+                try
+                {
+                    token = scan( Grammar.ARTIFICIAL_TOKENS_RULENAME, null );
+                    break;
+                }
+                catch ( RecognitionException re )
+                {
+                    // report a problem and try for another
+                    reportScanError( re );
+                    continue;
+                }
+            }
+            // the scan can only set type
+            // we must set the line, and other junk here to make it a complete token
+            int stop = input.Index - 1;
+            if ( token == null )
+            {
+                return TokenConstants.EOF_TOKEN;
+            }
+            token.Line = ( ( (ICharStream)input ).Line );
+            token.StartIndex = start;
+            token.StopIndex = stop;
+            token.CharPositionInLine = charPos;
+            return token;
+        }
+
+        /** For a given input char stream, try to match against the NFA
+         *  starting at startRule.  This is a deterministic parse even though
+         *  it is using an NFA because it uses DFAs at each decision point to
+         *  predict which alternative will succeed.  This is exactly what the
+         *  generated parser will do.
+         *
+         *  This only does lexer grammars.
+         *
+         *  Return the token type associated with the final rule end state.
+         */
+        public virtual void scan( String startRule,
+                         IDebugEventListener actions,
+                         IList visitedStates )
+        {
+            if ( grammar.type != Grammar.LEXER )
+            {
+                return;
+            }
+            ICharStream @in = (ICharStream)this.input;
+            //System.out.println("scan("+startRule+",'"+in.substring(in.index(),in.size()-1)+"')");
+            // Build NFAs/DFAs from the grammar AST if NFAs haven't been built yet
+            if ( grammar.getRuleStartState( startRule ) == null )
+            {
+                grammar.buildNFA();
+            }
+
+            if ( !grammar.AllDecisionDFAHaveBeenCreated )
+            {
+                // Create the DFA predictors for each decision
+                grammar.createLookaheadDFAs();
+            }
+
+            // do the parse
+            Stack<object> ruleInvocationStack = new Stack<object>();
+            NFAState start = grammar.getRuleStartState( startRule );
+            NFAState stop = grammar.getRuleStopState( startRule );
+            parseEngine( startRule, start, stop, @in, ruleInvocationStack,
+                        actions, visitedStates );
+        }
+
+        public virtual CommonToken scan( String startRule )
+        {
+            return scan( startRule, null );
+        }
+
+        public virtual CommonToken scan( String startRule,
+                                IList visitedStates )
+        {
+            LexerActionGetTokenType actions = new LexerActionGetTokenType( this, grammar );
+            scan( startRule, actions, visitedStates );
+            return actions.token;
+        }
+
+        public virtual void parse( String startRule,
+                          IDebugEventListener actions,
+                          IList visitedStates )
+        {
+            //System.out.println("parse("+startRule+")");
+            // Build NFAs/DFAs from the grammar AST if NFAs haven't been built yet
+            if ( grammar.getRuleStartState( startRule ) == null )
+            {
+                grammar.buildNFA();
+            }
+            if ( !grammar.AllDecisionDFAHaveBeenCreated )
+            {
+                // Create the DFA predictors for each decision
+                grammar.createLookaheadDFAs();
+            }
+            // do the parse
+            Stack<object> ruleInvocationStack = new Stack<object>();
+            NFAState start = grammar.getRuleStartState( startRule );
+            NFAState stop = grammar.getRuleStopState( startRule );
+            parseEngine( startRule, start, stop, input, ruleInvocationStack,
+                        actions, visitedStates );
+        }
+
+        public virtual ParseTree parse( String startRule )
+        {
+            return parse( startRule, null );
+        }
+
+        public virtual ParseTree parse( String startRule, IList visitedStates )
+        {
+            ParseTreeBuilder actions = new ParseTreeBuilder( grammar.name );
+            try
+            {
+                parse( startRule, actions, visitedStates );
+            }
+            catch ( RecognitionException /*re*/ )
+            {
+                // Errors are tracked via the ANTLRDebugInterface
+                // Exceptions are used just to blast out of the parse engine
+                // The error will be in the parse tree.
+            }
+            return actions.GetTree();
+        }
+
+        /** Fill a list of all NFA states visited during the parse */
+        protected virtual void parseEngine( String startRule,
+                                   NFAState start,
+                                   NFAState stop,
+                                   IIntStream input,
+                                   Stack<object> ruleInvocationStack,
+                                   IDebugEventListener actions,
+                                   IList visitedStates )
+        {
+            NFAState s = start;
+            if ( actions != null )
+            {
+                actions.EnterRule( s.nfa.grammar.FileName, start.enclosingRule.name );
+            }
+            int t = input.LA( 1 );
+            while ( s != stop )
+            {
+                if ( visitedStates != null )
+                {
+                    visitedStates.Add( s );
+                }
+                /*
+                System.out.println("parse state "+s.stateNumber+" input="+
+                    s.nfa.grammar.getTokenDisplayName(t));
+                    */
+                // CASE 1: decision state
+                if ( s.DecisionNumber > 0 && s.nfa.grammar.getNumberOfAltsForDecisionNFA( s ) > 1 )
+                {
+                    // decision point, must predict and jump to alt
+                    DFA dfa = s.nfa.grammar.getLookaheadDFA( s.DecisionNumber );
+                    /*
+                    if ( s.nfa.grammar.type!=Grammar.LEXER ) {
+                        System.out.println("decision: "+
+                                       dfa.getNFADecisionStartState().getDescription()+
+                                       " input="+s.nfa.grammar.getTokenDisplayName(t));
+                    }
+                    */
+                    int m = input.Mark();
+                    int predictedAlt = predict( dfa );
+                    if ( predictedAlt == NFA.INVALID_ALT_NUMBER )
+                    {
+                        String description = dfa.NFADecisionStartState.Description;
+                        NoViableAltException nvae =
+                            new NoViableAltException( description,
+                                                          dfa.DecisionNumber,
+                                                          s.stateNumber,
+                                                          input );
+                        if ( actions != null )
+                        {
+                            actions.RecognitionException( nvae );
+                        }
+                        input.Consume(); // recover
+                        throw nvae;
+                    }
+                    input.Rewind( m );
+                    int parseAlt =
+                        s.translateDisplayAltToWalkAlt( predictedAlt );
+                    /*
+                    if ( s.nfa.grammar.type!=Grammar.LEXER ) {
+                        System.out.println("predicted alt "+predictedAlt+", parseAlt "+
+                                           parseAlt);
+                    }
+                    */
+                    NFAState alt;
+                    if ( parseAlt > s.nfa.grammar.getNumberOfAltsForDecisionNFA( s ) )
+                    {
+                        // implied branch of loop etc...
+                        alt = s.nfa.grammar.nfa.getState( s.endOfBlockStateNumber );
+                    }
+                    else
+                    {
+                        alt = s.nfa.grammar.getNFAStateForAltOfDecision( s, parseAlt );
+                    }
+                    s = (NFAState)alt.transition[0].target;
+                    continue;
+                }
+
+                // CASE 2: finished matching a rule
+                if ( s.IsAcceptState )
+                { // end of rule node
+                    if ( actions != null )
+                    {
+                        actions.ExitRule( s.nfa.grammar.FileName, s.enclosingRule.name );
+                    }
+                    if ( ruleInvocationStack.Count == 0 )
+                    {
+                        // done parsing.  Hit the start state.
+                        //System.out.println("stack empty in stop state for "+s.getEnclosingRule());
+                        break;
+                    }
+                    // pop invoking state off the stack to know where to return to
+                    NFAState invokingState = (NFAState)ruleInvocationStack.Pop();
+                    RuleClosureTransition invokingTransition =
+                            (RuleClosureTransition)invokingState.transition[0];
+                    // move to node after state that invoked this rule
+                    s = invokingTransition.followState;
+                    continue;
+                }
+
+                Transition trans = s.transition[0];
+                Label label = trans.label;
+                if ( label.IsSemanticPredicate )
+                {
+                    FailedPredicateException fpe =
+                        new FailedPredicateException( input,
+                                                     s.enclosingRule.name,
+                                                     "can't deal with predicates yet" );
+                    if ( actions != null )
+                    {
+                        actions.RecognitionException( fpe );
+                    }
+                }
+
+                // CASE 3: epsilon transition
+                if ( label.IsEpsilon )
+                {
+                    // CASE 3a: rule invocation state
+                    if ( trans is RuleClosureTransition )
+                    {
+                        ruleInvocationStack.Push( s );
+                        s = (NFAState)trans.target;
+                        //System.out.println("call "+s.enclosingRule.name+" from "+s.nfa.grammar.getFileName());
+                        if ( actions != null )
+                        {
+                            actions.EnterRule( s.nfa.grammar.FileName, s.enclosingRule.name );
+                        }
+                        // could be jumping to new grammar, make sure DFA created
+                        if ( !s.nfa.grammar.AllDecisionDFAHaveBeenCreated )
+                        {
+                            s.nfa.grammar.createLookaheadDFAs();
+                        }
+                    }
+                    // CASE 3b: plain old epsilon transition, just move
+                    else
+                    {
+                        s = (NFAState)trans.target;
+                    }
+                }
+
+                // CASE 4: match label on transition
+                else if ( label.matches( t ) )
+                {
+                    if ( actions != null )
+                    {
+                        if ( s.nfa.grammar.type == Grammar.PARSER ||
+                             s.nfa.grammar.type == Grammar.COMBINED )
+                        {
+                            actions.ConsumeToken( ( (ITokenStream)input ).LT( 1 ) );
+                        }
+                    }
+                    s = (NFAState)s.transition[0].target;
+                    input.Consume();
+                    t = input.LA( 1 );
+                }
+
+                // CASE 5: error condition; label is inconsistent with input
+                else
+                {
+                    if ( label.IsAtom )
+                    {
+                        MismatchedTokenException mte =
+                            new MismatchedTokenException( label.Atom, input );
+                        if ( actions != null )
+                        {
+                            actions.RecognitionException( mte );
+                        }
+                        input.Consume(); // recover
+                        throw mte;
+                    }
+                    else if ( label.IsSet )
+                    {
+                        MismatchedSetException mse =
+                            new MismatchedSetException( ( (IntervalSet)label.Set ).toRuntimeBitSet(),
+                                                       input );
+                        if ( actions != null )
+                        {
+                            actions.RecognitionException( mse );
+                        }
+                        input.Consume(); // recover
+                        throw mse;
+                    }
+                    else if ( label.IsSemanticPredicate )
+                    {
+                        FailedPredicateException fpe =
+                            new FailedPredicateException( input,
+                                                         s.enclosingRule.name,
+                                                         label.SemanticContext.ToString() );
+                        if ( actions != null )
+                        {
+                            actions.RecognitionException( fpe );
+                        }
+                        input.Consume(); // recover
+                        throw fpe;
+                    }
+                    else
+                    {
+                        throw new RecognitionException( input ); // unknown error
+                    }
+                }
+            }
+            //System.out.println("hit stop state for "+stop.getEnclosingRule());
+            if ( actions != null )
+            {
+                actions.ExitRule( s.nfa.grammar.FileName, stop.enclosingRule.name );
+            }
+        }
+
+        /** Given an input stream, return the unique alternative predicted by
+         *  matching the input.  Upon error, return NFA.INVALID_ALT_NUMBER
+         *  The first symbol of lookahead is presumed to be primed; that is,
+         *  input.lookahead(1) must point at the input symbol you want to start
+         *  predicting with.
+         */
+        public int predict( DFA dfa ) {
+		DFAState s = dfa.startState;
+		int c = input.LA(1);
+		Transition eotTransition = null;
+	dfaLoop:
+		while ( !s.IsAcceptState ) {
+			/*
+			System.out.println("DFA.predict("+s.getStateNumber()+", "+
+					dfa.getNFA().getGrammar().getTokenName(c)+")");
+			*/
+			// for each edge of s, look for intersection with current char
+			for (int i=0; i<s.NumberOfTransitions; i++) {
+				Transition t = s.transition(i);
+				// special case: EOT matches any char
+				if ( t.label.matches(c) ) {
+					// take transition i
+					s = (DFAState)t.target;
+					input.Consume();
+					c = input.LA(1);
+					goto dfaLoop;
+				}
+				if ( t.label.Atom==Label.EOT ) {
+					eotTransition = t;
+				}
+			}
+			if ( eotTransition!=null ) {
+				s = (DFAState)eotTransition.target;
+				goto dfaLoop;
+			}
+			/*
+			ErrorManager.error(ErrorManager.MSG_NO_VIABLE_DFA_ALT,
+							   s,
+							   dfa.nfa.grammar.getTokenName(c));
+			*/
+			return NFA.INVALID_ALT_NUMBER;
+		}
+		// woohoo!  We know which alt to predict
+		// nothing emanates from a stop state; must terminate anyway
+		/*
+		System.out.println("DFA stop state "+s.getStateNumber()+" predicts "+
+				s.getUniquelyPredictedAlt());
+		*/
+		return s.getUniquelyPredictedAlt();
+	}
+
+        public virtual void reportScanError( RecognitionException re )
+        {
+            ICharStream cs = (ICharStream)input;
+            // print as good of a message as we can, given that we do not have
+            // a Lexer object and, hence, cannot call the routine to get a
+            // decent error message.
+            Console.Error.WriteLine( "problem matching token at " +
+                cs.Line + ":" + cs.CharPositionInLine + " " + re );
+        }
+
+        public virtual String SourceName
+        {
+            get
+            {
+                return input.SourceName;
+            }
+        }
+
+    }
+}
diff --git a/Antlr3/Tool/LeftRecursionCyclesMessage.cs b/Antlr3/Tool/LeftRecursionCyclesMessage.cs
new file mode 100644
index 0000000..af28c82
--- /dev/null
+++ b/Antlr3/Tool/LeftRecursionCyclesMessage.cs
@@ -0,0 +1,62 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using System;
+    using Antlr3.Analysis;
+
+    using ICollection = System.Collections.ICollection;
+    using StringTemplate = Antlr3.ST.StringTemplate;
+
+    /** Similar to LeftRecursionMessage except this is used for announcing
+     *  cycles found by walking rules without decisions; the other msg is
+     *  invoked when a decision DFA construction finds a problem in closure.
+     */
+    public class LeftRecursionCyclesMessage : Message
+    {
+        public ICollection cycles;
+
+        public LeftRecursionCyclesMessage( ICollection cycles )
+            : base( ErrorManager.MSG_LEFT_RECURSION_CYCLES )
+        {
+            this.cycles = cycles;
+        }
+
+        public override String ToString()
+        {
+            StringTemplate st = getMessageTemplate();
+            st.setAttribute( "listOfCycles", cycles );
+            return base.ToString( st );
+        }
+    }
+}
diff --git a/Antlr3/Tool/Message.cs b/Antlr3/Tool/Message.cs
new file mode 100644
index 0000000..de90b9d
--- /dev/null
+++ b/Antlr3/Tool/Message.cs
@@ -0,0 +1,149 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using StringTemplate = Antlr3.ST.StringTemplate;
+    using Exception = System.Exception;
+
+    /** The ANTLR code calls methods on ErrorManager to report errors etc...
+     *  Rather than simply pass these arguments to the ANTLRErrorListener directly,
+     *  create an object that encapsulates everything.  In this way, the error
+     *  listener interface does not have to change when I add a new kind of
+     *  error message.  I don't want to break a GUI for example every time
+     *  I update the error system in ANTLR itself.
+     *
+     *  To get a printable error/warning message, call toString().
+     */
+    public abstract class Message
+    {
+        // msgST is the actual text of the message
+        public StringTemplate msgST;
+        // these are for supporting different output formats
+        public StringTemplate locationST;
+        public StringTemplate reportST;
+        public StringTemplate messageFormatST;
+
+        public int msgID;
+        public object arg;
+        public object arg2;
+        public Exception e;
+        // used for location template
+        public string file;
+        public int line = -1;
+        public int charPositionInLine = -1;
+
+        public Message()
+        {
+        }
+
+        public Message( int msgID )
+            : this( msgID, null, null )
+        {
+        }
+
+        public Message( int msgID, object arg, object arg2 )
+        {
+            setMessageID( msgID );
+            this.arg = arg;
+            this.arg2 = arg2;
+        }
+
+        public virtual void setLine( int line )
+        {
+            this.line = line;
+        }
+
+        public virtual void setColumn( int column )
+        {
+            this.charPositionInLine = column;
+        }
+
+        public virtual void setMessageID( int msgID )
+        {
+            this.msgID = msgID;
+            msgST = ErrorManager.getMessage( msgID );
+        }
+
+        /** Return a new template instance every time someone tries to print
+         *  a Message.
+         */
+        public virtual StringTemplate getMessageTemplate()
+        {
+            return msgST.getInstanceOf();
+        }
+
+        /** Return a new template instance for the location part of a Message.
+         *  TODO: Is this really necessary? -Kay
+         */
+        public virtual StringTemplate getLocationTemplate()
+        {
+            return locationST.getInstanceOf();
+        }
+
+        public virtual string ToString( StringTemplate messageST )
+        {
+            // setup the location
+            locationST = ErrorManager.getLocationFormat();
+            reportST = ErrorManager.getReportFormat();
+            messageFormatST = ErrorManager.getMessageFormat();
+            bool locationValid = false;
+            if ( line != -1 )
+            {
+                locationST.setAttribute( "line", line );
+                locationValid = true;
+            }
+            if ( charPositionInLine != -1 )
+            {
+                locationST.setAttribute( "column", charPositionInLine + 1 );
+                locationValid = true;
+            }
+            if ( file != null )
+            {
+                locationST.setAttribute( "file", file );
+                locationValid = true;
+            }
+
+            messageFormatST.setAttribute( "id", msgID );
+            messageFormatST.setAttribute( "text", messageST );
+
+            if ( locationValid )
+            {
+                reportST.setAttribute( "location", locationST );
+            }
+            reportST.setAttribute( "message", messageFormatST );
+            reportST.setAttribute( "type", ErrorManager.getMessageType( msgID ) );
+
+            return reportST.ToString();
+        }
+    }
+}
diff --git a/Antlr3/Tool/NFAFactory.cs b/Antlr3/Tool/NFAFactory.cs
new file mode 100644
index 0000000..b435996
--- /dev/null
+++ b/Antlr3/Tool/NFAFactory.cs
@@ -0,0 +1,802 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using System.Collections.Generic;
+    using System.Linq;
+    using Antlr.Runtime.JavaExtensions;
+    using Antlr3.Analysis;
+
+    using IIntSet = Antlr3.Misc.IIntSet;
+    using IList = System.Collections.IList;
+    using IntervalSet = Antlr3.Misc.IntervalSet;
+    using StringBuilder = System.Text.StringBuilder;
+
+    /** Routines to construct StateClusters from EBNF grammar constructs.
+     *  No optimization is done to remove unnecessary epsilon edges.
+     *
+     *  TODO: add an optimization that reduces number of states and transitions
+     *  will help with speed of conversion and make it easier to view NFA.  For
+     *  example, o-A->o-->o-B->o should be o-A->o-B->o
+     */
+    public class NFAFactory
+    {
+        /** This factory is attached to a specifc NFA that it is building.
+         *  The NFA will be filled up with states and transitions.
+         */
+        NFA nfa = null;
+
+        Rule currentRule = null;
+
+        public NFAFactory( NFA nfa )
+        {
+            nfa.Factory = this;
+            this.nfa = nfa;
+        }
+
+        #region Properties
+        public Rule CurrentRule
+        {
+            get
+            {
+                return getCurrentRule();
+            }
+        }
+        #endregion
+
+        public Rule getCurrentRule()
+        {
+            return currentRule;
+        }
+
+        public void setCurrentRule( Rule value )
+        {
+            currentRule = value;
+        }
+
+        public virtual NFAState newState()
+        {
+            NFAState n = new NFAState( nfa );
+            int state = nfa.getNewNFAStateNumber();
+            n.stateNumber = state;
+            nfa.addState( n );
+            n.enclosingRule = currentRule;
+            return n;
+        }
+
+        /** Optimize an alternative (list of grammar elements).
+         *
+         *  Walk the chain of elements (which can be complicated loop blocks...)
+         *  and throw away any epsilon transitions used to link up simple elements.
+         *
+         *  This only removes 195 states from the java.g's NFA, but every little
+         *  bit helps.  Perhaps I can improve in the future.
+         */
+        public virtual void optimizeAlternative( StateCluster alt )
+        {
+            NFAState s = alt.left;
+            while ( s != alt.right )
+            {
+                // if it's a block element, jump over it and continue
+                if ( s.endOfBlockStateNumber != State.INVALID_STATE_NUMBER )
+                {
+                    s = nfa.getState( s.endOfBlockStateNumber );
+                    continue;
+                }
+                Transition t = s.transition[0];
+                if ( t is RuleClosureTransition )
+                {
+                    s = ( (RuleClosureTransition)t ).followState;
+                    continue;
+                }
+                if ( t.label.IsEpsilon && !t.label.IsAction && s.NumberOfTransitions == 1 )
+                {
+                    // bypass epsilon transition and point to what the epsilon's
+                    // target points to unless that epsilon transition points to
+                    // a block or loop etc..  Also don't collapse epsilons that
+                    // point at the last node of the alt. Don't collapse action edges
+                    NFAState epsilonTarget = (NFAState)t.target;
+                    if ( epsilonTarget.endOfBlockStateNumber == State.INVALID_STATE_NUMBER &&
+                         epsilonTarget.transition[0] != null )
+                    {
+                        s.setTransition0( epsilonTarget.transition[0] );
+                        /*
+                        System.out.println("### opt "+s.stateNumber+"->"+
+                                           epsilonTarget.transition(0).target.stateNumber);
+                        */
+                    }
+                }
+                s = (NFAState)t.target;
+            }
+        }
+
+        /** From label A build Graph o-A->o */
+        public virtual StateCluster build_Atom( int label, GrammarAST associatedAST )
+        {
+            NFAState left = newState();
+            NFAState right = newState();
+            left.associatedASTNode = associatedAST;
+            right.associatedASTNode = associatedAST;
+            transitionBetweenStates( left, right, label );
+            StateCluster g = new StateCluster( left, right );
+            return g;
+        }
+
+        public virtual StateCluster build_Atom( GrammarAST atomAST )
+        {
+            int tokenType = nfa.grammar.getTokenType( atomAST.Text );
+            return build_Atom( tokenType, atomAST );
+        }
+
+        /** From set build single edge graph o->o-set->o.  To conform to
+         *  what an alt block looks like, must have extra state on left.
+         */
+        public virtual StateCluster build_Set( IIntSet set, GrammarAST associatedAST )
+        {
+            NFAState left = newState();
+            NFAState right = newState();
+            left.associatedASTNode = associatedAST;
+            right.associatedASTNode = associatedAST;
+            Label label = new Label( set );
+            Transition e = new Transition( label, right );
+            left.addTransition( e );
+            StateCluster g = new StateCluster( left, right );
+            return g;
+        }
+
+        /** Can only complement block of simple alts; can complement build_Set()
+         *  result, that is.  Get set and complement, replace old with complement.
+        public StateCluster build_AlternativeBlockComplement(StateCluster blk) {
+            State s0 = blk.left;
+            IntSet set = getCollapsedBlockAsSet(s0);
+            if ( set!=null ) {
+                // if set is available, then structure known and blk is a set
+                set = nfa.grammar.complement(set);
+                Label label = s0.transition(0).target.transition(0).label;
+                label.setSet(set);
+            }
+            return blk;
+        }
+         */
+
+        public virtual StateCluster build_Range( int a, int b )
+        {
+            NFAState left = newState();
+            NFAState right = newState();
+            Label label = new Label( IntervalSet.of( a, b ) );
+            Transition e = new Transition( label, right );
+            left.addTransition( e );
+            StateCluster g = new StateCluster( left, right );
+            return g;
+        }
+
+        /** From char 'c' build StateCluster o-intValue(c)->o
+         */
+        public virtual StateCluster build_CharLiteralAtom( GrammarAST charLiteralAST )
+        {
+            int c = Grammar.getCharValueFromGrammarCharLiteral( charLiteralAST.Text );
+            return build_Atom( c, charLiteralAST );
+        }
+
+        /** From char 'c' build StateCluster o-intValue(c)->o
+         *  can include unicode spec likes '\u0024' later.  Accepts
+         *  actual unicode 16-bit now, of course, by default.
+         *  TODO not supplemental char clean!
+         */
+        public virtual StateCluster build_CharRange( string a, string b )
+        {
+            int from = Grammar.getCharValueFromGrammarCharLiteral( a );
+            int to = Grammar.getCharValueFromGrammarCharLiteral( b );
+            return build_Range( from, to );
+        }
+
+        /** For a non-lexer, just build a simple token reference atom.
+         *  For a lexer, a string is a sequence of char to match.  That is,
+         *  "fog" is treated as 'f' 'o' 'g' not as a single transition in
+         *  the DFA.  Machine== o-'f'->o-'o'->o-'g'->o and has n+1 states
+         *  for n characters.
+         */
+        public virtual StateCluster build_StringLiteralAtom( GrammarAST stringLiteralAST )
+        {
+            if ( nfa.grammar.type == Grammar.LEXER )
+            {
+                StringBuilder chars =
+                    Grammar.getUnescapedStringFromGrammarStringLiteral( stringLiteralAST.Text );
+                NFAState first = newState();
+                NFAState last = null;
+                NFAState prev = first;
+                for ( int i = 0; i < chars.Length; i++ )
+                {
+                    int c = chars[i];
+                    NFAState next = newState();
+                    transitionBetweenStates( prev, next, c );
+                    prev = last = next;
+                }
+                return new StateCluster( first, last );
+            }
+
+            // a simple token reference in non-Lexers
+            int tokenType = nfa.grammar.getTokenType( stringLiteralAST.Text );
+            return build_Atom( tokenType, stringLiteralAST );
+        }
+
+        /** For reference to rule r, build
+         *
+         *  o-e->(r)  o
+         *
+         *  where (r) is the start of rule r and the trailing o is not linked
+         *  to from rule ref state directly (it's done thru the transition(0)
+         *  RuleClosureTransition.
+         *
+         *  If the rule r is just a list of tokens, it's block will be just
+         *  a set on an edge o->o->o-set->o->o->o, could inline it rather than doing
+         *  the rule reference, but i'm not doing this yet as I'm not sure
+         *  it would help much in the NFA->DFA construction.
+         *
+         *  TODO add to codegen: collapse alt blks that are sets into single matchSet
+         */
+        public virtual StateCluster build_RuleRef( Rule refDef, NFAState ruleStart )
+        {
+            //System.out.println("building ref to rule "+nfa.grammar.name+"."+refDef.name);
+            NFAState left = newState();
+            // left.setDescription("ref to "+ruleStart.getDescription());
+            NFAState right = newState();
+            // right.setDescription("NFAState following ref to "+ruleStart.getDescription());
+            Transition e = new RuleClosureTransition( refDef, ruleStart, right );
+            left.addTransition( e );
+            StateCluster g = new StateCluster( left, right );
+            return g;
+        }
+
+        /** From an empty alternative build StateCluster o-e->o */
+        public virtual StateCluster build_Epsilon()
+        {
+            NFAState left = newState();
+            NFAState right = newState();
+            transitionBetweenStates( left, right, Label.EPSILON );
+            StateCluster g = new StateCluster( left, right );
+            return g;
+        }
+
+        /** Build what amounts to an epsilon transition with a semantic
+         *  predicate action.  The pred is a pointer into the AST of
+         *  the SEMPRED token.
+         */
+        public virtual StateCluster build_SemanticPredicate( GrammarAST pred )
+        {
+            // don't count syn preds
+            if ( !pred.Text.ToUpperInvariant()
+                    .StartsWith( Grammar.SYNPRED_RULE_PREFIX.ToUpperInvariant() ) )
+            {
+                nfa.grammar.numberOfSemanticPredicates++;
+            }
+            NFAState left = newState();
+            NFAState right = newState();
+            Transition e = new Transition( new PredicateLabel( pred ), right );
+            left.addTransition( e );
+            StateCluster g = new StateCluster( left, right );
+            return g;
+        }
+
+        /** Build what amounts to an epsilon transition with an action.
+         *  The action goes into NFA though it is ignored during analysis.
+         *  It slows things down a bit, but I must ignore predicates after
+         *  having seen an action (5-5-2008).
+         */
+        public virtual StateCluster build_Action( GrammarAST action )
+        {
+            NFAState left = newState();
+            NFAState right = newState();
+            Transition e = new Transition( new ActionLabel( action ), right );
+            left.addTransition( e );
+            return new StateCluster( left, right );
+        }
+
+        /** add an EOF transition to any rule end NFAState that points to nothing
+         *  (i.e., for all those rules not invoked by another rule).  These
+         *  are start symbols then.
+         *
+         *  Return the number of grammar entry points; i.e., how many rules are
+         *  not invoked by another rule (they can only be invoked from outside).
+         *  These are the start rules.
+         */
+        public virtual int build_EOFStates( IEnumerable<Rule> rules )
+        {
+            int numberUnInvokedRules = 0;
+            foreach ( Rule r in rules )
+            {
+                NFAState endNFAState = r.stopState;
+                // Is this rule a start symbol?  (no follow links)
+                if ( endNFAState.transition[0] == null )
+                {
+                    // if so, then don't let algorithm fall off the end of
+                    // the rule, make it hit EOF/EOT.
+                    build_EOFState( endNFAState );
+                    // track how many rules have been invoked by another rule
+                    numberUnInvokedRules++;
+                }
+            }
+            return numberUnInvokedRules;
+        }
+
+        /** set up an NFA NFAState that will yield eof tokens or,
+         *  in the case of a lexer grammar, an EOT token when the conversion
+         *  hits the end of a rule.
+         */
+        private void build_EOFState( NFAState endNFAState )
+        {
+            NFAState end = newState();
+            int label = Label.EOF;
+            if ( nfa.grammar.type == Grammar.LEXER )
+            {
+                label = Label.EOT;
+                end.IsEOTTargetState = true;
+            }
+            /*
+            System.out.println("build "+nfa.grammar.getTokenDisplayName(label)+
+                               " loop on end of state "+endNFAState.getDescription()+
+                               " to state "+end.stateNumber);
+            */
+            Transition toEnd = new Transition( label, end );
+            endNFAState.addTransition( toEnd );
+        }
+
+        /** From A B build A-e->B (that is, build an epsilon arc from right
+         *  of A to left of B).
+         *
+         *  As a convenience, return B if A is null or return A if B is null.
+         */
+        public virtual StateCluster build_AB( StateCluster A, StateCluster B )
+        {
+            if ( A == null )
+            {
+                return B;
+            }
+            if ( B == null )
+            {
+                return A;
+            }
+            transitionBetweenStates( A.right, B.left, Label.EPSILON );
+            StateCluster g = new StateCluster( A.left, B.right );
+            return g;
+        }
+
+        /** From a set ('a'|'b') build
+         *
+         *  o->o-'a'..'b'->o->o (last NFAState is blockEndNFAState pointed to by all alts)
+         */
+        public virtual StateCluster build_AlternativeBlockFromSet( StateCluster set )
+        {
+            if ( set == null )
+            {
+                return null;
+            }
+
+            // single alt, no decision, just return only alt state cluster
+            NFAState startOfAlt = newState(); // must have this no matter what
+            transitionBetweenStates( startOfAlt, set.left, Label.EPSILON );
+
+            return new StateCluster( startOfAlt, set.right );
+        }
+
+        /** From A|B|..|Z alternative block build
+         *
+         *  o->o-A->o->o (last NFAState is blockEndNFAState pointed to by all alts)
+         *  |          ^
+         *  o->o-B->o--|
+         *  |          |
+         *  ...        |
+         *  |          |
+         *  o->o-Z->o--|
+         *
+         *  So every alternative gets begin NFAState connected by epsilon
+         *  and every alt right side points at a block end NFAState.  There is a
+         *  new NFAState in the NFAState in the StateCluster for each alt plus one for the
+         *  end NFAState.
+         *
+         *  Special case: only one alternative: don't make a block with alt
+         *  begin/end.
+         *
+         *  Special case: if just a list of tokens/chars/sets, then collapse
+         *  to a single edge'd o-set->o graph.
+         *
+         *  Set alt number (1..n) in the left-Transition NFAState.
+         */
+        public virtual StateCluster build_AlternativeBlock( ICollection<StateCluster> alternativeStateClusters )
+        {
+            StateCluster result = null;
+            if ( alternativeStateClusters == null || alternativeStateClusters.Count == 0 )
+            {
+                return null;
+            }
+
+            // single alt case
+            if ( alternativeStateClusters.Count == 1 )
+            {
+                // single alt, no decision, just return only alt state cluster
+                StateCluster g = alternativeStateClusters.First();
+                NFAState startOfAlt = newState(); // must have this no matter what
+                transitionBetweenStates( startOfAlt, g.left, Label.EPSILON );
+
+                //System.out.println("### opt saved start/stop end in (...)");
+                return new StateCluster( startOfAlt, g.right );
+            }
+
+            // even if we can collapse for lookahead purposes, we will still
+            // need to predict the alts of this subrule in case there are actions
+            // etc...  This is the decision that is pointed to from the AST node
+            // (always)
+            NFAState prevAlternative = null; // tracks prev so we can link to next alt
+            NFAState firstAlt = null;
+            NFAState blockEndNFAState = newState();
+            blockEndNFAState.Description = "end block";
+            int altNum = 1;
+            foreach ( StateCluster g in alternativeStateClusters )
+            {
+                // add begin NFAState for this alt connected by epsilon
+                NFAState left = newState();
+                left.Description = "alt " + altNum + " of ()";
+                transitionBetweenStates( left, g.left, Label.EPSILON );
+                transitionBetweenStates( g.right, blockEndNFAState, Label.EPSILON );
+                // Are we the first alternative?
+                if ( firstAlt == null )
+                {
+                    firstAlt = left; // track extreme left node of StateCluster
+                }
+                else
+                {
+                    // if not first alternative, must link to this alt from previous
+                    transitionBetweenStates( prevAlternative, left, Label.EPSILON );
+                }
+                prevAlternative = left;
+                altNum++;
+            }
+
+            // return StateCluster pointing representing entire block
+            // Points to first alt NFAState on left, block end on right
+            result = new StateCluster( firstAlt, blockEndNFAState );
+
+            firstAlt.decisionStateType = NFAState.BLOCK_START;
+
+            // set EOB markers for Jean
+            firstAlt.endOfBlockStateNumber = blockEndNFAState.stateNumber;
+
+            return result;
+        }
+
+        /** From (A)? build either:
+         *
+         *  o--A->o
+         *  |     ^
+         *  o---->|
+         *
+         *  or, if A is a block, just add an empty alt to the end of the block
+         */
+        public virtual StateCluster build_Aoptional( StateCluster A )
+        {
+            StateCluster g = null;
+            int n = nfa.grammar.getNumberOfAltsForDecisionNFA( A.left );
+            if ( n == 1 )
+            {
+                // no decision, just wrap in an optional path
+                //NFAState decisionState = newState();
+                NFAState decisionState = A.left; // resuse left edge
+                decisionState.Description = "only alt of ()? block";
+                NFAState emptyAlt = newState();
+                emptyAlt.Description = "epsilon path of ()? block";
+                NFAState blockEndNFAState = null;
+                blockEndNFAState = newState();
+                transitionBetweenStates( A.right, blockEndNFAState, Label.EPSILON );
+                blockEndNFAState.Description = "end ()? block";
+                //transitionBetweenStates(decisionState, A.left, Label.EPSILON);
+                transitionBetweenStates( decisionState, emptyAlt, Label.EPSILON );
+                transitionBetweenStates( emptyAlt, blockEndNFAState, Label.EPSILON );
+
+                // set EOB markers for Jean
+                decisionState.endOfBlockStateNumber = blockEndNFAState.stateNumber;
+                blockEndNFAState.decisionStateType = NFAState.RIGHT_EDGE_OF_BLOCK;
+
+                g = new StateCluster( decisionState, blockEndNFAState );
+            }
+            else
+            {
+                // a decision block, add an empty alt
+                NFAState lastRealAlt =
+                        nfa.grammar.getNFAStateForAltOfDecision( A.left, n );
+                NFAState emptyAlt = newState();
+                emptyAlt.Description = "epsilon path of ()? block";
+                transitionBetweenStates( lastRealAlt, emptyAlt, Label.EPSILON );
+                transitionBetweenStates( emptyAlt, A.right, Label.EPSILON );
+
+                // set EOB markers for Jean (I think this is redundant here)
+                A.left.endOfBlockStateNumber = A.right.stateNumber;
+                A.right.decisionStateType = NFAState.RIGHT_EDGE_OF_BLOCK;
+
+                g = A; // return same block, but now with optional last path
+            }
+            g.left.decisionStateType = NFAState.OPTIONAL_BLOCK_START;
+
+            return g;
+        }
+
+        /** From (A)+ build
+         *
+         *     |---|    (Transition 2 from A.right points at alt 1)
+         *     v   |    (follow of loop is Transition 1)
+         *  o->o-A-o->o
+         *
+         *  Meaning that the last NFAState in A points back to A's left Transition NFAState
+         *  and we add a new begin/end NFAState.  A can be single alternative or
+         *  multiple.
+         *
+         *  During analysis we'll call the follow link (transition 1) alt n+1 for
+         *  an n-alt A block.
+         */
+        public virtual StateCluster build_Aplus( StateCluster A )
+        {
+            NFAState left = newState();
+            NFAState blockEndNFAState = newState();
+            blockEndNFAState.decisionStateType = NFAState.RIGHT_EDGE_OF_BLOCK;
+
+            // don't reuse A.right as loopback if it's right edge of another block
+            if ( A.right.decisionStateType == NFAState.RIGHT_EDGE_OF_BLOCK )
+            {
+                // nested A* so make another tail node to be the loop back
+                // instead of the usual A.right which is the EOB for inner loop
+                NFAState extraRightEdge = newState();
+                transitionBetweenStates( A.right, extraRightEdge, Label.EPSILON );
+                A.right = extraRightEdge;
+            }
+
+            transitionBetweenStates( A.right, blockEndNFAState, Label.EPSILON ); // follow is Transition 1
+            // turn A's block end into a loopback (acts like alt 2)
+            transitionBetweenStates( A.right, A.left, Label.EPSILON ); // loop back Transition 2
+            transitionBetweenStates( left, A.left, Label.EPSILON );
+
+            A.right.decisionStateType = NFAState.LOOPBACK;
+            A.left.decisionStateType = NFAState.BLOCK_START;
+
+            // set EOB markers for Jean
+            A.left.endOfBlockStateNumber = A.right.stateNumber;
+
+            StateCluster g = new StateCluster( left, blockEndNFAState );
+            return g;
+        }
+
+        /** From (A)* build
+         *
+         *     |---|
+         *     v   |
+         *  o->o-A-o--o (Transition 2 from block end points at alt 1; follow is Transition 1)
+         *  |         ^
+         *  o---------| (optional branch is 2nd alt of optional block containing A+)
+         *
+         *  Meaning that the last (end) NFAState in A points back to A's
+         *  left side NFAState and we add 3 new NFAStates (the
+         *  optional branch is built just like an optional subrule).
+         *  See the Aplus() method for more on the loop back Transition.
+         *  The new node on right edge is set to RIGHT_EDGE_OF_CLOSURE so we
+         *  can detect nested (A*)* loops and insert an extra node.  Previously,
+         *  two blocks shared same EOB node.
+         *
+         *  There are 2 or 3 decision points in a A*.  If A is not a block (i.e.,
+         *  it only has one alt), then there are two decisions: the optional bypass
+         *  and then loopback.  If A is a block of alts, then there are three
+         *  decisions: bypass, loopback, and A's decision point.
+         *
+         *  Note that the optional bypass must be outside the loop as (A|B)* is
+         *  not the same thing as (A|B|)+.
+         *
+         *  This is an accurate NFA representation of the meaning of (A)*, but
+         *  for generating code, I don't need a DFA for the optional branch by
+         *  virtue of how I generate code.  The exit-loopback-branch decision
+         *  is sufficient to let me make an appropriate enter, exit, loop
+         *  determination.  See codegen.g
+         */
+        public virtual StateCluster build_Astar( StateCluster A )
+        {
+            NFAState bypassDecisionState = newState();
+            bypassDecisionState.Description = "enter loop path of ()* block";
+            NFAState optionalAlt = newState();
+            optionalAlt.Description = "epsilon path of ()* block";
+            NFAState blockEndNFAState = newState();
+            blockEndNFAState.decisionStateType = NFAState.RIGHT_EDGE_OF_BLOCK;
+
+            // don't reuse A.right as loopback if it's right edge of another block
+            if ( A.right.decisionStateType == NFAState.RIGHT_EDGE_OF_BLOCK )
+            {
+                // nested A* so make another tail node to be the loop back
+                // instead of the usual A.right which is the EOB for inner loop
+                NFAState extraRightEdge = newState();
+                transitionBetweenStates( A.right, extraRightEdge, Label.EPSILON );
+                A.right = extraRightEdge;
+            }
+
+            // convert A's end block to loopback
+            A.right.Description = "()* loopback";
+            // Transition 1 to actual block of stuff
+            transitionBetweenStates( bypassDecisionState, A.left, Label.EPSILON );
+            // Transition 2 optional to bypass
+            transitionBetweenStates( bypassDecisionState, optionalAlt, Label.EPSILON );
+            transitionBetweenStates( optionalAlt, blockEndNFAState, Label.EPSILON );
+            // Transition 1 of end block exits
+            transitionBetweenStates( A.right, blockEndNFAState, Label.EPSILON );
+            // Transition 2 of end block loops
+            transitionBetweenStates( A.right, A.left, Label.EPSILON );
+
+            bypassDecisionState.decisionStateType = NFAState.BYPASS;
+            A.left.decisionStateType = NFAState.BLOCK_START;
+            A.right.decisionStateType = NFAState.LOOPBACK;
+
+            // set EOB markers for Jean
+            A.left.endOfBlockStateNumber = A.right.stateNumber;
+            bypassDecisionState.endOfBlockStateNumber = blockEndNFAState.stateNumber;
+
+            StateCluster g = new StateCluster( bypassDecisionState, blockEndNFAState );
+            return g;
+        }
+
+        /** Build an NFA predictor for special rule called Tokens manually that
+         *  predicts which token will succeed.  The refs to the rules are not
+         *  RuleRefTransitions as I want DFA conversion to stop at the EOT
+         *  transition on the end of each token, rather than return to Tokens rule.
+         *  If I used normal build_alternativeBlock for this, the RuleRefTransitions
+         *  would save return address when jumping away from Tokens rule.
+         *
+         *  All I do here is build n new states for n rules with an epsilon
+         *  edge to the rule start states and then to the next state in the
+         *  list:
+         *
+         *   o->(A)  (a state links to start of A and to next in list)
+         *   |
+         *   o->(B)
+         *   |
+         *   ...
+         *   |
+         *   o->(Z)
+         *
+         *  This is the NFA created for the artificial rule created in
+         *  Grammar.addArtificialMatchTokensRule().
+         *
+         *  11/28/2005: removed so we can use normal rule construction for Tokens.
+        public NFAState build_ArtificialMatchTokensRuleNFA() {
+            int altNum = 1;
+            NFAState firstAlt = null; // the start state for the "rule"
+            NFAState prevAlternative = null;
+            Iterator iter = nfa.grammar.getRules().iterator();
+            // TODO: add a single decision node/state for good description
+            while (iter.hasNext()) {
+                Rule r = (Rule) iter.next();
+                String ruleName = r.name;
+                String modifier = nfa.grammar.getRuleModifier(ruleName);
+                if ( ruleName.equals(Grammar.ARTIFICIAL_TOKENS_RULENAME) ||
+                     (modifier!=null &&
+                      modifier.equals(Grammar.FRAGMENT_RULE_MODIFIER)) )
+                {
+                    continue; // don't loop to yourself or do nontoken rules
+                }
+                NFAState ruleStartState = nfa.grammar.getRuleStartState(ruleName);
+                NFAState left = newState();
+                left.setDescription("alt "+altNum+" of artificial rule "+Grammar.ARTIFICIAL_TOKENS_RULENAME);
+                transitionBetweenStates(left, ruleStartState, Label.EPSILON);
+                // Are we the first alternative?
+                if ( firstAlt==null ) {
+                    firstAlt = left; // track extreme top left node as rule start
+                }
+                else {
+                    // if not first alternative, must link to this alt from previous
+                    transitionBetweenStates(prevAlternative, left, Label.EPSILON);
+                }
+                prevAlternative = left;
+                altNum++;
+            }
+            firstAlt.decisionStateType = NFAState.BLOCK_START;
+
+            return firstAlt;
+        }
+         */
+
+        /** Build an atom with all possible values in its label */
+        public virtual StateCluster build_Wildcard( GrammarAST associatedAST )
+        {
+            NFAState left = newState();
+            NFAState right = newState();
+            left.associatedASTNode = associatedAST;
+            right.associatedASTNode = associatedAST;
+            Label label = new Label( nfa.grammar.TokenTypes ); // char or tokens
+            Transition e = new Transition( label, right );
+            left.addTransition( e );
+            StateCluster g = new StateCluster( left, right );
+            return g;
+        }
+
+        /** Build a subrule matching ^(. .*) (any tree or node). Let's use
+         *  (^(. .+) | .) to be safe.
+         */
+        public StateCluster build_WildcardTree( GrammarAST associatedAST )
+        {
+            StateCluster wildRoot = build_Wildcard( associatedAST );
+
+            StateCluster down = build_Atom( Label.DOWN, associatedAST );
+            wildRoot = build_AB( wildRoot, down ); // hook in; . DOWN
+
+            // make .+
+            StateCluster wildChildren = build_Wildcard( associatedAST );
+            wildChildren = build_Aplus( wildChildren );
+            wildRoot = build_AB( wildRoot, wildChildren ); // hook in; . DOWN .+
+
+            StateCluster up = build_Atom( Label.UP, associatedAST );
+            wildRoot = build_AB( wildRoot, up ); // hook in; . DOWN .+ UP
+
+            // make optional . alt
+            StateCluster optionalNodeAlt = build_Wildcard( associatedAST );
+
+            //List alts = new List<object>();
+            var alts = new List<StateCluster>()
+            {
+                wildRoot,
+                optionalNodeAlt
+            };
+            StateCluster blk = build_AlternativeBlock( alts );
+
+            return blk;
+        }
+
+        /** Given a collapsed block of alts (a set of atoms), pull out
+         *  the set and return it.
+         */
+        protected virtual IIntSet getCollapsedBlockAsSet( State blk )
+        {
+            State s0 = blk;
+            if ( s0 != null && s0.getTransition( 0 ) != null )
+            {
+                State s1 = s0.getTransition( 0 ).target;
+                if ( s1 != null && s1.getTransition( 0 ) != null )
+                {
+                    Label label = s1.getTransition( 0 ).label;
+                    if ( label.IsSet )
+                    {
+                        return label.Set;
+                    }
+                }
+            }
+            return null;
+        }
+
+        private void transitionBetweenStates( NFAState a, NFAState b, int label )
+        {
+            Transition e = new Transition( label, b );
+            a.addTransition( e );
+        }
+    }
+}
diff --git a/Antlr3/Tool/NameSpaceChecker.cs b/Antlr3/Tool/NameSpaceChecker.cs
new file mode 100644
index 0000000..82bf9c3
--- /dev/null
+++ b/Antlr3/Tool/NameSpaceChecker.cs
@@ -0,0 +1,310 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using System.Collections.Generic;
+    using System.Linq;
+    using Antlr.Runtime.JavaExtensions;
+
+    using IToken = Antlr.Runtime.IToken;
+    using Label = Antlr3.Analysis.Label;
+
+    public class NameSpaceChecker
+    {
+        protected Grammar grammar;
+
+        public NameSpaceChecker( Grammar grammar )
+        {
+            this.grammar = grammar;
+        }
+
+        public virtual void checkConflicts()
+        {
+            for ( int i = CompositeGrammar.MIN_RULE_INDEX; i < grammar.composite.ruleIndexToRuleList.Count; i++ )
+            {
+                Rule r = grammar.composite.ruleIndexToRuleList[i];
+                if ( r == null )
+                {
+                    continue;
+                }
+                // walk all labels for Rule r
+                if ( r.labelNameSpace != null )
+                {
+                    foreach ( Grammar.LabelElementPair pair in r.labelNameSpace.Values )
+                    {
+                        checkForLabelConflict( r, pair.label );
+                    }
+                }
+                // walk rule scope attributes for Rule r
+                if ( r.ruleScope != null )
+                {
+                    var attributes = r.ruleScope.Attributes;
+                    for ( int j = 0; j < attributes.Count; j++ )
+                    {
+                        Attribute attribute = (Attribute)attributes.ElementAt( j );
+                        checkForRuleScopeAttributeConflict( r, attribute );
+                    }
+                }
+                checkForRuleDefinitionProblems( r );
+                checkForRuleArgumentAndReturnValueConflicts( r );
+            }
+            // check all global scopes against tokens
+            foreach ( AttributeScope scope in grammar.GlobalScopes.Values )
+            {
+                checkForGlobalScopeTokenConflict( scope );
+            }
+            // check for missing rule, tokens
+            lookForReferencesToUndefinedSymbols();
+        }
+
+        protected virtual void checkForRuleArgumentAndReturnValueConflicts( Rule r )
+        {
+            if ( r.returnScope != null )
+            {
+                HashSet<object> conflictingKeys = r.returnScope.intersection( r.parameterScope );
+                if ( conflictingKeys != null )
+                {
+                    foreach ( string key in conflictingKeys )
+                    {
+                        ErrorManager.grammarError(
+                            ErrorManager.MSG_ARG_RETVAL_CONFLICT,
+                            grammar,
+                            r.tree.Token,
+                            key,
+                            r.name );
+                    }
+                }
+            }
+        }
+
+        protected virtual void checkForRuleDefinitionProblems( Rule r )
+        {
+            string ruleName = r.name;
+            IToken ruleToken = r.tree.Token;
+            int msgID = 0;
+            if ( ( grammar.type == Grammar.PARSER || grammar.type == Grammar.TREE_PARSER ) &&
+                 char.IsUpper( ruleName[0] ) )
+            {
+                msgID = ErrorManager.MSG_LEXER_RULES_NOT_ALLOWED;
+            }
+            else if ( grammar.type == Grammar.LEXER &&
+                      char.IsLower( ruleName[0] ) &&
+                      !r.isSynPred )
+            {
+                msgID = ErrorManager.MSG_PARSER_RULES_NOT_ALLOWED;
+            }
+            else if ( grammar.getGlobalScope( ruleName ) != null )
+            {
+                msgID = ErrorManager.MSG_SYMBOL_CONFLICTS_WITH_GLOBAL_SCOPE;
+            }
+            if ( msgID != 0 )
+            {
+                ErrorManager.grammarError( msgID, grammar, ruleToken, ruleName );
+            }
+        }
+
+        /** If ref to undefined rule, give error at first occurrence.
+         *
+         *  Give error if you cannot find the scope override on a rule reference.
+         *
+         *  If you ref ID in a combined grammar and don't define ID as a lexer rule
+         *  it is an error.
+         */
+        protected virtual void lookForReferencesToUndefinedSymbols()
+        {
+            // for each rule ref, ask if there is a rule definition
+            foreach ( GrammarAST refAST in grammar.ruleRefs )
+            {
+                IToken tok = refAST.token;
+                string ruleName = tok.Text;
+                Rule localRule = grammar.getLocallyDefinedRule( ruleName );
+                Rule rule = grammar.getRule( ruleName );
+                if ( localRule == null && rule != null )
+                { // imported rule?
+                    grammar.delegatedRuleReferences.Add( rule );
+                    rule.imported = true;
+                }
+                if ( rule == null && grammar.getTokenType( ruleName ) != Label.EOF )
+                {
+                    ErrorManager.grammarError( ErrorManager.MSG_UNDEFINED_RULE_REF,
+                                              grammar,
+                                              tok,
+                                              ruleName );
+                }
+            }
+            if ( grammar.type == Grammar.COMBINED )
+            {
+                // if we're a combined grammar, we know which token IDs have no
+                // associated lexer rule.
+                foreach ( IToken tok in grammar.tokenIDRefs )
+                {
+                    string tokenID = tok.Text;
+                    if ( !grammar.composite.lexerRules.Contains( tokenID ) &&
+                         grammar.getTokenType( tokenID ) != Label.EOF )
+                    {
+                        ErrorManager.grammarWarning( ErrorManager.MSG_NO_TOKEN_DEFINITION,
+                                                    grammar,
+                                                    tok,
+                                                    tokenID );
+                    }
+                }
+            }
+            // check scopes and scoped rule refs
+            foreach ( GrammarAST scopeAST in grammar.scopedRuleRefs )
+            {
+                // ^(DOT ID atom)
+                Grammar scopeG = grammar.composite.getGrammar( scopeAST.Text );
+                GrammarAST refAST = (GrammarAST)scopeAST.GetChild( 1 );
+                string ruleName = refAST.Text;
+                if ( scopeG == null )
+                {
+                    ErrorManager.grammarError( ErrorManager.MSG_NO_SUCH_GRAMMAR_SCOPE,
+                                              grammar,
+                                              scopeAST.Token,
+                                              scopeAST.Text,
+                                              ruleName );
+                }
+                else
+                {
+                    Rule rule = grammar.getRule( scopeG.name, ruleName );
+                    if ( rule == null )
+                    {
+                        ErrorManager.grammarError( ErrorManager.MSG_NO_SUCH_RULE_IN_SCOPE,
+                                                  grammar,
+                                                  scopeAST.Token,
+                                                  scopeAST.Text,
+                                                  ruleName );
+                    }
+                }
+            }
+        }
+
+        protected virtual void checkForGlobalScopeTokenConflict( AttributeScope scope )
+        {
+            if ( grammar.getTokenType( scope.Name ) != Label.INVALID )
+            {
+                ErrorManager.grammarError( ErrorManager.MSG_SYMBOL_CONFLICTS_WITH_GLOBAL_SCOPE,
+                                          grammar, null, scope.Name );
+            }
+        }
+
+        /** Check for collision of a rule-scope dynamic attribute with:
+         *  arg, return value, rule name itself.  Labels are checked elsewhere.
+         */
+        public virtual void checkForRuleScopeAttributeConflict( Rule r, Attribute attribute )
+        {
+            int msgID = 0;
+            object arg2 = null;
+            string attrName = attribute.Name;
+            if ( r.name.Equals( attrName ) )
+            {
+                msgID = ErrorManager.MSG_ATTRIBUTE_CONFLICTS_WITH_RULE;
+                arg2 = r.name;
+            }
+            else if ( ( r.returnScope != null && r.returnScope.getAttribute( attrName ) != null ) ||
+                      ( r.parameterScope != null && r.parameterScope.getAttribute( attrName ) != null ) )
+            {
+                msgID = ErrorManager.MSG_ATTRIBUTE_CONFLICTS_WITH_RULE_ARG_RETVAL;
+                arg2 = r.name;
+            }
+            if ( msgID != 0 )
+            {
+                ErrorManager.grammarError( msgID, grammar, r.tree.Token, attrName, arg2 );
+            }
+        }
+
+        /** Make sure a label doesn't conflict with another symbol.
+         *  Labels must not conflict with: rules, tokens, scope names,
+         *  return values, parameters, and rule-scope dynamic attributes
+         *  defined in surrounding rule.
+         */
+        protected virtual void checkForLabelConflict( Rule r, IToken label )
+        {
+            int msgID = 0;
+            object arg2 = null;
+            if ( grammar.getGlobalScope( label.Text ) != null )
+            {
+                msgID = ErrorManager.MSG_SYMBOL_CONFLICTS_WITH_GLOBAL_SCOPE;
+            }
+            else if ( grammar.getRule( label.Text ) != null )
+            {
+                msgID = ErrorManager.MSG_LABEL_CONFLICTS_WITH_RULE;
+            }
+            else if ( grammar.getTokenType( label.Text ) != Label.INVALID )
+            {
+                msgID = ErrorManager.MSG_LABEL_CONFLICTS_WITH_TOKEN;
+            }
+            else if ( r.ruleScope != null && r.ruleScope.getAttribute( label.Text ) != null )
+            {
+                msgID = ErrorManager.MSG_LABEL_CONFLICTS_WITH_RULE_SCOPE_ATTRIBUTE;
+                arg2 = r.name;
+            }
+            else if ( ( r.returnScope != null && r.returnScope.getAttribute( label.Text ) != null ) ||
+                      ( r.parameterScope != null && r.parameterScope.getAttribute( label.Text ) != null ) )
+            {
+                msgID = ErrorManager.MSG_LABEL_CONFLICTS_WITH_RULE_ARG_RETVAL;
+                arg2 = r.name;
+            }
+            if ( msgID != 0 )
+            {
+                ErrorManager.grammarError( msgID, grammar, label, label.Text, arg2 );
+            }
+        }
+
+        /** If type of previous label differs from new label's type, that's an error.
+         */
+        public virtual bool checkForLabelTypeMismatch( Rule r, IToken label, int type )
+        {
+            Grammar.LabelElementPair prevLabelPair =
+                (Grammar.LabelElementPair)r.labelNameSpace.get( label.Text );
+            if ( prevLabelPair != null )
+            {
+                // label already defined; if same type, no problem
+                if ( prevLabelPair.type != type )
+                {
+                    string typeMismatchExpr =
+                        Grammar.LabelTypeToString[type] + "!=" +
+                        Grammar.LabelTypeToString[prevLabelPair.type];
+                    ErrorManager.grammarError(
+                        ErrorManager.MSG_LABEL_TYPE_CONFLICT,
+                        grammar,
+                        label,
+                        label.Text,
+                        typeMismatchExpr );
+                    return true;
+                }
+            }
+            return false;
+        }
+    }
+}
diff --git a/Antlr3/Tool/NonRegularDecisionMessage.cs b/Antlr3/Tool/NonRegularDecisionMessage.cs
new file mode 100644
index 0000000..2ab88cc
--- /dev/null
+++ b/Antlr3/Tool/NonRegularDecisionMessage.cs
@@ -0,0 +1,79 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using System;
+    using System.Collections.Generic;
+    using Antlr.Runtime.JavaExtensions;
+
+    using DecisionProbe = Antlr3.Analysis.DecisionProbe;
+    using StringTemplate = Antlr3.ST.StringTemplate;
+
+    /** More a single alternative recurses so this decision is not regular. */
+    public class NonRegularDecisionMessage : Message
+    {
+        public DecisionProbe probe;
+        public ICollection<int> altsWithRecursion;
+
+        public NonRegularDecisionMessage( DecisionProbe probe, ICollection<int> altsWithRecursion )
+            : base( ErrorManager.MSG_NONREGULAR_DECISION )
+        {
+            this.probe = probe;
+            this.altsWithRecursion = altsWithRecursion;
+        }
+
+        public override String ToString()
+        {
+            GrammarAST decisionASTNode = probe.dfa.DecisionASTNode;
+            line = decisionASTNode.Line;
+            charPositionInLine = decisionASTNode.CharPositionInLine;
+            String fileName = probe.dfa.nfa.grammar.FileName;
+            if ( fileName != null )
+            {
+                file = fileName;
+            }
+
+            StringTemplate st = getMessageTemplate();
+            String ruleName = probe.dfa.NFADecisionStartState.enclosingRule.name;
+            st.setAttribute( "ruleName", ruleName );
+            List<int> sortedAlts = new List<int>();
+            sortedAlts.addAll( altsWithRecursion );
+            sortedAlts.Sort();
+            //Collections.sort(sortedAlts); // make sure it's 1, 2, ...
+            st.setAttribute( "alts", sortedAlts );
+
+            return base.ToString( st );
+        }
+
+    }
+}
diff --git a/Antlr3/Tool/RecursionOverflowMessage.cs b/Antlr3/Tool/RecursionOverflowMessage.cs
new file mode 100644
index 0000000..f507bc5
--- /dev/null
+++ b/Antlr3/Tool/RecursionOverflowMessage.cs
@@ -0,0 +1,90 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using System;
+    using System.Collections.Generic;
+    using Antlr3.Analysis;
+
+    using StringTemplate = Antlr3.ST.StringTemplate;
+
+    /** Indicates recursion overflow.  A DFA state tried add an NFA configuration
+     *  with NFA state p that was mentioned in its stack context too many times.
+     */
+    public class RecursionOverflowMessage : Message
+    {
+        public DecisionProbe probe;
+        public DFAState sampleBadState;
+        public int alt;
+        public ICollection<string> targetRules;
+        public ICollection<ICollection<NFAState>> callSiteStates;
+
+        public RecursionOverflowMessage( DecisionProbe probe,
+                                        DFAState sampleBadState,
+                                        int alt,
+                                        ICollection<string> targetRules,
+                                        ICollection<ICollection<NFAState>> callSiteStates )
+            : base( ErrorManager.MSG_RECURSION_OVERLOW )
+        {
+            this.probe = probe;
+            this.sampleBadState = sampleBadState;
+            this.alt = alt;
+            this.targetRules = targetRules;
+            this.callSiteStates = callSiteStates;
+        }
+
+        public override String ToString()
+        {
+            GrammarAST decisionASTNode = probe.dfa.DecisionASTNode;
+            line = decisionASTNode.Line;
+            charPositionInLine = decisionASTNode.CharPositionInLine;
+            String fileName = probe.dfa.nfa.grammar.FileName;
+            if ( fileName != null )
+            {
+                file = fileName;
+            }
+
+            StringTemplate st = getMessageTemplate();
+            st.setAttribute( "targetRules", targetRules );
+            st.setAttribute( "alt", alt );
+            st.setAttribute( "callSiteStates", callSiteStates );
+
+            var labels = probe.getSampleNonDeterministicInputSequence( sampleBadState );
+            String input = probe.getInputSequenceDisplay( labels );
+            st.setAttribute( "input", input );
+
+            return base.ToString( st );
+        }
+
+    }
+}
diff --git a/Antlr3/Tool/Rule.cs b/Antlr3/Tool/Rule.cs
new file mode 100644
index 0000000..164e8ea
--- /dev/null
+++ b/Antlr3/Tool/Rule.cs
@@ -0,0 +1,775 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using System.Collections.Generic;
+    using System.Linq;
+    using Antlr.Runtime.JavaExtensions;
+
+    using ANTLRParser = Antlr3.Grammars.ANTLRParser;
+    using CodeGenerator = Antlr3.Codegen.CodeGenerator;
+    using CommonToken = Antlr.Runtime.CommonToken;
+    using IDictionary = System.Collections.IDictionary;
+    using IList = System.Collections.IList;
+    using IToken = Antlr.Runtime.IToken;
+    using LookaheadSet = Antlr3.Analysis.LookaheadSet;
+    using NFAState = Antlr3.Analysis.NFAState;
+
+    /** Combine the info associated with a rule. */
+    public class Rule
+    {
+        public string name;
+        public int index;
+        public string modifier;
+        public NFAState startState;
+        public NFAState stopState;
+
+        /** This rule's options */
+        protected IDictionary options;
+
+        public static readonly HashSet<string> legalOptions = new HashSet<string>()
+            {
+                "k",
+                "greedy",
+                "memoize",
+                "backtrack"
+            };
+
+        /** The AST representing the whole rule */
+        public GrammarAST tree;
+
+        /** To which grammar does this belong? */
+        public Grammar grammar;
+
+        /** For convenience, track the argument def AST action node if any */
+        public GrammarAST argActionAST;
+
+        public GrammarAST EORNode;
+
+        /** The set of all tokens reachable from the start state w/o leaving
+         *  via the accept state.  If it reaches the accept state, FIRST
+         *  includes EOR_TOKEN_TYPE.
+         */
+        public LookaheadSet FIRST;
+
+        /** The return values of a rule and predefined rule attributes */
+        public AttributeScope returnScope;
+
+        public AttributeScope parameterScope;
+
+        /** the attributes defined with "scope {...}" inside a rule */
+        public AttributeScope ruleScope;
+
+        /** A list of scope names used by this rule */
+        public List<string> useScopes;
+
+        /** Exceptions that this rule can throw */
+        public HashSet<string> throwsSpec;
+
+        /** A list of all LabelElementPair attached to tokens like id=ID */
+        public Dictionary<string, Grammar.LabelElementPair> tokenLabels;
+
+        /** A list of all LabelElementPair attached to tokens like x=. in tree grammar */
+        public Dictionary<string, Grammar.LabelElementPair> wildcardTreeLabels;
+
+        /** A list of all LabelElementPair attached to tokens like x+=. in tree grammar */
+        public Dictionary<string, Grammar.LabelElementPair> wildcardTreeListLabels;
+
+        /** A list of all LabelElementPair attached to single char literals like x='a' */
+        public Dictionary<string, Grammar.LabelElementPair> charLabels;
+
+        /** A list of all LabelElementPair attached to rule references like f=field */
+        public Dictionary<string, Grammar.LabelElementPair> ruleLabels;
+
+        /** A list of all Token list LabelElementPair like ids+=ID */
+        public Dictionary<string, Grammar.LabelElementPair> tokenListLabels;
+
+        /** A list of all rule ref list LabelElementPair like ids+=expr */
+        public Dictionary<string, Grammar.LabelElementPair> ruleListLabels;
+
+        /** All labels go in here (plus being split per the above lists) to
+         *  catch dup label and label type mismatches.
+         */
+        protected internal IDictionary<string, Grammar.LabelElementPair> labelNameSpace =
+            new Dictionary<string, Grammar.LabelElementPair>();
+
+        /** Map a name to an action for this rule.  Currently init is only
+         *  one we use, but we can add more in future.
+         *  The code generator will use this to fill holes in the rule template.
+         *  I track the AST node for the action in case I need the line number
+         *  for errors.  A better name is probably namedActions, but I don't
+         *  want everyone to have to change their code gen templates now.
+         */
+        IDictionary<string, object> actions = new Dictionary<string, object>();
+
+        /** Track all executable actions other than named actions like @init.
+         *  Also tracks exception handlers, predicates, and rewrite rewrites.
+         *  We need to examine these actions before code generation so
+         *  that we can detect refs to $rule.attr etc...
+         */
+        IList<GrammarAST> inlineActions = new List<GrammarAST>();
+
+        public int numberOfAlts;
+
+        /** Each alt has a Map<tokenRefName,List<tokenRefAST>>; range 1..numberOfAlts.
+         *  So, if there are 3 ID refs in a rule's alt number 2, you'll have
+         *  altToTokenRef[2].get("ID").size()==3.  This is used to see if $ID is ok.
+         *  There must be only one ID reference in the alt for $ID to be ok in
+         *  an action--must be unique.
+         *
+         *  This also tracks '+' and "int" literal token references
+         *  (if not in LEXER).
+         *
+         *  Rewrite rules force tracking of all tokens.
+         */
+        IDictionary<string, IList<GrammarAST>>[] altToTokenRefMap;
+
+        /** Each alt has a Map<ruleRefName,List<ruleRefAST>>; range 1..numberOfAlts
+         *  So, if there are 3 expr refs in a rule's alt number 2, you'll have
+         *  altToRuleRef[2].get("expr").size()==3.  This is used to see if $expr is ok.
+         *  There must be only one expr reference in the alt for $expr to be ok in
+         *  an action--must be unique.
+         *
+         *  Rewrite rules force tracking of all rule result ASTs. 1..n
+         */
+        IDictionary<string, IList<GrammarAST>>[] altToRuleRefMap;
+
+        /** Track which alts have rewrite rules associated with them. 1..n */
+        bool[] altsWithRewrites;
+
+        /** Do not generate start, stop etc... in a return value struct unless
+         *  somebody references $r.start somewhere.
+         */
+        public bool referencedPredefinedRuleAttributes = false;
+
+        public bool isSynPred = false;
+
+        public bool imported = false;
+
+        public Rule( Grammar grammar,
+                    string ruleName,
+                    int ruleIndex,
+                    int numberOfAlts )
+        {
+            this.name = ruleName;
+            this.index = ruleIndex;
+            this.numberOfAlts = numberOfAlts;
+            this.grammar = grammar;
+            throwsSpec = new HashSet<string>() { "RecognitionException" };
+            altToTokenRefMap = new IDictionary<string, IList<GrammarAST>>[numberOfAlts + 1]; //new Map[numberOfAlts + 1];
+            altToRuleRefMap = new IDictionary<string, IList<GrammarAST>>[numberOfAlts + 1]; //new Map[numberOfAlts + 1];
+            altsWithRewrites = new bool[numberOfAlts + 1];
+            for ( int alt = 1; alt <= numberOfAlts; alt++ )
+            {
+                altToTokenRefMap[alt] = new Dictionary<string, IList<GrammarAST>>();
+                altToRuleRefMap[alt] = new Dictionary<string, IList<GrammarAST>>();
+            }
+        }
+
+        #region Properties
+        public IDictionary<string, object> Actions
+        {
+            get
+            {
+                return actions;
+            }
+        }
+        public bool HasMultipleReturnValues
+        {
+            get
+            {
+                return getHasMultipleReturnValues();
+            }
+        }
+        public bool HasReturnValue
+        {
+            get
+            {
+                return getHasReturnValue();
+            }
+        }
+        public bool HasSingleReturnValue
+        {
+            get
+            {
+                return getHasSingleReturnValue();
+            }
+        }
+        public ICollection<GrammarAST> InlineActions
+        {
+            get
+            {
+                return getInlineActions();
+            }
+        }
+        public IDictionary RuleLabels
+        {
+            get
+            {
+                return getRuleLabels();
+            }
+        }
+        public IDictionary RuleListLabels
+        {
+            get
+            {
+                return getRuleListLabels();
+            }
+        }
+        public string SingleValueReturnName
+        {
+            get
+            {
+                return getSingleValueReturnName();
+            }
+        }
+        public string SingleValueReturnType
+        {
+            get
+            {
+                return getSingleValueReturnType();
+            }
+        }
+        #endregion
+
+        public virtual void defineLabel( IToken label, GrammarAST elementRef, int type )
+        {
+            Grammar.LabelElementPair pair = new Grammar.LabelElementPair( grammar, label, elementRef );
+            pair.type = type;
+            labelNameSpace[label.Text] = pair;
+            switch ( type )
+            {
+            case Grammar.TOKEN_LABEL:
+                if ( tokenLabels == null )
+                {
+                    tokenLabels = new Dictionary<string, Grammar.LabelElementPair>();
+                }
+                //tokenLabels.put( label.getText(), pair );
+                tokenLabels[label.Text] = pair;
+                break;
+
+            case Grammar.WILDCARD_TREE_LABEL:
+                if ( wildcardTreeLabels == null )
+                    wildcardTreeLabels = new Dictionary<string, Grammar.LabelElementPair>();
+                wildcardTreeLabels[label.Text] = pair;
+                break;
+
+            case Grammar.WILDCARD_TREE_LIST_LABEL:
+                if ( wildcardTreeListLabels == null )
+                    wildcardTreeListLabels = new Dictionary<string, Grammar.LabelElementPair>();
+                wildcardTreeListLabels[label.Text] = pair;
+                break;
+
+            case Grammar.RULE_LABEL:
+                if ( ruleLabels == null )
+                {
+                    ruleLabels = new Dictionary<string, Grammar.LabelElementPair>();
+                }
+                //ruleLabels.put( label.getText(), pair );
+                ruleLabels[label.Text] = pair;
+                break;
+            case Grammar.TOKEN_LIST_LABEL:
+                if ( tokenListLabels == null )
+                {
+                    tokenListLabels = new Dictionary<string, Grammar.LabelElementPair>();
+                }
+                //tokenListLabels.put( label.getText(), pair );
+                tokenListLabels[label.Text] = pair;
+                break;
+            case Grammar.RULE_LIST_LABEL:
+                if ( ruleListLabels == null )
+                {
+                    ruleListLabels = new Dictionary<string, Grammar.LabelElementPair>();
+                }
+                //ruleListLabels.put( label.getText(), pair );
+                ruleListLabels[label.Text] = pair;
+                break;
+            case Grammar.CHAR_LABEL:
+                if ( charLabels == null )
+                {
+                    charLabels = new Dictionary<string, Grammar.LabelElementPair>();
+                }
+                //charLabels.put( label.getText(), pair );
+                charLabels[label.Text] = pair;
+                break;
+            }
+        }
+
+        public virtual Grammar.LabelElementPair getLabel( string name )
+        {
+            return (Grammar.LabelElementPair)labelNameSpace.get( name );
+        }
+
+        public virtual Grammar.LabelElementPair getTokenLabel( string name )
+        {
+            Grammar.LabelElementPair pair = null;
+            if ( tokenLabels != null )
+            {
+                return (Grammar.LabelElementPair)tokenLabels.get( name );
+            }
+            return pair;
+        }
+
+        public virtual IDictionary getRuleLabels()
+        {
+            return ruleLabels;
+        }
+
+        public virtual IDictionary getRuleListLabels()
+        {
+            return ruleListLabels;
+        }
+
+        public virtual Grammar.LabelElementPair getRuleLabel( string name )
+        {
+            Grammar.LabelElementPair pair = null;
+            if ( ruleLabels != null )
+            {
+                return (Grammar.LabelElementPair)ruleLabels.get( name );
+            }
+            return pair;
+        }
+
+        public virtual Grammar.LabelElementPair getTokenListLabel( string name )
+        {
+            Grammar.LabelElementPair pair = null;
+            if ( tokenListLabels != null )
+            {
+                return (Grammar.LabelElementPair)tokenListLabels.get( name );
+            }
+            return pair;
+        }
+
+        public virtual Grammar.LabelElementPair getRuleListLabel( string name )
+        {
+            Grammar.LabelElementPair pair = null;
+            if ( ruleListLabels != null )
+            {
+                return (Grammar.LabelElementPair)ruleListLabels.get( name );
+            }
+            return pair;
+        }
+
+        /** Track a token ID or literal like '+' and "void" as having been referenced
+         *  somewhere within the alts (not rewrite sections) of a rule.
+         *
+         *  This differs from Grammar.altReferencesTokenID(), which tracks all
+         *  token IDs to check for token IDs without corresponding lexer rules.
+         */
+        public virtual void trackTokenReferenceInAlt( GrammarAST refAST, int outerAltNum )
+        {
+            IList<GrammarAST> refs = altToTokenRefMap[outerAltNum].get( refAST.Text );
+            if ( refs == null )
+            {
+                refs = new List<GrammarAST>();
+                altToTokenRefMap[outerAltNum][refAST.Text] = refs;
+            }
+            refs.Add( refAST );
+        }
+
+        public virtual IList getTokenRefsInAlt( string @ref, int outerAltNum )
+        {
+            if ( altToTokenRefMap[outerAltNum] != null )
+            {
+                IList tokenRefASTs = (IList)altToTokenRefMap[outerAltNum].get( @ref );
+                return tokenRefASTs;
+            }
+            return null;
+        }
+
+        public virtual void trackRuleReferenceInAlt( GrammarAST refAST, int outerAltNum )
+        {
+            IList<GrammarAST> refs = altToRuleRefMap[outerAltNum].get( refAST.Text );
+            if ( refs == null )
+            {
+                refs = new List<GrammarAST>();
+                altToRuleRefMap[outerAltNum][refAST.Text] = refs;
+            }
+            refs.Add( refAST );
+        }
+
+        public virtual IList getRuleRefsInAlt( string @ref, int outerAltNum )
+        {
+            if ( altToRuleRefMap[outerAltNum] != null )
+            {
+                IList ruleRefASTs = (IList)altToRuleRefMap[outerAltNum].get( @ref );
+                return ruleRefASTs;
+            }
+            return null;
+        }
+
+        public virtual ICollection<string> getTokenRefsInAlt( int altNum )
+        {
+            return altToTokenRefMap[altNum].Keys;
+        }
+
+        /** For use with rewrite rules, we must track all tokens matched on the
+         *  left-hand-side; so we need Lists.  This is a unique list of all
+         *  token types for which the rule needs a list of tokens.  This
+         *  is called from the rule template not directly by the code generator.
+         */
+        public virtual ICollection<string> getAllTokenRefsInAltsWithRewrites()
+        {
+            string output = (string)grammar.getOption( "output" );
+            ICollection<string> tokens = new HashSet<string>();
+            if ( output == null || !output.Equals( "AST" ) )
+            {
+                // return nothing if not generating trees; i.e., don't do for templates
+                return tokens;
+            }
+            for ( int i = 1; i <= numberOfAlts; i++ )
+            {
+                if ( altsWithRewrites[i] )
+                {
+                    foreach ( string tokenName in altToTokenRefMap[i].Keys )
+                    {
+                        // convert token name like ID to ID, "void" to 31
+                        int ttype = grammar.getTokenType( tokenName );
+                        string label = grammar.generator.getTokenTypeAsTargetLabel( ttype );
+                        tokens.Add( label );
+                    }
+                }
+            }
+            return tokens;
+        }
+
+        public virtual ICollection<string> getRuleRefsInAlt( int outerAltNum )
+        {
+            return altToRuleRefMap[outerAltNum].Keys;
+        }
+
+        /** For use with rewrite rules, we must track all rule AST results on the
+         *  left-hand-side; so we need Lists.  This is a unique list of all
+         *  rule results for which the rule needs a list of results.
+         */
+        public virtual ICollection<string> getAllRuleRefsInAltsWithRewrites()
+        {
+            var rules = from i in Enumerable.Range( 1, numberOfAlts )
+                        where altsWithRewrites[i]
+                        select altToRuleRefMap[i].Keys;
+
+            return new HashSet<string>( rules.SelectMany( r => r ) );
+        }
+
+        public virtual IList<GrammarAST> getInlineActions()
+        {
+            return inlineActions;
+        }
+
+        public virtual bool hasRewrite( int i )
+        {
+            if ( i >= altsWithRewrites.Length )
+            {
+                ErrorManager.internalError( "alt " + i + " exceeds number of " + name +
+                                           "'s alts (" + altsWithRewrites.Length + ")" );
+                return false;
+            }
+            return altsWithRewrites[i];
+        }
+
+        /** Track which rules have rewrite rules.  Pass in the ALT node
+         *  for the alt so we can check for problems when output=template,
+         *  rewrite=true, and grammar type is tree parser.
+         */
+        public virtual void trackAltsWithRewrites( GrammarAST altAST, int outerAltNum )
+        {
+            if ( grammar.type == Grammar.TREE_PARSER &&
+                 grammar.BuildTemplate &&
+                 grammar.getOption( "rewrite" ) != null &&
+                 grammar.getOption( "rewrite" ).Equals( "true" )
+                )
+            {
+                GrammarAST firstElementAST = (GrammarAST)altAST.GetChild( 0 );
+                grammar.sanity.ensureAltIsSimpleNodeOrTree( altAST,
+                                                           firstElementAST,
+                                                           outerAltNum );
+            }
+            altsWithRewrites[outerAltNum] = true;
+        }
+
+        /** Return the scope containing name */
+        public virtual AttributeScope getAttributeScope( string name )
+        {
+            AttributeScope scope = getLocalAttributeScope( name );
+            if ( scope != null )
+            {
+                return scope;
+            }
+            if ( ruleScope != null && ruleScope.getAttribute( name ) != null )
+            {
+                scope = ruleScope;
+            }
+            return scope;
+        }
+
+        /** Get the arg, return value, or predefined property for this rule */
+        public virtual AttributeScope getLocalAttributeScope( string name )
+        {
+            AttributeScope scope = null;
+            if ( returnScope != null && returnScope.getAttribute( name ) != null )
+            {
+                scope = returnScope;
+            }
+            else if ( parameterScope != null && parameterScope.getAttribute( name ) != null )
+            {
+                scope = parameterScope;
+            }
+            else
+            {
+                AttributeScope rulePropertiesScope =
+                    RuleLabelScope.grammarTypeToRulePropertiesScope[grammar.type];
+                if ( rulePropertiesScope.getAttribute( name ) != null )
+                {
+                    scope = rulePropertiesScope;
+                }
+            }
+            return scope;
+        }
+
+        /** For references to tokens rather than by label such as $ID, we
+         *  need to get the existing label for the ID ref or create a new
+         *  one.
+         */
+        public virtual string getElementLabel( string refdSymbol,
+                                      int outerAltNum,
+                                      CodeGenerator generator )
+        {
+            GrammarAST uniqueRefAST;
+            if ( grammar.type != Grammar.LEXER &&
+                 char.IsUpper( refdSymbol[0] ) )
+            {
+                // symbol is a token
+                IList tokenRefs = getTokenRefsInAlt( refdSymbol, outerAltNum );
+                uniqueRefAST = (GrammarAST)tokenRefs[0];
+            }
+            else
+            {
+                // symbol is a rule
+                IList ruleRefs = getRuleRefsInAlt( refdSymbol, outerAltNum );
+                uniqueRefAST = (GrammarAST)ruleRefs[0];
+            }
+            if ( uniqueRefAST.code == null )
+            {
+                // no code?  must not have gen'd yet; forward ref
+                return null;
+            }
+            string labelName = null;
+            string existingLabelName =
+                (string)uniqueRefAST.code.getAttribute( "label" );
+            // reuse any label or list label if it exists
+            if ( existingLabelName != null )
+            {
+                labelName = existingLabelName;
+            }
+            else
+            {
+                // else create new label
+                labelName = generator.createUniqueLabel( refdSymbol );
+                CommonToken label = new CommonToken( ANTLRParser.ID, labelName );
+                if ( grammar.type != Grammar.LEXER &&
+                     char.IsUpper( refdSymbol[0] ) )
+                {
+                    grammar.defineTokenRefLabel( name, label, uniqueRefAST );
+                }
+                else
+                {
+                    grammar.defineRuleRefLabel( name, label, uniqueRefAST );
+                }
+                uniqueRefAST.code.setAttribute( "label", labelName );
+            }
+            return labelName;
+        }
+
+        /** If a rule has no user-defined return values and nobody references
+         *  it's start/stop (predefined attributes), then there is no need to
+         *  define a struct; otherwise for now we assume a struct.  A rule also
+         *  has multiple return values if you are building trees or templates.
+         */
+        public virtual bool getHasMultipleReturnValues()
+        {
+            return
+                referencedPredefinedRuleAttributes || grammar.BuildAST ||
+                grammar.BuildTemplate ||
+                ( returnScope != null && returnScope.attributes.Count > 1 );
+        }
+
+        public virtual bool getHasSingleReturnValue()
+        {
+            return
+                !( referencedPredefinedRuleAttributes || grammar.BuildAST ||
+                  grammar.BuildTemplate ) &&
+                                           ( returnScope != null && returnScope.attributes.Count == 1 );
+        }
+
+        public virtual bool getHasReturnValue()
+        {
+            return
+                referencedPredefinedRuleAttributes || grammar.BuildAST ||
+                grammar.BuildTemplate ||
+                ( returnScope != null && returnScope.attributes.Count > 0 );
+        }
+
+        public virtual string getSingleValueReturnType()
+        {
+            if ( returnScope != null && returnScope.attributes.Count == 1 )
+            {
+                return returnScope.attributes[0].Type;
+                //ICollection<Attribute> retvalAttrs = returnScope.attributes.Values;
+                //return retvalAttrs.First().Type;
+
+                //object[] javaSucks = retvalAttrs.toArray();
+                //return ( (Attribute)javaSucks[0] ).type;
+            }
+            return null;
+        }
+
+        public virtual string getSingleValueReturnName()
+        {
+            if ( returnScope != null && returnScope.attributes.Count == 1 )
+            {
+                return returnScope.attributes[0].Name;
+                //ICollection<Attribute> retvalAttrs = returnScope.attributes.Values;
+                //return retvalAttrs.First().Name;
+
+                //object[] javaSucks = retvalAttrs.toArray();
+                //return ( (Attribute)javaSucks[0] ).name;
+            }
+            return null;
+        }
+
+        /** Given @scope::name {action} define it for this grammar.  Later,
+         *  the code generator will ask for the actions table.
+         */
+        public virtual void defineNamedAction( GrammarAST ampersandAST,
+                                      GrammarAST nameAST,
+                                      GrammarAST actionAST )
+        {
+            //JSystem.@out.println("rule @"+nameAST.getText()+"{"+actionAST.getText()+"}");
+            string actionName = nameAST.Text;
+            GrammarAST a = (GrammarAST)actions.get( actionName );
+            if ( a != null )
+            {
+                ErrorManager.grammarError(
+                    ErrorManager.MSG_ACTION_REDEFINITION, grammar,
+                    nameAST.Token, nameAST.Text );
+            }
+            else
+            {
+                actions[actionName] = actionAST;
+            }
+        }
+
+        public virtual void trackInlineAction( GrammarAST actionAST )
+        {
+            inlineActions.Add( actionAST );
+        }
+
+        /** Save the option key/value pair and process it; return the key
+         *  or null if invalid option.
+         */
+        public virtual string setOption( string key, object value, IToken optionsStartToken )
+        {
+            if ( !legalOptions.Contains( key ) )
+            {
+                ErrorManager.grammarError( ErrorManager.MSG_ILLEGAL_OPTION,
+                                          grammar,
+                                          optionsStartToken,
+                                          key );
+                return null;
+            }
+            if ( options == null )
+            {
+                options = new Dictionary<object, object>();
+            }
+            if ( key.Equals( "memoize" ) && value.ToString().Equals( "true" ) )
+            {
+                grammar.atLeastOneRuleMemoizes = true;
+            }
+            if ( key == "backtrack" && value.ToString() == "true" )
+            {
+                grammar.composite.getRootGrammar().atLeastOneBacktrackOption = true;
+            }
+            if ( key.Equals( "k" ) )
+            {
+                grammar.numberOfManualLookaheadOptions++;
+            }
+            options[key] = value;
+            return key;
+        }
+
+        public virtual void setOptions( IDictionary<string, object> options, IToken optionsStartToken )
+        {
+            if ( options == null )
+            {
+                this.options = null;
+                return;
+            }
+            //Set keys = options.keySet();
+            //for ( Iterator it = keys.iterator(); it.hasNext(); )
+            //{
+            //    String optionName = (String)it.next();
+            //    object optionValue = options.get( optionName );
+            //    String stored = setOption( optionName, optionValue, optionsStartToken );
+            //    if ( stored == null )
+            //    {
+            //        it.remove();
+            //    }
+            //}
+            foreach ( string optionName in options.Keys.ToArray() )
+            {
+                object optionValue = options.get( optionName );
+                string stored = setOption( optionName, optionValue, optionsStartToken );
+                if ( stored == null )
+                    options.Remove( optionName );
+            }
+        }
+
+        /** Used during grammar imports to see if sets of rules intersect... This
+         *  method and hashCode use the String name as the key for Rule objects.
+        public boolean equals(Object other) {
+            return this.name.equals(((Rule)other).name);
+        }
+         */
+
+        /** Used during grammar imports to see if sets of rules intersect...
+        public int hashCode() {
+            return name.hashCode();
+        }
+         * */
+
+        public override string ToString()
+        { // used for testing
+            return "[" + grammar.name + "." + name + ",index=" + index + ",line=" + tree.Token.Line + "]";
+        }
+    }
+}
diff --git a/Antlr3/Tool/RuleLabelScope.cs b/Antlr3/Tool/RuleLabelScope.cs
new file mode 100644
index 0000000..433daa8
--- /dev/null
+++ b/Antlr3/Tool/RuleLabelScope.cs
@@ -0,0 +1,118 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using IToken = Antlr.Runtime.IToken;
+
+    public class RuleLabelScope : AttributeScope
+    {
+        /** Rules have a predefined set of attributes as well as
+         *  the return values.  'text' needs to be computed though so.
+         */
+        public static AttributeScope predefinedRulePropertiesScope;
+
+        public static AttributeScope predefinedTreeRulePropertiesScope;
+
+        public static AttributeScope predefinedLexerRulePropertiesScope;
+
+        public static AttributeScope[] grammarTypeToRulePropertiesScope;
+
+        static RuleLabelScope()
+        {
+            predefinedRulePropertiesScope = new AttributeScope( "RulePredefined", null );
+            predefinedRulePropertiesScope.addAttribute( "text", null );
+            predefinedRulePropertiesScope.addAttribute( "start", null );
+            predefinedRulePropertiesScope.addAttribute( "stop", null );
+            predefinedRulePropertiesScope.addAttribute( "tree", null );
+            predefinedRulePropertiesScope.addAttribute( "st", null );
+            predefinedRulePropertiesScope.isPredefinedRuleScope = true;
+
+            predefinedTreeRulePropertiesScope = new AttributeScope( "RulePredefined", null );
+            predefinedTreeRulePropertiesScope.addAttribute( "text", null );
+            predefinedTreeRulePropertiesScope.addAttribute( "start", null ); // note: no stop; not meaningful
+            predefinedTreeRulePropertiesScope.addAttribute( "tree", null );
+            predefinedTreeRulePropertiesScope.addAttribute( "st", null );
+            predefinedTreeRulePropertiesScope.isPredefinedRuleScope = true;
+
+            predefinedLexerRulePropertiesScope = new AttributeScope( "LexerRulePredefined", null );
+            predefinedLexerRulePropertiesScope.addAttribute( "text", null );
+            predefinedLexerRulePropertiesScope.addAttribute( "type", null );
+            predefinedLexerRulePropertiesScope.addAttribute( "line", null );
+            predefinedLexerRulePropertiesScope.addAttribute( "index", null );
+            predefinedLexerRulePropertiesScope.addAttribute( "pos", null );
+            predefinedLexerRulePropertiesScope.addAttribute( "channel", null );
+            predefinedLexerRulePropertiesScope.addAttribute( "start", null );
+            predefinedLexerRulePropertiesScope.addAttribute( "stop", null );
+            predefinedLexerRulePropertiesScope.addAttribute( "int", null );
+            predefinedLexerRulePropertiesScope.isPredefinedLexerRuleScope = true;
+
+            grammarTypeToRulePropertiesScope =
+                new AttributeScope[]
+                {
+                    null,
+                    predefinedLexerRulePropertiesScope, // LEXER
+                    predefinedRulePropertiesScope, // PARSER
+                    predefinedTreeRulePropertiesScope, // TREE PARSER
+                    predefinedRulePropertiesScope // COMBINED
+                };
+
+        }
+
+        public Rule referencedRule;
+
+        public RuleLabelScope( Rule referencedRule, IToken actionToken )
+            : base( "ref_" + referencedRule.name, actionToken )
+        {
+            this.referencedRule = referencedRule;
+        }
+
+        /** If you label a rule reference, you can access that rule's
+         *  return values as well as any predefined attributes.
+         */
+        public override Attribute getAttribute( string name )
+        {
+            AttributeScope rulePropertiesScope =
+                RuleLabelScope.grammarTypeToRulePropertiesScope[grammar.type];
+            if ( rulePropertiesScope.getAttribute( name ) != null )
+            {
+                return rulePropertiesScope.getAttribute( name );
+            }
+
+            if ( referencedRule.returnScope != null )
+            {
+                return referencedRule.returnScope.getAttribute( name );
+            }
+            return null;
+        }
+    }
+}
diff --git a/Antlr3/Tool/ToolMessage.cs b/Antlr3/Tool/ToolMessage.cs
new file mode 100644
index 0000000..18c4062
--- /dev/null
+++ b/Antlr3/Tool/ToolMessage.cs
@@ -0,0 +1,94 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using Antlr.Runtime.JavaExtensions;
+
+    using Exception = System.Exception;
+    using StringTemplate = Antlr3.ST.StringTemplate;
+
+    /** A generic message from the tool such as "file not found" type errors; there
+     *  is no reason to create a special object for each error unlike the grammar
+     *  errors, which may be rather complex.
+     *
+     *  Sometimes you need to pass in a filename or something to say it is "bad".
+     *  Allow a generic object to be passed in and the string template can deal
+     *  with just printing it or pulling a property out of it.
+     *
+     *  TODO what to do with exceptions?  Want stack trace for internal errors?
+     */
+    public class ToolMessage : Message
+    {
+
+        public ToolMessage( int msgID )
+            : base( msgID, null, null )
+        {
+        }
+        public ToolMessage( int msgID, object arg )
+            : base( msgID, arg, null )
+        {
+        }
+        public ToolMessage( int msgID, Exception e )
+            : base( msgID )
+        {
+            this.e = e;
+        }
+        public ToolMessage( int msgID, object arg, object arg2 )
+            : base( msgID, arg, arg2 )
+        {
+        }
+        public ToolMessage( int msgID, object arg, Exception e )
+            : base( msgID, arg, null )
+        {
+            this.e = e;
+        }
+        public override string ToString()
+        {
+            StringTemplate st = getMessageTemplate();
+            if ( arg != null )
+            {
+                st.setAttribute( "arg", arg );
+            }
+            if ( arg2 != null )
+            {
+                st.setAttribute( "arg2", arg2 );
+            }
+            if ( e != null )
+            {
+                st.setAttribute( "exception", e );
+                st.setAttribute( "stackTrace", e.getStackTrace() );
+            }
+            return base.ToString( st );
+        }
+    }
+}
diff --git a/AntlrTestConfig.testrunconfig b/AntlrTestConfig.testrunconfig
new file mode 100644
index 0000000..0c160c2
--- /dev/null
+++ b/AntlrTestConfig.testrunconfig
@@ -0,0 +1,20 @@
+﻿<?xml version="1.0" encoding="UTF-8"?>
+<TestRunConfiguration name="AntlrTestConfig" id="ffdb4029-8f84-4bbb-9829-cc1e67c5715e" xmlns="http://microsoft.com/schemas/VisualStudio/TeamTest/2006">
+  <Description>This is a default test run configuration for a local test run.</Description>
+  <Deployment>
+    <DeploymentItem filename="..\antlr\main\tool\src\main\resources\org\antlr\" />
+  </Deployment>
+  <TestTypeSpecific>
+    <WebTestRunConfiguration testTypeId="4e7599fa-5ecb-43e9-a887-cd63cf72d207">
+      <Browser name="Internet Explorer 7.0">
+        <Headers>
+          <Header name="User-Agent" value="Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)" />
+          <Header name="Accept" value="*/*" />
+          <Header name="Accept-Language" value="{{$IEAcceptLanguage}}" />
+          <Header name="Accept-Encoding" value="GZIP" />
+        </Headers>
+      </Browser>
+      <Network Name="LAN" BandwidthInKbps="0" />
+    </WebTestRunConfiguration>
+  </TestTypeSpecific>
+</TestRunConfiguration>
\ No newline at end of file

