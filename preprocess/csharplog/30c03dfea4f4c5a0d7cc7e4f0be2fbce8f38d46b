commit 30c03dfea4f4c5a0d7cc7e4f0be2fbce8f38d46b
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Fri Apr 10 20:25:41 2009 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Fri Apr 10 20:25:41 2009 -0800

C# Port:
* Code cleanup

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 6027]

diff --git a/Antlr3/Analysis/ActionLabel.cs b/Antlr3/Analysis/ActionLabel.cs
index 00d5baa..1effda9 100644
--- a/Antlr3/Analysis/ActionLabel.cs
+++ b/Antlr3/Analysis/ActionLabel.cs
@@ -37,12 +37,12 @@ namespace Antlr3.Analysis

public class ActionLabel : Label
{
-        public GrammarAST actionAST;
+        GrammarAST _actionAST;

-        public ActionLabel( GrammarAST actionAST ) :
-            base( ACTION )
+        public ActionLabel( GrammarAST actionAST )
+            : base( ACTION )
{
-            this.actionAST = actionAST;
+            _actionAST = actionAST;
}

public override bool IsEpsilon
@@ -64,7 +64,7 @@ namespace Antlr3.Analysis

public override string ToString()
{
-            return "{" + actionAST + "}";
+            return "{" + _actionAST + "}";
}

public override string ToString( Grammar g )
diff --git a/Antlr3/Analysis/AnalysisRecursionOverflowException.cs b/Antlr3/Analysis/AnalysisRecursionOverflowException.cs
index d34b4e5..967aa22 100644
--- a/Antlr3/Analysis/AnalysisRecursionOverflowException.cs
+++ b/Antlr3/Analysis/AnalysisRecursionOverflowException.cs
@@ -37,13 +37,13 @@ namespace Antlr3.Analysis
/** An NFA configuration context stack overflowed. */
public class AnalysisRecursionOverflowException : Exception
{
-        public DFAState ovfState;
-        public NFAConfiguration proposedNFAConfiguration;
+        DFAState _ovfState;
+        NFAConfiguration _proposedNFAConfiguration;

public AnalysisRecursionOverflowException( DFAState ovfState, NFAConfiguration proposedNFAConfiguration )
{
-            this.ovfState = ovfState;
-            this.proposedNFAConfiguration = proposedNFAConfiguration;
+            _ovfState = ovfState;
+            _proposedNFAConfiguration = proposedNFAConfiguration;
}
}
}
diff --git a/Antlr3/Analysis/AnalysisTimeoutException.cs b/Antlr3/Analysis/AnalysisTimeoutException.cs
index 9371b2d..0600915 100644
--- a/Antlr3/Analysis/AnalysisTimeoutException.cs
+++ b/Antlr3/Analysis/AnalysisTimeoutException.cs
@@ -37,11 +37,11 @@ namespace Antlr3.Analysis
/** Analysis took too long; bail out of entire DFA construction. */
public class AnalysisTimeoutException : Exception
{
-        public DFA abortedDFA;
+        DFA _abortedDFA;

public AnalysisTimeoutException( DFA abortedDFA )
{
-            this.abortedDFA = abortedDFA;
+            _abortedDFA = abortedDFA;
}
}
}
diff --git a/Antlr3/Analysis/DFA.cs b/Antlr3/Analysis/DFA.cs
index bb0e0f4..fd2711c 100644
--- a/Antlr3/Analysis/DFA.cs
+++ b/Antlr3/Analysis/DFA.cs
@@ -57,10 +57,12 @@ namespace Antlr3.Analysis
public const int REACHABLE_NO = 0;
public const int REACHABLE_YES = 1;

+#if false
/** Prevent explosion of DFA states during conversion. The max number
*  of states per alt in a single decision's DFA.
-        public const int MAX_STATES_PER_ALT_IN_DFA = 450;
*/
+        public const int MAX_STATES_PER_ALT_IN_DFA = 450;
+#endif

/** Set to 0 to not terminate early (time in ms) */
public static TimeSpan MAX_TIME_PER_DFA_CREATION = TimeSpan.FromSeconds( 1 );
@@ -77,19 +79,19 @@ namespace Antlr3.Analysis
public int decisionNumber = 0;

/** From what NFAState did we create the DFA? */
-        public NFAState decisionNFAStartState;
+        NFAState _decisionNFAStartState;

/** The printable grammar fragment associated with this DFA */
-        public String description;
+        string _description;

/** A set of all uniquely-numbered DFA states.  Maps hash of DFAState
*  to the actual DFAState object.  We use this to detect
-         *  existing DFA states.  Map<DFAState,DFAState>.  Use Map so
+         *  existing DFA states.  Map&lt;DFAState,DFAState&gt;.  Use Map so
*  we can get old state back (Set only allows you to see if it's there).
*  Not used during fixed k lookahead as it's a waste to fill it with
*  a dup of states array.
*/
-        protected IDictionary<DFAState, DFAState> uniqueStates = new Dictionary<DFAState, DFAState>();
+        IDictionary<DFAState, DFAState> _uniqueStates = new Dictionary<DFAState, DFAState>();

/** Maps the state number to the actual DFAState.  Use a Vector as it
*  grows automatically when I set the ith element.  This contains all
@@ -102,29 +104,29 @@ namespace Antlr3.Analysis
*  a way to go from state number to DFAState rather than via a
*  hash lookup.
*/
-        protected List<DFAState> states = new List<DFAState>();
+        List<DFAState> _states = new List<DFAState>();

/** Unique state numbers per DFA */
-        protected int stateCounter = 0;
+        int _stateCounter = 0;

/** count only new states not states that were rejected as already present */
-        protected int numberOfStates = 0;
+        int _numberOfStates = 0;

/** User specified max fixed lookahead.  If 0, nothing specified.  -1
*  implies we have not looked at the options table yet to set k.
*/
-        protected int user_k = -1;
+        int _userK = -1;

/** While building the DFA, track max lookahead depth if not cyclic */
-        protected internal int max_k = -1;
+        internal int max_k = -1;

/** Is this DFA reduced?  I.e., can all states lead to an accept state? */
-        protected bool reduced = true;
+        bool _reduced = true;

/** Are there any loops in this DFA?
*  Computed by doesStateReachAcceptState()
*/
-        protected bool cyclic = false;
+        bool _cyclic = false;

/** Track whether this DFA has at least one sem/syn pred encountered
*  during a closure operation.  This is useful for deciding whether
@@ -144,12 +146,12 @@ namespace Antlr3.Analysis
*  and then in method doesStateReachAcceptState() I remove the alts I
*  know to be uniquely predicted.
*/
-        protected List<int> unreachableAlts;
+        List<int> _unreachableAlts;

-        protected int nAlts = 0;
+        int _nAlts = 0;

/** We only want one accept state per predicted alt; track here */
-        protected DFAState[] altToAcceptState;
+        DFAState[] _altToAcceptState;

/** Track whether an alt discovers recursion for each alt during
*  NFA to DFA conversion; >1 alt with recursion implies nonregular.
@@ -159,7 +161,7 @@ namespace Antlr3.Analysis
/** Which NFA are we converting (well, which piece of the NFA)? */
public NFA nfa;

-        protected NFAToDFAConverter nfaConverter;
+        NFAToDFAConverter _nfaConverter;

/** This probe tells you a lot about a decision and is useful even
*  when there is no error such as when a syntactic nondeterminism
@@ -172,7 +174,7 @@ namespace Antlr3.Analysis
*  if it takes too long, then terminate.  Assume bugs are in the
*  analysis engine.
*/
-        protected internal DateTime conversionStartTime;
+        internal DateTime conversionStartTime;

/** Map an edge transition table to a unique set number; ordered so
*  we can push into the output template as an ordered list of sets
@@ -189,14 +191,14 @@ namespace Antlr3.Analysis
*     	  ...
*      };
*/
-        public IDictionary<int[], int?> edgeTransitionClassMap = new Dictionary<int[], int?>();
+        IDictionary<int[], int?> _edgeTransitionClassMap = new Dictionary<int[], int?>();

/** The unique edge transition class number; every time we see a new
*  set of edges emanating from a state, we number it so we can reuse
*  if it's every seen again for another state.  For Java grammar,
*  some of the big edge transition tables are seen about 57 times.
*/
-        protected int edgeTransitionClass = 0;
+        int _edgeTransitionClass = 0;

/* This DFA can be converted to a transition[state][char] table and
* the following tables are filled by createStateTables upon request.
@@ -208,25 +210,25 @@ namespace Antlr3.Analysis
*/

/** List of special DFAState objects */
-        public IList specialStates;
+        IList<DFAState> _specialStates;
/** List of ST for special states. */
-        public IList specialStateSTs;
-        public const int EmptyValue = -1;
-        public int[] accept;
-        public int[] eot;
-        public int[] eof;
-        public int[] min;
-        public int[] max;
-        public int[] special;
-        public int[][] transition;
-        /** just the Vector<Integer> indicating which unique edge table is at
+        IList<StringTemplate> _specialStateSTs;
+        const int EmptyValue = -1;
+        int[] _accept;
+        int[] _eot;
+        int[] _eof;
+        int[] _min;
+        int[] _max;
+        int[] _special;
+        int[][] _transition;
+        /** just the Vector&lt;Integer&gt; indicating which unique edge table is at
*  position i.
*/
-        public List<int?> transitionEdgeTables; // not used by java yet
-        protected int uniqueCompressedSpecialStateNum = 0;
+        List<int?> _transitionEdgeTables; // not used by java yet
+        int _uniqueCompressedSpecialStateNum = 0;

/** Which generator to use if we're building state tables */
-        protected CodeGenerator generator = null;
+        CodeGenerator _generator = null;

protected DFA()
{
@@ -237,17 +239,17 @@ namespace Antlr3.Analysis
: this()
{
this.decisionNumber = decisionNumber;
-            this.decisionNFAStartState = decisionStartState;
+            this._decisionNFAStartState = decisionStartState;
nfa = decisionStartState.nfa;
-            nAlts = nfa.grammar.getNumberOfAltsForDecisionNFA( decisionStartState );
+            _nAlts = nfa.grammar.getNumberOfAltsForDecisionNFA( decisionStartState );
//setOptions( nfa.grammar.getDecisionOptions(getDecisionNumber()) );
initAltRelatedInfo();

//long start = JSystem.currentTimeMillis();
-            nfaConverter = new NFAToDFAConverter( this );
+            _nfaConverter = new NFAToDFAConverter( this );
try
{
-                nfaConverter.convert();
+                _nfaConverter.convert();

// figure out if there are problems with decision
verify();
@@ -312,28 +314,28 @@ namespace Antlr3.Analysis
{
get
{
-                return decisionNFAStartState.associatedASTNode;
+                return _decisionNFAStartState.associatedASTNode;
}
}
public int DecisionNumber
{
get
{
-                return decisionNFAStartState.DecisionNumber;
+                return _decisionNFAStartState.DecisionNumber;
}
}
public string Description
{
get
{
-                return description;
+                return _description;
}
}
public bool IsCyclic
{
get
{
-                return cyclic && UserMaxLookahead == 0;
+                return _cyclic && UserMaxLookahead == 0;
}
}
public bool IsGreedy
@@ -347,7 +349,7 @@ namespace Antlr3.Analysis
{
get
{
-                return reduced;
+                return _reduced;
}
}
public bool IsTokensRuleDecision
@@ -372,21 +374,29 @@ namespace Antlr3.Analysis
{
get
{
-                return states.Count - 1;
+                return _states.Count - 1;
}
}
public NFAState NFADecisionStartState
{
get
{
-                return decisionNFAStartState;
+                return _decisionNFAStartState;
+            }
+            set
+            {
+                _decisionNFAStartState = value;
}
}
public int NumberOfAlts
{
get
{
-                return nAlts;
+                return _nAlts;
+            }
+            set
+            {
+                _nAlts = value;
}
}
public int NumberOfStates
@@ -396,9 +406,9 @@ namespace Antlr3.Analysis
if ( UserMaxLookahead > 0 )
{
// if using fixed lookahead then uniqueSets not set
-                    return states.Count;
+                    return _states.Count;
}
-                return numberOfStates;
+                return _numberOfStates;
}
}
public bool OkToRetryWithK1
@@ -415,18 +425,29 @@ namespace Antlr3.Analysis
return getReasonForFailure();
}
}
+        public IList<StringTemplate> SpecialStateSTs
+        {
+            get
+            {
+                return _specialStateSTs;
+            }
+        }
public IDictionary<DFAState, DFAState> UniqueStates
{
get
{
-                return uniqueStates;
+                return _uniqueStates;
}
}
-        public ICollection<int> UnreachableAlts
+        public List<int> UnreachableAlts
{
get
{
-                return unreachableAlts;
+                return _unreachableAlts;
+            }
+            set
+            {
+                _unreachableAlts = value;
}
}
public int UserMaxLookahead
@@ -489,7 +510,7 @@ namespace Antlr3.Analysis
if ( snum != NumberOfStates )
{
ErrorManager.internalError( "DFA " + decisionNumber + ": " +
-                    decisionNFAStartState.Description + " num unique states " + NumberOfStates +
+                    _decisionNFAStartState.Description + " num unique states " + NumberOfStates +
"!= num renumbered states " + snum );
}
}
@@ -500,39 +521,39 @@ namespace Antlr3.Analysis

public virtual List<string> getJavaCompressedAccept()
{
-            return getRunLengthEncoding( accept );
+            return getRunLengthEncoding( _accept );
}
public virtual List<string> getJavaCompressedEOT()
{
-            return getRunLengthEncoding( eot );
+            return getRunLengthEncoding( _eot );
}
public virtual List<string> getJavaCompressedEOF()
{
-            return getRunLengthEncoding( eof );
+            return getRunLengthEncoding( _eof );
}
public virtual List<string> getJavaCompressedMin()
{
-            return getRunLengthEncoding( min );
+            return getRunLengthEncoding( _min );
}
public virtual List<string> getJavaCompressedMax()
{
-            return getRunLengthEncoding( max );
+            return getRunLengthEncoding( _max );
}
public virtual List<string> getJavaCompressedSpecial()
{
-            return getRunLengthEncoding( special );
+            return getRunLengthEncoding( _special );
}
public virtual List<List<string>> getJavaCompressedTransition()
{
-            if ( transition == null || transition.Length == 0 )
+            if ( _transition == null || _transition.Length == 0 )
{
return null;
}
-            List<List<string>> encoded = new List<List<string>>( transition.Length );
+            List<List<string>> encoded = new List<List<string>>( _transition.Length );
// walk Vector<Vector<FormattedInteger>> which is the transition[][] table
-            for ( int i = 0; i < transition.Length; i++ )
+            for ( int i = 0; i < _transition.Length; i++ )
{
-                var transitionsForState = transition[i];
+                var transitionsForState = _transition[i];
encoded.Add( getRunLengthEncoding( transitionsForState ) );
}
return encoded;
@@ -588,8 +609,8 @@ namespace Antlr3.Analysis
break;
}
}
-                encoded.Add( generator.target.encodeIntAsCharEscape( (char)n ) );
-                encoded.Add( generator.target.encodeIntAsCharEscape( (char)(int)I ) );
+                encoded.Add( _generator.target.encodeIntAsCharEscape( (char)n ) );
+                encoded.Add( _generator.target.encodeIntAsCharEscape( (char)(int)I ) );
i += n;
}
return encoded;
@@ -598,42 +619,42 @@ namespace Antlr3.Analysis
public virtual void createStateTables( CodeGenerator generator )
{
//JSystem.@out.println("createTables:\n"+this);
-            this.generator = generator;
-            description = NFADecisionStartState.Description;
-            description =
-                generator.target.getTargetStringLiteralFromString( description );
+            this._generator = generator;
+            _description = NFADecisionStartState.Description;
+            _description =
+                generator.target.getTargetStringLiteralFromString( _description );

// create all the tables
//special = new List<int>( this.NumberOfStates ); // Vector<short>
//special.setSize( this.NumberOfStates );
-            special = Enumerable.Repeat( EmptyValue, NumberOfStates ).ToArray();
-            specialStates = new List<object>();				// List<DFAState>
-            specialStateSTs = new List<object>();				// List<ST>
+            _special = Enumerable.Repeat( EmptyValue, NumberOfStates ).ToArray();
+            _specialStates = new List<DFAState>();
+            _specialStateSTs = new List<StringTemplate>();
//accept = new List<int>( this.NumberOfStates ); // Vector<int>
//accept.setSize( this.NumberOfStates );
-            accept = Enumerable.Repeat( EmptyValue, NumberOfStates ).ToArray();
+            _accept = Enumerable.Repeat( EmptyValue, NumberOfStates ).ToArray();
//eot = new List<int>( this.NumberOfStates ); // Vector<int>
//eot.setSize( this.NumberOfStates );
-            eot = Enumerable.Repeat( EmptyValue, NumberOfStates ).ToArray();
+            _eot = Enumerable.Repeat( EmptyValue, NumberOfStates ).ToArray();
//eof = new List<int>( this.NumberOfStates ); // Vector<int>
//eof.setSize( this.NumberOfStates );
-            eof = Enumerable.Repeat( EmptyValue, NumberOfStates ).ToArray();
+            _eof = Enumerable.Repeat( EmptyValue, NumberOfStates ).ToArray();
//min = new List<int>( this.NumberOfStates ); // Vector<int>
//min.setSize( this.NumberOfStates );
-            min = Enumerable.Repeat( EmptyValue, NumberOfStates ).ToArray();
+            _min = Enumerable.Repeat( EmptyValue, NumberOfStates ).ToArray();
//max = new List<int>( this.NumberOfStates ); // Vector<int>
//max.setSize( this.NumberOfStates );
-            max = Enumerable.Repeat( EmptyValue, NumberOfStates ).ToArray();
-            transition = new int[NumberOfStates][]; // Vector<Vector<int>>
+            _max = Enumerable.Repeat( EmptyValue, NumberOfStates ).ToArray();
+            _transition = new int[NumberOfStates][]; // Vector<Vector<int>>
//transition.setSize( this.NumberOfStates );
-            transitionEdgeTables = new List<int?>( this.NumberOfStates ); // Vector<Vector<int>>
-            transitionEdgeTables.setSize( this.NumberOfStates );
+            _transitionEdgeTables = new List<int?>( this.NumberOfStates ); // Vector<Vector<int>>
+            _transitionEdgeTables.setSize( this.NumberOfStates );

// for each state in the DFA, fill relevant tables.
IEnumerable<DFAState> it = null;
if ( UserMaxLookahead > 0 )
{
-                it = states;
+                it = _states;
}
else
{
@@ -650,7 +671,7 @@ namespace Antlr3.Analysis
if ( s.IsAcceptState )
{
// can't compute min,max,special,transition on accepts
-                    accept[s.stateNumber] = s.getUniquelyPredictedAlt();
+                    _accept[s.stateNumber] = s.getUniquelyPredictedAlt();
}
else
{
@@ -662,12 +683,12 @@ namespace Antlr3.Analysis
}

// now that we have computed list of specialStates, gen code for 'em
-            for ( int i = 0; i < specialStates.Count; i++ )
+            for ( int i = 0; i < _specialStates.Count; i++ )
{
-                DFAState ss = (DFAState)specialStates[i];
+                DFAState ss = (DFAState)_specialStates[i];
StringTemplate stateST =
generator.generateSpecialState( ss );
-                specialStateSTs.Add( stateST );
+                _specialStateSTs.Add( stateST );
}

// check that the tables are not messed up by encode/decode
@@ -767,12 +788,12 @@ namespace Antlr3.Analysis
smax = Label.MIN_CHAR_VALUE;
}

-            min[s.stateNumber] = (char)smin;
-            max[s.stateNumber] = (char)smax;
+            _min[s.stateNumber] = (char)smin;
+            _max[s.stateNumber] = (char)smax;

if ( smax < 0 || smin > Label.MAX_CHAR_VALUE || smin < 0 )
{
-                ErrorManager.internalError( "messed up: min=" + min + ", max=" + max );
+                ErrorManager.internalError( "messed up: min=" + _min + ", max=" + _max );
}
}

@@ -782,14 +803,14 @@ namespace Antlr3.Analysis
JSystem.@out.println("createTransitionTableEntryForState s"+s.stateNumber+
" dec "+s.dfa.decisionNumber+" cyclic="+s.dfa.isCyclic());
*/
-            int smax = max[s.stateNumber];
-            int smin = min[s.stateNumber];
+            int smax = _max[s.stateNumber];
+            int smin = _min[s.stateNumber];

int[] stateTransitions = new int[smax - smin + 1];
for ( int i = 0; i < stateTransitions.Length; i++ )
stateTransitions[i] = EmptyValue;

-            transition[s.stateNumber] = stateTransitions;
+            _transition[s.stateNumber] = stateTransitions;
for ( int j = 0; j < s.NumberOfTransitions; j++ )
{
Transition edge = s.transition( j );
@@ -812,17 +833,17 @@ namespace Antlr3.Analysis
}
// track unique state transition tables so we can reuse
int? edgeClass; // = edgeTransitionClassMap.get( stateTransitions );
-            if ( edgeTransitionClassMap.TryGetValue( stateTransitions, out edgeClass ) && edgeClass != null )
+            if ( _edgeTransitionClassMap.TryGetValue( stateTransitions, out edgeClass ) && edgeClass != null )
{
//JSystem.@out.println("we've seen this array before; size="+stateTransitions.size());
-                transitionEdgeTables[s.stateNumber] = edgeClass;
+                _transitionEdgeTables[s.stateNumber] = edgeClass;
}
else
{
-                edgeClass = edgeTransitionClass;
-                transitionEdgeTables[s.stateNumber] = edgeClass;
-                edgeTransitionClassMap[stateTransitions] = edgeClass;
-                edgeTransitionClass++;
+                edgeClass = _edgeTransitionClass;
+                _transitionEdgeTables[s.stateNumber] = edgeClass;
+                _edgeTransitionClassMap[stateTransitions] = edgeClass;
+                _edgeTransitionClass++;
}
}

@@ -840,24 +861,24 @@ namespace Antlr3.Analysis
if ( label.Atom == Label.EOT )
{
// eot[s] points to accept state
-                        eot[s.stateNumber] = edge.target.stateNumber;
+                        _eot[s.stateNumber] = edge.target.stateNumber;
}
else if ( label.Atom == Label.EOF )
{
// eof[s] points to accept state
-                        eof[s.stateNumber] = edge.target.stateNumber;
+                        _eof[s.stateNumber] = edge.target.stateNumber;
}
}
else if ( label.IsSet )
{
if ( label.Set.member( Label.EOT ) )
{
-                        eot[s.stateNumber] = edge.target.stateNumber;
+                        _eot[s.stateNumber] = edge.target.stateNumber;
}

if ( label.Set.member( Label.EOF ) )
{
-                        eof[s.stateNumber] = edge.target.stateNumber;
+                        _eof[s.stateNumber] = edge.target.stateNumber;
}
}
}
@@ -883,17 +904,17 @@ namespace Antlr3.Analysis
}
}
// if has pred or too big for table, make it special
-            int smax = max[s.stateNumber];
-            int smin = min[s.stateNumber];
+            int smax = _max[s.stateNumber];
+            int smin = _min[s.stateNumber];
if ( hasSemPred || smax - smin > MAX_STATE_TRANSITIONS_FOR_TABLE )
{
-                special[s.stateNumber] = uniqueCompressedSpecialStateNum;
-                uniqueCompressedSpecialStateNum++;
-                specialStates.Add( s );
+                _special[s.stateNumber] = _uniqueCompressedSpecialStateNum;
+                _uniqueCompressedSpecialStateNum++;
+                _specialStates.Add( s );
}
else
{
-                special[s.stateNumber] = EmptyValue; // not special
+                _special[s.stateNumber] = EmptyValue; // not special
}
}

@@ -918,7 +939,7 @@ namespace Antlr3.Analysis
}
// does a DFA state exist already with everything the same
// except its state number?
-            DFAState existing = (DFAState)uniqueStates.get( d );
+            DFAState existing = (DFAState)_uniqueStates.get( d );
if ( existing != null )
{
/*
@@ -930,20 +951,20 @@ namespace Antlr3.Analysis
}

// if not there, then add new state.
-            uniqueStates[d] = d;
-            numberOfStates++;
+            _uniqueStates[d] = d;
+            _numberOfStates++;
return d;
}

public void removeState( DFAState d )
{
DFAState it;
-            if ( uniqueStates.TryGetValue( d, out it ) )
+            if ( _uniqueStates.TryGetValue( d, out it ) )
{
-                uniqueStates.Remove( d );
+                _uniqueStates.Remove( d );
if ( it != null )
{
-                    numberOfStates--;
+                    _numberOfStates--;
}
}
}
@@ -965,12 +986,12 @@ namespace Antlr3.Analysis

public virtual DFAState getState( int stateNumber )
{
-            return (DFAState)states[stateNumber];
+            return (DFAState)_states[stateNumber];
}

public virtual void setState( int stateNumber, DFAState d )
{
-            states[stateNumber] = d;
+            _states[stateNumber] = d;
}

/** Is the DFA reduced?  I.e., does every state have a path to an accept
@@ -1023,12 +1044,12 @@ namespace Antlr3.Analysis
*/
public virtual int getUserMaxLookahead()
{
-            if ( user_k >= 0 )
+            if ( _userK >= 0 )
{ // cache for speed
-                return user_k;
+                return _userK;
}
-            user_k = nfa.grammar.getUserMaxLookahead( decisionNumber );
-            return user_k;
+            _userK = nfa.grammar.getUserMaxLookahead( decisionNumber );
+            return _userK;
}

public virtual bool getAutoBacktrackMode()
@@ -1038,7 +1059,7 @@ namespace Antlr3.Analysis

public virtual void setUserMaxLookahead( int k )
{
-            this.user_k = k;
+            this._userK = k;
}

/** Return k if decision is LL(k) for some k else return max int */
@@ -1096,7 +1117,7 @@ namespace Antlr3.Analysis
d.AcceptStateReachable = REACHABLE_YES;
// this alt is uniquely predicted, remove from nondeterministic list
int predicts = d.getUniquelyPredictedAlt();
-                unreachableAlts.Remove( predicts );
+                _unreachableAlts.Remove( predicts );
return true;
}

@@ -1114,7 +1135,7 @@ namespace Antlr3.Analysis
int targetStatus = edgeTarget.AcceptStateReachable;
if ( targetStatus == REACHABLE_BUSY )
{ // avoid cycles; they say nothing
-                    cyclic = true;
+                    _cyclic = true;
continue;
}
if ( targetStatus == REACHABLE_YES )
@@ -1141,7 +1162,7 @@ namespace Antlr3.Analysis
else
{
d.AcceptStateReachable = REACHABLE_NO;
-                reduced = false;
+                _reduced = false;
}
return anEdgeReachesAcceptState;
}
@@ -1184,12 +1205,12 @@ namespace Antlr3.Analysis

public virtual DFAState getAcceptState( int alt )
{
-            return altToAcceptState[alt];
+            return _altToAcceptState[alt];
}

public virtual void setAcceptState( int alt, DFAState acceptState )
{
-            altToAcceptState[alt] = acceptState;
+            _altToAcceptState[alt] = acceptState;
}

[Obsolete]
@@ -1278,10 +1299,10 @@ namespace Antlr3.Analysis
public virtual DFAState newState()
{
DFAState n = new DFAState( this );
-            n.stateNumber = stateCounter;
-            stateCounter++;
-            states.setSize( n.stateNumber + 1 );
-            states[n.stateNumber] = n; // track state num to state
+            n.stateNumber = _stateCounter;
+            _stateCounter++;
+            _states.setSize( n.stateNumber + 1 );
+            _states[n.stateNumber] = n; // track state num to state
return n;
}

@@ -1305,12 +1326,12 @@ namespace Antlr3.Analysis

protected virtual void initAltRelatedInfo()
{
-            unreachableAlts = new List<int>();
-            for ( int i = 1; i <= nAlts; i++ )
+            _unreachableAlts = new List<int>();
+            for ( int i = 1; i <= _nAlts; i++ )
{
-                unreachableAlts.Add( i );
+                _unreachableAlts.Add( i );
}
-            altToAcceptState = new DFAState[nAlts + 1];
+            _altToAcceptState = new DFAState[_nAlts + 1];
}

public override string ToString()
diff --git a/Antlr3/Analysis/DFAOptimizer.cs b/Antlr3/Analysis/DFAOptimizer.cs
index 1ea5cea..2f7eb57 100644
--- a/Antlr3/Analysis/DFAOptimizer.cs
+++ b/Antlr3/Analysis/DFAOptimizer.cs
@@ -129,23 +129,23 @@ namespace Antlr3.Analysis
*  This is a side-effect of calling optimize; can't clear after use
*  because code gen needs it.
*/
-        protected HashSet<object> visited = new HashSet<object>();
+        HashSet<object> _visited = new HashSet<object>();

-        protected Grammar grammar;
+        Grammar _grammar;

public DFAOptimizer( Grammar grammar )
{
-            this.grammar = grammar;
+            this._grammar = grammar;
}

public virtual void optimize()
{
// optimize each DFA in this grammar
for ( int decisionNumber = 1;
-                 decisionNumber <= grammar.NumberOfDecisions;
+                 decisionNumber <= _grammar.NumberOfDecisions;
decisionNumber++ )
{
-                DFA dfa = grammar.getLookaheadDFA( decisionNumber );
+                DFA dfa = _grammar.getLookaheadDFA( decisionNumber );
optimize( dfa );
}
}
@@ -163,7 +163,7 @@ namespace Antlr3.Analysis
//long start = JSystem.currentTimeMillis();
if ( PRUNE_EBNF_EXIT_BRANCHES && dfa.CanInlineDecision )
{
-                visited.Clear();
+                _visited.Clear();
int decisionType =
dfa.NFADecisionStartState.decisionStateType;
if ( dfa.IsGreedy &&
@@ -178,7 +178,7 @@ namespace Antlr3.Analysis
dfa.IsTokensRuleDecision &&
dfa.probe.stateToSyntacticallyAmbiguousTokensRuleAltsMap.Count > 0 )
{
-                visited.Clear();
+                _visited.Clear();
optimizeEOTBranches( dfa.startState );
}

@@ -193,11 +193,11 @@ namespace Antlr3.Analysis
protected virtual void optimizeExitBranches( DFAState d )
{
int sI = d.stateNumber;
-            if ( visited.Contains( sI ) )
+            if ( _visited.Contains( sI ) )
{
return; // already visited
}
-            visited.Add( sI );
+            _visited.Add( sI );
int nAlts = d.dfa.NumberOfAlts;
for ( int i = 0; i < d.NumberOfTransitions; i++ )
{
@@ -226,11 +226,11 @@ namespace Antlr3.Analysis
protected virtual void optimizeEOTBranches( DFAState d )
{
int sI = d.stateNumber;
-            if ( visited.Contains( sI ) )
+            if ( _visited.Contains( sI ) )
{
return; // already visited
}
-            visited.Add( sI );
+            _visited.Add( sI );
for ( int i = 0; i < d.NumberOfTransitions; i++ )
{
Transition edge = (Transition)d.transition( i );
diff --git a/Antlr3/Analysis/DFAState.cs b/Antlr3/Analysis/DFAState.cs
index bef518e..b7f6461 100644
--- a/Antlr3/Analysis/DFAState.cs
+++ b/Antlr3/Analysis/DFAState.cs
@@ -81,7 +81,7 @@ namespace Antlr3.Analysis
/** Track the transitions emanating from this DFA state.  The List
*  elements are Transition objects.
*/
-        protected IList<Transition> transitions =
+        IList<Transition> _transitions =
new List<Transition>( INITIAL_NUM_TRANSITIONS );

/** When doing an acyclic DFA, this is the number of lookahead symbols
@@ -89,7 +89,7 @@ namespace Antlr3.Analysis
*  dfa states, but it is only a valid value if the user has specified
*  a max fixed lookahead.
*/
-        protected internal int k;
+        int _k;

/** The NFA->DFA algorithm may terminate leaving some states
*  without a path to an accept state, implying that upon certain
@@ -97,14 +97,14 @@ namespace Antlr3.Analysis
*  predicting a unique alternative can be made.  Recall that an
*  accept state is one in which a unique alternative is predicted.
*/
-        protected int acceptStateReachable = DFA.REACHABLE_UNKNOWN;
+        int _acceptStateReachable = DFA.REACHABLE_UNKNOWN;

/** Rather than recheck every NFA configuration in a DFA state (after
*  resolving) in findNewDFAStatesAndAddDFATransitions just check
*  this boolean.  Saves a linear walk perhaps DFA state creation.
*  Every little bit helps.
*/
-        protected internal bool resolvedWithPredicates = false;
+        bool _resolvedWithPredicates = false;

/** If a closure operation finds that we tried to invoke the same
*  rule too many times (stack would grow beyond a threshold), it
@@ -128,18 +128,18 @@ namespace Antlr3.Analysis
*  now and we simply report the problem.  If synpreds exist, I'll retry
*  with k=1.
*/
-        protected internal bool abortedDueToMultipleRecursiveAlts = false;
+        internal bool abortedDueToMultipleRecursiveAlts = false;

/** Build up the hash code for this state as NFA configurations
*  are added as it's monotonically increasing list of configurations.
*/
-        protected int cachedHashCode;
+        int _cachedHashCode;

-        protected internal int cachedUniquelyPredicatedAlt = PREDICTED_ALT_UNSET;
+        internal int cachedUniquelyPredicatedAlt = PREDICTED_ALT_UNSET;

public int minAltInConfigurations = int.MaxValue;

-        public bool atLeastOneConfigurationHasAPredicate = false;
+        bool _atLeastOneConfigurationHasAPredicate = false;

/** The set of NFA configurations (state,alt,context) for this DFA state */
public OrderedHashSet<NFAConfiguration> nfaConfigurations =
@@ -157,7 +157,7 @@ namespace Antlr3.Analysis
*  Two configurations identical including semantic context are
*  considered the same closure computation.  @see NFAToDFAConverter.closureBusy().
*/
-        protected internal HashSet<NFAConfiguration> closureBusy = new HashSet<NFAConfiguration>();
+        internal HashSet<NFAConfiguration> closureBusy = new HashSet<NFAConfiguration>();

/** As this state is constructed (i.e., as NFA states are added), we
*  can easily check for non-epsilon transitions because the only
@@ -167,7 +167,7 @@ namespace Antlr3.Analysis
*  times size(nfa states), which can be pretty damn big.  It's better
*  to simply track possible labels.
*/
-        protected OrderedHashSet<Label> reachableLabels;
+        OrderedHashSet<Label> _reachableLabels;

public DFAState( DFA dfa )
{
@@ -179,11 +179,11 @@ namespace Antlr3.Analysis
{
get
{
-                return acceptStateReachable;
+                return _acceptStateReachable;
}
set
{
-                acceptStateReachable = value;
+                _acceptStateReachable = value;
}
}
public ICollection<int> AltSet
@@ -204,18 +204,22 @@ namespace Antlr3.Analysis
{
get
{
-                return resolvedWithPredicates;
+                return _resolvedWithPredicates;
+            }
+            set
+            {
+                _resolvedWithPredicates = value;
}
}
public int LookaheadDepth
{
get
{
-                return k;
+                return _k;
}
set
{
-                k = value;
+                _k = value;
if ( value > dfa.max_k )
{
// track max k for entire DFA
@@ -237,25 +241,25 @@ namespace Antlr3.Analysis
//nfaConfigurations = null; // getGatedPredicatesInNFAConfigurations needs
configurationsWithLabeledEdges = null;
closureBusy = null;
-            reachableLabels = null;
+            _reachableLabels = null;
}

public virtual Transition transition( int i )
{
-            return (Transition)transitions[i];
+            return (Transition)_transitions[i];
}

public override int NumberOfTransitions
{
get
{
-                return transitions.Count;
+                return _transitions.Count;
}
}

public override void addTransition( Transition t )
{
-            transitions.Add( t );
+            _transitions.Add( t );
}

/** Add a transition from this state to target with label.  Return
@@ -263,18 +267,18 @@ namespace Antlr3.Analysis
*/
public virtual int addTransition( DFAState target, Label label )
{
-            transitions.Add( new Transition( label, target ) );
-            return transitions.Count - 1;
+            _transitions.Add( new Transition( label, target ) );
+            return _transitions.Count - 1;
}

public override Transition getTransition( int trans )
{
-            return transitions[trans];
+            return _transitions[trans];
}

public virtual void removeTransition( int trans )
{
-            transitions.RemoveAt( trans );
+            _transitions.RemoveAt( trans );
}

/** Add an NFA configuration to this DFA node.  Add uniquely
@@ -311,12 +315,12 @@ namespace Antlr3.Analysis

if ( c.semanticContext != SemanticContext.EmptySemanticContext )
{
-                atLeastOneConfigurationHasAPredicate = true;
+                _atLeastOneConfigurationHasAPredicate = true;
}

// update hashCode; for some reason using context.hashCode() also
// makes the GC take like 70% of the CPU and is slow!
-            cachedHashCode += c.state + c.alt;
+            _cachedHashCode += c.state + c.alt;

// update reachableLabels
// We're adding an NFA state; check to see if it has a non-epsilon edge
@@ -387,27 +391,27 @@ namespace Antlr3.Analysis
*/
protected virtual void addReachableLabel( Label label )
{
-            if ( reachableLabels == null )
+            if ( _reachableLabels == null )
{
-                reachableLabels = new OrderedHashSet<Label>();
+                _reachableLabels = new OrderedHashSet<Label>();
}
/*
JSystem.@out.println("addReachableLabel to state "+dfa.decisionNumber+"."+stateNumber+": "+label.getSet().toString(dfa.nfa.grammar));
JSystem.@out.println("start of add to state "+dfa.decisionNumber+"."+stateNumber+": " +
"reachableLabels="+reachableLabels.toString());
*/
-            if ( reachableLabels.Contains( label ) )
+            if ( _reachableLabels.Contains( label ) )
{
// exact label present
return;
}
IIntSet t = label.Set;
IIntSet remainder = t; // remainder starts out as whole set to add
-            int n = reachableLabels.size(); // only look at initial elements
+            int n = _reachableLabels.size(); // only look at initial elements
// walk the existing list looking for the collision
for ( int i = 0; i < n; i++ )
{
-                Label rl = reachableLabels.get( i );
+                Label rl = _reachableLabels.get( i );
/*
JSystem.@out.println("comparing ["+i+"]: "+label.toString(dfa.nfa.grammar)+" & "+
rl.toString(dfa.nfa.grammar)+"="+
@@ -426,7 +430,7 @@ namespace Antlr3.Analysis
// know that will always be a non nil character class
IIntSet s_i = rl.Set;
IIntSet intersection = s_i.and( t );
-                reachableLabels.set( i, new Label( intersection ) );
+                _reachableLabels.set( i, new Label( intersection ) );

// Compute s_i-t to see what is in current set and not in incoming
IIntSet existingMinusNewElements = s_i.subtract( t );
@@ -436,7 +440,7 @@ namespace Antlr3.Analysis
// found a new character class, add to the end (doesn't affect
// outer loop duration due to n computation a priori.
Label newLabel = new Label( existingMinusNewElements );
-                    reachableLabels.add( newLabel );
+                    _reachableLabels.add( newLabel );
}

/*
@@ -461,7 +465,7 @@ namespace Antlr3.Analysis
JSystem.@out.println("remainder state "+dfa.decisionNumber+"."+stateNumber+": "+remainder.toString(dfa.nfa.grammar));
*/
Label newLabel = new Label( remainder );
-                reachableLabels.add( newLabel );
+                _reachableLabels.add( newLabel );
}
/*
JSystem.@out.println("#END of add to state "+dfa.decisionNumber+"."+stateNumber+": " +
@@ -471,7 +475,7 @@ namespace Antlr3.Analysis

public virtual OrderedHashSet<Label> getReachableLabels()
{
-            return reachableLabels;
+            return _reachableLabels;
}

public virtual void setNFAConfigurations( OrderedHashSet<NFAConfiguration> configs )
@@ -485,13 +489,13 @@ namespace Antlr3.Analysis
*/
public override int GetHashCode()
{
-            if ( cachedHashCode == 0 )
+            if ( _cachedHashCode == 0 )
{
// LL(1) algorithm doesn't use NFA configurations, which
// dynamically compute hashcode; must have something; use super
return base.GetHashCode();
}
-            return cachedHashCode;
+            return _cachedHashCode;
}

/** Two DFAStates are equal if their NFA configuration sets are the
@@ -613,7 +617,7 @@ namespace Antlr3.Analysis
protected internal virtual HashSet<int> getNonDeterministicAlts()
{
int user_k = dfa.UserMaxLookahead;
-            if ( user_k > 0 && user_k == k )
+            if ( user_k > 0 && user_k == _k )
{
// if fixed lookahead, then more than 1 alt is a nondeterminism
// if we have hit the max lookahead
@@ -705,7 +709,7 @@ namespace Antlr3.Analysis
// meaning input "ab" would test preds to decide what to
// do but it should match rule C w/o testing preds.
if ( dfa.nfa.grammar.type != Grammar.LEXER ||
-                             !dfa.decisionNFAStartState.enclosingRule.name.Equals( Grammar.ARTIFICIAL_TOKENS_RULENAME ) )
+                             !dfa.NFADecisionStartState.enclosingRule.name.Equals( Grammar.ARTIFICIAL_TOKENS_RULENAME ) )
{
numPotentialConflicts++;
thisStateHasPotentialProblem = true;
diff --git a/Antlr3/Analysis/DecisionProbe.cs b/Antlr3/Analysis/DecisionProbe.cs
index cf6d026..f11aaf0 100644
--- a/Antlr3/Analysis/DecisionProbe.cs
+++ b/Antlr3/Analysis/DecisionProbe.cs
@@ -79,7 +79,7 @@ namespace Antlr3.Analysis
*/
public class DecisionProbe
{
-        public DFA dfa;
+        internal DFA dfa;

/** Track all DFA states with nondeterministic alternatives.
*  By reaching the same DFA state, a path through the NFA for some input
@@ -89,75 +89,77 @@ namespace Antlr3.Analysis
*  Note that from the DFA state, you can ask for
*  which alts are nondeterministic.
*/
-        protected ICollection<DFAState> statesWithSyntacticallyAmbiguousAltsSet = new HashSet<DFAState>();
+        ICollection<DFAState> _statesWithSyntacticallyAmbiguousAltsSet = new HashSet<DFAState>();

/** Track just like stateToSyntacticallyAmbiguousAltsMap, but only
*  for nondeterminisms that arise in the Tokens rule such as keyword vs
*  ID rule.  The state maps to the list of Tokens rule alts that are
*  in conflict.
*/
-        protected internal IDictionary<DFAState, ICollection<int>> stateToSyntacticallyAmbiguousTokensRuleAltsMap =
+        internal IDictionary<DFAState, ICollection<int>> stateToSyntacticallyAmbiguousTokensRuleAltsMap =
new Dictionary<DFAState, ICollection<int>>();

/** Was a syntactic ambiguity resolved with predicates?  Any DFA
*  state that predicts more than one alternative, must be resolved
*  with predicates or it should be reported to the user.
*/
-        protected ICollection<DFAState> statesResolvedWithSemanticPredicatesSet = new HashSet<DFAState>();
+        ICollection<DFAState> _statesResolvedWithSemanticPredicatesSet = new HashSet<DFAState>();

/** Track the predicates for each alt per DFA state;
*  more than one DFA state might have syntactically ambig alt prediction.
*  Maps DFA state to another map, mapping alt number to a
*  SemanticContext (pred(s) to execute to resolve syntactic ambiguity).
*/
-        protected IDictionary<DFAState, IDictionary<int, SemanticContext>> stateToAltSetWithSemanticPredicatesMap =
+        IDictionary<DFAState, IDictionary<int, SemanticContext>> _stateToAltSetWithSemanticPredicatesMap =
new Dictionary<DFAState, IDictionary<int, SemanticContext>>();

/** Tracks alts insufficiently covered.
*  For example, p1||true gets reduced to true and so leaves
*  whole alt uncovered.  This maps DFA state to the set of alts
*/
-        protected IDictionary<DFAState, IDictionary<int, ICollection<IToken>>> stateToIncompletelyCoveredAltsMap =
+        IDictionary<DFAState, IDictionary<int, ICollection<IToken>>> _stateToIncompletelyCoveredAltsMap =
new Dictionary<DFAState, IDictionary<int, ICollection<IToken>>>();

/** The set of states w/o emanating edges and w/o resolving sem preds. */
-        protected ICollection<DFAState> danglingStates = new HashSet<DFAState>();
+        ICollection<DFAState> _danglingStates = new HashSet<DFAState>();

/** The overall list of alts within the decision that have at least one
*  conflicting input sequence.
*/
-        protected ICollection<int> altsWithProblem = new HashSet<int>();
+        ICollection<int> _altsWithProblem = new HashSet<int>();

/** If decision with > 1 alt has recursion in > 1 alt, it's nonregular
*  lookahead.  The decision cannot be made with a DFA.
*  the alts are stored in altsWithProblem.
*/
-        protected bool nonLLStarDecision = false;
+        bool _nonLLStarDecision = false;

/** Recursion is limited to a particular depth.  If that limit is exceeded
*  the proposed new NFAConfiguration is recorded for the associated DFA state.
*/
-        protected MultiMap<int, NFAConfiguration> stateToRecursionOverflowConfigurationsMap =
+        MultiMap<int, NFAConfiguration> _stateToRecursionOverflowConfigurationsMap =
new MultiMap<int, NFAConfiguration>();

-        /*
-	protected Map<Integer, List<NFAConfiguration>> stateToRecursionOverflowConfigurationsMap =
-		new HashMap<Integer, List<NFAConfiguration>>();
-		*/
+#if false
+        protected IDictionary<int, List<NFAConfiguration>> stateToRecursionOverflowConfigurationsMap =
+            new Dictionary<int, List<NFAConfiguration>>();
+#endif

+#if false
/** Left recursion discovered.  The proposed new NFAConfiguration
*  is recorded for the associated DFA state.
-        protected Map<Integer,List<NFAConfiguration>> stateToLeftRecursiveConfigurationsMap =
-            new HashMap<Integer,List<NFAConfiguration>>();
*/
+        protected IDictionary<int, List<NFAConfiguration>> stateToLeftRecursiveConfigurationsMap =
+            new Dictionary<int, List<NFAConfiguration>>();
+#endif

/** Did ANTLR have to terminate early on the analysis of this decision? */
-        protected bool timedOut = false;
+        bool _timedOut = false;

/** Used to find paths through syntactically ambiguous DFA. If we've
*  seen statement number before, what did we learn?
*/
-        protected IDictionary<int, int> stateReachable;
+        IDictionary<int, int> _stateReachable;

public const int REACHABLE_BUSY = -1;
public const int REACHABLE_NO = 0;
@@ -170,9 +172,9 @@ namespace Antlr3.Analysis
*  infinite loop.  Stop.  Set<String>.  The strings look like
*  stateNumber_labelIndex.
*/
-        protected ICollection<string> statesVisitedAtInputDepth;
+        ICollection<string> _statesVisitedAtInputDepth;

-        protected ICollection<int> statesVisitedDuringSampleSequence;
+        ICollection<int> _statesVisitedDuringSampleSequence;

public static bool verbose = false;

@@ -186,21 +188,21 @@ namespace Antlr3.Analysis
{
get
{
-                return stateToRecursionOverflowConfigurationsMap.Count > 0;
+                return _stateToRecursionOverflowConfigurationsMap.Count > 0;
}
}
public bool AnalysisTimedOut
{
get
{
-                return timedOut;
+                return _timedOut;
}
}
public ICollection<DFAState> DanglingStates
{
get
{
-                return danglingStates;
+                return _danglingStates;
}
}
public string Description
@@ -214,14 +216,14 @@ namespace Antlr3.Analysis
{
get
{
-                return statesWithSyntacticallyAmbiguousAltsSet;
+                return _statesWithSyntacticallyAmbiguousAltsSet;
}
}
public bool HasPredicate
{
get
{
-                return stateToAltSetWithSemanticPredicatesMap.Count > 0;
+                return _stateToAltSetWithSemanticPredicatesMap.Count > 0;
}
}
public bool IsCyclic
@@ -242,7 +244,7 @@ namespace Antlr3.Analysis
{
get
{
-                return nonLLStarDecision;
+                return _nonLLStarDecision;
}
}
public bool IsReduced
@@ -256,14 +258,14 @@ namespace Antlr3.Analysis
{
get
{
-                return altsWithProblem;
+                return _altsWithProblem;
}
}
public ICollection<DFAState> NondeterministicStatesResolvedWithSemanticPredicate
{
get
{
-                return statesResolvedWithSemanticPredicatesSet;
+                return _statesResolvedWithSemanticPredicatesSet;
}
}
public int NumberOfStates
@@ -310,17 +312,17 @@ namespace Antlr3.Analysis
*/
public virtual bool isDeterministic()
{
-            if ( danglingStates.Count == 0 &&
-                 statesWithSyntacticallyAmbiguousAltsSet.Count == 0 &&
+            if ( _danglingStates.Count == 0 &&
+                 _statesWithSyntacticallyAmbiguousAltsSet.Count == 0 &&
dfa.UnreachableAlts.Count == 0 )
{
return true;
}

-            if ( statesWithSyntacticallyAmbiguousAltsSet.Count > 0 )
+            if ( _statesWithSyntacticallyAmbiguousAltsSet.Count > 0 )
{
-                return statesWithSyntacticallyAmbiguousAltsSet
-                    .Except( statesResolvedWithSemanticPredicatesSet )
+                return _statesWithSyntacticallyAmbiguousAltsSet
+                    .Except( _statesResolvedWithSemanticPredicatesSet )
.Take( 1 )
.Count() == 0;
}
@@ -448,7 +450,7 @@ namespace Antlr3.Analysis
*/
public virtual void removeRecursiveOverflowState( DFAState d )
{
-            stateToRecursionOverflowConfigurationsMap.Remove( d.stateNumber );
+            _stateToRecursionOverflowConfigurationsMap.Remove( d.stateNumber );
}

/** Return a IList<Label> indicating an input sequence that can be matched
@@ -458,7 +460,7 @@ namespace Antlr3.Analysis
public virtual IList<Label> getSampleNonDeterministicInputSequence( DFAState targetState )
{
HashSet<object> dfaStates = getDFAPathStatesToTarget( targetState );
-            statesVisitedDuringSampleSequence = new HashSet<int>();
+            _statesVisitedDuringSampleSequence = new HashSet<int>();
IList<Label> labels = new List<Label>(); // may access ith element; use array
if ( dfa == null || dfa.startState == null )
{
@@ -542,7 +544,7 @@ namespace Antlr3.Analysis
path.Add( isolatedAltStart );

// add the actual path now
-            statesVisitedAtInputDepth = new HashSet<string>();
+            _statesVisitedAtInputDepth = new HashSet<string>();
getNFAPath( isolatedAltStart,
0,
labels,
@@ -556,7 +558,7 @@ namespace Antlr3.Analysis
*/
public virtual SemanticContext getSemanticContextForAlt( DFAState d, int alt )
{
-            var altToPredMap = stateToAltSetWithSemanticPredicatesMap.get( d );
+            var altToPredMap = _stateToAltSetWithSemanticPredicatesMap.get( d );
if ( altToPredMap == null )
{
return null;
@@ -582,7 +584,7 @@ namespace Antlr3.Analysis
*/
public virtual IDictionary<int, ICollection<IToken>> getIncompletelyCoveredAlts( DFAState d )
{
-            return stateToIncompletelyCoveredAltsMap.get( d );
+            return _stateToIncompletelyCoveredAltsMap.get( d );
}

public virtual void issueWarnings()
@@ -590,7 +592,7 @@ namespace Antlr3.Analysis
// NONREGULAR DUE TO RECURSION > 1 ALTS
// Issue this before aborted analysis, which might also occur
// if we take too long to terminate
-            if ( nonLLStarDecision && !dfa.AutoBacktrackMode )
+            if ( _nonLLStarDecision && !dfa.AutoBacktrackMode )
{
ErrorManager.nonLLStarDecision( this );
}
@@ -648,7 +650,7 @@ namespace Antlr3.Analysis
}
}

-            if ( !nonLLStarDecision )
+            if ( !_nonLLStarDecision )
{
var unreachableAlts = dfa.UnreachableAlts;
if ( unreachableAlts != null && unreachableAlts.Count > 0 )
@@ -727,7 +729,7 @@ namespace Antlr3.Analysis
{
// RECURSION OVERFLOW
ICollection<int> dfaStatesWithRecursionProblems =
-                stateToRecursionOverflowConfigurationsMap.Keys;
+                _stateToRecursionOverflowConfigurationsMap.Keys;
// now walk truly unique (unaliased) list of dfa states with inf recur
// Goal: create a map from alt to map<target,IList<callsites>>
// Map<Map<String target, IList<NFAState call sites>>
@@ -736,7 +738,7 @@ namespace Antlr3.Analysis
// track a single problem DFA state for each alt
var altToDFAState = new Dictionary<int, DFAState>();
computeAltToProblemMaps( dfaStatesWithRecursionProblems,
-                                    stateToRecursionOverflowConfigurationsMap,
+                                    _stateToRecursionOverflowConfigurationsMap,
altToTargetToCallSitesMap, // output param
altToDFAState );            // output param

@@ -821,12 +823,12 @@ namespace Antlr3.Analysis
*/
public virtual void reportDanglingState( DFAState d )
{
-            danglingStates.Add( d );
+            _danglingStates.Add( d );
}

public virtual void reportAnalysisTimeout()
{
-            timedOut = true;
+            _timedOut = true;
dfa.nfa.grammar.setOfDFAWhoseAnalysisTimedOut.Add( dfa );
}

@@ -839,8 +841,8 @@ namespace Antlr3.Analysis
JSystem.@out.println("non-LL(*) DFA "+dfa.decisionNumber+", alts: "+
dfa.recursiveAltSet.toList());
*/
-            nonLLStarDecision = true;
-            altsWithProblem.addAll( dfa.recursiveAltSet.ToList() );
+            _nonLLStarDecision = true;
+            _altsWithProblem.addAll( dfa.recursiveAltSet.ToList() );
}

public virtual void reportRecursionOverflow( DFAState d,
@@ -856,14 +858,14 @@ namespace Antlr3.Analysis
if ( d.stateNumber > 0 )
{
int stateI = d.stateNumber;
-                stateToRecursionOverflowConfigurationsMap.map( stateI, recursionNFAConfiguration );
+                _stateToRecursionOverflowConfigurationsMap.map( stateI, recursionNFAConfiguration );
}
}

public virtual void reportNondeterminism( DFAState d, HashSet<int> nondeterministicAlts )
{
-            altsWithProblem.addAll( nondeterministicAlts ); // track overall list
-            statesWithSyntacticallyAmbiguousAltsSet.Add( d );
+            _altsWithProblem.addAll( nondeterministicAlts ); // track overall list
+            _statesWithSyntacticallyAmbiguousAltsSet.Add( d );
dfa.nfa.grammar.setOfNondeterministicDecisionNumbers.Add(
dfa.DecisionNumber
);
@@ -886,7 +888,7 @@ namespace Antlr3.Analysis
{
d.dfa.probe.removeRecursiveOverflowState( d );
}
-            statesResolvedWithSemanticPredicatesSet.Add( d );
+            _statesResolvedWithSemanticPredicatesSet.Add( d );
//JSystem.@out.println("resolved with pred: "+d);
dfa.nfa.grammar.setOfNondeterministicDecisionNumbersResolvedWithPredicates.Add(
dfa.DecisionNumber
@@ -902,13 +904,13 @@ namespace Antlr3.Analysis
{
IDictionary<int, SemanticContext> copy = new Dictionary<int, SemanticContext>( altPredicateContext );
//copy.putAll( altPredicateContext );
-            stateToAltSetWithSemanticPredicatesMap[d] = copy;
+            _stateToAltSetWithSemanticPredicatesMap[d] = copy;
}

public virtual void reportIncompletelyCoveredAlts( DFAState d,
IDictionary<int, ICollection<IToken>> altToLocationsReachableWithoutPredicate )
{
-            stateToIncompletelyCoveredAltsMap[d] = altToLocationsReachableWithoutPredicate;
+            _stateToIncompletelyCoveredAltsMap[d] = altToLocationsReachableWithoutPredicate;
}

// S U P P O R T
@@ -925,13 +927,13 @@ namespace Antlr3.Analysis
{
states.Add( targetState );
//JSystem.@out.println("found target DFA state "+targetState.getStateNumber());
-                stateReachable[startState.stateNumber] = REACHABLE_YES;
+                _stateReachable[startState.stateNumber] = REACHABLE_YES;
return true;
}

DFAState s = startState;
// avoid infinite loops
-            stateReachable[s.stateNumber] = REACHABLE_BUSY;
+            _stateReachable[s.stateNumber] = REACHABLE_BUSY;

// look for a path to targetState among transitions for this state
// stop when you find the first one; I'm pretty sure there is
@@ -942,7 +944,7 @@ namespace Antlr3.Analysis
DFAState edgeTarget = (DFAState)t.target;

int targetStatus; //= stateReachable.get( edgeTarget.stateNumber );
-                if ( stateReachable.TryGetValue( edgeTarget.stateNumber, out targetStatus ) )
+                if ( _stateReachable.TryGetValue( edgeTarget.stateNumber, out targetStatus ) )
{
if ( targetStatus == REACHABLE_BUSY )
{ // avoid cycles; they say nothing
@@ -950,7 +952,7 @@ namespace Antlr3.Analysis
}
if ( targetStatus == REACHABLE_YES )
{ // return success!
-                        stateReachable[s.stateNumber] = REACHABLE_YES;
+                        _stateReachable[s.stateNumber] = REACHABLE_YES;
return true;
}
if ( targetStatus == REACHABLE_NO )
@@ -963,19 +965,19 @@ namespace Antlr3.Analysis
if ( reachesState( edgeTarget, targetState, states ) )
{
states.Add( s );
-                    stateReachable[s.stateNumber] = REACHABLE_YES;
+                    _stateReachable[s.stateNumber] = REACHABLE_YES;
return true;
}
}

-            stateReachable[s.stateNumber] = REACHABLE_NO;
+            _stateReachable[s.stateNumber] = REACHABLE_NO;
return false; // no path to targetState found.
}

protected virtual HashSet<object> getDFAPathStatesToTarget( DFAState targetState )
{
HashSet<object> dfaStates = new HashSet<object>();
-            stateReachable = new Dictionary<int, int>();
+            _stateReachable = new Dictionary<int, int>();
if ( dfa == null || dfa.startState == null )
{
return dfaStates;
@@ -998,7 +1000,7 @@ namespace Antlr3.Analysis
HashSet<object> states,
IList<Label> labels )
{
-            statesVisitedDuringSampleSequence.Add( startState.stateNumber );
+            _statesVisitedDuringSampleSequence.Add( startState.stateNumber );

// pick the first edge in states as the one to traverse
for ( int i = 0; i < startState.NumberOfTransitions; i++ )
@@ -1006,7 +1008,7 @@ namespace Antlr3.Analysis
Transition t = startState.getTransition( i );
DFAState edgeTarget = (DFAState)t.target;
if ( states.Contains( edgeTarget ) &&
-                     !statesVisitedDuringSampleSequence.Contains( edgeTarget.stateNumber ) )
+                     !_statesVisitedDuringSampleSequence.Contains( edgeTarget.stateNumber ) )
{
labels.Add( t.label ); // traverse edge and track label
if ( edgeTarget != targetState )
@@ -1041,7 +1043,7 @@ namespace Antlr3.Analysis
{
// track a visit to state s at input index labelIndex if not seen
String thisStateKey = getStateLabelIndexKey( s.stateNumber, labelIndex );
-            if ( statesVisitedAtInputDepth.Contains( thisStateKey ) )
+            if ( _statesVisitedAtInputDepth.Contains( thisStateKey ) )
{
/*
JSystem.@out.println("### already visited "+s.stateNumber+" previously at index "+
@@ -1049,7 +1051,7 @@ namespace Antlr3.Analysis
*/
return false;
}
-            statesVisitedAtInputDepth.Add( thisStateKey );
+            _statesVisitedAtInputDepth.Add( thisStateKey );

/*
JSystem.@out.println("enter state "+s.stateNumber+" visited states: "+
@@ -1077,7 +1079,7 @@ namespace Antlr3.Analysis
getNFAPath( edgeTarget, labelIndex, labels, path );
if ( found )
{
-                        statesVisitedAtInputDepth.Remove( thisStateKey );
+                        _statesVisitedAtInputDepth.Remove( thisStateKey );
return true; // return to "calling" state
}
path.RemoveAt( path.Count - 1 ); // remove; didn't work out
@@ -1094,7 +1096,7 @@ namespace Antlr3.Analysis
if ( labelIndex == labels.Count - 1 )
{
// found last label; done!
-                        statesVisitedAtInputDepth.Remove( thisStateKey );
+                        _statesVisitedAtInputDepth.Remove( thisStateKey );
return true;
}
// otherwise try to match remaining input
@@ -1102,7 +1104,7 @@ namespace Antlr3.Analysis
getNFAPath( edgeTarget, labelIndex + 1, labels, path );
if ( found )
{
-                        statesVisitedAtInputDepth.Remove( thisStateKey );
+                        _statesVisitedAtInputDepth.Remove( thisStateKey );
return true;
}
/*
@@ -1115,7 +1117,7 @@ namespace Antlr3.Analysis
}
//JSystem.@out.println("no epsilon or matching edge; removing "+thisStateKey);
// no edge was found matching label; is ok, some state will have it
-            statesVisitedAtInputDepth.Remove( thisStateKey );
+            _statesVisitedAtInputDepth.Remove( thisStateKey );
return false;
}

@@ -1146,7 +1148,7 @@ namespace Antlr3.Analysis

public virtual void reset()
{
-            stateToRecursionOverflowConfigurationsMap.Clear();
+            _stateToRecursionOverflowConfigurationsMap.Clear();
}
}

diff --git a/Antlr3/Analysis/LL1Analyzer.cs b/Antlr3/Analysis/LL1Analyzer.cs
index e134a28..af0e08d 100644
--- a/Antlr3/Analysis/LL1Analyzer.cs
+++ b/Antlr3/Analysis/LL1Analyzer.cs
@@ -58,17 +58,17 @@ namespace Antlr3.Analysis
/**	2	if we didn't find such a pred */
public const int DETECT_PRED_NOT_FOUND = 2;

-        public Grammar grammar;
+        Grammar _grammar;

/** Used during LOOK to detect computation cycles */
-        protected HashSet<NFAState> lookBusy = new HashSet<NFAState>();
+        HashSet<NFAState> _lookBusy = new HashSet<NFAState>();

-        public IDictionary<NFAState, LookaheadSet> FIRSTCache = new Dictionary<NFAState, LookaheadSet>();
-        public IDictionary<Rule, LookaheadSet> FOLLOWCache = new Dictionary<Rule, LookaheadSet>();
+        IDictionary<NFAState, LookaheadSet> _firstCache = new Dictionary<NFAState, LookaheadSet>();
+        IDictionary<Rule, LookaheadSet> _followCache = new Dictionary<Rule, LookaheadSet>();

public LL1Analyzer( Grammar grammar )
{
-            this.grammar = grammar;
+            this._grammar = grammar;
}

#if false
@@ -160,7 +160,7 @@ namespace Antlr3.Analysis
public virtual LookaheadSet FIRST( NFAState s )
{
//JSystem.@out.println("> FIRST("+s.enclosingRule.name+") in rule "+s.enclosingRule);
-            lookBusy.Clear();
+            _lookBusy.Clear();
LookaheadSet look = _FIRST( s, false );
//JSystem.@out.println("< FIRST("+s.enclosingRule.name+") in rule "+s.enclosingRule+"="+look.toString(this.grammar));
return look;
@@ -169,13 +169,13 @@ namespace Antlr3.Analysis
public virtual LookaheadSet FOLLOW( Rule r )
{
//JSystem.@out.println("> FOLLOW("+r.name+") in rule "+r.startState.enclosingRule);
-            LookaheadSet f = FOLLOWCache.get( r );
+            LookaheadSet f = _followCache.get( r );
if ( f != null )
{
return f;
}
f = _FIRST( r.stopState, true );
-            FOLLOWCache[r] = f;
+            _followCache[r] = f;
//JSystem.@out.println("< FOLLOW("+r+") in rule "+r.startState.enclosingRule+"="+f.toString(this.grammar));
return f;
}
@@ -186,10 +186,10 @@ namespace Antlr3.Analysis
{
Console.Out.WriteLine( "> LOOK(" + s + ")" );
}
-            lookBusy.Clear();
+            _lookBusy.Clear();
LookaheadSet look = _FIRST( s, true );
// FOLLOW makes no sense (at the moment!) for lexical rules.
-            if ( grammar.type != Grammar.LEXER && look.member( Label.EOR_TOKEN_TYPE ) )
+            if ( _grammar.type != Grammar.LEXER && look.member( Label.EOR_TOKEN_TYPE ) )
{
// avoid altering FIRST reset as it is cached
LookaheadSet f = FOLLOW( s.enclosingRule );
@@ -198,7 +198,7 @@ namespace Antlr3.Analysis
look = f;
//look.orInPlace(FOLLOW(s.enclosingRule));
}
-            else if ( grammar.type == Grammar.LEXER && look.member( Label.EOT ) )
+            else if ( _grammar.type == Grammar.LEXER && look.member( Label.EOT ) )
{
// if this has EOT, lookahead is all char (all char can follow rule)
//look = new LookaheadSet(Label.EOT);
@@ -206,7 +206,7 @@ namespace Antlr3.Analysis
}
if ( NFAToDFAConverter.debug )
{
-                Console.Out.WriteLine( "< LOOK(" + s + ")=" + look.ToString( grammar ) );
+                Console.Out.WriteLine( "< LOOK(" + s + ")=" + look.ToString( _grammar ) );
}
return look;
}
@@ -221,7 +221,7 @@ namespace Antlr3.Analysis
*/
if ( !chaseFollowTransitions && s.IsAcceptState )
{
-                if ( grammar.type == Grammar.LEXER )
+                if ( _grammar.type == Grammar.LEXER )
{
// FOLLOW makes no sense (at the moment!) for lexical rules.
// assume all char can follow
@@ -230,12 +230,12 @@ namespace Antlr3.Analysis
return new LookaheadSet( Label.EOR_TOKEN_TYPE );
}

-            if ( lookBusy.Contains( s ) )
+            if ( _lookBusy.Contains( s ) )
{
// return a copy of an empty set; we may modify set inline
return new LookaheadSet();
}
-            lookBusy.Add( s );
+            _lookBusy.Add( s );

Transition transition0 = s.transition[0];
if ( transition0 == null )
@@ -259,7 +259,7 @@ namespace Antlr3.Analysis
// if transition 0 is a rule call and we don't want FOLLOW, check cache
if ( !chaseFollowTransitions && transition0 is RuleClosureTransition )
{
-                LookaheadSet prev = FIRSTCache.get( (NFAState)transition0.target );
+                LookaheadSet prev = _firstCache.get( (NFAState)transition0.target );
if ( prev != null )
{
tset = new LookaheadSet( prev );
@@ -273,12 +273,12 @@ namespace Antlr3.Analysis
// save FIRST cache for transition 0 if rule call
if ( !chaseFollowTransitions && transition0 is RuleClosureTransition )
{
-                    FIRSTCache[(NFAState)transition0.target] = tset;
+                    _firstCache[(NFAState)transition0.target] = tset;
}
}

// did we fall off the end?
-            if ( grammar.type != Grammar.LEXER && tset.member( Label.EOR_TOKEN_TYPE ) )
+            if ( _grammar.type != Grammar.LEXER && tset.member( Label.EOR_TOKEN_TYPE ) )
{
if ( transition0 is RuleClosureTransition )
{
@@ -319,7 +319,7 @@ namespace Antlr3.Analysis
*/
public bool detectConfoundingPredicates( NFAState s )
{
-            lookBusy.Clear();
+            _lookBusy.Clear();
Rule r = s.enclosingRule;
return _detectConfoundingPredicates( s, r, false ) == DETECT_PRED_FOUND;
}
@@ -331,7 +331,7 @@ namespace Antlr3.Analysis
//JSystem.@out.println("_detectNonAutobacktrackPredicates("+s+")");
if ( !chaseFollowTransitions && s.IsAcceptState )
{
-                if ( grammar.type == Grammar.LEXER )
+                if ( _grammar.type == Grammar.LEXER )
{
// FOLLOW makes no sense (at the moment!) for lexical rules.
// assume all char can follow
@@ -340,12 +340,12 @@ namespace Antlr3.Analysis
return DETECT_PRED_EOR;
}

-            if ( lookBusy.Contains( s ) )
+            if ( _lookBusy.Contains( s ) )
{
// return a copy of an empty set; we may modify set inline
return DETECT_PRED_NOT_FOUND;
}
-            lookBusy.Add( s );
+            _lookBusy.Add( s );

Transition transition0 = s.transition[0];
if ( transition0 == null )
@@ -438,7 +438,7 @@ namespace Antlr3.Analysis
*/
public virtual SemanticContext getPredicates( NFAState altStartState )
{
-            lookBusy.Clear();
+            _lookBusy.Clear();
return _getPredicates( altStartState, altStartState );
}

@@ -451,11 +451,11 @@ namespace Antlr3.Analysis
}

// avoid infinite loops from (..)* etc...
-            if ( lookBusy.Contains( s ) )
+            if ( _lookBusy.Contains( s ) )
{
return null;
}
-            lookBusy.Add( s );
+            _lookBusy.Add( s );

Transition transition0 = s.transition[0];
// no transitions
diff --git a/Antlr3/Analysis/LL1DFA.cs b/Antlr3/Analysis/LL1DFA.cs
index 3deff53..d4d5da2 100644
--- a/Antlr3/Analysis/LL1DFA.cs
+++ b/Antlr3/Analysis/LL1DFA.cs
@@ -58,17 +58,17 @@ namespace Antlr3.Analysis
DFAState s0 = newState();
startState = s0;
nfa = decisionStartState.nfa;
-            nAlts = nfa.grammar.getNumberOfAltsForDecisionNFA( decisionStartState );
+            NumberOfAlts = nfa.grammar.getNumberOfAltsForDecisionNFA( decisionStartState );
this.decisionNumber = decisionNumber;
-            this.decisionNFAStartState = decisionStartState;
+            this.NFADecisionStartState = decisionStartState;
initAltRelatedInfo();
-            unreachableAlts = null;
+            UnreachableAlts = null;
for ( int alt = 1; alt < altLook.Length; alt++ )
{
DFAState acceptAltState = newState();
acceptAltState.acceptState = true;
setAcceptState( alt, acceptAltState );
-                acceptAltState.k = 1;
+                acceptAltState.LookaheadDepth = 1;
acceptAltState.cachedUniquelyPredicatedAlt = alt;
Label e = getLabelForSet( altLook[alt].tokenTypeSet );
s0.addTransition( acceptAltState, e );
@@ -85,11 +85,11 @@ namespace Antlr3.Analysis
DFAState s0 = newState();
startState = s0;
nfa = decisionStartState.nfa;
-            nAlts = nfa.grammar.getNumberOfAltsForDecisionNFA( decisionStartState );
+            NumberOfAlts = nfa.grammar.getNumberOfAltsForDecisionNFA( decisionStartState );
this.decisionNumber = decisionNumber;
-            this.decisionNFAStartState = decisionStartState;
+            this.NFADecisionStartState = decisionStartState;
initAltRelatedInfo();
-            unreachableAlts = null;
+            UnreachableAlts = null;
foreach ( var edgeVar in edgeMap )
{
IntervalSet edge = edgeVar.Key;
@@ -98,7 +98,7 @@ namespace Antlr3.Analysis
//Collections.sort( alts ); // make sure alts are attempted in order
//JSystem.@out.println(edge+" -> "+alts);
DFAState s = newState();
-                s.k = 1;
+                s.LookaheadDepth = 1;
Label e = getLabelForSet( edge );
s0.addTransition( s, e );
if ( alts.Count == 1 )
@@ -112,7 +112,7 @@ namespace Antlr3.Analysis
{
// resolve with syntactic predicates.  Add edges from
// state s that test predicates.
-                    s.resolvedWithPredicates = true;
+                    s.IsResolvedWithPredicates = true;
for ( int i = 0; i < alts.Count; i++ )
{
int alt = (int)alts[i];
diff --git a/Antlr3/Analysis/Label.cs b/Antlr3/Analysis/Label.cs
index 95941d0..b08f056 100644
--- a/Antlr3/Analysis/Label.cs
+++ b/Antlr3/Analysis/Label.cs
@@ -121,14 +121,14 @@ namespace Antlr3.Analysis
TokenConstants.MinTokenType;

/** The wildcard '.' char atom implies all valid characters==UNICODE */
-        //public static final IntSet ALLCHAR = IntervalSet.of(MIN_CHAR_VALUE,MAX_CHAR_VALUE);
+        //public static readonly IIntSet ALLCHAR = IntervalSet.of( MIN_CHAR_VALUE, MAX_CHAR_VALUE );

/** The token type or character value; or, signifies special label. */
-        protected internal int label;
+        internal int label;

/** A set of token types or character codes if label==SET */
// TODO: try IntervalSet for everything
-        protected IIntSet labelSet;
+        IIntSet _labelSet;

public Label( int label )
{
@@ -141,7 +141,7 @@ namespace Antlr3.Analysis
if ( labelSet == null )
{
this.label = SET;
-                this.labelSet = IntervalSet.of( INVALID );
+                this._labelSet = IntervalSet.of( INVALID );
return;
}
int singleAtom = labelSet.getSingleElement();
@@ -152,7 +152,7 @@ namespace Antlr3.Analysis
return;
}
this.label = SET;
-            this.labelSet = labelSet;
+            this._labelSet = labelSet;
}

#region Properties
@@ -219,12 +219,12 @@ namespace Antlr3.Analysis
// convert single element to a set if they ask for it.
return IntervalSet.of( label );
}
-                return labelSet;
+                return _labelSet;
}
set
{
label = SET;
-                labelSet = value;
+                _labelSet = value;
}
}
#endregion
@@ -237,8 +237,8 @@ namespace Antlr3.Analysis
//l = (Label)base.clone();
l = new Label( label );
l.label = this.label;
-                l.labelSet = new IntervalSet();
-                l.labelSet.addAll( this.labelSet );
+                l._labelSet = new IntervalSet();
+                l._labelSet.addAll( this._labelSet );
//}
//catch ( CloneNotSupportedException e )
//{
@@ -251,15 +251,15 @@ namespace Antlr3.Analysis
{
if ( IsAtom )
{
-                labelSet = IntervalSet.of( label );
+                _labelSet = IntervalSet.of( label );
label = SET;
if ( a.IsAtom )
{
-                    labelSet.Add( a.Atom );
+                    _labelSet.Add( a.Atom );
}
else if ( a.IsSet )
{
-                    labelSet.addAll( a.Set );
+                    _labelSet.addAll( a.Set );
}
else
{
@@ -271,11 +271,11 @@ namespace Antlr3.Analysis
{
if ( a.IsAtom )
{
-                    labelSet.Add( a.Atom );
+                    _labelSet.Add( a.Atom );
}
else if ( a.IsSet )
{
-                    labelSet.addAll( a.Set );
+                    _labelSet.addAll( a.Set );
}
else
{
@@ -294,7 +294,7 @@ namespace Antlr3.Analysis
}
if ( IsSet )
{
-                return labelSet.member( atom );
+                return _labelSet.member( atom );
}
return false;
}
@@ -331,7 +331,7 @@ namespace Antlr3.Analysis
{
if ( label == SET )
{
-                return labelSet.GetHashCode();
+                return _labelSet.GetHashCode();
}
else
{
@@ -357,7 +357,7 @@ namespace Antlr3.Analysis
}
if ( label == SET )
{
-                return this.labelSet.Equals( ( (Label)o ).labelSet );
+                return this._labelSet.Equals( ( (Label)o )._labelSet );
}
return true;  // label values are same, so true
}
@@ -400,7 +400,7 @@ namespace Antlr3.Analysis
switch ( label )
{
case SET:
-                return labelSet.ToString();
+                return _labelSet.ToString();
default:
return label.ToString(); //String.valueOf( label );
}
@@ -411,7 +411,7 @@ namespace Antlr3.Analysis
switch ( label )
{
case SET:
-                return labelSet.ToString( g );
+                return _labelSet.ToString( g );
default:
return g.getTokenDisplayName( label );
}
diff --git a/Antlr3/Analysis/NFA.cs b/Antlr3/Analysis/NFA.cs
index 8665487..365aa28 100644
--- a/Antlr3/Analysis/NFA.cs
+++ b/Antlr3/Analysis/NFA.cs
@@ -45,10 +45,10 @@ namespace Antlr3.Analysis
public const int INVALID_ALT_NUMBER = -1;

/** This NFA represents which grammar? */
-        public Grammar grammar;
+        internal Grammar grammar;

/** Which factory created this NFA? */
-        protected NFAFactory factory = null;
+        NFAFactory _factory;

public bool complete;

@@ -62,11 +62,11 @@ namespace Antlr3.Analysis
{
get
{
-                return factory;
+                return _factory;
}
set
{
-                factory = value;
+                _factory = value;
}
}
#endregion
diff --git a/Antlr3/Analysis/NFAConfiguration.cs b/Antlr3/Analysis/NFAConfiguration.cs
index 1b9de38..0483926 100644
--- a/Antlr3/Analysis/NFAConfiguration.cs
+++ b/Antlr3/Analysis/NFAConfiguration.cs
@@ -83,7 +83,7 @@ namespace Antlr3.Analysis
/** Lots of NFA states have only epsilon edges (1 or 2).  We can
*  safely consider only n>0 during closure.
*/
-        protected int numberEpsilonTransitionsEmanatingFromState;
+        //int _numberEpsilonTransitionsEmanatingFromState;

/** Indicates that the NFA state associated with this configuration
*  has exactly one transition and it's an atom (not epsilon etc...).
diff --git a/Antlr3/Analysis/NFAContext.cs b/Antlr3/Analysis/NFAContext.cs
index 6685a74..bd12336 100644
--- a/Antlr3/Analysis/NFAContext.cs
+++ b/Antlr3/Analysis/NFAContext.cs
@@ -122,7 +122,7 @@ namespace Antlr3.Analysis
*  and nothing on the stack is ever modified...ctx just grows
*  or shrinks.
*/
-        protected int cachedHashCode;
+        int _cachedHashCode;

public NFAContext( NFAContext parent, NFAState invokingState )
{
@@ -130,11 +130,11 @@ namespace Antlr3.Analysis
this.invokingState = invokingState;
if ( invokingState != null )
{
-                this.cachedHashCode = invokingState.stateNumber;
+                this._cachedHashCode = invokingState.stateNumber;
}
if ( parent != null )
{
-                this.cachedHashCode += parent.cachedHashCode;
+                this._cachedHashCode += parent._cachedHashCode;
}
}

@@ -162,7 +162,7 @@ namespace Antlr3.Analysis
public override bool Equals( object o )
{
NFAContext other = ( (NFAContext)o );
-            if ( this.cachedHashCode != other.cachedHashCode )
+            if ( this._cachedHashCode != other._cachedHashCode )
{
return false; // can't be same if hash is different
}
@@ -303,7 +303,7 @@ namespace Antlr3.Analysis

public override int GetHashCode()
{
-            return cachedHashCode;
+            return _cachedHashCode;
/*
int h = 0;
NFAContext sp = this;
diff --git a/Antlr3/Analysis/NFAState.cs b/Antlr3/Analysis/NFAState.cs
index 8972b38..de2d251 100644
--- a/Antlr3/Analysis/NFAState.cs
+++ b/Antlr3/Analysis/NFAState.cs
@@ -52,7 +52,7 @@ namespace Antlr3.Analysis
public const int MAX_TRANSITIONS = 2;

/** How many transitions; 0, 1, or 2 transitions */
-        int numTransitions = 0;
+        int _numTransitions = 0;
public Transition[] transition = new Transition[MAX_TRANSITIONS];

/** For o-A->o type NFA tranitions, record the label that leads to this
@@ -62,10 +62,10 @@ namespace Antlr3.Analysis
public Label incidentEdgeLabel;

/** Which NFA are we in? */
-        public NFA nfa = null;
+        public NFA nfa;

/** What's its decision number from 1..n? */
-        int decisionNumber = 0;
+        int _decisionNumber;

/** Subrules (...)* and (...)+ have more than one decision point in
*  the NFA created for them.  They both have a loop-exit-or-stay-in
@@ -93,7 +93,7 @@ namespace Antlr3.Analysis
*  to know what relationship this node has to the original grammar.
*  For example, "start of alt 1 of rule a".
*/
-        string description;
+        string _description;

/** Associate this NFAState with the corresponding GrammarAST node
*  from which this node was created.  This is useful not only for
@@ -106,7 +106,7 @@ namespace Antlr3.Analysis
public GrammarAST associatedASTNode;

/** Is this state the sole target of an EOT transition? */
-        bool EOTTargetState = false;
+        bool _eotTargetState = false;

/** Jean Bovet needs in the GUI to know which state pairs correspond
*  to the start/stop of a block.
@@ -123,22 +123,22 @@ namespace Antlr3.Analysis
{
get
{
-                return decisionNumber;
+                return _decisionNumber;
}
set
{
-                decisionNumber = value;
+                _decisionNumber = value;
}
}
public string Description
{
get
{
-                return description;
+                return _description;
}
set
{
-                description = value;
+                _description = value;
}
}
public bool IsDecisionState
@@ -152,11 +152,11 @@ namespace Antlr3.Analysis
{
get
{
-                return EOTTargetState;
+                return _eotTargetState;
}
set
{
-                EOTTargetState = value;
+                _eotTargetState = value;
}
}
#endregion
@@ -165,7 +165,7 @@ namespace Antlr3.Analysis
{
get
{
-                return numTransitions;
+                return _numTransitions;
}
}

@@ -175,14 +175,14 @@ namespace Antlr3.Analysis
{
throw new ArgumentException( "You can't add a null transition" );
}
-            if ( numTransitions > transition.Length )
+            if ( _numTransitions > transition.Length )
{
throw new ArgumentException( "You can only have " + transition.Length + " transitions" );
}
if ( e != null )
{
-                transition[numTransitions] = e;
-                numTransitions++;
+                transition[_numTransitions] = e;
+                _numTransitions++;
// Set the "back pointer" of the target state so that it
// knows about the label of the incoming edge.
Label label = e.label;
@@ -208,7 +208,7 @@ namespace Antlr3.Analysis
}
transition[0] = e;
transition[1] = null;
-            numTransitions = 1;
+            _numTransitions = 1;
}

public override Transition getTransition( int i )
@@ -245,7 +245,7 @@ namespace Antlr3.Analysis
public int translateDisplayAltToWalkAlt( int displayAlt )
{
NFAState nfaStart = this;
-            if ( decisionNumber == 0 || decisionStateType == 0 )
+            if ( _decisionNumber == 0 || decisionStateType == 0 )
{
return displayAlt;
}
diff --git a/Antlr3/Analysis/NFAtoDFAConverter.cs b/Antlr3/Analysis/NFAtoDFAConverter.cs
index fe6f5bb..7201120 100644
--- a/Antlr3/Analysis/NFAtoDFAConverter.cs
+++ b/Antlr3/Analysis/NFAtoDFAConverter.cs
@@ -49,7 +49,7 @@ namespace Antlr3.Analysis
public class NFAToDFAConverter
{
/** A list of DFA states we still need to process during NFA conversion */
-        protected Queue<DFAState> work = new Queue<DFAState>();
+        Queue<DFAState> _work = new Queue<DFAState>();

/** While converting NFA, we must track states that
*  reference other rule's NFAs so we know what to do
@@ -58,10 +58,10 @@ namespace Antlr3.Analysis
*  states.  I'm tracking a context tree (record of rule invocation
*  stack trace) for each alternative that could be predicted.
*/
-        protected NFAContext[] contextTrees;
+        NFAContext[] _contextTrees;

/** We are converting which DFA? */
-        protected DFA dfa;
+        DFA _dfa;

public static bool debug = false;

@@ -74,33 +74,33 @@ namespace Antlr3.Analysis
*/
public static bool SINGLE_THREADED_NFA_CONVERSION = true;

-        protected bool computingStartState = false;
+        bool _computingStartState = false;

public NFAToDFAConverter( DFA dfa )
{
-            this.dfa = dfa;
+            this._dfa = dfa;
int nAlts = dfa.NumberOfAlts;
initContextTrees( nAlts );
}

public virtual void convert()
{
-            dfa.conversionStartTime = System.DateTime.Now;
+            _dfa.conversionStartTime = System.DateTime.Now;

// create the DFA start state
-            dfa.startState = computeStartState();
+            _dfa.startState = computeStartState();

// while more DFA states to check, process them
-            while ( work.Count > 0 &&
-                    !dfa.nfa.grammar.NFAToDFAConversionExternallyAborted() )
+            while ( _work.Count > 0 &&
+                    !_dfa.nfa.grammar.NFAToDFAConversionExternallyAborted() )
{
-                DFAState d = (DFAState)work.Peek();
-                if ( dfa.nfa.grammar.composite.watchNFAConversion )
+                DFAState d = (DFAState)_work.Peek();
+                if ( _dfa.nfa.grammar.composite.watchNFAConversion )
{
Console.Out.WriteLine( "convert DFA state " + d.stateNumber +
" (" + d.nfaConfigurations.size() + " nfa states)" );
}
-                int k = dfa.UserMaxLookahead;
+                int k = _dfa.UserMaxLookahead;
if ( k > 0 && k == d.LookaheadDepth )
{
// we've hit max lookahead, make this a stop state
@@ -125,13 +125,13 @@ namespace Antlr3.Analysis
{
findNewDFAStatesAndAddDFATransitions( d );
}
-                work.Dequeue(); // done with it; remove from work list
+                _work.Dequeue(); // done with it; remove from work list
}

// Find all manual syn preds (gated).  These are not discovered
// in tryToResolveWithSemanticPredicates because they are implicitly
// added to every edge by code gen, DOT generation etc...
-            dfa.findAllGatedSynPredsUsedInDFAAcceptStates();
+            _dfa.findAllGatedSynPredsUsedInDFAAcceptStates();
}

/** From this first NFA state of a decision, create a DFA.
@@ -154,9 +154,9 @@ namespace Antlr3.Analysis
*/
protected virtual DFAState computeStartState()
{
-            NFAState alt = dfa.decisionNFAStartState;
-            DFAState startState = dfa.newState();
-            computingStartState = true;
+            NFAState alt = _dfa.NFADecisionStartState;
+            DFAState startState = _dfa.newState();
+            _computingStartState = true;
int i = 0;
int altNum = 1;
while ( alt != null )
@@ -165,14 +165,14 @@ namespace Antlr3.Analysis
// any input symbols for each alt.  Keep adding to same
// overall closure that will represent the DFA start state,
// but track the alt number
-                NFAContext initialContext = contextTrees[i];
+                NFAContext initialContext = _contextTrees[i];
// if first alt is derived from loopback/exit branch of loop,
// make alt=n+1 for n alts instead of 1
if ( i == 0 &&
-                     dfa.NFADecisionStartState.decisionStateType == NFAState.LOOPBACK )
+                     _dfa.NFADecisionStartState.decisionStateType == NFAState.LOOPBACK )
{
-                    int numAltsIncludingExitBranch = dfa.nfa.grammar
-                        .getNumberOfAltsForDecisionNFA( dfa.decisionNFAStartState );
+                    int numAltsIncludingExitBranch = _dfa.nfa.grammar
+                        .getNumberOfAltsForDecisionNFA( _dfa.NFADecisionStartState );
altNum = numAltsIncludingExitBranch;
closure( (NFAState)alt.transition[0].target,
altNum,
@@ -207,9 +207,9 @@ namespace Antlr3.Analysis
// now DFA start state has the complete closure for the decision
// but we have tracked which alt is associated with which
// NFA states.
-            dfa.addState( startState ); // make sure dfa knows about this state
-            work.Enqueue( startState );
-            computingStartState = false;
+            _dfa.addState( startState ); // make sure dfa knows about this state
+            _work.Enqueue( startState );
+            _computingStartState = false;
return startState;
}

@@ -256,7 +256,7 @@ namespace Antlr3.Analysis
// TODO: should this be done in the resolveAmbig method?
Label EOTLabel = new Label( Label.EOT );
bool containsEOT = labels != null && labels.Contains( EOTLabel );
-            if ( !dfa.IsGreedy && containsEOT )
+            if ( !_dfa.IsGreedy && containsEOT )
{
convertToEOTAcceptState( d );
return; // no more work to do on this accept state
@@ -300,7 +300,7 @@ namespace Antlr3.Analysis
if ( debug )
{
Console.Out.WriteLine( "DFA state after reach " + label + " " + d + "-" +
-                                       label.ToString( dfa.nfa.grammar ) + "->" + t );
+                                       label.ToString( _dfa.nfa.grammar ) + "->" + t );
}
if ( t == null )
{
@@ -350,7 +350,7 @@ namespace Antlr3.Analysis
// TODO: can fixed lookahead hit a dangling state case?
// TODO: yes, with left recursion
//Console.Error.WriteLine( "dangling state alts: " + d.getAltSet() );
-                dfa.probe.reportDanglingState( d );
+                _dfa.probe.reportDanglingState( d );
// turn off all configurations except for those associated with
// min alt number; somebody has to win else some input will not
// predict any alt.
@@ -359,7 +359,7 @@ namespace Antlr3.Analysis
// don't call convertToAcceptState() which merges stop states.
// other states point at us; don't want them pointing to dead states
d.IsAcceptState = true; // might be adding new accept state for alt
-                dfa.setAcceptState( minAlt, d );
+                _dfa.setAcceptState( minAlt, d );
//convertToAcceptState(d, minAlt); // force it to be an accept state
}

@@ -514,7 +514,7 @@ namespace Antlr3.Analysis
// figure out reachable NFA states from each of d's nfa states
// via epsilon transitions.
// Fill configsInClosure rather than altering d configs inline
-                closure( dfa.nfa.getState( c.state ),
+                closure( _dfa.nfa.getState( c.state ),
c.alt,
c.context,
c.semanticContext,
@@ -767,18 +767,18 @@ namespace Antlr3.Analysis
}
else if ( transition0 != null && transition0.IsSemanticPredicate )
{
-                    if ( computingStartState )
+                    if ( _computingStartState )
{
if ( collectPredicates )
{
// only indicate we can see a predicate if we're collecting preds
// Could be computing start state & seen an action before this.
-                            dfa.predicateVisible = true;
+                            _dfa.predicateVisible = true;
}
else
{
// this state has a pred, but we can't see it.
-                            dfa.hasPredicateBlockedByAction = true;
+                            _dfa.hasPredicateBlockedByAction = true;
// JSystem.@out.println("found pred during prediction but blocked by action found previously");
}
}
@@ -792,9 +792,9 @@ namespace Antlr3.Analysis
// do not hoist syn preds from other rules; only get if in
// starting state's rule (i.e., context is empty)
int walkAlt =
-                            dfa.decisionNFAStartState.translateDisplayAltToWalkAlt( alt );
+                            _dfa.NFADecisionStartState.translateDisplayAltToWalkAlt( alt );
NFAState altLeftEdge =
-                            dfa.nfa.grammar.getNFAStateForAltOfDecision( dfa.decisionNFAStartState, walkAlt );
+                            _dfa.nfa.grammar.getNFAStateForAltOfDecision( _dfa.NFADecisionStartState, walkAlt );
/*
JSystem.@out.println("state "+p.stateNumber+" alt "+alt+" walkAlt "+walkAlt+" trans to "+transition0.target);
JSystem.@out.println("DFA start state "+dfa.decisionNFAStartState.stateNumber);
@@ -907,7 +907,7 @@ namespace Antlr3.Analysis
public virtual DFAState reach( DFAState d, Label label )
{
//JSystem.@out.println("reach "+label.toString(dfa.nfa.grammar)+" from "+d.stateNumber);
-            DFAState labelDFATarget = dfa.newState();
+            DFAState labelDFATarget = _dfa.newState();

// for each NFA state in d with a labeled edge,
// add in target states for label
@@ -922,7 +922,7 @@ namespace Antlr3.Analysis
{
continue; // the conflict resolver indicates we must leave alone
}
-                NFAState p = dfa.nfa.getState( c.state );
+                NFAState p = _dfa.nfa.getState( c.state );
// by design of the grammar->NFA conversion, only transition 0
// may have a non-epsilon edge.
Transition edge = p.transition[0];
@@ -961,7 +961,7 @@ namespace Antlr3.Analysis
if ( labelDFATarget.nfaConfigurations.size() == 0 )
{
// kill; it's empty
-                dfa.setState( labelDFATarget.stateNumber, null );
+                _dfa.setState( labelDFATarget.stateNumber, null );
labelDFATarget = null;
}
return labelDFATarget;
@@ -989,7 +989,7 @@ namespace Antlr3.Analysis
{
continue; // the conflict resolver indicates we must leave alone
}
-                NFAState p = dfa.nfa.getState( c.state );
+                NFAState p = _dfa.nfa.getState( c.state );
Transition edge = p.transition[0];
Label edgeLabel = edge.label;
if ( edgeLabel.Equals( eot ) )
@@ -1014,7 +1014,7 @@ namespace Antlr3.Analysis
*/
protected virtual DFAState addDFAStateToWorkList( DFAState d )
{
-            DFAState existingState = dfa.addState( d );
+            DFAState existingState = _dfa.addState( d );
if ( d != existingState )
{
// already there...use/return the existing DFA state.
@@ -1027,7 +1027,7 @@ namespace Antlr3.Analysis
// into the reachable state space and the error
// reporting must be able to compute the path from
// start to the error state with infinite recursion
-                dfa.setState( d.stateNumber, existingState );
+                _dfa.setState( d.stateNumber, existingState );
return existingState;
}

@@ -1051,7 +1051,7 @@ namespace Antlr3.Analysis
else
{
// unresolved, add to work list to continue NFA conversion
-                work.Enqueue( d );
+                _work.Enqueue( d );
}
return d;
}
@@ -1070,7 +1070,7 @@ namespace Antlr3.Analysis
{
// check to see if we already have an accept state for this alt
// [must do this after we resolve nondeterminisms in general]
-                DFAState acceptStateForAlt = dfa.getAcceptState( alt );
+                DFAState acceptStateForAlt = _dfa.getAcceptState( alt );
if ( acceptStateForAlt != null )
{
// we already have an accept state for alt;
@@ -1087,8 +1087,8 @@ namespace Antlr3.Analysis
gatedPreds.Equals( existingStateGatedPreds ) ) )
{
// make this d.statenumber point at old DFA state
-                        dfa.setState( d.stateNumber, acceptStateForAlt );
-                        dfa.removeState( d );    // remove this state from unique DFA state set
+                        _dfa.setState( d.stateNumber, acceptStateForAlt );
+                        _dfa.removeState( d );    // remove this state from unique DFA state set
d = acceptStateForAlt; // use old accept state; throw this one out
return d;
}
@@ -1096,7 +1096,7 @@ namespace Antlr3.Analysis
}
}
d.IsAcceptState = true; // new accept state for alt
-            dfa.setAcceptState( alt, d );
+            _dfa.setAcceptState( alt, d );
return d;
}

@@ -1260,7 +1260,7 @@ namespace Antlr3.Analysis
// states in d must be targets of EOT.  These are the end states
// created in NFAFactory.build_EOFState
NFAConfiguration anyConfig = d.nfaConfigurations.get( 0 );
-            NFAState anyState = dfa.nfa.getState( anyConfig.state );
+            NFAState anyState = _dfa.nfa.getState( anyConfig.state );

// if d is target of EOT and more than one predicted alt
// indicate that d is nondeterministic on all alts otherwise
@@ -1275,7 +1275,7 @@ namespace Antlr3.Analysis
// track Tokens rule issues differently than other decisions
if ( d.dfa.IsTokensRuleDecision )
{
-                        dfa.probe.reportLexerRuleNondeterminism( d, allAlts );
+                        _dfa.probe.reportLexerRuleNondeterminism( d, allAlts );
//JSystem.@out.println("Tokens rule DFA state "+d+" nondeterministic");
conflictingLexerRules = true;
}
@@ -1293,7 +1293,7 @@ namespace Antlr3.Analysis
if ( !d.abortedDueToRecursionOverflow && !conflictingLexerRules )
{
// TODO: with k=x option set, this is called twice for same state
-                dfa.probe.reportNondeterminism( d, nondeterministicAlts );
+                _dfa.probe.reportNondeterminism( d, nondeterministicAlts );
// TODO: how to turn off when it's only the FOLLOW that is
// conflicting.  This used to shut off even alts i,j < n
// conflict warnings. :(
@@ -1308,8 +1308,8 @@ namespace Antlr3.Analysis
{
Console.Out.WriteLine( "resolved DFA state " + d.stateNumber + " with pred" );
}
-                d.resolvedWithPredicates = true;
-                dfa.probe.reportNondeterminismResolvedWithSemanticPredicate( d );
+                d.IsResolvedWithPredicates = true;
+                _dfa.probe.reportNondeterminismResolvedWithSemanticPredicate( d );
return;
}

@@ -1322,7 +1322,7 @@ namespace Antlr3.Analysis
protected virtual int resolveByChoosingFirstAlt( DFAState d, ICollection<int> nondeterministicAlts )
{
int winningAlt = 0;
-            if ( dfa.IsGreedy )
+            if ( _dfa.IsGreedy )
{
winningAlt = resolveByPickingMinAlt( d, nondeterministicAlts );
}
@@ -1336,7 +1336,7 @@ namespace Antlr3.Analysis
JSystem.@out.println("nondet="+nondeterministicAlts);
JSystem.@out.println("exit alt "+exitAlt);
*/
-                int exitAlt = dfa.NumberOfAlts;
+                int exitAlt = _dfa.NumberOfAlts;
if ( nondeterministicAlts.Contains( exitAlt ) )
{
// if nongreedy and exit alt is one of those nondeterministic alts
@@ -1383,7 +1383,7 @@ namespace Antlr3.Analysis
*/
protected virtual int resolveByPickingExitAlt( DFAState d, ICollection<int> nondeterministicAlts )
{
-            int exitAlt = dfa.NumberOfAlts;
+            int exitAlt = _dfa.NumberOfAlts;
turnOffOtherAlts( d, exitAlt, nondeterministicAlts );
return exitAlt;
}
@@ -1462,7 +1462,7 @@ namespace Antlr3.Analysis
}

//JSystem.@out.println("nondeterministic alts with predicates: "+altToPredMap);
-            dfa.probe.reportAltPredicateContext( d, altToPredMap );
+            _dfa.probe.reportAltPredicateContext( d, altToPredMap );

if ( nondeterministicAlts.Count - altToPredMap.Count > 1 )
{
@@ -1556,7 +1556,7 @@ namespace Antlr3.Analysis
// notify grammar that we've used the preds contained in semCtx
if ( semCtx.IsSyntacticPredicate )
{
-                            dfa.nfa.grammar.synPredUsedInDFA( dfa, semCtx );
+                            _dfa.nfa.grammar.synPredUsedInDFA( _dfa, semCtx );
}
}
else if ( nondeterministicAlts.Contains( configuration.alt ) )
@@ -1708,7 +1708,7 @@ namespace Antlr3.Analysis
if ( incompletelyCoveredAlts.Contains( altI ) &&
configuration.semanticContext == SemanticContext.EmptySemanticContext )
{
-                        NFAState s = dfa.nfa.getState( configuration.state );
+                        NFAState s = _dfa.nfa.getState( configuration.state );
/*
JSystem.@out.print("nondet config w/o context "+configuration+
" incident "+(s.incidentEdgeLabel!=null?s.incidentEdgeLabel.toString(dfa.nfa.grammar):null));
@@ -1738,7 +1738,7 @@ namespace Antlr3.Analysis
}
}
}
-                dfa.probe.reportIncompletelyCoveredAlts( d,
+                _dfa.probe.reportIncompletelyCoveredAlts( d,
altToLocationsReachableWithoutPredicate );
}

@@ -1811,21 +1811,21 @@ namespace Antlr3.Analysis
DFAState predDFATarget = d.dfa.getAcceptState( c.alt );
if ( predDFATarget == null )
{
-                    predDFATarget = dfa.newState(); // create if not there.
+                    predDFATarget = _dfa.newState(); // create if not there.
// create a new DFA state that is a target of the predicate from d
-                    predDFATarget.addNFAConfiguration( dfa.nfa.getState( c.state ),
+                    predDFATarget.addNFAConfiguration( _dfa.nfa.getState( c.state ),
c.alt,
c.context,
c.semanticContext );
predDFATarget.IsAcceptState = true;
-                    dfa.setAcceptState( c.alt, predDFATarget );
-                    DFAState existingState = dfa.addState( predDFATarget );
+                    _dfa.setAcceptState( c.alt, predDFATarget );
+                    DFAState existingState = _dfa.addState( predDFATarget );
if ( predDFATarget != existingState )
{
// already there...use/return the existing DFA state that
// is a target of this predicate.  Make this state number
// point at the existing state
-                        dfa.setState( predDFATarget.stateNumber, existingState );
+                        _dfa.setState( predDFATarget.stateNumber, existingState );
predDFATarget = existingState;
}
}
@@ -1836,15 +1836,15 @@ namespace Antlr3.Analysis

protected virtual void initContextTrees( int numberOfAlts )
{
-            contextTrees = new NFAContext[numberOfAlts];
-            for ( int i = 0; i < contextTrees.Length; i++ )
+            _contextTrees = new NFAContext[numberOfAlts];
+            for ( int i = 0; i < _contextTrees.Length; i++ )
{
int alt = i + 1;
// add a dummy root node so that an NFA configuration can
// always point at an NFAContext.  If a context refers to this
// node then it implies there is no call stack for
// that configuration
-                contextTrees[i] = new NFAContext( null, null );
+                _contextTrees[i] = new NFAContext( null, null );
}
}

diff --git a/Antlr3/Analysis/NonLLStarDecisionException.cs b/Antlr3/Analysis/NonLLStarDecisionException.cs
index 40ad542..f628326 100644
--- a/Antlr3/Analysis/NonLLStarDecisionException.cs
+++ b/Antlr3/Analysis/NonLLStarDecisionException.cs
@@ -39,10 +39,11 @@ namespace Antlr3.Analysis
*/
public class NonLLStarDecisionException : Exception
{
-        public DFA abortedDFA;
+        DFA _abortedDFA;
+
public NonLLStarDecisionException( DFA abortedDFA )
{
-            this.abortedDFA = abortedDFA;
+            _abortedDFA = abortedDFA;
}
}
}
diff --git a/Antlr3/Analysis/PredicateLabel.cs b/Antlr3/Analysis/PredicateLabel.cs
index d5ff2b8..40c6930 100644
--- a/Antlr3/Analysis/PredicateLabel.cs
+++ b/Antlr3/Analysis/PredicateLabel.cs
@@ -42,25 +42,25 @@ namespace Antlr3.Analysis
*  may have to combine a bunch of them as it collects predicates from
*  multiple NFA configurations into a single DFA state.
*/
-        protected SemanticContext semanticContext;
+        SemanticContext _semanticContext;

/** Make a semantic predicate label */
public PredicateLabel( GrammarAST predicateASTNode )
: base( SEMPRED )
{
-            this.semanticContext = new SemanticContext.Predicate( predicateASTNode );
+            this._semanticContext = new SemanticContext.Predicate( predicateASTNode );
}

/** Make a semantic predicates label */
public PredicateLabel( SemanticContext semCtx )
: base( SEMPRED )
{
-            this.semanticContext = semCtx;
+            this._semanticContext = semCtx;
}

public override int GetHashCode()
{
-            return semanticContext.GetHashCode();
+            return _semanticContext.GetHashCode();
}

public override bool Equals( object o )
@@ -78,7 +78,7 @@ namespace Antlr3.Analysis
{
return false;
}
-            return semanticContext.Equals( pl.SemanticContext );
+            return _semanticContext.Equals( pl.SemanticContext );
}

public override bool IsSemanticPredicate
@@ -93,13 +93,13 @@ namespace Antlr3.Analysis
{
get
{
-                return semanticContext;
+                return _semanticContext;
}
}

public override string ToString()
{
-            return "{" + semanticContext + "}?";
+            return "{" + _semanticContext + "}?";
}

public override string ToString( Grammar g )
diff --git a/Antlr3/Analysis/SemanticContext.cs b/Antlr3/Analysis/SemanticContext.cs
index 03f3841..0b436de 100644
--- a/Antlr3/Analysis/SemanticContext.cs
+++ b/Antlr3/Analysis/SemanticContext.cs
@@ -110,12 +110,12 @@ namespace Antlr3.Analysis
*  The simple Predicate object's predicate AST's type is used to set
*  gated to true if type==GATED_SEMPRED.
*/
-            protected bool gated = false;
+            bool _gated;

/** syntactic predicates are converted to semantic predicates
*  but synpreds are generated slightly differently.
*/
-            protected bool synpred = false;
+            bool _synpred;

public const int InvalidPredValue = -1;
public const int FalsePred = 0;
@@ -130,16 +130,16 @@ namespace Antlr3.Analysis
public Predicate()
{
predicateAST = new GrammarAST();
-                this.gated = false;
+                this._gated = false;
}

public Predicate( GrammarAST predicate )
{
this.predicateAST = predicate;
-                this.gated =
+                this._gated =
predicate.Type == ANTLRParser.GATED_SEMPRED ||
predicate.Type == ANTLRParser.SYN_SEMPRED;
-                this.synpred =
+                this._synpred =
predicate.Type == ANTLRParser.SYN_SEMPRED ||
predicate.Type == ANTLRParser.BACKTRACK_SEMPRED;
}
@@ -147,8 +147,8 @@ namespace Antlr3.Analysis
public Predicate( Predicate p )
{
this.predicateAST = p.predicateAST;
-                this.gated = p.gated;
-                this.synpred = p.synpred;
+                this._gated = p._gated;
+                this._synpred = p._synpred;
this.constantValue = p.constantValue;
}

@@ -183,7 +183,7 @@ namespace Antlr3.Analysis
StringTemplate eST = null;
if ( templates != null )
{
-                    if ( synpred )
+                    if ( _synpred )
{
eST = templates.GetInstanceOf( "evalSynPredicate" );
}
@@ -226,7 +226,7 @@ namespace Antlr3.Analysis
{
get
{
-                    if ( gated )
+                    if ( _gated )
{
return this;
}
@@ -246,7 +246,7 @@ namespace Antlr3.Analysis

public override void trackUseOfSyntacticPredicates( Grammar g )
{
-                if ( synpred )
+                if ( _synpred )
{
g.synPredNamesUsedInDFA.Add( predicateAST.Text );
}
@@ -312,11 +312,13 @@ namespace Antlr3.Analysis

public class AND : SemanticContext
{
-            protected SemanticContext left, right;
+            SemanticContext _left;
+            SemanticContext _right;
+
public AND( SemanticContext a, SemanticContext b )
{
-                this.left = a;
-                this.right = b;
+                this._left = a;
+                this._right = b;
}
public override StringTemplate genExpr( CodeGenerator generator,
StringTemplateGroup templates,
@@ -331,16 +333,16 @@ namespace Antlr3.Analysis
{
eST = new StringTemplate( "($left$&&$right$)" );
}
-                eST.SetAttribute( "left", left.genExpr( generator, templates, dfa ) );
-                eST.SetAttribute( "right", right.genExpr( generator, templates, dfa ) );
+                eST.SetAttribute( "left", _left.genExpr( generator, templates, dfa ) );
+                eST.SetAttribute( "right", _right.genExpr( generator, templates, dfa ) );
return eST;
}
public override SemanticContext GatedPredicateContext
{
get
{
-                    SemanticContext gatedLeft = left.GatedPredicateContext;
-                    SemanticContext gatedRight = right.GatedPredicateContext;
+                    SemanticContext gatedLeft = _left.GatedPredicateContext;
+                    SemanticContext gatedRight = _right.GatedPredicateContext;
if ( gatedLeft == null )
{
return gatedRight;
@@ -356,41 +358,42 @@ namespace Antlr3.Analysis
{
get
{
-                    return left.IsSyntacticPredicate || right.IsSyntacticPredicate;
+                    return _left.IsSyntacticPredicate || _right.IsSyntacticPredicate;
}
}
public override void trackUseOfSyntacticPredicates( Grammar g )
{
-                left.trackUseOfSyntacticPredicates( g );
-                right.trackUseOfSyntacticPredicates( g );
+                _left.trackUseOfSyntacticPredicates( g );
+                _right.trackUseOfSyntacticPredicates( g );
}
public override string ToString()
{
-                return "(" + left + "&&" + right + ")";
+                return "(" + _left + "&&" + _right + ")";
}
}

public class OR : SemanticContext
{
-            protected HashSet<object> operands;
+            HashSet<object> _operands;
+
public OR( SemanticContext a, SemanticContext b )
{
-                operands = new HashSet<object>();
+                _operands = new HashSet<object>();
if ( a is OR )
{
-                    operands.addAll( ( (OR)a ).operands );
+                    _operands.addAll( ( (OR)a )._operands );
}
else if ( a != null )
{
-                    operands.Add( a );
+                    _operands.Add( a );
}
if ( b is OR )
{
-                    operands.addAll( ( (OR)b ).operands );
+                    _operands.addAll( ( (OR)b )._operands );
}
else if ( b != null )
{
-                    operands.Add( b );
+                    _operands.Add( b );
}
}
public override StringTemplate genExpr( CodeGenerator generator,
@@ -406,7 +409,7 @@ namespace Antlr3.Analysis
{
eST = new StringTemplate( "($first(operands)$$rest(operands):{o | ||$o$}$)" );
}
-                foreach ( SemanticContext semctx in operands )
+                foreach ( SemanticContext semctx in _operands )
{
eST.SetAttribute( "operands", semctx.genExpr( generator, templates, dfa ) );
}
@@ -417,7 +420,7 @@ namespace Antlr3.Analysis
get
{
SemanticContext result = null;
-                    foreach ( SemanticContext semctx in operands )
+                    foreach ( SemanticContext semctx in _operands )
{
SemanticContext gatedPred = semctx.GatedPredicateContext;
if ( gatedPred != null )
@@ -433,7 +436,7 @@ namespace Antlr3.Analysis
{
get
{
-                    foreach ( SemanticContext semctx in operands )
+                    foreach ( SemanticContext semctx in _operands )
{
if ( semctx.IsSyntacticPredicate )
{
@@ -445,7 +448,7 @@ namespace Antlr3.Analysis
}
public override void trackUseOfSyntacticPredicates( Grammar g )
{
-                foreach ( SemanticContext semctx in operands )
+                foreach ( SemanticContext semctx in _operands )
{
semctx.trackUseOfSyntacticPredicates( g );
}
@@ -455,7 +458,7 @@ namespace Antlr3.Analysis
StringBuilder buf = new StringBuilder();
buf.Append( "(" );
int i = 0;
-                foreach ( SemanticContext semctx in operands )
+                foreach ( SemanticContext semctx in _operands )
{
if ( i > 0 )
{
diff --git a/Antlr3/Analysis/Transition.cs b/Antlr3/Analysis/Transition.cs
index cfb13ed..c126689 100644
--- a/Antlr3/Analysis/Transition.cs
+++ b/Antlr3/Analysis/Transition.cs
@@ -41,7 +41,7 @@ namespace Antlr3.Analysis
*  transitions) and has a label/target pair.  I have abstracted the notion
*  of a Label to handle the various kinds of things it can be.
*/
-    public class Transition : IComparable
+    public class Transition : IComparable<Transition>
{
/** What label must be consumed to transition to target */
public Label label;
@@ -112,9 +112,8 @@ namespace Antlr3.Analysis
this.target.Equals( other.target );
}

-        public virtual int CompareTo( object o )
+        public int CompareTo( Transition other )
{
-            Transition other = (Transition)o;
return this.label.CompareTo( other.label );
}

@@ -122,5 +121,6 @@ namespace Antlr3.Analysis
{
return label + "->" + target.stateNumber;
}
+
}
}
diff --git a/Antlr3/Tool/GrammarReport.cs b/Antlr3/Tool/GrammarReport.cs
index f819eba..785b732 100644
--- a/Antlr3/Tool/GrammarReport.cs
+++ b/Antlr3/Tool/GrammarReport.cs
@@ -247,12 +247,12 @@ namespace Antlr3.Tool
}
decisions.Add( dfa.decisionNumber );
buf.Append( "Rule " );
-                buf.Append( dfa.decisionNFAStartState.enclosingRule.name );
+                buf.Append( dfa.NFADecisionStartState.enclosingRule.name );
buf.Append( " decision " );
buf.Append( dfa.decisionNumber );
buf.Append( " location " );
GrammarAST decisionAST =
-                    dfa.decisionNFAStartState.associatedASTNode;
+                    dfa.NFADecisionStartState.associatedASTNode;
buf.Append( decisionAST.Line );
buf.Append( ":" );
buf.Append( decisionAST.CharPositionInLine );

