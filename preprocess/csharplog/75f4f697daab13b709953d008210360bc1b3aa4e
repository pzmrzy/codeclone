commit 75f4f697daab13b709953d008210360bc1b3aa4e
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Fri Feb 25 19:18:47 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Fri Feb 25 19:18:47 2011 -0800

(C# 3) Move actions from inline in the grammar to functions in the helper (partial) class file

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 7769]

diff --git a/Antlr3/Grammars/ActionAnalysisLexer.g3 b/Antlr3/Grammars/ActionAnalysisLexer.g3
index 542dae9..972134e 100644
--- a/Antlr3/Grammars/ActionAnalysisLexer.g3
+++ b/Antlr3/Grammars/ActionAnalysisLexer.g3
@@ -1,34 +1,34 @@
/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Grammar conversion to ANTLR v3 and C#:
- Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * [The "BSD licence"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Grammar conversion to ANTLR v3 and C#:
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */

/** We need to set Rule.referencedPredefinedRuleAttributes before
*  code generation.  This filter looks at an action in context of
@@ -46,79 +46,26 @@ options
filter=true;
}

-@header
-{
-using Antlr3.Tool;
-}
-
-@lexer::namespace{Antlr3.Grammars}
+@namespace{Antlr3.Grammars}

/**	$x.y	x is enclosing rule or rule ref or rule label
*			y is a return value, parameter, or predefined property.
*/
X_Y
-	:	'$' x=ID '.' y=ID {enclosingRule!=null}?
-		{
-			AttributeScope scope = null;
-			string refdRuleName = null;
-			if ( $x.text.Equals(enclosingRule.Name) )
-			{
-				// ref to enclosing rule.
-				refdRuleName = $x.text;
-				scope = enclosingRule.GetLocalAttributeScope($y.text);
-			}
-			else if ( enclosingRule.GetRuleLabel($x.text)!=null )
-			{
-				// ref to rule label
-				Grammar.LabelElementPair pair = enclosingRule.GetRuleLabel($x.text);
-				pair.actionReferencesLabel = true;
-				refdRuleName = pair.referencedRuleName;
-				Rule refdRule = grammar.GetRule(refdRuleName);
-				if ( refdRule!=null )
-				{
-					scope = refdRule.GetLocalAttributeScope($y.text);
-				}
-			}
-			else if ( enclosingRule.GetRuleRefsInAlt(x.Text, outerAltNum)!=null )
-			{
-				// ref to rule referenced in this alt
-				refdRuleName = $x.text;
-				Rule refdRule = grammar.GetRule(refdRuleName);
-				if ( refdRule!=null )
-				{
-					scope = refdRule.GetLocalAttributeScope($y.text);
-				}
-			}
-			if ( scope!=null &&
-				 (scope.isPredefinedRuleScope||scope.isPredefinedLexerRuleScope) )
-			{
-				grammar.ReferenceRuleLabelPredefinedAttribute(refdRuleName);
-				//System.out.println("referenceRuleLabelPredefinedAttribute for "+refdRuleName);
-			}
-		}
+	:	'$' x=ID '.' y=ID {enclosingRule != null}?
+		{HandleAttributeMemberReference($x.text, $y.text);}
;

/** $x	x is an isolated rule label.  Just record that the label was referenced */
X
-	:	'$' ID {enclosingRule!=null && enclosingRule.GetRuleLabel($ID.text)!=null}?
-		{
-			Grammar.LabelElementPair pair = enclosingRule.GetRuleLabel($ID.text);
-			pair.actionReferencesLabel = true;
-		}
+	:	'$' ID {enclosingRule != null && enclosingRule.GetRuleLabel($ID.text) != null}?
+		{HandleRuleLabelReference($ID.text);}
;

/** $y	y is a return value, parameter, or predefined property of current rule */
Y
-	:	'$' ID {enclosingRule!=null && enclosingRule.GetLocalAttributeScope($ID.text)!=null}?
-		{
-			AttributeScope scope = enclosingRule.GetLocalAttributeScope($ID.text);
-			if ( scope!=null &&
-				 (scope.isPredefinedRuleScope||scope.isPredefinedLexerRuleScope) )
-			{
-				grammar.ReferenceRuleLabelPredefinedAttribute(enclosingRule.Name);
-				//System.out.println("referenceRuleLabelPredefinedAttribute for "+$ID.text);
-			}
-		}
+	:	'$' ID {enclosingRule != null && enclosingRule.GetLocalAttributeScope($ID.text) != null}?
+		{HandleAttributeReference($ID.text);}
;

fragment
diff --git a/Antlr3/Grammars/ActionAnalysisLexerHelper.cs b/Antlr3/Grammars/ActionAnalysisLexerHelper.cs
index e0254b6..e08f252 100644
--- a/Antlr3/Grammars/ActionAnalysisLexerHelper.cs
+++ b/Antlr3/Grammars/ActionAnalysisLexerHelper.cs
@@ -1,10 +1,10 @@
/*
* [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Grammar conversion to ANTLR v3 and C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -37,17 +37,17 @@ namespace Antlr3.Grammars

partial class ActionAnalysisLexer
{
-        Rule enclosingRule;
-        Grammar grammar;
-        IToken actionToken;
-        int outerAltNum = 0;
+        private readonly Rule enclosingRule;
+        private readonly Grammar grammar;
+        private readonly IToken actionToken;
+        private readonly int outerAltNum = 0;

-        public ActionAnalysisLexer( Grammar grammar, string ruleName, GrammarAST actionAST )
-            : this( new ANTLRStringStream( actionAST.token.Text ) )
+        public ActionAnalysisLexer(Grammar grammar, string ruleName, GrammarAST actionAST)
+            : this(new ANTLRStringStream(actionAST.Token.Text))
{
this.grammar = grammar;
-            this.enclosingRule = grammar.GetLocallyDefinedRule( ruleName );
-            this.actionToken = actionAST.token;
+            this.enclosingRule = grammar.GetLocallyDefinedRule(ruleName);
+            this.actionToken = actionAST.Token;
this.outerAltNum = actionAST.outerAltNum;
}

@@ -58,7 +58,63 @@ namespace Antlr3.Grammars
do
{
t = NextToken();
-            } while ( t.Type != TokenTypes.EndOfFile );
+            } while (t.Type != TokenTypes.EndOfFile);
+        }
+
+        private void HandleAttributeMemberReference(string attribute, string member)
+        {
+            AttributeScope scope = null;
+            string refdRuleName = null;
+            if (attribute.Equals(enclosingRule.Name))
+            {
+                // ref to enclosing rule.
+                refdRuleName = attribute;
+                scope = enclosingRule.GetLocalAttributeScope(member);
+            }
+            else if (enclosingRule.GetRuleLabel(attribute) != null)
+            {
+                // ref to rule label
+                Grammar.LabelElementPair pair = enclosingRule.GetRuleLabel(attribute);
+                pair.actionReferencesLabel = true;
+                refdRuleName = pair.referencedRuleName;
+                Rule refdRule = grammar.GetRule(refdRuleName);
+                if (refdRule != null)
+                {
+                    scope = refdRule.GetLocalAttributeScope(member);
+                }
+            }
+            else if (enclosingRule.GetRuleRefsInAlt(attribute, outerAltNum) != null)
+            {
+                // ref to rule referenced in this alt
+                refdRuleName = attribute;
+                Rule refdRule = grammar.GetRule(refdRuleName);
+                if (refdRule != null)
+                {
+                    scope = refdRule.GetLocalAttributeScope(member);
+                }
+            }
+
+            if (scope != null && (scope.isPredefinedRuleScope || scope.isPredefinedLexerRuleScope))
+            {
+                grammar.ReferenceRuleLabelPredefinedAttribute(refdRuleName);
+                //System.Console.WriteLine("referenceRuleLabelPredefinedAttribute for " + refdRuleName);
+            }
+        }
+
+        private void HandleRuleLabelReference(string ruleLabel)
+        {
+            Grammar.LabelElementPair pair = enclosingRule.GetRuleLabel(ruleLabel);
+            pair.actionReferencesLabel = true;
+        }
+
+        private void HandleAttributeReference(string attributeName)
+        {
+            AttributeScope scope = enclosingRule.GetLocalAttributeScope(attributeName);
+            if (scope != null && (scope.isPredefinedRuleScope || scope.isPredefinedLexerRuleScope))
+            {
+                grammar.ReferenceRuleLabelPredefinedAttribute(enclosingRule.Name);
+                //System.Console.WriteLine("referenceRuleLabelPredefinedAttribute for " + attributeName);
+            }
}
}
}
diff --git a/Antlr3/Grammars/ActionTranslator.g3 b/Antlr3/Grammars/ActionTranslator.g3
index e54e7c3..4ddff73 100644
--- a/Antlr3/Grammars/ActionTranslator.g3
+++ b/Antlr3/Grammars/ActionTranslator.g3
@@ -37,13 +37,6 @@ options
language=CSharp3;
// try all non-fragment rules in order specified
filter=true;
-	// output=template;  TODO: can we make tokens return templates somehow?
-}
-
-@lexer::header
-{
-using Antlr3.Tool;
-using StringTemplate = Antlr3.ST.StringTemplate;
}

@lexer::namespace{Antlr3.Grammars}
@@ -56,150 +49,27 @@ using StringTemplate = Antlr3.ST.StringTemplate;
* 				;
*/
SET_ENCLOSING_RULE_SCOPE_ATTR
-	:	'$' x=ID '.' y=ID WS? '=' expr=ATTR_VALUE_EXPR ';'
-							{enclosingRule!=null &&
-	                         $x.text.Equals(enclosingRule.Name) &&
-	                         enclosingRule.GetLocalAttributeScope($y.text)!=null}?
-		//{JSystem.@out.println("found \$rule.attr");}
-		{
-			StringTemplate st = null;
-			AttributeScope scope = enclosingRule.GetLocalAttributeScope($y.text);
-			if ( scope.isPredefinedRuleScope )
-			{
-				if ( $y.text.Equals("st") || $y.text.Equals("tree") )
-				{
-					st = Template("ruleSetPropertyRef_"+$y.text);
-					grammar.ReferenceRuleLabelPredefinedAttribute($x.text);
-					st.SetAttribute("scope", $x.text);
-					st.SetAttribute("attr", $y.text);
-					st.SetAttribute("expr", TranslateAction($expr.text));
-				}
-				else
-				{
-					ErrorManager.GrammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
-											  grammar,
-											  actionToken,
-											  $x.text,
-											  $y.text);
-				}
-			}
-			else if ( scope.isPredefinedLexerRuleScope )
-			{
-	    		// this is a better message to emit than the previous one...
-				ErrorManager.GrammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
-										  grammar,
-										  actionToken,
-										  $x.text,
-										  $y.text);
-			}
-			else if ( scope.isParameterScope )
-			{
-				st = Template("parameterSetAttributeRef");
-				st.SetAttribute("attr", scope.GetAttribute($y.text));
-				st.SetAttribute("expr", TranslateAction($expr.text));
-			}
-			else
-			{ // must be return value
-				st = Template("returnSetAttributeRef");
-				st.SetAttribute("ruleDescriptor", enclosingRule);
-				st.SetAttribute("attr", scope.GetAttribute($y.text));
-				st.SetAttribute("expr", TranslateAction($expr.text));
-			}
-		}
+	:	'$' x=ID '.' y=ID WS? '=' expr=ATTR_VALUE_EXPR ';' {CanMatchSetEnclosingRuleScopeAttribute($x.text, $y.text)}?
+		{HandleSetEnclosingRuleScopeAttribute($x.text, $y.text, $expr.text);}
;
+
ENCLOSING_RULE_SCOPE_ATTR
-	:	'$' x=ID '.' y=ID	{enclosingRule!=null &&
-	                         $x.text.Equals(enclosingRule.Name) &&
-	                         enclosingRule.GetLocalAttributeScope($y.text)!=null}?
-		//{JSystem.@out.println("found \$rule.attr");}
-		{
-			if ( IsRuleRefInAlt($x.text) )
-			{
-				ErrorManager.GrammarError(ErrorManager.MSG_RULE_REF_AMBIG_WITH_RULE_IN_ALT,
-										  grammar,
-										  actionToken,
-										  $x.text);
-			}
-			StringTemplate st = null;
-			AttributeScope scope = enclosingRule.GetLocalAttributeScope($y.text);
-			if ( scope.isPredefinedRuleScope )
-			{
-				st = Template("rulePropertyRef_"+$y.text);
-				grammar.ReferenceRuleLabelPredefinedAttribute($x.text);
-				st.SetAttribute("scope", $x.text);
-				st.SetAttribute("attr", $y.text);
-			}
-			else if ( scope.isPredefinedLexerRuleScope )
-			{
-				// perhaps not the most precise error message to use, but...
-				ErrorManager.GrammarError(ErrorManager.MSG_RULE_HAS_NO_ARGS,
-										  grammar,
-										  actionToken,
-										  $x.text);
-			}
-			else if ( scope.isParameterScope )
-			{
-				st = Template("parameterAttributeRef");
-				st.SetAttribute("attr", scope.GetAttribute($y.text));
-			}
-			else
-			{ // must be return value
-				st = Template("returnAttributeRef");
-				st.SetAttribute("ruleDescriptor", enclosingRule);
-				st.SetAttribute("attr", scope.GetAttribute($y.text));
-			}
-		}
+	:	'$' x=ID '.' y=ID	{CanMatchEnclosingRuleScopeAttribute($x.text, $y.text)}?
+		{HandleEnclosingRuleScopeAttribute($x.text, $y.text);}
;

/** Setting $tokenlabel.attr or $tokenref.attr where attr is predefined property of a token is an error. */
SET_TOKEN_SCOPE_ATTR
-	:	'$' x=ID '.' y=ID WS? '='
-							 {enclosingRule!=null && input.LA(1)!='=' &&
-	                         (enclosingRule.GetTokenLabel($x.text)!=null||
-	                          IsTokenRefInAlt($x.text)) &&
-	                         AttributeScope.tokenScope.GetAttribute($y.text)!=null}?
-		//{JSystem.@out.println("found \$tokenlabel.attr or \$tokenref.attr");}
-		{
-			ErrorManager.GrammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
-									  grammar,
-									  actionToken,
-									  $x.text,
-									  $y.text);
-		}
+	:	'$' x=ID '.' y=ID WS? '=' {CanMatchSetTokenScopeAttribute($x.text, $y.text)}?
+		{HandleSetTokenScopeAttribute($x.text, $y.text);}
;

/** $tokenlabel.attr or $tokenref.attr where attr is predefined property of a token.
*  If in lexer grammar, only translate for strings and tokens (rule refs)
*/
TOKEN_SCOPE_ATTR
-	:	'$' x=ID '.' y=ID	{enclosingRule!=null &&
-	                         (enclosingRule.GetTokenLabel($x.text)!=null||
-	                          IsTokenRefInAlt($x.text)) &&
-	                         AttributeScope.tokenScope.GetAttribute($y.text)!=null &&
-	                         (grammar.type!=GrammarType.Lexer ||
-	                         GetElementLabel($x.text).elementRef.token.Type==ANTLRParser.TOKEN_REF ||
-	                         GetElementLabel($x.text).elementRef.token.Type==ANTLRParser.STRING_LITERAL)}?
-		// {JSystem.@out.println("found \$tokenlabel.attr or \$tokenref.attr");}
-		{
-			string label = $x.text;
-			if ( enclosingRule.GetTokenLabel($x.text)==null )
-			{
-				// \$tokenref.attr  gotta get old label or compute new one
-				CheckElementRefUniqueness($x.text, true);
-				label = enclosingRule.GetElementLabel($x.text, outerAltNum, generator);
-				if ( label==null )
-				{
-					ErrorManager.GrammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
-											  grammar,
-											  actionToken,
-											  "\$"+$x.text+"."+$y.text);
-					label = $x.text;
-				}
-			}
-			StringTemplate st = Template("tokenLabelPropertyRef_"+$y.text);
-			st.SetAttribute("scope", label);
-			st.SetAttribute("attr", AttributeScope.tokenScope.GetAttribute($y.text));
-		}
+	:	'$' x=ID '.' y=ID	{CanMatchTokenScopeAttribute($x.text, $y.text)}?
+		{HandleTokenScopeAttribute($x.text, $y.text);}
;

/** Setting $rulelabel.attr or $ruleref.attr where attr is a predefined property is an error
@@ -208,171 +78,33 @@ TOKEN_SCOPE_ATTR
*  attributes declared in scope {} or parameters, return values and the like.
*/
SET_RULE_SCOPE_ATTR
-@init
-{
-Grammar.LabelElementPair pair=null;
-string refdRuleName=null;
-}
-	:	'$' x=ID '.' y=ID WS? '=' {enclosingRule!=null && input.LA(1)!='='}?
-		{
-			pair = enclosingRule.GetRuleLabel($x.text);
-			refdRuleName = $x.text;
-			if ( pair!=null )
-			{
-				refdRuleName = pair.referencedRuleName;
-			}
-		}
-		// supercomplicated because I can't exec the above action.
-		// This asserts that if it's a label or a ref to a rule proceed but only if the attribute
-		// is valid for that rule's scope
-		{(enclosingRule.GetRuleLabel($x.text)!=null || IsRuleRefInAlt($x.text)) &&
-	      GetRuleLabelAttribute(enclosingRule.GetRuleLabel($x.text)!=null?enclosingRule.GetRuleLabel($x.text).referencedRuleName:$x.text,$y.text)!=null}?
-		//{JSystem.@out.println("found set \$rulelabel.attr or \$ruleref.attr: "+$x.text+"."+$y.text);}
-		{
-			ErrorManager.GrammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
-									  grammar,
-									  actionToken,
-									  $x.text,
-									  $y.text);
-		}
+	:	'$' x=ID '.' y=ID WS? '=' {CanMatchSetRuleScopeAttribute($x.text, $y.text)}?
+		{HandleSetRuleScopeAttribute($x.text, $y.text);}
;

/** $rulelabel.attr or $ruleref.attr where attr is a predefined property*/
RULE_SCOPE_ATTR
-@init
-{
-	Grammar.LabelElementPair pair=null;
-	string refdRuleName=null;
-}
-	:	'$' x=ID '.' y=ID {enclosingRule!=null}?
-		{
-		pair = enclosingRule.GetRuleLabel($x.text);
-		refdRuleName = $x.text;
-		if ( pair!=null ) {
-			refdRuleName = pair.referencedRuleName;
-		}
-		}
-		// supercomplicated because I can't exec the above action.
-		// This asserts that if it's a label or a ref to a rule proceed but only if the attribute
-		// is valid for that rule's scope
-		{(enclosingRule.GetRuleLabel($x.text)!=null || IsRuleRefInAlt($x.text)) &&
-	      GetRuleLabelAttribute(enclosingRule.GetRuleLabel($x.text)!=null?enclosingRule.GetRuleLabel($x.text).referencedRuleName:$x.text,$y.text)!=null}?
-		//{JSystem.@out.println("found \$rulelabel.attr or \$ruleref.attr: "+$x.text+"."+$y.text);}
-		{
-			string label = $x.text;
-			if ( pair==null )
-			{
-				// \$ruleref.attr  gotta get old label or compute new one
-				CheckElementRefUniqueness($x.text, false);
-				label = enclosingRule.GetElementLabel($x.text, outerAltNum, generator);
-				if ( label==null )
-				{
-					ErrorManager.GrammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
-											  grammar,
-											  actionToken,
-											  "\$"+$x.text+"."+$y.text);
-					label = $x.text;
-				}
-			}
-			StringTemplate st;
-			Rule refdRule = grammar.GetRule(refdRuleName);
-			AttributeScope scope = refdRule.GetLocalAttributeScope($y.text);
-			if ( scope.isPredefinedRuleScope )
-			{
-				st = Template("ruleLabelPropertyRef_"+$y.text);
-				grammar.ReferenceRuleLabelPredefinedAttribute(refdRuleName);
-				st.SetAttribute("scope", label);
-				st.SetAttribute("attr", $y.text);
-			}
-			else if ( scope.isPredefinedLexerRuleScope )
-			{
-				st = Template("lexerRuleLabelPropertyRef_"+$y.text);
-				grammar.ReferenceRuleLabelPredefinedAttribute(refdRuleName);
-				st.SetAttribute("scope", label);
-				st.SetAttribute("attr", $y.text);
-			}
-			else if ( scope.isParameterScope )
-			{
-				// TODO: error!
-			}
-			else
-			{
-				st = Template("ruleLabelRef");
-				st.SetAttribute("referencedRule", refdRule);
-				st.SetAttribute("scope", label);
-				st.SetAttribute("attr", scope.GetAttribute($y.text));
-			}
-		}
+	:	'$' x=ID '.' y=ID {CanMatchRuleScopeAttribute($x.text, $y.text)}?
+		{HandleRuleScopeAttribute($x.text, $y.text);}
;


/** $label	either a token label or token/rule list label like label+=expr */
LABEL_REF
-	:	'$' ID {enclosingRule!=null &&
-	            GetElementLabel($ID.text)!=null &&
-		        enclosingRule.GetRuleLabel($ID.text)==null}?
-		// {JSystem.@out.println("found \$label");}
-		{
-			StringTemplate st;
-			Grammar.LabelElementPair pair = GetElementLabel($ID.text);
-			if ( pair.type==LabelType.RuleList ||
-				  pair.type==LabelType.TokenList ||
-				  pair.type == LabelType.WildcardTreeList )
-			{
-				st = Template("listLabelRef");
-			}
-			else
-			{
-				st = Template("tokenLabelRef");
-			}
-			st.SetAttribute("label", $ID.text);
-		}
+	:	'$' ID {CanMatchLabelReference($ID.text)}?
+		{HandleLabelReference($ID.text);}
;

/** $tokenref in a non-lexer grammar */
ISOLATED_TOKEN_REF
-	:	'$' ID	{grammar.type!=GrammarType.Lexer && enclosingRule!=null && IsTokenRefInAlt($ID.text)}?
-		//{JSystem.@out.println("found \$tokenref");}
-		{
-			string label = enclosingRule.GetElementLabel($ID.text, outerAltNum, generator);
-			CheckElementRefUniqueness($ID.text, true);
-			if ( label==null )
-			{
-				ErrorManager.GrammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
-										  grammar,
-										  actionToken,
-										  $ID.text);
-			}
-			else
-			{
-				StringTemplate st = Template("tokenLabelRef");
-				st.SetAttribute("label", label);
-			}
-		}
+	:	'$' ID	{CanMatchIsolatedTokenReference($ID.text)}?
+		{HandleIsolatedTokenReference($ID.text);}
;

/** $lexerruleref from within the lexer */
ISOLATED_LEXER_RULE_REF
-	:	'$' ID	{grammar.type==GrammarType.Lexer &&
-	             enclosingRule!=null &&
-	             IsRuleRefInAlt($ID.text)}?
-		//{JSystem.@out.println("found \$lexerruleref");}
-		{
-			string label = enclosingRule.GetElementLabel($ID.text, outerAltNum, generator);
-			CheckElementRefUniqueness($ID.text, false);
-			if ( label==null )
-			{
-				ErrorManager.GrammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
-										  grammar,
-										  actionToken,
-										  $ID.text);
-			}
-			else
-			{
-				StringTemplate st = Template("lexerRuleLabel");
-				st.SetAttribute("label", label);
-			}
-		}
+	:	'$' ID	{CanMatchIsolatedLexerRuleReference($ID.text)}?
+		{HandleIsolatedLexerRuleReference($ID.text);}
;

/**  $y 	return value, parameter, predefined rule property, or token/rule
@@ -387,78 +119,13 @@ ISOLATED_LEXER_RULE_REF
*	TODO: this might get the dynamic scope's elements too.!!!!!!!!!
*/
SET_LOCAL_ATTR
-	:	'$' ID WS? '=' expr=ATTR_VALUE_EXPR ';' {enclosingRule!=null
-													&& enclosingRule.GetLocalAttributeScope($ID.text)!=null
-													&& !enclosingRule.GetLocalAttributeScope($ID.text).isPredefinedLexerRuleScope}?
-		//{JSystem.@out.println("found set \$localattr");}
-		{
-			StringTemplate st;
-			AttributeScope scope = enclosingRule.GetLocalAttributeScope($ID.text);
-			if ( scope.isPredefinedRuleScope )
-			{
-				if ($ID.text.Equals("tree") || $ID.text.Equals("st"))
-				{
-					st = Template("ruleSetPropertyRef_"+$ID.text);
-					grammar.ReferenceRuleLabelPredefinedAttribute(enclosingRule.Name);
-					st.SetAttribute("scope", enclosingRule.Name);
-					st.SetAttribute("attr", $ID.text);
-					st.SetAttribute("expr", TranslateAction($expr.text));
-				}
-				else
-				{
-					ErrorManager.GrammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
-											 grammar,
-											 actionToken,
-											 $ID.text,
-											 "");
-				}
-			}
-			else if ( scope.isParameterScope )
-			{
-				st = Template("parameterSetAttributeRef");
-				st.SetAttribute("attr", scope.GetAttribute($ID.text));
-				st.SetAttribute("expr", TranslateAction($expr.text));
-			}
-			else
-			{
-				st = Template("returnSetAttributeRef");
-				st.SetAttribute("ruleDescriptor", enclosingRule);
-				st.SetAttribute("attr", scope.GetAttribute($ID.text));
-				st.SetAttribute("expr", TranslateAction($expr.text));
-			}
-		}
+	:	'$' ID WS? '=' expr=ATTR_VALUE_EXPR ';' {CanMatchSetLocalAttribute($ID.text)}?
+		{HandleSetLocalAttribute($ID.text, $expr.text);}
;
+
LOCAL_ATTR
-	:	'$' ID {enclosingRule!=null && enclosingRule.GetLocalAttributeScope($ID.text)!=null}?
-		//{JSystem.@out.println("found \$localattr");}
-		{
-			StringTemplate st;
-			AttributeScope scope = enclosingRule.GetLocalAttributeScope($ID.text);
-			if ( scope.isPredefinedRuleScope )
-			{
-				st = Template("rulePropertyRef_"+$ID.text);
-				grammar.ReferenceRuleLabelPredefinedAttribute(enclosingRule.Name);
-				st.SetAttribute("scope", enclosingRule.Name);
-				st.SetAttribute("attr", $ID.text);
-			}
-			else if ( scope.isPredefinedLexerRuleScope )
-			{
-				st = Template("lexerRulePropertyRef_"+$ID.text);
-				st.SetAttribute("scope", enclosingRule.Name);
-				st.SetAttribute("attr", $ID.text);
-			}
-			else if ( scope.isParameterScope )
-			{
-				st = Template("parameterAttributeRef");
-				st.SetAttribute("attr", scope.GetAttribute($ID.text));
-			}
-			else
-			{
-				st = Template("returnAttributeRef");
-				st.SetAttribute("ruleDescriptor", enclosingRule);
-				st.SetAttribute("attr", scope.GetAttribute($ID.text));
-			}
-		}
+	:	'$' ID {CanMatchLocalAttribute($ID.text)}?
+		{HandleLocalAttribute($ID.text);}
;

/**	$x::y	the only way to access the attributes within a dynamic scope
@@ -474,57 +141,20 @@ LOCAL_ATTR
* 				;
*/
SET_DYNAMIC_SCOPE_ATTR
-	:	'$' x=ID '::' y=ID WS? '=' expr=ATTR_VALUE_EXPR ';'
-						   {ResolveDynamicScope($x.text)!=null &&
-						     ResolveDynamicScope($x.text).GetAttribute($y.text)!=null}?
-		//{JSystem.@out.println("found set \$scope::attr "+ $x.text + "::" + $y.text + " to " + $expr.text);}
-		{
-			AttributeScope scope = ResolveDynamicScope($x.text);
-			if ( scope!=null )
-			{
-				StringTemplate st = Template("scopeSetAttributeRef");
-				st.SetAttribute("scope", $x.text);
-				st.SetAttribute("attr",  scope.GetAttribute($y.text));
-				st.SetAttribute("expr",  TranslateAction($expr.text));
-			}
-			else
-			{
-				// error: invalid dynamic attribute
-			}
-		}
+	:	'$' x=ID '::' y=ID WS? '=' expr=ATTR_VALUE_EXPR ';' {CanMatchSetDynamicScopeAttribute($x.text, $y.text)}?
+		{HandleSetDynamicScopeAttribute($x.text, $y.text, $expr.text);}
;

DYNAMIC_SCOPE_ATTR
-	:	'$' x=ID '::' y=ID
-						   {ResolveDynamicScope($x.text)!=null &&
-						     ResolveDynamicScope($x.text).GetAttribute($y.text)!=null}?
-		//{JSystem.@out.println("found \$scope::attr "+ $x.text + "::" + $y.text);}
-		{
-			AttributeScope scope = ResolveDynamicScope($x.text);
-			if ( scope!=null )
-			{
-				StringTemplate st = Template("scopeAttributeRef");
-				st.SetAttribute("scope", $x.text);
-				st.SetAttribute("attr",  scope.GetAttribute($y.text));
-			}
-			else
-			{
-				// error: invalid dynamic attribute
-			}
-		}
+	:	'$' x=ID '::' y=ID {CanMatchDynamicScopeAttribute($x.text, $y.text)}?
+		{HandleDynamicScopeAttribute($x.text, $y.text);}
;

-
ERROR_SCOPED_XY
:	'$' x=ID '::' y=ID
-		{
-		chunks.Add(Text);
-		generator.IssueInvalidScopeError($x.text,$y.text,
-		                                 enclosingRule,actionToken,
-		                                 outerAltNum);
-		}
+		{HandleErrorScopedXY($x.text, $y.text);}
;
-
+
/**		To access deeper (than top of stack) scopes, use the notation:
*
* 		$x[-1]::y previous (just under top of stack)
@@ -535,24 +165,12 @@ ERROR_SCOPED_XY
*/
DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR
:	'$' x=ID '[' '-' expr=SCOPE_INDEX_EXPR ']' '::' y=ID
-		// {JSystem.@out.println("found \$scope[-...]::attr");}
-		{
-			StringTemplate st = Template("scopeAttributeRef");
-			st.SetAttribute("scope",    $x.text);
-			st.SetAttribute("attr",     ResolveDynamicScope($x.text).GetAttribute($y.text));
-			st.SetAttribute("negIndex", $expr.text);
-		}
+		{HandleDynamicNegativeIndexedScopeAttribute($x.text, $y.text, $expr.text);}
;

DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR
:	'$' x=ID '[' expr=SCOPE_INDEX_EXPR ']' '::' y=ID
-		// {JSystem.@out.println("found \$scope[...]::attr");}
-		{
-			StringTemplate st = Template("scopeAttributeRef");
-			st.SetAttribute("scope", $x.text);
-			st.SetAttribute("attr",  ResolveDynamicScope($x.text).GetAttribute($y.text));
-			st.SetAttribute("index", $expr.text);
-		}
+		{HandleDynamicAbsoluteIndexedScopeAttribute($x.text, $y.text, $expr.text);}
;

fragment
@@ -566,12 +184,8 @@ SCOPE_INDEX_EXPR
* 			which would be ambiguous.  See TestAttributes.testAmbiguousRuleRef()
*/
ISOLATED_DYNAMIC_SCOPE
-	:	'$' ID {ResolveDynamicScope($ID.text)!=null}?
-		// {JSystem.@out.println("found isolated \$scope where scope is a dynamic scope");}
-		{
-			StringTemplate st = Template("isolatedDynamicScopeRef");
-			st.SetAttribute("scope", $ID.text);
-		}
+	:	'$' ID {CanMatchIsolatedDynamicScope($ID.text)}?
+		{HandleIsolatedDynamicScope($ID.text);}
;

// antlr.g then codegen.g does these first two currently.
@@ -580,39 +194,13 @@ ISOLATED_DYNAMIC_SCOPE
/** %foo(a={},b={},...) ctor */
TEMPLATE_INSTANCE
:	'%' ID '(' ( WS? ARG (',' WS? ARG)* WS? )? ')'
-		// {JSystem.@out.println("found \%foo(args)");}
-		{
-			string action = $text.Substring( 1, $text.Length - 1 );
-			string ruleName = "<outside-of-rule>";
-			if ( enclosingRule!=null )
-			{
-				ruleName = enclosingRule.Name;
-			}
-			StringTemplate st =
-				generator.TranslateTemplateConstructor(ruleName,
-													   outerAltNum,
-													   actionToken,
-													   action);
-			if ( st!=null )
-			{
-				chunks.Add(st);
-			}
-		}
+		{HandleTemplateInstance($text);}
;

/** %({name-expr})(a={},...) indirect template ctor reference */
INDIRECT_TEMPLATE_INSTANCE
:	'%' '(' ACTION ')' '(' ( WS? ARG (',' WS? ARG)* WS? )? ')'
-		// {JSystem.@out.println("found \%({...})(args)");}
-		{
-			string action = $text.Substring( 1, $text.Length - 1 );
-			StringTemplate st =
-				generator.TranslateTemplateConstructor(enclosingRule.Name,
-													   outerAltNum,
-													   actionToken,
-													   action);
-			chunks.Add(st);
-		}
+		{HandleIndirectTemplateInstance($text);}
;

fragment
@@ -622,15 +210,7 @@ ARG	:	ID '=' ACTION
/**	%{expr}.y = z; template attribute y of StringTemplate-typed expr to z */
SET_EXPR_ATTRIBUTE
:	'%' a=ACTION '.' ID WS? '=' expr=ATTR_VALUE_EXPR ';'
-		// {JSystem.@out.println("found \%{expr}.y = z;");}
-		{
-			StringTemplate st = Template("actionSetAttribute");
-			string action = $a.text;
-			action = action.Substring( 1, action.Length - 2 ); // stuff inside {...}
-			st.SetAttribute("st", TranslateAction(action));
-			st.SetAttribute("attrName", $ID.text);
-			st.SetAttribute("expr", TranslateAction($expr.text));
-		}
+		{HandleSetExpressionAttribute($a.text, $ID.text, $expr.text);}
;

/*    %x.y = z; set template attribute y of x (always set never get attr)
@@ -639,13 +219,7 @@ SET_EXPR_ATTRIBUTE
*/
SET_ATTRIBUTE
:	'%' x=ID '.' y=ID WS? '=' expr=ATTR_VALUE_EXPR ';'
-		// {JSystem.@out.println("found \%x.y = z;");}
-		{
-			StringTemplate st = Template("actionSetAttribute");
-			st.SetAttribute("st", $x.text);
-			st.SetAttribute("attrName", $y.text);
-			st.SetAttribute("expr", TranslateAction($expr.text));
-		}
+		{HandleSetAttribute($x.text, $y.text, $expr.text);}
;

/** Don't allow an = as first char to prevent $x == 3; kind of stuff. */
@@ -656,14 +230,8 @@ ATTR_VALUE_EXPR

/** %{string-expr} anonymous template from string expr */
TEMPLATE_EXPR
-	:	'%' a=ACTION
-		// {JSystem.@out.println("found \%{expr}");}
-		{
-			StringTemplate st = Template("actionStringConstructor");
-			string action = $a.text;
-			action = action.Substring( 1, action.Length - 2 ); // stuff inside {...}
-			st.SetAttribute("stringExpr", TranslateAction(action));
-		}
+	:	'%' ACTION
+		{HandleTemplateExpression($ACTION.text);}
;

fragment
@@ -672,49 +240,28 @@ ACTION
;

ESC
-	:	'\\' '$' {chunks.Add("\$");}
-	|	'\\' '%' {chunks.Add("\%");}
-	|	'\\' ~('$'|'%') {chunks.Add(Text);}
+	:	'\\' c=. {HandleEscape((char)$c);}
;

ERROR_XY
:	'$' x=ID '.' y=ID
-		{
-			chunks.Add(Text);
-			generator.IssueInvalidAttributeError($x.text,$y.text,
-												 enclosingRule,actionToken,
-												 outerAltNum);
-		}
+		{HandleErrorXY($x.text, $y.text);}
;

ERROR_X
:	'$' x=ID
-		{
-			chunks.Add(Text);
-			generator.IssueInvalidAttributeError($x.text,
-												 enclosingRule,actionToken,
-												 outerAltNum);
-		}
+		{HandleErrorX($x.text);}
;

UNKNOWN_SYNTAX
:	'$'
-		{
-			chunks.Add(Text);
-			// shouldn't need an error here.  Just accept \$ if it doesn't look like anything
-		}
+		{HandleUnknownAttributeSyntax();}
|	'%' (ID|'.'|'('|')'|','|'{'|'}'|'"')*
-		{
-			chunks.Add(Text);
-			ErrorManager.GrammarError(ErrorManager.MSG_INVALID_TEMPLATE_ACTION,
-									  grammar,
-									  actionToken,
-									  Text);
-		}
+		{HandleUnknownTemplateSyntax();}
;

TEXT
-	:	~('$'|'%'|'\\')+ {chunks.Add(Text);}
+	:	~('$'|'%'|'\\')+ {HandleText();}
;

fragment
diff --git a/Antlr3/Grammars/ActionTranslatorHelper.cs b/Antlr3/Grammars/ActionTranslatorHelper.cs
index 2a60a49..40f1525 100644
--- a/Antlr3/Grammars/ActionTranslatorHelper.cs
+++ b/Antlr3/Grammars/ActionTranslatorHelper.cs
@@ -46,6 +46,7 @@ namespace Antlr3.Grammars
using IToken = Antlr.Runtime.IToken;
using Rule = Antlr3.Tool.Rule;
using StringBuilder = System.Text.StringBuilder;
+    using StringComparison = System.StringComparison;
using StringTemplate = Antlr3.ST.StringTemplate;
using TokenTypes = Antlr.Runtime.TokenTypes;

@@ -58,27 +59,27 @@ namespace Antlr3.Grammars
CodeGenerator generator;
IToken actionToken;

-        public ActionTranslator( CodeGenerator generator,
+        public ActionTranslator(CodeGenerator generator,
string ruleName,
-                                     GrammarAST actionAST )
-            : this( new ANTLRStringStream( actionAST.Token.Text ) )
+                                     GrammarAST actionAST)
+            : this(new ANTLRStringStream(actionAST.Token.Text))
{
this.generator = generator;
this.grammar = generator.grammar;
-            this.enclosingRule = grammar.GetLocallyDefinedRule( ruleName );
+            this.enclosingRule = grammar.GetLocallyDefinedRule(ruleName);
this.actionToken = actionAST.Token;
this.outerAltNum = actionAST.outerAltNum;
}

-        public ActionTranslator( CodeGenerator generator,
+        public ActionTranslator(CodeGenerator generator,
string ruleName,
IToken actionToken,
-                                     int outerAltNum )
-            : this( new ANTLRStringStream( actionToken.Text ) )
+                                     int outerAltNum)
+            : this(new ANTLRStringStream(actionToken.Text))
{
this.generator = generator;
grammar = generator.grammar;
-            this.enclosingRule = grammar.GetRule( ruleName );
+            this.enclosingRule = grammar.GetRule(ruleName);
this.actionToken = actionToken;
this.outerAltNum = outerAltNum;
}
@@ -93,7 +94,7 @@ namespace Antlr3.Grammars
do
{
t = NextToken();
-            } while ( t.Type != TokenTypes.EndOfFile );
+            } while (t.Type != TokenTypes.EndOfFile);
return chunks;
}

@@ -102,95 +103,617 @@ namespace Antlr3.Grammars
IList theChunks = TranslateToChunks();
//JSystem.@out.println("chunks="+a.chunks);
StringBuilder buf = new StringBuilder();
-            for ( int i = 0; i < theChunks.Count; i++ )
+            for (int i = 0; i < theChunks.Count; i++)
{
object o = (object)theChunks[i];
-                buf.Append( o );
+                buf.Append(o);
}
//JSystem.@out.println("translated: "+buf.toString());
return buf.ToString();
}

-        public IList TranslateAction( string action )
+        public IList TranslateAction(string action)
{
string rname = null;
-            if ( enclosingRule != null )
+            if (enclosingRule != null)
{
rname = enclosingRule.Name;
}
ActionTranslator translator =
-                new ActionTranslator( generator,
+                new ActionTranslator(generator,
rname,
-                                          new CommonToken( ANTLRParser.ACTION, action ), outerAltNum );
+                                          new CommonToken(ANTLRParser.ACTION, action), outerAltNum);
return translator.TranslateToChunks();
}

-        public bool IsTokenRefInAlt( string id )
+        public bool IsTokenRefInAlt(string id)
{
-            return enclosingRule.GetTokenRefsInAlt( id, outerAltNum ) != null;
+            return enclosingRule.GetTokenRefsInAlt(id, outerAltNum) != null;
}
-        public bool IsRuleRefInAlt( string id )
+        public bool IsRuleRefInAlt(string id)
{
-            return enclosingRule.GetRuleRefsInAlt( id, outerAltNum ) != null;
+            return enclosingRule.GetRuleRefsInAlt(id, outerAltNum) != null;
}
-        public Grammar.LabelElementPair GetElementLabel( string id )
+        public Grammar.LabelElementPair GetElementLabel(string id)
{
-            return enclosingRule.GetLabel( id );
+            return enclosingRule.GetLabel(id);
}

-        public void CheckElementRefUniqueness( string @ref, bool isToken )
+        public void CheckElementRefUniqueness(string @ref, bool isToken)
{
IList refs = null;
-            if ( isToken )
+            if (isToken)
{
-                refs = enclosingRule.GetTokenRefsInAlt( @ref, outerAltNum );
+                refs = enclosingRule.GetTokenRefsInAlt(@ref, outerAltNum);
}
else
{
-                refs = enclosingRule.GetRuleRefsInAlt( @ref, outerAltNum );
+                refs = enclosingRule.GetRuleRefsInAlt(@ref, outerAltNum);
}
-            if ( refs != null && refs.Count > 1 )
+            if (refs != null && refs.Count > 1)
{
-                ErrorManager.GrammarError( ErrorManager.MSG_NONUNIQUE_REF,
+                ErrorManager.GrammarError(ErrorManager.MSG_NONUNIQUE_REF,
grammar,
actionToken,
-                                          @ref );
+                                          @ref);
}
}

/** For \$rulelabel.name, return the Attribute found for name.  It
*  will be a predefined property or a return value.
*/
-        public Attribute GetRuleLabelAttribute( string ruleName, string attrName )
+        public Attribute GetRuleLabelAttribute(string ruleName, string attrName)
{
-            Rule r = grammar.GetRule( ruleName );
-            AttributeScope scope = r.GetLocalAttributeScope( attrName );
-            if ( scope != null && !scope.isParameterScope )
+            Rule r = grammar.GetRule(ruleName);
+            AttributeScope scope = r.GetLocalAttributeScope(attrName);
+            if (scope != null && !scope.isParameterScope)
{
-                return scope.GetAttribute( attrName );
+                return scope.GetAttribute(attrName);
}
return null;
}

-        AttributeScope ResolveDynamicScope( string scopeName )
+        private AttributeScope ResolveDynamicScope(string scopeName)
{
-            if ( grammar.GetGlobalScope( scopeName ) != null )
+            if (grammar.GetGlobalScope(scopeName) != null)
{
-                return grammar.GetGlobalScope( scopeName );
+                return grammar.GetGlobalScope(scopeName);
}
-            Rule scopeRule = grammar.GetRule( scopeName );
-            if ( scopeRule != null )
+            Rule scopeRule = grammar.GetRule(scopeName);
+            if (scopeRule != null)
{
return scopeRule.ruleScope;
}
return null; // not a valid dynamic scope
}

-        protected StringTemplate Template( string name )
+        protected StringTemplate Template(string name)
{
-            StringTemplate st = generator.Templates.GetInstanceOf( name );
-            chunks.Add( st );
+            StringTemplate st = generator.Templates.GetInstanceOf(name);
+            chunks.Add(st);
return st;
}
+
+        private bool CanMatchSetEnclosingRuleScopeAttribute(string attribute, string member)
+        {
+            return enclosingRule != null
+                && string.Equals(enclosingRule.Name, attribute, StringComparison.Ordinal)
+                && enclosingRule.GetLocalAttributeScope(member) != null;
+        }
+
+        private void HandleSetEnclosingRuleScopeAttribute(string x, string y, string expr)
+        {
+            StringTemplate st = null;
+            AttributeScope scope = enclosingRule.GetLocalAttributeScope(y);
+            if (scope.isPredefinedRuleScope)
+            {
+                if (y.Equals("st") || y.Equals("tree"))
+                {
+                    st = Template("ruleSetPropertyRef_" + y);
+                    grammar.ReferenceRuleLabelPredefinedAttribute(x);
+                    st.SetAttribute("scope", x);
+                    st.SetAttribute("attr", y);
+                    st.SetAttribute("expr", TranslateAction(expr));
+                }
+                else
+                {
+                    ErrorManager.GrammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR, grammar, actionToken, x, y);
+                }
+            }
+            else if (scope.isPredefinedLexerRuleScope)
+            {
+                // this is a better message to emit than the previous one...
+                ErrorManager.GrammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR, grammar, actionToken, x, y);
+            }
+            else if (scope.isParameterScope)
+            {
+                st = Template("parameterSetAttributeRef");
+                st.SetAttribute("attr", scope.GetAttribute(y));
+                st.SetAttribute("expr", TranslateAction(expr));
+            }
+            else
+            { // must be return value
+                st = Template("returnSetAttributeRef");
+                st.SetAttribute("ruleDescriptor", enclosingRule);
+                st.SetAttribute("attr", scope.GetAttribute(y));
+                st.SetAttribute("expr", TranslateAction(expr));
+            }
+        }
+
+        private bool CanMatchEnclosingRuleScopeAttribute(string x, string y)
+        {
+            return enclosingRule != null
+                && string.Equals(x, enclosingRule.Name, StringComparison.Ordinal)
+                && enclosingRule.GetLocalAttributeScope(y) != null;
+        }
+
+        private void HandleEnclosingRuleScopeAttribute(string x, string y)
+        {
+            if (IsRuleRefInAlt(x))
+            {
+                ErrorManager.GrammarError(ErrorManager.MSG_RULE_REF_AMBIG_WITH_RULE_IN_ALT, grammar, actionToken, x);
+            }
+
+            StringTemplate st = null;
+            AttributeScope scope = enclosingRule.GetLocalAttributeScope(y);
+            if (scope.isPredefinedRuleScope)
+            {
+                st = Template("rulePropertyRef_" + y);
+                grammar.ReferenceRuleLabelPredefinedAttribute(x);
+                st.SetAttribute("scope", x);
+                st.SetAttribute("attr", y);
+            }
+            else if (scope.isPredefinedLexerRuleScope)
+            {
+                // perhaps not the most precise error message to use, but...
+                ErrorManager.GrammarError(ErrorManager.MSG_RULE_HAS_NO_ARGS, grammar, actionToken, x);
+            }
+            else if (scope.isParameterScope)
+            {
+                st = Template("parameterAttributeRef");
+                st.SetAttribute("attr", scope.GetAttribute(y));
+            }
+            else
+            {
+                // must be return value
+                st = Template("returnAttributeRef");
+                st.SetAttribute("ruleDescriptor", enclosingRule);
+                st.SetAttribute("attr", scope.GetAttribute(y));
+            }
+        }
+
+        private bool CanMatchSetTokenScopeAttribute(string x, string y)
+        {
+            return enclosingRule != null
+                && input.LA(1) != '='
+                && (enclosingRule.GetTokenLabel(x) != null || IsTokenRefInAlt(x))
+                && AttributeScope.tokenScope.GetAttribute(y) != null;
+        }
+
+        private void HandleSetTokenScopeAttribute(string x, string y)
+        {
+            ErrorManager.GrammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR, grammar, actionToken, x, y);
+        }
+
+        private bool CanMatchTokenScopeAttribute(string x, string y)
+        {
+            return enclosingRule != null
+                && (enclosingRule.GetTokenLabel(x) != null || IsTokenRefInAlt(x))
+                && AttributeScope.tokenScope.GetAttribute(y) != null
+                && (grammar.type != Tool.GrammarType.Lexer
+                    || GetElementLabel(x).elementRef.Token.Type == ANTLRParser.TOKEN_REF
+                    || GetElementLabel(x).elementRef.Token.Type == ANTLRParser.STRING_LITERAL);
+        }
+
+        private void HandleTokenScopeAttribute(string x, string y)
+        {
+            string label = x;
+            if (enclosingRule.GetTokenLabel(x) == null)
+            {
+                // \tokenref.attr  gotta get old label or compute new one
+                CheckElementRefUniqueness(x, true);
+                label = enclosingRule.GetElementLabel(x, outerAltNum, generator);
+                if (label == null)
+                {
+                    ErrorManager.GrammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF, grammar, actionToken, "$" + x + "." + y);
+                    label = x;
+                }
+            }
+            StringTemplate st = Template("tokenLabelPropertyRef_" + y);
+            st.SetAttribute("scope", label);
+            st.SetAttribute("attr", AttributeScope.tokenScope.GetAttribute(y));
+        }
+
+        private bool CanMatchSetRuleScopeAttribute(string x, string y)
+        {
+            // This asserts that if it's a label or a ref to a rule proceed but only if the attribute
+            // is valid for that rule's scope
+            if (enclosingRule == null || input.LA(1) == '=')
+                return false;
+
+            Grammar.LabelElementPair label = enclosingRule.GetRuleLabel(x);
+            string ruleName = label != null ? label.referencedRuleName : x;
+            string attributeName = y;
+
+            return (label != null || IsRuleRefInAlt(x))
+                && GetRuleLabelAttribute(ruleName, attributeName) != null;
+        }
+
+        private void HandleSetRuleScopeAttribute(string x, string y)
+        {
+            ErrorManager.GrammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR, grammar, actionToken, x, y);
+        }
+
+        private bool CanMatchRuleScopeAttribute(string x, string y)
+        {
+            if (enclosingRule == null)
+                return false;
+
+            Grammar.LabelElementPair label = enclosingRule.GetRuleLabel(x);
+            string ruleName = label != null ? label.referencedRuleName : x;
+            string attributeName = y;
+
+            return (label != null || IsRuleRefInAlt(x))
+                && GetRuleLabelAttribute(ruleName, attributeName) != null;
+        }
+
+        private void HandleRuleScopeAttribute(string x, string y)
+        {
+            Grammar.LabelElementPair pair = enclosingRule.GetRuleLabel(x);
+            string refdRuleName = pair != null ? pair.referencedRuleName : x;
+            string label = x;
+            if (pair == null)
+            {
+                // $ruleref.attr  gotta get old label or compute new one
+                CheckElementRefUniqueness(x, false);
+                label = enclosingRule.GetElementLabel(x, outerAltNum, generator);
+                if (label == null)
+                {
+                    ErrorManager.GrammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF, grammar, actionToken, "$" + x + "." + y);
+                    label = x;
+                }
+            }
+
+            StringTemplate st;
+            Rule refdRule = grammar.GetRule(refdRuleName);
+            AttributeScope scope = refdRule.GetLocalAttributeScope(y);
+            if (scope.isPredefinedRuleScope)
+            {
+                st = Template("ruleLabelPropertyRef_" + y);
+                grammar.ReferenceRuleLabelPredefinedAttribute(refdRuleName);
+                st.SetAttribute("scope", label);
+                st.SetAttribute("attr", y);
+            }
+            else if (scope.isPredefinedLexerRuleScope)
+            {
+                st = Template("lexerRuleLabelPropertyRef_" + y);
+                grammar.ReferenceRuleLabelPredefinedAttribute(refdRuleName);
+                st.SetAttribute("scope", label);
+                st.SetAttribute("attr", y);
+            }
+            else if (scope.isParameterScope)
+            {
+                // TODO: error!
+            }
+            else
+            {
+                st = Template("ruleLabelRef");
+                st.SetAttribute("referencedRule", refdRule);
+                st.SetAttribute("scope", label);
+                st.SetAttribute("attr", scope.GetAttribute(y));
+            }
+        }
+
+        private bool CanMatchLabelReference(string label)
+        {
+            return enclosingRule != null
+                && GetElementLabel(label) != null
+                && enclosingRule.GetRuleLabel(label) == null;
+        }
+
+        private void HandleLabelReference(string label)
+        {
+            StringTemplate st;
+            Grammar.LabelElementPair pair = GetElementLabel(label);
+            if (pair.type == Tool.LabelType.RuleList ||
+                  pair.type == Tool.LabelType.TokenList ||
+                  pair.type == Tool.LabelType.WildcardTreeList)
+            {
+                st = Template("listLabelRef");
+            }
+            else
+            {
+                st = Template("tokenLabelRef");
+            }
+
+            st.SetAttribute("label", label);
+        }
+
+        private bool CanMatchIsolatedTokenReference(string name)
+        {
+            return enclosingRule != null
+                && grammar.type != Tool.GrammarType.Lexer
+                && IsTokenRefInAlt(name);
+        }
+
+        private void HandleIsolatedTokenReference(string name)
+        {
+            string label = enclosingRule.GetElementLabel(name, outerAltNum, generator);
+            CheckElementRefUniqueness(name, true);
+            if (label == null)
+            {
+                ErrorManager.GrammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF, grammar, actionToken, name);
+            }
+            else
+            {
+                StringTemplate st = Template("tokenLabelRef");
+                st.SetAttribute("label", label);
+            }
+        }
+
+        private bool CanMatchIsolatedLexerRuleReference(string name)
+        {
+            return enclosingRule != null
+                && grammar.type == Tool.GrammarType.Lexer
+                && IsRuleRefInAlt(name);
+        }
+
+        private void HandleIsolatedLexerRuleReference(string name)
+        {
+            string label = enclosingRule.GetElementLabel(name, outerAltNum, generator);
+            CheckElementRefUniqueness(name, false);
+            if (label == null)
+            {
+                ErrorManager.GrammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF, grammar, actionToken, name);
+            }
+            else
+            {
+                StringTemplate st = Template("lexerRuleLabel");
+                st.SetAttribute("label", label);
+            }
+        }
+
+        private bool CanMatchSetLocalAttribute(string attributeName)
+        {
+            return enclosingRule != null
+                && enclosingRule.GetLocalAttributeScope(attributeName) != null
+                && !enclosingRule.GetLocalAttributeScope(attributeName).isPredefinedLexerRuleScope;
+        }
+
+        private void HandleSetLocalAttribute(string attributeName, string expr)
+        {
+            StringTemplate st;
+            AttributeScope scope = enclosingRule.GetLocalAttributeScope(attributeName);
+            if (scope.isPredefinedRuleScope)
+            {
+                if (attributeName.Equals("tree") || attributeName.Equals("st"))
+                {
+                    st = Template("ruleSetPropertyRef_" + attributeName);
+                    grammar.ReferenceRuleLabelPredefinedAttribute(enclosingRule.Name);
+                    st.SetAttribute("scope", enclosingRule.Name);
+                    st.SetAttribute("attr", attributeName);
+                    st.SetAttribute("expr", TranslateAction(expr));
+                }
+                else
+                {
+                    ErrorManager.GrammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR, grammar, actionToken, attributeName, "");
+                }
+            }
+            else if (scope.isParameterScope)
+            {
+                st = Template("parameterSetAttributeRef");
+                st.SetAttribute("attr", scope.GetAttribute(attributeName));
+                st.SetAttribute("expr", TranslateAction(expr));
+            }
+            else
+            {
+                st = Template("returnSetAttributeRef");
+                st.SetAttribute("ruleDescriptor", enclosingRule);
+                st.SetAttribute("attr", scope.GetAttribute(attributeName));
+                st.SetAttribute("expr", TranslateAction(expr));
+            }
+        }
+
+        private bool CanMatchLocalAttribute(string name)
+        {
+            return enclosingRule != null
+                && enclosingRule.GetLocalAttributeScope(name) != null;
+        }
+
+        private void HandleLocalAttribute(string name)
+        {
+            StringTemplate st;
+            AttributeScope scope = enclosingRule.GetLocalAttributeScope(name);
+            if (scope.isPredefinedRuleScope)
+            {
+                st = Template("rulePropertyRef_" + name);
+                grammar.ReferenceRuleLabelPredefinedAttribute(enclosingRule.Name);
+                st.SetAttribute("scope", enclosingRule.Name);
+                st.SetAttribute("attr", name);
+            }
+            else if (scope.isPredefinedLexerRuleScope)
+            {
+                st = Template("lexerRulePropertyRef_" + name);
+                st.SetAttribute("scope", enclosingRule.Name);
+                st.SetAttribute("attr", name);
+            }
+            else if (scope.isParameterScope)
+            {
+                st = Template("parameterAttributeRef");
+                st.SetAttribute("attr", scope.GetAttribute(name));
+            }
+            else
+            {
+                st = Template("returnAttributeRef");
+                st.SetAttribute("ruleDescriptor", enclosingRule);
+                st.SetAttribute("attr", scope.GetAttribute(name));
+            }
+        }
+
+        private bool CanMatchSetDynamicScopeAttribute(string x, string y)
+        {
+            AttributeScope dynamicScope = ResolveDynamicScope(x);
+            return dynamicScope != null
+                && dynamicScope.GetAttribute(y) != null;
+        }
+
+        private void HandleSetDynamicScopeAttribute(string x, string y, string expr)
+        {
+            AttributeScope scope = ResolveDynamicScope(x);
+            if (scope != null)
+            {
+                StringTemplate st = Template("scopeSetAttributeRef");
+                st.SetAttribute("scope", x);
+                st.SetAttribute("attr", scope.GetAttribute(y));
+                st.SetAttribute("expr", TranslateAction(expr));
+            }
+            else
+            {
+                // error: invalid dynamic attribute
+            }
+        }
+
+        private bool CanMatchDynamicScopeAttribute(string x, string y)
+        {
+            AttributeScope dynamicScope = ResolveDynamicScope(x);
+            return dynamicScope != null
+                && dynamicScope.GetAttribute(y) != null;
+        }
+
+        private void HandleDynamicScopeAttribute(string x, string y)
+        {
+            AttributeScope scope = ResolveDynamicScope(x);
+            if (scope != null)
+            {
+                StringTemplate st = Template("scopeAttributeRef");
+                st.SetAttribute("scope", x);
+                st.SetAttribute("attr", scope.GetAttribute(y));
+            }
+            else
+            {
+                // error: invalid dynamic attribute
+            }
+        }
+
+        private void HandleErrorScopedXY(string x, string y)
+        {
+            chunks.Add(Text);
+            generator.IssueInvalidScopeError(x, y, enclosingRule, actionToken, outerAltNum);
+        }
+
+        private void HandleDynamicNegativeIndexedScopeAttribute(string x, string y, string expr)
+        {
+            StringTemplate st = Template("scopeAttributeRef");
+            st.SetAttribute("scope", x);
+            st.SetAttribute("attr", ResolveDynamicScope(x).GetAttribute(y));
+            st.SetAttribute("negIndex", expr);
+        }
+
+        private void HandleDynamicAbsoluteIndexedScopeAttribute(string x, string y, string expr)
+        {
+            StringTemplate st = Template("scopeAttributeRef");
+            st.SetAttribute("scope", x);
+            st.SetAttribute("attr", ResolveDynamicScope(x).GetAttribute(y));
+            st.SetAttribute("index", expr);
+        }
+
+        private bool CanMatchIsolatedDynamicScope(string name)
+        {
+            return ResolveDynamicScope(name) != null;
+        }
+
+        private void HandleIsolatedDynamicScope(string name)
+        {
+            StringTemplate st = Template("isolatedDynamicScopeRef");
+            st.SetAttribute("scope", name);
+        }
+
+        private void HandleTemplateInstance(string text)
+        {
+            string action = text.Substring(1, text.Length - 1);
+            string ruleName = "<outside-of-rule>";
+            if (enclosingRule != null)
+                ruleName = enclosingRule.Name;
+
+            StringTemplate st = generator.TranslateTemplateConstructor(ruleName, outerAltNum, actionToken, action);
+            if (st != null)
+                chunks.Add(st);
+        }
+
+        private void HandleIndirectTemplateInstance(string text)
+        {
+            string action = text.Substring(1, text.Length - 1);
+            StringTemplate st = generator.TranslateTemplateConstructor(enclosingRule.Name, outerAltNum, actionToken, action);
+            chunks.Add(st);
+        }
+
+        private void HandleSetExpressionAttribute(string a, string id, string expr)
+        {
+            StringTemplate st = Template("actionSetAttribute");
+            string action = a;
+            action = action.Substring(1, action.Length - 2); // stuff inside {...}
+            st.SetAttribute("st", TranslateAction(action));
+            st.SetAttribute("attrName", ID);
+            st.SetAttribute("expr", TranslateAction(expr));
+        }
+
+        private void HandleSetAttribute(string x, string y, string expr)
+        {
+            StringTemplate st = Template("actionSetAttribute");
+            st.SetAttribute("st", x);
+            st.SetAttribute("attrName", y);
+            st.SetAttribute("expr", TranslateAction(expr));
+        }
+
+        private void HandleTemplateExpression(string action)
+        {
+            StringTemplate st = Template("actionStringConstructor");
+            action = action.Substring(1, action.Length - 2); // stuff inside {...}
+            st.SetAttribute("stringExpr", TranslateAction(action));
+        }
+
+        private void HandleEscape(char escapeChar)
+        {
+            switch (escapeChar)
+            {
+            case '$':
+            case '%':
+                chunks.Add(escapeChar.ToString());
+                return;
+
+            default:
+                chunks.Add(Text);
+                return;
+            }
+        }
+
+        private void HandleErrorXY(string x, string y)
+        {
+            chunks.Add(Text);
+            generator.IssueInvalidAttributeError(x, y, enclosingRule, actionToken, outerAltNum);
+        }
+
+        private void HandleErrorX(string x)
+        {
+            chunks.Add(Text);
+            generator.IssueInvalidAttributeError(x, enclosingRule, actionToken, outerAltNum);
+        }
+
+        private void HandleUnknownAttributeSyntax()
+        {
+            chunks.Add(Text);
+            // shouldn't need an error here.  Just accept \$ if it doesn't look like anything
+        }
+
+        private void HandleUnknownTemplateSyntax()
+        {
+            chunks.Add(Text);
+            ErrorManager.GrammarError(ErrorManager.MSG_INVALID_TEMPLATE_ACTION, grammar, actionToken, Text);
+        }
+
+        private void HandleText()
+        {
+            chunks.Add(Text);
+        }
}
}

