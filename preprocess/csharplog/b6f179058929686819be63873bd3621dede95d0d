commit b6f179058929686819be63873bd3621dede95d0d
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Sun Feb 20 19:29:01 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Sun Feb 20 19:29:01 2011 -0800

(C# 3) Reference Token (property) instead of token (field)

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 7722]

diff --git a/Antlr3/Analysis/MachineProbe.cs b/Antlr3/Analysis/MachineProbe.cs
index e845795..5400b5e 100644
--- a/Antlr3/Analysis/MachineProbe.cs
+++ b/Antlr3/Analysis/MachineProbe.cs
@@ -141,7 +141,7 @@ namespace Antlr3.Analysis
{
if (p.associatedASTNode != null)
{
-                                IToken oldtoken = p.associatedASTNode.token;
+                                IToken oldtoken = p.associatedASTNode.Token;
CommonToken token = new CommonToken(oldtoken.Type, oldtoken.Text);
token.Line = (oldtoken.Line);
token.CharPositionInLine = (oldtoken.CharPositionInLine);
diff --git a/Antlr3/Grammars/DefineGrammarItemsWalker.g3 b/Antlr3/Grammars/DefineGrammarItemsWalker.g3
index 7f07b86..eafe49b 100644
--- a/Antlr3/Grammars/DefineGrammarItemsWalker.g3
+++ b/Antlr3/Grammars/DefineGrammarItemsWalker.g3
@@ -76,7 +76,7 @@ scope AttributeScopeActions;
}
:	^( 'scope' name=ID attrScopeAction* attrs=ACTION )
{
-			AttributeScope scope = grammar.DefineGlobalScope($name.text,$attrs.token);
+			AttributeScope scope = grammar.DefineGlobalScope($name.text,$attrs.Token);
scope.isDynamicGlobalScope = true;
scope.AddAttributes($attrs.text, ';');
foreach ( var action in $AttributeScopeActions::actions )
@@ -169,7 +169,7 @@ rule
if ( Rule.GetRuleType(name) == RuleType.Lexer && grammar.type==GrammarType.Combined )
{
// a merged grammar spec, track lexer rules and send to another grammar
-					grammar.DefineLexerRuleFoundInParser($id.token, $start);
+					grammar.DefineLexerRuleFoundInParser($id.Token, $start);
}
else
{
@@ -183,7 +183,7 @@ rule
}
if ( $ret!=null )
{
-						r.returnScope = grammar.CreateReturnScope(name,$ret.token);
+						r.returnScope = grammar.CreateReturnScope(name,$ret.Token);
r.returnScope.AddAttributes($ret.text, ',');
}
if ( $throwsSpec.exceptions != null )
@@ -239,7 +239,7 @@ scope AttributeScopeActions;
:	^(	'scope'
(	attrScopeAction* attrs=ACTION
{
-					r.ruleScope = grammar.CreateRuleScope(r.Name,$attrs.token);
+					r.ruleScope = grammar.CreateRuleScope(r.Name,$attrs.Token);
r.ruleScope.isDynamicRuleScope = true;
r.ruleScope.AddAttributes($attrs.text, ';');
foreach ( var action in $AttributeScopeActions::actions )
@@ -251,7 +251,7 @@ scope AttributeScopeActions;
if ( grammar.GetGlobalScope($uses.text)==null ) {
ErrorManager.GrammarError(ErrorManager.MSG_UNKNOWN_DYNAMIC_SCOPE,
grammar,
-					$uses.token,
+					$uses.Token,
$uses.text);
}
else {
@@ -345,11 +345,11 @@ element
}
if ( e.Type==RULE_REF)
{
-					grammar.DefineRuleRefLabel(currentRuleName,$id.token,e);
+					grammar.DefineRuleRefLabel(currentRuleName,$id.Token,e);
}
else if ( e.Type==WILDCARD && grammar.type==GrammarType.TreeParser )
{
-					grammar.DefineWildcardTreeLabel(currentRuleName,$id.token,e);
+					grammar.DefineWildcardTreeLabel(currentRuleName,$id.Token,e);
}
else
{
@@ -369,7 +369,7 @@ element
}
else if ( a.Type == WILDCARD && grammar.type == GrammarType.TreeParser )
{
-					grammar.DefineWildcardTreeListLabel( currentRuleName, $id2.token, a );
+					grammar.DefineWildcardTreeListLabel( currentRuleName, $id2.Token, a );
}
else
{
diff --git a/Antlr3/Tool/AssignTokenTypesBehavior.cs b/Antlr3/Tool/AssignTokenTypesBehavior.cs
index c97d2e0..533ffc8 100644
--- a/Antlr3/Tool/AssignTokenTypesBehavior.cs
+++ b/Antlr3/Tool/AssignTokenTypesBehavior.cs
@@ -84,7 +84,7 @@ namespace Antlr3.Tool
{
ErrorManager.GrammarError( ErrorManager.MSG_CANNOT_ALIAS_TOKENS_IN_LEXER,
grammar,
-                                          t.token,
+                                          t.Token,
t.Text );
return;
}
@@ -97,7 +97,7 @@ namespace Antlr3.Tool
{
ErrorManager.GrammarError( ErrorManager.MSG_LITERAL_NOT_ASSOCIATED_WITH_LEXER_RULE,
grammar,
-                                          t.token,
+                                          t.Token,
t.Text );
}
// Don't record literals for lexers, they are things to match not tokens
@@ -198,7 +198,7 @@ namespace Antlr3.Tool
// Allow if both are rules.  Will get DFA nondeterminism error later.
ErrorManager.GrammarError( ErrorManager.MSG_TOKEN_ALIAS_CONFLICT,
grammar,
-                                              t.token,
+                                              t.Token,
tokenID + "=" + literal,
prevAliasLiteralID );
}
@@ -216,7 +216,7 @@ namespace Antlr3.Tool
{
ErrorManager.GrammarError( ErrorManager.MSG_TOKEN_ALIAS_REASSIGNMENT,
grammar,
-                                          t.token,
+                                          t.Token,
tokenID + "=" + literal,
prevAliasTokenID );
return; // don't do the alias
diff --git a/Antlr3/Tool/GrammarAST.cs b/Antlr3/Tool/GrammarAST.cs
index 1a7997d..3338898 100644
--- a/Antlr3/Tool/GrammarAST.cs
+++ b/Antlr3/Tool/GrammarAST.cs
@@ -219,13 +219,13 @@ namespace Antlr3.Tool

public virtual void Initialize( int i, string s )
{
-            token = new CommonToken( i, s );
+            Token = new CommonToken( i, s );
}

public virtual void Initialize( ITree ast )
{
GrammarAST t = ( (GrammarAST)ast );
-            this.token = t.token;
+            this.Token = t.Token;
this.enclosingRuleName = t.enclosingRuleName;
this.TokenStartIndex = ast.TokenStartIndex;
this.TokenStopIndex = ast.TokenStopIndex;
@@ -236,7 +236,7 @@ namespace Antlr3.Tool

public virtual void Initialize( IToken token )
{
-            this.token = token;
+            this.Token = token;
}

/** Save the option key/value pair and process it; return the key
@@ -266,7 +266,7 @@ namespace Antlr3.Tool
{
ErrorManager.GrammarError( ErrorManager.MSG_ILLEGAL_OPTION,
grammar,
-                                          token,
+                                          Token,
key );
return null;
}
@@ -319,28 +319,28 @@ namespace Antlr3.Tool
{
get
{
-                if ( token == null )
+                if ( Token == null )
return string.Empty;

-                return token.Text;
+                return Token.Text;
}
set
{
-                token.Text = value;
+                Token.Text = value;
}
}
public override int Type
{
get
{
-                if ( token == null )
+                if ( Token == null )
return -1;

-                return token.Type;
+                return Token.Type;
}
set
{
-                token.Type = value;
+                Token.Type = value;
}
}
public override int Line
@@ -348,9 +348,9 @@ namespace Antlr3.Tool
get
{
int line = 0;
-                if ( token != null )
+                if ( Token != null )
{
-                    line = token.Line;
+                    line = Token.Line;
}
if ( line == 0 )
{
@@ -364,7 +364,7 @@ namespace Antlr3.Tool
}
set
{
-                token.Line = value;
+                Token.Line = value;
}
}
public override int CharPositionInLine
@@ -372,9 +372,9 @@ namespace Antlr3.Tool
get
{
int col = 0;
-                if ( token != null )
+                if ( Token != null )
{
-                    col = token.CharPositionInLine;
+                    col = Token.CharPositionInLine;
}
if ( col == 0 )
{
@@ -388,7 +388,7 @@ namespace Antlr3.Tool
}
set
{
-                token.CharPositionInLine = value;
+                Token.CharPositionInLine = value;
}
}

@@ -469,13 +469,13 @@ namespace Antlr3.Tool
return a != null && Type == a.Type;
}

-            return token.Line == t.Line &&
-                   token.CharPositionInLine == t.CharPositionInLine;
+            return Token.Line == t.Line &&
+                   Token.CharPositionInLine == t.CharPositionInLine;
}

public override int GetHashCode()
{
-            return ObjectExtensions.ShiftPrimeXOR( token.Line, token.CharPositionInLine );
+            return ObjectExtensions.ShiftPrimeXOR( Token.Line, Token.CharPositionInLine );
}

/** See if tree has exact token types and structure; no text */
diff --git a/Antlr3/Tool/Strip.cs b/Antlr3/Tool/Strip.cs
index a34e361..8224b0c 100644
--- a/Antlr3/Tool/Strip.cs
+++ b/Antlr3/Tool/Strip.cs
@@ -137,8 +137,8 @@ namespace Antlr3.Tool
{
CommonTree a = (CommonTree)t;
a = (CommonTree)a.GetChild( 0 );
-                tokens.Delete( a.token.TokenIndex );
-                KillTrailingNewline( tokens, a.token.TokenIndex );
+                tokens.Delete( a.Token.TokenIndex );
+                KillTrailingNewline( tokens, a.Token.TokenIndex );
} );

// wipe rule return declarations
@@ -146,14 +146,14 @@ namespace Antlr3.Tool
{
CommonTree a = (CommonTree)t;
CommonTree ret = (CommonTree)a.GetChild( 0 );
-                tokens.Delete( a.token.TokenIndex, ret.token.TokenIndex );
+                tokens.Delete( a.Token.TokenIndex, ret.Token.TokenIndex );
} );

// comment out semantic predicates
wiz.Visit( t, ANTLRParser.SEMPRED, ( tree ) =>
{
CommonTree a = (CommonTree)t;
-                tokens.Replace( a.token.TokenIndex, "/*" + a.Text + "*/" );
+                tokens.Replace( a.Token.TokenIndex, "/*" + a.Text + "*/" );
} );

// comment out semantic predicates
@@ -220,18 +220,18 @@ namespace Antlr3.Tool
CommonTree rew = (CommonTree)a.GetChild( 1 );
stop = rew.TokenStopIndex;
}
-                tokens.Delete( a.token.TokenIndex, stop );
+                tokens.Delete( a.Token.TokenIndex, stop );
KillTrailingNewline( tokens, stop );
} );

wiz.Visit( t, ANTLRParser.ROOT, ( tree ) =>
{
-                tokens.Delete( ( (CommonTree)t ).token.TokenIndex );
+                tokens.Delete( ( (CommonTree)t ).Token.TokenIndex );
} );

wiz.Visit( t, ANTLRParser.BANG, ( tree ) =>
{
-                tokens.Delete( ( (CommonTree)t ).token.TokenIndex );
+                tokens.Delete( ( (CommonTree)t ).Token.TokenIndex );
} );
}

@@ -253,7 +253,7 @@ namespace Antlr3.Tool
if ( !char.IsUpper( rule.Text[0] ) )
{
tokens.Delete( t.TokenStartIndex, t.TokenStopIndex );
-                    KillTrailingNewline( tokens, t.token.TokenIndex );
+                    KillTrailingNewline( tokens, t.Token.TokenIndex );
}
}
}
diff --git a/Antlr4.StringTemplate/Compiler/CodeGenerator.g3 b/Antlr4.StringTemplate/Compiler/CodeGenerator.g3
index f75f394..e177470 100644
--- a/Antlr4.StringTemplate/Compiler/CodeGenerator.g3
+++ b/Antlr4.StringTemplate/Compiler/CodeGenerator.g3
@@ -233,7 +233,7 @@ mapTemplateRef[int num_exprs]
|	subtemplate
{
if ($subtemplate.nargs != $num_exprs) {
-            errMgr.CompiletimeError(ErrorType.ANON_ARGUMENT_MISMATCH, templateToken, $subtemplate.start.token, $subtemplate.nargs, $num_exprs);
+            errMgr.CompiletimeError(ErrorType.ANON_ARGUMENT_MISMATCH, templateToken, $subtemplate.start.Token, $subtemplate.nargs, $num_exprs);
}
for (int i=1; i<=$num_exprs; i++) emit($subtemplate.start,Bytecode.INSTR_NULL);
emit2($subtemplate.start, Bytecode.INSTR_NEW,
diff --git a/Antlr4.StringTemplate/Compiler/CompilationState.cs b/Antlr4.StringTemplate/Compiler/CompilationState.cs
index 0df8c3c..ade7b8c 100644
--- a/Antlr4.StringTemplate/Compiler/CompilationState.cs
+++ b/Antlr4.StringTemplate/Compiler/CompilationState.cs
@@ -82,7 +82,7 @@ namespace Antlr4.StringTemplate.Compiler
{
if (Interpreter.predefinedAnonSubtemplateAttributes.Contains(name))
{
-                    errMgr.CompiletimeError(ErrorType.NO_SUCH_ATTRIBUTE, templateToken, id.token);
+                    errMgr.CompiletimeError(ErrorType.NO_SUCH_ATTRIBUTE, templateToken, id.Token);
Emit(id, Bytecode.INSTR_NULL);
}
else
@@ -103,7 +103,7 @@ namespace Antlr4.StringTemplate.Compiler
Bytecode funcBytecode;
if (!TemplateCompiler.funcs.TryGetValue(id.Text, out funcBytecode))
{
-                errMgr.CompiletimeError(ErrorType.NO_SUCH_FUNCTION, templateToken, id.token);
+                errMgr.CompiletimeError(ErrorType.NO_SUCH_FUNCTION, templateToken, id.Token);
Emit(id, Bytecode.INSTR_POP);
}
else

