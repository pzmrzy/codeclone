commit 07f3c7d386680e42070394cfd9c2b67d45b0efca
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Thu Dec 10 19:17:12 2009 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Thu Dec 10 19:17:12 2009 -0800

C# Port:
* Merge CL6342

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 6474]

diff --git a/Antlr3.Test/ST4/TestGroups.cs b/Antlr3.Test/ST4/TestGroups.cs
index 0c8df95..3eb83cc 100644
--- a/Antlr3.Test/ST4/TestGroups.cs
+++ b/Antlr3.Test/ST4/TestGroups.cs
@@ -203,7 +203,7 @@ namespace AntlrUnitTests.ST4
{
error = iae.Message;
}
-            string expected = "name must be of form /group/templatename: /sub/a";
+            string expected = "name must be of form /templatename: /sub/a";
string result = error;
Assert.AreEqual(expected, result);
}
@@ -225,7 +225,7 @@ namespace AntlrUnitTests.ST4
{
error = iae.Message;
}
-            string expected = "name must be of form /group/templatename: /group/b/b";
+            string expected = "name must be of form /templatename: /group/b/b";
string result = error;
Assert.AreEqual(expected, result);
}
@@ -324,6 +324,117 @@ namespace AntlrUnitTests.ST4
string expected = "dir1 b";
string result = st.Render();
Assert.AreEqual(expected, result);
+
+            // do it again, but make a template ref imported template
+            st = group2.GetInstanceOf("a");
+            expected = " dir1 b ";
+            result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestImportTemplateInGroupFileFromDir()
+        {
+            string dir = GetRandomDir();
+            string a = "a() ::= << <b()> >>\n";
+            WriteFile(dir, "a.st", a);
+
+            string groupFile =
+                "b() ::= \"group file b\"\n" +
+                "c() ::= \"group file c\"\n";
+            WriteFile(dir, "group.stg", groupFile);
+
+            TemplateGroup group1 = new TemplateGroupDirectory(dir);
+            TemplateGroup group2 = new TemplateGroupFile(dir + "/group.stg");
+            group1.ImportTemplates(group2);
+            Template st = group1.GetInstanceOf("a");
+            string expected = " group file b ";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestImportTemplateInDirFromGroupFile()
+        {
+            string dir = GetRandomDir();
+            string a = "a() ::= <<dir1 a>>\n";
+            WriteFile(dir, "a.st", a);
+
+            string groupFile =
+                "b() ::= \"<a()>\"\n";
+            WriteFile(dir, "group.stg", groupFile);
+
+            TemplateGroup group1 = new TemplateGroupDirectory(dir);
+            TemplateGroup group2 = new TemplateGroupFile(dir + "/group.stg");
+            group2.ImportTemplates(group1);
+            Template st = group2.GetInstanceOf("b");
+            string expected = "dir1 a";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestImportTemplateInGroupFileFromGroupFile()
+        {
+            string dir = GetRandomDir();
+            string groupFile =
+                "a() ::= \"g1 a\"\n" +
+                "b() ::= \"<c()>\"\n";
+            WriteFile(dir, "group1.stg", groupFile);
+
+            groupFile =
+                "b() ::= \"g2 b\"\n" +
+                "c() ::= \"g2 c\"\n";
+            WriteFile(dir, "group2.stg", groupFile);
+
+            TemplateGroup group1 = new TemplateGroupFile(dir + "/group1.stg");
+            TemplateGroup group2 = new TemplateGroupFile(dir + "/group2.stg");
+            group1.ImportTemplates(group2);
+            Template st = group1.GetInstanceOf("b");
+            string expected = "g2 c";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestImportTemplateFromSubdir()
+        {
+            // /randomdir/x/subdir/a and /randomdir/y/subdir/b
+            string dir = GetRandomDir();
+            string a = "a() ::= << <b()> >>\n";
+            string b = "b() ::= <<x/subdir/b>>\n";
+            WriteFile(dir, "x/subdir/a.st", a);
+            WriteFile(dir, "y/subdir/b.st", b);
+
+            TemplateGroup group1 = new TemplateGroupDirectory(dir + "/x");
+            TemplateGroup group2 = new TemplateGroupDirectory(dir + "/y");
+            group1.ImportTemplates(group2);
+            Template st = group1.GetInstanceOf("/subdir/a");
+            string expected = " x/subdir/b ";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestImportTemplateFromGroupFile()
+        {
+            // /randomdir/x/subdir/a and /randomdir/y/subdir.stg which has a and b
+            string dir = GetRandomDir();
+            string a = "a() ::= << <b()> >>\n"; // get b imported from subdir.stg
+            WriteFile(dir, "x/subdir/a.st", a);
+
+            string groupFile =
+                "a() ::= \"group file a\"\n" +
+                "b() ::= \"group file b\"\n";
+            WriteFile(dir, "y/subdir.stg", groupFile);
+
+            TemplateGroup group1 = new TemplateGroupDirectory(dir + "/x");
+            TemplateGroup group2 = new TemplateGroupDirectory(dir + "/y");
+            group1.ImportTemplates(group2);
+            Template st = group1.GetInstanceOf("/subdir/a");
+            string expected = " group file b ";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
}
}
}
diff --git a/StringTemplate4/TemplateGroup.cs b/StringTemplate4/TemplateGroup.cs
index 052c35a..adf9987 100644
--- a/StringTemplate4/TemplateGroup.cs
+++ b/StringTemplate4/TemplateGroup.cs
@@ -38,6 +38,7 @@ namespace StringTemplate
using Console = System.Console;
using Encoding = System.Text.Encoding;
using Exception = System.Exception;
+    using Path = System.IO.Path;
using StringBuilder = System.Text.StringBuilder;

public class TemplateGroup
@@ -80,8 +81,10 @@ namespace StringTemplate
/** Load files using what encoding? */
public Encoding encoding;

-        // only in root
-        protected IList<TemplateGroup> imports; // OR, supergroups;???
+        /// <summary>
+        /// Every group can import templates/dictionaries from other groups
+        /// </summary>
+        protected IList<TemplateGroup> imports;

public List<string> interfaces;

@@ -185,6 +188,29 @@ namespace StringTemplate
return template;
}

+        protected CompiledTemplate LookupImportedTemplate(string name)
+        {
+            Console.WriteLine("look for " + name + " in " + imports);
+            if (this != root)
+            {
+                // look for absolute template name from root
+                return root.LookupImportedTemplate(GetAbsoluteTemplateName(name));
+            }
+
+            // if we're the root, look for name in imports
+            if (imports == null)
+                return null;
+
+            foreach (var g in imports)
+            {
+                CompiledTemplate code = g.LookupTemplate(name);
+                if (code != null)
+                    return code;
+            }
+
+            return null;
+        }
+
// TODO: send in start/stop char or line/col so errors can be relative
public CompiledTemplate DefineTemplate(string name, string template)
{
@@ -266,10 +292,13 @@ namespace StringTemplate
dictionaries[name] = mapping;
}

-        public void ImportTemplates(TemplateGroup g)
+        /// <summary>
+        /// Make this group import templates/dictionaries from <paramref name="g"/>.
+        /// </summary>
+        public virtual void ImportTemplates(TemplateGroup g)
{
-            if (parent != null || g.parent != null)
-                throw new ArgumentException("can only import tempaltes into/from root groups");
+            if (g == null)
+                return;

if (imports == null)
imports = new List<TemplateGroup>();
@@ -277,17 +306,37 @@ namespace StringTemplate
imports.Add(g);
}

-        /** StringTemplate object factory; each group can have its own. */
+        /// <summary>
+        /// StringTemplate object factory; each group can have its own.
+        /// </summary>
public virtual Template CreateStringTemplate()
{
Template st = new Template();
return st;
}

-        //public string GetPathFromRoot()
-        //{
-        //    return root.fullyQualifiedRootDirName + AbsoluteTemplatePath;
-        //}
+        public string GetAbsoluteTemplateName(string name)
+        {
+            string p = AbsoluteTemplatePath;
+            if (p.Equals("/"))
+                return "/" + name;
+
+            return Path.Combine(p, name);
+        }
+
+        public override bool Equals(object obj)
+        {
+            TemplateGroup group = obj as TemplateGroup;
+            if (group != null)
+                return this.Name == group.Name;
+
+            return false;
+        }
+
+        public override int GetHashCode()
+        {
+            return this.Name.GetHashCode();
+        }

public override string ToString()
{
diff --git a/StringTemplate4/TemplateGroupDirectory.cs b/StringTemplate4/TemplateGroupDirectory.cs
index 1d27bb7..048cbe0 100644
--- a/StringTemplate4/TemplateGroupDirectory.cs
+++ b/StringTemplate4/TemplateGroupDirectory.cs
@@ -117,15 +117,11 @@ namespace StringTemplate
code = LookupTemplateFile(name); // try to load then
if (code == null)
{
-                Console.WriteLine("look for " + name + " in " + imports);
-                foreach (TemplateGroup g in imports)
-                {
-                    code = g.LookupTemplate(Path.Combine(AbsoluteTemplatePath, name));
-                }
-
+                code = LookupImportedTemplate(name);
if (code == null)
{
-                    throw new ArgumentException("no such template: " + Path.Combine(AbsoluteTemplatePath, name));
+                    // TODO: tolerance?
+                    throw new ArgumentException("no such template: " + GetAbsoluteTemplateName(name));
}
}

@@ -170,13 +166,7 @@ namespace StringTemplate
throw new ArgumentException("no such subdirectory or group file: " + names[0]);
}
string allButFirstName = string.Join(Path.DirectorySeparatorChar.ToString(), names.Skip(1).ToArray());
-            CompiledTemplate st = sub.LookupTemplate(allButFirstName);
-            // try list of imports at root
-            if (st == null)
-            {
-                Console.WriteLine("look for " + name + " in " + imports);
-            }
-            return st;
+            return sub.LookupTemplate(allButFirstName);
}

// load from disk
@@ -206,6 +196,38 @@ namespace StringTemplate
return null;
}

+        /// <summary>
+        /// Make this group import tempaltes/dictionaries from <paramref name="g"/>.
+        /// If this group has children, make them import stuff from the children of
+        /// <paramref name="g"/>.
+        /// </summary>
+        public override void ImportTemplates(TemplateGroup g)
+        {
+            if (g == null)
+                return;
+
+            if (imports == null)
+                imports = new List<TemplateGroup>();
+
+            imports.Add(g);
+
+            // now, hook up children. if this has group called x, then look for x in
+            // g's children. if found, then make our x import from g's x.
+#if false
+            TemplateGroupDirectory groupDir = g as TemplateGroupDirectory;
+            if (groupDir != null)
+            {
+                foreach (TemplateGroup child in groupDir)
+                {
+                    CompiledTemplate importedTemplate = groupDir.LookupTemplate(child.Name);
+                    int i = groupDir.children.IndexOf(child);
+                    if (i >= 0)
+                        child.ImportTemplates(groupDir.children[i]);
+                }
+            }
+#endif
+        }
+
public void AddChild(TemplateGroup g)
{
if (children == null)
diff --git a/StringTemplate4/TemplateGroupFile.cs b/StringTemplate4/TemplateGroupFile.cs
index bb254f4..b9e5dca 100644
--- a/StringTemplate4/TemplateGroupFile.cs
+++ b/StringTemplate4/TemplateGroupFile.cs
@@ -45,12 +45,12 @@ namespace StringTemplate

public TemplateGroupFile(string fullyQualifiedFileName)
{
-            if (!Path.GetExtension(fileName).Equals(".stg", StringComparison.OrdinalIgnoreCase))
+            if (!Path.GetExtension(fullyQualifiedFileName).Equals(".stg", StringComparison.OrdinalIgnoreCase))
{
throw new ArgumentException("Group file names must end in .stg: " + fullyQualifiedFileName);
}

-            this.fullyQualifiedRootDirName = Path.GetFullPath(Path.GetDirectoryName(fullyQualifiedRootDirName));
+            this.fullyQualifiedRootDirName = Path.GetFullPath(Path.GetDirectoryName(fullyQualifiedFileName));
this.fileName = Path.GetFileName(fullyQualifiedFileName);
this.parent = null;
this.root = this;
@@ -81,9 +81,6 @@ namespace StringTemplate
{
get
{
-                if (this == root)
-                    return "/" + Name;
-
return base.AbsoluteTemplatePath;
}
}
@@ -103,14 +100,12 @@ namespace StringTemplate
if (this != root)
return root.LookupTemplate(name);
// if no root, name must be "/groupfile/templatename"
-                string[] names = name.Split(new char[] { Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar });
-                //string fname = Path.GetFileName(fileName);
-                //string @base = fname.Substring(0, fname.LastIndexOf('.'));
-                if (names.Length > 2 || !names[0].Equals(Name))
+                string[] names = name.Substring(1).Split(new char[] { Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar });
+                if (names.Length > 1)
{
-                    throw new ArgumentException("name must be of form /" + Name + "/templatename: " + name);
+                    throw new ArgumentException("name must be of form /templatename: " + name);
}
-                name = names[1]; // toss out group part; just get template name
+                name = names[0];
}
if (name.IndexOfAny(new char[] { Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar }) >= 0)
{
@@ -121,11 +116,18 @@ namespace StringTemplate
if (!alreadyLoaded)
Load();

-            CompiledTemplate template;
-            if (!templates.TryGetValue(name, out template))
-                return null;
+            CompiledTemplate code;
+            if (!templates.TryGetValue(name, out code))
+            {
+                code = LookupImportedTemplate(name);
+                if (code == null)
+                {
+                    // TODO: tolerance?
+                    throw new ArgumentException("no such template: /" + GetAbsoluteTemplateName(name));
+                }
+            }

-            return template;
+            return code;
}

public override void Load()
@@ -133,7 +135,11 @@ namespace StringTemplate
if (alreadyLoaded)
return;

-            string absoluteFileName = Path.Combine(root.fullyQualifiedRootDirName, AbsoluteTemplatePath.Substring(1) + ".stg");
+            string absoluteFileName = Path.Combine(root.fullyQualifiedRootDirName, fileName);
+            if (this != root)
+            {
+                absoluteFileName = Path.Combine(root.fullyQualifiedRootDirName, AbsoluteTemplatePath.Substring(1) + ".stg");
+            }

try
{

