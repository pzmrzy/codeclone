commit d9aea0b0be6b56e9a838f32d2547f0cd372290b2
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Wed Sep 30 10:47:19 2009 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Wed Sep 30 10:47:19 2009 -0800

C# Port:
* Regenerated some of the grammars due to new templates
* Mark assemblies CLS Compliant

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 6209]

diff --git a/Antlr3.StringTemplate/Language/ActionEvaluator.cs b/Antlr3.StringTemplate/Language/ActionEvaluator.cs
index 27e0f51..639acce 100644
--- a/Antlr3.StringTemplate/Language/ActionEvaluator.cs
+++ b/Antlr3.StringTemplate/Language/ActionEvaluator.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Language\\ActionEvaluator.g3 2009-04-18 02:24:06
+// $ANTLR 3.1.2 Language\\ActionEvaluator.g3 2009-09-30 13:27:21

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -60,7 +60,7 @@ namespace Antlr3.ST.Language
[System.CLSCompliant(false)]
public partial class ActionEvaluator : TreeParser
{
-	public static readonly string[] tokenNames = new string[] {
+	internal static readonly string[] tokenNames = new string[] {
"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ANONYMOUS_TEMPLATE", "APPLY", "ARGS", "ASSIGN", "COLON", "COMMA", "CONDITIONAL", "DOT", "DOTDOTDOT", "ELSEIF", "ESC_CHAR", "FIRST", "FUNCTION", "ID", "INCLUDE", "INT", "LAST", "LBRACK", "LENGTH", "LIST", "LPAREN", "MULTI_APPLY", "NESTED_ANONYMOUS_TEMPLATE", "NEWLINE", "NOT", "NOTHING", "PLUS", "RBRACK", "REST", "RPAREN", "SEMI", "SINGLEVALUEARG", "STRING", "STRIP", "SUPER", "TEMPLATE", "TEMPLATE_ARGS", "TRUNC", "VALUE", "WS", "WS_CHAR"
};
public const int EOF=-1;
@@ -129,7 +129,6 @@ public partial class ActionEvaluator : TreeParser
// Language\\ActionEvaluator.g3:87:0: public action returns [int numCharsWritten=0] : expr ;
public int action(  )
{
-
int numCharsWritten = 0;

object expr1 = default(object);
@@ -166,7 +165,6 @@ public partial class ActionEvaluator : TreeParser
// Language\\ActionEvaluator.g3:91:0: expr returns [object value] : ( ^( PLUS a= expr b= expr ) | templateApplication | attribute | templateInclude | function | list | ^( VALUE e= expr ) );
private object expr(  )
{
-
object value = default(object);

object a = default(object);
@@ -365,7 +363,6 @@ public partial class ActionEvaluator : TreeParser
// Language\\ActionEvaluator.g3:117:0: list returns [object value=null] : ^( LIST ( expr | NOTHING )+ ) ;
private object list(  )
{
-
object value = null;

object expr7 = default(object);
@@ -466,7 +463,6 @@ public partial class ActionEvaluator : TreeParser
// Language\\ActionEvaluator.g3:140:0: templateInclude returns [object value=null] : ^( INCLUDE (id= ID a1= . | ^( VALUE n= expr a2= . ) ) ) ;
private object templateInclude(  )
{
-
object value = null;

StringTemplateAST id=null;
@@ -567,7 +563,6 @@ public partial class ActionEvaluator : TreeParser
// Language\\ActionEvaluator.g3:167:0: templateApplication returns [object value] : ( ^( APPLY a= expr ( template[templatesToApply] )+ ) | ^( MULTI_APPLY (a= expr )+ COLON anon= ANONYMOUS_TEMPLATE ) );
private object templateApplication(  )
{
-
object value = default(object);

StringTemplateAST anon=null;
@@ -737,7 +732,6 @@ public partial class ActionEvaluator : TreeParser
// Language\\ActionEvaluator.g3:189:0: function returns [object value] : ^( FUNCTION ( 'first' a= singleFunctionArg | 'rest' a= singleFunctionArg | 'last' a= singleFunctionArg | 'length' a= singleFunctionArg | 'strip' a= singleFunctionArg | 'trunc' a= singleFunctionArg ) ) ;
private object function(  )
{
-
object value = default(object);

object a = default(object);
@@ -898,7 +892,6 @@ public partial class ActionEvaluator : TreeParser
// Language\\ActionEvaluator.g3:201:0: singleFunctionArg returns [object value=null] : ^( SINGLEVALUEARG expr ) ;
private object singleFunctionArg(  )
{
-
object value = null;

object expr8 = default(object);
@@ -1077,7 +1070,6 @@ public partial class ActionEvaluator : TreeParser
// Language\\ActionEvaluator.g3:253:0: public ifCondition returns [bool value] : (a= ifAtom | ^( NOT a= ifAtom ) );
public bool ifCondition(  )
{
-
bool value = default(bool);

object a = default(object);
@@ -1153,7 +1145,6 @@ public partial class ActionEvaluator : TreeParser
// Language\\ActionEvaluator.g3:258:0: ifAtom returns [object value] : expr ;
private object ifAtom(  )
{
-
object value = default(object);

object expr10 = default(object);
@@ -1190,7 +1181,6 @@ public partial class ActionEvaluator : TreeParser
// Language\\ActionEvaluator.g3:262:0: attribute returns [object value] : ( ^( DOT obj= expr (prop= ID | ^( VALUE e= expr ) ) ) |i3= ID |i= INT |s= STRING |at= ANONYMOUS_TEMPLATE );
private object attribute(  )
{
-
object value = default(object);

StringTemplateAST prop=null;
@@ -1375,7 +1365,6 @@ public partial class ActionEvaluator : TreeParser
// Language\\ActionEvaluator.g3:309:0: public argList[StringTemplate embedded, System.Collections.Generic.Dictionary<string, object> initialContext] returns [System.Collections.Generic.Dictionary<string, object> argumentContext=null] : ( ^( ARGS ( argumentAssignment[$embedded,$argumentContext] )* ) | singleTemplateArg[$embedded,$argumentContext] );
public System.Collections.Generic.Dictionary<string, object> argList( StringTemplate embedded, System.Collections.Generic.Dictionary<string, object> initialContext )
{
-
System.Collections.Generic.Dictionary<string, object> argumentContext = null;


@@ -1673,7 +1662,6 @@ public partial class ActionEvaluator : TreeParser
// Language\\ActionEvaluator.g3:385:0: public actionFunctional returns [System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,int> func] : exprFunctional ;
public System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,int> actionFunctional(  )
{
-
System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,int> func = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,int>);

System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> exprFunctional12 = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
@@ -1788,7 +1776,6 @@ public partial class ActionEvaluator : TreeParser
// Language\\ActionEvaluator.g3:406:0: public ifConditionFunctional returns [System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,bool> func] : ( ifAtomFunctional | ^( NOT ifAtomFunctional ) );
public System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,bool> ifConditionFunctional(  )
{
-
System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,bool> func = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,bool>);

System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,bool> ifAtomFunctional13 = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,bool>);
@@ -1909,7 +1896,6 @@ public partial class ActionEvaluator : TreeParser
// Language\\ActionEvaluator.g3:430:0: ifAtomFunctional returns [System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,bool> func] : exprFunctional ;
private System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,bool> ifAtomFunctional(  )
{
-
System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,bool> func = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,bool>);

System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> exprFunctional15 = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
@@ -2128,7 +2114,6 @@ public partial class ActionEvaluator : TreeParser
// Language\\ActionEvaluator.g3:459:0: exprFunctional returns [System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> func] : ( ^( PLUS a= exprFunctional b= exprFunctional ) | templateApplicationFunctional | attributeFunctional | templateIncludeFunctional | functionFunctional | listFunctional | ^( VALUE a= exprFunctional ) );
private System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> exprFunctional(  )
{
-
System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> func = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);

System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> a = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
@@ -2541,7 +2526,6 @@ public partial class ActionEvaluator : TreeParser
// Language\\ActionEvaluator.g3:563:0: templateApplicationFunctional returns [System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> func] : ( ^( APPLY a= exprFunctional ( templateFunctional[templateApplicators] )+ ) | ^( MULTI_APPLY (a= exprFunctional )+ COLON ANONYMOUS_TEMPLATE ) );
private System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> templateApplicationFunctional(  )
{
-
System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> func = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);

StringTemplateAST ANONYMOUS_TEMPLATE22=null;
@@ -2919,7 +2903,6 @@ public partial class ActionEvaluator : TreeParser
// Language\\ActionEvaluator.g3:656:0: attributeFunctional returns [System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> func] : ( ^( DOT a= exprFunctional (id= ID | ^( VALUE b= exprFunctional ) ) ) |id= ID | INT | STRING | ANONYMOUS_TEMPLATE );
private System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> attributeFunctional(  )
{
-
System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> func = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);

StringTemplateAST id=null;
@@ -3221,7 +3204,6 @@ public partial class ActionEvaluator : TreeParser
// Language\\ActionEvaluator.g3:737:0: templateIncludeFunctional returns [System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> func] : ^( INCLUDE ( ID args= . | ^( VALUE exprFunctional args= . ) ) ) ;
private System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> templateIncludeFunctional(  )
{
-
System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> func = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);

StringTemplateAST ID30=null;
@@ -3524,7 +3506,6 @@ public partial class ActionEvaluator : TreeParser
// Language\\ActionEvaluator.g3:822:0: functionFunctional returns [System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> func] : ^( FUNCTION ( 'first' a= singleFunctionArgFunctional | 'rest' a= singleFunctionArgFunctional | 'last' a= singleFunctionArgFunctional | 'length' a= singleFunctionArgFunctional | 'strip' a= singleFunctionArgFunctional | 'trunc' a= singleFunctionArgFunctional ) ) ;
private System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> functionFunctional(  )
{
-
System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> func = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);

System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> a = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
@@ -3811,7 +3792,6 @@ public partial class ActionEvaluator : TreeParser
// Language\\ActionEvaluator.g3:893:0: listFunctional returns [System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> func] : ^( LIST ( exprFunctional | NOTHING )+ ) ;
private System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> listFunctional(  )
{
-
System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> func = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);

System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> exprFunctional32 = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
@@ -3958,7 +3938,6 @@ public partial class ActionEvaluator : TreeParser
// Language\\ActionEvaluator.g3:930:0: singleFunctionArgFunctional returns [System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> func] : ^( SINGLEVALUEARG exprFunctional ) ;
private System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> singleFunctionArgFunctional(  )
{
-
System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> func = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);

System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> exprFunctional33 = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
diff --git a/Antlr3.StringTemplate/Language/ActionLexer.cs b/Antlr3.StringTemplate/Language/ActionLexer.cs
index 02ec0f6..c7f1acb 100644
--- a/Antlr3.StringTemplate/Language/ActionLexer.cs
+++ b/Antlr3.StringTemplate/Language/ActionLexer.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Language\\Action.g3 2009-04-18 13:36:20
+// $ANTLR 3.1.2 Language\\Action.g3 2009-09-30 13:22:28

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -547,7 +547,7 @@ public partial class ActionLexer : Lexer
{
int _type = ANONYMOUS_TEMPLATE;
int _channel = DefaultTokenChannel;
-			IToken ESC_CHAR1=null;
+			CommonToken ESC_CHAR1=null;
int ch;


@@ -762,8 +762,8 @@ public partial class ActionLexer : Lexer
{
try
{
-			IToken a=null;
-			IToken a2=null;
+			CommonToken a=null;
+			CommonToken a2=null;


_text = string.Empty; // this template is empty text
@@ -974,7 +974,7 @@ public partial class ActionLexer : Lexer
{
try
{
-			IToken ESC_CHAR2=null;
+			CommonToken ESC_CHAR2=null;
int ch;


@@ -2135,7 +2135,6 @@ public partial class ActionLexer : Lexer
int _s = s;
switch ( s )
{
-
case 0:
int LA5_0 = input.LA(1);

@@ -2154,7 +2153,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 1:
int LA5_1 = input.LA(1);

@@ -2165,7 +2163,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 2:
int LA5_2 = input.LA(1);

@@ -2176,7 +2173,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 3:
int LA5_3 = input.LA(1);

@@ -2189,7 +2185,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 4:
int LA5_4 = input.LA(1);

@@ -2200,7 +2195,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 5:
int LA5_5 = input.LA(1);

@@ -2223,7 +2217,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 6:
int LA5_7 = input.LA(1);

@@ -2234,7 +2227,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 7:
int LA5_8 = input.LA(1);

@@ -2257,7 +2249,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 8:
int LA5_9 = input.LA(1);

@@ -2270,7 +2261,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 9:
int LA5_10 = input.LA(1);

@@ -2283,7 +2273,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 10:
int LA5_11 = input.LA(1);

@@ -2298,7 +2287,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 11:
int LA5_12 = input.LA(1);

@@ -2311,7 +2299,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 12:
int LA5_13 = input.LA(1);

@@ -2330,7 +2317,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 13:
int LA5_14 = input.LA(1);

@@ -2346,7 +2332,6 @@ public partial class ActionLexer : Lexer
input.Seek(index5_14);
if ( s>=0 ) return s;
break;
-
case 14:
int LA5_15 = input.LA(1);

@@ -2359,7 +2344,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 15:
int LA5_16 = input.LA(1);

@@ -2370,7 +2354,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 16:
int LA5_17 = input.LA(1);

@@ -2381,7 +2364,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 17:
int LA5_18 = input.LA(1);

@@ -2394,7 +2376,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 18:
int LA5_19 = input.LA(1);

@@ -2405,7 +2386,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 19:
int LA5_20 = input.LA(1);

@@ -2428,7 +2408,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 20:
int LA5_22 = input.LA(1);

@@ -2439,7 +2418,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 21:
int LA5_23 = input.LA(1);

@@ -2462,7 +2440,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 22:
int LA5_24 = input.LA(1);

@@ -2475,7 +2452,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 23:
int LA5_25 = input.LA(1);

@@ -2488,7 +2464,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 24:
int LA5_26 = input.LA(1);

@@ -2503,7 +2478,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 25:
int LA5_27 = input.LA(1);

@@ -2516,7 +2490,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 26:
int LA5_28 = input.LA(1);

@@ -2606,7 +2579,6 @@ public partial class ActionLexer : Lexer
int _s = s;
switch ( s )
{
-
case 0:
int LA6_0 = input.LA(1);

@@ -2621,7 +2593,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 1:
int LA6_2 = input.LA(1);

@@ -2634,7 +2605,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 2:
int LA6_5 = input.LA(1);

@@ -2650,7 +2620,6 @@ public partial class ActionLexer : Lexer
input.Seek(index6_5);
if ( s>=0 ) return s;
break;
-
case 3:
int LA6_6 = input.LA(1);

@@ -2743,7 +2712,6 @@ public partial class ActionLexer : Lexer
int _s = s;
switch ( s )
{
-
case 0:
int LA12_0 = input.LA(1);

@@ -2758,7 +2726,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 1:
int LA12_2 = input.LA(1);

@@ -2771,7 +2738,6 @@ public partial class ActionLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 2:
int LA12_5 = input.LA(1);

@@ -2787,7 +2753,6 @@ public partial class ActionLexer : Lexer
input.Seek(index12_5);
if ( s>=0 ) return s;
break;
-
case 3:
int LA12_6 = input.LA(1);

diff --git a/Antlr3.StringTemplate/Language/ActionParser.cs b/Antlr3.StringTemplate/Language/ActionParser.cs
index 7b3a2b9..e23fe7d 100644
--- a/Antlr3.StringTemplate/Language/ActionParser.cs
+++ b/Antlr3.StringTemplate/Language/ActionParser.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Language\\Action.g3 2009-07-30 16:11:23
+// $ANTLR 3.1.2 Language\\Action.g3 2009-09-30 13:22:27

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -3710,7 +3710,6 @@ public partial class ActionParser : Parser
int _s = s;
switch ( s )
{
-
case 0:
int LA15_0 = input.LA(1);

@@ -3734,7 +3733,6 @@ public partial class ActionParser : Parser
input.Seek(index15_0);
if ( s>=0 ) return s;
break;
-
case 1:
int LA15_1 = input.LA(1);

@@ -3750,7 +3748,6 @@ public partial class ActionParser : Parser
input.Seek(index15_1);
if ( s>=0 ) return s;
break;
-
case 2:
int LA15_3 = input.LA(1);

diff --git a/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.cs b/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.cs
index ea48415..eca009b 100644
--- a/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.cs
+++ b/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Language\\AngleBracketTemplateLexer.g3 2009-07-30 15:53:49
+// $ANTLR 3.1.2 Language\\AngleBracketTemplateLexer.g3 2009-09-30 13:27:15

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -145,7 +145,7 @@ public partial class AngleBracketTemplateLexer : Lexer
{
int _type = ACTION;
int _channel = DefaultTokenChannel;
-			IToken exp=null;
+			CommonToken exp=null;
int ch;


@@ -1200,7 +1200,7 @@ public partial class AngleBracketTemplateLexer : Lexer
{
int _type = LITERAL;
int _channel = DefaultTokenChannel;
-			IToken ind=null;
+			CommonToken ind=null;
int ch;


@@ -1464,8 +1464,8 @@ public partial class AngleBracketTemplateLexer : Lexer
{
try
{
-			IToken st=null;
-			IToken ESC1=null;
+			CommonToken st=null;
+			CommonToken ESC1=null;
int ch;


@@ -1693,7 +1693,7 @@ public partial class AngleBracketTemplateLexer : Lexer
{
try
{
-			IToken ESC2=null;
+			CommonToken ESC2=null;
int ch;


@@ -2038,10 +2038,10 @@ public partial class AngleBracketTemplateLexer : Lexer
{
try
{
-			IToken a=null;
-			IToken b=null;
-			IToken c=null;
-			IToken d=null;
+			CommonToken a=null;
+			CommonToken b=null;
+			CommonToken c=null;
+			CommonToken d=null;


uc = '\0';
@@ -3027,7 +3027,6 @@ public partial class AngleBracketTemplateLexer : Lexer
int _s = s;
switch ( s )
{
-
case 0:
int LA18_0 = input.LA(1);

@@ -3042,7 +3041,6 @@ public partial class AngleBracketTemplateLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 1:
int LA18_1 = input.LA(1);

@@ -3058,7 +3056,6 @@ public partial class AngleBracketTemplateLexer : Lexer
input.Seek(index18_1);
if ( s>=0 ) return s;
break;
-
case 2:
int LA18_2 = input.LA(1);

@@ -3074,7 +3071,6 @@ public partial class AngleBracketTemplateLexer : Lexer
input.Seek(index18_2);
if ( s>=0 ) return s;
break;
-
case 3:
int LA18_3 = input.LA(1);

@@ -3096,7 +3092,6 @@ public partial class AngleBracketTemplateLexer : Lexer
input.Seek(index18_3);
if ( s>=0 ) return s;
break;
-
case 4:
int LA18_4 = input.LA(1);

@@ -3116,7 +3111,6 @@ public partial class AngleBracketTemplateLexer : Lexer
input.Seek(index18_4);
if ( s>=0 ) return s;
break;
-
case 5:
int LA18_7 = input.LA(1);

@@ -3132,7 +3126,6 @@ public partial class AngleBracketTemplateLexer : Lexer
input.Seek(index18_7);
if ( s>=0 ) return s;
break;
-
case 6:
int LA18_8 = input.LA(1);

@@ -3148,7 +3141,6 @@ public partial class AngleBracketTemplateLexer : Lexer
input.Seek(index18_8);
if ( s>=0 ) return s;
break;
-
case 7:
int LA18_9 = input.LA(1);

@@ -3164,7 +3156,6 @@ public partial class AngleBracketTemplateLexer : Lexer
input.Seek(index18_9);
if ( s>=0 ) return s;
break;
-
case 8:
int LA18_10 = input.LA(1);

@@ -3180,7 +3171,6 @@ public partial class AngleBracketTemplateLexer : Lexer
input.Seek(index18_10);
if ( s>=0 ) return s;
break;
-
case 9:
int LA18_11 = input.LA(1);

@@ -3196,7 +3186,6 @@ public partial class AngleBracketTemplateLexer : Lexer
input.Seek(index18_11);
if ( s>=0 ) return s;
break;
-
case 10:
int LA18_12 = input.LA(1);

@@ -3212,7 +3201,6 @@ public partial class AngleBracketTemplateLexer : Lexer
input.Seek(index18_12);
if ( s>=0 ) return s;
break;
-
case 11:
int LA18_13 = input.LA(1);

@@ -3314,7 +3302,6 @@ public partial class AngleBracketTemplateLexer : Lexer
int _s = s;
switch ( s )
{
-
case 0:
int LA37_0 = input.LA(1);

@@ -3334,7 +3321,6 @@ public partial class AngleBracketTemplateLexer : Lexer
input.Seek(index37_0);
if ( s>=0 ) return s;
break;
-
case 1:
int LA37_1 = input.LA(1);

@@ -3354,7 +3340,6 @@ public partial class AngleBracketTemplateLexer : Lexer
input.Seek(index37_1);
if ( s>=0 ) return s;
break;
-
case 2:
int LA37_2 = input.LA(1);

@@ -3370,7 +3355,6 @@ public partial class AngleBracketTemplateLexer : Lexer
input.Seek(index37_2);
if ( s>=0 ) return s;
break;
-
case 3:
int LA37_3 = input.LA(1);

@@ -3386,7 +3370,6 @@ public partial class AngleBracketTemplateLexer : Lexer
input.Seek(index37_3);
if ( s>=0 ) return s;
break;
-
case 4:
int LA37_5 = input.LA(1);

diff --git a/Antlr3.StringTemplate/Language/GroupParser.cs b/Antlr3.StringTemplate/Language/GroupParser.cs
index 5f5f0b7..96ab089 100644
--- a/Antlr3.StringTemplate/Language/GroupParser.cs
+++ b/Antlr3.StringTemplate/Language/GroupParser.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Language\\Group.g3 2009-04-18 02:24:03
+// $ANTLR 3.1.2 Language\\Group.g3 2009-09-30 13:27:19

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -54,7 +54,7 @@ namespace Antlr3.ST.Language
[System.CLSCompliant(false)]
public partial class GroupParser : Parser
{
-	public static readonly string[] tokenNames = new string[] {
+	internal static readonly string[] tokenNames = new string[] {
"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ANONYMOUS_TEMPLATE", "ASSIGN", "AT", "BIGSTRING", "COLON", "COMMA", "DEFINED_TO_BE", "DOT", "ID", "KWDEFAULT", "KWGROUP", "KWIMPLEMENTS", "LBRACK", "LPAREN", "ML_COMMENT", "OPTIONAL", "PLUS", "RBRACK", "RPAREN", "SEMI", "SL_COMMENT", "STAR", "STRING", "WS"
};
public const int EOF=-1;
@@ -761,7 +761,6 @@ public partial class GroupParser : Parser
// Language\\Group.g3:257:0: map returns [Map mapping=new HashMap()] : LBRACK mapPairs[mapping] RBRACK ;
private Map map(  )
{
-
Map mapping = new HashMap();

try
@@ -1002,7 +1001,6 @@ public partial class GroupParser : Parser
// Language\\Group.g3:276:0: keyValue returns [StringTemplate value=null] : (s1= BIGSTRING |s2= STRING |k= ID {...}?|);
private StringTemplate keyValue(  )
{
-
StringTemplate value = null;

IToken s1=null;
diff --git a/Antlr3.StringTemplate/Language/InterfaceParser.cs b/Antlr3.StringTemplate/Language/InterfaceParser.cs
index 63b6b9e..0a30630 100644
--- a/Antlr3.StringTemplate/Language/InterfaceParser.cs
+++ b/Antlr3.StringTemplate/Language/InterfaceParser.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Language\\Interface.g3 2009-04-18 02:24:02
+// $ANTLR 3.1.2 Language\\Interface.g3 2009-09-30 13:27:17

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -51,7 +51,7 @@ namespace Antlr3.ST.Language
[System.CLSCompliant(false)]
public partial class InterfaceParser : Parser
{
-	public static readonly string[] tokenNames = new string[] {
+	internal static readonly string[] tokenNames = new string[] {
"<invalid>", "<EOR>", "<DOWN>", "<UP>", "COLON", "COMMA", "ID", "INTERFACE", "LPAREN", "ML_COMMENT", "OPTIONAL", "RPAREN", "SEMI", "SL_COMMENT", "WS"
};
public const int EOF=-1;
@@ -251,7 +251,6 @@ public partial class InterfaceParser : Parser
// Language\\Interface.g3:142:0: args returns [System.Collections.Generic.SortedList<string, FormalArgument> args] : a= ID ( COMMA b= ID )* ;
private System.Collections.Generic.SortedList<string, FormalArgument> args(  )
{
-
System.Collections.Generic.SortedList<string, FormalArgument> args = default(System.Collections.Generic.SortedList<string, FormalArgument>);

IToken a=null;
diff --git a/Antlr3.StringTemplate/Language/TemplateLexer.cs b/Antlr3.StringTemplate/Language/TemplateLexer.cs
index 6a80dc0..186287b 100644
--- a/Antlr3.StringTemplate/Language/TemplateLexer.cs
+++ b/Antlr3.StringTemplate/Language/TemplateLexer.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Language\\Template.g3 2009-07-30 16:39:08
+// $ANTLR 3.1.2 Language\\Template.g3 2009-09-30 13:26:49

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -257,7 +257,7 @@ public partial class TemplateLexer : Lexer
{
int _type = ACTION;
int _channel = DefaultTokenChannel;
-			IToken exp=null;
+			CommonToken exp=null;
int ch;


@@ -1311,7 +1311,7 @@ public partial class TemplateLexer : Lexer
{
int _type = LITERAL;
int _channel = DefaultTokenChannel;
-			IToken ind=null;
+			CommonToken ind=null;
int ch;


@@ -1591,8 +1591,8 @@ public partial class TemplateLexer : Lexer
{
try
{
-			IToken st=null;
-			IToken ESC1=null;
+			CommonToken st=null;
+			CommonToken ESC1=null;
int ch;


@@ -1820,7 +1820,7 @@ public partial class TemplateLexer : Lexer
{
try
{
-			IToken ESC2=null;
+			CommonToken ESC2=null;
int ch;


@@ -2223,10 +2223,10 @@ public partial class TemplateLexer : Lexer
{
try
{
-			IToken a=null;
-			IToken b=null;
-			IToken c=null;
-			IToken d=null;
+			CommonToken a=null;
+			CommonToken b=null;
+			CommonToken c=null;
+			CommonToken d=null;


uc = '\0';
@@ -3259,7 +3259,6 @@ public partial class TemplateLexer : Lexer
int _s = s;
switch ( s )
{
-
case 0:
int LA18_0 = input.LA(1);

@@ -3274,7 +3273,6 @@ public partial class TemplateLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 1:
int LA18_1 = input.LA(1);

@@ -3290,7 +3288,6 @@ public partial class TemplateLexer : Lexer
input.Seek(index18_1);
if ( s>=0 ) return s;
break;
-
case 2:
int LA18_2 = input.LA(1);

@@ -3306,7 +3303,6 @@ public partial class TemplateLexer : Lexer
input.Seek(index18_2);
if ( s>=0 ) return s;
break;
-
case 3:
int LA18_3 = input.LA(1);

@@ -3328,7 +3324,6 @@ public partial class TemplateLexer : Lexer
input.Seek(index18_3);
if ( s>=0 ) return s;
break;
-
case 4:
int LA18_4 = input.LA(1);

@@ -3348,7 +3343,6 @@ public partial class TemplateLexer : Lexer
input.Seek(index18_4);
if ( s>=0 ) return s;
break;
-
case 5:
int LA18_7 = input.LA(1);

@@ -3364,7 +3358,6 @@ public partial class TemplateLexer : Lexer
input.Seek(index18_7);
if ( s>=0 ) return s;
break;
-
case 6:
int LA18_8 = input.LA(1);

@@ -3380,7 +3373,6 @@ public partial class TemplateLexer : Lexer
input.Seek(index18_8);
if ( s>=0 ) return s;
break;
-
case 7:
int LA18_9 = input.LA(1);

@@ -3396,7 +3388,6 @@ public partial class TemplateLexer : Lexer
input.Seek(index18_9);
if ( s>=0 ) return s;
break;
-
case 8:
int LA18_10 = input.LA(1);

@@ -3412,7 +3403,6 @@ public partial class TemplateLexer : Lexer
input.Seek(index18_10);
if ( s>=0 ) return s;
break;
-
case 9:
int LA18_11 = input.LA(1);

@@ -3428,7 +3418,6 @@ public partial class TemplateLexer : Lexer
input.Seek(index18_11);
if ( s>=0 ) return s;
break;
-
case 10:
int LA18_12 = input.LA(1);

@@ -3444,7 +3433,6 @@ public partial class TemplateLexer : Lexer
input.Seek(index18_12);
if ( s>=0 ) return s;
break;
-
case 11:
int LA18_13 = input.LA(1);

diff --git a/Antlr3.StringTemplate/Language/TemplateParser.cs b/Antlr3.StringTemplate/Language/TemplateParser.cs
index f38f851..775fc7b 100644
--- a/Antlr3.StringTemplate/Language/TemplateParser.cs
+++ b/Antlr3.StringTemplate/Language/TemplateParser.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Language\\Template.g3 2009-07-30 16:39:08
+// $ANTLR 3.1.2 Language\\Template.g3 2009-09-30 13:26:48

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -474,7 +474,7 @@ public partial class TemplateParser : Parser


#region Follow sets
-	static class Follow
+	private static class Follow
{
public static readonly BitSet _LITERAL_in_template71 = new BitSet(new ulong[]{0x3A2012UL});
public static readonly BitSet _NEWLINE_in_template82 = new BitSet(new ulong[]{0x3A2012UL});
diff --git a/Antlr3.Targets/Antlr3.Targets.ActionScript/ActionScriptTarget.cs b/Antlr3.Targets/Antlr3.Targets.ActionScript/ActionScriptTarget.cs
index 31499c3..65eba7a 100644
--- a/Antlr3.Targets/Antlr3.Targets.ActionScript/ActionScriptTarget.cs
+++ b/Antlr3.Targets/Antlr3.Targets.ActionScript/ActionScriptTarget.cs
@@ -31,6 +31,7 @@
*/
namespace Antlr3.Targets
{
+    using CLSCompliant = System.CLSCompliantAttribute;
using CodeGenerator = Antlr3.Codegen.CodeGenerator;
using Console = System.Console;
using Grammar = Antlr3.Tool.Grammar;
@@ -118,7 +119,8 @@ namespace Antlr3.Targets
*  This is to match how the BitSet constructor works, where the bits are
*  passed in in 32-bit chunks with low-order bits coming first.
*/
-        public override string GetTarget64BitStringFromValue( ulong word )
+        [CLSCompliant(false)]
+        public override string GetTarget64BitStringFromValue(ulong word)
{
StringBuilder buf = new StringBuilder( 22 ); // enough for the two "0x", "," and " "
buf.Append( "0x" );
diff --git a/Antlr3.Targets/Antlr3.Targets.ActionScript/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.ActionScript/Properties/AssemblyInfo.cs
index d21dec6..1fa2728 100644
--- a/Antlr3.Targets/Antlr3.Targets.ActionScript/Properties/AssemblyInfo.cs
+++ b/Antlr3.Targets/Antlr3.Targets.ActionScript/Properties/AssemblyInfo.cs
@@ -30,6 +30,7 @@
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

+using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
@@ -45,6 +46,7 @@ using System.Runtime.InteropServices;
[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2009" )]
[assembly: AssemblyTrademark( "" )]
[assembly: AssemblyCulture( "" )]
+[assembly: CLSCompliant(true)]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
diff --git a/Antlr3.Targets/Antlr3.Targets.C/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.C/Properties/AssemblyInfo.cs
index 6a9df66..fe51ee5 100644
--- a/Antlr3.Targets/Antlr3.Targets.C/Properties/AssemblyInfo.cs
+++ b/Antlr3.Targets/Antlr3.Targets.C/Properties/AssemblyInfo.cs
@@ -30,6 +30,7 @@
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

+using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
@@ -45,6 +46,7 @@ using System.Runtime.InteropServices;
[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2009" )]
[assembly: AssemblyTrademark( "" )]
[assembly: AssemblyCulture( "" )]
+[assembly: CLSCompliant(true)]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.CSharp/Properties/AssemblyInfo.cs
index cff6fe2..79d37e6 100644
--- a/Antlr3.Targets/Antlr3.Targets.CSharp/Properties/AssemblyInfo.cs
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp/Properties/AssemblyInfo.cs
@@ -30,6 +30,7 @@
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

+using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
@@ -45,6 +46,7 @@ using System.Runtime.InteropServices;
[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2009" )]
[assembly: AssemblyTrademark( "" )]
[assembly: AssemblyCulture( "" )]
+[assembly: CLSCompliant(true)]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp2/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.CSharp2/Properties/AssemblyInfo.cs
index 8af9497..e6e2976 100644
--- a/Antlr3.Targets/Antlr3.Targets.CSharp2/Properties/AssemblyInfo.cs
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp2/Properties/AssemblyInfo.cs
@@ -30,6 +30,7 @@
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

+using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
@@ -45,6 +46,7 @@ using System.Runtime.InteropServices;
[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2009" )]
[assembly: AssemblyTrademark( "" )]
[assembly: AssemblyCulture( "" )]
+[assembly: CLSCompliant(true)]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp3/CSharp3Target.cs b/Antlr3.Targets/Antlr3.Targets.CSharp3/CSharp3Target.cs
index 96a89b9..9150583 100644
--- a/Antlr3.Targets/Antlr3.Targets.CSharp3/CSharp3Target.cs
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp3/CSharp3Target.cs
@@ -31,6 +31,7 @@
*/
namespace Antlr3.Targets
{
+    using CLSCompliant = System.CLSCompliantAttribute;
using Target = Antlr3.Codegen.Target;

public class CSharp3Target : Target
@@ -40,7 +41,8 @@ namespace Antlr3.Targets
return "\\x" + v.ToString( "X" );
}

-        public override string GetTarget64BitStringFromValue( ulong word )
+        [CLSCompliant(false)]
+        public override string GetTarget64BitStringFromValue(ulong word)
{
return "0x" + word.ToString( "X" );
}
diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp3/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.CSharp3/Properties/AssemblyInfo.cs
index 24145f4..578bc60 100644
--- a/Antlr3.Targets/Antlr3.Targets.CSharp3/Properties/AssemblyInfo.cs
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp3/Properties/AssemblyInfo.cs
@@ -30,6 +30,7 @@
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

+using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
@@ -45,6 +46,7 @@ using System.Runtime.InteropServices;
[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2009" )]
[assembly: AssemblyTrademark( "" )]
[assembly: AssemblyCulture( "" )]
+[assembly: CLSCompliant(true)]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
diff --git a/Antlr3.Targets/Antlr3.Targets.Cpp/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.Cpp/Properties/AssemblyInfo.cs
index cd0f0f0..c118c06 100644
--- a/Antlr3.Targets/Antlr3.Targets.Cpp/Properties/AssemblyInfo.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Cpp/Properties/AssemblyInfo.cs
@@ -30,6 +30,7 @@
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

+using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
@@ -45,6 +46,7 @@ using System.Runtime.InteropServices;
[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2009" )]
[assembly: AssemblyTrademark( "" )]
[assembly: AssemblyCulture( "" )]
+[assembly: CLSCompliant(true)]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
diff --git a/Antlr3.Targets/Antlr3.Targets.Delphi/DelphiTarget.cs b/Antlr3.Targets/Antlr3.Targets.Delphi/DelphiTarget.cs
index 9bbc7f7..8bc3c33 100644
--- a/Antlr3.Targets/Antlr3.Targets.Delphi/DelphiTarget.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Delphi/DelphiTarget.cs
@@ -33,6 +33,7 @@
*/
namespace Antlr3.Targets
{
+    using CLSCompliant = System.CLSCompliantAttribute;
using CodeGenerator = Antlr3.Codegen.CodeGenerator;
using Grammar = Antlr3.Tool.Grammar;
using Label = Antlr3.Analysis.Label;
@@ -123,7 +124,8 @@ namespace Antlr3.Targets
return buf.ToString();
}

-        public override string GetTarget64BitStringFromValue( ulong word )
+        [CLSCompliant(false)]
+        public override string GetTarget64BitStringFromValue(ulong word)
{
int numHexDigits = 8 * 2;
StringBuilder buf = new StringBuilder( numHexDigits + 2 );
diff --git a/Antlr3.Targets/Antlr3.Targets.Delphi/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.Delphi/Properties/AssemblyInfo.cs
index 6bcb75d..d30065d 100644
--- a/Antlr3.Targets/Antlr3.Targets.Delphi/Properties/AssemblyInfo.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Delphi/Properties/AssemblyInfo.cs
@@ -30,6 +30,7 @@
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

+using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
@@ -45,6 +46,7 @@ using System.Runtime.InteropServices;
[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2009" )]
[assembly: AssemblyTrademark( "" )]
[assembly: AssemblyCulture( "" )]
+[assembly: CLSCompliant(true)]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
diff --git a/Antlr3.Targets/Antlr3.Targets.Java/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.Java/Properties/AssemblyInfo.cs
index f2acdcd..b142d5d 100644
--- a/Antlr3.Targets/Antlr3.Targets.Java/Properties/AssemblyInfo.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Java/Properties/AssemblyInfo.cs
@@ -30,6 +30,7 @@
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

+using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
@@ -45,6 +46,7 @@ using System.Runtime.InteropServices;
[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2009" )]
[assembly: AssemblyTrademark( "" )]
[assembly: AssemblyCulture( "" )]
+[assembly: CLSCompliant(true)]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
diff --git a/Antlr3.Targets/Antlr3.Targets.JavaScript/JavaScriptTarget.cs b/Antlr3.Targets/Antlr3.Targets.JavaScript/JavaScriptTarget.cs
index d81d88f..1eacbfc 100644
--- a/Antlr3.Targets/Antlr3.Targets.JavaScript/JavaScriptTarget.cs
+++ b/Antlr3.Targets/Antlr3.Targets.JavaScript/JavaScriptTarget.cs
@@ -31,6 +31,7 @@
*/
namespace Antlr3.Targets
{
+    using CLSCompliant = System.CLSCompliantAttribute;
using StringBuilder = System.Text.StringBuilder;
using Target = Antlr3.Codegen.Target;

@@ -60,6 +61,7 @@ namespace Antlr3.Targets
*
*  Note: stole the following two methods from the ActionScript target.
*/
+        [CLSCompliant(false)]
public override string GetTarget64BitStringFromValue( ulong word )
{
StringBuilder buf = new StringBuilder( 22 ); // enough for the two "0x", "," and " "
diff --git a/Antlr3.Targets/Antlr3.Targets.JavaScript/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.JavaScript/Properties/AssemblyInfo.cs
index 7aa698c..b1a5e89 100644
--- a/Antlr3.Targets/Antlr3.Targets.JavaScript/Properties/AssemblyInfo.cs
+++ b/Antlr3.Targets/Antlr3.Targets.JavaScript/Properties/AssemblyInfo.cs
@@ -30,6 +30,7 @@
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

+using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
@@ -45,6 +46,7 @@ using System.Runtime.InteropServices;
[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2009" )]
[assembly: AssemblyTrademark( "" )]
[assembly: AssemblyCulture( "" )]
+[assembly: CLSCompliant(true)]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
diff --git a/Antlr3.Targets/Antlr3.Targets.ObjC/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.ObjC/Properties/AssemblyInfo.cs
index 9b66944..049d84a 100644
--- a/Antlr3.Targets/Antlr3.Targets.ObjC/Properties/AssemblyInfo.cs
+++ b/Antlr3.Targets/Antlr3.Targets.ObjC/Properties/AssemblyInfo.cs
@@ -30,6 +30,7 @@
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

+using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
@@ -45,6 +46,7 @@ using System.Runtime.InteropServices;
[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2009" )]
[assembly: AssemblyTrademark( "" )]
[assembly: AssemblyCulture( "" )]
+[assembly: CLSCompliant(true)]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
diff --git a/Antlr3.Targets/Antlr3.Targets.Perl5/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.Perl5/Properties/AssemblyInfo.cs
index c9eb1df..ea9fc53 100644
--- a/Antlr3.Targets/Antlr3.Targets.Perl5/Properties/AssemblyInfo.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Perl5/Properties/AssemblyInfo.cs
@@ -30,6 +30,7 @@
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

+using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
@@ -45,6 +46,7 @@ using System.Runtime.InteropServices;
[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2009" )]
[assembly: AssemblyTrademark( "" )]
[assembly: AssemblyCulture( "" )]
+[assembly: CLSCompliant(true)]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
diff --git a/Antlr3.Targets/Antlr3.Targets.Python/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.Python/Properties/AssemblyInfo.cs
index 9e3003c..a7d4059 100644
--- a/Antlr3.Targets/Antlr3.Targets.Python/Properties/AssemblyInfo.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Python/Properties/AssemblyInfo.cs
@@ -30,6 +30,7 @@
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

+using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
@@ -45,6 +46,7 @@ using System.Runtime.InteropServices;
[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2009" )]
[assembly: AssemblyTrademark( "" )]
[assembly: AssemblyCulture( "" )]
+[assembly: CLSCompliant(true)]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
diff --git a/Antlr3.Targets/Antlr3.Targets.Ruby/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.Ruby/Properties/AssemblyInfo.cs
index 434f098..a91151f 100644
--- a/Antlr3.Targets/Antlr3.Targets.Ruby/Properties/AssemblyInfo.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Ruby/Properties/AssemblyInfo.cs
@@ -30,6 +30,7 @@
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

+using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
@@ -45,6 +46,7 @@ using System.Runtime.InteropServices;
[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2009" )]
[assembly: AssemblyTrademark( "" )]
[assembly: AssemblyCulture( "" )]
+[assembly: CLSCompliant(true)]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
diff --git a/Antlr3/Analysis/DFA.cs b/Antlr3/Analysis/DFA.cs
index ade12c3..e5cae36 100644
--- a/Antlr3/Analysis/DFA.cs
+++ b/Antlr3/Analysis/DFA.cs
@@ -321,6 +321,7 @@ namespace Antlr3.Analysis
return _decisionNFAStartState.associatedASTNode;
}
}
+        [CLSCompliant(false)]
public int DecisionNumber
{
get
diff --git a/Antlr3/Analysis/Label.cs b/Antlr3/Analysis/Label.cs
index 8be998d..a8a639c 100644
--- a/Antlr3/Analysis/Label.cs
+++ b/Antlr3/Analysis/Label.cs
@@ -32,6 +32,7 @@

namespace Antlr3.Analysis
{
+    using CLSCompliant = System.CLSCompliantAttribute;
using Grammar = Antlr3.Tool.Grammar;
using ICloneable = System.ICloneable;
using IComparable = System.IComparable;
@@ -209,6 +210,7 @@ namespace Antlr3.Analysis
return null;
}
}
+        [CLSCompliant(false)]
public virtual IIntSet Set
{
get
diff --git a/Antlr3/Analysis/SemanticContext.cs b/Antlr3/Analysis/SemanticContext.cs
index 62e9ae3..467522c 100644
--- a/Antlr3/Analysis/SemanticContext.cs
+++ b/Antlr3/Analysis/SemanticContext.cs
@@ -36,6 +36,7 @@ namespace Antlr3.Analysis
using Antlr.Runtime.JavaExtensions;

using ANTLRParser = Antlr3.Grammars.ANTLRParser;
+    using CLSCompliant = System.CLSCompliantAttribute;
using CodeGenerator = Antlr3.Codegen.CodeGenerator;
using Grammar = Antlr3.Tool.Grammar;
using GrammarAST = Antlr3.Tool.GrammarAST;
@@ -539,7 +540,8 @@ namespace Antlr3.Analysis
}
}

-        public static SemanticContext And( SemanticContext a, SemanticContext b )
+        [CLSCompliant(false)]
+        public static SemanticContext And(SemanticContext a, SemanticContext b)
{
//System.Console.Out.WriteLine( "AND: " + a + "&&" + b );
if ( a == EmptySemanticContext || a == null )
@@ -558,7 +560,8 @@ namespace Antlr3.Analysis
return new AND( a, b );
}

-        public static SemanticContext Or( SemanticContext a, SemanticContext b )
+        [CLSCompliant(false)]
+        public static SemanticContext Or(SemanticContext a, SemanticContext b)
{
//System.Console.Out.WriteLine( "OR: " + a + "||" + b );
if ( a == EmptySemanticContext || a == null )
@@ -603,7 +606,8 @@ namespace Antlr3.Analysis
return new OR( a, b );
}

-        public static SemanticContext Not( SemanticContext a )
+        [CLSCompliant(false)]
+        public static SemanticContext Not(SemanticContext a)
{
NOT nota = a as NOT;
if ( nota != null )
diff --git a/Antlr3/Analysis/Transition.cs b/Antlr3/Analysis/Transition.cs
index c126689..b649ea5 100644
--- a/Antlr3/Analysis/Transition.cs
+++ b/Antlr3/Analysis/Transition.cs
@@ -62,6 +62,7 @@ namespace Antlr3.Analysis
}

#region Properties
+        [CLSCompliant(false)]
public Label Label
{
get
@@ -69,6 +70,7 @@ namespace Antlr3.Analysis
return label;
}
}
+        [CLSCompliant(false)]
public State Target
{
get
diff --git a/Antlr3/Codegen/CodeGenerator.cs b/Antlr3/Codegen/CodeGenerator.cs
index 2a2096a..91dfed9 100644
--- a/Antlr3/Codegen/CodeGenerator.cs
+++ b/Antlr3/Codegen/CodeGenerator.cs
@@ -45,6 +45,7 @@ namespace Antlr3.Codegen
using ArgumentException = System.ArgumentException;
using AttributeScope = Antlr3.Tool.AttributeScope;
using BitSet = Antlr3.Misc.BitSet;
+    using CLSCompliant = System.CLSCompliantAttribute;
using CommonGroupLoader = Antlr3.ST.CommonGroupLoader;
using CommonToken = Antlr.Runtime.CommonToken;
using DateTime = System.DateTime;
@@ -194,6 +195,7 @@ namespace Antlr3.Codegen
}

#region Properties
+        [CLSCompliant(false)]
public StringTemplateGroup BaseTemplates
{
get
@@ -201,6 +203,7 @@ namespace Antlr3.Codegen
return baseTemplates;
}
}
+        [CLSCompliant(false)]
public StringTemplate RecognizerST
{
get
@@ -208,6 +211,7 @@ namespace Antlr3.Codegen
return outputFileST;
}
}
+        [CLSCompliant(false)]
public StringTemplateGroup Templates
{
get
@@ -222,6 +226,7 @@ namespace Antlr3.Codegen
return GetVocabFileName();
}
}
+        [CLSCompliant(false)]
public bool Debug
{
get
@@ -233,6 +238,7 @@ namespace Antlr3.Codegen
debug = value;
}
}
+        [CLSCompliant(false)]
public bool Profile
{
get
@@ -249,6 +255,7 @@ namespace Antlr3.Codegen
}
}
}
+        [CLSCompliant(false)]
public bool Trace
{
get
diff --git a/Antlr3/Codegen/Target.cs b/Antlr3/Codegen/Target.cs
index 9fa3ec2..6282fdb 100644
--- a/Antlr3/Codegen/Target.cs
+++ b/Antlr3/Codegen/Target.cs
@@ -36,6 +36,7 @@ namespace Antlr3.Codegen

using AntlrTool = Antlr3.AntlrTool;
using ArgumentException = System.ArgumentException;
+    using CLSCompliant = System.CLSCompliantAttribute;
using Grammar = Antlr3.Tool.Grammar;
using GrammarType = Antlr3.Tool.GrammarType;
using IList = System.Collections.IList;
@@ -368,6 +369,7 @@ namespace Antlr3.Codegen
/** Convert long to 0xNNNNNNNNNNNNNNNN by default for spitting out
*  with bitsets.  I.e., convert bytes to hex string.
*/
+        [CLSCompliant(false)]
public virtual string GetTarget64BitStringFromValue( ulong word )
{
int numHexDigits = 8 * 2;
diff --git a/Antlr3/Grammars/ANTLRLexer.cs b/Antlr3/Grammars/ANTLRLexer.cs
index f152a27..9c8ad0a 100644
--- a/Antlr3/Grammars/ANTLRLexer.cs
+++ b/Antlr3/Grammars/ANTLRLexer.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Grammars\\ANTLR.g3 2009-04-24 11:17:05
+// $ANTLR 3.1.2 Grammars\\ANTLR.g3 2009-09-30 13:27:50

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -52,6 +52,8 @@ using Map = System.Collections.IDictionary;
using HashMap = System.Collections.Generic.Dictionary<object, object>;
namespace Antlr3.Grammars
{
+[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.1.2")]
+[System.CLSCompliant(false)]
public partial class ANTLRLexer : Lexer
{
public const int EOF=-1;
@@ -2064,8 +2066,8 @@ public partial class ANTLRLexer : Lexer
{
try
{
-			IToken ACTION_STRING_LITERAL1=null;
-			IToken ACTION_CHAR_LITERAL2=null;
+			CommonToken ACTION_STRING_LITERAL1=null;
+			CommonToken ACTION_CHAR_LITERAL2=null;
int c;


@@ -2858,8 +2860,8 @@ public partial class ANTLRLexer : Lexer
{
try
{
-			IToken file=null;
-			IToken line=null;
+			CommonToken file=null;
+			CommonToken line=null;

// Grammars\\ANTLR.g3:1111:4: ( 'src' ' ' file= ACTION_STRING_LITERAL ' ' line= INT )
// Grammars\\ANTLR.g3:1111:4: 'src' ' ' file= ACTION_STRING_LITERAL ' ' line= INT
@@ -3492,7 +3494,6 @@ public partial class ANTLRLexer : Lexer
int _s = s;
switch ( s )
{
-
case 0:
int LA9_14 = input.LA(1);

@@ -3511,7 +3512,6 @@ public partial class ANTLRLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 1:
int LA9_15 = input.LA(1);

@@ -3530,7 +3530,6 @@ public partial class ANTLRLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 2:
int LA9_16 = input.LA(1);

@@ -3550,7 +3549,6 @@ public partial class ANTLRLexer : Lexer
input.Seek(index9_16);
if ( s>=0 ) return s;
break;
-
case 3:
int LA9_18 = input.LA(1);

@@ -3570,7 +3568,6 @@ public partial class ANTLRLexer : Lexer
input.Seek(index9_18);
if ( s>=0 ) return s;
break;
-
case 4:
int LA9_19 = input.LA(1);

@@ -3589,7 +3586,6 @@ public partial class ANTLRLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 5:
int LA9_20 = input.LA(1);

@@ -3608,7 +3604,6 @@ public partial class ANTLRLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 6:
int LA9_21 = input.LA(1);

@@ -3627,7 +3622,6 @@ public partial class ANTLRLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 7:
int LA9_22 = input.LA(1);

@@ -3647,7 +3641,6 @@ public partial class ANTLRLexer : Lexer
input.Seek(index9_22);
if ( s>=0 ) return s;
break;
-
case 8:
int LA9_23 = input.LA(1);

@@ -3667,7 +3660,6 @@ public partial class ANTLRLexer : Lexer
input.Seek(index9_23);
if ( s>=0 ) return s;
break;
-
case 9:
int LA9_24 = input.LA(1);

@@ -3686,7 +3678,6 @@ public partial class ANTLRLexer : Lexer

if ( s>=0 ) return s;
break;
-
case 10:
int LA9_29 = input.LA(1);

diff --git a/Antlr3/Grammars/ANTLRParser.cs b/Antlr3/Grammars/ANTLRParser.cs
index 0026f3a..dcc09c2 100644
--- a/Antlr3/Grammars/ANTLRParser.cs
+++ b/Antlr3/Grammars/ANTLRParser.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Grammars\\ANTLR.g3 2009-05-07 18:09:39
+// $ANTLR 3.1.2 Grammars\\ANTLR.g3 2009-09-30 13:27:49

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -76,6 +76,8 @@ namespace Antlr3.Grammars
*  University of San Francisco
*  2005
*/
+[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.1.2")]
+[System.CLSCompliant(false)]
public partial class ANTLRParser : Parser
{
internal static readonly string[] tokenNames = new string[] {
@@ -10164,7 +10166,7 @@ public partial class ANTLRParser : Parser
LT(2).CharPositionInLine+1==LT(3).CharPositionInLine)) )
{
if (state.backtracking>0) {state.failed=true; return ;}
-			throw new FailedPredicateException(input, "synpred1_ANTLR", "LT(1).CharPositionInLine+LT(1).Text.Length==LT(2).CharPositionInLine&&\n\t\t\t LT(2).CharPositionInLine+1==LT(3).CharPositionInLine");
+			throw new FailedPredicateException(input, "synpred1_ANTLR", "LT(1).CharPositionInLine+LT(1).Text.Length==LT(2).CharPositionInLine&&\r\n\t\t\t LT(2).CharPositionInLine+1==LT(3).CharPositionInLine");
}
PushFollow(Follow._id_in_synpred1_ANTLR1909);
id();
@@ -10426,7 +10428,6 @@ public partial class ANTLRParser : Parser
int _s = s;
switch ( s )
{
-
case 0:
int LA52_7 = input.LA(1);

@@ -10442,7 +10443,6 @@ public partial class ANTLRParser : Parser
input.Seek(index52_7);
if ( s>=0 ) return s;
break;
-
case 1:
int LA52_8 = input.LA(1);

@@ -10458,7 +10458,6 @@ public partial class ANTLRParser : Parser
input.Seek(index52_8);
if ( s>=0 ) return s;
break;
-
case 2:
int LA52_9 = input.LA(1);

@@ -10474,7 +10473,6 @@ public partial class ANTLRParser : Parser
input.Seek(index52_9);
if ( s>=0 ) return s;
break;
-
case 3:
int LA52_10 = input.LA(1);

@@ -10490,7 +10488,6 @@ public partial class ANTLRParser : Parser
input.Seek(index52_10);
if ( s>=0 ) return s;
break;
-
case 4:
int LA52_11 = input.LA(1);

@@ -10506,7 +10503,6 @@ public partial class ANTLRParser : Parser
input.Seek(index52_11);
if ( s>=0 ) return s;
break;
-
case 5:
int LA52_12 = input.LA(1);

@@ -10522,7 +10518,6 @@ public partial class ANTLRParser : Parser
input.Seek(index52_12);
if ( s>=0 ) return s;
break;
-
case 6:
int LA52_13 = input.LA(1);

@@ -10538,7 +10533,6 @@ public partial class ANTLRParser : Parser
input.Seek(index52_13);
if ( s>=0 ) return s;
break;
-
case 7:
int LA52_14 = input.LA(1);

@@ -10554,7 +10548,6 @@ public partial class ANTLRParser : Parser
input.Seek(index52_14);
if ( s>=0 ) return s;
break;
-
case 8:
int LA52_15 = input.LA(1);

@@ -10570,7 +10563,6 @@ public partial class ANTLRParser : Parser
input.Seek(index52_15);
if ( s>=0 ) return s;
break;
-
case 9:
int LA52_16 = input.LA(1);

@@ -10670,7 +10662,6 @@ public partial class ANTLRParser : Parser
int _s = s;
switch ( s )
{
-
case 0:
int LA82_0 = input.LA(1);

@@ -10696,7 +10687,6 @@ public partial class ANTLRParser : Parser
input.Seek(index82_0);
if ( s>=0 ) return s;
break;
-
case 1:
int LA82_1 = input.LA(1);

@@ -10712,7 +10702,6 @@ public partial class ANTLRParser : Parser
input.Seek(index82_1);
if ( s>=0 ) return s;
break;
-
case 2:
int LA82_2 = input.LA(1);

@@ -10728,7 +10717,6 @@ public partial class ANTLRParser : Parser
input.Seek(index82_2);
if ( s>=0 ) return s;
break;
-
case 3:
int LA82_3 = input.LA(1);

@@ -10744,7 +10732,6 @@ public partial class ANTLRParser : Parser
input.Seek(index82_3);
if ( s>=0 ) return s;
break;
-
case 4:
int LA82_4 = input.LA(1);

@@ -10770,7 +10757,7 @@ public partial class ANTLRParser : Parser
#endregion DFA

#region Follow sets
-	static class Follow
+	private static class Follow
{
public static readonly BitSet _ACTION_in_grammar_308 = new BitSet(new ulong[]{0x1002040008000000UL,0x10000000UL});
public static readonly BitSet _DOC_COMMENT_in_grammar_319 = new BitSet(new ulong[]{0x1002040008000000UL,0x10000000UL});
diff --git a/Antlr3/Grammars/ANTLRTreePrinter.cs b/Antlr3/Grammars/ANTLRTreePrinter.cs
index 964cadc..2caa00c 100644
--- a/Antlr3/Grammars/ANTLRTreePrinter.cs
+++ b/Antlr3/Grammars/ANTLRTreePrinter.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Grammars\\ANTLRTreePrinter.g3 2009-04-18 02:22:43
+// $ANTLR 3.1.2 Grammars\\ANTLRTreePrinter.g3 2009-09-30 13:28:41

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -56,9 +56,11 @@ namespace Antlr3.Grammars
*  University of San Francisco
*  August 19, 2003
*/
+[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.1.2")]
+[System.CLSCompliant(false)]
public partial class ANTLRTreePrinter : TreeParser
{
-	public static readonly string[] tokenNames = new string[] {
+	internal static readonly string[] tokenNames = new string[] {
"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", "ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARG_ACTION", "ARGLIST", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", "CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", "COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", "DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", "EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", "GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", "LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", "NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", "OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", "RET", "RETURNS", "REWRITE", "ROOT", "RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", "SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYN_SEMPRED", "SYNPRED", "TEMPLATE", "THROWS", "TOKEN_REF", "TOKENS", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", "WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT"
};
public const int EOF=-1;
@@ -182,7 +184,6 @@ public partial class ANTLRTreePrinter : TreeParser
// Grammars\\ANTLRTreePrinter.g3:89:0: public toString[Grammar g, bool showActions] returns [string s=null] : ( grammar_ | rule | alternative | element | single_rewrite | EOR ) ;
public string toString( Grammar g, bool showActions )
{
-
string s = null;


@@ -1692,7 +1693,7 @@ public partial class ANTLRTreePrinter : TreeParser
ANTLRTreePrinter.modifier_return retval = new ANTLRTreePrinter.modifier_return();
retval.start = input.LT(1);

-		@out(((GrammarAST)retval.start).Text); @out(" ");
+		@out(((GrammarAST)retval.Start).Text); @out(" ");
try
{
// Grammars\\ANTLRTreePrinter.g3:231:4: ( 'protected' | 'public' | 'private' | 'fragment' )
@@ -1924,7 +1925,7 @@ public partial class ANTLRTreePrinter : TreeParser
retval.start = input.LT(1);


-		int numAlts = CountAltsForBlock(((GrammarAST)retval.start));
+		int numAlts = CountAltsForBlock(((GrammarAST)retval.Start));

try
{
@@ -1936,7 +1937,7 @@ public partial class ANTLRTreePrinter : TreeParser

if ( forceParens||numAlts>1 )
{
-								//for ( Antlr.Runtime.Tree.Tree parent = ((GrammarAST)retval.start).getParent(); parent != null && parent.getType() != RULE; parent = parent.getParent() )
+								//for ( Antlr.Runtime.Tree.Tree parent = ((GrammarAST)retval.Start).getParent(); parent != null && parent.getType() != RULE; parent = parent.getParent() )
//{
//	if ( parent.getType() == BLOCK && countAltsForBlock((GrammarAST)parent) > 1 )
//	{
@@ -3388,7 +3389,7 @@ public partial class ANTLRTreePrinter : TreeParser
{
Match(input,RULE_REF,Follow._RULE_REF_in_atom1466);

-					@out(((GrammarAST)retval.start).ToString());
+					@out(((GrammarAST)retval.Start).ToString());

if ( input.LA(1)==TokenTypes.Down )
{
@@ -3449,7 +3450,7 @@ public partial class ANTLRTreePrinter : TreeParser
{
Match(input,TOKEN_REF,Follow._TOKEN_REF_in_atom1504);

-					@out(((GrammarAST)retval.start).ToString());
+					@out(((GrammarAST)retval.Start).ToString());

if ( input.LA(1)==TokenTypes.Down )
{
@@ -3510,7 +3511,7 @@ public partial class ANTLRTreePrinter : TreeParser
{
Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_atom1544);

-					@out(((GrammarAST)retval.start).ToString());
+					@out(((GrammarAST)retval.Start).ToString());

if ( input.LA(1)==TokenTypes.Down )
{
@@ -3550,7 +3551,7 @@ public partial class ANTLRTreePrinter : TreeParser
{
Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_atom1568);

-					@out(((GrammarAST)retval.start).ToString());
+					@out(((GrammarAST)retval.Start).ToString());

if ( input.LA(1)==TokenTypes.Down )
{
@@ -3590,7 +3591,7 @@ public partial class ANTLRTreePrinter : TreeParser
{
Match(input,WILDCARD,Follow._WILDCARD_in_atom1592);

-					@out(((GrammarAST)retval.start).ToString());
+					@out(((GrammarAST)retval.Start).ToString());

if ( input.LA(1)==TokenTypes.Down )
{
@@ -3734,7 +3735,7 @@ public partial class ANTLRTreePrinter : TreeParser


#region Follow sets
-	public static class Follow
+	private static class Follow
{
public static readonly BitSet _grammar__in_toString72 = new BitSet(new ulong[]{0x2UL});
public static readonly BitSet _rule_in_toString78 = new BitSet(new ulong[]{0x2UL});
diff --git a/Antlr3/Grammars/ActionAnalysisLexer.cs b/Antlr3/Grammars/ActionAnalysisLexer.cs
index 4bf0b01..09ba29c 100644
--- a/Antlr3/Grammars/ActionAnalysisLexer.cs
+++ b/Antlr3/Grammars/ActionAnalysisLexer.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Grammars\\ActionAnalysisLexer.g3 2009-04-18 13:36:23
+// $ANTLR 3.1.2 Grammars\\ActionAnalysisLexer.g3 2009-09-30 13:28:39

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -57,6 +57,8 @@ namespace Antlr3.Grammars
*  remove unusued labels.  This also tracks, for labeled rules,
*  which are referenced by actions.
*/
+[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.1.2")]
+[System.CLSCompliant(false)]
public partial class ActionAnalysisLexer : Lexer
{
public const int EOF=-1;
@@ -141,8 +143,8 @@ public partial class ActionAnalysisLexer : Lexer
{
int _type = X_Y;
int _channel = DefaultTokenChannel;
-			IToken x=null;
-			IToken y=null;
+			CommonToken x=null;
+			CommonToken y=null;

// Grammars\\ActionAnalysisLexer.g3:92:4: ( '$' x= ID '.' y= ID {...}?)
// Grammars\\ActionAnalysisLexer.g3:92:4: '$' x= ID '.' y= ID {...}?
@@ -220,7 +222,7 @@ public partial class ActionAnalysisLexer : Lexer
{
int _type = X;
int _channel = DefaultTokenChannel;
-			IToken ID1=null;
+			CommonToken ID1=null;

// Grammars\\ActionAnalysisLexer.g3:135:4: ( '$' ID {...}?)
// Grammars\\ActionAnalysisLexer.g3:135:4: '$' ID {...}?
@@ -260,7 +262,7 @@ public partial class ActionAnalysisLexer : Lexer
{
int _type = Y;
int _channel = DefaultTokenChannel;
-			IToken ID2=null;
+			CommonToken ID2=null;

// Grammars\\ActionAnalysisLexer.g3:144:4: ( '$' ID {...}?)
// Grammars\\ActionAnalysisLexer.g3:144:4: '$' ID {...}?
diff --git a/Antlr3/Grammars/ActionTranslator.cs b/Antlr3/Grammars/ActionTranslator.cs
index 19f8021..600d0d5 100644
--- a/Antlr3/Grammars/ActionTranslator.cs
+++ b/Antlr3/Grammars/ActionTranslator.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Grammars\\ActionTranslator.g3 2009-04-24 11:05:40
+// $ANTLR 3.1.2 Grammars\\ActionTranslator.g3 2009-09-30 13:28:35

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -51,6 +51,8 @@ using Map = System.Collections.IDictionary;
using HashMap = System.Collections.Generic.Dictionary<object, object>;
namespace Antlr3.Grammars
{
+[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.1.2")]
+[System.CLSCompliant(false)]
public partial class ActionTranslator : Lexer
{
public const int EOF=-1;
@@ -165,9 +167,9 @@ public partial class ActionTranslator : Lexer
{
int _type = SET_ENCLOSING_RULE_SCOPE_ATTR;
int _channel = DefaultTokenChannel;
-			IToken x=null;
-			IToken y=null;
-			IToken expr=null;
+			CommonToken x=null;
+			CommonToken y=null;
+			CommonToken expr=null;

// Grammars\\ActionTranslator.g3:91:4: ( '$' x= ID '.' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?)
// Grammars\\ActionTranslator.g3:91:4: '$' x= ID '.' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?
@@ -279,8 +281,8 @@ public partial class ActionTranslator : Lexer
{
int _type = ENCLOSING_RULE_SCOPE_ATTR;
int _channel = DefaultTokenChannel;
-			IToken x=null;
-			IToken y=null;
+			CommonToken x=null;
+			CommonToken y=null;

// Grammars\\ActionTranslator.g3:143:4: ( '$' x= ID '.' y= ID {...}?)
// Grammars\\ActionTranslator.g3:143:4: '$' x= ID '.' y= ID {...}?
@@ -359,8 +361,8 @@ public partial class ActionTranslator : Lexer
{
int _type = SET_TOKEN_SCOPE_ATTR;
int _channel = DefaultTokenChannel;
-			IToken x=null;
-			IToken y=null;
+			CommonToken x=null;
+			CommonToken y=null;

// Grammars\\ActionTranslator.g3:188:4: ( '$' x= ID '.' y= ID ( WS )? '=' {...}?)
// Grammars\\ActionTranslator.g3:188:4: '$' x= ID '.' y= ID ( WS )? '=' {...}?
@@ -431,8 +433,8 @@ public partial class ActionTranslator : Lexer
{
int _type = TOKEN_SCOPE_ATTR;
int _channel = DefaultTokenChannel;
-			IToken x=null;
-			IToken y=null;
+			CommonToken x=null;
+			CommonToken y=null;

// Grammars\\ActionTranslator.g3:207:4: ( '$' x= ID '.' y= ID {...}?)
// Grammars\\ActionTranslator.g3:207:4: '$' x= ID '.' y= ID {...}?
@@ -498,8 +500,8 @@ public partial class ActionTranslator : Lexer
{
int _type = SET_RULE_SCOPE_ATTR;
int _channel = DefaultTokenChannel;
-			IToken x=null;
-			IToken y=null;
+			CommonToken x=null;
+			CommonToken y=null;


Grammar.LabelElementPair pair=null;
@@ -588,8 +590,8 @@ public partial class ActionTranslator : Lexer
{
int _type = RULE_SCOPE_ATTR;
int _channel = DefaultTokenChannel;
-			IToken x=null;
-			IToken y=null;
+			CommonToken x=null;
+			CommonToken y=null;


Grammar.LabelElementPair pair=null;
@@ -694,7 +696,7 @@ public partial class ActionTranslator : Lexer
{
int _type = LABEL_REF;
int _channel = DefaultTokenChannel;
-			IToken ID1=null;
+			CommonToken ID1=null;

// Grammars\\ActionTranslator.g3:343:4: ( '$' ID {...}?)
// Grammars\\ActionTranslator.g3:343:4: '$' ID {...}?
@@ -747,7 +749,7 @@ public partial class ActionTranslator : Lexer
{
int _type = ISOLATED_TOKEN_REF;
int _channel = DefaultTokenChannel;
-			IToken ID2=null;
+			CommonToken ID2=null;

// Grammars\\ActionTranslator.g3:366:4: ( '$' ID {...}?)
// Grammars\\ActionTranslator.g3:366:4: '$' ID {...}?
@@ -799,7 +801,7 @@ public partial class ActionTranslator : Lexer
{
int _type = ISOLATED_LEXER_RULE_REF;
int _channel = DefaultTokenChannel;
-			IToken ID3=null;
+			CommonToken ID3=null;

// Grammars\\ActionTranslator.g3:388:4: ( '$' ID {...}?)
// Grammars\\ActionTranslator.g3:388:4: '$' ID {...}?
@@ -853,8 +855,8 @@ public partial class ActionTranslator : Lexer
{
int _type = SET_LOCAL_ATTR;
int _channel = DefaultTokenChannel;
-			IToken expr=null;
-			IToken ID4=null;
+			CommonToken expr=null;
+			CommonToken ID4=null;

// Grammars\\ActionTranslator.g3:422:4: ( '$' ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?)
// Grammars\\ActionTranslator.g3:422:4: '$' ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?
@@ -953,7 +955,7 @@ public partial class ActionTranslator : Lexer
{
int _type = LOCAL_ATTR;
int _channel = DefaultTokenChannel;
-			IToken ID5=null;
+			CommonToken ID5=null;

// Grammars\\ActionTranslator.g3:464:4: ( '$' ID {...}?)
// Grammars\\ActionTranslator.g3:464:4: '$' ID {...}?
@@ -1017,9 +1019,9 @@ public partial class ActionTranslator : Lexer
{
int _type = SET_DYNAMIC_SCOPE_ATTR;
int _channel = DefaultTokenChannel;
-			IToken x=null;
-			IToken y=null;
-			IToken expr=null;
+			CommonToken x=null;
+			CommonToken y=null;
+			CommonToken expr=null;

// Grammars\\ActionTranslator.g3:509:4: ( '$' x= ID '::' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?)
// Grammars\\ActionTranslator.g3:509:4: '$' x= ID '::' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?
@@ -1100,8 +1102,8 @@ public partial class ActionTranslator : Lexer
{
int _type = DYNAMIC_SCOPE_ATTR;
int _channel = DefaultTokenChannel;
-			IToken x=null;
-			IToken y=null;
+			CommonToken x=null;
+			CommonToken y=null;

// Grammars\\ActionTranslator.g3:530:4: ( '$' x= ID '::' y= ID {...}?)
// Grammars\\ActionTranslator.g3:530:4: '$' x= ID '::' y= ID {...}?
@@ -1156,8 +1158,8 @@ public partial class ActionTranslator : Lexer
{
int _type = ERROR_SCOPED_XY;
int _channel = DefaultTokenChannel;
-			IToken x=null;
-			IToken y=null;
+			CommonToken x=null;
+			CommonToken y=null;

// Grammars\\ActionTranslator.g3:551:4: ( '$' x= ID '::' y= ID )
// Grammars\\ActionTranslator.g3:551:4: '$' x= ID '::' y= ID
@@ -1199,9 +1201,9 @@ public partial class ActionTranslator : Lexer
{
int _type = DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR;
int _channel = DefaultTokenChannel;
-			IToken x=null;
-			IToken expr=null;
-			IToken y=null;
+			CommonToken x=null;
+			CommonToken expr=null;
+			CommonToken y=null;

// Grammars\\ActionTranslator.g3:569:4: ( '$' x= ID '[' '-' expr= SCOPE_INDEX_EXPR ']' '::' y= ID )
// Grammars\\ActionTranslator.g3:569:4: '$' x= ID '[' '-' expr= SCOPE_INDEX_EXPR ']' '::' y= ID
@@ -1249,9 +1251,9 @@ public partial class ActionTranslator : Lexer
{
int _type = DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR;
int _channel = DefaultTokenChannel;
-			IToken x=null;
-			IToken expr=null;
-			IToken y=null;
+			CommonToken x=null;
+			CommonToken expr=null;
+			CommonToken y=null;

// Grammars\\ActionTranslator.g3:580:4: ( '$' x= ID '[' expr= SCOPE_INDEX_EXPR ']' '::' y= ID )
// Grammars\\ActionTranslator.g3:580:4: '$' x= ID '[' expr= SCOPE_INDEX_EXPR ']' '::' y= ID
@@ -1354,7 +1356,7 @@ public partial class ActionTranslator : Lexer
{
int _type = ISOLATED_DYNAMIC_SCOPE;
int _channel = DefaultTokenChannel;
-			IToken ID6=null;
+			CommonToken ID6=null;

// Grammars\\ActionTranslator.g3:601:4: ( '$' ID {...}?)
// Grammars\\ActionTranslator.g3:601:4: '$' ID {...}?
@@ -1725,9 +1727,9 @@ public partial class ActionTranslator : Lexer
{
int _type = SET_EXPR_ATTRIBUTE;
int _channel = DefaultTokenChannel;
-			IToken a=null;
-			IToken expr=null;
-			IToken ID7=null;
+			CommonToken a=null;
+			CommonToken expr=null;
+			CommonToken ID7=null;

// Grammars\\ActionTranslator.g3:656:4: ( '%' a= ACTION '.' ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' )
// Grammars\\ActionTranslator.g3:656:4: '%' a= ACTION '.' ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';'
@@ -1795,9 +1797,9 @@ public partial class ActionTranslator : Lexer
{
int _type = SET_ATTRIBUTE;
int _channel = DefaultTokenChannel;
-			IToken x=null;
-			IToken y=null;
-			IToken expr=null;
+			CommonToken x=null;
+			CommonToken y=null;
+			CommonToken expr=null;

// Grammars\\ActionTranslator.g3:673:4: ( '%' x= ID '.' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' )
// Grammars\\ActionTranslator.g3:673:4: '%' x= ID '.' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';'
@@ -1925,7 +1927,7 @@ public partial class ActionTranslator : Lexer
{
int _type = TEMPLATE_EXPR;
int _channel = DefaultTokenChannel;
-			IToken a=null;
+			CommonToken a=null;

// Grammars\\ActionTranslator.g3:691:4: ( '%' a= ACTION )
// Grammars\\ActionTranslator.g3:691:4: '%' a= ACTION
@@ -2109,8 +2111,8 @@ public partial class ActionTranslator : Lexer
{
int _type = ERROR_XY;
int _channel = DefaultTokenChannel;
-			IToken x=null;
-			IToken y=null;
+			CommonToken x=null;
+			CommonToken y=null;

// Grammars\\ActionTranslator.g3:713:4: ( '$' x= ID '.' y= ID )
// Grammars\\ActionTranslator.g3:713:4: '$' x= ID '.' y= ID
@@ -2151,7 +2153,7 @@ public partial class ActionTranslator : Lexer
{
int _type = ERROR_X;
int _channel = DefaultTokenChannel;
-			IToken x=null;
+			CommonToken x=null;

// Grammars\\ActionTranslator.g3:723:4: ( '$' x= ID )
// Grammars\\ActionTranslator.g3:723:4: '$' x= ID
@@ -3281,7 +3283,6 @@ public partial class ActionTranslator : Lexer
int _s = s;
switch ( s )
{
-
case 0:
int LA28_0 = input.LA(1);

@@ -3296,7 +3297,6 @@ public partial class ActionTranslator : Lexer

if ( s>=0 ) return s;
break;
-
case 1:
int LA28_1 = input.LA(1);

@@ -3348,7 +3348,6 @@ public partial class ActionTranslator : Lexer
input.Seek(index28_1);
if ( s>=0 ) return s;
break;
-
case 2:
int LA28_22 = input.LA(1);

diff --git a/Antlr3/Grammars/AssignTokenTypesWalker.cs b/Antlr3/Grammars/AssignTokenTypesWalker.cs
index f12afc1..f94d450 100644
--- a/Antlr3/Grammars/AssignTokenTypesWalker.cs
+++ b/Antlr3/Grammars/AssignTokenTypesWalker.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Grammars\\AssignTokenTypesWalker.g3 2009-04-18 02:22:45
+// $ANTLR 3.1.2 Grammars\\AssignTokenTypesWalker.g3 2009-09-30 13:28:43

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -107,9 +107,11 @@ namespace Antlr3.Grammars
*     g.defineToken(<tokenID>, ttype);
*     where some of the ttype values will be the same for aliases tokens.
*/
+[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.1.2")]
+[System.CLSCompliant(false)]
public partial class AssignTokenTypesWalker : TreeParser
{
-	public static readonly string[] tokenNames = new string[] {
+	internal static readonly string[] tokenNames = new string[] {
"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", "ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARG_ACTION", "ARGLIST", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", "CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", "COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", "DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", "EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", "GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", "LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", "NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", "OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", "RET", "RETURNS", "REWRITE", "ROOT", "RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", "SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYN_SEMPRED", "SYNPRED", "TEMPLATE", "THROWS", "TOKEN_REF", "TOKENS", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", "WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT", "CHARSET"
};
public const int EOF=-1;
@@ -706,7 +708,6 @@ public partial class AssignTokenTypesWalker : TreeParser
// Grammars\\AssignTokenTypesWalker.g3:167:0: optionsSpec returns [Map opts=new HashMap()] : ^( OPTIONS ( option[$opts] )+ ) ;
private Map optionsSpec(  )
{
-
Map opts = new HashMap();

try
@@ -840,7 +841,7 @@ public partial class AssignTokenTypesWalker : TreeParser


if ( state.backtracking == 0 )
-				retval.value = ((GrammarAST)retval.start).Text;
+				retval.value = ((GrammarAST)retval.Start).Text;

try
{
@@ -1644,7 +1645,7 @@ public partial class AssignTokenTypesWalker : TreeParser
}

Match(input,EOR,Follow._EOR_in_rule630);
-			TrackTokenRule(id,(m!=null?((GrammarAST)m.start):null),(b!=null?((GrammarAST)b.start):null));
+			TrackTokenRule(id,(m!=null?((GrammarAST)m.Start):null),(b!=null?((GrammarAST)b.Start):null));

Match(input, TokenTypes.Up, null);

@@ -3200,7 +3201,7 @@ public partial class AssignTokenTypesWalker : TreeParser


#region Follow sets
-	public static class Follow
+	private static class Follow
{
public static readonly BitSet _LEXER_GRAMMAR_in_grammar_68 = new BitSet(new ulong[]{0x4UL});
public static readonly BitSet _grammarSpec_in_grammar_73 = new BitSet(new ulong[]{0x8UL});
diff --git a/Antlr3/Grammars/CodeGenTreeWalker.cs b/Antlr3/Grammars/CodeGenTreeWalker.cs
index 2dc6eef..755130d 100644
--- a/Antlr3/Grammars/CodeGenTreeWalker.cs
+++ b/Antlr3/Grammars/CodeGenTreeWalker.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Grammars\\CodeGenTreeWalker.g3 2009-04-24 11:05:41
+// $ANTLR 3.1.2 Grammars\\CodeGenTreeWalker.g3 2009-09-30 13:28:37

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -66,9 +66,11 @@ namespace Antlr3.Grammars
*  University of San Francisco
*  June 15, 2004
*/
+[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.1.2")]
+[System.CLSCompliant(false)]
public partial class CodeGenTreeWalker : TreeParser
{
-	public static readonly string[] tokenNames = new string[] {
+	internal static readonly string[] tokenNames = new string[] {
"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", "ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARG_ACTION", "ARGLIST", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", "CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", "COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", "DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", "EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", "GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", "LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", "NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", "OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", "RET", "RETURNS", "REWRITE", "ROOT", "RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", "SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYN_SEMPRED", "SYNPRED", "TEMPLATE", "THROWS", "TOKEN_REF", "TOKENS", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", "WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT"
};
public const int EOF=-1;
@@ -1021,13 +1023,13 @@ public partial class CodeGenTreeWalker : TreeParser

string initAction = null;
// get the dfa for the BLOCK
-			GrammarAST block2=(GrammarAST)((GrammarAST)retval.start).GetFirstChildWithType(BLOCK);
+			GrammarAST block2=(GrammarAST)((GrammarAST)retval.Start).GetFirstChildWithType(BLOCK);
Antlr3.Analysis.DFA dfa=block2.LookaheadDFA;
// init blockNestingLevel so it's block level RULE_BLOCK_NESTING_LEVEL
// for alts of rule
blockNestingLevel = RULE_BLOCK_NESTING_LEVEL-1;
-			Rule ruleDescr = grammar.GetRule(((GrammarAST)retval.start).GetChild(0).Text);
-			currentRuleName = ((GrammarAST)retval.start).GetChild(0).Text;
+			Rule ruleDescr = grammar.GetRule(((GrammarAST)retval.Start).GetChild(0).Text);
+			currentRuleName = ((GrammarAST)retval.Start).GetChild(0).Text;

// For syn preds, we don't want any AST code etc... in there.
// Save old templates ptr and restore later.  Base templates include Dbg.
@@ -1324,7 +1326,7 @@ public partial class CodeGenTreeWalker : TreeParser
{

description =
-									grammar.GrammarTreeToString((GrammarAST)((GrammarAST)retval.start).GetFirstChildWithType(BLOCK),
+									grammar.GrammarTreeToString((GrammarAST)((GrammarAST)retval.Start).GetFirstChildWithType(BLOCK),
false);
description =
generator.target.GetTargetStringLiteralFromString(description);
@@ -1360,7 +1362,7 @@ public partial class CodeGenTreeWalker : TreeParser
retval.code.SetAttribute("emptyRule", grammar.IsEmptyRule(block2));
}
retval.code.SetAttribute("ruleDescriptor", ruleDescr);
-								string memo = (string)grammar.GetBlockOption(((GrammarAST)retval.start),"memoize");
+								string memo = (string)grammar.GetBlockOption(((GrammarAST)retval.Start),"memoize");
if ( memo==null )
{
memo = (string)grammar.GetOption("memoize");
@@ -1408,12 +1410,12 @@ public partial class CodeGenTreeWalker : TreeParser
{
bool naked =
currentRuleName.Equals(Grammar.ArtificialTokensRuleName) ||
-										((mod!=null?((GrammarAST)mod.start):null)!=null&&(mod!=null?((GrammarAST)mod.start):null).Text.Equals(Grammar.FragmentRuleModifier));
+										((mod!=null?((GrammarAST)mod.Start):null)!=null&&(mod!=null?((GrammarAST)mod.Start):null).Text.Equals(Grammar.FragmentRuleModifier));
retval.code.SetAttribute("nakedBlock", naked);
}
else
{
-									description = grammar.GrammarTreeToString(((GrammarAST)retval.start),false);
+									description = grammar.GrammarTreeToString(((GrammarAST)retval.Start),false);
description = generator.target.GetTargetStringLiteralFromString(description);
retval.code.SetAttribute("description", description);
}
@@ -1772,7 +1774,7 @@ public partial class CodeGenTreeWalker : TreeParser
{
int LA35_1 = input.LA(2);

-				if ( ((((GrammarAST)retval.start).SetValue!=null)) )
+				if ( ((((GrammarAST)retval.Start).SetValue!=null)) )
{
alt35=1;
}
@@ -1800,7 +1802,7 @@ public partial class CodeGenTreeWalker : TreeParser
case 1:
// Grammars\\CodeGenTreeWalker.g3:358:4: {...}? => setBlock
{
-				if ( !((((GrammarAST)retval.start).SetValue!=null)) )
+				if ( !((((GrammarAST)retval.Start).SetValue!=null)) )
{
if (state.backtracking>0) {state.failed=true; return retval;}
throw new FailedPredicateException(input, "block", "$start.SetValue!=null");
@@ -1926,9 +1928,9 @@ public partial class CodeGenTreeWalker : TreeParser
// (unless it's a " -> ..." rewrite
// ( -> ... )
bool etc =
-													(rew!=null?((GrammarAST)rew.start):null).Type==REWRITE &&
-													(rew!=null?((GrammarAST)rew.start):null).GetChild(0)!=null &&
-													(rew!=null?((GrammarAST)rew.start):null).GetChild(0).Type==ETC;
+													(rew!=null?((GrammarAST)rew.Start):null).Type==REWRITE &&
+													(rew!=null?((GrammarAST)rew.Start):null).GetChild(0)!=null &&
+													(rew!=null?((GrammarAST)rew.Start):null).GetChild(0).Type==ETC;
if ( (rew!=null?rew.code:default(StringTemplate))!=null && !etc )
{
(alt!=null?alt.code:default(StringTemplate)).SetAttribute("rew", (rew!=null?rew.code:default(StringTemplate)));
@@ -2004,7 +2006,7 @@ public partial class CodeGenTreeWalker : TreeParser
currentAltHasASTRewrite = r.HasRewrite(outerAltNum);
if ( currentAltHasASTRewrite )
{
-						r.TrackTokenReferenceInAlt(((GrammarAST)retval.start), outerAltNum);
+						r.TrackTokenReferenceInAlt(((GrammarAST)retval.Start), outerAltNum);
}
}
}
@@ -2430,7 +2432,7 @@ public partial class CodeGenTreeWalker : TreeParser
Rule r = grammar.GetRule(currentRuleName);
currentAltHasASTRewrite = r.HasRewrite(outerAltNum);
}
-				string description = grammar.GrammarTreeToString(((GrammarAST)retval.start), false);
+				string description = grammar.GrammarTreeToString(((GrammarAST)retval.Start), false);
description = generator.target.GetTargetStringLiteralFromString(description);
retval.code.SetAttribute("description", description);
retval.code.SetAttribute("treeLevel", rewriteTreeNestingLevel);
@@ -2478,8 +2480,8 @@ public partial class CodeGenTreeWalker : TreeParser
{
retval.code.SetAttribute("elements.{el,line,pos}",
(e!=null?e.code:default(StringTemplate)),
-																  (e!=null?((GrammarAST)e.start):null).Line,
-																  (e!=null?((GrammarAST)e.start):null).CharPositionInLine
+																  (e!=null?((GrammarAST)e.Start):null).Line,
+																  (e!=null?((GrammarAST)e.Start):null).CharPositionInLine
);
}

@@ -3015,7 +3017,6 @@ public partial class CodeGenTreeWalker : TreeParser
// Grammars\\CodeGenTreeWalker.g3:603:0: notElement[GrammarAST n, GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null] : (assign_c= CHAR_LITERAL |assign_s= STRING_LITERAL |assign_t= TOKEN_REF | ^(assign_st= BLOCK ( . )* ) ) ;
private StringTemplate notElement( GrammarAST n, GrammarAST label, GrammarAST astSuffix )
{
-
StringTemplate code = null;

GrammarAST assign_c=null;
@@ -3237,7 +3238,7 @@ public partial class CodeGenTreeWalker : TreeParser


Antlr3.Analysis.DFA dfa=null;
-			GrammarAST b = (GrammarAST)((GrammarAST)retval.start).GetChild(0);
+			GrammarAST b = (GrammarAST)((GrammarAST)retval.Start).GetChild(0);
GrammarAST eob = (GrammarAST)b.LastChild; // loops will use EOB DFA

try
@@ -3285,7 +3286,7 @@ public partial class CodeGenTreeWalker : TreeParser
{
if ( state.backtracking == 0 )
{
-					 dfa = ((GrammarAST)retval.start).LookaheadDFA;
+					 dfa = ((GrammarAST)retval.Start).LookaheadDFA;
}
PushFollow(Follow._block_in_ebnf1241);
blk=block("block", dfa);
@@ -3304,7 +3305,7 @@ public partial class CodeGenTreeWalker : TreeParser
{
if ( state.backtracking == 0 )
{
-					 dfa = ((GrammarAST)retval.start).LookaheadDFA;
+					 dfa = ((GrammarAST)retval.Start).LookaheadDFA;
}
Match(input,OPTIONAL,Follow._OPTIONAL_in_ebnf1260); if (state.failed) return retval;

@@ -3377,7 +3378,7 @@ public partial class CodeGenTreeWalker : TreeParser
if ( state.backtracking == 0 )
{

-							string description = grammar.GrammarTreeToString(((GrammarAST)retval.start), false);
+							string description = grammar.GrammarTreeToString(((GrammarAST)retval.Start), false);
description = generator.target.GetTargetStringLiteralFromString(description);
retval.code.SetAttribute("description", description);

@@ -3419,7 +3420,7 @@ public partial class CodeGenTreeWalker : TreeParser
if ( state.backtracking == 0 )
{
retval.code = templates.GetInstanceOf("tree");
-				NFAState afterDOWN = (NFAState)((GrammarAST)retval.start).NFATreeDownState.GetTransition(0).target;
+				NFAState afterDOWN = (NFAState)((GrammarAST)retval.Start).NFATreeDownState.GetTransition(0).target;
LookaheadSet s = grammar.Look(afterDOWN);
if ( s.Member(Label.UP) ) {
// nullable child list if we can see the UP as the next token
@@ -3453,8 +3454,8 @@ public partial class CodeGenTreeWalker : TreeParser

retval.code.SetAttribute("root.{el,line,pos}",
(el!=null?el.code:default(StringTemplate)),
-												  (el!=null?((GrammarAST)el.start):null).Line,
-												  (el!=null?((GrammarAST)el.start):null).CharPositionInLine
+												  (el!=null?((GrammarAST)el.Start):null).Line,
+												  (el!=null?((GrammarAST)el.Start):null).CharPositionInLine
);

}
@@ -3504,8 +3505,8 @@ public partial class CodeGenTreeWalker : TreeParser

retval.code.SetAttribute("actionsAfterRoot.{el,line,pos}",
(act!=null?act.code:default(StringTemplate)),
-															  (act!=null?((GrammarAST)act.start):null).Line,
-															  (act!=null?((GrammarAST)act.start):null).CharPositionInLine
+															  (act!=null?((GrammarAST)act.Start):null).Line,
+															  (act!=null?((GrammarAST)act.Start):null).CharPositionInLine
);

}
@@ -3549,8 +3550,8 @@ public partial class CodeGenTreeWalker : TreeParser

retval.code.SetAttribute("children.{el,line,pos}",
(el!=null?el.code:default(StringTemplate)),
-														  (el!=null?((GrammarAST)el.start):null).Line,
-														  (el!=null?((GrammarAST)el.start):null).CharPositionInLine
+														  (el!=null?((GrammarAST)el.Start):null).Line,
+														  (el!=null?((GrammarAST)el.Start):null).CharPositionInLine
);

}
@@ -3618,16 +3619,16 @@ public partial class CodeGenTreeWalker : TreeParser
labelText = label.Text;
}
if ( grammar.type!=GrammarType.Lexer &&
-					 (((GrammarAST)retval.start).Type==RULE_REF||((GrammarAST)retval.start).Type==TOKEN_REF||
-					  ((GrammarAST)retval.start).Type==CHAR_LITERAL||((GrammarAST)retval.start).Type==STRING_LITERAL) )
+					 (((GrammarAST)retval.Start).Type==RULE_REF||((GrammarAST)retval.Start).Type==TOKEN_REF||
+					  ((GrammarAST)retval.Start).Type==CHAR_LITERAL||((GrammarAST)retval.Start).Type==STRING_LITERAL) )
{
-					Rule encRule = grammar.GetRule(((GrammarAST)((GrammarAST)retval.start)).enclosingRuleName);
+					Rule encRule = grammar.GetRule(((GrammarAST)((GrammarAST)retval.Start)).enclosingRuleName);
if ( encRule!=null && encRule.HasRewrite(outerAltNum) && astSuffix!=null )
{
ErrorManager.GrammarError(ErrorManager.MSG_AST_OP_IN_ALT_WITH_REWRITE,
grammar,
-												  ((GrammarAST)((GrammarAST)retval.start)).Token,
-												  ((GrammarAST)((GrammarAST)retval.start)).enclosingRuleName,
+												  ((GrammarAST)((GrammarAST)retval.Start)).Token,
+												  ((GrammarAST)((GrammarAST)retval.Start)).enclosingRuleName,
outerAltNum);
astSuffix = null;
}
@@ -4047,7 +4048,6 @@ public partial class CodeGenTreeWalker : TreeParser
// Grammars\\CodeGenTreeWalker.g3:965:0: set[GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null] : ^(s= BLOCK ( . )* ) ;
private StringTemplate set( GrammarAST label, GrammarAST astSuffix )
{
-
StringTemplate code = null;

GrammarAST s=null;
@@ -4246,7 +4246,7 @@ public partial class CodeGenTreeWalker : TreeParser

if ( state.backtracking == 0 )
{
-				if ( ((GrammarAST)retval.start).Type==REWRITE )
+				if ( ((GrammarAST)retval.Start).Type==REWRITE )
{
if ( generator.grammar.BuildTemplate )
{
@@ -4258,19 +4258,19 @@ public partial class CodeGenTreeWalker : TreeParser
retval.code.SetAttribute("treeLevel", OUTER_REWRITE_NESTING_LEVEL);
retval.code.SetAttribute("rewriteBlockLevel", OUTER_REWRITE_NESTING_LEVEL);
retval.code.SetAttribute("referencedElementsDeep",
-										  GetTokenTypesAsTargetLabels(((GrammarAST)retval.start).rewriteRefsDeep));
+										  GetTokenTypesAsTargetLabels(((GrammarAST)retval.Start).rewriteRefsDeep));
HashSet<string> tokenLabels =
-							grammar.GetLabels(((GrammarAST)retval.start).rewriteRefsDeep, LabelType.Token);
+							grammar.GetLabels(((GrammarAST)retval.Start).rewriteRefsDeep, LabelType.Token);
HashSet<string> tokenListLabels =
-							grammar.GetLabels(((GrammarAST)retval.start).rewriteRefsDeep, LabelType.TokenList);
+							grammar.GetLabels(((GrammarAST)retval.Start).rewriteRefsDeep, LabelType.TokenList);
HashSet<string> ruleLabels =
-							grammar.GetLabels(((GrammarAST)retval.start).rewriteRefsDeep, LabelType.Rule);
+							grammar.GetLabels(((GrammarAST)retval.Start).rewriteRefsDeep, LabelType.Rule);
HashSet<string> ruleListLabels =
-							grammar.GetLabels(((GrammarAST)retval.start).rewriteRefsDeep, LabelType.RuleList);
+							grammar.GetLabels(((GrammarAST)retval.Start).rewriteRefsDeep, LabelType.RuleList);
HashSet<string> wildcardLabels =
-							grammar.GetLabels(((GrammarAST)retval.start).rewriteRefsDeep, LabelType.WildcardTree);
+							grammar.GetLabels(((GrammarAST)retval.Start).rewriteRefsDeep, LabelType.WildcardTree);
HashSet<string> wildcardListLabels =
-							grammar.GetLabels(((GrammarAST)retval.start).rewriteRefsDeep, LabelType.WildcardTreeList);
+							grammar.GetLabels(((GrammarAST)retval.Start).rewriteRefsDeep, LabelType.WildcardTreeList);
// just in case they ref r for "previous value", make a stream
// from retval.tree
StringTemplate retvalST = templates.GetInstanceOf("prevRuleRootRef");
@@ -4401,7 +4401,6 @@ public partial class CodeGenTreeWalker : TreeParser
// Grammars\\CodeGenTreeWalker.g3:1069:0: rewrite_block[string blockTemplateName] returns [StringTemplate code=null] : ^( BLOCK alt= rewrite_alternative EOB ) ;
private StringTemplate rewrite_block( string blockTemplateName )
{
-
StringTemplate code = null;

GrammarAST BLOCK14=null;
@@ -4471,7 +4470,6 @@ public partial class CodeGenTreeWalker : TreeParser
// Grammars\\CodeGenTreeWalker.g3:1097:0: rewrite_alternative returns [StringTemplate code=null] : ({...}? ^(a= ALT ( (el= rewrite_element )+ | EPSILON ) EOA ) |{...}? rewrite_template | ETC );
private StringTemplate rewrite_alternative(  )
{
-
StringTemplate code = null;

GrammarAST a=null;
@@ -4646,8 +4644,8 @@ public partial class CodeGenTreeWalker : TreeParser
{
code.SetAttribute("elements.{el,line,pos}",
(el!=null?el.code:default(StringTemplate)),
-																		(el!=null?((GrammarAST)el.start):null).Line,
-																		(el!=null?((GrammarAST)el.start):null).CharPositionInLine
+																		(el!=null?((GrammarAST)el.Start):null).Line,
+																		(el!=null?((GrammarAST)el.Start):null).CharPositionInLine
);

}
@@ -4926,7 +4924,7 @@ public partial class CodeGenTreeWalker : TreeParser
if ( state.backtracking == 0 )
{

-								string description = grammar.GrammarTreeToString(((GrammarAST)retval.start), false);
+								string description = grammar.GrammarTreeToString(((GrammarAST)retval.Start), false);
description = generator.target.GetTargetStringLiteralFromString(description);
retval.code.SetAttribute("description", description);

@@ -4954,7 +4952,7 @@ public partial class CodeGenTreeWalker : TreeParser
if ( state.backtracking == 0 )
{

-								string description = grammar.GrammarTreeToString(((GrammarAST)retval.start), false);
+								string description = grammar.GrammarTreeToString(((GrammarAST)retval.Start), false);
description = generator.target.GetTargetStringLiteralFromString(description);
retval.code.SetAttribute("description", description);

@@ -4982,7 +4980,7 @@ public partial class CodeGenTreeWalker : TreeParser
if ( state.backtracking == 0 )
{

-								string description = grammar.GrammarTreeToString(((GrammarAST)retval.start), false);
+								string description = grammar.GrammarTreeToString(((GrammarAST)retval.Start), false);
description = generator.target.GetTargetStringLiteralFromString(description);
retval.code.SetAttribute("description", description);

@@ -5047,8 +5045,8 @@ public partial class CodeGenTreeWalker : TreeParser

retval.code.SetAttribute("root.{el,line,pos}",
(r!=null?r.code:default(StringTemplate)),
-												   (r!=null?((GrammarAST)r.start):null).Line,
-												   (r!=null?((GrammarAST)r.start):null).CharPositionInLine
+												   (r!=null?((GrammarAST)r.Start):null).Line,
+												   (r!=null?((GrammarAST)r.Start):null).CharPositionInLine
);

}
@@ -5079,8 +5077,8 @@ public partial class CodeGenTreeWalker : TreeParser

retval.code.SetAttribute("children.{el,line,pos}",
(el!=null?el.code:default(StringTemplate)),
-															(el!=null?((GrammarAST)el.start):null).Line,
-															(el!=null?((GrammarAST)el.start):null).CharPositionInLine
+															(el!=null?((GrammarAST)el.Start):null).Line,
+															(el!=null?((GrammarAST)el.Start):null).CharPositionInLine
);

}
@@ -5102,7 +5100,7 @@ public partial class CodeGenTreeWalker : TreeParser
if ( state.backtracking == 0 )
{

-							string description = grammar.GrammarTreeToString(((GrammarAST)retval.start), false);
+							string description = grammar.GrammarTreeToString(((GrammarAST)retval.Start), false);
description = generator.target.GetTargetStringLiteralFromString(description);
retval.code.SetAttribute("description", description);

@@ -5316,7 +5314,7 @@ public partial class CodeGenTreeWalker : TreeParser
{

GrammarAST term = (tk) ?? (cl) ?? (sl);
-								string tokenName = ((GrammarAST)retval.start).Token.Text;
+								string tokenName = ((GrammarAST)retval.Start).Token.Text;
string stName = "rewriteTokenRef";
Rule rule = grammar.GetRule(currentRuleName);
ICollection<string> tokenRefsInAlt = rule.GetTokenRefsInAlt(outerAltNum);
@@ -5341,7 +5339,7 @@ public partial class CodeGenTreeWalker : TreeParser
List args = generator.TranslateAction(currentRuleName,arg);
retval.code.SetAttribute("args", args);
}
-								retval.code.SetAttribute("elementIndex", ((TokenWithIndex)((GrammarAST)retval.start).Token).TokenIndex);
+								retval.code.SetAttribute("elementIndex", ((TokenWithIndex)((GrammarAST)retval.Start).Token).TokenIndex);
int ttype = grammar.GetTokenType(tokenName);
string tok = generator.GetTokenTypeAsTargetLabel(ttype);
retval.code.SetAttribute("token", tok);
@@ -5349,7 +5347,7 @@ public partial class CodeGenTreeWalker : TreeParser
{
ErrorManager.GrammarError(ErrorManager.MSG_UNDEFINED_TOKEN_REF_IN_REWRITE,
grammar,
-															  ((GrammarAST)(((GrammarAST)retval.start))).Token,
+															  ((GrammarAST)(((GrammarAST)retval.Start))).Token,
tokenName);
retval.code = new StringTemplate(); // blank; no code gen
}
@@ -5464,7 +5462,6 @@ public partial class CodeGenTreeWalker : TreeParser
// Grammars\\CodeGenTreeWalker.g3:1360:0: public rewrite_template returns [StringTemplate code=null] : ( ^( ALT EPSILON EOA ) | ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? ) |act= ACTION );
public StringTemplate rewrite_template(  )
{
-
StringTemplate code = null;

GrammarAST id=null;
@@ -5898,7 +5895,6 @@ public partial class CodeGenTreeWalker : TreeParser
int _s = s;
switch ( s )
{
-
case 0:
int LA45_0 = input.LA(1);

@@ -5946,7 +5942,6 @@ public partial class CodeGenTreeWalker : TreeParser
input.Seek(index45_0);
if ( s>=0 ) return s;
break;
-
case 1:
int LA45_7 = input.LA(1);

@@ -5972,7 +5967,7 @@ public partial class CodeGenTreeWalker : TreeParser
#endregion DFA

#region Follow sets
-	public static class Follow
+	private static class Follow
{
public static readonly BitSet _LEXER_GRAMMAR_in_grammar_66 = new BitSet(new ulong[]{0x4UL});
public static readonly BitSet _grammarSpec_in_grammar_68 = new BitSet(new ulong[]{0x8UL});
diff --git a/Antlr3/Grammars/DefineGrammarItemsWalker.cs b/Antlr3/Grammars/DefineGrammarItemsWalker.cs
index 5244b04..6328fc7 100644
--- a/Antlr3/Grammars/DefineGrammarItemsWalker.cs
+++ b/Antlr3/Grammars/DefineGrammarItemsWalker.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Grammars\\DefineGrammarItemsWalker.g3 2009-04-24 11:05:57
+// $ANTLR 3.1.2 Grammars\\DefineGrammarItemsWalker.g3 2009-09-30 13:28:45

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -56,9 +56,11 @@ using Map = System.Collections.IDictionary;
using HashMap = System.Collections.Generic.Dictionary<object, object>;
namespace Antlr3.Grammars
{
+[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.1.2")]
+[System.CLSCompliant(false)]
public partial class DefineGrammarItemsWalker : TreeParser
{
-	public static readonly string[] tokenNames = new string[] {
+	internal static readonly string[] tokenNames = new string[] {
"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", "ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARG_ACTION", "ARGLIST", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", "CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", "COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", "DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", "EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", "GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", "LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", "NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", "OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", "RET", "RETURNS", "REWRITE", "ROOT", "RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", "SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYN_SEMPRED", "SYNPRED", "TEMPLATE", "THROWS", "TOKEN_REF", "TOKENS", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", "WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT"
};
public const int EOF=-1;
@@ -196,7 +198,7 @@ public partial class DefineGrammarItemsWalker : TreeParser


grammar = g;
-		root = ((GrammarAST)retval.start);
+		root = ((GrammarAST)retval.Start);

try
{
@@ -1360,12 +1362,12 @@ public partial class DefineGrammarItemsWalker : TreeParser
if ( char.IsUpper(name[0]) && grammar.type==GrammarType.Combined )
{
// a merged grammar spec, track lexer rules and send to another grammar
-									grammar.DefineLexerRuleFoundInParser(id.token, ((GrammarAST)retval.start));
+									grammar.DefineLexerRuleFoundInParser(id.token, ((GrammarAST)retval.Start));
}
else
{
-									int numAlts = CountAltsForRule(((GrammarAST)retval.start));
-									grammar.DefineRule(id.Token, (modifier4!=null?modifier4.mod:default(string)), opts, ((GrammarAST)retval.start), args, numAlts);
+									int numAlts = CountAltsForRule(((GrammarAST)retval.Start));
+									grammar.DefineRule(id.Token, (modifier4!=null?modifier4.mod:default(string)), opts, ((GrammarAST)retval.Start), args, numAlts);
r = grammar.GetRule(name);
if ( args!=null )
{
@@ -1483,7 +1485,7 @@ public partial class DefineGrammarItemsWalker : TreeParser

// copy rule options into the block AST, which is where
// the analysis will look for k option etc...
-								(b!=null?((GrammarAST)b.start):null).BlockOptions = opts;
+								(b!=null?((GrammarAST)b.Start):null).BlockOptions = opts;

}

@@ -1558,7 +1560,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
retval.start = input.LT(1);


-			retval.mod = ((GrammarAST)retval.start).Token.Text;
+			retval.mod = ((GrammarAST)retval.Start).Token.Text;

try
{
@@ -1598,7 +1600,6 @@ public partial class DefineGrammarItemsWalker : TreeParser
// Grammars\\DefineGrammarItemsWalker.g3:261:0: throwsSpec returns [HashSet<string> exceptions] : ^( 'throws' ( ID )+ ) ;
private HashSet<string> throwsSpec(  )
{
-
HashSet<string> exceptions = default(HashSet<string>);

GrammarAST ID6=null;
@@ -2035,8 +2036,8 @@ public partial class DefineGrammarItemsWalker : TreeParser
{
if ( grammar.type!=GrammarType.Lexer && grammar.GetOption("output")!=null && blockLevel==1 )
{
-					GrammarAST aRewriteNode = ((GrammarAST)retval.start).FindFirstType(REWRITE); // alt itself has rewrite?
-					GrammarAST rewriteAST = (GrammarAST)((GrammarAST)retval.start).Parent.GetChild(((GrammarAST)retval.start).ChildIndex + 1);
+					GrammarAST aRewriteNode = ((GrammarAST)retval.Start).FindFirstType(REWRITE); // alt itself has rewrite?
+					GrammarAST rewriteAST = (GrammarAST)((GrammarAST)retval.Start).Parent.GetChild(((GrammarAST)retval.Start).ChildIndex + 1);
// we have a rewrite if alt uses it inside subrule or this alt has one
// but don't count -> ... rewrites, which mean "do default auto construction"
if ( aRewriteNode!=null||
@@ -2046,7 +2047,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
rewriteAST.GetChild(0).Type!=ETC) )
{
Rule r = grammar.GetRule(currentRuleName);
-						r.TrackAltsWithRewrites(((GrammarAST)retval.start),this.outerAltNum);
+						r.TrackAltsWithRewrites(((GrammarAST)retval.Start),this.outerAltNum);
}
}
}
@@ -2466,7 +2467,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
if ( state.backtracking == 0 )
{

-									GrammarAST e = (el!=null?((GrammarAST)el.start):null);
+									GrammarAST e = (el!=null?((GrammarAST)el.Start):null);
if ( e.Type==ANTLRParser.ROOT || e.Type==ANTLRParser.BANG )
{
e = (GrammarAST)e.GetChild(0);
@@ -2503,7 +2504,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
if ( state.backtracking == 0 )
{

-									GrammarAST a = (a2!=null?((GrammarAST)a2.start):null);
+									GrammarAST a = (a2!=null?((GrammarAST)a2.Start):null);
if ( a.Type==ANTLRParser.ROOT || a.Type==ANTLRParser.BANG )
{
a = (GrammarAST)a.GetChild(0);
@@ -2872,7 +2873,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
if ( state.backtracking == 0 )
{

-							GrammarAST block = (GrammarAST)((GrammarAST)retval.start).GetChild(0);
+							GrammarAST block = (GrammarAST)((GrammarAST)retval.Start).GetChild(0);
IDictionary<string, object> opts=new Dictionary<string, object>();
opts["greedy"] = "false";
if ( grammar.type!=GrammarType.Lexer )
@@ -3295,11 +3296,11 @@ public partial class DefineGrammarItemsWalker : TreeParser
GrammarAST pred=null;


-			currentRewriteRule = ((GrammarAST)retval.start); // has to execute during backtracking
+			currentRewriteRule = ((GrammarAST)retval.Start); // has to execute during backtracking
if ( state.backtracking == 0 )
{
if ( grammar.BuildAST )
-					((GrammarAST)retval.start).rewriteRefsDeep = new HashSet<GrammarAST>();
+					((GrammarAST)retval.Start).rewriteRefsDeep = new HashSet<GrammarAST>();
}

try
@@ -3409,7 +3410,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
if ( state.backtracking == 0 )
{
// don't do if guessing
-				currentRewriteBlock=((GrammarAST)retval.start); // pts to BLOCK node
+				currentRewriteBlock=((GrammarAST)retval.Start); // pts to BLOCK node
currentRewriteBlock.rewriteRefsShallow = new HashSet<GrammarAST>();
currentRewriteBlock.rewriteRefsDeep = new HashSet<GrammarAST>();
}
@@ -3982,22 +3983,22 @@ public partial class DefineGrammarItemsWalker : TreeParser
Rule r = grammar.GetRule(currentRuleName);
var tokenRefsInAlt = r.GetTokenRefsInAlt(outerAltNum);
bool imaginary =
-					((GrammarAST)retval.start).Type==TOKEN_REF &&
-					!tokenRefsInAlt.Contains(((GrammarAST)retval.start).Text);
+					((GrammarAST)retval.Start).Type==TOKEN_REF &&
+					!tokenRefsInAlt.Contains(((GrammarAST)retval.Start).Text);
if ( !imaginary && grammar.BuildAST &&
-					 (((GrammarAST)retval.start).Type==RULE_REF ||
-					  ((GrammarAST)retval.start).Type==LABEL ||
-					  ((GrammarAST)retval.start).Type==TOKEN_REF ||
-					  ((GrammarAST)retval.start).Type==CHAR_LITERAL ||
-					  ((GrammarAST)retval.start).Type==STRING_LITERAL) )
+					 (((GrammarAST)retval.Start).Type==RULE_REF ||
+					  ((GrammarAST)retval.Start).Type==LABEL ||
+					  ((GrammarAST)retval.Start).Type==TOKEN_REF ||
+					  ((GrammarAST)retval.Start).Type==CHAR_LITERAL ||
+					  ((GrammarAST)retval.Start).Type==STRING_LITERAL) )
{
// track per block and for entire rewrite rule
if ( currentRewriteBlock!=null )
{
-						currentRewriteBlock.rewriteRefsShallow.Add(((GrammarAST)retval.start));
-						currentRewriteBlock.rewriteRefsDeep.Add(((GrammarAST)retval.start));
+						currentRewriteBlock.rewriteRefsShallow.Add(((GrammarAST)retval.Start));
+						currentRewriteBlock.rewriteRefsDeep.Add(((GrammarAST)retval.Start));
}
-					currentRewriteRule.rewriteRefsDeep.Add(((GrammarAST)retval.start));
+					currentRewriteRule.rewriteRefsDeep.Add(((GrammarAST)retval.Start));
}
}

@@ -4640,7 +4641,6 @@ public partial class DefineGrammarItemsWalker : TreeParser
int _s = s;
switch ( s )
{
-
case 0:
int LA37_27 = input.LA(1);

@@ -4656,7 +4656,6 @@ public partial class DefineGrammarItemsWalker : TreeParser
input.Seek(index37_27);
if ( s>=0 ) return s;
break;
-
case 1:
int LA37_28 = input.LA(1);

@@ -4682,7 +4681,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
#endregion DFA

#region Follow sets
-	public static class Follow
+	private static class Follow
{
public static readonly BitSet _LEXER_GRAMMAR_in_grammar_77 = new BitSet(new ulong[]{0x4UL});
public static readonly BitSet _grammarSpec_in_grammar_83 = new BitSet(new ulong[]{0x8UL});
diff --git a/Antlr3/Grammars/TreeToNFAConverter.cs b/Antlr3/Grammars/TreeToNFAConverter.cs
index f0afc6d..283632a 100644
--- a/Antlr3/Grammars/TreeToNFAConverter.cs
+++ b/Antlr3/Grammars/TreeToNFAConverter.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Grammars\\TreeToNFAConverter.g3 2009-04-24 11:05:59
+// $ANTLR 3.1.2 Grammars\\TreeToNFAConverter.g3 2009-09-30 13:28:47

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -57,9 +57,11 @@ using HashMap = System.Collections.Generic.Dictionary<object, object>;
namespace Antlr3.Grammars
{
/** Build an NFA from a tree representing an ANTLR grammar. */
+[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.1.2")]
+[System.CLSCompliant(false)]
public partial class TreeToNFAConverter : TreeParser
{
-	public static readonly string[] tokenNames = new string[] {
+	internal static readonly string[] tokenNames = new string[] {
"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", "ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARG_ACTION", "ARGLIST", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", "CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", "COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", "DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", "EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", "GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", "LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", "NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", "OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", "RET", "RETURNS", "REWRITE", "ROOT", "RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", "SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYN_SEMPRED", "SYNPRED", "TEMPLATE", "THROWS", "TOKEN_REF", "TOKENS", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", "WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT"
};
public const int EOF=-1;
@@ -1160,7 +1162,7 @@ public partial class TreeToNFAConverter : TreeParser
{

StateCluster g = (b!=null?b.g:default(StateCluster));
-								if ( (b!=null?((GrammarAST)b.start):null).SetValue!=null )
+								if ( (b!=null?((GrammarAST)b.Start):null).SetValue!=null )
{
// if block comes back as a set not BLOCK, make it
// a single ALT block
@@ -1178,11 +1180,11 @@ public partial class TreeToNFAConverter : TreeParser
// track decision if > 1 alts
if ( grammar.GetNumberOfAltsForDecisionNFA(g.left)>1 )
{
-										g.left.Description = grammar.GrammarTreeToString(((GrammarAST)retval.start),false);
-										g.left.SetDecisionASTNode((b!=null?((GrammarAST)b.start):null));
+										g.left.Description = grammar.GrammarTreeToString(((GrammarAST)retval.Start),false);
+										g.left.SetDecisionASTNode((b!=null?((GrammarAST)b.Start):null));
int d = grammar.AssignDecisionNumber( g.left );
grammar.SetDecisionNFA( d, g.left );
-										grammar.SetDecisionBlockAST(d, (b!=null?((GrammarAST)b.start):null));
+										grammar.SetDecisionBlockAST(d, (b!=null?((GrammarAST)b.Start):null));
}

// hook to end of rule node
@@ -1504,7 +1506,7 @@ public partial class TreeToNFAConverter : TreeParser
{
int LA33_1 = input.LA(2);

-				if ( ((grammar.IsValidSet(this,((GrammarAST)retval.start)) &&
+				if ( ((grammar.IsValidSet(this,((GrammarAST)retval.Start)) &&
!currentRuleName.Equals(Grammar.ArtificialTokensRuleName))) )
{
alt33=1;
@@ -1533,7 +1535,7 @@ public partial class TreeToNFAConverter : TreeParser
case 1:
// Grammars\\TreeToNFAConverter.g3:193:4: {...}? => set
{
-				if ( !((grammar.IsValidSet(this,((GrammarAST)retval.start)) &&
+				if ( !((grammar.IsValidSet(this,((GrammarAST)retval.Start)) &&
!currentRuleName.Equals(Grammar.ArtificialTokensRuleName))) )
{
if (state.backtracking>0) {state.failed=true; return retval;}
@@ -1706,7 +1708,6 @@ public partial class TreeToNFAConverter : TreeParser
// Grammars\\TreeToNFAConverter.g3:213:0: alternative returns [StateCluster g=null] : ^( ALT (e= element )+ EOA ) ;
private StateCluster alternative(  )
{
-
StateCluster g = null;

TreeToNFAConverter.element_return e = default(TreeToNFAConverter.element_return);
@@ -2023,7 +2024,7 @@ public partial class TreeToNFAConverter : TreeParser
if ( grammar.GetOption("output")==null )
{
ErrorManager.GrammarError(ErrorManager.MSG_REWRITE_OR_OP_WITH_NO_OUTPUT_OPTION,
-																	  grammar, ((GrammarAST)retval.start).Token, currentRuleName);
+																	  grammar, ((GrammarAST)retval.Start).Token, currentRuleName);
}

}
@@ -2236,11 +2237,11 @@ public partial class TreeToNFAConverter : TreeParser
if ( state.backtracking == 0 )
{
retval.g = factory.BuildRange(grammar.GetTokenType((a!=null?(input.TokenStream.ToString(
-					  input.TreeAdaptor.GetTokenStartIndex(a.start),
-					  input.TreeAdaptor.GetTokenStopIndex(a.start))):null)),
+					  input.TreeAdaptor.GetTokenStartIndex(a.Start),
+					  input.TreeAdaptor.GetTokenStopIndex(a.Start))):null)),
grammar.GetTokenType((b!=null?(input.TokenStream.ToString(
-					  input.TreeAdaptor.GetTokenStartIndex(b.start),
-					  input.TreeAdaptor.GetTokenStopIndex(b.start))):null)));
+					  input.TreeAdaptor.GetTokenStartIndex(b.Start),
+					  input.TreeAdaptor.GetTokenStopIndex(b.Start))):null)));
}

}
@@ -2477,7 +2478,7 @@ public partial class TreeToNFAConverter : TreeParser
TreeToNFAConverter.set_return set7 = default(TreeToNFAConverter.set_return);


-			GrammarAST blk = ((GrammarAST)retval.start);
+			GrammarAST blk = ((GrammarAST)retval.Start);
if ( blk.Type!=BLOCK ) {
blk = (GrammarAST)blk.GetChild(0);
}
@@ -2493,7 +2494,7 @@ public partial class TreeToNFAConverter : TreeParser
{
int LA42_1 = input.LA(2);

-				if ( ((grammar.IsValidSet(this,((GrammarAST)retval.start)))) )
+				if ( ((grammar.IsValidSet(this,((GrammarAST)retval.Start)))) )
{
alt42=1;
}
@@ -2539,7 +2540,7 @@ public partial class TreeToNFAConverter : TreeParser
case 1:
// Grammars\\TreeToNFAConverter.g3:287:4: {...}? => set
{
-				if ( !((grammar.IsValidSet(this,((GrammarAST)retval.start)))) )
+				if ( !((grammar.IsValidSet(this,((GrammarAST)retval.Start)))) )
{
if (state.backtracking>0) {state.failed=true; return retval;}
throw new FailedPredicateException(input, "ebnf", "grammar.IsValidSet(this,$start)");
@@ -2606,12 +2607,12 @@ public partial class TreeToNFAConverter : TreeParser
bg = factory.BuildAlternativeBlockFromSet(bg);
}
retval.g = factory.BuildAoptional(bg);
-								retval.g.left.Description = grammar.GrammarTreeToString(((GrammarAST)retval.start),false);
+								retval.g.left.Description = grammar.GrammarTreeToString(((GrammarAST)retval.Start),false);
// there is always at least one alt even if block has just 1 alt
int d = grammar.AssignDecisionNumber( retval.g.left );
grammar.SetDecisionNFA(d, retval.g.left);
grammar.SetDecisionBlockAST(d, blk);
-								retval.g.left.SetDecisionASTNode(((GrammarAST)retval.start));
+								retval.g.left.SetDecisionASTNode(((GrammarAST)retval.Start));

}

@@ -2640,17 +2641,17 @@ public partial class TreeToNFAConverter : TreeParser
}
retval.g = factory.BuildAstar(bg);
// track the loop back / exit decision point
-								bg.right.Description = "()* loopback of "+grammar.GrammarTreeToString(((GrammarAST)retval.start),false);
+								bg.right.Description = "()* loopback of "+grammar.GrammarTreeToString(((GrammarAST)retval.Start),false);
int d = grammar.AssignDecisionNumber( bg.right );
grammar.SetDecisionNFA(d, bg.right);
grammar.SetDecisionBlockAST(d, blk);
bg.right.SetDecisionASTNode(eob);
// make block entry state also have same decision for interpreting grammar
NFAState altBlockState = (NFAState)retval.g.left.GetTransition(0).target;
-								altBlockState.SetDecisionASTNode(((GrammarAST)retval.start));
+								altBlockState.SetDecisionASTNode(((GrammarAST)retval.Start));
altBlockState.DecisionNumber = d;
retval.g.left.DecisionNumber = d; // this is the bypass decision (2 alts)
-								retval.g.left.SetDecisionASTNode(((GrammarAST)retval.start));
+								retval.g.left.SetDecisionASTNode(((GrammarAST)retval.Start));

}

@@ -2680,14 +2681,14 @@ public partial class TreeToNFAConverter : TreeParser
retval.g = factory.BuildAplus(bg);
// don't make a decision on left edge, can reuse loop end decision
// track the loop back / exit decision point
-								bg.right.Description = "()+ loopback of "+grammar.GrammarTreeToString(((GrammarAST)retval.start),false);
+								bg.right.Description = "()+ loopback of "+grammar.GrammarTreeToString(((GrammarAST)retval.Start),false);
int d = grammar.AssignDecisionNumber( bg.right );
grammar.SetDecisionNFA(d, bg.right);
grammar.SetDecisionBlockAST(d, blk);
bg.right.SetDecisionASTNode(eob);
// make block entry state also have same decision for interpreting grammar
NFAState altBlockState = (NFAState)retval.g.left.GetTransition(0).target;
-								altBlockState.SetDecisionASTNode(((GrammarAST)retval.start));
+								altBlockState.SetDecisionASTNode(((GrammarAST)retval.Start));
altBlockState.DecisionNumber = d;

}
@@ -2746,7 +2747,7 @@ public partial class TreeToNFAConverter : TreeParser
if ( state.backtracking == 0 )
{

-								down = factory.BuildAtom(Label.DOWN, (e!=null?((GrammarAST)e.start):null));
+								down = factory.BuildAtom(Label.DOWN, (e!=null?((GrammarAST)e.Start):null));
// TODO set following states for imaginary nodes?
//el.followingNFAState = down.right;
retval.g = factory.BuildAB(retval.g,down);
@@ -2794,11 +2795,11 @@ public partial class TreeToNFAConverter : TreeParser
if ( state.backtracking == 0 )
{

-								up = factory.BuildAtom(Label.UP, (e!=null?((GrammarAST)e.start):null));
+								up = factory.BuildAtom(Label.UP, (e!=null?((GrammarAST)e.Start):null));
//el.followingNFAState = up.right;
retval.g = factory.BuildAB(retval.g,up);
// tree roots point at right edge of DOWN for LOOK computation later
-								((GrammarAST)retval.start).NFATreeDownState = down.left;
+								((GrammarAST)retval.Start).NFATreeDownState = down.left;

}

@@ -2824,7 +2825,6 @@ public partial class TreeToNFAConverter : TreeParser
// Grammars\\TreeToNFAConverter.g3:386:0: atom_or_notatom returns [StateCluster g=null] : ( atom[null] | ^(n= NOT (c= CHAR_LITERAL (ast1= ast_suffix )? |t= TOKEN_REF (ast3= ast_suffix )? | set ) ) );
private StateCluster atom_or_notatom(  )
{
-
StateCluster g = null;

GrammarAST n=null;
@@ -3566,7 +3566,7 @@ public partial class TreeToNFAConverter : TreeParser

IIntSet elements=new IntervalSet();
if ( state.backtracking == 0 )
-				((GrammarAST)retval.start).SetValue = elements; // track set for use by code gen
+				((GrammarAST)retval.Start).SetValue = elements; // track set for use by code gen

try
{
@@ -3717,7 +3717,6 @@ public partial class TreeToNFAConverter : TreeParser
// Grammars\\TreeToNFAConverter.g3:576:0: setRule returns [IIntSet elements=new IntervalSet()] : ^( RULE id= ID ( modifier )? ARG RET ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ^( BLOCK ( ^( OPTIONS ( . )* ) )? ( ^( ALT ( BACKTRACK_SEMPRED )? setElement[elements] EOA ) )+ EOB ) ( exceptionGroup )? EOR ) ;
private IIntSet setRule(  )
{
-
IIntSet elements = new IntervalSet();

GrammarAST id=null;
@@ -4342,7 +4341,6 @@ public partial class TreeToNFAConverter : TreeParser
// Grammars\\TreeToNFAConverter.g3:698:0: testBlockAsSet returns [int alts=0] options {backtrack=true; } : ^( BLOCK ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+ EOB ) ;
private int testBlockAsSet(  )
{
-
int alts = 0;

int testSetElement10 = default(int);
@@ -4450,7 +4448,6 @@ public partial class TreeToNFAConverter : TreeParser
// Grammars\\TreeToNFAConverter.g3:713:0: testSetRule returns [int alts=0] : ^( RULE id= ID ( modifier )? ARG RET ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ^( BLOCK ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+ EOB ) ( exceptionGroup )? EOR ) ;
private int testSetRule(  )
{
-
int alts = 0;

GrammarAST id=null;
@@ -4775,7 +4772,6 @@ public partial class TreeToNFAConverter : TreeParser
// Grammars\\TreeToNFAConverter.g3:733:0: testSetElement returns [int alts=1] : (c= CHAR_LITERAL |t= TOKEN_REF |{...}? =>s= STRING_LITERAL | ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL ) | testBlockAsSet | ^( NOT tse= testSetElement ) );
private int testSetElement(  )
{
-
int alts = 1;

GrammarAST c=null;
@@ -5014,7 +5010,7 @@ public partial class TreeToNFAConverter : TreeParser
#endregion DFA

#region Follow sets
-	public static class Follow
+	private static class Follow
{
public static readonly BitSet _LEXER_GRAMMAR_in_grammar_67 = new BitSet(new ulong[]{0x4UL});
public static readonly BitSet _grammarSpec_in_grammar_69 = new BitSet(new ulong[]{0x8UL});
diff --git a/Antlr3/Misc/BitSet.cs b/Antlr3/Misc/BitSet.cs
index d6ef754..f103277 100644
--- a/Antlr3/Misc/BitSet.cs
+++ b/Antlr3/Misc/BitSet.cs
@@ -38,6 +38,7 @@ namespace Antlr3.Misc

using ArgumentException = System.ArgumentException;
using Array = System.Array;
+    using CLSCompliant = System.CLSCompliantAttribute;
using Grammar = Antlr3.Tool.Grammar;
using ICloneable = System.ICloneable;
using IDictionary = System.Collections.IDictionary;
@@ -86,7 +87,8 @@ namespace Antlr3.Misc
}

/** Construction from a static array of longs */
-        public BitSet( ulong[] bits )
+        [CLSCompliant(false)]
+        public BitSet(ulong[] bits)
{
_bits = bits;
}
@@ -571,6 +573,7 @@ namespace Antlr3.Misc
return elems;
}

+        [CLSCompliant(false)]
public virtual ulong[] ToPackedArray()
{
return _bits;
diff --git a/Antlr3/Misc/IntervalSet.cs b/Antlr3/Misc/IntervalSet.cs
index 9876dd3..5dcbc8d 100644
--- a/Antlr3/Misc/IntervalSet.cs
+++ b/Antlr3/Misc/IntervalSet.cs
@@ -36,6 +36,7 @@ namespace Antlr3.Misc
using System.Linq;

using ArgumentException = System.ArgumentException;
+    using CLSCompliant = System.CLSCompliantAttribute;
using Grammar = Antlr3.Tool.Grammar;
using Label = Antlr3.Analysis.Label;
using NotImplementedException = System.NotImplementedException;
@@ -84,6 +85,7 @@ namespace Antlr3.Misc
return intervals.Sum( interval => interval.b - interval.a + 1 );
}
}
+        [CLSCompliant(false)]
public ICollection<Interval> Intervals
{
get
diff --git a/Antlr3/Misc/OrderedHashSet.cs b/Antlr3/Misc/OrderedHashSet.cs
index b0a7388..cc7a2b8 100644
--- a/Antlr3/Misc/OrderedHashSet.cs
+++ b/Antlr3/Misc/OrderedHashSet.cs
@@ -34,6 +34,7 @@ namespace Antlr3.Misc
{
using System.Collections.Generic;

+    using CLSCompliant = System.CLSCompliantAttribute;
using NotSupportedException = System.NotSupportedException;

/** A HashMap that remembers the order that the elements were added.
@@ -44,8 +45,10 @@ namespace Antlr3.Misc
public class OrderedHashSet<T> : ICollection<T>
{
/** Track the elements as they are added to the set */
+        [CLSCompliant(false)]
protected IList<T> _elements = new List<T>();

+        [CLSCompliant(false)]
protected HashSet<T> _elementSet = new HashSet<T>();

public T Get( int i )
diff --git a/Antlr3/Properties/AssemblyInfo.cs b/Antlr3/Properties/AssemblyInfo.cs
index 661bc3f..5ea12a0 100644
--- a/Antlr3/Properties/AssemblyInfo.cs
+++ b/Antlr3/Properties/AssemblyInfo.cs
@@ -30,6 +30,7 @@
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

+using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
@@ -45,6 +46,7 @@ using System.Runtime.InteropServices;
[assembly: AssemblyCopyright( "Copyright © Pixel Mine 2008" )]
[assembly: AssemblyTrademark( "" )]
[assembly: AssemblyCulture( "" )]
+[assembly: CLSCompliant(true)]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
diff --git a/Antlr3/Tool/AssignTokenTypesBehavior.cs b/Antlr3/Tool/AssignTokenTypesBehavior.cs
index a25f753..70164c4 100644
--- a/Antlr3/Tool/AssignTokenTypesBehavior.cs
+++ b/Antlr3/Tool/AssignTokenTypesBehavior.cs
@@ -38,15 +38,18 @@ namespace Antlr3.Tool
using Antlr.Runtime.Tree;
using Antlr3.Grammars;

+    using CLSCompliant = System.CLSCompliantAttribute;
using Label = Antlr3.Analysis.Label;

/** Move all of the functionality from assign.types.g grammar file. */
+    [CLSCompliant(false)]
public class AssignTokenTypesBehavior : AssignTokenTypesWalker
{
protected const int Unassigned = -1;
protected const int UnassignedInParserRule = -2;

protected IDictionary<string, int> stringLiterals = new SortedList<string, int>();
+        [CLSCompliant(false)]
protected IDictionary<string, int> tokens = new SortedList<string, int>();
protected IDictionary<string, string> aliases = new SortedList<string, string>();
protected IDictionary<string, string> aliasesReverseIndex = new Dictionary<string, string>();
diff --git a/Antlr3/Tool/AttributeScope.cs b/Antlr3/Tool/AttributeScope.cs
index d590274..3584b82 100644
--- a/Antlr3/Tool/AttributeScope.cs
+++ b/Antlr3/Tool/AttributeScope.cs
@@ -36,6 +36,7 @@ namespace Antlr3.Tool
using System.Linq;
using Antlr.Runtime.JavaExtensions;

+    using CLSCompliant = System.CLSCompliantAttribute;
using CodeGenerator = Antlr3.Codegen.CodeGenerator;
using IToken = Antlr.Runtime.IToken;

@@ -116,6 +117,7 @@ namespace Antlr3.Tool
return actions;
}
}
+        [CLSCompliant(false)]
public ICollection<Attribute> Attributes
{
get
diff --git a/Antlr3/Tool/BuildDependencyGenerator.cs b/Antlr3/Tool/BuildDependencyGenerator.cs
index 4469277..1d742be 100644
--- a/Antlr3/Tool/BuildDependencyGenerator.cs
+++ b/Antlr3/Tool/BuildDependencyGenerator.cs
@@ -100,6 +100,7 @@ namespace Antlr3.Tool
generator.LoadTemplates( language );
}

+        [CLSCompliant(false)]
public virtual string TokenVocab
{
get
@@ -108,6 +109,7 @@ namespace Antlr3.Tool
}
}

+        [CLSCompliant(false)]
public virtual CodeGenerator Generator
{
get
diff --git a/Antlr3/Tool/DOTGenerator.cs b/Antlr3/Tool/DOTGenerator.cs
index 4bbeb5b..a78effd 100644
--- a/Antlr3/Tool/DOTGenerator.cs
+++ b/Antlr3/Tool/DOTGenerator.cs
@@ -87,6 +87,7 @@ namespace Antlr3.Tool
arrowhead = value;
}
}
+        [CLSCompliant(false)]
public string RankDir
{
get
diff --git a/Antlr3/Tool/Grammar.cs b/Antlr3/Tool/Grammar.cs
index c3af4db..5b80c59 100644
--- a/Antlr3/Tool/Grammar.cs
+++ b/Antlr3/Tool/Grammar.cs
@@ -40,6 +40,7 @@ namespace Antlr3.Tool
using Antlr3.Misc;

using AngleBracketTemplateLexer = Antlr3.ST.Language.AngleBracketTemplateLexer;
+    using CLSCompliant = System.CLSCompliantAttribute;
using CodeGenerator = Antlr3.Codegen.CodeGenerator;
using CommonToken = Antlr.Runtime.CommonToken;
using Console = System.Console;
@@ -170,6 +171,7 @@ namespace Antlr3.Tool

public class LabelElementPair
{
+            [CLSCompliant(false)]
public Grammar _outer;
public IToken label;
public GrammarAST elementRef;
@@ -593,6 +595,7 @@ namespace Antlr3.Tool
}

#region Properties
+        [CLSCompliant(false)]
public IDictionary<string, IDictionary<string, object>> Actions
{
get
@@ -668,6 +671,7 @@ namespace Antlr3.Tool
defaultRuleModifier = value;
}
}
+        [CLSCompliant(false)]
public ICollection<Rule> DelegatedRuleReferences
{
get
@@ -704,6 +708,7 @@ namespace Antlr3.Tool
return GetDirectDelegates();
}
}
+        [CLSCompliant(false)]
public string FileName
{
get
@@ -877,6 +882,7 @@ namespace Antlr3.Tool
return IntervalSet.Of( Label.MIN_TOKEN_TYPE, MaxTokenType );
}
}
+        [CLSCompliant(false)]
public AntlrTool Tool
{
get
@@ -1300,7 +1306,8 @@ namespace Antlr3.Tool
/** for any syntactic predicates, we need to define rules for them; they will get
*  defined automatically like any other rule. :)
*/
-        protected virtual IList<GrammarAST> GetArtificialRulesForSyntacticPredicates( ANTLRParser parser,
+        [CLSCompliant(false)]
+        protected virtual IList<GrammarAST> GetArtificialRulesForSyntacticPredicates(ANTLRParser parser,
IDictionary<string, GrammarAST> nameToSynpredASTMap )
{
IList<GrammarAST> rules = new List<GrammarAST>();
@@ -3462,7 +3469,8 @@ namespace Antlr3.Tool
/** Given set tree like ( SET A B ), check that A and B
*  are both valid sets themselves, else we must tree like a BLOCK
*/
-        public virtual bool IsValidSet( TreeToNFAConverter nfabuilder, GrammarAST t )
+        [CLSCompliant(false)]
+        public virtual bool IsValidSet(TreeToNFAConverter nfabuilder, GrammarAST t)
{
bool valid = true;
try
@@ -3489,7 +3497,8 @@ namespace Antlr3.Tool
*
*		^( RULE ID modifier ARG RET SCOPE block EOR )
*/
-        public virtual IIntSet GetSetFromRule( TreeToNFAConverter nfabuilder, string ruleName )
+        [CLSCompliant(false)]
+        public virtual IIntSet GetSetFromRule(TreeToNFAConverter nfabuilder, string ruleName)
{
Rule r = GetRule( ruleName );
if ( r == null )
diff --git a/Antlr3/Tool/GrammarAST.cs b/Antlr3/Tool/GrammarAST.cs
index a046de4..1a7997d 100644
--- a/Antlr3/Tool/GrammarAST.cs
+++ b/Antlr3/Tool/GrammarAST.cs
@@ -38,6 +38,7 @@ namespace Antlr3.Tool
using Antlr3.Extensions;

using ANTLRParser = Antlr3.Grammars.ANTLRParser;
+    using CLSCompliant = System.CLSCompliantAttribute;
using CommonToken = Antlr.Runtime.CommonToken;
using DFA = Antlr3.Analysis.DFA;
using IIntSet = Antlr3.Misc.IIntSet;
@@ -76,6 +77,7 @@ namespace Antlr3.Tool
public DFA lookaheadDFA = null;

/** What NFA start state was built from this node? */
+        [CLSCompliant(false)]
public NFAState _nfaStartState = null;

/** This is used for TREE_BEGIN nodes to point into
@@ -147,6 +149,7 @@ namespace Antlr3.Tool
}

#region Properties
+        [CLSCompliant(false)]
public IDictionary<string, object> BlockOptions
{
get
@@ -177,6 +180,7 @@ namespace Antlr3.Tool
return (GrammarAST)parent.GetChild( parent.ChildCount - 1 );
}
}
+        [CLSCompliant(false)]
public DFA LookaheadDFA
{
get
@@ -199,6 +203,7 @@ namespace Antlr3.Tool
_nfaStartState = value;
}
}
+        [CLSCompliant(false)]
public IIntSet SetValue
{
get
diff --git a/Antlr3/Tool/GrammarSpelunker.cs b/Antlr3/Tool/GrammarSpelunker.cs
index c5b3660..ef9a16c 100644
--- a/Antlr3/Tool/GrammarSpelunker.cs
+++ b/Antlr3/Tool/GrammarSpelunker.cs
@@ -37,6 +37,7 @@ namespace Antlr3.Tool
#if BUILD_SPELUNKER
using Console = System.Console;
#endif
+    using CLSCompliant = System.CLSCompliantAttribute;
using Exception = System.Exception;
using Path = System.IO.Path;
using StringBuilder = System.Text.StringBuilder;
@@ -59,6 +60,7 @@ namespace Antlr3.Tool
{
protected string grammarFileName;
protected string token;
+        [CLSCompliant(false)]
protected Scanner scanner;

// grammar info / properties
@@ -176,6 +178,7 @@ namespace Antlr3.Tool
importedGrammars = null;
}

+        [CLSCompliant(false)]
public virtual string GrammarModifier
{
get
@@ -183,6 +186,7 @@ namespace Antlr3.Tool
return grammarModifier;
}
}
+        [CLSCompliant(false)]
public virtual string GrammarName
{
get
@@ -190,6 +194,7 @@ namespace Antlr3.Tool
return grammarName;
}
}
+        [CLSCompliant(false)]
public virtual string TokenVocab
{
get
@@ -197,6 +202,7 @@ namespace Antlr3.Tool
return tokenVocab;
}
}
+        [CLSCompliant(false)]
public virtual string Language
{
get
@@ -204,6 +210,7 @@ namespace Antlr3.Tool
return language;
}
}
+        [CLSCompliant(false)]
public virtual List<string> ImportedGrammars
{
get
diff --git a/Antlr3/Tool/Message.cs b/Antlr3/Tool/Message.cs
index a095a97..c94ace4 100644
--- a/Antlr3/Tool/Message.cs
+++ b/Antlr3/Tool/Message.cs
@@ -32,6 +32,7 @@

namespace Antlr3.Tool
{
+    using CLSCompliant = System.CLSCompliantAttribute;
using StringTemplate = Antlr3.ST.StringTemplate;
using Exception = System.Exception;

@@ -78,6 +79,7 @@ namespace Antlr3.Tool
this.arg2 = arg2;
}

+        [CLSCompliant(false)]
public virtual int Line
{
get
diff --git a/Antlr3/Tool/Rule.cs b/Antlr3/Tool/Rule.cs
index 89d0f4f..2805d84 100644
--- a/Antlr3/Tool/Rule.cs
+++ b/Antlr3/Tool/Rule.cs
@@ -37,6 +37,7 @@ namespace Antlr3.Tool
using Antlr.Runtime.JavaExtensions;

using ANTLRParser = Antlr3.Grammars.ANTLRParser;
+    using CLSCompliant = System.CLSCompliantAttribute;
using CodeGenerator = Antlr3.Codegen.CodeGenerator;
using CommonToken = Antlr.Runtime.CommonToken;
using IDictionary = System.Collections.IDictionary;
@@ -232,6 +233,7 @@ namespace Antlr3.Tool
return GetInlineActions();
}
}
+        [CLSCompliant(false)]
public IDictionary RuleLabels
{
get
@@ -239,6 +241,7 @@ namespace Antlr3.Tool
return GetRuleLabels();
}
}
+        [CLSCompliant(false)]
public IDictionary RuleListLabels
{
get

