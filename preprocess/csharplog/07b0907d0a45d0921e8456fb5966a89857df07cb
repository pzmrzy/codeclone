commit 07b0907d0a45d0921e8456fb5966a89857df07cb
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Fri Jan 21 08:09:26 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Fri Jan 21 08:09:26 2011 -0800

Removed the previous C# port of StringTemplate 4

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 7484]

diff --git a/Antlr3.Test/ST4/StringTemplateTestBase.cs b/Antlr3.Test/ST4/StringTemplateTestBase.cs
deleted file mode 100644
index e648d81..0000000
--- a/Antlr3.Test/ST4/StringTemplateTestBase.cs
+++ /dev/null
@@ -1,136 +0,0 @@
-﻿namespace AntlrUnitTests.ST4
-{
-    using Antlr.Runtime;
-    using Microsoft.VisualStudio.TestTools.UnitTesting;
-    using StringTemplate;
-    using Directory = System.IO.Directory;
-    using Environment = System.Environment;
-    using File = System.IO.File;
-    using IOException = System.IO.IOException;
-    using Path = System.IO.Path;
-    using Random = System.Random;
-    using StringBuilder = System.Text.StringBuilder;
-    using StringTemplate.Compiler;
-
-    public abstract class StringTemplateTestBase
-    {
-        public static readonly string tmpdir = Path.GetTempPath();
-        public static readonly string newline = Environment.NewLine;
-
-        private Random random = new Random();
-
-        public TestContext TestContext
-        {
-            get;
-            private set;
-        }
-
-        [ClassInitialize]
-        public virtual void ClassSetUp(TestContext testContext)
-        {
-            TestContext = testContext;
-        }
-
-        [TestInitialize]
-        public virtual void TestInitialize()
-        {
-            TemplateGroup.defaultGroup = new TemplateGroup();
-            StringTemplate.Compiler.TemplateCompiler.subtemplateCount = 0;
-        }
-
-        public void WriteFile(string dir, string fileName, string content)
-        {
-            try
-            {
-                string f = Path.Combine(dir, fileName);
-                if (!Directory.Exists(Path.GetDirectoryName(f)))
-                    Directory.CreateDirectory(Path.GetDirectoryName(f));
-
-                File.WriteAllText(f, content);
-            }
-            catch (IOException ioe)
-            {
-                TestContext.WriteLine("can't write file");
-                TestContext.WriteLine(ioe.StackTrace);
-            }
-        }
-
-        public void CheckTokens(string template, string expected)
-        {
-            CheckTokens(template, expected, '<', '>');
-        }
-
-
-        public void CheckTokens(string template, string expected, char delimiterStartChar, char delimiterStopChar)
-        {
-            TemplateLexer lexer = new TemplateLexer(new ANTLRStringStream(template), delimiterStartChar, delimiterStopChar);
-            CommonTokenStream tokens = new CommonTokenStream(lexer);
-            StringBuilder buf = new StringBuilder();
-            buf.Append("[");
-            int i = 1;
-            IToken t = tokens.LT(i);
-            while (t.Type != CharStreamConstants.EndOfFile)
-            {
-                if (i > 1)
-                    buf.Append(", ");
-                buf.Append(t);
-                i++;
-                t = tokens.LT(i);
-            }
-            buf.Append("]");
-            string result = buf.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        public class User
-        {
-            public int id;
-            public string name;
-
-            public User(int id, string name)
-            {
-                this.id = id;
-                this.name = name;
-            }
-
-            public string Name
-            {
-                get
-                {
-                    return name;
-                }
-            }
-        }
-
-        public class HashableUser : User
-        {
-            public HashableUser(int id, string name)
-                : base(id, name)
-            {
-            }
-
-            public override int GetHashCode()
-            {
-                return id;
-            }
-
-            public override bool Equals(object o)
-            {
-                if (o is HashableUser)
-                {
-                    HashableUser hu = (HashableUser)o;
-                    return this.id == hu.id && this.name.Equals(hu.name);
-                }
-
-                return false;
-            }
-        }
-
-        protected string GetRandomDir()
-        {
-            string randomDir = Path.Combine(tmpdir, "dir" + random.Next(100000));
-            Directory.CreateDirectory(randomDir);
-            return randomDir;
-        }
-    }
-}
diff --git a/Antlr3.Test/ST4/TestCompiler.cs b/Antlr3.Test/ST4/TestCompiler.cs
deleted file mode 100644
index 21ab411..0000000
--- a/Antlr3.Test/ST4/TestCompiler.cs
+++ /dev/null
@@ -1,330 +0,0 @@
-﻿namespace AntlrUnitTests.ST4
-{
-    using Microsoft.VisualStudio.TestTools.UnitTesting;
-    using StringTemplate;
-    using Antlr.Runtime.JavaExtensions;
-    using StringTemplate.Compiler;
-
-    [TestClass]
-    public class TestCompiler : StringTemplateTestBase
-    {
-        [TestMethod]
-        public void TestAttr()
-        {
-            string template = "hi <name>";
-            CompiledTemplate code = new TemplateCompiler().Compile(template);
-            string asmExpected =
-                "load_str 0, " +
-                "write, " +
-                "load_attr 1, " +
-                "write";
-            string asmResult = code.Instructions();
-            Assert.AreEqual(asmExpected, asmResult);
-            string stringsExpected = "[hi , name]";
-            string stringsResult = code.strings.ToElementString();
-            Assert.AreEqual(stringsExpected, stringsResult);
-        }
-
-        [TestMethod]
-        public void TestInclude()
-        {
-            string template = "hi <foo()>";
-            CompiledTemplate code = new TemplateCompiler().Compile(template);
-            string asmExpected =
-                "load_str 0, write, new 1, write";
-            string asmResult = code.Instructions();
-            Assert.AreEqual(asmExpected, asmResult);
-            string stringsExpected = "[hi , /foo]";
-            string stringsResult = code.strings.ToElementString();
-            Assert.AreEqual(stringsExpected, stringsResult);
-        }
-
-        [TestMethod]
-        public void TestProp()
-        {
-            string template = "hi <a.b>";
-            CompiledTemplate code = new TemplateCompiler().Compile(template);
-            string asmExpected =
-                "load_str 0, write, load_attr 1, load_prop 2, write";
-            string asmResult = code.Instructions();
-            Assert.AreEqual(asmExpected, asmResult);
-            string stringsExpected = "[hi , a, b]";
-            string stringsResult = code.strings.ToElementString();
-            Assert.AreEqual(stringsExpected, stringsResult);
-        }
-
-        [TestMethod]
-        public void TestProp2()
-        {
-            string template = "<u.id>: <u.name>";
-            CompiledTemplate code = new TemplateCompiler().Compile(template);
-            string asmExpected =
-                "load_attr 0, load_prop 1, write, load_str 2, write, " +
-                "load_attr 0, load_prop 3, write";
-            string asmResult = code.Instructions();
-            Assert.AreEqual(asmExpected, asmResult);
-            string stringsExpected = "[u, id, : , name]";
-            string stringsResult = code.strings.ToElementString();
-            Assert.AreEqual(stringsExpected, stringsResult);
-        }
-
-        [TestMethod]
-        public void TestMap()
-        {
-            string template = "hi <name:bold()>";
-            CompiledTemplate code = new TemplateCompiler().Compile(template);
-            string asmExpected =
-                "load_str 0, write, load_attr 1, load_str 2, map, write";
-            string asmResult = code.Instructions();
-            Assert.AreEqual(asmExpected, asmResult);
-            string stringsExpected = "[hi , name, /bold]";
-            string stringsResult = code.strings.ToElementString();
-            Assert.AreEqual(stringsExpected, stringsResult);
-        }
-
-        [TestMethod]
-        public void TestRepeatedMap()
-        {
-            string template = "hi <name:bold():italics()>";
-            CompiledTemplate code = new TemplateCompiler().Compile(template);
-            string asmExpected =
-                "load_str 0, " +
-                "write, " +
-                "load_attr 1, " +
-                "load_str 2, " +
-                "map, " +
-                "load_str 3, " +
-                "map, " +
-                "write";
-            string asmResult = code.Instructions();
-            Assert.AreEqual(asmExpected, asmResult);
-            string stringsExpected = "[hi , name, /bold, /italics]";
-            string stringsResult = code.strings.ToElementString();
-            Assert.AreEqual(stringsExpected, stringsResult);
-        }
-
-        [TestMethod]
-        public void TestRotMap()
-        {
-            string template = "hi <name:bold(),italics()>";
-            CompiledTemplate code = new TemplateCompiler().Compile(template);
-            string asmExpected =
-                "load_str 0, write, load_attr 1, load_str 2, load_str 3, rot_map 2, write";
-            string asmResult = code.Instructions();
-            Assert.AreEqual(asmExpected, asmResult);
-            string stringsExpected = "[hi , name, /bold, /italics]";
-            string stringsResult = code.strings.ToElementString();
-            Assert.AreEqual(stringsExpected, stringsResult);
-        }
-
-        [TestMethod]
-        public void TestAnonMap()
-        {
-            string template = "hi <name:{n | <n>}>";
-            CompiledTemplate code = new TemplateCompiler().Compile(template);
-            string asmExpected =
-                "load_str 0, write, load_attr 1, load_str 2, map, write";
-            string asmResult = code.Instructions();
-            Assert.AreEqual(asmExpected, asmResult);
-            string stringsExpected = "[hi , name, /_sub1]";
-            string stringsResult = code.strings.ToElementString();
-            Assert.AreEqual(stringsExpected, stringsResult);
-        }
-
-        [TestMethod]
-        public void TestIf()
-        {
-            string template = "go: <if(name)>hi, foo<endif>";
-            CompiledTemplate code = new TemplateCompiler().Compile(template);
-            string asmExpected =
-                "load_str 0, write, load_attr 1, brf 14, load_str 2, write";
-            string asmResult = code.Instructions();
-            Assert.AreEqual(asmExpected, asmResult);
-            string stringsExpected = "[go: , name, hi, foo]";
-            string stringsResult = code.strings.ToElementString();
-            Assert.AreEqual(stringsExpected, stringsResult);
-        }
-
-        [TestMethod]
-        public void TestIfElse()
-        {
-            string template = "go: <if(name)>hi, foo<else>bye<endif>";
-            CompiledTemplate code = new TemplateCompiler().Compile(template);
-            string asmExpected =
-                "load_str 0, " +
-                "write, " +
-                "load_attr 1, " +
-                "brf 17, " +
-                "load_str 2, " +
-                "write, " +
-                "br 21, " +
-                "load_str 3, " +
-                "write";
-            string asmResult = code.Instructions();
-            Assert.AreEqual(asmExpected, asmResult);
-            string stringsExpected = "[go: , name, hi, foo, bye]";
-            string stringsResult = code.strings.ToElementString();
-            Assert.AreEqual(stringsExpected, stringsResult);
-        }
-
-        [TestMethod]
-        public void TestElseIf()
-        {
-            string template = "go: <if(name)>hi, foo<elseif(user)>a user<endif>";
-            CompiledTemplate code = new TemplateCompiler().Compile(template);
-            string asmExpected =
-                "load_str 0, " +
-                "write, " +
-                "load_attr 1, " +
-                "brf 17, " +
-                "load_str 2, " +
-                "write, " +
-                "br 27, " +
-                "load_attr 3, " +
-                "brf 27, " +
-                "load_str 4, " +
-                "write";
-            string asmResult = code.Instructions();
-            Assert.AreEqual(asmExpected, asmResult);
-            string stringsExpected = "[go: , name, hi, foo, user, a user]";
-            string stringsResult = code.strings.ToElementString();
-            Assert.AreEqual(stringsExpected, stringsResult);
-        }
-
-        [TestMethod]
-        public void TestElseIfElse()
-        {
-            string template = "go: <if(name)>hi, foo<elseif(user)>a user<else>bye<endif>";
-            CompiledTemplate code = new TemplateCompiler().Compile(template);
-            string asmExpected =
-                "load_str 0, " +
-                "write, " +
-                "load_attr 1, " +
-                "brf 17, " +
-                "load_str 2, " +
-                "write, " +
-                "br 34, " +
-                "load_attr 3, " +
-                "brf 30, " +
-                "load_str 4, " +
-                "write, " +
-                "br 34, " +
-                "load_str 5, " +
-                "write";
-            string asmResult = code.Instructions();
-            Assert.AreEqual(asmExpected, asmResult);
-            string stringsExpected = "[go: , name, hi, foo, user, a user, bye]";
-            string stringsResult = code.strings.ToElementString();
-            Assert.AreEqual(stringsExpected, stringsResult);
-        }
-
-        [TestMethod]
-        public void TestOption()
-        {
-            string template = "hi <name; separator=\"x\">";
-            CompiledTemplate code = new TemplateCompiler().Compile(template);
-            string asmExpected =
-                "load_str 0, write, load_attr 1, options, load_str 2, store_option 3, write_opt";
-            string asmResult = code.Instructions();
-            Assert.AreEqual(asmExpected, asmResult);
-            string stringsExpected = "[hi , name, x]";
-            string stringsResult = code.strings.ToElementString();
-            Assert.AreEqual(stringsExpected, stringsResult);
-        }
-
-        [TestMethod]
-        public void TestOptionAsTemplate()
-        {
-            string template = "hi <name; separator={, }>";
-            CompiledTemplate code = new TemplateCompiler().Compile(template);
-            string asmExpected =
-                "load_str 0, write, load_attr 1, options, new 2, store_option 3, write_opt";
-            string asmResult = code.Instructions();
-            Assert.AreEqual(asmExpected, asmResult);
-            string stringsExpected = "[hi , name, /_sub1]";
-            string stringsResult = code.strings.ToElementString();
-            Assert.AreEqual(stringsExpected, stringsResult);
-        }
-
-        [TestMethod]
-        public void TestOptions()
-        {
-            string template = "hi <name; anchor, wrap=foo(), separator=\", \">";
-            CompiledTemplate code = new TemplateCompiler().Compile(template);
-            string asmExpected =
-                "load_str 0, " +
-                "write, " +
-                "load_attr 1, " +
-                "options, " +
-                "load_str 2, " +
-                "store_option 0, " +
-                "new 3, " +
-                "store_option 4, " +
-                "load_str 4, " +
-                "store_option 3, " +
-                "write_opt";
-            string stringsExpected = // the ", , ," is the ", " separator string
-                "[hi , name, true, /foo, , ]";
-            string stringsResult = code.strings.ToElementString();
-            Assert.AreEqual(stringsExpected, stringsResult);
-            string asmResult = code.Instructions();
-            Assert.AreEqual(asmExpected, asmResult);
-        }
-
-        [TestMethod]
-        public void TestEmptyList()
-        {
-            string template = "<[]>";
-            CompiledTemplate code = new TemplateCompiler().Compile(template);
-            string asmExpected = "list, write";
-            string asmResult = code.Instructions();
-            Assert.AreEqual(asmExpected, asmResult);
-            string stringsExpected = "[]";
-            string stringsResult = code.strings.ToElementString();
-            Assert.AreEqual(stringsExpected, stringsResult);
-        }
-
-        [TestMethod]
-        public void TestList()
-        {
-            string template = "<[a,b]>";
-            CompiledTemplate code = new TemplateCompiler().Compile(template);
-            string asmExpected = "list, load_attr 0, add, load_attr 1, add, write";
-            string asmResult = code.Instructions();
-            Assert.AreEqual(asmExpected, asmResult);
-            string stringsExpected = "[a, b]";
-            string stringsResult = code.strings.ToElementString();
-            Assert.AreEqual(stringsExpected, stringsResult);
-        }
-
-        [TestMethod]
-        public void TestEmbeddedRegion()
-        {
-            string template = "<@r>foo<@end>";
-            // compile as if in root dir and in template 'a'
-            CompiledTemplate code = new TemplateCompiler(TemplateName.Root, new TemplateName("a")).Compile(template);
-            string asmExpected =
-                "new 0, write";
-            string asmResult = code.Instructions();
-            Assert.AreEqual(asmExpected, asmResult);
-            string stringsExpected = "[/region__a__r]";
-            string stringsResult = code.strings.ToElementString();
-            Assert.AreEqual(stringsExpected, stringsResult);
-        }
-
-        [TestMethod]
-        public void TestRegion()
-        {
-            string template = "x:<@r()>";
-            // compile as if in root dir and in template 'a'
-            CompiledTemplate code = new TemplateCompiler(TemplateName.Root, new TemplateName("a")).Compile(template);
-            string asmExpected =
-                "load_str 0, write, new 1, write";
-            string asmResult = code.Instructions();
-            Assert.AreEqual(asmExpected, asmResult);
-            string stringsExpected = "[x:, /region__a__r]";
-            string stringsResult = code.strings.ToElementString();
-            Assert.AreEqual(stringsExpected, stringsResult);
-        }
-    }
-}
diff --git a/Antlr3.Test/ST4/TestCoreBasics.cs b/Antlr3.Test/ST4/TestCoreBasics.cs
deleted file mode 100644
index ebb319b..0000000
--- a/Antlr3.Test/ST4/TestCoreBasics.cs
+++ /dev/null
@@ -1,539 +0,0 @@
-﻿namespace AntlrUnitTests.ST4
-{
-    using Microsoft.VisualStudio.TestTools.UnitTesting;
-    using StringTemplate;
-    using ArrayList = System.Collections.ArrayList;
-    using StringWriter = System.IO.StringWriter;
-    using Path = System.IO.Path;
-    using StringTemplate.Compiler;
-    using System.Collections.Generic;
-    using Antlr.Runtime;
-
-    [TestClass]
-    public class TestCoreBasics : StringTemplateTestBase
-    {
-        [TestMethod]
-        public void TestNullAttr()
-        {
-            string template = "hi <name>!";
-            Template st = new Template(template);
-            string expected =
-                "hi !";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestAttr()
-        {
-            string template = "hi <name>!";
-            Template st = new Template(template);
-            st.Add("name", "Ter");
-            string expected = "hi Ter!";
-            string result = st.Render();
-            st.code.Dump();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestSetUnknownAttr()
-        {
-            string templates =
-                "t() ::= <<hi <name>!>>\n";
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-            WriteFile(tmpdir, "t.stg", templates);
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
-            var st = group.GetInstanceOf("t");
-            st.Add("name", "Ter");
-            string expected = "hi Ter!";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-
-            // check error now
-            expected = "context [t]  can't set attribute name; template t has no such attribute" + newline;
-            result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestMultiAttr()
-        {
-            string template = "hi <name>!";
-            Template st = new Template(template);
-            st.Add("name", "Ter");
-            st.Add("name", "Tom");
-            string expected =
-                "hi TerTom!";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestAttrIsList()
-        {
-            string template = "hi <name>!";
-            Template st = new Template(template);
-            var names = new ArrayList() { "Ter", "Tom" };
-            st.Add("name", names);
-            st.Add("name", "Sumana"); // shouldn't alter my version of names list!
-            string expected =
-                "hi TerTomSumana!";  // ST sees 3 names
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-
-            Assert.IsTrue(names.Count == 2); // my names list is still just 2
-        }
-
-        [TestMethod]
-        public void TestAttrIsArray()
-        {
-            string template = "hi <name>!";
-            Template st = new Template(template);
-            string[] names = new string[] { "Ter", "Tom" };
-            st.Add("name", names);
-            st.Add("name", "Sumana"); // shouldn't alter my version of names list!
-            string expected =
-                "hi TerTomSumana!";  // ST sees 3 names
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestProp()
-        {
-            string template = "<u.id>: <u.name>";
-            Template st = new Template(template);
-            st.Add("u", new User(1, "parrt"));
-            string expected = "1: parrt";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestInclude()
-        {
-            string template = "load <box()>;";
-            Template st = new Template(template);
-            st.code.nativeGroup.DefineTemplate(new TemplateName("box"),
-                                    "kewl" + newline +
-                                    "daddy"
-                                    );
-            st.Add("name", "Ter");
-            string expected =
-                "load kewl" + newline +
-                "daddy;";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestIncludeWithArg()
-        {
-            string template = "load <box(x=\"arg\")>;";
-            Template st = new Template(template);
-            st.code.nativeGroup.DefineTemplate(new TemplateName("box"), "kewl <x> daddy");
-            st.Add("name", "Ter");
-            string expected = "load kewl arg daddy;";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestIncludeWithSingleUnnamedArg()
-        {
-            string template = "load <box(\"arg\")>;";
-            Template st = new Template(template);
-            IDictionary<string, FormalArgument> args =
-                new Dictionary<string, FormalArgument>();
-            args["x"] = new FormalArgument("x");
-            st.code.nativeGroup.DefineTemplate(TemplateName.Root,
-                                               new CommonToken(GroupParser.ID, "box"),
-                                               args, "kewl <x> daddy");
-            st.Add("name", "Ter");
-            string expected = "load kewl arg daddy;";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestIncludeWithArg2()
-        {
-            string template = "load <box(x=\"arg\", y=foo())>;";
-            Template st = new Template(template);
-            st.code.nativeGroup.DefineTemplate(new TemplateName("box"), "kewl <x> <y> daddy");
-            st.code.nativeGroup.DefineTemplate(new TemplateName("foo"), "blech");
-            st.Add("name", "Ter");
-            string expected = "load kewl arg blech daddy;";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestIncludeWithNestedArgs()
-        {
-            string template = "load <box(y=foo(x=\"arg\"))>;";
-            Template st = new Template(template);
-            st.code.nativeGroup.DefineTemplate(new TemplateName("box"), "kewl <y> daddy");
-            st.code.nativeGroup.DefineTemplate(new TemplateName("foo"), "blech <x>");
-            st.Add("name", "Ter");
-            string expected = "load kewl blech arg daddy;";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestDefineTemplate()
-        {
-            TemplateGroup group = new TemplateGroup();
-            group.DefineTemplate(new TemplateName("inc"), "<it>+1");
-            group.DefineTemplate(new TemplateName("test"), "hi <name>!");
-            Template st = group.GetInstanceOf("test");
-            st.Add("name", "Ter");
-            st.Add("name", "Tom");
-            st.Add("name", "Sumana");
-            string expected =
-                "hi TerTomSumana!";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestMap()
-        {
-            TemplateGroup group = new TemplateGroup();
-            group.DefineTemplate(new TemplateName("inc"), "[<it>]");
-            group.DefineTemplate(new TemplateName("test"), "hi <name:inc()>!");
-            Template st = group.GetInstanceOf("test");
-            st.Add("name", "Ter");
-            st.Add("name", "Tom");
-            st.Add("name", "Sumana");
-            string expected =
-                "hi [Ter][Tom][Sumana]!";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestMapWithExprAsTemplateName()
-        {
-            string templates =
-                "d ::= [\"foo\":\"bold\"]\n" +
-                "test() ::= \"<name:(d.foo)()>\"\n" +
-                "bold() ::= <<*<it>*>>\n";
-            WriteFile(tmpdir, "t.stg", templates);
-            var group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
-            var st = group.GetInstanceOf("test");
-            st.Add("name", "Ter");
-            st.Add("name", "Tom");
-            st.Add("name", "Sumana");
-            string expected = "*Ter**Tom**Sumana*";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestParallelMap()
-        {
-            TemplateGroup group = new TemplateGroup();
-            group.DefineTemplate(new TemplateName("test"), "hi <names,phones:{n,p | <n>:<p>;}>");
-            Template st = group.GetInstanceOf("test");
-            st.Add("names", "Ter");
-            st.Add("names", "Tom");
-            st.Add("names", "Sumana");
-            st.Add("phones", "x5001");
-            st.Add("phones", "x5002");
-            st.Add("phones", "x5003");
-            string expected =
-                "hi Ter:x5001;Tom:x5002;Sumana:x5003;";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestParallelMapWith3Versus2Elements()
-        {
-            TemplateGroup group = new TemplateGroup();
-            group.DefineTemplate(new TemplateName("test"), "hi <names,phones:{n,p | <n>:<p>;}>");
-            Template st = group.GetInstanceOf("test");
-            st.Add("names", "Ter");
-            st.Add("names", "Tom");
-            st.Add("names", "Sumana");
-            st.Add("phones", "x5001");
-            st.Add("phones", "x5002");
-            string expected =
-                "hi Ter:x5001;Tom:x5002;Sumana:;";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestMapIndexes()
-        {
-            TemplateGroup group = new TemplateGroup();
-            group.DefineTemplate(new TemplateName("inc"), "<i>:<it>");
-            group.DefineTemplate(new TemplateName("test"), "<name:inc(); separator=\", \">");
-            Template st = group.GetInstanceOf("test");
-            st.Add("name", "Ter");
-            st.Add("name", "Tom");
-            st.Add("name", null); // don't count this one
-            st.Add("name", "Sumana");
-            string expected =
-                "1:Ter, 2:Tom, 3:Sumana";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestMapSingleValue()
-        {
-            TemplateGroup group = new TemplateGroup();
-            group.DefineTemplate(new TemplateName("a"), "[<it>]");
-            group.DefineTemplate(new TemplateName("test"), "hi <name:a()>!");
-            Template st = group.GetInstanceOf("test");
-            st.Add("name", "Ter");
-            string expected = "hi [Ter]!";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestRepeatedMap()
-        {
-            TemplateGroup group = new TemplateGroup();
-            group.DefineTemplate(new TemplateName("a"), "[<it>]");
-            group.DefineTemplate(new TemplateName("b"), "(<it>)");
-            group.DefineTemplate(new TemplateName("test"), "hi <name:a():b()>!");
-            Template st = group.GetInstanceOf("test");
-            st.Add("name", "Ter");
-            st.Add("name", "Tom");
-            st.Add("name", "Sumana");
-            string expected =
-                "hi ([Ter])([Tom])([Sumana])!";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestRoundRobinMap()
-        {
-            TemplateGroup group = new TemplateGroup();
-            group.DefineTemplate(new TemplateName("a"), "[<it>]");
-            group.DefineTemplate(new TemplateName("b"), "(<it>)");
-            group.DefineTemplate(new TemplateName("test"), "hi <name:a(),b()>!");
-            Template st = group.GetInstanceOf("test");
-            st.Add("name", "Ter");
-            st.Add("name", "Tom");
-            st.Add("name", "Sumana");
-            string expected =
-                "hi [Ter](Tom)[Sumana]!";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestTrueCond()
-        {
-            string template = "<if(name)>works<endif>";
-            Template st = new Template(template);
-            st.Add("name", "Ter");
-            string expected = "works";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestFalseCond()
-        {
-            string template = "<if(name)>works<endif>";
-            Template st = new Template(template);
-            string expected = "";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestNotTrueCond()
-        {
-            string template = "<if(!name)>works<endif>";
-            Template st = new Template(template);
-            st.Add("name", "Ter");
-            string expected = "";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestNotFalseCond()
-        {
-            string template = "<if(!name)>works<endif>";
-            Template st = new Template(template);
-            string expected = "works";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestTrueCondWithElse()
-        {
-            string template = "<if(name)>works<else>fail<endif>";
-            Template st = new Template(template);
-            st.Add("name", "Ter");
-            string expected = "works";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestFalseCondWithElse()
-        {
-            string template = "<if(name)>fail<else>works<endif>";
-            Template st = new Template(template);
-            string expected = "works";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestElseIf()
-        {
-            string template = "<if(name)>fail<elseif(id)>works<else>fail<endif>";
-            Template st = new Template(template);
-            st.Add("id", "2DF3DF");
-            string expected = "works";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestElseIfNoElseAllFalse()
-        {
-            string template = "<if(name)>fail<elseif(id)>fail<endif>";
-            Template st = new Template(template);
-            string expected = "";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestElseIfAllExprFalse()
-        {
-            string template = "<if(name)>fail<elseif(id)>fail<else>works<endif>";
-            Template st = new Template(template);
-            string expected = "works";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestOr()
-        {
-            string template = "<if(name||notThere)>works<else>fail<endif>";
-            Template st = new Template(template);
-            st.Add("name", "Ter");
-            string expected = "works";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestAnd()
-        {
-            string template = "<if(name&&notThere)>fail<else>works<endif>";
-            Template st = new Template(template);
-            st.Add("name", "Ter");
-            string expected = "works";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestAndNot()
-        {
-            string template = "<if(name&&!notThere)>works<else>fail<endif>";
-            Template st = new Template(template);
-            st.Add("name", "Ter");
-            string expected = "works";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestITDoesntPropagate()
-        {
-            TemplateGroup group = new TemplateGroup();
-            group.DefineTemplate(new TemplateName("foo"), "<it>");   // <it> not visible
-            string template = "<names:{<foo()>}>"; // <it> visible only to {...} here
-            group.DefineTemplate(new TemplateName("test"), template);
-            Template st = group.GetInstanceOf("test");
-            st.Add("names", "Ter");
-            st.Add("names", "Tom");
-            string expected = "";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestCharLiterals()
-        {
-            Template st = new Template(
-                    "Foo <\\n><\\n><\\t> bar\n"
-                    );
-            StringWriter sw = new StringWriter();
-            st.Write(new AutoIndentWriter(sw, "\n")); // force \n as newline
-            string result = sw.ToString();
-            string expecting = "Foo \n\n\t bar\n";     // expect \n in output
-            Assert.AreEqual(expecting, result);
-
-            st = new Template(
-                    "Foo <\\n><\\t> bar" + newline);
-            sw = new StringWriter();
-            st.Write(new AutoIndentWriter(sw, "\n")); // force \n as newline
-            expecting = "Foo \n\t bar\n";     // expect \n in output
-            result = sw.ToString();
-            Assert.AreEqual(expecting, result);
-
-            st = new Template(
-                    "Foo<\\ >bar<\\n>");
-            sw = new StringWriter();
-            st.Write(new AutoIndentWriter(sw, "\n")); // force \n as newline
-            result = sw.ToString();
-            expecting = "Foo bar\n"; // forced \n
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestUnicodeLiterals()
-        {
-            Template st = new Template(
-                    "Foo <\\uFEA5><\\n><\\u00C2> bar\n"
-                    );
-            string expecting = "Foo \ufea5" + newline + "\u00C2 bar" + newline;
-            string result = st.Render();
-            Assert.AreEqual(expecting, result);
-
-            st = new Template(
-                    "Foo <\\uFEA5><\\n><\\u00C2> bar" + newline);
-            expecting = "Foo \ufea5" + newline + "\u00C2 bar" + newline;
-            result = st.Render();
-            Assert.AreEqual(expecting, result);
-
-            st = new Template(
-                    "Foo<\\ >bar<\\n>");
-            expecting = "Foo bar" + newline;
-            result = st.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestSubtemplateExpr()
-        {
-            string template = "<{name\n}>";
-            Template st = new Template(template);
-            string expected =
-                "name" + newline;
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-    }
-}
diff --git a/Antlr3.Test/ST4/TestDebugEvents.cs b/Antlr3.Test/ST4/TestDebugEvents.cs
deleted file mode 100644
index 187a05c..0000000
--- a/Antlr3.Test/ST4/TestDebugEvents.cs
+++ /dev/null
@@ -1,112 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace AntlrUnitTests.ST4
-{
-    using System.Collections.Generic;
-    using Microsoft.VisualStudio.TestTools.UnitTesting;
-    using StringTemplate;
-    using StringTemplate.Debug;
-    using Interpreter = StringTemplate.Interpreter;
-    using ST = StringTemplate.Template;
-    using STGroup = StringTemplate.TemplateGroup;
-    using STGroupFile = StringTemplate.TemplateGroupFile;
-    using String = System.String;
-    using StringWriter = System.IO.StringWriter;
-    using Antlr.Runtime.JavaExtensions;
-    using IList = System.Collections.IList;
-
-    [TestClass]
-    public class TestDebugEvents : StringTemplateTestBase
-    {
-        [TestMethod]
-        public void TestString()
-        {
-            string templates =
-                "t() ::= <<foo>>" + newline;
-
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
-            group.Debug = true;
-            DebugTemplate template = (DebugTemplate)group.GetInstanceOf("t");
-            IList<InterpEvent> events = template.GetEvents();
-            String expected =
-                "[EvalExprEvent{self=t(),start=0,stop=2,expr=foo}," +
-                " EvalTemplateEvent{self=t(),start=0,stop=2}]";
-            String result = ((IList)events).ToElementString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestAttribute()
-        {
-            String templates =
-                "t(x) ::= << <x> >>" + newline;
-
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
-            group.Debug = true;
-            DebugTemplate template = (DebugTemplate)group.GetInstanceOf("t");
-            IList<InterpEvent> events = template.GetEvents();
-            String expected =
-                "[EvalExprEvent{self=t(),start=0,stop=-1,expr=<x>}," +
-                " EvalExprEvent{self=t(),start=0,stop=0,expr= }," +
-                " EvalTemplateEvent{self=t(),start=0,stop=0}]";
-            String result = ((IList)events).ToElementString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestTemplateCall()
-        {
-            String templates =
-                "t(x) ::= <<[<u()>]>>\n" +
-                "u() ::= << <x> >>\n";
-
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
-            group.Debug = true;
-            DebugTemplate template = (DebugTemplate)group.GetInstanceOf("t");
-            IList<InterpEvent> events = template.GetEvents();
-            String expected =
-                "[EvalExprEvent{self=t(),start=0,stop=0,expr=[}," +
-                " EvalExprEvent{self=u(),start=1,stop=0,expr=<x>}," +
-                " EvalExprEvent{self=u(),start=1,stop=1,expr= }," +
-                " EvalTemplateEvent{self=u(),start=1,stop=1}," +
-                " EvalExprEvent{self=t(),start=1,stop=1,expr=<u()>}," +
-                " EvalExprEvent{self=t(),start=2,stop=2,expr=]}," +
-                " EvalTemplateEvent{self=t(),start=0,stop=2}]";
-            String result = ((IList)events).ToElementString();
-            Assert.AreEqual(expected, result);
-        }
-    }
-}
diff --git a/Antlr3.Test/ST4/TestDictionaries.cs b/Antlr3.Test/ST4/TestDictionaries.cs
deleted file mode 100644
index 0533e4b..0000000
--- a/Antlr3.Test/ST4/TestDictionaries.cs
+++ /dev/null
@@ -1,265 +0,0 @@
-﻿namespace AntlrUnitTests.ST4
-{
-    using System.Collections.Generic;
-    using Microsoft.VisualStudio.TestTools.UnitTesting;
-    using StringTemplate;
-    using Path = System.IO.Path;
-
-    [TestClass]
-    public class TestDictionaries : StringTemplateTestBase
-    {
-        [TestMethod]
-        public void TestDict()
-        {
-            string templates =
-                    "typeInit ::= [\"int\":\"0\", \"float\":\"0.0\"] " + newline +
-                    "var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
-                    ;
-            WriteFile(tmpdir, "test.stg", templates);
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "test.stg"));
-            Template st = group.GetInstanceOf("var");
-            st.Add("type", "int");
-            st.Add("name", "x");
-            string expecting = "int x = 0;";
-            string result = st.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestDictValuesAreTemplates()
-        {
-            string templates =
-                    "typeInit ::= [\"int\":{0<w>}, \"float\":{0.0<w>}] " + newline +
-                    "var(type,w,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
-                    ;
-            WriteFile(tmpdir, "test.stg", templates);
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "test.stg"));
-            Template st = group.GetInstanceOf("var");
-            st.Add("w", "L");
-            st.Add("type", "int");
-            st.Add("name", "x");
-            string expecting = "int x = 0L;";
-            string result = st.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestDictKeyLookupViaTemplate()
-        {
-            // Make sure we try rendering stuff to string if not found as regular object
-            string templates =
-                    "typeInit ::= [\"int\":{0<w>}, \"float\":{0.0<w>}] " + newline +
-                    "var(type,w,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
-                    ;
-            WriteFile(tmpdir, "test.stg", templates);
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "test.stg"));
-            Template st = group.GetInstanceOf("var");
-            st.Add("w", "L");
-            st.Add("type", new Template("int"));
-            st.Add("name", "x");
-            string expecting = "int x = 0L;";
-            string result = st.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestDictKeyLookupAsNonToStringableObject()
-        {
-            // Make sure we try rendering stuff to string if not found as regular object
-            string templates =
-                    "foo(m,k) ::= \"<m.(k)>\"" + newline
-                    ;
-            WriteFile(tmpdir, "test.stg", templates);
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "test.stg"));
-            Template st = group.GetInstanceOf("foo");
-            IDictionary<HashableUser, string> m = new Dictionary<HashableUser, string>();
-            m[new HashableUser(99, "parrt")] = "first";
-            m[new HashableUser(172036, "tombu")] = "second";
-            m[new HashableUser(391, "sriram")] = "third";
-            st.Add("m", m);
-            st.Add("k", new HashableUser(172036, "tombu"));
-            string expecting = "second";
-            string result = st.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestDictMissingDefaultValueIsEmpty()
-        {
-            string templates =
-                    "typeInit ::= [\"int\":\"0\", \"float\":\"0.0\"] " + newline +
-                    "var(type,w,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
-                    ;
-            WriteFile(tmpdir, "test.stg", templates);
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "test.stg"));
-            Template st = group.GetInstanceOf("var");
-            st.Add("w", "L");
-            st.Add("type", "double"); // double not in typeInit map
-            st.Add("name", "x");
-            string expecting = "double x = ;"; // weird, but tests default value is key
-            string result = st.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestDictHiddenByFormalArg()
-        {
-            string templates =
-                    "typeInit ::= [\"int\":\"0\", \"float\":\"0.0\"] " + newline +
-                    "var(typeInit,type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
-                    ;
-            WriteFile(tmpdir, "test.stg", templates);
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "test.stg"));
-            Template st = group.GetInstanceOf("var");
-            st.Add("type", "int");
-            st.Add("name", "x");
-            string expecting = "int x = ;";
-            string result = st.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestDictEmptyValueAndAngleBracketStrings()
-        {
-            string templates =
-                    "typeInit ::= [\"int\":\"0\", \"float\":, \"double\":<<0.0L>>] " + newline +
-                    "var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
-                    ;
-            WriteFile(tmpdir, "test.stg", templates);
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "test.stg"));
-            Template st = group.GetInstanceOf("var");
-            st.Add("type", "float");
-            st.Add("name", "x");
-            string expecting = "float x = ;";
-            string result = st.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestDictDefaultValue()
-        {
-            string templates =
-                    "typeInit ::= [\"int\":\"0\", default:\"null\"] " + newline +
-                    "var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
-                    ;
-            WriteFile(tmpdir, "test.stg", templates);
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "test.stg"));
-            Template st = group.GetInstanceOf("var");
-            st.Add("type", "UserRecord");
-            st.Add("name", "x");
-            string expecting = "UserRecord x = null;";
-            string result = st.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestDictEmptyDefaultValue()
-        {
-            string templates =
-                    "typeInit ::= [\"int\":\"0\", default:] " + newline +
-                    "var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
-                    ;
-            WriteFile(tmpdir, "test.stg", templates);
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "test.stg"));
-            Template st = group.GetInstanceOf("var");
-            st.Add("type", "UserRecord");
-            st.Add("name", "x");
-            string expecting = "UserRecord x = ;";
-            string result = st.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestDictDefaultValueIsKey()
-        {
-            string templates =
-                    "typeInit ::= [\"int\":\"0\", default:key] " + newline +
-                    "var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
-                    ;
-            WriteFile(tmpdir, "test.stg", templates);
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "test.stg"));
-            Template st = group.GetInstanceOf("var");
-            st.Add("type", "UserRecord");
-            st.Add("name", "x");
-            string expecting = "UserRecord x = key;";
-            string result = st.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        /**
-         * Test that a map can have only the default entry.
-         */
-        [TestMethod]
-        public void TestDictDefaultStringAsKey()
-        {
-            string templates =
-                    "typeInit ::= [\"default\":\"foo\"] " + newline +
-                    "var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
-                    ;
-            WriteFile(tmpdir, "test.stg", templates);
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "test.stg"));
-            Template st = group.GetInstanceOf("var");
-            st.Add("type", "default");
-            st.Add("name", "x");
-            string expecting = "default x = foo;";
-            string result = st.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        /**
-         * Test that a map can return a <b>string</b> with the word: default.
-         */
-        [TestMethod]
-        public void TestDictDefaultIsDefaultString()
-        {
-            string templates =
-                    "map ::= [default: \"default\"] " + newline +
-                    "t() ::= << <map.(\"1\")> >>" + newline
-                    ;
-            WriteFile(tmpdir, "test.stg", templates);
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "test.stg"));
-            Template st = group.GetInstanceOf("t");
-            string expecting = " default ";
-            string result = st.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestDictViaEnclosingTemplates()
-        {
-            string templates =
-                    "typeInit ::= [\"int\":\"0\", \"float\":\"0.0\"] " + newline +
-                    "intermediate(type,name) ::= \"<var(...)>\"" + newline +
-                    "var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
-                    ;
-            WriteFile(tmpdir, "test.stg", templates);
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "test.stg"));
-            Template st = group.GetInstanceOf("intermediate");
-            st.Add("type", "int");
-            st.Add("name", "x");
-            string expecting = "int x = 0;";
-            string result = st.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestDictViaEnclosingTemplates2()
-        {
-            string templates =
-                    "typeInit ::= [\"int\":\"0\", \"float\":\"0.0\"] " + newline +
-                    "intermediate(stuff) ::= \"<stuff>\"" + newline +
-                    "var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
-                    ;
-            WriteFile(tmpdir, "test.stg", templates);
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "test.stg"));
-            Template interm = group.GetInstanceOf("intermediate");
-            Template var = group.GetInstanceOf("var");
-            var.Add("type", "int");
-            var.Add("name", "x");
-            interm.Add("stuff", var);
-            string expecting = "int x = 0;";
-            string result = interm.Render();
-            Assert.AreEqual(expecting, result);
-        }
-    }
-}
diff --git a/Antlr3.Test/ST4/TestDollarDelimiters.cs b/Antlr3.Test/ST4/TestDollarDelimiters.cs
deleted file mode 100644
index f276e6b..0000000
--- a/Antlr3.Test/ST4/TestDollarDelimiters.cs
+++ /dev/null
@@ -1,84 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace AntlrUnitTests.ST4
-{
-    using Microsoft.VisualStudio.TestTools.UnitTesting;
-
-    [TestClass]
-    public class TestDollarDelimiters : StringTemplateTestBase
-    {
-        [TestMethod]
-        public void TestSimpleAttr()
-        {
-            string template = "hi $name$";
-            string expected = "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='$',<LDELIM>,1:3], [@2,4:7='name',<ID>,1:4], [@3,8:8='$',<RDELIM>,1:8]]";
-            CheckTokens(template, expected, '$', '$');
-        }
-
-        [TestMethod]
-        public void TestString()
-        {
-            string template = "hi $foo(a=\"$\")$";
-            string expected = "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='$',<LDELIM>,1:3], [@2,4:6='foo',<ID>,1:4], [@3,7:7='(',<LPAREN>,1:7], [@4,8:8='a',<ID>,1:8], [@5,9:9='=',<EQUALS>,1:9], [@6,10:12='\"$\"',<STRING>,1:10], [@7,13:13=')',<RPAREN>,1:13], [@8,14:14='$',<RDELIM>,1:14]]";
-            CheckTokens(template, expected, '$', '$');
-        }
-
-        [TestMethod]
-        public void TestEscInString()
-        {
-            string template = "hi $foo(a=\"$\\\"\")$"; // "hi $foo(a="$\"")$"
-            string expected = "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='$',<LDELIM>,1:3], [@2,4:6='foo',<ID>,1:4], [@3,7:7='(',<LPAREN>,1:7], [@4,8:8='a',<ID>,1:8], [@5,9:9='=',<EQUALS>,1:9], [@6,10:0='\"$\"\"',<STRING>,1:10], [@7,15:15=')',<RPAREN>,1:15], [@8,16:16='$',<RDELIM>,1:16]]";
-            CheckTokens(template, expected, '$', '$');
-        }
-
-        [TestMethod]
-        public void TestSubtemplate()
-        {
-            string template = "hi $names:{n | $n$}$";
-            string expected =
-                "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='$',<LDELIM>,1:3], [@2,4:8='names',<ID>,1:4], " +
-                "[@3,9:9=':',<COLON>,1:9], [@4,10:10='{',<LCURLY>,1:10], [@5,11:11='n',<ID>,1:11], " +
-                "[@6,13:13='|',<PIPE>,1:13], [@7,15:15='$',<LDELIM>,1:15], [@8,16:16='n',<ID>,1:16], " +
-                "[@9,17:17='$',<RDELIM>,1:17], [@10,18:18='}',<RCURLY>,1:18], [@11,19:19='$',<RDELIM>,1:19]]";
-            CheckTokens(template, expected, '$', '$');
-        }
-
-        [TestMethod]
-        public void TestNestedSubtemplate()
-        {
-            string template = "hi $names:{n | $n:{$it$}$}$";
-            string expected = "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='$',<LDELIM>,1:3], [@2,4:8='names',<ID>,1:4], [@3,9:9=':',<COLON>,1:9], [@4,10:10='{',<LCURLY>,1:10], [@5,11:11='n',<ID>,1:11], [@6,13:13='|',<PIPE>,1:13], [@7,15:15='$',<LDELIM>,1:15], [@8,16:16='n',<ID>,1:16], [@9,17:17=':',<COLON>,1:17], [@10,18:18='{',<LCURLY>,1:18], [@11,19:19='$',<LDELIM>,1:19], [@12,20:21='it',<ID>,1:20], [@13,22:22='$',<RDELIM>,1:22], [@14,23:23='}',<RCURLY>,1:23], [@15,24:24='$',<RDELIM>,1:24], [@16,25:25='}',<RCURLY>,1:25], [@17,26:26='$',<RDELIM>,1:26]]";
-            CheckTokens(template, expected, '$', '$');
-        }
-    }
-}
diff --git a/Antlr3.Test/ST4/TestFunctions.cs b/Antlr3.Test/ST4/TestFunctions.cs
deleted file mode 100644
index c2d9a32..0000000
--- a/Antlr3.Test/ST4/TestFunctions.cs
+++ /dev/null
@@ -1,419 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace AntlrUnitTests.ST4
-{
-    using Microsoft.VisualStudio.TestTools.UnitTesting;
-    using StringTemplate;
-    using ArrayList = System.Collections.ArrayList;
-    using Hashtable = System.Collections.Hashtable;
-    using IDictionary = System.Collections.IDictionary;
-    using Path = System.IO.Path;
-
-    [TestClass]
-    public class TestFunctions : StringTemplateTestBase
-    {
-        [TestMethod]
-        public void TestFirst()
-        {
-            string template = "<first(names)>";
-            Template st = new Template(template);
-            var names = new ArrayList() { "Ter", "Tom" };
-            st.Add("names", names);
-            string expected = "Ter";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestLength()
-        {
-            string template = "<length(names)>";
-            Template st = new Template(template);
-            var names = new ArrayList() { "Ter", "Tom" };
-            st.Add("names", names);
-            string expected = "2";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestFirstOp()
-        {
-            Template e = new Template(
-                    "<first(names)>"
-                );
-            e.Add("names", "Ter");
-            e.Add("names", "Tom");
-            e.Add("names", "Sriram");
-            string expecting = "Ter";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestTruncOp()
-        {
-            Template e = new Template(
-                    "<trunc(names); separator=\", \">"
-                );
-            e.Add("names", "Ter");
-            e.Add("names", "Tom");
-            e.Add("names", "Sriram");
-            string expecting = "Ter, Tom";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestRestOp()
-        {
-            Template e = new Template(
-                    "<rest(names); separator=\", \">"
-                );
-            e.Add("names", "Ter");
-            e.Add("names", "Tom");
-            e.Add("names", "Sriram");
-            string expecting = "Tom, Sriram";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestRestOpEmptyList()
-        {
-            Template e = new Template(
-                    "<rest(names); separator=\", \">"
-                );
-            e.Add("names", new ArrayList());
-            string expecting = "";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestReUseOfRestResult()
-        {
-            string templates =
-                "a(names) ::= \"<b(rest(names))>\"" + newline +
-                "b(x) ::= \"<x>, <x>\"" + newline
-                ;
-            WriteFile(tmpdir, "t.stg", templates);
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
-            Template e = group.GetInstanceOf("a");
-            var names = new ArrayList();
-            names.Add("Ter");
-            names.Add("Tom");
-            e.Add("names", names);
-            string expecting = "Tom, Tom";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestLastOp()
-        {
-            Template e = new Template(
-                    "<last(names)>"
-                );
-            e.Add("names", "Ter");
-            e.Add("names", "Tom");
-            e.Add("names", "Sriram");
-            string expecting = "Sriram";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestStripOp()
-        {
-            var e = new Template(
-                    "<strip(names); null=\"n/a\">"
-                );
-            e.Add("names", null);
-            e.Add("names", "Tom");
-            e.Add("names", null);
-            e.Add("names", null);
-            e.Add("names", "Sriram");
-            e.Add("names", null);
-            string expecting = "TomSriram";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestCombinedOp()
-        {
-            // replace first of yours with first of mine
-            Template e = new Template(
-                    "<[first(mine),rest(yours)]; separator=\", \">"
-                );
-            e.Add("mine", "1");
-            e.Add("mine", "2");
-            e.Add("mine", "3");
-            e.Add("yours", "a");
-            e.Add("yours", "b");
-            string expecting = "1, b";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestCatListAndSingleAttribute()
-        {
-            // replace first of yours with first of mine
-            Template e = new Template(
-                    "<[mine,yours]; separator=\", \">"
-                );
-            e.Add("mine", "1");
-            e.Add("mine", "2");
-            e.Add("mine", "3");
-            e.Add("yours", "a");
-            string expecting = "1, 2, 3, a";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestReUseOfCat()
-        {
-            string templates =
-                "a(mine,yours) ::= \"<b([mine,yours])>\"" + newline +
-                "b(x) ::= \"<x>, <x>\"" + newline
-                ;
-            WriteFile(tmpdir, "t.stg", templates);
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
-            Template e = group.GetInstanceOf("a");
-            var mine = new ArrayList();
-            mine.Add("Ter");
-            mine.Add("Tom");
-            e.Add("mine", mine);
-            var yours = new ArrayList();
-            yours.Add("Foo");
-            e.Add("yours", yours);
-            string expecting = "TerTomFoo, TerTomFoo";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestCatListAndEmptyAttributes()
-        {
-            // + is overloaded to be cat strings and cat lists so the
-            // two operands (from left to right) determine which way it
-            // goes.  In this case, x+mine is a list so everything from their
-            // to the right becomes list cat.
-            Template e = new Template(
-                    "<[x,mine,y,yours,z]; separator=\", \">"
-                );
-            e.Add("mine", "1");
-            e.Add("mine", "2");
-            e.Add("mine", "3");
-            e.Add("yours", "a");
-            string expecting = "1, 2, 3, a";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestNestedOp()
-        {
-            Template e = new Template(
-                    "<first(rest(names))>" // gets 2nd element
-                );
-            e.Add("names", "Ter");
-            e.Add("names", "Tom");
-            e.Add("names", "Sriram");
-            string expecting = "Tom";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestFirstWithOneAttributeOp()
-        {
-            Template e = new Template(
-                    "<first(names)>"
-                );
-            e.Add("names", "Ter");
-            string expecting = "Ter";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestLastWithOneAttributeOp()
-        {
-            Template e = new Template(
-                    "<last(names)>"
-                );
-            e.Add("names", "Ter");
-            string expecting = "Ter";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestLastWithLengthOneListAttributeOp()
-        {
-            Template e = new Template(
-                    "<last(names)>"
-                );
-            e.Add("names", new ArrayList() { "Ter" });
-            string expecting = "Ter";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestRestWithOneAttributeOp()
-        {
-            Template e = new Template(
-                    "<rest(names)>"
-                );
-            e.Add("names", "Ter");
-            string expecting = "";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestRestWithLengthOneListAttributeOp()
-        {
-            Template e = new Template(
-                    "<rest(names)>"
-                );
-            e.Add("names", new ArrayList() { "Ter" });
-            string expecting = "";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestRepeatedRestOp()
-        {
-            Template e = new Template(
-                    "<rest(names)>, <rest(names)>" // gets 2nd element
-                );
-            e.Add("names", "Ter");
-            e.Add("names", "Tom");
-            string expecting = "Tom, Tom";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestIncomingLists()
-        {
-            Template e = new Template(
-                    "<rest(names)>, <rest(names)>" // gets 2nd element
-                );
-            e.Add("names", "Ter");
-            e.Add("names", "Tom");
-            string expecting = "Tom, Tom";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestFirstWithCatAttribute()
-        {
-            Template e = new Template(
-                    "<first([names,phones])>"
-                );
-            e.Add("names", "Ter");
-            e.Add("names", "Tom");
-            e.Add("phones", "1");
-            e.Add("phones", "2");
-            string expecting = "Ter";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestFirstWithListOfMaps()
-        {
-            Template e = new Template(
-                    "<first(maps).Ter>"
-                );
-            IDictionary m1 = new Hashtable();
-            IDictionary m2 = new Hashtable();
-            m1["Ter"] = "x5707";
-            e.Add("maps", m1);
-            m2["Tom"] = "x5332";
-            e.Add("maps", m2);
-            string expecting = "x5707";
-            Assert.AreEqual(expecting, e.Render());
-
-            var list = new ArrayList() { m1, m2 };
-            e.Add("maps", list);
-            expecting = "x5707";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestFirstWithListOfMaps2()
-        {
-            Template e = new Template(
-                    "<first(maps):{ m | <m>!}>"
-                );
-            IDictionary m1 = new Hashtable();
-            IDictionary m2 = new Hashtable();
-            m1["Ter"] = "x5707";
-            e.Add("maps", m1);
-            m2["Tom"] = "x5332";
-            e.Add("maps", m2);
-            string expecting = "x5707!";
-            Assert.AreEqual(expecting, e.Render());
-            var list = new ArrayList() { m1, m2 };
-            e.Add("maps", list);
-            expecting = "x5707!";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestTrim()
-        {
-            Template e = new Template(
-                    "<trim(name)>"
-                );
-            e.Add("name", " Ter  \n");
-            string expecting = "Ter";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestStrlen()
-        {
-            Template e = new Template(
-                    "<strlen(name)>"
-                );
-            e.Add("name", "012345");
-            string expecting = "6";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestReverse()
-        {
-            Template e = new Template(
-                    "<reverse(names); separator=\", \">"
-                );
-            e.Add("names", "Ter");
-            e.Add("names", "Tom");
-            e.Add("names", "Sriram");
-            string expecting = "Sriram, Tom, Ter";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-    }
-}
diff --git a/Antlr3.Test/ST4/TestGroupSyntax.cs b/Antlr3.Test/ST4/TestGroupSyntax.cs
deleted file mode 100644
index 590d753..0000000
--- a/Antlr3.Test/ST4/TestGroupSyntax.cs
+++ /dev/null
@@ -1,180 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace AntlrUnitTests.ST4
-{
-    using Microsoft.VisualStudio.TestTools.UnitTesting;
-    using Path = System.IO.Path;
-    using STGroup = StringTemplate.TemplateGroup;
-    using STGroupFile = StringTemplate.TemplateGroupFile;
-    using String = System.String;
-
-    [TestClass]
-    public class TestGroupSyntax : StringTemplateTestBase
-    {
-        [TestMethod]
-        public void TestSimpleGroup()
-        {
-            String templates =
-                "t() ::= <<foo>>" + newline;
-
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            String expected =
-                "t() ::= <<" + newline +
-                "foo" + newline +
-                ">>" + newline;
-            String result = group.Show();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestMultiTemplates()
-        {
-            String templates =
-                "ta() ::= \"[<it>]\"" + newline +
-                "duh() ::= <<hi there>>" + newline +
-                "wow() ::= <<last>>" + newline;
-
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            String expected =
-                "ta() ::= <<" + newline +
-                "[<it>]" + newline +
-                ">>" + newline +
-                "duh() ::= <<" + newline +
-                "hi there" + newline +
-                ">>" + newline +
-                "wow() ::= <<" + newline +
-                "last" + newline +
-                ">>" + newline;
-            String result = group.Show();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestSingleTemplateWithArgs()
-        {
-            String templates =
-                "t(a,b) ::= \"[<a>]\"" + newline;
-
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            String expected =
-                "t(a,b) ::= <<" + newline +
-                "[<a>]" + newline +
-                ">>" + newline;
-            String result = group.Show();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestDefaultValues()
-        {
-            String templates =
-                "t(a={def1},b=\"def2\") ::= \"[<a>]\"" + newline;
-
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            String expected =
-                "t(a={def1},b=\"def2\") ::= <<" + newline +
-                "[<a>]" + newline +
-                ">>" + newline;
-            String result = group.Show();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestDefaultValueTemplateWithArg()
-        {
-            String templates =
-                "t(a={x | 2*<x>}) ::= \"[<a>]\"" + newline;
-
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            String expected =
-                "t(a={x | 2*<x>}) ::= <<" + newline +
-                "[<a>]" + newline +
-                ">>" + newline;
-            String result = group.Show();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestNestedTemplateInGroupFile()
-        {
-            String templates =
-                "t(a) ::= \"<a:{x | <x:{<it>}>}>\"" + newline;
-
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            String expected =
-                "t(a) ::= <<" + newline +
-                "<a:{x | <x:{<it>}>}>" + newline +
-                ">>" + newline;
-            String result = group.Show();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestNestedDefaultValueTemplate()
-        {
-            String templates =
-                "t(a={x | <x:{<it>}>}) ::= \"ick\"" + newline;
-
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            String expected =
-                "t(a={x | <x:{<it>}>}) ::= <<" + newline +
-                "ick" + newline +
-                ">>" + newline;
-            String result = group.Show();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestNestedDefaultValueTemplateWithEscapes()
-        {
-            String templates =
-                "t(a={x | \\< <x:{<it>\\}}>}) ::= \"[<a>]\"" + newline;
-
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            String expected =
-                "t(a={x | \\< <x:{<it>\\}}>}) ::= <<" + newline +
-                "[<a>]" + newline +
-                ">>" + newline;
-            String result = group.Show();
-            Assert.AreEqual(expected, result);
-        }
-    }
-}
diff --git a/Antlr3.Test/ST4/TestGroupSyntaxErrors.cs b/Antlr3.Test/ST4/TestGroupSyntaxErrors.cs
deleted file mode 100644
index d0e5927..0000000
--- a/Antlr3.Test/ST4/TestGroupSyntaxErrors.cs
+++ /dev/null
@@ -1,253 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace AntlrUnitTests.ST4
-{
-    using Microsoft.VisualStudio.TestTools.UnitTesting;
-    using Path = System.IO.Path;
-    using STGroup = StringTemplate.TemplateGroup;
-    using STGroupFile = StringTemplate.TemplateGroupFile;
-    using String = System.String;
-    using StringTemplate;
-
-    [TestClass]
-    public class TestGroupSyntaxErrors : StringTemplateTestBase
-    {
-        [TestMethod]
-        public void TestMissingTemplate()
-        {
-            String templates =
-                "foo() ::= \n";
-            WriteFile(tmpdir, "t.stg", templates);
-
-            STGroup group = null;
-            ITemplateErrorListener errors = new ErrorBuffer();
-            group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ErrorManager.ErrorListener = errors;
-            group.Load(); // force load
-            String expected = "t.stg 2:0: missing template at '<EOF>'" + newline;
-            String result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestParen()
-        {
-            String templates =
-                "foo( ::= << >>\n";
-            WriteFile(tmpdir, "t.stg", templates);
-
-            STGroup group = null;
-            var errors = new ErrorBuffer();
-            group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ErrorManager.ErrorListener = errors;
-            group.Load(); // force load
-            String expected = "t.stg 1:5: missing ')' at '::='" + newline;
-            String result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestNewlineInString()
-        {
-            String templates =
-                "foo() ::= \"\nfoo\"\n";
-            WriteFile(tmpdir, "t.stg", templates);
-
-            STGroup group = null;
-            var errors = new ErrorBuffer();
-            group = new STGroupFile(tmpdir + "/" + "t.stg");
-            ErrorManager.ErrorListener = errors;
-            group.Load(); // force load
-            String expected = "t.stg 1:11: \\n in string" + newline;
-            String result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestParen2()
-        {
-            String templates =
-                "foo) ::= << >>\n" +
-                "bar() ::= <<bar>>\n";
-            WriteFile(tmpdir, "t.stg", templates);
-
-            STGroup group = null;
-            var errors = new ErrorBuffer();
-            group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ErrorManager.ErrorListener = errors;
-            group.Load(); // force load
-            String expected = "t.stg 1:0: garbled template definition starting at 'foo'" + newline;
-            String result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestArg()
-        {
-            String templates =
-                "foo(a,) ::= << >>\n";
-            WriteFile(tmpdir, "t.stg", templates);
-
-            STGroup group = null;
-            var errors = new ErrorBuffer();
-            group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ErrorManager.ErrorListener = errors;
-            group.Load(); // force load
-            String expected = "t.stg 1:6: missing ID at ')'" + newline;
-            String result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestArg2()
-        {
-            String templates =
-                "foo(a,,) ::= << >>\n";
-            WriteFile(tmpdir, "t.stg", templates);
-
-            STGroup group = null;
-            ErrorBuffer errors = new ErrorBuffer();
-            group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ErrorManager.ErrorListener = errors;
-            group.Load(); // force load
-            String expected = "t.stg 1:6: missing ID at ','" + newline +
-                              "t.stg 1:7: missing ID at ')'" + newline;
-            String result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestArg3()
-        {
-            String templates =
-                "foo(a b) ::= << >>\n";
-            WriteFile(tmpdir, "t.stg", templates);
-
-            STGroup group = null;
-            ErrorBuffer errors = new ErrorBuffer();
-            group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ErrorManager.ErrorListener = errors;
-            group.Load(); // force load
-            String expected = "t.stg 1:6: extraneous input 'b' expecting ')'" + newline;
-            String result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestErrorWithinTemplate()
-        {
-            String templates =
-                "foo(a) ::= \"<a b>\"\n";
-            WriteFile(tmpdir, "t.stg", templates);
-
-            STGroup group = null;
-            ErrorBuffer errors = new ErrorBuffer();
-            group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ErrorManager.ErrorListener = errors;
-            group.Load(); // force load
-            String expected = "1:15: 'b' came as a complete surprise to me" + newline;
-            String result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestMap()
-        {
-            String templates =
-                "d ::= []\n";
-            WriteFile(tmpdir, "t.stg", templates);
-
-            STGroup group = null;
-            ErrorBuffer errors = new ErrorBuffer();
-            group = new STGroupFile(tmpdir + "/" + "t.stg");
-            ErrorManager.ErrorListener = errors;
-            group.Load(); // force load
-            String expected = "t.stg 1:7: missing dictionary entry at ']'" + newline;
-            String result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestMap2()
-        {
-            String templates =
-                "d ::= [\"k\":]\n";
-            WriteFile(tmpdir, "t.stg", templates);
-
-            STGroup group = null;
-            ErrorBuffer errors = new ErrorBuffer();
-            group = new STGroupFile(tmpdir + "/" + "t.stg");
-            ErrorManager.ErrorListener = errors;
-            group.Load(); // force load
-            String expected = "t.stg 1:11: missing value for key at ']'" + newline;
-            String result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestMap3()
-        {
-            String templates =
-                "d ::= [\"k\":{dfkj}}]\n"; // extra }
-            WriteFile(tmpdir, "t.stg", templates);
-
-            STGroup group = null;
-            ErrorBuffer errors = new ErrorBuffer();
-            group = new STGroupFile(tmpdir + "/" + "t.stg");
-            ErrorManager.ErrorListener = errors;
-            group.Load(); // force load
-            String expected = "t.stg 1:17: invalid character '}'" + newline;
-            String result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestUnterminatedString()
-        {
-            String templates =
-                "f() ::= \""; // extra }
-            WriteFile(tmpdir, "t.stg", templates);
-
-            STGroup group = null;
-            ErrorBuffer errors = new ErrorBuffer();
-            group = new STGroupFile(tmpdir + "/" + "t.stg");
-            ErrorManager.ErrorListener = errors;
-            group.Load(); // force load
-            String expected =
-                "t.stg 1:9: unterminated string" + newline +
-                "t.stg 1:9: missing template at '<EOF>'" + newline;
-            String result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-    }
-}
diff --git a/Antlr3.Test/ST4/TestGroups.cs b/Antlr3.Test/ST4/TestGroups.cs
deleted file mode 100644
index 474c58b..0000000
--- a/Antlr3.Test/ST4/TestGroups.cs
+++ /dev/null
@@ -1,470 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace AntlrUnitTests.ST4
-{
-    using Microsoft.VisualStudio.TestTools.UnitTesting;
-    using StringTemplate;
-    using ArgumentException = System.ArgumentException;
-    using Path = System.IO.Path;
-    using ST = StringTemplate.Template;
-    using STErrorListener = StringTemplate.ITemplateErrorListener;
-    using STGroup = StringTemplate.TemplateGroup;
-    using STGroupDir = StringTemplate.TemplateGroupDirectory;
-    using STGroupFile = StringTemplate.TemplateGroupFile;
-    using String = System.String;
-
-    [TestClass]
-    public class TestGroups : StringTemplateTestBase
-    {
-        [TestMethod]
-        public void TestSimpleGroup()
-        {
-            string dir = GetRandomDir();
-            string a =
-                "a(x) ::= <<" + newline +
-                "foo" + newline +
-                ">>" + newline;
-            WriteFile(dir, "a.st", a);
-            TemplateGroup group = new TemplateGroupDirectory(dir);
-            Template st = group.GetInstanceOf("a");
-            string expected = "foo" + newline;
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestGroupWithTwoTemplates()
-        {
-            string dir = GetRandomDir();
-            string a =
-                "a(x) ::= <<" + newline +
-                "foo" + newline +
-                ">>" + newline;
-            WriteFile(dir, "a.st", a);
-            string b =
-                "b() ::= \"bar\"" + newline;
-            WriteFile(dir, "b.st", b);
-            TemplateGroup group = new TemplateGroupDirectory(dir);
-            Template st1 = group.GetInstanceOf("a");
-            Template st2 = group.GetInstanceOf("b");
-            string expected = "foo" + newline + "bar";
-            string result = st1.Render() + st2.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestSubdir()
-        {
-            // /randomdir/a and /randomdir/subdir/b
-            string dir = GetRandomDir();
-            string a =
-                "a(x) ::= <<" + newline +
-                "foo" + newline +
-                ">>" + newline;
-            WriteFile(dir, "a.st", a);
-            string b =
-                "b() ::= \"bar\"" + newline;
-            WriteFile(Path.Combine(dir, "subdir"), "b.st", b);
-            TemplateGroup group = new TemplateGroupDirectory(dir);
-            Template st1 = group.GetInstanceOf("a");
-            Template st2 = group.GetInstanceOf("subdir/b");
-            string expected = "foo" + newline + "bar";
-            string result = st1.Render() + st2.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestAbsoluteTemplateRef()
-        {
-            // /randomdir/a and /randomdir/subdir/b
-            string dir = GetRandomDir();
-            string a =
-                "a(x) ::= << </subdir/b()> >>\n";
-            WriteFile(dir, "a.st", a);
-            string b =
-                "b() ::= <<bar>>\n";
-            WriteFile(dir + "/subdir", "b.st", b);
-            TemplateGroup group = new TemplateGroupDirectory(dir);
-            Template st = group.GetInstanceOf("a");
-            st.code.Dump();
-            string expected = " bar ";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestGroupFileInDir()
-        {
-            // /randomdir/a and /randomdir/group.stg with b and c templates
-            string dir = GetRandomDir();
-            string a =
-                "a(x) ::= <<\n" +
-                "foo\n" +
-                ">>\n";
-            WriteFile(dir, "a.st", a);
-            string groupFile =
-                "b() ::= \"bar\"\n" +
-                "c() ::= \"duh\"\n";
-            WriteFile(dir, "group.stg", groupFile);
-            TemplateGroup group = new TemplateGroupDirectory(dir);
-            Template st1 = group.GetInstanceOf("a");
-            Template st2 = group.GetInstanceOf("group/b");
-            Template st3 = group.GetInstanceOf("group/c");
-            string expected = "foo" + newline + "barduh";
-            string result = st1.Render() + st2.Render() + st3.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestSubSubdir()
-        {
-            // /randomdir/a and /randomdir/subdir/b
-            string dir = GetRandomDir();
-            string a =
-                "a(x) ::= <<" + newline +
-                "foo" + newline +
-                ">>" + newline;
-            WriteFile(dir, "a.st", a);
-            string b =
-                "b() ::= \"bar\"" + newline;
-            WriteFile(Path.Combine(Path.Combine(dir, "sub1"), "sub2"), "b.st", b);
-            TemplateGroup group = new TemplateGroupDirectory(dir);
-            Template st1 = group.GetInstanceOf("a");
-            Template st2 = group.GetInstanceOf("sub1/sub2/b");
-            string expected = "foo" + newline + "bar";
-            string result = st1.Render() + st2.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestGroupFileInSubDir()
-        {
-            // /randomdir/a and /randomdir/group.stg with b and c templates
-            string dir = GetRandomDir();
-            string a =
-                "a(x) ::= <<\n" +
-                "foo\n" +
-                ">>\n";
-            WriteFile(dir, "a.st", a);
-            string groupFile =
-                "b() ::= \"bar\"\n" +
-                "c() ::= \"duh\"\n";
-            WriteFile(dir, Path.Combine("subdir", "group.stg"), groupFile);
-            TemplateGroup group = new TemplateGroupDirectory(dir);
-            Template st1 = group.GetInstanceOf("a");
-            Template st2 = group.GetInstanceOf("subdir/group/b");
-            Template st3 = group.GetInstanceOf("subdir/group/c");
-            string expected = "foo" + newline + "barduh";
-            string result = st1.Render() + st2.Render() + st3.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestRefToAnotherTemplateInSameGroup()
-        {
-            string dir = GetRandomDir();
-            string a = "a() ::= << <b()> >>\n";
-            string b = "b() ::= <<bar>>\n";
-            WriteFile(dir, "a.st", a);
-            WriteFile(dir, "b.st", b);
-            TemplateGroup group = new TemplateGroupDirectory(dir);
-            Template st = group.GetInstanceOf("a");
-            string expected = " bar ";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestRefToAnotherTemplateInSameSubdir()
-        {
-            // /randomdir/a and /randomdir/subdir/b
-            string dir = GetRandomDir();
-            string a = "a() ::= << <b()> >>\n";
-            string b = "b() ::= <<bar>>\n";
-            WriteFile(dir + "/subdir", "a.st", a);
-            WriteFile(dir + "/subdir", "b.st", b);
-            TemplateGroup group = new TemplateGroupDirectory(dir);
-            Template st = group.GetInstanceOf("subdir/a");
-            st.code.Dump();
-            string expected = " bar ";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestDupDef()
-        {
-            string dir = GetRandomDir();
-            string groupFile =
-                "b() ::= \"bar\"\n" +
-                "b() ::= \"duh\"\n";
-            WriteFile(dir, "group.stg", groupFile);
-            TemplateGroup group = new TemplateGroupFile(dir + "/group.stg");
-            group.Load();
-        }
-
-        [TestMethod]
-        public void TestSimpleDefaultArg()
-        {
-            string dir = GetRandomDir();
-            string a = "a() ::= << <b()> >>\n";
-            string b = "b(x=\"foo\") ::= \"<x>\"\n";
-            WriteFile(dir, "a.st", a);
-            WriteFile(dir, "b.st", b);
-            STGroup group = new STGroupDir(dir);
-            ST st = group.GetInstanceOf("a");
-            string expected = " foo ";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestDefaultArgument()
-        {
-            string templates =
-                    "method(name) ::= <<" + newline +
-                    "<stat(...)>" + newline +
-                    ">>" + newline +
-                    "stat(name,value=\"99\") ::= \"x=<value>; // <name>\"" + newline
-                    ;
-            WriteFile(tmpdir, "group.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/group.stg");
-            ST b = group.GetInstanceOf("method");
-            b.Add("name", "foo");
-            string expecting = "x=99; // foo" + newline;
-            string result = b.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestDefaultArgument2()
-        {
-            String templates =
-                    "stat(name,value=\"99\") ::= \"x=<value>; // <name>\"" + newline
-                    ;
-            WriteFile(tmpdir, "group.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/group.stg");
-            ST b = group.GetInstanceOf("stat");
-            b.Add("name", "foo");
-            String expecting = "x=99; // foo";
-            String result = b.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestDefaultArgumentManuallySet()
-        {
-            String templates =
-                    "method(fields) ::= <<" + newline +
-                    "<fields:{f | <stat(f=f)>}>" + newline +
-                    ">>" + newline +
-                    "stat(f,value={<f.name>}) ::= \"x=<value>; // <f.name>\"" + newline
-                    ;
-            WriteFile(tmpdir, "group.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/group.stg");
-            ST m = group.GetInstanceOf("method");
-            m.Add("fields", new Field());
-            String expecting = "x=parrt; // parrt" + newline;
-            String result = m.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        /** This fails because checkNullAttributeAgainstFormalArguments looks
-         *  for a formal argument at the current level not of the original embedded
-         *  template. We have defined it all the way in the embedded, but there is
-         *  no value so we try to look upwards ala dynamic scoping. When it reaches
-         *  the top, it doesn't find a value but it will miss the
-         *  formal argument down in the embedded.
-         *
-         *  By definition, though, the formal parameter exists if we have
-         *  a default value. look up the value to see if it's null without
-         *  checking checkNullAttributeAgainstFormalArguments.
-         */
-        [TestMethod]
-        public void TestDefaultArgumentImplicitlySet()
-        {
-            String templates =
-                    "method(fields) ::= <<" + newline +
-                    "<fields:{f | <stat(...)>}>" + newline +
-                    ">>" + newline +
-                    "stat(f,value={<f.name>}) ::= \"x=<value>; // <f.name>\"" + newline
-                    ;
-            WriteFile(tmpdir, "group.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/group.stg");
-            ST m = group.GetInstanceOf("method");
-            m.Add("fields", new Field());
-            String expecting = "x=parrt; // parrt" + newline;
-            String result = m.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestDefaultArgumentImplicitlySet2()
-        {
-            String templates =
-                    "method(fields) ::= <<" + newline +
-                    "<fields:{f | <f:stat()>}>" + newline +
-                    ">>" + newline +
-                    "stat(f,value={<f.name>}) ::= \"x=<value>; // <f.name>\"" + newline
-                    ;
-            WriteFile(tmpdir, "group.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/group.stg");
-            ST m = group.GetInstanceOf("method");
-            m.Add("fields", new Field());
-            String expecting = "x=parrt; // parrt" + newline;
-            String result = m.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestDefaultArgumentAsTemplate()
-        {
-            String templates =
-                    "method(name,size) ::= <<" + newline +
-                    "<stat(...)>" + newline +
-                    ">>" + newline +
-                    "stat(name,value={<name>}) ::= \"x=<value>; // <name>\"" + newline
-                    ;
-            WriteFile(tmpdir, "group.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/group.stg");
-            ST b = group.GetInstanceOf("method");
-            b.Add("name", "foo");
-            b.Add("size", "2");
-            String expecting = "x=foo; // foo" + newline;
-            String result = b.Render();
-            //System.err.println("result='"+result+"'");
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestDefaultArgumentAsTemplate2()
-        {
-            String templates =
-                    "method(name,size) ::= <<" + newline +
-                    "<stat(...)>" + newline +
-                    ">>" + newline +
-                    "stat(name,value={ [<name>] }) ::= \"x=<value>; // <name>\"" + newline
-                    ;
-            WriteFile(tmpdir, "group.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/group.stg");
-            ST b = group.GetInstanceOf("method");
-            b.Add("name", "foo");
-            b.Add("size", "2");
-            String expecting = "x=[foo] ; // foo" + newline; // won't see ' ' after '=' since it's an indent not simple string
-            String result = b.Render();
-            //System.err.println("result='"+result+"'");
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestDoNotUseDefaultArgument()
-        {
-            String templates =
-                    "method(name) ::= <<" + newline +
-                    "<stat(value=\"34\",...)>" + newline +
-                    ">>" + newline +
-                    "stat(name,value=\"99\") ::= \"x=<value>; // <name>\"" + newline
-                    ;
-            WriteFile(tmpdir, "group.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/group.stg");
-            ST b = group.GetInstanceOf("method");
-            b.Add("name", "foo");
-            String expecting = "x=34; // foo" + newline;
-            String result = b.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestDefaultArgumentInParensToEvalEarly()
-        {
-            String templates =
-                    "A(x) ::= \"<B()>\"" + newline +
-                    "B(y={<(x)>}) ::= \"<y> <x> <x> <y>\"" + newline
-                    ;
-            WriteFile(tmpdir, "group.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/group.stg");
-            ST b = group.GetInstanceOf("A");
-            b.Add("x", new Counter());
-            String expecting = "0 1 2 0"; // trace must be false to get these numbers
-            String result = b.Render();
-            //System.err.println("result='"+result+"'");
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestCompatibilityMode()
-        {
-            ErrorManager.CompatibilityMode = true;
-
-            try
-            {
-                string dir = GetRandomDir();
-                string a =
-                    "foo\n" +
-                    "bar\n";
-                WriteFile(dir, "a.st", a);
-                STGroup group = new STGroupDir(dir);
-                ST st = group.GetInstanceOf("a");
-                string expected =
-                    "foo" + newline +
-                    "bar";
-                string result = st.Render();
-                Assert.AreEqual(expected, result);
-            }
-            finally
-            {
-                ErrorManager.CompatibilityMode = false;
-            }
-        }
-
-        private class Field
-        {
-            public string name = "parrt";
-            public int n = 0;
-
-            public override string ToString()
-            {
-                return "Field";
-            }
-        }
-
-        private class Counter
-        {
-            int n = 0;
-            public override string ToString()
-            {
-                return (n++).ToString();
-            }
-        }
-    }
-}
diff --git a/Antlr3.Test/ST4/TestImports.cs b/Antlr3.Test/ST4/TestImports.cs
deleted file mode 100644
index 7c0d97a..0000000
--- a/Antlr3.Test/ST4/TestImports.cs
+++ /dev/null
@@ -1,224 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace AntlrUnitTests.ST4
-{
-    using Microsoft.VisualStudio.TestTools.UnitTesting;
-    using StringTemplate;
-
-    [TestClass]
-    public class TestImports : StringTemplateTestBase
-    {
-        [TestMethod]
-        public void TestImportTemplate()
-        {
-            string dir1 = GetRandomDir();
-            string a = "a() ::= <<dir1 a>>\n";
-            string b = "b() ::= <<dir1 b>>\n";
-            WriteFile(dir1, "a.st", a);
-            WriteFile(dir1, "b.st", b);
-            string dir2 = GetRandomDir();
-            a = "a() ::= << <b()> >>\n";
-            WriteFile(dir2, "a.st", a);
-
-            TemplateGroup group1 = new TemplateGroupDirectory(dir1);
-            TemplateGroup group2 = new TemplateGroupDirectory(dir2);
-            group2.ImportTemplates(group1);
-            Template st = group2.GetInstanceOf("b");
-            string expected = "dir1 b";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-
-            // do it again, but make a template ref imported template
-            st = group2.GetInstanceOf("a");
-            expected = " dir1 b ";
-            result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestImportTemplateInGroupFileFromDir()
-        {
-            string dir = GetRandomDir();
-            string a = "a() ::= << <b()> >>\n";
-            WriteFile(dir, "x/a.st", a);
-
-            string groupFile =
-                "b() ::= \"group file b\"\n" +
-                "c() ::= \"group file c\"\n";
-            WriteFile(dir, "y/group.stg", groupFile);
-
-            TemplateGroup group1 = new TemplateGroupDirectory(dir + "/x");
-            TemplateGroup group2 = new TemplateGroupFile(dir + "/y/group.stg");
-            group1.ImportTemplates(group2);
-            Template st = group1.GetInstanceOf("/a");
-            st.code.Dump();
-            string expected = " group file b ";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestImportTemplateInDirFromGroupFile()
-        {
-            string dir = GetRandomDir();
-            string a = "a() ::= <<dir1 a>>\n";
-            WriteFile(dir, "group/a.st", a);
-
-            string groupFile =
-                "b() ::= \"<a()>\"\n";
-            WriteFile(dir, "group.stg", groupFile);
-
-            TemplateGroup group1 = new TemplateGroupDirectory(dir);
-            TemplateGroup group2 = new TemplateGroupFile(dir + "/group.stg");
-            group2.ImportTemplates(group1);
-            Template st = group2.GetInstanceOf("/group/b");
-            string expected = "dir1 a";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestImportTemplateInGroupFileFromGroupFile()
-        {
-            string dir = GetRandomDir();
-            string groupFile =
-                "a() ::= \"g1 a\"\n" +
-                "b() ::= \"<c()>\"\n";
-            WriteFile(dir, "x/group.stg", groupFile);
-
-            groupFile =
-                "b() ::= \"g2 b\"\n" +
-                "c() ::= \"g2 c\"\n";
-            WriteFile(dir, "y/group.stg", groupFile);
-
-            TemplateGroup group1 = new TemplateGroupFile(dir + "/x/group.stg");
-            TemplateGroup group2 = new TemplateGroupFile(dir + "/y/group.stg");
-            group1.ImportTemplates(group2);
-            Template st = group1.GetInstanceOf("/b");
-            string expected = "g2 c";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestImportTemplateFromSubdir()
-        {
-            // /randomdir/x/subdir/a and /randomdir/y/subdir/b
-            string dir = GetRandomDir();
-            string a = "a() ::= << <b()> >>\n";
-            string b = "b() ::= <<x/subdir/b>>\n";
-            WriteFile(dir, "x/subdir/a.st", a);
-            WriteFile(dir, "y/subdir/b.st", b);
-
-            TemplateGroup group1 = new TemplateGroupDirectory(dir + "/x");
-            TemplateGroup group2 = new TemplateGroupDirectory(dir + "/y");
-            group1.ImportTemplates(group2);
-            Template st = group1.GetInstanceOf("/subdir/a");
-            string expected = " x/subdir/b ";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestImportTemplateFromGroupFile()
-        {
-            // /randomdir/x/subdir/a and /randomdir/y/subdir.stg which has a and b
-            string dir = GetRandomDir();
-            string a = "a() ::= << <b()> >>\n"; // get b imported from subdir.stg
-            WriteFile(dir, "x/subdir/a.st", a);
-
-            string groupFile =
-                "a() ::= \"group file a\"\n" +
-                "b() ::= \"group file b\"\n";
-            WriteFile(dir, "y/subdir.stg", groupFile);
-
-            TemplateGroup group1 = new TemplateGroupDirectory(dir + "/x");
-            TemplateGroup group2 = new TemplateGroupDirectory(dir + "/y");
-            group1.ImportTemplates(group2);
-            Template st = group1.GetInstanceOf("/subdir/a");
-            string expected = " group file b ";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestPolymorphicTemplateReference()
-        {
-            string dir1 = GetRandomDir();
-            string b = "b() ::= <<dir1 b>>\n";
-            WriteFile(dir1, "b.st", b);
-            string dir2 = GetRandomDir();
-            string a = "a() ::= << <b()> >>\n";
-            b = "b() ::= <<dir2 b>>\n";
-            WriteFile(dir2, "a.st", a);
-            WriteFile(dir2, "b.st", b);
-
-            TemplateGroup group1 = new TemplateGroupDirectory(dir1);
-            TemplateGroup group2 = new TemplateGroupDirectory(dir2);
-            group1.ImportTemplates(group2);
-
-            // normal lookup; a created from dir2 calls dir2.b
-            Template st = group2.GetInstanceOf("a");
-            string expected = " dir2 b ";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-
-            // polymorphic lookup; a created from dir1 calls dir2.a which calls dir1.b
-            st = group1.GetInstanceOf("a");
-            expected = " dir1 b ";
-            result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestSuper()
-        {
-            string dir1 = GetRandomDir();
-            string a = "a() ::= <<dir1 a>>\n";
-            string b = "b() ::= <<dir1 b>>\n";
-            WriteFile(dir1, "a.st", a);
-            WriteFile(dir1, "b.st", b);
-            string dir2 = GetRandomDir();
-            a = "a() ::= << [<super.a()>] >>\n";
-            WriteFile(dir2, "a.st", a);
-
-            TemplateGroup group1 = new TemplateGroupDirectory(dir1);
-            TemplateGroup group2 = new TemplateGroupDirectory(dir2);
-            group2.ImportTemplates(group1);
-            Template st = group2.GetInstanceOf("a");
-            string expected = " [dir1 a] ";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-    }
-}
diff --git a/Antlr3.Test/ST4/TestIndentation.cs b/Antlr3.Test/ST4/TestIndentation.cs
deleted file mode 100644
index 21a97e8..0000000
--- a/Antlr3.Test/ST4/TestIndentation.cs
+++ /dev/null
@@ -1,284 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace AntlrUnitTests.ST4
-{
-    using Microsoft.VisualStudio.TestTools.UnitTesting;
-    using StringTemplate;
-    using Path = System.IO.Path;
-    using STErrorListener = StringTemplate.ITemplateErrorListener;
-    using STGroup = StringTemplate.TemplateGroup;
-    using STGroupFile = StringTemplate.TemplateGroupFile;
-    using String = System.String;
-
-    [TestClass]
-    public class TestIndentation : StringTemplateTestBase
-    {
-        [TestMethod]
-        public void TestSimpleIndentOfAttributeList()
-        {
-            String templates =
-                    "list(names) ::= <<" +
-                    "  <names; separator=\"\\n\">" + newline +
-                    ">>" + newline;
-
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            Template t = group.GetInstanceOf("list");
-            t.Add("names", "Terence");
-            t.Add("names", "Jim");
-            t.Add("names", "Sriram");
-            String expecting =
-                    "  Terence" + newline +
-                    "  Jim" + newline +
-                    "  Sriram" + newline;
-            Assert.AreEqual(expecting, t.Render());
-        }
-
-        [TestMethod]
-        public void TestIndentOfMultilineAttributes()
-        {
-            String templates =
-                    "list(names) ::= <<" +
-                    "  <names; separator=\"\n\">" + newline +
-                    ">>" + newline;
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            Template t = group.GetInstanceOf("list");
-            t.Add("names", "Terence\nis\na\nmaniac");
-            t.Add("names", "Jim");
-            t.Add("names", "Sriram\nis\ncool");
-            String expecting =
-                    "  Terence" + newline +
-                    "  is" + newline +
-                    "  a" + newline +
-                    "  maniac" + newline +
-                    "  Jim" + newline +
-                    "  Sriram" + newline +
-                    "  is" + newline +
-                    "  cool" + newline;
-            Assert.AreEqual(expecting, t.Render());
-        }
-
-        [TestMethod]
-        public void TestIndentOfMultipleBlankLines()
-        {
-            String templates =
-                    "list(names) ::= <<" +
-                    "  <names>" + newline +
-                    ">>" + newline;
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            Template t = group.GetInstanceOf("list");
-            t.Add("names", "Terence\n\nis a maniac");
-            String expecting =
-                    "  Terence" + newline +
-                    "" + newline + // no indent on blank line
-                    "  is a maniac" + newline;
-            Assert.AreEqual(expecting, t.Render());
-        }
-
-        [TestMethod]
-        public void TestIndentBetweenLeftJustifiedLiterals()
-        {
-            String templates =
-                    "list(names) ::= <<" +
-                    "Before:" + newline +
-                    "  <names; separator=\"\\n\">" + newline +
-                    "after" + newline +
-                    ">>" + newline;
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            Template t = group.GetInstanceOf("list");
-            t.Add("names", "Terence");
-            t.Add("names", "Jim");
-            t.Add("names", "Sriram");
-            String expecting =
-                    "Before:" + newline +
-                    "  Terence" + newline +
-                    "  Jim" + newline +
-                    "  Sriram" + newline +
-                    "after" + newline;
-            Assert.AreEqual(expecting, t.Render());
-        }
-
-        [TestMethod]
-        public void TestNestedIndent()
-        {
-            String templates =
-                    "method(name,stats) ::= <<" +
-                    "void <name>() {" + newline +
-                    "\t<stats; separator=\"\\n\">" + newline +
-                    "}" + newline +
-                    ">>" + newline +
-                    "ifstat(expr,stats) ::= <<" + newline +
-                    "if (<expr>) {" + newline +
-                    "  <stats; separator=\"\\n\">" + newline +
-                    "}" +
-                    ">>" + newline +
-                    "assign(lhs,expr) ::= <<<lhs>=<expr>;>>" + newline
-                    ;
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            Template t = group.GetInstanceOf("method");
-            t.Add("name", "foo");
-            Template s1 = group.GetInstanceOf("assign");
-            s1.Add("lhs", "x");
-            s1.Add("expr", "0");
-            Template s2 = group.GetInstanceOf("ifstat");
-            s2.Add("expr", "x>0");
-            Template s2a = group.GetInstanceOf("assign");
-            s2a.Add("lhs", "y");
-            s2a.Add("expr", "x+y");
-            Template s2b = group.GetInstanceOf("assign");
-            s2b.Add("lhs", "z");
-            s2b.Add("expr", "4");
-            s2.Add("stats", s2a);
-            s2.Add("stats", s2b);
-            t.Add("stats", s1);
-            t.Add("stats", s2);
-            String expecting =
-                    "void foo() {" + newline +
-                    "\tx=0;" + newline +
-                    "\tif (x>0) {" + newline +
-                    "\t  y=x+y;" + newline +
-                    "\t  z=4;" + newline +
-                    "\t}" + newline +
-                    "}" + newline;
-            Assert.AreEqual(expecting, t.Render());
-        }
-
-        [TestMethod]
-        public void TestIndentedIFWithValueExpr()
-        {
-            Template t = new Template(
-                "begin" + newline +
-                "    <if(x)>foo<endif>" + newline +
-                "end" + newline);
-            t.Add("x", "x");
-            String expecting = "begin" + newline + "    foo" + newline + "end" + newline;
-            String result = t.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestIFWithIndentOnMultipleLines()
-        {
-            Template t = new Template(
-                "begin" + newline +
-                "   <if(x)>" + newline +
-                "   foo" + newline +
-                "   <else>" + newline +
-                "   bar" + newline +
-                "   <endif>" + newline +
-                "end" + newline);
-            String expecting = "begin" + newline + "   bar" + newline + "end" + newline;
-            String result = t.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestIFWithIndentAndExprOnMultipleLines()
-        {
-            Template t = new Template(
-                "begin" + newline +
-                "   <if(x)>" + newline +
-                "   <x>" + newline +
-                "   <else>" + newline +
-                "   <y>" + newline +
-                "   <endif>" + newline +
-                "end" + newline);
-            t.Add("y", "y");
-            String expecting = "begin" + newline + "   y" + newline + "end" + newline;
-            String result = t.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestIFWithIndentAndExprWithIndentOnMultipleLines()
-        {
-            Template t = new Template(
-                "begin" + newline +
-                "   <if(x)>" + newline +
-                "     <x>" + newline +
-                "   <else>" + newline +
-                "     <y>" + newline +
-                "   <endif>" + newline +
-                "end" + newline);
-            t.Add("y", "y");
-            String expecting = "begin" + newline + "     y" + newline + "end" + newline;
-            String result = t.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestNestedIFWithIndentOnMultipleLines()
-        {
-            Template t = new Template(
-                "begin" + newline +
-                "   <if(x)>" + newline +
-                "      <if(y)>" + newline +
-                "      foo" + newline +
-                "      <endif>" + newline +
-                "   <else>" + newline +
-                "      <if(z)>" + newline +
-                "      foo" + newline +
-                "      <endif>" + newline +
-                "   <endif>" + newline +
-                "end" + newline);
-            t.Add("x", "x");
-            t.Add("y", "y");
-            String expecting = "begin" + newline + "      foo" + newline + "end" + newline; // no indent
-            String result = t.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestIFInSubtemplate()
-        {
-            Template t = new Template(
-                "<names:{n |" + newline +
-                "   <if(x)>" + newline +
-                "   <x>" + newline +
-                "   <else>" + newline +
-                "   <y>" + newline +
-                "   <endif>" + newline +
-                "}>" + newline);
-            t.Add("names", "Ter");
-            t.Add("y", "y");
-            String expecting = "   y" + newline + newline;
-            String result = t.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-    }
-}
diff --git a/Antlr3.Test/ST4/TestIndirectionAndEarlyEvaluation.cs b/Antlr3.Test/ST4/TestIndirectionAndEarlyEvaluation.cs
deleted file mode 100644
index 6dc54e8..0000000
--- a/Antlr3.Test/ST4/TestIndirectionAndEarlyEvaluation.cs
+++ /dev/null
@@ -1,127 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace AntlrUnitTests.ST4
-{
-    using System.Collections.Generic;
-    using Microsoft.VisualStudio.TestTools.UnitTesting;
-    using ST = StringTemplate.Template;
-    using STGroup = StringTemplate.TemplateGroup;
-    using String = System.String;
-    using StringTemplate;
-
-    [TestClass]
-    public class TestIndirectionAndEarlyEvaluation : StringTemplateTestBase
-    {
-        [TestMethod]
-        public void TestEarlyEval()
-        {
-            String template = "<(name)>";
-            ST st = new ST(template);
-            st.Add("name", "Ter");
-            String expected = "Ter";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestIndirectTemplateInclude()
-        {
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("foo"), "bar");
-            String template = "<(name)()>";
-            group.DefineTemplate(new TemplateName("test"), template);
-            ST st = group.GetInstanceOf("test");
-            st.Add("name", "foo");
-            String expected = "bar";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestIndirectTemplateIncludeViaTemplate()
-        {
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("foo"), "bar");
-            group.DefineTemplate(new TemplateName("tname"), "foo");
-            String template = "<(tname())()>";
-            group.DefineTemplate(new TemplateName("test"), template);
-            ST st = group.GetInstanceOf("test");
-            String expected = "bar";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestIndirectProp()
-        {
-            String template = "<u.(propname)>: <u.name>";
-            ST st = new ST(template);
-            st.Add("u", new TestCoreBasics.User(1, "parrt"));
-            st.Add("propname", "id");
-            String expected = "1: parrt";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestIndirectMap()
-        {
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("a"), "[<it>]");
-            group.DefineTemplate(new TemplateName("test"), "hi <names:(templateName)()>!");
-            ST st = group.GetInstanceOf("test");
-            st.Add("names", "Ter");
-            st.Add("names", "Tom");
-            st.Add("names", "Sumana");
-            st.Add("templateName", "a");
-            String expected =
-                "hi [Ter][Tom][Sumana]!";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestNonStringDictLookup()
-        {
-            String template = "<m.(intkey)>";
-            ST st = new ST(template);
-            IDictionary<int, string> m = new Dictionary<int, String>();
-            m[36] = "foo";
-            st.Add("m", m);
-            st.Add("intkey", 36);
-            String expected = "foo";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-    }
-}
diff --git a/Antlr3.Test/ST4/TestInterptimeErrors.cs b/Antlr3.Test/ST4/TestInterptimeErrors.cs
deleted file mode 100644
index 44864a9..0000000
--- a/Antlr3.Test/ST4/TestInterptimeErrors.cs
+++ /dev/null
@@ -1,344 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace AntlrUnitTests.ST4
-{
-    using Microsoft.VisualStudio.TestTools.UnitTesting;
-    using ST = StringTemplate.Template;
-    using STErrorListener = StringTemplate.ITemplateErrorListener;
-    using STGroup = StringTemplate.TemplateGroup;
-    using STGroupDir = StringTemplate.TemplateGroupDirectory;
-    using STGroupFile = StringTemplate.TemplateGroupFile;
-    using String = System.String;
-    using Path = System.IO.Path;
-    using StringTemplate;
-
-    [TestClass]
-    public class TestInterptimeErrors : StringTemplateTestBase
-    {
-        public class UserHiddenName
-        {
-            private string name;
-
-            public UserHiddenName(string name)
-            {
-                this.name = name;
-            }
-
-            protected string Name
-            {
-                get
-                {
-                    return name;
-                }
-            }
-        }
-
-        public class UserHiddenNameField
-        {
-            private string name;
-
-            public UserHiddenNameField(string name)
-            {
-                this.name = name;
-            }
-        }
-
-        [TestMethod]
-        public void TestMissingEmbeddedTemplate()
-        {
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-
-            String templates =
-                "t() ::= \"<foo()>\"" + newline;
-
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ST st = group.GetInstanceOf("t");
-            st.Render();
-            String expected = "context [t] 1:0 no such template: foo" + newline;
-            String result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestMissingSuperTemplate()
-        {
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-
-            String templates =
-                "t() ::= \"<super.t()>\"" + newline;
-
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            String templates2 =
-                "u() ::= \"blech\"" + newline;
-
-            WriteFile(tmpdir, "t2.stg", templates2);
-            STGroup group2 = new STGroupFile(Path.Combine(tmpdir, "t2.stg"));
-            group.ImportTemplates(group2);
-            ST st = group.GetInstanceOf("t");
-            st.Render();
-            String expected = "context [t] 1:1 no such template: super.t" + newline;
-            String result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestNoPropertyNotError()
-        {
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-
-            String templates =
-                "t(u) ::= \"<u.x>\"" + newline;
-
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ST st = group.GetInstanceOf("t");
-            st.Add("u", new User(32, "parrt"));
-            st.Render();
-            String expected = "";
-            String result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestHiddenPropertyNotError()
-        {
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-
-            String templates =
-                "t(u) ::= \"<u.name>\"" + newline;
-
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ST st = group.GetInstanceOf("t");
-            st.Add("u", new UserHiddenName("parrt"));
-            st.Render();
-            String expected = "";
-            String result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestHiddenFieldNotError()
-        {
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-
-            String templates =
-                "t(u) ::= \"<u.name>\"" + newline;
-
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ST st = group.GetInstanceOf("t");
-            st.Add("u", new UserHiddenNameField("parrt"));
-            st.Render();
-            String expected = "";
-            String result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestPassUnknownAttr()
-        {
-            String templates =
-                "t() ::= \"<u(x={Ter})>\"\n" +
-                "u(y) ::= <<hi <x>!>>\n";
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ST st = group.GetInstanceOf("t");
-            String expected = "hi Ter!";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-
-            // check error now
-            expected = "context [t u] can't set attribute x; template u has no such attribute" + newline;
-            result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestSoleArg()
-        {
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-
-            string templates =
-                "t() ::= \"<u({9})>\"\n" +
-                "u(x,y) ::= \"<x>\"\n";
-
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ST st = group.GetInstanceOf("t");
-            st.Render();
-            string expected = "context [t] 1:3 expecting single arg in template reference u() (not 2 args)" + newline;
-            string result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestSoleArgUsingApplySyntax()
-        {
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-
-            String templates =
-                "t() ::= \"<{9}:u()>\"\n" +
-                "u(x,y) ::= \"<x>\"\n";
-
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ST st = group.GetInstanceOf("t");
-            String expected = "9";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-
-            expected = "context [t] 1:1 expecting single arg in template reference u() (not 2 args)" + newline;
-            result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestUndefinedArg()
-        {
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-
-            string templates =
-                "t() ::= \"<u()>\"\n" +
-                "u() ::= \"<x>\"\n";
-
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            group.Debug = true;
-            ST st = group.GetInstanceOf("t");
-            st.Render();
-            String expected = "context [t, u] 1:1 attribute x isn't defined" + newline;
-            String result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestUndefinedArgNoProblemInCompatibilityMode()
-        {
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-            ErrorManager.CompatibilityMode = true;
-
-            try
-            {
-                string templates =
-                    "t() ::= \"<u()>\"\n" +
-                    "u() ::= \"<x>\"\n";
-
-                WriteFile(tmpdir, "t.stg", templates);
-                STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
-                ST st = group.GetInstanceOf("t");
-                st.Render();
-                String expected = "";
-                String result = errors.ToString();
-                Assert.AreEqual(expected, result);
-            }
-            finally
-            {
-                ErrorManager.CompatibilityMode = false;
-            }
-        }
-
-        [TestMethod]
-        public void TestParallelAttributeIterationWithMismatchArgListSizes()
-        {
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-            Template e = new Template(
-                    "<names,phones,salaries:{n,p | <n>@<p>}; separator=\", \">"
-                );
-            e.Add("names", "Ter");
-            e.Add("names", "Tom");
-            e.Add("phones", "1");
-            e.Add("phones", "2");
-            e.Add("salaries", "big");
-            e.Render();
-            string errorExpecting = "context [anonymous] 1:1 iterating through 3 arguments but parallel map has 2 formal arguments" + newline;
-            Assert.AreEqual(errorExpecting, errors.ToString());
-            string expecting = "Ter@1, Tom@2";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestParallelAttributeIterationWithMissingArgs()
-        {
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-            Template e = new Template(
-                    "<names,phones,salaries:{<n>@<p>}; separator=\", \">"
-                );
-            e.Add("names", "Tom");
-            e.Add("phones", "2");
-            e.Add("salaries", "big");
-            e.Render(); // generate the error
-            string errorExpecting = "context [anonymous] 1:1 missing argument definitions" + newline;
-            Assert.AreEqual(errorExpecting, errors.ToString());
-        }
-
-        [TestMethod]
-        public void TestStringTypeMismatch()
-        {
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-            ST e = new ST("<trim(s)>");
-            e.Add("s", 34);
-            e.Render(); // generate the error
-            String errorExpecting = "context [anonymous] 1:1 function trim expects a string not System.Int32" + newline;
-            Assert.AreEqual(errorExpecting, errors.ToString());
-        }
-
-        [TestMethod]
-        public void TestStringTypeMismatch2()
-        {
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-            ST e = new ST("<strlen(s)>");
-            e.Add("s", 34);
-            e.Render(); // generate the error
-            String errorExpecting = "context [anonymous] 1:1 function strlen expects a string not System.Int32" + newline;
-            Assert.AreEqual(errorExpecting, errors.ToString());
-        }
-    }
-}
diff --git a/Antlr3.Test/ST4/TestLexer.cs b/Antlr3.Test/ST4/TestLexer.cs
deleted file mode 100644
index 1c947c5..0000000
--- a/Antlr3.Test/ST4/TestLexer.cs
+++ /dev/null
@@ -1,254 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace AntlrUnitTests.ST4
-{
-    using Antlr.Runtime;
-    using Microsoft.VisualStudio.TestTools.UnitTesting;
-    using StringTemplate;
-
-    using StringBuilder = System.Text.StringBuilder;
-
-    [TestClass]
-    public class TestLexer : StringTemplateTestBase
-    {
-        [TestMethod]
-        public void TestOneExpr()
-        {
-            string template = "<name>";
-            string expected = "[[@0,0:0='<',<LDELIM>,1:0], [@1,1:4='name',<ID>,1:1], " +
-                              "[@2,5:5='>',<RDELIM>,1:5]]";
-            CheckTokens(template, expected);
-        }
-
-        [TestMethod]
-        public void TestOneExprSurrounded()
-        {
-            string template = "hi <name> mom";
-            string expected = "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='<',<LDELIM>,1:3], " +
-                              "[@2,4:7='name',<ID>,1:4], [@3,8:8='>',<RDELIM>,1:8], " +
-                              "[@4,9:12=' mom',<TEXT>,1:9]]";
-            CheckTokens(template, expected);
-        }
-
-        [TestMethod]
-        public void TestEscDelim()
-        {
-            string template = "hi \\<name>";
-            string expected = "[[@0,0:9='hi <name>',<TEXT>,1:0]]";
-            CheckTokens(template, expected);
-        }
-
-        [TestMethod]
-        public void TestEscDelimHasCorrectStartChar()
-        {
-            string template = "<a>\\<dog";
-            string expected =
-                "[[@0,0:0='<',<LDELIM>,1:0], [@1,1:1='a',<ID>,1:1], [@2,2:2='>',<RDELIM>,1:2], " +
-                "[@3,3:7='<dog',<TEXT>,1:3]]";
-            CheckTokens(template, expected);
-        }
-
-        [TestMethod]
-        public void TestEscChar()
-        {
-            string template = "hi \\x";
-            string expected = "[[@0,0:4='hi \\x',<TEXT>,1:0]]";
-            CheckTokens(template, expected);
-        }
-
-        [TestMethod]
-        public void TestString()
-        {
-            string template = "hi <foo(a=\">\")>";
-            string expected = "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='<',<LDELIM>,1:3], " +
-                              "[@2,4:6='foo',<ID>,1:4], [@3,7:7='(',<LPAREN>,1:7], " +
-                              "[@4,8:8='a',<ID>,1:8], [@5,9:9='=',<EQUALS>,1:9], " +
-                              "[@6,10:12='\">\"',<STRING>,1:10], [@7,13:13=')',<RPAREN>,1:13], " +
-                              "[@8,14:14='>',<RDELIM>,1:14]]";
-            CheckTokens(template, expected);
-        }
-
-        [TestMethod]
-        public void TestEscInString()
-        {
-            string template = "hi <foo(a=\">\\\"\")>";
-            string expected =
-                "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='<',<LDELIM>,1:3], [@2,4:6='foo',<ID>,1:4], " +
-                "[@3,7:7='(',<LPAREN>,1:7], [@4,8:8='a',<ID>,1:8], [@5,9:9='=',<EQUALS>,1:9], " +
-                "[@6,10:14='\">\"\"',<STRING>,1:10], [@7,15:15=')',<RPAREN>,1:15], " +
-                "[@8,16:16='>',<RDELIM>,1:16]]";
-            CheckTokens(template, expected);
-        }
-
-        [TestMethod]
-        public void TestSubtemplate()
-        {
-            string template = "hi <names:{n | <n>}>";
-            string expected =
-                "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='<',<LDELIM>,1:3], [@2,4:8='names',<ID>,1:4], [@3,9:9=':',<COLON>,1:9], [@4,10:10='{',<LCURLY>,1:10], [@5,11:11='n',<ID>,1:11], [@6,13:13='|',<PIPE>,1:13], [@7,15:15='<',<LDELIM>,1:15], [@8,16:16='n',<ID>,1:16], [@9,17:17='>',<RDELIM>,1:17], [@10,18:18='}',<RCURLY>,1:18], [@11,19:19='>',<RDELIM>,1:19]]";
-            CheckTokens(template, expected);
-        }
-
-        [TestMethod]
-        public void TestSubtemplateNoArg()
-        {
-            string template = "hi <names:{ <it>}>";
-            string expected =
-                "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='<',<LDELIM>,1:3], " +
-                    "[@2,4:8='names',<ID>,1:4], [@3,9:9=':',<COLON>,1:9], " +
-                    "[@4,10:10='{',<LCURLY>,1:10], [@5,11:11=' ',<TEXT>,1:11], " +
-                    "[@6,12:12='<',<LDELIM>,1:12], [@7,13:14='it',<ID>,1:13], " +
-                    "[@8,15:15='>',<RDELIM>,1:15], [@9,16:16='}',<RCURLY>,1:16], " +
-                    "[@10,17:17='>',<RDELIM>,1:17]]";
-            CheckTokens(template, expected);
-        }
-
-        [TestMethod]
-        public void TestSubtemplateMultiArgs()
-        {
-            string template = "hi <names:{x,y | <x><y>}>"; // semantically bogus
-            string expected =
-                "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='<',<LDELIM>,1:3], [@2,4:8='names',<ID>,1:4], [@3,9:9=':',<COLON>,1:9], [@4,10:10='{',<LCURLY>,1:10], [@5,11:11='x',<ID>,1:11], [@6,12:12=',',<COMMA>,1:12], [@7,13:13='y',<ID>,1:13], [@8,15:15='|',<PIPE>,1:15], [@9,17:17='<',<LDELIM>,1:17], [@10,18:18='x',<ID>,1:18], [@11,19:19='>',<RDELIM>,1:19], [@12,20:20='<',<LDELIM>,1:20], [@13,21:21='y',<ID>,1:21], [@14,22:22='>',<RDELIM>,1:22], [@15,23:23='}',<RCURLY>,1:23], [@16,24:24='>',<RDELIM>,1:24]]";
-            CheckTokens(template, expected);
-        }
-
-        [TestMethod]
-        public void TestNestedSubtemplate()
-        {
-            string template = "hi <names:{n | <n:{<it>}>}>";
-            string expected =
-                "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='<',<LDELIM>,1:3], [@2,4:8='names',<ID>,1:4], [@3,9:9=':',<COLON>,1:9], [@4,10:10='{',<LCURLY>,1:10], [@5,11:11='n',<ID>,1:11], [@6,13:13='|',<PIPE>,1:13], [@7,15:15='<',<LDELIM>,1:15], [@8,16:16='n',<ID>,1:16], [@9,17:17=':',<COLON>,1:17], [@10,18:18='{',<LCURLY>,1:18], [@11,19:19='<',<LDELIM>,1:19], [@12,20:21='it',<ID>,1:20], [@13,22:22='>',<RDELIM>,1:22], [@14,23:23='}',<RCURLY>,1:23], [@15,24:24='>',<RDELIM>,1:24], [@16,25:25='}',<RCURLY>,1:25], [@17,26:26='>',<RDELIM>,1:26]]";
-            CheckTokens(template, expected);
-        }
-
-        [TestMethod]
-        public void TestNestedList()
-        {
-            string template =
-                "*<[names, [\"foo\",\"bar\"]:{<it>!},phones]; separator=\", \">*";
-            string expected =
-                "[[@0,0:0='*',<TEXT>,1:0], [@1,1:1='<',<LDELIM>,1:1], [@2,2:2='[',<LBRACK>,1:2], " +
-                "[@3,3:7='names',<ID>,1:3], [@4,8:8=',',<COMMA>,1:8], [@5,9:10=' [',<LBRACK>,1:9], " +
-                "[@6,11:15='\"foo\"',<STRING>,1:11], [@7,16:16=',',<COMMA>,1:16], " +
-                "[@8,17:21='\"bar\"',<STRING>,1:17], [@9,22:22=']',<RBRACK>,1:22], " +
-                "[@10,23:23=':',<COLON>,1:23], [@11,24:24='{',<LCURLY>,1:24], " +
-                "[@12,25:25='<',<LDELIM>,1:25], [@13,26:27='it',<ID>,1:26], " +
-                "[@14,28:28='>',<RDELIM>,1:28], [@15,29:29='!',<TEXT>,1:29], " +
-                "[@16,30:30='}',<RCURLY>,1:30], [@17,31:31=',',<COMMA>,1:31], " +
-                "[@18,32:37='phones',<ID>,1:32], [@19,38:38=']',<RBRACK>,1:38], " +
-                "[@20,39:39=';',<SEMI>,1:39], [@21,41:49='separator',<ID>,1:41], " +
-                "[@22,50:50='=',<EQUALS>,1:50], [@23,51:54='\", \"',<STRING>,1:51], " +
-                "[@24,55:55='>',<RDELIM>,1:55], [@25,56:56='*',<TEXT>,1:56]]";
-            CheckTokens(template, expected);
-        }
-
-        [TestMethod]
-        public void TestIF()
-        {
-            string template = "<if(!name)>works<endif>";
-            string expected =
-                "[[@0,0:0='<',<LDELIM>,1:0], [@1,1:2='if',<IF>,1:1], [@2,3:3='(',<LPAREN>,1:3], " +
-                "[@3,4:4='!',<BANG>,1:4], [@4,5:8='name',<ID>,1:5], [@5,9:9=')',<RPAREN>,1:9], " +
-                "[@6,10:10='>',<RDELIM>,1:10], [@7,11:15='works',<TEXT>,1:11], " +
-                "[@8,16:16='<',<LDELIM>,1:16], [@9,17:21='endif',<ENDIF>,1:17], " +
-                "[@10,22:22='>',<RDELIM>,1:22]]";
-            CheckTokens(template, expected);
-        }
-
-        [TestMethod]
-        public void TestIFNot()
-        {
-            string template = "<if(!name)>works<endif>";
-            string expected =
-                "[[@0,0:0='<',<LDELIM>,1:0], [@1,1:2='if',<IF>,1:1], [@2,3:3='(',<LPAREN>,1:3], " +
-                "[@3,4:4='!',<BANG>,1:4], [@4,5:8='name',<ID>,1:5], [@5,9:9=')',<RPAREN>,1:9], " +
-                "[@6,10:10='>',<RDELIM>,1:10], [@7,11:15='works',<TEXT>,1:11], " +
-                "[@8,16:16='<',<LDELIM>,1:16], [@9,17:21='endif',<ENDIF>,1:17], " +
-                "[@10,22:22='>',<RDELIM>,1:22]]";
-            CheckTokens(template, expected);
-        }
-
-        [TestMethod]
-        public void TestIFELSE()
-        {
-            string template = "<if(name)>works<else>fail<endif>";
-            string expected =
-                "[[@0,0:0='<',<LDELIM>,1:0], [@1,1:2='if',<IF>,1:1], [@2,3:3='(',<LPAREN>,1:3], " +
-                "[@3,4:7='name',<ID>,1:4], [@4,8:8=')',<RPAREN>,1:8], [@5,9:9='>',<RDELIM>,1:9], " +
-                "[@6,10:14='works',<TEXT>,1:10], [@7,15:15='<',<LDELIM>,1:15], " +
-                "[@8,16:19='else',<ELSE>,1:16], [@9,20:20='>',<RDELIM>,1:20], " +
-                "[@10,21:24='fail',<TEXT>,1:21], [@11,25:25='<',<LDELIM>,1:25], " +
-                "[@12,26:30='endif',<ENDIF>,1:26], [@13,31:31='>',<RDELIM>,1:31]]";
-            CheckTokens(template, expected);
-        }
-
-        [TestMethod]
-        public void TestELSEIF()
-        {
-            string template = "<if(name)>fail<elseif(id)>works<else>fail<endif>";
-            string expected =
-                "[[@0,0:0='<',<LDELIM>,1:0], [@1,1:2='if',<IF>,1:1], [@2,3:3='(',<LPAREN>,1:3], " +
-                "[@3,4:7='name',<ID>,1:4], [@4,8:8=')',<RPAREN>,1:8], [@5,9:9='>',<RDELIM>,1:9], " +
-                "[@6,10:13='fail',<TEXT>,1:10], [@7,14:14='<',<LDELIM>,1:14], " +
-                "[@8,15:20='elseif',<ELSEIF>,1:15], [@9,21:21='(',<LPAREN>,1:21], " +
-                "[@10,22:23='id',<ID>,1:22], [@11,24:24=')',<RPAREN>,1:24], " +
-                "[@12,25:25='>',<RDELIM>,1:25], [@13,26:30='works',<TEXT>,1:26], " +
-                "[@14,31:31='<',<LDELIM>,1:31], [@15,32:35='else',<ELSE>,1:32], " +
-                "[@16,36:36='>',<RDELIM>,1:36], [@17,37:40='fail',<TEXT>,1:37], " +
-                "[@18,41:41='<',<LDELIM>,1:41], [@19,42:46='endif',<ENDIF>,1:42], " +
-                "[@20,47:47='>',<RDELIM>,1:47]]";
-            CheckTokens(template, expected);
-        }
-
-        [TestMethod]
-        public void TestEmbeddedRegion()
-        {
-            string template = "<@r>foo<@end>";
-            string expected =
-                "[[@0,0:0='<',<LDELIM>,1:0], [@1,1:1='@',<AT>,1:1], [@2,2:2='r',<ID>,1:2], " +
-                "[@3,3:3='>',<RDELIM>,1:3], [@4,4:6='foo',<TEXT>,1:4], [@5,7:7='<',<LDELIM>,1:7], " +
-                "[@6,8:11='@end',<END>,1:8], [@7,12:12='>',<RDELIM>,1:12]]";
-            CheckTokens(template, expected);
-        }
-
-        [TestMethod]
-        public void TestRegion()
-        {
-            string template = "<@r()>";
-            string expected =
-                "[[@0,0:0='<',<LDELIM>,1:0], [@1,1:1='@',<AT>,1:1], [@2,2:2='r',<ID>,1:2], " +
-                 "[@3,3:3='(',<LPAREN>,1:3], [@4,4:4=')',<RPAREN>,1:4], [@5,5:5='>',<RDELIM>,1:5]]";
-            CheckTokens(template, expected);
-        }
-    }
-}
diff --git a/Antlr3.Test/ST4/TestLineWrap.cs b/Antlr3.Test/ST4/TestLineWrap.cs
deleted file mode 100644
index 1c59978..0000000
--- a/Antlr3.Test/ST4/TestLineWrap.cs
+++ /dev/null
@@ -1,438 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace AntlrUnitTests.ST4
-{
-    using Microsoft.VisualStudio.TestTools.UnitTesting;
-    using ArrayList = System.Collections.ArrayList;
-    using ST = StringTemplate.Template;
-    using STErrorListener = StringTemplate.ITemplateErrorListener;
-    using STGroup = StringTemplate.TemplateGroup;
-    using STGroupFile = StringTemplate.TemplateGroupFile;
-    using String = System.String;
-    using StringTemplate;
-    using StringWriter = System.IO.StringWriter;
-    using Path = System.IO.Path;
-
-    [TestClass]
-    public class TestLineWrap : StringTemplateTestBase
-    {
-        [TestMethod]
-        public void TestLineWrap1()
-        {
-            String templates =
-                "array(values) ::= <<int[] a = { <values; wrap=\"\\n\", separator=\",\"> };>>" + newline;
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-
-            ST a = group.GetInstanceOf("array");
-            a.Add("values",
-                           new int[] {3,9,20,2,1,4,6,32,5,6,77,888,2,1,6,32,5,6,77,
-						4,9,20,2,1,4,63,9,20,2,1,4,6,32,5,6,77,6,32,5,6,77,
-					    3,9,20,2,1,4,6,32,5,6,77,888,1,6,32,5});
-            String expecting =
-                "int[] a = { 3,9,20,2,1,4,6,32,5,6,77,888,\n" +
-                "2,1,6,32,5,6,77,4,9,20,2,1,4,63,9,20,2,1,\n" +
-                "4,6,32,5,6,77,6,32,5,6,77,3,9,20,2,1,4,6,\n" +
-                "32,5,6,77,888,1,6,32,5 };";
-
-            StringWriter sw = new StringWriter();
-            ITemplateWriter stw = new AutoIndentWriter(sw, "\n"); // force \n as newline
-            stw.SetLineWidth(40);
-            a.Write(stw);
-            String result = sw.ToString();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestLineWrapAnchored()
-        {
-            String templates =
-                    "array(values) ::= <<int[] a = { <values; anchor, wrap, separator=\",\"> };>>" + newline;
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-
-            ST a = group.GetInstanceOf("array");
-            a.Add("values",
-                           new int[] {3,9,20,2,1,4,6,32,5,6,77,888,2,1,6,32,5,6,77,
-						4,9,20,2,1,4,63,9,20,2,1,4,6,32,5,6,77,6,32,5,6,77,
-					    3,9,20,2,1,4,6,32,5,6,77,888,1,6,32,5});
-            String expecting =
-                "int[] a = { 3,9,20,2,1,4,6,32,5,6,77,888," + newline +
-                "            2,1,6,32,5,6,77,4,9,20,2,1,4," + newline +
-                "            63,9,20,2,1,4,6,32,5,6,77,6," + newline +
-                "            32,5,6,77,3,9,20,2,1,4,6,32," + newline +
-                "            5,6,77,888,1,6,32,5 };";
-            Assert.AreEqual(expecting, a.Render(40));
-        }
-
-        [TestMethod]
-        public void TestSubtemplatesAnchorToo()
-        {
-            String templates =
-                    "array(values) ::= <<{ <values; anchor, separator=\", \"> }>>" + newline;
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-
-            ST x = new ST("<\\n>{ <stuff; anchor, separator=\",\\n\"> }<\\n>");
-            x.groupThatCreatedThisInstance = group;
-            x.Add("stuff", "1");
-            x.Add("stuff", "2");
-            x.Add("stuff", "3");
-            ST a = group.GetInstanceOf("array");
-            a.Add("values", new ArrayList() { "a", x, "b" });
-            String expecting =
-                "{ a," + newline +
-                "  { 1," + newline +
-                "    2," + newline +
-                "    3 }" + newline +
-                "  , b }";
-            Assert.AreEqual(expecting, a.Render(40));
-        }
-
-        [TestMethod]
-        public void TestFortranLineWrap()
-        {
-            String templates =
-                    "func(args) ::= <<       FUNCTION line( <args; wrap=\"\\n      c\", separator=\",\"> )>>" + newline;
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
-
-            ST a = group.GetInstanceOf("func");
-            a.Add("args",
-                           new String[] { "a", "b", "c", "d", "e", "f" });
-            String expecting =
-                "       FUNCTION line( a,b,c,d," + newline +
-                "      ce,f )";
-            Assert.AreEqual(expecting, a.Render(30));
-        }
-
-        [TestMethod]
-        public void TestLineWrapWithDiffAnchor()
-        {
-            String templates =
-                    "array(values) ::= <<int[] a = { <{1,9,2,<values; wrap, separator=\",\">}; anchor> };>>" + newline;
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
-
-            ST a = group.GetInstanceOf("array");
-            a.Add("values",
-                           new int[] {3,9,20,2,1,4,6,32,5,6,77,888,2,1,6,32,5,6,77,
-						4,9,20,2,1,4,63,9,20,2,1,4,6});
-            String expecting =
-                "int[] a = { 1,9,2,3,9,20,2,1,4," + newline +
-                "            6,32,5,6,77,888,2," + newline +
-                "            1,6,32,5,6,77,4,9," + newline +
-                "            20,2,1,4,63,9,20,2," + newline +
-                "            1,4,6 };";
-            Assert.AreEqual(expecting, a.Render(30));
-        }
-
-        [TestMethod]
-        public void TestLineWrapEdgeCase()
-        {
-            String templates =
-                    "duh(chars) ::= <<<chars; wrap=\"\\n\"\\>>>" + newline;
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
-
-            ST a = group.GetInstanceOf("duh");
-            a.Add("chars", new String[] { "a", "b", "c", "d", "e" });
-            // lineWidth==3 implies that we can have 3 characters at most
-            String expecting =
-                "abc" + newline +
-                "de";
-            Assert.AreEqual(expecting, a.Render(3));
-        }
-
-        [TestMethod]
-        public void TestLineWrapLastCharIsNewline()
-        {
-            String templates =
-                    "duh(chars) ::= <<<chars; wrap=\"\\n\"\\>>>" + newline;
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-
-            ST a = group.GetInstanceOf("duh");
-            a.Add("chars", new String[] { "a", "b", "\n", "d", "e" });
-            // don't do \n if it's last element anyway
-            String expecting =
-                "ab" + newline +
-                "de";
-            Assert.AreEqual(expecting, a.Render(3));
-        }
-
-        [TestMethod]
-        public void TestLineWrapCharAfterWrapIsNewline()
-        {
-            String templates =
-                    "duh(chars) ::= <<<chars; wrap=\"\\n\"\\>>>" + newline;
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
-
-            ST a = group.GetInstanceOf("duh");
-            a.Add("chars", new String[] { "a", "b", "c", "\n", "d", "e" });
-            // Once we wrap, we must dump chars as we see them.  A newline right
-            // after a wrap is just an "unfortunate" event.  People will expect
-            // a newline if it's in the data.
-            String expecting =
-                "abc" + newline +
-                "" + newline +
-                "de";
-            Assert.AreEqual(expecting, a.Render(3));
-        }
-
-        [TestMethod]
-        public void TestLineWrapForList()
-        {
-            String templates =
-                    "duh(data) ::= <<!<data; wrap>!>>" + newline;
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
-
-            ST a = group.GetInstanceOf("duh");
-            a.Add("data", new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 });
-            String expecting =
-                "!123" + newline +
-                "4567" + newline +
-                "89!";
-            Assert.AreEqual(expecting, a.Render(4));
-        }
-
-        [TestMethod]
-        public void TestLineWrapForAnonTemplate()
-        {
-            String templates =
-                    "duh(data) ::= <<!<data:{v|[<v>]}; wrap>!>>" + newline;
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
-
-            ST a = group.GetInstanceOf("duh");
-            a.Add("data", new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 });
-            String expecting =
-                "![1][2][3]" + newline + // width=9 is the 3 char; don't break til after ]
-                "[4][5][6]" + newline +
-                "[7][8][9]!";
-            Assert.AreEqual(expecting, a.Render(9));
-        }
-
-        [TestMethod]
-        public void TestLineWrapForAnonTemplateAnchored()
-        {
-            String templates =
-                    "duh(data) ::= <<!<data:{v|[<v>]}; anchor, wrap>!>>" + newline;
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
-
-            ST a = group.GetInstanceOf("duh");
-            a.Add("data", new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 });
-            String expecting =
-                "![1][2][3]" + newline +
-                " [4][5][6]" + newline +
-                " [7][8][9]!";
-            Assert.AreEqual(expecting, a.Render(9));
-        }
-
-        [TestMethod]
-        public void TestLineWrapForAnonTemplateComplicatedWrap()
-        {
-            String templates =
-                    "top(s) ::= <<  <s>.>>" +
-                    "str(data) ::= <<!<data:{v|[<v>]}; wrap=\"!+\\n!\">!>>" + newline;
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
-
-            ST t = group.GetInstanceOf("top");
-            ST s = group.GetInstanceOf("str");
-            s.Add("data", new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 });
-            t.Add("s", s);
-            String expecting =
-                "  ![1][2]!+" + newline +
-                "  ![3][4]!+" + newline +
-                "  ![5][6]!+" + newline +
-                "  ![7][8]!+" + newline +
-                "  ![9]!.";
-            Assert.AreEqual(expecting, t.Render(9));
-        }
-
-        [TestMethod]
-        public void TestIndentBeyondLineWidth()
-        {
-            String templates =
-                    "duh(chars) ::= <<    <chars; wrap=\"\\n\"\\>>>" + newline;
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
-
-            ST a = group.GetInstanceOf("duh");
-            a.Add("chars", new String[] { "a", "b", "c", "d", "e" });
-            //
-            String expecting =
-                "    a" + newline +
-                "    b" + newline +
-                "    c" + newline +
-                "    d" + newline +
-                "    e";
-            Assert.AreEqual(expecting, a.Render(2));
-        }
-
-        [TestMethod]
-        public void TestIndentedExpr()
-        {
-            String templates =
-                    "duh(chars) ::= <<    <chars; wrap=\"\\n\"\\>>>" + newline;
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
-
-            ST a = group.GetInstanceOf("duh");
-            a.Add("chars", new String[] { "a", "b", "c", "d", "e" });
-            //
-            String expecting =
-                "    ab" + newline +
-                "    cd" + newline +
-                "    e";
-            // width=4 spaces + 2 char.
-            Assert.AreEqual(expecting, a.Render(6));
-        }
-
-        [TestMethod]
-        public void TestNestedIndentedExpr()
-        {
-            String templates =
-                    "top(d) ::= <<  <d>!>>" + newline +
-                    "duh(chars) ::= <<  <chars; wrap=\"\\n\"\\>>>" + newline;
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
-
-            ST top = group.GetInstanceOf("top");
-            ST duh = group.GetInstanceOf("duh");
-            duh.Add("chars", new String[] { "a", "b", "c", "d", "e" });
-            top.Add("d", duh);
-            String expecting =
-                "    ab" + newline +
-                "    cd" + newline +
-                "    e!";
-            // width=4 spaces + 2 char.
-            Assert.AreEqual(expecting, top.Render(6));
-        }
-
-        [TestMethod]
-        public void TestNestedWithIndentAndTrackStartOfExpr()
-        {
-            String templates =
-                    "top(d) ::= <<  <d>!>>" + newline +
-                    "duh(chars) ::= <<x: <chars; anchor, wrap=\"\\n\"\\>>>" + newline;
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
-
-            ST top = group.GetInstanceOf("top");
-            ST duh = group.GetInstanceOf("duh");
-            duh.Add("chars", new String[] { "a", "b", "c", "d", "e" });
-            top.Add("d", duh);
-            //
-            String expecting =
-                "  x: ab" + newline +
-                "     cd" + newline +
-                "     e!";
-            Assert.AreEqual(expecting, top.Render(7));
-        }
-
-        [TestMethod]
-        public void TestLineDoesNotWrapDueToLiteral()
-        {
-            String templates =
-                    "m(args,body) ::= <<[TestMethod] public voidfoo(<args; wrap=\"\\n\",separator=\", \">) throws Ick { <body> }>>" + newline;
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
-
-            ST a = group.GetInstanceOf("m");
-            a.Add("args",
-                           new String[] { "a", "b", "c" });
-            a.Add("body", "i=3;");
-            // make it wrap because of ") throws Ick { " literal
-            int n = "[TestMethod] public voidfoo(a, b, c".Length;
-            String expecting =
-                "[TestMethod] public voidfoo(a, b, c) throws Ick { i=3; }";
-            Assert.AreEqual(expecting, a.Render(n));
-        }
-
-        [TestMethod]
-        public void TestSingleValueWrap()
-        {
-            String templates =
-                    "m(args,body) ::= <<{ <body; anchor, wrap=\"\\n\"> }>>" + newline;
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
-
-            ST m = group.GetInstanceOf("m");
-            m.Add("body", "i=3;");
-            // make it wrap because of ") throws Ick { " literal
-            String expecting =
-                "{ " + newline +
-                "  i=3; }";
-            Assert.AreEqual(expecting, m.Render(2));
-        }
-
-        [TestMethod]
-        public void TestLineWrapInNestedExpr()
-        {
-            String templates =
-                    "top(arrays) ::= <<Arrays: <arrays>done>>" + newline +
-                    "array(values) ::= <<int[] a = { <values; anchor, wrap=\"\\n\", separator=\",\"> };<\\n\\>>>" + newline;
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
-
-            ST top = group.GetInstanceOf("top");
-            ST a = group.GetInstanceOf("array");
-            a.Add("values",
-                           new int[] {3,9,20,2,1,4,6,32,5,6,77,888,2,1,6,32,5,6,77,
-						4,9,20,2,1,4,63,9,20,2,1,4,6,32,5,6,77,6,32,5,6,77,
-					    3,9,20,2,1,4,6,32,5,6,77,888,1,6,32,5});
-            top.Add("arrays", a);
-            top.Add("arrays", a); // add twice
-            String expecting =
-                "Arrays: int[] a = { 3,9,20,2,1,4,6,32,5," + newline +
-                "                    6,77,888,2,1,6,32,5," + newline +
-                "                    6,77,4,9,20,2,1,4,63," + newline +
-                "                    9,20,2,1,4,6,32,5,6," + newline +
-                "                    77,6,32,5,6,77,3,9,20," + newline +
-                "                    2,1,4,6,32,5,6,77,888," + newline +
-                "                    1,6,32,5 };" + newline +
-                "int[] a = { 3,9,20,2,1,4,6,32,5,6,77,888," + newline +
-                "            2,1,6,32,5,6,77,4,9,20,2,1,4," + newline +
-                "            63,9,20,2,1,4,6,32,5,6,77,6," + newline +
-                "            32,5,6,77,3,9,20,2,1,4,6,32," + newline +
-                "            5,6,77,888,1,6,32,5 };" + newline +
-                "done";
-            Assert.AreEqual(expecting, top.Render(40));
-        }
-    }
-}
diff --git a/Antlr3.Test/ST4/TestLists.cs b/Antlr3.Test/ST4/TestLists.cs
deleted file mode 100644
index 4444e36..0000000
--- a/Antlr3.Test/ST4/TestLists.cs
+++ /dev/null
@@ -1,177 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace AntlrUnitTests.ST4
-{
-    using Microsoft.VisualStudio.TestTools.UnitTesting;
-    using ArrayList = System.Collections.ArrayList;
-    using ST = StringTemplate.Template;
-    using STErrorListener = StringTemplate.ITemplateErrorListener;
-    using STGroup = StringTemplate.TemplateGroup;
-    using STGroupFile = StringTemplate.TemplateGroupFile;
-    using String = System.String;
-
-    [TestClass]
-    public class TestLists : StringTemplateTestBase
-    {
-        [TestMethod]
-        public void TestJustCat()
-        {
-            ST e = new ST(
-                    "<[names,phones]>"
-                );
-            e.Add("names", "Ter");
-            e.Add("names", "Tom");
-            e.Add("phones", "1");
-            e.Add("phones", "2");
-            String expecting = "TerTom12";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestCat2Attributes()
-        {
-            ST e = new ST(
-                    "<[names,phones]; separator=\", \">"
-                );
-            e.Add("names", "Ter");
-            e.Add("names", "Tom");
-            e.Add("phones", "1");
-            e.Add("phones", "2");
-            String expecting = "Ter, Tom, 1, 2";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestCat2AttributesWithApply()
-        {
-            ST e = new ST(
-                    "<[names,phones]:{a|<a>.}>"
-                );
-            e.Add("names", "Ter");
-            e.Add("names", "Tom");
-            e.Add("phones", "1");
-            e.Add("phones", "2");
-            String expecting = "Ter.Tom.1.2.";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestCat3Attributes()
-        {
-            ST e = new ST(
-                    "<[names,phones,salaries]; separator=\", \">"
-                );
-            e.Add("names", "Ter");
-            e.Add("names", "Tom");
-            e.Add("phones", "1");
-            e.Add("phones", "2");
-            e.Add("salaries", "big");
-            e.Add("salaries", "huge");
-            String expecting = "Ter, Tom, 1, 2, big, huge";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestCatWithTemplateApplicationAsElement()
-        {
-            ST e = new ST(
-                    "<[names:{<it>!},phones]; separator=\", \">"
-                );
-            e.Add("names", "Ter");
-            e.Add("names", "Tom");
-            e.Add("phones", "1");
-            e.Add("phones", "2");
-            String expecting = "Ter!, Tom!, 1, 2";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestCatWithIFAsElement()
-        {
-            ST e = new ST(
-                    "<[{<if(names)>doh<endif>},phones]; separator=\", \">"
-                );
-            e.Add("names", "Ter");
-            e.Add("names", "Tom");
-            e.Add("phones", "1");
-            e.Add("phones", "2");
-            String expecting = "doh, 1, 2";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestCatWithNullTemplateApplicationAsElement()
-        {
-            ST e = new ST(
-                    "<[names:{<it>!},\"foo\"]:{x}; separator=\", \">"
-                );
-            e.Add("phones", "1");
-            e.Add("phones", "2");
-            String expecting = "x";  // only one since template application gives nothing
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestCatWithNestedTemplateApplicationAsElement()
-        {
-            ST e = new ST(
-                    "<[names, [\"foo\",\"bar\"]:{<it>!},phones]; separator=\", \">"
-                );
-            e.Add("names", "Ter");
-            e.Add("names", "Tom");
-            e.Add("phones", "1");
-            e.Add("phones", "2");
-            String expecting = "Ter, Tom, foo!, bar!, 1, 2";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestListAsTemplateArgument()
-        {
-            String templates =
-                    "test(names,phones) ::= \"<foo([names,phones])>\"" + newline +
-                    "foo(items) ::= \"<items:{a | *<a>*}>\"" + newline
-                    ;
-            WriteFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
-            ST e = group.GetInstanceOf("test");
-            e.Add("names", "Ter");
-            e.Add("names", "Tom");
-            e.Add("phones", "1");
-            e.Add("phones", "2");
-            String expecting = "*Ter**Tom**1**2*";
-            String result = e.Render();
-            Assert.AreEqual(expecting, result);
-        }
-    }
-}
diff --git a/Antlr3.Test/ST4/TestNullAndEmptyValues.cs b/Antlr3.Test/ST4/TestNullAndEmptyValues.cs
deleted file mode 100644
index f578d17..0000000
--- a/Antlr3.Test/ST4/TestNullAndEmptyValues.cs
+++ /dev/null
@@ -1,149 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace AntlrUnitTests.ST4
-{
-    using Microsoft.VisualStudio.TestTools.UnitTesting;
-    using ArrayList = System.Collections.ArrayList;
-    using ST = StringTemplate.Template;
-    using STErrorListener = StringTemplate.ITemplateErrorListener;
-    using STGroup = StringTemplate.TemplateGroup;
-    using String = System.String;
-    using StringTemplate;
-
-    [TestClass]
-    public class TestNullAndEmptyValues : StringTemplateTestBase
-    {
-        [TestMethod]
-        public void TestSeparatorWithNullFirstValue()
-        {
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("test"), "hi <name; separator=\", \">!");
-            ST st = group.GetInstanceOf("test");
-            st.Add("name", null); // null is added to list, but ignored in iteration
-            st.Add("name", "Tom");
-            st.Add("name", "Sumana");
-            String expected = "hi Tom, Sumana!";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestSeparatorWithNull2ndValue()
-        {
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("test"), "hi <name; separator=\", \">!");
-            ST st = group.GetInstanceOf("test");
-            st.Add("name", "Ter");
-            st.Add("name", null);
-            st.Add("name", "Sumana");
-            String expected = "hi Ter, Sumana!";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestSeparatorWithNullLastValue()
-        {
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("test"), "hi <name; separator=\", \">!");
-            ST st = group.GetInstanceOf("test");
-            st.Add("name", "Ter");
-            st.Add("name", "Tom");
-            st.Add("name", null);
-            String expected = "hi Ter, Tom!";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestSeparatorWithTwoNullValuesInRow()
-        {
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("test"), "hi <name; separator=\", \">!");
-            ST st = group.GetInstanceOf("test");
-            st.Add("name", "Ter");
-            st.Add("name", "Tom");
-            st.Add("name", null);
-            st.Add("name", null);
-            st.Add("name", "Sri");
-            String expected = "hi Ter, Tom, Sri!";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestSizeZeroButNonNullListGetsNoOutput()
-        {
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("test"),
-                "begin\n" +
-                "<users>\n" +
-                "end\n");
-            ST t = group.GetInstanceOf("test");
-            t.Add("users", null);
-            String expecting = "begin" + newline + "end" + newline;
-            String result = t.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestNullListGetsNoOutput()
-        {
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("test"),
-                "begin\n" +
-                "<users:{name: <it>}; separator=\", \">\n" +
-                "end\n");
-            ST t = group.GetInstanceOf("test");
-            //t.setAttribute("users", new Duh());
-            String expecting = "begin" + newline + "end" + newline;
-            String result = t.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestEmptyListGetsNoOutput()
-        {
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("test"),
-                "begin\n" +
-                "<users:{name: <it>}; separator=\", \">\n" +
-                "end\n");
-            ST t = group.GetInstanceOf("test");
-            t.Add("users", new ArrayList());
-            String expecting = "begin" + newline + "end" + newline;
-            String result = t.Render();
-            Assert.AreEqual(expecting, result);
-        }
-    }
-}
diff --git a/Antlr3.Test/ST4/TestOptions.cs b/Antlr3.Test/ST4/TestOptions.cs
deleted file mode 100644
index c6b7c81..0000000
--- a/Antlr3.Test/ST4/TestOptions.cs
+++ /dev/null
@@ -1,184 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace AntlrUnitTests.ST4
-{
-    using Microsoft.VisualStudio.TestTools.UnitTesting;
-    using ST = StringTemplate.Template;
-    using STGroup = StringTemplate.TemplateGroup;
-    using String = System.String;
-    using StringTemplate;
-
-    [TestClass]
-    public class TestOptions : StringTemplateTestBase
-    {
-        [TestMethod]
-        public void TestSeparator()
-        {
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("test"), "hi <name; separator=\", \">!");
-            ST st = group.GetInstanceOf("test");
-            st.Add("name", "Ter");
-            st.Add("name", "Tom");
-            st.Add("name", "Sumana");
-            String expected = "hi Ter, Tom, Sumana!";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestAttrSeparator()
-        {
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("test"), "hi <name; separator=sep>!");
-            ST st = group.GetInstanceOf("test");
-            st.Add("sep", ", ");
-            st.Add("name", "Ter");
-            st.Add("name", "Tom");
-            st.Add("name", "Sumana");
-            String expected = "hi Ter, Tom, Sumana!";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestIncludeSeparator()
-        {
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("foo"), "|");
-            group.DefineTemplate(new TemplateName("test"), "hi <name; separator=foo()>!");
-            ST st = group.GetInstanceOf("test");
-            st.Add("sep", ", ");
-            st.Add("name", "Ter");
-            st.Add("name", "Tom");
-            st.Add("name", "Sumana");
-            String expected = "hi Ter|Tom|Sumana!";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestSubtemplateSeparator()
-        {
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("test"), "hi <name; separator={<sep> _}>!");
-            ST st = group.GetInstanceOf("test");
-            st.Add("sep", ",");
-            st.Add("name", "Ter");
-            st.Add("name", "Tom");
-            st.Add("name", "Sumana");
-            String expected = "hi Ter, _Tom, _Sumana!";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestSeparatorWithNullFirstValueAndNullOption()
-        {
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("test"), "hi <name; null=\"n/a\", separator=\", \">!");
-            ST st = group.GetInstanceOf("test");
-            st.Add("name", null);
-            st.Add("name", "Tom");
-            st.Add("name", "Sumana");
-            String expected = "hi n/a, Tom, Sumana!";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestSeparatorWithNull2ndValueAndNullOption()
-        {
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("test"), "hi <name; null=\"n/a\", separator=\", \">!");
-            ST st = group.GetInstanceOf("test");
-            st.Add("name", "Ter");
-            st.Add("name", null);
-            st.Add("name", "Sumana");
-            String expected = "hi Ter, n/a, Sumana!";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestNullValueAndNullOption()
-        {
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("test"), "<name; null=\"n/a\">");
-            ST st = group.GetInstanceOf("test");
-            st.Add("name", null);
-            String expected = "n/a";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestMissingValueAndNullOption()
-        {
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("test"), "<name; null=\"n/a\">");
-            ST st = group.GetInstanceOf("test");
-            String expected = "n/a";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestOptionDoesntApplyToNestedTemplate()
-        {
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("foo"), "<zippo>");
-            group.DefineTemplate(new TemplateName("test"), "<foo(); null=\"n/a\">");
-            ST st = group.GetInstanceOf("test");
-            st.Add("zippo", null);
-            String expected = "";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestIllegalOption()
-        {
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("test"), "<name; bad=\"ugly\">");
-            ST st = group.GetInstanceOf("test");
-            st.Add("name", "Ter");
-            String expected = "Ter";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-            expected = "1:7: no such option: bad" + newline;
-            Assert.AreEqual(expected, errors.ToString());
-        }
-    }
-}
diff --git a/Antlr3.Test/ST4/TestRegions.cs b/Antlr3.Test/ST4/TestRegions.cs
deleted file mode 100644
index 6d3a9a4..0000000
--- a/Antlr3.Test/ST4/TestRegions.cs
+++ /dev/null
@@ -1,160 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace AntlrUnitTests.ST4
-{
-    using Microsoft.VisualStudio.TestTools.UnitTesting;
-    using StringTemplate;
-    using Path = System.IO.Path;
-
-    [TestClass]
-    public class TestRegions : StringTemplateTestBase
-    {
-        [TestMethod]
-        public void TestEmbeddedRegion()
-        {
-            string dir = GetRandomDir();
-            string groupFile =
-                "a() ::= <<\n" +
-                "[<@r>bar<@end>]\n" +
-                ">>\n";
-            WriteFile(dir, "group.stg", groupFile);
-            TemplateGroup group = new TemplateGroupFile(dir + "/group.stg");
-            Template st = group.GetInstanceOf("a");
-            string expected = "[bar]" + newline;
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestRegion()
-        {
-            string dir = GetRandomDir();
-            string groupFile =
-                "a() ::= <<\n" +
-                "[<@r()>]\n" +
-                ">>\n";
-            WriteFile(dir, "group.stg", groupFile);
-            TemplateGroup group = new TemplateGroupFile(dir + "/group.stg");
-            Template st = group.GetInstanceOf("a");
-            string expected = "[]" + newline;
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestDefineRegionInSubgroup()
-        {
-            string dir = GetRandomDir();
-            string g1 = "a() ::= <<[<@r()>]>>\n";
-            WriteFile(dir, "g1.stg", g1);
-            string g2 = "@a.r() ::= <<foo>>\n";
-            WriteFile(dir, "g2.stg", g2);
-
-            TemplateGroup group1 = new TemplateGroupFile(dir + "/g1.stg");
-            TemplateGroup group2 = new TemplateGroupFile(dir + "/g2.stg");
-            group2.ImportTemplates(group1); // define r in g2
-            Template st = group2.GetInstanceOf("a");
-            string expected = "[foo]";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestDefineRegionInSubgroupThatRefsSuper()
-        {
-            string dir = GetRandomDir();
-            string g1 = "a() ::= <<[<@r>foo<@end>]>>\n";
-            WriteFile(dir, "g1.stg", g1);
-            string g2 = "@a.r() ::= <<(<@super.r()>)>>\n";
-            WriteFile(dir, "g2.stg", g2);
-
-            TemplateGroup group1 = new TemplateGroupFile(dir + "/g1.stg");
-            TemplateGroup group2 = new TemplateGroupFile(dir + "/g2.stg");
-            group2.ImportTemplates(group1); // define r in g2
-            Template st = group2.GetInstanceOf("a");
-            string expected = "[(foo)]";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestDefineRegionInSubgroup2()
-        {
-            string dir = GetRandomDir();
-            string g1 = "a() ::= <<[<@r()>]>>\n";
-            WriteFile(dir, "g1.stg", g1);
-            string g2 = "@a.r() ::= <<foo>>>\n";
-            WriteFile(dir, "g2.stg", g2);
-
-            TemplateGroup group1 = new TemplateGroupFile(dir + "/g1.stg");
-            TemplateGroup group2 = new TemplateGroupFile(dir + "/g2.stg");
-            group1.ImportTemplates(group2); // opposite of previous; g1 imports g2
-            Template st = group1.GetInstanceOf("a");
-            string expected = "[]"; // @a.r implicitly defined in g1; can't see g2's
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestDefineRegionInSameGroup()
-        {
-            string dir = GetRandomDir();
-            string g = "a() ::= <<[<@r()>]>>\n" +
-                       "@a.r() ::= <<foo>>\n";
-            WriteFile(dir, "g.stg", g);
-
-            TemplateGroup group = new TemplateGroupFile(dir + "/g.stg");
-            Template st = group.GetInstanceOf("a");
-            string expected = "[foo]";
-            string result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestCantDefineEmbeddedRegionAgain()
-        {
-            string dir = GetRandomDir();
-            string g = "a() ::= <<[<@r>foo<@end>]>>\n" +
-                       "@a.r() ::= <<bar>>\n"; // error; dup
-            WriteFile(dir, "g.stg", g);
-
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(dir, "g.stg"));
-            ErrorBuffer errors = new ErrorBuffer();
-            ErrorManager.ErrorListener = errors;
-            group.Load();
-            string expected = "2:3: region a.r is embedded and thus already implicitly defined" + newline;
-            string result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-    }
-}
diff --git a/Antlr3.Test/ST4/TestRenderers.cs b/Antlr3.Test/ST4/TestRenderers.cs
deleted file mode 100644
index 7453f83..0000000
--- a/Antlr3.Test/ST4/TestRenderers.cs
+++ /dev/null
@@ -1,244 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace AntlrUnitTests.ST4
-{
-    using Microsoft.VisualStudio.TestTools.UnitTesting;
-    using StringTemplate;
-    using ArrayList = System.Collections.ArrayList;
-    using CultureInfo = System.Globalization.CultureInfo;
-    using DateTime = System.DateTime;
-    using IList = System.Collections.IList;
-    using Path = System.IO.Path;
-
-    [TestClass]
-    public class TestRenderers : StringTemplateTestBase
-    {
-        [TestMethod]
-        public void TestRendererForGroup()
-        {
-            string templates =
-                    "dateThing(created) ::= \"datetime: <created>\"\n";
-            WriteFile(tmpdir, "t.stg", templates);
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
-            group.RegisterRenderer(typeof(DateTime), new DateTimeRenderer());
-            Template st = group.GetInstanceOf("dateThing");
-            st.Add("created", new DateTime(2005, 7, 5));
-            string expecting = "datetime: 7/5/2005 12:00 AM";
-            string result = st.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestRendererWithFormat()
-        {
-            string templates =
-                    "dateThing(created) ::= << date: <created; format=\"yyyy.MM.dd\"> >>\n";
-            WriteFile(tmpdir, "t.stg", templates);
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
-            group.RegisterRenderer(typeof(DateTime), new DateTimeRenderer());
-            Template st = group.GetInstanceOf("dateThing");
-            st.Add("created", new DateTime(2005, 7, 5));
-            string expecting = " date: 2005.07.05 ";
-            string result = st.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestRendererWithPredefinedFormat()
-        {
-            string templates =
-                    "dateThing(created) ::= << datetime: <created; format=\"short\"> >>\n";
-            WriteFile(tmpdir, "t.stg", templates);
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
-            group.RegisterRenderer(typeof(DateTime), new DateTimeRenderer());
-            Template st = group.GetInstanceOf("dateThing");
-            st.Add("created", new DateTime(2005, 7, 5));
-            string expecting = " datetime: 7/5/2005 12:00 AM ";
-            string result = st.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestRendererWithPredefinedFormat2()
-        {
-            string templates =
-                    "dateThing(created) ::= << datetime: <created; format=\"full\"> >>\n";
-            WriteFile(tmpdir, "t.stg", templates);
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
-            group.RegisterRenderer(typeof(DateTime), new DateTimeRenderer());
-            Template st = group.GetInstanceOf("dateThing");
-            st.Add("created", new DateTime(2005, 7, 5));
-            string expecting = " datetime: Tuesday, July 5, 2005 12:00:00 AM PDT ";
-            string result = st.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestRendererWithPredefinedFormat3()
-        {
-            string templates =
-                    "dateThing(created) ::= << date: <created; format=\"date:medium\"> >>\n";
-
-            WriteFile(tmpdir, "t.stg", templates);
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
-            group.RegisterRenderer(typeof(DateTime), new DateTimeRenderer());
-            Template st = group.GetInstanceOf("dateThing");
-            st.Add("created", new DateTime(2005, 7, 5));
-            string expecting = " date: Jul 5, 2005 ";
-            string result = st.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestRendererWithPredefinedFormat4()
-        {
-            string templates =
-                    "dateThing(created) ::= << time: <created; format=\"time:medium\"> >>\n";
-
-            WriteFile(tmpdir, "t.stg", templates);
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
-            group.RegisterRenderer(typeof(DateTime), new DateTimeRenderer());
-            Template st = group.GetInstanceOf("dateThing");
-            st.Add("created", new DateTime(2005, 7, 5));
-            string expecting = " time: 12:00:00 AM ";
-            string result = st.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestStringRendererWithPrintfFormat()
-        {
-            string templates =
-                    "foo(x) ::= << <x; format=\"%6s\"> >>\n";
-
-            WriteFile(tmpdir, "t.stg", templates);
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
-            group.RegisterRenderer(typeof(string), new StringRenderer());
-            Template st = group.GetInstanceOf("foo");
-            st.Add("x", "hi");
-            string expecting = "     hi ";
-            string result = st.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestNumberRendererWithPrintfFormat()
-        {
-            string templates =
-                    "foo(x,y) ::= << <x; format=\"F0\"> <y; format=\"0.000\"> >>\n";
-
-            WriteFile(tmpdir, "t.stg", templates);
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
-            group.RegisterRenderer(typeof(int), new NumberRenderer());
-            group.RegisterRenderer(typeof(double), new NumberRenderer());
-            Template st = group.GetInstanceOf("foo");
-            st.Add("x", -2100);
-            st.Add("y", 3.14159);
-            string expecting = " -2100 3.142 ";
-            string result = st.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestLocaleWithNumberRenderer()
-        {
-            string templates =
-                    "foo(x,y) ::= << <x; format=\"N0\"> <y; format=\"0.000\"> >>\n";
-
-            WriteFile(tmpdir, "t.stg", templates);
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
-            group.RegisterRenderer(typeof(int), new NumberRenderer());
-            group.RegisterRenderer(typeof(double), new NumberRenderer());
-            Template st = group.GetInstanceOf("foo");
-            st.Add("x", -2100);
-            st.Add("y", 3.14159);
-            // Polish uses ' ' for ',' and ',' for '.'
-            string expecting = " -2 100 3,142 ";
-            string result = st.Render(CultureInfo.GetCultureInfo("pl-PL"));
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestRendererWithFormatAndList()
-        {
-            string template =
-                    "The names: <names; format=\"upper\">";
-            TemplateGroup group = new TemplateGroup();
-            group.RegisterRenderer(typeof(string), new StringRenderer());
-            Template st = new Template(template);
-            st.groupThatCreatedThisInstance = group;
-            st.Add("names", "ter");
-            st.Add("names", "tom");
-            st.Add("names", "sriram");
-            string expecting = "The names: TERTOMSRIRAM";
-            string result = st.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestRendererWithFormatAndSeparator()
-        {
-            string template =
-                    "The names: <names; separator=\" and \", format=\"upper\">";
-            TemplateGroup group = new TemplateGroup();
-            group.RegisterRenderer(typeof(string), new StringRenderer());
-            Template st = new Template(template);
-            st.groupThatCreatedThisInstance = group;
-            st.Add("names", "ter");
-            st.Add("names", "tom");
-            st.Add("names", "sriram");
-            string expecting = "The names: TER and TOM and SRIRAM";
-            string result = st.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestRendererWithFormatAndSeparatorAndNull()
-        {
-            string template =
-                    "The names: <names; separator=\" and \", null=\"n/a\", format=\"upper\">";
-            TemplateGroup group = new TemplateGroup();
-            group.RegisterRenderer(typeof(string), new StringRenderer());
-            Template st = new Template(template);
-            st.groupThatCreatedThisInstance = group;
-            IList names = new ArrayList();
-            names.Add("ter");
-            names.Add(null);
-            names.Add("sriram");
-            st.Add("names", names);
-            string expecting = "The names: TER and N/A and SRIRAM";
-            string result = st.Render();
-            Assert.AreEqual(expecting, result);
-        }
-    }
-}
diff --git a/Antlr3.Test/ST4/TestSubtemplates.cs b/Antlr3.Test/ST4/TestSubtemplates.cs
deleted file mode 100644
index 419001b..0000000
--- a/Antlr3.Test/ST4/TestSubtemplates.cs
+++ /dev/null
@@ -1,217 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace AntlrUnitTests.ST4
-{
-    using Microsoft.VisualStudio.TestTools.UnitTesting;
-    using ST = StringTemplate.Template;
-    using STErrorListener = StringTemplate.ITemplateErrorListener;
-    using STGroup = StringTemplate.TemplateGroup;
-    using STGroupDir = StringTemplate.TemplateGroupDirectory;
-    using STGroupFile = StringTemplate.TemplateGroupFile;
-    using String = System.String;
-    using StringTemplate;
-
-    [TestClass]
-    public class TestSubtemplates : StringTemplateTestBase
-    {
-        [TestMethod]
-        public void TestSimpleIteration()
-        {
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("test"), "<names:{<it>}>!");
-            ST st = group.GetInstanceOf("test");
-            st.Add("names", "Ter");
-            st.Add("names", "Tom");
-            st.Add("names", "Sumana");
-            String expected = "TerTomSumana!";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestSimpleIterationWithArg()
-        {
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("test"), "<names:{n | <n>}>!");
-            ST st = group.GetInstanceOf("test");
-            st.Add("names", "Ter");
-            st.Add("names", "Tom");
-            st.Add("names", "Sumana");
-            String expected = "TerTomSumana!";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void Test_it_NotDefinedWithArg()
-        {
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("test"), "<names:{n | <it>}>!");
-            ST st = group.GetInstanceOf("test");
-            st.Add("names", "Ter");
-            st.Add("names", "Tom");
-            st.Add("names", "Sumana");
-            String expected = "!";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void Test_it_NotDefinedWithArgSingleValue()
-        {
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("test"), "<names:{n | <it>}>!");
-            ST st = group.GetInstanceOf("test");
-            st.Add("names", "Ter");
-            String expected = "!";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestNestedIterationWithArg()
-        {
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("test"), "<users:{u | <u.id:{id | <id>=}><u.name>}>!");
-            ST st = group.GetInstanceOf("test");
-            st.Add("users", new TestCoreBasics.User(1, "parrt"));
-            st.Add("users", new TestCoreBasics.User(2, "tombu"));
-            st.Add("users", new TestCoreBasics.User(3, "sri"));
-            String expected = "1=parrt2=tombu3=sri!";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestParallelAttributeIteration()
-        {
-            ST e = new ST(
-                    "<names,phones,salaries:{n,p,s | <n>@<p>: <s>\n}>"
-                );
-            e.Add("names", "Ter");
-            e.Add("names", "Tom");
-            e.Add("phones", "1");
-            e.Add("phones", "2");
-            e.Add("salaries", "big");
-            e.Add("salaries", "huge");
-            String expecting = "Ter@1: big" + newline + "Tom@2: huge" + newline;
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestParallelAttributeIterationWithNullValue(){
-        ST e = new ST(
-                "<names,phones,salaries:{n,p,s | <n>@<p>: <s>\n}>"
-            );
-        e.Add("names", "Ter");
-        e.Add("names", "Tom");
-        e.Add("names", "Sriram");
-        e.Add("phones", new object[] { "1", null, "3" });
-        e.Add("salaries", "big");
-        e.Add("salaries", "huge");
-        e.Add("salaries", "enormous");
-        String expecting = "Ter@1: big"+newline+
-                           "Tom@: huge"+newline+
-                           "Sriram@3: enormous"+newline;
-        Assert.AreEqual(expecting, e.Render());
-    }
-
-        [TestMethod]
-        public void TestParallelAttributeIterationHasI()
-        {
-            ST e = new ST(
-                    "<names,phones,salaries:{n,p,s | <i0>. <n>@<p>: <s>\n}>"
-                );
-            e.Add("names", "Ter");
-            e.Add("names", "Tom");
-            e.Add("phones", "1");
-            e.Add("phones", "2");
-            e.Add("salaries", "big");
-            e.Add("salaries", "huge");
-            String expecting =
-                "0. Ter@1: big" + newline +
-                "1. Tom@2: huge" + newline;
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestParallelAttributeIterationWithDifferentSizes()
-        {
-            ST e = new ST(
-                    "<names,phones,salaries:{n,p,s | <n>@<p>: <s>}; separator=\", \">"
-                );
-            e.Add("names", "Ter");
-            e.Add("names", "Tom");
-            e.Add("names", "Sriram");
-            e.Add("phones", "1");
-            e.Add("phones", "2");
-            e.Add("salaries", "big");
-            String expecting = "Ter@1: big, Tom@2: , Sriram@: ";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestParallelAttributeIterationWithSingletons()
-        {
-            ST e = new ST(
-                    "<names,phones,salaries:{n,p,s | <n>@<p>: <s>}; separator=\", \">"
-                );
-            e.Add("names", "Ter");
-            e.Add("phones", "1");
-            e.Add("salaries", "big");
-            String expecting = "Ter@1: big";
-            Assert.AreEqual(expecting, e.Render());
-        }
-
-        [TestMethod]
-        public void TestParallelAttributeIterationWithDifferentSizesTemplateRefInsideToo()
-        {
-            String templates =
-                    "page(names,phones,salaries) ::= " + newline +
-                    "	<< <names,phones,salaries:{n,p,s | <value(n)>@<value(p)>: <value(s)>}; separator=\", \"> >>" + newline +
-                    "value(x=\"n/a\") ::= \"<x>\"" + newline;
-            WriteFile(tmpdir, "g.stg", templates);
-
-            STGroup group = new STGroupFile(tmpdir + "/g.stg");
-            ST p = group.GetInstanceOf("page");
-            p.Add("names", "Ter");
-            p.Add("names", "Tom");
-            p.Add("names", "Sriram");
-            p.Add("phones", "1");
-            p.Add("phones", "2");
-            p.Add("salaries", "big");
-            String expecting = "Ter@1: big, Tom@2: n/a, Sriram@n/a: n/a";
-            Assert.AreEqual(expecting, p.Render());
-        }
-    }
-}
diff --git a/Antlr3.Test/ST4/TestSyntaxErrors.cs b/Antlr3.Test/ST4/TestSyntaxErrors.cs
deleted file mode 100644
index b90ba5c..0000000
--- a/Antlr3.Test/ST4/TestSyntaxErrors.cs
+++ /dev/null
@@ -1,186 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace AntlrUnitTests.ST4
-{
-    using Antlr.Runtime;
-    using Microsoft.VisualStudio.TestTools.UnitTesting;
-    using StringTemplate;
-    using StringTemplate.Compiler;
-    using Path = System.IO.Path;
-    using String = System.String;
-
-    [TestClass]
-    public class TestSyntaxErrors : StringTemplateTestBase
-    {
-        [TestMethod]
-        public void TestEmptyExpr()
-        {
-            string template = " <> ";
-            TemplateGroup group = new TemplateGroup();
-            string result = null;
-            try
-            {
-                group.DefineTemplate(new TemplateName("test"), template);
-            }
-            catch (TemplateException se)
-            {
-                RecognitionException re = (RecognitionException)se.InnerException;
-                result = new TemplateSyntaxErrorMessage(ErrorType.SyntaxError, re.Token, re, se.Message).ToString();
-            }
-            string expected = "1:0: this doesn't look like a template: \" <> \"";
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestEmptyExpr2()
-        {
-            String template = "hi <> ";
-            TemplateGroup group = new TemplateGroup();
-            String result = null;
-            try
-            {
-                group.DefineTemplate(new TemplateName("test"), template);
-            }
-            catch (TemplateException se)
-            {
-                RecognitionException re = (RecognitionException)se.InnerException;
-                result = new TemplateSyntaxErrorMessage(ErrorType.SyntaxError, re.Token, re, se.Message).ToString();
-            }
-            String expected = "1:3: doesn't look like an expression";
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestWeirdChar()
-        {
-            string template = "   <*>";
-            TemplateGroup group = new TemplateGroup();
-            string result = null;
-            try
-            {
-                group.DefineTemplate(new TemplateName("test"), template);
-            }
-            catch (TemplateException se)
-            {
-                RecognitionException re = (RecognitionException)se.InnerException;
-                result = new TemplateSyntaxErrorMessage(ErrorType.SyntaxError, re.Token, re, se.Message).ToString();
-            }
-            string expected = "1:4: invalid character: *";
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestValidButOutOfPlaceChar()
-        {
-            String templates =
-                "foo() ::= <<hi <.> mom>>\n";
-            WriteFile(tmpdir, "t.stg", templates);
-
-            ITemplateErrorListener errors = new ErrorBuffer();
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ErrorManager.ErrorListener = errors;
-            group.Load(); // force load
-            String expected = "1:15: doesn't look like an expression" + newline;
-            string result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestValidButOutOfPlaceCharOnDifferentLine()
-        {
-            String templates =
-                    "foo() ::= \"hi <\n" +
-                    ".> mom\"\n";
-            WriteFile(tmpdir, "t.stg", templates);
-
-            ITemplateErrorListener errors = new ErrorBuffer();
-            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ErrorManager.ErrorListener = errors;
-            group.Load(); // force load
-            String expected = "t.stg 1:15: \\n in string, 1:14: doesn't look like an expression" + newline;
-            string result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestErrorInNestedTemplate()
-        {
-            String templates =
-                "foo() ::= \"hi <name:{[<aaa.bb!>]}> mom\"\n";
-            WriteFile(tmpdir, "t.stg", templates);
-
-            TemplateGroup group = null;
-            ITemplateErrorListener errors = new ErrorBuffer();
-            group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ErrorManager.ErrorListener = errors;
-            group.Load(); // force load
-            String expected = "1:29: '!' came as a complete surprise to me" + newline;
-            string result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestEOFInExpr()
-        {
-            String templates =
-                "foo() ::= \"hi <name:{[<aaa.bb>]}\"\n";
-            WriteFile(tmpdir, "t.stg", templates);
-
-            TemplateGroup group = null;
-            var errors = new ErrorBuffer();
-            group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ErrorManager.ErrorListener = errors;
-            group.Load(); // force load
-            String expected = "1:32: premature EOF" + newline;
-            String result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestMissingRPAREN()
-        {
-            String templates =
-                "foo() ::= \"hi <foo(>\"\n";
-            WriteFile(tmpdir, "t.stg", templates);
-
-            TemplateGroup group = null;
-            var errors = new ErrorBuffer();
-            group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ErrorManager.ErrorListener = errors;
-            group.Load(); // force load
-            String expected = "1:19: mismatched input '>' expecting RPAREN" + newline;
-            String result = errors.ToString();
-            Assert.AreEqual(expected, result);
-        }
-    }
-}
diff --git a/Antlr3.Test/ST4/TestWhitespace.cs b/Antlr3.Test/ST4/TestWhitespace.cs
deleted file mode 100644
index 91d24f7..0000000
--- a/Antlr3.Test/ST4/TestWhitespace.cs
+++ /dev/null
@@ -1,325 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace AntlrUnitTests.ST4
-{
-    using Microsoft.VisualStudio.TestTools.UnitTesting;
-    using StringTemplate;
-    using ST = StringTemplate.Template;
-    using STErrorListener = StringTemplate.ITemplateErrorListener;
-    using STGroup = StringTemplate.TemplateGroup;
-    using String = System.String;
-    using StringWriter = System.IO.StringWriter;
-
-    [TestClass]
-    public class TestWhitespace : StringTemplateTestBase
-    {
-        [TestMethod]
-        public void TestTrimmedSubtemplates()
-        {
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("test"), "<names:{n | <n>}>!");
-            ST st = group.GetInstanceOf("test");
-            st.Add("names", "Ter");
-            st.Add("names", "Tom");
-            st.Add("names", "Sumana");
-            String expected = "TerTomSumana!";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestTrimJustOneWSInSubtemplates()
-        {
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("test"), "<names:{n |  <n> }>!");
-            ST st = group.GetInstanceOf("test");
-            st.Add("names", "Ter");
-            st.Add("names", "Tom");
-            st.Add("names", "Sumana");
-            String expected = " Ter  Tom  Sumana !";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestTrimNewlineInSubtemplates()
-        {
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("test"), "<names:{n |\n" +
-                                         "<n>}>!");
-            ST st = group.GetInstanceOf("test");
-            st.Add("names", "Ter");
-            st.Add("names", "Tom");
-            st.Add("names", "Sumana");
-            String expected = "TerTomSumana!";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestLeaveNewlineOnEndInSubtemplates()
-        {
-            STGroup group = new STGroup();
-            group.DefineTemplate(new TemplateName("test"), "<names:{n |\n" +
-                                         "<n>\n" +
-                                         "}>!");
-            ST st = group.GetInstanceOf("test");
-            st.Add("names", "Ter");
-            st.Add("names", "Tom");
-            st.Add("names", "Sumana");
-            String expected = "Ter" + newline + "Tom" + newline + "Sumana" + newline + "!";
-            String result = st.Render();
-            Assert.AreEqual(expected, result);
-        }
-
-        [TestMethod]
-        public void TestEmptyExprAsFirstLineGetsNoOutput()
-        {
-            ST t = new ST(
-                "<users>\n" +
-                "end\n");
-            String expecting = "end" + newline;
-            String result = t.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestEmptyLineWithIndent()
-        {
-            ST t = new ST(
-                "begin\n" +
-                "    \n" +
-                "end\n");
-            String expecting = "begin" + newline + newline + "end" + newline;
-            String result = t.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestSizeZeroOnLineByItselfGetsNoOutput()
-        {
-            ST t = new ST(
-                "begin\n" +
-                "<name>\n" +
-                "<users>\n" +
-                "<users>\n" +
-                "end\n");
-            String expecting = "begin" + newline + "end" + newline;
-            String result = t.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestSizeZeroOnLineWithIndentGetsNoOutput()
-        {
-            ST t = new ST(
-                "begin\n" +
-                "  <name>\n" +
-                "	<users>\n" +
-                "	<users>\n" +
-                "end\n");
-            String expecting = "begin" + newline + "end" + newline;
-            String result = t.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestSizeZeroOnLineWithMultipleExpr()
-        {
-            ST t = new ST(
-                "begin\n" +
-                "  <name>\n" +
-                "	<users><users>\n" +
-                "end\n");
-            String expecting = "begin" + newline + "end" + newline;
-            String result = t.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestIFExpr()
-        {
-            ST t = new ST(
-                "begin\n" +
-                "<if(x)><endif>\n" +
-                "end\n");
-            String expecting = "begin"+newline+"end"+newline;
-            String result = t.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestIndentedIFExpr()
-        {
-            ST t = new ST(
-                "begin\n" +
-                "    <if(x)><endif>\n" +
-                "end\n");
-            String expecting = "begin" + newline + "end" + newline;
-            String result = t.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestIFElseExpr()
-        {
-            ST t = new ST(
-                "begin\n" +
-                "<if(users)><else><endif>\n" +
-                "end\n");
-            String expecting = "begin" + newline + "end" + newline;
-            String result = t.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestIFOnMultipleLines()
-        {
-            ST t = new ST(
-                "begin\n" +
-                "<if(users)>\n" +
-                "foo\n" +
-                "<else>\n" +
-                "bar\n" +
-                "<endif>\n" +
-                "end\n");
-            String expecting = "begin"+newline+"bar"+newline+"end"+newline;
-            String result = t.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestNestedIFOnMultipleLines()
-        {
-            ST t = new ST(
-                "begin\n" +
-                "<if(x)>\n" +
-                "<if(y)>\n" +
-                "foo\n" +
-                "<else>\n" +
-                "bar\n" +
-                "<endif>\n" +
-                "<endif>\n" +
-                "end\n");
-            t.Add("x", "x");
-            String expecting = "begin"+newline+"bar"+newline+"end"+newline;
-            String result = t.Render();
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestLineBreak()
-        {
-            ST st = new ST(
-                    "Foo <\\\\>" + newline +
-                    "  \t  bar" + newline
-                    );
-            StringWriter sw = new StringWriter();
-            st.Write(new AutoIndentWriter(sw, "\n")); // force \n as newline
-            String result = sw.ToString();
-            String expecting = "Foo bar\n";     // expect \n in output
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestLineBreak2()
-        {
-            ST st = new ST(
-                    "Foo <\\\\>       " + newline +
-                    "  \t  bar" + newline
-                    );
-            StringWriter sw = new StringWriter();
-            st.Write(new AutoIndentWriter(sw, "\n")); // force \n as newline
-            String result = sw.ToString();
-            String expecting = "Foo bar\n";
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestLineBreakNoWhiteSpace()
-        {
-            ST st = new ST(
-                    "Foo <\\\\>" + newline +
-                    "bar\n"
-                    );
-            StringWriter sw = new StringWriter();
-            st.Write(new AutoIndentWriter(sw, "\n")); // force \n as newline
-            String result = sw.ToString();
-            String expecting = "Foo bar\n";
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestNewlineNormalizationInTemplateString()
-        {
-            ST st = new ST(
-                    "Foo\r\n" +
-                    "Bar\n"
-                    );
-            StringWriter sw = new StringWriter();
-            st.Write(new AutoIndentWriter(sw, "\n")); // force \n as newline
-            String result = sw.ToString();
-            String expecting = "Foo\nBar\n";     // expect \n in output
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestNewlineNormalizationInTemplateStringPC()
-        {
-            ST st = new ST(
-                    "Foo\r\n" +
-                    "Bar\n"
-                    );
-            StringWriter sw = new StringWriter();
-            st.Write(new AutoIndentWriter(sw, "\r\n")); // force \r\n as newline
-            String result = sw.ToString();
-            String expecting = "Foo\r\nBar\r\n";     // expect \r\n in output
-            Assert.AreEqual(expecting, result);
-        }
-
-        [TestMethod]
-        public void TestNewlineNormalizationInAttribute()
-        {
-            ST st = new ST(
-                    "Foo\r\n" +
-                    "<name>\n"
-                    );
-            st.Add("name", "a\nb\r\nc");
-            StringWriter sw = new StringWriter();
-            st.Write(new AutoIndentWriter(sw, "\n")); // force \n as newline
-            String result = sw.ToString();
-            String expecting = "Foo\na\nb\nc\n";     // expect \n in output
-            Assert.AreEqual(expecting, result);
-        }
-    }
-}
diff --git a/StringTemplate4/AutoIndentWriter.cs b/StringTemplate4/AutoIndentWriter.cs
deleted file mode 100644
index 9a562b8..0000000
--- a/StringTemplate4/AutoIndentWriter.cs
+++ /dev/null
@@ -1,286 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate
-{
-    using System.Collections.Generic;
-    using Array = System.Array;
-    using Environment = System.Environment;
-    using StringBuilder = System.Text.StringBuilder;
-    using TextWriter = System.IO.TextWriter;
-    using InvalidOperationException = System.InvalidOperationException;
-    using ArgumentNullException = System.ArgumentNullException;
-
-    public class AutoIndentWriter : ITemplateWriter
-    {
-        public static readonly int NoWrap = -1;
-
-        /** stack of indents; use List as it's much faster than Stack. Grows
-         *  from 0..n-1.
-         */
-        protected readonly IList<string> indents = new List<string>();
-
-        /** Stack of integer anchors (char positions in line); avoid Integer
-         *  creation overhead.
-         */
-        protected int[] anchors = new int[10];
-        protected int anchors_sp = -1;
-
-        /** \n or \r\n? */
-        protected readonly string newline;
-
-        protected readonly TextWriter @out = null;
-        protected bool atStartOfLine = true;
-
-        /** Track char position in the line (later we can think about tabs).
-         *  Indexed from 0.  We want to keep charPosition &lt;= lineWidth.
-         *  This is the position we are *about* to write not the position
-         *  last written to.
-         */
-        protected int charPosition = 0;
-
-        /// <summary>
-        /// The absolute char index into the output of the next char to be written.
-        /// </summary>
-        protected int charIndex = 0;
-
-        protected int lineWidth = NoWrap;
-
-        protected int charPositionOfStartOfExpr = 0;
-
-        public AutoIndentWriter(TextWriter @out, string newline)
-        {
-            if (@out == null)
-                throw new ArgumentNullException("out");
-
-            this.@out = @out;
-            indents.Add(null); // s oftart with no indent
-            this.newline = newline ?? Environment.NewLine;
-        }
-
-        public AutoIndentWriter(TextWriter @out)
-            : this(@out, Environment.NewLine)
-        {
-        }
-
-        public int Index
-        {
-            get
-            {
-                return charIndex;
-            }
-        }
-
-        public virtual void SetLineWidth(int lineWidth)
-        {
-            this.lineWidth = lineWidth;
-        }
-
-        public virtual void PushIndentation(string indent)
-        {
-            indents.Add(indent);
-        }
-
-        public virtual string PopIndentation()
-        {
-            if (indents.Count == 0)
-                throw new InvalidOperationException();
-
-            var result = indents[indents.Count - 1];
-            indents.RemoveAt(indents.Count - 1);
-            return result;
-        }
-
-        public virtual void PushAnchorPoint()
-        {
-            if ((anchors_sp + 1) >= anchors.Length)
-            {
-                Array.Resize(ref anchors, anchors.Length * 2);
-            }
-            anchors_sp++;
-            anchors[anchors_sp] = charPosition;
-        }
-
-        public virtual void PopAnchorPoint()
-        {
-            if (anchors_sp == -1)
-                throw new InvalidOperationException();
-
-            anchors_sp--;
-        }
-
-        public virtual int GetIndentationWidth()
-        {
-            int n = 0;
-            for (int i = 0; i < indents.Count; i++)
-            {
-                string ind = indents[i];
-                if (ind != null)
-                {
-                    n += ind.Length;
-                }
-            }
-            return n;
-        }
-
-        /** Write out a string literal or attribute expression or expression element.*/
-        public virtual int Write(string str)
-        {
-            if (str == null)
-                return 0;
-
-            int n = 0;
-            for (int i = 0; i < str.Length; i++)
-            {
-                char c = str[i];
-                // found \n or \r\n newline?
-                if (c == '\r')
-                    continue;
-
-                if (c == '\n')
-                {
-                    atStartOfLine = true;
-                    charPosition = -1; // set so the write below sets to 0
-                    @out.Write(newline);
-                    n += newline.Length;
-                    charIndex += newline.Length;
-                    charPosition += n; // wrote n more char
-                    continue;
-                }
-                // normal character
-                // check to see if we are at the start of a line; need indent if so
-                if (atStartOfLine)
-                {
-                    n += Indent();
-                    atStartOfLine = false;
-                }
-                n++;
-                @out.Write(c);
-                charPosition++;
-                charIndex++;
-            }
-            return n;
-        }
-
-        public virtual int WriteSeparator(string str)
-        {
-            return Write(str);
-        }
-
-        /** Write out a string literal or attribute expression or expression element.
-         *
-         *  If doing line wrap, then check wrap before emitting this str.  If
-         *  at or beyond desired line width then emit a \n and any indentation
-         *  before spitting out this str.
-         */
-        public virtual int Write(string str, string wrap)
-        {
-            int n = WriteWrap(wrap);
-            return n + Write(str);
-        }
-
-        public virtual int WriteWrap(string wrap)
-        {
-            int n = 0;
-            // if want wrap and not already at start of line (last char was \n)
-            // and we have hit or exceeded the threshold
-            if (lineWidth != NoWrap && wrap != null && !atStartOfLine &&
-                 charPosition >= lineWidth)
-            {
-                // ok to wrap
-                // Walk wrap string and look for A\nB.  Spit out A\n
-                // then spit indent or anchor, whichever is larger
-                // then spit out B.
-                for (int i = 0; i < wrap.Length; i++)
-                {
-                    char c = wrap[i];
-                    if (c == '\n')
-                    {
-                        @out.Write(newline);
-                        n += newline.Length;
-                        charPosition = 0;
-                        charIndex += newline.Length;
-                        n += Indent();
-                        // continue writing any chars out
-                    }
-                    else
-                    {  // write A or B part
-                        n++;
-                        @out.Write(c);
-                        charPosition++;
-                        charIndex++;
-                    }
-                }
-            }
-            return n;
-        }
-
-        public virtual int Indent()
-        {
-            int n = 0;
-            for (int i = 0; i < indents.Count; i++)
-            {
-                string ind = indents[i];
-                if (ind != null)
-                {
-                    n += ind.Length;
-                    @out.Write(ind);
-                }
-            }
-
-            // If current anchor is beyond current indent width, indent to anchor
-            // *after* doing indents (might tabs in there or whatever)
-            int indentWidth = n;
-            if (anchors_sp >= 0 && anchors[anchors_sp] > indentWidth)
-            {
-                int remainder = anchors[anchors_sp] - indentWidth;
-                for (int i = 1; i <= remainder; i++)
-                    @out.Write(' ');
-                n += remainder;
-            }
-
-            charPosition += n;
-            charIndex += n;
-            return n;
-        }
-
-        protected virtual StringBuilder GetIndentString(int spaces)
-        {
-            StringBuilder buf = new StringBuilder();
-            for (int i = 1; i <= spaces; i++)
-            {
-                buf.Append(' ');
-            }
-            return buf;
-        }
-    }
-}
diff --git a/StringTemplate4/BlankTemplate.cs b/StringTemplate4/BlankTemplate.cs
deleted file mode 100644
index ff2dbd0..0000000
--- a/StringTemplate4/BlankTemplate.cs
+++ /dev/null
@@ -1,89 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate
-{
-    using StringTemplate.Compiler;
-    using StringTemplate.Debug;
-    using CultureInfo = System.Globalization.CultureInfo;
-
-    public class BlankTemplate : DebugTemplate
-    {
-        // derive from DebugTemplate not just Template in case we're debugging
-
-        public BlankTemplate()
-        {
-            code = new CompiledTemplate();
-        }
-
-        public BlankTemplate(string template)
-            : this()
-        {
-        }
-
-        public override TemplateName Name
-        {
-            get
-            {
-                return new TemplateName("blank");
-            }
-        }
-
-        public override void Add(string name, object value)
-        {
-        }
-
-        protected internal override void RawSetAttribute(string name, object value)
-        {
-        }
-
-        public override object GetAttribute(string name)
-        {
-            return null;
-        }
-
-        public override string GetEnclosingInstanceStackString()
-        {
-            return null;
-        }
-
-        public override int Write(ITemplateWriter @out)
-        {
-            return 0;
-        }
-
-        public override string Render(CultureInfo culture, int lineWidth)
-        {
-            return string.Empty;
-        }
-    }
-}
diff --git a/StringTemplate4/Compiler/Bytecode.cs b/StringTemplate4/Compiler/Bytecode.cs
deleted file mode 100644
index ed3d2a6..0000000
--- a/StringTemplate4/Compiler/Bytecode.cs
+++ /dev/null
@@ -1,174 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate.Compiler
-{
-    public class Bytecode
-    {
-        public const int MaxOperands = 3;
-        public const int OPND_SIZE_IN_BYTES = 2;
-        public const int STRING = 1;
-        public const int ADDR = 2;
-        public const int INT = 3;
-
-        public class Instruction
-        {
-            internal string name; // E.g., "load_str", "new"
-            internal int[] type = new int[MaxOperands];
-            internal int n = 0;
-
-            public Instruction(string name)
-                : this(name, 0, 0, 0)
-            {
-                n = 0;
-            }
-
-            public Instruction(string name, int a)
-                : this(name, a, 0, 0)
-            {
-                n = 1;
-            }
-
-            public Instruction(string name, int a, int b)
-                : this(name, a, b, 0)
-            {
-                n = 2;
-            }
-
-            public Instruction(string name, int a, int b, int c)
-            {
-                this.name = name;
-                type[0] = a;
-                type[1] = b;
-                type[2] = c;
-                n = 3;
-            }
-        }
-
-        // TODO: try an enum here
-
-        // INSTRUCTION BYTECODES (byte is signed; use a short to keep 0..255)
-        public const short INSTR_LOAD_STR = 1;
-        public const short INSTR_LOAD_ATTR = 2;
-        public const short INSTR_LOAD_LOCAL = 3; // load stuff like it, i, i0
-        public const short INSTR_LOAD_PROP = 4;
-        public const short INSTR_LOAD_PROP_IND = 5;
-        public const short INSTR_STORE_ATTR = 6;
-        public const short INSTR_STORE_SOLE_ARG = 7;
-        public const short INSTR_SET_PASS_THRU = 8;
-        public const short INSTR_STORE_OPTION = 9;
-        public const short INSTR_NEW = 10;  // create new template instance
-        public const short INSTR_NEW_IND = 11;  // create new template instance using value on stack
-        public const short INSTR_SUPER_NEW = 12;  // create new template instance using value on stack
-        public const short INSTR_WRITE = 13;
-        public const short INSTR_WRITE_OPT = 14;
-        public const short INSTR_MAP = 15;  // <a:b()>, <a:b():c()>, <a:{...}>
-        public const short INSTR_ROT_MAP = 16;  // <a:b(),c()>
-        public const short INSTR_PAR_MAP = 17;  // <names,phones:{n,p | ...}>
-        public const short INSTR_BR = 18;
-        public const short INSTR_BRF = 19;
-        public const short INSTR_OPTIONS = 20;  // push options block
-        public const short INSTR_LIST = 21;
-        public const short INSTR_ADD = 22;
-        public const short INSTR_TOSTR = 23;
-        // Predefined functions
-        public const short INSTR_FIRST = 24;
-        public const short INSTR_LAST = 25;
-        public const short INSTR_REST = 26;
-        public const short INSTR_TRUNC = 27;
-        public const short INSTR_STRIP = 28;
-        public const short INSTR_TRIM = 29;
-        public const short INSTR_LENGTH = 30;
-        public const short INSTR_STRLEN = 31;
-        public const short INSTR_REVERSE = 32;
-
-        public const short INSTR_NOT = 33;
-        public const short INSTR_OR = 34;
-        public const short INSTR_AND = 35;
-
-        public const short INSTR_INDENT = 36;
-        public const short INSTR_DEDENT = 37;
-        public const short INSTR_NEWLINE = 38;
-
-        public const short INSTR_NOOP = 39; // do nothing
-        public const short INSTR_POP = 40;
-
-        /** Used for assembly/disassembly; describes instruction set */
-        // START: instr
-        public static Instruction[] instructions =
-            new Instruction[]
-            {
-                null, // <INVALID>
-                new Instruction("load_str",STRING), // index is the opcode
-                new Instruction("load_attr",STRING),
-                new Instruction("load_local",STRING),
-                new Instruction("load_prop",STRING),
-                new Instruction("load_prop_ind"),
-                new Instruction("store_attr",STRING),
-                new Instruction("store_sole_arg"),
-                new Instruction("set_pass_thru"),
-                new Instruction("store_option",INT),
-                new Instruction("new",STRING),
-                new Instruction("new_ind"),
-                new Instruction("super_new",STRING),
-                new Instruction("write"),
-                new Instruction("write_opt"),
-                new Instruction("map"),
-                new Instruction("rot_map", INT),
-                new Instruction("par_map", INT),
-                new Instruction("br", ADDR),
-                new Instruction("brf", ADDR),
-                new Instruction("options"),
-                new Instruction("list"),
-                new Instruction("add"),
-                new Instruction("tostr"),
-                new Instruction("first"),
-                new Instruction("last"),
-                new Instruction("rest"),
-                new Instruction("trunc"),
-                new Instruction("strip"),
-                new Instruction("trim"),
-                new Instruction("length"),
-                new Instruction("strlen"),
-                new Instruction("reverse"),
-                new Instruction("not"),
-                new Instruction("or"),
-                new Instruction("and"),
-                new Instruction("indent", STRING),
-                new Instruction("dedent"),
-                new Instruction("newline"),
-                new Instruction("noop"),
-                new Instruction("pop")
-            };
-        // END: instr
-    }
-}
diff --git a/StringTemplate4/Compiler/BytecodeDisassembler.cs b/StringTemplate4/Compiler/BytecodeDisassembler.cs
deleted file mode 100644
index 7b683c7..0000000
--- a/StringTemplate4/Compiler/BytecodeDisassembler.cs
+++ /dev/null
@@ -1,225 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate.Compiler
-{
-    using System.Collections.Generic;
-    using ArgumentException = System.ArgumentException;
-    using ArgumentNullException = System.ArgumentNullException;
-    using ArgumentOutOfRangeException = System.ArgumentOutOfRangeException;
-    using StringBuilder = System.Text.StringBuilder;
-
-    public class BytecodeDisassembler
-    {
-        // TODO: make disassembler point at compiledST code?
-        CompiledTemplate code;
-#if false
-        private readonly byte[] code;
-        private readonly int codeSize;
-        private readonly string[] strings;
-        private readonly Interval[] sourceMap;
-#endif
-
-        public BytecodeDisassembler(CompiledTemplate code)
-        {
-            if (code == null)
-                throw new ArgumentNullException("code");
-
-            this.code = code;
-        }
-
-        public virtual string Instructions()
-        {
-            StringBuilder buf = new StringBuilder();
-            int ip = 0;
-            while (ip < code.codeSize)
-            {
-                if (ip > 0)
-                    buf.Append(", ");
-                int opcode = code.instrs[ip];
-                Bytecode.Instruction I = Bytecode.instructions[opcode];
-                buf.Append(I.name);
-                ip++;
-                for (int opnd = 0; opnd < I.n; opnd++)
-                {
-                    buf.Append(' ');
-                    buf.Append(GetShort(code.instrs, ip));
-                    ip += Bytecode.OPND_SIZE_IN_BYTES;
-                }
-            }
-            return buf.ToString();
-        }
-
-        public virtual string Disassemble()
-        {
-            StringBuilder buf = new StringBuilder();
-            int i = 0;
-            while (i < code.codeSize)
-            {
-                i = DisassembleInstruction(buf, i);
-                buf.Append('\n');
-            }
-            return buf.ToString();
-        }
-
-        public virtual int DisassembleInstruction(StringBuilder buf, int ip)
-        {
-            if (buf == null)
-                throw new ArgumentNullException("buf");
-            if (ip < 0)
-                throw new ArgumentOutOfRangeException("ip");
-
-            int opcode = code.instrs[ip];
-            if (ip >= code.codeSize)
-            {
-                throw new ArgumentException("ip out of range: " + ip);
-            }
-            Bytecode.Instruction I =
-                Bytecode.instructions[opcode];
-            if (I == null)
-            {
-                throw new ArgumentException("no such instruction " + opcode +
-                    " at address " + ip);
-            }
-            string instrName = I.name;
-            buf.Append(string.Format("{0:0000}:\t{1}", ip, instrName));
-            ip++;
-            if (I.n == 0)
-            {
-                buf.Append("  ");
-                return ip;
-            }
-            List<string> operands = new List<string>();
-            for (int i = 0; i < I.n; i++)
-            {
-                int opnd = GetShort(code.instrs, ip);
-                ip += Bytecode.OPND_SIZE_IN_BYTES;
-                switch (I.type[i])
-                {
-                case Bytecode.STRING:
-                    operands.Add(ShowConstPoolOperand(opnd));
-                    break;
-                case Bytecode.ADDR:
-                case Bytecode.INT:
-                    operands.Add(opnd.ToString());
-                    break;
-                default:
-                    operands.Add(opnd.ToString());
-                    break;
-                }
-            }
-            for (int i = 0; i < operands.Count; i++)
-            {
-                string s = operands[i];
-                if (i > 0)
-                    buf.Append(", ");
-                buf.Append(s);
-            }
-            return ip;
-        }
-
-        private string ShowConstPoolOperand(int poolIndex)
-        {
-            StringBuilder buf = new StringBuilder();
-            buf.Append("#");
-            buf.Append(poolIndex);
-            string s = "<bad string index>";
-            if (poolIndex > 0 && poolIndex < code.strings.Length)
-            {
-                if (code.strings[poolIndex] == null)
-                    s = "null";
-                else
-                {
-                    s = code.strings[poolIndex].ToString();
-                    if (code.strings[poolIndex] is string)
-                    {
-                        s = Misc.ReplaceEscapes(s);
-                        s = '"' + s + '"';
-                    }
-                }
-            }
-            buf.Append(":");
-            buf.Append(s);
-            return buf.ToString();
-        }
-
-        public static int GetShort(byte[] memory, int index)
-        {
-            if (memory == null)
-                throw new ArgumentNullException("memory");
-            if (index < 0)
-                throw new ArgumentOutOfRangeException("index");
-            if (index + 1 >= memory.Length)
-                throw new ArgumentException();
-
-            int b1 = memory[index++] & 0xFF; // mask off sign-extended bits
-            int b2 = memory[index++] & 0xFF;
-            int word = b1 << (8 * 1) | b2;
-            return word;
-        }
-
-        public virtual string Strings()
-        {
-            StringBuilder buf = new StringBuilder();
-            int addr = 0;
-            foreach (object o in code.strings)
-            {
-                if (o is string)
-                {
-                    string s = (string)o;
-                    s = Misc.ReplaceEscapes(s);
-                    buf.Append(string.Format("{0:0000}: \"{1}\"\n", addr, s));
-                }
-                else
-                {
-                    buf.Append(string.Format("{0:0000}: {1}\n", addr, o));
-                }
-                addr++;
-            }
-            return buf.ToString();
-        }
-
-        public string SourceMap()
-        {
-            StringBuilder buf = new StringBuilder();
-            int addr = 0;
-            foreach (Interval i in code.sourceMap)
-            {
-                string chunk = code.template.Substring(i.A, i.B + 1);
-                buf.Append(string.Format("{0:0000}: {1}\t\"{2}\"\n", addr, i, chunk));
-            }
-            addr++;
-
-            return buf.ToString();
-        }
-    }
-}
diff --git a/StringTemplate4/Compiler/CompiledTemplate.cs b/StringTemplate4/Compiler/CompiledTemplate.cs
deleted file mode 100644
index df5b936..0000000
--- a/StringTemplate4/Compiler/CompiledTemplate.cs
+++ /dev/null
@@ -1,131 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate.Compiler
-{
-    using System.Collections.Generic;
-    using System.Diagnostics;
-    using Console = System.Console;
-    using StringBuilder = System.Text.StringBuilder;
-
-    public class CompiledTemplate
-    {
-        /** The original, immutable pattern (not really used again after
-         *  initial "compilation"). Useful for debugging.
-         */
-        public string template;
-
-        // for subtemplates:
-        public int embeddedStart = -1;
-        public int embeddedStop = -1;
-
-        protected internal IDictionary<string, FormalArgument> formalArguments = FormalArgument.Unknown;
-
-        protected internal List<CompiledTemplate> implicitlyDefinedTemplates;
-
-        /** The group that holds this ST definition.  We use it to initiate
-         *  interpretation via ST.toString().  From there, it becomes field 'group'
-         *  in interpreter and is fixed until rendering completes.
-         */
-        public TemplateGroup nativeGroup = TemplateGroup.defaultGroup;
-
-        /** Does this template come from a <@region>...<@end> embedded in
-         *  another template?
-         */
-        protected internal bool isRegion;
-
-        /** If someone refs <@r()> in template t, an implicit
-         *
-         *   @t.r() ::= ""
-         *
-         *  is defined, but you can overwrite this def by defining your
-         *  own.  We need to prevent more than one manual def though.  Between
-         *  this var and isEmbeddedRegion we can determine these cases.
-         */
-        protected internal Template.RegionType regionDefType;
-
-        public string[] strings;
-        public byte[] instrs;        // byte-addressable code memory.
-        public int codeSize;
-        public Interval[] sourceMap; // maps IP to range in template pattern
-
-        [DebuggerHidden]
-        public string Disassembly
-        {
-            get
-            {
-                BytecodeDisassembler dis = new BytecodeDisassembler(this);
-                StringBuilder buffer = new StringBuilder();
-                buffer.AppendLine(dis.Disassemble());
-                buffer.AppendLine("Strings:");
-                buffer.AppendLine(dis.Strings());
-                buffer.AppendLine("Bytecode to template map:");
-                buffer.AppendLine(dis.SourceMap());
-                return buffer.ToString();
-            }
-        }
-
-        public TemplateName Name
-        {
-            get;
-            internal set;
-        }
-
-        public string Template
-        {
-            get
-            {
-                return template;
-            }
-        }
-
-        public bool IsSubtemplate
-        {
-            get;
-            set;
-        }
-
-        public virtual string Instructions()
-        {
-            var disassembler = new BytecodeDisassembler(this);
-            return disassembler.Instructions();
-        }
-
-        public virtual void Dump()
-        {
-            var disassembler = new BytecodeDisassembler(this);
-            Console.WriteLine(disassembler.Disassemble());
-            Console.WriteLine("Strings:");
-            Console.WriteLine(disassembler.Strings());
-        }
-    }
-}
diff --git a/StringTemplate4/Compiler/FormalArgument.cs b/StringTemplate4/Compiler/FormalArgument.cs
deleted file mode 100644
index 9203816..0000000
--- a/StringTemplate4/Compiler/FormalArgument.cs
+++ /dev/null
@@ -1,131 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate.Compiler
-{
-    using Antlr.Runtime;
-    using System.Collections.Generic;
-
-    public class FormalArgument
-    {
-        // the following represent bit positions emulating a cardinality bitset.
-#if false
-        public static readonly int OPTIONAL = 1;     // a?
-        public static readonly int REQUIRED = 2;     // a
-        public static readonly int ZERO_OR_MORE = 4; // a*
-        public static readonly int ONE_OR_MORE = 8;  // a+
-
-        public static readonly string[] suffixes = {
-        null,
-        "?",
-        "",
-        null,
-        "*",
-        null,
-        null,
-        null,
-        "+"
-    };
-        //protected int cardinality = REQUIRED;
-#endif
-
-        /** When template arguments are not available such as when the user
-         *  uses "new ST(...)", then the list of formal arguments
-         *  must be distinguished from the case where a template can specify
-         *  args and there just aren't any such as the t() template above.
-         */
-        public static readonly IDictionary<string, FormalArgument> Unknown = new Dictionary<string, FormalArgument>();
-
-        public string name;
-
-        /** If they specified name="value", store the template here */
-        public IToken defaultValueToken;
-        public CompiledTemplate compiledDefaultValue;
-
-        public FormalArgument(string name)
-        {
-            this.name = name;
-        }
-
-        public FormalArgument(string name, IToken defaultValueToken)
-        {
-            this.name = name;
-            this.defaultValueToken = defaultValueToken;
-        }
-
-        /*
-        public static String getCardinalityName(int cardinality) {
-            switch (cardinality) {
-                case OPTIONAL : return "optional";
-                case REQUIRED : return "exactly one";
-                case ZERO_OR_MORE : return "zero-or-more";
-                case ONE_OR_MORE : return "one-or-more";
-                default : return "unknown";
-            }
-        }
-        */
-
-        public override int GetHashCode()
-        {
-            return name.GetHashCode() + defaultValueToken.GetHashCode();
-        }
-
-        public override bool Equals(object o)
-        {
-            if (o == null || !(o is FormalArgument))
-            {
-                return false;
-            }
-            FormalArgument other = (FormalArgument)o;
-            if (!this.name.Equals(other.name))
-            {
-                return false;
-            }
-            // only check if there is a default value; that's all
-            if ((this.defaultValueToken != null && other.defaultValueToken == null) ||
-                 (this.defaultValueToken == null && other.defaultValueToken != null))
-            {
-                return false;
-            }
-            return true;
-        }
-
-        public override string ToString()
-        {
-            if (defaultValueToken != null)
-            {
-                return name + "=" + defaultValueToken.Text;
-            }
-            return name;
-        }
-    }
-}
diff --git a/StringTemplate4/Compiler/Group.g3 b/StringTemplate4/Compiler/Group.g3
deleted file mode 100644
index 3635fc3..0000000
--- a/StringTemplate4/Compiler/Group.g3
+++ /dev/null
@@ -1,247 +0,0 @@
-﻿/*
- [The "BSD licence"]
- Copyright (c) 2003-2009 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-grammar Group;
-
-options {
-	language=CSharp3;
-}
-
-@lexer::namespace{StringTemplate.Compiler}
-@parser::namespace{StringTemplate.Compiler}
-
-@header
-{
-using Console = System.Console;
-}
-
-public
-group[TemplateGroup group, TemplateName prefix]
-@init {
-GroupLexer lexer = (GroupLexer)input.TokenSource;
-this._group = lexer._group = $group;
-}
-	:	def[prefix]+
-    ;
-
-/** Match template and dictionary defs outside of (...)+ loop in group.
- *  The key is catching while still in the loop; must keep prediction of
- *  elements separate from "stay in loop" prediction.
- */
-def[TemplateName prefix]
-	:	templateDef[prefix]
-	|	dictDef
-	;
-catch[RecognitionException re]
-{
-	// kill at least current token; it's garbage.
-	// pretend we already saw an error here
-	state.lastErrorIndex = input.Index;
-	Error("garbled template definition starting at '" + input.LT(1).Text + "'");
-}
-
-public
-templateDef[TemplateName prefix]
-@init {
-    string template=null;
-    TemplateName fullName = null;
-    int n=0; // num char to strip from left, right of template def
-}
-	:	(	'@' enclosing=ID '.' region=ID '(' ')'
-			{fullName = TemplateGroup.GetMangledRegionName(new TemplateName($enclosing.text), $region.text);}
-		|	name=ID '(' formalArgs? ')' {fullName = new TemplateName($name.text);}
-		)
-		'::='
-		{IToken templateToken = input.LT(1);}
-		(	STRING     {template=$STRING.text; n=1;}
-		|	BIGSTRING  {template=$BIGSTRING.text; n=2;}
-		|	{
-			template = "";
-			string msg = "missing template at '" + input.LT(1).Text + "'";
-			NoViableAltException e = new NoViableAltException("", 0, 0, input);
-			ErrorManager.SyntaxError(ErrorType.SyntaxError, e, msg, SourceName);
-			}
-		)
-		{
-		template = Misc.Strip(template, n);
-		bool removedNewline = false;
-		if (templateToken.Type == BIGSTRING && template[0] == '\n')
-		{
-			removedNewline = true;
-			template = Misc.TrimOneStartingNewline(template);
-		}
-	    try {
-			if ($enclosing != null)
-				this._group.DefineRegion(prefix, new TemplateName($enclosing.text), $region, template);
-			else
-				this._group.DefineTemplate(prefix, $name, $formalArgs.args, template);
-		}
-		catch (TemplateException e)
-		{
-			RecognitionException re = (RecognitionException)e.InnerException;
-			if (removedNewline)
-			{
-				re.Line += templateToken.Line;
-			}
-			else
-			{
-				re.Token.CharPositionInLine = re.CharPositionInLine + templateToken.CharPositionInLine + n;
-				re.Token.Line = re.Line + templateToken.Line - 1;
-			}
-			ErrorManager.SyntaxError(ErrorType.SyntaxError, re, e.Message);
-		}
-	    }
-	|   alias=ID '::=' target=ID	{this._group.DefineTemplateAlias($alias, $target);}
-	;
-
-formalArgs returns[IDictionary<string,FormalArgument> args]
-@init {$args = new Dictionary<string,FormalArgument>();}
-    :	formalArg[$args] ( ',' formalArg[$args] )*
-	;
-
-formalArg[IDictionary<string,FormalArgument> args]
-	:	ID
-		(	'=' a=STRING
-		|	'=' a=ANONYMOUS_TEMPLATE
-		)?
-		{$args[$ID.text] = new FormalArgument($ID.text, $a);}
-    ;
-
-/*
-suffix returns [int cardinality=FormalArgument.REQUIRED]
-    :   OPTIONAL
-    |   STAR
-    |   PLUS
-	|
-    ;
-    */
-
-dictDef
-	:	ID '::=' dict
-        {
-        if ( this._group.dictionaries.ContainsKey($ID.text) ) {
-            ErrorManager.CompileTimeError(ErrorType.MapRedefinition, $ID);
-        }
-        else if ( this._group.templates.ContainsKey(new TemplateName($ID.text)) ) {
-            ErrorManager.CompileTimeError(ErrorType.TemplateRedefinitionAsMap, $ID);
-        }
-        else {
-            this._group.DefineDictionary($ID.text, $dict.mapping);
-        }
-        }
-	;
-
-dict returns [IDictionary<string, object> mapping]
-@init {mapping=new Dictionary<string, object>();}
-	:   '[' dictPairs[mapping] ']'
-	;
-
-dictPairs[IDictionary<string, object> mapping]
-    :	keyValuePair[mapping]
-    	(',' keyValuePair[mapping])* (',' defaultValuePair[mapping])?
-    |	defaultValuePair[mapping]
-    ;
-catch[RecognitionException re]
-{
-	Error("missing dictionary entry at '" + input.LT(1).Text + "'");
-}
-
-defaultValuePair[IDictionary<string,object> mapping]
-	:	'default' ':' keyValue {mapping[TemplateGroup.DEFAULT_KEY] = $keyValue.value;}
-	;
-
-keyValuePair[IDictionary<string,object> mapping]
-	:	STRING ':' keyValue {mapping[Misc.ReplaceEscapes(Misc.Strip($STRING.text, 1))] = $keyValue.value;}
-	;
-
-keyValue returns [object value]
-	:	BIGSTRING			{$value = new Template(Misc.Strip($BIGSTRING.text,2));}
-	|	ANONYMOUS_TEMPLATE	{$value = new Template(Misc.Strip($ANONYMOUS_TEMPLATE.text,1));}
-	|	STRING				{$value = Misc.ReplaceEscapes(Misc.Strip($STRING.text, 1));}
-	|	{input.LT(1).Text.Equals("key")}?=> ID
-							{$value = TemplateGroup.DICT_KEY;}
-	|						{$value = null;}
-	;
-catch[RecognitionException re]
-{
-	Error("missing value for key at '" + input.LT(1).Text + "'");
-}
-
-ID	:	('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'0'..'9'|'-'|'_')*
-	;
-
-STRING
-	:	'"'
-		(	'\\' '"'
-		|	'\\' ~'"'
-		|	{
-			string msg = "\\n in string";
-			NoViableAltException e = new NoViableAltException("", 0, 0, input);
-			ErrorManager.SyntaxError(ErrorType.SyntaxError, e, msg, SourceName);
-			}
-			'\n'
-		|	~('\\'|'"'|'\n')
-		)*
-		'"'
-	;
-
-BIGSTRING
-	:	'<<'
-		(	options {greedy=false;}
-		:	'\\' '>'  // \> escape
-		|	'\\' ~'>'
-		|	~'\\'
-		)*
-        '>>'
-        {
-        $text = $text.Replace(@"\>", ">");
-        }
-	;
-
-ANONYMOUS_TEMPLATE
-    :	'{'
-    	{
-		TemplateLexer lexer =
-			new TemplateLexer(input, this._group.delimiterStartChar, this._group.delimiterStopChar);
-		lexer.subtemplateDepth = 1;
-		CommonTokenStream tokens = new CommonTokenStream(lexer);
-        TemplateParser parser = new TemplateParser(tokens, (ICodeGenerator)null, null);
-		parser.template();
-		}
-    	// don't match '}' here; subparser matches it to terminate
-    ;
-
-COMMENT
-    :   '/*' ( options {greedy=false;} : . )* '*/' {Skip();}
-    ;
-
-LINE_COMMENT
-    :	'//' ~('\n'|'\r')* '\r'? '\n' {Skip();}
-    ;
-
-WS  :	(' '|'\r'|'\t'|'\n') {Skip();} ;
diff --git a/StringTemplate4/Compiler/GroupLexerHelper.cs b/StringTemplate4/Compiler/GroupLexerHelper.cs
deleted file mode 100644
index 9381851..0000000
--- a/StringTemplate4/Compiler/GroupLexerHelper.cs
+++ /dev/null
@@ -1,69 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate.Compiler
-{
-    using Path = System.IO.Path;
-    using Antlr.Runtime;
-
-    partial class GroupLexer
-    {
-        protected internal TemplateGroup _group;
-
-        public override string SourceName
-        {
-            get
-            {
-                string fullFileName = base.SourceName;
-                return Path.GetFileName(fullFileName);
-            }
-        }
-
-        public override void ReportError(RecognitionException e)
-        {
-            string msg = null;
-            if (e is NoViableAltException)
-            {
-                msg = "invalid character '" + (char)input.LA(1) + "'";
-            }
-            else if (e is MismatchedTokenException && ((MismatchedTokenException)e).expecting == '"')
-            {
-                msg = "unterminated string";
-            }
-            else
-            {
-                msg = GetErrorMessage(e, TokenNames);
-            }
-            ErrorManager.SyntaxError(ErrorType.SyntaxError, e, msg, SourceName);
-        }
-    }
-}
diff --git a/StringTemplate4/Compiler/GroupParserHelper.cs b/StringTemplate4/Compiler/GroupParserHelper.cs
deleted file mode 100644
index a659a95..0000000
--- a/StringTemplate4/Compiler/GroupParserHelper.cs
+++ /dev/null
@@ -1,65 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate.Compiler
-{
-    using Antlr.Runtime;
-    using Path = System.IO.Path;
-
-    public partial class GroupParser
-    {
-        protected internal TemplateGroup _group;
-
-        public override string SourceName
-        {
-            get
-            {
-                string fullFileName = base.SourceName;
-                // strip to simple name
-                return Path.GetFileName(fullFileName);
-            }
-        }
-
-        public override void DisplayRecognitionError(string[] tokenNames, RecognitionException e)
-        {
-            string message = GetErrorMessage(e, tokenNames);
-            ErrorManager.SyntaxError(ErrorType.SyntaxError, e, message, SourceName);
-        }
-
-        public void Error(string msg)
-        {
-            NoViableAltException e = new NoViableAltException("", 0, 0, input);
-            ErrorManager.SyntaxError(ErrorType.SyntaxError, e, msg, SourceName);
-            Recover(input, null);
-        }
-    }
-}
diff --git a/StringTemplate4/Compiler/ICodeGenerator.cs b/StringTemplate4/Compiler/ICodeGenerator.cs
deleted file mode 100644
index 0bd4476..0000000
--- a/StringTemplate4/Compiler/ICodeGenerator.cs
+++ /dev/null
@@ -1,71 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate.Compiler
-{
-    using System.Collections.Generic;
-    using Antlr.Runtime;
-
-    // TODO: maybe rename; more than code gen now; break into two interfaces?
-    public interface ICodeGenerator
-    {
-        /// <summary>
-        /// If we're compiling templates in subdir or group file under root,
-        /// what's the templatePathPrefix to add?
-        /// </summary>
-        TemplateName TemplateReferencePrefix
-        {
-            get;
-        }
-
-        void Emit(short opcode);
-        void Emit(short opcode, int sourceStart, int sourceStop);
-        void Emit(short opcode, int arg);
-        void Emit(short opcode, int arg, int sourceStart, int sourceStop);
-        void Emit(short opcode, int arg1, int arg2, int sourceStart, int sourceStop);
-        void Emit(short opcode, string s);
-        void Emit(short opcode, string s, int sourceStart, int sourceStop);
-        void Write(int addr, short value);
-        /** Return address where next instruction will be written */
-        int Address();
-
-        /** Compile a subtemplate. It's the '...' in this &lt;names:{p | ...}&gt; */
-        TemplateName CompileAnonTemplate(TemplateName enclosingTemplateName,
-                                   ITokenStream input,
-                                   IList<IToken> ids,
-                                   RecognizerSharedState state);
-
-        TemplateName CompileRegion(TemplateName enclosingTemplateName, string regionName, ITokenStream input, RecognizerSharedState state);
-
-        void DefineBlankRegion(TemplateName name);
-    }
-}
diff --git a/StringTemplate4/Compiler/Interval.cs b/StringTemplate4/Compiler/Interval.cs
deleted file mode 100644
index f4f66ce..0000000
--- a/StringTemplate4/Compiler/Interval.cs
+++ /dev/null
@@ -1,84 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate.Compiler
-{
-    public struct Interval
-    {
-        public Interval(int a, int b)
-            : this()
-        {
-            this.A = a;
-            this.B = b;
-        }
-
-        public int A
-        {
-            get;
-            private set;
-        }
-
-        public int B
-        {
-            get;
-            private set;
-        }
-
-        public static bool operator ==(Interval x, Interval y)
-        {
-            return x.A == y.A && x.B == y.B;
-        }
-
-        public static bool operator !=(Interval x, Interval y)
-        {
-            return !(x == y);
-        }
-
-        public override bool Equals(object obj)
-        {
-            if (!(obj is Interval))
-                return false;
-
-            return this == (Interval)obj;
-        }
-
-        public override int GetHashCode()
-        {
-            return A ^ B;
-        }
-
-        public override string ToString()
-        {
-            return A.ToString() + ".." + B.ToString();
-        }
-    }
-}
diff --git a/StringTemplate4/Compiler/StringTable.cs b/StringTemplate4/Compiler/StringTable.cs
deleted file mode 100644
index cd34595..0000000
--- a/StringTemplate4/Compiler/StringTable.cs
+++ /dev/null
@@ -1,64 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate.Compiler
-{
-    using System.Collections.Generic;
-    using System.Linq;
-
-    public class StringTable
-    {
-        private readonly Dictionary<string, int> _table = new Dictionary<string, int>();
-        private int _i = -1;
-
-        public int Add(string s)
-        {
-            int i;
-            if (_table.TryGetValue(s, out i))
-                return i;
-
-            i = ++_i;
-            _table[s] = i;
-            return i;
-        }
-
-        public int GetIndex(string s)
-        {
-            return _table[s];
-        }
-
-        public string[] ToArray()
-        {
-            return _table.OrderBy(pair => pair.Value).Select(pair => pair.Key).ToArray();
-        }
-    }
-}
diff --git a/StringTemplate4/Compiler/TemplateCompiler.cs b/StringTemplate4/Compiler/TemplateCompiler.cs
deleted file mode 100644
index 002953c..0000000
--- a/StringTemplate4/Compiler/TemplateCompiler.cs
+++ /dev/null
@@ -1,376 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate.Compiler
-{
-    using System.Collections.Generic;
-    using Antlr.Runtime;
-    using ArgumentException = System.ArgumentException;
-    using ArgumentNullException = System.ArgumentNullException;
-    using Array = System.Array;
-    using Console = System.Console;
-    using Math = System.Math;
-
-    /// <summary>
-    /// A compiler for a single template
-    /// </summary>
-    public class TemplateCompiler : ICodeGenerator
-    {
-        /** Given a template of length n, how much code will result?
-         *  For now, let's assume n/5. Later, we can test in practice.
-         */
-        public static readonly double CODE_SIZE_FACTOR = 5.0;
-        public static readonly int SUBTEMPLATE_INITIAL_CODE_SIZE = 15;
-
-        public static readonly IDictionary<string, int> supportedOptions =
-            new Dictionary<string, int>()
-            {
-                { "anchor",    Interpreter.OPTION_ANCHOR},
-                { "format",    Interpreter.OPTION_FORMAT},
-                { "null",      Interpreter.OPTION_NULL},
-                { "separator", Interpreter.OPTION_SEPARATOR},
-                { "wrap",      Interpreter.OPTION_WRAP}
-            };
-
-        public static readonly int NUM_OPTIONS = supportedOptions.Count;
-
-        public static readonly IDictionary<string, string> defaultOptionValues =
-            new Dictionary<string, string>()
-        {
-            {"anchor", "true"},
-            {"wrap",   "\n"}
-        };
-
-        public static IDictionary<string, short> funcs =
-            new Dictionary<string, short>()
-        {
-            {"first", Bytecode.INSTR_FIRST},
-            {"last", Bytecode.INSTR_LAST},
-            {"rest", Bytecode.INSTR_REST},
-            {"trunc", Bytecode.INSTR_TRUNC},
-            {"strip", Bytecode.INSTR_STRIP},
-            {"trim", Bytecode.INSTR_TRIM},
-            {"length", Bytecode.INSTR_LENGTH},
-            {"strlen", Bytecode.INSTR_STRLEN},
-            {"reverse", Bytecode.INSTR_REVERSE}
-        };
-
-        StringTable strings = new StringTable();
-        byte[] instrs;
-        Interval[] sourceMap;
-        int ip = 0;
-        CompiledTemplate code = new CompiledTemplate();
-
-        /** subdir context.  If we're compiling templates in subdir a/b/c, then
-         *  /a/b/c is the path prefix to add to all ID refs; it fully qualifies them.
-         *  It's like resolving x to this.x in Java for field x.
-         */
-        private TemplateName templatePathPrefix;
-
-        private TemplateName enclosingTemplateName;
-
-        public static int subtemplateCount = 0; // public for testing access
-
-        public TemplateCompiler()
-            : this(TemplateName.Root, new TemplateName("unknown"))
-        {
-        }
-
-        public TemplateCompiler(TemplateName templatePathPrefix, TemplateName enclosingTemplateName)
-        {
-            this.templatePathPrefix = templatePathPrefix;
-            this.enclosingTemplateName = enclosingTemplateName;
-        }
-
-        public TemplateName TemplateReferencePrefix
-        {
-            get
-            {
-                return this.templatePathPrefix;
-            }
-        }
-
-        public CompiledTemplate Compile(string template)
-        {
-            return Compile(template, '<', '>');
-        }
-
-        public CompiledTemplate Compile(string template,
-                                        char delimiterStartChar,
-                                        char delimiterStopChar)
-        {
-            int initialSize = Math.Max(5, (int)(template.Length / CODE_SIZE_FACTOR));
-            instrs = new byte[initialSize];
-            sourceMap = new Interval[initialSize];
-            code.template = template;
-
-            TemplateLexer lexer = new TemplateLexer(new ANTLRStringStream(template), delimiterStartChar, delimiterStopChar);
-            CommonTokenStream tokens = new CommonTokenStream(lexer);
-            TemplateParser parser = new TemplateParser(tokens, this, enclosingTemplateName);
-            try
-            {
-                parser.templateAndEOF(); // parse, trigger compile actions for single expr
-            }
-            catch (RecognitionException re)
-            {
-                ThrowTemplateException(tokens, parser, re);
-            }
-
-            if (strings != null)
-                code.strings = strings.ToArray();
-            code.codeSize = ip;
-            code.instrs = new byte[code.codeSize];
-            code.sourceMap = new Interval[code.codeSize];
-            Array.Copy(instrs, 0, code.instrs, 0, code.codeSize);
-            Array.Copy(sourceMap, 0, code.sourceMap, 0, code.codeSize);
-            return code;
-        }
-
-        public CompiledTemplate Compile(ITokenStream tokens, RecognizerSharedState state)
-        {
-            instrs = new byte[SUBTEMPLATE_INITIAL_CODE_SIZE];
-            sourceMap = new Interval[SUBTEMPLATE_INITIAL_CODE_SIZE];
-            TemplateParser parser = new TemplateParser(tokens, state, this, enclosingTemplateName);
-            try
-            {
-                parser.template(); // parse, trigger compile actions for single expr
-            }
-            catch (RecognitionException re)
-            {
-                ThrowTemplateException(tokens, parser, re);
-            }
-
-            if (strings != null)
-                code.strings = strings.ToArray();
-            code.codeSize = ip;
-            code.instrs = new byte[code.codeSize];
-            code.sourceMap = new Interval[code.codeSize];
-            Array.Copy(instrs, 0, code.instrs, 0, code.codeSize);
-            Array.Copy(sourceMap, 0, code.sourceMap, 0, code.codeSize);
-            return code;
-        }
-
-        protected void ThrowTemplateException(ITokenStream tokens, TemplateParser parser, RecognitionException re)
-        {
-            string msg = parser.GetErrorMessage(re, parser.TokenNames);
-            //String hdr = parser.getErrorHeader(re);
-            if (re.Token.Type == TemplateLexer.EOF_TYPE)
-            {
-                throw new TemplateException("premature EOF", re);
-            }
-            else if (re is NoViableAltException)
-            {
-                throw new TemplateException("'" + re.Token.Text + "' came as a complete surprise to me", re);
-            }
-            else if (tokens.Index == 0)
-            {
-                // couldn't parse anything
-                throw new TemplateException("this doesn't look like a template: \"" + tokens + "\"", re);
-            }
-            else if (tokens.LA(1) == TemplateLexer.LDELIM)
-            {
-                // couldn't parse anything
-                throw new TemplateException("doesn't look like an expression", re);
-            }
-            else
-            {
-                throw new TemplateException(msg, re);
-            }
-        }
-
-        public int DefineString(string s)
-        {
-            return strings.Add(s);
-        }
-
-        // CodeGenerator interface impl.
-
-        public void Emit(short opcode)
-        {
-            Emit(opcode, -1, -1);
-        }
-
-        public void Emit(short opcode, int sourceStart, int sourceStop)
-        {
-            EnsureCapacity(1);
-            if (!(sourceStart < 0 || sourceStop < 0))
-                sourceMap[ip] = new Interval(sourceStart, sourceStop);
-            instrs[ip++] = (byte)opcode;
-        }
-
-        public void Emit(short opcode, int arg)
-        {
-            Emit(opcode, arg, -1, -1);
-        }
-
-        public void Emit(short opcode, int arg, int sourceStart, int sourceStop)
-        {
-            Emit(opcode, sourceStart, sourceStop);
-            EnsureCapacity(2);
-            WriteShort(instrs, ip, (short)arg);
-            ip += 2;
-        }
-
-        public void Emit(short opcode, int arg1, int arg2, int sourceStart, int sourceStop)
-        {
-            Emit(opcode, arg1, sourceStart, sourceStop);
-            EnsureCapacity(2);
-            WriteShort(instrs, ip, (short)arg2);
-            ip += 2;
-        }
-
-        public void Emit(short opcode, string s)
-        {
-            Emit(opcode, s, -1, -1);
-        }
-
-        public void Emit(short opcode, string s, int sourceStart, int sourceStop)
-        {
-            int i = DefineString(s);
-            Emit(opcode, i, sourceStart, sourceStop);
-        }
-
-        public void Write(int addr, short value)
-        {
-            WriteShort(instrs, addr, value);
-        }
-
-        public int Address()
-        {
-            return ip;
-        }
-
-        public TemplateName CompileAnonTemplate(TemplateName enclosingTemplateName,
-                                          ITokenStream input,
-                                          IList<IToken> argIDs,
-                                          RecognizerSharedState state)
-        {
-            subtemplateCount++;
-            TemplateName name = TemplateName.Combine(templatePathPrefix, Template.SubtemplatePrefix + subtemplateCount);
-            ITokenSource tokenSource = input.TokenSource;
-            TemplateLexer lexer = tokenSource as TemplateLexer;
-            int start = -1;
-            int stop = -1;
-            if (tokenSource != null)
-                start = lexer.input.Index;
-            TemplateCompiler c = new TemplateCompiler(templatePathPrefix, enclosingTemplateName);
-            CompiledTemplate sub = c.Compile(input, state);
-            sub.Name = name;
-            sub.IsSubtemplate = true;
-            if (lexer != null)
-            {
-                stop = lexer.input.Index;
-                //sub.template = lexer.input.Substring(start, stop - start - 1);
-                //Console.WriteLine(start + ".." + stop);
-                sub.embeddedStart = start;
-                sub.embeddedStop = stop - 1;
-                sub.template = lexer.input.Substring(0, lexer.input.Count - 1);
-            }
-            if (code.implicitlyDefinedTemplates == null)
-                code.implicitlyDefinedTemplates = new List<CompiledTemplate>();
-            code.implicitlyDefinedTemplates.Add(sub);
-            if (argIDs != null)
-            {
-                sub.formalArguments = new Dictionary<string, FormalArgument>();
-                foreach (IToken arg in argIDs)
-                {
-                    string argName = arg.Text;
-                    sub.formalArguments[argName] = new FormalArgument(argName);
-                }
-            }
-            return name;
-        }
-
-        public TemplateName CompileRegion(TemplateName enclosingTemplateName,
-                                    string regionName,
-                                    ITokenStream input,
-                                    RecognizerSharedState state)
-        {
-            TemplateCompiler c = new TemplateCompiler(templatePathPrefix, enclosingTemplateName);
-            CompiledTemplate sub = c.Compile(input, state);
-            TemplateName fullName = TemplateName.Combine(templatePathPrefix, TemplateGroup.GetMangledRegionName(enclosingTemplateName, regionName));
-            sub.isRegion = true;
-            sub.regionDefType = Template.RegionType.Embedded;
-            sub.Name = fullName;
-            if (code.implicitlyDefinedTemplates == null)
-            {
-                code.implicitlyDefinedTemplates = new List<CompiledTemplate>();
-            }
-            code.implicitlyDefinedTemplates.Add(sub);
-            return fullName;
-        }
-
-        public void DefineBlankRegion(TemplateName name)
-        {
-            if (name == null)
-                throw new ArgumentNullException();
-            if (!name.IsRooted)
-                throw new ArgumentException();
-
-            // TODO: combine with CompileRegion
-            CompiledTemplate blank = new CompiledTemplate()
-            {
-                isRegion = true,
-                regionDefType = Template.RegionType.Implicit,
-                Name = name
-            };
-
-            if (code.implicitlyDefinedTemplates == null)
-                code.implicitlyDefinedTemplates = new List<CompiledTemplate>();
-
-            code.implicitlyDefinedTemplates.Add(blank);
-        }
-
-        protected void EnsureCapacity(int n)
-        {
-            if ((ip + n) >= instrs.Length)
-            {
-                // ensure room for full instruction
-                byte[] c = new byte[instrs.Length * 2];
-                Array.Copy(instrs, 0, c, 0, instrs.Length);
-                instrs = c;
-                Interval[] sm = new Interval[sourceMap.Length * 2];
-                Array.Copy(sourceMap, 0, sm, 0, sourceMap.Length);
-                sourceMap = sm;
-            }
-        }
-
-        /** Write value at index into a byte array highest to lowest byte,
-         *  left to right.
-         */
-        public static void WriteShort(byte[] memory, int index, short value)
-        {
-            memory[index + 0] = (byte)((value >> (8 * 1)) & 0xFF);
-            memory[index + 1] = (byte)(value & 0xFF);
-        }
-    }
-}
diff --git a/StringTemplate4/Compiler/TemplateException.cs b/StringTemplate4/Compiler/TemplateException.cs
deleted file mode 100644
index f02218f..0000000
--- a/StringTemplate4/Compiler/TemplateException.cs
+++ /dev/null
@@ -1,54 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate.Compiler
-{
-    using Exception = System.Exception;
-
-    public class TemplateException : Exception
-    {
-        public TemplateException()
-            : this("StringTemplate exception", null)
-        {
-        }
-
-        public TemplateException(Exception innerException)
-            : this("StringTemplate exception", innerException)
-        {
-        }
-
-        public TemplateException(string message, Exception innerException)
-            : base(message, innerException)
-        {
-        }
-    }
-}
diff --git a/StringTemplate4/Compiler/TemplateLexer.cs b/StringTemplate4/Compiler/TemplateLexer.cs
deleted file mode 100644
index 7576329..0000000
--- a/StringTemplate4/Compiler/TemplateLexer.cs
+++ /dev/null
@@ -1,649 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate.Compiler
-{
-    using System.Collections.Generic;
-    using Antlr.Runtime;
-    using Console = System.Console;
-    using Exception = System.Exception;
-    using NumberStyles = System.Globalization.NumberStyles;
-    using StringBuilder = System.Text.StringBuilder;
-
-    public class TemplateLexer : ITokenSource
-    {
-        public const char EOF = unchecked((char)(-1));            // EOF char
-        public const int EOF_TYPE = CharStreamConstants.EndOfFile;  // EOF token type
-
-        public class TemplateToken : CommonToken
-        {
-            public TemplateToken(ICharStream input, int type, int channel, int start, int stop)
-                : base(input, type, channel, start, stop)
-            {
-            }
-
-            public TemplateToken(int type, string text)
-                : base(type, text)
-            {
-            }
-
-            public override string ToString()
-            {
-                string channelStr = "";
-                if (Channel > 0)
-                {
-                    channelStr = ",channel=" + Channel;
-                }
-                string txt = Text;
-                if (txt != null)
-                {
-                    txt = Misc.ReplaceEscapes(txt);
-                }
-                else
-                {
-                    txt = "<no text>";
-                }
-                return "[@" + TokenIndex + "," + StartIndex + ":" + StopIndex + "='" + txt + "',<" + TemplateParser.tokenNames[Type] + ">" + channelStr + "," + Line + ":" + CharPositionInLine + "]";
-            }
-        }
-
-        public static readonly IToken SKIP = new TemplateToken(-1, "<skip>");
-
-        // TODO: enum?
-        // pasted from STParser
-        public const int RBRACK = 17;
-        public const int LBRACK = 16;
-        public const int ELSE = 5;
-        public const int ELLIPSIS = 11;
-        public const int LCURLY = 20;
-        public const int BANG = 10;
-        public const int EQUALS = 12;
-        public const int TEXT = 22;
-        public const int ID = 25;
-        public const int SEMI = 9;
-        public const int LPAREN = 14;
-        public const int IF = 4;
-        public const int ELSEIF = 6;
-        public const int COLON = 13;
-        public const int RPAREN = 15;
-        public const int WS = 27;
-        public const int COMMA = 18;
-        public const int RCURLY = 21;
-        public const int ENDIF = 7;
-        public const int RDELIM = 24;
-        public const int SUPER = 8;
-        public const int DOT = 19;
-        public const int LDELIM = 23;
-        public const int STRING = 26;
-        public const int PIPE = 28;
-        public const int OR = 29;
-        public const int AND = 30;
-        public const int INDENT = 31;
-        public const int NEWLINE = 32;
-        public const int AT = 33;
-        public const int REGION_END = 34;
-
-        char delimiterStartChar = '<';
-        char delimiterStopChar = '>';
-
-        bool scanningInsideExpr = false;
-        internal int subtemplateDepth = 0; // start out *not* in a {...} subtemplate
-
-        internal ICharStream input;
-        char c;        // current character
-        int startCharIndex;
-        int startLine;
-        int startCharPositionInLine;
-
-        List<IToken> tokens = new List<IToken>();
-
-        public IToken NextToken()
-        {
-            if (tokens.Count > 0)
-            {
-                var result = tokens[0];
-                tokens.RemoveAt(0);
-                return result;
-            }
-            return _nextToken();
-        }
-
-        public TemplateLexer(ANTLRStringStream input)
-            : this(input, '<', '>')
-        {
-        }
-
-        public TemplateLexer(ICharStream input, char delimiterStartChar, char delimiterStopChar)
-        {
-            this.input = input;
-            c = (char)input.LA(1); // prime lookahead
-            this.delimiterStartChar = delimiterStartChar;
-            this.delimiterStopChar = delimiterStopChar;
-        }
-
-        /** Ensure x is next character on the input stream */
-        public void Match(char x)
-        {
-            if (c == x)
-                Consume();
-            else
-                throw new Exception(GetErrorHeader() + "expecting " + x + "; found " + c);
-        }
-
-        protected void Consume()
-        {
-            input.Consume();
-            c = (char)input.LA(1);
-        }
-
-        public void Emit(IToken token)
-        {
-            tokens.Add(token);
-        }
-
-        public IToken _nextToken()
-        {
-            //System.out.println("nextToken: c="+(char)c+"@"+input.index());
-            while (true)
-            { // lets us avoid recursion when skipping stuff
-                startCharIndex = input.Index;
-                startLine = input.Line;
-                startCharPositionInLine = input.CharPositionInLine;
-
-                if (c == EOF)
-                    return NewToken(EOF_TYPE);
-                IToken t = null;
-                if (scanningInsideExpr)
-                    t = Inside();
-                else
-                    t = Outside();
-                if (t != SKIP)
-                    return t;
-            }
-        }
-
-        protected IToken Outside()
-        {
-            if (input.CharPositionInLine == 0 && (c == ' ' || c == '\t'))
-            {
-                while (c == ' ' || c == '\t')
-                    Consume(); // scarf indent
-
-                if (c != EOF)
-                    return NewToken(INDENT);
-
-                return NewToken(TEXT);
-            }
-            if (c == delimiterStartChar)
-            {
-                Consume();
-                if (c == '!')
-                {
-                    mCOMMENT();
-                    return SKIP;
-                }
-                if (c == '\\')
-                    return ESCAPE(); // <\\> <\uFFFF> <\n> etc...
-                scanningInsideExpr = true;
-                return NewToken(LDELIM);
-            }
-            if (c == '\r')
-            {
-                // \r\n -> \n
-                Consume();
-                Consume();
-                return NewToken(NEWLINE);
-            }
-            if (c == '\n')
-            {
-                Consume();
-                return NewToken(NEWLINE);
-            }
-            if (c == '}' && subtemplateDepth > 0)
-            {
-                scanningInsideExpr = true;
-                subtemplateDepth--;
-                Consume();
-                return NewTokenFromPreviousChar(RCURLY);
-            }
-            return mTEXT();
-        }
-
-        protected IToken Inside()
-        {
-            while (true)
-            {
-                switch (c)
-                {
-                case ' ':
-                case '\t':
-                case '\n':
-                case '\r':
-                    Consume();
-                    continue;
-                case '.':
-                    Consume();
-                    if (input.LA(1) == '.' && input.LA(2) == '.')
-                    {
-                        Consume();
-                        Match('.');
-                        return NewToken(ELLIPSIS);
-                    }
-                    return NewToken(DOT);
-                case ',':
-                    Consume();
-                    return NewToken(COMMA);
-                case ':':
-                    Consume();
-                    return NewToken(COLON);
-                case ';':
-                    Consume();
-                    return NewToken(SEMI);
-                case '(':
-                    Consume();
-                    return NewToken(LPAREN);
-                case ')':
-                    Consume();
-                    return NewToken(RPAREN);
-                case '[':
-                    Consume();
-                    return NewToken(LBRACK);
-                case ']':
-                    Consume();
-                    return NewToken(RBRACK);
-                case '=':
-                    Consume();
-                    return NewToken(EQUALS);
-                case '!':
-                    Consume();
-                    return NewToken(BANG);
-                case '@':
-                    Consume();
-                    if (c == 'e' && input.LA(2) == 'n' && input.LA(3) == 'd')
-                    {
-                        Consume();
-                        Consume();
-                        Consume();
-                        return NewToken(REGION_END);
-                    }
-                    return NewToken(AT);
-                case '"':
-                    return mSTRING();
-                case '&':
-                    Consume();
-                    Match('&');
-                    return NewToken(AND); // &&
-                case '|':
-                    Consume();
-                    Match('|');
-                    return NewToken(OR); // ||
-                case '{':
-                    return SubTemplate();
-                default:
-                    if (c == delimiterStopChar)
-                    {
-                        Consume();
-                        scanningInsideExpr = false;
-                        return NewToken(RDELIM);
-                    }
-                    if (IsIDStartLetter(c))
-                    {
-                        IToken id = mID();
-                        string name = id.Text;
-                        if (name.Equals("if"))
-                            return NewToken(IF);
-                        else if (name.Equals("endif"))
-                            return NewToken(ENDIF);
-                        else if (name.Equals("else"))
-                            return NewToken(ELSE);
-                        else if (name.Equals("elseif"))
-                            return NewToken(ELSEIF);
-                        else if (name.Equals("super"))
-                            return NewToken(SUPER);
-                        return id;
-                    }
-                    RecognitionException re = new NoViableAltException("", 0, 0, input);
-                    re.Line = startLine;
-                    re.CharPositionInLine = startCharPositionInLine;
-                    if (c == EOF)
-                    {
-                        throw new TemplateException("EOF inside ST expression", re);
-                    }
-                    throw new TemplateException("invalid character: " + c, re);
-                }
-            }
-        }
-
-        private IToken SubTemplate()
-        {
-            // look for "{ args ID (',' ID)* '|' ..."
-            subtemplateDepth++;
-            int m = input.Mark();
-            int curlyStartChar = startCharIndex;
-            int curlyLine = startLine;
-            int curlyPos = startCharPositionInLine;
-            List<IToken> argTokens = new List<IToken>();
-            Consume();
-            IToken curly = NewTokenFromPreviousChar(LCURLY);
-            mWS();
-            argTokens.Add(mID());
-            mWS();
-            while (c == ',')
-            {
-                Consume();
-                argTokens.Add(NewTokenFromPreviousChar(COMMA));
-                mWS();
-                argTokens.Add(mID());
-                mWS();
-            }
-            mWS();
-            if (c == '|')
-            {
-                Consume();
-                argTokens.Add(NewTokenFromPreviousChar(PIPE));
-                if (IsWS(c))
-                    Consume(); // ignore a single whitespace after |
-                //System.out.println("matched args: "+argTokens);
-                foreach (IToken t in argTokens)
-                    Emit(t);
-                input.Release(m);
-                scanningInsideExpr = false;
-                startCharIndex = curlyStartChar; // reset state
-                startLine = curlyLine;
-                startCharPositionInLine = curlyPos;
-                return curly;
-            }
-            //System.out.println("no match rewind");
-            input.Rewind(m);
-            startCharIndex = curlyStartChar; // reset state
-            startLine = curlyLine;
-            startCharPositionInLine = curlyPos;
-            Consume();
-            scanningInsideExpr = false;
-            return curly;
-        }
-
-        private IToken ESCAPE()
-        {
-            Consume(); // kill \\
-            IToken t = null;
-            switch (c)
-            {
-            case '\\':
-                mLINEBREAK();
-                return SKIP;
-            case 'n':
-                t = NewToken(TEXT, "\n", input.CharPositionInLine - 2);
-                break;
-            case 't':
-                t = NewToken(TEXT, "\t", input.CharPositionInLine - 2);
-                break;
-            case ' ':
-                t = NewToken(TEXT, " ", input.CharPositionInLine - 2);
-                break;
-            case 'u':
-                t = UNICODE();
-                break;
-            default:
-                ErrorManager.CompileTimeError(ErrorType.LexerError, c);
-                break;
-            }
-            Consume();
-            Match(delimiterStopChar);
-            return t;
-        }
-
-        private IToken UNICODE()
-        {
-            Consume();
-            char[] chars = new char[4];
-            if (!IsUnicodeLetter(c))
-                ErrorManager.CompileTimeError(ErrorType.LexerError, c);
-            chars[0] = c;
-            Consume();
-            if (!IsUnicodeLetter(c))
-                ErrorManager.CompileTimeError(ErrorType.LexerError, c);
-            chars[1] = c;
-            Consume();
-            if (!IsUnicodeLetter(c))
-                ErrorManager.CompileTimeError(ErrorType.LexerError, c);
-            chars[2] = c;
-            Consume();
-            if (!IsUnicodeLetter(c))
-                ErrorManager.CompileTimeError(ErrorType.LexerError, c);
-            chars[3] = c;
-            // ESCAPE kills final char and >
-            char uc = (char)int.Parse(new string(chars), NumberStyles.HexNumber);
-            return NewToken(TEXT, uc.ToString(), input.CharPositionInLine - 6);
-        }
-
-        private IToken mTEXT()
-        {
-            bool modifiedText = false;
-            StringBuilder buf = new StringBuilder();
-            while (c != EOF && c != delimiterStartChar)
-            {
-                if (c == '\r' || c == '\n')
-                    break;
-                if (c == '}' && subtemplateDepth > 0)
-                    break;
-                if (c == '\\')
-                {
-                    if (input.LA(2) == delimiterStartChar ||
-                         input.LA(2) == '}')
-                    {
-                        modifiedText = true;
-                        Consume(); // toss out \ char
-                        buf.Append(c);
-                        Consume();
-                    }
-                    else
-                    {
-                        Consume();
-                    }
-                    continue;
-                }
-                buf.Append(c);
-                Consume();
-            }
-            if (modifiedText)
-                return NewToken(TEXT, buf.ToString());
-            else
-                return NewToken(TEXT);
-        }
-
-        /** ID  :   ('a'..'z'|'A'..'Z'|'_'|'/') ('a'..'z'|'A'..'Z'|'0'..'9'|'_'|'/')* ; */
-        private IToken mID()
-        {
-            // called from subTemplate; so keep resetting position during speculation
-            startCharIndex = input.Index;
-            startLine = input.Line;
-            startCharPositionInLine = input.CharPositionInLine;
-            Consume();
-            while (IsIDLetter(c))
-            {
-                Consume();
-            }
-            return NewToken(ID);
-        }
-
-        /** STRING : '"' ( '\\' '"' | '\\' ~'"' | ~('\\'|'"') )* '"' ; */
-        private IToken mSTRING()
-        {
-            //{setText(getText().substring(1, getText().length()-1));}
-            bool sawEscape = false;
-            StringBuilder buf = new StringBuilder();
-            buf.Append(c);
-            Consume();
-            while (c != '"')
-            {
-                if (c == '\\')
-                {
-                    sawEscape = true;
-                    Consume();
-                    switch (c)
-                    {
-                    case 'n':
-                        buf.Append('\n');
-                        break;
-                    case 'r':
-                        buf.Append('\r');
-                        break;
-                    case 't':
-                        buf.Append('\t');
-                        break;
-                    default:
-                        buf.Append(c);
-                        break;
-                    }
-                    Consume();
-                    continue;
-                }
-                buf.Append(c);
-                Consume();
-            }
-            buf.Append(c);
-            Consume();
-            if (sawEscape)
-                return NewToken(STRING, buf.ToString());
-            else
-                return NewToken(STRING);
-        }
-
-        private void mWS()
-        {
-            while (c == ' ' || c == '\t' || c == '\n' || c == '\r')
-                Consume();
-        }
-
-        private void mCOMMENT()
-        {
-            Match('!');
-            while (!(c == '!' && input.LA(2) == delimiterStopChar))
-                Consume();
-            Consume();
-            Consume(); // kill !>
-        }
-
-        private void mLINEBREAK()
-        {
-            Match('\\'); // only kill 2nd \ as outside() kills first one
-            Match(delimiterStopChar);
-            while (c == ' ' || c == '\t')
-                Consume(); // scarf WS after <\\>
-            if (c == '\r')
-                Consume();
-            Match('\n');
-            while (c == ' ' || c == '\t')
-                Consume(); // scarf any indent
-            return;
-        }
-
-        public static bool IsIDStartLetter(char c)
-        {
-            return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c == '/';
-        }
-
-        public static bool IsIDLetter(char c)
-        {
-            return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c >= '0' && c <= '9' || c == '/';
-        }
-
-        public static bool IsWS(char c)
-        {
-            return c == ' ' || c == '\t' || c == '\n' || c == '\r';
-        }
-
-        public static bool IsUnicodeLetter(char c)
-        {
-            return c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F' || c >= '0' && c <= '9';
-        }
-
-        public IToken NewToken(int ttype)
-        {
-            TemplateToken t = new TemplateToken(input, ttype, Lexer.DefaultTokenChannel,
-                    startCharIndex, input.Index - 1);
-            t.Line = startLine;
-            t.CharPositionInLine = startCharPositionInLine;
-            return t;
-        }
-
-        public IToken NewTokenFromPreviousChar(int ttype)
-        {
-            TemplateToken t =
-                new TemplateToken(input, ttype, Lexer.DefaultTokenChannel,
-                    input.Index - 1, input.Index - 1);
-            t.Line = input.Line;
-            t.CharPositionInLine = input.CharPositionInLine - 1;
-            return t;
-        }
-
-        public IToken NewToken(int ttype, string text, int pos)
-        {
-            TemplateToken t = new TemplateToken(ttype, text);
-            t.Line = input.Line;
-            t.CharPositionInLine = pos;
-            return t;
-        }
-
-        public IToken NewToken(int ttype, string text)
-        {
-            TemplateToken t = new TemplateToken(ttype, text);
-            t.StartIndex = startCharIndex;
-            t.StopIndex = input.Index - 1;
-            t.Line = startLine;
-            t.CharPositionInLine = startCharPositionInLine;
-            return t;
-        }
-
-        public string GetErrorHeader()
-        {
-            return startLine + ":" + startCharPositionInLine;
-        }
-
-        public string SourceName
-        {
-            get
-            {
-                return "no idea";
-            }
-        }
-
-        public string[] TokenNames
-        {
-            get
-            {
-                return TemplateParser.tokenNames;
-            }
-        }
-    }
-}
diff --git a/StringTemplate4/Compiler/TemplateLexer.tokens b/StringTemplate4/Compiler/TemplateLexer.tokens
deleted file mode 100644
index d4491a0..0000000
--- a/StringTemplate4/Compiler/TemplateLexer.tokens
+++ /dev/null
@@ -1,54 +0,0 @@
-RBRACK=17
-LBRACK=16
-ELSE=5
-ELLIPSIS=11
-LCURLY=20
-BANG=10
-EQUALS=12
-TEXT=22
-ID=25
-SEMI=9
-LPAREN=14
-IF=4
-ELSEIF=6
-COLON=13
-RPAREN=15
-WS=27
-COMMA=18
-RCURLY=21
-ENDIF=7
-RDELIM=24
-SUPER=8
-DOT=19
-LDELIM=23
-STRING=26
-PIPE=28
-OR=29
-AND=30
-INDENT=31
-NEWLINE=32
-AT=33
-END=34
-'super'=8
-'|'=28
-'!'=10
-'}'=21
-'else'=5
-'if'=4
-'{'=20
-'...'=11
-'elseif'=6
-';'=9
-'='=12
-':'=13
-'('=14
-'['=16
-','=18
-'.'=19
-'endif'=7
-')'=15
-']'=17
-'||'=29
-'&&'=30
-'@'=33
-'@end'=34
\ No newline at end of file
diff --git a/StringTemplate4/Compiler/TemplateParser.g3 b/StringTemplate4/Compiler/TemplateParser.g3
deleted file mode 100644
index fff517f..0000000
--- a/StringTemplate4/Compiler/TemplateParser.g3
+++ /dev/null
@@ -1,356 +0,0 @@
-﻿/*
- [The "BSD licence"]
- Copyright (c) 2009 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/** Recognize a single StringTemplate template text, expressions, and conditionals */
-parser grammar TemplateParser;
-
-options {
-	language=CSharp3;
-	tokenVocab=TemplateLexer;
-	TokenLabelType=CommonToken;
-}
-
-@namespace{StringTemplate.Compiler}
-@header{using System.Linq;}
-
-@rulecatch {
-   catch (RecognitionException) { throw; }
-}
-
-public
-templateAndEOF
-	:	template EOF
-	;
-
-public
-template
-	:	element*
-	;
-
-element
-	:	(	// TODO: remove backtracking
-			options {backtrack=true; k=2;}
-		:	i=INDENT         {Indent($i.text);}
-			ifOnOneLine      {gen.Emit(Bytecode.INSTR_DEDENT);}
-		|	i=INDENT ifOnMultiLines
-		)
-	|	ifOnMultiLines
-	|	i=INDENT       	 {Indent($i.text);}
-		exprTag          {gen.Emit(Bytecode.INSTR_DEDENT);}
-	|	exprTag
-	|	i=INDENT         {Indent($i.text);}
-		text             {gen.Emit(Bytecode.INSTR_DEDENT);}
-	|	text
-	|   (i=INDENT {Indent($i.text);})? region
-						 {
-						 gen.Emit(Bytecode.INSTR_NEW, $region.name.FullName, $region.start.StartIndex, $region.start.StopIndex);
-						 gen.Emit(Bytecode.INSTR_WRITE, $region.start.StartIndex, $region.stop.StartIndex);
-						 }
-	|	i=INDENT         {Indent($i.text);}
-	 	NEWLINE          {gen.Emit(Bytecode.INSTR_NEWLINE);}
-	 	                 {gen.Emit(Bytecode.INSTR_DEDENT);}
-	|	NEWLINE          {gen.Emit(Bytecode.INSTR_NEWLINE);}
-	;
-
-text
-	:	TEXT
-		{
-		if ( $TEXT.text.Length>0 ) {
-			gen.Emit(Bytecode.INSTR_LOAD_STR, $TEXT.text, $TEXT.StartIndex, $TEXT.StopIndex);
-			gen.Emit(Bytecode.INSTR_WRITE, $TEXT.StartIndex, $TEXT.StopIndex);
-		}
-		}
-	;
-
-exprTag
-	:	LDELIM
-		expr
-		(	';' exprOptions {gen.Emit(Bytecode.INSTR_WRITE_OPT, $LDELIM.StartIndex, input.LT(1).StartIndex);}
-		|	                {gen.Emit(Bytecode.INSTR_WRITE, $LDELIM.StartIndex, input.LT(1).StartIndex);}
-		)
-		RDELIM
-	;
-
-region returns [TemplateName name] // match $@foo$...$@end$
-	:	LDELIM '@' ID RDELIM
-		{{ // force exec even when backtracking
-		if (state.backtracking == 0)
-			$name = gen.CompileRegion(_enclosingTemplateName, $ID.text, input, state);
-		else
-			$name = NoopGen.CompileRegion(_enclosingTemplateName, $ID.text, input, state);
-		gen.CompileRegion(_enclosingTemplateName, $ID.text, input, state);
-        }}
-		LDELIM '@end' RDELIM
-	;
-
-subtemplate returns [TemplateName name]
-	:	'{' ( ids+=ID (',' ids+=ID)* '|' )?
-		{{ // force exec even when backtracking
-		List<IToken> idTokens = null;
-		if ($ids != null)
-			idTokens = new List<IToken>($ids.Cast<IToken>());
-		if (state.backtracking == 0)
-			$name = gen.CompileAnonTemplate(_enclosingTemplateName, input, idTokens, state);
-		else
-			$name = NoopGen.CompileAnonTemplate(_enclosingTemplateName, input, idTokens, state);
-        }}
-        '}'
-    ;
-
-/** The (...)* loop in rule template doesn't think '}' can follow it because
- *  we call template in an action (via compileAnonTemplate).  To avoid
- *  syntax errors upon '}' in rule templatee, we force '}' into FOLLOW set.
- *  I hope to make ANTLR ignore FOLLOW set for (...)* in future.
- */
-addTemplateEndTokensToFollowOfTemplateRule : template ('}' | LDELIM '@end') ;
-
-ifOnMultiLines
-@init {
-    /** Tracks address of branch operand (in code block).  It's how
-     *  we backpatch forward references when generating code for IFs.
-     */
-    int prevBranchOperand = -1;
-    /** Branch instruction operands that are forward refs to end of IF.
-     *  We need to update them once we see the endif.
-     */
-    List<int> endRefs = new List<int>();
-}
-	:	LDELIM 'if' '(' conditional ')' RDELIM
-		{
-        prevBranchOperand = gen.Address()+1;
-        gen.Emit(Bytecode.INSTR_BRF, -1); // write placeholder as branch target
-		}
-		template
-		(	INDENT? LDELIM 'elseif'
-			{
-			endRefs.Add(gen.Address()+1);
-			gen.Emit(Bytecode.INSTR_BR, -1); // br end
-			// update previous branch instruction
-			gen.Write(prevBranchOperand, (short)gen.Address());
-			prevBranchOperand = -1;
-			}
-			'(' conditional ')' RDELIM
-			{
-        	prevBranchOperand = gen.Address()+1;
-        	gen.Emit(Bytecode.INSTR_BRF, -1); // write placeholder as branch target
-			}
-			template
-		)*
-		(	INDENT? LDELIM 'else' RDELIM
-			{
-			endRefs.Add(gen.Address()+1);
-			gen.Emit(Bytecode.INSTR_BR, -1); // br end
-			// update previous branch instruction
-			gen.Write(prevBranchOperand, (short)gen.Address());
-			prevBranchOperand = -1;
-			}
-			template
-		)?
-		INDENT? endif=LDELIM 'endif' RDELIM
-		( {true}? NEWLINE )? // kill \on for <endif> on line by itself
-		{
-		if ( prevBranchOperand>=0 ) {
-			gen.Write(prevBranchOperand, (short)gen.Address());
-		}
-        foreach (int opnd in endRefs) gen.Write(opnd, (short)gen.Address());
-		}
-	;
-
-// TODO: code dup but need to call elementsForIfOnOneLine not template inside :(
-ifOnOneLine
-@init {
-    /** Tracks address of branch operand (in code block).  It's how
-     *  we backpatch forward references when generating code for IFs.
-     */
-    int prevBranchOperand = -1;
-    /** Branch instruction operands that are forward refs to end of IF.
-     *  We need to update them once we see the endif.
-     */
-    List<int> endRefs = new List<int>();
-}
-	:	LDELIM 'if' '(' conditional ')' RDELIM
-		{
-        prevBranchOperand = gen.Address()+1;
-        gen.Emit(Bytecode.INSTR_BRF, -1); // write placeholder as branch target
-		}
-		elementsForIfOnOneLine*
-		(	LDELIM 'elseif'
-			{
-			endRefs.Add(gen.Address()+1);
-			gen.Emit(Bytecode.INSTR_BR, -1); // br end
-			// update previous branch instruction
-			gen.Write(prevBranchOperand, (short)gen.Address());
-			prevBranchOperand = -1;
-			}
-			'(' conditional ')' RDELIM
-			{
-        	prevBranchOperand = gen.Address()+1;
-        	gen.Emit(Bytecode.INSTR_BRF, -1); // write placeholder as branch target
-			}
-			elementsForIfOnOneLine*
-		)*
-		(	LDELIM 'else' RDELIM
-			{
-			endRefs.Add(gen.Address()+1);
-			gen.Emit(Bytecode.INSTR_BR, -1); // br end
-			// update previous branch instruction
-			gen.Write(prevBranchOperand, (short)gen.Address());
-			prevBranchOperand = -1;
-			}
-			elementsForIfOnOneLine*
-		)?
-		endif=LDELIM 'endif' RDELIM
-		{
-		if ( prevBranchOperand>=0 ) {
-			gen.Write(prevBranchOperand, (short)gen.Address());
-		}
-        foreach (int opnd in endRefs) gen.Write(opnd, (short)gen.Address());
-		}
-	;
-
-elementsForIfOnOneLine
-	:	exprTag
-	|	text
-	|	ifOnOneLine
-	;
-
-conditional
-	:	andConditional ('||' andConditional {gen.Emit(Bytecode.INSTR_OR);})*
-	;
-
-andConditional
-	:	notConditional ('&&' notConditional {gen.Emit(Bytecode.INSTR_AND);})*
-	;
-
-notConditional
-	:	'!' primary  {gen.Emit(Bytecode.INSTR_NOT);}
-	|	primary
-	;
-
-exprOptions
-	:	{gen.Emit(Bytecode.INSTR_OPTIONS);} option (',' option)*
-	;
-
-option
-	:	ID ( '=' exprNoComma | {DefaultOption($ID);} )
-		{SetOption($ID);}
-	;
-
-exprNoComma
-	:	memberExpr ( ':' templateRef {gen.Emit(Bytecode.INSTR_MAP, $templateRef.start.StartIndex, $templateRef.start.StopIndex);} )?
-	//|	subtemplate {gen.Emit(Bytecode.INSTR_NEW, $subtemplate.name.FullName, $subtemplate.start.StartIndex, $subtemplate.start.StopIndex);}
-	;
-
-expr
-	:	mapExpr
-	//|	// <{...}>
-	//	subtemplate
-	//	{
-	//	var prefixed = PrefixedName($subtemplate.name);
-	//	gen.Emit(Bytecode.INSTR_NEW, prefixed != null ? prefixed.FullName : null, $subtemplate.start.StartIndex, $subtemplate.stop.StopIndex);}
-	;
-
-mapExpr
-@init {int nt=1, ne=1;}
-	:	memberExpr (c=',' memberExpr {ne++;} )*
-		(	':' templateRef
-			(	(',' templateRef {nt++;})+  {gen.Emit(Bytecode.INSTR_ROT_MAP, nt);}
-			|	{if ( $c!=null ) gen.Emit(Bytecode.INSTR_PAR_MAP, ne);
-				 else gen.Emit(Bytecode.INSTR_MAP);}
-			)
-		)*
-	;
-
-memberExpr
-	:	callExpr
-		(	'.' ID {gen.Emit(Bytecode.INSTR_LOAD_PROP, $ID.text, $ID.StartIndex, $ID.StopIndex);}
-		|	'.' lp='(' mapExpr rp=')' {gen.Emit(Bytecode.INSTR_LOAD_PROP_IND, $lp.StartIndex, $rp.StopIndex);}
-		)*
-	;
-
-callExpr
-options {k=2;} // prevent full LL(*), which fails, falling back on k=1; need k=2
-	:	{TemplateCompiler.funcs.ContainsKey(input.LT(1).Text)}?
-		ID '(' expr ')' {Func($ID);}
-	|	(s='super' '.')? ID
-		{
-		var prefixed = PrefixedName(new TemplateName($ID.text));
-		gen.Emit($s!=null?Bytecode.INSTR_SUPER_NEW:Bytecode.INSTR_NEW, prefixed != null ? prefixed.FullName : null, $start.StartIndex, $ID.StopIndex);
-		}
-		'(' args? ')'
-	|	'@' (s='super' '.')? ID '(' rp=')'	// convert <@r()> to <region__enclosingTemplate__r()>
-		{
-		TemplateName mangled = TemplateGroup.GetMangledRegionName(_enclosingTemplateName, $ID.text);
-		gen.DefineBlankRegion(PrefixedName(mangled));
-		var prefixed = PrefixedName(mangled);
-		gen.Emit($s!=null?Bytecode.INSTR_SUPER_NEW:Bytecode.INSTR_NEW, prefixed != null ? prefixed.FullName : null, $start.StartIndex, $rp.StartIndex);
-		}
-	|	primary
-	;
-
-primary
-	:	o=ID		{RefAttr($o);}
-	|	STRING		{gen.Emit(Bytecode.INSTR_LOAD_STR, Misc.Strip($STRING.text,1), $STRING.StartIndex, $STRING.StopIndex);}
-	|	subtemplate	{gen.Emit(Bytecode.INSTR_NEW, $subtemplate.name.FullName, $subtemplate.start.StartIndex, $subtemplate.stop.StopIndex);}
-	|	list
-	|	lp='(' expr rp=')' {gen.Emit(Bytecode.INSTR_TOSTR);}
-		( {gen.Emit(Bytecode.INSTR_NEW_IND, $lp.StartIndex, $rp.StartIndex);} '(' args? ')' )? // indirect call
-	;
-
-args:	arg (',' arg)* ;
-
-arg :	ID '=' exprNoComma {gen.Emit(Bytecode.INSTR_STORE_ATTR, $ID.text, $ID.StartIndex, $exprNoComma.stop.StopIndex);}
-	|	exprNoComma        {gen.Emit(Bytecode.INSTR_STORE_SOLE_ARG, $exprNoComma.start.StartIndex, $exprNoComma.stop.StopIndex);}
-	|	elip='...'		   {gen.Emit(Bytecode.INSTR_SET_PASS_THRU);}
-	;
-
-/**
-expr:template()      apply template to expr
-expr:{arg | ...}     apply subtemplate to expr
-expr:(e)()           convert e to a string template name and apply to expr
-*/
-templateRef
-	:	ID '(' ')'
-		{
-			var prefixed = PrefixedName(new TemplateName($ID.text));
-			gen.Emit(Bytecode.INSTR_LOAD_STR, prefixed != null ? prefixed.FullName : null, $ID.StartIndex, $ID.StopIndex);
-		}
-	|	subtemplate {
-					var prefixed = PrefixedName($subtemplate.name);
-					gen.Emit(Bytecode.INSTR_LOAD_STR, prefixed != null ? prefixed.FullName : null, $subtemplate.start.StartIndex, $subtemplate.start.StopIndex);
-					}
-	|	lp='(' mapExpr rp=')' '(' ')' {gen.Emit(Bytecode.INSTR_TOSTR, $lp.StartIndex, $rp.StartIndex);}
-	;
-
-list:	{gen.Emit(Bytecode.INSTR_LIST);} '[' listElement (',' listElement)* ']'
-	|	{gen.Emit(Bytecode.INSTR_LIST);} '[' ']'
-	;
-
-listElement
-    :   exprNoComma {gen.Emit(Bytecode.INSTR_ADD, $exprNoComma.start.StartIndex, $exprNoComma.stop.StopIndex);}
-    ;
diff --git a/StringTemplate4/Compiler/TemplateParserHelper.cs b/StringTemplate4/Compiler/TemplateParserHelper.cs
deleted file mode 100644
index ba6c005..0000000
--- a/StringTemplate4/Compiler/TemplateParserHelper.cs
+++ /dev/null
@@ -1,204 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate.Compiler
-{
-    using System.Collections.Generic;
-    using Antlr.Runtime;
-    using Console = System.Console;
-    using ArgumentNullException = System.ArgumentNullException;
-
-    partial class TemplateParser
-    {
-        /** The name of the template we are compiling or the name of the
-         *  enclosing template.  This template could be a subtemplate or region of
-         *  an enclosing template.
-         */
-        private TemplateName _enclosingTemplateName;
-
-        private static ICodeGenerator NoopGen = new CodeGenerator();
-        private ICodeGenerator gen = NoopGen;
-
-        public TemplateParser(ITokenStream input, ICodeGenerator gen, TemplateName enclosingTemplateName)
-            : this(input, new RecognizerSharedState(), gen, enclosingTemplateName)
-        {
-        }
-
-        public TemplateParser(ITokenStream input, RecognizerSharedState state, ICodeGenerator gen, TemplateName enclosingTemplateName)
-            : base(null, null) // overcome bug in ANTLR 3.2
-        {
-            this.input = input;
-            this.state = state;
-            if (gen != null)
-                this.gen = gen;
-            this._enclosingTemplateName = enclosingTemplateName;
-        }
-
-        public TemplateName PrefixedName(TemplateName t)
-        {
-            if (t == null)
-                return null;
-
-            return TemplateName.Combine(gen.TemplateReferencePrefix, t);
-        }
-
-        public void RefAttr(IToken id)
-        {
-            string name = id.Text;
-            if (Interpreter.predefinedAttributes.Contains(name))
-            {
-                gen.Emit(Bytecode.INSTR_LOAD_LOCAL, name, id.StartIndex, id.StopIndex);
-            }
-            else
-            {
-                gen.Emit(Bytecode.INSTR_LOAD_ATTR, name, id.StartIndex, id.StopIndex);
-            }
-        }
-
-        public void SetOption(IToken id)
-        {
-            int i;
-            if (!TemplateCompiler.supportedOptions.TryGetValue(id.Text, out i))
-            {
-                ErrorManager.CompileTimeError(ErrorType.NoSuchOption, id);
-                gen.Emit(Bytecode.INSTR_POP, id.StartIndex, id.StopIndex);
-                return;
-            }
-
-            gen.Emit(Bytecode.INSTR_STORE_OPTION, i, id.StartIndex, id.StopIndex);
-        }
-
-        public void DefaultOption(IToken id)
-        {
-            string v;
-            if (!TemplateCompiler.defaultOptionValues.TryGetValue(id.Text, out v))
-            {
-                ErrorManager.CompileTimeError(ErrorType.NoDefaultValue, id);
-                gen.Emit(Bytecode.INSTR_POP, id.StartIndex, id.StopIndex);
-            }
-
-            gen.Emit(Bytecode.INSTR_LOAD_STR, v, id.StartIndex, id.StopIndex);
-        }
-
-        public void Func(IToken id)
-        {
-            short funcBytecode;
-            if (!TemplateCompiler.funcs.TryGetValue(id.Text, out funcBytecode))
-            {
-                ErrorManager.CompileTimeError(ErrorType.NoSuchFunction, id);
-                gen.Emit(Bytecode.INSTR_POP, id.StartIndex, id.StopIndex);
-                return;
-            }
-
-            gen.Emit(funcBytecode, id.StartIndex, id.StopIndex);
-        }
-
-        public void Indent(string indent)
-        {
-            gen.Emit(Bytecode.INSTR_INDENT, indent);
-        }
-
-        protected override object RecoverFromMismatchedToken(IIntStream input, int ttype, BitSet follow)
-        {
-            throw new MismatchedTokenException(ttype, input);
-        }
-
-        /// <summary>
-        /// used to parse w/o compilation side-effects
-        /// </summary>
-        private sealed class CodeGenerator : ICodeGenerator
-        {
-            public TemplateName TemplateReferencePrefix
-            {
-                get
-                {
-                    return null;
-                }
-            }
-
-            public void Emit(short opcode)
-            {
-            }
-
-            public void Emit(short opcode, int startIndex, int stopIndex)
-            {
-            }
-
-            public void Emit(short opcode, int arg)
-            {
-            }
-
-            public void Emit(short opcode, int arg, int startIndex, int stopIndex)
-            {
-            }
-
-            public void Emit(short opcode, int arg1, int arg2, int startIndex, int stopIndex)
-            {
-            }
-
-            public void Emit(short opcode, string s)
-            {
-            }
-
-            public void Emit(short opcode, string s, int startIndex, int stopIndex)
-            {
-            }
-
-            public void Write(int addr, short value)
-            {
-            }
-
-            public int Address()
-            {
-                return 0;
-            }
-
-            public TemplateName CompileAnonTemplate(TemplateName enclosingTemplateName, ITokenStream input, IList<IToken> ids, RecognizerSharedState state)
-            {
-                TemplateCompiler c = new TemplateCompiler();
-                c.Compile(input, state);
-                return null;
-            }
-
-            public TemplateName CompileRegion(TemplateName enclosingTemplateName, string regionName, ITokenStream input, RecognizerSharedState state)
-            {
-                TemplateCompiler c = new TemplateCompiler();
-                c.Compile(input, state);
-                return null;
-            }
-
-            public void DefineBlankRegion(TemplateName fullyQualifiedName)
-            {
-            }
-        }
-    }
-}
diff --git a/StringTemplate4/Coordinate.cs b/StringTemplate4/Coordinate.cs
deleted file mode 100644
index 91e39c8..0000000
--- a/StringTemplate4/Coordinate.cs
+++ /dev/null
@@ -1,84 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate
-{
-    public struct Coordinate
-    {
-        public Coordinate(int line, int charPosition)
-            : this()
-        {
-            this.Line = line;
-            this.CharPosition = charPosition;
-        }
-
-        public int Line
-        {
-            get;
-            private set;
-        }
-
-        public int CharPosition
-        {
-            get;
-            private set;
-        }
-
-        public static bool operator ==(Coordinate x, Coordinate y)
-        {
-            return x.Line == y.Line && x.CharPosition == y.CharPosition;
-        }
-
-        public static bool operator !=(Coordinate x, Coordinate y)
-        {
-            return !(x == y);
-        }
-
-        public override bool Equals(object obj)
-        {
-            if (!(obj is Coordinate))
-                return false;
-
-            return this == (Coordinate)obj;
-        }
-
-        public override int GetHashCode()
-        {
-            return Line ^ CharPosition;
-        }
-
-        public override string ToString()
-        {
-            return Line.ToString() + ":" + CharPosition.ToString();
-        }
-    }
-}
diff --git a/StringTemplate4/DateTimeRenderer.cs b/StringTemplate4/DateTimeRenderer.cs
deleted file mode 100644
index 79899ca..0000000
--- a/StringTemplate4/DateTimeRenderer.cs
+++ /dev/null
@@ -1,72 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate
-{
-    using System.Collections.Generic;
-    using CultureInfo = System.Globalization.CultureInfo;
-    using DateTime = System.DateTime;
-
-    public class DateTimeRenderer : IAttributeRenderer
-    {
-        private static readonly IDictionary<string, string> StandardFormats =
-            new Dictionary<string, string>()
-            {
-                {"short", "g"},
-                {"medium", "G"},
-                {"long", "f"},
-                {"full", "F"},
-
-                {"date:short", "d"},
-                {"date:medium", "d"},
-                {"date:long", "D"},
-                {"date:full", ""},
-
-                {"time:short", "t"},
-                {"time:medium", "T"},
-                {"time:long", "T"},
-                {"time:full", "T"},
-            };
-
-        public string ToString(object o, string formatString, CultureInfo culture)
-        {
-            DateTime d = (DateTime)o;
-            formatString = formatString ?? "short";
-
-            string format;
-            if (!StandardFormats.TryGetValue(formatString, out format))
-                format = formatString;
-
-            return d.ToString(format, culture);
-        }
-    }
-}
diff --git a/StringTemplate4/Debug/AddAttributeEvent.cs b/StringTemplate4/Debug/AddAttributeEvent.cs
deleted file mode 100644
index 467fd70..0000000
--- a/StringTemplate4/Debug/AddAttributeEvent.cs
+++ /dev/null
@@ -1,51 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate.Debug
-{
-    public class AddAttributeEvent : ConstructionEvent
-    {
-        private string name;
-        private object value; // unused really; leave for future
-
-        public AddAttributeEvent(string name, object value)
-        {
-            this.name = name;
-            this.value = value;
-        }
-
-        public override string ToString()
-        {
-            return string.Format("{0}{{name='{1}',value='{2}',location={3}:{4}}}", GetType().Name, name, value, FileName, Line);
-        }
-    }
-}
diff --git a/StringTemplate4/Debug/ConstructionEvent.cs b/StringTemplate4/Debug/ConstructionEvent.cs
deleted file mode 100644
index dd7ad26..0000000
--- a/StringTemplate4/Debug/ConstructionEvent.cs
+++ /dev/null
@@ -1,99 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate
-{
-    using System.Diagnostics;
-
-    public class ConstructionEvent
-    {
-        private readonly StackTrace stack;
-
-        public ConstructionEvent()
-        {
-            this.stack = new StackTrace(true);
-        }
-
-        public string FileName
-        {
-            get
-            {
-                var entry = TemplateEntryPoint;
-                if (entry == null)
-                    return string.Empty;
-
-                return entry.GetFileName();
-            }
-        }
-
-        public int Line
-        {
-            get
-            {
-                var entry = TemplateEntryPoint;
-                if (entry == null)
-                    return 0;
-
-                return entry.GetFileLineNumber();
-            }
-        }
-
-        public StackFrame TemplateEntryPoint
-        {
-            get
-            {
-                var frames = stack.GetFrames();
-                if (frames == null || frames.Length == 0)
-                    return null;
-
-                foreach (var frame in frames)
-                {
-                    var method = frame.GetMethod();
-                    if (method == null)
-                        continue;
-
-                    if (method.Name == "Main")
-                        return frame;
-
-                    var ns = method.DeclaringType.Namespace;
-                    if (ns == null)
-                        return frame;
-
-                    if (!ns.StartsWith("StringTemplate"))
-                        return frame;
-                }
-
-                return frames[0];
-            }
-        }
-    }
-}
diff --git a/StringTemplate4/Debug/DebugTemplate.cs b/StringTemplate4/Debug/DebugTemplate.cs
deleted file mode 100644
index 854bb72..0000000
--- a/StringTemplate4/Debug/DebugTemplate.cs
+++ /dev/null
@@ -1,108 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate.Debug
-{
-    using System.Collections.Generic;
-    using CultureInfo = System.Globalization.CultureInfo;
-    using StringWriter = System.IO.StringWriter;
-
-    public class DebugTemplate : Template
-    {
-        public DebugTemplate()
-        {
-            this.InterpreterEvents = new List<InterpEvent>();
-            this.AddAttributeEvents = new Dictionary<string, ICollection<AddAttributeEvent>>();
-            this.TemplateConstructionEvent = new ConstructionEvent();
-        }
-
-        public IList<InterpEvent> InterpreterEvents
-        {
-            get;
-            private set;
-        }
-
-        public IDictionary<string, ICollection<AddAttributeEvent>> AddAttributeEvents
-        {
-            get;
-            private set;
-        }
-
-        public ConstructionEvent TemplateConstructionEvent
-        {
-            get;
-            private set;
-        }
-
-        public override void Add(string name, object value)
-        {
-            if (groupThatCreatedThisInstance.Debug)
-            {
-                ICollection<AddAttributeEvent> collection;
-                if (!AddAttributeEvents.TryGetValue(name, out collection))
-                {
-                    collection = new List<AddAttributeEvent>();
-                    AddAttributeEvents[name] = collection;
-                }
-
-                collection.Add(new AddAttributeEvent(name, value));
-            }
-
-            base.Add(name, value);
-        }
-
-        public IList<InterpEvent> GetEvents()
-        {
-            return GetEvents(CultureInfo.CurrentCulture, AutoIndentWriter.NoWrap);
-        }
-
-        public IList<InterpEvent> GetEvents(int lineWidth)
-        {
-            return GetEvents(CultureInfo.CurrentCulture, lineWidth);
-        }
-
-        public IList<InterpEvent> GetEvents(CultureInfo culture)
-        {
-            return GetEvents(CultureInfo.CurrentCulture, AutoIndentWriter.NoWrap);
-        }
-
-        public IList<InterpEvent> GetEvents(CultureInfo culture, int lineWidth)
-        {
-            StringWriter stream = new StringWriter();
-            ITemplateWriter writer = new AutoIndentWriter(stream);
-            writer.SetLineWidth(lineWidth);
-            Interpreter interp = new Interpreter(groupThatCreatedThisInstance, culture);
-            interp.Exec(writer, this);
-            return interp.Events;
-        }
-    }
-}
diff --git a/StringTemplate4/Debug/EvalExprEvent.cs b/StringTemplate4/Debug/EvalExprEvent.cs
deleted file mode 100644
index 4e5822a..0000000
--- a/StringTemplate4/Debug/EvalExprEvent.cs
+++ /dev/null
@@ -1,60 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate.Debug
-{
-    using ArgumentNullException = System.ArgumentNullException;
-
-    public class EvalExprEvent : InterpEvent
-    {
-        int exprStart;
-        int exprStop; // template pattern location
-        string expr;
-
-        public EvalExprEvent(DebugTemplate self, int start, int stop, int exprStart, int exprStop)
-            : base(self, start, stop)
-        {
-            if (self == null)
-                throw new ArgumentNullException("self");
-
-            this.exprStart = exprStart;
-            this.exprStop = exprStop;
-            expr = self.code.template.Substring(exprStart, exprStop - exprStart + 1);
-        }
-
-        public override string ToString()
-        {
-            return string.Format("{0}{{self={1},start={2},stop={3},expr={4}}}", GetType().Name, Template, Start, Stop, expr);
-
-        }
-    }
-}
diff --git a/StringTemplate4/Debug/EvalTemplateEvent.cs b/StringTemplate4/Debug/EvalTemplateEvent.cs
deleted file mode 100644
index 9ac0499..0000000
--- a/StringTemplate4/Debug/EvalTemplateEvent.cs
+++ /dev/null
@@ -1,42 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate.Debug
-{
-    public class EvalTemplateEvent : InterpEvent
-    {
-        public EvalTemplateEvent(DebugTemplate template, int start, int stop)
-            : base(template, start, stop)
-        {
-        }
-    }
-}
diff --git a/StringTemplate4/Debug/InterpEvent.cs b/StringTemplate4/Debug/InterpEvent.cs
deleted file mode 100644
index 168d074..0000000
--- a/StringTemplate4/Debug/InterpEvent.cs
+++ /dev/null
@@ -1,75 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate.Debug
-{
-    using ArgumentException = System.ArgumentException;
-    using ArgumentNullException = System.ArgumentNullException;
-
-    public class InterpEvent
-    {
-        public InterpEvent(DebugTemplate template, int start, int stop)
-        {
-            if (template == null)
-                throw new ArgumentNullException("template");
-            if (start > stop)
-                throw new ArgumentException();
-
-            this.Template = template;
-            this.Start = start;
-            this.Stop = stop;
-        }
-
-        public Template Template
-        {
-            get;
-            private set;
-        }
-
-        public int Start
-        {
-            get;
-            private set;
-        }
-
-        public int Stop
-        {
-            get;
-            private set;
-        }
-
-        public override string ToString()
-        {
-            return string.Format("{0}{{self={1},start={2},stop={3}}}", GetType().Name, Template, Start, Stop);
-        }
-    }
-}
diff --git a/StringTemplate4/ErrorBuffer.cs b/StringTemplate4/ErrorBuffer.cs
deleted file mode 100644
index e65589b..0000000
--- a/StringTemplate4/ErrorBuffer.cs
+++ /dev/null
@@ -1,40 +0,0 @@
-﻿namespace StringTemplate
-{
-    using System.Collections.Generic;
-    using StringBuilder = System.Text.StringBuilder;
-
-    public class ErrorBuffer : ITemplateErrorListener
-    {
-        private List<TemplateMessage> errors = new List<TemplateMessage>();
-
-        public void CompileTimeError(TemplateMessage msg)
-        {
-            errors.Add(msg);
-        }
-
-        public void RuntimeError(TemplateMessage msg)
-        {
-            errors.Add(msg);
-        }
-
-        public void IOError(TemplateMessage msg)
-        {
-            errors.Add(msg);
-        }
-
-        public void InternalError(TemplateMessage msg)
-        {
-            errors.Add(msg);
-        }
-
-        public override string ToString()
-        {
-            StringBuilder buf = new StringBuilder();
-            foreach (TemplateMessage m in errors)
-            {
-                buf.AppendLine(m.ToString());
-            }
-            return buf.ToString();
-        }
-    }
-}
diff --git a/StringTemplate4/ErrorManager.cs b/StringTemplate4/ErrorManager.cs
deleted file mode 100644
index 8ee91e7..0000000
--- a/StringTemplate4/ErrorManager.cs
+++ /dev/null
@@ -1,218 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate
-{
-    using Console = System.Console;
-    using Exception = System.Exception;
-    using IOException = System.IO.IOException;
-    using ThreadStatic = System.ThreadStaticAttribute;
-    using StringTemplate.Compiler;
-    using Type = System.Type;
-    using Antlr.Runtime;
-
-    public static class ErrorManager
-    {
-        public static readonly ITemplateErrorListener DefaultErrorListener = new DefaultErrorListenerImpl();
-
-        [ThreadStatic]
-        private static ITemplateErrorListener listener;
-
-        /** Backward compatibility for tombu, co-designer.  Don't check missing
-         *  args against formal arg lists and don't require template headers in .st
-         *  files.
-         */
-        public static bool CompatibilityMode
-        {
-            get;
-            set;
-        }
-
-        public static ITemplateErrorListener ErrorListener
-        {
-            get
-            {
-                return listener ?? DefaultErrorListener;
-            }
-            set
-            {
-                listener = value;
-            }
-        }
-
-        private static Type[] CriticalExceptions =
-            {
-                typeof(System.StackOverflowException),
-                typeof(System.OutOfMemoryException),
-                typeof(System.Threading.ThreadAbortException),
-                typeof(System.Runtime.InteropServices.SEHException),
-                typeof(System.Security.SecurityException),
-                typeof(System.ExecutionEngineException),
-                typeof(System.AccessViolationException),
-                typeof(System.BadImageFormatException),
-                typeof(System.AppDomainUnloadedException),
-            };
-
-        public static bool IsCriticalException(Exception ex)
-        {
-            if (ex == null)
-                return false;
-
-            var exceptionType = ex.GetType();
-            foreach (Type t in CriticalExceptions)
-            {
-                if (t.IsAssignableFrom(exceptionType))
-                    return true;
-            }
-
-            return false;
-        }
-
-        public static void CompileTimeError(ErrorType error, IToken t)
-        {
-            ErrorListener.CompileTimeError(new TemplateCompileTimeMessage(error, t, null, t.Text));
-        }
-
-        public static void CompileTimeError(ErrorType error, object arg)
-        {
-            ErrorListener.CompileTimeError(new TemplateCompileTimeMessage(error, null, null, arg));
-        }
-
-        public static void CompileTimeError(ErrorType error, IToken t, object arg)
-        {
-            ErrorListener.CompileTimeError(new TemplateCompileTimeMessage(error, t, null, arg));
-        }
-
-#if false
-        public static void CompileTimeError(ErrorType error, object arg1, object arg2)
-        {
-            ErrorListener.CompileTimeError(new TemplateMessage(error, null, null, arg1, arg2));
-        }
-#endif
-
-        public static void SyntaxError(ErrorType error, RecognitionException e, string msg)
-        {
-            ErrorListener.CompileTimeError(new TemplateSyntaxErrorMessage(error, e.Token, e, msg));
-        }
-
-        public static void SyntaxError(ErrorType error, RecognitionException e, string msg, object arg)
-        {
-            ErrorListener.CompileTimeError(new TemplateSyntaxErrorMessage(error, e.Token, e, msg, arg));
-        }
-
-        public static void RuntimeError(Template template, int ip, ErrorType error)
-        {
-            ErrorListener.RuntimeError(new TemplateRuntimeMessage(error, ip, template));
-        }
-
-        public static void RuntimeError(Template template, int ip, ErrorType error, object arg)
-        {
-            ErrorListener.RuntimeError(new TemplateRuntimeMessage(error, ip, template, null, arg));
-        }
-
-        public static void RuntimeError(Template template, int ip, ErrorType error, Exception source, object arg)
-        {
-            ErrorListener.RuntimeError(new TemplateRuntimeMessage(error, ip, template, source, arg));
-        }
-
-        public static void RuntimeError(Template template, int ip, ErrorType error, object arg1, object arg2)
-        {
-            ErrorListener.RuntimeError(new TemplateRuntimeMessage(error, ip, template, null, arg1, arg2));
-        }
-
-        public static void IOError(Template template, ErrorType error, Exception source)
-        {
-            ErrorListener.IOError(new TemplateMessage(error, template, source));
-        }
-
-        public static void IOError(Template template, ErrorType error, Exception source, object arg)
-        {
-            ErrorListener.IOError(new TemplateMessage(error, template, source, arg));
-        }
-
-        public static void InternalError(Template template, ErrorType error, Exception source)
-        {
-            ErrorListener.InternalError(new TemplateMessage(error, template, source));
-        }
-
-        public static void InternalError(Template template, ErrorType error, Exception source, object arg)
-        {
-            ErrorListener.InternalError(new TemplateMessage(error, template, source, arg));
-        }
-
-        public static void InternalError(Template template, ErrorType error, Exception source, object arg1, object arg2)
-        {
-            ErrorListener.InternalError(new TemplateMessage(error, template, source, arg1, arg2));
-        }
-
-        private class DefaultErrorListenerImpl : ITemplateErrorListener
-        {
-            public void CompileTimeError(TemplateMessage message)
-            {
-                Console.Error.WriteLine(message);
-            }
-
-            public void RuntimeError(TemplateMessage message)
-            {
-                Console.Error.WriteLine(message);
-            }
-
-            public void IOError(TemplateMessage message)
-            {
-                throw new IOException(message.Message, message.Source);
-            }
-
-            public void InternalError(TemplateMessage message)
-            {
-                throw new TemplateException(message.Message, message.Source);
-            }
-
-            // TODO: put in [root ... template] stack
-            public void Error(string message, Exception e)
-            {
-                Console.Error.WriteLine(message);
-                if (e != null)
-                    Console.Error.WriteLine(e.StackTrace);
-            }
-
-            public void Error(string message)
-            {
-                Error(message, null);
-            }
-
-            public void Warning(string message)
-            {
-                Console.WriteLine(message);
-            }
-        }
-    }
-}
diff --git a/StringTemplate4/ErrorType.cs b/StringTemplate4/ErrorType.cs
deleted file mode 100644
index 66bb215..0000000
--- a/StringTemplate4/ErrorType.cs
+++ /dev/null
@@ -1,79 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate
-{
-    public sealed class ErrorType
-    {
-        // RUNTIME SEMANTIC ERRORS
-        public static readonly ErrorType NoSuchTemplate = new ErrorType("no such template: {0}");
-        public static readonly ErrorType CantSetAttribute = new ErrorType("can't set attribute {0}; template {1} has no such attribute");
-        public static readonly ErrorType NoImportedTemplate = new ErrorType("no such template: super.{0}");
-        public static readonly ErrorType NO_ATTRIBUTE_DEFINITION = new ErrorType("attribute {0} isn't defined");
-        public static readonly ErrorType ExpectingSingleArgument = new ErrorType("expecting single arg in template reference {0} (not {1} args)");
-        public static readonly ErrorType MissingFormalArguments = new ErrorType("missing argument definitions");
-        public static readonly ErrorType ArgumentCountMismatch = new ErrorType("iterating through {0} arguments but parallel map has {1} formal arguments");
-        public static readonly ErrorType ExpectingString = new ErrorType("function {0} expects a string not {1}");
-
-        // COMPILE-TIME SYNTAX/SEMANTIC ERRORS
-        public static readonly ErrorType SyntaxError = new ErrorType("{0}");
-        public static readonly ErrorType TemplateRedefinition = new ErrorType("redefinition of template {0}");
-        public static readonly ErrorType EmbeddedRegionRedefinition = new ErrorType("region {0} is embedded and thus already implicitly defined");
-        public static readonly ErrorType RegionRedefinition = new ErrorType("redefinition of region {0}");
-        public static readonly ErrorType MapRedefinition = new ErrorType("redefinition of dictionary {0}");
-        public static readonly ErrorType AliasTargetUndefined = new ErrorType("cannot alias {0} to undefined template: {1}");
-        public static readonly ErrorType TemplateRedefinitionAsMap = new ErrorType("redefinition of template {0} as a map");
-        public static readonly ErrorType LexerError = new ErrorType("lexer there are add character {0}");
-        public static readonly ErrorType NoDefaultValue = new ErrorType("missing dictionary default value");
-        public static readonly ErrorType NoSuchFunction = new ErrorType("no such function: {0}");
-        public static readonly ErrorType NoSuchOption = new ErrorType("no such option: {0}");
-
-        // IO ERRORS
-        public static readonly ErrorType WriteIoError = new ErrorType("error writing output caused by");
-        public static readonly ErrorType CantLoadGroupFile = new ErrorType("can't load group file {0}");
-        public static readonly ErrorType CantLoadTemplateFile = new ErrorType("can't load template file {0}");
-        public static readonly ErrorType InvalidBytecode = new ErrorType("invalid bytecode {0} at IP {1}");
-
-        public static readonly ErrorType GuiError = new ErrorType("GUI error");
-
-        private ErrorType(string messageFormat)
-        {
-            this.MessageFormat = messageFormat;
-        }
-
-        public string MessageFormat
-        {
-            get;
-            private set;
-        }
-    }
-}
diff --git a/StringTemplate4/IAttributeRenderer.cs b/StringTemplate4/IAttributeRenderer.cs
deleted file mode 100644
index a866e21..0000000
--- a/StringTemplate4/IAttributeRenderer.cs
+++ /dev/null
@@ -1,50 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate
-{
-    using CultureInfo = System.Globalization.CultureInfo;
-
-    /** This interface describes an object that knows how to format or otherwise
-     *  render an object appropriately.  There is one renderer registered per
-     *  group for a given Java type.
-     *
-     *  If the format string passed to the renderer is not recognized then simply
-     *  call toString().
-     *
-     *  formatString can be null but locale will at least be Locale.getDefault()
-     */
-    public interface IAttributeRenderer
-    {
-        string ToString(object o, string formatString, CultureInfo culture);
-    }
-}
diff --git a/StringTemplate4/ITemplateErrorListener.cs b/StringTemplate4/ITemplateErrorListener.cs
deleted file mode 100644
index f9e1f50..0000000
--- a/StringTemplate4/ITemplateErrorListener.cs
+++ /dev/null
@@ -1,44 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate
-{
-    using Exception = System.Exception;
-
-    public interface ITemplateErrorListener
-    {
-        void CompileTimeError(TemplateMessage message);
-        void RuntimeError(TemplateMessage message);
-        void IOError(TemplateMessage message);
-        void InternalError(TemplateMessage message);
-    }
-}
diff --git a/StringTemplate4/ITemplateWriter.cs b/StringTemplate4/ITemplateWriter.cs
deleted file mode 100644
index 7a61cf1..0000000
--- a/StringTemplate4/ITemplateWriter.cs
+++ /dev/null
@@ -1,86 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate
-{
-    public interface ITemplateWriter
-    {
-        /// <summary>
-        /// Get the absolute char index into the output of the char we're about to write.
-        /// Returns 0 if no char written yet.
-        /// </summary>
-        int Index
-        {
-            get;
-        }
-
-        void PushIndentation(string indent);
-
-        string PopIndentation();
-
-        void PushAnchorPoint();
-
-        void PopAnchorPoint();
-
-        void SetLineWidth(int lineWidth);
-
-        /** Write the string and return how many actual chars were written.
-         *  With autoindentation and wrapping, more chars than length(str)
-         *  can be emitted.  No wrapping is done.
-         */
-        int Write(string str);
-
-        /** Same as write, but wrap lines using the indicated string as the
-         *  wrap character (such as "\n").
-         */
-        int Write(string str, string wrap);
-
-        /** Because we evaluate ST instance by invoking exec() again, we
-         *  can't pass options in.  So the WRITE instruction of an applied
-         *  template (such as when we wrap in between template applications
-         *  like &lt;data:{v|[&lt;v&gt;]}; wrap&gt;) we need to write the wrap string
-         *  before calling exec().  We expose just like for the separator.
-         *  See Interpreter.writeObject where it checks for ST instance.
-         *  If POJO, writePOJO passes wrap to STWriter's
-         *
-         *     write(String str, String wrap)
-         *
-         *  method.  Can't pass to exec().
-         */
-        int WriteWrap(string wrap);
-
-        /** Write a separator.  Same as write() except that a \n cannot
-         *  be inserted before emitting a separator.
-         */
-        int WriteSeparator(string str);
-    }
-}
diff --git a/StringTemplate4/Interpreter.cs b/StringTemplate4/Interpreter.cs
deleted file mode 100644
index 9f0187b..0000000
--- a/StringTemplate4/Interpreter.cs
+++ /dev/null
@@ -1,1258 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate
-{
-    using System.Collections.Generic;
-    using System.Linq;
-    using StringTemplate.Compiler;
-    using StringTemplate.Debug;
-    using Array = System.Array;
-    using ArrayList = System.Collections.ArrayList;
-    using Console = System.Console;
-    using CultureInfo = System.Globalization.CultureInfo;
-    using Environment = System.Environment;
-    using Exception = System.Exception;
-    using FieldInfo = System.Reflection.FieldInfo;
-    using ICollection = System.Collections.ICollection;
-    using IDictionary = System.Collections.IDictionary;
-    using IList = System.Collections.IList;
-    using IOException = System.IO.IOException;
-    using Iterator = System.Collections.IEnumerator;
-    using Math = System.Math;
-    using MethodInfo = System.Reflection.MethodInfo;
-    using StringBuilder = System.Text.StringBuilder;
-    using StringWriter = System.IO.StringWriter;
-    using Type = System.Type;
-
-    public class Interpreter
-    {
-        // TODO: enum?
-        public static readonly int OPTION_ANCHOR = 0;
-        public static readonly int OPTION_FORMAT = 1;
-        public static readonly int OPTION_NULL = 2;
-        public static readonly int OPTION_SEPARATOR = 3;
-        public static readonly int OPTION_WRAP = 4;
-
-        public static readonly int DEFAULT_OPERAND_STACK_SIZE = 100;
-
-        public static readonly HashSet<string> predefinedAttributes =
-            new HashSet<string>()
-        {
-            "it",
-            "i",
-            "i0"
-        };
-
-        /** Operand stack, grows upwards */
-        object[] operands = new object[DEFAULT_OPERAND_STACK_SIZE];
-        int sp = -1;  // stack pointer register
-        int current_ip = 0;
-        int nw = 0;   // how many char written on this template line so far? ("number written" register)
-
-        /** Exec st with respect to this group. Once set in Template.toString(),
-         *  it should be fixed.  Template has group also.
-         */
-        TemplateGroup group;
-
-        CultureInfo culture;
-
-        public bool trace = false;
-
-        /// <summary>
-        /// Track everything happening in interp if debug
-        /// </summary>
-        protected internal IList<InterpEvent> events;
-
-        public Interpreter(TemplateGroup group)
-            : this(group, CultureInfo.CurrentCulture)
-        {
-        }
-
-        // TODO: remove out and move back to exec; must avoid creating new interp when deugging same st tree
-        public Interpreter(TemplateGroup group, CultureInfo culture)
-        {
-            this.group = group;
-            this.culture = culture;
-            if (group.Debug)
-            {
-                events = new List<InterpEvent>();
-            }
-        }
-
-        public IList<InterpEvent> Events
-        {
-            get
-            {
-                return events;
-            }
-        }
-
-        public int Exec(ITemplateWriter @out, Template self)
-        {
-            int start = @out.Index; // track char we're about to write
-            int prevOpcode = 0;
-            int n = 0; // how many char we write out
-            int nameIndex = 0;
-            int addr = 0;
-            string name = null;
-            object o = null, left = null, right = null;
-            Template st = null;
-            object[] options = null;
-            byte[] code = self.code.instrs;        // which code block are we executing
-            int ip = 0;
-            while (ip < self.code.codeSize)
-            {
-                if (trace)
-                    Trace(self, ip);
-                short opcode = code[ip];
-                current_ip = ip;
-                ip++; //jump to next instruction or first byte of operand
-                switch (opcode)
-                {
-                case Bytecode.INSTR_LOAD_STR:
-                    int strIndex = GetShort(code, ip);
-                    ip += 2;
-                    operands[++sp] = self.code.strings[strIndex];
-                    break;
-                case Bytecode.INSTR_LOAD_ATTR:
-                    nameIndex = GetShort(code, ip);
-                    ip += 2;
-                    name = self.code.strings[nameIndex];
-                    o = self.GetAttribute(name);
-                    operands[++sp] = o;
-                    if (o == null)
-                        CheckNullAttributeAgainstFormalArguments(self, name);
-                    break;
-                case Bytecode.INSTR_LOAD_LOCAL:
-                    nameIndex = GetShort(code, ip);
-                    ip += 2;
-                    name = self.code.strings[nameIndex];
-                    if (self.attributes == null || !self.attributes.TryGetValue(name, out o))
-                        o = null;
-                    operands[++sp] = o;
-                    break;
-                case Bytecode.INSTR_LOAD_PROP:
-                    nameIndex = GetShort(code, ip);
-                    ip += 2;
-                    o = operands[sp--];
-                    name = self.code.strings[nameIndex];
-                    operands[++sp] = GetObjectProperty(self, o, name);
-                    break;
-                case Bytecode.INSTR_LOAD_PROP_IND:
-                    object propName = operands[sp--];
-                    o = operands[sp];
-                    operands[sp] = GetObjectProperty(self, o, propName);
-                    break;
-                case Bytecode.INSTR_NEW:
-                    nameIndex = GetShort(code, ip);
-                    ip += 2;
-                    name = self.code.strings[nameIndex];
-                    st = group.GetEmbeddedInstanceOf(self, ip, new TemplateName(name));
-                    if (st == null)
-                    {
-                        ErrorManager.RuntimeError(self, current_ip, ErrorType.NoSuchTemplate, new TemplateName(name).Name);
-                        st = Template.Blank;
-                    }
-                    operands[++sp] = st;
-                    break;
-                case Bytecode.INSTR_NEW_IND:
-                    name = (string)operands[sp--];
-                    st = group.GetEmbeddedInstanceOf(self, ip, new TemplateName(name));
-                    if (st == null)
-                    {
-                        ErrorManager.RuntimeError(self, current_ip, ErrorType.NoSuchTemplate, new TemplateName(name).Name);
-                        st = Template.Blank;
-                    }
-                    operands[++sp] = st;
-                    break;
-                case Bytecode.INSTR_SUPER_NEW:
-                    nameIndex = GetShort(code, ip);
-                    ip += 2;
-                    name = self.code.strings[nameIndex];
-                    CompiledTemplate imported = group.LookupImportedTemplate(new TemplateName(name));
-                    if (imported == null)
-                    {
-                        ErrorManager.RuntimeError(self, current_ip, ErrorType.NoImportedTemplate, new TemplateName(name).Name);
-                        operands[++sp] = Template.Blank;
-                        break;
-                    }
-                    // TODO: factor into STGroup
-                    st = imported.nativeGroup.CreateStringTemplate();
-                    st.groupThatCreatedThisInstance = group;
-                    st.code = imported;
-                    operands[++sp] = st;
-                    break;
-                case Bytecode.INSTR_STORE_ATTR:
-                    nameIndex = GetShort(code, ip);
-                    name = self.code.strings[nameIndex];
-                    ip += 2;
-                    o = operands[sp--];    // value to store
-                    st = (Template)operands[sp]; // store arg in Template on top of stack
-                    st.CheckAttributeExists(name);
-                    st.RawSetAttribute(name, o);
-                    break;
-                case Bytecode.INSTR_STORE_SOLE_ARG:
-                    // unnamed arg, set to sole arg (or first if multiple)
-                    o = operands[sp--];    // value to store
-                    st = (Template)operands[sp]; // store arg in Template on top of stack
-                    SetSoleArgument(self, st, o);
-                    break;
-                case Bytecode.INSTR_SET_PASS_THRU:
-                    st = (Template)operands[sp]; // Template on top of stack
-                    st.passThroughAttributes = true;
-                    break;
-                case Bytecode.INSTR_STORE_OPTION:
-                    int optionIndex = GetShort(code, ip);
-                    ip += 2;
-                    o = operands[sp--];    // value to store
-                    options = (object[])operands[sp]; // get options
-                    options[optionIndex] = o; // store value into options on stack
-                    break;
-                case Bytecode.INSTR_WRITE:
-                    o = operands[sp--];
-                    nw = WriteObjectNoOptions(@out, self, o);
-                    n += nw;
-                    break;
-                case Bytecode.INSTR_WRITE_OPT:
-                    options = (object[])operands[sp--]; // get options
-                    o = operands[sp--];                 // get option to write
-                    nw = WriteObjectWithOptions(@out, self, o, options);
-                    n += nw;
-                    break;
-                case Bytecode.INSTR_MAP:
-                    name = (string)operands[sp--];
-                    o = operands[sp--];
-                    Map(self, o, new TemplateName(name));
-                    break;
-                case Bytecode.INSTR_ROT_MAP:
-                    int nmaps = GetShort(code, ip);
-                    ip += 2;
-                    List<TemplateName> templates = new List<TemplateName>();
-                    for (int i = nmaps - 1; i >= 0; i--)
-                        templates.Add(new TemplateName((string)operands[sp - i]));
-                    sp -= nmaps;
-                    o = operands[sp--];
-                    if (o != null)
-                        Rot_map(self, o, templates);
-                    break;
-                case Bytecode.INSTR_PAR_MAP:
-                    name = (string)operands[sp--];
-                    nmaps = GetShort(code, ip);
-                    ip += 2;
-                    List<object> exprs = new List<object>();
-                    for (int i = nmaps - 1; i >= 0; i--)
-                        exprs.Add(operands[sp - i]);
-                    sp -= nmaps;
-                    operands[++sp] = Par_map(self, exprs, new TemplateName(name));
-                    break;
-                case Bytecode.INSTR_BR:
-                    ip = GetShort(code, ip);
-                    break;
-                case Bytecode.INSTR_BRF:
-                    addr = GetShort(code, ip);
-                    ip += 2;
-                    o = operands[sp--]; // <if(expr)>...<endif>
-                    if (!TestAttributeTrue(o))
-                        ip = addr; // jump
-                    break;
-                case Bytecode.INSTR_OPTIONS:
-                    operands[++sp] = new object[TemplateCompiler.NUM_OPTIONS];
-                    break;
-                case Bytecode.INSTR_LIST:
-                    operands[++sp] = new List<object>();
-                    break;
-                case Bytecode.INSTR_ADD:
-                    o = operands[sp--];             // pop value
-                    List<object> list = (List<object>)operands[sp]; // don't pop list
-                    AddToList(list, o);
-                    break;
-                case Bytecode.INSTR_TOSTR:
-                    // replace with string value; early eval
-                    operands[sp] = ToString(self, operands[sp]);
-                    break;
-                case Bytecode.INSTR_FIRST:
-                    operands[sp] = First(operands[sp]);
-                    break;
-                case Bytecode.INSTR_LAST:
-                    operands[sp] = Last(operands[sp]);
-                    break;
-                case Bytecode.INSTR_REST:
-                    operands[sp] = Rest(operands[sp]);
-                    break;
-                case Bytecode.INSTR_TRUNC:
-                    operands[sp] = Trunc(operands[sp]);
-                    break;
-                case Bytecode.INSTR_STRIP:
-                    operands[sp] = Strip(operands[sp]); // TODO: should strip work on strings?
-                    break;
-                case Bytecode.INSTR_TRIM:
-                    o = operands[sp--];
-                    if (o.GetType() == typeof(string))
-                    {
-                        operands[++sp] = ((string)o).Trim();
-                    }
-                    else
-                    {
-                        ErrorManager.RuntimeError(self, current_ip, ErrorType.ExpectingString, "trim", o.GetType().FullName);
-                        operands[++sp] = o;
-                    }
-                    break;
-                case Bytecode.INSTR_LENGTH:
-                    operands[sp] = Length(operands[sp]);
-                    break;
-                case Bytecode.INSTR_STRLEN:
-                    o = operands[sp--];
-                    if (o.GetType() == typeof(string))
-                    {
-                        operands[++sp] = ((string)o).Length;
-                    }
-                    else
-                    {
-                        ErrorManager.RuntimeError(self, current_ip, ErrorType.ExpectingString, "strlen", o.GetType().FullName);
-                        operands[++sp] = 0;
-                    }
-                    break;
-                case Bytecode.INSTR_REVERSE:
-                    operands[sp] = Reverse(operands[sp]);
-                    break;
-                case Bytecode.INSTR_NOT:
-                    operands[sp] = !TestAttributeTrue(operands[sp]);
-                    break;
-                case Bytecode.INSTR_OR:
-                    right = operands[sp--];
-                    left = operands[sp--];
-                    operands[++sp] = TestAttributeTrue(left) || TestAttributeTrue(right);
-                    break;
-                case Bytecode.INSTR_AND:
-                    right = operands[sp--];
-                    left = operands[sp--];
-                    operands[++sp] = TestAttributeTrue(left) && TestAttributeTrue(right);
-                    break;
-                case Bytecode.INSTR_INDENT:
-                    strIndex = GetShort(code, ip);
-                    ip += 2;
-                    @out.PushIndentation(self.code.strings[strIndex]);
-                    break;
-                case Bytecode.INSTR_DEDENT:
-                    @out.PopIndentation();
-                    break;
-                case Bytecode.INSTR_NEWLINE:
-                    try
-                    {
-                        if (prevOpcode == Bytecode.INSTR_NEWLINE ||
-                             prevOpcode == Bytecode.INSTR_INDENT ||
-                             nw > 0)
-                        {
-                            @out.Write(Environment.NewLine);
-                        }
-                        nw = -1; // indicate nothing written but no WRITE yet
-                    }
-                    catch (IOException ioe)
-                    {
-                        ErrorManager.IOError(self, ErrorType.WriteIoError, ioe);
-                    }
-                    break;
-                case Bytecode.INSTR_NOOP:
-                    break;
-                case Bytecode.INSTR_POP:
-                    sp--; // throw away top item on stack
-                    break;
-                default:
-                    ErrorManager.InternalError(self, ErrorType.InvalidBytecode, null, opcode, ip - 1);
-                    self.code.Dump();
-                    break;
-                }
-                prevOpcode = opcode;
-            }
-
-            if (group.Debug)
-            {
-                int stop = @out.Index - 1;
-                EvalTemplateEvent e = new EvalTemplateEvent((DebugTemplate)self, start, stop);
-                //Console.WriteLine(e);
-                events.Add(e);
-                if (self.enclosingInstance != null)
-                {
-                    ((DebugTemplate)self.enclosingInstance).InterpreterEvents.Add(e);
-                }
-            }
-
-            return n;
-        }
-
-        protected int WriteObjectNoOptions(ITemplateWriter @out, Template self, object o)
-        {
-            int start = @out.Index; // track char we're about to write
-            int n = WriteObject(@out, self, o, null);
-
-#if false
-            if (group.Debug)
-            {
-                Interval templateLocation = self.code.sourceMap[ip];
-                int exprStart = templateLocation.A;
-                int exprStop = templateLocation.B;
-                events.Add(new EvalExprEvent((DebugTemplate)self, start, @out.Index - 1, exprStart, exprStop));
-            }
-#endif
-
-            return n;
-        }
-
-        protected int WriteObjectWithOptions(ITemplateWriter @out, Template self, object o, object[] options)
-        {
-            int start = @out.Index; // track char we're about to write
-            // precompute all option values (render all the way to strings)
-            string[] optionStrings = null;
-            if (options != null)
-            {
-                optionStrings = new string[options.Length];
-                for (int i = 0; i < TemplateCompiler.NUM_OPTIONS; i++)
-                {
-                    optionStrings[i] = ToString(self, options[i]);
-                }
-            }
-
-            if (options != null && options[OPTION_ANCHOR] != null)
-                @out.PushAnchorPoint();
-
-            int n = WriteObject(@out, self, o, optionStrings);
-
-            if (options != null && options[OPTION_ANCHOR] != null)
-                @out.PopAnchorPoint();
-
-#if false
-            if (group.Debug)
-            {
-                Interval templateLocation = self.code.sourceMap[ip];
-                int exprStart = templateLocation.A;
-                int exprStop = templateLocation.B;
-                events.Add(new EvalExprEvent((DebugTemplate)self, start, @out.Index - 1, exprStart, exprStop));
-            }
-#endif
-
-            return n;
-        }
-
-        protected int WriteObject(ITemplateWriter @out, Template self, object o, string[] options)
-        {
-            int n = 0;
-            if (o == null)
-            {
-                if (options != null && options[OPTION_NULL] != null)
-                {
-                    o = options[OPTION_NULL];
-                }
-                else
-                {
-                    return 0;
-                }
-            }
-
-            if (o is Template)
-            {
-                ((Template)o).enclosingInstance = self;
-                SetDefaultArguments((Template)o);
-                if (options != null && options[OPTION_WRAP] != null)
-                {
-                    // if we have a wrap string, then inform writer it might need to wrap
-                    try
-                    {
-                        @out.WriteWrap(options[OPTION_WRAP]);
-                    }
-                    catch (IOException ioe)
-                    {
-                        ErrorManager.IOError(self, ErrorType.WriteIoError, ioe);
-                    }
-                }
-                n = Exec(@out, (Template)o);
-            }
-            else
-            {
-                o = ConvertAnythingIteratableToIterator(o); // normalize
-                try
-                {
-                    if (o is Iterator)
-                        n = WriteIterator(@out, self, o, options);
-                    else
-                        n = WritePlainObject(@out, o, options);
-                }
-                catch (IOException ioe)
-                {
-                    ErrorManager.IOError(self, ErrorType.WriteIoError, ioe, o);
-                }
-            }
-
-            return n;
-        }
-
-        protected int WriteIterator(ITemplateWriter @out, Template self, object o, string[] options)
-        {
-            if (o == null)
-                return 0;
-            int n = 0;
-            Iterator it = (Iterator)o;
-            string separator = null;
-            if (options != null)
-                separator = options[OPTION_SEPARATOR];
-            bool seenAValue = false;
-            while (it.MoveNext())
-            {
-                object iterValue = it.Current;
-                // Emit separator if we're beyond first value
-                bool needSeparator = seenAValue &&
-                    separator != null &&            // we have a separator and
-                    (iterValue != null ||           // either we have a value
-                     options[OPTION_NULL] != null); // or no value but null option
-                if (needSeparator)
-                    n += @out.WriteSeparator(separator);
-                int nw = WriteObject(@out, self, iterValue, options);
-                if (nw > 0)
-                    seenAValue = true;
-                n += nw;
-            }
-            return n;
-        }
-
-        protected int WritePlainObject(ITemplateWriter @out, object o, string[] options)
-        {
-            string formatString = null;
-            if (options != null)
-                formatString = options[OPTION_FORMAT];
-            IAttributeRenderer r = group.GetAttributeRenderer(o.GetType());
-            string v = null;
-            if (r != null)
-            {
-                v = r.ToString(o, formatString, culture);
-            }
-            else
-            {
-                v = o.ToString();
-            }
-
-            int n = 0;
-            if (options != null && options[OPTION_WRAP] != null)
-                n = @out.Write(v, options[OPTION_WRAP]);
-            else
-                n = @out.Write(v);
-
-            return n;
-        }
-
-        protected void Map(Template self, object attr, TemplateName name)
-        {
-            Rot_map(self, attr, new TemplateName[] { name });
-        }
-
-        // <names:a,b>
-        protected void Rot_map(Template self, object attr, IList<TemplateName> templates)
-        {
-            if (attr == null)
-            {
-                operands[++sp] = null;
-                return;
-            }
-            attr = ConvertAnythingIteratableToIterator(attr);
-            if (attr is Iterator)
-            {
-                List<Template> mapped = new List<Template>();
-                Iterator iter = (Iterator)attr;
-                int i0 = 0;
-                int i = 1;
-                int ti = 0;
-                while (iter.MoveNext())
-                {
-                    object iterValue = iter.Current;
-                    if (iterValue == null)
-                        continue;
-                    int templateIndex = ti % templates.Count; // rotate through
-                    ti++;
-                    TemplateName name = templates[templateIndex];
-                    Template st = group.GetEmbeddedInstanceOf(self, current_ip, name);
-                    SetSoleArgument(self, st, iterValue);
-                    st.RawSetAttribute("i0", i0);
-                    st.RawSetAttribute("i", i);
-                    mapped.Add(st);
-                    i0++;
-                    i++;
-                }
-                operands[++sp] = mapped;
-                //Console.WriteLine("mapped="+mapped);
-            }
-            else
-            { // if only single value, just apply first template to attribute
-                Template st = group.GetInstanceOf(templates[0]);
-                if (st != null)
-                {
-                    SetSoleArgument(self, st, attr);
-                    st.RawSetAttribute("i0", 0);
-                    st.RawSetAttribute("i", 1);
-                    operands[++sp] = st;
-                }
-                else
-                {
-                    operands[++sp] = Template.Blank;
-                }
-                //            map(self, attr, templates.get(1));
-            }
-        }
-
-        // <names,phones:{n,p | ...}>
-        protected Template.AttributeList Par_map(Template self, List<object> exprs, TemplateName template)
-        {
-            if (exprs == null || template == null || exprs.Count == 0)
-            {
-                return null; // do not apply if missing templates or empty values
-            }
-            // make everything iterable
-            for (int i = 0; i < exprs.Count; i++)
-            {
-                object attr = exprs[i];
-                if (attr != null)
-                    exprs[i] = ConvertAnythingToIterator(attr);
-            }
-
-            // ensure arguments line up
-            int numAttributes = exprs.Count;
-            CompiledTemplate code = group.LookupTemplate(template);
-            var formalArguments = code.formalArguments;
-            if (formalArguments == null || formalArguments.Count == 0)
-            {
-                ErrorManager.RuntimeError(self, current_ip, ErrorType.MissingFormalArguments);
-                return null;
-            }
-
-            object[] formalArgumentNames = formalArguments.Keys.ToArray();
-            if (formalArgumentNames.Length != numAttributes)
-            {
-                ErrorManager.RuntimeError(self, current_ip, ErrorType.ArgumentCountMismatch, numAttributes, formalArgumentNames.Length);
-                // truncate arg list to match smaller size
-                int shorterSize = Math.Min(formalArgumentNames.Length, numAttributes);
-                numAttributes = shorterSize;
-                object[] newFormalArgumentNames = new object[shorterSize];
-                Array.Copy(formalArgumentNames, 0,
-                                 newFormalArgumentNames, 0,
-                                 shorterSize);
-                formalArgumentNames = newFormalArgumentNames;
-            }
-
-            // keep walking while at least one attribute has values
-
-            {
-                Template.AttributeList results = new Template.AttributeList();
-                int i = 0; // iteration number from 0
-                while (true)
-                {
-                    // get a value for each attribute in list; put into Template instance
-                    int numEmpty = 0;
-                    Template embedded = group.GetEmbeddedInstanceOf(self, current_ip, template);
-                    embedded.RawSetAttribute("i0", i);
-                    embedded.RawSetAttribute("i", i + 1);
-                    for (int a = 0; a < numAttributes; a++)
-                    {
-                        Iterator it = (Iterator)exprs[a];
-                        if (it != null && it.MoveNext())
-                        {
-                            string argName = (string)formalArgumentNames[a];
-                            object iteratedValue = it.Current;
-                            embedded.CheckAttributeExists(argName);
-                            embedded.RawSetAttribute(argName, iteratedValue);
-                        }
-                        else
-                        {
-                            numEmpty++;
-                        }
-                    }
-                    if (numEmpty == numAttributes)
-                        break;
-                    results.Add(embedded);
-                    i++;
-                }
-                return results;
-            }
-        }
-
-        protected void SetSoleArgument(Template self, Template st, object attr)
-        {
-            string name = "it";
-            int nargs = 0;
-            if (st.code.formalArguments != null)
-            {
-                nargs = st.code.formalArguments.Count;
-            }
-
-            if (nargs > 0)
-            {
-                if (nargs != 1)
-                    ErrorManager.RuntimeError(self, current_ip, ErrorType.ExpectingSingleArgument, st, nargs);
-
-                name = st.code.formalArguments.Keys.First();
-            }
-
-            st.RawSetAttribute(name, attr);
-        }
-
-        protected void AddToList(List<object> list, object o)
-        {
-            if (o == null)
-                return; // [a,b,c] lists ignore null values
-            o = Interpreter.ConvertAnythingIteratableToIterator(o);
-            if (o is Iterator)
-            {
-                // copy of elements into our temp list
-                Iterator it = (Iterator)o;
-                while (it.MoveNext())
-                    list.Add(it.Current);
-            }
-            else
-            {
-                list.Add(o);
-            }
-        }
-
-        /** Return the first attribute if multiple valued or the attribute
-         *  itself if single-valued.  Used in <names:first()>
-         */
-        public object First(object v)
-        {
-            if (v == null)
-                return null;
-            object r = v;
-            v = ConvertAnythingIteratableToIterator(v);
-            if (v is Iterator)
-            {
-                Iterator it = (Iterator)v;
-                if (it.MoveNext())
-                {
-                    r = it.Current;
-                }
-            }
-            return r;
-        }
-
-        /** Return the last attribute if multiple valued or the attribute
-         *  itself if single-valued. Unless it's a list or array, this is pretty
-         *  slow as it iterates until the last element.
-         */
-        public object Last(object v)
-        {
-            if (v == null)
-                return null;
-            if (v is IList)
-                return ((IList)v)[((IList)v).Count - 1];
-            else if (v.GetType().IsArray)
-            {
-                object[] elems = (object[])v;
-                return elems[elems.Length - 1];
-            }
-            object last = v;
-            v = ConvertAnythingIteratableToIterator(v);
-            if (v is Iterator)
-            {
-                Iterator it = (Iterator)v;
-                while (it.MoveNext())
-                {
-                    last = it.Current;
-                }
-            }
-            return last;
-        }
-
-        /** Return everything but the first attribute if multiple valued
-         *  or null if single-valued.
-         */
-        public object Rest(object v)
-        {
-            if (v == null)
-                return null;
-            if (v is IList)
-            { // optimize list case
-                IList elems = (IList)v;
-                if (elems.Count <= 1)
-                    return null;
-                return elems.Cast<object>().Skip(1).ToArray();
-            }
-            object theRest = v; // else iterate and copy
-            v = ConvertAnythingIteratableToIterator(v);
-            if (v is Iterator)
-            {
-                IList a = new ArrayList();
-                Iterator it = (Iterator)v;
-                if (!it.MoveNext())
-                    return null; // if not even one value return null
-                //it.Current; // ignore first value
-                while (it.MoveNext())
-                {
-                    object o = it.Current;
-                    if (o != null)
-                        a.Add(o);
-                }
-                return a;
-            }
-            else
-            {
-                theRest = null;  // rest of single-valued attribute is null
-            }
-            return theRest;
-        }
-
-        /** Return all but the last element.  trunc(x)=null if x is single-valued. */
-        public object Trunc(object v)
-        {
-            if (v == null)
-                return null;
-            if (v is IList)
-            {
-                // optimize list case
-                IList elems = (IList)v;
-                if (elems.Count <= 1)
-                    return null;
-                return elems.Cast<object>().Take(elems.Count - 1).ToArray();
-            }
-            v = ConvertAnythingIteratableToIterator(v);
-            if (v is Iterator)
-            {
-                IList a = new ArrayList();
-                Iterator it = (Iterator)v;
-                if (it.MoveNext())
-                {
-                    object previous = it.Current;
-                    while (it.MoveNext())
-                    {
-                        a.Add(previous);
-                        previous = it.Current;
-                    }
-                }
-                return a;
-            }
-            return null; // trunc(x)==null when x single-valued attribute
-        }
-
-        /** Return a new list w/o null values. */
-        public object Strip(object v)
-        {
-            if (v == null)
-                return null;
-            v = ConvertAnythingIteratableToIterator(v);
-            if (v is Iterator)
-            {
-                IList a = new ArrayList();
-                Iterator it = (Iterator)v;
-                while (it.MoveNext())
-                {
-                    object o = (object)it.Current;
-                    if (o != null)
-                        a.Add(o);
-                }
-                return a;
-            }
-            return v; // strip(x)==x when x single-valued attribute
-        }
-
-        /** Return a list with the same elements as v but in reverse order. null
-         *  values are NOT stripped out. use reverse(strip(v)) to do that.
-         */
-        public object Reverse(object v)
-        {
-            if (v == null)
-                return null;
-            v = ConvertAnythingIteratableToIterator(v);
-            if (v is Iterator)
-            {
-                IList a = new List<object>();
-                Iterator it = (Iterator)v;
-                while (it.MoveNext())
-                    a.Insert(0, it.Current);
-                return a;
-            }
-            return v;
-        }
-
-        /** Return the length of a mult-valued attribute or 1 if it is a
-         *  single attribute. If attribute is null return 0.
-         *  Special case several common collections and primitive arrays for
-         *  speed. This method by Kay Roepke from v3.
-         */
-        public object Length(object v)
-        {
-            if (v == null)
-                return 0;
-            int i = 1;      // we have at least one of something. Iterator and arrays might be empty.
-            if (v is IDictionary)
-                i = ((IDictionary)v).Count;
-            else if (v is ICollection)
-                i = ((ICollection)v).Count;
-            else if (v is object[])
-                i = ((object[])v).Length;
-            else if (v is string[])
-                i = ((string[])v).Length;
-            else if (v is int[])
-                i = ((int[])v).Length;
-            else if (v is long[])
-                i = ((long[])v).Length;
-            else if (v is float[])
-                i = ((float[])v).Length;
-            else if (v is double[])
-                i = ((double[])v).Length;
-            else if (v is Iterator)
-            {
-                Iterator it = (Iterator)v;
-                i = 0;
-                while (it.MoveNext())
-                {
-                    i++;
-                }
-            }
-            return i;
-        }
-
-        protected string ToString(Template self, object value)
-        {
-            if (value != null)
-            {
-                string s = value as string;
-                if (s != null)
-                    return s;
-
-                // if Template, make sure it evaluates with enclosing template as self
-                Template t = value as Template;
-                if (t != null)
-                    t.enclosingInstance = self;
-
-                // if not string already, must evaluate it
-                StringWriter sw = new StringWriter();
-                //Interpreter interp = new Interpreter(group, new NoIndentWriter(sw), culture);
-                //interp.WriteObjectNoOptions(self, value, -1, -1);
-                WriteObjectNoOptions(new NoIndentWriter(sw), self, value);
-                return sw.ToString();
-            }
-            return null;
-        }
-
-        protected static object ConvertAnythingIteratableToIterator(object o)
-        {
-            Iterator iter = null;
-            if (o == null)
-                return null;
-            else if (o is IDictionary)
-                iter = ((IDictionary)o).Values.GetEnumerator();
-            if (o is ICollection)
-                iter = ((ICollection)o).GetEnumerator();
-            //else if (o.GetType().IsArray)
-            //    iter = new ArrayIterator(o);
-            else if (o is Iterator)
-                iter = (Iterator)o;
-            if (iter == null)
-                return o;
-            return iter;
-        }
-
-        protected static Iterator ConvertAnythingToIterator(object o)
-        {
-            o = ConvertAnythingIteratableToIterator(o);
-            if (o is Iterator)
-                return (Iterator)o;
-            IList singleton = new Template.AttributeList(1);
-            singleton.Add(o);
-            return singleton.GetEnumerator();
-        }
-
-        protected bool TestAttributeTrue(object a)
-        {
-            if (a == null)
-                return false;
-            if (a is bool)
-                return (bool)a;
-            if (a is ICollection)
-                return ((ICollection)a).Count > 0;
-            //if (a is IDictionary)
-            //    return ((IDictionary)a).Count > 0;
-            //if (a is Iterator)
-            //    return ((Iterator)a).hasNext();
-            return true; // any other non-null object, return true--it's present
-        }
-
-        protected object GetObjectProperty(Template self, object o, object property)
-        {
-            if (o == null || property == null)
-            {
-                // TODO: throw Ill arg if they want
-                return null;
-            }
-
-            object value = null;
-
-            if (o is IDictionary)
-            {
-                IDictionary map = (IDictionary)o;
-                if (property.ToString() == TemplateGroup.DICT_KEY)
-                    value = property;
-                else if (property.Equals("keys"))
-                    value = map.Keys;
-                else if (property.Equals("values"))
-                    value = map.Values;
-                else if (map.Contains(property))
-                    value = map[property];
-                else if (map.Contains(ToString(self, property)))
-                {
-                    // if we can't find the key, toString it
-                    value = map[ToString(self, property)];
-                }
-                else
-                    value = map[TemplateGroup.DEFAULT_KEY]; // not found, use default
-                if (property.ToString() == TemplateGroup.DICT_KEY)
-                {
-                    value = property;
-                }
-                return value;
-            }
-
-            var c = o.GetType();
-
-            // try getXXX and isXXX properties
-
-            // look up using reflection
-            string propertyName = (string)property;
-            string methodSuffix = char.ToUpperInvariant(propertyName[0]) +
-                propertyName.Substring(1);
-            MethodInfo m = GetMethod(c, "get" + methodSuffix);
-            if (m == null)
-            {
-                m = GetMethod(c, "is" + methodSuffix);
-            }
-            if (m != null)
-            {
-                // save to avoid lookup later
-                //self.getGroup().cacheClassProperty(c,propertyName,m);
-                try
-                {
-                    value = InvokeMethod(m, o, value);
-                }
-                catch (Exception e)
-                {
-                    if (ErrorManager.IsCriticalException(e))
-                        throw;
-
-                    //ErrorManager.RuntimeError(self, ErrorType.CantAccessPropertyMethod, e, m);
-                }
-            }
-            else
-            {
-                // try for a visible field
-                try
-                {
-                    FieldInfo f = c.GetField(propertyName);
-                    //self.getGroup().cacheClassProperty(c,propertyName,f);
-                    try
-                    {
-                        value = AccessField(f, o, value);
-                    }
-                    catch (Exception e)
-                    {
-                        if (ErrorManager.IsCriticalException(e))
-                            throw;
-
-                        //ErrorManager.RuntimeError(self, ErrorType.CantAccessPropertyField, e, m);
-                    }
-                }
-                catch (Exception e)
-                {
-                    if (ErrorManager.IsCriticalException(e))
-                        throw;
-
-                    //ErrorManager.RuntimeError(self, ErrorType.NoSuchProperty, c, propertyName);
-                }
-            }
-
-            return value;
-        }
-
-        protected object AccessField(FieldInfo f, object o, object value)
-        {
-            value = f.GetValue(o);
-            return value;
-        }
-
-        protected object InvokeMethod(MethodInfo m, object o, object value)
-        {
-            value = m.Invoke(o, (object[])null);
-            return value;
-        }
-
-        protected MethodInfo GetMethod(Type c, string methodName)
-        {
-            MethodInfo m;
-            try
-            {
-                m = c.GetMethod(methodName, (Type[])null);
-            }
-            catch (Exception e)
-            {
-                if (ErrorManager.IsCriticalException(e))
-                    throw;
-
-                m = null;
-            }
-            return m;
-        }
-
-        /** Set any default argument values that were not set by the
-         *  invoking template or by setAttribute directly.  Note
-         *  that the default values may be templates.  Their evaluation
-         *  context is the template itself and, hence, can see attributes
-         *  within the template, any arguments, and any values inherited
-         *  by the template.
-         */
-        public void SetDefaultArguments(Template invokedST)
-        {
-            if (invokedST.code.formalArguments == null || invokedST.code.formalArguments.Count == 0)
-                return;
-
-            foreach (FormalArgument arg in invokedST.code.formalArguments.Values)
-            {
-                // if no value for attribute and default arg, inject default arg into self
-                object attributeValue;
-                if ((invokedST.attributes == null || !invokedST.attributes.TryGetValue(arg.name, out attributeValue) || attributeValue == null) && arg.compiledDefaultValue != null)
-                {
-                    Template defaultArgST = group.CreateStringTemplate();
-                    defaultArgST.groupThatCreatedThisInstance = group;
-                    defaultArgST.code = arg.compiledDefaultValue;
-                    Console.WriteLine("setting def arg " + arg.name + " to " + defaultArgST);
-                    // If default arg is template with single expression
-                    // wrapped in parens, x={<(...)>}, then eval to string
-                    // rather than setting x to the template for later
-                    // eval.
-                    string defArgTemplate = arg.defaultValueToken.Text;
-                    if (defArgTemplate.StartsWith("{<(") && defArgTemplate.EndsWith(")>}"))
-                    {
-                        invokedST.RawSetAttribute(arg.name, ToString(invokedST, defaultArgST));
-                    }
-                    else
-                    {
-                        invokedST.RawSetAttribute(arg.name, defaultArgST);
-                    }
-                }
-            }
-        }
-
-        /** A reference to an attribute with no value must be compared against
-         *  the formal parameters up the enclosing chain to see if it exists;
-         *  if it exists all is well, but if not, record an error.
-         *
-         *  Don't generate error if template has no formal arguments.
-         */
-        protected void CheckNullAttributeAgainstFormalArguments(Template self, string name)
-        {
-            if (self.code.formalArguments == FormalArgument.Unknown)
-                return; // ignore unknown args in tombu mode
-
-            Template p = self;
-            while (p != null)
-            {
-                if (p.code.formalArguments != null && p.code.formalArguments.ContainsKey(name))
-                {
-                    // found it; no problems, just return
-                    return;
-                }
-                p = p.enclosingInstance;
-            }
-
-            ErrorManager.RuntimeError(self, current_ip, ErrorType.NO_ATTRIBUTE_DEFINITION, name);
-        }
-
-        protected void Trace(Template self, int ip)
-        {
-            BytecodeDisassembler dis = new BytecodeDisassembler(self.code);
-            StringBuilder buf = new StringBuilder();
-            dis.DisassembleInstruction(buf, ip);
-            string name = self.code.Name + ":";
-            if (self.code.Name == Template.UnknownName)
-                name = "";
-            Console.Write(string.Format("{0:-40s}", name + buf));
-            Console.Write("\tstack=[");
-            for (int i = 0; i <= sp; i++)
-            {
-                object o = operands[i];
-                PrintForTrace(o);
-            }
-            Console.Write(" ], calls=");
-            Console.Write(self.GetEnclosingInstanceStackString());
-            Console.Write(", sp=" + sp + ", nw=" + nw);
-            Console.WriteLine();
-        }
-
-        protected void PrintForTrace(object o)
-        {
-            if (o is Template)
-            {
-                if (((Template)o).code == null)
-                    Console.Write("bad-template()");
-                else
-                    Console.Write(" " + ((Template)o).code.Name + "()");
-                return;
-            }
-            o = ConvertAnythingIteratableToIterator(o);
-            if (o is Iterator)
-            {
-                Iterator it = (Iterator)o;
-                Console.Write(" [");
-                while (it.MoveNext())
-                {
-                    PrintForTrace(it.Current);
-                }
-                Console.Write(" ]");
-            }
-            else
-            {
-                Console.Write(" " + o);
-            }
-        }
-
-        public static int GetInt(byte[] memory, int index)
-        {
-            int b1 = memory[index++] & 0xFF; // mask off sign-extended bits
-            int b2 = memory[index++] & 0xFF;
-            int b3 = memory[index++] & 0xFF;
-            int b4 = memory[index++] & 0xFF;
-            int word = b1 << (8 * 3) | b2 << (8 * 2) | b3 << (8 * 1) | b4;
-            return word;
-        }
-
-        public static int GetShort(byte[] memory, int index)
-        {
-            int b1 = memory[index++] & 0xFF; // mask off sign-extended bits
-            int b2 = memory[index++] & 0xFF;
-            int word = b1 << (8 * 1) | b2;
-            return word;
-        }
-    }
-}
diff --git a/StringTemplate4/Misc.cs b/StringTemplate4/Misc.cs
deleted file mode 100644
index 5b0eaf4..0000000
--- a/StringTemplate4/Misc.cs
+++ /dev/null
@@ -1,104 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate
-{
-    using ArgumentException = System.ArgumentException;
-    using ArgumentNullException = System.ArgumentNullException;
-    using ArgumentOutOfRangeException = System.ArgumentOutOfRangeException;
-
-    internal static class Misc
-    {
-        public static string Strip(string s, int n)
-        {
-            if (s == null)
-                throw new ArgumentNullException("s");
-            if (n < 0)
-                throw new ArgumentOutOfRangeException("n");
-            if (s.Length - 2 * n < 0)
-                throw new ArgumentException();
-
-            return s.Substring(n, s.Length - 2 * n);
-        }
-
-        public static string TrimOneStartingNewline(string s)
-        {
-            if (s == null)
-                throw new ArgumentNullException("s");
-
-            // strip newline from front but just one
-            if (s.StartsWith("\r\n"))
-                s = s.Substring(2);
-            else if (s.StartsWith("\n"))
-                s = s.Substring(1);
-            return s;
-        }
-
-        public static string ReplaceEscapes(string s)
-        {
-            if (s == null)
-                throw new ArgumentNullException("s");
-
-            s = s.Replace("\n", @"\\n");
-            s = s.Replace("\r", @"\\r");
-            s = s.Replace("\t", @"\\t");
-            return s;
-        }
-
-        /// <summary>
-        /// Given index into string, compute the line and char position in line
-        /// </summary>
-        public static Coordinate GetLineCharPosition(string s, int index)
-        {
-            int line = 1;
-            int charPos = 0;
-            int p = 0;
-            while (p < index)
-            {
-                // don't care about s[index] itself; count before
-                if (s[p] == '\n')
-                {
-                    line++;
-                    charPos = 0;
-                }
-                else
-                {
-                    charPos++;
-                }
-
-                p++;
-            }
-
-            return new Coordinate(line, charPos);
-        }
-    }
-}
diff --git a/StringTemplate4/NoIndentWriter.cs b/StringTemplate4/NoIndentWriter.cs
deleted file mode 100644
index 7d73c1a..0000000
--- a/StringTemplate4/NoIndentWriter.cs
+++ /dev/null
@@ -1,53 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate
-{
-    using TextWriter = System.IO.TextWriter;
-
-    public class NoIndentWriter : AutoIndentWriter
-    {
-        public NoIndentWriter(TextWriter @out)
-            : base(@out)
-        {
-        }
-
-        public override int Write(string str)
-        {
-            if (string.IsNullOrEmpty(str))
-                return 0;
-
-            @out.Write(str);
-            return str.Length;
-        }
-    }
-}
diff --git a/StringTemplate4/NumberRenderer.cs b/StringTemplate4/NumberRenderer.cs
deleted file mode 100644
index b403d21..0000000
--- a/StringTemplate4/NumberRenderer.cs
+++ /dev/null
@@ -1,49 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate
-{
-    using CultureInfo = System.Globalization.CultureInfo;
-    using IFormattable = System.IFormattable;
-
-    public class NumberRenderer : IAttributeRenderer
-    {
-        public string ToString(object o, string formatString, CultureInfo culture)
-        {
-            IFormattable formattable = o as IFormattable;
-            if (formattable != null)
-                return formattable.ToString(formatString, culture);
-
-            return o.ToString();
-        }
-    }
-}
diff --git a/StringTemplate4/Properties/AssemblyInfo.cs b/StringTemplate4/Properties/AssemblyInfo.cs
deleted file mode 100644
index 839caa9..0000000
--- a/StringTemplate4/Properties/AssemblyInfo.cs
+++ /dev/null
@@ -1,70 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System.Reflection;
-using System.Runtime.CompilerServices;
-using System.Runtime.InteropServices;
-using System;
-
-// General Information about an assembly is controlled through the following
-// set of attributes. Change these attribute values to modify the information
-// associated with an assembly.
-[assembly: AssemblyTitle("StringTemplate4")]
-[assembly: AssemblyDescription("")]
-[assembly: AssemblyConfiguration("")]
-[assembly: AssemblyCompany("Sam Harwell")]
-[assembly: AssemblyProduct("StringTemplate4")]
-[assembly: AssemblyCopyright("Copyright © Sam Harwell 2009")]
-[assembly: AssemblyTrademark("")]
-[assembly: AssemblyCulture("")]
-
-// Setting ComVisible to false makes the types in this assembly not visible
-// to COM components.  If you need to access a type in this assembly from
-// COM, set the ComVisible attribute to true on that type.
-[assembly: ComVisible(false)]
-[assembly: CLSCompliant(false)]
-
-// The following GUID is for the ID of the typelib if this project is exposed to COM
-[assembly: Guid("9fefb7b5-1863-4c57-aae2-21d018c08bd0")]
-
-// Version information for an assembly consists of the following four values:
-//
-//      Major Version
-//      Minor Version
-//      Build Number
-//      Revision
-//
-// You can specify all the values or you can default the Build and Revision Numbers
-// by using the '*' as shown below:
-// [assembly: AssemblyVersion("1.0.*")]
-[assembly: AssemblyVersion("1.0.0.0")]
-[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/StringTemplate4/StringRenderer.cs b/StringTemplate4/StringRenderer.cs
deleted file mode 100644
index bea3481..0000000
--- a/StringTemplate4/StringRenderer.cs
+++ /dev/null
@@ -1,70 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate
-{
-    using CultureInfo = System.Globalization.CultureInfo;
-    using HttpUtility = System.Web.HttpUtility;
-    using SecurityElement = System.Security.SecurityElement;
-
-    public class StringRenderer : IAttributeRenderer
-    {
-        // trim(s) and strlen(s) built-in funcs; these are format options
-        public string ToString(object o, string formatString, CultureInfo culture)
-        {
-            string s = o.ToString();
-            if (formatString == null || string.IsNullOrEmpty(s))
-                return s;
-
-            switch (formatString)
-            {
-            case "upper":
-                return s.ToUpper(culture);
-
-            case "lower":
-                return s.ToLower(culture);
-
-            case "cap":
-                return char.ToUpper(s[0], culture) + s.Substring(1);
-
-            case "url-encode":
-                return HttpUtility.UrlEncode(s);
-
-            case "xml-encode":
-                return SecurityElement.Escape(s);
-
-            default:
-                return s;
-            }
-        }
-    }
-}
diff --git a/StringTemplate4/StringTemplate4.csproj b/StringTemplate4/StringTemplate4.csproj
deleted file mode 100644
index d2c80ee..0000000
--- a/StringTemplate4/StringTemplate4.csproj
+++ /dev/null
@@ -1,128 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <PropertyGroup>
-    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
-    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>9.0.30729</ProductVersion>
-    <SchemaVersion>2.0</SchemaVersion>
-    <ProjectGuid>{BBE5D9E6-2F4C-46EF-8CDB-17F886A36837}</ProjectGuid>
-    <OutputType>Library</OutputType>
-    <AppDesignerFolder>Properties</AppDesignerFolder>
-    <RootNamespace>StringTemplate</RootNamespace>
-    <AssemblyName>StringTemplate4</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
-    <FileAlignment>512</FileAlignment>
-    <SignAssembly>true</SignAssembly>
-    <AssemblyOriginatorKeyFile>..\Antlr3\Key.snk</AssemblyOriginatorKeyFile>
-    <SccProjectName>Perforce Project</SccProjectName>
-    <SccLocalPath>..\..\..</SccLocalPath>
-    <SccAuxPath>
-    </SccAuxPath>
-    <SccProvider>MSSCCI:Perforce SCM</SccProvider>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
-    <DebugSymbols>true</DebugSymbols>
-    <DebugType>full</DebugType>
-    <Optimize>false</Optimize>
-    <OutputPath>bin\Debug\</OutputPath>
-    <DefineConstants>DEBUG;TRACE</DefineConstants>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
-    <DebugType>pdbonly</DebugType>
-    <Optimize>true</Optimize>
-    <OutputPath>bin\Release\</OutputPath>
-    <DefineConstants>TRACE</DefineConstants>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-  </PropertyGroup>
-  <ItemGroup>
-    <Reference Include="System" />
-    <Reference Include="System.Core">
-      <RequiredTargetFramework>3.5</RequiredTargetFramework>
-    </Reference>
-    <Reference Include="System.Web" />
-  </ItemGroup>
-  <ItemGroup>
-    <Compile Include="AutoIndentWriter.cs" />
-    <Compile Include="BlankTemplate.cs" />
-    <Compile Include="Compiler\Bytecode.cs" />
-    <Compile Include="Compiler\BytecodeDisassembler.cs" />
-    <Compile Include="Compiler\CompiledTemplate.cs" />
-    <Compile Include="Compiler\FormalArgument.cs" />
-    <Compile Include="Compiler\ICodeGenerator.cs" />
-    <Compile Include="Compiler\Interval.cs" />
-    <Compile Include="Compiler\StringTable.cs" />
-    <Compile Include="Compiler\TemplateCompiler.cs" />
-    <Compile Include="Compiler\TemplateException.cs" />
-    <Compile Include="Compiler\TemplateLexer.cs" />
-    <Compile Include="Coordinate.cs" />
-    <Compile Include="DateTimeRenderer.cs" />
-    <Compile Include="Debug\AddAttributeEvent.cs" />
-    <Compile Include="Debug\ConstructionEvent.cs" />
-    <Compile Include="Debug\DebugTemplate.cs" />
-    <Compile Include="Debug\EvalExprEvent.cs" />
-    <Compile Include="Debug\EvalTemplateEvent.cs" />
-    <Compile Include="Debug\InterpEvent.cs" />
-    <Compile Include="ErrorBuffer.cs" />
-    <Compile Include="ErrorManager.cs" />
-    <Compile Include="Compiler\GroupLexerHelper.cs">
-      <DependentUpon>Group.g3</DependentUpon>
-    </Compile>
-    <Compile Include="Compiler\GroupParserHelper.cs">
-      <DependentUpon>Group.g3</DependentUpon>
-    </Compile>
-    <Compile Include="ErrorType.cs" />
-    <Compile Include="IAttributeRenderer.cs" />
-    <Compile Include="Interpreter.cs" />
-    <Compile Include="ITemplateErrorListener.cs" />
-    <Compile Include="ITemplateWriter.cs" />
-    <Compile Include="Misc.cs" />
-    <Compile Include="NoIndentWriter.cs" />
-    <Compile Include="NumberRenderer.cs" />
-    <Compile Include="Properties\AssemblyInfo.cs" />
-    <Compile Include="StringRenderer.cs" />
-    <Compile Include="Template.cs" />
-    <Compile Include="TemplateCompileTimeMessage.cs" />
-    <Compile Include="TemplateGroup.cs" />
-    <Compile Include="TemplateGroupDirectory.cs" />
-    <Compile Include="TemplateGroupFile.cs" />
-    <Compile Include="Compiler\TemplateParserHelper.cs">
-      <DependentUpon>TemplateParser.g3</DependentUpon>
-    </Compile>
-    <Compile Include="TemplateMessage.cs" />
-    <Compile Include="TemplateName.cs" />
-    <Compile Include="TemplateRuntimeMessage.cs" />
-    <Compile Include="TemplateSyntaxErrorMessage.cs" />
-  </ItemGroup>
-  <ItemGroup>
-    <None Include="..\Antlr3\Key.snk">
-      <Link>Key.snk</Link>
-    </None>
-    <Antlr3 Include="Compiler\Group.g3" />
-    <AntlrTokens Include="Compiler\TemplateLexer.tokens" />
-    <Antlr3 Include="Compiler\TemplateParser.g3" />
-  </ItemGroup>
-  <ItemGroup>
-    <ProjectReference Include="..\..\..\antlr\main\runtime\CSharp3\Sources\Antlr3.Runtime\Antlr3.Runtime.csproj">
-      <Project>{8FDC0A87-9005-4D5A-AB75-E55CEB575559}</Project>
-      <Name>Antlr3.Runtime</Name>
-    </ProjectReference>
-  </ItemGroup>
-  <PropertyGroup>
-    <!-- Folder containing AntlrBuildTask.dll -->
-    <AntlrBuildTaskPath>$(SolutionDir)bin\Bootstrap</AntlrBuildTaskPath>
-    <!-- Path to the ANTLR Tool itself. -->
-    <AntlrToolPath>$(SolutionDir)bin\Bootstrap\Antlr3.exe</AntlrToolPath>
-  </PropertyGroup>
-  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
-  <Import Project="$(SolutionDir)bin\Bootstrap\Antlr3.targets" />
-  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
-       Other similar extension points exist, see Microsoft.Common.targets.
-  <Target Name="BeforeBuild">
-  </Target>
-  <Target Name="AfterBuild">
-  </Target>
-  -->
-</Project>
\ No newline at end of file
diff --git a/StringTemplate4/StringTemplate4.csproj.vspscc b/StringTemplate4/StringTemplate4.csproj.vspscc
deleted file mode 100644
index 52102f8..0000000
--- a/StringTemplate4/StringTemplate4.csproj.vspscc
+++ /dev/null
@@ -1,10 +0,0 @@
-﻿""
-{
-"FILE_VERSION" = "9237"
-"ENLISTMENT_CHOICE" = "NEVER"
-"PROJECT_FILE_RELATIVE_PATH" = "relative:antlrcs\\main\\StringTemplate4"
-"NUMBER_OF_EXCLUDED_FILES" = "0"
-"ORIGINAL_PROJECT_FILE_PATH" = ""
-"NUMBER_OF_NESTED_PROJECTS" = "0"
-"SOURCE_CONTROL_SETTINGS_PROVIDER" = "PROJECT"
-}
diff --git a/StringTemplate4/Template.cs b/StringTemplate4/Template.cs
deleted file mode 100644
index ec90128..0000000
--- a/StringTemplate4/Template.cs
+++ /dev/null
@@ -1,390 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate
-{
-    using System.Collections.Generic;
-    using System.Diagnostics;
-    using StringTemplate.Compiler;
-    using ArgumentException = System.ArgumentException;
-    using ArrayList = System.Collections.ArrayList;
-    using CultureInfo = System.Globalization.CultureInfo;
-    using IList = System.Collections.IList;
-    using StringBuilder = System.Text.StringBuilder;
-    using StringWriter = System.IO.StringWriter;
-
-    public class Template
-    {
-        public const string SubtemplatePrefix = "_sub";
-        public static readonly TemplateName UnknownName = new TemplateName("anonymous");
-        public static readonly Template Blank = new BlankTemplate();
-
-        /** The code to interpret; it pulls from attributes and this template's
-         *  group of templates to evaluate to string.
-         */
-        public CompiledTemplate code; // TODO: is this the right name?
-
-        /** Map an attribute name to its value(s). */
-        internal IDictionary<string, object> attributes;
-
-        /** Enclosing instance if I'm embedded within another template.
-         *  IF-subtemplates are considered embedded as well.
-         */
-        internal Template enclosingInstance; // who's your daddy?
-
-        /** Created as instance of which group? We need this to init interpreter
-         *  via render.  So, we create st and then it needs to know which
-         *  group created it for sake of polymorphism:
-         *
-         *  st = skin1.getInstanceOf("searchbox");
-         *  result = st.render(); // knows skin1 created it
-         */
-        public TemplateGroup groupThatCreatedThisInstance;
-
-        /** Normally, formal parameters hide any attributes inherited from the
-         *  enclosing template with the same name.  This is normally what you
-         *  want, but makes it hard to invoke another template passing in all
-         *  the data.  Use notation now: <otherTemplate(...)> to say "pass in
-         *  all data".  Works great.  Can also say <otherTemplate(foo="xxx",...)>
-         */
-        protected internal bool passThroughAttributes = false;
-
-        /** Just an alias for ArrayList, but this way I can track whether a
-         *  list is something ST created or it's an incoming list.
-         */
-        public sealed class AttributeList : ArrayList
-        {
-            public AttributeList(int capacity)
-                : base(capacity)
-            {
-            }
-
-            public AttributeList()
-            {
-            }
-        }
-
-        public Template()
-        {
-        }
-
-        public Template(string template)
-            //: this(TemplateGroup.defaultGroup, template)
-        {
-            //code = TemplateGroup.defaultGroup.DefineTemplate(UnknownName, template);
-            groupThatCreatedThisInstance = TemplateGroup.defaultGroup;
-            code = groupThatCreatedThisInstance.Compile(TemplateName.Root, null, template);
-            code.Name = UnknownName;
-            groupThatCreatedThisInstance.DefineImplicitlyDefinedTemplates(code);
-        }
-
-#if false
-        public Template(TemplateGroup nativeGroup, string template)
-        {
-            code = nativeGroup.DefineTemplate(UnknownName, template);
-            groupThatCreatedThisInstance = nativeGroup;
-        }
-#endif
-
-        public IDictionary<string, object> Attributes
-        {
-            get
-            {
-                return this.attributes;
-            }
-        }
-
-        public CompiledTemplate CompiledTemplate
-        {
-            get
-            {
-                return code;
-            }
-        }
-
-        [DebuggerHidden]
-        public IEnumerable<Template> EnclosingInstanceStack
-        {
-            get
-            {
-                return GetEnclosingInstanceStack(false);
-            }
-        }
-
-        public bool IsSubtemplate
-        {
-            get
-            {
-                return CompiledTemplate.IsSubtemplate;
-            }
-        }
-
-        public virtual TemplateName Name
-        {
-            get
-            {
-                return code.Name;
-            }
-        }
-
-        public virtual void Add(string name, object value)
-        {
-            if (name == null)
-                return; // allow null value
-
-            if (name.IndexOf('.') >= 0)
-            {
-                throw new ArgumentException("cannot have '.' in attribute names");
-            }
-
-            if (value is Template)
-                ((Template)value).enclosingInstance = this;
-
-            object curvalue = null;
-            if (attributes == null || !attributes.ContainsKey(name))
-            {
-                // new attribute
-                CheckAttributeExists(name);
-                RawSetAttribute(name, value);
-                return;
-            }
-            if (attributes != null)
-                curvalue = attributes[name];
-
-            // attribute will be multi-valued for sure now
-            // convert current attribute to list if not already
-            // copy-on-write semantics; copy a list injected by user to add new value
-            AttributeList multi = ConvertToAttributeList(curvalue);
-            RawSetAttribute(name, multi); // replace with list
-
-            // now, add incoming value to multi-valued attribute
-            if (value is IList)
-            {
-                // flatten incoming list into existing list
-                multi.AddRange((IList)value);
-            }
-            else if (value != null && value.GetType().IsArray)
-            {
-                multi.AddRange((object[])value);
-            }
-            else
-            {
-                multi.Add(value);
-            }
-        }
-
-        protected internal virtual void RawSetAttribute(string name, object value)
-        {
-            if (attributes == null)
-                attributes = new Dictionary<string, object>();
-
-            attributes[name] = value;
-        }
-
-        protected internal void CheckAttributeExists(string name)
-        {
-            if (code.formalArguments == FormalArgument.Unknown)
-                return;
-
-            if (code.formalArguments == null || !code.formalArguments.ContainsKey(name))
-                ErrorManager.RuntimeError(this, -1, ErrorType.CantSetAttribute, name, Name);
-        }
-
-        /** Find an attr with dynamic scoping up enclosing ST chain.
-         *  If not found, look for a map.  So attributes sent in to a template
-         *  override dictionary names.
-         */
-        public virtual object GetAttribute(string name)
-        {
-            object o = null;
-            if (attributes != null)
-                attributes.TryGetValue(name, out o);
-
-            if (o != null)
-                return o;
-
-            if (code.formalArguments != null &&
-                 code.formalArguments.ContainsKey(name) &&  // no local value && it's a formal arg
-                 !passThroughAttributes)                 // but no ... in arg list
-            {
-                // if you've defined attribute as formal arg for this
-                // template and it has no value, do not look up the
-                // enclosing dynamic scopes.
-                return null;
-            }
-
-            Template p = this.enclosingInstance;
-            while (p != null)
-            {
-                if (p.attributes != null)
-                    p.attributes.TryGetValue(name, out o);
-                if (o != null)
-                    return o;
-                p = p.enclosingInstance;
-            }
-            if (code.formalArguments == null || !code.formalArguments.ContainsKey(name))
-            {
-                // if not hidden by formal args, return any dictionary
-                return code.nativeGroup.RawGetDictionary(name);
-            }
-            return null;
-        }
-
-        protected static AttributeList ConvertToAttributeList(object curvalue)
-        {
-            AttributeList multi;
-            if (curvalue == null)
-            {
-                multi = new AttributeList(); // make list to hold multiple values
-                multi.Add(curvalue);         // add previous single-valued attribute
-            }
-            else if (curvalue.GetType() == typeof(AttributeList))
-            { // already a list made by ST
-                multi = (AttributeList)curvalue;
-            }
-            else if (curvalue is IList)
-            { // existing attribute is non-ST List
-                // must copy to an ST-managed list before adding new attribute
-                // (can't alter incoming attributes)
-                IList listAttr = (IList)curvalue;
-                multi = new AttributeList(listAttr.Count);
-                multi.AddRange(listAttr);
-            }
-            else if (curvalue.GetType().IsArray)
-            { // copy array to list
-                object[] a = (object[])curvalue;
-                multi = new AttributeList(a.Length);
-                multi.AddRange(a); // asList doesn't copy as far as I can tell
-            }
-            else
-            {
-                // curvalue nonlist and we want to add an attribute
-                // must convert curvalue existing to list
-                multi = new AttributeList(); // make list to hold multiple values
-                multi.Add(curvalue);         // add previous single-valued attribute
-            }
-            return multi;
-        }
-
-        /** If an instance of x is enclosed in a y which is in a z, return
-         *  a String of these instance names in order from topmost to lowest;
-         *  here that would be "[z y x]".
-         */
-        public virtual string GetEnclosingInstanceStackString()
-        {
-            IList<Template> templates = GetEnclosingInstanceStack(true);
-            StringBuilder builder = new StringBuilder();
-            int i = 0;
-            foreach (var st in templates)
-            {
-                if (i > 0)
-                    builder.Append(" ");
-
-                builder.Append(st.Name);
-                i++;
-            }
-
-            return builder.ToString();
-        }
-
-        public IList<Template> GetEnclosingInstanceStack(bool topdown)
-        {
-            var stack = new List<Template>();
-            Template p = this;
-            while (p != null)
-            {
-                if (topdown)
-                    stack.Insert(0, p);
-                else
-                    stack.Add(p);
-
-                p = p.enclosingInstance;
-            }
-
-            return stack;
-        }
-
-        public virtual int Write(ITemplateWriter @out)
-        {
-            Interpreter interp = new Interpreter(groupThatCreatedThisInstance);
-            interp.SetDefaultArguments(this);
-            return interp.Exec(@out, this);
-        }
-
-        public virtual int Write(ITemplateWriter @out, CultureInfo culture)
-        {
-            Interpreter interp = new Interpreter(groupThatCreatedThisInstance, culture);
-            interp.SetDefaultArguments(this);
-            return interp.Exec(@out, this);
-        }
-
-        public string Render()
-        {
-            return Render(CultureInfo.CurrentCulture);
-        }
-
-        public string Render(int lineWidth)
-        {
-            return Render(CultureInfo.CurrentCulture, lineWidth);
-        }
-
-        public string Render(CultureInfo culture)
-        {
-            return Render(culture, AutoIndentWriter.NoWrap);
-        }
-
-        public virtual string Render(CultureInfo culture, int lineWidth)
-        {
-            StringWriter @out = new StringWriter();
-            ITemplateWriter wr = new AutoIndentWriter(@out);
-            wr.SetLineWidth(lineWidth);
-            Write(wr, culture);
-            return @out.ToString();
-        }
-
-        public override string ToString()
-        {
-            if (code == null)
-                return "bad-template()";
-
-            return code.Name + "()";
-        }
-
-        /** &lt;@r()&gt;, &lt;@r&gt;...&lt;@end&gt;, and @t.r() ::= "..." defined manually by coder */
-        public enum RegionType
-        {
-            Implicit,
-            Embedded,
-            Explicit
-        }
-    }
-}
diff --git a/StringTemplate4/TemplateCompileTimeMessage.cs b/StringTemplate4/TemplateCompileTimeMessage.cs
deleted file mode 100644
index 6d0af43..0000000
--- a/StringTemplate4/TemplateCompileTimeMessage.cs
+++ /dev/null
@@ -1,69 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate
-{
-    using Antlr.Runtime;
-    using ArgumentNullException = System.ArgumentNullException;
-    using Exception = System.Exception;
-
-    public class TemplateCompileTimeMessage : TemplateMessage
-    {
-        private IToken _token;
-
-        public TemplateCompileTimeMessage(ErrorType error, IToken token)
-            : this(error, token, null)
-        {
-        }
-
-        public TemplateCompileTimeMessage(ErrorType error, IToken token, Exception innerException)
-            : this(error, token, innerException, null)
-        {
-        }
-
-        public TemplateCompileTimeMessage(ErrorType error, IToken token, Exception innerException, object arg)
-            : base(error, null, innerException, arg)
-        {
-            this._token = token;
-        }
-
-        //public override string ToString()
-        //{
-        //    RecognitionException re = (RecognitionException)Source;
-        //    string header = re.Line + ":" + re.CharPositionInLine;
-        //    if (Argument1 == null)
-        //        return string.Format(ErrorType.MessageFormat, header + ": " + "??");
-
-        //    return string.Format(ErrorType.MessageFormat, Argument1 + " " + header + ": " + "??");
-        //}
-    }
-}
diff --git a/StringTemplate4/TemplateGroup.cs b/StringTemplate4/TemplateGroup.cs
deleted file mode 100644
index a74a227..0000000
--- a/StringTemplate4/TemplateGroup.cs
+++ /dev/null
@@ -1,493 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate
-{
-    using System.Collections.Generic;
-    using System.Linq;
-    using Antlr.Runtime;
-    using StringTemplate.Compiler;
-    using StringTemplate.Debug;
-    using ArgumentException = System.ArgumentException;
-    using Console = System.Console;
-    using Encoding = System.Text.Encoding;
-    using Exception = System.Exception;
-    using Path = System.IO.Path;
-    using StringBuilder = System.Text.StringBuilder;
-    using Type = System.Type;
-    using ArgumentNullException = System.ArgumentNullException;
-
-    /** A directory or directory tree of .st template files and/or group files.
-     *  Individual template files contain formal template definitions. In a sense,
-     *  it's like a single group file broken into multiple files, one for each template.
-     *  ST v3 had just the pure template inside, not the template name and header.
-     *  Name inside must match filename (minus suffix).
-     */
-    public class TemplateGroup
-    {
-        /** When we use key as a value in a dictionary, this is how we signify. */
-        public static readonly string DICT_KEY = "key";
-        public static readonly string DEFAULT_KEY = "default";
-
-        public string fullyQualifiedRootDirName;
-
-        /** Load files using what encoding? */
-        public Encoding encoding;
-
-        /// <summary>
-        /// Every group can import templates/dictionaries from other groups
-        /// </summary>
-        protected IList<TemplateGroup> imports;
-
-        public List<string> interfaces;
-
-        public char delimiterStartChar = '<'; // Use <expr> by default
-        public char delimiterStopChar = '>';
-
-        /** Maps template name to StringTemplate object */
-        protected internal IDictionary<TemplateName, CompiledTemplate> templates =
-            new Dictionary<TemplateName, CompiledTemplate>();
-
-        /** Maps dict names to HashMap objects.  This is the list of dictionaries
-         *  defined by the user like typeInitMap ::= ["int":"0"]
-         */
-        protected internal IDictionary<string, IDictionary<string, object>> dictionaries =
-            new Dictionary<string, IDictionary<string, object>>();
-
-        /** A dictionary that allows people to register a renderer for
-         *  a particular kind of object for any template evaluated relative to this
-         *  group.  For example, a date should be formatted differently depending
-         *  on the locale.  You can set Date.class to an object whose
-         *  toString(Object) method properly formats a Date attribute
-         *  according to locale.  Or you can have a different renderer object
-         *  for each locale.
-         */
-        protected IDictionary<Type, IAttributeRenderer> renderers;
-
-        protected bool alreadyLoaded = false;
-
-        public static TemplateGroup defaultGroup = new TemplateGroup();
-
-        public TemplateGroup()
-        {
-        }
-
-        public bool Debug
-        {
-            get;
-            set;
-        }
-
-        public virtual string Name
-        {
-            get
-            {
-                return "<no name>;";
-            }
-        }
-
-        public IDictionary<TemplateName, CompiledTemplate> Templates
-        {
-            get
-            {
-                return templates;
-            }
-        }
-
-        public Template GetInstanceOf(string name)
-        {
-            return GetInstanceOf(new TemplateName(name));
-        }
-
-        /** The primary means of getting an instance of a template from this
-         *  group. Must be absolute name like /a/b
-         */
-        public virtual Template GetInstanceOf(TemplateName name)
-        {
-            if (!name.IsRooted)
-                name = TemplateName.Combine(TemplateName.Root, name);
-
-            //Console.WriteLine("GetInstanceOf(" + name + ")");
-            CompiledTemplate c = LookupTemplate(name);
-            if (c != null)
-            {
-                Template instanceST = CreateStringTemplate();
-                instanceST.groupThatCreatedThisInstance = this;
-                instanceST.code = c;
-                return instanceST;
-            }
-            return null;
-        }
-
-        public virtual Template GetEmbeddedInstanceOf(Template enclosingInstance, int ip, TemplateName name)
-        {
-            Template st = GetInstanceOf(name);
-            if (st == null)
-            {
-                ErrorManager.RuntimeError(enclosingInstance, ip, ErrorType.NoSuchTemplate, name.Name);
-                return Template.Blank;
-            }
-            st.enclosingInstance = enclosingInstance;
-            return st;
-        }
-
-        public virtual CompiledTemplate LookupTemplate(TemplateName name)
-        {
-            if (!alreadyLoaded)
-                Load();
-
-            CompiledTemplate code;
-            if (!templates.TryGetValue(name, out code))
-            {
-                code = LookupImportedTemplate(name);
-            }
-
-            return code;
-        }
-
-        protected internal CompiledTemplate LookupImportedTemplate(TemplateName name)
-        {
-            //Console.WriteLine("look for " + name + " in " + imports);
-
-            if (imports == null)
-                return null;
-
-            foreach (var g in imports)
-            {
-                CompiledTemplate code = g.LookupTemplate(name);
-                if (code != null)
-                    return code;
-            }
-
-            return null;
-        }
-
-        public CompiledTemplate RawGetTemplate(TemplateName name)
-        {
-            CompiledTemplate template;
-            if (!templates.TryGetValue(name, out template))
-                return null;
-
-            return template;
-        }
-
-        public IDictionary<string, object> RawGetDictionary(string name)
-        {
-            IDictionary<string, object> dictionary;
-            if (!dictionaries.TryGetValue(name, out dictionary))
-                return null;
-
-            return dictionary;
-        }
-
-        // for testing
-        public CompiledTemplate DefineTemplate(TemplateName name, string template)
-        {
-            return DefineTemplate(TemplateName.Root, new CommonToken(GroupParser.ID, name.Name), FormalArgument.Unknown, template);
-        }
-
-#if false
-        public virtual CompiledTemplate DefineTemplate(TemplateName name,
-                                         List<string> args,
-                                         string template)
-        {
-            IDictionary<string, FormalArgument> margs = null;
-            if (args != null)
-                margs = args.ToDictionary(arg => arg, arg => new FormalArgument(arg));
-
-            return DefineTemplate(TemplateName.Root, name, margs, template);
-        }
-
-        public virtual CompiledTemplate DefineTemplate(IToken nameToken,
-                                         string[] args,
-                                         string template)
-        {
-            IDictionary<string, FormalArgument> margs = null;
-            if (args != null)
-                margs = args.ToDictionary(arg => arg, arg => new FormalArgument(arg));
-
-            return DefineTemplate(TemplateName.Root, nameToken, margs, template);
-        }
-#endif
-
-        // can't trap recog errors here; don't know where in file template is defined
-        public virtual CompiledTemplate DefineTemplate(TemplateName prefix, IToken nameToken, IDictionary<string, FormalArgument> args, string template)
-        {
-            if (nameToken == null)
-                throw new ArgumentNullException("nameToken");
-
-            TemplateName name = new TemplateName(nameToken.Text);
-            CompiledTemplate code = Compile(prefix, name, template);
-            code.Name = name;
-            code.formalArguments = args;
-            RawDefineTemplate(TemplateName.Combine(prefix, name), code, nameToken);
-            if (args != null)
-            { // compile any default args
-                foreach (string a in args.Keys)
-                {
-                    FormalArgument fa = args[a];
-                    if (fa.defaultValueToken != null)
-                    {
-                        TemplateCompiler c2 = new TemplateCompiler(prefix, name);
-                        string defArgTemplate = Misc.Strip(fa.defaultValueToken.Text, 1);
-                        fa.compiledDefaultValue = c2.Compile(defArgTemplate);
-                        fa.compiledDefaultValue.Name = new TemplateName(fa.name + "-default-value");
-                    }
-                }
-            }
-
-            // define any anonymous subtemplates
-            DefineImplicitlyDefinedTemplates(code);
-
-            return code;
-        }
-
-        /** Make name and alias for target.  Replace any previous def of name */
-        public CompiledTemplate DefineTemplateAlias(IToken aliasToken, IToken targetToken)
-        {
-            TemplateName alias = new TemplateName(aliasToken.Text);
-            TemplateName target = new TemplateName(targetToken.Text);
-            CompiledTemplate targetCode;
-            if (!templates.TryGetValue(target, out targetCode))
-            {
-                NoViableAltException e = null;
-                ErrorManager.SyntaxError(ErrorType.AliasTargetUndefined, e, alias.Name, target.Name);
-                return null;
-            }
-            templates[alias] = targetCode;
-            return targetCode;
-        }
-
-        public CompiledTemplate DefineRegion(TemplateName prefix,
-                                             TemplateName enclosingTemplateName,
-                                             IToken regionToken,
-                                             string template)
-        {
-            string name = regionToken.Text;
-            CompiledTemplate code = Compile(prefix, enclosingTemplateName, template);
-            code.Name = TemplateName.Combine(prefix, GetMangledRegionName(enclosingTemplateName, name));
-            code.isRegion = true;
-            code.regionDefType = Template.RegionType.Explicit;
-            RawDefineTemplate(code.Name, code, regionToken);
-            return code;
-        }
-
-        protected internal void DefineImplicitlyDefinedTemplates(CompiledTemplate code)
-        {
-            if (code.implicitlyDefinedTemplates != null)
-            {
-                foreach (CompiledTemplate sub in code.implicitlyDefinedTemplates)
-                {
-                    RawDefineTemplate(sub.Name, sub, null);
-                    DefineImplicitlyDefinedTemplates(sub);
-                }
-            }
-        }
-
-        protected void RawDefineTemplate(TemplateName name, CompiledTemplate code, IToken definingToken)
-        {
-            CompiledTemplate prev;
-            if (templates.TryGetValue(name, out prev))
-            {
-                if (!prev.isRegion)
-                {
-                    ErrorManager.CompileTimeError(ErrorType.TemplateRedefinition, definingToken);
-                    return;
-                }
-                if (prev.isRegion && prev.regionDefType == Template.RegionType.Embedded)
-                {
-                    ErrorManager.CompileTimeError(ErrorType.EmbeddedRegionRedefinition, definingToken, GetUnmangledTemplateName(name));
-                    return;
-                }
-                else if (prev.isRegion && prev.regionDefType == Template.RegionType.Explicit)
-                {
-                    ErrorManager.CompileTimeError(ErrorType.RegionRedefinition, definingToken, GetUnmangledTemplateName(name));
-                    return;
-                }
-            }
-            templates[name] = code;
-        }
-
-        protected internal CompiledTemplate Compile(TemplateName prefix, TemplateName enclosingTemplateName, string template)
-        {
-            TemplateCompiler c = new TemplateCompiler(prefix, enclosingTemplateName);
-            CompiledTemplate code = c.Compile(template);
-            code.nativeGroup = this;
-            code.template = template;
-            return code;
-        }
-
-        /** The "foo" of t() ::= "&lt;@foo()&gt;" is mangled to "region#t#foo" */
-        public static TemplateName GetMangledRegionName(TemplateName enclosingTemplateName,
-                                                  string name)
-        {
-            return new TemplateName("region__" + enclosingTemplateName + "__" + name);
-        }
-
-        /// <summary>
-        /// Return "t.foo" from "region__t__foo"
-        /// </summary>
-        public static string GetUnmangledTemplateName(TemplateName mangledName)
-        {
-            string name = mangledName.Name;
-            string t = name.Substring("region__".Length, name.LastIndexOf("__") - "region__".Length);
-            string r = name.Substring(name.LastIndexOf("__") + 2);
-            return t + '.' + r;
-        }
-
-        /** Define a map for this group; not thread safe...do not keep adding
-         *  these while you reference them.
-         */
-        public virtual void DefineDictionary(string name, IDictionary<string, object> mapping)
-        {
-            dictionaries[name] = mapping;
-        }
-
-        /// <summary>
-        /// Make this group import templates/dictionaries from <paramref name="g"/>.
-        /// </summary>
-        public virtual void ImportTemplates(TemplateGroup g)
-        {
-            if (g == null)
-                return;
-
-            if (imports == null)
-                imports = new List<TemplateGroup>();
-
-            imports.Add(g);
-        }
-
-        public virtual void Load()
-        {
-        }
-
-        // TODO: make this happen in background then flip ptr to new list of templates/dictionaries?
-        public virtual void LoadGroupFile(TemplateName prefix, string fileName)
-        {
-            string absoluteFileName = Path.Combine(fullyQualifiedRootDirName, fileName);
-            //Console.WriteLine("load group file " + absoluteFileName);
-            GroupParser parser = null;
-            try
-            {
-                ANTLRFileStream fs = new ANTLRFileStream(absoluteFileName, encoding);
-                GroupLexer lexer = new GroupLexer(fs);
-                CommonTokenStream tokens = new CommonTokenStream(lexer);
-                parser = new GroupParser(tokens);
-                parser.group(this, prefix);
-            }
-#if false
-            catch (RecognitionException e)
-            {
-                if (e.Token.Type == TemplateLexer.EOF_TYPE)
-                    ErrorManager.SyntaxError(ErrorType.SyntaxError, e, "premature EOF", absoluteFileName);
-                else
-                    ErrorManager.SyntaxError(ErrorType.SyntaxError, e, absoluteFileName);
-            }
-#endif
-            catch (Exception e)
-            {
-                if (ErrorManager.IsCriticalException(e))
-                    throw;
-
-                ErrorManager.IOError(null, ErrorType.CantLoadGroupFile, e, absoluteFileName);
-            }
-        }
-
-        /** Register a renderer for all objects of a particular type for all
-         *  templates evaluated relative to this group.
-         */
-        public void RegisterRenderer(Type attributeType, IAttributeRenderer r)
-        {
-            if (renderers == null)
-                renderers = new Dictionary<Type, IAttributeRenderer>();
-
-            renderers[attributeType] = r;
-        }
-
-        public IAttributeRenderer GetAttributeRenderer(Type attributeType)
-        {
-            if (renderers == null)
-                return null;
-
-            IAttributeRenderer renderer;
-            if (!renderers.TryGetValue(attributeType, out renderer))
-                return null;
-
-            return renderer;
-        }
-
-        /// <summary>
-        /// StringTemplate object factory; each group can have its own.
-        /// </summary>
-        public virtual Template CreateStringTemplate()
-        {
-            // TODO: try making a mem pool
-            if (Debug)
-                return new DebugTemplate();
-
-            return new Template();
-        }
-
-        public override string ToString()
-        {
-            return Name;
-        }
-
-        public virtual string Show()
-        {
-            if (!alreadyLoaded)
-                Load();
-
-            StringBuilder buf = new StringBuilder();
-            if (imports != null)
-                buf.Append(" : " + imports);
-            foreach (TemplateName name in templates.Keys)
-            {
-                CompiledTemplate c = templates[name];
-                if (c.IsSubtemplate)
-                    continue;
-
-                buf.Append(name.Name);
-                buf.Append('(');
-                if (c.formalArguments != null)
-                {
-                    buf.Append(string.Join(",", c.formalArguments.Values.Select(value => value.ToString()).ToArray()));
-                }
-                buf.Append(')');
-                buf.AppendLine(" ::= <<");
-                buf.AppendLine(c.template);
-                buf.AppendLine(">>");
-            }
-            return buf.ToString();
-        }
-    }
-}
diff --git a/StringTemplate4/TemplateGroupDirectory.cs b/StringTemplate4/TemplateGroupDirectory.cs
deleted file mode 100644
index a2f7060..0000000
--- a/StringTemplate4/TemplateGroupDirectory.cs
+++ /dev/null
@@ -1,164 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate
-{
-    using Antlr.Runtime;
-    using StringTemplate.Compiler;
-    using ArgumentException = System.ArgumentException;
-    using Console = System.Console;
-    using Directory = System.IO.Directory;
-    using Encoding = System.Text.Encoding;
-    using Exception = System.Exception;
-    using File = System.IO.File;
-    using Path = System.IO.Path;
-    using ArgumentNullException = System.ArgumentNullException;
-
-    public class TemplateGroupDirectory : TemplateGroup
-    {
-        public string dirName;
-
-        public TemplateGroupDirectory(string fullyQualifiedRootDirName)
-        {
-            this.fullyQualifiedRootDirName = fullyQualifiedRootDirName;
-            this.dirName = "/"; // it's the root
-            if (!Directory.Exists(fullyQualifiedRootDirName))
-            {
-                throw new ArgumentException("No such directory: " + fullyQualifiedRootDirName);
-            }
-        }
-
-        public TemplateGroupDirectory(string fullyQualifiedRootDirName, Encoding encoding)
-            : this(fullyQualifiedRootDirName)
-        {
-            this.encoding = encoding;
-        }
-
-        public override string Name
-        {
-            get
-            {
-                return dirName;
-            }
-        }
-
-        /// <summary>
-        /// walk dir and all subdir to load templates, group files
-        /// </summary>
-        public override void Load()
-        {
-            _Load(TemplateName.Root);
-            alreadyLoaded = true;
-        }
-
-        protected void _Load(TemplateName prefix)
-        {
-            if (prefix == null)
-                throw new ArgumentNullException("prefix");
-            if (!prefix.IsRooted)
-                throw new ArgumentException();
-
-            string relativePrefix = prefix.FullName.Substring(1);
-
-            string dir = Path.Combine(fullyQualifiedRootDirName, relativePrefix);
-            //Console.WriteLine("load dir '" + prefix + "' under " + fullyQualifiedRootDirName);
-
-            foreach (var d in Directory.GetDirectories(dir))
-            {
-                _Load(TemplateName.Combine(prefix, Path.GetFileName(d)));
-            }
-
-            foreach (var f in Directory.GetFiles(dir))
-            {
-                if (Path.GetExtension(f).Equals(".st", System.StringComparison.OrdinalIgnoreCase))
-                    LoadTemplateFile(prefix, Path.GetFileName(f));
-                else if (Path.GetExtension(f).Equals(".stg", System.StringComparison.OrdinalIgnoreCase))
-                    LoadGroupFile(TemplateName.Combine(prefix, Path.GetFileNameWithoutExtension(f)), Path.Combine(relativePrefix, Path.GetFileName(f)));
-            }
-        }
-
-        public CompiledTemplate LoadTemplateFile(TemplateName prefix, string fileName)
-        {
-            if (prefix == null)
-                throw new ArgumentNullException("prefix");
-            if (fileName == null)
-                throw new ArgumentNullException("fileName");
-            if (!prefix.IsRooted)
-                throw new ArgumentException("Expected the prefix to be a rooted name.", "prefix");
-
-            TemplateName templateName = TemplateName.Combine(prefix, new TemplateName(Path.GetFileNameWithoutExtension(fileName)));
-
-            // load from disk
-            string absoluteFileName = Path.Combine(Path.Combine(fullyQualifiedRootDirName, prefix.FullName.Substring(1)), fileName);
-
-            //Console.WriteLine("load " + absoluteFileName);
-            if (!File.Exists(absoluteFileName))
-            {
-                // TODO: add tolerance check here
-                return null;
-            }
-            try
-            {
-                if (ErrorManager.CompatibilityMode)
-                {
-                    string template = File.ReadAllText(absoluteFileName);
-                    template = template.Trim();
-                    DefineTemplate(prefix, new CommonToken(GroupParser.ID, templateName.Name), null, template);
-                }
-                else
-                {
-                    ANTLRFileStream fs = new ANTLRFileStream(absoluteFileName, encoding);
-                    GroupLexer lexer = new GroupLexer(fs);
-                    CommonTokenStream tokens = new CommonTokenStream(lexer);
-                    GroupParser parser = new GroupParser(tokens);
-                    parser._group = this;
-                    parser.templateDef(prefix);
-                }
-
-                CompiledTemplate code;
-                if (!templates.TryGetValue(templateName, out code))
-                    return null;
-
-                return code;
-            }
-            catch (Exception e)
-            {
-                if (ErrorManager.IsCriticalException(e))
-                    throw;
-
-                ErrorManager.IOError(null, ErrorType.CantLoadTemplateFile, e, absoluteFileName);
-                Console.Error.WriteLine(e.StackTrace);
-            }
-            return null;
-        }
-    }
-}
diff --git a/StringTemplate4/TemplateGroupFile.cs b/StringTemplate4/TemplateGroupFile.cs
deleted file mode 100644
index 94ba3bc..0000000
--- a/StringTemplate4/TemplateGroupFile.cs
+++ /dev/null
@@ -1,78 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate
-{
-    using Antlr.Runtime;
-    using ArgumentException = System.ArgumentException;
-    using Encoding = System.Text.Encoding;
-    using Exception = System.Exception;
-    using Path = System.IO.Path;
-    using StringComparison = System.StringComparison;
-
-    public class TemplateGroupFile : TemplateGroup
-    {
-        public string fileName;
-
-        public TemplateGroupFile(string fullyQualifiedFileName)
-        {
-            if (!Path.GetExtension(fullyQualifiedFileName).Equals(".stg", StringComparison.OrdinalIgnoreCase))
-            {
-                throw new ArgumentException("Group file names must end in .stg: " + fullyQualifiedFileName);
-            }
-
-            string absoluteFileName = Path.GetFullPath(fullyQualifiedFileName);
-            this.fullyQualifiedRootDirName = Path.GetDirectoryName(absoluteFileName);
-            this.fileName = Path.GetFileName(fullyQualifiedFileName);
-        }
-
-        public TemplateGroupFile(string fullyQualifiedFileName, Encoding encoding)
-            : this(fullyQualifiedFileName)
-        {
-            this.encoding = encoding;
-        }
-
-        public override string Name
-        {
-            get
-            {
-                return Path.GetFileNameWithoutExtension(fileName);
-            }
-        }
-
-        public override void Load()
-        {
-            LoadGroupFile(TemplateName.Root, fileName);
-            alreadyLoaded = true;
-        }
-    }
-}
diff --git a/StringTemplate4/TemplateMessage.cs b/StringTemplate4/TemplateMessage.cs
deleted file mode 100644
index 2c6cf17..0000000
--- a/StringTemplate4/TemplateMessage.cs
+++ /dev/null
@@ -1,142 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate
-{
-    using Exception = System.Exception;
-    using StringBuilder = System.Text.StringBuilder;
-    using Antlr.Runtime;
-
-    public class TemplateMessage
-    {
-        /** if in debug mode, has create instance, add attr events and eval
-         *  template events.
-         */
-
-        public TemplateMessage(ErrorType error)
-            : this(error, null, null, null, null)
-        {
-        }
-
-        public TemplateMessage(ErrorType error, Template template)
-            : this(error, template, null, null, null)
-        {
-        }
-
-        public TemplateMessage(ErrorType error, Template template, Exception source)
-            : this(error, template, source, null, null)
-        {
-        }
-
-        public TemplateMessage(ErrorType error, Template template, Exception source, IToken token)
-            : this(error, template, source, null, null)
-        {
-            this.Token = token;
-        }
-
-        public TemplateMessage(ErrorType error, Template template, Exception source, object arg)
-            : this(error, template, source, arg, null)
-        {
-        }
-
-        public TemplateMessage(ErrorType error, Template template, Exception source, IToken token, object arg)
-            : this(error, template, source, arg, null)
-        {
-            this.Token = token;
-        }
-
-        public TemplateMessage(ErrorType error, Template template, Exception source, object arg1, object arg2)
-        {
-            this.ErrorType = error;
-            this.Template = template;
-            this.Source = source;
-            this.Argument1 = arg1;
-            this.Argument2 = arg2;
-        }
-
-        public ErrorType ErrorType
-        {
-            get;
-            private set;
-        }
-
-        public object Argument1
-        {
-            get;
-            private set;
-        }
-
-        public object Argument2
-        {
-            get;
-            private set;
-        }
-
-        public Template Template
-        {
-            get;
-            private set;
-        }
-
-        public IToken Token
-        {
-            get;
-            private set;
-        }
-
-        public string Message
-        {
-            get
-            {
-                return string.Format(ErrorType.MessageFormat, Argument1, Argument2);
-            }
-        }
-
-        public Exception Source
-        {
-            get;
-            private set;
-        }
-
-        public override string ToString()
-        {
-            StringBuilder builder = new StringBuilder(Message);
-
-            if (Source != null)
-            {
-                builder.AppendLine(Source.StackTrace);
-            }
-
-            return builder.ToString();
-        }
-    }
-}
diff --git a/StringTemplate4/TemplateName.cs b/StringTemplate4/TemplateName.cs
deleted file mode 100644
index 0d1e8bc..0000000
--- a/StringTemplate4/TemplateName.cs
+++ /dev/null
@@ -1,139 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate
-{
-    using ArgumentException = System.ArgumentException;
-    using ArgumentNullException = System.ArgumentNullException;
-    using System.Text.RegularExpressions;
-
-    public sealed class TemplateName
-    {
-        public const char TemplateDirectorySeparator = '/';
-        public static readonly TemplateName Root = new TemplateName("/");
-
-        private static readonly Regex FullNameValidator = new Regex(@"^(?:[a-z_][a-z0-9_\-]*)?(?:/[a-z_][a-z0-9_\-]*)*$", RegexOptions.Compiled | RegexOptions.IgnoreCase);
-
-        private readonly string _name;
-
-        public TemplateName(string name)
-        {
-            if (name == null)
-                throw new ArgumentNullException("name");
-            if (name.Length == 0 || (name != TemplateDirectorySeparator.ToString() && !FullNameValidator.IsMatch(name)))
-                throw new ArgumentException("name is not in the correct format", "name");
-
-            this._name = name;
-        }
-
-        public string FullName
-        {
-            get
-            {
-                return _name;
-            }
-        }
-
-        public bool IsRooted
-        {
-            get
-            {
-                return _name[0] == TemplateDirectorySeparator;
-            }
-        }
-
-        public string Name
-        {
-            get
-            {
-                int lastSeparator = _name.LastIndexOf(TemplateDirectorySeparator);
-                if (lastSeparator < 0)
-                    return _name;
-
-                return _name.Substring(lastSeparator + 1);
-            }
-        }
-
-        public static TemplateName Combine(TemplateName left, string right)
-        {
-            return Combine(left, new TemplateName(right));
-        }
-
-        public static TemplateName Combine(TemplateName left, TemplateName right)
-        {
-            if (left == null)
-                throw new ArgumentNullException("left");
-            if (right == null)
-                throw new ArgumentNullException("right");
-
-            if (left == Root)
-                return right.IsRooted ? right : new TemplateName(TemplateDirectorySeparator + right.FullName);
-
-            if (right.IsRooted)
-                return new TemplateName(left.FullName + right.FullName);
-            else
-                return new TemplateName(left.FullName + TemplateDirectorySeparator + right.FullName);
-        }
-
-        public static bool operator ==(TemplateName left, TemplateName right)
-        {
-            if (object.ReferenceEquals(left, null))
-                return object.ReferenceEquals(right, null);
-
-            return left.Equals(right);
-        }
-
-        public static bool operator !=(TemplateName left, TemplateName right)
-        {
-            return !(left == right);
-        }
-
-        public override bool Equals(object obj)
-        {
-            TemplateName other = obj as TemplateName;
-            if (other == null)
-                return false;
-
-            return other._name == _name;
-        }
-
-        public override int GetHashCode()
-        {
-            return _name.GetHashCode();
-        }
-
-        public override string ToString()
-        {
-            return _name;
-        }
-    }
-}
diff --git a/StringTemplate4/TemplateRuntimeMessage.cs b/StringTemplate4/TemplateRuntimeMessage.cs
deleted file mode 100644
index 88fde91..0000000
--- a/StringTemplate4/TemplateRuntimeMessage.cs
+++ /dev/null
@@ -1,103 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate
-{
-    using StringTemplate.Compiler;
-    using Exception = System.Exception;
-    using StringBuilder = System.Text.StringBuilder;
-
-    public class TemplateRuntimeMessage : TemplateMessage
-    {
-        /** Where error occurred in bytecode memory */
-        private int ip = -1;
-
-        public TemplateRuntimeMessage(ErrorType error, int ip)
-            : this(error, ip, null)
-        {
-        }
-
-        public TemplateRuntimeMessage(ErrorType error, int ip, Template template)
-            : this(error, ip, template, null)
-        {
-        }
-
-        public TemplateRuntimeMessage(ErrorType error, int ip, Template template, Exception source)
-            : this(error, ip, template, source, null)
-        {
-        }
-
-        public TemplateRuntimeMessage(ErrorType error, int ip, Template template, Exception source, object arg)
-            : this(error, ip, template, source, arg, null)
-        {
-        }
-
-        public TemplateRuntimeMessage(ErrorType error, int ip, Template template, Exception source, object arg, object arg2)
-            : base(error, template, source, arg, arg2)
-        {
-            this.ip = ip;
-        }
-
-        /** Given an ip (code location), get it's range in source template then
-         *  return it's template line:col.
-         */
-        public string GetSourceLocation()
-        {
-            if (ip < 0)
-                return string.Empty;
-
-            Interval I = Template.code.sourceMap[ip];
-            if (I == null)
-                return null;
-            // get left edge and get line/col
-            int i = I.A;
-            Coordinate loc = Misc.GetLineCharPosition(Template.code.template, i);
-            return loc.ToString();
-        }
-
-        public override string ToString()
-        {
-            StringBuilder buf = new StringBuilder();
-            string loc = GetSourceLocation();
-            if (Template != null)
-            {
-                buf.Append("context [");
-                buf.Append(Template.GetEnclosingInstanceStackString());
-                buf.Append("]");
-            }
-            if (!string.IsNullOrEmpty(loc))
-                buf.Append(" " + loc);
-            buf.Append(" " + base.ToString());
-            return buf.ToString();
-        }
-    }
-}
diff --git a/StringTemplate4/TemplateSyntaxErrorMessage.cs b/StringTemplate4/TemplateSyntaxErrorMessage.cs
deleted file mode 100644
index 8ef1c42..0000000
--- a/StringTemplate4/TemplateSyntaxErrorMessage.cs
+++ /dev/null
@@ -1,74 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate
-{
-    using Antlr.Runtime;
-    using ArgumentNullException = System.ArgumentNullException;
-    using Exception = System.Exception;
-
-    public class TemplateSyntaxErrorMessage : TemplateMessage
-    {
-        private string _message;
-
-        public TemplateSyntaxErrorMessage(ErrorType error, IToken token)
-            : this(error, token, null)
-        {
-        }
-
-        public TemplateSyntaxErrorMessage(ErrorType error, IToken token, Exception innerException)
-            : this(error, token, innerException, null)
-        {
-        }
-
-        public TemplateSyntaxErrorMessage(ErrorType error, IToken token, Exception innerException, string message)
-            : this(error, token, innerException, message, null)
-        {
-        }
-
-        public TemplateSyntaxErrorMessage(ErrorType error, IToken token, Exception innerException, string message, object arg)
-            : base(error, null, innerException, arg)
-        {
-            this._message = message;
-        }
-
-        public override string ToString()
-        {
-            RecognitionException re = (RecognitionException)Source;
-            string header = re.Line + ":" + re.CharPositionInLine;
-            if (Argument1 == null)
-                return string.Format(ErrorType.MessageFormat, header + ": " + _message);
-
-            return string.Format(ErrorType.MessageFormat, Argument1 + " " + header + ": " + _message);
-        }
-    }
-}

