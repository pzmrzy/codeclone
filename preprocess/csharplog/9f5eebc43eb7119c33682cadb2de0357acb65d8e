commit 9f5eebc43eb7119c33682cadb2de0357acb65d8e
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Tue Feb 15 16:25:29 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Tue Feb 15 16:25:29 2011 -0800

(C# 3) Updated bootstrap binaries

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 7706]

diff --git a/Antlr3.StringTemplate/Properties/AssemblyInfo.cs b/Antlr3.StringTemplate/Properties/AssemblyInfo.cs
index 63b9727..dd523d6 100644
--- a/Antlr3.StringTemplate/Properties/AssemblyInfo.cs
+++ b/Antlr3.StringTemplate/Properties/AssemblyInfo.cs
@@ -66,5 +66,5 @@ using System.Runtime.InteropServices;
*      the Major or Minor version is incremented.
*   3. Revision is the Perforce changelist number associated with the release.
*/
-[assembly: AssemblyVersion("3.3.0.7239")]
-[assembly: AssemblyFileVersion("3.3.0.7239")]
+[assembly: AssemblyVersion("3.3.1.7705")]
+[assembly: AssemblyFileVersion("3.3.1.7705")]
diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp3/Properties/AssemblyInfo.cs b/Antlr3.Targets/Antlr3.Targets.CSharp3/Properties/AssemblyInfo.cs
index f46401f..b6656e8 100644
--- a/Antlr3.Targets/Antlr3.Targets.CSharp3/Properties/AssemblyInfo.cs
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp3/Properties/AssemblyInfo.cs
@@ -66,5 +66,5 @@ using System.Runtime.InteropServices;
*      the Major or Minor version is incremented.
*   3. Revision is the Perforce changelist number associated with the release.
*/
-[assembly: AssemblyVersion("3.3.0.7239")]
-[assembly: AssemblyFileVersion("3.3.0.7239")]
+[assembly: AssemblyVersion("3.3.1.7705")]
+[assembly: AssemblyFileVersion("3.3.1.7705")]
diff --git a/Antlr3/Properties/AssemblyInfo.cs b/Antlr3/Properties/AssemblyInfo.cs
index bb3924c..835187d 100644
--- a/Antlr3/Properties/AssemblyInfo.cs
+++ b/Antlr3/Properties/AssemblyInfo.cs
@@ -66,5 +66,5 @@ using System.Runtime.InteropServices;
*      the Major or Minor version is incremented.
*   3. Revision is the Perforce changelist number associated with the release.
*/
-[assembly: AssemblyVersion("3.3.0.7239")]
-[assembly: AssemblyFileVersion("3.3.0.7239")]
+[assembly: AssemblyVersion("3.3.1.7705")]
+[assembly: AssemblyFileVersion("3.3.1.7705")]
diff --git a/bin/Bootstrap/Antlr3.Runtime.Debug.dll b/bin/Bootstrap/Antlr3.Runtime.Debug.dll
index efaaa23..346df65 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.Debug.dll and b/bin/Bootstrap/Antlr3.Runtime.Debug.dll differ
diff --git a/bin/Bootstrap/Antlr3.Runtime.dll b/bin/Bootstrap/Antlr3.Runtime.dll
index 87cbbe1..91d1782 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.dll and b/bin/Bootstrap/Antlr3.Runtime.dll differ
diff --git a/bin/Bootstrap/Antlr3.StringTemplate.dll b/bin/Bootstrap/Antlr3.StringTemplate.dll
index aa5b866..b43a431 100644
Binary files a/bin/Bootstrap/Antlr3.StringTemplate.dll and b/bin/Bootstrap/Antlr3.StringTemplate.dll differ
diff --git a/bin/Bootstrap/Antlr3.exe b/bin/Bootstrap/Antlr3.exe
index 558854c..7ddcda1 100755
Binary files a/bin/Bootstrap/Antlr3.exe and b/bin/Bootstrap/Antlr3.exe differ
diff --git a/bin/Bootstrap/AntlrBuildTask.dll b/bin/Bootstrap/AntlrBuildTask.dll
index 99c72c7..0b1c871 100644
Binary files a/bin/Bootstrap/AntlrBuildTask.dll and b/bin/Bootstrap/AntlrBuildTask.dll differ
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTParser.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTParser.stg
index fc0bed0..ec93fd7 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTParser.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTParser.stg
@@ -179,9 +179,9 @@ root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_0);

createNodeFromToken(label,terminalOptions) ::= <<
<if(terminalOptions.class)>
-new <terminalOptions.class>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text><endif>)
+new <terminalOptions.class>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>)
<else>
-(<ASTLabelType>)adaptor.Create(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text><endif>)
+(<ASTLabelType>)adaptor.Create(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>)
<endif>
>>

diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg
index 461d2c0..1b6bbf8 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg
@@ -120,9 +120,9 @@ _last = (<ASTLabelType>)input.LT(1);
<if(!rewriteMode)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<if(terminalOptions.class)>
-<label>_tree = new <terminalOptions.class>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text><endif>);
+<label>_tree = new <terminalOptions.class>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
<else>
-<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text><endif>);
+<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
<endif><\n>
adaptor.AddChild(root_<treeLevel>, <label>_tree);
<if(backtracking)>}<endif>
@@ -145,9 +145,9 @@ _last = (<ASTLabelType>)input.LT(1);
<if(!rewriteMode)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<if(terminalOptions.class)>
-<label>_tree = new <terminalOptions.class>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text><endif>);
+<label>_tree = new <terminalOptions.class>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
<else>
-<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text><endif>);
+<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
<endif><\n>
root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_<treeLevel>);
<if(backtracking)>}<endif>
@@ -183,9 +183,9 @@ _last = (<ASTLabelType>)input.LT(1);
<if(!rewriteMode)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<if(terminalOptions.class)>
-<label>_tree = new <terminalOptions.class>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text><endif>);
+<label>_tree = new <terminalOptions.class>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
<else>
-<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text><endif>);
+<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
<endif><\n>
adaptor.AddChild(root_<treeLevel>, <label>_tree);
<if(backtracking)>}<endif>
@@ -209,9 +209,9 @@ matchSetRuleRoot(s,label,terminalOptions,elementIndex,debug) ::= <<
<if(!rewriteMode)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<if(terminalOptions.class)>
-<label>_tree = new <terminalOptions.class>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text><endif>);
+<label>_tree = new <terminalOptions.class>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
<else>
-<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text><endif>);
+<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
<endif><\n>
root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_<treeLevel>);
<if(backtracking)>}<endif>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
index 56910ae..63fa4b3 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
@@ -112,7 +112,7 @@ lexer(grammar, name, tokens, scopes, rules, numRules, labelType="CommonToken",
[System.CLSCompliant(false)]
public partial class <grammar.recognizerName> : <@superClassName><superClass><@end>
{
-	<tokens:{public const int <it.name>=<it.type>;}; separator="\n">
+	<tokens:{public const int <it.name; format="id">=<it.type>;}; separator="\n">
<scopes:{<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>
<actions.lexer.members>

@@ -284,7 +284,7 @@ public partial class <grammar.recognizerName> : <@superClassName><superClass><@e
"\<invalid>", "\<EOR>", "\<DOWN>", "\<UP>", <tokenNames; separator=", ">
};<\n>
<endif>
-	<tokens:{public const int <it.name>=<it.type>;}; separator="\n">
+	<tokens:{public const int <it.name; format="id">=<it.type>;}; separator="\n">

// delegates
<grammar.delegates:
@@ -332,7 +332,7 @@ public <grammar.recognizerName>(<inputStreamType> input, RecognizerSharedState s
appear to be defined in this recognizer. !>
#region Delegated rules
<grammar.delegatedRules:{ruleDescriptor|
-	public <returnType()> <ruleDescriptor.name>(<ruleDescriptor.parameterScope:parameterScope(scope=it)>) <!throws RecognitionException !>\{ <if(ruleDescriptor.hasReturnValue)>return <endif><ruleDescriptor.grammar:delegateName()>.<ruleDescriptor.name>(<ruleDescriptor.parameterScope.attributes:{a|<a.name>}; separator=", ">); \}}; separator="\n">
+	public <returnType()> <ruleDescriptor.name; format="id">(<ruleDescriptor.parameterScope:parameterScope(scope=it)>) <!throws RecognitionException !>\{ <if(ruleDescriptor.hasReturnValue)>return <endif><ruleDescriptor.grammar:delegateName()>.<ruleDescriptor.name; format="id">(<ruleDescriptor.parameterScope.attributes:{a|<a.name; format="id">}; separator=", ">); \}}; separator="\n">
#endregion Delegated rules<\n>
<endif>

@@ -487,7 +487,7 @@ partial void LeaveRule_<ruleName>();
// $ANTLR start "<ruleName>"
// <fileName>:<description>
[GrammarRule("<ruleName>")]
-<csharpVisibilityMap.(ruleDescriptor.modifier); null="private"> <returnType()> <ruleName>(<ruleDescriptor.parameterScope:parameterScope(scope=it)>)
+<csharpVisibilityMap.(ruleDescriptor.modifier); null="private"> <returnType()> <ruleName; format="id">(<ruleDescriptor.parameterScope:parameterScope(scope=it)>)
{
EnterRule_<ruleName>();
EnterRule("<ruleName>", <ruleDescriptor.index>);
@@ -552,7 +552,7 @@ ruleDeclarations() ::= <<
retval.Start = (<labelType>)input.LT(1);<\n>
<else>
<ruleDescriptor.returnScope.attributes:{ a |
-<a.type> <a.name> = <if(a.initValue)><a.initValue><else><initValue(a.type)><endif>;
+<a.type> <a.name; format="id"> = <if(a.initValue)><a.initValue><else><initValue(a.type)><endif>;
}>
<endif>
<if(memoize)>
@@ -1004,7 +1004,7 @@ wildcardCharListLabel(label, elementIndex) ::= <<
*/
ruleRef(rule,label,elementIndex,args,scope) ::= <<
PushFollow(Follow._<rule.name>_in_<ruleName><elementIndex>);
-<if(label)><label>=<endif><if(scope)><scope:delegateName()>.<endif><rule.name>(<args; separator=", ">);
+<if(label)><label>=<endif><if(scope)><scope:delegateName()>.<endif><rule.name; format="id">(<args; separator=", ">);
PopFollow();
<checkRuleBacktrackFailure()>
>>
@@ -1485,43 +1485,48 @@ parameterScope(scope) ::= <<
<scope.attributes:{<it.decl>}; separator=", ">
>>

-parameterAttributeRef(attr) ::= "<attr.name>"
-parameterSetAttributeRef(attr,expr) ::= "<attr.name> =<expr>;"
+parameterAttributeRef(attr) ::= <<
+<attr.name; format="id">
+>>
+
+parameterSetAttributeRef(attr,expr) ::= <<
+<attr.name; format="id"> =<expr>;
+>>

scopeAttributeRef(scope,attr,index,negIndex) ::= <<
<if(negIndex)>
-((<scope>_scope)<scope>_stack.elementAt(<scope>_stack.size()-<negIndex>-1)).<attr.name>
+System.Linq.Enumerable.ElementAt(<scope>_stack, <negIndex>).<attr.name; format="id">
<else>
<if(index)>
-((<scope>_scope)<scope>_stack.elementAt(<index>)).<attr.name>
+System.Linq.Enumerable.ElementAt(<scope>_stack, <scope>_stack.Count-<index>-1).<attr.name; format="id">
<else>
-((<scope>_scope)<scope>_stack.Peek()).<attr.name>
+<scope>_stack.Peek().<attr.name; format="id">
<endif>
<endif>
>>

scopeSetAttributeRef(scope,attr,expr,index,negIndex) ::= <<
<if(negIndex)>
-((<scope>_scope)<scope>_stack.elementAt(<scope>_stack.size()-<negIndex>-1)).<attr.name> =<expr>;
+System.Linq.Enumerable.ElementAt(<scope>_stack, <negIndex>).<attr.name; format="id"> = <expr>;
<else>
<if(index)>
-((<scope>_scope)<scope>_stack.elementAt(<index>)).<attr.name> =<expr>;
+System.Linq.Enumerable.ElementAt(<scope>_stack, <scope>_stack.Count-<index>-1).<attr.name; format="id"> = <expr>;
<else>
-((<scope>_scope)<scope>_stack.Peek()).<attr.name> =<expr>;
+<scope>_stack.Peek().<attr.name; format="id"> = <expr>;
<endif>
<endif>
>>

/** $x is either global scope or x is rule with dynamic scope; refers
*  to stack itself not top of stack.  This is useful for predicates
- *  like {$function.size()>0 && $function::name.equals("foo")}?
+ *  like {$function.Count>0 && $function::name.Equals("foo")}?
*/
isolatedDynamicScopeRef(scope) ::= "<scope>_stack"

/** reference an attribute of rule; might only have single return value */
ruleLabelRef(referencedRule,scope,attr) ::= <<
<if(referencedRule.hasMultipleReturnValues)>
-(<scope>!=null?<scope>.<attr.name>:<initValue(attr.type)>)
+(<scope>!=null?<scope>.<attr.name; format="id">:<initValue(attr.type)>)
<else>
<scope>
<endif>
@@ -1529,17 +1534,17 @@ ruleLabelRef(referencedRule,scope,attr) ::= <<

returnAttributeRef(ruleDescriptor,attr) ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
-retval.<attr.name>
+retval.<attr.name; format="id">
<else>
-<attr.name>
+<attr.name; format="id">
<endif>
>>

returnSetAttributeRef(ruleDescriptor,attr,expr) ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
-retval.<attr.name> =<expr>;
+retval.<attr.name; format="id"> =<expr>;
<else>
-<attr.name> =<expr>;
+<attr.name; format="id"> =<expr>;
<endif>
>>

diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/ST.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/ST.stg
index f94cb7f..ff5a2cf 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/ST.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/ST.stg
@@ -50,12 +50,12 @@ public override string ToString() { return (Template==null) ? string.Empty : Tem

@genericParser.members() ::= <<
<@super.members()>
-protected StringTemplateGroup templateLib = new StringTemplateGroup("<name>Templates", typeof(AngleBracketTemplateLexer) );
+private StringTemplateGroup _templateGroup = new StringTemplateGroup("<name>Templates", typeof(AngleBracketTemplateLexer) );

-public StringTemplateGroup TemplateLib
+public StringTemplateGroup TemplateGroup
{
-	get { return templateLib; }
-	set { templateLib = value; }
+	get { return _templateGroup; }
+	set { _templateGroup = value; }
}
>>

@@ -119,23 +119,27 @@ null;
*  template.
*/
rewriteExternalTemplate(name,args) ::= <<
-templateLib.GetInstanceOf("<name>"<if(args)>,
-	new STAttrMap()<args:{a | .put("<a.name>", <a.value>)}>
-	<endif>)
+TemplateGroup.GetInstanceOf("<name>"<optionalArguments(args)>)
>>

/** expr is a string expression that says what template to load */
rewriteIndirectTemplate(expr,args) ::= <<
-templateLib.GetInstanceOf(<expr><if(args)>,
-	new STAttrMap()<args:{a | .put("<a.name>", <a.value>)}>
-	<endif>)
+TemplateGroup.GetInstanceOf(<expr><optionalArguments(args)>)
>>

/** Invoke an inline template with a set of attribute name/value pairs */
rewriteInlineTemplate(args, template) ::= <<
-new StringTemplate(templateLib, "<template>"<if(args)>,
-	new STAttrMap()<args:{a | .put("<a.name>", <a.value>)}>
-	<endif>)
+new StringTemplate(TemplateGroup, "<template>"<optionalArguments(args)>)
+>>
+
+optionalArguments(args) ::= <<
+<if(args)>,
+	new Dictionary\<string, object>() { <args:optionalArgument(); separator=", "> }
+<endif>
+>>
+
+optionalArgument() ::= <<
+{"<it.name>", <it.value>}
>>

/** plain -> {foo} action */
@@ -150,5 +154,5 @@ actionSetAttribute(st,attrName,expr) ::= <<

/** Translate %{stringExpr} */
actionStringConstructor(stringExpr) ::= <<
-new StringTemplate(templateLib,<stringExpr>)
+new StringTemplate(TemplateGroup,<stringExpr>)
>>
diff --git a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll
index 923b254..ef3acdc 100644
Binary files a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll and b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll differ

