commit 509c13be0c722a041fe777b1007318f6f14bf2fa
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Thu Apr 16 14:45:35 2009 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Thu Apr 16 14:45:35 2009 -0800

C# Port:
* More Capitalized method names

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 6035]

diff --git a/Antlr3.Test/TestCharDFAConversion.cs b/Antlr3.Test/TestCharDFAConversion.cs
index 1ba1708..27c3475 100644
--- a/Antlr3.Test/TestCharDFAConversion.cs
+++ b/Antlr3.Test/TestCharDFAConversion.cs
@@ -238,7 +238,7 @@ namespace AntlrUnitTests
// This is ok because we've already verified there are no problems
// with the enter/exit decision
DFAOptimizer optimizer = new DFAOptimizer( g );
-            optimizer.optimize();
+            optimizer.Optimize();
FASerializer serializer = new FASerializer( g );
DFA dfa = g.getLookaheadDFA( 1 );
string result = serializer.serialize( dfa.startState );
diff --git a/Antlr3.Test/TestDFAMatching.cs b/Antlr3.Test/TestDFAMatching.cs
index e225ac7..fc7f36f 100644
--- a/Antlr3.Test/TestDFAMatching.cs
+++ b/Antlr3.Test/TestDFAMatching.cs
@@ -109,7 +109,7 @@ namespace AntlrUnitTests
//throws Exception
{
ANTLRStringStream stream = new ANTLRStringStream( input );
-            assertEquals( dfa.predict( stream ), expected );
+            assertEquals( dfa.Predict( stream ), expected );
}

}
diff --git a/Antlr3/Analysis/DFA.cs b/Antlr3/Analysis/DFA.cs
index 9842d91..c24b07a 100644
--- a/Antlr3/Analysis/DFA.cs
+++ b/Antlr3/Analysis/DFA.cs
@@ -243,16 +243,16 @@ namespace Antlr3.Analysis
nfa = decisionStartState.nfa;
_nAlts = nfa.grammar.getNumberOfAltsForDecisionNFA( decisionStartState );
//setOptions( nfa.grammar.getDecisionOptions(getDecisionNumber()) );
-            initAltRelatedInfo();
+            InitAltRelatedInfo();

//long start = JSystem.currentTimeMillis();
_nfaConverter = new NFAToDFAConverter( this );
try
{
-                _nfaConverter.convert();
+                _nfaConverter.Convert();

// figure out if there are problems with decision
-                verify();
+                Verify();

if ( !probe.IsDeterministic || probe.AnalysisOverflowed )
{
@@ -262,7 +262,7 @@ namespace Antlr3.Analysis
// must be after verify as it computes cyclic, needed by this routine
// should be after warnings because early termination or something
// will not allow the reset to operate properly in some cases.
-                resetStateNumbersToBeContiguous();
+                ResetStateNumbersToBeContiguous();

//long stop = JSystem.currentTimeMillis();
//JSystem.@out.println("verify cost: "+(int)(stop-start)+" ms");
@@ -307,9 +307,13 @@ namespace Antlr3.Analysis
{
get
{
-                return getAutoBacktrackMode();
+                return GetAutoBacktrackMode();
}
}
+        /** What GrammarAST node (derived from the grammar) is this DFA
+         *  associated with?  It will point to the start of a block or
+         *  the loop back of a (...)+ block etc...
+         */
public GrammarAST DecisionASTNode
{
get
@@ -331,6 +335,12 @@ namespace Antlr3.Analysis
return _description;
}
}
+        /** Is this DFA cyclic?  That is, are there any loops?  If not, then
+         *  the DFA is essentially an LL(k) predictor for some fixed, max k value.
+         *  We can build a series of nested IF statements to match this.  In the
+         *  presence of cycles, we need to build a general DFA and interpret it
+         *  to distinguish between alternatives.
+         */
public bool IsCyclic
{
get
@@ -342,9 +352,14 @@ namespace Antlr3.Analysis
{
get
{
-                return isGreedy();
+                return GetIsGreedy();
}
}
+        /** Is the DFA reduced?  I.e., does every state have a path to an accept
+         *  state?  If not, don't delete as we need to generate an error indicating
+         *  which paths are "dead ends".  Also tracks list of alts with no accept
+         *  state in the DFA.  Must call verify() first before this makes sense.
+         */
public bool IsReduced
{
get
@@ -356,9 +371,10 @@ namespace Antlr3.Analysis
{
get
{
-                return isTokensRuleDecision();
+                return GetIsTokensRuleDecision();
}
}
+        /** Return k if decision is LL(k) for some k else return max int */
public int MaxLookaheadDepth
{
get
@@ -370,6 +386,9 @@ namespace Antlr3.Analysis
return max_k;
}
}
+        /** What is the max state number ever created?  This may be beyond
+         *  getNumberOfStates().
+         */
public int MaxStateNumber
{
get
@@ -415,14 +434,14 @@ namespace Antlr3.Analysis
{
get
{
-                return okToRetryDFAWithK1();
+                return OkToRetryDFAWithK1();
}
}
public string ReasonForFailure
{
get
{
-                return getReasonForFailure();
+                return GetReasonForFailure();
}
}
public IList<StringTemplate> SpecialStateSTs
@@ -439,6 +458,10 @@ namespace Antlr3.Analysis
return _uniqueStates;
}
}
+        /** Return a list of Integer alt numbers for which no lookahead could
+         *  be computed or for which no single DFA accept state predicts those
+         *  alts.  Must call verify() first before this makes sense.
+         */
public List<int> UnreachableAlts
{
get
@@ -454,7 +477,7 @@ namespace Antlr3.Analysis
{
get
{
-                return getUserMaxLookahead();
+                return GetUserMaxLookahead();
}
}
#endregion
@@ -473,7 +496,7 @@ namespace Antlr3.Analysis
*  of state numbers from all states should represent a contiguous range
*  from 0..n-1 where n is the number of unique states.
*/
-        public virtual void resetStateNumbersToBeContiguous()
+        public virtual void ResetStateNumbersToBeContiguous()
{
if ( UserMaxLookahead > 0 )
{
@@ -486,7 +509,7 @@ namespace Antlr3.Analysis
int snum = 0;
for ( int i = 0; i <= MaxStateNumber; i++ )
{
-                DFAState s = getState( i );
+                DFAState s = GetState( i );
// some states are unused after creation most commonly due to cycles
// or conflict resolution.
if ( s == null )
@@ -519,31 +542,31 @@ namespace Antlr3.Analysis
// or even consistently formatted strings acceptable to java that
// I am forced to build the individual char elements here

-        public virtual List<string> getJavaCompressedAccept()
+        public virtual List<string> GetJavaCompressedAccept()
{
-            return getRunLengthEncoding( _accept );
+            return GetRunLengthEncoding( _accept );
}
-        public virtual List<string> getJavaCompressedEOT()
+        public virtual List<string> GetJavaCompressedEOT()
{
-            return getRunLengthEncoding( _eot );
+            return GetRunLengthEncoding( _eot );
}
-        public virtual List<string> getJavaCompressedEOF()
+        public virtual List<string> GetJavaCompressedEOF()
{
-            return getRunLengthEncoding( _eof );
+            return GetRunLengthEncoding( _eof );
}
-        public virtual List<string> getJavaCompressedMin()
+        public virtual List<string> GetJavaCompressedMin()
{
-            return getRunLengthEncoding( _min );
+            return GetRunLengthEncoding( _min );
}
-        public virtual List<string> getJavaCompressedMax()
+        public virtual List<string> GetJavaCompressedMax()
{
-            return getRunLengthEncoding( _max );
+            return GetRunLengthEncoding( _max );
}
-        public virtual List<string> getJavaCompressedSpecial()
+        public virtual List<string> GetJavaCompressedSpecial()
{
-            return getRunLengthEncoding( _special );
+            return GetRunLengthEncoding( _special );
}
-        public virtual List<List<string>> getJavaCompressedTransition()
+        public virtual List<List<string>> GetJavaCompressedTransition()
{
if ( _transition == null || _transition.Length == 0 )
{
@@ -554,7 +577,7 @@ namespace Antlr3.Analysis
for ( int i = 0; i < _transition.Length; i++ )
{
var transitionsForState = _transition[i];
-                encoded.Add( getRunLengthEncoding( transitionsForState ) );
+                encoded.Add( GetRunLengthEncoding( transitionsForState ) );
}
return encoded;
}
@@ -569,7 +592,7 @@ namespace Antlr3.Analysis
*  and \uFFFF for 16bit.  Hideous and specific to Java, but it is the
*  only target bad enough to need it.
*/
-        public virtual List<string> getRunLengthEncoding( int[] data )
+        public virtual List<string> GetRunLengthEncoding( int[] data )
{
if ( data == null || data.Length == 0 )
{
@@ -616,7 +639,7 @@ namespace Antlr3.Analysis
return encoded;
}

-        public virtual void createStateTables( CodeGenerator generator )
+        public virtual void CreateStateTables( CodeGenerator generator )
{
//JSystem.@out.println("createTables:\n"+this);
this._generator = generator;
@@ -671,14 +694,14 @@ namespace Antlr3.Analysis
if ( s.IsAcceptState )
{
// can't compute min,max,special,transition on accepts
-                    _accept[s.stateNumber] = s.getUniquelyPredictedAlt();
+                    _accept[s.stateNumber] = s.GetUniquelyPredictedAlt();
}
else
{
-                    createMinMaxTables( s );
-                    createTransitionTableEntryForState( s );
-                    createSpecialTable( s );
-                    createEOTAndEOFTables( s );
+                    CreateMinMaxTables( s );
+                    CreateTransitionTableEntryForState( s );
+                    CreateSpecialTable( s );
+                    CreateEOTAndEOFTables( s );
}
}

@@ -708,7 +731,7 @@ namespace Antlr3.Analysis
}

#if false
-        private void testEncodeDecode( int[] data )
+        private void TestEncodeDecode( int[] data )
{
JSystem.@out.println( "data=" + data );
var encoded = getRunLengthEncoding( data );
@@ -743,13 +766,13 @@ namespace Antlr3.Analysis
}
#endif

-        protected virtual void createMinMaxTables( DFAState s )
+        protected virtual void CreateMinMaxTables( DFAState s )
{
int smin = Label.MAX_CHAR_VALUE + 1;
int smax = Label.MIN_ATOM_VALUE - 1;
for ( int j = 0; j < s.NumberOfTransitions; j++ )
{
-                Transition edge = (Transition)s.transition( j );
+                Transition edge = (Transition)s.Transition( j );
Label label = edge.label;
if ( label.IsAtom )
{
@@ -797,7 +820,7 @@ namespace Antlr3.Analysis
}
}

-        protected virtual void createTransitionTableEntryForState( DFAState s )
+        protected virtual void CreateTransitionTableEntryForState( DFAState s )
{
/*
JSystem.@out.println("createTransitionTableEntryForState s"+s.stateNumber+
@@ -813,7 +836,7 @@ namespace Antlr3.Analysis
_transition[s.stateNumber] = stateTransitions;
for ( int j = 0; j < s.NumberOfTransitions; j++ )
{
-                Transition edge = s.transition( j );
+                Transition edge = s.Transition( j );
Label label = edge.label;
if ( label.IsAtom && label.Atom >= Label.MIN_CHAR_VALUE )
{
@@ -850,11 +873,11 @@ namespace Antlr3.Analysis
/** Set up the EOT and EOF tables; we cannot put -1 min/max values so
*  we need another way to test that in the DFA transition function.
*/
-        protected virtual void createEOTAndEOFTables( DFAState s )
+        protected virtual void CreateEOTAndEOFTables( DFAState s )
{
for ( int j = 0; j < s.NumberOfTransitions; j++ )
{
-                Transition edge = s.transition( j );
+                Transition edge = s.Transition( j );
Label label = edge.label;
if ( label.IsAtom )
{
@@ -884,7 +907,7 @@ namespace Antlr3.Analysis
}
}

-        protected virtual void createSpecialTable( DFAState s )
+        protected virtual void CreateSpecialTable( DFAState s )
{
// number all special states from 0...n-1 instead of their usual numbers
bool hasSemPred = false;
@@ -892,12 +915,12 @@ namespace Antlr3.Analysis
// TODO this code is very similar to canGenerateSwitch.  Refactor to share
for ( int j = 0; j < s.NumberOfTransitions; j++ )
{
-                Transition edge = (Transition)s.transition( j );
+                Transition edge = (Transition)s.Transition( j );
Label label = edge.label;
// can't do a switch if the edges have preds or are going to
// require gated predicates
if ( label.IsSemanticPredicate ||
-                     ( (DFAState)edge.target ).getGatedPredicatesInNFAConfigurations() != null )
+                     ( (DFAState)edge.target ).GetGatedPredicatesInNFAConfigurations() != null )
{
hasSemPred = true;
break;
@@ -918,7 +941,7 @@ namespace Antlr3.Analysis
}
}

-        public virtual int predict( IIntStream input )
+        public virtual int Predict( IIntStream input )
{
Interpreter interp = new Interpreter( nfa.grammar, input );
return interp.predict( this );
@@ -931,7 +954,7 @@ namespace Antlr3.Analysis
*  don't updated uniqueStates, just return incoming state, which
*  indicates it's a new state.
*/
-        protected internal virtual DFAState addState( DFAState d )
+        protected internal virtual DFAState AddState( DFAState d )
{
if ( UserMaxLookahead > 0 )
{
@@ -956,7 +979,7 @@ namespace Antlr3.Analysis
return d;
}

-        public void removeState( DFAState d )
+        public void RemoveState( DFAState d )
{
DFAState it;
if ( _uniqueStates.TryGetValue( d, out it ) )
@@ -969,62 +992,18 @@ namespace Antlr3.Analysis
}
}

-        [Obsolete]
-        public IDictionary<DFAState, DFAState> getUniqueStates()
-        {
-            return UniqueStates;
-        }
-
-        /** What is the max state number ever created?  This may be beyond
-         *  getNumberOfStates().
-         */
-        [Obsolete]
-        public int getMaxStateNumber()
-        {
-            return MaxStateNumber;
-        }
-
-        public virtual DFAState getState( int stateNumber )
+        public virtual DFAState GetState( int stateNumber )
{
return (DFAState)_states[stateNumber];
}

-        public virtual void setState( int stateNumber, DFAState d )
+        public virtual void SetState( int stateNumber, DFAState d )
{
_states[stateNumber] = d;
}

-        /** Is the DFA reduced?  I.e., does every state have a path to an accept
-         *  state?  If not, don't delete as we need to generate an error indicating
-         *  which paths are "dead ends".  Also tracks list of alts with no accept
-         *  state in the DFA.  Must call verify() first before this makes sense.
-         */
-        [Obsolete]
-        public virtual bool isReduced()
-        {
-            return IsReduced;
-        }
-
-        /** Is this DFA cyclic?  That is, are there any loops?  If not, then
-         *  the DFA is essentially an LL(k) predictor for some fixed, max k value.
-         *  We can build a series of nested IF statements to match this.  In the
-         *  presence of cycles, we need to build a general DFA and interpret it
-         *  to distinguish between alternatives.
-         */
-        [Obsolete]
-        public virtual bool isCyclic()
-        {
-            return IsCyclic;
-        }
-
-        [Obsolete]
-        public virtual bool canInlineDecision()
-        {
-            return CanInlineDecision;
-        }
-
/** Is this DFA derived from the NFA for the Tokens rule? */
-        public virtual bool isTokensRuleDecision()
+        public virtual bool GetIsTokensRuleDecision()
{
if ( nfa.grammar.type != Grammar.LEXER )
{
@@ -1042,7 +1021,7 @@ namespace Antlr3.Analysis
*  DFA cycles are created when this value, k, is greater than 0.
*  If this decision has no k lookahead specified, then try the grammar.
*/
-        public virtual int getUserMaxLookahead()
+        public virtual int GetUserMaxLookahead()
{
if ( _userK >= 0 )
{ // cache for speed
@@ -1052,33 +1031,16 @@ namespace Antlr3.Analysis
return _userK;
}

-        public virtual bool getAutoBacktrackMode()
+        public virtual bool GetAutoBacktrackMode()
{
return nfa.grammar.getAutoBacktrackMode( decisionNumber );
}

-        public virtual void setUserMaxLookahead( int k )
+        public virtual void SetUserMaxLookahead( int k )
{
this._userK = k;
}

-        /** Return k if decision is LL(k) for some k else return max int */
-        [Obsolete]
-        public virtual int getMaxLookaheadDepth()
-        {
-            return MaxLookaheadDepth;
-        }
-
-        /** Return a list of Integer alt numbers for which no lookahead could
-         *  be computed or for which no single DFA accept state predicts those
-         *  alts.  Must call verify() first before this makes sense.
-         */
-        [Obsolete]
-        public virtual List<int> getUnreachableAlts()
-        {
-            return (List<int>)UnreachableAlts;
-        }
-
/** Once this DFA has been built, need to verify that:
*
*  1. it's reduced
@@ -1091,9 +1053,9 @@ namespace Antlr3.Analysis
*
*  This is avoided if analysis bails out for any reason.
*/
-        public virtual void verify()
+        public virtual void Verify()
{
-            doesStateReachAcceptState( startState );
+            DoesStateReachAcceptState( startState );
}

/** figure out if this state eventually reaches an accept state and
@@ -1109,14 +1071,14 @@ namespace Antlr3.Analysis
*
*  TODO: I call getUniquelyPredicatedAlt too much; cache predicted alt
*/
-        protected virtual bool doesStateReachAcceptState( DFAState d )
+        protected virtual bool DoesStateReachAcceptState( DFAState d )
{
if ( d.IsAcceptState )
{
// accept states have no edges emanating from them so we can return
d.AcceptStateReachable = REACHABLE_YES;
// this alt is uniquely predicted, remove from nondeterministic list
-                int predicts = d.getUniquelyPredictedAlt();
+                int predicts = d.GetUniquelyPredictedAlt();
_unreachableAlts.Remove( predicts );
return true;
}
@@ -1130,7 +1092,7 @@ namespace Antlr3.Analysis
// all transitions must be traversed to set status of each DFA state.
for ( int i = 0; i < d.NumberOfTransitions; i++ )
{
-                Transition t = d.transition( i );
+                Transition t = d.Transition( i );
DFAState edgeTarget = (DFAState)t.target;
int targetStatus = edgeTarget.AcceptStateReachable;
if ( targetStatus == REACHABLE_BUSY )
@@ -1148,7 +1110,7 @@ namespace Antlr3.Analysis
continue;
}
// target must be REACHABLE_UNKNOWN (i.e., unvisited)
-                if ( doesStateReachAcceptState( edgeTarget ) )
+                if ( DoesStateReachAcceptState( edgeTarget ) )
{
anEdgeReachesAcceptState = true;
// have to keep looking so don't break loop
@@ -1174,16 +1136,16 @@ namespace Antlr3.Analysis
*  syntactic predicates that are not ever used such as those
*  created by autobacktrack mode.
*/
-        public virtual void findAllGatedSynPredsUsedInDFAAcceptStates()
+        public virtual void FindAllGatedSynPredsUsedInDFAAcceptStates()
{
int nAlts = NumberOfAlts;
for ( int i = 1; i <= nAlts; i++ )
{
-                DFAState a = getAcceptState( i );
+                DFAState a = GetAcceptState( i );
//JSystem.@out.println("alt "+i+": "+a);
if ( a != null )
{
-                    HashSet<SemanticContext> synpreds = a.getGatedSyntacticPredicatesInNFAConfigurations();
+                    HashSet<SemanticContext> synpreds = a.GetGatedSyntacticPredicatesInNFAConfigurations();
if ( synpreds != null )
{
// add all the predicates we find (should be just one, right?)
@@ -1197,34 +1159,16 @@ namespace Antlr3.Analysis
}
}

-        [Obsolete]
-        public virtual NFAState getNFADecisionStartState()
-        {
-            return NFADecisionStartState;
-        }
-
-        public virtual DFAState getAcceptState( int alt )
+        public virtual DFAState GetAcceptState( int alt )
{
return _altToAcceptState[alt];
}

-        public virtual void setAcceptState( int alt, DFAState acceptState )
+        public virtual void SetAcceptState( int alt, DFAState acceptState )
{
_altToAcceptState[alt] = acceptState;
}

-        [Obsolete]
-        public virtual String getDescription()
-        {
-            return Description;
-        }
-
-        [Obsolete]
-        public virtual int getDecisionNumber()
-        {
-            return DecisionNumber;
-        }
-
/** If this DFA failed to finish during construction, we might be
*  able to retry with k=1 but we need to know whether it will
*  potentially succeed.  Can only succeed if there is a predicate
@@ -1232,7 +1176,7 @@ namespace Antlr3.Analysis
*  cycle forever.  Timeout can retry with k=1 even if no predicate
*  if k!=1.
*/
-        public virtual bool okToRetryDFAWithK1()
+        public virtual bool OkToRetryDFAWithK1()
{
bool nonLLStarOrOverflowAndPredicateVisible =
( probe.IsNonLLStarDecision || probe.AnalysisOverflowed ) &&
@@ -1241,7 +1185,7 @@ namespace Antlr3.Analysis
( AnalysisTimedOut || nonLLStarOrOverflowAndPredicateVisible );
}

-        public virtual String getReasonForFailure()
+        public virtual string GetReasonForFailure()
{
StringBuilder buf = new StringBuilder();
if ( probe.IsNonLLStarDecision )
@@ -1274,17 +1218,7 @@ namespace Antlr3.Analysis
return buf.ToString();
}

-        /** What GrammarAST node (derived from the grammar) is this DFA
-         *  associated with?  It will point to the start of a block or
-         *  the loop back of a (...)+ block etc...
-         */
-        [Obsolete]
-        public virtual GrammarAST getDecisionASTNode()
-        {
-            return DecisionASTNode;
-        }
-
-        public virtual bool isGreedy()
+        public virtual bool GetIsGreedy()
{
GrammarAST blockAST = nfa.grammar.getDecisionBlockAST( decisionNumber );
Object v = nfa.grammar.getBlockOption( blockAST, "greedy" );
@@ -1296,7 +1230,7 @@ namespace Antlr3.Analysis

}

-        public virtual DFAState newState()
+        public virtual DFAState NewState()
{
DFAState n = new DFAState( this );
n.stateNumber = _stateCounter;
@@ -1306,25 +1240,7 @@ namespace Antlr3.Analysis
return n;
}

-        [Obsolete]
-        public virtual int getNumberOfStates()
-        {
-            return NumberOfStates;
-        }
-
-        [Obsolete]
-        public virtual int getNumberOfAlts()
-        {
-            return NumberOfAlts;
-        }
-
-        [Obsolete]
-        public virtual bool analysisTimedOut()
-        {
-            return AnalysisTimedOut;
-        }
-
-        protected virtual void initAltRelatedInfo()
+        protected virtual void InitAltRelatedInfo()
{
_unreachableAlts = new List<int>();
for ( int i = 1; i <= _nAlts; i++ )
@@ -1375,7 +1291,7 @@ namespace Antlr3.Analysis
*  1. If not greedy, modify the labels parameter to be EOT
*  2. If greedy, remove EOT from the labels set
*/
-        protected boolean reachableLabelsEOTCoexistsWithAllChar(OrderedHashSet labels)
+        protected boolean ReachableLabelsEOTCoexistsWithAllChar(OrderedHashSet labels)
{
Label eot = new Label(Label.EOT);
if ( !labels.containsKey(eot) ) {
diff --git a/Antlr3/Analysis/DFAOptimizer.cs b/Antlr3/Analysis/DFAOptimizer.cs
index 2f7eb57..da0f39e 100644
--- a/Antlr3/Analysis/DFAOptimizer.cs
+++ b/Antlr3/Analysis/DFAOptimizer.cs
@@ -138,7 +138,7 @@ namespace Antlr3.Analysis
this._grammar = grammar;
}

-        public virtual void optimize()
+        public virtual void Optimize()
{
// optimize each DFA in this grammar
for ( int decisionNumber = 1;
@@ -146,11 +146,11 @@ namespace Antlr3.Analysis
decisionNumber++ )
{
DFA dfa = _grammar.getLookaheadDFA( decisionNumber );
-                optimize( dfa );
+                Optimize( dfa );
}
}

-        protected virtual void optimize( DFA dfa )
+        protected virtual void Optimize( DFA dfa )
{
if ( dfa == null )
{
@@ -170,7 +170,7 @@ namespace Antlr3.Analysis
( decisionType == NFAState.OPTIONAL_BLOCK_START ||
decisionType == NFAState.LOOPBACK ) )
{
-                    optimizeExitBranches( dfa.startState );
+                    OptimizeExitBranches( dfa.startState );
}
}
// If the Tokens rule has syntactically ambiguous rules, try to prune
@@ -179,7 +179,7 @@ namespace Antlr3.Analysis
dfa.probe.stateToSyntacticallyAmbiguousTokensRuleAltsMap.Count > 0 )
{
_visited.Clear();
-                optimizeEOTBranches( dfa.startState );
+                OptimizeEOTBranches( dfa.startState );
}

/* ack...code gen needs this, cannot optimize
@@ -190,7 +190,7 @@ namespace Antlr3.Analysis
//JSystem.@out.println("minimized in "+(int)(stop-start)+" ms");
}

-        protected virtual void optimizeExitBranches( DFAState d )
+        protected virtual void OptimizeExitBranches( DFAState d )
{
int sI = d.stateNumber;
if ( _visited.Contains( sI ) )
@@ -201,7 +201,7 @@ namespace Antlr3.Analysis
int nAlts = d.dfa.NumberOfAlts;
for ( int i = 0; i < d.NumberOfTransitions; i++ )
{
-                Transition edge = (Transition)d.transition( i );
+                Transition edge = (Transition)d.Transition( i );
DFAState edgeTarget = ( (DFAState)edge.target );
/*
JSystem.@out.println(d.stateNumber+"-"+
@@ -210,20 +210,20 @@ namespace Antlr3.Analysis
*/
// if target is an accept state and that alt is the exit alt
if ( edgeTarget.IsAcceptState &&
-                    edgeTarget.getUniquelyPredictedAlt() == nAlts )
+                    edgeTarget.GetUniquelyPredictedAlt() == nAlts )
{
/*
JSystem.@out.println("ignoring transition "+i+" to max alt "+
d.dfa.getNumberOfAlts());
*/
-                    d.removeTransition( i );
+                    d.RemoveTransition( i );
i--; // back up one so that i++ of loop iteration stays within bounds
}
-                optimizeExitBranches( edgeTarget );
+                OptimizeExitBranches( edgeTarget );
}
}

-        protected virtual void optimizeEOTBranches( DFAState d )
+        protected virtual void OptimizeEOTBranches( DFAState d )
{
int sI = d.stateNumber;
if ( _visited.Contains( sI ) )
@@ -233,7 +233,7 @@ namespace Antlr3.Analysis
_visited.Add( sI );
for ( int i = 0; i < d.NumberOfTransitions; i++ )
{
-                Transition edge = (Transition)d.transition( i );
+                Transition edge = (Transition)d.Transition( i );
DFAState edgeTarget = ( (DFAState)edge.target );
/*
JSystem.@out.println(d.stateNumber+"-"+
@@ -249,14 +249,14 @@ namespace Antlr3.Analysis
{
//JSystem.@out.println("state "+d+" can be pruned");
// remove the superfluous EOT edge
-                    d.removeTransition( i );
+                    d.RemoveTransition( i );
d.IsAcceptState = true; // make it an accept state
// force it to uniquely predict the originally predicted state
d.cachedUniquelyPredicatedAlt =
-                        edgeTarget.getUniquelyPredictedAlt();
+                        edgeTarget.GetUniquelyPredictedAlt();
i--; // back up one so that i++ of loop iteration stays within bounds
}
-                optimizeEOTBranches( edgeTarget );
+                OptimizeEOTBranches( edgeTarget );
}
}

@@ -264,7 +264,7 @@ namespace Antlr3.Analysis
/** Walk DFA states, unlinking the nfa configs and whatever else I
*  can to reduce memory footprint.
*/
-        protected virtual void unlinkUnneededStateData( DFAState d )
+        protected virtual void UnlinkUnneededStateData( DFAState d )
{
int sI = d.stateNumber;
if ( visited.Contains( sI ) )
@@ -277,7 +277,7 @@ namespace Antlr3.Analysis
{
Transition edge = (Transition)d.transition( i );
DFAState edgeTarget = ( (DFAState)edge.target );
-                unlinkUnneededStateData( edgeTarget );
+                UnlinkUnneededStateData( edgeTarget );
}
}
#endif
diff --git a/Antlr3/Analysis/DFAState.cs b/Antlr3/Analysis/DFAState.cs
index b7f6461..7fb36fa 100644
--- a/Antlr3/Analysis/DFAState.cs
+++ b/Antlr3/Analysis/DFAState.cs
@@ -175,6 +175,7 @@ namespace Antlr3.Analysis
}

#region Properties
+        /** Is an accept state reachable from this state? */
public int AcceptStateReachable
{
get
@@ -190,14 +191,14 @@ namespace Antlr3.Analysis
{
get
{
-                return getAltSet();
+                return GetAltSet();
}
}
public ICollection<int> DisabledAlternatives
{
get
{
-                return getDisabledAlternatives();
+                return GetDisabledAlternatives();
}
}
public bool IsResolvedWithPredicates
@@ -231,12 +232,12 @@ namespace Antlr3.Analysis
{
get
{
-                return getReachableLabels();
+                return GetReachableLabels();
}
}
#endregion

-        public virtual void reset()
+        public virtual void Reset()
{
//nfaConfigurations = null; // getGatedPredicatesInNFAConfigurations needs
configurationsWithLabeledEdges = null;
@@ -244,7 +245,7 @@ namespace Antlr3.Analysis
_reachableLabels = null;
}

-        public virtual Transition transition( int i )
+        public virtual Transition Transition( int i )
{
return (Transition)_transitions[i];
}
@@ -257,7 +258,7 @@ namespace Antlr3.Analysis
}
}

-        public override void addTransition( Transition t )
+        public override void AddTransition( Transition t )
{
_transitions.Add( t );
}
@@ -265,18 +266,18 @@ namespace Antlr3.Analysis
/** Add a transition from this state to target with label.  Return
*  the transition number from 0..n-1.
*/
-        public virtual int addTransition( DFAState target, Label label )
+        public virtual int AddTransition( DFAState target, Label label )
{
_transitions.Add( new Transition( label, target ) );
return _transitions.Count - 1;
}

-        public override Transition getTransition( int trans )
+        public override Transition GetTransition( int trans )
{
return _transitions[trans];
}

-        public virtual void removeTransition( int trans )
+        public virtual void RemoveTransition( int trans )
{
_transitions.RemoveAt( trans );
}
@@ -298,7 +299,7 @@ namespace Antlr3.Analysis
*  transition labels so we can simply walk it later rather than doing a
*  loop over all possible labels in the NFA.
*/
-        public virtual void addNFAConfiguration( NFAState state, NFAConfiguration c )
+        public virtual void AddNFAConfiguration( NFAState state, NFAConfiguration c )
{
if ( nfaConfigurations.Contains( c ) )
{
@@ -338,12 +339,12 @@ namespace Antlr3.Analysis
// later we can check this to ignore o-A->o states in closure
c.singleAtomTransitionEmanating = true;
}
-                    addReachableLabel( label );
+                    AddReachableLabel( label );
}
}
}

-        public virtual NFAConfiguration addNFAConfiguration( NFAState state,
+        public virtual NFAConfiguration AddNFAConfiguration( NFAState state,
int alt,
NFAContext context,
SemanticContext semanticContext )
@@ -352,7 +353,7 @@ namespace Antlr3.Analysis
alt,
context,
semanticContext );
-            addNFAConfiguration( state, c );
+            AddNFAConfiguration( state, c );
return c;
}

@@ -389,7 +390,7 @@ namespace Antlr3.Analysis
*
*  Single element labels are treated as sets to make the code uniform.
*/
-        protected virtual void addReachableLabel( Label label )
+        protected virtual void AddReachableLabel( Label label )
{
if ( _reachableLabels == null )
{
@@ -417,7 +418,7 @@ namespace Antlr3.Analysis
rl.toString(dfa.nfa.grammar)+"="+
intersection.toString(dfa.nfa.grammar));
*/
-                if ( !Label.intersect( label, rl ) )
+                if ( !Label.Intersect( label, rl ) )
{
continue;
}
@@ -435,7 +436,7 @@ namespace Antlr3.Analysis
// Compute s_i-t to see what is in current set and not in incoming
IIntSet existingMinusNewElements = s_i.subtract( t );
//JSystem.@out.println(s_i+"-"+t+"="+existingMinusNewElements);
-                if ( !existingMinusNewElements.isNil() )
+                if ( !existingMinusNewElements.IsNil )
{
// found a new character class, add to the end (doesn't affect
// outer loop duration due to n computation a priori.
@@ -450,14 +451,14 @@ namespace Antlr3.Analysis

// anything left to add to the reachableLabels?
remainder = t.subtract( s_i );
-                if ( remainder.isNil() )
+                if ( remainder.IsNil )
{
break; // nothing left to add to set.  done!
}

t = remainder;
}
-            if ( !remainder.isNil() )
+            if ( !remainder.IsNil )
{
/*
JSystem.@out.println("before add remainder to state "+dfa.decisionNumber+"."+stateNumber+": " +
@@ -473,12 +474,12 @@ namespace Antlr3.Analysis
*/
}

-        public virtual OrderedHashSet<Label> getReachableLabels()
+        public virtual OrderedHashSet<Label> GetReachableLabels()
{
return _reachableLabels;
}

-        public virtual void setNFAConfigurations( OrderedHashSet<NFAConfiguration> configs )
+        public virtual void SetNFAConfigurations( OrderedHashSet<NFAConfiguration> configs )
{
this.nfaConfigurations = configs;
}
@@ -533,7 +534,7 @@ namespace Antlr3.Analysis
*  this to the work list and then have semantic predicate edges
*  emanating from it.
*/
-        public virtual int getUniquelyPredictedAlt()
+        public virtual int GetUniquelyPredictedAlt()
{
if ( cachedUniquelyPredicatedAlt != PREDICTED_ALT_UNSET )
{
@@ -568,7 +569,7 @@ namespace Antlr3.Analysis
*  Ignore the resolved bit etc...  Return INVALID_ALT_NUMBER
*  if there is more than one alt mentioned.
*/
-        public virtual int getUniqueAlt()
+        public virtual int GetUniqueAlt()
{
int alt = NFA.INVALID_ALT_NUMBER;
int numConfigs = nfaConfigurations.size();
@@ -599,7 +600,7 @@ namespace Antlr3.Analysis
*  DFA state, that alt is disabled.  There may be other accept states
*  for that alt.
*/
-        public virtual ICollection<int> getDisabledAlternatives()
+        public virtual ICollection<int> GetDisabledAlternatives()
{
HashSet<int> disabled = new HashSet<int>();
int numConfigs = nfaConfigurations.size();
@@ -614,7 +615,7 @@ namespace Antlr3.Analysis
return disabled;
}

-        protected internal virtual HashSet<int> getNonDeterministicAlts()
+        protected internal virtual HashSet<int> GetNonDeterministicAlts()
{
int user_k = dfa.UserMaxLookahead;
if ( user_k > 0 && user_k == _k )
@@ -630,7 +631,7 @@ namespace Antlr3.Analysis
}
else
{
-                return getConflictingAlts();
+                return GetConflictingAlts();
}
}

@@ -650,7 +651,7 @@ namespace Antlr3.Analysis
*  Don't report conflicts for DFA states that have conflicting Tokens
*  rule NFA states; they will be resolved in favor of the first rule.
*/
-        protected virtual HashSet<int> getConflictingAlts()
+        protected virtual HashSet<int> GetConflictingAlts()
{
// TODO this is called multiple times: cache result?
//JSystem.@out.println("getNondetAlts for DFA state "+stateNumber);
@@ -763,7 +764,7 @@ namespace Antlr3.Analysis
// conflicts means s.ctx==t.ctx or s.ctx is a stack
// suffix of t.ctx or vice versa (if alts differ).
// Also a conflict if s.ctx or t.ctx is empty
-                        if ( s.alt != t.alt && s.context.conflictsWith( t.context ) )
+                        if ( s.alt != t.alt && s.context.ConflictsWith( t.context ) )
{
nondeterministicAlts.Add( s.alt );
nondeterministicAlts.Add( t.alt );
@@ -782,7 +783,7 @@ namespace Antlr3.Analysis
/** Get the set of all alts mentioned by all NFA configurations in this
*  DFA state.
*/
-        public virtual HashSet<int> getAltSet()
+        public virtual HashSet<int> GetAltSet()
{
int numConfigs = nfaConfigurations.size();
HashSet<int> alts = new HashSet<int>();
@@ -798,7 +799,7 @@ namespace Antlr3.Analysis
return alts;
}

-        public virtual HashSet<SemanticContext> getGatedSyntacticPredicatesInNFAConfigurations()
+        public virtual HashSet<SemanticContext> GetGatedSyntacticPredicatesInNFAConfigurations()
{
int numConfigs = nfaConfigurations.size();
HashSet<SemanticContext> synpreds = new HashSet<SemanticContext>();
@@ -847,7 +848,7 @@ namespace Antlr3.Analysis
*
*  TODO: cache this as it's called a lot; or at least set bit if >1 present in state
*/
-        public virtual SemanticContext getGatedPredicatesInNFAConfigurations()
+        public virtual SemanticContext GetGatedPredicatesInNFAConfigurations()
{
SemanticContext unionOfPredicatesFromAllAlts = null;
int numConfigs = nfaConfigurations.size();
@@ -888,25 +889,6 @@ namespace Antlr3.Analysis
return unionOfPredicatesFromAllAlts;
}

-        /** Is an accept state reachable from this state? */
-        [Obsolete]
-        public virtual int getAcceptStateReachable()
-        {
-            return AcceptStateReachable;
-        }
-
-        [Obsolete]
-        public virtual void setAcceptStateReachable( int acceptStateReachable )
-        {
-            AcceptStateReachable = acceptStateReachable;
-        }
-
-        [Obsolete]
-        public virtual bool isResolvedWithPredicates()
-        {
-            return IsResolvedWithPredicates;
-        }
-
/** Print all NFA states plus what alts they predict */
public override String ToString()
{
@@ -924,18 +906,5 @@ namespace Antlr3.Analysis
buf.Append( "}" );
return buf.ToString();
}
-
-        [Obsolete]
-        public virtual int getLookaheadDepth()
-        {
-            return LookaheadDepth;
-        }
-
-        [Obsolete]
-        public virtual void setLookaheadDepth( int k )
-        {
-            LookaheadDepth = k;
-        }
-
}
}
diff --git a/Antlr3/Analysis/DecisionProbe.cs b/Antlr3/Analysis/DecisionProbe.cs
index 26817da..d81dd39 100644
--- a/Antlr3/Analysis/DecisionProbe.cs
+++ b/Antlr3/Analysis/DecisionProbe.cs
@@ -332,7 +332,7 @@ namespace Antlr3.Analysis
*/
public virtual IList<int> GetNonDeterministicAltsForState( DFAState targetState )
{
-            IEnumerable<int> nondetAlts = targetState.getNonDeterministicAlts();
+            IEnumerable<int> nondetAlts = targetState.GetNonDeterministicAlts();
if ( nondetAlts == null )
return null;

@@ -676,7 +676,7 @@ namespace Antlr3.Analysis
for ( int i = 0; i < configs.Count; i++ )
{
NFAConfiguration c = (NFAConfiguration)configs[i];
-                    NFAState ruleInvocationState = dfa.nfa.getState( c.state );
+                    NFAState ruleInvocationState = dfa.nfa.GetState( c.state );
Transition transition0 = ruleInvocationState.transition[0];
RuleClosureTransition @ref = (RuleClosureTransition)transition0;
String targetRule = ( (NFAState)@ref.target ).enclosingRule.name;
@@ -698,7 +698,7 @@ namespace Antlr3.Analysis
// track one problem DFA state per alt
if ( altToDFAState.get( altI ) == null )
{
-                        DFAState sampleBadState = dfa.getState( stateI );
+                        DFAState sampleBadState = dfa.GetState( stateI );
altToDFAState[altI] = sampleBadState;
}
}
@@ -710,7 +710,7 @@ namespace Antlr3.Analysis
HashSet<object> dfaStatesUnaliased = new HashSet<object>();
foreach ( int stateI in dfaStatesWithRecursionProblems )
{
-                DFAState d = dfa.getState( stateI );
+                DFAState d = dfa.GetState( stateI );
dfaStatesUnaliased.Add( d.stateNumber );
}
return dfaStatesUnaliased;
@@ -842,7 +842,7 @@ namespace Antlr3.Analysis
// at most one path to any DFA state with conflicting predictions
for ( int i = 0; i < s.NumberOfTransitions; i++ )
{
-                Transition t = s.transition( i );
+                Transition t = s.Transition( i );
DFAState edgeTarget = (DFAState)t.target;

int targetStatus; //= stateReachable.get( edgeTarget.stateNumber );
@@ -907,7 +907,7 @@ namespace Antlr3.Analysis
// pick the first edge in states as the one to traverse
for ( int i = 0; i < startState.NumberOfTransitions; i++ )
{
-                Transition t = startState.getTransition( i );
+                Transition t = startState.GetTransition( i );
DFAState edgeTarget = (DFAState)t.target;
if ( states.Contains( edgeTarget ) &&
!_statesVisitedDuringSampleSequence.Contains( edgeTarget.stateNumber ) )
@@ -987,7 +987,7 @@ namespace Antlr3.Analysis
path.RemoveAt( path.Count - 1 ); // remove; didn't work out
continue; // look at the next edge
}
-                if ( t.label.matches( label ) )
+                if ( t.label.Matches( label ) )
{
path.Add( edgeTarget );
/*
diff --git a/Antlr3/Analysis/LL1Analyzer.cs b/Antlr3/Analysis/LL1Analyzer.cs
index af0e08d..303e00d 100644
--- a/Antlr3/Analysis/LL1Analyzer.cs
+++ b/Antlr3/Analysis/LL1Analyzer.cs
@@ -72,7 +72,7 @@ namespace Antlr3.Analysis
}

#if false
-        public virtual void computeRuleFIRSTSets()
+        public virtual void ComputeRuleFIRSTSets()
{
if ( NumberOfDecisions == 0 )
{
@@ -92,7 +92,7 @@ namespace Antlr3.Analysis
#endif

#if false
-        public HashSet<string> getOverriddenRulesWithDifferentFIRST() {
+        public HashSet<string> GetOverriddenRulesWithDifferentFIRST() {
// walk every rule in this grammar and compare FIRST set with
// those in imported grammars.
HashSet<string> rules = new HashSet<string>();
@@ -113,7 +113,7 @@ namespace Antlr3.Analysis
return rules;
}

-        public Set<Rule> getImportedRulesSensitiveToOverriddenRulesDueToLOOK() {
+        public Set<Rule> GetImportedRulesSensitiveToOverriddenRulesDueToLOOK() {
Set<String> diffFIRSTs = getOverriddenRulesWithDifferentFIRST();
Set<Rule> rules = new HashSet();
for (Iterator it = diffFIRSTs.iterator(); it.hasNext();) {
@@ -133,7 +133,7 @@ namespace Antlr3.Analysis
#endif

#if false
-        public LookaheadSet LOOK(Rule r) {
+        public LookaheadSet Look(Rule r) {
if ( r.FIRST==null ) {
r.FIRST = FIRST(r.startState);
}
@@ -157,16 +157,16 @@ namespace Antlr3.Analysis
*
*  This routine will only be used on parser and tree parser grammars.
*/
-        public virtual LookaheadSet FIRST( NFAState s )
+        public LookaheadSet First( NFAState s )
{
//JSystem.@out.println("> FIRST("+s.enclosingRule.name+") in rule "+s.enclosingRule);
_lookBusy.Clear();
-            LookaheadSet look = _FIRST( s, false );
+            LookaheadSet look = FirstCore( s, false );
//JSystem.@out.println("< FIRST("+s.enclosingRule.name+") in rule "+s.enclosingRule+"="+look.toString(this.grammar));
return look;
}

-        public virtual LookaheadSet FOLLOW( Rule r )
+        public LookaheadSet Follow( Rule r )
{
//JSystem.@out.println("> FOLLOW("+r.name+") in rule "+r.startState.enclosingRule);
LookaheadSet f = _followCache.get( r );
@@ -174,31 +174,31 @@ namespace Antlr3.Analysis
{
return f;
}
-            f = _FIRST( r.stopState, true );
+            f = FirstCore( r.stopState, true );
_followCache[r] = f;
//JSystem.@out.println("< FOLLOW("+r+") in rule "+r.startState.enclosingRule+"="+f.toString(this.grammar));
return f;
}

-        public virtual LookaheadSet LOOK( NFAState s )
+        public LookaheadSet Look( NFAState s )
{
if ( NFAToDFAConverter.debug )
{
Console.Out.WriteLine( "> LOOK(" + s + ")" );
}
_lookBusy.Clear();
-            LookaheadSet look = _FIRST( s, true );
+            LookaheadSet look = FirstCore( s, true );
// FOLLOW makes no sense (at the moment!) for lexical rules.
-            if ( _grammar.type != Grammar.LEXER && look.member( Label.EOR_TOKEN_TYPE ) )
+            if ( _grammar.type != Grammar.LEXER && look.Member( Label.EOR_TOKEN_TYPE ) )
{
// avoid altering FIRST reset as it is cached
-                LookaheadSet f = FOLLOW( s.enclosingRule );
-                f.orInPlace( look );
-                f.remove( Label.EOR_TOKEN_TYPE );
+                LookaheadSet f = Follow( s.enclosingRule );
+                f.OrInPlace( look );
+                f.Remove( Label.EOR_TOKEN_TYPE );
look = f;
//look.orInPlace(FOLLOW(s.enclosingRule));
}
-            else if ( _grammar.type == Grammar.LEXER && look.member( Label.EOT ) )
+            else if ( _grammar.type == Grammar.LEXER && look.Member( Label.EOT ) )
{
// if this has EOT, lookahead is all char (all char can follow rule)
//look = new LookaheadSet(Label.EOT);
@@ -211,7 +211,7 @@ namespace Antlr3.Analysis
return look;
}

-        protected virtual LookaheadSet _FIRST( NFAState s, bool chaseFollowTransitions )
+        protected virtual LookaheadSet FirstCore( NFAState s, bool chaseFollowTransitions )
{
/*
JSystem.@out.println("_LOOK("+s+") in rule "+s.enclosingRule);
@@ -269,7 +269,7 @@ namespace Antlr3.Analysis
// if not in cache, must compute
if ( tset == null )
{
-                tset = _FIRST( (NFAState)transition0.target, chaseFollowTransitions );
+                tset = FirstCore( (NFAState)transition0.target, chaseFollowTransitions );
// save FIRST cache for transition 0 if rule call
if ( !chaseFollowTransitions && transition0 is RuleClosureTransition )
{
@@ -278,7 +278,7 @@ namespace Antlr3.Analysis
}

// did we fall off the end?
-            if ( _grammar.type != Grammar.LEXER && tset.member( Label.EOR_TOKEN_TYPE ) )
+            if ( _grammar.type != Grammar.LEXER && tset.Member( Label.EOR_TOKEN_TYPE ) )
{
if ( transition0 is RuleClosureTransition )
{
@@ -292,9 +292,9 @@ namespace Antlr3.Analysis
// remove the EOR and get what follows
//tset.remove(Label.EOR_TOKEN_TYPE);
NFAState following = (NFAState)ruleInvocationTrans.followState;
-                    LookaheadSet fset = _FIRST( following, chaseFollowTransitions );
-                    fset.orInPlace( tset ); // tset cached; or into new set
-                    fset.remove( Label.EOR_TOKEN_TYPE );
+                    LookaheadSet fset = FirstCore( following, chaseFollowTransitions );
+                    fset.OrInPlace( tset ); // tset cached; or into new set
+                    fset.Remove( Label.EOR_TOKEN_TYPE );
tset = fset;
}
}
@@ -303,8 +303,8 @@ namespace Antlr3.Analysis
if ( transition1 != null )
{
LookaheadSet tset1 =
-                    _FIRST( (NFAState)transition1.target, chaseFollowTransitions );
-                tset1.orInPlace( tset ); // tset cached; or into new set
+                    FirstCore( (NFAState)transition1.target, chaseFollowTransitions );
+                tset1.OrInPlace( tset ); // tset cached; or into new set
tset = tset1;
}

@@ -317,14 +317,14 @@ namespace Antlr3.Analysis
*
*  TODO: what about gated vs regular preds?
*/
-        public bool detectConfoundingPredicates( NFAState s )
+        public bool DetectConfoundingPredicates( NFAState s )
{
_lookBusy.Clear();
Rule r = s.enclosingRule;
-            return _detectConfoundingPredicates( s, r, false ) == DETECT_PRED_FOUND;
+            return DetectConfoundingPredicatesCore( s, r, false ) == DETECT_PRED_FOUND;
}

-        protected int _detectConfoundingPredicates( NFAState s,
+        protected virtual int DetectConfoundingPredicatesCore( NFAState s,
Rule enclosingRule,
bool chaseFollowTransitions )
{
@@ -385,7 +385,7 @@ namespace Antlr3.Analysis
}
*/

-            int result = _detectConfoundingPredicates( (NFAState)transition0.target,
+            int result = DetectConfoundingPredicatesCore( (NFAState)transition0.target,
enclosingRule,
chaseFollowTransitions );
if ( result == DETECT_PRED_FOUND )
@@ -406,7 +406,7 @@ namespace Antlr3.Analysis
(RuleClosureTransition)transition0;
NFAState following = (NFAState)ruleInvocationTrans.followState;
int afterRuleResult =
-                        _detectConfoundingPredicates( following,
+                        DetectConfoundingPredicatesCore( following,
enclosingRule,
chaseFollowTransitions );
if ( afterRuleResult == DETECT_PRED_FOUND )
@@ -420,7 +420,7 @@ namespace Antlr3.Analysis
if ( transition1 != null )
{
int t1Result =
-                    _detectConfoundingPredicates( (NFAState)transition1.target,
+                    DetectConfoundingPredicatesCore( (NFAState)transition1.target,
enclosingRule,
chaseFollowTransitions );
if ( t1Result == DETECT_PRED_FOUND )
@@ -436,13 +436,13 @@ namespace Antlr3.Analysis
*  not look into other rules for now.  Do something simple.  Include
*  backtracking synpreds.
*/
-        public virtual SemanticContext getPredicates( NFAState altStartState )
+        public SemanticContext GetPredicates( NFAState altStartState )
{
_lookBusy.Clear();
-            return _getPredicates( altStartState, altStartState );
+            return GetPredicatesCore( altStartState, altStartState );
}

-        protected virtual SemanticContext _getPredicates( NFAState s, NFAState altStartState )
+        protected virtual SemanticContext GetPredicatesCore( NFAState s, NFAState altStartState )
{
//JSystem.@out.println("_getPredicates("+s+")");
if ( s.IsAcceptState )
@@ -488,13 +488,13 @@ namespace Antlr3.Analysis
}

// get preds from beyond this state
-            p0 = _getPredicates( (NFAState)transition0.target, altStartState );
+            p0 = GetPredicatesCore( (NFAState)transition0.target, altStartState );

// get preds from other transition
Transition transition1 = s.transition[1];
if ( transition1 != null )
{
-                p1 = _getPredicates( (NFAState)transition1.target, altStartState );
+                p1 = GetPredicatesCore( (NFAState)transition1.target, altStartState );
}

// join this&following-right|following-down
diff --git a/Antlr3/Analysis/LL1DFA.cs b/Antlr3/Analysis/LL1DFA.cs
index d4d5da2..f9c4f0f 100644
--- a/Antlr3/Analysis/LL1DFA.cs
+++ b/Antlr3/Analysis/LL1DFA.cs
@@ -55,23 +55,23 @@ namespace Antlr3.Analysis
*/
public LL1DFA( int decisionNumber, NFAState decisionStartState, LookaheadSet[] altLook )
{
-            DFAState s0 = newState();
+            DFAState s0 = NewState();
startState = s0;
nfa = decisionStartState.nfa;
NumberOfAlts = nfa.grammar.getNumberOfAltsForDecisionNFA( decisionStartState );
this.decisionNumber = decisionNumber;
this.NFADecisionStartState = decisionStartState;
-            initAltRelatedInfo();
+            InitAltRelatedInfo();
UnreachableAlts = null;
for ( int alt = 1; alt < altLook.Length; alt++ )
{
-                DFAState acceptAltState = newState();
+                DFAState acceptAltState = NewState();
acceptAltState.acceptState = true;
-                setAcceptState( alt, acceptAltState );
+                SetAcceptState( alt, acceptAltState );
acceptAltState.LookaheadDepth = 1;
acceptAltState.cachedUniquelyPredicatedAlt = alt;
-                Label e = getLabelForSet( altLook[alt].tokenTypeSet );
-                s0.addTransition( acceptAltState, e );
+                Label e = GetLabelForSet( altLook[alt].tokenTypeSet );
+                s0.AddTransition( acceptAltState, e );
}
}

@@ -82,13 +82,13 @@ namespace Antlr3.Analysis
NFAState decisionStartState,
MultiMap<IntervalSet, int> edgeMap )
{
-            DFAState s0 = newState();
+            DFAState s0 = NewState();
startState = s0;
nfa = decisionStartState.nfa;
NumberOfAlts = nfa.grammar.getNumberOfAltsForDecisionNFA( decisionStartState );
this.decisionNumber = decisionNumber;
this.NFADecisionStartState = decisionStartState;
-            initAltRelatedInfo();
+            InitAltRelatedInfo();
UnreachableAlts = null;
foreach ( var edgeVar in edgeMap )
{
@@ -97,15 +97,15 @@ namespace Antlr3.Analysis
alts = alts.OrderBy( i => i ).ToList();
//Collections.sort( alts ); // make sure alts are attempted in order
//JSystem.@out.println(edge+" -> "+alts);
-                DFAState s = newState();
+                DFAState s = NewState();
s.LookaheadDepth = 1;
-                Label e = getLabelForSet( edge );
-                s0.addTransition( s, e );
+                Label e = GetLabelForSet( edge );
+                s0.AddTransition( s, e );
if ( alts.Count == 1 )
{
s.acceptState = true;
int alt = alts[0];
-                    setAcceptState( alt, s );
+                    SetAcceptState( alt, s );
s.cachedUniquelyPredicatedAlt = alt;
}
else
@@ -117,13 +117,13 @@ namespace Antlr3.Analysis
{
int alt = (int)alts[i];
s.cachedUniquelyPredicatedAlt = NFA.INVALID_ALT_NUMBER;
-                        DFAState predDFATarget = getAcceptState( alt );
+                        DFAState predDFATarget = GetAcceptState( alt );
if ( predDFATarget == null )
{
-                            predDFATarget = newState(); // create if not there.
+                            predDFATarget = NewState(); // create if not there.
predDFATarget.acceptState = true;
predDFATarget.cachedUniquelyPredicatedAlt = alt;
-                            setAcceptState( alt, predDFATarget );
+                            SetAcceptState( alt, predDFATarget );
}
// add a transition to pred target from d
/*
@@ -139,19 +139,19 @@ namespace Antlr3.Analysis
s.addTransition(predDFATarget, new Label(ctx));
*/
SemanticContext.Predicate synpred =
-                            getSynPredForAlt( decisionStartState, alt );
+                            GetSynPredForAlt( decisionStartState, alt );
if ( synpred == null )
{
synpred = new SemanticContext.TruePredicate();
}
-                        s.addTransition( predDFATarget, new PredicateLabel( synpred ) );
+                        s.AddTransition( predDFATarget, new PredicateLabel( synpred ) );
}
}
}
//JSystem.@out.println("dfa for preds=\n"+this);
}

-        protected virtual Label getLabelForSet( IntervalSet edgeSet )
+        protected virtual Label GetLabelForSet( IntervalSet edgeSet )
{
Label e = null;
int atom = edgeSet.getSingleElement();
@@ -166,11 +166,11 @@ namespace Antlr3.Analysis
return e;
}

-        protected virtual SemanticContext.Predicate getSynPredForAlt( NFAState decisionStartState,
+        protected virtual SemanticContext.Predicate GetSynPredForAlt( NFAState decisionStartState,
int alt )
{
int walkAlt =
-                decisionStartState.translateDisplayAltToWalkAlt( alt );
+                decisionStartState.TranslateDisplayAltToWalkAlt( alt );
NFAState altLeftEdge =
nfa.grammar.getNFAStateForAltOfDecision( decisionStartState, walkAlt );
NFAState altStartState = (NFAState)altLeftEdge.transition[0].target;
diff --git a/Antlr3/Analysis/Label.cs b/Antlr3/Analysis/Label.cs
index b08f056..2b03876 100644
--- a/Antlr3/Analysis/Label.cs
+++ b/Antlr3/Analysis/Label.cs
@@ -247,7 +247,7 @@ namespace Antlr3.Analysis
return l;
}

-        public virtual void add( Label a )
+        public virtual void Add( Label a )
{
if ( IsAtom )
{
@@ -286,7 +286,7 @@ namespace Antlr3.Analysis
throw new InvalidOperationException( "can't add element to Label of type " + label );
}

-        public virtual bool matches( int atom )
+        public virtual bool Matches( int atom )
{
if ( label == atom )
{
@@ -299,7 +299,7 @@ namespace Antlr3.Analysis
return false;
}

-        public virtual bool matches( IIntSet set )
+        public virtual bool Matches( IIntSet set )
{
if ( IsAtom )
{
@@ -308,21 +308,21 @@ namespace Antlr3.Analysis
if ( IsSet )
{
// matches if intersection non-nil
-                return !Set.and( set ).isNil();
+                return !Set.and( set ).IsNil;
}
return false;
}


-        public virtual bool matches( Label other )
+        public virtual bool Matches( Label other )
{
if ( other.IsSet )
{
-                return matches( other.Set );
+                return Matches( other.Set );
}
if ( other.IsAtom )
{
-                return matches( other.Atom );
+                return Matches( other.Atom );
}
return false;
}
@@ -379,7 +379,7 @@ namespace Antlr3.Analysis
*  At this point, Labels are not compared for equals when they are
*  predicates, but here's the code for future use.
*/
-        protected boolean predicatesEquals(Set others) {
+        protected boolean PredicatesEquals(Set others) {
Iterator iter = semanticContext.iterator();
while (iter.hasNext()) {
AST predAST = (AST) iter.next();
@@ -418,7 +418,7 @@ namespace Antlr3.Analysis
}

#if false
-        public String predicatesToString() {
+        public String PredicatesToString() {
if ( semanticContext==NFAConfiguration.DEFAULT_CLAUSE_SEMANTIC_CONTEXT ) {
return "!other preds";
}
@@ -435,7 +435,7 @@ namespace Antlr3.Analysis
}
#endif

-        public static bool intersect( Label label, Label edgeLabel )
+        public static bool Intersect( Label label, Label edgeLabel )
{
bool hasIntersection = false;
bool labelIsSet = label.IsSet;
@@ -445,7 +445,7 @@ namespace Antlr3.Analysis
hasIntersection = true;
}
else if ( labelIsSet && edgeIsSet &&
-                      !edgeLabel.Set.and( label.Set ).isNil() )
+                      !edgeLabel.Set.and( label.Set ).IsNil )
{
hasIntersection = true;
}
diff --git a/Antlr3/Analysis/LookaheadSet.cs b/Antlr3/Analysis/LookaheadSet.cs
index 63da25a..5b797c7 100644
--- a/Antlr3/Analysis/LookaheadSet.cs
+++ b/Antlr3/Analysis/LookaheadSet.cs
@@ -72,44 +72,39 @@ namespace Antlr3.Analysis
{
get
{
-                return isNil();
+                return tokenTypeSet.IsNil;
}
}
#endregion

-        public virtual void orInPlace( LookaheadSet other )
+        public virtual void OrInPlace( LookaheadSet other )
{
this.tokenTypeSet.addAll( other.tokenTypeSet );
}

-        public virtual LookaheadSet or( LookaheadSet other )
+        public virtual LookaheadSet Or( LookaheadSet other )
{
return new LookaheadSet( tokenTypeSet.or( other.tokenTypeSet ) );
}

-        public virtual LookaheadSet subtract( LookaheadSet other )
+        public virtual LookaheadSet Subtract( LookaheadSet other )
{
return new LookaheadSet( this.tokenTypeSet.subtract( other.tokenTypeSet ) );
}

-        public virtual bool member( int a )
+        public virtual bool Member( int a )
{
return tokenTypeSet.member( a );
}

-        public virtual LookaheadSet intersection( LookaheadSet s )
+        public virtual LookaheadSet Intersection( LookaheadSet s )
{
IIntSet i = this.tokenTypeSet.and( s.tokenTypeSet );
LookaheadSet intersection = new LookaheadSet( i );
return intersection;
}

-        public virtual bool isNil()
-        {
-            return tokenTypeSet.isNil();
-        }
-
-        public virtual void remove( int a )
+        public virtual void Remove( int a )
{
tokenTypeSet = (IntervalSet)tokenTypeSet.subtract( IntervalSet.of( a ) );
}
diff --git a/Antlr3/Analysis/NFA.cs b/Antlr3/Analysis/NFA.cs
index 365aa28..73e1ccd 100644
--- a/Antlr3/Analysis/NFA.cs
+++ b/Antlr3/Analysis/NFA.cs
@@ -71,17 +71,17 @@ namespace Antlr3.Analysis
}
#endregion

-        public int getNewNFAStateNumber()
+        public int GetNewNFAStateNumber()
{
return grammar.composite.getNewNFAStateNumber();
}

-        public void addState( NFAState state )
+        public void AddState( NFAState state )
{
grammar.composite.addState( state );
}

-        public NFAState getState( int s )
+        public NFAState GetState( int s )
{
return grammar.composite.getState( s );
}
diff --git a/Antlr3/Analysis/NFAContext.cs b/Antlr3/Analysis/NFAContext.cs
index bd12336..256be5e 100644
--- a/Antlr3/Analysis/NFAContext.cs
+++ b/Antlr3/Analysis/NFAContext.cs
@@ -210,9 +210,9 @@ namespace Antlr3.Analysis
*  discussed with Sriram Srinivasan Feb 28, 2005 about not terminating
*  fast enough upon nondeterminism.
*/
-        public virtual bool conflictsWith( NFAContext other )
+        public virtual bool ConflictsWith( NFAContext other )
{
-            return this.suffix( other ); // || this.equals(other);
+            return this.Suffix( other ); // || this.equals(other);
}

/** [$] suffix any context
@@ -235,7 +235,7 @@ namespace Antlr3.Analysis
*  another, then it will still degenerate to the simple empty stack
*  comparison case.
*/
-        protected virtual bool suffix( NFAContext other )
+        protected virtual bool Suffix( NFAContext other )
{
NFAContext sp = this;
// if one of the contexts is empty, it never enters loop and returns true
@@ -256,7 +256,7 @@ namespace Antlr3.Analysis
/** Walk upwards to the root of the call stack context looking
*  for a particular invoking state.
*/
-        public virtual bool contains( int state )
+        public virtual bool Contains( int state )
{
NFAContext sp = this;
int n = 0; // track recursive invocations of state
@@ -285,7 +285,7 @@ namespace Antlr3.Analysis
*  Note that many NFA states can invoke rule r, but we ignore recursion
*  unless you hit the same rule invocation state again.
*/
-        public virtual int recursionDepthEmanatingFromState( int state )
+        public virtual int RecursionDepthEmanatingFromState( int state )
{
NFAContext sp = this;
int n = 0; // track recursive invocations of target from this state
diff --git a/Antlr3/Analysis/NFAConversionThread.cs b/Antlr3/Analysis/NFAConversionThread.cs
index 405961a..a8ce3ab 100644
--- a/Antlr3/Analysis/NFAConversionThread.cs
+++ b/Antlr3/Analysis/NFAConversionThread.cs
@@ -53,7 +53,7 @@ namespace Antlr3.Analysis
this.i = i;
this.j = j;
}
-        public virtual void run()
+        public virtual void Run()
{
for ( int decision = i; decision <= j; decision++ )
{
diff --git a/Antlr3/Analysis/NFAState.cs b/Antlr3/Analysis/NFAState.cs
index de2d251..ff8e623 100644
--- a/Antlr3/Analysis/NFAState.cs
+++ b/Antlr3/Analysis/NFAState.cs
@@ -169,7 +169,7 @@ namespace Antlr3.Analysis
}
}

-        public override void addTransition( Transition e )
+        public override void AddTransition( Transition e )
{
if ( e == null )
{
@@ -200,7 +200,7 @@ namespace Antlr3.Analysis
/** Used during optimization to reset a state to have the (single)
*  transition another state has.
*/
-        public void setTransition0( Transition e )
+        public void SetTransition0( Transition e )
{
if ( e == null )
{
@@ -211,7 +211,7 @@ namespace Antlr3.Analysis
_numTransitions = 1;
}

-        public override Transition getTransition( int i )
+        public override Transition GetTransition( int i )
{
return transition[i];
}
@@ -242,7 +242,7 @@ namespace Antlr3.Analysis
*
*  Return same alt if we can't translate.
*/
-        public int translateDisplayAltToWalkAlt( int displayAlt )
+        public int TranslateDisplayAltToWalkAlt( int displayAlt )
{
NFAState nfaStart = this;
if ( _decisionNumber == 0 || decisionStateType == 0 )
@@ -288,7 +288,7 @@ namespace Antlr3.Analysis
/** What AST node is associated with this NFAState?  When you
*  set the AST node, I set the node to point back to this NFA state.
*/
-        public void setDecisionASTNode( GrammarAST decisionASTNode )
+        public void SetDecisionASTNode( GrammarAST decisionASTNode )
{
decisionASTNode.NFAStartState = this;
this.associatedASTNode = decisionASTNode;
diff --git a/Antlr3/Analysis/NFAtoDFAConverter.cs b/Antlr3/Analysis/NFAtoDFAConverter.cs
index 3841072..3f9d99b 100644
--- a/Antlr3/Analysis/NFAtoDFAConverter.cs
+++ b/Antlr3/Analysis/NFAtoDFAConverter.cs
@@ -80,15 +80,15 @@ namespace Antlr3.Analysis
{
this._dfa = dfa;
int nAlts = dfa.NumberOfAlts;
-            initContextTrees( nAlts );
+            InitContextTrees( nAlts );
}

-        public virtual void convert()
+        public virtual void Convert()
{
_dfa.conversionStartTime = System.DateTime.Now;

// create the DFA start state
-            _dfa.startState = computeStartState();
+            _dfa.startState = ComputeStartState();

// while more DFA states to check, process them
while ( _work.Count > 0 &&
@@ -110,11 +110,11 @@ namespace Antlr3.Analysis
String input = d.dfa.probe.getInputSequenceDisplay(sampleInputLabels);
JSystem.@out.println("sample input: "+input);
*/
-                    resolveNonDeterminisms( d );
+                    ResolveNonDeterminisms( d );
// Check to see if we need to add any semantic predicate transitions
if ( d.IsResolvedWithPredicates )
{
-                        addPredicateTransitions( d );
+                        AddPredicateTransitions( d );
}
else
{
@@ -123,7 +123,7 @@ namespace Antlr3.Analysis
}
else
{
-                    findNewDFAStatesAndAddDFATransitions( d );
+                    FindNewDFAStatesAndAddDFATransitions( d );
}
_work.Dequeue(); // done with it; remove from work list
}
@@ -131,7 +131,7 @@ namespace Antlr3.Analysis
// Find all manual syn preds (gated).  These are not discovered
// in tryToResolveWithSemanticPredicates because they are implicitly
// added to every edge by code gen, DOT generation etc...
-            _dfa.findAllGatedSynPredsUsedInDFAAcceptStates();
+            _dfa.FindAllGatedSynPredsUsedInDFAAcceptStates();
}

/** From this first NFA state of a decision, create a DFA.
@@ -152,10 +152,10 @@ namespace Antlr3.Analysis
*  when nongreedy and EOT transition.  Make state with EOT emanating
*  from it the accept state.
*/
-        protected virtual DFAState computeStartState()
+        protected virtual DFAState ComputeStartState()
{
NFAState alt = _dfa.NFADecisionStartState;
-            DFAState startState = _dfa.newState();
+            DFAState startState = _dfa.NewState();
_computingStartState = true;
int i = 0;
int altNum = 1;
@@ -174,7 +174,7 @@ namespace Antlr3.Analysis
int numAltsIncludingExitBranch = _dfa.nfa.grammar
.getNumberOfAltsForDecisionNFA( _dfa.NFADecisionStartState );
altNum = numAltsIncludingExitBranch;
-                    closure( (NFAState)alt.transition[0].target,
+                    Closure( (NFAState)alt.transition[0].target,
altNum,
initialContext,
SemanticContext.EmptySemanticContext,
@@ -185,7 +185,7 @@ namespace Antlr3.Analysis
}
else
{
-                    closure( (NFAState)alt.transition[0].target,
+                    Closure( (NFAState)alt.transition[0].target,
altNum,
initialContext,
SemanticContext.EmptySemanticContext,
@@ -207,7 +207,7 @@ namespace Antlr3.Analysis
// now DFA start state has the complete closure for the decision
// but we have tracked which alt is associated with which
// NFA states.
-            _dfa.addState( startState ); // make sure dfa knows about this state
+            _dfa.AddState( startState ); // make sure dfa knows about this state
_work.Enqueue( startState );
_computingStartState = false;
return startState;
@@ -218,7 +218,7 @@ namespace Antlr3.Analysis
*  from the set of NFA states reachable from any NFA
*  state in DFA state d.
*/
-        protected virtual void findNewDFAStatesAndAddDFATransitions( DFAState d )
+        protected virtual void FindNewDFAStatesAndAddDFATransitions( DFAState d )
{
//JSystem.@out.println("work on DFA state "+d);
var labels = d.ReachableLabels;
@@ -258,7 +258,7 @@ namespace Antlr3.Analysis
bool containsEOT = labels != null && labels.Contains( EOTLabel );
if ( !_dfa.IsGreedy && containsEOT )
{
-                convertToEOTAcceptState( d );
+                ConvertToEOTAcceptState( d );
return; // no more work to do on this accept state
}

@@ -296,7 +296,7 @@ namespace Antlr3.Analysis
for ( int i = 0; i < numLabels; i++ )
{
Label label = (Label)labels.ElementAt( i );
-                DFAState t = reach( d, label );
+                DFAState t = Reach( d, label );
if ( debug )
{
Console.Out.WriteLine( "DFA state after reach " + label + " " + d + "-" +
@@ -312,7 +312,7 @@ namespace Antlr3.Analysis
continue;
}
//JSystem.@out.println("dfa.k="+dfa.getUserMaxLookahead());
-                if ( t.getUniqueAlt() == NFA.INVALID_ALT_NUMBER )
+                if ( t.GetUniqueAlt() == NFA.INVALID_ALT_NUMBER )
{
// Only compute closure if a unique alt number is not known.
// If a unique alternative is mentioned among all NFA
@@ -320,7 +320,7 @@ namespace Antlr3.Analysis
// beyond this state; also no possibility of a nondeterminism.
// This optimization May 22, 2006 just dropped -Xint time
// for analysis of Java grammar from 11.5s to 2s!  Wow.
-                    closure( t );  // add any NFA states reachable via epsilon
+                    Closure( t );  // add any NFA states reachable via epsilon
}

/*
@@ -330,10 +330,10 @@ namespace Antlr3.Analysis
*/

// add if not in DFA yet and then make d-label->t
-                DFAState targetState = addDFAStateToWorkList( t );
+                DFAState targetState = AddDFAStateToWorkList( t );

numberOfEdgesEmanating +=
-                    addTransition( d, label, targetState, targetToLabelMap );
+                    AddTransition( d, label, targetState, targetToLabelMap );

// lookahead of target must be one larger than d's k
// We are possibly setting the depth of a pre-existing state
@@ -354,19 +354,19 @@ namespace Antlr3.Analysis
// turn off all configurations except for those associated with
// min alt number; somebody has to win else some input will not
// predict any alt.
-                int minAlt = resolveByPickingMinAlt( d, null );
+                int minAlt = ResolveByPickingMinAlt( d, null );
// force it to be an accept state
// don't call convertToAcceptState() which merges stop states.
// other states point at us; don't want them pointing to dead states
d.IsAcceptState = true; // might be adding new accept state for alt
-                _dfa.setAcceptState( minAlt, d );
+                _dfa.SetAcceptState( minAlt, d );
//convertToAcceptState(d, minAlt); // force it to be an accept state
}

// Check to see if we need to add any semantic predicate transitions
if ( d.IsResolvedWithPredicates )
{
-                addPredicateTransitions( d );
+                AddPredicateTransitions( d );
}
}

@@ -434,7 +434,7 @@ namespace Antlr3.Analysis
*  are actions in that rule.  For now, since I am not preventing
*  backtracking from Tokens rule, I will simply allow the optimization.
*/
-        protected static int addTransition( DFAState d,
+        protected static int AddTransition( DFAState d,
Label label,
DFAState targetState,
IDictionary<int, Transition> targetToLabelMap )
@@ -462,7 +462,7 @@ namespace Antlr3.Analysis
if ( oldTransition.label.Atom != Label.EOT )
{
// ok, not EOT, add in this label to old label
-                            oldTransition.label.add( label );
+                            oldTransition.label.Add( label );
}
//JSystem.@out.println("label updated to be "+oldTransition.label.toString(dfa.nfa.grammar));
}
@@ -472,8 +472,8 @@ namespace Antlr3.Analysis
// make a transition from d to t upon 'a'
n = 1;
label = (Label)label.Clone(); // clone in case we alter later
-                    int transitionIndex = d.addTransition( targetState, label );
-                    Transition trans = d.getTransition( transitionIndex );
+                    int transitionIndex = d.AddTransition( targetState, label );
+                    Transition trans = d.GetTransition( transitionIndex );
// track target/transition pairs
targetToLabelMap[tI] = trans;
}
@@ -481,7 +481,7 @@ namespace Antlr3.Analysis
else
{
n = 1;
-                d.addTransition( targetState, label );
+                d.AddTransition( targetState, label );
}
return n;
}
@@ -490,7 +490,7 @@ namespace Antlr3.Analysis
*  compute the epsilon closure; that is, find all NFA states reachable
*  from the NFA states in d via purely epsilon transitions.
*/
-        public virtual void closure( DFAState d )
+        public virtual void Closure( DFAState d )
{
if ( debug )
{
@@ -514,7 +514,7 @@ namespace Antlr3.Analysis
// figure out reachable NFA states from each of d's nfa states
// via epsilon transitions.
// Fill configsInClosure rather than altering d configs inline
-                closure( _dfa.nfa.getState( c.state ),
+                Closure( _dfa.nfa.GetState( c.state ),
c.alt,
c.context,
c.semanticContext,
@@ -628,7 +628,7 @@ namespace Antlr3.Analysis
*
*      This case also catches infinite left recursion.
*/
-        public virtual void closure( NFAState p,
+        public virtual void Closure( NFAState p,
int alt,
NFAContext context,
SemanticContext semanticContext,
@@ -657,7 +657,7 @@ namespace Antlr3.Analysis
semanticContext );

// Avoid infinite recursion
-            if ( closureIsBusy( d, proposedNFAConfiguration ) )
+            if ( ClosureIsBusy( d, proposedNFAConfiguration ) )
{
if ( debug )
{
@@ -672,13 +672,13 @@ namespace Antlr3.Analysis
d.closureBusy.Add( proposedNFAConfiguration );

// p itself is always in closure
-            d.addNFAConfiguration( p, proposedNFAConfiguration );
+            d.AddNFAConfiguration( p, proposedNFAConfiguration );

// Case 1: are we a reference to another rule?
Transition transition0 = p.transition[0];
if ( transition0 is RuleClosureTransition )
{
-                int depth = context.recursionDepthEmanatingFromState( p.stateNumber );
+                int depth = context.RecursionDepthEmanatingFromState( p.stateNumber );
// Detect recursion by more than a single alt, which indicates
// that the decision's lookahead language is non-regular; terminate
if ( depth == 1 && d.dfa.UserMaxLookahead == 0 )
@@ -727,7 +727,7 @@ namespace Antlr3.Analysis
// JSystem.@out.println(" context="+context);
// traverse epsilon edge to new rule
NFAState ruleTarget = (NFAState)@ref.target;
-                closure( ruleTarget, alt, newContext, semanticContext, d, collectPredicates );
+                Closure( ruleTarget, alt, newContext, semanticContext, d, collectPredicates );
}
// Case 2: end of rule state, context (i.e., an invoker) exists
else if ( p.IsAcceptState && context.parent != null )
@@ -737,7 +737,7 @@ namespace Antlr3.Analysis
(RuleClosureTransition)whichStateInvokedRule.transition[0];
NFAState continueState = edgeToRule.followState;
NFAContext newContext = context.parent; // "pop" invoking state
-                closure( continueState, alt, newContext, semanticContext, d, collectPredicates );
+                Closure( continueState, alt, newContext, semanticContext, d, collectPredicates );
}
// Case 3: end of rule state, nobody invoked this rule (no context)
//    Fall thru to be handled by case 4 automagically.
@@ -757,7 +757,7 @@ namespace Antlr3.Analysis
}
*/
}
-                    closure( (NFAState)transition0.target,
+                    Closure( (NFAState)transition0.target,
alt,
context,
semanticContext,
@@ -792,7 +792,7 @@ namespace Antlr3.Analysis
// do not hoist syn preds from other rules; only get if in
// starting state's rule (i.e., context is empty)
int walkAlt =
-                            _dfa.NFADecisionStartState.translateDisplayAltToWalkAlt( alt );
+                            _dfa.NFADecisionStartState.TranslateDisplayAltToWalkAlt( alt );
NFAState altLeftEdge =
_dfa.nfa.grammar.getNFAStateForAltOfDecision( _dfa.NFADecisionStartState, walkAlt );
/*
@@ -810,7 +810,7 @@ namespace Antlr3.Analysis
SemanticContext.And( semanticContext, labelContext );
}
}
-                    closure( (NFAState)transition0.target,
+                    Closure( (NFAState)transition0.target,
alt,
context,
newSemanticContext,
@@ -820,7 +820,7 @@ namespace Antlr3.Analysis
Transition transition1 = p.transition[1];
if ( transition1 != null && transition1.IsEpsilon )
{
-                    closure( (NFAState)transition1.target,
+                    Closure( (NFAState)transition1.target,
alt,
context,
semanticContext,
@@ -865,7 +865,7 @@ namespace Antlr3.Analysis
*  Changing back to Set from List.  Changed a large grammar from 8 minutes
*  to 11 seconds.  Cool.  Closing ANTLR-235.
*/
-        public static bool closureIsBusy( DFAState d,
+        public static bool ClosureIsBusy( DFAState d,
NFAConfiguration proposedNFAConfiguration )
{
return d.closureBusy.Contains( proposedNFAConfiguration );
@@ -904,10 +904,10 @@ namespace Antlr3.Analysis
*  This method does not see EOT transitions off the end of token rule
*  accept states if the rule was invoked by somebody.
*/
-        public virtual DFAState reach( DFAState d, Label label )
+        public virtual DFAState Reach( DFAState d, Label label )
{
//JSystem.@out.println("reach "+label.toString(dfa.nfa.grammar)+" from "+d.stateNumber);
-            DFAState labelDFATarget = _dfa.newState();
+            DFAState labelDFATarget = _dfa.NewState();

// for each NFA state in d with a labeled edge,
// add in target states for label
@@ -922,7 +922,7 @@ namespace Antlr3.Analysis
{
continue; // the conflict resolver indicates we must leave alone
}
-                NFAState p = _dfa.nfa.getState( c.state );
+                NFAState p = _dfa.nfa.GetState( c.state );
// by design of the grammar->NFA conversion, only transition 0
// may have a non-epsilon edge.
Transition edge = p.transition[0];
@@ -947,11 +947,11 @@ namespace Antlr3.Analysis
// Labels not unique at this point (not until addReachableLabels)
// so try simple int label match before general set intersection
//JSystem.@out.println("comparing "+edgeLabel+" with "+label);
-                if ( Label.intersect( label, edgeLabel ) )
+                if ( Label.Intersect( label, edgeLabel ) )
{
// found a transition with label;
// add NFA target to (potentially) new DFA state
-                    NFAConfiguration newC = labelDFATarget.addNFAConfiguration(
+                    NFAConfiguration newC = labelDFATarget.AddNFAConfiguration(
(NFAState)edge.target,
c.alt,
c.context,
@@ -961,7 +961,7 @@ namespace Antlr3.Analysis
if ( labelDFATarget.nfaConfigurations.size() == 0 )
{
// kill; it's empty
-                _dfa.setState( labelDFATarget.stateNumber, null );
+                _dfa.SetState( labelDFATarget.stateNumber, null );
labelDFATarget = null;
}
return labelDFATarget;
@@ -978,7 +978,7 @@ namespace Antlr3.Analysis
*  Seems like that would be rare or impossible.  Perhaps convert
*  this routine to find all such configs and give error if >1.
*/
-        protected virtual void convertToEOTAcceptState( DFAState d )
+        protected virtual void ConvertToEOTAcceptState( DFAState d )
{
Label eot = new Label( Label.EOT );
int numConfigs = d.nfaConfigurations.size();
@@ -989,7 +989,7 @@ namespace Antlr3.Analysis
{
continue; // the conflict resolver indicates we must leave alone
}
-                NFAState p = _dfa.nfa.getState( c.state );
+                NFAState p = _dfa.nfa.GetState( c.state );
Transition edge = p.transition[0];
Label edgeLabel = edge.label;
if ( edgeLabel.Equals( eot ) )
@@ -998,7 +998,7 @@ namespace Antlr3.Analysis
d.IsAcceptState = true;
//JSystem.@out.println("d goes from "+d);
d.nfaConfigurations.clear();
-                    d.addNFAConfiguration( p, c.alt, c.context, c.semanticContext );
+                    d.AddNFAConfiguration( p, c.alt, c.context, c.semanticContext );
//JSystem.@out.println("to "+d);
return; // assume only one EOT transition
}
@@ -1012,9 +1012,9 @@ namespace Antlr3.Analysis
*  and with the same syn and sem context, the DFA is nondeterministic for
*  at least one input sequence reaching that NFA state.
*/
-        protected virtual DFAState addDFAStateToWorkList( DFAState d )
+        protected virtual DFAState AddDFAStateToWorkList( DFAState d )
{
-            DFAState existingState = _dfa.addState( d );
+            DFAState existingState = _dfa.AddState( d );
if ( d != existingState )
{
// already there...use/return the existing DFA state.
@@ -1027,7 +1027,7 @@ namespace Antlr3.Analysis
// into the reachable state space and the error
// reporting must be able to compute the path from
// start to the error state with infinite recursion
-                _dfa.setState( d.stateNumber, existingState );
+                _dfa.SetState( d.stateNumber, existingState );
return existingState;
}

@@ -1035,14 +1035,14 @@ namespace Antlr3.Analysis

// resolve syntactic conflicts by choosing a single alt or
// by using semantic predicates if present.
-            resolveNonDeterminisms( d );
+            ResolveNonDeterminisms( d );

// If deterministic, don't add this state; it's an accept state
// Just return as a valid DFA state
-            int alt = d.getUniquelyPredictedAlt();
+            int alt = d.GetUniquelyPredictedAlt();
if ( alt != NFA.INVALID_ALT_NUMBER )
{ // uniquely predicts an alt?
-                d = convertToAcceptState( d, alt );
+                d = ConvertToAcceptState( d, alt );
/*
JSystem.@out.println("convert to accept; DFA "+d.dfa.decisionNumber+" state "+d.stateNumber+" uniquely predicts alt "+
d.getUniquelyPredictedAlt());
@@ -1056,7 +1056,7 @@ namespace Antlr3.Analysis
return d;
}

-        protected virtual DFAState convertToAcceptState( DFAState d, int alt )
+        protected virtual DFAState ConvertToAcceptState( DFAState d, int alt )
{
// only merge stop states if they are deterministic and no
// recursion problems and only if they have the same gated pred
@@ -1064,13 +1064,13 @@ namespace Antlr3.Analysis
// Later, the error reporting may want to trace the path from
// the start state to the nondet state
if ( DFAOptimizer.MERGE_STOP_STATES &&
-                d.getNonDeterministicAlts() == null &&
+                d.GetNonDeterministicAlts() == null &&
!d.abortedDueToRecursionOverflow &&
!d.abortedDueToMultipleRecursiveAlts )
{
// check to see if we already have an accept state for this alt
// [must do this after we resolve nondeterminisms in general]
-                DFAState acceptStateForAlt = _dfa.getAcceptState( alt );
+                DFAState acceptStateForAlt = _dfa.GetAcceptState( alt );
if ( acceptStateForAlt != null )
{
// we already have an accept state for alt;
@@ -1079,16 +1079,16 @@ namespace Antlr3.Analysis
// have gated preds or share exactly same single gated pred.
// The equals() method is only defined on Predicate contexts not
// OR etc...
-                    SemanticContext gatedPreds = d.getGatedPredicatesInNFAConfigurations();
+                    SemanticContext gatedPreds = d.GetGatedPredicatesInNFAConfigurations();
SemanticContext existingStateGatedPreds =
-                        acceptStateForAlt.getGatedPredicatesInNFAConfigurations();
+                        acceptStateForAlt.GetGatedPredicatesInNFAConfigurations();
if ( ( gatedPreds == null && existingStateGatedPreds == null ) ||
( ( gatedPreds != null && existingStateGatedPreds != null ) &&
gatedPreds.Equals( existingStateGatedPreds ) ) )
{
// make this d.statenumber point at old DFA state
-                        _dfa.setState( d.stateNumber, acceptStateForAlt );
-                        _dfa.removeState( d );    // remove this state from unique DFA state set
+                        _dfa.SetState( d.stateNumber, acceptStateForAlt );
+                        _dfa.RemoveState( d );    // remove this state from unique DFA state set
d = acceptStateForAlt; // use old accept state; throw this one out
return d;
}
@@ -1096,7 +1096,7 @@ namespace Antlr3.Analysis
}
}
d.IsAcceptState = true; // new accept state for alt
-            _dfa.setAcceptState( alt, d );
+            _dfa.SetAcceptState( alt, d );
return d;
}

@@ -1241,14 +1241,14 @@ namespace Antlr3.Analysis
*  Worse, when you have two identical literal rules, you will see 3 alts
*  in the EOT state (one for ID and one each for the identical rules).
*/
-        public virtual void resolveNonDeterminisms( DFAState d )
+        public virtual void ResolveNonDeterminisms( DFAState d )
{
if ( debug )
{
Console.Out.WriteLine( "resolveNonDeterminisms " + d.ToString() );
}
bool conflictingLexerRules = false;
-            HashSet<int> nondeterministicAlts = d.getNonDeterministicAlts();
+            HashSet<int> nondeterministicAlts = d.GetNonDeterministicAlts();
if ( debug && nondeterministicAlts != null )
{
Console.Out.WriteLine( "nondet alts=" + nondeterministicAlts );
@@ -1260,7 +1260,7 @@ namespace Antlr3.Analysis
// states in d must be targets of EOT.  These are the end states
// created in NFAFactory.build_EOFState
NFAConfiguration anyConfig = d.nfaConfigurations.get( 0 );
-            NFAState anyState = _dfa.nfa.getState( anyConfig.state );
+            NFAState anyState = _dfa.nfa.GetState( anyConfig.state );

// if d is target of EOT and more than one predicted alt
// indicate that d is nondeterministic on all alts otherwise
@@ -1301,7 +1301,7 @@ namespace Antlr3.Analysis

// ATTEMPT TO RESOLVE WITH SEMANTIC PREDICATES
bool resolved =
-                tryToResolveWithSemanticPredicates( d, nondeterministicAlts );
+                TryToResolveWithSemanticPredicates( d, nondeterministicAlts );
if ( resolved )
{
if ( debug )
@@ -1314,17 +1314,17 @@ namespace Antlr3.Analysis
}

// RESOLVE SYNTACTIC CONFLICT BY REMOVING ALL BUT ONE ALT
-            resolveByChoosingFirstAlt( d, nondeterministicAlts );
+            ResolveByChoosingFirstAlt( d, nondeterministicAlts );

//JSystem.@out.println("state "+d.stateNumber+" resolved to alt "+winningAlt);
}

-        protected virtual int resolveByChoosingFirstAlt( DFAState d, ICollection<int> nondeterministicAlts )
+        protected virtual int ResolveByChoosingFirstAlt( DFAState d, ICollection<int> nondeterministicAlts )
{
int winningAlt = 0;
if ( _dfa.IsGreedy )
{
-                winningAlt = resolveByPickingMinAlt( d, nondeterministicAlts );
+                winningAlt = ResolveByPickingMinAlt( d, nondeterministicAlts );
}
else
{
@@ -1341,11 +1341,11 @@ namespace Antlr3.Analysis
{
// if nongreedy and exit alt is one of those nondeterministic alts
// predicted, resolve in favor of what follows block
-                    winningAlt = resolveByPickingExitAlt( d, nondeterministicAlts );
+                    winningAlt = ResolveByPickingExitAlt( d, nondeterministicAlts );
}
else
{
-                    winningAlt = resolveByPickingMinAlt( d, nondeterministicAlts );
+                    winningAlt = ResolveByPickingMinAlt( d, nondeterministicAlts );
}
}
return winningAlt;
@@ -1361,19 +1361,19 @@ namespace Antlr3.Analysis
*
*  Return the min alt found.
*/
-        protected virtual int resolveByPickingMinAlt( DFAState d, ICollection<int> nondeterministicAlts )
+        protected virtual int ResolveByPickingMinAlt( DFAState d, ICollection<int> nondeterministicAlts )
{
int min = int.MaxValue;
if ( nondeterministicAlts != null )
{
-                min = getMinAlt( nondeterministicAlts );
+                min = GetMinAlt( nondeterministicAlts );
}
else
{
min = d.minAltInConfigurations;
}

-            turnOffOtherAlts( d, min, nondeterministicAlts );
+            TurnOffOtherAlts( d, min, nondeterministicAlts );

return min;
}
@@ -1381,17 +1381,17 @@ namespace Antlr3.Analysis
/** Resolve state d by choosing exit alt, which is same value as the
*  number of alternatives.  Return that exit alt.
*/
-        protected virtual int resolveByPickingExitAlt( DFAState d, ICollection<int> nondeterministicAlts )
+        protected virtual int ResolveByPickingExitAlt( DFAState d, ICollection<int> nondeterministicAlts )
{
int exitAlt = _dfa.NumberOfAlts;
-            turnOffOtherAlts( d, exitAlt, nondeterministicAlts );
+            TurnOffOtherAlts( d, exitAlt, nondeterministicAlts );
return exitAlt;
}

/** turn off all states associated with alts other than the good one
*  (as long as they are one of the nondeterministic ones)
*/
-        protected static void turnOffOtherAlts( DFAState d, int min, ICollection<int> nondeterministicAlts )
+        protected static void TurnOffOtherAlts( DFAState d, int min, ICollection<int> nondeterministicAlts )
{
int numConfigs = d.nfaConfigurations.size();
for ( int i = 0; i < numConfigs; i++ )
@@ -1408,7 +1408,7 @@ namespace Antlr3.Analysis
}
}

-        protected static int getMinAlt( ICollection<int> nondeterministicAlts )
+        protected static int GetMinAlt( ICollection<int> nondeterministicAlts )
{
int min = int.MaxValue;
foreach ( int altI in nondeterministicAlts )
@@ -1450,11 +1450,11 @@ namespace Antlr3.Analysis
*
*  This is done down in getPredicatesPerNonDeterministicAlt().
*/
-        protected virtual bool tryToResolveWithSemanticPredicates( DFAState d,
+        protected virtual bool TryToResolveWithSemanticPredicates( DFAState d,
ICollection<int> nondeterministicAlts )
{
IDictionary<int, SemanticContext> altToPredMap =
-                    getPredicatesPerNonDeterministicAlt( d, nondeterministicAlts );
+                    GetPredicatesPerNonDeterministicAlt( d, nondeterministicAlts );

if ( altToPredMap.Count == 0 )
{
@@ -1490,7 +1490,7 @@ namespace Antlr3.Analysis
BitSet predSet = BitSet.of( altToPredMap.Keys );
int nakedAlt = ndSet.subtract( predSet ).getSingleElement();
SemanticContext nakedAltPred = null;
-                if ( nakedAlt == max( nondeterministicAlts ) )
+                if ( nakedAlt == Max( nondeterministicAlts ) )
{
// the naked alt is the last nondet alt and will be the default clause
nakedAltPred = new SemanticContext.TruePredicate();
@@ -1501,7 +1501,7 @@ namespace Antlr3.Analysis
// unless it's a synpred since those have precedence same
// as alt order
SemanticContext unionOfPredicatesFromAllAlts =
-                        getUnionOfPredicates( altToPredMap );
+                        GetUnionOfPredicates( altToPredMap );
//JSystem.@out.println("all predicates "+unionOfPredicatesFromAllAlts);
if ( unionOfPredicatesFromAllAlts.IsSyntacticPredicate )
{
@@ -1591,7 +1591,7 @@ namespace Antlr3.Analysis
*  we did a reach on to compute state d.  d may have insufficient
*  preds, so we really want this for the error message.
*/
-        protected virtual IDictionary<int, SemanticContext> getPredicatesPerNonDeterministicAlt( DFAState d,
+        protected virtual IDictionary<int, SemanticContext> GetPredicatesPerNonDeterministicAlt( DFAState d,
ICollection<int> nondeterministicAlts )
{
// map alt to combined SemanticContext
@@ -1708,7 +1708,7 @@ namespace Antlr3.Analysis
if ( incompletelyCoveredAlts.Contains( altI ) &&
configuration.semanticContext == SemanticContext.EmptySemanticContext )
{
-                        NFAState s = _dfa.nfa.getState( configuration.state );
+                        NFAState s = _dfa.nfa.GetState( configuration.state );
/*
JSystem.@out.print("nondet config w/o context "+configuration+
" incident "+(s.incidentEdgeLabel!=null?s.incidentEdgeLabel.toString(dfa.nfa.grammar):null));
@@ -1748,7 +1748,7 @@ namespace Antlr3.Analysis
/** OR together all predicates from the alts.  Note that the predicate
*  for an alt could itself be a combination of predicates.
*/
-        protected static SemanticContext getUnionOfPredicates( IDictionary<int, SemanticContext> altToPredMap )
+        protected static SemanticContext GetUnionOfPredicates( IDictionary<int, SemanticContext> altToPredMap )
{
SemanticContext unionOfPredicatesFromAllAlts = null;
foreach ( SemanticContext semCtx in altToPredMap.Values )
@@ -1787,7 +1787,7 @@ namespace Antlr3.Analysis
*  Predicates succeed in the order they are specifed.  Alt i wins
*  over alt i+1 if both predicates are true.
*/
-        protected virtual void addPredicateTransitions( DFAState d )
+        protected virtual void AddPredicateTransitions( DFAState d )
{
List<NFAConfiguration> configsWithPreds = new List<NFAConfiguration>();
// get a list of all configs with predicates
@@ -1808,33 +1808,33 @@ namespace Antlr3.Analysis
for ( int i = 0; i < predConfigsSortedByAlt.Count; i++ )
{
NFAConfiguration c = (NFAConfiguration)predConfigsSortedByAlt[i];
-                DFAState predDFATarget = d.dfa.getAcceptState( c.alt );
+                DFAState predDFATarget = d.dfa.GetAcceptState( c.alt );
if ( predDFATarget == null )
{
-                    predDFATarget = _dfa.newState(); // create if not there.
+                    predDFATarget = _dfa.NewState(); // create if not there.
// create a new DFA state that is a target of the predicate from d
-                    predDFATarget.addNFAConfiguration( _dfa.nfa.getState( c.state ),
+                    predDFATarget.AddNFAConfiguration( _dfa.nfa.GetState( c.state ),
c.alt,
c.context,
c.semanticContext );
predDFATarget.IsAcceptState = true;
-                    _dfa.setAcceptState( c.alt, predDFATarget );
-                    DFAState existingState = _dfa.addState( predDFATarget );
+                    _dfa.SetAcceptState( c.alt, predDFATarget );
+                    DFAState existingState = _dfa.AddState( predDFATarget );
if ( predDFATarget != existingState )
{
// already there...use/return the existing DFA state that
// is a target of this predicate.  Make this state number
// point at the existing state
-                        _dfa.setState( predDFATarget.stateNumber, existingState );
+                        _dfa.SetState( predDFATarget.stateNumber, existingState );
predDFATarget = existingState;
}
}
// add a transition to pred target from d
-                d.addTransition( predDFATarget, new PredicateLabel( c.semanticContext ) );
+                d.AddTransition( predDFATarget, new PredicateLabel( c.semanticContext ) );
}
}

-        protected virtual void initContextTrees( int numberOfAlts )
+        protected virtual void InitContextTrees( int numberOfAlts )
{
_contextTrees = new NFAContext[numberOfAlts];
for ( int i = 0; i < _contextTrees.Length; i++ )
@@ -1848,7 +1848,7 @@ namespace Antlr3.Analysis
}
}

-        public static int max( ICollection<int> s )
+        public static int Max( ICollection<int> s )
{
if ( s == null )
return int.MinValue;
diff --git a/Antlr3/Analysis/SemanticContext.cs b/Antlr3/Analysis/SemanticContext.cs
index 0b436de..ca07b39 100644
--- a/Antlr3/Analysis/SemanticContext.cs
+++ b/Antlr3/Analysis/SemanticContext.cs
@@ -84,7 +84,7 @@ namespace Antlr3.Analysis
/** Generate an expression that will evaluate the semantic context,
*  given a set of output templates.
*/
-        public abstract StringTemplate genExpr( CodeGenerator generator,
+        public abstract StringTemplate GenExpr( CodeGenerator generator,
StringTemplateGroup templates,
DFA dfa );

@@ -94,7 +94,7 @@ namespace Antlr3.Analysis
}

/** Notify the indicated grammar of any syn preds used within this context */
-        public virtual void trackUseOfSyntacticPredicates( Grammar g )
+        public virtual void TrackUseOfSyntacticPredicates( Grammar g )
{
}

@@ -176,7 +176,7 @@ namespace Antlr3.Analysis
return predicateAST.Text.GetHashCode();
}

-            public override StringTemplate genExpr( CodeGenerator generator,
+            public override StringTemplate GenExpr( CodeGenerator generator,
StringTemplateGroup templates,
DFA dfa )
{
@@ -244,7 +244,7 @@ namespace Antlr3.Analysis
}
}

-            public override void trackUseOfSyntacticPredicates( Grammar g )
+            public override void TrackUseOfSyntacticPredicates( Grammar g )
{
if ( _synpred )
{
@@ -269,7 +269,7 @@ namespace Antlr3.Analysis
this.constantValue = TruePred;
}

-            public override StringTemplate genExpr( CodeGenerator generator,
+            public override StringTemplate GenExpr( CodeGenerator generator,
StringTemplateGroup templates,
DFA dfa )
{
@@ -293,7 +293,7 @@ namespace Antlr3.Analysis
{
this.constantValue = FalsePred;
}
-            public StringTemplate genExpr( CodeGenerator generator,
+            public StringTemplate GenExpr( CodeGenerator generator,
StringTemplateGroup templates,
DFA dfa )
{
@@ -320,7 +320,7 @@ namespace Antlr3.Analysis
this._left = a;
this._right = b;
}
-            public override StringTemplate genExpr( CodeGenerator generator,
+            public override StringTemplate GenExpr( CodeGenerator generator,
StringTemplateGroup templates,
DFA dfa )
{
@@ -333,8 +333,8 @@ namespace Antlr3.Analysis
{
eST = new StringTemplate( "($left$&&$right$)" );
}
-                eST.SetAttribute( "left", _left.genExpr( generator, templates, dfa ) );
-                eST.SetAttribute( "right", _right.genExpr( generator, templates, dfa ) );
+                eST.SetAttribute( "left", _left.GenExpr( generator, templates, dfa ) );
+                eST.SetAttribute( "right", _right.GenExpr( generator, templates, dfa ) );
return eST;
}
public override SemanticContext GatedPredicateContext
@@ -361,10 +361,10 @@ namespace Antlr3.Analysis
return _left.IsSyntacticPredicate || _right.IsSyntacticPredicate;
}
}
-            public override void trackUseOfSyntacticPredicates( Grammar g )
+            public override void TrackUseOfSyntacticPredicates( Grammar g )
{
-                _left.trackUseOfSyntacticPredicates( g );
-                _right.trackUseOfSyntacticPredicates( g );
+                _left.TrackUseOfSyntacticPredicates( g );
+                _right.TrackUseOfSyntacticPredicates( g );
}
public override string ToString()
{
@@ -396,7 +396,7 @@ namespace Antlr3.Analysis
_operands.Add( b );
}
}
-            public override StringTemplate genExpr( CodeGenerator generator,
+            public override StringTemplate GenExpr( CodeGenerator generator,
StringTemplateGroup templates,
DFA dfa )
{
@@ -411,7 +411,7 @@ namespace Antlr3.Analysis
}
foreach ( SemanticContext semctx in _operands )
{
-                    eST.SetAttribute( "operands", semctx.genExpr( generator, templates, dfa ) );
+                    eST.SetAttribute( "operands", semctx.GenExpr( generator, templates, dfa ) );
}
return eST;
}
@@ -446,11 +446,11 @@ namespace Antlr3.Analysis
return false;
}
}
-            public override void trackUseOfSyntacticPredicates( Grammar g )
+            public override void TrackUseOfSyntacticPredicates( Grammar g )
{
foreach ( SemanticContext semctx in _operands )
{
-                    semctx.trackUseOfSyntacticPredicates( g );
+                    semctx.TrackUseOfSyntacticPredicates( g );
}
}
public override string ToString()
@@ -479,7 +479,7 @@ namespace Antlr3.Analysis
{
this.ctx = ctx;
}
-            public override StringTemplate genExpr( CodeGenerator generator,
+            public override StringTemplate GenExpr( CodeGenerator generator,
StringTemplateGroup templates,
DFA dfa )
{
@@ -492,7 +492,7 @@ namespace Antlr3.Analysis
{
eST = new StringTemplate( "?!($pred$)" );
}
-                eST.SetAttribute( "pred", ctx.genExpr( generator, templates, dfa ) );
+                eST.SetAttribute( "pred", ctx.GenExpr( generator, templates, dfa ) );
return eST;
}
public override SemanticContext GatedPredicateContext
@@ -514,9 +514,9 @@ namespace Antlr3.Analysis
return ctx.IsSyntacticPredicate;
}
}
-            public override void trackUseOfSyntacticPredicates( Grammar g )
+            public override void TrackUseOfSyntacticPredicates( Grammar g )
{
-                ctx.trackUseOfSyntacticPredicates( g );
+                ctx.TrackUseOfSyntacticPredicates( g );
}

public override bool Equals( object @object )
diff --git a/Antlr3/Analysis/State.cs b/Antlr3/Analysis/State.cs
index e248cd9..2bc832a 100644
--- a/Antlr3/Analysis/State.cs
+++ b/Antlr3/Analysis/State.cs
@@ -62,8 +62,8 @@ namespace Antlr3.Analysis
}
#endregion

-        public abstract void addTransition( Transition e );
+        public abstract void AddTransition( Transition e );

-        public abstract Transition getTransition( int i );
+        public abstract Transition GetTransition( int i );
}
}
diff --git a/Antlr3/Codegen/ACyclicDFACodeGenerator.cs b/Antlr3/Codegen/ACyclicDFACodeGenerator.cs
index 8732494..78a1811 100644
--- a/Antlr3/Codegen/ACyclicDFACodeGenerator.cs
+++ b/Antlr3/Codegen/ACyclicDFACodeGenerator.cs
@@ -64,7 +64,7 @@ namespace Antlr3.Codegen
if ( s.IsAcceptState )
{
StringTemplate dfaST2 = templates.GetInstanceOf( "dfaAcceptState" );
-                dfaST2.SetAttribute( "alt", s.getUniquelyPredictedAlt() );
+                dfaST2.SetAttribute( "alt", s.GetUniquelyPredictedAlt() );
return dfaST2;
}

@@ -109,14 +109,14 @@ namespace Antlr3.Codegen
//System.Console.Out.WriteLine( "DFA state " + s.stateNumber );
for ( int i = 0; i < s.NumberOfTransitions; i++ )
{
-                Transition edge = (Transition)s.transition( i );
+                Transition edge = (Transition)s.Transition( i );
//System.Console.Out.WriteLine( "edge " + s.stateNumber + "-" + edge.label.ToString() + "->" + edge.target.stateNumber );
if ( edge.label.Atom == Label.EOT )
{
// don't generate a real edge for EOT; track alt EOT predicts
// generate that prediction in the else clause as default case
EOTTarget = (DFAState)edge.target;
-                    EOTPredicts = EOTTarget.getUniquelyPredictedAlt();
+                    EOTPredicts = EOTTarget.GetUniquelyPredictedAlt();
/*
System.Console.Out.WriteLine("DFA s"+s.stateNumber+" EOT goes to s"+
edge.target.stateNumber+" predicates alt "+
@@ -142,11 +142,11 @@ namespace Antlr3.Codegen
{
DFAState target = (DFAState)edge.target;
SemanticContext preds =
-                        target.getGatedPredicatesInNFAConfigurations();
+                        target.GetGatedPredicatesInNFAConfigurations();
if ( preds != null )
{
//System.Console.Out.WriteLine( "preds=" + target.getGatedPredicatesInNFAConfigurations() );
-                        StringTemplate predST = preds.genExpr( parentGenerator,
+                        StringTemplate predST = preds.GenExpr( parentGenerator,
parentGenerator.Templates,
dfa );
edgeST.SetAttribute( "predicates", predST );
@@ -181,7 +181,7 @@ namespace Antlr3.Codegen
// hoisted up to the state that has the EOT edge.
for ( int i = 0; i < EOTTarget.NumberOfTransitions; i++ )
{
-                    Transition predEdge = (Transition)EOTTarget.transition( i );
+                    Transition predEdge = (Transition)EOTTarget.Transition( i );
StringTemplate edgeST = templates.GetInstanceOf( dfaEdgeName );
edgeST.SetAttribute( "labelExpr",
parentGenerator.genSemanticPredicateExpr( templates, predEdge ) );
diff --git a/Antlr3/Codegen/CodeGenerator.cs b/Antlr3/Codegen/CodeGenerator.cs
index fb4d7df..3240781 100644
--- a/Antlr3/Codegen/CodeGenerator.cs
+++ b/Antlr3/Codegen/CodeGenerator.cs
@@ -437,7 +437,7 @@ namespace Antlr3.Codegen

// OPTIMIZE DFA
DFAOptimizer optimizer = new DFAOptimizer( grammar );
-            optimizer.optimize();
+            optimizer.Optimize();

// OUTPUT FILE (contains recognizerST)
outputFileST = templates.GetInstanceOf( "outputFile" );
@@ -724,12 +724,12 @@ namespace Antlr3.Codegen
ErrorManager.internalError( "no follow state or cannot compute follow" );
follow = new LookaheadSet();
}
-            if ( follow.member( Label.EOF ) )
+            if ( follow.Member( Label.EOF ) )
{
// TODO: can we just remove?  Seems needed here:
// compilation_unit : global_statement* EOF
// Actually i guess we resync to EOF regardless
-                follow.remove( Label.EOF );
+                follow.Remove( Label.EOF );
}
//JSystem.@out.println(" "+follow);

@@ -798,7 +798,7 @@ namespace Antlr3.Codegen
else
{
// generate any kind of DFA here (cyclic or acyclic)
-                dfa.createStateTables( this );
+                dfa.CreateStateTables( this );
outputFileST.SetAttribute( "cyclicDFAs", dfa );
headerFileST.SetAttribute( "cyclicDFAs", dfa );
decisionST = templates.GetInstanceOf( "dfaDecision" );
@@ -833,7 +833,7 @@ namespace Antlr3.Codegen
StringTemplate eotST = null;
for ( int i = 0; i < s.NumberOfTransitions; i++ )
{
-                Transition edge = (Transition)s.transition( i );
+                Transition edge = (Transition)s.Transition( i );
StringTemplate edgeST;
if ( edge.label.Atom == Label.EOT )
{
@@ -856,11 +856,11 @@ namespace Antlr3.Codegen
if ( !edge.label.IsSemanticPredicate )
{
DFAState t = (DFAState)edge.target;
-                    SemanticContext preds = t.getGatedPredicatesInNFAConfigurations();
+                    SemanticContext preds = t.GetGatedPredicatesInNFAConfigurations();
if ( preds != null )
{
foundGatedPred = true;
-                        StringTemplate predST = preds.genExpr( this,
+                        StringTemplate predST = preds.GenExpr( this,
Templates,
t.dfa );
edgeST.SetAttribute( "predicates", predST.ToString() );
@@ -912,7 +912,7 @@ namespace Antlr3.Codegen
DFA dfa = ( (DFAState)edge.target ).dfa; // which DFA are we in
Label label = edge.label;
SemanticContext semCtx = label.SemanticContext;
-            return semCtx.genExpr( this, templates, dfa );
+            return semCtx.GenExpr( this, templates, dfa );
}

/** For intervals such as [3..3, 30..35], generate an expression that
@@ -1517,7 +1517,7 @@ namespace Antlr3.Codegen
int size = 0;
for ( int i = 0; i < s.NumberOfTransitions; i++ )
{
-                Transition edge = (Transition)s.transition( i );
+                Transition edge = (Transition)s.Transition( i );
if ( edge.label.IsSemanticPredicate )
{
return false;
@@ -1525,7 +1525,7 @@ namespace Antlr3.Codegen
// can't do a switch if the edges are going to require predicates
if ( edge.label.Atom == Label.EOT )
{
-                    int EOTPredicts = ( (DFAState)edge.target ).getUniquelyPredictedAlt();
+                    int EOTPredicts = ( (DFAState)edge.target ).GetUniquelyPredictedAlt();
if ( EOTPredicts == NFA.INVALID_ALT_NUMBER )
{
// EOT target has to be a predicate then; no unique alt
@@ -1534,7 +1534,7 @@ namespace Antlr3.Codegen
}
// if target is a state with gated preds, we need to use preds on
// this edge then to reach it.
-                if ( ( (DFAState)edge.target ).getGatedPredicatesInNFAConfigurations() != null )
+                if ( ( (DFAState)edge.target ).GetGatedPredicatesInNFAConfigurations() != null )
{
return false;
}
diff --git a/Antlr3/Grammars/CodeGenTreeWalker.cs b/Antlr3/Grammars/CodeGenTreeWalker.cs
index 12e67d7..3e2c431 100644
--- a/Antlr3/Grammars/CodeGenTreeWalker.cs
+++ b/Antlr3/Grammars/CodeGenTreeWalker.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Grammars\\CodeGenTreeWalker.g3 2009-04-10 17:42:48
+// $ANTLR 3.1.2 Grammars\\CodeGenTreeWalker.g3 2009-04-16 17:15:31

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -3419,9 +3419,9 @@ public partial class CodeGenTreeWalker : TreeParser
if ( state.backtracking == 0 )
{
retval.code = templates.GetInstanceOf("tree");
-				NFAState afterDOWN = (NFAState)((GrammarAST)retval.start).NFATreeDownState.getTransition(0).target;
+				NFAState afterDOWN = (NFAState)((GrammarAST)retval.start).NFATreeDownState.GetTransition(0).target;
LookaheadSet s = grammar.LOOK(afterDOWN);
-				if ( s.member(Label.UP) ) {
+				if ( s.Member(Label.UP) ) {
// nullable child list if we can see the UP as the next token
// we need an "if ( input.LA(1)==Token.DOWN )" gate around
// the child list.
diff --git a/Antlr3/Grammars/CodeGenTreeWalker.g3 b/Antlr3/Grammars/CodeGenTreeWalker.g3
index 9c4c628..ab88d9f 100644
--- a/Antlr3/Grammars/CodeGenTreeWalker.g3
+++ b/Antlr3/Grammars/CodeGenTreeWalker.g3
@@ -698,9 +698,9 @@ tree_ returns [StringTemplate code]
if ( state.backtracking == 0 )
{
$code = templates.GetInstanceOf("tree");
-		NFAState afterDOWN = (NFAState)$start.NFATreeDownState.getTransition(0).target;
+		NFAState afterDOWN = (NFAState)$start.NFATreeDownState.GetTransition(0).target;
LookaheadSet s = grammar.LOOK(afterDOWN);
-		if ( s.member(Label.UP) ) {
+		if ( s.Member(Label.UP) ) {
// nullable child list if we can see the UP as the next token
// we need an "if ( input.LA(1)==Token.DOWN )" gate around
// the child list.
diff --git a/Antlr3/Grammars/TreeToNFAConverter.cs b/Antlr3/Grammars/TreeToNFAConverter.cs
index f39d888..33d61d3 100644
--- a/Antlr3/Grammars/TreeToNFAConverter.cs
+++ b/Antlr3/Grammars/TreeToNFAConverter.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Grammars\\TreeToNFAConverter.g3 2009-04-10 17:43:58
+// $ANTLR 3.1.2 Grammars\\TreeToNFAConverter.g3 2009-04-16 17:19:06

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -1173,13 +1173,13 @@ public partial class TreeToNFAConverter : TreeParser
Rule thisR = grammar.getLocallyDefinedRule(currentRuleName);
NFAState start = thisR.startState;
start.associatedASTNode = id;
-									start.addTransition(new Transition(Label.EPSILON, g.left));
+									start.AddTransition(new Transition(Label.EPSILON, g.left));

// track decision if > 1 alts
if ( grammar.getNumberOfAltsForDecisionNFA(g.left)>1 )
{
g.left.Description = grammar.grammarTreeToString(((GrammarAST)retval.start),false);
-										g.left.setDecisionASTNode((b!=null?((GrammarAST)b.start):null));
+										g.left.SetDecisionASTNode((b!=null?((GrammarAST)b.start):null));
int d = grammar.assignDecisionNumber( g.left );
grammar.setDecisionNFA( d, g.left );
grammar.setDecisionBlockAST(d, (b!=null?((GrammarAST)b.start):null));
@@ -1187,7 +1187,7 @@ public partial class TreeToNFAConverter : TreeParser

// hook to end of rule node
NFAState end = thisR.stopState;
-									g.right.addTransition(new Transition(Label.EPSILON,end));
+									g.right.AddTransition(new Transition(Label.EPSILON,end));
}

}
@@ -2571,7 +2571,7 @@ public partial class TreeToNFAConverter : TreeParser
if ( grammar.getNumberOfAltsForDecisionNFA((b!=null?b.g:default(StateCluster)).left)>1 )
{
(b!=null?b.g:default(StateCluster)).left.Description = grammar.grammarTreeToString(blk,false);
-									(b!=null?b.g:default(StateCluster)).left.setDecisionASTNode(blk);
+									(b!=null?b.g:default(StateCluster)).left.SetDecisionASTNode(blk);
int d = grammar.assignDecisionNumber( (b!=null?b.g:default(StateCluster)).left );
grammar.setDecisionNFA( d, (b!=null?b.g:default(StateCluster)).left );
grammar.setDecisionBlockAST(d, blk);
@@ -2611,7 +2611,7 @@ public partial class TreeToNFAConverter : TreeParser
int d = grammar.assignDecisionNumber( retval.g.left );
grammar.setDecisionNFA(d, retval.g.left);
grammar.setDecisionBlockAST(d, blk);
-								retval.g.left.setDecisionASTNode(((GrammarAST)retval.start));
+								retval.g.left.SetDecisionASTNode(((GrammarAST)retval.start));

}

@@ -2644,13 +2644,13 @@ public partial class TreeToNFAConverter : TreeParser
int d = grammar.assignDecisionNumber( bg.right );
grammar.setDecisionNFA(d, bg.right);
grammar.setDecisionBlockAST(d, blk);
-								bg.right.setDecisionASTNode(eob);
+								bg.right.SetDecisionASTNode(eob);
// make block entry state also have same decision for interpreting grammar
-								NFAState altBlockState = (NFAState)retval.g.left.getTransition(0).target;
-								altBlockState.setDecisionASTNode(((GrammarAST)retval.start));
+								NFAState altBlockState = (NFAState)retval.g.left.GetTransition(0).target;
+								altBlockState.SetDecisionASTNode(((GrammarAST)retval.start));
altBlockState.DecisionNumber = d;
retval.g.left.DecisionNumber = d; // this is the bypass decision (2 alts)
-								retval.g.left.setDecisionASTNode(((GrammarAST)retval.start));
+								retval.g.left.SetDecisionASTNode(((GrammarAST)retval.start));

}

@@ -2684,10 +2684,10 @@ public partial class TreeToNFAConverter : TreeParser
int d = grammar.assignDecisionNumber( bg.right );
grammar.setDecisionNFA(d, bg.right);
grammar.setDecisionBlockAST(d, blk);
-								bg.right.setDecisionASTNode(eob);
+								bg.right.SetDecisionASTNode(eob);
// make block entry state also have same decision for interpreting grammar
-								NFAState altBlockState = (NFAState)retval.g.left.getTransition(0).target;
-								altBlockState.setDecisionASTNode(((GrammarAST)retval.start));
+								NFAState altBlockState = (NFAState)retval.g.left.GetTransition(0).target;
+								altBlockState.SetDecisionASTNode(((GrammarAST)retval.start));
altBlockState.DecisionNumber = d;

}
@@ -2948,7 +2948,7 @@ public partial class TreeToNFAConverter : TreeParser
ttype = grammar.getTokenType((c!=null?c.Text:null));
}
IIntSet notAtom = grammar.complement(ttype);
-											if ( notAtom.isNil() )
+											if ( notAtom.IsNil )
{
ErrorManager.grammarError(
ErrorManager.MSG_EMPTY_COMPLEMENT,
@@ -3016,7 +3016,7 @@ public partial class TreeToNFAConverter : TreeParser
ttype = grammar.getTokenType((t!=null?t.Text:null));
notAtom = grammar.complement(ttype);
}
-											if ( notAtom==null || notAtom.isNil() )
+											if ( notAtom==null || notAtom.IsNil )
{
ErrorManager.grammarError(
ErrorManager.MSG_EMPTY_COMPLEMENT,
@@ -3053,7 +3053,7 @@ public partial class TreeToNFAConverter : TreeParser
// let code gen do the complement again; here we compute
// for NFA construction
s = grammar.complement(s);
-											if ( s.isNil() )
+											if ( s.IsNil )
{
ErrorManager.grammarError(
ErrorManager.MSG_EMPTY_COMPLEMENT,
@@ -3227,7 +3227,7 @@ public partial class TreeToNFAConverter : TreeParser
retval.g = factory.build_RuleRef(rr, start);
r.followingNFAState = retval.g.right;
r._nfaStartState = retval.g.left;
-									if ( retval.g.left.getTransition(0) is RuleClosureTransition
+									if ( retval.g.left.GetTransition(0) is RuleClosureTransition
&& grammar.type!=Grammar.LEXER )
{
addFollowTransition((r!=null?r.Text:null), retval.g.right);
@@ -4287,7 +4287,7 @@ public partial class TreeToNFAConverter : TreeParser
if ( state.backtracking == 0 )
{

-								Transition setTrans = (gset!=null?gset.g:default(StateCluster)).left.getTransition(0);
+								Transition setTrans = (gset!=null?gset.g:default(StateCluster)).left.GetTransition(0);
elements.addAll(setTrans.label.Set);

}
diff --git a/Antlr3/Grammars/TreeToNFAConverter.g3 b/Antlr3/Grammars/TreeToNFAConverter.g3
index f38f461..ea16b8e 100644
--- a/Antlr3/Grammars/TreeToNFAConverter.g3
+++ b/Antlr3/Grammars/TreeToNFAConverter.g3
@@ -147,13 +147,13 @@ rule
Rule thisR = grammar.getLocallyDefinedRule(currentRuleName);
NFAState start = thisR.startState;
start.associatedASTNode = $id;
-					start.addTransition(new Transition(Label.EPSILON, g.left));
+					start.AddTransition(new Transition(Label.EPSILON, g.left));

// track decision if > 1 alts
if ( grammar.getNumberOfAltsForDecisionNFA(g.left)>1 )
{
g.left.Description = grammar.grammarTreeToString($start,false);
-						g.left.setDecisionASTNode($b.start);
+						g.left.SetDecisionASTNode($b.start);
int d = grammar.assignDecisionNumber( g.left );
grammar.setDecisionNFA( d, g.left );
grammar.setDecisionBlockAST(d, $b.start);
@@ -161,7 +161,7 @@ rule

// hook to end of rule node
NFAState end = thisR.stopState;
-					g.right.addTransition(new Transition(Label.EPSILON,end));
+					g.right.AddTransition(new Transition(Label.EPSILON,end));
}
}
)
@@ -292,7 +292,7 @@ ebnf returns [StateCluster g=null]
if ( grammar.getNumberOfAltsForDecisionNFA($b.g.left)>1 )
{
$b.g.left.Description = grammar.grammarTreeToString(blk,false);
-				$b.g.left.setDecisionASTNode(blk);
+				$b.g.left.SetDecisionASTNode(blk);
int d = grammar.assignDecisionNumber( $b.g.left );
grammar.setDecisionNFA( d, $b.g.left );
grammar.setDecisionBlockAST(d, blk);
@@ -314,7 +314,7 @@ ebnf returns [StateCluster g=null]
int d = grammar.assignDecisionNumber( $g.left );
grammar.setDecisionNFA(d, $g.left);
grammar.setDecisionBlockAST(d, blk);
-			$g.left.setDecisionASTNode($start);
+			$g.left.SetDecisionASTNode($start);
}
|	^( CLOSURE b=block )
{
@@ -329,13 +329,13 @@ ebnf returns [StateCluster g=null]
int d = grammar.assignDecisionNumber( bg.right );
grammar.setDecisionNFA(d, bg.right);
grammar.setDecisionBlockAST(d, blk);
-			bg.right.setDecisionASTNode(eob);
+			bg.right.SetDecisionASTNode(eob);
// make block entry state also have same decision for interpreting grammar
-			NFAState altBlockState = (NFAState)$g.left.getTransition(0).target;
-			altBlockState.setDecisionASTNode($start);
+			NFAState altBlockState = (NFAState)$g.left.GetTransition(0).target;
+			altBlockState.SetDecisionASTNode($start);
altBlockState.DecisionNumber = d;
$g.left.DecisionNumber = d; // this is the bypass decision (2 alts)
-			$g.left.setDecisionASTNode($start);
+			$g.left.SetDecisionASTNode($start);
}
|	^( POSITIVE_CLOSURE b=block )
{
@@ -351,10 +351,10 @@ ebnf returns [StateCluster g=null]
int d = grammar.assignDecisionNumber( bg.right );
grammar.setDecisionNFA(d, bg.right);
grammar.setDecisionBlockAST(d, blk);
-			bg.right.setDecisionASTNode(eob);
+			bg.right.SetDecisionASTNode(eob);
// make block entry state also have same decision for interpreting grammar
-			NFAState altBlockState = (NFAState)$g.left.getTransition(0).target;
-			altBlockState.setDecisionASTNode($start);
+			NFAState altBlockState = (NFAState)$g.left.GetTransition(0).target;
+			altBlockState.SetDecisionASTNode($start);
altBlockState.DecisionNumber = d;
}
;
@@ -398,7 +398,7 @@ atom_or_notatom returns [StateCluster g=null]
ttype = grammar.getTokenType($c.text);
}
IIntSet notAtom = grammar.complement(ttype);
-					if ( notAtom.isNil() )
+					if ( notAtom.IsNil )
{
ErrorManager.grammarError(
ErrorManager.MSG_EMPTY_COMPLEMENT,
@@ -433,7 +433,7 @@ atom_or_notatom returns [StateCluster g=null]
ttype = grammar.getTokenType($t.text);
notAtom = grammar.complement(ttype);
}
-					if ( notAtom==null || notAtom.isNil() )
+					if ( notAtom==null || notAtom.IsNil )
{
ErrorManager.grammarError(
ErrorManager.MSG_EMPTY_COMPLEMENT,
@@ -453,7 +453,7 @@ atom_or_notatom returns [StateCluster g=null]
// let code gen do the complement again; here we compute
// for NFA construction
s = grammar.complement(s);
-					if ( s.isNil() )
+					if ( s.IsNil )
{
ErrorManager.grammarError(
ErrorManager.MSG_EMPTY_COMPLEMENT,
@@ -477,7 +477,7 @@ atom[string scopeName] returns [StateCluster g=null]
$g = factory.build_RuleRef(rr, start);
r.followingNFAState = $g.right;
r._nfaStartState = $g.left;
-				if ( $g.left.getTransition(0) is RuleClosureTransition
+				if ( $g.left.GetTransition(0) is RuleClosureTransition
&& grammar.type!=Grammar.LEXER )
{
addFollowTransition($r.text, $g.right);
@@ -675,7 +675,7 @@ setElement[IIntSet elements]

|	gset=set
{
-			Transition setTrans = $gset.g.left.getTransition(0);
+			Transition setTrans = $gset.g.left.GetTransition(0);
elements.addAll(setTrans.label.Set);
}

diff --git a/Antlr3/Grammars/TreeToNFAConverterHelper.cs b/Antlr3/Grammars/TreeToNFAConverterHelper.cs
index 2d013eb..3daf5e3 100644
--- a/Antlr3/Grammars/TreeToNFAConverterHelper.cs
+++ b/Antlr3/Grammars/TreeToNFAConverterHelper.cs
@@ -121,21 +121,21 @@ namespace Antlr3.Grammars
// find last link in FOLLOW chain emanating from rule
Rule r = grammar.getRule( ruleName );
NFAState end = r.stopState;
-            while ( end.getTransition( 1 ) != null )
+            while ( end.GetTransition( 1 ) != null )
{
-                end = (NFAState)end.getTransition( 1 ).target;
+                end = (NFAState)end.GetTransition( 1 ).target;
}
-            if ( end.getTransition( 0 ) != null )
+            if ( end.GetTransition( 0 ) != null )
{
// already points to a following node
// gotta add another node to keep edges to a max of 2
NFAState n = factory.newState();
Transition e = new Transition( Label.EPSILON, n );
-                end.addTransition( e );
+                end.AddTransition( e );
end = n;
}
Transition followEdge = new Transition( Label.EPSILON, following );
-            end.addTransition( followEdge );
+            end.AddTransition( followEdge );
}

protected virtual void finish()
diff --git a/Antlr3/Misc/BitSet.cs b/Antlr3/Misc/BitSet.cs
index 4064814..bc2252f 100644
--- a/Antlr3/Misc/BitSet.cs
+++ b/Antlr3/Misc/BitSet.cs
@@ -103,7 +103,12 @@ namespace Antlr3.Misc
{
get
{
-                return isNil();
+                for ( int i = _bits.Length - 1; i >= 0; i-- )
+                {
+                    if ( _bits[i] != 0 )
+                        return false;
+                }
+                return true;
}
}
public int LengthInLongWords
@@ -352,16 +357,6 @@ namespace Antlr3.Misc
return Label.INVALID;
}

-        public virtual bool isNil()
-        {
-            for ( int i = _bits.Length - 1; i >= 0; i-- )
-            {
-                if ( _bits[i] != 0 )
-                    return false;
-            }
-            return true;
-        }
-
public virtual IIntSet complement()
{
BitSet s = (BitSet)this.Clone();
diff --git a/Antlr3/Misc/IntSet.cs b/Antlr3/Misc/IntSet.cs
index f7061de..b4812ea 100644
--- a/Antlr3/Misc/IntSet.cs
+++ b/Antlr3/Misc/IntSet.cs
@@ -68,7 +68,10 @@ namespace Antlr3.Misc
*/
int size();

-        bool isNil();
+        bool IsNil
+        {
+            get;
+        }

bool Equals( object obj );

diff --git a/Antlr3/Misc/IntervalSet.cs b/Antlr3/Misc/IntervalSet.cs
index c4b5ab5..67404bf 100644
--- a/Antlr3/Misc/IntervalSet.cs
+++ b/Antlr3/Misc/IntervalSet.cs
@@ -631,9 +631,12 @@ namespace Antlr3.Misc
}

/** return true if this set has no members */
-        public virtual bool isNil()
+        public virtual bool IsNil
{
-            return intervals == null || intervals.Count == 0;
+            get
+            {
+                return intervals == null || intervals.Count == 0;
+            }
}

/** If this set is a single integer, return it otherwise Label.INVALID */
@@ -652,7 +655,7 @@ namespace Antlr3.Misc

public virtual int getMaxElement()
{
-            if ( isNil() )
+            if ( IsNil )
{
return Label.INVALID;
}
@@ -663,7 +666,7 @@ namespace Antlr3.Misc
/** Return minimum element >= 0 */
public virtual int getMinElement()
{
-            if ( isNil() )
+            if ( IsNil )
{
return Label.INVALID;
}
diff --git a/Antlr3/Tool/DOTGenerator.cs b/Antlr3/Tool/DOTGenerator.cs
index 223e220..1f3370f 100644
--- a/Antlr3/Tool/DOTGenerator.cs
+++ b/Antlr3/Tool/DOTGenerator.cs
@@ -180,7 +180,7 @@ namespace Antlr3.Tool
// make a DOT edge for each transition
for ( int i = 0; i < s.NumberOfTransitions; i++ )
{
-                Transition edge = (Transition)s.transition( i );
+                Transition edge = (Transition)s.Transition( i );
//Console.Out.WriteLine( "dfa " + s.dfa.decisionNumber + " edge from s"
//    + s.stateNumber + " [" + i + "] of " + s.NumberOfTransitions );
if ( StripNonreducedStates )
@@ -264,7 +264,7 @@ namespace Antlr3.Tool
StringTemplate edgeST = null;
for ( int i = 0; i < s.NumberOfTransitions; i++ )
{
-                Transition edge = (Transition)s.getTransition( i );
+                Transition edge = (Transition)s.GetTransition( i );
if ( edge is RuleClosureTransition )
{
RuleClosureTransition rr = ( (RuleClosureTransition)edge );
@@ -366,12 +366,12 @@ namespace Antlr3.Tool
{
// look for gated predicates; don't add gated to simple sempred edges
SemanticContext preds =
-                    ( (DFAState)target ).getGatedPredicatesInNFAConfigurations();
+                    ( (DFAState)target ).GetGatedPredicatesInNFAConfigurations();
if ( preds != null )
{
string predsStr = "";
predsStr = "&&{" +
-                        preds.genExpr( grammar.generator,
+                        preds.GenExpr( grammar.generator,
grammar.generator.Templates, null ).ToString()
+ "}?";
label += predsStr;
@@ -471,7 +471,7 @@ namespace Antlr3.Tool
else if ( s is DFAState && ( (DFAState)s ).IsAcceptState )
{
stateLabel = stateLabel +
-                        "=>" + ( (DFAState)s ).getUniquelyPredictedAlt();
+                        "=>" + ( (DFAState)s ).GetUniquelyPredictedAlt();
}
return '"' + stateLabel + '"';
}
diff --git a/Antlr3/Tool/ErrorManager.cs b/Antlr3/Tool/ErrorManager.cs
index 3814954..448f816 100644
--- a/Antlr3/Tool/ErrorManager.cs
+++ b/Antlr3/Tool/ErrorManager.cs
@@ -868,13 +868,13 @@ namespace Antlr3.Tool

public static bool doNotAttemptAnalysis()
{
-            return !getErrorState().errorMsgIDs.and( ERRORS_FORCING_NO_ANALYSIS ).isNil();
+            return !getErrorState().errorMsgIDs.and( ERRORS_FORCING_NO_ANALYSIS ).IsNil;
}

public static bool doNotAttemptCodeGen()
{
return doNotAttemptAnalysis() ||
-                   !getErrorState().errorMsgIDs.and( ERRORS_FORCING_NO_CODEGEN ).isNil();
+                   !getErrorState().errorMsgIDs.and( ERRORS_FORCING_NO_CODEGEN ).IsNil;
}

/** Return first non ErrorManager code location for generating messages */
diff --git a/Antlr3/Tool/FASerializer.cs b/Antlr3/Tool/FASerializer.cs
index f6e937b..d7ab037 100644
--- a/Antlr3/Tool/FASerializer.cs
+++ b/Antlr3/Tool/FASerializer.cs
@@ -140,7 +140,7 @@ namespace Antlr3.Tool
// visit nodes pointed to by each transition;
for ( int i = 0; i < s.NumberOfTransitions; i++ )
{
-                Transition edge = (Transition)s.getTransition( i );
+                Transition edge = (Transition)s.GetTransition( i );
walkFANormalizingStateNumbers( edge.target ); // keep walkin'
// if this transition is a rule reference, the node "following" this state
// will not be found and appear to be not in graph.  Must explicitly jump
@@ -172,7 +172,7 @@ namespace Antlr3.Tool
// depth first walk each transition, printing its edge first
for ( int i = 0; i < s.NumberOfTransitions; i++ )
{
-                Transition edge = (Transition)s.getTransition( i );
+                Transition edge = (Transition)s.GetTransition( i );
StringBuilder buf = new StringBuilder();
buf.Append( stateStr );
if ( edge.IsAction )
@@ -194,11 +194,11 @@ namespace Antlr3.Tool
{
// look for gated predicates; don't add gated to simple sempred edges
SemanticContext preds =
-                            ( (DFAState)edge.target ).getGatedPredicatesInNFAConfigurations();
+                            ( (DFAState)edge.target ).GetGatedPredicatesInNFAConfigurations();
if ( preds != null )
{
predsStr = "&&{" +
-                                preds.genExpr( grammar.generator,
+                                preds.GenExpr( grammar.generator,
grammar.generator.Templates, null ).ToString()
+ "}?";
}
@@ -236,7 +236,7 @@ namespace Antlr3.Tool
{
if ( s is DFAState )
{
-                    stateStr = ":s" + n + "=>" + ( (DFAState)s ).getUniquelyPredictedAlt();
+                    stateStr = ":s" + n + "=>" + ( (DFAState)s ).GetUniquelyPredictedAlt();
}
else
{
diff --git a/Antlr3/Tool/Grammar.cs b/Antlr3/Tool/Grammar.cs
index 953bd27..3ee2142 100644
--- a/Antlr3/Tool/Grammar.cs
+++ b/Antlr3/Tool/Grammar.cs
@@ -1522,7 +1522,7 @@ namespace Antlr3.Tool
int midpoint = numDecisions / 2;
NFAConversionThread t1 =
new NFAConversionThread( this, barrier, 1, midpoint );
-                new System.Threading.Thread( t1.run ).Start();
+                new System.Threading.Thread( t1.Run ).Start();
//new Thread( t1 ).start();
if ( midpoint == ( numDecisions / 2 ) )
{
@@ -1530,7 +1530,7 @@ namespace Antlr3.Tool
}
NFAConversionThread t2 =
new NFAConversionThread( this, barrier, midpoint, numDecisions );
-                new System.Threading.Thread( t2.run ).Start();
+                new System.Threading.Thread( t2.Run ).Start();
//new Thread( t2 ).start();
// wait for these two threads to finish
try
@@ -1579,11 +1579,11 @@ namespace Antlr3.Tool
for ( int alt = 1; alt <= numAlts; alt++ )
{
int walkAlt =
-                    decisionStartState.translateDisplayAltToWalkAlt( alt );
+                    decisionStartState.TranslateDisplayAltToWalkAlt( alt );
NFAState altLeftEdge = getNFAStateForAltOfDecision( decisionStartState, walkAlt );
NFAState altStartState = (NFAState)altLeftEdge.transition[0].target;
//JSystem.@out.println("alt "+alt+" start state = "+altStartState.stateNumber);
-                altLook[alt] = ll1Analyzer.LOOK( altStartState );
+                altLook[alt] = ll1Analyzer.Look( altStartState );
//JSystem.@out.println("alt "+alt+": "+altLook[alt].toString(this));
}

@@ -1598,7 +1598,7 @@ namespace Antlr3.Tool
altLook[i].toString(this)+" with "+
altLook[j].toString(this));
*/
-                    LookaheadSet collision = altLook[i].intersection( altLook[j] );
+                    LookaheadSet collision = altLook[i].Intersection( altLook[j] );
if ( !collision.IsNil )
{
//JSystem.@out.println("collision (non-LL(1)): "+collision.toString(this));
@@ -1610,7 +1610,7 @@ namespace Antlr3.Tool

outer:
bool foundConfoundingPredicate =
-                ll1Analyzer.detectConfoundingPredicates( decisionStartState );
+                ll1Analyzer.DetectConfoundingPredicates( decisionStartState );
if ( decisionIsLL_1 && !foundConfoundingPredicate )
{
// build an LL(1) optimized DFA with edge for each altLook[i]
@@ -1661,7 +1661,7 @@ namespace Antlr3.Tool
for ( int alt = 1; alt < altLook.Length; alt++ )
{
LookaheadSet look = altLook[alt];
-                    if ( !ds.and( look.tokenTypeSet ).isNil() )
+                    if ( !ds.and( look.tokenTypeSet ).IsNil )
{
edgeMap.map( ds, alt );
}
@@ -1709,7 +1709,7 @@ namespace Antlr3.Tool
{
IntervalSet s_i = (IntervalSet)disjointSets.get( i );

-                    if ( t.and( s_i ).isNil() )
+                    if ( t.and( s_i ).IsNil )
{ // nothing in common
continue;
}
@@ -1726,7 +1726,7 @@ namespace Antlr3.Tool
// Compute s_i-t to see what is in current set and not in incoming
IIntSet existingMinusNewElements = s_i.subtract( t );
//JSystem.@out.println(s_i+"-"+t+"="+existingMinusNewElements);
-                    if ( !existingMinusNewElements.isNil() )
+                    if ( !existingMinusNewElements.IsNil )
{
// found a new character class, add to the end (doesn't affect
// outer loop duration due to n computation a priori.
@@ -1735,14 +1735,14 @@ namespace Antlr3.Tool

// anything left to add to the reachableLabels?
remainder = (IntervalSet)t.subtract( s_i );
-                    if ( remainder.isNil() )
+                    if ( remainder.IsNil )
{
break; // nothing left to add to set.  done!
}

t = remainder;
}
-                if ( !remainder.isNil() )
+                if ( !remainder.IsNil )
{
disjointSets.add( remainder );
}
@@ -1805,7 +1805,7 @@ namespace Antlr3.Tool
{
foreach ( DFAState s in lookaheadDFA.UniqueStates.Values )
{
-                    s.reset();
+                    s.Reset();
}
}

@@ -1970,7 +1970,7 @@ namespace Antlr3.Tool
public virtual void synPredUsedInDFA( DFA dfa, SemanticContext semCtx )
{
decisionsWhoseDFAsUsesSynPreds.Add( dfa );
-            semCtx.trackUseOfSyntacticPredicates( this ); // walk ctx looking for preds
+            semCtx.TrackUseOfSyntacticPredicates( this ); // walk ctx looking for preds
}

#if false
@@ -3792,12 +3792,12 @@ namespace Antlr3.Tool

public virtual LookaheadSet FIRST( NFAState s )
{
-            return ll1Analyzer.FIRST( s );
+            return ll1Analyzer.First( s );
}

public virtual LookaheadSet LOOK( NFAState s )
{
-            return ll1Analyzer.LOOK( s );
+            return ll1Analyzer.Look( s );
}

public virtual void setCodeGenerator( CodeGenerator generator )
diff --git a/Antlr3/Tool/GrammarNonDeterminismMessage.cs b/Antlr3/Tool/GrammarNonDeterminismMessage.cs
index 3eff0c5..9d905bc 100644
--- a/Antlr3/Tool/GrammarNonDeterminismMessage.cs
+++ b/Antlr3/Tool/GrammarNonDeterminismMessage.cs
@@ -109,7 +109,7 @@ namespace Antlr3.Tool
if ( DecisionProbe.verbose )
{
int tracePathAlt =
-                            nfaStart.translateDisplayAltToWalkAlt( (int)displayAltI );
+                            nfaStart.TranslateDisplayAltToWalkAlt( (int)displayAltI );
if ( firstAlt == 0 )
{
firstAlt = tracePathAlt;
diff --git a/Antlr3/Tool/Interpreter.cs b/Antlr3/Tool/Interpreter.cs
index ac31a4d..327a959 100644
--- a/Antlr3/Tool/Interpreter.cs
+++ b/Antlr3/Tool/Interpreter.cs
@@ -291,7 +291,7 @@ namespace Antlr3.Tool
}
input.Rewind( m );
int parseAlt =
-                        s.translateDisplayAltToWalkAlt( predictedAlt );
+                        s.TranslateDisplayAltToWalkAlt( predictedAlt );
//if ( s.nfa.grammar.type != Grammar.LEXER )
//{
//    Console.Out.WriteLine( "predicted alt " + predictedAlt + ", parseAlt " + parseAlt );
@@ -300,7 +300,7 @@ namespace Antlr3.Tool
if ( parseAlt > s.nfa.grammar.getNumberOfAltsForDecisionNFA( s ) )
{
// implied branch of loop etc...
-                        alt = s.nfa.grammar.nfa.getState( s.endOfBlockStateNumber );
+                        alt = s.nfa.grammar.nfa.GetState( s.endOfBlockStateNumber );
}
else
{
@@ -373,7 +373,7 @@ namespace Antlr3.Tool
}

// CASE 4: match label on transition
-                else if ( label.matches( t ) )
+                else if ( label.Matches( t ) )
{
if ( actions != null )
{
@@ -458,9 +458,9 @@ namespace Antlr3.Tool
// for each edge of s, look for intersection with current char
for ( int i = 0; i < s.NumberOfTransitions; i++ )
{
-                    Transition t = s.transition( i );
+                    Transition t = s.Transition( i );
// special case: EOT matches any char
-                    if ( t.label.matches( c ) )
+                    if ( t.label.Matches( c ) )
{
// take transition i
s = (DFAState)t.target;
@@ -488,7 +488,7 @@ namespace Antlr3.Tool
// woohoo!  We know which alt to predict
// nothing emanates from a stop state; must terminate anyway
//Console.Out.WriteLine( "DFA stop state " + s.stateNumber + " predicts " + s.getUniquelyPredictedAlt() );
-            return s.getUniquelyPredictedAlt();
+            return s.GetUniquelyPredictedAlt();
}

public virtual void reportScanError( RecognitionException re )
diff --git a/Antlr3/Tool/NFAFactory.cs b/Antlr3/Tool/NFAFactory.cs
index db9b72c..9bf7a1a 100644
--- a/Antlr3/Tool/NFAFactory.cs
+++ b/Antlr3/Tool/NFAFactory.cs
@@ -95,9 +95,9 @@ namespace Antlr3.Tool
public virtual NFAState newState()
{
NFAState n = new NFAState( nfa );
-            int state = nfa.getNewNFAStateNumber();
+            int state = nfa.GetNewNFAStateNumber();
n.stateNumber = state;
-            nfa.addState( n );
+            nfa.AddState( n );
n.enclosingRule = currentRule;
return n;
}
@@ -118,7 +118,7 @@ namespace Antlr3.Tool
// if it's a block element, jump over it and continue
if ( s.endOfBlockStateNumber != State.INVALID_STATE_NUMBER )
{
-                    s = nfa.getState( s.endOfBlockStateNumber );
+                    s = nfa.GetState( s.endOfBlockStateNumber );
continue;
}
Transition t = s.transition[0];
@@ -137,7 +137,7 @@ namespace Antlr3.Tool
if ( epsilonTarget.endOfBlockStateNumber == State.INVALID_STATE_NUMBER &&
epsilonTarget.transition[0] != null )
{
-                        s.setTransition0( epsilonTarget.transition[0] );
+                        s.SetTransition0( epsilonTarget.transition[0] );
//System.Console.Out.WriteLine( "### opt " + s.stateNumber + "->" + epsilonTarget.transition[0].target.stateNumber );
}
}
@@ -174,7 +174,7 @@ namespace Antlr3.Tool
right.associatedASTNode = associatedAST;
Label label = new Label( set );
Transition e = new Transition( label, right );
-            left.addTransition( e );
+            left.AddTransition( e );
StateCluster g = new StateCluster( left, right );
return g;
}
@@ -204,7 +204,7 @@ namespace Antlr3.Tool
NFAState right = newState();
Label label = new Label( IntervalSet.of( a, b ) );
Transition e = new Transition( label, right );
-            left.addTransition( e );
+            left.AddTransition( e );
StateCluster g = new StateCluster( left, right );
return g;
}
@@ -282,7 +282,7 @@ namespace Antlr3.Tool
NFAState right = newState();
//right.Description = "NFAState following ref to " + ruleStart.Description;
Transition e = new RuleClosureTransition( refDef, ruleStart, right );
-            left.addTransition( e );
+            left.AddTransition( e );
StateCluster g = new StateCluster( left, right );
return g;
}
@@ -311,7 +311,7 @@ namespace Antlr3.Tool
NFAState left = newState();
NFAState right = newState();
Transition e = new Transition( new PredicateLabel( pred ), right );
-            left.addTransition( e );
+            left.AddTransition( e );
StateCluster g = new StateCluster( left, right );
return g;
}
@@ -326,7 +326,7 @@ namespace Antlr3.Tool
NFAState left = newState();
NFAState right = newState();
Transition e = new Transition( new ActionLabel( action ), right );
-            left.addTransition( e );
+            left.AddTransition( e );
return new StateCluster( left, right );
}

@@ -374,7 +374,7 @@ namespace Antlr3.Tool
//                              " loop on end of state " + endNFAState.Description +
//                              " to state " + end.stateNumber );
Transition toEnd = new Transition( label, end );
-            endNFAState.addTransition( toEnd );
+            endNFAState.AddTransition( toEnd );
}

/** From A B build A-e->B (that is, build an epsilon arc from right
@@ -747,7 +747,7 @@ namespace Antlr3.Tool
right.associatedASTNode = associatedAST;
Label label = new Label( nfa.grammar.TokenTypes ); // char or tokens
Transition e = new Transition( label, right );
-            left.addTransition( e );
+            left.AddTransition( e );
StateCluster g = new StateCluster( left, right );
return g;
}
@@ -790,12 +790,12 @@ namespace Antlr3.Tool
protected virtual IIntSet getCollapsedBlockAsSet( State blk )
{
State s0 = blk;
-            if ( s0 != null && s0.getTransition( 0 ) != null )
+            if ( s0 != null && s0.GetTransition( 0 ) != null )
{
-                State s1 = s0.getTransition( 0 ).target;
-                if ( s1 != null && s1.getTransition( 0 ) != null )
+                State s1 = s0.GetTransition( 0 ).target;
+                if ( s1 != null && s1.GetTransition( 0 ) != null )
{
-                    Label label = s1.getTransition( 0 ).label;
+                    Label label = s1.GetTransition( 0 ).label;
if ( label.IsSet )
{
return label.Set;
@@ -808,7 +808,7 @@ namespace Antlr3.Tool
private void transitionBetweenStates( NFAState a, NFAState b, int label )
{
Transition e = new Transition( label, b );
-            a.addTransition( e );
+            a.AddTransition( e );
}
}
}

