commit f21955f65ea44bedd02f2a6b282f902d7262477c
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Wed Feb 2 19:57:14 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Wed Feb 2 19:57:14 2011 -0800

(C# 3) Use "shadow" templates to keep track of multiple renderings of a single template.

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 7612]

diff --git a/Antlr4.StringTemplate/Debug/DebugTemplate.cs b/Antlr4.StringTemplate/Debug/DebugTemplate.cs
index 42c7d81..5ebdc8e 100644
--- a/Antlr4.StringTemplate/Debug/DebugTemplate.cs
+++ b/Antlr4.StringTemplate/Debug/DebugTemplate.cs
@@ -42,26 +42,43 @@ namespace Antlr4.StringTemplate.Debug
*/
public class DebugTemplate : Template
{
-        public class State
-        {
-            /** Track all events that occur during rendering. */
-            public List<InterpEvent> interpEvents = new List<InterpEvent>();
-        }
-
/** Record who made us? ConstructionEvent creates Exception to grab stack */
-        public ConstructionEvent newSTEvent = new ConstructionEvent();
+        public ConstructionEvent newSTEvent;

/** Track construction-time Add attribute "events"; used for Template user-level debugging */
-        public MultiMap<string, AddAttributeEvent> addAttrEvents = new MultiMap<string, AddAttributeEvent>();
-
-        //public Interpreter interp; // set when we start interpreter in inspect()
+        public MultiMap<string, AddAttributeEvent> addAttrEvents;

public DebugTemplate()
{
+            newSTEvent = new ConstructionEvent();
+            addAttrEvents = new MultiMap<string, AddAttributeEvent>();
+        }
+
+        public DebugTemplate(Template prototype)
+            : base(prototype)
+        {
+            newSTEvent = new ConstructionEvent();
+            addAttrEvents = new MultiMap<string, AddAttributeEvent>();
+        }
+
+        protected DebugTemplate(DebugTemplate prototype, bool shadowLocals, Template enclosingInstance)
+            : base(prototype, shadowLocals, enclosingInstance)
+        {
+            if (shadowLocals)
+            {
+                newSTEvent = prototype.newSTEvent;
+                addAttrEvents = prototype.addAttrEvents;
+            }
+            else
+            {
+                newSTEvent = new ConstructionEvent();
+                addAttrEvents = new MultiMap<string, AddAttributeEvent>();
+            }
}

-        public DebugTemplate(Template proto) : base(proto)
+        public override Template CreateShadow(Template shadowEnclosingInstance)
{
+            return new DebugTemplate(this, true, shadowEnclosingInstance);
}

public override void Add(string name, object value)
diff --git a/Antlr4.StringTemplate/Interpreter.cs b/Antlr4.StringTemplate/Interpreter.cs
index 7ae04bf..b763cc7 100644
--- a/Antlr4.StringTemplate/Interpreter.cs
+++ b/Antlr4.StringTemplate/Interpreter.cs
@@ -701,33 +701,24 @@ namespace Antlr4.StringTemplate
Template template = o as Template;
if (template != null)
{
-                Template previousEnclosingInstance = template.EnclosingInstance;
-                object[] previousLocals = template.locals;
+                if (template.EnclosingInstance != self)
+                    template = template.CreateShadow(self);

-                try
+                SetDefaultArguments(template);
+                if (options != null && options[(int)Option.Wrap] != null)
{
-                    template.EnclosingInstance = self;
-                    template.locals = SetDefaultArguments(template);
-                    if (options != null && options[(int)Option.Wrap] != null)
+                    // if we have a wrap string, then inform writer it
+                    // might need to wrap
+                    try
{
-                        // if we have a wrap string, then inform writer it
-                        // might need to wrap
-                        try
-                        {
-                            @out.WriteWrap(options[(int)Option.Wrap]);
-                        }
-                        catch (IOException ioe)
-                        {
-                            errMgr.IOError(self, ErrorType.WRITE_IO_ERROR, ioe);
-                        }
+                        @out.WriteWrap(options[(int)Option.Wrap]);
+                    }
+                    catch (IOException ioe)
+                    {
+                        errMgr.IOError(self, ErrorType.WRITE_IO_ERROR, ioe);
}
-                    n = Execute(@out, template);
-                }
-                finally
-                {
-                    template.EnclosingInstance = previousEnclosingInstance;
-                    template.locals = previousLocals;
}
+                n = Execute(@out, template);
}
else
{
@@ -1165,9 +1156,15 @@ namespace Antlr4.StringTemplate
{
if (value.GetType() == typeof(string))
return (string)value;
+
// if Template, make sure it evaluates with enclosing template as self
-                if (value is Template)
-                    ((Template)value).EnclosingInstance = self;
+                Template template = value as Template;
+                if (template != null)
+                {
+                    if (template.EnclosingInstance != self)
+                        value = template = template.CreateShadow(self);
+                }
+
// if not string already, must evaluate it
StringWriter sw = new StringWriter();
/*
@@ -1287,23 +1284,16 @@ namespace Antlr4.StringTemplate
*
*  The evaluation context is the template enclosing invokedST.
*/
-        public virtual object[] SetDefaultArguments(Template invokedST)
+        public virtual void SetDefaultArguments(Template invokedST)
{
if (invokedST.impl.formalArguments == null)
-                return invokedST.locals;
+                return;

-            object[] previousLocals = null;
foreach (FormalArgument arg in invokedST.impl.formalArguments)
{
// if no value for attribute and default arg, inject default arg into self
if (invokedST.locals[arg.Index] == Template.EmptyAttribute && arg.CompiledDefaultValue != null)
{
-                    if (previousLocals == null)
-                    {
-                        previousLocals = invokedST.locals;
-                        invokedST.locals = (object[])invokedST.locals.Clone();
-                    }
-
Template defaultArgST = group.CreateStringTemplate();
defaultArgST.EnclosingInstance = invokedST.EnclosingInstance;
defaultArgST.groupThatCreatedThisInstance = group;
@@ -1325,8 +1315,6 @@ namespace Antlr4.StringTemplate
}
}
}
-
-            return previousLocals ?? invokedST.locals;
}

protected virtual void Trace(Template self, int ip)
diff --git a/Antlr4.StringTemplate/Template.cs b/Antlr4.StringTemplate/Template.cs
index bc6fb2d..ce63559 100644
--- a/Antlr4.StringTemplate/Template.cs
+++ b/Antlr4.StringTemplate/Template.cs
@@ -152,14 +152,17 @@ namespace Antlr4.StringTemplate
}

/** Clone a prototype template for application in MAP operations; copy all fields */
-        public Template(Template proto)
+        public Template(Template prototype)
+            : this(prototype, false, prototype.EnclosingInstance)
{
-            this.impl = proto.impl;
-            if (proto.locals != null)
-                this.locals = (object[])proto.locals.Clone();
+        }

-            this.EnclosingInstance = proto.EnclosingInstance;
-            this.groupThatCreatedThisInstance = proto.groupThatCreatedThisInstance;
+        protected Template(Template prototype, bool shadowLocals, Template enclosingInstance)
+        {
+            this.impl = prototype.impl;
+            this.locals = shadowLocals ? prototype.locals : (object[])prototype.locals.Clone();
+            this.EnclosingInstance = enclosingInstance;
+            this.groupThatCreatedThisInstance = prototype.groupThatCreatedThisInstance;
}

public Template EnclosingInstance
@@ -175,6 +178,11 @@ namespace Antlr4.StringTemplate
}
}

+        public virtual Template CreateShadow(Template shadowEnclosingInstance)
+        {
+            return new Template(this, true, shadowEnclosingInstance);
+        }
+
/** Inject an attribute (name/value pair). If there is already an
*  attribute with that name, this method turns the attribute into an
*  AttributeList with both the previous and the new attribute as elements.
@@ -218,9 +226,6 @@ namespace Antlr4.StringTemplate
}
}

-            if (value is Template)
-                ((Template)value).EnclosingInstance = this;
-
object curvalue = locals[arg.Index];
if (curvalue == EmptyAttribute)
{
@@ -236,14 +241,11 @@ namespace Antlr4.StringTemplate
locals[arg.Index] = multi; // replace with list

// now, Add incoming value to multi-valued attribute
-            if (value is IList)
+            IList list = value as IList;
+            if (list != null)
{
// flatten incoming list into existing list
-                multi.AddRange(((IList)value).Cast<object>());
-            }
-            else if (value != null && value.GetType().IsArray)
-            {
-                multi.AddRange(((Array)value).Cast<object>());
+                multi.AddRange(list.Cast<object>());
}
else
{
@@ -499,7 +501,11 @@ namespace Antlr4.StringTemplate
if (impl == null)
return "bad-template()";

-            return impl.name + "()";
+            string args = string.Empty;
+            if (impl.formalArguments != null)
+                args = string.Join(",", impl.formalArguments.Select(i => i.Name).ToArray());
+
+            return string.Format("{0}({1})", Name, args);
}

// Template.Format("name, phone | <name>:<phone>", n, p);
diff --git a/Antlr4.Test.StringTemplate/TestDebugEvents.cs b/Antlr4.Test.StringTemplate/TestDebugEvents.cs
index d05d810..8a69a18 100644
--- a/Antlr4.Test.StringTemplate/TestDebugEvents.cs
+++ b/Antlr4.Test.StringTemplate/TestDebugEvents.cs
@@ -73,9 +73,9 @@ namespace Antlr4.Test.StringTemplate
DebugTemplate st = (DebugTemplate)group.GetInstanceOf("t");
List<InterpEvent> events = st.GetEvents();
string expected =
-                "[EvalExprEvent{self=t(), output=[0..0), expr=<x>}," +
-                " EvalExprEvent{self=t(), output=[0..1), expr= }," +
-                " EvalTemplateEvent{self=t(), output=[0..1)}]";
+                "[EvalExprEvent{self=t(x), output=[0..0), expr=<x>}," +
+                " EvalExprEvent{self=t(x), output=[0..1), expr= }," +
+                " EvalTemplateEvent{self=t(x), output=[0..1)}]";
string result = events.ToListString();
Assert.AreEqual(expected, result);
}
@@ -93,13 +93,13 @@ namespace Antlr4.Test.StringTemplate
DebugTemplate st = (DebugTemplate)group.GetInstanceOf("t");
List<InterpEvent> events = st.GetEvents();
string expected =
-                "[EvalExprEvent{self=t(), output=[0..1), expr=[}," +
+                "[EvalExprEvent{self=t(x), output=[0..1), expr=[}," +
" EvalExprEvent{self=u(), output=[1..1), expr=<x>}," +
" EvalExprEvent{self=u(), output=[1..2), expr= }," +
" EvalTemplateEvent{self=u(), output=[1..2)}," +
-                " EvalExprEvent{self=t(), output=[1..2), expr=<u()>}," +
-                " EvalExprEvent{self=t(), output=[2..3), expr=]}," +
-                " EvalTemplateEvent{self=t(), output=[0..3)}]";
+                " EvalExprEvent{self=t(x), output=[1..2), expr=<u()>}," +
+                " EvalExprEvent{self=t(x), output=[2..3), expr=]}," +
+                " EvalTemplateEvent{self=t(x), output=[0..3)}]";
string result = events.ToListString();
Assert.AreEqual(expected, result);
}

