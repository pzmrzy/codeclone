commit 160973ab642571612e133535392513c9e345c3e3
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Wed Jun 29 19:34:20 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Wed Jun 29 19:34:20 2011 -0800

(C# 3) IntervalSet performance updates

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 8805]

diff --git a/Antlr3.Test/TestIntervalSet.cs b/Antlr3.Test/TestIntervalSet.cs
index df174ce..0795590 100644
--- a/Antlr3.Test/TestIntervalSet.cs
+++ b/Antlr3.Test/TestIntervalSet.cs
@@ -38,6 +38,7 @@ namespace AntlrUnitTests
using Microsoft.VisualStudio.TestTools.UnitTesting;

using IList = System.Collections.IList;
+    using Interval = Antlr3.Misc.Interval;
using IntervalSet = Antlr3.Misc.IntervalSet;
using Label = Antlr3.Analysis.Label;

@@ -113,6 +114,7 @@ namespace AntlrUnitTests
Assert.AreEqual( result, expecting );
}

+#if false
[TestMethod]
public void TestNotSingleElement() /*throws Exception*/ {
IntervalSet vocabulary = IntervalSet.Of( 1, 1000 );
@@ -165,6 +167,7 @@ namespace AntlrUnitTests
string result = ( s.Complement( vocabulary ) ).ToString();
Assert.AreEqual( result, expecting );
}
+#endif

[TestMethod]
public void TestSubtractOfCompletelyContainedRange() /*throws Exception*/ {
@@ -325,7 +328,7 @@ namespace AntlrUnitTests
public void TestComplement() /*throws Exception*/ {
IntervalSet s = IntervalSet.Of( 100, 100 );
s.Add( 101, 101 );
-            IntervalSet s2 = IntervalSet.Of( 100, 102 );
+            Interval s2 = Interval.FromBounds( 100, 102 );
string expecting = "102";
string result = ( s.Complement( s2 ) ).ToString();
Assert.AreEqual( result, expecting );
@@ -334,7 +337,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestComplement2() /*throws Exception*/ {
IntervalSet s = IntervalSet.Of( 100, 101 );
-            IntervalSet s2 = IntervalSet.Of( 100, 102 );
+            Interval s2 = Interval.FromBounds( 100, 102 );
string expecting = "102";
string result = ( s.Complement( s2 ) ).ToString();
Assert.AreEqual( result, expecting );
diff --git a/Antlr3/Codegen/CodeGenerator.cs b/Antlr3/Codegen/CodeGenerator.cs
index ad38e8d..1d18478 100644
--- a/Antlr3/Codegen/CodeGenerator.cs
+++ b/Antlr3/Codegen/CodeGenerator.cs
@@ -1196,7 +1196,7 @@ namespace Antlr3.Codegen
}
StringTemplate setST = templates.GetInstanceOf( "setTest" );
int rangeNumber = 1;
-            foreach ( Interval I in iset.GetIntervals() )
+            foreach ( Interval I in iset.Intervals )
{
int a = I.a;
int b = I.b;
diff --git a/Antlr3/Grammars/TreeToNFAConverter.g3 b/Antlr3/Grammars/TreeToNFAConverter.g3
index fe1d4b2..63cd575 100644
--- a/Antlr3/Grammars/TreeToNFAConverter.g3
+++ b/Antlr3/Grammars/TreeToNFAConverter.g3
@@ -361,6 +361,6 @@ testSetElement returns [int alts=1]
|   testBlockAsSet
{{ $alts = $testBlockAsSet.alts; }}
|   ^( NOT tse=testSetElement )
-		{{ $alts = grammar.TokenTypes.Count - $tse.alts; }}
+		{{ $alts = grammar.TokenTypes.Length - $tse.alts; }}
;
catch[RecognitionException re] { re.PreserveStackTrace(); throw; }
diff --git a/Antlr3/Misc/BitSet.cs b/Antlr3/Misc/BitSet.cs
index 79ecd67..03c90e1 100644
--- a/Antlr3/Misc/BitSet.cs
+++ b/Antlr3/Misc/BitSet.cs
@@ -177,7 +177,7 @@ namespace Antlr3.Misc
{
IntervalSet other = (IntervalSet)set;
// walk set and add each interval
-                foreach ( Interval I in other.intervals )
+                foreach ( Interval I in other.Intervals )
{
this.OrInPlace( BitSet.Range( I.a, I.b ) );
}
@@ -361,13 +361,9 @@ namespace Antlr3.Misc
return s;
}

-        public virtual IIntSet Complement( IIntSet set )
+        public virtual IIntSet Complement( Interval vocabulary )
{
-            if ( set == null )
-            {
-                return this.Complement();
-            }
-            return set.Subtract( this );
+            return BitSet.Of(vocabulary).Subtract(this);
}

public virtual void NotInPlace()
@@ -408,6 +404,13 @@ namespace Antlr3.Misc
return s;
}

+        public static BitSet Of(Interval interval)
+        {
+            BitSet s = new BitSet(interval.b + 1);
+            s.AddAll(Enumerable.Range(interval.a, interval.b - interval.a + 1));
+            return s;
+        }
+
public static BitSet Of<T>( T elements )
where T : IEnumerable<int>
{
diff --git a/Antlr3/Misc/IIntSet.cs b/Antlr3/Misc/IIntSet.cs
index 288ef64..e621e34 100644
--- a/Antlr3/Misc/IIntSet.cs
+++ b/Antlr3/Misc/IIntSet.cs
@@ -57,7 +57,7 @@ namespace Antlr3.Misc
*/
IIntSet And( IIntSet a );

-        IIntSet Complement( IIntSet elements );
+        IIntSet Complement( Interval vocabulary );

IIntSet Or( IIntSet a );

diff --git a/Antlr3/Misc/Interval.cs b/Antlr3/Misc/Interval.cs
index 979a033..530ec8e 100644
--- a/Antlr3/Misc/Interval.cs
+++ b/Antlr3/Misc/Interval.cs
@@ -33,121 +33,111 @@
namespace Antlr3.Misc
{
using Math = System.Math;
+    using ArgumentException = System.ArgumentException;

/** An immutable inclusive interval a..b */
-    public class Interval
+    public struct Interval
{
-        public const int INTERVAL_POOL_MAX_VALUE = 1000;
+        public readonly int a;
+        public readonly int b;

-        static Interval[] cache = new Interval[INTERVAL_POOL_MAX_VALUE + 1];
-
-        public int a;
-        public int b;
-
-        public static int creates = 0;
-        public static int misses = 0;
-        public static int hits = 0;
-        public static int outOfRange = 0;
-
-        public Interval( int a, int b )
+        private Interval( int a, int b )
{
+            if (a > b)
+                throw new ArgumentException();
+
this.a = a;
this.b = b;
}

-        /** Interval objects are used readonly so share all with the
-         *  same single value a==b up to some max size.  Use an array as a perfect hash.
-         *  Return shared object for 0..INTERVAL_POOL_MAX_VALUE or a new
-         *  Interval object with a..a in it.  On Java.g, 218623 IntervalSets
-         *  have a..a (set with 1 element).
-         */
-        public static Interval Create( int a, int b )
+        public int Length
{
-            //return new Interval(a,b);
-            // cache just a..a
-            if ( a != b || a < 0 || a > INTERVAL_POOL_MAX_VALUE )
+            get
{
-                return new Interval( a, b );
+                return b - a + 1;
}
-            if ( cache[a] == null )
-            {
-                cache[a] = new Interval( a, a );
-            }
-            return cache[a];
+        }
+
+        public static Interval FromBounds( int start, int endInclusive )
+        {
+            return new Interval( start, endInclusive );
}

public override int GetHashCode()
{
-            throw new System.NotImplementedException();
+            return a + b;
+        }
+
+        public bool Equals(Interval other)
+        {
+            return this.a == other.a && this.b == other.b;
}

public override bool Equals( object o )
{
-            if ( o == null )
-            {
+            if (!(o is Interval))
return false;
-            }
-            Interval other = (Interval)o;
-            return this.a == other.a && this.b == other.b;
+
+            return this.Equals((Interval)o);
}

/** Does this start completely before other? Disjoint */
-        public virtual bool StartsBeforeDisjoint( Interval other )
+        public bool StartsBeforeDisjoint( Interval other )
{
return this.a < other.a && this.b < other.a;
}

/** Does this start at or before other? Nondisjoint */
-        public virtual bool StartsBeforeNonDisjoint( Interval other )
+        public bool StartsBeforeNonDisjoint( Interval other )
{
return this.a <= other.a && this.b >= other.a;
}

/** Does this.a start after other.b? May or may not be disjoint */
-        public virtual bool StartsAfter( Interval other )
+        public bool StartsAfter( Interval other )
{
return this.a > other.a;
}

/** Does this start completely after other? Disjoint */
-        public virtual bool StartsAfterDisjoint( Interval other )
+        public bool StartsAfterDisjoint( Interval other )
{
return this.a > other.b;
}

/** Does this start after other? NonDisjoint */
-        public virtual bool StartsAfterNonDisjoint( Interval other )
+        public bool StartsAfterNonDisjoint( Interval other )
{
return this.a > other.a && this.a <= other.b; // this.b>=other.b implied
}

/** Are both ranges disjoint? I.e., no overlap? */
-        public virtual bool Disjoint( Interval other )
+        public bool Disjoint( Interval other )
{
return StartsBeforeDisjoint( other ) || StartsAfterDisjoint( other );
}

/** Are two intervals adjacent such as 0..41 and 42..42? */
-        public virtual bool Adjacent( Interval other )
+        public bool Adjacent( Interval other )
{
return this.a == other.b + 1 || this.b == other.a - 1;
}

-        public virtual bool ProperlyContains( Interval other )
+        public bool ProperlyContains( Interval other )
{
return other.a >= this.a && other.b <= this.b;
}

/** Return the interval computed from combining this and other */
-        public virtual Interval Union( Interval other )
+        public Interval Union( Interval other )
{
-            return Interval.Create( Math.Min( a, other.a ), Math.Max( b, other.b ) );
+            return Interval.FromBounds( Math.Min( a, other.a ), Math.Max( b, other.b ) );
}

/** Return the interval in common between this and o */
-        public virtual Interval Intersection( Interval other )
+        public Interval Intersection( Interval other )
{
-            return Interval.Create( Math.Max( a, other.a ), Math.Min( b, other.b ) );
+            return Interval.FromBounds( Math.Max( a, other.a ), Math.Min( b, other.b ) );
}

/** Return the interval with elements from this not in other;
@@ -155,21 +145,22 @@ namespace Antlr3.Misc
*  within this, which would result in two disjoint intervals
*  instead of the single one returned by this method.
*/
-        public virtual Interval DifferenceNotProperlyContained( Interval other )
+        public Interval? DifferenceNotProperlyContained( Interval other )
{
-            Interval diff = null;
+            Interval? diff = null;
+
// other.a to left of this.a (or same)
if ( other.StartsBeforeNonDisjoint( this ) )
{
-                diff = Interval.Create( Math.Max( this.a, other.b + 1 ),
+                diff = Interval.FromBounds( Math.Max( this.a, other.b + 1 ),
this.b );
}
-
// other.a to right of this.a
else if ( other.StartsAfterNonDisjoint( this ) )
{
-                diff = Interval.Create( this.a, other.a - 1 );
+                diff = Interval.FromBounds( this.a, other.a - 1 );
}
+
return diff;
}

diff --git a/Antlr3/Misc/IntervalSet.cs b/Antlr3/Misc/IntervalSet.cs
index 5dcbc8d..16e7348 100644
--- a/Antlr3/Misc/IntervalSet.cs
+++ b/Antlr3/Misc/IntervalSet.cs
@@ -36,11 +36,10 @@ namespace Antlr3.Misc
using System.Linq;

using ArgumentException = System.ArgumentException;
-    using CLSCompliant = System.CLSCompliantAttribute;
using Grammar = Antlr3.Tool.Grammar;
using Label = Antlr3.Analysis.Label;
+    using Math = System.Math;
using NotImplementedException = System.NotImplementedException;
-    using Obsolete = System.ObsoleteAttribute;
using StringBuilder = System.Text.StringBuilder;

/** A set of integers that relies on ranges being common to do
@@ -59,11 +58,11 @@ namespace Antlr3.Misc
*/
public class IntervalSet : IIntSet
{
-        public static readonly IntervalSet COMPLETE_SET = IntervalSet.Of( 0, Label.MAX_CHAR_VALUE );
+        public static readonly Interval CompleteInterval = Interval.FromBounds(0, Label.MAX_CHAR_VALUE);
+        public static readonly IntervalSet COMPLETE_SET = IntervalSet.Of(CompleteInterval);

/** The list of sorted, disjoint intervals. */
-        //protected List<Interval> intervals;
-        protected internal IList<Interval> intervals;
+        private IList<Interval> intervals;

/** Create a set with no elements */
public IntervalSet()
@@ -85,14 +84,15 @@ namespace Antlr3.Misc
return intervals.Sum( interval => interval.b - interval.a + 1 );
}
}
-        [CLSCompliant(false)]
+
public ICollection<Interval> Intervals
{
get
{
-                return GetIntervals();
+                return intervals;
}
}
+
public int MaxElement
{
get
@@ -119,16 +119,18 @@ namespace Antlr3.Misc
/** Create a set with a single element, el. */
public static IntervalSet Of( int a )
{
-            IntervalSet s = new IntervalSet();
-            s.Add( a );
-            return s;
+            return Of(Interval.FromBounds(a, a));
}

/** Create a set with all ints within range [a..b] (inclusive) */
public static IntervalSet Of( int a, int b )
{
-            IntervalSet s = new IntervalSet();
-            s.Add( a, b );
+            return Of(Interval.FromBounds(a, b));
+        }
+
+        public static IntervalSet Of(Interval interval)
+        {
+            IntervalSet s = new IntervalSet(new List<Interval> { interval });
return s;
}

@@ -149,7 +151,7 @@ namespace Antlr3.Misc
*/
public virtual void Add( int a, int b )
{
-            Add( Interval.Create( a, b ) );
+            Add( Interval.FromBounds( a, b ) );
}

// copy on write so we can cache a..a intervals and sets of that
@@ -288,7 +290,7 @@ namespace Antlr3.Misc

public virtual IIntSet Complement( int minElement, int maxElement )
{
-            return this.Complement( IntervalSet.Of( minElement, maxElement ) );
+            return this.Complement( Interval.FromBounds( minElement, maxElement ) );
}

/** Given the set of possible values (rather than, say UNICODE or MAXINT),
@@ -297,50 +299,60 @@ namespace Antlr3.Misc
*
*  'this' is assumed to be either a subset or equal to vocabulary.
*/
-        public virtual IIntSet Complement( IIntSet vocabulary )
+        public virtual IIntSet Complement( Interval vocabulary )
{
-            if ( vocabulary == null )
-            {
-                return null; // nothing in common with null set
-            }
-            if ( !( vocabulary is IntervalSet ) )
+            if (vocabulary.b < MinElement || vocabulary.a > MaxElement)
{
-                throw new ArgumentException( "can't complement with non IntervalSet (" +
-                                                   vocabulary.GetType().Name + ")" );
+                // nothing in common with this set
+                return null;
}
-            IntervalSet vocabularyIS = ( (IntervalSet)vocabulary );
-            int maxElement = vocabularyIS.GetMaxElement();

-            IntervalSet compl = new IntervalSet();
int n = intervals.Count;
if ( n == 0 )
{
-                return compl;
+                return IntervalSet.Of(vocabulary);
}
-            Interval first = (Interval)intervals[0];
+
+            IntervalSet compl = new IntervalSet();
+
+            Interval first = intervals[0];
// add a range from 0 to first.a constrained to vocab
-            if ( first.a > 0 )
+            if ( first.a > vocabulary.a )
{
-                IntervalSet s = IntervalSet.Of( 0, first.a - 1 );
-                IntervalSet a = (IntervalSet)s.And( vocabularyIS );
-                compl.AddAll( a );
+                compl.Intervals.Add(Interval.FromBounds(vocabulary.a, first.a - 1));
}
+
for ( int i = 1; i < n; i++ )
-            { // from 2nd interval .. nth
-                Interval previous = (Interval)intervals[i - 1];
-                Interval current = (Interval)intervals[i];
-                IntervalSet s = IntervalSet.Of( previous.b + 1, current.a - 1 );
-                IntervalSet a = (IntervalSet)s.And( vocabularyIS );
-                compl.AddAll( a );
-            }
-            Interval last = (Interval)intervals[n - 1];
+            {
+                if (intervals[i - 1].b >= vocabulary.b)
+                    break;
+
+                if (intervals[i].a <= vocabulary.a)
+                    continue;
+
+                if (intervals[i - 1].b == intervals[i].a - 1)
+                    continue;
+
+                compl.Intervals.Add(Interval.FromBounds(Math.Max(vocabulary.a, intervals[i - 1].b + 1), Math.Min(vocabulary.b, intervals[i].a - 1)));
+
+                //// from 2nd interval .. nth
+                //Interval previous = intervals[i - 1];
+                //Interval current = intervals[i];
+                //IntervalSet s = IntervalSet.Of( previous.b + 1, current.a - 1 );
+                //IntervalSet a = (IntervalSet)s.And( vocabularyIS );
+                //compl.AddAll( a );
+            }
+
+            Interval last = intervals[n - 1];
// add a range from last.b to maxElement constrained to vocab
-            if ( last.b < maxElement )
+            if ( last.b < vocabulary.b )
{
-                IntervalSet s = IntervalSet.Of( last.b + 1, maxElement );
-                IntervalSet a = (IntervalSet)s.And( vocabularyIS );
-                compl.AddAll( a );
+                compl.Intervals.Add(Interval.FromBounds(last.b + 1, vocabulary.b));
+                //IntervalSet s = IntervalSet.Of( last.b + 1, maxElement );
+                //IntervalSet a = (IntervalSet)s.And( vocabularyIS );
+                //compl.AddAll( a );
}
+
return compl;
}

@@ -357,7 +369,7 @@ namespace Antlr3.Misc
// will be empty.  The only problem would be when this' set max value
// goes beyond MAX_CHAR_VALUE, but hopefully the constant MAX_CHAR_VALUE
// will prevent this.
-            return this.And( ( (IntervalSet)other ).Complement( COMPLETE_SET ) );
+            return this.And( ( (IntervalSet)other ).Complement( CompleteInterval ) );
}

#if false
@@ -526,7 +538,7 @@ namespace Antlr3.Misc

var myIntervals = this.intervals;
var theirIntervals = ( (IntervalSet)other ).intervals;
-            IntervalSet intersection = null;
+            IntervalSet intersection = new IntervalSet();
int mySize = myIntervals.Count;
int theirSize = theirIntervals.Count;
int i = 0;
@@ -534,8 +546,8 @@ namespace Antlr3.Misc
// iterate down both interval lists looking for nondisjoint intervals
while ( i < mySize && j < theirSize )
{
-                Interval mine = (Interval)myIntervals[i];
-                Interval theirs = (Interval)theirIntervals[j];
+                Interval mine = myIntervals[i];
+                Interval theirs = theirIntervals[j];
//JSystem.@out.println("mine="+mine+" and theirs="+theirs);
if ( mine.StartsBeforeDisjoint( theirs ) )
{
@@ -550,30 +562,18 @@ namespace Antlr3.Misc
else if ( mine.ProperlyContains( theirs ) )
{
// overlap, add intersection, get next theirs
-                    if ( intersection == null )
-                    {
-                        intersection = new IntervalSet();
-                    }
-                    intersection.Add( mine.Intersection( theirs ) );
+                    intersection.Intervals.Add( theirs );
j++;
}
else if ( theirs.ProperlyContains( mine ) )
{
// overlap, add intersection, get next mine
-                    if ( intersection == null )
-                    {
-                        intersection = new IntervalSet();
-                    }
-                    intersection.Add( mine.Intersection( theirs ) );
+                    intersection.Intervals.Add( mine );
i++;
}
else if ( !mine.Disjoint( theirs ) )
{
// overlap, add intersection
-                    if ( intersection == null )
-                    {
-                        intersection = new IntervalSet();
-                    }
intersection.Add( mine.Intersection( theirs ) );
// Move the iterator of lower range [a..b], but not
// the upper range as it may contain elements that will collide
@@ -592,10 +592,7 @@ namespace Antlr3.Misc
}
}
}
-            if ( intersection == null )
-            {
-                return new IntervalSet();
-            }
+
return intersection;
}

@@ -687,12 +684,6 @@ namespace Antlr3.Misc
return Label.INVALID;
}

-        /** Return a list of Interval objects. */
-        public virtual IList<Interval> GetIntervals()
-        {
-            return intervals;
-        }
-
/** Are two IntervalSets equal?  Because all intervals are sorted
*  and disjoint, equals is a simple linear walk over both lists
*  to make sure they are the same.  Interval.equals() is used
diff --git a/Antlr3/Tool/Grammar.cs b/Antlr3/Tool/Grammar.cs
index dec0b45..3c362d6 100644
--- a/Antlr3/Tool/Grammar.cs
+++ b/Antlr3/Tool/Grammar.cs
@@ -353,14 +353,14 @@ namespace Antlr3.Tool
public string label;

/** TODO: hook this to the charVocabulary option */
-        protected IIntSet charVocabulary = null;
+        protected Interval? charVocabulary = null;

/** For ANTLRWorks, we want to be able to map a line:col to a specific
*  decision DFA so it can display DFA.
*/
Dictionary<string, DFA> lineColumnToLookaheadDFAMap = new Dictionary<string, DFA>();

-        public Tool tool;
+        private Tool _tool;

/** The unique set of all rule references in any rule; set of tree node
*  objects so two refs to same rule can exist but at different line/position.
@@ -646,16 +646,16 @@ namespace Antlr3.Tool
/** If there is a char vocabulary, use it; else return min to max char
*  as defined by the target.  If no target, use max unicode char value.
*/
-        public IIntSet AllCharValues
+        public Interval AllCharValues
{
get
{
if ( charVocabulary != null )
{
-                    return charVocabulary;
+                    return charVocabulary.Value;
}
-                IIntSet allChar = IntervalSet.Of( Label.MIN_CHAR_VALUE, MaxCharValue );
-                return allChar;
+
+                return Interval.FromBounds(Label.MIN_CHAR_VALUE, MaxCharValue);
}
}
public bool AllDecisionDFAHaveBeenCreated
@@ -927,7 +927,7 @@ namespace Antlr3.Tool
}
}
/** Return a set of all possible token or char types for this grammar */
-        public IIntSet TokenTypes
+        public Interval TokenTypes
{
get
{
@@ -935,21 +935,24 @@ namespace Antlr3.Tool
{
return AllCharValues;
}
-                return IntervalSet.Of( Label.MIN_TOKEN_TYPE, MaxTokenType );
+
+                return Interval.FromBounds(Label.MIN_TOKEN_TYPE, MaxTokenType);
}
}
-        [CLSCompliant(false)]
+
public AntlrTool Tool
{
get
{
-                return tool;
+                return _tool;
}
+
set
{
-                tool = value;
+                _tool = value;
}
}
+
public GrammarAST Tree
{
get
@@ -957,6 +960,7 @@ namespace Antlr3.Tool
return grammarTree;
}
}
+
#endregion

public virtual void SetName( string name )
@@ -1809,7 +1813,7 @@ namespace Antlr3.Tool
// Compute s_i-t to see what is in current set and not in incoming
IIntSet existingMinusNewElements = s_i.Subtract( t );
//JSystem.@out.println(s_i+"-"+t+"="+existingMinusNewElements);
-                    if ( !existingMinusNewElements.IsNil )
+                    if ( existingMinusNewElements != null && !existingMinusNewElements.IsNil )
{
// found a new character class, add to the end (doesn't affect
// outer loop duration due to n computation a priori.
@@ -2876,18 +2880,18 @@ namespace Antlr3.Tool
TextReader br = null;
try
{
-                string fullName = tool.GetLibraryFile( gname );
+                string fullName = Tool.GetLibraryFile( gname );
if (!File.Exists(fullName))
{
gname = grammarName + AltGrammarFileExtension;
-                    fullName = tool.GetLibraryFile(gname);
+                    fullName = Tool.GetLibraryFile(gname);
}

//FileReader fr = new FileReader( fullName );
//br = new BufferedReader( fr );
br = new StringReader( System.IO.File.ReadAllText( fullName ) );
Grammar delegateGrammar = null;
-                delegateGrammar = new Grammar( tool, gname, composite );
+                delegateGrammar = new Grammar( Tool, gname, composite );
delegateGrammar.label = label;

AddDelegateGrammar( delegateGrammar );
@@ -2976,7 +2980,7 @@ namespace Antlr3.Tool
}

Regex vocabLine = new Regex( @"^(?<tokenID>'(?:\\'|.)+'|\w+)\s*=\s*(?<tokenType>\d+)$", RegexOptions.Compiled );
-            string fileName = Path.GetFullPath( tool.GetImportedVocabFile( vocabName ) );
+            string fileName = Path.GetFullPath( Tool.GetImportedVocabFile( vocabName ) );
if ( File.Exists( fileName ) )
{
try
diff --git a/Antlr3/Tool/GrammarReport.cs b/Antlr3/Tool/GrammarReport.cs
index 8c33544..ade7bc9 100644
--- a/Antlr3/Tool/GrammarReport.cs
+++ b/Antlr3/Tool/GrammarReport.cs
@@ -214,7 +214,7 @@ namespace Antlr3.Tool
//
//		data. = Stats.sum(cyclicDFAStates);

-            data.numTokens = g.TokenTypes.Count;
+            data.numTokens = g.TokenTypes.Length;

data.DFACreationWallClockTimeInMS = g.DFACreationWallClockTimeInMS;

diff --git a/Antlr3/Tool/LeftRecursiveRuleAnalyzer.cs b/Antlr3/Tool/LeftRecursiveRuleAnalyzer.cs
index daeb055..97b10dd 100644
--- a/Antlr3/Tool/LeftRecursiveRuleAnalyzer.cs
+++ b/Antlr3/Tool/LeftRecursiveRuleAnalyzer.cs
@@ -78,7 +78,7 @@ namespace Antlr3.Tool
this.g = g;
this.ruleName = ruleName;
language = (string)g.GetOption("language");
-            generator = new CodeGenerator(g.tool, g, language);
+            generator = new CodeGenerator(g.Tool, g, language);
generator.LoadTemplates(language);
recRuleTemplates = LoadPrecRuleTemplates(g.Tool);
}
diff --git a/Antlr3/Tool/NFAFactory.cs b/Antlr3/Tool/NFAFactory.cs
index cf79b31..4c82385 100644
--- a/Antlr3/Tool/NFAFactory.cs
+++ b/Antlr3/Tool/NFAFactory.cs
@@ -728,7 +728,7 @@ namespace Antlr3.Tool
NFAState right = NewState();
left.associatedASTNode = associatedAST;
right.associatedASTNode = associatedAST;
-            Label label = new Label( _nfa.Grammar.TokenTypes ); // char or tokens
+            Label label = new Label(IntervalSet.Of( _nfa.Grammar.TokenTypes )); // char or tokens
Transition e = new Transition( label, right );
left.AddTransition( e );
StateCluster g = new StateCluster( left, right );

