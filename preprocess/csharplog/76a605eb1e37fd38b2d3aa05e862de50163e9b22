commit 76a605eb1e37fd38b2d3aa05e862de50163e9b22
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Tue Jun 21 14:45:46 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Tue Jun 21 14:45:46 2011 -0800

(C# 3) Move 850 lines of inline action code from the CodeGenerator grammar to its helper file (major grammar cleanup).

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 8707]

diff --git a/Antlr3/Grammars/CodeGenTreeWalker.g3 b/Antlr3/Grammars/CodeGenTreeWalker.g3
index 7d26e2b..4b441e0 100644
--- a/Antlr3/Grammars/CodeGenTreeWalker.g3
+++ b/Antlr3/Grammars/CodeGenTreeWalker.g3
@@ -31,7 +31,7 @@
*/

/** Walk a grammar and generate code by gradually building up
- *  a bigger and bigger StringTemplate.
+ *  a bigger and bigger Template.
*
*  Terence Parr
*  University of San Francisco
@@ -55,7 +55,7 @@ using Antlr3.Extensions;

using BitSet = Antlr.Runtime.BitSet;
using DFA = Antlr.Runtime.DFA;
-using StringTemplate = Antlr4.StringTemplate.Template;
+using Template = Antlr4.StringTemplate.Template;
using TemplateGroup = Antlr4.StringTemplate.TemplateGroup;
using TokenWithIndex = Antlr.Runtime.CommonToken;
}
@@ -64,45 +64,12 @@ using TokenWithIndex = Antlr.Runtime.CommonToken;

public
grammar_[Grammar g,
-		StringTemplate recognizerST,
-		StringTemplate outputFileST,
-		StringTemplate headerFileST]
+		 Template recognizerST,
+		 Template outputFileST,
+		 Template headerFileST]
@init
{
-	if ( state.backtracking == 0 )
-	{
-		Init(g);
-		this.recognizerST = recognizerST;
-		this.outputFileST = outputFileST;
-		this.headerFileST = headerFileST;
-		string superClass = (string)g.GetOption("superClass");
-		outputOption = (string)g.GetOption("output");
-		if (superClass != null)
-			recognizerST.SetAttribute("superClass", superClass);
-
-		if ( g.type!=GrammarType.Lexer ) {
-			object labelType = g.GetOption("ASTLabelType");
-			if (labelType != null)
-				recognizerST.SetAttribute("ASTLabelType", labelType);
-		}
-
-		if ( g.type==GrammarType.TreeParser && g.GetOption("ASTLabelType")==null ) {
-			ErrorManager.GrammarWarning(ErrorManager.MSG_MISSING_AST_TYPE_IN_TREE_GRAMMAR,
-									   g,
-									   null,
-									   g.name);
-		}
-
-		if ( g.type!=GrammarType.TreeParser ) {
-			object labelType = g.GetOption("TokenLabelType");
-			if (labelType != null)
-				recognizerST.SetAttribute("labelType", labelType);
-		}
-
-		$recognizerST.SetAttribute("numRules", grammar.Rules.Count);
-		$outputFileST.SetAttribute("numRules", grammar.Rules.Count);
-		$headerFileST.SetAttribute("numRules", grammar.Rules.Count);
-	}
+	HandleGrammarInit($g, $recognizerST, $outputFileST, $headerFileST);
}
:	(	^( LEXER_GRAMMAR grammarSpec )
|	^( PARSER_GRAMMAR grammarSpec )
@@ -116,20 +83,10 @@ attrScope
;

grammarSpec
-	:   name=ID
-		(	cmt=DOC_COMMENT
-			{
-				outputFileST.SetAttribute("docComment", $cmt.text);
-				headerFileST.SetAttribute("docComment", $cmt.text);
-			}
+	:   ID
+		(	comment=DOC_COMMENT
)?
-		{
-			recognizerST.SetAttribute("name", grammar.GetRecognizerName());
-			outputFileST.SetAttribute("name", grammar.GetRecognizerName());
-			headerFileST.SetAttribute("name", grammar.GetRecognizerName());
-			recognizerST.SetAttribute("scopes", grammar.GlobalScopes);
-			headerFileST.SetAttribute("scopes", grammar.GlobalScopes);
-		}
+								{HandleGrammarSpecAfterName($comment);}
( ^(OPTIONS .*) )?
( ^(IMPORT .*) )?
( ^(TOKENS .*) )?
@@ -138,53 +95,34 @@ grammarSpec
rules[recognizerST]
;

-rules[StringTemplate recognizerST]
+rules[Template recognizerST]
@init
{
-	string ruleName = ((GrammarAST)input.LT(1)).GetChild(0).Text;
-	bool generated = grammar.GenerateMethodForRule(ruleName);
+string ruleName;
+bool generated;
+HandleRulesInit($start, out ruleName, out generated);
}
:	(	(	options {k=1;} :
{generated}? =>
-				rST=rule
-				{
-					if ( $rST.code != null )
-					{
-						recognizerST.SetAttribute("rules", $rST.code);
-						outputFileST.SetAttribute("rules", $rST.code);
-						headerFileST.SetAttribute("rules", $rST.code);
-					}
-				}
+				rST=rule						{HandleRulesRule($rST.code);}
|	^(RULE .*)
|	^(PREC_RULE .*) // ignore
)
-			{{
-				if ( input.LA(1) == RULE )
-				{
-					ruleName = ((GrammarAST)input.LT(1)).GetChild(0).Text;
-					//System.Diagnostics.Debug.Assert( ruleName == ((GrammarAST)input.LT(1)).enclosingRuleName );
-					generated = grammar.GenerateMethodForRule(ruleName);
-				}
-			}}
+												{{HandleRulesForcedAfterRule(ref ruleName, ref generated);}}
)+
;

-rule returns [StringTemplate code=null]
+rule returns [Template code=null]
@init
{
-	string initAction = null;
-	// get the dfa for the BLOCK
-	GrammarAST block2=(GrammarAST)$start.GetFirstChildWithType(BLOCK);
-	Antlr3.Analysis.DFA dfa=block2.LookaheadDFA;
-	// init blockNestingLevel so it's block level RULE_BLOCK_NESTING_LEVEL
-	// for alts of rule
-	blockNestingLevel = RULE_BLOCK_NESTING_LEVEL-1;
-	Rule ruleDescr = grammar.GetRule($start.GetChild(0).Text);
-	currentRuleName = $start.GetChild(0).Text;
-	string description = string.Empty;
+string initAction;
+GrammarAST block2;
+Antlr3.Analysis.DFA dfa;
+Rule ruleDescr;
+string description;
+HandleRuleInit($start, out initAction, out block2, out dfa, out ruleDescr, out description);
}
-	:	^(	RULE id=ID
-			{ System.Diagnostics.Debug.Assert( currentRuleName == $id.text ); }
+	:	^(	RULE id=ID						{HandleRuleAfterId($id);}
(mod=modifier)?
^(ARG (ARG_ACTION)?)
^(RET (ARG_ACTION)?)
@@ -192,89 +130,12 @@ rule returns [StringTemplate code=null]
( ^(OPTIONS .*) )?
(ruleScopeSpec)?
( ^(AMPERSAND .*) )*
-			b=block["ruleBlock", dfa]
-			{
-				description =
-					grammar.GrammarTreeToString((GrammarAST)$start.GetFirstChildWithType(BLOCK),
-												false);
-				description =
-					generator.Target.GetTargetStringLiteralFromString(description);
-				$b.code.SetAttribute("description", description);
-				// do not generate lexer rules in combined grammar
-				string stName = null;
-				if ( ruleDescr.IsSynPred )
-				{
-					stName = "synpredRule";
-				}
-				else if ( grammar.type==GrammarType.Lexer )
-				{
-					if ( currentRuleName.Equals(Grammar.ArtificialTokensRuleName) )
-					{
-						stName = "tokensRule";
-					}
-					else
-					{
-						stName = "lexerRule";
-					}
-				}
-				else
-				{
-					if ( !(grammar.type==GrammarType.Combined &&
-						 Rule.GetRuleType(currentRuleName) == RuleType.Lexer) )
-					{
-						stName = "rule";
-					}
-				}
-				$code = templates.GetInstanceOf(stName);
-				if ( $code.Name.Equals("rule") )
-				{
-					$code.SetAttribute("emptyRule", grammar.IsEmptyRule(block2));
-				}
-				$code.SetAttribute("ruleDescriptor", ruleDescr);
-				string memo = (string)grammar.GetBlockOption($start,"memoize");
-				if ( memo==null )
-				{
-					memo = (string)grammar.GetOption("memoize");
-				}
-				if ( memo!=null && memo.Equals("true") &&
-					 (stName.Equals("rule")||stName.Equals("lexerRule")) )
-				{
-					$code.SetAttribute("memoize", memo!=null && memo.Equals("true"));
-				}
-			}
+			b=block["ruleBlock", dfa]		{HandleRuleAfterBlock(out $code, $start, block2, ruleDescr, description, $b.code);}

(exceptionGroup[$code])?
EOR
)
-		{
-			if ( $code!=null )
-			{
-				if ( grammar.type==GrammarType.Lexer )
-				{
-					bool naked =
-						currentRuleName.Equals(Grammar.ArtificialTokensRuleName) ||
-						($mod.start!=null&&$mod.start.Text.Equals(Grammar.FragmentRuleModifier));
-					$code.SetAttribute("nakedBlock", naked);
-				}
-				else
-				{
-					description = grammar.GrammarTreeToString($start,false);
-					description = generator.Target.GetTargetStringLiteralFromString(description);
-					$code.SetAttribute("description", description);
-				}
-				Rule theRule = grammar.GetRule(currentRuleName);
-				generator.TranslateActionAttributeReferencesForSingleScope(
-					theRule,
-					theRule.Actions
-				);
-				$code.SetAttribute("ruleName", currentRuleName);
-				$code.SetAttribute("block", $b.code);
-				if ( initAction!=null )
-				{
-					$code.SetAttribute("initAction", initAction);
-				}
-			}
-		}
+											{HandleRuleEnd($code, $start, initAction, description, $mod.start, $b.code);}
;

modifier
@@ -289,353 +150,108 @@ throwsSpec
;

ruleScopeSpec
-	:	^( 'scope' ( ^(AMPERSAND .*) )* (ACTION)? ( ID )* )
+	:	^('scope' ( ^(AMPERSAND .*) )* ACTION? ID*)
;

block[string blockTemplateName, Antlr3.Analysis.DFA dfa]
-	 returns [StringTemplate code=null]
+	 returns [Template code]
options { k=1; }
@init
{
-	int altNum = 0;
-
-	blockNestingLevel++;
-	if ( state.backtracking == 0 )
-	{
-		StringTemplate decision = null;
-		if ( $dfa != null )
-		{
-			$code = templates.GetInstanceOf($blockTemplateName);
-			decision = generator.GenLookaheadDecision(recognizerST,$dfa);
-			$code.SetAttribute("decision", decision);
-			$code.SetAttribute("decisionNumber", $dfa.NfaStartStateDecisionNumber);
-			$code.SetAttribute("maxK",$dfa.MaxLookaheadDepth);
-			$code.SetAttribute("maxAlt",$dfa.NumberOfAlts);
-		}
-		else
-		{
-			$code = templates.GetInstanceOf($blockTemplateName+"SingleAlt");
-		}
-		$code.SetAttribute("blockLevel", blockNestingLevel);
-		$code.SetAttribute("enclosingBlockLevel", blockNestingLevel-1);
-		altNum = 1;
-		if ( this.blockNestingLevel==RULE_BLOCK_NESTING_LEVEL ) {
-			this.outerAltNum=1;
-		}
-	}
+	int altNum;
+	HandleBlockInit($blockTemplateName, $dfa, ref $code, out altNum);
}
-	:	{$start.SetValue!=null}? => setBlock
-		{
-			$code.SetAttribute("alts",$setBlock.code);
-		}
+	:	{((GrammarAST)input.LT(1)).SetValue != null}? => setBlock		{HandleBlockSetBlock($code, $setBlock.code);}

|	^(  BLOCK
( ^(OPTIONS .*) )? // ignore
-			( alt=alternative rew=rewrite
-				{
-					if ( this.blockNestingLevel==RULE_BLOCK_NESTING_LEVEL )
-					{
-						this.outerAltNum++;
-					}
-					// add the rewrite code as just another element in the alt :)
-					// (unless it's a " -> ..." rewrite
-					// ( -> ... )
-					GrammarAST firstRewriteAST = (GrammarAST)$rew.start.FindFirstType(REWRITE);
-					bool etc =
-						$rew.start.Type==REWRITES &&
-						firstRewriteAST.GetChild(0)!=null &&
-						firstRewriteAST.GetChild(0).Type==ETC;
-					if ( $rew.code!=null && !etc )
-					{
-						$alt.code.SetAttribute("rew", $rew.code);
-					}
-					// add this alt to the list of alts for this block
-					$code.SetAttribute("alts",$alt.code);
-					$alt.code.SetAttribute("altNum", altNum);
-					$alt.code.SetAttribute("outerAlt", blockNestingLevel==RULE_BLOCK_NESTING_LEVEL);
-					altNum++;
-				}
+			( alt=alternative rew=rewrite								{HandleBlockAlternative($code, ref altNum, $alt.code, $rew.start, $rew.code);}
)+
EOB
)
;
-finally { blockNestingLevel--; }
+finally {HandleBlockFinally();}

-setBlock returns [StringTemplate code=null]
-@init
-{
-	StringTemplate setcode = null;
-	if ( state.backtracking == 0 )
-	{
-		if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL && grammar.BuildAST )
-		{
-			Rule r = grammar.GetRule(currentRuleName);
-			currentAltHasASTRewrite = r.HasRewrite(outerAltNum);
-			if ( currentAltHasASTRewrite )
-			{
-				r.TrackTokenReferenceInAlt($start, outerAltNum);
-			}
-		}
-	}
-}
-	:	^(s=BLOCK .*)
-		{
-			int i = ((TokenWithIndex)$s.Token).TokenIndex;
-			if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL )
-			{
-				setcode = GetTokenElementST("matchRuleBlockSet", "set", $s, null, null);
-			}
-			else
-			{
-				setcode = GetTokenElementST("matchSet", "set", $s, null, null);
-			}
-			setcode.SetAttribute("elementIndex", i);
-			//if ( grammar.type!=GrammarType.Lexer )
-			//{
-			//	generator.GenerateLocalFollow($s,"set",currentRuleName,i);
-			//}
-			setcode.SetAttribute("s",
-				generator.GenSetExpr(templates,$s.SetValue,1,false));
-			StringTemplate altcode=templates.GetInstanceOf("alt");
-			altcode.SetAttribute("elements.{el,line,pos}",
-								 setcode,
-								 $s.Line,
-								 $s.CharPositionInLine + 1
-								);
-			altcode.SetAttribute("altNum", 1);
-			altcode.SetAttribute("outerAlt", blockNestingLevel==RULE_BLOCK_NESTING_LEVEL);
-			if ( !currentAltHasASTRewrite && grammar.BuildAST )
-			{
-				altcode.SetAttribute("autoAST", true);
-			}
-			altcode.SetAttribute("treeLevel", rewriteTreeNestingLevel);
-			$code = altcode;
-		}
+setBlock returns [Template code]
+	:	^(s=BLOCK .*)							{HandleSetBlock(out $code, $start, $s);}
;

setAlternative
:	^(ALT setElement+ EOA)
;

-exceptionGroup[StringTemplate ruleST]
-	:	( exceptionHandler[$ruleST] )+ (finallyClause[$ruleST])?
+exceptionGroup[Template ruleST]
+	:	exceptionHandler[$ruleST]+ finallyClause[$ruleST]?
|	finallyClause[$ruleST]
;

-exceptionHandler[StringTemplate ruleST]
-	:	^('catch' ARG_ACTION ACTION)
-		{
-			IList<object> chunks = generator.TranslateAction(currentRuleName,$ACTION);
-			$ruleST.SetAttribute("exceptions.{decl,action}",$ARG_ACTION.text,chunks);
-		}
+exceptionHandler[Template ruleST]
+	:	^('catch' ARG_ACTION ACTION)			{HandleExceptionHandler($ruleST, $ARG_ACTION, $ACTION);}
;

-finallyClause[StringTemplate ruleST]
-	:	^('finally' ACTION)
-		{
-			IList<object> chunks = generator.TranslateAction(currentRuleName,$ACTION);
-			$ruleST.SetAttribute("finally",chunks);
-		}
+finallyClause[Template ruleST]
+	:	^('finally' ACTION)						{HandleFinallyClause($ruleST, $ACTION);}
;

-alternative returns [StringTemplate code]
+alternative returns [Template code]
@init
{
-	if ( state.backtracking == 0 )
-	{
-		$code = templates.GetInstanceOf("alt");
-		if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL && grammar.BuildAST )
-		{
-			Rule r = grammar.GetRule(currentRuleName);
-			currentAltHasASTRewrite = r.HasRewrite(outerAltNum);
-		}
-		string description = grammar.GrammarTreeToString($start, false);
-		description = generator.Target.GetTargetStringLiteralFromString(description);
-		$code.SetAttribute("description", description);
-		$code.SetAttribute("treeLevel", rewriteTreeNestingLevel);
-		if ( !currentAltHasASTRewrite && grammar.BuildAST )
-		{
-			$code.SetAttribute("autoAST", true);
-		}
-	}
+HandleAlternativeInit(out $code, $start);
}
-	:	^(	a=ALT
-			(
-				e=element[null,null]
-				{
-					if (e != null && e.code != null)
-					{
-						$code.SetAttribute("elements.{el,line,pos}",
-										  $e.code,
-										  $e.start.Line,
-										  $e.start.CharPositionInLine + 1
-										 );
-					}
-				}
+	:	^(	ALT
+			(	e=element[null,null]			{HandleAlternativeElement($code, $e.start, $e.code);}
)+
EOA
)
;

-element[GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null]
+element[GrammarAST label, GrammarAST astSuffix] returns [Template code]
options { k=1; }
-@init
-{
-	IIntSet elements=null;
-	GrammarAST ast = null;
-}
-	:	^(ROOT e=element[label,$ROOT])
-		{ $code = $e.code; }
-
-	|	^(BANG e=element[label,$BANG])
-		{ $code = $e.code; }
-
-	|	^( n=NOT notElement[$n, $label, $astSuffix] )
-		{ $code = $notElement.code; }
-
-	|	^( ASSIGN alabel=ID e=element[$alabel,$astSuffix] )
-		{ $code = $e.code; }
-
-	|	^( PLUS_ASSIGN label2=ID e=element[$label2,$astSuffix] )
-		{ $code = $e.code; }
-
-	|	^(CHAR_RANGE a=CHAR_LITERAL b=CHAR_LITERAL)
-		{
-			$code = templates.GetInstanceOf("charRangeRef");
-			string low = generator.Target.GetTargetCharLiteralFromANTLRCharLiteral(generator,$a.text);
-			string high = generator.Target.GetTargetCharLiteralFromANTLRCharLiteral(generator,$b.text);
-			$code.SetAttribute("a", low);
-			$code.SetAttribute("b", high);
-			if ( label!=null )
-			{
-				$code.SetAttribute("label", $label.Text);
-			}
-		}
-
-	|	({((GrammarAST)input.LT(1)).SetValue==null}? (BLOCK|OPTIONAL|CLOSURE|POSITIVE_CLOSURE)) => /*{$start.getSetValue()==null}?*/ ebnf
-		{ $code = $ebnf.code; }
-
-	|	atom[null, $label, $astSuffix]
-		{ $code = $atom.code; }
-
-	|	tree_
-		{ $code = $tree_.code; }
-
-	|	element_action
-		{ $code = $element_action.code; }
-
-	|   (sp=SEMPRED|sp=GATED_SEMPRED)
-		{
-			$code = templates.GetInstanceOf("validateSemanticPredicate");
-			$code.SetAttribute("pred", generator.TranslateAction(currentRuleName,$sp));
-			string description = generator.Target.GetTargetStringLiteralFromString($sp.text);
-			$code.SetAttribute("description", description);
-		}
-
+	:	^(ROOT e=element[label,$ROOT])							{$code = $e.code;}
+	|	^(BANG e=element[label,$BANG])							{$code = $e.code;}
+	|	^(n=NOT notElement[$n, $label, $astSuffix])				{$code = $notElement.code;}
+	|	^(ASSIGN alabel=ID e=element[$alabel,$astSuffix])		{$code = $e.code;}
+	|	^(PLUS_ASSIGN label2=ID e=element[$label2,$astSuffix])	{$code = $e.code;}
+	|	^(CHAR_RANGE a=CHAR_LITERAL b=CHAR_LITERAL)				{HandleElementCharRange($label, out $code, $a, $b);}
+	|	{$start.SetValue == null}? ebnf							{$code = $ebnf.code;}
+	|	atom[null, $label, $astSuffix]							{$code = $atom.code;}
+	|	tree_													{$code = $tree_.code;}
+	|	element_action											{$code = $element_action.code;}
+	|	(sp=SEMPRED | sp=GATED_SEMPRED)							{HandleElementSemanticPredicate(out $code, $sp);}
|	SYN_SEMPRED // used only in lookahead; don't generate validating pred
-
|	^(SYNPRED .*)
-
|	^(BACKTRACK_SEMPRED .*)
-
-	|   EPSILON
+	|	EPSILON
;

-element_action returns [StringTemplate code=null]
-	:	act=ACTION
-		{
-			$code = templates.GetInstanceOf("execAction");
-			$code.SetAttribute("action", generator.TranslateAction(currentRuleName,$act));
-		}
-	|	act2=FORCED_ACTION
-		{
-			$code = templates.GetInstanceOf("execForcedAction");
-			$code.SetAttribute("action", generator.TranslateAction(currentRuleName,$act2));
-		}
+element_action returns [Template code]
+	:	action=ACTION			{HandleElementAction(out $code, $action, false);}
+	|	action=FORCED_ACTION	{HandleElementAction(out $code, $action, true);}
;

-notElement[GrammarAST n, GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null]
+notElement[GrammarAST n, GrammarAST label, GrammarAST astSuffix] returns [Template code]
@init
{
-	IIntSet elements=null;
-	string labelText = null;
-	if ( label!=null )
-	{
-		labelText = label.Text;
-	}
+	IIntSet elements = null;
}
-	:	(	assign_c=CHAR_LITERAL
-			{
-				int ttype=0;
-				if ( grammar.type==GrammarType.Lexer )
-				{
-					ttype = Grammar.GetCharValueFromGrammarCharLiteral($assign_c.text);
-				}
-				else
-				{
-					ttype = grammar.GetTokenType($assign_c.text);
-				}
-				elements = grammar.Complement(ttype);
-			}
-		|	assign_s=STRING_LITERAL
-			{
-				int ttype=0;
-				if ( grammar.type==GrammarType.Lexer )
-				{
-					// TODO: error!
-				}
-				else
-				{
-					ttype = grammar.GetTokenType($assign_s.text);
-				}
-				elements = grammar.Complement(ttype);
-			}
-		|	assign_t=TOKEN_REF
-			{
-				int ttype = grammar.GetTokenType($assign_t.text);
-				elements = grammar.Complement(ttype);
-			}
-		|	^(assign_st=BLOCK .*)
-			{
-				elements = $assign_st.SetValue;
-				elements = grammar.Complement(elements);
-			}
+	:	(	t=CHAR_LITERAL		{HandleNotElementCharLiteral(out elements, $t);}
+		|	t=STRING_LITERAL	{HandleNotElementStringLiteral(out elements, $t);}
+		|	t=TOKEN_REF			{HandleNotElementTokenReference(out elements, $t);}
+		|	^(t=BLOCK .*)		{HandleNotElementBlock(out elements, $t);}
)
-		{
-			$code = GetTokenElementST("matchSet",
-									 "set",
-									 (GrammarAST)$n.GetChild(0),
-									 astSuffix,
-									 labelText);
-			$code.SetAttribute("s",generator.GenSetExpr(templates,elements,1,false));
-			int i = ((TokenWithIndex)n.Token).TokenIndex;
-			$code.SetAttribute("elementIndex", i);
-			if ( grammar.type!=GrammarType.Lexer )
-			{
-				generator.GenerateLocalFollow(n,"set",currentRuleName,i);
-			}
-		}
+								{HandleNotElementEnd($n, $label, $astSuffix, out $code, elements, $start);}
;

-ebnf returns [StringTemplate code=null]
+ebnf returns [Template code=null]
@init
{
-	Antlr3.Analysis.DFA dfa=null;
GrammarAST b = (GrammarAST)$start.GetChild(0);
GrammarAST eob = (GrammarAST)b.LastChild; // loops will use EOB DFA
}
-	:	(	{ dfa = $start.LookaheadDFA; }
-			blk=block["block", dfa]
-			{ $code = $blk.code; }
-		|	{ dfa = $start.LookaheadDFA; }
-			^( OPTIONAL blk=block["optionalBlock", dfa] )
-			{ $code = $blk.code; }
-		|	{ dfa = eob.LookaheadDFA; }
-			^( CLOSURE blk=block["closureBlock", dfa] )
-			{ $code = $blk.code; }
-		|	{ dfa = eob.LookaheadDFA; }
-			^( POSITIVE_CLOSURE blk=block["positiveClosureBlock", dfa] )
-			{ $code = $blk.code; }
+	:	(	blk=block["block", $start.LookaheadDFA]										{$code = $blk.code;}
+		|	^(OPTIONAL blk=block["optionalBlock", $start.LookaheadDFA])					{$code = $blk.code;}
+		|	^(CLOSURE blk=block["closureBlock", eob.LookaheadDFA])						{$code = $blk.code;}
+		|	^(POSITIVE_CLOSURE blk=block["positiveClosureBlock", eob.LookaheadDFA])		{$code = $blk.code;}
)
{
string description = grammar.GrammarTreeToString($start, false);
@@ -644,7 +260,7 @@ ebnf returns [StringTemplate code=null]
}
;

-tree_ returns [StringTemplate code]
+tree_ returns [Template code]
@init
{
rewriteTreeNestingLevel++;
@@ -704,213 +320,20 @@ tree_ returns [StringTemplate code]
finally { rewriteTreeNestingLevel--; }

atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
-	returns [StringTemplate code=null]
+	returns [Template code]
@init
{
-	string labelText=null;
-	if ( state.backtracking == 0 )
-	{
-		if ( label!=null )
-		{
-			labelText = label.Text;
-		}
-		if ( grammar.type!=GrammarType.Lexer &&
-			 ($start.Type==RULE_REF||$start.Type==TOKEN_REF||
-			  $start.Type==CHAR_LITERAL||$start.Type==STRING_LITERAL) )
-		{
-			Rule encRule = grammar.GetRule(((GrammarAST)$start).enclosingRuleName);
-			if ( encRule!=null && encRule.HasRewrite(outerAltNum) && astSuffix!=null )
-			{
-				ErrorManager.GrammarError(ErrorManager.MSG_AST_OP_IN_ALT_WITH_REWRITE,
-										  grammar,
-										  ((GrammarAST)$start).Token,
-										  ((GrammarAST)$start).enclosingRuleName,
-										  outerAltNum);
-				astSuffix = null;
-			}
-		}
-	}
+	string labelText;
+	HandleAtomInit($start, $label, ref $astSuffix, out labelText);
}
-	:   ^( r=RULE_REF (rarg=ARG_ACTION)? )
-		{
-			grammar.CheckRuleReference(scope, $r, $rarg, currentRuleName);
-			string scopeName = null;
-			if ( scope!=null ) {
-				scopeName = scope.Text;
-			}
-			Rule rdef = grammar.GetRule(scopeName, $r.text);
-			// don't insert label=r() if $label.attr not used, no ret value, ...
-			if ( !rdef.HasReturnValue ) {
-				labelText = null;
-			}
-			$code = GetRuleElementST("ruleRef", $r.text, $r, astSuffix, labelText);
-			$code.SetAttribute("rule", rdef);
-			if ( scope!=null ) { // scoped rule ref
-				Grammar scopeG = grammar.composite.GetGrammar(scope.Text);
-				$code.SetAttribute("scope", scopeG);
-			}
-			else if ( rdef.Grammar != this.grammar ) { // nonlocal
-				// if rule definition is not in this grammar, it's nonlocal
-				IList<Grammar> rdefDelegates = rdef.Grammar.GetDelegates();
-				if ( rdefDelegates.Contains(this.grammar) ) {
-					$code.SetAttribute("scope", rdef.Grammar);
-				}
-				else {
-					// defining grammar is not a delegate, scope all the
-					// back to root, which has delegate methods for all
-					// rules.  Don't use scope if we are root.
-					if ( this.grammar != rdef.Grammar.composite.DelegateGrammarTreeRoot.Grammar ) {
-						$code.SetAttribute("scope",
-										  rdef.Grammar.composite.DelegateGrammarTreeRoot.Grammar);
-					}
-				}
-			}
-
-			if ( $rarg!=null ) {
-				IList<object> args = generator.TranslateAction(currentRuleName,$rarg);
-				$code.SetAttribute("args", args);
-			}
-			int i = ((TokenWithIndex)r.Token).TokenIndex;
-			$code.SetAttribute("elementIndex", i);
-			generator.GenerateLocalFollow($r,$r.text,currentRuleName,i);
-			$r.code = $code;
-		}
-
-	|	^( t=TOKEN_REF (targ=ARG_ACTION)? )
-		{
-			if ( currentAltHasASTRewrite && $t.terminalOptions!=null &&
-				$t.terminalOptions[Grammar.defaultTokenOption]!=null )
-			{
-				ErrorManager.GrammarError(ErrorManager.MSG_HETERO_ILLEGAL_IN_REWRITE_ALT,
-										grammar,
-										((GrammarAST)($t)).Token,
-										$t.text);
-			}
-			grammar.CheckRuleReference(scope, $t, $targ, currentRuleName);
-			if ( grammar.type==GrammarType.Lexer )
-			{
-				if ( grammar.GetTokenType($t.text)==Label.EOF )
-				{
-					$code = templates.GetInstanceOf("lexerMatchEOF");
-				}
-				else
-				{
-					$code = templates.GetInstanceOf("lexerRuleRef");
-					if ( IsListLabel(labelText) )
-					{
-						$code = templates.GetInstanceOf("lexerRuleRefAndListLabel");
-					}
-					string scopeName = null;
-					if ( scope!=null )
-					{
-						scopeName = scope.Text;
-					}
-					Rule rdef2 = grammar.GetRule(scopeName, $t.text);
-					$code.SetAttribute("rule", rdef2);
-					if ( scope!=null )
-					{ // scoped rule ref
-						Grammar scopeG = grammar.composite.GetGrammar(scope.Text);
-						$code.SetAttribute("scope", scopeG);
-					}
-					else if ( rdef2.Grammar != this.grammar )
-					{ // nonlocal
-						// if rule definition is not in this grammar, it's nonlocal
-						$code.SetAttribute("scope", rdef2.Grammar);
-					}
-					if ( $targ!=null )
-					{
-						IList<object> args = generator.TranslateAction(currentRuleName,$targ);
-						$code.SetAttribute("args", args);
-					}
-				}
-				int i = ((TokenWithIndex)$t.Token).TokenIndex;
-				$code.SetAttribute("elementIndex", i);
-				if ( label!=null )
-					$code.SetAttribute("label", labelText);
-			}
-			else
-			{
-				$code = GetTokenElementST("tokenRef", $t.text, $t, astSuffix, labelText);
-				string tokenLabel =
-					generator.GetTokenTypeAsTargetLabel(grammar.GetTokenType(t.Text));
-				$code.SetAttribute("token",tokenLabel);
-				if ( !currentAltHasASTRewrite && $t.terminalOptions!=null )
-				{
-					$code.SetAttribute("terminalOptions", $t.terminalOptions);
-				}
-				int i = ((TokenWithIndex)$t.Token).TokenIndex;
-				$code.SetAttribute("elementIndex", i);
-				generator.GenerateLocalFollow($t,tokenLabel,currentRuleName,i);
-			}
-			$t.code = $code;
-		}
-
-	|	c=CHAR_LITERAL
-		{
-			if ( grammar.type==GrammarType.Lexer )
-			{
-				$code = templates.GetInstanceOf("charRef");
-				$code.SetAttribute("char",
-				   generator.Target.GetTargetCharLiteralFromANTLRCharLiteral(generator,$c.text));
-				if ( label!=null )
-				{
-					$code.SetAttribute("label", labelText);
-				}
-			}
-			else { // else it's a token type reference
-				$code = GetTokenElementST("tokenRef", "char_literal", $c, astSuffix, labelText);
-				string tokenLabel = generator.GetTokenTypeAsTargetLabel(grammar.GetTokenType($c.text));
-				$code.SetAttribute("token",tokenLabel);
-				if ( $c.terminalOptions!=null ) {
-					$code.SetAttribute("terminalOptions",$c.terminalOptions);
-				}
-				int i = ((TokenWithIndex)$c.Token).TokenIndex;
-				$code.SetAttribute("elementIndex", i);
-				generator.GenerateLocalFollow($c,tokenLabel,currentRuleName,i);
-			}
-		}
-
-	|	s=STRING_LITERAL
-		{
-			int i = ((TokenWithIndex)$s.Token).TokenIndex;
-			if ( grammar.type==GrammarType.Lexer )
-			{
-				$code = templates.GetInstanceOf("lexerStringRef");
-				$code.SetAttribute("string",
-					generator.Target.GetTargetStringLiteralFromANTLRStringLiteral(generator,$s.text));
-				$code.SetAttribute("elementIndex", i);
-				if ( label!=null )
-				{
-					$code.SetAttribute("label", labelText);
-				}
-			}
-			else
-			{
-				// else it's a token type reference
-				$code = GetTokenElementST("tokenRef", "string_literal", $s, astSuffix, labelText);
-				string tokenLabel =
-					generator.GetTokenTypeAsTargetLabel(grammar.GetTokenType($s.text));
-				$code.SetAttribute("token",tokenLabel);
-				if ( $s.terminalOptions!=null )
-				{
-					$code.SetAttribute("terminalOptions",$s.terminalOptions);
-				}
-				$code.SetAttribute("elementIndex", i);
-				generator.GenerateLocalFollow($s,tokenLabel,currentRuleName,i);
-			}
-		}
-
-	|	w=WILDCARD
-		{
-			$code = GetWildcardST($w,astSuffix,labelText);
-			$code.SetAttribute("elementIndex", ((TokenWithIndex)$w.Token).TokenIndex);
-		}
-
-	|	^(DOT ID a=atom[$ID, label, astSuffix]) // scope override on rule or token
-		{ $code = $a.code; }
-
-	|	set[label,astSuffix]
-		{ $code = $set.code; }
+	:   ^( r=RULE_REF (rarg=ARG_ACTION)? )		{HandleAtomRuleReference($scope, $label, $astSuffix, out $code, labelText, $r, $rarg);}
+	|	^( t=TOKEN_REF (targ=ARG_ACTION)? )		{HandleAtomTokenReference($scope, $label, $astSuffix, out $code, labelText, $t, $targ);}
+	|	c=CHAR_LITERAL							{HandleAtomCharLiteral($label, $astSuffix, out $code, labelText, $c);}
+	|	s=STRING_LITERAL						{HandleAtomStringLiteral($label, $astSuffix, out $code, labelText, $s);}
+	|	w=WILDCARD								{HandleAtomWildcard($astSuffix, out $code, labelText, $w);}
+	|	^(DOT ID a=atom[$ID, $label, $astSuffix]) // scope override on rule or token
+												{ $code = $a.code; }
+	|	set[$label, $astSuffix]					{ $code = $set.code; }
;

ast_suffix
@@ -918,26 +341,9 @@ ast_suffix
|	BANG
;

-set[GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null]
-@init
-{
-	string labelText=null;
-	if ( $label!=null )
-	{
-		labelText = $label.Text;
-	}
-}
-	:	^(s=BLOCK .*) // only care that it's a BLOCK with setValue!=null
-		{
-			$code = GetTokenElementST("matchSet", "set", $s, astSuffix, labelText);
-			int i = ((TokenWithIndex)$s.Token).TokenIndex;
-			$code.SetAttribute("elementIndex", i);
-			if ( grammar.type!=GrammarType.Lexer )
-			{
-				generator.GenerateLocalFollow($s,"set",currentRuleName,i);
-			}
-			$code.SetAttribute("s", generator.GenSetExpr(templates,$s.SetValue,1,false));
-		}
+set[GrammarAST label, GrammarAST astSuffix] returns [Template code]
+	:	// only care that it's a BLOCK with setValue!=null
+		^(s=BLOCK .*)							{HandleSet($label, $astSuffix, out $code, $s);}
;

setElement
@@ -949,87 +355,25 @@ setElement

// REWRITE stuff

-rewrite returns [StringTemplate code=null]
+rewrite returns [Template code]
@init
{
-	if ( state.backtracking == 0 )
-	{
-		if ( $start.Type==REWRITES )
-		{
-			if ( generator.Grammar.BuildTemplate )
-			{
-				$code = templates.GetInstanceOf("rewriteTemplate");
-			}
-			else
-			{
-				$code = templates.GetInstanceOf("rewriteCode");
-				$code.SetAttribute("treeLevel", OUTER_REWRITE_NESTING_LEVEL);
-				$code.SetAttribute("rewriteBlockLevel", OUTER_REWRITE_NESTING_LEVEL);
-				$code.SetAttribute("referencedElementsDeep",
-								  GetTokenTypesAsTargetLabels($start.rewriteRefsDeep));
-				HashSet<string> tokenLabels =
-					grammar.GetLabels($start.rewriteRefsDeep, LabelType.Token);
-				HashSet<string> tokenListLabels =
-					grammar.GetLabels($start.rewriteRefsDeep, LabelType.TokenList);
-				HashSet<string> ruleLabels =
-					grammar.GetLabels($start.rewriteRefsDeep, LabelType.Rule);
-				HashSet<string> ruleListLabels =
-					grammar.GetLabels($start.rewriteRefsDeep, LabelType.RuleList);
-				HashSet<string> wildcardLabels =
-					grammar.GetLabels($start.rewriteRefsDeep, LabelType.WildcardTree);
-				HashSet<string> wildcardListLabels =
-					grammar.GetLabels($start.rewriteRefsDeep, LabelType.WildcardTreeList);
-				// just in case they ref $r for "previous value", make a stream
-				// from retval.tree
-				StringTemplate retvalST = templates.GetInstanceOf("prevRuleRootRef");
-				ruleLabels.Add(retvalST.Render());
-				$code.SetAttribute("referencedTokenLabels", tokenLabels);
-				$code.SetAttribute("referencedTokenListLabels", tokenListLabels);
-				$code.SetAttribute("referencedRuleLabels", ruleLabels);
-				$code.SetAttribute("referencedRuleListLabels", ruleListLabels);
-				$code.SetAttribute("referencedWildcardLabels", wildcardLabels);
-				$code.SetAttribute("referencedWildcardListLabels", wildcardListLabels);
-			}
-		}
-		else
-		{
-				$code = templates.GetInstanceOf("noRewrite");
-				$code.SetAttribute("treeLevel", OUTER_REWRITE_NESTING_LEVEL);
-				$code.SetAttribute("rewriteBlockLevel", OUTER_REWRITE_NESTING_LEVEL);
-		}
-	}
+HandleRewriteInit(out $code, $start);
}
:	^(	REWRITES
(
-				{rewriteRuleRefs = new HashSet<object>();}
-				^( r=REWRITE (pred=SEMPRED)? alt=rewrite_alternative)
-				{
-					rewriteBlockNestingLevel = OUTER_REWRITE_NESTING_LEVEL;
-					IList<object> predChunks = null;
-					if ( $pred!=null )
-					{
-						//predText = #pred.getText();
-						predChunks = generator.TranslateAction(currentRuleName,$pred);
-					}
-					string description =
-						grammar.GrammarTreeToString($r,false);
-					description = generator.Target.GetTargetStringLiteralFromString(description);
-					$code.SetAttribute("alts.{pred,alt,description}",
-									  predChunks,
-									  alt,
-									  description);
-					pred=null;
-				}
+																		{HandleRewriteBeforeRewrite();}
+				^( r=REWRITE (pred=SEMPRED)? alt=rewrite_alternative)	{HandleRewriteAfterRewrite($code, $r, ref $pred, $alt.code);}
)*
)
|
;

-rewrite_block[string blockTemplateName] returns [StringTemplate code=null]
+rewrite_block[string blockTemplateName] returns [Template code]
@init
{
rewriteBlockNestingLevel++;
-	StringTemplate save_currentBlockST = currentBlockST;
+	Template save_currentBlockST = currentBlockST;
if ( state.backtracking == 0 )
{
$code = templates.GetInstanceOf(blockTemplateName);
@@ -1053,7 +397,7 @@ rewrite_block[string blockTemplateName] returns [StringTemplate code=null]
;
finally { rewriteBlockNestingLevel--; currentBlockST = save_currentBlockST; }

-rewrite_alternative returns [StringTemplate code=null]
+rewrite_alternative returns [Template code]
:	{generator.Grammar.BuildAST}?
^(	a=ALT {$code=templates.GetInstanceOf("rewriteElementList");}
(	(
@@ -1083,45 +427,26 @@ rewrite_alternative returns [StringTemplate code=null]
ETC
;

-rewrite_element returns [StringTemplate code=null]
+rewrite_element returns [Template code]
@init
{
IIntSet elements=null;
GrammarAST ast = null;
}
-	:	rewrite_atom[false]
-		{ $code = $rewrite_atom.code; }
-	|	rewrite_ebnf
-		{ $code = $rewrite_ebnf.code; }
-	|	rewrite_tree
-		{ $code = $rewrite_tree.code; }
+	:	rewrite_atom[false]		{ $code = $rewrite_atom.code; }
+	|	rewrite_ebnf			{ $code = $rewrite_ebnf.code; }
+	|	rewrite_tree			{ $code = $rewrite_tree.code; }
;

-rewrite_ebnf returns [StringTemplate code=null]
-	:	^( OPTIONAL rewrite_block["rewriteOptionalBlock"] )
-		{ $code = $rewrite_block.code; }
-		{
-			string description = grammar.GrammarTreeToString($start, false);
-			description = generator.Target.GetTargetStringLiteralFromString(description);
-			$code.SetAttribute("description", description);
-		}
-	|	^( CLOSURE rewrite_block["rewriteClosureBlock"] )
-		{ $code = $rewrite_block.code; }
-		{
-			string description = grammar.GrammarTreeToString($start, false);
-			description = generator.Target.GetTargetStringLiteralFromString(description);
-			$code.SetAttribute("description", description);
-		}
-	|	^( POSITIVE_CLOSURE rewrite_block["rewritePositiveClosureBlock"] )
-		{ $code = $rewrite_block.code; }
-		{
-			string description = grammar.GrammarTreeToString($start, false);
-			description = generator.Target.GetTargetStringLiteralFromString(description);
-			$code.SetAttribute("description", description);
-		}
+rewrite_ebnf returns [Template code]
+	:	(	^(OPTIONAL b=rewrite_block["rewriteOptionalBlock"])
+		|	^(CLOSURE b=rewrite_block["rewriteClosureBlock"])
+		|	^(POSITIVE_CLOSURE b=rewrite_block["rewritePositiveClosureBlock"])
+		)
+		{HandleRewriteEbnf(out $code, $start, $b.code);}
;

-rewrite_tree returns [StringTemplate code]
+rewrite_tree returns [Template code]
@init
{
rewriteTreeNestingLevel++;
@@ -1160,213 +485,28 @@ rewrite_tree returns [StringTemplate code]
;
finally { rewriteTreeNestingLevel--; }

-rewrite_atom[bool isRoot] returns [StringTemplate code=null]
-	:   r=RULE_REF
-		{
-			string ruleRefName = $r.text;
-			string stName = "rewriteRuleRef";
-			if ( isRoot )
-			{
-				stName += "Root";
-			}
-			$code = templates.GetInstanceOf(stName);
-			$code.SetAttribute("rule", ruleRefName);
-			if ( grammar.GetRule(ruleRefName)==null )
-			{
-				ErrorManager.GrammarError(ErrorManager.MSG_UNDEFINED_RULE_REF,
-										  grammar,
-										  ((GrammarAST)($r)).Token,
-										  ruleRefName);
-				$code = new StringTemplate(string.Empty); // blank; no code gen
-			}
-			else if ( grammar.GetRule(currentRuleName)
-						 .GetRuleRefsInAlt(ruleRefName,outerAltNum)==null )
-			{
-				ErrorManager.GrammarError(ErrorManager.MSG_REWRITE_ELEMENT_NOT_PRESENT_ON_LHS,
-										  grammar,
-										  ((GrammarAST)($r)).Token,
-										  ruleRefName);
-				$code = new StringTemplate(); // blank; no code gen
-			}
-			else
-			{
-				// track all rule refs as we must copy 2nd ref to rule and beyond
-				if ( !rewriteRuleRefs.Contains(ruleRefName) )
-				{
-					rewriteRuleRefs.Add(ruleRefName);
-				}
-			}
-		}
-
-	|
-		(	^(tk=TOKEN_REF (arg=ARG_ACTION)?)
-		|	cl=CHAR_LITERAL
-		|	sl=STRING_LITERAL
-		)
-		{
-			GrammarAST term = ($tk) ?? ($cl) ?? ($sl);
-			string tokenName = $start.Token.Text;
-			string stName = "rewriteTokenRef";
-			Rule rule = grammar.GetRule(currentRuleName);
-			ICollection<string> tokenRefsInAlt = rule.GetTokenRefsInAlt(outerAltNum);
-			bool createNewNode = !tokenRefsInAlt.Contains(tokenName) || $arg!=null;
-			if ( createNewNode )
-			{
-				stName = "rewriteImaginaryTokenRef";
-			}
-			if ( isRoot )
-			{
-				stName += "Root";
-			}
-			$code = templates.GetInstanceOf(stName);
-			$code.SetAttribute("terminalOptions",term.terminalOptions);
-			if ( $arg!=null )
-			{
-				IList<object> args = generator.TranslateAction(currentRuleName,$arg);
-				$code.SetAttribute("args", args);
-			}
-			$code.SetAttribute("elementIndex", ((TokenWithIndex)$start.Token).TokenIndex);
-			int ttype = grammar.GetTokenType(tokenName);
-			string tok = generator.GetTokenTypeAsTargetLabel(ttype);
-			$code.SetAttribute("token", tok);
-			if ( grammar.GetTokenType(tokenName)==Label.INVALID )
-			{
-				ErrorManager.GrammarError(ErrorManager.MSG_UNDEFINED_TOKEN_REF_IN_REWRITE,
-										  grammar,
-										  ((GrammarAST)($start)).Token,
-										  tokenName);
-				$code = new StringTemplate(); // blank; no code gen
-			}
-		}
-
-	|	LABEL
-		{
-			string labelName = $LABEL.text;
-			Rule rule = grammar.GetRule(currentRuleName);
-			Grammar.LabelElementPair pair = rule.GetLabel(labelName);
-			if ( labelName.Equals(currentRuleName) )
-			{
-				// special case; ref to old value via $ rule
-				if ( rule.HasRewrite(outerAltNum) &&
-					 rule.GetRuleRefsInAlt(outerAltNum).Contains(labelName) )
-				{
-					ErrorManager.GrammarError(ErrorManager.MSG_RULE_REF_AMBIG_WITH_RULE_IN_ALT,
-											  grammar,
-											  ((GrammarAST)($LABEL)).Token,
-											  labelName);
-				}
-				StringTemplate labelST = templates.GetInstanceOf("prevRuleRootRef");
-				$code = templates.GetInstanceOf("rewriteRuleLabelRef"+(isRoot?"Root":""));
-				$code.SetAttribute("label", labelST);
-			}
-			else if ( pair==null )
-			{
-				ErrorManager.GrammarError(ErrorManager.MSG_UNDEFINED_LABEL_REF_IN_REWRITE,
-										  grammar,
-										  ((GrammarAST)($LABEL)).Token,
-										  labelName);
-				$code = new StringTemplate();
-			}
-			else
-			{
-				string stName = null;
-				switch ( pair.type )
-				{
-				case LabelType.Token :
-					stName = "rewriteTokenLabelRef";
-					break;
-				case LabelType.WildcardTree :
-					stName = "rewriteWildcardLabelRef";
-					break;
-				case LabelType.WildcardTreeList:
-					stName = "rewriteRuleListLabelRef"; // acts like rule ref list for ref
-					break;
-				case LabelType.Rule :
-					stName = "rewriteRuleLabelRef";
-					break;
-				case LabelType.TokenList :
-					stName = "rewriteTokenListLabelRef";
-					break;
-				case LabelType.RuleList :
-					stName = "rewriteRuleListLabelRef";
-					break;
-				}
-				if ( isRoot )
-				{
-					stName += "Root";
-				}
-				$code = templates.GetInstanceOf(stName);
-				$code.SetAttribute("label", labelName);
-			}
-		}
-
-	|	ACTION
-		{
-			// actions in rewrite rules yield a tree object
-			string actText = $ACTION.text;
-			IList<object> chunks = generator.TranslateAction(currentRuleName,$ACTION);
-			$code = templates.GetInstanceOf("rewriteNodeAction"+(isRoot?"Root":""));
-			$code.SetAttribute("action", chunks);
-		}
+rewrite_atom[bool isRoot] returns [Template code]
+	:   r=RULE_REF								{HandleRewriteAtomRuleReference(isRoot, out $code, $r);}
+	|	(	^(term=TOKEN_REF (arg=ARG_ACTION)?)
+		|	term=CHAR_LITERAL
+		|	term=STRING_LITERAL
+		)										{HandleRewriteAtomTokenReference($isRoot, out $code, $start, $term, $arg);}
+	|	LABEL									{HandleRewriteAtomLabel($isRoot, out $code, $LABEL);}
+	|	ACTION									{HandleRewriteAtomAction($isRoot, out $code, $ACTION);}
;

public
-rewrite_template returns [StringTemplate code=null]
-	:	^( ALT EPSILON EOA ) {$code=templates.GetInstanceOf("rewriteEmptyTemplate");}
-	|	^(	TEMPLATE (id=ID|ind=ACTION)
-			{
-				if ( $id!=null && $id.text.Equals("template") )
-				{
-						$code = templates.GetInstanceOf("rewriteInlineTemplate");
-				}
-				else if ( $id!=null )
-				{
-						$code = templates.GetInstanceOf("rewriteExternalTemplate");
-						$code.SetAttribute("name", $id.text);
-				}
-				else if ( $ind!=null )
-				{ // must be \%({expr})(args)
-					$code = templates.GetInstanceOf("rewriteIndirectTemplate");
-					IList<object> chunks=generator.TranslateAction(currentRuleName,$ind);
-					$code.SetAttribute("expr", chunks);
-				}
-			}
+rewrite_template returns [Template code]
+	:	^(ALT EPSILON EOA)					{HandleRewriteTemplateAlt(out $code);}
+	|	^(	TEMPLATE (id=ID|ind=ACTION)		{HandleRewriteTemplateAfterId(out $code, $id, $ind);}
^(	ARGLIST
-				(	^( ARG arg=ID a=ACTION
-					{
-						// must set alt num here rather than in define.g
-						// because actions like \%foo(name={\$ID.text}) aren't
-						// broken up yet into trees.
-						$a.outerAltNum = this.outerAltNum;
-						IList<object> chunks = generator.TranslateAction(currentRuleName,$a);
-						$code.SetAttribute("args.{name,value}", $arg.text, chunks);
-					}
-					)
+				(	^(ARG arg=ID a=ACTION)	{HandleRewriteTemplateArg($code, $arg, $a);}
)*
)
-			(	DOUBLE_QUOTE_STRING_LITERAL
-				{
-					string sl = $DOUBLE_QUOTE_STRING_LITERAL.text;
-					string t = sl.Substring( 1, sl.Length - 2 ); // strip quotes
-					t = generator.Target.GetTargetStringLiteralFromString(t);
-					$code.SetAttribute("template",t);
-				}
-			|	DOUBLE_ANGLE_STRING_LITERAL
-				{
-					string sl = $DOUBLE_ANGLE_STRING_LITERAL.text;
-					string t = sl.Substring( 2, sl.Length - 4 ); // strip double angle quotes
-					t = generator.Target.GetTargetStringLiteralFromString(t);
-					$code.SetAttribute("template",t);
-				}
+			(	DOUBLE_QUOTE_STRING_LITERAL	{HandleRewriteTemplateLiteral($code, $DOUBLE_QUOTE_STRING_LITERAL, 1);}
+			|	DOUBLE_ANGLE_STRING_LITERAL	{HandleRewriteTemplateLiteral($code, $DOUBLE_ANGLE_STRING_LITERAL, 2);}
)?
)

-	|	act=ACTION
-		{
-			// set alt num for same reason as ARGLIST above
-			$act.outerAltNum = this.outerAltNum;
-			$code=templates.GetInstanceOf("rewriteAction");
-			$code.SetAttribute("action",
-							  generator.TranslateAction(currentRuleName,$act));
-		}
+	|	act=ACTION							{HandleRewriteTemplateAction(out $code, $act);}
;
diff --git a/Antlr3/Grammars/CodeGenTreeWalkerHelper.cs b/Antlr3/Grammars/CodeGenTreeWalkerHelper.cs
index f4dbf58..61db778 100644
--- a/Antlr3/Grammars/CodeGenTreeWalkerHelper.cs
+++ b/Antlr3/Grammars/CodeGenTreeWalkerHelper.cs
@@ -36,20 +36,23 @@ namespace Antlr3.Grammars
using Antlr3.Codegen;
using Antlr3.Extensions;

+    using ArgumentException = System.ArgumentException;
using CommonToken = Antlr.Runtime.CommonToken;
using Console = System.Console;
using ErrorManager = Antlr3.Tool.ErrorManager;
using Grammar = Antlr3.Tool.Grammar;
using GrammarAST = Antlr3.Tool.GrammarAST;
using GrammarType = Antlr3.Tool.GrammarType;
+    using IIntSet = Antlr3.Misc.IIntSet;
using IToken = Antlr.Runtime.IToken;
+    using Label = Antlr3.Analysis.Label;
using LabelType = Antlr3.Tool.LabelType;
using MismatchedTokenException = Antlr.Runtime.MismatchedTokenException;
using NoViableAltException = Antlr.Runtime.NoViableAltException;
using RecognitionException = Antlr.Runtime.RecognitionException;
using Rule = Antlr3.Tool.Rule;
using RuleType = Antlr3.Tool.RuleType;
-    using StringTemplate = Antlr4.StringTemplate.Template;
+    using Template = Antlr4.StringTemplate.Template;
using TemplateGroup = Antlr4.StringTemplate.TemplateGroup;

partial class CodeGenTreeWalker
@@ -61,7 +64,7 @@ namespace Antlr3.Grammars
protected int blockNestingLevel = 0;
protected int rewriteBlockNestingLevel = 0;
protected internal int outerAltNum = 0;
-        protected StringTemplate currentBlockST = null;
+        protected Template currentBlockST = null;
protected bool currentAltHasASTRewrite = false;
protected int rewriteTreeNestingLevel = 0;
protected HashSet<object> rewriteRuleRefs = null;
@@ -97,14 +100,14 @@ namespace Antlr3.Grammars
/** The overall lexer/parser template; simulate dynamically scoped
*  attributes by making this an instance var of the walker.
*/
-        protected StringTemplate recognizerST;
+        protected Template recognizerST;

-        protected StringTemplate outputFileST;
-        protected StringTemplate headerFileST;
+        protected Template outputFileST;
+        protected Template headerFileST;

protected string outputOption = "";

-        protected StringTemplate GetWildcardST( GrammarAST elementAST, GrammarAST ast_suffix, string label )
+        protected Template GetWildcardST( GrammarAST elementAST, GrammarAST ast_suffix, string label )
{
string name = "wildcard";
if ( grammar.type == GrammarType.Lexer )
@@ -114,7 +117,7 @@ namespace Antlr3.Grammars
return GetTokenElementST( name, name, elementAST, ast_suffix, label );
}

-        protected StringTemplate GetRuleElementST( string name,
+        protected Template GetRuleElementST( string name,
string ruleTargetName,
GrammarAST elementAST,
GrammarAST ast_suffix,
@@ -133,7 +136,7 @@ namespace Antlr3.Grammars
CommonToken labelTok = new CommonToken( ANTLRParser.ID, label );
grammar.DefineRuleRefLabel( currentRuleName, labelTok, elementAST );
}
-            StringTemplate elementST = templates.GetInstanceOf( name );
+            Template elementST = templates.GetInstanceOf( name );
if ( label != null )
{
elementST.SetAttribute( "label", label );
@@ -141,7 +144,7 @@ namespace Antlr3.Grammars
return elementST;
}

-        protected StringTemplate GetTokenElementST( string name,
+        protected Template GetTokenElementST( string name,
string elementName,
GrammarAST elementAST,
GrammarAST ast_suffix,
@@ -173,7 +176,7 @@ namespace Antlr3.Grammars
grammar.DefineTokenRefLabel( currentRuleName, labelTok, elementAST );
}

-            StringTemplate elementST = null;
+            Template elementST = null;
if ( tryUnchecked && templates.IsDefined( name + "Unchecked" + suffix ) )
elementST = templates.GetInstanceOf( name + "Unchecked" + suffix );
if ( elementST == null )
@@ -278,5 +281,879 @@ namespace Antlr3.Grammars
this.generator = grammar.CodeGenerator;
this.templates = generator.Templates;
}
+
+        private void HandleGrammarInit(Grammar g, Template recognizerST, Template outputFileST, Template headerFileST)
+        {
+            if (state.backtracking == 0)
+            {
+                Init(g);
+                this.recognizerST = recognizerST;
+                this.outputFileST = outputFileST;
+                this.headerFileST = headerFileST;
+                string superClass = (string)g.GetOption("superClass");
+                outputOption = (string)g.GetOption("output");
+                if (superClass != null)
+                    recognizerST.SetAttribute("superClass", superClass);
+
+                if (g.type != GrammarType.Lexer)
+                {
+                    object labelType = g.GetOption("ASTLabelType");
+                    if (labelType != null)
+                        recognizerST.SetAttribute("ASTLabelType", labelType);
+                }
+
+                if (g.type == GrammarType.TreeParser && g.GetOption("ASTLabelType") == null)
+                    ErrorManager.GrammarWarning(ErrorManager.MSG_MISSING_AST_TYPE_IN_TREE_GRAMMAR, g, null, g.name);
+
+                if (g.type != GrammarType.TreeParser)
+                {
+                    object labelType = g.GetOption("TokenLabelType");
+                    if (labelType != null)
+                        recognizerST.SetAttribute("labelType", labelType);
+                }
+
+                recognizerST.SetAttribute("numRules", grammar.Rules.Count);
+                outputFileST.SetAttribute("numRules", grammar.Rules.Count);
+                headerFileST.SetAttribute("numRules", grammar.Rules.Count);
+            }
+        }
+
+        private void HandleGrammarSpecAfterName(GrammarAST comment)
+        {
+            if (comment != null)
+            {
+                outputFileST.SetAttribute("docComment", comment.Text);
+                headerFileST.SetAttribute("docComment", comment.Text);
+            }
+
+            recognizerST.SetAttribute("name", grammar.GetRecognizerName());
+            outputFileST.SetAttribute("name", grammar.GetRecognizerName());
+            headerFileST.SetAttribute("name", grammar.GetRecognizerName());
+            recognizerST.SetAttribute("scopes", grammar.GlobalScopes);
+            headerFileST.SetAttribute("scopes", grammar.GlobalScopes);
+        }
+
+        private void HandleRulesInit(GrammarAST start, out string ruleName, out bool generated)
+        {
+            ruleName = start.GetChild(0).Text;
+            generated = grammar.GenerateMethodForRule(ruleName);
+        }
+
+        private void HandleRulesRule(Template ruleTemplate)
+        {
+            if (ruleTemplate != null)
+            {
+                recognizerST.SetAttribute("rules", ruleTemplate);
+                outputFileST.SetAttribute("rules", ruleTemplate);
+                headerFileST.SetAttribute("rules", ruleTemplate);
+            }
+        }
+
+        private void HandleRulesForcedAfterRule(ref string ruleName, ref bool generated)
+        {
+            if (input.LA(1) == RULE)
+            {
+                ruleName = ((GrammarAST)input.LT(1)).GetChild(0).Text;
+                //System.Diagnostics.Debug.Assert( ruleName == ((GrammarAST)input.LT(1)).enclosingRuleName );
+                generated = grammar.GenerateMethodForRule(ruleName);
+            }
+        }
+
+        private void HandleRuleInit(GrammarAST start, out string initAction, out GrammarAST block2, out Antlr3.Analysis.DFA dfa, out Rule ruleDescr, out string description)
+        {
+            initAction = null;
+            // get the dfa for the BLOCK
+            block2 = (GrammarAST)start.GetFirstChildWithType(BLOCK);
+            dfa = block2.LookaheadDFA;
+            // init blockNestingLevel so it's block level RULE_BLOCK_NESTING_LEVEL
+            // for alts of rule
+            blockNestingLevel = RULE_BLOCK_NESTING_LEVEL - 1;
+            ruleDescr = grammar.GetRule(start.GetChild(0).Text);
+            currentRuleName = start.GetChild(0).Text;
+            description = string.Empty;
+        }
+
+        private void HandleRuleAfterId(GrammarAST id)
+        {
+            System.Diagnostics.Debug.Assert(currentRuleName == id.Text);
+        }
+
+        private void HandleRuleAfterBlock(out Template code, GrammarAST start, GrammarAST block2, Rule ruleDescr, string description, Template blockCode)
+        {
+            description = grammar.GrammarTreeToString((GrammarAST)start.GetFirstChildWithType(BLOCK), false);
+            description = generator.Target.GetTargetStringLiteralFromString(description);
+            blockCode.SetAttribute("description", description);
+            // do not generate lexer rules in combined grammar
+            string stName = null;
+            if (ruleDescr.IsSynPred)
+            {
+                stName = "synpredRule";
+            }
+            else if (grammar.type == GrammarType.Lexer)
+            {
+                if (currentRuleName.Equals(Grammar.ArtificialTokensRuleName))
+                    stName = "tokensRule";
+                else
+                    stName = "lexerRule";
+            }
+            else
+            {
+                if (!(grammar.type == GrammarType.Combined && Rule.GetRuleType(currentRuleName) == RuleType.Lexer))
+                    stName = "rule";
+            }
+
+            code = templates.GetInstanceOf(stName);
+            if (code.Name.Equals("rule"))
+                code.SetAttribute("emptyRule", grammar.IsEmptyRule(block2));
+
+            code.SetAttribute("ruleDescriptor", ruleDescr);
+            string memo = (string)grammar.GetBlockOption(start, "memoize");
+            if (memo == null)
+                memo = (string)grammar.GetOption("memoize");
+
+            if (memo != null && memo.Equals("true") && (stName.Equals("rule") || stName.Equals("lexerRule")))
+                code.SetAttribute("memoize", memo != null && memo.Equals("true"));
+        }
+
+        private void HandleRuleEnd(Template code, GrammarAST start, string initAction, string description, GrammarAST modifier, Template blockCode)
+        {
+            if (code != null)
+            {
+                if (grammar.type == GrammarType.Lexer)
+                {
+                    bool naked =
+                        currentRuleName.Equals(Grammar.ArtificialTokensRuleName) ||
+                        (modifier != null && modifier.Text.Equals(Grammar.FragmentRuleModifier));
+                    code.SetAttribute("nakedBlock", naked);
+                }
+                else
+                {
+                    description = grammar.GrammarTreeToString(start, false);
+                    description = generator.Target.GetTargetStringLiteralFromString(description);
+                    code.SetAttribute("description", description);
+                }
+
+                Rule theRule = grammar.GetRule(currentRuleName);
+                generator.TranslateActionAttributeReferencesForSingleScope(theRule, theRule.Actions);
+                code.SetAttribute("ruleName", currentRuleName);
+                code.SetAttribute("block", blockCode);
+                if (initAction != null)
+                {
+                    code.SetAttribute("initAction", initAction);
+                }
+            }
+        }
+
+        private void HandleBlockInit(string blockTemplateName, Antlr3.Analysis.DFA dfa, ref Template code, out int altNum)
+        {
+            altNum = 0;
+            blockNestingLevel++;
+
+            if (state.backtracking == 0)
+            {
+                Template decision = null;
+                if (dfa != null)
+                {
+                    code = templates.GetInstanceOf(blockTemplateName);
+                    decision = generator.GenLookaheadDecision(recognizerST, dfa);
+                    code.SetAttribute("decision", decision);
+                    code.SetAttribute("decisionNumber", dfa.NfaStartStateDecisionNumber);
+                    code.SetAttribute("maxK", dfa.MaxLookaheadDepth);
+                    code.SetAttribute("maxAlt", dfa.NumberOfAlts);
+                }
+                else
+                {
+                    code = templates.GetInstanceOf(blockTemplateName + "SingleAlt");
+                }
+                code.SetAttribute("blockLevel", blockNestingLevel);
+                code.SetAttribute("enclosingBlockLevel", blockNestingLevel - 1);
+                altNum = 1;
+                if (this.blockNestingLevel == RULE_BLOCK_NESTING_LEVEL)
+                {
+                    this.outerAltNum = 1;
+                }
+            }
+        }
+
+        private void HandleBlockSetBlock(Template code, Template setBlockCode)
+        {
+            code.SetAttribute("alts", setBlockCode);
+        }
+
+        private void HandleBlockAlternative(Template code, ref int altNum, Template altCode, GrammarAST rewStart, Template rewCode)
+        {
+            if (this.blockNestingLevel == RULE_BLOCK_NESTING_LEVEL)
+            {
+                this.outerAltNum++;
+            }
+
+            // add the rewrite code as just another element in the alt :)
+            // (unless it's a " -> ..." rewrite
+            // ( -> ... )
+            GrammarAST firstRewriteAST = (GrammarAST)rewStart.FindFirstType(REWRITE);
+            bool etc =
+                rewStart.Type == REWRITES &&
+                firstRewriteAST.GetChild(0) != null &&
+                firstRewriteAST.GetChild(0).Type == ETC;
+
+            if (rewCode != null && !etc)
+            {
+                altCode.SetAttribute("rew", rewCode);
+            }
+
+            // add this alt to the list of alts for this block
+            code.SetAttribute("alts", altCode);
+            altCode.SetAttribute("altNum", altNum);
+            altCode.SetAttribute("outerAlt", blockNestingLevel == RULE_BLOCK_NESTING_LEVEL);
+            altNum++;
+        }
+
+        private void HandleSetBlock(out Template code, GrammarAST start, GrammarAST s)
+        {
+            if (blockNestingLevel == RULE_BLOCK_NESTING_LEVEL && grammar.BuildAST)
+            {
+                Rule r = grammar.GetRule(currentRuleName);
+                currentAltHasASTRewrite = r.HasRewrite(outerAltNum);
+                if (currentAltHasASTRewrite)
+                    r.TrackTokenReferenceInAlt(start, outerAltNum);
+            }
+
+            Template setcode;
+            int i = s.Token.TokenIndex;
+            if (blockNestingLevel == RULE_BLOCK_NESTING_LEVEL)
+                setcode = GetTokenElementST("matchRuleBlockSet", "set", s, null, null);
+            else
+                setcode = GetTokenElementST("matchSet", "set", s, null, null);
+
+            setcode.SetAttribute("elementIndex", i);
+            //if ( grammar.type!=GrammarType.Lexer )
+            //{
+            //	generator.GenerateLocalFollow($s,"set",currentRuleName,i);
+            //}
+
+            setcode.SetAttribute("s", generator.GenSetExpr(templates, s.SetValue, 1, false));
+            Template altcode = templates.GetInstanceOf("alt");
+            altcode.SetAttribute("elements.{el,line,pos}", setcode, s.Line, s.CharPositionInLine + 1);
+            altcode.SetAttribute("altNum", 1);
+            altcode.SetAttribute("outerAlt", blockNestingLevel == RULE_BLOCK_NESTING_LEVEL);
+            if (!currentAltHasASTRewrite && grammar.BuildAST)
+                altcode.SetAttribute("autoAST", true);
+
+            altcode.SetAttribute("treeLevel", rewriteTreeNestingLevel);
+            code = altcode;
+        }
+
+        private void HandleBlockFinally()
+        {
+            blockNestingLevel--;
+        }
+
+        private void HandleExceptionHandler(Template ruleTemplate, GrammarAST argAction, GrammarAST action)
+        {
+            IList<object> chunks = generator.TranslateAction(currentRuleName, action);
+            ruleTemplate.SetAttribute("exceptions.{decl,action}", argAction.Text, chunks);
+        }
+
+        private void HandleFinallyClause(Template ruleTemplate, GrammarAST action)
+        {
+            IList<object> chunks = generator.TranslateAction(currentRuleName, action);
+            ruleTemplate.SetAttribute("finally", chunks);
+        }
+
+        private void HandleAlternativeInit(out Template code, GrammarAST start)
+        {
+            code = null;
+            if (state.backtracking == 0)
+            {
+                code = templates.GetInstanceOf("alt");
+                if (blockNestingLevel == RULE_BLOCK_NESTING_LEVEL && grammar.BuildAST)
+                {
+                    Rule r = grammar.GetRule(currentRuleName);
+                    currentAltHasASTRewrite = r.HasRewrite(outerAltNum);
+                }
+
+                string description = grammar.GrammarTreeToString(start, false);
+                description = generator.Target.GetTargetStringLiteralFromString(description);
+                code.SetAttribute("description", description);
+                code.SetAttribute("treeLevel", rewriteTreeNestingLevel);
+                if (!currentAltHasASTRewrite && grammar.BuildAST)
+                {
+                    code.SetAttribute("autoAST", true);
+                }
+            }
+        }
+
+        private void HandleAlternativeElement(Template code, GrammarAST elementStart, Template elementCode)
+        {
+            if (elementStart != null && elementCode != null)
+            {
+                code.SetAttribute("elements.{el,line,pos}", elementCode, elementStart.Line, elementStart.CharPositionInLine + 1);
+            }
+        }
+
+        private void HandleElementCharRange(GrammarAST label, out Template code, GrammarAST a, GrammarAST b)
+        {
+            code = templates.GetInstanceOf("charRangeRef");
+            string low = generator.Target.GetTargetCharLiteralFromANTLRCharLiteral(generator, a.Text);
+            string high = generator.Target.GetTargetCharLiteralFromANTLRCharLiteral(generator, b.Text);
+            code.SetAttribute("a", low);
+            code.SetAttribute("b", high);
+            if (label != null)
+                code.SetAttribute("label", label.Text);
+        }
+
+        private void HandleElementSemanticPredicate(out Template code, GrammarAST sp)
+        {
+            code = templates.GetInstanceOf("validateSemanticPredicate");
+            code.SetAttribute("pred", generator.TranslateAction(currentRuleName, sp));
+            string description = generator.Target.GetTargetStringLiteralFromString(sp.Text);
+            code.SetAttribute("description", description);
+        }
+
+        private void HandleElementAction(out Template code, GrammarAST action, bool forced)
+        {
+            code = templates.GetInstanceOf(forced ? "execForcedAction" : "execAction");
+            code.SetAttribute("action", generator.TranslateAction(currentRuleName, action));
+        }
+
+        private void HandleNotElementCharLiteral(out IIntSet elements, GrammarAST assign_c)
+        {
+            int ttype = 0;
+            if (grammar.type == GrammarType.Lexer)
+                ttype = Grammar.GetCharValueFromGrammarCharLiteral(assign_c.Text);
+            else
+                ttype = grammar.GetTokenType(assign_c.Text);
+
+            elements = grammar.Complement(ttype);
+        }
+
+        private void HandleNotElementStringLiteral(out IIntSet elements, GrammarAST assign_s)
+        {
+            int ttype = 0;
+            if (grammar.type == GrammarType.Lexer)
+            {
+                // TODO: error!
+            }
+            else
+            {
+                ttype = grammar.GetTokenType(assign_s.Text);
+            }
+
+            elements = grammar.Complement(ttype);
+        }
+
+        private void HandleNotElementTokenReference(out IIntSet elements, GrammarAST assign_t)
+        {
+            int ttype = grammar.GetTokenType(assign_t.Text);
+            elements = grammar.Complement(ttype);
+        }
+
+        private void HandleNotElementBlock(out IIntSet elements, GrammarAST assign_st)
+        {
+            elements = assign_st.SetValue;
+            elements = grammar.Complement(elements);
+        }
+
+        private void HandleNotElementEnd(GrammarAST n, GrammarAST label, GrammarAST astSuffix, out Template code, IIntSet elements, GrammarAST start)
+        {
+            if (n.GetChild(0) != start)
+                throw new System.InvalidOperationException();
+
+            string labelText = null;
+            if (label != null)
+                labelText = label.Text;
+
+            code = GetTokenElementST("matchSet", "set", (GrammarAST)n.GetChild(0), astSuffix, labelText);
+            code.SetAttribute("s", generator.GenSetExpr(templates, elements, 1, false));
+            int i = n.Token.TokenIndex;
+            code.SetAttribute("elementIndex", i);
+            if (grammar.type != GrammarType.Lexer)
+                generator.GenerateLocalFollow(n, "set", currentRuleName, i);
+        }
+
+        private void HandleAtomInit(GrammarAST start, GrammarAST label, ref GrammarAST astSuffix, out string labelText)
+        {
+            labelText = null;
+            if (state.backtracking == 0)
+            {
+                if (label != null)
+                    labelText = label.Text;
+
+                if (grammar.type != GrammarType.Lexer)
+                {
+                    switch (start.Type)
+                    {
+                    case RULE_REF:
+                    case TOKEN_REF:
+                    case CHAR_LITERAL:
+                    case STRING_LITERAL:
+                        Rule encRule = grammar.GetRule(start.enclosingRuleName);
+                        if (encRule != null && encRule.HasRewrite(outerAltNum) && astSuffix != null)
+                        {
+                            ErrorManager.GrammarError(ErrorManager.MSG_AST_OP_IN_ALT_WITH_REWRITE, grammar, start.Token, start.enclosingRuleName, outerAltNum);
+                            astSuffix = null;
+                        }
+
+                        break;
+
+                    default:
+                        break;
+                    }
+                }
+            }
+        }
+
+        private void HandleAtomRuleReference(GrammarAST scope, GrammarAST label, GrammarAST astSuffix, out Template code, string labelText, GrammarAST r, GrammarAST rarg)
+        {
+            grammar.CheckRuleReference(scope, r, rarg, currentRuleName);
+            string scopeName = null;
+            if (scope != null)
+            {
+                scopeName = scope.Text;
+            }
+
+            Rule rdef = grammar.GetRule(scopeName, r.Text);
+            // don't insert label=r() if $label.attr not used, no ret value, ...
+            if (!rdef.HasReturnValue)
+            {
+                labelText = null;
+            }
+
+            code = GetRuleElementST("ruleRef", r.Text, r, astSuffix, labelText);
+            code.SetAttribute("rule", rdef);
+            if (scope != null)
+            {
+                // scoped rule ref
+                Grammar scopeG = grammar.composite.GetGrammar(scope.Text);
+                code.SetAttribute("scope", scopeG);
+            }
+            else if (rdef.Grammar != this.grammar)
+            {
+                // nonlocal
+                // if rule definition is not in this grammar, it's nonlocal
+                IList<Grammar> rdefDelegates = rdef.Grammar.GetDelegates();
+                if (rdefDelegates.Contains(this.grammar))
+                {
+                    code.SetAttribute("scope", rdef.Grammar);
+                }
+                else
+                {
+                    // defining grammar is not a delegate, scope all the
+                    // back to root, which has delegate methods for all
+                    // rules.  Don't use scope if we are root.
+                    if (this.grammar != rdef.Grammar.composite.DelegateGrammarTreeRoot.Grammar)
+                    {
+                        code.SetAttribute("scope",
+                                          rdef.Grammar.composite.DelegateGrammarTreeRoot.Grammar);
+                    }
+                }
+            }
+
+            if (rarg != null)
+            {
+                IList<object> args = generator.TranslateAction(currentRuleName, rarg);
+                code.SetAttribute("args", args);
+            }
+            int i = r.Token.TokenIndex;
+            code.SetAttribute("elementIndex", i);
+            generator.GenerateLocalFollow(r, r.Text, currentRuleName, i);
+            r.code = code;
+        }
+
+        private void HandleAtomTokenReference(GrammarAST scope, GrammarAST label, GrammarAST astSuffix, out Template code, string labelText, GrammarAST t, GrammarAST targ)
+        {
+            if (currentAltHasASTRewrite && t.terminalOptions != null && t.terminalOptions[Grammar.defaultTokenOption] != null)
+            {
+                ErrorManager.GrammarError(ErrorManager.MSG_HETERO_ILLEGAL_IN_REWRITE_ALT, grammar, t.Token, t.Text);
+            }
+
+            grammar.CheckRuleReference(scope, t, targ, currentRuleName);
+            if (grammar.type == GrammarType.Lexer)
+            {
+                if (grammar.GetTokenType(t.Text) == Label.EOF)
+                {
+                    code = templates.GetInstanceOf("lexerMatchEOF");
+                }
+                else
+                {
+                    code = templates.GetInstanceOf("lexerRuleRef");
+                    if (IsListLabel(labelText))
+                        code = templates.GetInstanceOf("lexerRuleRefAndListLabel");
+
+                    string scopeName = null;
+                    if (scope != null)
+                        scopeName = scope.Text;
+
+                    Rule rdef2 = grammar.GetRule(scopeName, t.Text);
+                    code.SetAttribute("rule", rdef2);
+                    if (scope != null)
+                    {
+                        // scoped rule ref
+                        Grammar scopeG = grammar.composite.GetGrammar(scope.Text);
+                        code.SetAttribute("scope", scopeG);
+                    }
+                    else if (rdef2.Grammar != this.grammar)
+                    {
+                        // nonlocal
+                        // if rule definition is not in this grammar, it's nonlocal
+                        code.SetAttribute("scope", rdef2.Grammar);
+                    }
+
+                    if (targ != null)
+                    {
+                        IList<object> args = generator.TranslateAction(currentRuleName, targ);
+                        code.SetAttribute("args", args);
+                    }
+                }
+
+                int i = t.Token.TokenIndex;
+                code.SetAttribute("elementIndex", i);
+                if (label != null)
+                    code.SetAttribute("label", labelText);
+            }
+            else
+            {
+                code = GetTokenElementST("tokenRef", t.Text, t, astSuffix, labelText);
+                string tokenLabel = generator.GetTokenTypeAsTargetLabel(grammar.GetTokenType(t.Text));
+                code.SetAttribute("token", tokenLabel);
+                if (!currentAltHasASTRewrite && t.terminalOptions != null)
+                    code.SetAttribute("terminalOptions", t.terminalOptions);
+
+                int i = t.Token.TokenIndex;
+                code.SetAttribute("elementIndex", i);
+                generator.GenerateLocalFollow(t, tokenLabel, currentRuleName, i);
+            }
+
+            t.code = code;
+        }
+
+        private void HandleAtomCharLiteral(GrammarAST label, GrammarAST astSuffix, out Template code, string labelText, GrammarAST c)
+        {
+            if (grammar.type == GrammarType.Lexer)
+            {
+                code = templates.GetInstanceOf("charRef");
+                code.SetAttribute("char", generator.Target.GetTargetCharLiteralFromANTLRCharLiteral(generator, c.Text));
+                if (label != null)
+                    code.SetAttribute("label", labelText);
+            }
+            else
+            {
+                // else it's a token type reference
+                code = GetTokenElementST("tokenRef", "char_literal", c, astSuffix, labelText);
+                string tokenLabel = generator.GetTokenTypeAsTargetLabel(grammar.GetTokenType(c.Text));
+                code.SetAttribute("token", tokenLabel);
+                if (c.terminalOptions != null)
+                    code.SetAttribute("terminalOptions", c.terminalOptions);
+
+                int i = c.Token.TokenIndex;
+                code.SetAttribute("elementIndex", i);
+                generator.GenerateLocalFollow(c, tokenLabel, currentRuleName, i);
+            }
+        }
+
+        private void HandleAtomStringLiteral(GrammarAST label, GrammarAST astSuffix, out Template code, string labelText, GrammarAST s)
+        {
+            int i = s.Token.TokenIndex;
+            if (grammar.type == GrammarType.Lexer)
+            {
+                code = templates.GetInstanceOf("lexerStringRef");
+                code.SetAttribute("string",
+                    generator.Target.GetTargetStringLiteralFromANTLRStringLiteral(generator, s.Text));
+                code.SetAttribute("elementIndex", i);
+                if (label != null)
+                    code.SetAttribute("label", labelText);
+            }
+            else
+            {
+                // else it's a token type reference
+                code = GetTokenElementST("tokenRef", "string_literal", s, astSuffix, labelText);
+                string tokenLabel =
+                    generator.GetTokenTypeAsTargetLabel(grammar.GetTokenType(s.Text));
+                code.SetAttribute("token", tokenLabel);
+                if (s.terminalOptions != null)
+                {
+                    code.SetAttribute("terminalOptions", s.terminalOptions);
+                }
+                code.SetAttribute("elementIndex", i);
+                generator.GenerateLocalFollow(s, tokenLabel, currentRuleName, i);
+            }
+        }
+
+        private void HandleAtomWildcard(GrammarAST astSuffix, out Template code, string labelText, GrammarAST w)
+        {
+            code = GetWildcardST(w, astSuffix, labelText);
+            code.SetAttribute("elementIndex", w.Token.TokenIndex);
+        }
+
+        private void HandleSet(GrammarAST label, GrammarAST astSuffix, out Template code, GrammarAST s)
+        {
+            string labelText = null;
+            if (label != null)
+                labelText = label.Text;
+
+            code = GetTokenElementST("matchSet", "set", s, astSuffix, labelText);
+            int i = s.Token.TokenIndex;
+            code.SetAttribute("elementIndex", i);
+            if (grammar.type != GrammarType.Lexer)
+                generator.GenerateLocalFollow(s, "set", currentRuleName, i);
+
+            code.SetAttribute("s", generator.GenSetExpr(templates, s.SetValue, 1, false));
+        }
+
+        private void HandleRewriteInit(out Template code, GrammarAST start)
+        {
+            code = null;
+
+            if (state.backtracking == 0)
+            {
+                if (start.Type == REWRITES)
+                {
+                    if (generator.Grammar.BuildTemplate)
+                    {
+                        code = templates.GetInstanceOf("rewriteTemplate");
+                    }
+                    else
+                    {
+                        code = templates.GetInstanceOf("rewriteCode");
+                        code.SetAttribute("treeLevel", OUTER_REWRITE_NESTING_LEVEL);
+                        code.SetAttribute("rewriteBlockLevel", OUTER_REWRITE_NESTING_LEVEL);
+                        code.SetAttribute("referencedElementsDeep", GetTokenTypesAsTargetLabels(start.rewriteRefsDeep));
+                        HashSet<string> tokenLabels = grammar.GetLabels(start.rewriteRefsDeep, LabelType.Token);
+                        HashSet<string> tokenListLabels = grammar.GetLabels(start.rewriteRefsDeep, LabelType.TokenList);
+                        HashSet<string> ruleLabels = grammar.GetLabels(start.rewriteRefsDeep, LabelType.Rule);
+                        HashSet<string> ruleListLabels = grammar.GetLabels(start.rewriteRefsDeep, LabelType.RuleList);
+                        HashSet<string> wildcardLabels = grammar.GetLabels(start.rewriteRefsDeep, LabelType.WildcardTree);
+                        HashSet<string> wildcardListLabels = grammar.GetLabels(start.rewriteRefsDeep, LabelType.WildcardTreeList);
+                        // just in case they ref $r for "previous value", make a stream
+                        // from retval.tree
+                        Template retvalST = templates.GetInstanceOf("prevRuleRootRef");
+                        ruleLabels.Add(retvalST.Render());
+                        code.SetAttribute("referencedTokenLabels", tokenLabels);
+                        code.SetAttribute("referencedTokenListLabels", tokenListLabels);
+                        code.SetAttribute("referencedRuleLabels", ruleLabels);
+                        code.SetAttribute("referencedRuleListLabels", ruleListLabels);
+                        code.SetAttribute("referencedWildcardLabels", wildcardLabels);
+                        code.SetAttribute("referencedWildcardListLabels", wildcardListLabels);
+                    }
+                }
+                else
+                {
+                    code = templates.GetInstanceOf("noRewrite");
+                    code.SetAttribute("treeLevel", OUTER_REWRITE_NESTING_LEVEL);
+                    code.SetAttribute("rewriteBlockLevel", OUTER_REWRITE_NESTING_LEVEL);
+                }
+            }
+        }
+
+        private void HandleRewriteBeforeRewrite()
+        {
+            rewriteRuleRefs = new HashSet<object>();
+        }
+
+        private void HandleRewriteAfterRewrite(Template code, GrammarAST r, ref GrammarAST pred, Template alt)
+        {
+            rewriteBlockNestingLevel = OUTER_REWRITE_NESTING_LEVEL;
+            IList<object> predChunks = null;
+            if (pred != null)
+                predChunks = generator.TranslateAction(currentRuleName, pred);
+
+            string description = grammar.GrammarTreeToString(r, false);
+            description = generator.Target.GetTargetStringLiteralFromString(description);
+            code.SetAttribute("alts.{pred,alt,description}", predChunks, alt, description);
+            pred = null;
+        }
+
+        private void HandleRewriteEbnf(out Template code, GrammarAST start, Template rewriteBlockCode)
+        {
+            code = rewriteBlockCode;
+            string description = grammar.GrammarTreeToString(start, false);
+            description = generator.Target.GetTargetStringLiteralFromString(description);
+            code.SetAttribute("description", description);
+        }
+
+        private void HandleRewriteAtomRuleReference(bool isRoot, out Template code, GrammarAST r)
+        {
+            string ruleRefName = r.Text;
+            string stName = "rewriteRuleRef";
+            if (isRoot)
+                stName += "Root";
+
+            code = templates.GetInstanceOf(stName);
+            code.SetAttribute("rule", ruleRefName);
+            if (grammar.GetRule(ruleRefName) == null)
+            {
+                ErrorManager.GrammarError(ErrorManager.MSG_UNDEFINED_RULE_REF, grammar, r.Token, ruleRefName);
+                // blank; no code gen
+                code = new Template(string.Empty);
+            }
+            else if (grammar.GetRule(currentRuleName).GetRuleRefsInAlt(ruleRefName, outerAltNum) == null)
+            {
+                ErrorManager.GrammarError(ErrorManager.MSG_REWRITE_ELEMENT_NOT_PRESENT_ON_LHS, grammar, r.Token, ruleRefName);
+                // blank; no code gen
+                code = new Template(string.Empty);
+            }
+            else
+            {
+                // track all rule refs as we must copy 2nd ref to rule and beyond
+                if (!rewriteRuleRefs.Contains(ruleRefName))
+                    rewriteRuleRefs.Add(ruleRefName);
+            }
+        }
+
+        private void HandleRewriteAtomTokenReference(bool isRoot, out Template code, GrammarAST start, GrammarAST term, GrammarAST arg)
+        {
+            string tokenName = start.Token.Text;
+            string stName = "rewriteTokenRef";
+            Rule rule = grammar.GetRule(currentRuleName);
+            ICollection<string> tokenRefsInAlt = rule.GetTokenRefsInAlt(outerAltNum);
+            bool createNewNode = !tokenRefsInAlt.Contains(tokenName) || arg != null;
+            if (createNewNode)
+                stName = "rewriteImaginaryTokenRef";
+
+            if (isRoot)
+                stName += "Root";
+
+            code = templates.GetInstanceOf(stName);
+            code.SetAttribute("terminalOptions", term.terminalOptions);
+            if (arg != null)
+            {
+                IList<object> args = generator.TranslateAction(currentRuleName, arg);
+                code.SetAttribute("args", args);
+            }
+
+            code.SetAttribute("elementIndex", start.Token.TokenIndex);
+            int ttype = grammar.GetTokenType(tokenName);
+            string tok = generator.GetTokenTypeAsTargetLabel(ttype);
+            code.SetAttribute("token", tok);
+            if (grammar.GetTokenType(tokenName) == Label.INVALID)
+            {
+                ErrorManager.GrammarError(ErrorManager.MSG_UNDEFINED_TOKEN_REF_IN_REWRITE, grammar, start.Token, tokenName);
+                // blank; no code gen
+                code = new Template(string.Empty);
+            }
+        }
+
+        private void HandleRewriteAtomLabel(bool isRoot, out Template code, GrammarAST label)
+        {
+            string labelName = label.Text;
+            Rule rule = grammar.GetRule(currentRuleName);
+            Grammar.LabelElementPair pair = rule.GetLabel(labelName);
+            if (labelName.Equals(currentRuleName))
+            {
+                // special case; ref to old value via $ rule
+                if (rule.HasRewrite(outerAltNum) && rule.GetRuleRefsInAlt(outerAltNum).Contains(labelName))
+                    ErrorManager.GrammarError(ErrorManager.MSG_RULE_REF_AMBIG_WITH_RULE_IN_ALT, grammar, label.Token, labelName);
+
+                Template labelST = templates.GetInstanceOf("prevRuleRootRef");
+                code = templates.GetInstanceOf("rewriteRuleLabelRef" + (isRoot ? "Root" : ""));
+                code.SetAttribute("label", labelST);
+            }
+            else if (pair == null)
+            {
+                ErrorManager.GrammarError(ErrorManager.MSG_UNDEFINED_LABEL_REF_IN_REWRITE, grammar, label.Token, labelName);
+                code = new Template(string.Empty);
+            }
+            else
+            {
+                string stName = null;
+                switch (pair.type)
+                {
+                case LabelType.Token:
+                    stName = "rewriteTokenLabelRef";
+                    break;
+
+                case LabelType.WildcardTree:
+                    stName = "rewriteWildcardLabelRef";
+                    break;
+
+                case LabelType.WildcardTreeList:
+                    stName = "rewriteRuleListLabelRef"; // acts like rule ref list for ref
+                    break;
+
+                case LabelType.Rule:
+                    stName = "rewriteRuleLabelRef";
+                    break;
+
+                case LabelType.TokenList:
+                    stName = "rewriteTokenListLabelRef";
+                    break;
+
+                case LabelType.RuleList:
+                    stName = "rewriteRuleListLabelRef";
+                    break;
+                }
+
+                if (isRoot)
+                    stName += "Root";
+
+                code = templates.GetInstanceOf(stName);
+                code.SetAttribute("label", labelName);
+            }
+        }
+
+        private void HandleRewriteAtomAction(bool isRoot, out Template code, GrammarAST action)
+        {
+            // actions in rewrite rules yield a tree object
+            string actText = action.Text;
+            IList<object> chunks = generator.TranslateAction(currentRuleName, action);
+            code = templates.GetInstanceOf("rewriteNodeAction" + (isRoot ? "Root" : ""));
+            code.SetAttribute("action", chunks);
+        }
+
+        private void HandleRewriteTemplateAlt(out Template code)
+        {
+            code = templates.GetInstanceOf("rewriteEmptyTemplate");
+        }
+
+        private void HandleRewriteTemplateAfterId(out Template code, GrammarAST id, GrammarAST ind)
+        {
+            if (id != null && id.Text.Equals("template"))
+            {
+                code = templates.GetInstanceOf("rewriteInlineTemplate");
+            }
+            else if (id != null)
+            {
+                code = templates.GetInstanceOf("rewriteExternalTemplate");
+                code.SetAttribute("name", id.Text);
+            }
+            else if (ind != null)
+            {
+                // must be \%({expr})(args)
+                code = templates.GetInstanceOf("rewriteIndirectTemplate");
+                IList<object> chunks = generator.TranslateAction(currentRuleName, ind);
+                code.SetAttribute("expr", chunks);
+            }
+            else
+            {
+                throw new ArgumentException();
+            }
+        }
+
+        private void HandleRewriteTemplateArg(Template code, GrammarAST arg, GrammarAST action)
+        {
+            // must set alt num here rather than in define.g
+            // because actions like \%foo(name={\$ID.text}) aren't
+            // broken up yet into trees.
+            action.outerAltNum = this.outerAltNum;
+            IList<object> chunks = generator.TranslateAction(currentRuleName, action);
+            code.SetAttribute("args.{name,value}", arg.Text, chunks);
+        }
+
+        private void HandleRewriteTemplateLiteral(Template code, GrammarAST literal, int delimiterWidth)
+        {
+            string sl = literal.Text;
+            // strip quotes
+            string t = sl.Substring(delimiterWidth, sl.Length - 2 * delimiterWidth);
+            t = generator.Target.GetTargetStringLiteralFromString(t);
+            code.SetAttribute("template", t);
+        }
+
+        private void HandleRewriteTemplateAction(out Template code, GrammarAST action)
+        {
+            // set alt num for same reason as ARGLIST above
+            action.outerAltNum = this.outerAltNum;
+            code = templates.GetInstanceOf("rewriteAction");
+            code.SetAttribute("action", generator.TranslateAction(currentRuleName, action));
+        }
}
}

