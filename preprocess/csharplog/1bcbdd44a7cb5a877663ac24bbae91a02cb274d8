commit 1bcbdd44a7cb5a877663ac24bbae91a02cb274d8
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Thu Aug 4 11:06:33 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Thu Aug 4 11:06:33 2011 -0800

(C# 3) Updated build script and bootstrap binaries

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 8997]

diff --git a/bin/Bootstrap/Antlr3.Runtime.Debug.dll b/bin/Bootstrap/Antlr3.Runtime.Debug.dll
index b10315d..f893f5c 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.Debug.dll and b/bin/Bootstrap/Antlr3.Runtime.Debug.dll differ
diff --git a/bin/Bootstrap/Antlr3.Runtime.JavaExtensions.dll b/bin/Bootstrap/Antlr3.Runtime.JavaExtensions.dll
index 5f287d3..6c71bb4 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.JavaExtensions.dll and b/bin/Bootstrap/Antlr3.Runtime.JavaExtensions.dll differ
diff --git a/bin/Bootstrap/Antlr3.Runtime.dll b/bin/Bootstrap/Antlr3.Runtime.dll
index c18161d..8180652 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.dll and b/bin/Bootstrap/Antlr3.Runtime.dll differ
diff --git a/bin/Bootstrap/Antlr3.exe b/bin/Bootstrap/Antlr3.exe
index c2effc3..6b32fd5 100755
Binary files a/bin/Bootstrap/Antlr3.exe and b/bin/Bootstrap/Antlr3.exe differ
diff --git a/bin/Bootstrap/Antlr3.targets b/bin/Bootstrap/Antlr3.targets
index b57c5e0..3a440da 100644
--- a/bin/Bootstrap/Antlr3.targets
+++ b/bin/Bootstrap/Antlr3.targets
@@ -81,6 +81,7 @@
<ItemGroup Condition="'$(BuildingInsideVisualStudio)'=='true'">
<AvailableItemName Include="Antlr3" />
<AvailableItemName Include="AntlrTokens" />
+    <AvailableItemName Include="AntlrAbstractGrammar" />
</ItemGroup>

<Target Name="AntlrCompileReadGeneratedFileList">
@@ -107,7 +108,7 @@
<Target Name="AntlrCompile"
DependsOnTargets="$(AntlrCompileDependsOn)"
Condition="'@(Antlr3)' != ''"
-          Inputs="@(Antlr3);@(AntlrTokens)"
+          Inputs="@(Antlr3);@(AntlrTokens);@(AntlrAbstractGrammar)"
Outputs="@(AntlrOutputCodeFilesList);
$(IntermediateOutputPath)$(AntlrGenCodeFileNames);">

@@ -126,7 +127,8 @@
Language="$(Language)"
SourceCodeFiles="@(Antlr3)"
ContinueOnError="$(_IntellisenseOnlyCompile)"
-      TokensFiles="@(AntlrTokens)">
+      TokensFiles="@(AntlrTokens)"
+      AbstractGrammarFiles="@(AntlrAbstractGrammar)">

<Output ItemName="AntlrGeneratedCodeFiles" TaskParameter="GeneratedCodeFiles" />
<Output ItemName="Compile" TaskParameter="GeneratedCodeFiles" />
diff --git a/bin/Bootstrap/Antlr4.StringTemplate.Visualizer.dll b/bin/Bootstrap/Antlr4.StringTemplate.Visualizer.dll
index 522565e..ec72842 100644
Binary files a/bin/Bootstrap/Antlr4.StringTemplate.Visualizer.dll and b/bin/Bootstrap/Antlr4.StringTemplate.Visualizer.dll differ
diff --git a/bin/Bootstrap/Antlr4.StringTemplate.dll b/bin/Bootstrap/Antlr4.StringTemplate.dll
index 82f95f8..8a4198d 100644
Binary files a/bin/Bootstrap/Antlr4.StringTemplate.dll and b/bin/Bootstrap/Antlr4.StringTemplate.dll differ
diff --git a/bin/Bootstrap/AntlrBuildTask.dll b/bin/Bootstrap/AntlrBuildTask.dll
index 591bd65..f0f5682 100644
Binary files a/bin/Bootstrap/AntlrBuildTask.dll and b/bin/Bootstrap/AntlrBuildTask.dll differ
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp2/AST.stg b/bin/Bootstrap/Codegen/Templates/CSharp2/AST.stg
index 35fdebd..a898b69 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp2/AST.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp2/AST.stg
@@ -196,10 +196,8 @@ root_0 = (<ASTLabelType>)adaptor.Nil();
<! if tree parser and rewrite=true !>
<if(TREE_PARSER&&rewriteMode)>
<prevRuleRootRef()>.Tree = (<ASTLabelType>)adaptor.RulePostProcessing(root_0);
-input.ReplaceChildren(adaptor.GetParent(retval.Start),
-                      adaptor.GetChildIndex(retval.Start),
-                      adaptor.GetChildIndex(_last),
-                      retval.Tree);
+if (<prevRuleRootRef()>.Tree != null)
+	input.ReplaceChildren(adaptor.GetParent(retval.Start), adaptor.GetChildIndex(retval.Start), adaptor.GetChildIndex(_last), retval.Tree);
<endif>
<! if parser or tree-parser && rewrite!=true, we need to set result !>
<if(!TREE_PARSER||!rewriteMode)>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp2/ASTTreeParser.stg b/bin/Bootstrap/Codegen/Templates/CSharp2/ASTTreeParser.stg
index d749fa6..fc6df64 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp2/ASTTreeParser.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp2/ASTTreeParser.stg
@@ -44,14 +44,17 @@
/** Add a variable to track last element matched */
ruleDeclarations() ::= <<
<super.ruleDeclarations()>
+<if(!ruleDescriptor.isSynPred)>
<ASTLabelType> _first_0 = default(<ASTLabelType>);
-<ASTLabelType> _last = default(<ASTLabelType>);<\n>
+<ASTLabelType> _last = default(<ASTLabelType>);
+<endif>
>>

/** What to emit when there is no rewrite rule.  For auto build
*  mode, does nothing.
*/
noRewrite(rewriteBlockLevel, treeLevel) ::= <<
+<if(!ruleDescriptor.isSynPred)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<if(rewriteMode)>
retval.Tree = (<ASTLabelType>)_first_0;
@@ -59,6 +62,7 @@ if (adaptor.GetParent(retval.Tree)!=null && adaptor.IsNil(adaptor.GetParent(retv
retval.Tree = (<ASTLabelType>)adaptor.GetParent(retval.Tree);
<endif>
<if(backtracking)>}<endif>
+<endif>
>>

/** match ^(root children) in tree parser; override here to
@@ -66,6 +70,7 @@ if (adaptor.GetParent(retval.Tree)!=null && adaptor.IsNil(adaptor.GetParent(retv
*/
tree(root, actionsAfterRoot, children, nullableChildList,
enclosingTreeLevel, treeLevel) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
{
<ASTLabelType> _save_last_<treeLevel> = _last;
@@ -98,7 +103,10 @@ Match(input, TokenTypes.Up, null); <checkRuleBacktrackFailure()>
adaptor.AddChild(root_<enclosingTreeLevel>, root_<treeLevel>);
<endif>
_last = _save_last_<treeLevel>;
-}<\n>
+}
+<else>
+<super.tree(...)>
+<endif>
>>

// TOKEN AST STUFF
@@ -107,12 +115,17 @@ _last = _save_last_<treeLevel>;
*  setting of _last
*/
tokenRefBang(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.tokenRef(...)>
+<else>
+<super.tokenRefBang(...)>
+<endif>
>>

/** ID auto construct */
tokenRef(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.tokenRef(...)>
<if(!rewriteMode)>
@@ -128,16 +141,24 @@ adaptor.AddChild(root_<treeLevel>, <label>_tree);
<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
if (_first_<treeLevel> == null) _first_<treeLevel> = <label>;
<endif>
+<else>
+<super.tokenRef(...)>
+<endif>
>>

/** label+=TOKEN auto construct */
tokenRefAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
<tokenRef(...)>
<listLabelElem(elem=label,...)>
+<else>
+<super.tokenRefAndListLabel(...)>
+<endif>
>>

/** ^(ID ...) auto construct */
tokenRefRuleRoot(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.tokenRef(...)>
<if(!rewriteMode)>
@@ -150,16 +171,24 @@ _last = (<ASTLabelType>)input.LT(1);
root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_<treeLevel>);
<if(backtracking)>}<endif>
<endif>
+<else>
+<super.tokenRefRuleRoot(...)>
+<endif>
>>

/** Match ^(label+=TOKEN ...) auto construct */
tokenRefRuleRootAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
<tokenRefRuleRoot(...)>
<listLabelElem(elem=label,...)>
+<else>
+<super.tokenRefRuleRootAndListLabel(...)>
+<endif>
>>

/** Match . wildcard and auto dup the node/subtree */
wildcard(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.wildcard(...)>
<if(!rewriteMode)>
@@ -171,11 +200,15 @@ adaptor.AddChild(root_<treeLevel>, <label>_tree);
<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
if (_first_<treeLevel> == null) _first_<treeLevel> = <label>;
<endif>
+<else>
+<super.wildcard(...)>
+<endif>
>>

// SET AST

matchSet(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.matchSet(postmatchCode={
<if(!rewriteMode)>
@@ -190,19 +223,31 @@ adaptor.AddChild(root_<treeLevel>, <label>_tree);
<endif>
}, ...
)>
+<else>
+<super.matchSet(...)>
+<endif>
>>

matchRuleBlockSet(s,label,terminalOptions,elementIndex,postmatchCode,treeLevel="0") ::= <<
+<if(!ruleDescriptor.isSynPred)>
<matchSet(...)>
<noRewrite(...)> <! set return tree !>
+<else>
+<super.matchRuleBlockSet(...)>
+<endif>
>>

matchSetBang(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.matchSet(...)>
+<else>
+<super.matchSetBang(...)>
+<endif>
>>

matchSetRuleRoot(s,label,terminalOptions,elementIndex,debug) ::= <<
+<if(!ruleDescriptor.isSynPred)>
<super.matchSet(postmatchCode={
<if(!rewriteMode)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
@@ -216,12 +261,16 @@ root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_<treeLe
<endif>
}, ...
)>
+<else>
+<super.matchSetRuleRoot(...)>
+<endif>
>>

// RULE REF AST

/** rule auto construct */
ruleRef(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.ruleRef(...)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
@@ -230,51 +279,82 @@ adaptor.AddChild(root_<treeLevel>, <label>.Tree);
<else> <! rewrite mode !>
if (_first_<treeLevel> == null) _first_<treeLevel> = <label>.Tree;
<endif>
+<else>
+<super.ruleRef(...)>
+<endif>
>>

/** x+=rule auto construct */
ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
<ruleRef(...)>
<listLabelElem(elem={<label>.Tree},...)>
+<else>
+<super.ruleRefAndListLabel(...)>
+<endif>
>>

/** ^(rule ...) auto construct */
ruleRefRuleRoot(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.ruleRef(...)>
<if(!rewriteMode)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>.Tree, root_<treeLevel>);
<endif>
+<else>
+<super.ruleRefRuleRoot(...)>
+<endif>
>>

/** ^(x+=rule ...) auto construct */
ruleRefRuleRootAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
<ruleRefRuleRoot(...)>
<listLabelElem(elem={<label>.Tree},...)>
+<else>
+<super.ruleRefRuleRootAndListLabel(...)>
+<endif>
>>

/** rule when output=AST and tracking for rewrite */
ruleRefTrack(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.ruleRefTrack(...)>
+<else>
+<super.ruleRefTrack(...)>
+<endif>
>>

/** x+=rule when output=AST and tracking for rewrite */
ruleRefTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.ruleRefTrackAndListLabel(...)>
+<else>
+<super.ruleRefTrackAndListLabel(...)>
+<endif>
>>

/** ^(rule ...) rewrite */
ruleRefRuleRootTrack(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.ruleRefRootTrack(...)>
+<else>
+<super.ruleRefRuleRootTrack(...)>
+<endif>
>>

/** ^(x+=rule ...) rewrite */
ruleRefRuleRootTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.ruleRefRuleRootTrackAndListLabel(...)>
+<else>
+<super.ruleRefRuleRootTrackAndListLabel(...)>
+<endif>
>>

/** Streams for token refs are tree nodes now; override to
@@ -290,9 +370,11 @@ stream_<token>.NextNode()

ruleCleanUp() ::= <<
<super.ruleCleanUp()>
+<if(!ruleDescriptor.isSynPred)>
<if(!rewriteMode)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
retval.Tree = (<ASTLabelType>)adaptor.RulePostProcessing(root_0);
<if(backtracking)>}<endif>
<endif>
+<endif>
>>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp2/CSharp2.stg b/bin/Bootstrap/Codegen/Templates/CSharp2/CSharp2.stg
index 2e82edd..b4c7e54 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp2/CSharp2.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp2/CSharp2.stg
@@ -165,6 +165,14 @@ lexer(grammar, name, tokens, scopes, rules, numRules, filterMode, labelType="Com
}
}

+<if(grammar.delegates)>
+	public override void SetState(RecognizerSharedState state)
+	{
+		base.SetState(state);
+		<grammar.delegates:{g|<g:delegateName()>.SetState(state);}; separator="\n">
+	}
+<endif>
+
<endif>
<if(filterMode)>
<filteringNextToken()>
@@ -296,6 +304,22 @@ genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
<last(grammar.delegators):{g|private <g.recognizerName> gParent;}>
<endif>

+<if(grammar.delegates)>
+	public override void SetState(RecognizerSharedState state)
+	{
+		base.SetState(state);
+		<grammar.delegates:{g|<g:delegateName()>.SetState(state);}; separator="\n">
+	}
+
+<if(TREE_PARSER)>
+	public override void SetTreeNodeStream(ITreeNodeStream input)
+	{
+		base.SetTreeNodeStream(input);
+		<grammar.delegates:{g|<g:delegateName()>.SetTreeNodeStream(input);}; separator="\n">
+	}
+<endif>
+<endif>
+
<scopes:{it|<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>
<@members()>

@@ -370,7 +394,6 @@ genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<inputStreamType> input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
: base(input, state)
{
-	<parserCtorBody()>
<if(grammar.directDelegates)>
<grammar.directDelegates:
{g|<g:delegateName()> = new <g.recognizerName>(input, state<trunc(g.delegators):{p|, <p:delegateName()>}>, this);}; separator="\n">
@@ -381,6 +404,7 @@ genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
<if(grammar.delegators)>
<last(grammar.delegators):{g|gParent = <g:delegateName()>;}>
<endif>
+	<parserCtorBody()>
OnCreated();
}
>>
@@ -509,13 +533,13 @@ ruleWrapperMap ::= [

ruleWrapperBottomup() ::= <<
<if(TREE_PARSER && filterMode)>
-public override IAstRuleReturnScope Bottomup() { return bottomup(); }
+protected override <if(buildAST)>IAstRuleReturnScope<else>void<endif> Bottomup() { return bottomup(); }
<endif>
>>

ruleWrapperTopdown() ::= <<
<if(TREE_PARSER && filterMode)>
-public override IAstRuleReturnScope Topdown() { return topdown(); }
+protected override <if(buildAST)>IAstRuleReturnScope<else>void<endif> Topdown() { return topdown(); }
<endif>
>>

diff --git a/bin/Bootstrap/Codegen/Templates/CSharp2/Dbg.stg b/bin/Bootstrap/Codegen/Templates/CSharp2/Dbg.stg
index efad5b5..16f6de2 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp2/Dbg.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp2/Dbg.stg
@@ -95,9 +95,9 @@ ctorForRootGrammar() ::= <<
<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, int port, RecognizerSharedState state )
: base( input, state )
{
-	<parserCtorBody()>
<createListenerAndHandshake()>
<grammar.directDelegates:{g|<g:delegateName()> = new <g.recognizerName>( input, dbg, this.state, this<grammar.delegators:{g|, <g:delegateName()>}> );}; separator="\n">
+	<parserCtorBody()>
<@finally()>
}<\n>
>>
@@ -113,9 +113,9 @@ ctorForProfilingRootGrammar() ::= <<
{
Profiler p = (Profiler)dbg;
p.setParser(this);
-	<parserCtorBody()>
<grammar.directDelegates:
{g|<g:delegateName()> = new <g.recognizerName>( input, dbg, this.state, this<grammar.delegators:{g|, <g:delegateName()>}> );}; separator="\n">
+	<parserCtorBody()>
<@finally()>
}
<\n>
@@ -126,9 +126,9 @@ ctorForDelegateGrammar() ::= <<
<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, IDebugEventListener dbg, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}> )
: base( input, dbg, state )
{
-	<parserCtorBody()>
<grammar.directDelegates:
{g|<g:delegateName()> = new <g.recognizerName>( input, this, this.state<grammar.delegators:{g|, <g:delegateName()>}> );}; separator="\n">
+	<parserCtorBody()>
}<\n>
>>

@@ -140,8 +140,8 @@ ctorForPredefinedListener() ::= <<
Profiler p = (Profiler)dbg;
p.setParser(this);
<endif>
-	<parserCtorBody()>
<grammar.directDelegates:{g|<g:delegateName()> = new <g.recognizerName>(input, dbg, this.state, this<grammar.delegators:{g|, <g:delegateName()>}>);}; separator="\n">
+	<parserCtorBody()>
<@finally()>
}<\n>
>>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg
index 0243429..5eba4ed 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg
@@ -194,10 +194,8 @@ root_0 = (<ASTLabelType>)adaptor.Nil();
<! if tree parser and rewrite=true !>
<if(TREE_PARSER&&rewriteMode)>
<prevRuleRootRef()>.Tree = (<ASTLabelType>)adaptor.RulePostProcessing(root_0);
-input.ReplaceChildren(adaptor.GetParent(retval.Start),
-                      adaptor.GetChildIndex(retval.Start),
-                      adaptor.GetChildIndex(_last),
-                      retval.Tree);
+if (<prevRuleRootRef()>.Tree != null)
+	input.ReplaceChildren(adaptor.GetParent(retval.Start), adaptor.GetChildIndex(retval.Start), adaptor.GetChildIndex(_last), retval.Tree);
<endif>
<! if parser or tree-parser && rewrite!=true, we need to set result !>
<if(!TREE_PARSER||!rewriteMode)>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg
index 3be82ed..676ba00 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg
@@ -45,14 +45,17 @@
/** Add a variable to track last element matched */
ruleDeclarations() ::= <<
<super.ruleDeclarations()>
+<if(!ruleDescriptor.isSynPred)>
<ASTLabelType> _first_0 = default(<ASTLabelType>);
-<ASTLabelType> _last = default(<ASTLabelType>);<\n>
+<ASTLabelType> _last = default(<ASTLabelType>);
+<endif>
>>

/** What to emit when there is no rewrite rule.  For auto build
*  mode, does nothing.
*/
noRewrite(rewriteBlockLevel, treeLevel) ::= <<
+<if(!ruleDescriptor.isSynPred)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<if(rewriteMode)>
retval.Tree = (<ASTLabelType>)_first_0;
@@ -60,6 +63,7 @@ if (adaptor.GetParent(retval.Tree)!=null && adaptor.IsNil(adaptor.GetParent(retv
retval.Tree = (<ASTLabelType>)adaptor.GetParent(retval.Tree);
<endif>
<if(backtracking)>}<endif>
+<endif>
>>

/** match ^(root children) in tree parser; override here to
@@ -67,6 +71,7 @@ if (adaptor.GetParent(retval.Tree)!=null && adaptor.IsNil(adaptor.GetParent(retv
*/
tree(root, actionsAfterRoot, children, nullableChildList,
enclosingTreeLevel, treeLevel) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
{
<ASTLabelType> _save_last_<treeLevel> = _last;
@@ -99,7 +104,10 @@ Match(input, TokenTypes.Up, null); <checkRuleBacktrackFailure()>
adaptor.AddChild(root_<enclosingTreeLevel>, root_<treeLevel>);
<endif>
_last = _save_last_<treeLevel>;
-}<\n>
+}
+<else>
+<super.tree(...)>
+<endif>
>>

// TOKEN AST STUFF
@@ -108,12 +116,17 @@ _last = _save_last_<treeLevel>;
*  setting of _last
*/
tokenRefBang(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.tokenRef(...)>
+<else>
+<super.tokenRefBang(...)>
+<endif>
>>

/** ID auto construct */
tokenRef(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.tokenRef(...)>
<if(!rewriteMode)>
@@ -129,16 +142,24 @@ adaptor.AddChild(root_<treeLevel>, <label>_tree);
<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
if (_first_<treeLevel> == null) _first_<treeLevel> = <label>;
<endif>
+<else>
+<super.tokenRef(...)>
+<endif>
>>

/** label+=TOKEN auto construct */
tokenRefAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
<tokenRef(...)>
<listLabelElem(elem=label,...)>
+<else>
+<super.tokenRefAndListLabel(...)>
+<endif>
>>

/** ^(ID ...) auto construct */
tokenRefRuleRoot(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.tokenRef(...)>
<if(!rewriteMode)>
@@ -151,16 +172,24 @@ _last = (<ASTLabelType>)input.LT(1);
root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_<treeLevel>);
<if(backtracking)>}<endif>
<endif>
+<else>
+<super.tokenRefRuleRoot(...)>
+<endif>
>>

/** Match ^(label+=TOKEN ...) auto construct */
tokenRefRuleRootAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
<tokenRefRuleRoot(...)>
<listLabelElem(elem=label,...)>
+<else>
+<super.tokenRefRuleRootAndListLabel(...)>
+<endif>
>>

/** Match . wildcard and auto dup the node/subtree */
wildcard(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.wildcard(...)>
<if(!rewriteMode)>
@@ -172,11 +201,15 @@ adaptor.AddChild(root_<treeLevel>, <label>_tree);
<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
if (_first_<treeLevel> == null) _first_<treeLevel> = <label>;
<endif>
+<else>
+<super.wildcard(...)>
+<endif>
>>

// SET AST

matchSet(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.matchSet(postmatchCode={
<if(!rewriteMode)>
@@ -191,19 +224,31 @@ adaptor.AddChild(root_<treeLevel>, <label>_tree);
<endif>
}, ...
)>
+<else>
+<super.matchSet(...)>
+<endif>
>>

matchRuleBlockSet(s,label,terminalOptions,elementIndex,postmatchCode,treeLevel="0") ::= <<
+<if(!ruleDescriptor.isSynPred)>
<matchSet(...)>
<noRewrite(...)> <! set return tree !>
+<else>
+<super.matchRuleBlockSet(...)>
+<endif>
>>

matchSetBang(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.matchSet(...)>
+<else>
+<super.matchSetBang(...)>
+<endif>
>>

matchSetRuleRoot(s,label,terminalOptions,elementIndex,debug) ::= <<
+<if(!ruleDescriptor.isSynPred)>
<super.matchSet(postmatchCode={
<if(!rewriteMode)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
@@ -217,12 +262,16 @@ root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_<treeLe
<endif>
}, ...
)>
+<else>
+<super.matchSetRuleRoot(...)>
+<endif>
>>

// RULE REF AST

/** rule auto construct */
ruleRef(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.ruleRef(...)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
@@ -231,27 +280,42 @@ adaptor.AddChild(root_<treeLevel>, <label>.Tree);
<else> <! rewrite mode !>
if (_first_<treeLevel> == null) _first_<treeLevel> = <label>.Tree;
<endif>
+<else>
+<super.ruleRef(...)>
+<endif>
>>

/** x+=rule auto construct */
ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
<ruleRef(...)>
<listLabelElem(elem={<label>.Tree},...)>
+<else>
+<super.ruleRefAndListLabel(...)>
+<endif>
>>

/** ^(rule ...) auto construct */
ruleRefRuleRoot(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.ruleRef(...)>
<if(!rewriteMode)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>.Tree, root_<treeLevel>);
<endif>
+<else>
+<super.ruleRefRuleRoot(...)>
+<endif>
>>

/** ^(x+=rule ...) auto construct */
ruleRefRuleRootAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
<ruleRefRuleRoot(...)>
<listLabelElem(elem={<label>.Tree},...)>
+<else>
+<super.ruleRefRuleRootAndListLabel(...)>
+<endif>
>>

/** rule when output=AST and tracking for rewrite */
@@ -262,20 +326,32 @@ _last = (<ASTLabelType>)input.LT(1);

/** x+=rule when output=AST and tracking for rewrite */
ruleRefTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.ruleRefTrackAndListLabel(...)>
+<else>
+<super.ruleRefTrackAndListLabel(...)>
+<endif>
>>

/** ^(rule ...) rewrite */
ruleRefRuleRootTrack(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.ruleRefRootTrack(...)>
+<else>
+<super.ruleRefRuleRootTrack(...)>
+<endif>
>>

/** ^(x+=rule ...) rewrite */
ruleRefRuleRootTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.ruleRefRuleRootTrackAndListLabel(...)>
+<else>
+<super.ruleRefRuleRootTrackAndListLabel(...)>
+<endif>
>>

/** Streams for token refs are tree nodes now; override to
@@ -291,9 +367,11 @@ stream_<token>.NextNode()

ruleCleanUp() ::= <<
<super.ruleCleanUp()>
+<if(!ruleDescriptor.isSynPred)>
<if(!rewriteMode)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
retval.Tree = (<ASTLabelType>)adaptor.RulePostProcessing(root_0);
<if(backtracking)>}<endif>
<endif>
+<endif>
>>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
index 63f5e22..a789e8a 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
@@ -162,6 +162,14 @@ lexer(grammar, name, tokens, scopes, rules, numRules, filterMode, labelType="Com
}
}

+<if(grammar.delegates)>
+	public override void SetState(RecognizerSharedState state)
+	{
+		base.SetState(state);
+		<grammar.delegates:{g|<g:delegateName()>.SetState(state);}; separator="\n">
+	}
+<endif>
+
<endif>
<if(filterMode)>
<filteringNextToken()>
@@ -291,6 +299,22 @@ genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
<last(grammar.delegators):{g|private <g.recognizerName> gParent;}>
<endif>

+<if(grammar.delegates)>
+	public override void SetState(RecognizerSharedState state)
+	{
+		base.SetState(state);
+		<grammar.delegates:{g|<g:delegateName()>.SetState(state);}; separator="\n">
+	}
+
+<if(TREE_PARSER)>
+	public override void SetTreeNodeStream(ITreeNodeStream input)
+	{
+		base.SetTreeNodeStream(input);
+		<grammar.delegates:{g|<g:delegateName()>.SetTreeNodeStream(input);}; separator="\n">
+	}
+<endif>
+<endif>
+
<scopes:{it|<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>
<@members()>

@@ -352,7 +376,6 @@ genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<inputStreamType> input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
: base(input, state)
{
-	<parserCtorBody()>
<if(grammar.directDelegates)>
<grammar.directDelegates:
{g|<g:delegateName()> = new <g.recognizerName>(input, state<trunc(g.delegators):{p|, <p:delegateName()>}>, this);}; separator="\n">
@@ -363,6 +386,7 @@ genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
<if(grammar.delegators)>
<last(grammar.delegators):{g|gParent = <g:delegateName()>;}>
<endif>
+	<parserCtorBody()>
OnCreated();
}
>>
@@ -490,13 +514,13 @@ ruleWrapperMap ::= [

ruleWrapperBottomup() ::= <<
<if(TREE_PARSER && filterMode)>
-public override IAstRuleReturnScope Bottomup() { return bottomup(); }
+protected override <if(buildAST)>IAstRuleReturnScope<else>void<endif> Bottomup() { <if(buildAST)>return <endif>bottomup(); }
<endif>
>>

ruleWrapperTopdown() ::= <<
<if(TREE_PARSER && filterMode)>
-public override IAstRuleReturnScope Topdown() { return topdown(); }
+protected override <if(buildAST)>IAstRuleReturnScope<else>void<endif> Topdown() { <if(buildAST)>return <endif>topdown(); }
<endif>
>>

diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/Dbg.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/Dbg.stg
index 3841a8f..c16a848 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/Dbg.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/Dbg.stg
@@ -94,9 +94,9 @@ ctorForRootGrammar() ::= <<
<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, int port, RecognizerSharedState state )
: base( input, state )
{
-	<parserCtorBody()>
<createListenerAndHandshake()>
<grammar.directDelegates:{g|<g:delegateName()> = new <g.recognizerName>( input, dbg, this.state, this<grammar.delegators:{g|, <g:delegateName()>}> );}; separator="\n">
+	<parserCtorBody()>
<@finally()>
}<\n>
>>
@@ -112,9 +112,9 @@ ctorForProfilingRootGrammar() ::= <<
{
Profiler p = (Profiler)dbg;
p.setParser(this);
-	<parserCtorBody()>
<grammar.directDelegates:
{g|<g:delegateName()> = new <g.recognizerName>( input, dbg, this.state, this<grammar.delegators:{g|, <g:delegateName()>}> );}; separator="\n">
+	<parserCtorBody()>
<@finally()>
}
<\n>
@@ -125,9 +125,9 @@ ctorForDelegateGrammar() ::= <<
<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, IDebugEventListener dbg, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}> )
: base( input, dbg, state )
{
-	<parserCtorBody()>
<grammar.directDelegates:
{g|<g:delegateName()> = new <g.recognizerName>( input, this, this.state<grammar.delegators:{g|, <g:delegateName()>}> );}; separator="\n">
+	<parserCtorBody()>
}<\n>
>>

@@ -139,8 +139,8 @@ ctorForPredefinedListener() ::= <<
Profiler p = (Profiler)dbg;
p.setParser(this);
<endif>
-	<parserCtorBody()>
<grammar.directDelegates:{g|<g:delegateName()> = new <g.recognizerName>(input, dbg, this.state, this<grammar.delegators:{g|, <g:delegateName()>}>);}; separator="\n">
+	<parserCtorBody()>
<@finally()>
}<\n>
>>
diff --git a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp2.dll b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp2.dll
index 83b7b20..3f6e08c 100644
Binary files a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp2.dll and b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp2.dll differ
diff --git a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll
index 5ea30fc..904f68f 100644
Binary files a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll and b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll differ
diff --git a/bin/prep/prepare.ps1 b/bin/prep/prepare.ps1
index 4b2ddc4..c5577d7 100644
--- a/bin/prep/prepare.ps1
+++ b/bin/prep/prepare.ps1
@@ -167,12 +167,12 @@ copy "..\$BuildConfig\Antlr4.StringTemplate.Visualizer.pdb" ".\ST4"
copy "LICENSE.txt" ".\ST4"

# compress the distributable packages
-$AntlrVersion = "special-3.4.0.8959"
-$STVersion = "special-4.0.4.8959"
+$AntlrVersion = "special-3.4.1.8995"
+$STVersion = "special-4.0.5.8995"

-$ArchivePath = ".\dist\antlr-dotnet-csharp3bootstrap-" + $AntlrVersion + ".7z"
+$ArchivePath = ".\dist\antlr-dotnet-csharpbootstrap-" + $AntlrVersion + ".7z"
.\7z.exe a -r -mx9 $ArchivePath ".\Bootstrap\*"
-$ArchivePath = ".\dist\antlr-dotnet-csharp3runtime-" + $AntlrVersion + ".7z"
+$ArchivePath = ".\dist\antlr-dotnet-csharpruntime-" + $AntlrVersion + ".7z"
.\7z.exe a -r -mx9 $ArchivePath ".\Runtime\*"
$ArchivePath = ".\dist\antlr-dotnet-tool-" + $AntlrVersion + ".7z"
.\7z.exe a -r -mx9 $ArchivePath ".\Tool\*"

