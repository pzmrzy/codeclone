commit c74244b864d4615665d97d664ddcc34349cc1a5d
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Thu Dec 10 22:28:39 2009 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Thu Dec 10 22:28:39 2009 -0800

C# Port:
* Merge CL6351-6353

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 6481]

diff --git a/Antlr3.Test/ST4/TestRenderers.cs b/Antlr3.Test/ST4/TestRenderers.cs
index 03e4db1..dc39b00 100644
--- a/Antlr3.Test/ST4/TestRenderers.cs
+++ b/Antlr3.Test/ST4/TestRenderers.cs
@@ -35,105 +35,159 @@ namespace AntlrUnitTests.ST4
using Microsoft.VisualStudio.TestTools.UnitTesting;
using StringTemplate;
using ArrayList = System.Collections.ArrayList;
+    using CultureInfo = System.Globalization.CultureInfo;
using DateTime = System.DateTime;
using IList = System.Collections.IList;

[TestClass]
public class TestRenderers : StringTemplateTestBase
{
-#if false
-        public class DateRenderer : IAttributeRenderer
+        [TestMethod]
+        public void TestRendererForGroup()
{
-            public string ToString(object o)
-            {
-                DateTime dateTime = (DateTime)o;
-                return dateTime.ToString("yyyy.MM.dd");
-            }
-
-            public string ToString(object o, string formatString)
-            {
-                return ToString(o);
-            }
+            string templates =
+                    "dateThing(created) ::= \"datetime: <created>\"\n";
+            WriteFile(tmpdir, "t.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/t.stg");
+            group.RegisterRenderer(typeof(DateTime), new DateTimeRenderer());
+            Template st = group.GetInstanceOf("dateThing");
+            st.Add("created", new DateTime(2005, 7, 5));
+            string expecting = "datetime: 7/5/2005 12:00 AM";
+            string result = st.Render();
+            Assert.AreEqual(expecting, result);
}

-        public class DateRenderer2 : IAttributeRenderer
+        [TestMethod]
+        public void TestRendererWithFormat()
{
-            public string ToString(object o)
-            {
-                DateTime dateTime = (DateTime)o;
-                return dateTime.ToString("yyyy/MM/dd");
-            }
-
-            public string ToString(object o, string formatString)
-            {
-                return ToString(o);
-            }
+            string templates =
+                    "dateThing(created) ::= << date: <created; format=\"yyyy.MM.dd\"> >>\n";
+            WriteFile(tmpdir, "t.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/t.stg");
+            group.RegisterRenderer(typeof(DateTime), new DateTimeRenderer());
+            Template st = group.GetInstanceOf("dateThing");
+            st.Add("created", new DateTime(2005, 7, 5));
+            string expecting = " date: 2005.07.05 ";
+            string result = st.Render();
+            Assert.AreEqual(expecting, result);
}

-        public class DateRenderer3 : IAttributeRenderer
+        [TestMethod]
+        public void TestRendererWithPredefinedFormat()
{
-            public string ToString(object o)
-            {
-                DateTime dateTime = (DateTime)o;
-                return dateTime.ToString("yyyy/MM/dd");
-            }
-
-            public string ToString(object o, string formatString)
-            {
-                DateTime dateTime = (DateTime)o;
-                return dateTime.ToString(formatString);
-            }
+            string templates =
+                    "dateThing(created) ::= << datetime: <created; format=\"short\"> >>\n";
+            WriteFile(tmpdir, "t.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/t.stg");
+            group.RegisterRenderer(typeof(DateTime), new DateTimeRenderer());
+            Template st = group.GetInstanceOf("dateThing");
+            st.Add("created", new DateTime(2005, 7, 5));
+            string expecting = " datetime: 7/5/2005 12:00 AM ";
+            string result = st.Render();
+            Assert.AreEqual(expecting, result);
}
-#endif

-        public class StringRenderer : IAttributeRenderer
+        [TestMethod]
+        public void TestRendererWithPredefinedFormat2()
{
-            public string ToString(object o)
-            {
-                return (string)o;
-            }
-
-            public string ToString(object o, string formatString)
-            {
-                if (formatString.Equals("upper"))
-                {
-                    return ((string)o).ToUpperInvariant();
-                }
-                return ToString(o);
-            }
+            string templates =
+                    "dateThing(created) ::= << datetime: <created; format=\"full\"> >>\n";
+            WriteFile(tmpdir, "t.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/t.stg");
+            group.RegisterRenderer(typeof(DateTime), new DateTimeRenderer());
+            Template st = group.GetInstanceOf("dateThing");
+            st.Add("created", new DateTime(2005, 7, 5));
+            string expecting = " datetime: Tuesday, July 5, 2005 12:00:00 AM PDT ";
+            string result = st.Render();
+            Assert.AreEqual(expecting, result);
}

[TestMethod]
-        public void TestRendererForGroup()
+        public void TestRendererWithPredefinedFormat3()
{
string templates =
-                    "dateThing(created) ::= \"date: <created>\"\n";
+                    "dateThing(created) ::= << date: <created; format=\"date:medium\"> >>\n";
+
WriteFile(tmpdir, "t.stg", templates);
TemplateGroup group = new TemplateGroupFile(tmpdir + "/t.stg");
group.RegisterRenderer(typeof(DateTime), new DateTimeRenderer());
Template st = group.GetInstanceOf("dateThing");
st.Add("created", new DateTime(2005, 7, 5));
-            string expecting = "date: 7/5/2005 12:00 AM";
+            string expecting = " date: Jul 5, 2005 ";
string result = st.Render();
Assert.AreEqual(expecting, result);
}

[TestMethod]
-        public void TestRendererWithFormat()
+        public void TestRendererWithPredefinedFormat4()
{
string templates =
-                    "dateThing(created) ::= << date: <created; format=\"yyyy.MM.dd\"> >>\n";
+                    "dateThing(created) ::= << time: <created; format=\"time:medium\"> >>\n";
+
WriteFile(tmpdir, "t.stg", templates);
TemplateGroup group = new TemplateGroupFile(tmpdir + "/t.stg");
group.RegisterRenderer(typeof(DateTime), new DateTimeRenderer());
Template st = group.GetInstanceOf("dateThing");
st.Add("created", new DateTime(2005, 7, 5));
-            string expecting = " date: 2005.07.05 ";
+            string expecting = " time: 12:00:00 AM ";
+            string result = st.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestStringRendererWithPrintfFormat()
+        {
+            string templates =
+                    "foo(x) ::= << <x; format=\"%6s\"> >>\n";
+
+            WriteFile(tmpdir, "t.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/t.stg");
+            group.RegisterRenderer(typeof(string), new StringRenderer());
+            Template st = group.GetInstanceOf("foo");
+            st.Add("x", "hi");
+            string expecting = "     hi ";
string result = st.Render();
Assert.AreEqual(expecting, result);
}

[TestMethod]
+        public void TestNumberRendererWithPrintfFormat()
+        {
+            string templates =
+                    "foo(x,y) ::= << <x; format=\"F0\"> <y; format=\"0.000\"> >>\n";
+
+            WriteFile(tmpdir, "t.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/t.stg");
+            group.RegisterRenderer(typeof(int), new NumberRenderer());
+            group.RegisterRenderer(typeof(double), new NumberRenderer());
+            Template st = group.GetInstanceOf("foo");
+            st.Add("x", -2100);
+            st.Add("y", 3.14159);
+            string expecting = " -2100 3.142 ";
+            string result = st.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestLocaleWithNumberRenderer()
+        {
+            string templates =
+                    "foo(x,y) ::= << <x; format=\"N0\"> <y; format=\"0.000\"> >>\n";
+
+            WriteFile(tmpdir, "t.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/t.stg");
+            group.RegisterRenderer(typeof(int), new NumberRenderer());
+            group.RegisterRenderer(typeof(double), new NumberRenderer());
+            Template st = group.GetInstanceOf("foo");
+            st.Add("x", -2100);
+            st.Add("y", 3.14159);
+            // Polish uses ' ' for ',' and ',' for '.'
+            string expecting = " -2 100 3,142 ";
+            string result = st.Render(CultureInfo.GetCultureInfo("pl-PL"));
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
public void TestRendererWithFormatAndList()
{
string template =
diff --git a/Antlr3.vsmdi b/Antlr3.vsmdi
index 6d9067e..e2d4094 100644
--- a/Antlr3.vsmdi
+++ b/Antlr3.vsmdi
@@ -476,11 +476,18 @@
</TestList>
<TestList name="Renderers" id="67a2d196-65c0-4971-b559-0e9f67f75ff3" parentListId="4adbb104-d28d-4362-8420-a9fefe69c167">
<TestLinks>
-      <TestLink id="3ffc0e12-5b88-bc34-a25c-b2d6f3224187" name="TestRendererWithFormatAndSeparator" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="ea4372e3-c98a-6401-a78d-2fdc9fee4b89" name="TestRendererWithFormatAndSeparatorAndNull" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="68b63446-2e96-13b1-538e-a41b7651a4e8" name="TestRendererWithFormatAndList" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="7df55a29-26d5-c356-0622-bb9529509a8d" name="TestRendererWithFormat" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5228625b-d266-1b2d-2080-40201c75e923" name="TestRendererWithPredefinedFormat4" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="89db638a-9811-e6a3-f21b-508e9fcb516b" name="TestNumberRendererWithPrintfFormat" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6043c740-3431-6094-7ebc-45d0dd90b30c" name="TestStringRendererWithPrintfFormat" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="110e4cb5-58da-9909-2cb0-58c8e2cd2120" name="TestRendererForGroup" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="68b63446-2e96-13b1-538e-a41b7651a4e8" name="TestRendererWithFormatAndList" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3ffc0e12-5b88-bc34-a25c-b2d6f3224187" name="TestRendererWithFormatAndSeparator" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8907b929-9e5f-de03-25c8-f4e9fb79ccb6" name="TestLocaleWithNumberRenderer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ea4372e3-c98a-6401-a78d-2fdc9fee4b89" name="TestRendererWithFormatAndSeparatorAndNull" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1bec159c-f78f-7d57-e1c6-3c7a8ae1f5c6" name="TestRendererWithPredefinedFormat" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="36df468f-a77e-c0b7-761d-dfd711f028c1" name="TestRendererWithPredefinedFormat3" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5f6c2f38-d916-bf7f-bda6-a728dcdd246e" name="TestRendererWithPredefinedFormat2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
</TestLinks>
</TestList>
<TestList name="Null and Empty Values" id="6f9712eb-43ef-4a76-8810-256978946e66" parentListId="4adbb104-d28d-4362-8420-a9fefe69c167">
diff --git a/StringTemplate4/BlankTemplate.cs b/StringTemplate4/BlankTemplate.cs
index 865b784..50a7c1d 100644
--- a/StringTemplate4/BlankTemplate.cs
+++ b/StringTemplate4/BlankTemplate.cs
@@ -32,6 +32,8 @@

namespace StringTemplate
{
+    using CultureInfo = System.Globalization.CultureInfo;
+
public class BlankTemplate : Template
{
public BlankTemplate()
@@ -67,7 +69,7 @@ namespace StringTemplate
return 0;
}

-        public override string Render()
+        public override string Render(CultureInfo culture)
{
return string.Empty;
}
diff --git a/StringTemplate4/DateTimeRenderer.cs b/StringTemplate4/DateTimeRenderer.cs
index 7631a33..79899ca 100644
--- a/StringTemplate4/DateTimeRenderer.cs
+++ b/StringTemplate4/DateTimeRenderer.cs
@@ -33,6 +33,7 @@
namespace StringTemplate
{
using System.Collections.Generic;
+    using CultureInfo = System.Globalization.CultureInfo;
using DateTime = System.DateTime;

public class DateTimeRenderer : IAttributeRenderer
@@ -51,25 +52,21 @@ namespace StringTemplate
{"date:full", ""},

{"time:short", "t"},
-                {"time:medium", "t"},
+                {"time:medium", "T"},
{"time:long", "T"},
{"time:full", "T"},
};

-        public string ToString(object o)
-        {
-            return ToString(o, "short");
-        }
-
-        public string ToString(object o, string formatString)
+        public string ToString(object o, string formatString, CultureInfo culture)
{
DateTime d = (DateTime)o;
+            formatString = formatString ?? "short";

string format;
if (!StandardFormats.TryGetValue(formatString, out format))
format = formatString;

-            return d.ToString(format);
+            return d.ToString(format, culture);
}
}
}
diff --git a/StringTemplate4/DebugTemplate.cs b/StringTemplate4/DebugTemplate.cs
new file mode 100644
index 0000000..5c19104
--- /dev/null
+++ b/StringTemplate4/DebugTemplate.cs
@@ -0,0 +1,73 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    using Exception = System.Exception;
+    using System.Collections.Generic;
+
+    public class DebugTemplate : Template
+    {
+        public class AddEvent
+        {
+            string name;
+            object value;
+            Exception source;
+
+            public AddEvent(string name, object value)
+            {
+                this.name = name;
+                this.value = value;
+                this.source = new Exception();
+            }
+        }
+
+        /** Track add attribute "events"; used for ST user-level debugging */
+        IList<AddEvent> addEvents; // TODO: put this in a subclass; alter factor in STGroup
+
+        public override void Add(string name, object value)
+        {
+            if (name == null)
+                return; // allow null value
+
+            base.Add(name, value);
+
+            if (code.nativeGroup.Detects(ErrorTolerance.DETECT_ADD_ATTR))
+            {
+                if (addEvents == null)
+                    addEvents = new List<AddEvent>();
+
+                addEvents.Add(new AddEvent(name, value));
+            }
+        }
+    }
+}
diff --git a/StringTemplate4/IAttributeRenderer.cs b/StringTemplate4/IAttributeRenderer.cs
index bab8ea6..a866e21 100644
--- a/StringTemplate4/IAttributeRenderer.cs
+++ b/StringTemplate4/IAttributeRenderer.cs
@@ -32,24 +32,19 @@

namespace StringTemplate
{
+    using CultureInfo = System.Globalization.CultureInfo;
+
/** This interface describes an object that knows how to format or otherwise
-     *  render an object appropriately.  Usually this is used for locale changes
-     *  for objects such as Date and floating point numbers...  You can either
-     *  have an object that is sensitive to the locale or have a different object
-     *  per locale.
+     *  render an object appropriately.  There is one renderer registered per
+     *  group for a given Java type.
*
-     *  Each template may have a renderer for each object type or can default
-     *  to the group's renderer or the super group's renderer if the group doesn't
-     *  have one.
+     *  If the format string passed to the renderer is not recognized then simply
+     *  call toString().
*
-     *  The toString(Object,String) method is used when the user uses the
-     *  format option: $o; format="f"$.  It checks the formatName and applies the
-     *  appropriate formatting.  If the format string passed to the renderer is
-     *  not recognized then simply call toString().
+     *  formatString can be null but locale will at least be Locale.getDefault()
*/
public interface IAttributeRenderer
{
-        string ToString(object o);
-        string ToString(object o, string formatName);
+        string ToString(object o, string formatString, CultureInfo culture);
}
}
diff --git a/StringTemplate4/Interpreter.cs b/StringTemplate4/Interpreter.cs
index 04c449e..483ffd2 100644
--- a/StringTemplate4/Interpreter.cs
+++ b/StringTemplate4/Interpreter.cs
@@ -37,6 +37,7 @@ namespace StringTemplate
using Array = System.Array;
using ArrayList = System.Collections.ArrayList;
using Console = System.Console;
+    using CultureInfo = System.Globalization.CultureInfo;
using Environment = System.Environment;
using FieldInfo = System.Reflection.FieldInfo;
using ICollection = System.Collections.ICollection;
@@ -78,11 +79,19 @@ namespace StringTemplate
*/
TemplateGroup group;

+        CultureInfo culture;
+
public bool trace = false;

public Interpreter(TemplateGroup group)
+            : this(group, CultureInfo.CurrentCulture)
+        {
+        }
+
+        public Interpreter(TemplateGroup group, CultureInfo culture)
{
this.group = group;
+            this.culture = culture;
}

public int Exec(ITemplateWriter @out, Template self)
@@ -427,10 +436,7 @@ namespace StringTemplate
string v = null;
if (r != null)
{
-                if (formatString != null)
-                    v = r.ToString(o, formatString);
-                else
-                    v = r.ToString(o);
+                v = r.ToString(o, formatString, culture);
}
else
{
@@ -565,42 +571,6 @@ namespace StringTemplate
}
return results;
}
-
-            /*
-            if ( attr is Iterator ) {
-                List<Template> mapped = new ArrayList<Template>();
-                Iterator iter = (Iterator)attr;
-                int i0 = 0;
-                int i = 1;
-                int ti = 0;
-                while ( iter.hasNext() ) {
-                    object iterValue = iter.next();
-                    if ( iterValue == null ) continue;
-                    int templateIndex = ti % templates.size(); // rotate through
-                    ti++;
-                    string name = templates.get(templateIndex);
-                    Template st = group.getEmbeddedInstanceOf(self, name);
-                    for (FormalArgument arg : st.code.formalArguments.values()) {
-                        st.rawSetAttribute(arg.name, iterValue);
-                    }
-                    st.rawSetAttribute("i0", i0);
-                    st.rawSetAttribute("i", i);
-                    mapped.add(st);
-                    i0++;
-                    i++;
-                }
-                operands[++sp] = mapped;
-                //Console.WriteLine("mapped="+mapped);
-            }
-            else { // if only single value, just apply first template to attribute
-                Template st = group.getInstanceOf(templates.get(0));
-                setSoleArgument(st, attr);
-                st.rawSetAttribute("i0", 0);
-                st.rawSetAttribute("i", 1);
-                operands[++sp] = st;
-    //            map(self, attr, templates.get(1));
-            }
-            */
}

protected void SetSoleArgument(Template st, object attr)
@@ -1017,8 +987,8 @@ namespace StringTemplate
self.code.strings);
StringBuilder buf = new StringBuilder();
dis.DisassembleInstruction(buf, ip);
-            string name = self.name + ":";
-            if (self.name == Template.UnknownName)
+            string name = self.code.name + ":";
+            if (self.code.name == Template.UnknownName)
name = "";
Console.Write(string.Format("{0:-40s}", name + buf));
Console.Write("\tstack=[");
@@ -1037,7 +1007,7 @@ namespace StringTemplate
{
if (o is Template)
{
-                Console.Write(" " + ((Template)o).name + "()");
+                Console.Write(" " + ((Template)o).code.name + "()");
return;
}
o = ConvertAnythingIteratableToIterator(o);
diff --git a/StringTemplate4/NumberRenderer.cs b/StringTemplate4/NumberRenderer.cs
new file mode 100644
index 0000000..b403d21
--- /dev/null
+++ b/StringTemplate4/NumberRenderer.cs
@@ -0,0 +1,49 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    using CultureInfo = System.Globalization.CultureInfo;
+    using IFormattable = System.IFormattable;
+
+    public class NumberRenderer : IAttributeRenderer
+    {
+        public string ToString(object o, string formatString, CultureInfo culture)
+        {
+            IFormattable formattable = o as IFormattable;
+            if (formattable != null)
+                return formattable.ToString(formatString, culture);
+
+            return o.ToString();
+        }
+    }
+}
diff --git a/StringTemplate4/StringRenderer.cs b/StringTemplate4/StringRenderer.cs
new file mode 100644
index 0000000..bea3481
--- /dev/null
+++ b/StringTemplate4/StringRenderer.cs
@@ -0,0 +1,70 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    using CultureInfo = System.Globalization.CultureInfo;
+    using HttpUtility = System.Web.HttpUtility;
+    using SecurityElement = System.Security.SecurityElement;
+
+    public class StringRenderer : IAttributeRenderer
+    {
+        // trim(s) and strlen(s) built-in funcs; these are format options
+        public string ToString(object o, string formatString, CultureInfo culture)
+        {
+            string s = o.ToString();
+            if (formatString == null || string.IsNullOrEmpty(s))
+                return s;
+
+            switch (formatString)
+            {
+            case "upper":
+                return s.ToUpper(culture);
+
+            case "lower":
+                return s.ToLower(culture);
+
+            case "cap":
+                return char.ToUpper(s[0], culture) + s.Substring(1);
+
+            case "url-encode":
+                return HttpUtility.UrlEncode(s);
+
+            case "xml-encode":
+                return SecurityElement.Escape(s);
+
+            default:
+                return s;
+            }
+        }
+    }
+}
diff --git a/StringTemplate4/StringTemplate4.csproj b/StringTemplate4/StringTemplate4.csproj
index 5faf08c..0e8060a 100644
--- a/StringTemplate4/StringTemplate4.csproj
+++ b/StringTemplate4/StringTemplate4.csproj
@@ -42,6 +42,7 @@
<Reference Include="System.Core">
<RequiredTargetFramework>3.5</RequiredTargetFramework>
</Reference>
+    <Reference Include="System.Web" />
</ItemGroup>
<ItemGroup>
<Compile Include="AutoIndentWriter.cs" />
@@ -51,6 +52,7 @@
<Compile Include="CompiledTemplate.cs" />
<Compile Include="Compiler.cs" />
<Compile Include="DateTimeRenderer.cs" />
+    <Compile Include="DebugTemplate.cs" />
<Compile Include="ErrorTolerance.cs" />
<Compile Include="FormalArgument.cs" />
<Compile Include="GroupLexerHelper.cs" />
@@ -62,7 +64,9 @@
<Compile Include="ITemplateWriter.cs" />
<Compile Include="Misc.cs" />
<Compile Include="NoIndentWriter.cs" />
+    <Compile Include="NumberRenderer.cs" />
<Compile Include="Properties\AssemblyInfo.cs" />
+    <Compile Include="StringRenderer.cs" />
<Compile Include="StringTable.cs" />
<Compile Include="Template.cs" />
<Compile Include="TemplateException.cs" />
diff --git a/StringTemplate4/Template.cs b/StringTemplate4/Template.cs
index 3761377..e75f692 100644
--- a/StringTemplate4/Template.cs
+++ b/StringTemplate4/Template.cs
@@ -36,6 +36,7 @@ namespace StringTemplate
using ArgumentException = System.ArgumentException;
using ArrayList = System.Collections.ArrayList;
using Console = System.Console;
+    using CultureInfo = System.Globalization.CultureInfo;
using Exception = System.Exception;
using IList = System.Collections.IList;
using IOException = System.IO.IOException;
@@ -45,14 +46,21 @@ namespace StringTemplate
public class Template
{
public const string UnknownName = "unknown";
-        public string name = UnknownName;
-
+        public static readonly Template Blank = new BlankTemplate();

/** The code to interpret; it pulls from attributes and this template's
*  group of templates to evaluate to string.
*/
public CompiledTemplate code; // TODO: is this the right name?

+        /** Map an attribute name to its value(s). */
+        protected internal IDictionary<string, object> attributes;
+
+        /** Enclosing instance if I'm embedded within another template.
+         *  IF-subtemplates are considered embedded as well.
+         */
+        internal Template enclosingInstance; // who's your daddy?
+
/** Created as instance of which group? We need this to init interpreter
*  via render.  So, we create st and then it needs to know which
*  group created it for sake of polymorphism:
@@ -62,27 +70,6 @@ namespace StringTemplate
*/
public TemplateGroup groupThatCreatedThisInstance;

-        public static readonly Template Blank = new BlankTemplate();
-
-        /** Map an attribute name to its value(s). */
-        protected internal IDictionary<string, object> attributes;
-
-        public class AddEvent
-        {
-            string name;
-            object value;
-            Exception source;
-            public AddEvent(string name, object value)
-            {
-                this.name = name;
-                this.value = value;
-                this.source = new Exception();
-            }
-        }
-
-        /** Track add attribute "events"; used for ST user-level debugging */
-        IList<AddEvent> addEvents;
-
/** Normally, formal parameters hide any attributes inherited from the
*  enclosing template with the same name.  This is normally what you
*  want, but makes it hard to invoke another template passing in all
@@ -91,11 +78,6 @@ namespace StringTemplate
*/
protected internal bool passThroughAttributes = false;

-        /** Enclosing instance if I'm embedded within another template.
-         *  IF-subtemplates are considered embedded as well.
-         */
-        internal Template enclosingInstance; // who's your daddy?
-
/** Just an alias for ArrayList, but this way I can track whether a
*  list is something ST created or it's an incoming list.
*/
@@ -152,13 +134,6 @@ namespace StringTemplate
throw new ArgumentException("cannot have '.' in attribute names");
}

-            if (code.nativeGroup.Detects(ErrorTolerance.DETECT_ADD_ATTR))
-            {
-                if (addEvents == null)
-                    addEvents = new List<AddEvent>();
-                addEvents.Add(new AddEvent(name, value));
-            }
-
if (value is Template)
((Template)value).enclosingInstance = this;

@@ -319,13 +294,24 @@ namespace StringTemplate
return interp.Exec(@out, this);
}

-        public virtual string Render()
+        public virtual int Write(ITemplateWriter @out, CultureInfo culture)
+        {
+            Interpreter interp = new Interpreter(groupThatCreatedThisInstance, culture);
+            return interp.Exec(@out, this);
+        }
+
+        public string Render()
+        {
+            return Render(CultureInfo.CurrentCulture);
+        }
+
+        public virtual string Render(CultureInfo culture)
{
StringWriter @out = new StringWriter();
ITemplateWriter wr = new AutoIndentWriter(@out);
try
{
-                Write(wr);
+                Write(wr, culture);
/*
System.err.println("template size = "+code.template.length()+
", code size = "+code.instrs.length+", ratio = "+
@@ -341,7 +327,7 @@ namespace StringTemplate

public override string ToString()
{
-            return name + "()";
+            return code.name + "()";
}
}
}
diff --git a/StringTemplate4/TemplateGroup.cs b/StringTemplate4/TemplateGroup.cs
index aaac3f0..bda791e 100644
--- a/StringTemplate4/TemplateGroup.cs
+++ b/StringTemplate4/TemplateGroup.cs
@@ -145,7 +145,6 @@ namespace StringTemplate
{
Template instanceST = CreateStringTemplate();
instanceST.groupThatCreatedThisInstance = this;
-                instanceST.name = name;
instanceST.code = c;
return instanceST;
}

