commit e589c63956a9e06aec08b146c2871211c13b1d56
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Tue May 3 20:16:15 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Tue May 3 20:16:15 2011 -0800

(C# 3) Code cleanup

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 8387]

diff --git a/Antlr3.Targets/Antlr3.Targets.ActionScript/ActionScriptTarget.cs b/Antlr3.Targets/Antlr3.Targets.ActionScript/ActionScriptTarget.cs
index 65eba7a..96f7bd3 100644
--- a/Antlr3.Targets/Antlr3.Targets.ActionScript/ActionScriptTarget.cs
+++ b/Antlr3.Targets/Antlr3.Targets.ActionScript/ActionScriptTarget.cs
@@ -60,7 +60,7 @@ namespace Antlr3.Targets
return ttype.ToString();
}

-            string name = generator.grammar.GetTokenDisplayName( ttype );
+            string name = generator.Grammar.GetTokenDisplayName( ttype );

// If name is a literal, return the token type instead
if ( name[0] == '\'' )
diff --git a/Antlr3.Targets/Antlr3.Targets.Cpp/CPPTarget.cs b/Antlr3.Targets/Antlr3.Targets.Cpp/CPPTarget.cs
index 8f5fb72..507ad3a 100644
--- a/Antlr3.Targets/Antlr3.Targets.Cpp/CPPTarget.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Cpp/CPPTarget.cs
@@ -118,7 +118,7 @@ namespace Antlr3.Targets
{
int c = Grammar.GetCharValueFromGrammarCharLiteral( literal );
string prefix = "'";
-            if ( codegen.grammar.MaxCharValue > 255 )
+            if ( codegen.Grammar.MaxCharValue > 255 )
prefix = "L'";
else if ( ( c & 0x80 ) != 0 )	// if in char mode prevent sign extensions
return "" + c;
@@ -136,7 +136,7 @@ namespace Antlr3.Targets
{
StringBuilder buf = Grammar.GetUnescapedStringFromGrammarStringLiteral( literal );
string prefix = "\"";
-            if ( codegen.grammar.MaxCharValue > 255 )
+            if ( codegen.Grammar.MaxCharValue > 255 )
prefix = "L\"";
return prefix + EscapeString( buf.ToString() ) + "\"";
}
diff --git a/Antlr3.Targets/Antlr3.Targets.ObjC/ObjCTarget.cs b/Antlr3.Targets/Antlr3.Targets.ObjC/ObjCTarget.cs
index f3d422f..df17512 100644
--- a/Antlr3.Targets/Antlr3.Targets.ObjC/ObjCTarget.cs
+++ b/Antlr3.Targets/Antlr3.Targets.ObjC/ObjCTarget.cs
@@ -89,7 +89,7 @@ namespace Antlr3.Targets
/** If we have a label, prefix it with the recognizer's name */
public override string GetTokenTypeAsTargetLabel( CodeGenerator generator, int ttype )
{
-            string name = generator.grammar.GetTokenDisplayName( ttype );
+            string name = generator.Grammar.GetTokenDisplayName( ttype );
// If name is a literal, return the token type instead
if ( name[0] == '\'' )
{
@@ -104,7 +104,7 @@ namespace Antlr3.Targets
/** Target must be able to override the labels used for token types. Sometimes also depends on the token text.*/
string GetTokenTextAndTypeAsTargetLabel( CodeGenerator generator, string text, int tokenType )
{
-            string name = generator.grammar.GetTokenDisplayName( tokenType );
+            string name = generator.Grammar.GetTokenDisplayName( tokenType );
// If name is a literal, return the token type instead
if ( name[0] == '\'' )
{
@@ -117,7 +117,7 @@ namespace Antlr3.Targets
}
else
{
-                return generator.grammar.name + Grammar.grammarTypeToFileNameSuffix[(int)generator.grammar.type] + "_" + textEquivalent;
+                return generator.Grammar.name + Grammar.grammarTypeToFileNameSuffix[(int)generator.Grammar.type] + "_" + textEquivalent;
}
}

diff --git a/Antlr3.Targets/Antlr3.Targets.Python/PythonTarget.cs b/Antlr3.Targets/Antlr3.Targets.Python/PythonTarget.cs
index f0ab410..7ef4148 100644
--- a/Antlr3.Targets/Antlr3.Targets.Python/PythonTarget.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Python/PythonTarget.cs
@@ -61,7 +61,7 @@ namespace Antlr3.Targets
return ttype.ToString();
}

-            string name = generator.grammar.GetTokenDisplayName( ttype );
+            string name = generator.Grammar.GetTokenDisplayName( ttype );

// If name is a literal, return the token type instead
if ( name[0] == '\'' )
diff --git a/Antlr3.Targets/Antlr3.Targets.Ruby/RubyTarget.cs b/Antlr3.Targets/Antlr3.Targets.Ruby/RubyTarget.cs
index 3fdedd3..878d5e1 100644
--- a/Antlr3.Targets/Antlr3.Targets.Ruby/RubyTarget.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Ruby/RubyTarget.cs
@@ -454,11 +454,11 @@ namespace Antlr3.Targets

public override string GetTokenTypeAsTargetLabel(CodeGenerator generator, int ttype)
{
-            string name = generator.grammar.GetTokenDisplayName(ttype);
+            string name = generator.Grammar.GetTokenDisplayName(ttype);
// If name is a literal, return the token type instead
if (name[0] == '\'')
{
-                return generator.grammar.ComputeTokenNameFromLiteral(ttype, name);
+                return generator.Grammar.ComputeTokenNameFromLiteral(ttype, name);
}
return name;
}
diff --git a/Antlr3.Test/TestAttributes.cs b/Antlr3.Test/TestAttributes.cs
index a609373..cdc7687 100644
--- a/Antlr3.Test/TestAttributes.cs
+++ b/Antlr3.Test/TestAttributes.cs
@@ -3029,7 +3029,7 @@ namespace AntlrUnitTests

[TestMethod]
public void TestAssignToTreeNodeAttribute() /*throws Exception*/ {
-            string action = "$tree.scope = localScope;";
+            //string action = "$tree.scope = localScope;";
string expecting = "((Object)retval.tree).scope = localScope;";
ErrorQueue equeue = new ErrorQueue();
ErrorManager.SetErrorListener( equeue );
diff --git a/Antlr3.Test/TestCharDFAConversion.cs b/Antlr3.Test/TestCharDFAConversion.cs
index 4cf3209..359042f 100644
--- a/Antlr3.Test/TestCharDFAConversion.cs
+++ b/Antlr3.Test/TestCharDFAConversion.cs
@@ -239,7 +239,7 @@ namespace AntlrUnitTests
optimizer.Optimize();
FASerializer serializer = new FASerializer( g );
DFA dfa = g.GetLookaheadDFA( 1 );
-            string result = serializer.Serialize( dfa.startState );
+            string result = serializer.Serialize( dfa.StartState );
expecting = ".s0-'x'->:s1=>1" + NewLine;
Assert.AreEqual( expecting, result );
}
@@ -560,7 +560,7 @@ namespace AntlrUnitTests
DFA dfa = g.GetLookaheadDFA( decision );
Assert.IsNotNull(dfa, "unknown decision #" + decision);
FASerializer serializer = new FASerializer( g );
-            string result = serializer.Serialize( dfa.startState );
+            string result = serializer.Serialize( dfa.StartState );
//System.out.print(result);
var nonDetAlts = dfa.UnreachableAlts;
//System.out.println("alts w/o predict state="+nonDetAlts);
diff --git a/Antlr3.Test/TestCompositeGrammars.cs b/Antlr3.Test/TestCompositeGrammars.cs
index bbb3671..b29228b 100644
--- a/Antlr3.Test/TestCompositeGrammars.cs
+++ b/Antlr3.Test/TestCompositeGrammars.cs
@@ -234,10 +234,10 @@ namespace AntlrUnitTests
string expectedTypeToTokenList = "[A, B, C, WS]";

Assert.AreEqual( expectedTokenIDToTypeMap,
-                         realElements( g.composite.tokenIDToTypeMap ).ToElementString() );
-            Assert.AreEqual( expectedStringLiteralToTypeMap, g.composite.stringLiteralToTypeMap.ToElementString() );
+                         realElements( g.composite.TokenIDToTypeMap ).ToElementString() );
+            Assert.AreEqual( expectedStringLiteralToTypeMap, g.composite.StringLiteralToTypeMap.ToElementString() );
Assert.AreEqual( expectedTypeToTokenList,
-                         realElements( g.composite.typeToTokenList ).ToElementString() );
+                         realElements( g.composite.TypeToTokenList ).ToElementString() );

Assert.AreEqual(0, equeue.errors.Count, "unexpected errors: " + equeue);
}
@@ -309,10 +309,10 @@ namespace AntlrUnitTests
string expectedTypeToTokenList = "[A, WS, X]";

Assert.AreEqual( expectedTokenIDToTypeMap,
-                         realElements( g.composite.tokenIDToTypeMap ).ToElementString() );
-            Assert.AreEqual( expectedStringLiteralToTypeMap, g.composite.stringLiteralToTypeMap.ToElementString() );
+                         realElements( g.composite.TokenIDToTypeMap ).ToElementString() );
+            Assert.AreEqual( expectedStringLiteralToTypeMap, g.composite.StringLiteralToTypeMap.ToElementString() );
Assert.AreEqual( expectedTypeToTokenList,
-                         realElements( g.composite.typeToTokenList ).ToElementString() );
+                         realElements( g.composite.TypeToTokenList ).ToElementString() );

object expectedArg = "X='a'";
object expectedArg2 = "A";
@@ -362,10 +362,10 @@ namespace AntlrUnitTests
string expectedTypeToTokenList = "[A, WS, T__6]";

Assert.AreEqual( expectedTokenIDToTypeMap,
-                         realElements( g.composite.tokenIDToTypeMap ).ToElementString() );
-            Assert.AreEqual( expectedStringLiteralToTypeMap, sortMapToString( g.composite.stringLiteralToTypeMap ) );
+                         realElements( g.composite.TokenIDToTypeMap ).ToElementString() );
+            Assert.AreEqual( expectedStringLiteralToTypeMap, sortMapToString( g.composite.StringLiteralToTypeMap ) );
Assert.AreEqual( expectedTypeToTokenList,
-                         realElements( g.composite.typeToTokenList ).ToElementString() );
+                         realElements( g.composite.TypeToTokenList ).ToElementString() );

object expectedArg = "A='x'";
object expectedArg2 = "'a'";
@@ -454,10 +454,10 @@ namespace AntlrUnitTests
string expectedTypeToTokenList = "[A, 'a', WS]";

Assert.AreEqual( expectedTokenIDToTypeMap,
-                         realElements( g.composite.tokenIDToTypeMap ).ToElementString() );
-            Assert.AreEqual( expectedStringLiteralToTypeMap, g.composite.stringLiteralToTypeMap.ToElementString() );
+                         realElements( g.composite.TokenIDToTypeMap ).ToElementString() );
+            Assert.AreEqual( expectedStringLiteralToTypeMap, g.composite.StringLiteralToTypeMap.ToElementString() );
Assert.AreEqual( expectedTypeToTokenList,
-                         realElements( g.composite.typeToTokenList ).ToElementString() );
+                         realElements( g.composite.TypeToTokenList ).ToElementString() );

Assert.AreEqual(0, equeue.errors.Count, "unexpected errors: " + equeue);
}
@@ -633,7 +633,7 @@ namespace AntlrUnitTests
".s1-<EOT>->:s2=>1" + NewLine;
Antlr3.Analysis.DFA dfa = g.GetLookaheadDFA( 1 );
FASerializer serializer = new FASerializer( g );
-            string result = serializer.Serialize( dfa.startState );
+            string result = serializer.Serialize( dfa.StartState );
Assert.AreEqual( expectingDFA, result );

// must not be a "unreachable alt: Tokens" error
@@ -781,10 +781,10 @@ namespace AntlrUnitTests
string expectedTypeToTokenList = "[M, S, T]";

Assert.AreEqual( expectedTokenIDToTypeMap,
-                         realElements( g.composite.tokenIDToTypeMap ).ToElementString() );
-            Assert.AreEqual( expectedStringLiteralToTypeMap, g.composite.stringLiteralToTypeMap.ToElementString() );
+                         realElements( g.composite.TokenIDToTypeMap ).ToElementString() );
+            Assert.AreEqual( expectedStringLiteralToTypeMap, g.composite.StringLiteralToTypeMap.ToElementString() );
Assert.AreEqual( expectedTypeToTokenList,
-                         realElements( g.composite.typeToTokenList ).ToElementString() );
+                         realElements( g.composite.TypeToTokenList ).ToElementString() );

Assert.AreEqual(0, equeue.errors.Count, "unexpected errors: " + equeue);

@@ -845,10 +845,10 @@ namespace AntlrUnitTests
string expectedTypeToTokenList = "[A, B, C, M, S, T]";

Assert.AreEqual( expectedTokenIDToTypeMap,
-                         realElements( g.composite.tokenIDToTypeMap ).ToElementString() );
-            Assert.AreEqual( expectedStringLiteralToTypeMap, g.composite.stringLiteralToTypeMap.ToElementString() );
+                         realElements( g.composite.TokenIDToTypeMap ).ToElementString() );
+            Assert.AreEqual( expectedStringLiteralToTypeMap, g.composite.StringLiteralToTypeMap.ToElementString() );
Assert.AreEqual( expectedTypeToTokenList,
-                         realElements( g.composite.typeToTokenList ).ToElementString() );
+                         realElements( g.composite.TypeToTokenList ).ToElementString() );

Assert.AreEqual(0, equeue.errors.Count, "unexpected errors: " + equeue);

@@ -892,10 +892,10 @@ namespace AntlrUnitTests
string expectedTypeToTokenList = "[M, S, T]";

Assert.AreEqual( expectedTokenIDToTypeMap,
-                         realElements( g.composite.tokenIDToTypeMap ).ToElementString() );
-            Assert.AreEqual( expectedStringLiteralToTypeMap, g.composite.stringLiteralToTypeMap.ToElementString() );
+                         realElements( g.composite.TokenIDToTypeMap ).ToElementString() );
+            Assert.AreEqual( expectedStringLiteralToTypeMap, g.composite.StringLiteralToTypeMap.ToElementString() );
Assert.AreEqual( expectedTypeToTokenList,
-                         realElements( g.composite.typeToTokenList ).ToElementString() );
+                         realElements( g.composite.TypeToTokenList ).ToElementString() );

Assert.AreEqual(0, equeue.errors.Count, "unexpected errors: " + equeue);
}
@@ -947,9 +947,9 @@ namespace AntlrUnitTests
string expectedStringLiteralToTypeMap = "{}";
string expectedTypeToTokenList = "[T1, T2, T3, T4]";

-            Assert.AreEqual(expectedTokenIDToTypeMap, realElements(g.composite.tokenIDToTypeMap).ToElementString());
-            Assert.AreEqual(expectedStringLiteralToTypeMap, g.composite.stringLiteralToTypeMap.ToElementString());
-            Assert.AreEqual(expectedTypeToTokenList, realElements(g.composite.typeToTokenList).ToElementString());
+            Assert.AreEqual(expectedTokenIDToTypeMap, realElements(g.composite.TokenIDToTypeMap).ToElementString());
+            Assert.AreEqual(expectedStringLiteralToTypeMap, g.composite.StringLiteralToTypeMap.ToElementString());
+            Assert.AreEqual(expectedTypeToTokenList, realElements(g.composite.TypeToTokenList).ToElementString());

Assert.AreEqual(0, equeue.errors.Count, "unexpected errors: " + equeue);

diff --git a/Antlr3.Test/TestDFAConversion.cs b/Antlr3.Test/TestDFAConversion.cs
index 7c7f972..e3f2ab6 100644
--- a/Antlr3.Test/TestDFAConversion.cs
+++ b/Antlr3.Test/TestDFAConversion.cs
@@ -1766,7 +1766,7 @@ namespace AntlrUnitTests
DFA dfa = g.GetLookaheadDFA( decision );
Assert.IsNotNull( dfa, "no DFA for decision " + decision );
FASerializer serializer = new FASerializer( g );
-            string result = serializer.Serialize( dfa.startState );
+            string result = serializer.Serialize( dfa.StartState );

var unreachableAlts = dfa.UnreachableAlts;

diff --git a/Antlr3.Test/TestSemanticPredicates.cs b/Antlr3.Test/TestSemanticPredicates.cs
index dbbec79..44c53b2 100644
--- a/Antlr3.Test/TestSemanticPredicates.cs
+++ b/Antlr3.Test/TestSemanticPredicates.cs
@@ -864,7 +864,7 @@ namespace AntlrUnitTests

DFA dfa = g.GetLookaheadDFA( decision );
FASerializer serializer = new FASerializer( g );
-            string result = serializer.Serialize( dfa.startState );
+            string result = serializer.Serialize( dfa.StartState );
//System.out.print(result);
var unreachableAlts = dfa.UnreachableAlts;

@@ -911,7 +911,7 @@ namespace AntlrUnitTests
BitSet s2 = new BitSet();
s2.AddAll( nonDetAlts );
Assert.AreEqual(s, s2, "nondet alts mismatch");
-                Assert.AreEqual(hasPredHiddenByAction, nondetMsg.problemState.dfa.hasPredicateBlockedByAction, "mismatch between expected hasPredHiddenByAction");
+                Assert.AreEqual(hasPredHiddenByAction, nondetMsg.problemState.Dfa.HasPredicateBlockedByAction, "mismatch between expected hasPredHiddenByAction");
}
else
{
@@ -933,7 +933,7 @@ namespace AntlrUnitTests
BitSet s2 = new BitSet();
s2.AddAll( actualAlts );
Assert.AreEqual(s, s2, "mismatch between insufficiently covered alts");
-                Assert.AreEqual(hasPredHiddenByAction, insuffPredMsg.problemState.dfa.hasPredicateBlockedByAction, "mismatch between expected hasPredHiddenByAction");
+                Assert.AreEqual(hasPredHiddenByAction, insuffPredMsg.problemState.Dfa.HasPredicateBlockedByAction, "mismatch between expected hasPredHiddenByAction");
}
else
{
diff --git a/Antlr3.Test/TestSymbolDefinitions.cs b/Antlr3.Test/TestSymbolDefinitions.cs
index 61ed66e..c9d94d3 100644
--- a/Antlr3.Test/TestSymbolDefinitions.cs
+++ b/Antlr3.Test/TestSymbolDefinitions.cs
@@ -855,10 +855,10 @@ namespace AntlrUnitTests
string expectedTypeToTokenList = "[SEMI]";

Assert.AreEqual( expectedTokenIDToTypeMap,
-                         realElements( g.composite.tokenIDToTypeMap ).ToElementString() );
-            Assert.AreEqual( expectedStringLiteralToTypeMap, g.composite.stringLiteralToTypeMap.ToElementString() );
+                         realElements( g.composite.TokenIDToTypeMap ).ToElementString() );
+            Assert.AreEqual( expectedStringLiteralToTypeMap, g.composite.StringLiteralToTypeMap.ToElementString() );
Assert.AreEqual( expectedTypeToTokenList,
-                         realElements( g.composite.typeToTokenList ).ToElementString() );
+                         realElements( g.composite.TypeToTokenList ).ToElementString() );

Assert.AreEqual(0, equeue.errors.Count, "unexpected errors: " + equeue);
}
@@ -888,10 +888,10 @@ namespace AntlrUnitTests
string expectedTypeToTokenList = "[SEMI]";

Assert.AreEqual( expectedTokenIDToTypeMap,
-                         realElements( g.composite.tokenIDToTypeMap ).ToElementString() );
-            Assert.AreEqual( expectedStringLiteralToTypeMap, g.composite.stringLiteralToTypeMap.ToElementString() );
+                         realElements( g.composite.TokenIDToTypeMap ).ToElementString() );
+            Assert.AreEqual( expectedStringLiteralToTypeMap, g.composite.StringLiteralToTypeMap.ToElementString() );
Assert.AreEqual( expectedTypeToTokenList,
-                         realElements( g.composite.typeToTokenList ).ToElementString() );
+                         realElements( g.composite.TypeToTokenList ).ToElementString() );

Assert.AreEqual(0, equeue.errors.Count, "unexpected errors: " + equeue);
}
diff --git a/Antlr3/Analysis/ActionLabel.cs b/Antlr3/Analysis/ActionLabel.cs
index 1effda9..a8585bb 100644
--- a/Antlr3/Analysis/ActionLabel.cs
+++ b/Antlr3/Analysis/ActionLabel.cs
@@ -37,7 +37,7 @@ namespace Antlr3.Analysis

public class ActionLabel : Label
{
-        GrammarAST _actionAST;
+        private readonly GrammarAST _actionAST;

public ActionLabel( GrammarAST actionAST )
: base( ACTION )
diff --git a/Antlr3/Analysis/Cyclic.cs b/Antlr3/Analysis/Cyclic.cs
new file mode 100644
index 0000000..6ccc3fb
--- /dev/null
+++ b/Antlr3/Analysis/Cyclic.cs
@@ -0,0 +1,41 @@
+﻿/*
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Analysis
+{
+    public enum Cyclic
+    {
+        Unknown = -2,
+        Busy = -1, // in process of computing
+        Done = 0,
+    }
+}
diff --git a/Antlr3/Analysis/DFA.cs b/Antlr3/Analysis/DFA.cs
index 25a05c9..1736173 100644
--- a/Antlr3/Analysis/DFA.cs
+++ b/Antlr3/Analysis/DFA.cs
@@ -32,7 +32,6 @@

namespace Antlr3.Analysis
{
-    using System;
using System.Collections.Generic;
using System.Linq;
using Antlr.Runtime.JavaExtensions;
@@ -42,8 +41,10 @@ namespace Antlr3.Analysis
using IIntSet = Antlr3.Misc.IIntSet;
using IIntStream = Antlr.Runtime.IIntStream;
using IntervalSet = Antlr3.Misc.IntervalSet;
+    using Math = System.Math;
using StringBuilder = System.Text.StringBuilder;
using StringTemplate = Antlr4.StringTemplate.Template;
+    using TimeSpan = System.TimeSpan;

/** A DFA (converted from a grammar's NFA).
*  DFAs are used as prediction machine for alternative blocks in all kinds
@@ -51,15 +52,6 @@ namespace Antlr3.Analysis
*/
public class DFA
{
-        public const int REACHABLE_UNKNOWN = -2;
-        public const int REACHABLE_BUSY = -1; // in process of computing
-        public const int REACHABLE_NO = 0;
-        public const int REACHABLE_YES = 1;
-
-        public const int CYCLIC_UNKNOWN = -2;
-        public const int CYCLIC_BUSY = -1; // in process of computing
-        public const int CYCLIC_DONE = 0;
-
#if false
/** Prevent explosion of DFA states during conversion. The max number
*  of states per alt in a single decision's DFA.
@@ -76,16 +68,16 @@ namespace Antlr3.Analysis
public static int MAX_STATE_TRANSITIONS_FOR_TABLE = 65534;

/** What's the start state for this DFA? */
-        public DFAState startState;
+        private DFAState _startState;

/** This DFA is being built for which decision? */
-        public int decisionNumber = 0;
+        private readonly int _decisionNumber;

/** From what NFAState did we create the DFA? */
-        NFAState _decisionNFAStartState;
+        private readonly NFAState _decisionNFAStartState;

/** The printable grammar fragment associated with this DFA */
-        string _description;
+        private string _description;

/** A set of all uniquely-numbered DFA states.  Maps hash of DFAState
*  to the actual DFAState object.  We use this to detect
@@ -94,7 +86,7 @@ namespace Antlr3.Analysis
*  Not used during fixed k lookahead as it's a waste to fill it with
*  a dup of states array.
*/
-        IDictionary<DFAState, DFAState> _uniqueStates = new Dictionary<DFAState, DFAState>();
+        private readonly Dictionary<DFAState, DFAState> _uniqueStates = new Dictionary<DFAState, DFAState>();

/** Maps the state number to the actual DFAState.  Use a Vector as it
*  grows automatically when I set the ith element.  This contains all
@@ -107,38 +99,40 @@ namespace Antlr3.Analysis
*  a way to go from state number to DFAState rather than via a
*  hash lookup.
*/
-        List<DFAState> _states = new List<DFAState>();
+        private readonly List<DFAState> _states = new List<DFAState>();

/** Unique state numbers per DFA */
-        int _stateCounter = 0;
+        private int _stateCounter = 0;

/** count only new states not states that were rejected as already present */
-        int _numberOfStates = 0;
+        private int _numberOfStates = 0;

/** User specified max fixed lookahead.  If 0, nothing specified.  -1
*  implies we have not looked at the options table yet to set k.
*/
-        int _userK = -1;
+        private int _userK = -1;

-        /** While building the DFA, track max lookahead depth if not cyclic */
-        internal int max_k = -1;
+        /// <summary>
+        /// While building the DFA, track max lookahead depth if not cyclic.
+        /// </summary>
+        private int _max_k = -1;

/** Is this DFA reduced?  I.e., can all states lead to an accept state? */
-        bool _reduced = true;
+        private bool _reduced = true;

/** Are there any loops in this DFA?
*  Computed by doesStateReachAcceptState()
*/
-        bool _cyclic = false;
+        private bool _cyclic = false;

/** Track whether this DFA has at least one sem/syn pred encountered
*  during a closure operation.  This is useful for deciding whether
*  to retry a non-LL(*) with k=1.  If no pred, it will not work w/o
*  a pred so don't bother.  It would just give another error message.
*/
-        public bool predicateVisible = false;
+        private bool _predicateVisible = false;

-        public bool hasPredicateBlockedByAction = false;
+        private bool _hasPredicateBlockedByAction = false;

/** Each alt in an NFA derived from a grammar must have a DFA state that
*  predicts it lest the parser not know what to do.  Nondeterminisms can
@@ -149,29 +143,29 @@ namespace Antlr3.Analysis
*  and then in method doesStateReachAcceptState() I remove the alts I
*  know to be uniquely predicted.
*/
-        List<int> _unreachableAlts;
+        private readonly List<int> _unreachableAlts;

-        int _nAlts = 0;
+        private readonly int _numberOfAlts = 0;

/** We only want one accept state per predicted alt; track here */
-        DFAState[] _altToAcceptState;
+        private readonly DFAState[] _altToAcceptState;

/** Track whether an alt discovers recursion for each alt during
*  NFA to DFA conversion; >1 alt with recursion implies nonregular.
*/
-        public IIntSet recursiveAltSet = new IntervalSet();
+        private readonly IIntSet _recursiveAltSet = new IntervalSet();

/** Which NFA are we converting (well, which piece of the NFA)? */
-        public NFA nfa;
+        private readonly NFA _nfa;

-        NFAToDFAConverter _nfaConverter;
+        private readonly NFAToDFAConverter _nfaConverter;

/** This probe tells you a lot about a decision and is useful even
*  when there is no error such as when a syntactic nondeterminism
*  is solved via semantic predicates.  Perhaps a GUI would want
*  the ability to show that.
*/
-        public DecisionProbe probe;
+        private readonly DecisionProbe _probe;

/** Map an edge transition table to a unique set number; ordered so
*  we can push into the output template as an ordered list of sets
@@ -188,14 +182,14 @@ namespace Antlr3.Analysis
*     	  ...
*      };
*/
-        IDictionary<int[], int?> _edgeTransitionClassMap = new Dictionary<int[], int?>();
+        private readonly Dictionary<int[], int?> _edgeTransitionClassMap = new Dictionary<int[], int?>();

/** The unique edge transition class number; every time we see a new
*  set of edges emanating from a state, we number it so we can reuse
*  if it's every seen again for another state.  For Java grammar,
*  some of the big edge transition tables are seen about 57 times.
*/
-        int _edgeTransitionClass = 0;
+        private int _edgeTransitionClass = 0;

/* This DFA can be converted to a transition[state][char] table and
* the following tables are filled by createStateTables upon request.
@@ -207,40 +201,37 @@ namespace Antlr3.Analysis
*/

/** List of special DFAState objects */
-        IList<DFAState> _specialStates;
+        private IList<DFAState> _specialStates;
+
/** List of ST for special states. */
-        IList<StringTemplate> _specialStateSTs;
-        const int EmptyValue = -1;
-        int[] _accept;
-        int[] _eot;
-        int[] _eof;
-        int[] _min;
-        int[] _max;
-        int[] _special;
-        int[][] _transition;
+        private IList<StringTemplate> _specialStateSTs;
+        private const int EmptyValue = -1;
+        private int[] _accept;
+        private int[] _eot;
+        private int[] _eof;
+        private int[] _min;
+        private int[] _max;
+        private int[] _special;
+        private int[][] _transition;
/** just the Vector&lt;Integer&gt; indicating which unique edge table is at
*  position i.
*/
-        List<int?> _transitionEdgeTables; // not used by java yet
-        int _uniqueCompressedSpecialStateNum = 0;
+        private List<int?> _transitionEdgeTables; // not used by java yet
+        private int _uniqueCompressedSpecialStateNum;

/** Which generator to use if we're building state tables */
-        CodeGenerator _generator = null;
-
-        protected DFA()
-        {
-            probe = new DecisionProbe( this );
-        }
+        private CodeGenerator _generator;

public DFA( int decisionNumber, NFAState decisionStartState )
-            : this()
{
-            this.decisionNumber = decisionNumber;
+            _probe = new DecisionProbe(this);
+            this._decisionNumber = decisionNumber;
this._decisionNFAStartState = decisionStartState;
-            nfa = decisionStartState.nfa;
-            _nAlts = nfa.grammar.GetNumberOfAltsForDecisionNFA( decisionStartState );
+            _nfa = decisionStartState.nfa;
+            _numberOfAlts = Nfa.Grammar.GetNumberOfAltsForDecisionNFA( decisionStartState );
//setOptions( nfa.grammar.getDecisionOptions(getDecisionNumber()) );
-            InitAltRelatedInfo();
+            _altToAcceptState = new DFAState[NumberOfAlts + 1];
+            _unreachableAlts = new List<int>(Enumerable.Range(1, NumberOfAlts));

//long start = JSystem.currentTimeMillis();
_nfaConverter = new NFAToDFAConverter( this );
@@ -251,9 +242,9 @@ namespace Antlr3.Analysis
// figure out if there are problems with decision
Verify();

-                if ( !probe.IsDeterministic || probe.AnalysisOverflowed )
+                if ( !Probe.IsDeterministic || Probe.AnalysisOverflowed )
{
-                    probe.IssueWarnings();
+                    Probe.IssueWarnings();
}

// must be after verify as it computes cyclic, needed by this routine
@@ -266,33 +257,43 @@ namespace Antlr3.Analysis
}
catch ( NonLLStarDecisionException /*nonLL*/ )
{
-                probe.ReportNonLLStarDecision( this );
+                Probe.ReportNonLLStarDecision( this );
// >1 alt recurses, k=* and no auto backtrack nor manual sem/syn
if ( !OkToRetryWithK1 )
{
-                    probe.IssueWarnings();
+                    Probe.IssueWarnings();
}
}
}

#region Properties

+        public NFA Nfa
+        {
+            get
+            {
+                return _nfa;
+            }
+        }
+
public bool CanInlineDecision
{
get
{
return !IsCyclic &&
-                    !probe.IsNonLLStarDecision &&
+                    !Probe.IsNonLLStarDecision &&
NumberOfStates < CodeGenerator.MaxAcyclicDfaStatesInline;
}
}
+
public bool AutoBacktrackMode
{
get
{
-                return GetAutoBacktrackMode();
+                return Nfa.Grammar.GetAutoBacktrackMode(DecisionNumber);
}
}
+
/** What GrammarAST node (derived from the grammar) is this DFA
*  associated with?  It will point to the start of a block or
*  the loop back of a (...)+ block etc...
@@ -304,21 +305,49 @@ namespace Antlr3.Analysis
return _decisionNFAStartState.associatedASTNode;
}
}
-        [CLSCompliant(false)]
+
+        public DFAState StartState
+        {
+            get
+            {
+                return _startState;
+            }
+
+            set
+            {
+                _startState = value;
+            }
+        }
+
public int DecisionNumber
{
get
{
+                return _decisionNumber;
+            }
+        }
+
+        public int NfaStartStateDecisionNumber
+        {
+            get
+            {
return _decisionNFAStartState.DecisionNumber;
}
}
+
public string Description
{
get
{
return _description;
}
+
+            private set
+            {
+                _description = value;
+            }
}
+
/** Is this DFA cyclic?  That is, are there any loops?  If not, then
*  the DFA is essentially an LL(k) predictor for some fixed, max k value.
*  We can build a series of nested IF statements to match this.  In the
@@ -333,13 +362,39 @@ namespace Antlr3.Analysis
}
}

+        public bool PredicateVisible
+        {
+            get
+            {
+                return _predicateVisible;
+            }
+
+            set
+            {
+                _predicateVisible = value;
+            }
+        }
+
+        public bool HasPredicateBlockedByAction
+        {
+            get
+            {
+                return _hasPredicateBlockedByAction;
+            }
+
+            set
+            {
+                _hasPredicateBlockedByAction = value;
+            }
+        }
+
public bool IsClassicDFA
{
get
{
return !IsCyclic &&
-                       !nfa.grammar.decisionsWhoseDFAsUsesSemPreds.Contains(this) &&
-                       !nfa.grammar.decisionsWhoseDFAsUsesSynPreds.Contains(this);
+                       !Nfa.Grammar.decisionsWhoseDFAsUsesSemPreds.Contains(this) &&
+                       !Nfa.Grammar.decisionsWhoseDFAsUsesSynPreds.Contains(this);
}
}

@@ -350,6 +405,31 @@ namespace Antlr3.Analysis
return GetIsGreedy();
}
}
+
+        /// <summary>
+        /// While building the DFA, track max lookahead depth if not cyclic.
+        /// </summary>
+        public int MaxLookahead
+        {
+            get
+            {
+                return _max_k;
+            }
+
+            set
+            {
+                _max_k = value;
+            }
+        }
+
+        public IIntSet RecursiveAltSet
+        {
+            get
+            {
+                return _recursiveAltSet;
+            }
+        }
+
/** Is the DFA reduced?  I.e., does every state have a path to an accept
*  state?  If not, don't delete as we need to generate an error indicating
*  which paths are "dead ends".  Also tracks list of alts with no accept
@@ -379,7 +459,7 @@ namespace Antlr3.Analysis
if (HasCycle)
return int.MaxValue;
// compute to be sure
-                return CalculateMaxLookaheadDepth(startState, 0);
+                return CalculateMaxLookaheadDepth(StartState, 0);
}
}

@@ -393,28 +473,31 @@ namespace Antlr3.Analysis
return _states.Count - 1;
}
}
+
public NFAState NFADecisionStartState
{
get
{
return _decisionNFAStartState;
}
-            set
-            {
-                _decisionNFAStartState = value;
-            }
}
+
public int NumberOfAlts
{
get
{
-                return _nAlts;
+                return _numberOfAlts;
}
-            set
+        }
+
+        public DecisionProbe Probe
+        {
+            get
{
-                _nAlts = value;
+                return _probe;
}
}
+
public int NumberOfStates
{
get
@@ -441,6 +524,7 @@ namespace Antlr3.Analysis
return GetReasonForFailure();
}
}
+
public IList<StringTemplate> SpecialStateSTs
{
get
@@ -448,6 +532,7 @@ namespace Antlr3.Analysis
return _specialStateSTs;
}
}
+
public IDictionary<DFAState, DFAState> UniqueStates
{
get
@@ -455,6 +540,7 @@ namespace Antlr3.Analysis
return _uniqueStates;
}
}
+
/** Return a list of Integer alt numbers for which no lookahead could
*  be computed or for which no single DFA accept state predicts those
*  alts.  Must call verify() first before this makes sense.
@@ -465,11 +551,8 @@ namespace Antlr3.Analysis
{
return _unreachableAlts;
}
-            set
-            {
-                _unreachableAlts = value;
-            }
}
+
public int UserMaxLookahead
{
get
@@ -486,7 +569,7 @@ namespace Antlr3.Analysis
int max = depth;
for (int i = 0; i < d.NumberOfTransitions; i++)
{
-                Transition t = d.Transition(i);
+                Transition t = d.GetTransition(i);
//			if ( t.isSemanticPredicate() ) return Integer.MAX_VALUE;
if (!t.IsSemanticPredicate)
{
@@ -518,7 +601,7 @@ namespace Antlr3.Analysis
{
get
{
-                bool has = CalculateHasSynPred(startState, new HashSet<DFAState>());
+                bool has = CalculateHasSynPred(StartState, new HashSet<DFAState>());
//		if ( !has ) {
//			System.out.println("no synpred in dec "+decisionNumber);
//			FASerializer serializer = new FASerializer(nfa.grammar);
@@ -534,7 +617,7 @@ namespace Antlr3.Analysis
busy.Add(d);
for (int i = 0; i < d.NumberOfTransitions; i++)
{
-                Transition t = d.Transition(i);
+                Transition t = d.GetTransition(i);
if (t.IsSemanticPredicate)
{
SemanticContext ctx = t.Label.SemanticContext;
@@ -557,7 +640,7 @@ namespace Antlr3.Analysis
{
get
{ // has user-defined sempred
-                bool has = CalculateHasSemPred(startState, new HashSet<DFAState>());
+                bool has = CalculateHasSemPred(StartState, new HashSet<DFAState>());
return has;
}
}
@@ -567,7 +650,7 @@ namespace Antlr3.Analysis
busy.Add(d);
for (int i = 0; i < d.NumberOfTransitions; i++)
{
-                Transition t = d.Transition(i);
+                Transition t = d.GetTransition(i);
if (t.IsSemanticPredicate)
{
SemanticContext ctx = t.Label.SemanticContext;
@@ -587,27 +670,27 @@ namespace Antlr3.Analysis
{
get
{
-                bool cyclic = CalculateHasCycle(startState, new Dictionary<DFAState, int>());
+                bool cyclic = CalculateHasCycle(StartState, new Dictionary<DFAState, Cyclic>());
return cyclic;
}
}

-        internal virtual bool CalculateHasCycle(DFAState d, IDictionary<DFAState, int> busy)
+        internal virtual bool CalculateHasCycle(DFAState d, IDictionary<DFAState, Cyclic> busy)
{
-            busy[d] = CYCLIC_BUSY;
+            busy[d] = Cyclic.Busy;
for (int i = 0; i < d.NumberOfTransitions; i++)
{
-                Transition t = d.Transition(i);
+                Transition t = d.GetTransition(i);
DFAState target = (DFAState)t.Target;
-                int cond;
+                Cyclic cond;
if (!busy.TryGetValue(target, out cond))
-                    cond = CYCLIC_UNKNOWN;
-                if (cond == CYCLIC_BUSY)
+                    cond = Cyclic.Unknown;
+                if (cond == Cyclic.Busy)
return true;
-                if (cond != CYCLIC_DONE && CalculateHasCycle(target, busy))
+                if (cond != Cyclic.Done && CalculateHasCycle(target, busy))
return true;
}
-            busy[d] = CYCLIC_DONE;
+            busy[d] = Cyclic.Done;
return false;
}

@@ -661,7 +744,7 @@ namespace Antlr3.Analysis
}
if ( snum != NumberOfStates )
{
-                ErrorManager.InternalError( "DFA " + decisionNumber + ": " +
+                ErrorManager.InternalError( "DFA " + DecisionNumber + ": " +
_decisionNFAStartState.Description + " num unique states " + NumberOfStates +
"!= num renumbered states " + snum );
}
@@ -761,8 +844,8 @@ namespace Antlr3.Analysis
break;
}
}
-                encoded.Add( _generator.target.EncodeIntAsCharEscape( (char)n ) );
-                encoded.Add( _generator.target.EncodeIntAsCharEscape( (char)(int)I ) );
+                encoded.Add( _generator.Target.EncodeIntAsCharEscape( (char)n ) );
+                encoded.Add( _generator.Target.EncodeIntAsCharEscape( (char)(int)I ) );
i += n;
}
return encoded;
@@ -772,9 +855,8 @@ namespace Antlr3.Analysis
{
//JSystem.@out.println("createTables:\n"+this);
this._generator = generator;
-            _description = NFADecisionStartState.Description;
-            _description =
-                generator.target.GetTargetStringLiteralFromString( _description );
+            Description = NFADecisionStartState.Description;
+            Description = generator.Target.GetTargetStringLiteralFromString( Description );

// create all the tables
//special = new List<int>( this.NumberOfStates ); // Vector<short>
@@ -812,6 +894,7 @@ namespace Antlr3.Analysis
{
it = UniqueStates.Values;
}
+
foreach ( DFAState s in it )
{
if ( s == null )
@@ -820,6 +903,7 @@ namespace Antlr3.Analysis
// when inlining DFA (due to lacking of exit branch pruning?)
continue;
}
+
if ( s.IsAcceptState )
{
// can't compute min,max,special,transition on accepts
@@ -837,9 +921,8 @@ namespace Antlr3.Analysis
// now that we have computed list of specialStates, gen code for 'em
for ( int i = 0; i < _specialStates.Count; i++ )
{
-                DFAState ss = (DFAState)_specialStates[i];
-                StringTemplate stateST =
-                    generator.GenerateSpecialState( ss );
+                DFAState ss = _specialStates[i];
+                StringTemplate stateST = generator.GenerateSpecialState( ss );
_specialStateSTs.Add( stateST );
}

@@ -901,7 +984,7 @@ namespace Antlr3.Analysis
int smax = Label.MIN_ATOM_VALUE - 1;
for ( int j = 0; j < s.NumberOfTransitions; j++ )
{
-                Transition edge = (Transition)s.Transition( j );
+                Transition edge = (Transition)s.GetTransition( j );
Label label = edge.Label;
if ( label.IsAtom )
{
@@ -965,7 +1048,7 @@ namespace Antlr3.Analysis
_transition[s.StateNumber] = stateTransitions;
for ( int j = 0; j < s.NumberOfTransitions; j++ )
{
-                Transition edge = s.Transition( j );
+                Transition edge = s.GetTransition( j );
Label label = edge.Label;
if ( label.IsAtom && label.Atom >= Label.MIN_CHAR_VALUE )
{
@@ -1006,7 +1089,7 @@ namespace Antlr3.Analysis
{
for ( int j = 0; j < s.NumberOfTransitions; j++ )
{
-                Transition edge = s.Transition( j );
+                Transition edge = s.GetTransition( j );
Label label = edge.Label;
if ( label.IsAtom )
{
@@ -1044,7 +1127,7 @@ namespace Antlr3.Analysis
// TODO this code is very similar to canGenerateSwitch.  Refactor to share
for ( int j = 0; j < s.NumberOfTransitions; j++ )
{
-                Transition edge = (Transition)s.Transition( j );
+                Transition edge = (Transition)s.GetTransition( j );
Label label = edge.Label;
// can't do a switch if the edges have preds or are going to
// require gated predicates
@@ -1072,7 +1155,7 @@ namespace Antlr3.Analysis

public virtual int Predict( IIntStream input )
{
-            Interpreter interp = new Interpreter( nfa.grammar, input );
+            Interpreter interp = new Interpreter( Nfa.Grammar, input );
return interp.Predict( this );
}

@@ -1135,12 +1218,12 @@ namespace Antlr3.Analysis
/** Is this DFA derived from the NFA for the Tokens rule? */
public virtual bool GetIsTokensRuleDecision()
{
-            if ( nfa.grammar.type != GrammarType.Lexer )
+            if ( Nfa.Grammar.type != GrammarType.Lexer )
{
return false;
}
NFAState nfaStart = NFADecisionStartState;
-            Rule r = nfa.grammar.GetLocallyDefinedRule( Grammar.ArtificialTokensRuleName );
+            Rule r = Nfa.Grammar.GetLocallyDefinedRule( Grammar.ArtificialTokensRuleName );
NFAState TokensRuleStart = r.StartState;
NFAState TokensDecisionStart =
(NFAState)TokensRuleStart.transition[0].Target;
@@ -1154,16 +1237,13 @@ namespace Antlr3.Analysis
public virtual int GetUserMaxLookahead()
{
if ( _userK >= 0 )
-            { // cache for speed
+            {
+                // cache for speed
return _userK;
}
-            _userK = nfa.grammar.GetUserMaxLookahead( decisionNumber );
-            return _userK;
-        }

-        public virtual bool GetAutoBacktrackMode()
-        {
-            return nfa.grammar.GetAutoBacktrackMode( decisionNumber );
+            _userK = Nfa.Grammar.GetUserMaxLookahead( DecisionNumber );
+            return _userK;
}

public virtual void SetUserMaxLookahead( int k )
@@ -1185,7 +1265,7 @@ namespace Antlr3.Analysis
*/
public virtual void Verify()
{
-            DoesStateReachAcceptState( startState );
+            DoesStateReachAcceptState( StartState );
}

/** figure out if this state eventually reaches an accept state and
@@ -1206,15 +1286,15 @@ namespace Antlr3.Analysis
if ( d.IsAcceptState )
{
// accept states have no edges emanating from them so we can return
-                d.AcceptStateReachable = REACHABLE_YES;
+                d.AcceptStateReachable = Reachable.Yes;
// this alt is uniquely predicted, remove from nondeterministic list
int predicts = d.GetUniquelyPredictedAlt();
-                _unreachableAlts.Remove( predicts );
+                UnreachableAlts.Remove( predicts );
return true;
}

// avoid infinite loops
-            d.AcceptStateReachable = REACHABLE_BUSY;
+            d.AcceptStateReachable = Reachable.Busy;

bool anEdgeReachesAcceptState = false;
// Visit every transition, track if at least one edge reaches stop state
@@ -1222,23 +1302,29 @@ namespace Antlr3.Analysis
// all transitions must be traversed to set status of each DFA state.
for ( int i = 0; i < d.NumberOfTransitions; i++ )
{
-                Transition t = d.Transition( i );
+                Transition t = d.GetTransition( i );
DFAState edgeTarget = (DFAState)t.Target;
-                int targetStatus = edgeTarget.AcceptStateReachable;
-                if ( targetStatus == REACHABLE_BUSY )
-                { // avoid cycles; they say nothing
+                Reachable targetStatus = edgeTarget.AcceptStateReachable;
+                if ( targetStatus == Reachable.Busy )
+                {
+                    // avoid cycles; they say nothing
_cyclic = true;
continue;
}
-                if ( targetStatus == REACHABLE_YES )
-                { // avoid unnecessary work
+
+                if ( targetStatus == Reachable.Yes )
+                {
+                    // avoid unnecessary work
anEdgeReachesAcceptState = true;
continue;
}
-                if ( targetStatus == REACHABLE_NO )
-                {  // avoid unnecessary work
+
+                if ( targetStatus == Reachable.No )
+                {
+                    // avoid unnecessary work
continue;
}
+
// target must be REACHABLE_UNKNOWN (i.e., unvisited)
if ( DoesStateReachAcceptState( edgeTarget ) )
{
@@ -1247,15 +1333,17 @@ namespace Antlr3.Analysis
// must cover all states even if we find a path for this state
}
}
+
if ( anEdgeReachesAcceptState )
{
-                d.AcceptStateReachable = REACHABLE_YES;
+                d.AcceptStateReachable = Reachable.Yes;
}
else
{
-                d.AcceptStateReachable = REACHABLE_NO;
+                d.AcceptStateReachable = Reachable.No;
_reduced = false;
}
+
return anEdgeReachesAcceptState;
}

@@ -1282,7 +1370,7 @@ namespace Antlr3.Analysis
foreach ( SemanticContext semctx in synpreds )
{
// JSystem.@out.println("synpreds: "+semctx);
-                            nfa.grammar.SynPredUsedInDFA( this, semctx );
+                            Nfa.Grammar.SynPredUsedInDFA( this, semctx );
}
}
}
@@ -1309,8 +1397,8 @@ namespace Antlr3.Analysis
public virtual bool OkToRetryDFAWithK1()
{
bool nonLLStarOrOverflowAndPredicateVisible =
-                ( probe.IsNonLLStarDecision || probe.AnalysisOverflowed ) &&
-                predicateVisible; // auto backtrack or manual sem/syn
+                ( Probe.IsNonLLStarDecision || Probe.AnalysisOverflowed ) &&
+                _predicateVisible; // auto backtrack or manual sem/syn

return UserMaxLookahead != 1 && nonLLStarOrOverflowAndPredicateVisible;
}
@@ -1318,18 +1406,18 @@ namespace Antlr3.Analysis
public virtual string GetReasonForFailure()
{
StringBuilder buf = new StringBuilder();
-            if ( probe.IsNonLLStarDecision )
+            if ( Probe.IsNonLLStarDecision )
{
buf.Append( "non-LL(*)" );
-                if ( predicateVisible )
+                if ( _predicateVisible )
{
buf.Append( " && predicate visible" );
}
}
-            if ( probe.AnalysisOverflowed )
+            if ( Probe.AnalysisOverflowed )
{
buf.Append( "recursion overflow" );
-                if ( predicateVisible )
+                if ( _predicateVisible )
{
buf.Append( " && predicate visible" );
}
@@ -1341,8 +1429,8 @@ namespace Antlr3.Analysis

public virtual bool GetIsGreedy()
{
-            GrammarAST blockAST = nfa.grammar.GetDecisionBlockAST( decisionNumber );
-            Object v = nfa.grammar.GetBlockOption( blockAST, "greedy" );
+            GrammarAST blockAST = Nfa.Grammar.GetDecisionBlockAST( DecisionNumber );
+            object v = Nfa.Grammar.GetBlockOption( blockAST, "greedy" );
if ( v != null && v.Equals( "false" ) )
{
return false;
@@ -1361,24 +1449,14 @@ namespace Antlr3.Analysis
return n;
}

-        protected virtual void InitAltRelatedInfo()
-        {
-            _unreachableAlts = new List<int>();
-            for ( int i = 1; i <= _nAlts; i++ )
-            {
-                _unreachableAlts.Add( i );
-            }
-            _altToAcceptState = new DFAState[_nAlts + 1];
-        }
-
public override string ToString()
{
-            FASerializer serializer = new FASerializer( nfa.grammar );
-            if ( startState == null )
+            FASerializer serializer = new FASerializer( Nfa.Grammar );
+            if ( StartState == null )
{
return "";
}
-            return serializer.Serialize( startState, false );
+            return serializer.Serialize( StartState, false );
}

#if false
diff --git a/Antlr3/Analysis/DFAOptimizer.cs b/Antlr3/Analysis/DFAOptimizer.cs
index ee98e13..70cd18a 100644
--- a/Antlr3/Analysis/DFAOptimizer.cs
+++ b/Antlr3/Analysis/DFAOptimizer.cs
@@ -34,6 +34,7 @@ namespace Antlr3.Analysis
{
using System.Collections.Generic;

+    using ArgumentNullException = System.ArgumentNullException;
using Grammar = Antlr3.Tool.Grammar;

/** A module to perform optimizations on DFAs.
@@ -129,12 +130,15 @@ namespace Antlr3.Analysis
*  This is a side-effect of calling optimize; can't clear after use
*  because code gen needs it.
*/
-        HashSet<object> _visited = new HashSet<object>();
+        private readonly HashSet<object> _visited = new HashSet<object>();

-        Grammar _grammar;
+        private readonly Grammar _grammar;

public DFAOptimizer( Grammar grammar )
{
+            if (grammar == null)
+                throw new ArgumentNullException("grammar");
+
this._grammar = grammar;
}

@@ -170,16 +174,16 @@ namespace Antlr3.Analysis
( decisionType == NFAState.OPTIONAL_BLOCK_START ||
decisionType == NFAState.LOOPBACK ) )
{
-                    OptimizeExitBranches( dfa.startState );
+                    OptimizeExitBranches( dfa.StartState );
}
}
// If the Tokens rule has syntactically ambiguous rules, try to prune
if ( PRUNE_TOKENS_RULE_SUPERFLUOUS_EOT_EDGES &&
dfa.IsTokensRuleDecision &&
-                 dfa.probe.stateToSyntacticallyAmbiguousTokensRuleAltsMap.Count > 0 )
+                 dfa.Probe.stateToSyntacticallyAmbiguousTokensRuleAltsMap.Count > 0 )
{
_visited.Clear();
-                OptimizeEOTBranches( dfa.startState );
+                OptimizeEOTBranches( dfa.StartState );
}

/* ack...code gen needs this, cannot optimize
@@ -190,18 +194,21 @@ namespace Antlr3.Analysis
//JSystem.@out.println("minimized in "+(int)(stop-start)+" ms");
}

-        protected virtual void OptimizeExitBranches( DFAState d )
+        protected virtual void OptimizeExitBranches( DFAState state )
{
-            int sI = d.StateNumber;
+            if (state == null)
+                throw new ArgumentNullException("state");
+
+            int sI = state.StateNumber;
if ( _visited.Contains( sI ) )
{
return; // already visited
}
_visited.Add( sI );
-            int nAlts = d.dfa.NumberOfAlts;
-            for ( int i = 0; i < d.NumberOfTransitions; i++ )
+            int nAlts = state.Dfa.NumberOfAlts;
+            for ( int i = 0; i < state.NumberOfTransitions; i++ )
{
-                Transition edge = (Transition)d.Transition( i );
+                Transition edge = (Transition)state.GetTransition( i );
DFAState edgeTarget = ( (DFAState)edge.Target );
/*
JSystem.@out.println(d.stateNumber+"-"+
@@ -216,24 +223,27 @@ namespace Antlr3.Analysis
JSystem.@out.println("ignoring transition "+i+" to max alt "+
d.dfa.getNumberOfAlts());
*/
-                    d.RemoveTransition( i );
+                    state.RemoveTransition( i );
i--; // back up one so that i++ of loop iteration stays within bounds
}
OptimizeExitBranches( edgeTarget );
}
}

-        protected virtual void OptimizeEOTBranches( DFAState d )
+        protected virtual void OptimizeEOTBranches( DFAState state )
{
-            int sI = d.StateNumber;
+            if (state == null)
+                throw new ArgumentNullException("state");
+
+            int sI = state.StateNumber;
if ( _visited.Contains( sI ) )
{
return; // already visited
}
_visited.Add( sI );
-            for ( int i = 0; i < d.NumberOfTransitions; i++ )
+            for ( int i = 0; i < state.NumberOfTransitions; i++ )
{
-                Transition edge = (Transition)d.Transition( i );
+                Transition edge = state.GetTransition( i );
DFAState edgeTarget = ( (DFAState)edge.Target );
/*
JSystem.@out.println(d.stateNumber+"-"+
@@ -243,17 +253,16 @@ namespace Antlr3.Analysis
// if only one edge coming out, it is EOT, and target is accept prune
if ( PRUNE_TOKENS_RULE_SUPERFLUOUS_EOT_EDGES &&
edgeTarget.IsAcceptState &&
-                    d.NumberOfTransitions == 1 &&
+                    state.NumberOfTransitions == 1 &&
edge.Label.IsAtom &&
edge.Label.Atom == Label.EOT )
{
//JSystem.@out.println("state "+d+" can be pruned");
// remove the superfluous EOT edge
-                    d.RemoveTransition( i );
-                    d.IsAcceptState = true; // make it an accept state
+                    state.RemoveTransition( i );
+                    state.IsAcceptState = true; // make it an accept state
// force it to uniquely predict the originally predicted state
-                    d.cachedUniquelyPredicatedAlt =
-                        edgeTarget.GetUniquelyPredictedAlt();
+                    state.CachedUniquelyPredicatedAlt = edgeTarget.GetUniquelyPredictedAlt();
i--; // back up one so that i++ of loop iteration stays within bounds
}
OptimizeEOTBranches( edgeTarget );
diff --git a/Antlr3/Analysis/DFAState.cs b/Antlr3/Analysis/DFAState.cs
index d3a0de9..8e60c0a 100644
--- a/Antlr3/Analysis/DFAState.cs
+++ b/Antlr3/Analysis/DFAState.cs
@@ -71,17 +71,16 @@ namespace Antlr3.Analysis
public class DFAState : State
{
public const int INITIAL_NUM_TRANSITIONS = 4;
-        public const int PREDICTED_ALT_UNSET = NFA.INVALID_ALT_NUMBER - 1;

/** We are part of what DFA?  Use this ref to get access to the
*  context trees for an alt.
*/
-        public DFA dfa;
+        private readonly DFA dfa;

/** Track the transitions emanating from this DFA state.  The List
*  elements are Transition objects.
*/
-        IList<Transition> _transitions =
+        private readonly IList<Transition> _transitions =
new List<Transition>( INITIAL_NUM_TRANSITIONS );

/** When doing an acyclic DFA, this is the number of lookahead symbols
@@ -89,7 +88,7 @@ namespace Antlr3.Analysis
*  dfa states, but it is only a valid value if the user has specified
*  a max fixed lookahead.
*/
-        int _k;
+        private int _k;

/** The NFA->DFA algorithm may terminate leaving some states
*  without a path to an accept state, implying that upon certain
@@ -97,20 +96,20 @@ namespace Antlr3.Analysis
*  predicting a unique alternative can be made.  Recall that an
*  accept state is one in which a unique alternative is predicted.
*/
-        int _acceptStateReachable = DFA.REACHABLE_UNKNOWN;
+        private Reachable _acceptStateReachable = Reachable.Unknown;

/** Rather than recheck every NFA configuration in a DFA state (after
*  resolving) in findNewDFAStatesAndAddDFATransitions just check
*  this boolean.  Saves a linear walk perhaps DFA state creation.
*  Every little bit helps.
*/
-        bool _resolvedWithPredicates = false;
+        private bool _resolvedWithPredicates = false;

/** If a closure operation finds that we tried to invoke the same
*  rule too many times (stack would grow beyond a threshold), it
*  marks the state has aborted and notifies the DecisionProbe.
*/
-        public bool abortedDueToRecursionOverflow = false;
+        private bool _abortedDueToRecursionOverflow = false;

/** If we detect recursion on more than one alt, decision is non-LL(*),
*  but try to isolate it to only those states whose closure operations
@@ -128,24 +127,24 @@ namespace Antlr3.Analysis
*  now and we simply report the problem.  If synpreds exist, I'll retry
*  with k=1.
*/
-        internal bool abortedDueToMultipleRecursiveAlts = false;
+        private bool _abortedDueToMultipleRecursiveAlts = false;

/** Build up the hash code for this state as NFA configurations
*  are added as it's monotonically increasing list of configurations.
*/
-        int _cachedHashCode;
+        private int _cachedHashCode;

-        internal int cachedUniquelyPredicatedAlt = PREDICTED_ALT_UNSET;
+        private int? _cachedUniquelyPredicatedAlt;

-        public int minAltInConfigurations = int.MaxValue;
+        private int _minAltInConfigurations = int.MaxValue;

-        bool _atLeastOneConfigurationHasAPredicate = false;
+        private bool _atLeastOneConfigurationHasAPredicate = false;

/** The set of NFA configurations (state,alt,context) for this DFA state */
-        public OrderedHashSet<NFAConfiguration> nfaConfigurations =
+        private OrderedHashSet<NFAConfiguration> _nfaConfigurations =
new OrderedHashSet<NFAConfiguration>();

-        public IList<NFAConfiguration> configurationsWithLabeledEdges =
+        private IList<NFAConfiguration> _configurationsWithLabeledEdges =
new List<NFAConfiguration>();

/** Used to prevent the closure operation from looping to itself and
@@ -157,7 +156,7 @@ namespace Antlr3.Analysis
*  Two configurations identical including semantic context are
*  considered the same closure computation.  @see NFAToDFAConverter.closureBusy().
*/
-        internal HashSet<NFAConfiguration> closureBusy = new HashSet<NFAConfiguration>();
+        private HashSet<NFAConfiguration> _closureBusy = new HashSet<NFAConfiguration>();

/** As this state is constructed (i.e., as NFA states are added), we
*  can easily check for non-epsilon transitions because the only
@@ -167,33 +166,51 @@ namespace Antlr3.Analysis
*  times size(nfa states), which can be pretty damn big.  It's better
*  to simply track possible labels.
*/
-        OrderedHashSet<Label> _reachableLabels;
+        private OrderedHashSet<Label> _reachableLabels;

public DFAState( DFA dfa )
{
+            if (dfa == null)
+                throw new ArgumentNullException("dfa");
+
this.dfa = dfa;
}

#region Properties
+
+        public DFA Dfa
+        {
+            get
+            {
+                return dfa;
+            }
+        }
+
/** Is an accept state reachable from this state? */
-        public int AcceptStateReachable
+        public Reachable AcceptStateReachable
{
get
{
return _acceptStateReachable;
}
+
set
{
_acceptStateReachable = value;
}
}
-        public ICollection<int> AltSet
+
+        /** Get the set of all alts mentioned by all NFA configurations in this
+         *  DFA state.
+         */
+        public IEnumerable<int> AltSet
{
get
{
-                return GetAltSet();
+                return _nfaConfigurations.Select(i => i.Alt).Distinct();
}
}
+
public bool AtLeastOneConfigurationHasAPredicate
{
get
@@ -201,62 +218,157 @@ namespace Antlr3.Analysis
return _atLeastOneConfigurationHasAPredicate;
}
}
-        public ICollection<int> DisabledAlternatives
+
+        /** When more than one alternative can match the same input, the first
+         *  alternative is chosen to resolve the conflict.  The other alts
+         *  are "turned off" by setting the "resolved" flag in the NFA
+         *  configurations.  Return the set of disabled alternatives.  For
+         *
+         *  a : A | A | A ;
+         *
+         *  this method returns {2,3} as disabled.  This does not mean that
+         *  the alternative is totally unreachable, it just means that for this
+         *  DFA state, that alt is disabled.  There may be other accept states
+         *  for that alt.
+         */
+        public IEnumerable<int> DisabledAlternatives
{
get
{
-                return GetDisabledAlternatives();
+                return _nfaConfigurations.Where(i => i.Resolved).Select(i => i.Alt).Distinct();
}
}
+
public bool IsResolvedWithPredicates
{
get
{
return _resolvedWithPredicates;
}
+
set
{
_resolvedWithPredicates = value;
}
}
+
+        public bool AbortedDueToRecursionOverflow
+        {
+            get
+            {
+                return _abortedDueToRecursionOverflow;
+            }
+
+            set
+            {
+                _abortedDueToRecursionOverflow = value;
+            }
+        }
+
+        public bool AbortedDueToMultipleRecursiveAlts
+        {
+            get
+            {
+                return _abortedDueToMultipleRecursiveAlts;
+            }
+
+            set
+            {
+                _abortedDueToMultipleRecursiveAlts = value;
+            }
+        }
+
public int LookaheadDepth
{
get
{
return _k;
}
+
set
{
_k = value;
-                if ( value > dfa.max_k )
+                if ( value > dfa.MaxLookahead )
{
// track max k for entire DFA
-                    dfa.max_k = value;
+                    dfa.MaxLookahead = value;
}
}
}
+
public ICollection<Label> ReachableLabels
{
get
{
-                return GetReachableLabels();
+                return _reachableLabels;
}
}
+
+        internal int? CachedUniquelyPredicatedAlt
+        {
+            get
+            {
+                return _cachedUniquelyPredicatedAlt;
+            }
+
+            set
+            {
+                _cachedUniquelyPredicatedAlt = value;
+            }
+        }
+
+        public int MinAltInConfigurations
+        {
+            get
+            {
+                return _minAltInConfigurations;
+            }
+
+            set
+            {
+                _minAltInConfigurations = value;
+            }
+        }
+
+        public OrderedHashSet<NFAConfiguration> NfaConfigurations
+        {
+            get
+            {
+                return _nfaConfigurations;
+            }
+        }
+
+        public IList<NFAConfiguration> ConfigurationsWithLabeledEdges
+        {
+            get
+            {
+                return _configurationsWithLabeledEdges;
+            }
+        }
+
+        public HashSet<NFAConfiguration> ClosureBusy
+        {
+            get
+            {
+                return _closureBusy;
+            }
+
+            set
+            {
+                _closureBusy = value;
+            }
+        }
+
#endregion

public virtual void Reset()
{
//nfaConfigurations = null; // getGatedPredicatesInNFAConfigurations needs
-            configurationsWithLabeledEdges = null;
-            closureBusy = null;
+            _configurationsWithLabeledEdges = null;
+            _closureBusy = null;
_reachableLabels = null;
}

-        public virtual Transition Transition( int i )
-        {
-            return (Transition)_transitions[i];
-        }
-
public override int NumberOfTransitions
{
get
@@ -308,27 +420,27 @@ namespace Antlr3.Analysis
*/
public virtual void AddNFAConfiguration( NFAState state, NFAConfiguration c )
{
-            if ( nfaConfigurations.Contains( c ) )
+            if ( _nfaConfigurations.Contains( c ) )
{
return;
}

-            nfaConfigurations.Add( c );
+            _nfaConfigurations.Add( c );

// track min alt rather than compute later
-            if ( c.alt < minAltInConfigurations )
+            if ( c.Alt < _minAltInConfigurations )
{
-                minAltInConfigurations = c.alt;
+                _minAltInConfigurations = c.Alt;
}

-            if ( c.semanticContext != SemanticContext.EmptySemanticContext )
+            if ( c.SemanticContext != SemanticContext.EmptySemanticContext )
{
_atLeastOneConfigurationHasAPredicate = true;
}

// update hashCode; for some reason using context.hashCode() also
// makes the GC take like 70% of the CPU and is slow!
-            _cachedHashCode += c.state + c.alt;
+            _cachedHashCode += c.State + c.Alt;

// update reachableLabels
// We're adding an NFA state; check to see if it has a non-epsilon edge
@@ -340,11 +452,11 @@ namespace Antlr3.Analysis
// this NFA state has a non-epsilon edge, track for fast
// walking later when we do reach on this DFA state we're
// building.
-                    configurationsWithLabeledEdges.Add( c );
+                    _configurationsWithLabeledEdges.Add( c );
if ( state.transition[1] == null )
{
// later we can check this to ignore o-A->o states in closure
-                        c.singleAtomTransitionEmanating = true;
+                        c.SingleAtomTransitionEmanating = true;
}
AddReachableLabel( label );
}
@@ -481,16 +593,6 @@ namespace Antlr3.Analysis
*/
}

-        public virtual OrderedHashSet<Label> GetReachableLabels()
-        {
-            return _reachableLabels;
-        }
-
-        public virtual void SetNFAConfigurations( OrderedHashSet<NFAConfiguration> configs )
-        {
-            this.nfaConfigurations = configs;
-        }
-
/** A decent hash for a DFA state is the sum of the NFA state/alt pairs.
*  This is used when we add DFAState objects to the DFA.states Map and
*  when we compare DFA states.  Computed in addNFAConfiguration()
@@ -520,15 +622,17 @@ namespace Antlr3.Analysis
public override bool Equals( object o )
{
// compare set of NFA configurations in this set with other
-            DFAState other = (DFAState)o;
+            DFAState other = o as DFAState;
+            if (other == null)
+                return false;

-            if ( object.ReferenceEquals( nfaConfigurations, other.nfaConfigurations ) )
+            if ( object.ReferenceEquals( _nfaConfigurations, other._nfaConfigurations ) )
return true;

-            if ( this.nfaConfigurations.Equals( other.nfaConfigurations ) )
+            if ( this._nfaConfigurations.Equals( other._nfaConfigurations ) )
return true;

-            if ( nfaConfigurations.SequenceEqual( other.nfaConfigurations ) )
+            if ( _nfaConfigurations.SequenceEqual( other._nfaConfigurations ) )
return true;

return false;
@@ -543,32 +647,35 @@ namespace Antlr3.Analysis
*/
public virtual int GetUniquelyPredictedAlt()
{
-            if ( cachedUniquelyPredicatedAlt != PREDICTED_ALT_UNSET )
+            if ( _cachedUniquelyPredicatedAlt.HasValue )
{
-                return cachedUniquelyPredicatedAlt;
+                return _cachedUniquelyPredicatedAlt.Value;
}
+
int alt = NFA.INVALID_ALT_NUMBER;
-            int numConfigs = nfaConfigurations.Count;
+            int numConfigs = _nfaConfigurations.Count;
for ( int i = 0; i < numConfigs; i++ )
{
-                NFAConfiguration configuration = (NFAConfiguration)nfaConfigurations[i];
+                NFAConfiguration configuration = _nfaConfigurations[i];
// ignore anything we resolved; predicates will still result
// in transitions out of this state, so must count those
// configurations; i.e., don't ignore resolveWithPredicate configs
-                if ( configuration.resolved )
+                if ( configuration.Resolved )
{
continue;
}
+
if ( alt == NFA.INVALID_ALT_NUMBER )
{
-                    alt = configuration.alt; // found first nonresolved alt
+                    alt = configuration.Alt; // found first nonresolved alt
}
-                else if ( configuration.alt != alt )
+                else if ( configuration.Alt != alt )
{
return NFA.INVALID_ALT_NUMBER;
}
}
-            this.cachedUniquelyPredicatedAlt = alt;
+
+            this._cachedUniquelyPredicatedAlt = alt;
return alt;
}

@@ -579,15 +686,15 @@ namespace Antlr3.Analysis
public virtual int GetUniqueAlt()
{
int alt = NFA.INVALID_ALT_NUMBER;
-            int numConfigs = nfaConfigurations.Count;
+            int numConfigs = _nfaConfigurations.Count;
for ( int i = 0; i < numConfigs; i++ )
{
-                NFAConfiguration configuration = (NFAConfiguration)nfaConfigurations[i];
+                NFAConfiguration configuration = _nfaConfigurations[i];
if ( alt == NFA.INVALID_ALT_NUMBER )
{
-                    alt = configuration.alt; // found first alt
+                    alt = configuration.Alt; // found first alt
}
-                else if ( configuration.alt != alt )
+                else if ( configuration.Alt != alt )
{
return NFA.INVALID_ALT_NUMBER;
}
@@ -595,33 +702,6 @@ namespace Antlr3.Analysis
return alt;
}

-        /** When more than one alternative can match the same input, the first
-         *  alternative is chosen to resolve the conflict.  The other alts
-         *  are "turned off" by setting the "resolved" flag in the NFA
-         *  configurations.  Return the set of disabled alternatives.  For
-         *
-         *  a : A | A | A ;
-         *
-         *  this method returns {2,3} as disabled.  This does not mean that
-         *  the alternative is totally unreachable, it just means that for this
-         *  DFA state, that alt is disabled.  There may be other accept states
-         *  for that alt.
-         */
-        public virtual ICollection<int> GetDisabledAlternatives()
-        {
-            HashSet<int> disabled = new HashSet<int>();
-            int numConfigs = nfaConfigurations.Count;
-            for ( int i = 0; i < numConfigs; i++ )
-            {
-                NFAConfiguration configuration = (NFAConfiguration)nfaConfigurations[i];
-                if ( configuration.resolved )
-                {
-                    disabled.Add( configuration.alt );
-                }
-            }
-            return disabled;
-        }
-
protected internal virtual HashSet<int> GetNonDeterministicAlts()
{
int user_k = dfa.UserMaxLookahead;
@@ -631,7 +711,7 @@ namespace Antlr3.Analysis
// if we have hit the max lookahead
return new HashSet<int>( AltSet );
}
-            else if ( abortedDueToMultipleRecursiveAlts || abortedDueToRecursionOverflow )
+            else if ( AbortedDueToMultipleRecursiveAlts || AbortedDueToRecursionOverflow )
{
// if we had to abort for non-LL(*) state assume all alts are a problem
return new HashSet<int>( AltSet );
@@ -668,7 +748,7 @@ namespace Antlr3.Analysis
// save the overhead.  There are many o-a->o NFA transitions
// and so we save a hash map and iterator creation for each
// state.
-            int numConfigs = nfaConfigurations.Count;
+            int numConfigs = _nfaConfigurations.Count;
if ( numConfigs <= 1 )
{
return null;
@@ -680,8 +760,8 @@ namespace Antlr3.Analysis
new MultiMap<int, NFAConfiguration>();
for ( int i = 0; i < numConfigs; i++ )
{
-                NFAConfiguration configuration = (NFAConfiguration)nfaConfigurations[i];
-                int stateI = configuration.state;
+                NFAConfiguration configuration = (NFAConfiguration)_nfaConfigurations[i];
+                int stateI = configuration.State;
stateToConfigListMap.Map( stateI, configuration );
}
// potential conflicts are states with > 1 configuration and diff alts
@@ -699,9 +779,9 @@ namespace Antlr3.Analysis
NFAConfiguration c = (NFAConfiguration)configsForState[i];
if ( alt == 0 )
{
-                        alt = c.alt;
+                        alt = c.Alt;
}
-                    else if ( c.alt != alt )
+                    else if ( c.Alt != alt )
{
/*
JSystem.@out.println("potential conflict in state "+stateI+
@@ -717,7 +797,7 @@ namespace Antlr3.Analysis
// for example would terminate at state s1 and test predicate
// meaning input "ab" would test preds to decide what to
// do but it should match rule C w/o testing preds.
-                        if ( dfa.nfa.grammar.type != GrammarType.Lexer ||
+                        if ( dfa.Nfa.Grammar.type != GrammarType.Lexer ||
!dfa.NFADecisionStartState.enclosingRule.Name.Equals( Grammar.ArtificialTokensRuleName ) )
{
numPotentialConflicts++;
@@ -773,10 +853,10 @@ namespace Antlr3.Analysis
// conflicts means s.ctx==t.ctx or s.ctx is a stack
// suffix of t.ctx or vice versa (if alts differ).
// Also a conflict if s.ctx or t.ctx is empty
-                        if ( s.alt != t.alt && s.context.ConflictsWith( t.context ) )
+                        if ( s.Alt != t.Alt && s.Context.ConflictsWith( t.Context ) )
{
-                            nondeterministicAlts.Add( s.alt );
-                            nondeterministicAlts.Add( t.alt );
+                            nondeterministicAlts.Add( s.Alt );
+                            nondeterministicAlts.Add( t.Alt );
}
}
}
@@ -789,39 +869,20 @@ namespace Antlr3.Analysis
return nondeterministicAlts;
}

-        /** Get the set of all alts mentioned by all NFA configurations in this
-         *  DFA state.
-         */
-        public virtual HashSet<int> GetAltSet()
-        {
-            int numConfigs = nfaConfigurations.Count;
-            HashSet<int> alts = new HashSet<int>();
-            for ( int i = 0; i < numConfigs; i++ )
-            {
-                NFAConfiguration configuration = (NFAConfiguration)nfaConfigurations[i];
-                alts.Add( configuration.alt );
-            }
-            if ( alts.Count == 0 )
-            {
-                return null;
-            }
-            return alts;
-        }
-
public virtual HashSet<SemanticContext> GetGatedSyntacticPredicatesInNFAConfigurations()
{
-            int numConfigs = nfaConfigurations.Count;
+            int numConfigs = _nfaConfigurations.Count;
HashSet<SemanticContext> synpreds = new HashSet<SemanticContext>();
for ( int i = 0; i < numConfigs; i++ )
{
-                NFAConfiguration configuration = (NFAConfiguration)nfaConfigurations[i];
+                NFAConfiguration configuration = (NFAConfiguration)_nfaConfigurations[i];
SemanticContext gatedPredExpr =
-                    configuration.semanticContext.GatedPredicateContext;
+                    configuration.SemanticContext.GatedPredicateContext;
// if this is a manual syn pred (gated and syn pred), add
if ( gatedPredExpr != null &&
-                     configuration.semanticContext.IsSyntacticPredicate )
+                     configuration.SemanticContext.IsSyntacticPredicate )
{
-                    synpreds.Add( configuration.semanticContext );
+                    synpreds.Add( configuration.SemanticContext );
}
}
if ( synpreds.Count == 0 )
@@ -860,12 +921,12 @@ namespace Antlr3.Analysis
public virtual SemanticContext GetGatedPredicatesInNFAConfigurations()
{
SemanticContext unionOfPredicatesFromAllAlts = null;
-            int numConfigs = nfaConfigurations.Count;
+            int numConfigs = _nfaConfigurations.Count;
for ( int i = 0; i < numConfigs; i++ )
{
-                NFAConfiguration configuration = (NFAConfiguration)nfaConfigurations[i];
+                NFAConfiguration configuration = (NFAConfiguration)_nfaConfigurations[i];
SemanticContext gatedPredExpr =
-                    configuration.semanticContext.GatedPredicateContext;
+                    configuration.SemanticContext.GatedPredicateContext;
if ( gatedPredExpr == null )
{
// if we ever find a configuration w/o a gated predicate
@@ -873,7 +934,7 @@ namespace Antlr3.Analysis
// the indident edges.
return null;
}
-                else if ( acceptState || !configuration.semanticContext.IsSyntacticPredicate )
+                else if ( IsAcceptState || !configuration.SemanticContext.IsSyntacticPredicate )
{
// at this point we have a gated predicate and, due to elseif,
// we know it's an accept or not a syn pred.  In this case,
@@ -903,9 +964,9 @@ namespace Antlr3.Analysis
{
StringBuilder buf = new StringBuilder();
buf.Append( StateNumber + ":{" );
-            for ( int i = 0; i < nfaConfigurations.Count; i++ )
+            for ( int i = 0; i < _nfaConfigurations.Count; i++ )
{
-                NFAConfiguration configuration = (NFAConfiguration)nfaConfigurations[i];
+                NFAConfiguration configuration = (NFAConfiguration)_nfaConfigurations[i];
if ( i > 0 )
{
buf.Append( ", " );
diff --git a/Antlr3/Analysis/DecisionProbe.cs b/Antlr3/Analysis/DecisionProbe.cs
index 69ce1ef..747f1a5 100644
--- a/Antlr3/Analysis/DecisionProbe.cs
+++ b/Antlr3/Analysis/DecisionProbe.cs
@@ -32,12 +32,12 @@

namespace Antlr3.Analysis
{
-    using System;
using System.Collections.Generic;
using System.Linq;
using Antlr3.Misc;

using ANTLRParser = Antlr3.Grammars.ANTLRParser;
+    using ArgumentNullException = System.ArgumentNullException;
using ErrorManager = Antlr3.Tool.ErrorManager;
using Grammar = Antlr3.Tool.Grammar;
using GrammarAST = Antlr3.Tool.GrammarAST;
@@ -78,7 +78,7 @@ namespace Antlr3.Analysis
*/
public class DecisionProbe
{
-        internal DFA dfa;
+        private readonly DFA _dfa;

/** Track all DFA states with nondeterministic alternatives.
*  By reaching the same DFA state, a path through the NFA for some input
@@ -88,39 +88,39 @@ namespace Antlr3.Analysis
*  Note that from the DFA state, you can ask for
*  which alts are nondeterministic.
*/
-        ICollection<DFAState> _statesWithSyntacticallyAmbiguousAltsSet = new HashSet<DFAState>();
+        private readonly HashSet<DFAState> _statesWithSyntacticallyAmbiguousAltsSet = new HashSet<DFAState>();

/** Track just like stateToSyntacticallyAmbiguousAltsMap, but only
*  for nondeterminisms that arise in the Tokens rule such as keyword vs
*  ID rule.  The state maps to the list of Tokens rule alts that are
*  in conflict.
*/
-        internal IDictionary<DFAState, ICollection<int>> stateToSyntacticallyAmbiguousTokensRuleAltsMap =
+        internal readonly Dictionary<DFAState, ICollection<int>> stateToSyntacticallyAmbiguousTokensRuleAltsMap =
new Dictionary<DFAState, ICollection<int>>();

/** Was a syntactic ambiguity resolved with predicates?  Any DFA
*  state that predicts more than one alternative, must be resolved
*  with predicates or it should be reported to the user.
*/
-        ICollection<DFAState> _statesResolvedWithSemanticPredicatesSet = new HashSet<DFAState>();
+        private readonly HashSet<DFAState> _statesResolvedWithSemanticPredicatesSet = new HashSet<DFAState>();

/** Track the predicates for each alt per DFA state;
*  more than one DFA state might have syntactically ambig alt prediction.
*  Maps DFA state to another map, mapping alt number to a
*  SemanticContext (pred(s) to execute to resolve syntactic ambiguity).
*/
-        IDictionary<DFAState, IDictionary<int, SemanticContext>> _stateToAltSetWithSemanticPredicatesMap =
+        private readonly Dictionary<DFAState, IDictionary<int, SemanticContext>> _stateToAltSetWithSemanticPredicatesMap =
new Dictionary<DFAState, IDictionary<int, SemanticContext>>();

/** Tracks alts insufficiently covered.
*  For example, p1||true gets reduced to true and so leaves
*  whole alt uncovered.  This maps DFA state to the set of alts
*/
-        IDictionary<DFAState, IDictionary<int, ICollection<IToken>>> _stateToIncompletelyCoveredAltsMap =
+        private readonly Dictionary<DFAState, IDictionary<int, ICollection<IToken>>> _stateToIncompletelyCoveredAltsMap =
new Dictionary<DFAState, IDictionary<int, ICollection<IToken>>>();

/** The set of states w/o emanating edges and w/o resolving sem preds. */
-        ICollection<DFAState> _danglingStates = new HashSet<DFAState>();
+        private readonly HashSet<DFAState> _danglingStates = new HashSet<DFAState>();

/** The overall list of alts within the decision that have at least one
*  conflicting input sequence.
@@ -131,12 +131,12 @@ namespace Antlr3.Analysis
*  lookahead.  The decision cannot be made with a DFA.
*  the alts are stored in altsWithProblem.
*/
-        bool _nonLLStarDecision = false;
+        private bool _nonLLStarDecision = false;

/** Recursion is limited to a particular depth.  If that limit is exceeded
*  the proposed new NFAConfiguration is recorded for the associated DFA state.
*/
-        MultiMap<int, NFAConfiguration> _stateToRecursionOverflowConfigurationsMap =
+        private readonly MultiMap<int, NFAConfiguration> _stateToRecursionOverflowConfigurationsMap =
new MultiMap<int, NFAConfiguration>();

#if false
@@ -155,11 +155,7 @@ namespace Antlr3.Analysis
/** Used to find paths through syntactically ambiguous DFA. If we've
*  seen statement number before, what did we learn?
*/
-        IDictionary<int, int> _stateReachable;
-
-        public const int REACHABLE_BUSY = -1;
-        public const int REACHABLE_NO = 0;
-        public const int REACHABLE_YES = 1;
+        private IDictionary<int, Reachable> _stateReachable;

/** Used while finding a path through an NFA whose edge labels match
*  an input sequence.  Tracks the input position
@@ -168,18 +164,29 @@ namespace Antlr3.Analysis
*  infinite loop.  Stop.  Set<String>.  The strings look like
*  stateNumber_labelIndex.
*/
-        ICollection<string> _statesVisitedAtInputDepth;
+        private ICollection<string> _statesVisitedAtInputDepth;

-        ICollection<int> _statesVisitedDuringSampleSequence;
+        private ICollection<int> _statesVisitedDuringSampleSequence;

public static bool verbose = false;

public DecisionProbe( DFA dfa )
{
-            this.dfa = dfa;
+            if (dfa == null)
+                throw new ArgumentNullException("dfa");
+
+            this._dfa = dfa;
}

#region Properties
+        public DFA Dfa
+        {
+            get
+            {
+                return _dfa;
+            }
+        }
+
/** Took too long to analyze a DFA */
public bool AnalysisOverflowed
{
@@ -201,6 +208,7 @@ namespace Antlr3.Analysis
return _danglingStates;
}
}
+
/** Return a string like "3:22: ( A {;} | B )" that describes this
*  decision.
*/
@@ -208,9 +216,10 @@ namespace Antlr3.Analysis
{
get
{
-                return dfa.NFADecisionStartState.Description;
+                return _dfa.NFADecisionStartState.Description;
}
}
+
/** Return all DFA states in this DFA that have NFA configurations that
*  conflict.  You must report a problem for each state in this set
*  because each state represents a different input sequence.
@@ -222,6 +231,7 @@ namespace Antlr3.Analysis
return _statesWithSyntacticallyAmbiguousAltsSet;
}
}
+
/** At least one alt refs a sem or syn pred */
public bool HasPredicate
{
@@ -230,13 +240,15 @@ namespace Antlr3.Analysis
return _stateToAltSetWithSemanticPredicatesMap.Count > 0;
}
}
+
public bool IsCyclic
{
get
{
-                return dfa.IsCyclic;
+                return _dfa.IsCyclic;
}
}
+
/** If no states are dead-ends, no alts are unreachable, there are
*  no nondeterminisms unresolved by syn preds, all is ok with decision.
*/
@@ -246,7 +258,7 @@ namespace Antlr3.Analysis
{
if ( _danglingStates.Count == 0 &&
_statesWithSyntacticallyAmbiguousAltsSet.Count == 0 &&
-                     dfa.UnreachableAlts.Count == 0 )
+                     _dfa.UnreachableAlts.Count == 0 )
{
return true;
}
@@ -262,6 +274,7 @@ namespace Antlr3.Analysis
return false;
}
}
+
/** Found recursion in > 1 alt */
public bool IsNonLLStarDecision
{
@@ -270,13 +283,15 @@ namespace Antlr3.Analysis
return _nonLLStarDecision;
}
}
+
public bool IsReduced
{
get
{
-                return dfa.IsReduced;
+                return _dfa.IsReduced;
}
}
+
public ICollection<int> NonDeterministicAlts
{
get
@@ -284,6 +299,7 @@ namespace Antlr3.Analysis
return _altsWithProblem;
}
}
+
public ICollection<DFAState> NondeterministicStatesResolvedWithSemanticPredicate
{
get
@@ -291,14 +307,16 @@ namespace Antlr3.Analysis
return _statesResolvedWithSemanticPredicatesSet;
}
}
+
/** How many states does the DFA predictor have? */
public int NumberOfStates
{
get
{
-                return dfa.NumberOfStates;
+                return _dfa.NumberOfStates;
}
}
+
/** Get a list of all unreachable alternatives for this decision.  There
*  may be multiple alternatives with ambiguous input sequences, but this
*  is the overall list of unreachable alternatives (either due to
@@ -308,9 +326,10 @@ namespace Antlr3.Analysis
{
get
{
-                return dfa.UnreachableAlts;
+                return _dfa.UnreachableAlts;
}
}
+
#endregion

// I N F O R M A T I O N  A B O U T  D E C I S I O N
@@ -343,7 +362,7 @@ namespace Antlr3.Analysis
*  that for this DFA state, that alt is disabled.  There may be other
*  accept states for that alt that make an alt reachable.
*/
-        public virtual ICollection<int> GetDisabledAlternatives( DFAState d )
+        public virtual IEnumerable<int> GetDisabledAlternatives( DFAState d )
{
return d.DisabledAlternatives;
}
@@ -365,11 +384,11 @@ namespace Antlr3.Analysis
HashSet<object> dfaStates = GetDFAPathStatesToTarget( targetState );
_statesVisitedDuringSampleSequence = new HashSet<int>();
IList<Label> labels = new List<Label>(); // may access ith element; use array
-            if ( dfa == null || dfa.startState == null )
+            if ( _dfa == null || _dfa.StartState == null )
{
return labels;
}
-            GetSampleInputSequenceUsingStateSet( dfa.startState,
+            GetSampleInputSequenceUsingStateSet( _dfa.StartState,
targetState,
dfaStates,
labels );
@@ -380,9 +399,9 @@ namespace Antlr3.Analysis
*  of the associated input string.  One could show something different
*  for lexers and parsers, for example.
*/
-        public virtual String GetInputSequenceDisplay( IList<Label> labels )
+        public virtual string GetInputSequenceDisplay( IList<Label> labels )
{
-            Grammar g = dfa.nfa.grammar;
+            Grammar g = _dfa.Nfa.Grammar;
StringBuilder buf = new StringBuilder();
foreach ( Label label in labels )
{
@@ -431,18 +450,18 @@ namespace Antlr3.Analysis
int alt,
IList<Label> labels )
{
-            NFAState nfaStart = dfa.NFADecisionStartState;
+            NFAState nfaStart = _dfa.NFADecisionStartState;
List<NFAState> path = new List<NFAState>();
// first add all NFA states leading up to altStart state
for ( int a = firstAlt; a <= alt; a++ )
{
NFAState s =
-                    dfa.nfa.grammar.GetNFAStateForAltOfDecision( nfaStart, a );
+                    _dfa.Nfa.Grammar.GetNFAStateForAltOfDecision( nfaStart, a );
path.Add( s );
}

// add first state of actual alt
-            NFAState altStart = dfa.nfa.grammar.GetNFAStateForAltOfDecision( nfaStart, alt );
+            NFAState altStart = _dfa.Nfa.Grammar.GetNFAStateForAltOfDecision( nfaStart, alt );
NFAState isolatedAltStart = (NFAState)altStart.transition[0].Target;
path.Add( isolatedAltStart );

@@ -486,7 +505,7 @@ namespace Antlr3.Analysis
// NONREGULAR DUE TO RECURSION > 1 ALTS
// Issue this before aborted analysis, which might also occur
// if we take too long to terminate
-            if ( _nonLLStarDecision && !dfa.AutoBacktrackMode )
+            if ( _nonLLStarDecision && !_dfa.AutoBacktrackMode )
{
ErrorManager.NonLLStarDecision( this );
}
@@ -496,41 +515,38 @@ namespace Antlr3.Analysis
// generate a separate message for each problem state in DFA
ICollection<DFAState> resolvedStates = NondeterministicStatesResolvedWithSemanticPredicate;
ICollection<DFAState> problemStates = DFAStatesWithSyntacticallyAmbiguousAlts;
-            if ( problemStates.Count > 0 )
+            foreach (DFAState d in problemStates)
{
-                foreach ( DFAState d in problemStates )
-                {
-                    if ( dfa.nfa.grammar.NFAToDFAConversionExternallyAborted() )
-                        break;
+                if (_dfa.Nfa.Grammar.NFAToDFAConversionExternallyAborted())
+                    break;

-                    IDictionary<int, ICollection<IToken>> insufficientAltToLocations = GetIncompletelyCoveredAlts( d );
-                    if ( insufficientAltToLocations != null && insufficientAltToLocations.Count > 0 )
-                    {
-                        ErrorManager.InsufficientPredicates( this, d, insufficientAltToLocations );
-                    }
-                    // don't report problem if resolved
-                    if ( resolvedStates == null || !resolvedStates.Contains( d ) )
+                IDictionary<int, ICollection<IToken>> insufficientAltToLocations = GetIncompletelyCoveredAlts(d);
+                if (insufficientAltToLocations != null && insufficientAltToLocations.Count > 0)
+                {
+                    ErrorManager.InsufficientPredicates(this, d, insufficientAltToLocations);
+                }
+                // don't report problem if resolved
+                if (resolvedStates == null || !resolvedStates.Contains(d))
+                {
+                    // first strip last alt from disableAlts if it's wildcard
+                    // then don't print error if no more disable alts
+                    List<int> disabledAlts = GetDisabledAlternatives(d).ToList();
+                    StripWildCardAlts(disabledAlts);
+                    if (disabledAlts.Count > 0)
{
-                        // first strip last alt from disableAlts if it's wildcard
-                        // then don't print error if no more disable alts
-                        ICollection<int> disabledAlts = GetDisabledAlternatives( d );
-                        StripWildCardAlts( disabledAlts );
-                        if ( disabledAlts.Count > 0 )
+                        // nondeterminism; same input predicts multiple alts.
+                        // but don't emit error if greedy=true explicitly set
+                        bool explicitlyGreedy = false;
+                        GrammarAST blockAST = d.Dfa.Nfa.Grammar.GetDecisionBlockAST(d.Dfa.DecisionNumber);
+                        if (blockAST != null)
{
-                            // nondeterminism; same input predicts multiple alts.
-                            // but don't emit error if greedy=true explicitly set
-                            bool explicitlyGreedy = false;
-                            GrammarAST blockAST = d.dfa.nfa.grammar.GetDecisionBlockAST(d.dfa.decisionNumber);
-                            if (blockAST != null)
-                            {
-                                String greedyS = (String)blockAST.GetBlockOption("greedy");
-                                if (greedyS != null && greedyS.Equals("true"))
-                                    explicitlyGreedy = true;
-                            }
-
-                            if (!explicitlyGreedy)
-                                ErrorManager.Nondeterminism(this, d);
+                            string greedyS = (string)blockAST.GetBlockOption("greedy");
+                            if (greedyS != null && greedyS.Equals("true"))
+                                explicitlyGreedy = true;
}
+
+                        if (!explicitlyGreedy)
+                            ErrorManager.Nondeterminism(this, d);
}
}
}
@@ -547,16 +563,16 @@ namespace Antlr3.Analysis

if ( !_nonLLStarDecision )
{
-                var unreachableAlts = dfa.UnreachableAlts;
+                var unreachableAlts = _dfa.UnreachableAlts;
if ( unreachableAlts != null && unreachableAlts.Count > 0 )
{
// give different msg if it's an empty Tokens rule from delegate
bool isInheritedTokensRule = false;
-                    if ( dfa.IsTokensRuleDecision )
+                    if ( _dfa.IsTokensRuleDecision )
{
foreach ( int altI in unreachableAlts )
{
-                            GrammarAST decAST = dfa.DecisionASTNode;
+                            GrammarAST decAST = _dfa.DecisionASTNode;
GrammarAST altAST = (GrammarAST)decAST.GetChild( altI - 1 );
GrammarAST delegatedTokensAlt =
(GrammarAST)altAST.GetFirstChildWithType( ANTLRParser.DOT );
@@ -564,9 +580,9 @@ namespace Antlr3.Analysis
{
isInheritedTokensRule = true;
ErrorManager.GrammarWarning( ErrorManager.MSG_IMPORTED_TOKENS_RULE_EMPTY,
-                                                            dfa.nfa.grammar,
+                                                            _dfa.Nfa.Grammar,
null,
-                                                            dfa.nfa.grammar.name,
+                                                            _dfa.Nfa.Grammar.name,
delegatedTokensAlt.GetChild( 0 ).Text );
}
}
@@ -594,7 +610,7 @@ namespace Antlr3.Analysis
int lastAlt =
(int)sortedDisableAlts[sortedDisableAlts.Count - 1];
GrammarAST blockAST =
-                dfa.nfa.grammar.GetDecisionBlockAST( dfa.decisionNumber );
+                _dfa.Nfa.Grammar.GetDecisionBlockAST( _dfa.DecisionNumber );
//JSystem.@out.println("block with error = "+blockAST.toStringTree());
GrammarAST lastAltAST = null;
if ( blockAST.GetChild( 0 ).Type == ANTLRParser.OPTIONS )
@@ -671,11 +687,11 @@ namespace Antlr3.Analysis
for ( int i = 0; i < configs.Count; i++ )
{
NFAConfiguration c = (NFAConfiguration)configs[i];
-                    NFAState ruleInvocationState = dfa.nfa.GetState( c.state );
+                    NFAState ruleInvocationState = _dfa.Nfa.GetState( c.State );
Transition transition0 = ruleInvocationState.transition[0];
RuleClosureTransition @ref = (RuleClosureTransition)transition0;
-                    String targetRule = ( (NFAState)@ref.Target ).enclosingRule.Name;
-                    int altI = c.alt;
+                    string targetRule = ( (NFAState)@ref.Target ).enclosingRule.Name;
+                    int altI = c.Alt;
IDictionary<string, ICollection<NFAState>> targetToCallSiteMap;
altToTargetToCallSitesMap.TryGetValue(altI, out targetToCallSiteMap);
if ( targetToCallSiteMap == null )
@@ -695,7 +711,7 @@ namespace Antlr3.Analysis
DFAState state;
if ( !altToDFAState.TryGetValue( altI, out state ) || state == null )
{
-                        DFAState sampleBadState = dfa.GetState( stateI );
+                        DFAState sampleBadState = _dfa.GetState( stateI );
altToDFAState[altI] = sampleBadState;
}
}
@@ -707,7 +723,7 @@ namespace Antlr3.Analysis
HashSet<object> dfaStatesUnaliased = new HashSet<object>();
foreach ( int stateI in dfaStatesWithRecursionProblems )
{
-                DFAState d = dfa.GetState( stateI );
+                DFAState d = _dfa.GetState( stateI );
dfaStatesUnaliased.Add( d.StateNumber );
}
return dfaStatesUnaliased;
@@ -735,8 +751,8 @@ namespace Antlr3.Analysis
dfa.recursiveAltSet.toList());
*/
_nonLLStarDecision = true;
-            dfa.nfa.grammar.numNonLLStar++;
-            _altsWithProblem.UnionWith( dfa.recursiveAltSet.ToList() );
+            dfa.Nfa.Grammar.numNonLLStar++;
+            _altsWithProblem.UnionWith( dfa.RecursiveAltSet.ToList() );
}

public virtual void ReportRecursionOverflow( DFAState d,
@@ -760,8 +776,8 @@ namespace Antlr3.Analysis
{
_altsWithProblem.UnionWith( nondeterministicAlts ); // track overall list
_statesWithSyntacticallyAmbiguousAltsSet.Add( d );
-            dfa.nfa.grammar.setOfNondeterministicDecisionNumbers.Add(
-                dfa.DecisionNumber
+            _dfa.Nfa.Grammar.setOfNondeterministicDecisionNumbers.Add(
+                _dfa.NfaStartStateDecisionNumber
);
}

@@ -778,14 +794,14 @@ namespace Antlr3.Analysis
{
// First, prevent a recursion warning on this state due to
// pred resolution
-            if ( d.abortedDueToRecursionOverflow )
+            if ( d.AbortedDueToRecursionOverflow )
{
-                d.dfa.probe.RemoveRecursiveOverflowState( d );
+                d.Dfa.Probe.RemoveRecursiveOverflowState( d );
}
_statesResolvedWithSemanticPredicatesSet.Add( d );
//JSystem.@out.println("resolved with pred: "+d);
-            dfa.nfa.grammar.setOfNondeterministicDecisionNumbersResolvedWithPredicates.Add(
-                dfa.DecisionNumber
+            _dfa.Nfa.Grammar.setOfNondeterministicDecisionNumbersResolvedWithPredicates.Add(
+                _dfa.NfaStartStateDecisionNumber
);
}

@@ -821,35 +837,35 @@ namespace Antlr3.Analysis
{
states.Add( targetState );
//JSystem.@out.println("found target DFA state "+targetState.getStateNumber());
-                _stateReachable[startState.StateNumber] = REACHABLE_YES;
+                _stateReachable[startState.StateNumber] = Reachable.Yes;
return true;
}

DFAState s = startState;
// avoid infinite loops
-            _stateReachable[s.StateNumber] = REACHABLE_BUSY;
+            _stateReachable[s.StateNumber] = Reachable.Busy;

// look for a path to targetState among transitions for this state
// stop when you find the first one; I'm pretty sure there is
// at most one path to any DFA state with conflicting predictions
for ( int i = 0; i < s.NumberOfTransitions; i++ )
{
-                Transition t = s.Transition( i );
+                Transition t = s.GetTransition( i );
DFAState edgeTarget = (DFAState)t.Target;

-                int targetStatus; //= stateReachable.get( edgeTarget.stateNumber );
+                Reachable targetStatus; //= stateReachable.get( edgeTarget.stateNumber );
if ( _stateReachable.TryGetValue( edgeTarget.StateNumber, out targetStatus ) )
{
-                    if ( targetStatus == REACHABLE_BUSY )
+                    if ( targetStatus == Reachable.Busy )
{ // avoid cycles; they say nothing
continue;
}
-                    if ( targetStatus == REACHABLE_YES )
+                    if ( targetStatus == Reachable.Yes )
{ // return success!
-                        _stateReachable[s.StateNumber] = REACHABLE_YES;
+                        _stateReachable[s.StateNumber] = Reachable.Yes;
return true;
}
-                    if ( targetStatus == REACHABLE_NO )
+                    if ( targetStatus == Reachable.No )
{ // try another transition
continue;
}
@@ -859,24 +875,25 @@ namespace Antlr3.Analysis
if ( ReachesState( edgeTarget, targetState, states ) )
{
states.Add( s );
-                    _stateReachable[s.StateNumber] = REACHABLE_YES;
+                    _stateReachable[s.StateNumber] = Reachable.Yes;
return true;
}
}

-            _stateReachable[s.StateNumber] = REACHABLE_NO;
+            _stateReachable[s.StateNumber] = Reachable.No;
return false; // no path to targetState found.
}

protected virtual HashSet<object> GetDFAPathStatesToTarget( DFAState targetState )
{
HashSet<object> dfaStates = new HashSet<object>();
-            _stateReachable = new Dictionary<int, int>();
-            if ( dfa == null || dfa.startState == null )
+            _stateReachable = new Dictionary<int, Reachable>();
+            if ( _dfa == null || _dfa.StartState == null )
{
return dfaStates;
}
-            bool reaches = ReachesState( dfa.startState, targetState, dfaStates );
+
+            bool reaches = ReachesState( _dfa.StartState, targetState, dfaStates );
return dfaStates;
}

@@ -936,7 +953,7 @@ namespace Antlr3.Analysis
IList<NFAState> path )      // output list of NFA states
{
// track a visit to state s at input index labelIndex if not seen
-            String thisStateKey = GetStateLabelIndexKey( s.StateNumber, labelIndex );
+            string thisStateKey = GetStateLabelIndexKey( s.StateNumber, labelIndex );
if ( _statesVisitedAtInputDepth.Contains( thisStateKey ) )
{
/*
@@ -961,9 +978,9 @@ namespace Antlr3.Analysis
Label label = (Label)labels[labelIndex];
/*
JSystem.@out.println(s.stateNumber+"-"+
-                                   t.label.toString(dfa.nfa.grammar)+"->"+
+                                   t.label.toString(dfa.nfa.Grammar)+"->"+
edgeTarget.stateNumber+" =="+
-                                   label.toString(dfa.nfa.grammar)+"?");
+                                   label.toString(dfa.nfa.Grammar)+"?");
*/
if ( t.Label.IsEpsilon || t.Label.IsSemanticPredicate )
{
@@ -984,7 +1001,7 @@ namespace Antlr3.Analysis
path.Add( edgeTarget );
/*
JSystem.@out.println("found label "+
-                                       t.label.toString(dfa.nfa.grammar)+
+                                       t.label.toString(dfa.nfa.Grammar)+
" at state "+s.stateNumber+"; labelIndex="+labelIndex);
*/
if ( labelIndex == labels.Count - 1 )
@@ -1003,7 +1020,7 @@ namespace Antlr3.Analysis
}
/*
JSystem.@out.println("backtrack; path from "+s.stateNumber+"->"+
-                                       t.label.toString(dfa.nfa.grammar)+" didn't work");
+                                       t.label.toString(dfa.nfa.Grammar)+" didn't work");
*/
path.RemoveAt( path.Count - 1 ); // remove; didn't work out
continue; // keep looking for a path for labels
@@ -1015,7 +1032,7 @@ namespace Antlr3.Analysis
return false;
}

-        protected virtual String GetStateLabelIndexKey( int s, int i )
+        protected virtual string GetStateLabelIndexKey( int s, int i )
{
StringBuilder buf = new StringBuilder();
buf.Append( s );
@@ -1027,11 +1044,11 @@ namespace Antlr3.Analysis
/** From an alt number associated with artificial Tokens rule, return
*  the name of the token that is associated with that alt.
*/
-        public virtual String GetTokenNameForTokensRuleAlt( int alt )
+        public virtual string GetTokenNameForTokensRuleAlt( int alt )
{
-            NFAState decisionState = dfa.NFADecisionStartState;
+            NFAState decisionState = _dfa.NFADecisionStartState;
NFAState altState =
-                dfa.nfa.grammar.GetNFAStateForAltOfDecision( decisionState, alt );
+                _dfa.Nfa.Grammar.GetNFAStateForAltOfDecision( decisionState, alt );
NFAState decisionLeft = (NFAState)altState.transition[0].Target;
RuleClosureTransition ruleCallEdge =
(RuleClosureTransition)decisionLeft.transition[0];
diff --git a/Antlr3/Analysis/LL1Analyzer.cs b/Antlr3/Analysis/LL1Analyzer.cs
index 3b916ff..c98f217 100644
--- a/Antlr3/Analysis/LL1Analyzer.cs
+++ b/Antlr3/Analysis/LL1Analyzer.cs
@@ -58,13 +58,13 @@ namespace Antlr3.Analysis
/**	2	if we didn't find such a pred */
public const int DETECT_PRED_NOT_FOUND = 2;

-        Grammar _grammar;
+        private readonly Grammar _grammar;

/** Used during LOOK to detect computation cycles */
-        HashSet<NFAState> _lookBusy = new HashSet<NFAState>();
+        private readonly HashSet<NFAState> _lookBusy = new HashSet<NFAState>();

-        IDictionary<NFAState, LookaheadSet> _firstCache = new Dictionary<NFAState, LookaheadSet>();
-        IDictionary<Rule, LookaheadSet> _followCache = new Dictionary<Rule, LookaheadSet>();
+        private readonly IDictionary<NFAState, LookaheadSet> _firstCache = new Dictionary<NFAState, LookaheadSet>();
+        private readonly IDictionary<Rule, LookaheadSet> _followCache = new Dictionary<Rule, LookaheadSet>();

public LL1Analyzer( Grammar grammar )
{
@@ -290,7 +290,7 @@ namespace Antlr3.Analysis
(RuleClosureTransition)transition0;
// remove the EOR and get what follows
//tset.remove(Label.EOR_TOKEN_TYPE);
-                    NFAState following = (NFAState)ruleInvocationTrans.followState;
+                    NFAState following = (NFAState)ruleInvocationTrans.FollowState;
LookaheadSet fset = FirstCore( following, chaseFollowTransitions );
fset.OrInPlace( tset );
fset.Remove( Label.EOR_TOKEN_TYPE );
@@ -404,7 +404,7 @@ namespace Antlr3.Analysis
// should include A.
RuleClosureTransition ruleInvocationTrans =
(RuleClosureTransition)transition0;
-                    NFAState following = (NFAState)ruleInvocationTrans.followState;
+                    NFAState following = (NFAState)ruleInvocationTrans.FollowState;
int afterRuleResult =
DetectConfoundingPredicatesCore( following,
enclosingRule,
diff --git a/Antlr3/Analysis/LL1DFA.cs b/Antlr3/Analysis/LL1DFA.cs
index e16f141..4fdfc3a 100644
--- a/Antlr3/Analysis/LL1DFA.cs
+++ b/Antlr3/Analysis/LL1DFA.cs
@@ -53,23 +53,19 @@ namespace Antlr3.Analysis
*  ...
*/
public LL1DFA( int decisionNumber, NFAState decisionStartState, LookaheadSet[] altLook )
+            : base(decisionNumber, decisionStartState)
{
DFAState s0 = NewState();
-            startState = s0;
-            nfa = decisionStartState.nfa;
-            NumberOfAlts = nfa.grammar.GetNumberOfAltsForDecisionNFA( decisionStartState );
-            this.decisionNumber = decisionNumber;
-            this.NFADecisionStartState = decisionStartState;
-            InitAltRelatedInfo();
-            UnreachableAlts = null;
+            StartState = s0;
+            UnreachableAlts.Clear();
for ( int alt = 1; alt < altLook.Length; alt++ )
{
DFAState acceptAltState = NewState();
-                acceptAltState.acceptState = true;
+                acceptAltState.IsAcceptState = true;
SetAcceptState( alt, acceptAltState );
acceptAltState.LookaheadDepth = 1;
-                acceptAltState.cachedUniquelyPredicatedAlt = alt;
-                Label e = GetLabelForSet( altLook[alt].tokenTypeSet );
+                acceptAltState.CachedUniquelyPredicatedAlt = alt;
+                Label e = GetLabelForSet( altLook[alt].TokenTypeSet );
s0.AddTransition( acceptAltState, e );
}
}
@@ -77,18 +73,12 @@ namespace Antlr3.Analysis
/** From a set of edgeset->list-of-alts mappings, create a DFA
*  that uses syn preds for all |list-of-alts|>1.
*/
-        public LL1DFA( int decisionNumber,
-                      NFAState decisionStartState,
-                      MultiMap<IntervalSet, int> edgeMap )
+        public LL1DFA(int decisionNumber, NFAState decisionStartState, MultiMap<IntervalSet, int> edgeMap)
+            : base(decisionNumber, decisionStartState)
{
DFAState s0 = NewState();
-            startState = s0;
-            nfa = decisionStartState.nfa;
-            NumberOfAlts = nfa.grammar.GetNumberOfAltsForDecisionNFA( decisionStartState );
-            this.decisionNumber = decisionNumber;
-            this.NFADecisionStartState = decisionStartState;
-            InitAltRelatedInfo();
-            UnreachableAlts = null;
+            StartState = s0;
+            UnreachableAlts.Clear();
foreach ( var edgeVar in edgeMap )
{
IntervalSet edge = edgeVar.Key;
@@ -102,10 +92,10 @@ namespace Antlr3.Analysis
s0.AddTransition( s, e );
if ( alts.Count == 1 )
{
-                    s.acceptState = true;
+                    s.IsAcceptState = true;
int alt = alts[0];
SetAcceptState( alt, s );
-                    s.cachedUniquelyPredicatedAlt = alt;
+                    s.CachedUniquelyPredicatedAlt = alt;
}
else
{
@@ -115,13 +105,13 @@ namespace Antlr3.Analysis
for ( int i = 0; i < alts.Count; i++ )
{
int alt = (int)alts[i];
-                        s.cachedUniquelyPredicatedAlt = NFA.INVALID_ALT_NUMBER;
+                        s.CachedUniquelyPredicatedAlt = NFA.INVALID_ALT_NUMBER;
DFAState predDFATarget = GetAcceptState( alt );
if ( predDFATarget == null )
{
predDFATarget = NewState(); // create if not there.
-                            predDFATarget.acceptState = true;
-                            predDFATarget.cachedUniquelyPredicatedAlt = alt;
+                            predDFATarget.IsAcceptState = true;
+                            predDFATarget.CachedUniquelyPredicatedAlt = alt;
SetAcceptState( alt, predDFATarget );
}
// add a transition to pred target from d
@@ -171,7 +161,7 @@ namespace Antlr3.Analysis
int walkAlt =
decisionStartState.TranslateDisplayAltToWalkAlt( alt );
NFAState altLeftEdge =
-                nfa.grammar.GetNFAStateForAltOfDecision( decisionStartState, walkAlt );
+                Nfa.Grammar.GetNFAStateForAltOfDecision( decisionStartState, walkAlt );
NFAState altStartState = (NFAState)altLeftEdge.transition[0].Target;
//JSystem.@out.println("alt "+alt+" start state = "+altStartState.stateNumber);
if ( altStartState.transition[0].IsSemanticPredicate )
@@ -188,7 +178,7 @@ namespace Antlr3.Analysis
*/
if ( ctx.IsSyntacticPredicate )
{
-                            nfa.grammar.SynPredUsedInDFA( this, ctx );
+                            Nfa.Grammar.SynPredUsedInDFA( this, ctx );
}
return (SemanticContext.Predicate)altStartState.transition[0].Label.SemanticContext;
}
diff --git a/Antlr3/Analysis/Label.cs b/Antlr3/Analysis/Label.cs
index e9db325..1d6d3dc 100644
--- a/Antlr3/Analysis/Label.cs
+++ b/Antlr3/Analysis/Label.cs
@@ -47,7 +47,7 @@ namespace Antlr3.Analysis
*  (which assumes an epsilon transition) or a tree of predicates (in a DFA).
*  Special label types have to be &lt; 0 to avoid conflict with char.
*/
-    public class Label : IComparable, ICloneable
+    public class Label : System.IComparable<Label>, ICloneable
{
public const int INVALID = -7;

@@ -169,6 +169,9 @@ namespace Antlr3.Analysis
}
}

+        /// <summary>
+        /// Gets whether or not the label is an action
+        /// </summary>
public virtual bool IsAction
{
get
@@ -177,6 +180,9 @@ namespace Antlr3.Analysis
}
}

+        /// <summary>
+        /// Gets whether or not the label is an atom
+        /// </summary>
public virtual bool IsAtom
{
get
@@ -185,6 +191,9 @@ namespace Antlr3.Analysis
}
}

+        /// <summary>
+        /// Gets whether or not the label is an epsilon label
+        /// </summary>
public virtual bool IsEpsilon
{
get
@@ -193,6 +202,9 @@ namespace Antlr3.Analysis
}
}

+        /// <summary>
+        /// Gets whether or not the label is a semantic predicate
+        /// </summary>
public virtual bool IsSemanticPredicate
{
get
@@ -201,6 +213,9 @@ namespace Antlr3.Analysis
}
}

+        /// <summary>
+        /// Gets whether or not the label matches a set
+        /// </summary>
public virtual bool IsSet
{
get
@@ -209,6 +224,9 @@ namespace Antlr3.Analysis
}
}

+        /// <summary>
+        /// Gets the semantic context for the label
+        /// </summary>
public virtual SemanticContext SemanticContext
{
get
@@ -236,24 +254,19 @@ namespace Antlr3.Analysis
}
}

-        public virtual object Clone()
+        public virtual Label Clone()
{
-            Label l;
-            //try
-            //{
-                //l = (Label)base.clone();
-                l = new Label( label );
-                l.label = this.label;
-                l._labelSet = new IntervalSet();
-                l._labelSet.AddAll( this._labelSet );
-            //}
-            //catch ( CloneNotSupportedException e )
-            //{
-            //    throw new InternalError();
-            //}
+            Label l = new Label(label);
+            l._labelSet = new IntervalSet();
+            l._labelSet.AddAll(this._labelSet);
return l;
}

+        object ICloneable.Clone()
+        {
+            return Clone();
+        }
+
public virtual void Add( Label a )
{
if ( IsAtom )
@@ -272,8 +285,10 @@ namespace Antlr3.Analysis
{
throw new InvalidOperationException( "can't add element to Label of type " + label );
}
+
return;
}
+
if ( IsSet )
{
if ( a.IsAtom )
@@ -288,8 +303,10 @@ namespace Antlr3.Analysis
{
throw new InvalidOperationException( "can't add element to Label of type " + label );
}
+
return;
}
+
throw new InvalidOperationException( "can't add element to Label of type " + label );
}

@@ -297,12 +314,15 @@ namespace Antlr3.Analysis
{
if ( label == atom )
{
-                return true; // handle the single atom case efficiently
+                // handle the single atom case efficiently
+                return true;
}
+
if ( IsSet )
{
return _labelSet.Contains( atom );
}
+
return false;
}

@@ -312,11 +332,13 @@ namespace Antlr3.Analysis
{
return set.Contains( Atom );
}
+
if ( IsSet )
{
// matches if intersection non-nil
return !Set.And( set ).IsNil;
}
+
return false;
}

@@ -327,10 +349,12 @@ namespace Antlr3.Analysis
{
return Matches( other.Set );
}
+
if ( other.IsAtom )
{
return Matches( other.Atom );
}
+
return false;
}

@@ -349,29 +373,34 @@ namespace Antlr3.Analysis
// TODO: do we care about comparing set {A} with atom A? Doesn't now.
public override bool Equals( object o )
{
-            if ( o == null )
-            {
+            Label other = o as Label;
+            if (other == null)
return false;
-            }
-            if ( this == o )
+
+            if (object.ReferenceEquals(this, o))
{
-                return true; // equals if same object
+                // equals if same object
+                return true;
}
+
// labels must be the same even if epsilon or set or sempred etc...
-            if ( label != ( (Label)o ).label )
+            if ( label != other.label )
{
return false;
}
+
if ( label == SET )
{
-                return this._labelSet.Equals( ( (Label)o )._labelSet );
+                return this._labelSet.Equals( other._labelSet );
}
-            return true;  // label values are same, so true
+
+            // label values are same, so true
+            return true;
}

-        public virtual int CompareTo( object o )
+        public virtual int CompareTo( Label other )
{
-            return this.label - ( (Label)o ).label;
+            return this.label - other.label;
}

#if false
@@ -408,6 +437,7 @@ namespace Antlr3.Analysis
{
case SET:
return _labelSet.ToString();
+
default:
return label.ToString(); //String.valueOf( label );
}
@@ -466,6 +496,7 @@ namespace Antlr3.Analysis
{
hasIntersection = true;
}
+
return hasIntersection;
}
}
diff --git a/Antlr3/Analysis/LookaheadSet.cs b/Antlr3/Analysis/LookaheadSet.cs
index fd3ac6d..c943a4a 100644
--- a/Antlr3/Analysis/LookaheadSet.cs
+++ b/Antlr3/Analysis/LookaheadSet.cs
@@ -43,7 +43,7 @@ namespace Antlr3.Analysis
*/
public class LookaheadSet
{
-        public IntervalSet tokenTypeSet;
+        private IntervalSet tokenTypeSet;

public LookaheadSet()
{
@@ -68,6 +68,15 @@ namespace Antlr3.Analysis
}

#region Properties
+
+        public IntervalSet TokenTypeSet
+        {
+            get
+            {
+                return tokenTypeSet;
+            }
+        }
+
public bool IsNil
{
get
@@ -75,6 +84,7 @@ namespace Antlr3.Analysis
return tokenTypeSet.IsNil;
}
}
+
#endregion

public virtual void OrInPlace( LookaheadSet other )
diff --git a/Antlr3/Analysis/MachineProbe.cs b/Antlr3/Analysis/MachineProbe.cs
index 4e2d9e0..7df14b3 100644
--- a/Antlr3/Analysis/MachineProbe.cs
+++ b/Antlr3/Analysis/MachineProbe.cs
@@ -33,23 +33,28 @@
namespace Antlr3.Analysis
{
using System.Collections.Generic;
+    using Antlr.Runtime;
using Antlr3.Misc;
using Antlr3.Tool;
-    using Antlr.Runtime;
+
+    using ArgumentNullException = System.ArgumentNullException;

public class MachineProbe
{
-        private DFA dfa;
+        private readonly DFA _dfa;

public MachineProbe(DFA dfa)
{
-            this.dfa = dfa;
+            if (dfa == null)
+                throw new ArgumentNullException("dfa");
+
+            this._dfa = dfa;
}

internal List<DFAState> GetAnyDFAPathToTarget(DFAState targetState)
{
HashSet<DFAState> visited = new HashSet<DFAState>();
-            return GetAnyDFAPathToTarget(dfa.startState, targetState, visited);
+            return GetAnyDFAPathToTarget(_dfa.StartState, targetState, visited);
}

public List<DFAState> GetAnyDFAPathToTarget(DFAState startState, DFAState targetState, HashSet<DFAState> visited)
@@ -143,11 +148,11 @@ namespace Antlr3.Analysis
{
IToken oldtoken = p.associatedASTNode.Token;
CommonToken token = new CommonToken(oldtoken.Type, oldtoken.Text);
-                                token.Line = (oldtoken.Line);
-                                token.CharPositionInLine = (oldtoken.CharPositionInLine);
+                                token.Line = oldtoken.Line;
+                                token.CharPositionInLine = oldtoken.CharPositionInLine;
tokens.Add(token);
-                                goto endNfaConfigLoop; // found path, move to next
-                                // NFAState set
+                                // found path, move to next NFAState set
+                                goto endNfaConfigLoop;
}
}
}
diff --git a/Antlr3/Analysis/NFA.cs b/Antlr3/Analysis/NFA.cs
index fab8d61..2847ab0 100644
--- a/Antlr3/Analysis/NFA.cs
+++ b/Antlr3/Analysis/NFA.cs
@@ -45,45 +45,61 @@ namespace Antlr3.Analysis
public const int INVALID_ALT_NUMBER = -1;

/** This NFA represents which grammar? */
-        internal Grammar grammar;
+        private readonly Grammar _grammar;

/** Which factory created this NFA? */
-        NFAFactory _factory;
+        private readonly NFAFactory _factory;

-        public bool complete;
+        private bool _complete;

-        public NFA( Grammar g )
+        public NFA( Grammar grammar )
{
-            this.grammar = g;
+            this._grammar = grammar;
+            this._factory = new NFAFactory(this);
+        }
+
+        public Grammar Grammar
+        {
+            get
+            {
+                return _grammar;
+            }
}

-        #region Properties
public NFAFactory Factory
{
get
{
return _factory;
}
+        }
+
+        public bool Complete
+        {
+            get
+            {
+                return _complete;
+            }
+
set
{
-                _factory = value;
+                _complete = value;
}
}
-        #endregion

public int GetNewNFAStateNumber()
{
-            return grammar.composite.GetNewNFAStateNumber();
+            return Grammar.composite.GetNewNFAStateNumber();
}

public void AddState( NFAState state )
{
-            grammar.composite.AddState( state );
+            Grammar.composite.AddState( state );
}

public NFAState GetState( int s )
{
-            return grammar.composite.GetState( s );
+            return Grammar.composite.GetState( s );
}
}
}
diff --git a/Antlr3/Analysis/NFAConfiguration.cs b/Antlr3/Analysis/NFAConfiguration.cs
index 0483926..18081ff 100644
--- a/Antlr3/Analysis/NFAConfiguration.cs
+++ b/Antlr3/Analysis/NFAConfiguration.cs
@@ -32,6 +32,7 @@

namespace Antlr3.Analysis
{
+    using ArgumentNullException = System.ArgumentNullException;
using StringBuilder = System.Text.StringBuilder;

/** An NFA state, predicted alt, and syntactic/semantic context.
@@ -43,13 +44,13 @@ namespace Antlr3.Analysis
public class NFAConfiguration
{
/** The NFA state associated with this configuration */
-        public int state;
+        private readonly int _state;

/** What alt is predicted by this configuration */
-        public int alt;
+        private readonly int _alt;

/** What is the stack of rule invocations that got us to state? */
-        public NFAContext context;
+        private readonly NFAContext _context;

/** The set of semantic predicates associated with this NFA
*  configuration.  The predicates were found on the way to
@@ -60,7 +61,7 @@ namespace Antlr3.Analysis
*  the equals() method will correctly show {pred1,pred2} as equals()
*  to {pred2,pred1}.
*/
-        public SemanticContext semanticContext = SemanticContext.EmptySemanticContext;
+        private SemanticContext _semanticContext = SemanticContext.EmptySemanticContext;

/** Indicate that this configuration has been resolved and no further
*  DFA processing should occur with it.  Essentially, this is used
@@ -68,7 +69,7 @@ namespace Antlr3.Analysis
*  such as (s|2) and (s|3), I can set (s|3) to resolved=true (and any
*  other configuration associated with alt 3).
*/
-        protected internal bool resolved;
+        private bool _resolved;

/** This bit is used to indicate a semantic predicate will be
*  used to resolve the conflict.  Method
@@ -78,7 +79,7 @@ namespace Antlr3.Analysis
*  nondeterministic configurations (as it does for "resolved" field)
*  that have enough predicates to resolve the conflit.
*/
-        protected internal bool resolveWithPredicate;
+        private bool _resolveWithPredicate;

/** Lots of NFA states have only epsilon edges (1 or 2).  We can
*  safely consider only n>0 during closure.
@@ -88,7 +89,7 @@ namespace Antlr3.Analysis
/** Indicates that the NFA state associated with this configuration
*  has exactly one transition and it's an atom (not epsilon etc...).
*/
-        protected internal bool singleAtomTransitionEmanating;
+        private bool _singleAtomTransitionEmanating;

//protected boolean addedDuringClosure = true;

@@ -97,10 +98,89 @@ namespace Antlr3.Analysis
NFAContext context,
SemanticContext semanticContext )
{
-            this.state = state;
-            this.alt = alt;
-            this.context = context;
-            this.semanticContext = semanticContext;
+            this._state = state;
+            this._alt = alt;
+            this._context = context;
+            this._semanticContext = semanticContext;
+        }
+
+        public int State
+        {
+            get
+            {
+                return _state;
+            }
+        }
+
+        public int Alt
+        {
+            get
+            {
+                return _alt;
+            }
+        }
+
+        public NFAContext Context
+        {
+            get
+            {
+                return _context;
+            }
+        }
+
+        public SemanticContext SemanticContext
+        {
+            get
+            {
+                return _semanticContext;
+            }
+
+            set
+            {
+                if (value == null)
+                    throw new ArgumentNullException("value");
+
+                _semanticContext = value;
+            }
+        }
+
+        protected internal bool Resolved
+        {
+            get
+            {
+                return _resolved;
+            }
+
+            set
+            {
+                _resolved = value;
+            }
+        }
+
+        protected internal bool ResolveWithPredicate
+        {
+            get
+            {
+                return _resolveWithPredicate;
+            }
+
+            set
+            {
+                _resolveWithPredicate = value;
+            }
+        }
+
+        protected internal bool SingleAtomTransitionEmanating
+        {
+            get
+            {
+                return _singleAtomTransitionEmanating;
+            }
+
+            set
+            {
+                _singleAtomTransitionEmanating = value;
+            }
}

/** An NFA configuration is equal to another if both have
@@ -117,15 +197,15 @@ namespace Antlr3.Analysis
return false;
}
NFAConfiguration other = (NFAConfiguration)o;
-            return this.state == other.state &&
-                   this.alt == other.alt &&
-                   this.context.Equals( other.context ) &&
-                   this.semanticContext.Equals( other.semanticContext );
+            return this._state == other._state &&
+                   this._alt == other._alt &&
+                   this._context.Equals( other._context ) &&
+                   this._semanticContext.Equals( other._semanticContext );
}

public override int GetHashCode()
{
-            int h = state + alt + context.GetHashCode();
+            int h = _state + _alt + _context.GetHashCode();
return h;
}

@@ -137,32 +217,37 @@ namespace Antlr3.Analysis
public string ToString( bool showAlt )
{
StringBuilder buf = new StringBuilder();
-            buf.Append( state );
+            buf.Append( _state );
if ( showAlt )
{
buf.Append( "|" );
-                buf.Append( alt );
+                buf.Append( _alt );
}
-            if ( context.parent != null )
+
+            if ( _context.Parent != null )
{
buf.Append( "|" );
-                buf.Append( context );
+                buf.Append( _context );
}
-            if ( semanticContext != null &&
-                 semanticContext != SemanticContext.EmptySemanticContext )
+
+            if ( _semanticContext != null &&
+                 _semanticContext != SemanticContext.EmptySemanticContext )
{
buf.Append( "|" );
-                string escQuote = semanticContext.ToString().Replace( "\"", "\\\"" );
+                string escQuote = _semanticContext.ToString().Replace( "\"", "\\\"" );
buf.Append( escQuote );
}
-            if ( resolved )
+
+            if ( _resolved )
{
buf.Append( "|resolved" );
}
-            if ( resolveWithPredicate )
+
+            if ( _resolveWithPredicate )
{
buf.Append( "|resolveWithPredicate" );
}
+
return buf.ToString();
}
}
diff --git a/Antlr3/Analysis/NFAContext.cs b/Antlr3/Analysis/NFAContext.cs
index f576510..ee5514d 100644
--- a/Antlr3/Analysis/NFAContext.cs
+++ b/Antlr3/Analysis/NFAContext.cs
@@ -106,12 +106,12 @@ namespace Antlr3.Analysis
*/
public static int MAX_SAME_RULE_INVOCATIONS_PER_NFA_CONFIG_STACK = 4;

-        public NFAContext parent;
+        private readonly NFAContext _parent;

/** The NFA state that invoked another rule's start state is recorded
*  on the rule invocation context stack.
*/
-        public NFAState invokingState;
+        private readonly NFAState _invokingState;

/** Computing the hashCode is very expensive and closureBusy()
*  uses it to track when it's seen a state|ctx before to avoid
@@ -122,23 +122,39 @@ namespace Antlr3.Analysis
*  and nothing on the stack is ever modified...ctx just grows
*  or shrinks.
*/
-        int _cachedHashCode;
+        private readonly int _cachedHashCode;

public NFAContext( NFAContext parent, NFAState invokingState )
{
-            this.parent = parent;
-            this.invokingState = invokingState;
+            this._parent = parent;
+            this._invokingState = invokingState;
if ( invokingState != null )
{
this._cachedHashCode = invokingState.StateNumber;
}
+
if ( parent != null )
{
this._cachedHashCode += parent._cachedHashCode;
}
}

-        #region Properties
+        public NFAContext Parent
+        {
+            get
+            {
+                return _parent;
+            }
+        }
+
+        public NFAState InvokingState
+        {
+            get
+            {
+                return _invokingState;
+            }
+        }
+
/** A context is empty if there is no parent; meaning nobody pushed
*  anything on the call stack.
*/
@@ -146,10 +162,9 @@ namespace Antlr3.Analysis
{
get
{
-                return parent == null;
+                return _parent == null;
}
}
-        #endregion

/** Two contexts are equals() if both have
*  same call stack; walk upwards to the root.
@@ -172,16 +187,16 @@ namespace Antlr3.Analysis
}
// JSystem.@out.println("comparing "+this+" with "+other);
NFAContext sp = this;
-            while ( sp.parent != null && other.parent != null )
+            while ( sp._parent != null && other._parent != null )
{
-                if ( sp.invokingState != other.invokingState )
+                if ( sp._invokingState != other._invokingState )
{
return false;
}
-                sp = sp.parent;
-                other = other.parent;
+                sp = sp._parent;
+                other = other._parent;
}
-            if ( !( sp.parent == null && other.parent == null ) )
+            if ( !( sp._parent == null && other._parent == null ) )
{
return false; // both pointers must be at their roots after walk
}
@@ -239,14 +254,14 @@ namespace Antlr3.Analysis
{
NFAContext sp = this;
// if one of the contexts is empty, it never enters loop and returns true
-            while ( sp.parent != null && other.parent != null )
+            while ( sp._parent != null && other._parent != null )
{
-                if ( sp.invokingState != other.invokingState )
+                if ( sp._invokingState != other._invokingState )
{
return false;
}
-                sp = sp.parent;
-                other = other.parent;
+                sp = sp._parent;
+                other = other._parent;
}
//JSystem.@out.println("suffix");
return true;
@@ -290,13 +305,13 @@ namespace Antlr3.Analysis
NFAContext sp = this;
int n = 0; // track recursive invocations of target from this state
//JSystem.@out.println("this.context is "+sp);
-            while ( sp.parent != null )
+            while ( sp._parent != null )
{
-                if ( sp.invokingState.StateNumber == state )
+                if ( sp._invokingState.StateNumber == state )
{
n++;
}
-                sp = sp.parent;
+                sp = sp._parent;
}
return n;
}
@@ -320,11 +335,11 @@ namespace Antlr3.Analysis
StringBuilder buf = new StringBuilder();
NFAContext sp = this;
buf.Append( "[" );
-            while ( sp.parent != null )
+            while ( sp._parent != null )
{
-                buf.Append( sp.invokingState.StateNumber );
+                buf.Append( sp._invokingState.StateNumber );
buf.Append( " " );
-                sp = sp.parent;
+                sp = sp._parent;
}
buf.Append( "$]" );
return buf.ToString();
diff --git a/Antlr3/Analysis/NFAState.cs b/Antlr3/Analysis/NFAState.cs
index a3f8e4a..dd13990 100644
--- a/Antlr3/Analysis/NFAState.cs
+++ b/Antlr3/Analysis/NFAState.cs
@@ -259,7 +259,7 @@ namespace Antlr3.Analysis
ErrorManager.internalError("can't get DFA for decision "+decisionNumber);
}
*/
-            int nAlts = nfa.grammar.GetNumberOfAltsForDecisionNFA( nfaStart );
+            int nAlts = nfa.Grammar.GetNumberOfAltsForDecisionNFA( nfaStart );
switch ( nfaStart.decisionStateType )
{
case LOOPBACK:
diff --git a/Antlr3/Analysis/NFAtoDFAConverter.cs b/Antlr3/Analysis/NFAtoDFAConverter.cs
index 90bbbfa..c4ce836 100644
--- a/Antlr3/Analysis/NFAtoDFAConverter.cs
+++ b/Antlr3/Analysis/NFAtoDFAConverter.cs
@@ -47,8 +47,19 @@ namespace Antlr3.Analysis
*/
public class NFAToDFAConverter
{
+        public static bool debug = false;
+
+        /** Should ANTLR launch multiple threads to convert NFAs to DFAs?
+         *  With a 2-CPU box, I note that it's about the same single or
+         *  multithreaded.  Both CPU meters are going even when single-threaded
+         *  so I assume the GC is killing us.  Could be the compiler.  When I
+         *  run java -Xint mode, I get about 15% speed improvement with multiple
+         *  threads.
+         */
+        public static bool SINGLE_THREADED_NFA_CONVERSION = true;
+
/** A list of DFA states we still need to process during NFA conversion */
-        Queue<DFAState> _work = new Queue<DFAState>();
+        private readonly Queue<DFAState> _work = new Queue<DFAState>();

/** While converting NFA, we must track states that
*  reference other rule's NFAs so we know what to do
@@ -57,23 +68,12 @@ namespace Antlr3.Analysis
*  states.  I'm tracking a context tree (record of rule invocation
*  stack trace) for each alternative that could be predicted.
*/
-        NFAContext[] _contextTrees;
+        private NFAContext[] _contextTrees;

/** We are converting which DFA? */
-        DFA _dfa;
-
-        public static bool debug = false;
-
-        /** Should ANTLR launch multiple threads to convert NFAs to DFAs?
-         *  With a 2-CPU box, I note that it's about the same single or
-         *  multithreaded.  Both CPU meters are going even when single-threaded
-         *  so I assume the GC is killing us.  Could be the compiler.  When I
-         *  run java -Xint mode, I get about 15% speed improvement with multiple
-         *  threads.
-         */
-        public static bool SINGLE_THREADED_NFA_CONVERSION = true;
+        private readonly DFA _dfa;

-        bool _computingStartState = false;
+        private bool _computingStartState = false;

public NFAToDFAConverter( DFA dfa )
{
@@ -87,17 +87,17 @@ namespace Antlr3.Analysis
//_dfa.conversionStartTime = System.DateTime.Now;

// create the DFA start state
-            _dfa.startState = ComputeStartState();
+            _dfa.StartState = ComputeStartState();

// while more DFA states to check, process them
while ( _work.Count > 0 &&
-                    !_dfa.nfa.grammar.NFAToDFAConversionExternallyAborted() )
+                    !_dfa.Nfa.Grammar.NFAToDFAConversionExternallyAborted() )
{
DFAState d = (DFAState)_work.Peek();
-                if ( _dfa.nfa.grammar.composite.watchNFAConversion )
+                if ( _dfa.Nfa.Grammar.composite.WatchNFAConversion )
{
Console.Out.WriteLine( "convert DFA state " + d.StateNumber +
-                                       " (" + d.nfaConfigurations.Count + " nfa states)" );
+                                       " (" + d.NfaConfigurations.Count + " nfa states)" );
}
int k = _dfa.UserMaxLookahead;
if ( k > 0 && k == d.LookaheadDepth )
@@ -170,7 +170,7 @@ namespace Antlr3.Analysis
if ( i == 0 &&
_dfa.NFADecisionStartState.decisionStateType == NFAState.LOOPBACK )
{
-                    int numAltsIncludingExitBranch = _dfa.nfa.grammar
+                    int numAltsIncludingExitBranch = _dfa.Nfa.Grammar
.GetNumberOfAltsForDecisionNFA( _dfa.NFADecisionStartState );
altNum = numAltsIncludingExitBranch;
Closure( (NFAState)alt.transition[0].Target,
@@ -299,7 +299,7 @@ namespace Antlr3.Analysis
if ( debug )
{
Console.Out.WriteLine( "DFA state after reach " + label + " " + d + "-" +
-                                       label.ToString( _dfa.nfa.grammar ) + "->" + t );
+                                       label.ToString( _dfa.Nfa.Grammar ) + "->" + t );
}
if ( t == null )
{
@@ -348,7 +348,7 @@ namespace Antlr3.Analysis
// TODO: can fixed lookahead hit a dangling state case?
// TODO: yes, with left recursion
//Console.Error.WriteLine( "dangling state alts: " + d.getAltSet() );
-                _dfa.probe.ReportDanglingState( d );
+                _dfa.Probe.ReportDanglingState( d );
// turn off all configurations except for those associated with
// min alt number; somebody has to win else some input will not
// predict any alt.
@@ -500,13 +500,13 @@ namespace Antlr3.Analysis
List<NFAConfiguration> configs = new List<NFAConfiguration>();
// Because we are adding to the configurations in closure
// must clone initial list so we know when to stop doing closure
-            configs.AddRange( d.nfaConfigurations );
+            configs.AddRange( d.NfaConfigurations );
// for each NFA configuration in d (abort if we detect non-LL(*) state)
int numConfigs = configs.Count;
for ( int i = 0; i < numConfigs; i++ )
{
NFAConfiguration c = (NFAConfiguration)configs[i];
-                if ( c.singleAtomTransitionEmanating )
+                if ( c.SingleAtomTransitionEmanating )
{
continue; // ignore NFA states w/o epsilon transitions
}
@@ -514,15 +514,15 @@ namespace Antlr3.Analysis
// figure out reachable NFA states from each of d's nfa states
// via epsilon transitions.
// Fill configsInClosure rather than altering d configs inline
-                Closure( _dfa.nfa.GetState( c.state ),
-                        c.alt,
-                        c.context,
-                        c.semanticContext,
+                Closure( _dfa.Nfa.GetState( c.State ),
+                        c.Alt,
+                        c.Context,
+                        c.SemanticContext,
d,
false );
}
//JSystem.@out.println("after closure d="+d);
-            d.closureBusy = null; // wack all that memory used during closure
+            d.ClosureBusy = null; // wack all that memory used during closure
}

/** Where can we get from NFA state p traversing only epsilon transitions?
@@ -663,13 +663,13 @@ namespace Antlr3.Analysis
{
Console.Out.WriteLine( "avoid visiting exact closure computation NFA config: " +
proposedNFAConfiguration + " in " + p.enclosingRule.Name );
-                    Console.Out.WriteLine( "state is " + d.dfa.decisionNumber + "." + d.StateNumber );
+                    Console.Out.WriteLine( "state is " + d.Dfa.DecisionNumber + "." + d.StateNumber );
}
return;
}

// set closure to be busy for this NFA configuration
-            d.closureBusy.Add( proposedNFAConfiguration );
+            d.ClosureBusy.Add( proposedNFAConfiguration );

// p itself is always in closure
d.AddNFAConfiguration( p, proposedNFAConfiguration );
@@ -681,14 +681,14 @@ namespace Antlr3.Analysis
int depth = context.RecursionDepthEmanatingFromState( p.StateNumber );
// Detect recursion by more than a single alt, which indicates
// that the decision's lookahead language is potentially non-regular; terminate
-                if ( depth == 1 && d.dfa.UserMaxLookahead == 0 )
+                if ( depth == 1 && d.Dfa.UserMaxLookahead == 0 )
{ // k=* only
-                    d.dfa.recursiveAltSet.Add( alt ); // indicate that this alt is recursive
-                    if ( d.dfa.recursiveAltSet.Count > 1 )
+                    d.Dfa.RecursiveAltSet.Add( alt ); // indicate that this alt is recursive
+                    if ( d.Dfa.RecursiveAltSet.Count > 1 )
{
//JSystem.@out.println("recursive alts: "+d.dfa.recursiveAltSet.toString());
-                        d.abortedDueToMultipleRecursiveAlts = true;
-                        throw new NonLLStarDecisionException( d.dfa );
+                        d.AbortedDueToMultipleRecursiveAlts = true;
+                        throw new NonLLStarDecisionException( d.Dfa );
}
/*
JSystem.@out.println("alt "+alt+" in rule "+p.enclosingRule+" dec "+d.dfa.decisionNumber+
@@ -705,8 +705,8 @@ namespace Antlr3.Analysis
JSystem.@out.println("OVF state "+d);
JSystem.@out.println("proposed "+proposedNFAConfiguration);
*/
-                    d.abortedDueToRecursionOverflow = true;
-                    d.dfa.probe.ReportRecursionOverflow( d, proposedNFAConfiguration );
+                    d.AbortedDueToRecursionOverflow = true;
+                    d.Dfa.Probe.ReportRecursionOverflow( d, proposedNFAConfiguration );
if ( debug )
{
Console.Out.WriteLine( "analysis overflow in closure(" + d.StateNumber + ")" );
@@ -730,13 +730,13 @@ namespace Antlr3.Analysis
Closure( ruleTarget, alt, newContext, semanticContext, d, collectPredicates );
}
// Case 2: end of rule state, context (i.e., an invoker) exists
-            else if ( p.IsAcceptState && context.parent != null )
+            else if ( p.IsAcceptState && context.Parent != null )
{
-                NFAState whichStateInvokedRule = context.invokingState;
+                NFAState whichStateInvokedRule = context.InvokingState;
RuleClosureTransition edgeToRule =
(RuleClosureTransition)whichStateInvokedRule.transition[0];
-                NFAState continueState = edgeToRule.followState;
-                NFAContext newContext = context.parent; // "pop" invoking state
+                NFAState continueState = edgeToRule.FollowState;
+                NFAContext newContext = context.Parent; // "pop" invoking state
Closure( continueState, alt, newContext, semanticContext, d, collectPredicates );
}
// Case 3: end of rule state, nobody invoked this rule (no context)
@@ -773,12 +773,12 @@ namespace Antlr3.Analysis
{
// only indicate we can see a predicate if we're collecting preds
// Could be computing start state & seen an action before this.
-                            _dfa.predicateVisible = true;
+                            _dfa.PredicateVisible = true;
}
else
{
// this state has a pred, but we can't see it.
-                            _dfa.hasPredicateBlockedByAction = true;
+                            _dfa.HasPredicateBlockedByAction = true;
// JSystem.@out.println("found pred during prediction but blocked by action found previously");
}
}
@@ -794,7 +794,7 @@ namespace Antlr3.Analysis
int walkAlt =
_dfa.NFADecisionStartState.TranslateDisplayAltToWalkAlt( alt );
NFAState altLeftEdge =
-                            _dfa.nfa.grammar.GetNFAStateForAltOfDecision( _dfa.NFADecisionStartState, walkAlt );
+                            _dfa.Nfa.Grammar.GetNFAStateForAltOfDecision( _dfa.NFADecisionStartState, walkAlt );
/*
JSystem.@out.println("state "+p.stateNumber+" alt "+alt+" walkAlt "+walkAlt+" trans to "+transition0.target);
JSystem.@out.println("DFA start state "+dfa.decisionNFAStartState.stateNumber);
@@ -868,7 +868,7 @@ namespace Antlr3.Analysis
public static bool ClosureIsBusy( DFAState d,
NFAConfiguration proposedNFAConfiguration )
{
-            return d.closureBusy.Contains( proposedNFAConfiguration );
+            return d.ClosureBusy.Contains( proposedNFAConfiguration );
/*
int numConfigs = d.closureBusy.size();
// Check epsilon cycle (same state, same alt, same context)
@@ -913,20 +913,20 @@ namespace Antlr3.Analysis
// add in target states for label
//JSystem.@out.println("size(d.state="+d.stateNumber+")="+d.nfaConfigurations.size());
//JSystem.@out.println("size(labeled edge states)="+d.configurationsWithLabeledEdges.size());
-            IList<NFAConfiguration> configs = d.configurationsWithLabeledEdges;
+            IList<NFAConfiguration> configs = d.ConfigurationsWithLabeledEdges;
int numConfigs = configs.Count;
for ( int i = 0; i < numConfigs; i++ )
{
NFAConfiguration c = configs[i];
-                if ( c.resolved || c.resolveWithPredicate )
+                if ( c.Resolved || c.ResolveWithPredicate )
{
continue; // the conflict resolver indicates we must leave alone
}
-                NFAState p = _dfa.nfa.GetState( c.state );
+                NFAState p = _dfa.Nfa.GetState( c.State );
// by design of the grammar->NFA conversion, only transition 0
// may have a non-epsilon edge.
Transition edge = p.transition[0];
-                if ( edge == null || !c.singleAtomTransitionEmanating )
+                if ( edge == null || !c.SingleAtomTransitionEmanating )
{
continue;
}
@@ -939,7 +939,7 @@ namespace Antlr3.Analysis
// to this rule in the invoking rule.  In other words, if
// somebody called this rule, don't see the EOT emanating from
// this accept state.
-                if ( c.context.parent != null && edgeLabel.label == Label.EOT )
+                if ( c.Context.Parent != null && edgeLabel.label == Label.EOT )
{
continue;
}
@@ -953,12 +953,12 @@ namespace Antlr3.Analysis
// add NFA target to (potentially) new DFA state
NFAConfiguration newC = labelDFATarget.AddNFAConfiguration(
(NFAState)edge.Target,
-                        c.alt,
-                        c.context,
-                        c.semanticContext );
+                        c.Alt,
+                        c.Context,
+                        c.SemanticContext );
}
}
-            if ( labelDFATarget.nfaConfigurations.Count == 0 )
+            if ( labelDFATarget.NfaConfigurations.Count == 0 )
{
// kill; it's empty
_dfa.SetState( labelDFATarget.StateNumber, null );
@@ -981,15 +981,15 @@ namespace Antlr3.Analysis
protected virtual void ConvertToEOTAcceptState( DFAState d )
{
Label eot = new Label( Label.EOT );
-            int numConfigs = d.nfaConfigurations.Count;
+            int numConfigs = d.NfaConfigurations.Count;
for ( int i = 0; i < numConfigs; i++ )
{
-                NFAConfiguration c = (NFAConfiguration)d.nfaConfigurations[i];
-                if ( c.resolved || c.resolveWithPredicate )
+                NFAConfiguration c = d.NfaConfigurations[i];
+                if ( c.Resolved || c.ResolveWithPredicate )
{
continue; // the conflict resolver indicates we must leave alone
}
-                NFAState p = _dfa.nfa.GetState( c.state );
+                NFAState p = _dfa.Nfa.GetState( c.State );
Transition edge = p.transition[0];
Label edgeLabel = edge.Label;
if ( edgeLabel.Equals( eot ) )
@@ -997,8 +997,8 @@ namespace Antlr3.Analysis
//JSystem.@out.println("config with EOT: "+c);
d.IsAcceptState = true;
//JSystem.@out.println("d goes from "+d);
-                    d.nfaConfigurations.Clear();
-                    d.AddNFAConfiguration( p, c.alt, c.context, c.semanticContext );
+                    d.NfaConfigurations.Clear();
+                    d.AddNFAConfiguration( p, c.Alt, c.Context, c.SemanticContext );
//JSystem.@out.println("to "+d);
return; // assume only one EOT transition
}
@@ -1065,8 +1065,8 @@ namespace Antlr3.Analysis
// the start state to the nondet state
if ( DFAOptimizer.MergeStopStates &&
d.GetNonDeterministicAlts() == null &&
-                !d.abortedDueToRecursionOverflow &&
-                !d.abortedDueToMultipleRecursiveAlts )
+                !d.AbortedDueToRecursionOverflow &&
+                !d.AbortedDueToMultipleRecursiveAlts )
{
// check to see if we already have an accept state for this alt
// [must do this after we resolve nondeterminisms in general]
@@ -1259,8 +1259,8 @@ namespace Antlr3.Analysis
// transition on EOT to get to this DFA state as well so all
// states in d must be targets of EOT.  These are the end states
// created in NFAFactory.build_EOFState
-            NFAConfiguration anyConfig = d.nfaConfigurations[0];
-            NFAState anyState = _dfa.nfa.GetState( anyConfig.state );
+            NFAConfiguration anyConfig = d.NfaConfigurations[0];
+            NFAState anyState = _dfa.Nfa.GetState( anyConfig.State );

// if d is target of EOT and more than one predicted alt
// indicate that d is nondeterministic on all alts otherwise
@@ -1273,9 +1273,9 @@ namespace Antlr3.Analysis
{
nondeterministicAlts = allAlts;
// track Tokens rule issues differently than other decisions
-                    if ( d.dfa.IsTokensRuleDecision )
+                    if ( d.Dfa.IsTokensRuleDecision )
{
-                        _dfa.probe.ReportLexerRuleNondeterminism( d, allAlts );
+                        _dfa.Probe.ReportLexerRuleNondeterminism( d, allAlts );
//JSystem.@out.println("Tokens rule DFA state "+d+" nondeterministic");
conflictingLexerRules = true;
}
@@ -1283,17 +1283,17 @@ namespace Antlr3.Analysis
}

// if no problems return unless we aborted work on d to avoid inf recursion
-            if ( !d.abortedDueToRecursionOverflow && nondeterministicAlts == null )
+            if ( !d.AbortedDueToRecursionOverflow && nondeterministicAlts == null )
{
return; // no problems, return
}

// if we're not a conflicting lexer rule and we didn't abort, report ambig
// We should get a report for abort so don't give another
-            if ( !d.abortedDueToRecursionOverflow && !conflictingLexerRules )
+            if ( !d.AbortedDueToRecursionOverflow && !conflictingLexerRules )
{
// TODO: with k=x option set, this is called twice for same state
-                _dfa.probe.ReportNondeterminism( d, nondeterministicAlts );
+                _dfa.Probe.ReportNondeterminism( d, nondeterministicAlts );
// TODO: how to turn off when it's only the FOLLOW that is
// conflicting.  This used to shut off even alts i,j < n
// conflict warnings. :(
@@ -1309,7 +1309,7 @@ namespace Antlr3.Analysis
Console.Out.WriteLine( "resolved DFA state " + d.StateNumber + " with pred" );
}
d.IsResolvedWithPredicates = true;
-                _dfa.probe.ReportNondeterminismResolvedWithSemanticPredicate( d );
+                _dfa.Probe.ReportNondeterminismResolvedWithSemanticPredicate( d );
return;
}

@@ -1370,7 +1370,7 @@ namespace Antlr3.Analysis
}
else
{
-                min = d.minAltInConfigurations;
+                min = d.MinAltInConfigurations;
}

TurnOffOtherAlts( d, min, nondeterministicAlts );
@@ -1393,16 +1393,16 @@ namespace Antlr3.Analysis
*/
protected static void TurnOffOtherAlts( DFAState d, int min, ICollection<int> nondeterministicAlts )
{
-            int numConfigs = d.nfaConfigurations.Count;
+            int numConfigs = d.NfaConfigurations.Count;
for ( int i = 0; i < numConfigs; i++ )
{
-                NFAConfiguration configuration = (NFAConfiguration)d.nfaConfigurations[i];
-                if ( configuration.alt != min )
+                NFAConfiguration configuration = d.NfaConfigurations[i];
+                if ( configuration.Alt != min )
{
if ( nondeterministicAlts == null ||
-                         nondeterministicAlts.Contains( configuration.alt ) )
+                         nondeterministicAlts.Contains( configuration.Alt ) )
{
-                        configuration.resolved = true;
+                        configuration.Resolved = true;
}
}
}
@@ -1462,7 +1462,7 @@ namespace Antlr3.Analysis
}

//JSystem.@out.println("nondeterministic alts with predicates: "+altToPredMap);
-            _dfa.probe.ReportAltPredicateContext( d, altToPredMap );
+            _dfa.Probe.ReportAltPredicateContext( d, altToPredMap );

if ( nondeterministicAlts.Count - altToPredMap.Count > 1 )
{
@@ -1522,15 +1522,15 @@ namespace Antlr3.Analysis

altToPredMap[nakedAlt] = nakedAltPred;
// set all config with alt=nakedAlt to have the computed predicate
-                int numConfigs = d.nfaConfigurations.Count;
+                int numConfigs = d.NfaConfigurations.Count;
for ( int i = 0; i < numConfigs; i++ )
{
// TODO: I don't think we need to do this; altToPredMap has it
//7/27/10  theok, I removed it and it still seems to work with everything; leave in anyway just in case
-                    NFAConfiguration configuration = (NFAConfiguration)d.nfaConfigurations[i];
-                    if ( configuration.alt == nakedAlt )
+                    NFAConfiguration configuration = d.NfaConfigurations[i];
+                    if ( configuration.Alt == nakedAlt )
{
-                        configuration.semanticContext = nakedAltPred;
+                        configuration.SemanticContext = nakedAltPred;
}
}
}
@@ -1541,38 +1541,38 @@ namespace Antlr3.Analysis
// and setting its resolvedWithPredicate flag
// First, prevent a recursion warning on this state due to
// pred resolution
-                if ( d.abortedDueToRecursionOverflow )
+                if ( d.AbortedDueToRecursionOverflow )
{
-                    d.dfa.probe.RemoveRecursiveOverflowState( d );
+                    d.Dfa.Probe.RemoveRecursiveOverflowState( d );
}
-                int numConfigs = d.nfaConfigurations.Count;
+                int numConfigs = d.NfaConfigurations.Count;
//System.out.println("pred map="+altToPredMap);
for ( int i = 0; i < numConfigs; i++ )
{
-                    NFAConfiguration configuration = (NFAConfiguration)d.nfaConfigurations[i];
+                    NFAConfiguration configuration = d.NfaConfigurations[i];
SemanticContext semCtx;
-                    altToPredMap.TryGetValue(configuration.alt, out semCtx);
+                    altToPredMap.TryGetValue(configuration.Alt, out semCtx);
if ( semCtx != null )
{
// resolve (first found) with pred
// and remove alt from problem list
//System.out.println("c="+configuration);
-                        configuration.resolveWithPredicate = true;
+                        configuration.ResolveWithPredicate = true;
// altToPredMap has preds from all alts; store into "annointed" config
-                        configuration.semanticContext = semCtx; // reset to combined
-                        altToPredMap.Remove( configuration.alt );
+                        configuration.SemanticContext = semCtx; // reset to combined
+                        altToPredMap.Remove( configuration.Alt );

// notify grammar that we've used the preds contained in semCtx
if ( semCtx.IsSyntacticPredicate )
{
-                            _dfa.nfa.grammar.SynPredUsedInDFA( _dfa, semCtx );
+                            _dfa.Nfa.Grammar.SynPredUsedInDFA( _dfa, semCtx );
}
}
-                    else if ( nondeterministicAlts.Contains( configuration.alt ) )
+                    else if ( nondeterministicAlts.Contains( configuration.Alt ) )
{
// resolve all configurations for nondeterministic alts
// for which there is no predicate context by turning it off
-                        configuration.resolved = true;
+                        configuration.Resolved = true;
}
}
return true;
@@ -1628,21 +1628,21 @@ namespace Antlr3.Analysis
//JSystem.@out.println("configs="+d.nfaConfigurations);
//JSystem.@out.println("configs with preds?"+d.atLeastOneConfigurationHasAPredicate);
//JSystem.@out.println("configs with preds="+d.configurationsWithPredicateEdges);
-            int numConfigs = d.nfaConfigurations.Count;
+            int numConfigs = d.NfaConfigurations.Count;
for ( int i = 0; i < numConfigs; i++ )
{
-                NFAConfiguration configuration = (NFAConfiguration)d.nfaConfigurations[i];
-                int altI = configuration.alt;
+                NFAConfiguration configuration = d.NfaConfigurations[i];
+                int altI = configuration.Alt;
// if alt is nondeterministic, combine its predicates
if ( nondeterministicAlts.Contains( altI ) )
{
// if there is a predicate for this NFA configuration, OR in
-                    if ( configuration.semanticContext !=
+                    if ( configuration.SemanticContext !=
SemanticContext.EmptySemanticContext )
{
OrderedHashSet<SemanticContext> predSet;
altToSetOfContextsMap.TryGetValue(altI, out predSet);
-                        predSet.Add( configuration.semanticContext );
+                        predSet.Add( configuration.SemanticContext );
}
else
{
@@ -1714,12 +1714,12 @@ namespace Antlr3.Analysis
*/
for ( int i = 0; i < numConfigs; i++ )
{
-                    NFAConfiguration configuration = (NFAConfiguration)d.nfaConfigurations[i];
-                    int altI = configuration.alt;
+                    NFAConfiguration configuration = d.NfaConfigurations[i];
+                    int altI = configuration.Alt;
if ( incompletelyCoveredAlts.Contains( altI ) &&
-                         configuration.semanticContext == SemanticContext.EmptySemanticContext )
+                         configuration.SemanticContext == SemanticContext.EmptySemanticContext )
{
-                        NFAState s = _dfa.nfa.GetState( configuration.state );
+                        NFAState s = _dfa.Nfa.GetState( configuration.State );
/*
JSystem.@out.print("nondet config w/o context "+configuration+
" incident "+(s.incidentEdgeLabel!=null?s.incidentEdgeLabel.toString(dfa.nfa.grammar):null));
@@ -1750,7 +1750,7 @@ namespace Antlr3.Analysis
}
}
}
-                _dfa.probe.ReportIncompletelyCoveredAlts( d,
+                _dfa.Probe.ReportIncompletelyCoveredAlts( d,
altToLocationsReachableWithoutPredicate );
}

@@ -1782,9 +1782,9 @@ namespace Antlr3.Analysis
{
public virtual int Compare( NFAConfiguration ca, NFAConfiguration cb )
{
-                if ( ca.alt < cb.alt )
+                if ( ca.Alt < cb.Alt )
return -1;
-                else if ( ca.alt > cb.alt )
+                else if ( ca.Alt > cb.Alt )
return 1;
return 0;
}
@@ -1803,11 +1803,11 @@ namespace Antlr3.Analysis
{
List<NFAConfiguration> configsWithPreds = new List<NFAConfiguration>();
// get a list of all configs with predicates
-            int numConfigs = d.nfaConfigurations.Count;
+            int numConfigs = d.NfaConfigurations.Count;
for ( int i = 0; i < numConfigs; i++ )
{
-                NFAConfiguration c = (NFAConfiguration)d.nfaConfigurations[i];
-                if ( c.resolveWithPredicate )
+                NFAConfiguration c = d.NfaConfigurations[i];
+                if ( c.ResolveWithPredicate )
{
configsWithPreds.Add( c );
}
@@ -1819,18 +1819,18 @@ namespace Antlr3.Analysis
// Now, we can add edges emanating from d for these preds in right order
for ( int i = 0; i < predConfigsSortedByAlt.Count; i++ )
{
-                NFAConfiguration c = (NFAConfiguration)predConfigsSortedByAlt[i];
-                DFAState predDFATarget = d.dfa.GetAcceptState( c.alt );
+                NFAConfiguration c = predConfigsSortedByAlt[i];
+                DFAState predDFATarget = d.Dfa.GetAcceptState( c.Alt );
if ( predDFATarget == null )
{
predDFATarget = _dfa.NewState(); // create if not there.
// create a new DFA state that is a target of the predicate from d
-                    predDFATarget.AddNFAConfiguration( _dfa.nfa.GetState( c.state ),
-                                                      c.alt,
-                                                      c.context,
-                                                      c.semanticContext );
+                    predDFATarget.AddNFAConfiguration( _dfa.Nfa.GetState( c.State ),
+                                                      c.Alt,
+                                                      c.Context,
+                                                      c.SemanticContext );
predDFATarget.IsAcceptState = true;
-                    _dfa.SetAcceptState( c.alt, predDFATarget );
+                    _dfa.SetAcceptState( c.Alt, predDFATarget );
DFAState existingState = _dfa.AddState( predDFATarget );
if ( predDFATarget != existingState )
{
@@ -1842,7 +1842,7 @@ namespace Antlr3.Analysis
}
}
// add a transition to pred target from d
-                d.AddTransition( predDFATarget, new PredicateLabel( c.semanticContext ) );
+                d.AddTransition( predDFATarget, new PredicateLabel( c.SemanticContext ) );
}
}

diff --git a/Antlr3/Analysis/PredicateLabel.cs b/Antlr3/Analysis/PredicateLabel.cs
index 40c6930..20f8829 100644
--- a/Antlr3/Analysis/PredicateLabel.cs
+++ b/Antlr3/Analysis/PredicateLabel.cs
@@ -1,10 +1,10 @@
﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -42,7 +42,7 @@ namespace Antlr3.Analysis
*  may have to combine a bunch of them as it collects predicates from
*  multiple NFA configurations into a single DFA state.
*/
-        SemanticContext _semanticContext;
+        private readonly SemanticContext _semanticContext;

/** Make a semantic predicate label */
public PredicateLabel( GrammarAST predicateASTNode )
diff --git a/Antlr3/Analysis/Reachable.cs b/Antlr3/Analysis/Reachable.cs
new file mode 100644
index 0000000..f488376
--- /dev/null
+++ b/Antlr3/Analysis/Reachable.cs
@@ -0,0 +1,42 @@
+﻿/*
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Analysis
+{
+    public enum Reachable
+    {
+        Unknown = -2,
+        Busy = -1, // in process of computing
+        No = 0,
+        Yes = 1,
+    }
+}
diff --git a/Antlr3/Analysis/RuleClosureTransition.cs b/Antlr3/Analysis/RuleClosureTransition.cs
index db31504..85f644a 100644
--- a/Antlr3/Analysis/RuleClosureTransition.cs
+++ b/Antlr3/Analysis/RuleClosureTransition.cs
@@ -43,19 +43,34 @@ namespace Antlr3.Analysis
public class RuleClosureTransition : Transition
{
/** Ptr to the rule definition object for this rule ref */
-        public Rule rule;
+        private readonly Rule _rule;

/** What node to begin computations following ref to rule */
-        public NFAState followState;
+        private readonly NFAState _followState;

public RuleClosureTransition( Rule rule,
NFAState ruleStart,
NFAState followState )
: base( Label.EPSILON, ruleStart )
{
-            this.rule = rule;
-            this.followState = followState;
+            this._rule = rule;
+            this._followState = followState;
+        }
+
+        public Rule Rule
+        {
+            get
+            {
+                return _rule;
+            }
}
-    }

+        public NFAState FollowState
+        {
+            get
+            {
+                return _followState;
+            }
+        }
+    }
}
diff --git a/Antlr3/Analysis/SemanticContext.cs b/Antlr3/Analysis/SemanticContext.cs
index ff19a03..0fee07b 100644
--- a/Antlr3/Analysis/SemanticContext.cs
+++ b/Antlr3/Analysis/SemanticContext.cs
@@ -254,7 +254,7 @@ namespace Antlr3.Analysis
else
{
eST = templates.GetInstanceOf("evalPredicate");
-                        generator.grammar.decisionsWhoseDFAsUsesSemPreds.Add(dfa);
+                        generator.Grammar.decisionsWhoseDFAsUsesSemPreds.Add(dfa);
}

string predEnclosingRuleName = _predicateAST.enclosingRuleName;
@@ -280,7 +280,7 @@ namespace Antlr3.Analysis

if (generator != null)
{
-                    string description = generator.target.GetTargetStringLiteralFromString(this.ToString());
+                    string description = generator.Target.GetTargetStringLiteralFromString(this.ToString());
eST.SetAttribute("description", description);
}

diff --git a/Antlr3/Analysis/State.cs b/Antlr3/Analysis/State.cs
index 18f5c7d..9185588 100644
--- a/Antlr3/Analysis/State.cs
+++ b/Antlr3/Analysis/State.cs
@@ -42,7 +42,7 @@ namespace Antlr3.Analysis
/** An accept state is an end of rule state for lexers and
*  parser grammar rules.
*/
-        protected internal bool acceptState = false;
+        private bool acceptState = false;

public virtual bool IsAcceptState
{
diff --git a/Antlr3/Analysis/StateCluster.cs b/Antlr3/Analysis/StateCluster.cs
index bf5d723..07908ac 100644
--- a/Antlr3/Analysis/StateCluster.cs
+++ b/Antlr3/Analysis/StateCluster.cs
@@ -38,14 +38,39 @@ namespace Antlr3.Analysis
*/
public class StateCluster
{
-        public NFAState left;
-        public NFAState right;
+        private NFAState _left;
+        private NFAState _right;

public StateCluster( NFAState left, NFAState right )
{
-            this.left = left;
-            this.right = right;
+            this._left = left;
+            this._right = right;
+        }
+
+        public NFAState Left
+        {
+            get
+            {
+                return _left;
+            }
+
+            set
+            {
+                _left = value;
+            }
}
-    }

+        public NFAState Right
+        {
+            get
+            {
+                return _right;
+            }
+
+            set
+            {
+                _right = value;
+            }
+        }
+    }
}
diff --git a/Antlr3/Analysis/Transition.cs b/Antlr3/Analysis/Transition.cs
index 6a78a7c..c885421 100644
--- a/Antlr3/Analysis/Transition.cs
+++ b/Antlr3/Analysis/Transition.cs
@@ -65,6 +65,9 @@ namespace Antlr3.Analysis
this.target = target;
}

+        /// <summary>
+        /// Gets or sets the label which must be consumed to transition to target
+        /// </summary>
public Label Label
{
get
@@ -78,6 +81,9 @@ namespace Antlr3.Analysis
}
}

+        /// <summary>
+        /// Gets the target state
+        /// </summary>
public State Target
{
get
@@ -86,7 +92,9 @@ namespace Antlr3.Analysis
}
}

-
+        /// <summary>
+        /// Gets whether or not the transition is an action
+        /// </summary>
public bool IsAction
{
get
@@ -95,6 +103,9 @@ namespace Antlr3.Analysis
}
}

+        /// <summary>
+        /// Gets whether or not the transition is an epsilon-transition
+        /// </summary>
public bool IsEpsilon
{
get
@@ -103,6 +114,9 @@ namespace Antlr3.Analysis
}
}

+        /// <summary>
+        /// Gets whether or not the transition is a semantic predicate transition
+        /// </summary>
public bool IsSemanticPredicate
{
get
diff --git a/Antlr3/Antlr3.csproj b/Antlr3/Antlr3.csproj
index c124b52..04ceb85 100644
--- a/Antlr3/Antlr3.csproj
+++ b/Antlr3/Antlr3.csproj
@@ -54,6 +54,7 @@
<Compile Include="Analysis\ActionLabel.cs" />
<Compile Include="Analysis\AnalysisRecursionOverflowException.cs" />
<Compile Include="Analysis\AnalysisTimeoutException.cs" />
+    <Compile Include="Analysis\Cyclic.cs" />
<Compile Include="Analysis\DecisionProbe.cs" />
<Compile Include="Analysis\DFA.cs" />
<Compile Include="Analysis\DFAOptimizer.cs" />
@@ -70,6 +71,7 @@
<Compile Include="Analysis\NFAtoDFAConverter.cs" />
<Compile Include="Analysis\NonLLStarDecisionException.cs" />
<Compile Include="Analysis\PredicateLabel.cs" />
+    <Compile Include="Analysis\Reachable.cs" />
<Compile Include="Analysis\RuleClosureTransition.cs" />
<Compile Include="Analysis\SemanticContext.cs" />
<Compile Include="Analysis\State.cs" />
diff --git a/Antlr3/AntlrTool.cs b/Antlr3/AntlrTool.cs
index 8602f42..14f516f 100644
--- a/Antlr3/AntlrTool.cs
+++ b/Antlr3/AntlrTool.cs
@@ -620,7 +620,7 @@ namespace Antlr3
{
StringReader sr = new StringReader( lexerGrammarStr );
Grammar lexerGrammar = new Grammar(this);
-                            lexerGrammar.composite.watchNFAConversion = internalOption_watchNFAConversion;
+                            lexerGrammar.composite.WatchNFAConversion = internalOption_watchNFAConversion;
lexerGrammar.implicitLexer = true;
if ( TestMode )
lexerGrammar.DefaultRuleModifier = "public";
@@ -749,7 +749,7 @@ namespace Antlr3

StringReader reader = new StringReader( System.IO.File.ReadAllText( f ) );
grammar.ParseAndBuildAST( reader );
-            composite.watchNFAConversion = internalOption_watchNFAConversion;
+            composite.WatchNFAConversion = internalOption_watchNFAConversion;
return grammar;
}

@@ -818,7 +818,7 @@ namespace Antlr3
generator = new DOTGenerator(g);
}

-                string graph = generator.GenerateGraph( dfa.startState );
+                string graph = generator.GenerateGraph( dfa.StartState );
string graphFileName = g.name + "." + "dec-" + d;
if ( g.implicitLexer )
{
diff --git a/Antlr3/Codegen/ACyclicDFACodeGenerator.cs b/Antlr3/Codegen/ACyclicDFACodeGenerator.cs
index 5d1c2a9..f69ec5f 100644
--- a/Antlr3/Codegen/ACyclicDFACodeGenerator.cs
+++ b/Antlr3/Codegen/ACyclicDFACodeGenerator.cs
@@ -42,17 +42,17 @@ namespace Antlr3.Codegen

public class ACyclicDFACodeGenerator
{
-        protected CodeGenerator parentGenerator;
+        private readonly CodeGenerator _parentGenerator;

public ACyclicDFACodeGenerator( CodeGenerator parent )
{
-            this.parentGenerator = parent;
+            this._parentGenerator = parent;
}

public virtual StringTemplate GenFixedLookaheadDecision( TemplateGroup templates,
DFA dfa )
{
-            return WalkFixedDFAGeneratingStateMachine( templates, dfa, dfa.startState, 1 );
+            return WalkFixedDFAGeneratingStateMachine( templates, dfa, dfa.StartState, 1 );
}

protected virtual StringTemplate WalkFixedDFAGeneratingStateMachine(
@@ -75,7 +75,7 @@ namespace Antlr3.Codegen
string dfaLoopbackStateName = "dfaLoopbackState";
string dfaOptionalBlockStateName = "dfaOptionalBlockState";
string dfaEdgeName = "dfaEdge";
-            if ( parentGenerator.CanGenerateSwitch( s ) )
+            if ( _parentGenerator.CanGenerateSwitch( s ) )
{
dfaStateName = "dfaStateSwitch";
dfaLoopbackStateName = "dfaLoopbackStateSwitch";
@@ -110,7 +110,7 @@ namespace Antlr3.Codegen
//System.Console.Out.WriteLine( "DFA state " + s.stateNumber );
for ( int i = 0; i < s.NumberOfTransitions; i++ )
{
-                Transition edge = (Transition)s.Transition( i );
+                Transition edge = (Transition)s.GetTransition( i );
//System.Console.Out.WriteLine( "edge " + s.stateNumber + "-" + edge.label.ToString() + "->" + edge.target.stateNumber );
if ( edge.Label.Atom == Label.EOT )
{
@@ -129,13 +129,13 @@ namespace Antlr3.Codegen
// If the template wants all the label values delineated, do that
if ( edgeST.impl.TryGetFormalArgument( "labels" ) != null )
{
-                    List<string> labels = edge.Label.Set.Select( value => parentGenerator.GetTokenTypeAsTargetLabel( value ) ).ToList();
+                    List<string> labels = edge.Label.Set.Select( value => _parentGenerator.GetTokenTypeAsTargetLabel( value ) ).ToList();
edgeST.SetAttribute( "labels", labels );
}
else
{ // else create an expression to evaluate (the general case)
edgeST.SetAttribute( "labelExpr",
-                                        parentGenerator.GenLabelExpr( templates, edge, k ) );
+                                        _parentGenerator.GenLabelExpr( templates, edge, k ) );
}

// stick in any gated predicates for any edge if not already a pred
@@ -147,8 +147,8 @@ namespace Antlr3.Codegen
if ( preds != null )
{
//System.Console.Out.WriteLine( "preds=" + target.getGatedPredicatesInNFAConfigurations() );
-                        StringTemplate predST = preds.GenExpr( parentGenerator,
-                                                              parentGenerator.Templates,
+                        StringTemplate predST = preds.GenExpr( _parentGenerator,
+                                                              _parentGenerator.Templates,
dfa );
edgeST.SetAttribute( "predicates", predST );
}
@@ -182,10 +182,10 @@ namespace Antlr3.Codegen
// hoisted up to the state that has the EOT edge.
for ( int i = 0; i < EOTTarget.NumberOfTransitions; i++ )
{
-                    Transition predEdge = (Transition)EOTTarget.Transition( i );
+                    Transition predEdge = (Transition)EOTTarget.GetTransition( i );
StringTemplate edgeST = templates.GetInstanceOf( dfaEdgeName );
edgeST.SetAttribute( "labelExpr",
-                                        parentGenerator.GenSemanticPredicateExpr( templates, predEdge ) );
+                                        _parentGenerator.GenSemanticPredicateExpr( templates, predEdge ) );
// the target must be an accept state
//System.Console.Out.WriteLine( "EOT edge" );
StringTemplate targetST =
diff --git a/Antlr3/Codegen/CodeGenerator.cs b/Antlr3/Codegen/CodeGenerator.cs
index 184c63d..92b8b15 100644
--- a/Antlr3/Codegen/CodeGenerator.cs
+++ b/Antlr3/Codegen/CodeGenerator.cs
@@ -127,53 +127,54 @@ namespace Antlr3.Codegen
/** Which grammar are we generating code for?  Each generator
*  is attached to a specific grammar.
*/
-        public Grammar grammar;
+        private readonly Grammar _grammar;

/** What language are we generating? */
-        protected string language;
+        private readonly string _language;

/** The target specifies how to write out files and do other language
*  specific actions.
*/
-        public Target target = null;
-        static readonly Dictionary<string, Target> _targets = new Dictionary<string, Target>();
+        private readonly Target _target;
+
+        private static readonly Dictionary<string, Target> _targets = new Dictionary<string, Target>();

/** Where are the templates this generator should use to generate code? */
-        protected TemplateGroup templates;
+        private TemplateGroup _templates;

/** The basic output templates without AST or templates stuff; this will be
*  the templates loaded for the language such as Java.stg *and* the Dbg
*  stuff if turned on.  This is used for generating syntactic predicates.
*/
-        protected TemplateGroup baseTemplates;
+        private TemplateGroup baseTemplates;

-        protected StringTemplate recognizerST;
-        protected StringTemplate outputFileST;
-        protected StringTemplate headerFileST;
+        private StringTemplate recognizerST;
+        private StringTemplate outputFileST;
+        private StringTemplate headerFileST;

/** Used to create unique labels */
-        protected int uniqueLabelNumber = 1;
+        private int uniqueLabelNumber = 1;

/** A reference to the ANTLR tool so we can learn about output directories
*  and such.
*/
-        protected readonly AntlrTool tool;
+        private readonly AntlrTool tool;

/** Generate debugging event method calls */
-        protected bool debug;
+        private bool debug;

/** Create a Tracer object and make the recognizer invoke this. */
-        protected bool trace;
+        private bool trace;

/** Track runtime parsing information about decisions etc...
*  This requires the debugging event mechanism to work.
*/
-        protected bool profile;
+        private bool profile;

-        protected int lineWidth = 72;
+        private int lineWidth = 72;

/** I have factored out the generation of acyclic DFAs to separate class */
-        public ACyclicDFACodeGenerator acyclicDFAGenerator;
+        private readonly ACyclicDFACodeGenerator _acyclicDFAGenerator;

/** I have factored out the generation of cyclic DFAs to separate class */
/*
@@ -183,7 +184,7 @@ namespace Antlr3.Codegen

public static readonly string VocabFileExtension = ".tokens";

-        protected const string vocabFilePattern =
+        private const string vocabFilePattern =
"<tokens:{it|<it.name>=<it.type>\n}>" +
"<literals:{it|<it.name>=<it.type>\n}>";

@@ -193,16 +194,40 @@ namespace Antlr3.Codegen
throw new ArgumentNullException("tool");

this.tool = tool;
-            this.grammar = grammar;
-            this.language = language;
+            this._grammar = grammar;
+            this._language = language;

-            acyclicDFAGenerator = new ACyclicDFACodeGenerator( this );
+            _acyclicDFAGenerator = new ACyclicDFACodeGenerator( this );

-            target = LoadLanguageTarget( language, tool.TargetsDirectory );
+            _target = LoadLanguageTarget( language, tool.TargetsDirectory );
}

#region Properties

+        public Grammar Grammar
+        {
+            get
+            {
+                return _grammar;
+            }
+        }
+
+        public string Language
+        {
+            get
+            {
+                return _language;
+            }
+        }
+
+        public Target Target
+        {
+            get
+            {
+                return _target;
+            }
+        }
+
[CLSCompliant(false)]
public TemplateGroup BaseTemplates
{
@@ -226,7 +251,7 @@ namespace Antlr3.Codegen
{
get
{
-                return templates;
+                return _templates;
}
}

@@ -338,8 +363,8 @@ namespace Antlr3.Codegen
/** load the main language.stg template group file */
public virtual void LoadTemplates( string language )
{
-            string outputOption = (string)this.grammar.GetOption("output") ?? string.Empty;
-            LoadTemplates(tool, language, grammar.type, outputOption, debug, out baseTemplates, out templates);
+            string outputOption = (string)this._grammar.GetOption("output") ?? string.Empty;
+            LoadTemplates(tool, language, _grammar.type, outputOption, debug, out baseTemplates, out _templates);
}

private static readonly Dictionary<string, TemplateGroup> _coreTemplates =
@@ -629,8 +654,8 @@ namespace Antlr3.Codegen
{
//JSystem.@out.println("### generate "+grammar.name+" recognizer");
// LOAD OUTPUT TEMPLATES
-            LoadTemplates( language );
-            if ( templates == null )
+            LoadTemplates( _language );
+            if ( _templates == null )
{
return null;
}
@@ -640,7 +665,7 @@ namespace Antlr3.Codegen
{
return null;
}
-            target.PerformGrammarAnalysis( this, grammar );
+            _target.PerformGrammarAnalysis( this, _grammar );


// some grammar analysis errors will not yield reliable DFA
@@ -650,30 +675,30 @@ namespace Antlr3.Codegen
}

// OPTIMIZE DFA
-            DFAOptimizer optimizer = new DFAOptimizer( grammar );
+            DFAOptimizer optimizer = new DFAOptimizer( _grammar );
optimizer.Optimize();

// OUTPUT FILE (contains recognizerST)
-            outputFileST = templates.GetInstanceOf( "outputFile" );
+            outputFileST = _templates.GetInstanceOf( "outputFile" );

// HEADER FILE
-            if ( templates.IsDefined( "headerFile" ) )
+            if ( _templates.IsDefined( "headerFile" ) )
{
-                headerFileST = templates.GetInstanceOf( "headerFile" );
+                headerFileST = _templates.GetInstanceOf( "headerFile" );
}
else
{
// create a dummy to avoid null-checks all over code generator
-                headerFileST = new StringTemplate( templates, string.Empty );
+                headerFileST = new StringTemplate( _templates, string.Empty );
// it normally sees this from outputFile
headerFileST.Add("cyclicDFAs", null);
headerFileST.impl.Name = "dummy-header-file";
}

-            bool filterMode = grammar.GetOption( "filter" ) != null &&
-                                  grammar.GetOption( "filter" ).Equals( "true" );
-            bool canBacktrack = grammar.composite.GetRootGrammar().atLeastOneBacktrackOption ||
-                                   grammar.SyntacticPredicates != null ||
+            bool filterMode = _grammar.GetOption( "filter" ) != null &&
+                                  _grammar.GetOption( "filter" ).Equals( "true" );
+            bool canBacktrack = _grammar.composite.RootGrammar.atLeastOneBacktrackOption ||
+                                   _grammar.SyntacticPredicates != null ||
filterMode;

// TODO: move this down further because generating the recognizer
@@ -683,42 +708,42 @@ namespace Antlr3.Codegen
// The only two possible output files are available at this point.
// Verify action scopes are ok for target and dump actions into output
// Templates can say <actions.parser.header> for example.
-            var actions = grammar.Actions;
+            var actions = _grammar.Actions;
VerifyActionScopesOkForTarget( actions );
// translate $x::y references
TranslateActionAttributeReferences( actions );
-            StringTemplate gateST = templates.GetInstanceOf( "actionGate" );
+            StringTemplate gateST = _templates.GetInstanceOf( "actionGate" );
if ( filterMode )
{
// if filtering, we need to set actions to execute at backtracking
// level 1 not 0.
-                gateST = templates.GetInstanceOf( "filteringActionGate" );
+                gateST = _templates.GetInstanceOf( "filteringActionGate" );
}
-            grammar.SetSynPredGateIfNotAlready( gateST );
+            _grammar.SetSynPredGateIfNotAlready( gateST );

headerFileST.SetAttribute( "actions", actions );
outputFileST.SetAttribute( "actions", actions );

-            headerFileST.SetAttribute( "buildTemplate", grammar.BuildTemplate );
-            outputFileST.SetAttribute( "buildTemplate", grammar.BuildTemplate );
-            headerFileST.SetAttribute( "buildAST", grammar.BuildAST );
-            outputFileST.SetAttribute( "buildAST", grammar.BuildAST );
+            headerFileST.SetAttribute( "buildTemplate", _grammar.BuildTemplate );
+            outputFileST.SetAttribute( "buildTemplate", _grammar.BuildTemplate );
+            headerFileST.SetAttribute( "buildAST", _grammar.BuildAST );
+            outputFileST.SetAttribute( "buildAST", _grammar.BuildAST );

-            outputFileST.SetAttribute( "rewriteMode", grammar.RewriteMode );
-            headerFileST.SetAttribute( "rewriteMode", grammar.RewriteMode );
+            outputFileST.SetAttribute( "rewriteMode", _grammar.RewriteMode );
+            headerFileST.SetAttribute( "rewriteMode", _grammar.RewriteMode );

outputFileST.SetAttribute( "backtracking", canBacktrack );
headerFileST.SetAttribute( "backtracking", canBacktrack );
// turn on memoize attribute at grammar level so we can create ruleMemo.
// each rule has memoize attr that hides this one, indicating whether
// it needs to save results
-            string memoize = (string)grammar.GetOption( "memoize" );
+            string memoize = (string)_grammar.GetOption( "memoize" );
outputFileST.SetAttribute( "memoize",
-                                      ( grammar.atLeastOneRuleMemoizes ||
+                                      ( _grammar.atLeastOneRuleMemoizes ||
( memoize != null && memoize.Equals( "true" ) ) &&
canBacktrack ) );
headerFileST.SetAttribute( "memoize",
-                                      ( grammar.atLeastOneRuleMemoizes ||
+                                      ( _grammar.atLeastOneRuleMemoizes ||
( memoize != null && memoize.Equals( "true" ) ) &&
canBacktrack ) );

@@ -730,23 +755,23 @@ namespace Antlr3.Codegen
headerFileST.SetAttribute( "profile", profile );

// RECOGNIZER
-            if ( grammar.type == GrammarType.Lexer )
+            if ( _grammar.type == GrammarType.Lexer )
{
-                recognizerST = templates.GetInstanceOf( "lexer" );
+                recognizerST = _templates.GetInstanceOf( "lexer" );
outputFileST.SetAttribute( "LEXER", true );
headerFileST.SetAttribute( "LEXER", true );
recognizerST.SetAttribute( "filterMode", filterMode );
}
-            else if ( grammar.type == GrammarType.Parser ||
-                grammar.type == GrammarType.Combined )
+            else if ( _grammar.type == GrammarType.Parser ||
+                _grammar.type == GrammarType.Combined )
{
-                recognizerST = templates.GetInstanceOf( "parser" );
+                recognizerST = _templates.GetInstanceOf( "parser" );
outputFileST.SetAttribute( "PARSER", true );
headerFileST.SetAttribute( "PARSER", true );
}
else
{
-                recognizerST = templates.GetInstanceOf( "treeParser" );
+                recognizerST = _templates.GetInstanceOf( "treeParser" );
outputFileST.SetAttribute( "TREE_PARSER", true );
headerFileST.SetAttribute( "TREE_PARSER", true );
recognizerST.SetAttribute( "filterMode", filterMode );
@@ -754,12 +779,12 @@ namespace Antlr3.Codegen
outputFileST.SetAttribute( "recognizer", recognizerST );
headerFileST.SetAttribute( "recognizer", recognizerST );
outputFileST.SetAttribute( "actionScope",
-                                      grammar.GetDefaultActionScope( grammar.type ) );
+                                      _grammar.GetDefaultActionScope( _grammar.type ) );
headerFileST.SetAttribute( "actionScope",
-                                      grammar.GetDefaultActionScope( grammar.type ) );
+                                      _grammar.GetDefaultActionScope( _grammar.type ) );

string targetAppropriateFileNameString =
-                target.GetTargetStringLiteralFromString( grammar.FileName );
+                _target.GetTargetStringLiteralFromString( _grammar.FileName );
outputFileST.SetAttribute( "fileName", targetAppropriateFileNameString );
headerFileST.SetAttribute( "fileName", targetAppropriateFileNameString );
outputFileST.SetAttribute( "ANTLRVersion", AntlrTool.AssemblyVersion.ToString(4) );
@@ -772,10 +797,10 @@ namespace Antlr3.Codegen
// Walk the AST holding the input grammar, this time generating code
// Decisions are generated by using the precomputed DFAs
// Fill in the various templates with data
-                CodeGenTreeWalker gen = new CodeGenTreeWalker( new Antlr.Runtime.Tree.CommonTreeNodeStream( grammar.Tree ) );
+                CodeGenTreeWalker gen = new CodeGenTreeWalker( new Antlr.Runtime.Tree.CommonTreeNodeStream( _grammar.Tree ) );
try
{
-                    gen.grammar_( grammar,
+                    gen.grammar_( _grammar,
recognizerST,
outputFileST,
headerFileST );
@@ -791,7 +816,7 @@ namespace Antlr3.Codegen
GenTokenTypeConstants( outputFileST );
GenTokenTypeConstants( headerFileST );

-            if ( grammar.type != GrammarType.Lexer )
+            if ( _grammar.type != GrammarType.Lexer )
{
GenTokenTypeNames( recognizerST );
GenTokenTypeNames( outputFileST );
@@ -800,31 +825,31 @@ namespace Antlr3.Codegen

// Now that we know what synpreds are used, we can set into template
HashSet<string> synpredNames = null;
-            if ( grammar.synPredNamesUsedInDFA.Count > 0 )
+            if ( _grammar.synPredNamesUsedInDFA.Count > 0 )
{
-                synpredNames = grammar.synPredNamesUsedInDFA;
+                synpredNames = _grammar.synPredNamesUsedInDFA;
}
outputFileST.SetAttribute( "synpreds", synpredNames );
headerFileST.SetAttribute( "synpreds", synpredNames );

// all recognizers can see Grammar object
-            recognizerST.SetAttribute( "grammar", grammar );
+            recognizerST.SetAttribute( "grammar", _grammar );

if (CodeGenerator.LaunchTemplateInspector)
{
outputFileST.Visualize();
-                if (templates.IsDefined("headerFile"))
+                if (_templates.IsDefined("headerFile"))
headerFileST.Visualize();
}

// WRITE FILES
try
{
-                target.GenRecognizerFile( tool, this, grammar, outputFileST );
-                if ( templates.IsDefined( "headerFile" ) )
+                _target.GenRecognizerFile( tool, this, _grammar, outputFileST );
+                if ( _templates.IsDefined( "headerFile" ) )
{
-                    StringTemplate extST = templates.GetInstanceOf( "headerFileExtension" );
-                    target.GenRecognizerHeaderFile( tool, this, grammar, headerFileST, extST.Render() );
+                    StringTemplate extST = _templates.GetInstanceOf( "headerFileExtension" );
+                    _target.GenRecognizerHeaderFile( tool, this, _grammar, headerFileST, extST.Render() );
}
// write out the vocab interchange file; used by antlr,
// does not change per target
@@ -859,15 +884,15 @@ namespace Antlr3.Codegen
foreach ( var action in actions )
{
string scope = action.Key;
-                if ( !target.IsValidActionScope( grammar.type, scope ) )
+                if ( !_target.IsValidActionScope( _grammar.type, scope ) )
{
// get any action from the scope to get error location
var scopeActions = action.Value;
GrammarAST actionAST = scopeActions.Values.Cast<GrammarAST>().First();
ErrorManager.GrammarError(
-                        ErrorManager.MSG_INVALID_ACTION_SCOPE, grammar,
+                        ErrorManager.MSG_INVALID_ACTION_SCOPE, _grammar,
actionAST.Token, scope,
-                        grammar.GrammarTypeString );
+                        _grammar.GrammarTypeString );
}
}
}
@@ -946,7 +971,7 @@ namespace Antlr3.Codegen
{
// compute follow for this element and, as side-effect, track
// the rule LOOK sensitivity.
-                follow = grammar.First( followingNFAState );
+                follow = _grammar.First( followingNFAState );
}

if ( follow == null )
@@ -965,23 +990,23 @@ namespace Antlr3.Codegen

IList<int> tokenTypeList = null;
ulong[] words = null;
-            if ( follow.tokenTypeSet == null )
+            if ( follow.TokenTypeSet == null )
{
words = new ulong[1];
tokenTypeList = new List<int>();
}
else
{
-                BitSet bits = BitSet.Of( follow.tokenTypeSet );
+                BitSet bits = BitSet.Of( follow.TokenTypeSet );
words = bits.ToPackedArray();
-                tokenTypeList = follow.tokenTypeSet.ToList();
+                tokenTypeList = follow.TokenTypeSet.ToList();
}
// use the target to convert to hex strings (typically)
string[] wordStrings = new string[words.Length];
for ( int j = 0; j < words.Length; j++ )
{
ulong w = words[j];
-                wordStrings[j] = target.GetTarget64BitStringFromValue( w );
+                wordStrings[j] = _target.GetTarget64BitStringFromValue( w );
}
recognizerST.SetAttribute( "bitsets.{name,inName,bits,tokenTypes,tokenIndex}",
referencedElementName,
@@ -1023,7 +1048,7 @@ namespace Antlr3.Codegen
if ( dfa.CanInlineDecision )
{
decisionST =
-                    acyclicDFAGenerator.GenFixedLookaheadDecision( Templates, dfa );
+                    _acyclicDFAGenerator.GenFixedLookaheadDecision( Templates, dfa );
}
else
{
@@ -1031,15 +1056,15 @@ namespace Antlr3.Codegen
dfa.CreateStateTables( this );
outputFileST.SetAttribute( "cyclicDFAs", dfa );
headerFileST.SetAttribute( "cyclicDFAs", dfa );
-                decisionST = templates.GetInstanceOf( "dfaDecision" );
+                decisionST = _templates.GetInstanceOf( "dfaDecision" );
string description = dfa.NFADecisionStartState.Description;
-                description = target.GetTargetStringLiteralFromString( description );
+                description = _target.GetTargetStringLiteralFromString( description );
if ( description != null )
{
decisionST.SetAttribute( "description", description );
}
decisionST.SetAttribute( "decisionNumber",
-                                        dfa.DecisionNumber );
+                                        dfa.NfaStartStateDecisionNumber );
}
return decisionST;
}
@@ -1053,30 +1078,30 @@ namespace Antlr3.Codegen
public virtual StringTemplate GenerateSpecialState( DFAState s )
{
StringTemplate stateST;
-            stateST = templates.GetInstanceOf( "cyclicDFAState" );
+            stateST = _templates.GetInstanceOf( "cyclicDFAState" );
stateST.SetAttribute( "needErrorClause", true );
stateST.SetAttribute( "semPredState", s.IsResolvedWithPredicates );
stateST.SetAttribute( "stateNumber", s.StateNumber );
-            stateST.SetAttribute( "decisionNumber", s.dfa.decisionNumber );
+            stateST.SetAttribute( "decisionNumber", s.Dfa.DecisionNumber );

bool foundGatedPred = false;
StringTemplate eotST = null;
for ( int i = 0; i < s.NumberOfTransitions; i++ )
{
-                Transition edge = (Transition)s.Transition( i );
+                Transition edge = (Transition)s.GetTransition( i );
StringTemplate edgeST;
if ( edge.Label.Atom == Label.EOT )
{
// this is the default clause; has to held until last
-                    edgeST = templates.GetInstanceOf( "eotDFAEdge" );
+                    edgeST = _templates.GetInstanceOf( "eotDFAEdge" );
stateST.RemoveAttribute( "needErrorClause" );
eotST = edgeST;
}
else
{
-                    edgeST = templates.GetInstanceOf( "cyclicDFAEdge" );
+                    edgeST = _templates.GetInstanceOf( "cyclicDFAEdge" );
StringTemplate exprST =
-                        GenLabelExpr( templates, edge, 1 );
+                        GenLabelExpr( _templates, edge, 1 );
edgeST.SetAttribute( "labelExpr", exprST );
}
edgeST.SetAttribute( "edgeNumber", i + 1 );
@@ -1092,7 +1117,7 @@ namespace Antlr3.Codegen
foundGatedPred = true;
StringTemplate predST = preds.GenExpr( this,
Templates,
-                                                              t.dfa );
+                                                              t.Dfa );
edgeST.SetAttribute( "predicates", predST.Render() );
}
}
@@ -1139,7 +1164,7 @@ namespace Antlr3.Codegen
protected internal virtual StringTemplate GenSemanticPredicateExpr( TemplateGroup templates,
Transition edge )
{
-            DFA dfa = ( (DFAState)edge.Target ).dfa; // which DFA are we in
+            DFA dfa = ( (DFAState)edge.Target ).Dfa; // which DFA are we in
Label label = edge.Label;
SemanticContext semCtx = label.SemanticContext;
return semCtx.GenExpr( this, templates, dfa );
@@ -1210,7 +1235,7 @@ namespace Antlr3.Codegen
protected virtual void GenTokenTypeConstants( StringTemplate code )
{
// make constants for the token types
-            foreach (var token in grammar.composite.tokenIDToTypeMap.OrderBy(i => i.Value))
+            foreach (var token in _grammar.composite.TokenIDToTypeMap.OrderBy(i => i.Value))
{
if (token.Value == Label.EOF || token.Value >= Label.MIN_TOKEN_TYPE)
code.SetAttribute("tokens.{name,type}", token.Key, token.Value);
@@ -1222,12 +1247,12 @@ namespace Antlr3.Codegen
*/
protected virtual void GenTokenTypeNames( StringTemplate code )
{
-            for ( int t = Label.MIN_TOKEN_TYPE; t <= grammar.MaxTokenType; t++ )
+            for ( int t = Label.MIN_TOKEN_TYPE; t <= _grammar.MaxTokenType; t++ )
{
-                string tokenName = grammar.GetTokenDisplayName( t );
+                string tokenName = _grammar.GetTokenDisplayName( t );
if ( tokenName != null )
{
-                    tokenName = target.GetTargetStringLiteralFromString( tokenName, true );
+                    tokenName = _target.GetTargetStringLiteralFromString( tokenName, true );
code.SetAttribute( "tokenNames", tokenName );
}
}
@@ -1245,12 +1270,12 @@ namespace Antlr3.Codegen
*/
public virtual string GetTokenTypeAsTargetLabel( int ttype )
{
-            if ( grammar.type == GrammarType.Lexer )
+            if ( _grammar.type == GrammarType.Lexer )
{
-                string name = grammar.GetTokenDisplayName( ttype );
-                return target.GetTargetCharLiteralFromANTLRCharLiteral( this, name );
+                string name = _grammar.GetTokenDisplayName( ttype );
+                return _target.GetTargetCharLiteralFromANTLRCharLiteral( this, name );
}
-            return target.GetTokenTypeAsTargetLabel( this, ttype );
+            return _target.GetTokenTypeAsTargetLabel( this, ttype );
}

/** Generate a token vocab file with all the token names/types.  For example:
@@ -1268,9 +1293,9 @@ namespace Antlr3.Codegen
vocabFileST.Add("tokens", null);
vocabFileST.impl.Name = "vocab-file";
// make constants for the token names
-            foreach ( string tokenID in grammar.TokenIDs )
+            foreach ( string tokenID in _grammar.TokenIDs )
{
-                int tokenType = grammar.GetTokenType( tokenID );
+                int tokenType = _grammar.GetTokenType( tokenID );
if ( tokenType >= Label.MIN_TOKEN_TYPE )
{
vocabFileST.SetAttribute( "tokens.{name,type}", tokenID, tokenType );
@@ -1278,9 +1303,9 @@ namespace Antlr3.Codegen
}

// now dump the strings
-            foreach ( string literal in grammar.StringLiterals )
+            foreach ( string literal in _grammar.StringLiterals )
{
-                int tokenType = grammar.GetTokenType( literal );
+                int tokenType = _grammar.GetTokenType( literal );
if ( tokenType >= Label.MIN_TOKEN_TYPE )
{
vocabFileST.SetAttribute( "tokens.{name,type}", literal, tokenType );
@@ -1299,7 +1324,7 @@ namespace Antlr3.Codegen
}
ActionTranslator translator = new ActionTranslator( this, ruleName, actionTree );
IList<object> chunks = translator.TranslateToChunks();
-            chunks = target.PostProcessAction( chunks, actionTree.Token );
+            chunks = _target.PostProcessAction( chunks, actionTree.Token );
return chunks;
}

@@ -1325,8 +1350,8 @@ namespace Antlr3.Codegen
actionToken,
actionTree.outerAltNum );
IList<object> chunks = translator.TranslateToChunks();
-                    chunks = target.PostProcessAction( chunks, actionToken );
-                    StringTemplate catST = new StringTemplate( templates, "<chunks>" );
+                    chunks = _target.PostProcessAction( chunks, actionToken );
+                    StringTemplate catST = new StringTemplate( _templates, "<chunks>" );
catST.SetAttribute( "chunks", chunks );
translatedArgs.Add( catST );
}
@@ -1461,7 +1486,7 @@ namespace Antlr3.Codegen
// first, parse with antlr.g
//JSystem.@out.println("translate template: "+templateActionText);
ANTLRLexer lexer = new ANTLRLexer( new Antlr.Runtime.ANTLRStringStream( templateActionText ) );
-                lexer.Filename = grammar.FileName;
+                lexer.Filename = _grammar.FileName;
//lexer.setTokenObjectClass( "antlr.TokenWithIndex" );
//TokenStreamRewriteEngine tokenBuffer = new TokenStreamRewriteEngine( lexer );
//tokenBuffer.discard( ANTLRParser.WS );
@@ -1469,7 +1494,7 @@ namespace Antlr3.Codegen
//tokenBuffer.discard( ANTLRParser.COMMENT );
//tokenBuffer.discard( ANTLRParser.SL_COMMENT );
ANTLRParser parser = new ANTLRParser( new Antlr.Runtime.CommonTokenStream( lexer ) );
-                parser.FileName = grammar.FileName;
+                parser.FileName = _grammar.FileName;
//parser.setASTNodeClass( "org.antlr.tool.GrammarAST" );
try
{
@@ -1479,7 +1504,7 @@ namespace Antlr3.Codegen
catch ( RecognitionException /*re*/ )
{
ErrorManager.GrammarError( ErrorManager.MSG_INVALID_TEMPLATE_ACTION,
-                                                  grammar,
+                                                  _grammar,
actionToken,
templateActionText );
}
@@ -1492,7 +1517,7 @@ namespace Antlr3.Codegen
{
// then translate via codegen.g
CodeGenTreeWalker gen = new CodeGenTreeWalker( new Antlr.Runtime.Tree.CommonTreeNodeStream( rewriteTree ) );
-                gen.Init( grammar );
+                gen.Init( _grammar );
gen.currentRuleName = ruleName;
gen.outerAltNum = outerAltNum;
StringTemplate st = null;
@@ -1517,8 +1542,8 @@ namespace Antlr3.Codegen
int outerAltNum )
{
//JSystem.@out.println("error $"+x+"::"+y);
-            Rule r = grammar.GetRule( x );
-            AttributeScope scope = grammar.GetGlobalScope( x );
+            Rule r = _grammar.GetRule( x );
+            AttributeScope scope = _grammar.GetGlobalScope( x );
if ( scope == null )
{
if ( r != null )
@@ -1529,14 +1554,14 @@ namespace Antlr3.Codegen
if ( scope == null )
{
ErrorManager.GrammarError( ErrorManager.MSG_UNKNOWN_DYNAMIC_SCOPE,
-                                              grammar,
+                                              _grammar,
actionToken,
x );
}
else if ( scope.GetAttribute( y ) == null )
{
ErrorManager.GrammarError( ErrorManager.MSG_UNKNOWN_DYNAMIC_SCOPE_ATTRIBUTE,
-                                              grammar,
+                                              _grammar,
actionToken,
x,
y );
@@ -1554,7 +1579,7 @@ namespace Antlr3.Codegen
{
// action not in a rule
ErrorManager.GrammarError( ErrorManager.MSG_ATTRIBUTE_REF_NOT_IN_RULE,
-                                              grammar,
+                                              _grammar,
actionToken,
x,
y );
@@ -1572,28 +1597,28 @@ namespace Antlr3.Codegen
{
refdRuleName = enclosingRule.GetRuleLabel( x ).referencedRuleName;
}
-                Rule refdRule = grammar.GetRule( refdRuleName );
+                Rule refdRule = _grammar.GetRule( refdRuleName );
AttributeScope scope = refdRule.GetAttributeScope( y );
if ( scope == null )
{
ErrorManager.GrammarError( ErrorManager.MSG_UNKNOWN_RULE_ATTRIBUTE,
-                                              grammar,
+                                              _grammar,
actionToken,
refdRuleName,
y );
}
-                else if ( scope.isParameterScope )
+                else if ( scope.IsParameterScope )
{
ErrorManager.GrammarError( ErrorManager.MSG_INVALID_RULE_PARAMETER_REF,
-                                              grammar,
+                                              _grammar,
actionToken,
refdRuleName,
y );
}
-                else if ( scope.isDynamicRuleScope )
+                else if ( scope.IsDynamicRuleScope )
{
ErrorManager.GrammarError( ErrorManager.MSG_INVALID_RULE_SCOPE_ATTRIBUTE_REF,
-                                              grammar,
+                                              _grammar,
actionToken,
refdRuleName,
y );
@@ -1612,7 +1637,7 @@ namespace Antlr3.Codegen
{
// action not in a rule
ErrorManager.GrammarError( ErrorManager.MSG_ATTRIBUTE_REF_NOT_IN_RULE,
-                                              grammar,
+                                              _grammar,
actionToken,
x );
return;
@@ -1627,21 +1652,21 @@ namespace Antlr3.Codegen
enclosingRule.Name.Equals( x ) )
{
ErrorManager.GrammarError( ErrorManager.MSG_ISOLATED_RULE_SCOPE,
-                                              grammar,
+                                              _grammar,
actionToken,
x );
}
-            else if ( scope != null && scope.isDynamicRuleScope )
+            else if ( scope != null && scope.IsDynamicRuleScope )
{
ErrorManager.GrammarError( ErrorManager.MSG_ISOLATED_RULE_ATTRIBUTE,
-                                              grammar,
+                                              _grammar,
actionToken,
x );
}
else
{
ErrorManager.GrammarError( ErrorManager.MSG_UNKNOWN_SIMPLE_ATTRIBUTE,
-                                          grammar,
+                                          _grammar,
actionToken,
x );
}
@@ -1654,8 +1679,8 @@ namespace Antlr3.Codegen
*/
public virtual string GetRecognizerFileName( string name, GrammarType type )
{
-            StringTemplate extST = templates.GetInstanceOf( "codeFileExtension" );
-            string recognizerName = grammar.GetRecognizerName();
+            StringTemplate extST = _templates.GetInstanceOf( "codeFileExtension" );
+            string recognizerName = _grammar.GetRecognizerName();
return recognizerName + extST.Render();
/*
String suffix = "";
@@ -1673,19 +1698,19 @@ namespace Antlr3.Codegen
*/
public virtual string GetVocabFileName()
{
-            if ( grammar.IsBuiltFromString )
+            if ( _grammar.IsBuiltFromString )
{
return null;
}
-            return grammar.name + VocabFileExtension;
+            return _grammar.name + VocabFileExtension;
}

public virtual void Write( StringTemplate code, string fileName )
{
Stopwatch watch = Stopwatch.StartNew();
-            TextWriter w = tool.GetOutputFile( grammar, fileName );
+            TextWriter w = tool.GetOutputFile( _grammar, fileName );
// Write the output to a StringWriter
-            ITemplateWriter wr = templates.GetStringTemplateWriter( w );
+            ITemplateWriter wr = _templates.GetStringTemplateWriter( w );
wr.LineWidth = lineWidth;
code.Write( wr );
w.Close();
@@ -1708,7 +1733,7 @@ namespace Antlr3.Codegen
int size = 0;
for ( int i = 0; i < s.NumberOfTransitions; i++ )
{
-                Transition edge = (Transition)s.Transition( i );
+                Transition edge = (Transition)s.GetTransition( i );
if ( edge.Label.IsSemanticPredicate )
{
return false;
diff --git a/Antlr3/Codegen/Target.cs b/Antlr3/Codegen/Target.cs
index 2a1361b..e4bb9ca 100644
--- a/Antlr3/Codegen/Target.cs
+++ b/Antlr3/Codegen/Target.cs
@@ -127,51 +127,51 @@ namespace Antlr3.Codegen
*  moment so targets can add template actions w/o having to recompile
*  ANTLR.
*/
-        public virtual bool IsValidActionScope( GrammarType grammarType, string scope )
+        public virtual bool IsValidActionScope(GrammarType grammarType, string scope)
{
-            switch ( grammarType )
+            switch (grammarType)
{
case GrammarType.Lexer:
-                if ( scope.Equals( "lexer" ) )
-                {
+                if (scope.Equals("lexer"))
return true;
-                }
+
break;
+
case GrammarType.Parser:
-                if ( scope.Equals( "parser" ) )
-                {
+                if (scope.Equals("parser"))
return true;
-                }
+
break;
+
case GrammarType.Combined:
-                if ( scope.Equals( "parser" ) )
-                {
+                if (scope.Equals("parser"))
return true;
-                }
-                if ( scope.Equals( "lexer" ) )
-                {
+
+                if (scope.Equals("lexer"))
return true;
-                }
+
break;
+
case GrammarType.TreeParser:
-                if ( scope.Equals( "treeparser" ) )
-                {
+                if (scope.Equals("treeparser"))
return true;
-                }
+
break;
}
+
return false;
}

/** Target must be able to override the labels used for token types */
public virtual string GetTokenTypeAsTargetLabel( CodeGenerator generator, int ttype )
{
-            string name = generator.grammar.GetTokenDisplayName( ttype );
+            string name = generator.Grammar.GetTokenDisplayName( ttype );
// If name is a literal, return the token type instead
if ( name[0] == '\'' )
{
-                return ttype.ToString(); //String.valueOf( ttype );
+                return ttype.ToString();
}
+
return name;
}

@@ -195,6 +195,7 @@ namespace Antlr3.Codegen
{
return "'\u0000'";
}
+
if ( c < targetCharValueEscape.Length &&
targetCharValueEscape[c] != null )
{
@@ -334,11 +335,13 @@ namespace Antlr3.Codegen
{
return null;
}
+
StringBuilder buf = new StringBuilder();
if ( quoted )
{
buf.Append( '"' );
}
+
for ( int i = 0; i < s.Length; i++ )
{
int c = s[i];
@@ -353,10 +356,12 @@ namespace Antlr3.Codegen
buf.Append( (char)c );
}
}
+
if ( quoted )
{
buf.Append( '"' );
}
+
return buf.ToString();
}

@@ -383,6 +388,7 @@ namespace Antlr3.Codegen
{
buf.Append( '0' );
}
+
buf.Append( digits );
return buf.ToString();
}
@@ -403,6 +409,7 @@ namespace Antlr3.Codegen
value /= 8;
index--;
}
+
return builder.ToString().Trim();
}

@@ -412,6 +419,7 @@ namespace Antlr3.Codegen
{
return "\\" + ToOctalString( v );
}
+
//String hex = Integer.toHexString( v | 0x10000 ).substring( 1, 5 );
string hex = v.ToString( "x4" );
return "\\u" + hex;
@@ -432,7 +440,5 @@ namespace Antlr3.Codegen
{
return chunks;
}
-
}
-
}
diff --git a/Antlr3/Grammars/ActionAnalysisLexerHelper.cs b/Antlr3/Grammars/ActionAnalysisLexerHelper.cs
index e08f252..d852301 100644
--- a/Antlr3/Grammars/ActionAnalysisLexerHelper.cs
+++ b/Antlr3/Grammars/ActionAnalysisLexerHelper.cs
@@ -94,7 +94,7 @@ namespace Antlr3.Grammars
}
}

-            if (scope != null && (scope.isPredefinedRuleScope || scope.isPredefinedLexerRuleScope))
+            if (scope != null && (scope.IsPredefinedRuleScope || scope.IsPredefinedLexerRuleScope))
{
grammar.ReferenceRuleLabelPredefinedAttribute(refdRuleName);
//System.Console.WriteLine("referenceRuleLabelPredefinedAttribute for " + refdRuleName);
@@ -110,7 +110,7 @@ namespace Antlr3.Grammars
private void HandleAttributeReference(string attributeName)
{
AttributeScope scope = enclosingRule.GetLocalAttributeScope(attributeName);
-            if (scope != null && (scope.isPredefinedRuleScope || scope.isPredefinedLexerRuleScope))
+            if (scope != null && (scope.IsPredefinedRuleScope || scope.IsPredefinedLexerRuleScope))
{
grammar.ReferenceRuleLabelPredefinedAttribute(enclosingRule.Name);
//System.Console.WriteLine("referenceRuleLabelPredefinedAttribute for " + attributeName);
diff --git a/Antlr3/Grammars/ActionTranslatorHelper.cs b/Antlr3/Grammars/ActionTranslatorHelper.cs
index d5b42f8..74d2825 100644
--- a/Antlr3/Grammars/ActionTranslatorHelper.cs
+++ b/Antlr3/Grammars/ActionTranslatorHelper.cs
@@ -65,7 +65,7 @@ namespace Antlr3.Grammars
: this(new ANTLRStringStream(actionAST.Token.Text))
{
this.generator = generator;
-            this.grammar = generator.grammar;
+            this.grammar = generator.Grammar;
this.enclosingRule = grammar.GetLocallyDefinedRule(ruleName);
this.actionToken = actionAST.Token;
this.outerAltNum = actionAST.outerAltNum;
@@ -78,7 +78,7 @@ namespace Antlr3.Grammars
: this(new ANTLRStringStream(actionToken.Text))
{
this.generator = generator;
-            grammar = generator.grammar;
+            grammar = generator.Grammar;
this.enclosingRule = grammar.GetRule(ruleName);
this.actionToken = actionToken;
this.outerAltNum = outerAltNum;
@@ -170,7 +170,7 @@ namespace Antlr3.Grammars
{
Rule r = grammar.GetRule(ruleName);
AttributeScope scope = r.GetLocalAttributeScope(attrName);
-            if (scope != null && !scope.isParameterScope)
+            if (scope != null && !scope.IsParameterScope)
{
return scope.GetAttribute(attrName);
}
@@ -209,7 +209,7 @@ namespace Antlr3.Grammars
{
StringTemplate st = null;
AttributeScope scope = enclosingRule.GetLocalAttributeScope(y);
-            if (scope.isPredefinedRuleScope)
+            if (scope.IsPredefinedRuleScope)
{
if (y.Equals("st") || y.Equals("tree"))
{
@@ -224,12 +224,12 @@ namespace Antlr3.Grammars
ErrorManager.GrammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR, grammar, actionToken, x, y);
}
}
-            else if (scope.isPredefinedLexerRuleScope)
+            else if (scope.IsPredefinedLexerRuleScope)
{
// this is a better message to emit than the previous one...
ErrorManager.GrammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR, grammar, actionToken, x, y);
}
-            else if (scope.isParameterScope)
+            else if (scope.IsParameterScope)
{
st = Template("parameterSetAttributeRef");
st.SetAttribute("attr", scope.GetAttribute(y));
@@ -260,19 +260,19 @@ namespace Antlr3.Grammars

StringTemplate st = null;
AttributeScope scope = enclosingRule.GetLocalAttributeScope(y);
-            if (scope.isPredefinedRuleScope)
+            if (scope.IsPredefinedRuleScope)
{
st = Template("rulePropertyRef_" + y);
grammar.ReferenceRuleLabelPredefinedAttribute(x);
st.SetAttribute("scope", x);
st.SetAttribute("attr", y);
}
-            else if (scope.isPredefinedLexerRuleScope)
+            else if (scope.IsPredefinedLexerRuleScope)
{
// perhaps not the most precise error message to use, but...
ErrorManager.GrammarError(ErrorManager.MSG_RULE_HAS_NO_ARGS, grammar, actionToken, x);
}
-            else if (scope.isParameterScope)
+            else if (scope.IsParameterScope)
{
st = Template("parameterAttributeRef");
st.SetAttribute("attr", scope.GetAttribute(y));
@@ -381,21 +381,21 @@ namespace Antlr3.Grammars
StringTemplate st;
Rule refdRule = grammar.GetRule(refdRuleName);
AttributeScope scope = refdRule.GetLocalAttributeScope(y);
-            if (scope.isPredefinedRuleScope)
+            if (scope.IsPredefinedRuleScope)
{
st = Template("ruleLabelPropertyRef_" + y);
grammar.ReferenceRuleLabelPredefinedAttribute(refdRuleName);
st.SetAttribute("scope", label);
st.SetAttribute("attr", y);
}
-            else if (scope.isPredefinedLexerRuleScope)
+            else if (scope.IsPredefinedLexerRuleScope)
{
st = Template("lexerRuleLabelPropertyRef_" + y);
grammar.ReferenceRuleLabelPredefinedAttribute(refdRuleName);
st.SetAttribute("scope", label);
st.SetAttribute("attr", y);
}
-            else if (scope.isParameterScope)
+            else if (scope.IsParameterScope)
{
// TODO: error!
}
@@ -481,14 +481,14 @@ namespace Antlr3.Grammars
{
return enclosingRule != null
&& enclosingRule.GetLocalAttributeScope(attributeName) != null
-                && !enclosingRule.GetLocalAttributeScope(attributeName).isPredefinedLexerRuleScope;
+                && !enclosingRule.GetLocalAttributeScope(attributeName).IsPredefinedLexerRuleScope;
}

private void HandleSetLocalAttribute(string attributeName, string expr)
{
StringTemplate st;
AttributeScope scope = enclosingRule.GetLocalAttributeScope(attributeName);
-            if (scope.isPredefinedRuleScope)
+            if (scope.IsPredefinedRuleScope)
{
if (attributeName.Equals("tree") || attributeName.Equals("st"))
{
@@ -503,7 +503,7 @@ namespace Antlr3.Grammars
ErrorManager.GrammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR, grammar, actionToken, attributeName, "");
}
}
-            else if (scope.isParameterScope)
+            else if (scope.IsParameterScope)
{
st = Template("parameterSetAttributeRef");
st.SetAttribute("attr", scope.GetAttribute(attributeName));
@@ -528,20 +528,20 @@ namespace Antlr3.Grammars
{
StringTemplate st;
AttributeScope scope = enclosingRule.GetLocalAttributeScope(name);
-            if (scope.isPredefinedRuleScope)
+            if (scope.IsPredefinedRuleScope)
{
st = Template("rulePropertyRef_" + name);
grammar.ReferenceRuleLabelPredefinedAttribute(enclosingRule.Name);
st.SetAttribute("scope", enclosingRule.Name);
st.SetAttribute("attr", name);
}
-            else if (scope.isPredefinedLexerRuleScope)
+            else if (scope.IsPredefinedLexerRuleScope)
{
st = Template("lexerRulePropertyRef_" + name);
st.SetAttribute("scope", enclosingRule.Name);
st.SetAttribute("attr", name);
}
-            else if (scope.isParameterScope)
+            else if (scope.IsParameterScope)
{
st = Template("parameterAttributeRef");
st.SetAttribute("attr", scope.GetAttribute(name));
diff --git a/Antlr3/Grammars/CodeGenTreeWalker.g3 b/Antlr3/Grammars/CodeGenTreeWalker.g3
index 7f9c3ae..4ed408b 100644
--- a/Antlr3/Grammars/CodeGenTreeWalker.g3
+++ b/Antlr3/Grammars/CodeGenTreeWalker.g3
@@ -207,7 +207,7 @@ rule returns [StringTemplate code=null]
grammar.GrammarTreeToString((GrammarAST)$start.GetFirstChildWithType(BLOCK),
false);
description =
-					generator.target.GetTargetStringLiteralFromString(description);
+					generator.Target.GetTargetStringLiteralFromString(description);
$b.code.SetAttribute("description", description);
// do not generate lexer rules in combined grammar
string stName = null;
@@ -268,7 +268,7 @@ rule returns [StringTemplate code=null]
else
{
description = grammar.GrammarTreeToString($start,false);
-					description = generator.target.GetTargetStringLiteralFromString(description);
+					description = generator.Target.GetTargetStringLiteralFromString(description);
$code.SetAttribute("description", description);
}
Rule theRule = grammar.GetRule(currentRuleName);
@@ -318,7 +318,7 @@ options { k=1; }
$code = templates.GetInstanceOf($blockTemplateName);
decision = generator.GenLookaheadDecision(recognizerST,$dfa);
$code.SetAttribute("decision", decision);
-			$code.SetAttribute("decisionNumber", $dfa.DecisionNumber);
+			$code.SetAttribute("decisionNumber", $dfa.NfaStartStateDecisionNumber);
$code.SetAttribute("maxK",$dfa.MaxLookaheadDepth);
$code.SetAttribute("maxAlt",$dfa.NumberOfAlts);
}
@@ -460,7 +460,7 @@ alternative returns [StringTemplate code]
currentAltHasASTRewrite = r.HasRewrite(outerAltNum);
}
string description = grammar.GrammarTreeToString($start, false);
-		description = generator.target.GetTargetStringLiteralFromString(description);
+		description = generator.Target.GetTargetStringLiteralFromString(description);
$code.SetAttribute("description", description);
$code.SetAttribute("treeLevel", rewriteTreeNestingLevel);
if ( !currentAltHasASTRewrite && grammar.BuildAST )
@@ -512,8 +512,8 @@ options { k=1; }
|	^(CHAR_RANGE a=CHAR_LITERAL b=CHAR_LITERAL)
{
$code = templates.GetInstanceOf("charRangeRef");
-			string low = generator.target.GetTargetCharLiteralFromANTLRCharLiteral(generator,$a.text);
-			string high = generator.target.GetTargetCharLiteralFromANTLRCharLiteral(generator,$b.text);
+			string low = generator.Target.GetTargetCharLiteralFromANTLRCharLiteral(generator,$a.text);
+			string high = generator.Target.GetTargetCharLiteralFromANTLRCharLiteral(generator,$b.text);
$code.SetAttribute("a", low);
$code.SetAttribute("b", high);
if ( label!=null )
@@ -538,7 +538,7 @@ options { k=1; }
{
$code = templates.GetInstanceOf("validateSemanticPredicate");
$code.SetAttribute("pred", generator.TranslateAction(currentRuleName,$sp));
-			string description = generator.target.GetTargetStringLiteralFromString($sp.text);
+			string description = generator.Target.GetTargetStringLiteralFromString($sp.text);
$code.SetAttribute("description", description);
}

@@ -649,7 +649,7 @@ ebnf returns [StringTemplate code=null]
)
{
string description = grammar.GrammarTreeToString($start, false);
-			description = generator.target.GetTargetStringLiteralFromString(description);
+			description = generator.Target.GetTargetStringLiteralFromString(description);
$code.SetAttribute("description", description);
}
;
@@ -769,9 +769,9 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
// defining grammar is not a delegate, scope all the
// back to root, which has delegate methods for all
// rules.  Don't use scope if we are root.
-					if ( this.grammar != rdef.Grammar.composite.delegateGrammarTreeRoot.grammar ) {
+					if ( this.grammar != rdef.Grammar.composite.DelegateGrammarTreeRoot.Grammar ) {
$code.SetAttribute("scope",
-										  rdef.Grammar.composite.delegateGrammarTreeRoot.grammar);
+										  rdef.Grammar.composite.DelegateGrammarTreeRoot.Grammar);
}
}
}
@@ -861,7 +861,7 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
{
$code = templates.GetInstanceOf("charRef");
$code.SetAttribute("char",
-				   generator.target.GetTargetCharLiteralFromANTLRCharLiteral(generator,$c.text));
+				   generator.Target.GetTargetCharLiteralFromANTLRCharLiteral(generator,$c.text));
if ( label!=null )
{
$code.SetAttribute("label", labelText);
@@ -887,7 +887,7 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
{
$code = templates.GetInstanceOf("lexerStringRef");
$code.SetAttribute("string",
-					generator.target.GetTargetStringLiteralFromANTLRStringLiteral(generator,$s.text));
+					generator.Target.GetTargetStringLiteralFromANTLRStringLiteral(generator,$s.text));
$code.SetAttribute("elementIndex", i);
if ( label!=null )
{
@@ -966,7 +966,7 @@ rewrite returns [StringTemplate code=null]
{
if ( $start.Type==REWRITES )
{
-			if ( generator.grammar.BuildTemplate )
+			if ( generator.Grammar.BuildTemplate )
{
$code = templates.GetInstanceOf("rewriteTemplate");
}
@@ -1023,7 +1023,7 @@ rewrite returns [StringTemplate code=null]
}
string description =
grammar.GrammarTreeToString($r,false);
-					description = generator.target.GetTargetStringLiteralFromString(description);
+					description = generator.Target.GetTargetStringLiteralFromString(description);
$code.SetAttribute("alts.{pred,alt,description}",
predChunks,
alt,
@@ -1064,7 +1064,7 @@ rewrite_block[string blockTemplateName] returns [StringTemplate code=null]
finally { rewriteBlockNestingLevel--; currentBlockST = save_currentBlockST; }

rewrite_alternative returns [StringTemplate code=null]
-	:	{generator.grammar.BuildAST}?
+	:	{generator.Grammar.BuildAST}?
^(	a=ALT {$code=templates.GetInstanceOf("rewriteElementList");}
(	(
el=rewrite_element
@@ -1086,7 +1086,7 @@ rewrite_alternative returns [StringTemplate code=null]
EOA
)

-	|	{generator.grammar.BuildTemplate}? rewrite_template
+	|	{generator.Grammar.BuildTemplate}? rewrite_template
{ $code = $rewrite_template.code; }

|	// reproduce same input (only AST at moment)
@@ -1112,21 +1112,21 @@ rewrite_ebnf returns [StringTemplate code=null]
{ $code = $rewrite_block.code; }
{
string description = grammar.GrammarTreeToString($start, false);
-			description = generator.target.GetTargetStringLiteralFromString(description);
+			description = generator.Target.GetTargetStringLiteralFromString(description);
$code.SetAttribute("description", description);
}
|	^( CLOSURE rewrite_block["rewriteClosureBlock"] )
{ $code = $rewrite_block.code; }
{
string description = grammar.GrammarTreeToString($start, false);
-			description = generator.target.GetTargetStringLiteralFromString(description);
+			description = generator.Target.GetTargetStringLiteralFromString(description);
$code.SetAttribute("description", description);
}
|	^( POSITIVE_CLOSURE rewrite_block["rewritePositiveClosureBlock"] )
{ $code = $rewrite_block.code; }
{
string description = grammar.GrammarTreeToString($start, false);
-			description = generator.target.GetTargetStringLiteralFromString(description);
+			description = generator.Target.GetTargetStringLiteralFromString(description);
$code.SetAttribute("description", description);
}
;
@@ -1164,7 +1164,7 @@ rewrite_tree returns [StringTemplate code]
)
{
string description = grammar.GrammarTreeToString($start, false);
-			description = generator.target.GetTargetStringLiteralFromString(description);
+			description = generator.Target.GetTargetStringLiteralFromString(description);
$code.SetAttribute("description", description);
}
;
@@ -1358,14 +1358,14 @@ rewrite_template returns [StringTemplate code=null]
{
string sl = $DOUBLE_QUOTE_STRING_LITERAL.text;
string t = sl.Substring( 1, sl.Length - 2 ); // strip quotes
-					t = generator.target.GetTargetStringLiteralFromString(t);
+					t = generator.Target.GetTargetStringLiteralFromString(t);
$code.SetAttribute("template",t);
}
|	DOUBLE_ANGLE_STRING_LITERAL
{
string sl = $DOUBLE_ANGLE_STRING_LITERAL.text;
string t = sl.Substring( 2, sl.Length - 4 ); // strip double angle quotes
-					t = generator.target.GetTargetStringLiteralFromString(t);
+					t = generator.Target.GetTargetStringLiteralFromString(t);
$code.SetAttribute("template",t);
}
)?
diff --git a/Antlr3/Grammars/DefineGrammarItemsWalker.g3 b/Antlr3/Grammars/DefineGrammarItemsWalker.g3
index 71dbbf3..5fef3bf 100644
--- a/Antlr3/Grammars/DefineGrammarItemsWalker.g3
+++ b/Antlr3/Grammars/DefineGrammarItemsWalker.g3
@@ -77,7 +77,7 @@ scope AttributeScopeActions;
:	^( 'scope' name=ID attrScopeAction* attrs=ACTION )
{
AttributeScope scope = grammar.DefineGlobalScope($name.text,$attrs.Token);
-			scope.isDynamicGlobalScope = true;
+			scope.IsDynamicGlobalScope = true;
scope.AddAttributes($attrs.text, ';');
foreach ( var action in $AttributeScopeActions::actions )
scope.DefineNamedAction( action.Key, action.Value );
@@ -240,7 +240,7 @@ scope AttributeScopeActions;
(	attrScopeAction* attrs=ACTION
{
r.RuleScope = grammar.CreateRuleScope(r.Name,$attrs.Token);
-					r.RuleScope.isDynamicRuleScope = true;
+					r.RuleScope.IsDynamicRuleScope = true;
r.RuleScope.AddAttributes($attrs.text, ';');
foreach ( var action in $AttributeScopeActions::actions )
r.RuleScope.DefineNamedAction( action.Key, action.Value );
diff --git a/Antlr3/Grammars/TreeToNFAConverter.g3 b/Antlr3/Grammars/TreeToNFAConverter.g3
index 7b0b91b..d9e477e 100644
--- a/Antlr3/Grammars/TreeToNFAConverter.g3
+++ b/Antlr3/Grammars/TreeToNFAConverter.g3
@@ -114,21 +114,21 @@ rule
Rule thisR = grammar.GetLocallyDefinedRule(currentRuleName);
NFAState start = thisR.StartState;
start.associatedASTNode = $id;
-					start.AddTransition(new Transition(Label.EPSILON, g.left));
+					start.AddTransition(new Transition(Label.EPSILON, g.Left));

// track decision if > 1 alts
-					if ( grammar.GetNumberOfAltsForDecisionNFA(g.left)>1 )
+					if ( grammar.GetNumberOfAltsForDecisionNFA(g.Left)>1 )
{
-						g.left.Description = grammar.GrammarTreeToString($start,false);
-						g.left.SetDecisionASTNode($b.start);
-						int d = grammar.AssignDecisionNumber( g.left );
-						grammar.SetDecisionNFA( d, g.left );
+						g.Left.Description = grammar.GrammarTreeToString($start,false);
+						g.Left.SetDecisionASTNode($b.start);
+						int d = grammar.AssignDecisionNumber( g.Left );
+						grammar.SetDecisionNFA( d, g.Left );
grammar.SetDecisionBlockAST(d, $b.start);
}

// hook to end of rule node
NFAState end = thisR.StopState;
-					g.right.AddTransition(new Transition(Label.EPSILON,end));
+					g.Right.AddTransition(new Transition(Label.EPSILON,end));
}
}
)
@@ -259,12 +259,12 @@ ebnf returns [StateCluster g=null]
|	b=block
{
// track decision if > 1 alts
-			if ( grammar.GetNumberOfAltsForDecisionNFA($b.g.left)>1 )
+			if ( grammar.GetNumberOfAltsForDecisionNFA($b.g.Left)>1 )
{
-				$b.g.left.Description = grammar.GrammarTreeToString(blk,false);
-				$b.g.left.SetDecisionASTNode(blk);
-				int d = grammar.AssignDecisionNumber( $b.g.left );
-				grammar.SetDecisionNFA( d, $b.g.left );
+				$b.g.Left.Description = grammar.GrammarTreeToString(blk,false);
+				$b.g.Left.SetDecisionASTNode(blk);
+				int d = grammar.AssignDecisionNumber( $b.g.Left );
+				grammar.SetDecisionNFA( d, $b.g.Left );
grammar.SetDecisionBlockAST(d, blk);
}
$g = $b.g;
@@ -279,12 +279,12 @@ ebnf returns [StateCluster g=null]
bg = factory.BuildAlternativeBlockFromSet(bg);
}
$g = factory.BuildAoptional(bg);
-			$g.left.Description = grammar.GrammarTreeToString($start,false);
+			$g.Left.Description = grammar.GrammarTreeToString($start,false);
// there is always at least one alt even if block has just 1 alt
-			int d = grammar.AssignDecisionNumber( $g.left );
-			grammar.SetDecisionNFA(d, $g.left);
+			int d = grammar.AssignDecisionNumber( $g.Left );
+			grammar.SetDecisionNFA(d, $g.Left);
grammar.SetDecisionBlockAST(d, blk);
-			$g.left.SetDecisionASTNode($start);
+			$g.Left.SetDecisionASTNode($start);
}
|	^( CLOSURE b=block )
{
@@ -295,17 +295,17 @@ ebnf returns [StateCluster g=null]
}
$g = factory.BuildAstar(bg);
// track the loop back / exit decision point
-			bg.right.Description = "()* loopback of "+grammar.GrammarTreeToString($start,false);
-			int d = grammar.AssignDecisionNumber( bg.right );
-			grammar.SetDecisionNFA(d, bg.right);
+			bg.Right.Description = "()* loopback of "+grammar.GrammarTreeToString($start,false);
+			int d = grammar.AssignDecisionNumber( bg.Right );
+			grammar.SetDecisionNFA(d, bg.Right);
grammar.SetDecisionBlockAST(d, blk);
-			bg.right.SetDecisionASTNode(eob);
+			bg.Right.SetDecisionASTNode(eob);
// make block entry state also have same decision for interpreting grammar
-			NFAState altBlockState = (NFAState)$g.left.GetTransition(0).Target;
+			NFAState altBlockState = (NFAState)$g.Left.GetTransition(0).Target;
altBlockState.SetDecisionASTNode($start);
altBlockState.DecisionNumber = d;
-			$g.left.DecisionNumber = d; // this is the bypass decision (2 alts)
-			$g.left.SetDecisionASTNode($start);
+			$g.Left.DecisionNumber = d; // this is the bypass decision (2 alts)
+			$g.Left.SetDecisionASTNode($start);
}
|	^( POSITIVE_CLOSURE b=block )
{
@@ -317,13 +317,13 @@ ebnf returns [StateCluster g=null]
$g = factory.BuildAplus(bg);
// don't make a decision on left edge, can reuse loop end decision
// track the loop back / exit decision point
-			bg.right.Description = "()+ loopback of "+grammar.GrammarTreeToString($start,false);
-			int d = grammar.AssignDecisionNumber( bg.right );
-			grammar.SetDecisionNFA(d, bg.right);
+			bg.Right.Description = "()+ loopback of "+grammar.GrammarTreeToString($start,false);
+			int d = grammar.AssignDecisionNumber( bg.Right );
+			grammar.SetDecisionNFA(d, bg.Right);
grammar.SetDecisionBlockAST(d, blk);
-			bg.right.SetDecisionASTNode(eob);
+			bg.Right.SetDecisionASTNode(eob);
// make block entry state also have same decision for interpreting grammar
-			NFAState altBlockState = (NFAState)$g.left.GetTransition(0).Target;
+			NFAState altBlockState = (NFAState)$g.Left.GetTransition(0).Target;
altBlockState.SetDecisionASTNode($start);
altBlockState.DecisionNumber = d;
}
@@ -339,16 +339,16 @@ tree_ returns [StateCluster g=null]
{
down = factory.BuildAtom(Label.DOWN, $e.start);
// TODO set following states for imaginary nodes?
-				//el.followingNFAState = down.right;
+				//el.followingNFAState = down.Right;
$g = factory.BuildAB($g,down);
}
( e=element {$g = factory.BuildAB($g,$e.g);} )*
{
up = factory.BuildAtom(Label.UP, $e.start);
-				//el.followingNFAState = up.right;
+				//el.followingNFAState = up.Right;
$g = factory.BuildAB($g,up);
// tree roots point at right edge of DOWN for LOOK computation later
-				$start.NFATreeDownState = down.left;
+				$start.NFATreeDownState = down.Left;
}
)
;
@@ -433,7 +433,7 @@ atom_or_notatom returns [StateCluster g=null]
$g=factory.BuildSet(s,$n);
}
)
-			{$n.followingNFAState = $g.right;}
+			{$n.followingNFAState = $g.Right;}
)
;

@@ -445,12 +445,12 @@ atom[string scopeName] returns [StateCluster g=null]
{
Rule rr = grammar.GetRule(scopeName,$r.text);
$g = factory.BuildRuleRef(rr, start);
-				r.followingNFAState = $g.right;
-				r._nfaStartState = $g.left;
-				if ( $g.left.GetTransition(0) is RuleClosureTransition
+				r.followingNFAState = $g.Right;
+				r._nfaStartState = $g.Left;
+				if ( $g.Left.GetTransition(0) is RuleClosureTransition
&& grammar.type!=GrammarType.Lexer )
{
-					AddFollowTransition($r.text, $g.right);
+					AddFollowTransition($r.text, $g.Right);
}
// else rule ref got inlined to a set
}
@@ -465,7 +465,7 @@ atom[string scopeName] returns [StateCluster g=null]
{
Rule rr = grammar.GetRule(scopeName,t.Text);
$g = factory.BuildRuleRef(rr, start);
-					t._nfaStartState = $g.left;
+					t._nfaStartState = $g.Left;
// don't add FOLLOW transitions in the lexer;
// only exact context should be used.
}
@@ -473,7 +473,7 @@ atom[string scopeName] returns [StateCluster g=null]
else
{
$g = factory.BuildAtom(t);
-				t.followingNFAState = $g.right;
+				t.followingNFAState = $g.Right;
}
}

@@ -486,7 +486,7 @@ atom[string scopeName] returns [StateCluster g=null]
else
{
$g = factory.BuildAtom(c);
-				c.followingNFAState = $g.right;
+				c.followingNFAState = $g.Right;
}
}

@@ -499,13 +499,13 @@ atom[string scopeName] returns [StateCluster g=null]
else
{
$g = factory.BuildAtom(s);
-				s.followingNFAState = $g.right;
+				s.followingNFAState = $g.Right;
}
}

|	^(	w=WILDCARD (as5=ast_suffix)? )
{
-				if ( nfa.grammar.type == GrammarType.TreeParser
+				if ( nfa.Grammar.type == GrammarType.TreeParser
&& (w.ChildIndex > 0 || w.Parent.GetChild(1).Type == EOA) )
{
$g = factory.BuildWildcardTree( $w );
@@ -537,7 +537,7 @@ set returns [StateCluster g=null]
)
{
$g = factory.BuildSet(elements,$b);
-		$b.followingNFAState = $g.right;
+		$b.followingNFAState = $g.Right;
$b.SetValue = elements; // track set value of this block
}
//{System.out.println("set elements="+elements.ToString(grammar));}
@@ -645,7 +645,7 @@ setElement[IIntSet elements]

|	gset=set
{
-			Transition setTrans = $gset.g.left.GetTransition(0);
+			Transition setTrans = $gset.g.Left.GetTransition(0);
elements.AddAll(setTrans.Label.Set);
}

diff --git a/Antlr3/Tool/AssignTokenTypesBehavior.cs b/Antlr3/Tool/AssignTokenTypesBehavior.cs
index 0b6a244..a04f033 100644
--- a/Antlr3/Tool/AssignTokenTypesBehavior.cs
+++ b/Antlr3/Tool/AssignTokenTypesBehavior.cs
@@ -44,25 +44,24 @@ namespace Antlr3.Tool
[CLSCompliant(false)]
public class AssignTokenTypesBehavior : AssignTokenTypesWalker
{
-        protected const int Unassigned = -1;
-        protected const int UnassignedInParserRule = -2;
+        private const int Unassigned = -1;
+        private const int UnassignedInParserRule = -2;

-        protected IDictionary<string, int> stringLiterals = new SortedList<string, int>(StringComparer.Ordinal);
-        [CLSCompliant(false)]
-        protected IDictionary<string, int> tokens = new SortedList<string, int>(StringComparer.Ordinal);
-        protected IDictionary<string, string> aliases = new SortedList<string, string>(StringComparer.Ordinal);
-        protected IDictionary<string, string> aliasesReverseIndex = new Dictionary<string, string>();
+        private readonly IDictionary<string, int> _stringLiterals = new SortedList<string, int>(StringComparer.Ordinal);
+        private readonly IDictionary<string, int> _tokens = new SortedList<string, int>(StringComparer.Ordinal);
+        private readonly IDictionary<string, string> _aliases = new SortedList<string, string>(StringComparer.Ordinal);
+        private readonly IDictionary<string, string> _aliasesReverseIndex = new Dictionary<string, string>();
+
+        /** Track actual lexer rule defs so we don't get repeated token defs in
+         *  generated lexer.
+         */
+        private readonly HashSet<string> tokenRuleDefs = new HashSet<string>();

public AssignTokenTypesBehavior()
: base(null)
{
}

-        /** Track actual lexer rule defs so we don't get repeated token defs in
-         *  generated lexer.
-         */
-        protected HashSet<string> tokenRuleDefs = new HashSet<string>();
-
protected override void Init( Grammar g )
{
this.grammar = g;
@@ -109,7 +108,7 @@ namespace Antlr3.Tool
Rule.GetRuleType(currentRuleName) == RuleType.Parser) &&
grammar.GetTokenType( t.Text ) == Label.INVALID )
{
-                stringLiterals[t.Text] = UnassignedInParserRule;
+                _stringLiterals[t.Text] = UnassignedInParserRule;
}
}

@@ -119,9 +118,9 @@ namespace Antlr3.Tool
// Might have ';'=4 in vocab import and SEMI=';'. Avoid
// setting to UNASSIGNED if we have loaded ';'/SEMI
if ( grammar.GetTokenType( t.Text ) == Label.INVALID &&
-                 !tokens.ContainsKey( t.Text ) )
+                 !_tokens.ContainsKey( t.Text ) )
{
-                tokens[t.Text] = Unassigned;
+                _tokens[t.Text] = Unassigned;
}
}

@@ -144,12 +143,12 @@ namespace Antlr3.Tool

// track all lexer rules so we can look for token refs w/o
// associated lexer rules.
-                grammar.composite.lexerRules.Add( t.Text );
+                grammar.composite.LexerRules.Add( t.Text );

int existing = grammar.GetTokenType( t.Text );
if ( existing == Label.INVALID )
{
-                    tokens[t.Text] = Unassigned;
+                    _tokens[t.Text] = Unassigned;
}
// look for "<TOKEN> : <literal> ;" pattern
// (can have optional action last)
@@ -180,7 +179,7 @@ namespace Antlr3.Tool
string tokenID = t.Text;
string literal = s.Text;
string prevAliasLiteralID;
-            aliasesReverseIndex.TryGetValue(literal, out prevAliasLiteralID);
+            _aliasesReverseIndex.TryGetValue(literal, out prevAliasLiteralID);
if ( prevAliasLiteralID != null )
{ // we've seen this literal before
if ( tokenID.Equals( prevAliasLiteralID ) )
@@ -208,10 +207,10 @@ namespace Antlr3.Tool
{
// we've seen this before from a tokenVocab most likely
// don't assign a new token type; use existingLiteralType.
-                tokens[tokenID] = existingLiteralType;
+                _tokens[tokenID] = existingLiteralType;
}
string prevAliasTokenID;
-            aliases.TryGetValue(tokenID, out prevAliasTokenID);
+            _aliases.TryGetValue(tokenID, out prevAliasTokenID);
if ( prevAliasTokenID != null )
{
ErrorManager.GrammarError( ErrorManager.MSG_TOKEN_ALIAS_REASSIGNMENT,
@@ -221,8 +220,8 @@ namespace Antlr3.Tool
prevAliasTokenID );
return; // don't do the alias
}
-            aliases[tokenID] = literal;
-            aliasesReverseIndex[literal] = tokenID;
+            _aliases[tokenID] = literal;
+            _aliasesReverseIndex[literal] = tokenID;
}

protected internal override void DefineTokens( Grammar root )
@@ -269,10 +268,10 @@ namespace Antlr3.Tool
protected override void AssignStringTypes( Grammar root )
{
// walk string literals assigning types to unassigned ones
-            foreach ( var literal in stringLiterals.Where( pair => pair.Value < Label.MIN_TOKEN_TYPE ).ToArray() )
+            foreach ( var literal in _stringLiterals.Where( pair => pair.Value < Label.MIN_TOKEN_TYPE ).ToArray() )
{
int type = root.GetNewTokenType();
-                stringLiterals[literal.Key] = type;
+                _stringLiterals[literal.Key] = type;
// if string referenced in combined grammar parser rule,
// automatically define in the generated lexer
root.DefineLexerRuleForStringLiteral( literal.Key, type );
@@ -287,18 +286,18 @@ namespace Antlr3.Tool
}
// walk aliases if any and assign types to aliased literals if literal
// was referenced
-            foreach ( var alias in aliases )
+            foreach ( var alias in _aliases )
{
string tokenID = alias.Key;
string literal = alias.Value;
-                if ( literal[0] == '\'' && stringLiterals.ContainsKey( literal ) )
+                if ( literal[0] == '\'' && _stringLiterals.ContainsKey( literal ) )
{
int token;
-                    tokens.TryGetValue(tokenID, out token);
-                    stringLiterals[literal] = token;
+                    _tokens.TryGetValue(tokenID, out token);
+                    _stringLiterals[literal] = token;
// an alias still means you need a lexer rule for it
int typeI;
-                    tokens.TryGetValue(tokenID, out typeI);
+                    _tokens.TryGetValue(tokenID, out typeI);
if ( !tokenRuleDefs.Contains( tokenID ) )
{
root.DefineLexerRuleForAliasedStringLiteral( tokenID, literal, typeI );
@@ -310,20 +309,20 @@ namespace Antlr3.Tool
protected override void AssignTokenIDTypes( Grammar root )
{
// walk token names, assigning values if unassigned
-            foreach ( var token in tokens.Where( pair => pair.Value == Unassigned ).ToArray() )
+            foreach ( var token in _tokens.Where( pair => pair.Value == Unassigned ).ToArray() )
{
-                tokens[token.Key] = root.GetNewTokenType();
+                _tokens[token.Key] = root.GetNewTokenType();
}
}

protected override void DefineTokenNamesAndLiteralsInGrammar( Grammar root )
{
-            foreach ( var token in tokens )
+            foreach ( var token in _tokens )
{
root.DefineToken( token.Key, token.Value );
}

-            foreach ( var lit in stringLiterals )
+            foreach ( var lit in _stringLiterals )
{
root.DefineToken( lit.Key, lit.Value );
}
diff --git a/Antlr3/Tool/AttributeScope.cs b/Antlr3/Tool/AttributeScope.cs
index f3265b4..b3e4f04 100644
--- a/Antlr3/Tool/AttributeScope.cs
+++ b/Antlr3/Tool/AttributeScope.cs
@@ -35,7 +35,6 @@ namespace Antlr3.Tool
using System.Collections.Generic;
using System.Linq;

-    using CLSCompliant = System.CLSCompliantAttribute;
using CodeGenerator = Antlr3.Codegen.CodeGenerator;
using IToken = Antlr.Runtime.IToken;

@@ -47,12 +46,11 @@ namespace Antlr3.Tool
*/
public class AttributeScope
{
-
/** All token scopes (token labels) share the same fixed scope of
*  of predefined attributes.  I keep this out of the runtime.Token
*  object to avoid a runtime space burden.
*/
-        public static AttributeScope tokenScope = new AttributeScope( "Token", null );
+        public static readonly AttributeScope tokenScope = new AttributeScope( "Token", null );

static AttributeScope()
{
@@ -67,34 +65,34 @@ namespace Antlr3.Tool
}

/** This scope is associated with which input token (for error handling)? */
-        private readonly IToken derivedFromToken;
+        private readonly IToken _derivedFromToken;

-        private readonly Grammar grammar;
+        private readonly Grammar _grammar;

/** The scope name */
-        private readonly string name;
+        private readonly string _name;

/** Not a rule scope, but visible to all rules "scope symbols { ...}" */
-        public bool isDynamicGlobalScope;
+        private bool _isDynamicGlobalScope;

/** Visible to all rules, but defined in rule "scope { int i; }" */
-        public bool isDynamicRuleScope;
+        private bool _isDynamicRuleScope;

-        public bool isParameterScope;
+        private bool _isParameterScope;

-        public bool isReturnScope;
+        private bool _isReturnScope;

-        public bool isPredefinedRuleScope;
+        private bool _isPredefinedRuleScope;

-        public bool isPredefinedLexerRuleScope;
+        private bool _isPredefinedLexerRuleScope;

-        private readonly IDictionary<string, GrammarAST> actions = new Dictionary<string, GrammarAST>();
+        private readonly Dictionary<string, GrammarAST> _actions = new Dictionary<string, GrammarAST>();

/** The list of Attribute objects */

// until we have a list-ordered dictionary
//protected internal IDictionary<string, Attribute> attributes = new SortedList<string, Attribute>();
-        private readonly List<Attribute> attributes = new List<Attribute>();
+        private readonly List<Attribute> _attributes = new List<Attribute>();

public AttributeScope( string name, IToken derivedFromToken )
: this( null, name, derivedFromToken )
@@ -103,27 +101,104 @@ namespace Antlr3.Tool

public AttributeScope( Grammar grammar, string name, IToken derivedFromToken )
{
-            this.grammar = grammar;
-            this.name = name;
-            this.derivedFromToken = derivedFromToken;
+            this._grammar = grammar;
+            this._name = name;
+            this._derivedFromToken = derivedFromToken;
}

#region Properties

+        public bool IsDynamicGlobalScope
+        {
+            get
+            {
+                return _isDynamicGlobalScope;
+            }
+
+            set
+            {
+                _isDynamicGlobalScope = value;
+            }
+        }
+
+        public bool IsDynamicRuleScope
+        {
+            get
+            {
+                return _isDynamicRuleScope;
+            }
+
+            set
+            {
+                _isDynamicRuleScope = value;
+            }
+        }
+
+        public bool IsParameterScope
+        {
+            get
+            {
+                return _isParameterScope;
+            }
+
+            set
+            {
+                _isParameterScope = value;
+            }
+        }
+
+        public bool IsReturnScope
+        {
+            get
+            {
+                return _isReturnScope;
+            }
+
+            set
+            {
+                _isReturnScope = value;
+            }
+        }
+
+        public bool IsPredefinedRuleScope
+        {
+            get
+            {
+                return _isPredefinedRuleScope;
+            }
+
+            set
+            {
+                _isPredefinedRuleScope = value;
+            }
+        }
+
+        public bool IsPredefinedLexerRuleScope
+        {
+            get
+            {
+                return _isPredefinedLexerRuleScope;
+            }
+
+            set
+            {
+                _isPredefinedLexerRuleScope = value;
+            }
+        }
+
public IDictionary<string, GrammarAST> Actions
{
get
{
-                return actions;
+                return _actions;
}
}

-        [CLSCompliant(false)]
public IList<Attribute> Attributes
{
get
{
-                return attributes.AsReadOnly();
+                return _attributes.AsReadOnly();
}
}

@@ -131,7 +206,7 @@ namespace Antlr3.Tool
{
get
{
-                return attributes == null ? 0 : attributes.Count;
+                return _attributes == null ? 0 : _attributes.Count;
}
}

@@ -139,7 +214,7 @@ namespace Antlr3.Tool
{
get
{
-                return grammar;
+                return _grammar;
}
}

@@ -147,12 +222,12 @@ namespace Antlr3.Tool
{
get
{
-                if ( isParameterScope )
-                    return name + "_parameter";
-                else if ( isReturnScope )
-                    return name + "_return";
+                if ( IsParameterScope )
+                    return _name + "_parameter";
+                else if ( IsReturnScope )
+                    return _name + "_return";

-                return name;
+                return _name;
}
}

@@ -178,27 +253,27 @@ namespace Antlr3.Tool
foreach ( string a in attrs )
{
Attribute attr = new Attribute( a );
-                if ( !isReturnScope && attr.InitValue != null )
+                if ( !IsReturnScope && attr.InitValue != null )
{
ErrorManager.GrammarError( ErrorManager.MSG_ARG_INIT_VALUES_ILLEGAL,
-                                              grammar,
-                                              derivedFromToken,
+                                              _grammar,
+                                              _derivedFromToken,
attr.Name );
attr.InitValue = null; // wipe it out
}
-                for ( int i = 0; i <= attributes.Count; i++ )
+                for ( int i = 0; i <= _attributes.Count; i++ )
{
-                    if ( i < attributes.Count )
+                    if ( i < _attributes.Count )
{
-                        if ( attributes[i].Name == attr.Name )
+                        if ( _attributes[i].Name == attr.Name )
{
-                            attributes[i] = attr;
+                            _attributes[i] = attr;
break;
}
}
else
{
-                        attributes.Add( attr );
+                        _attributes.Add( attr );
// *must* break since the count changed
break;
//attributes.put( attr.Name, attr );
@@ -210,19 +285,19 @@ namespace Antlr3.Tool
public virtual void AddAttribute( string name, string decl )
{
Attribute attr = new Attribute( name, decl );
-            for ( int i = 0; i <= attributes.Count; i++ )
+            for ( int i = 0; i <= _attributes.Count; i++ )
{
-                if ( i < attributes.Count )
+                if ( i < _attributes.Count )
{
-                    if ( attributes[i].Name == attr.Name )
+                    if ( _attributes[i].Name == attr.Name )
{
-                        attributes[i] = attr;
+                        _attributes[i] = attr;
break;
}
}
else
{
-                    attributes.Add( attr );
+                    _attributes.Add( attr );
// *must* break since the count changed
break;
//attributes.put( name, new Attribute( name, decl ) );
@@ -240,7 +315,7 @@ namespace Antlr3.Tool
if ( Actions.TryGetValue( actionName, out a ) && a != null )
{
ErrorManager.GrammarError(
-                    ErrorManager.MSG_ACTION_REDEFINITION, grammar,
+                    ErrorManager.MSG_ACTION_REDEFINITION, _grammar,
nameAST.Token, nameAST.Text );
}
else
@@ -251,7 +326,7 @@ namespace Antlr3.Tool

public virtual Attribute GetAttribute( string name )
{
-            return attributes.FirstOrDefault( attr => attr.Name == name );
+            return _attributes.FirstOrDefault( attr => attr.Name == name );
}

/** Return the set of keys that collide from
@@ -264,7 +339,7 @@ namespace Antlr3.Tool
return null;
}
HashSet<object> inter = new HashSet<object>();
-            foreach ( Attribute attr in attributes )
+            foreach ( Attribute attr in _attributes )
{
string key = attr.Name;
if ( other.GetAttribute( key ) != null )
@@ -281,7 +356,7 @@ namespace Antlr3.Tool

public override string ToString()
{
-            return ( isDynamicGlobalScope ? "global " : "" ) + Name + ":" + attributes;
+            return ( IsDynamicGlobalScope ? "global " : "" ) + Name + ":" + _attributes;
}
}
}
diff --git a/Antlr3/Tool/BuildDependencyGenerator.cs b/Antlr3/Tool/BuildDependencyGenerator.cs
index 85eae6b..d0f7442 100644
--- a/Antlr3/Tool/BuildDependencyGenerator.cs
+++ b/Antlr3/Tool/BuildDependencyGenerator.cs
@@ -82,24 +82,24 @@ namespace Antlr3.Tool
*/
public class BuildDependencyGenerator
{
-        protected string grammarFileName;
-        protected string tokenVocab;
-        protected Tool tool;
-        protected Grammar grammar;
-        protected CodeGenerator generator;
-        protected TemplateGroup templates;
+        private readonly string grammarFileName;
+        private readonly Tool tool;
+        private readonly Grammar grammar;
+        private readonly CodeGenerator generator;
+        private string tokenVocab;
+        private TemplateGroup templates;

public BuildDependencyGenerator( Tool tool, string grammarFileName )
{
this.tool = tool;
this.grammarFileName = grammarFileName;
-            grammar = tool.GetRootGrammar( grammarFileName );
+            this.grammar = tool.GetRootGrammar( grammarFileName );
+
string language = (string)grammar.GetOption( "language" );
-            generator = new CodeGenerator( tool, grammar, language );
-            generator.LoadTemplates( language );
+            this.generator = new CodeGenerator( tool, grammar, language );
+            this.generator.LoadTemplates( language );
}

-        [CLSCompliant(false)]
public virtual string TokenVocab
{
get
@@ -108,7 +108,6 @@ namespace Antlr3.Tool
}
}

-        [CLSCompliant(false)]
public virtual CodeGenerator Generator
{
get
diff --git a/Antlr3/Tool/CompositeGrammar.cs b/Antlr3/Tool/CompositeGrammar.cs
index cb8dae8..eb3793e 100644
--- a/Antlr3/Tool/CompositeGrammar.cs
+++ b/Antlr3/Tool/CompositeGrammar.cs
@@ -58,15 +58,15 @@ namespace Antlr3.Tool
{
public const int MinRuleIndex = 1;

-        public CompositeGrammarTree delegateGrammarTreeRoot;
+        private CompositeGrammarTree delegateGrammarTreeRoot;

/** Used during getRuleReferenceClosure to detect computation cycles */
-        protected HashSet<NFAState> refClosureBusy = new HashSet<NFAState>();
+        private readonly HashSet<NFAState> refClosureBusy = new HashSet<NFAState>();

/** Used to assign state numbers; all grammars in composite share common
*  NFA space.  This NFA tracks state numbers number to state mapping.
*/
-        public int stateCounter = 0;
+        private int stateCounter = 0;

/** The NFA states in the NFA built from rules across grammars in composite.
*  Maps state number to NFAState object.
@@ -74,7 +74,7 @@ namespace Antlr3.Tool
*  this properly.  After talking to Josh Bloch, Collections guy at Sun,
*  I decided this was easiest solution.
*/
-        protected List<NFAState> numberToStateList = new List<NFAState>( 1000 );
+        private readonly List<NFAState> numberToStateList = new List<NFAState>( 1000 );

/** Token names and literal tokens like "void" are uniquely indexed.
*  with -1 implying EOF.  Characters are different; they go from
@@ -84,42 +84,43 @@ namespace Antlr3.Tool
*  like EPSILON. Char/String literals and token types overlap in the same
*  space, however.
*/
-        protected internal int maxTokenType = Label.MIN_TOKEN_TYPE - 1;
+        private int maxTokenType = Label.MIN_TOKEN_TYPE - 1;

/** Map token like ID (but not literals like "while") to its token type */
-        public IDictionary<string, int> tokenIDToTypeMap = new Dictionary<string, int>();
+        private readonly Dictionary<string, int> tokenIDToTypeMap = new Dictionary<string, int>();

/** Map token literals like "while" to its token type.  It may be that
*  WHILE="while"=35, in which case both tokenIDToTypeMap and this
*  field will have entries both mapped to 35.
*/
-        public IDictionary<string, int> stringLiteralToTypeMap = new Dictionary<string, int>();
+        private readonly Dictionary<string, int> stringLiteralToTypeMap = new Dictionary<string, int>();
+
/** Reverse index for stringLiteralToTypeMap */
-        public List<string> typeToStringLiteralList = new List<string>();
+        private readonly List<string> typeToStringLiteralList = new List<string>();

/** Map a token type to its token name.
*  Must subtract MIN_TOKEN_TYPE from index.
*/
-        public List<string> typeToTokenList = new List<string>();
+        private readonly List<string> typeToTokenList = new List<string>();

/** If combined or lexer grammar, track the rules.
* 	Track lexer rules so we can warn about undefined tokens.
*  This is combined set of lexer rules from all lexer grammars
*  seen in all imports.
*/
-        protected internal HashSet<string> lexerRules = new HashSet<string>();
+        private readonly HashSet<string> lexerRules = new HashSet<string>();

/** Rules are uniquely labeled from 1..n among all grammars */
-        protected internal int ruleIndex = MinRuleIndex;
+        private int ruleIndex = MinRuleIndex;

/** Map a rule index to its name; use a Vector on purpose as new
*  collections stuff won't let me setSize and make it grow.  :(
*  I need a specific guaranteed index, which the Collections stuff
*  won't let me have.
*/
-        protected internal List<Rule> ruleIndexToRuleList = new List<Rule>();
+        private readonly List<Rule> ruleIndexToRuleList = new List<Rule>();

-        public bool watchNFAConversion = false;
+        private bool watchNFAConversion = false;

protected virtual void InitTokenSymbolTables()
{
@@ -159,13 +160,121 @@ namespace Antlr3.Tool
}

#region Properties
+
+        public CompositeGrammarTree DelegateGrammarTreeRoot
+        {
+            get
+            {
+                return delegateGrammarTreeRoot;
+            }
+        }
+
public Grammar RootGrammar
{
get
{
-                return GetRootGrammar();
+                if (delegateGrammarTreeRoot == null)
+                    return null;
+
+                return delegateGrammarTreeRoot.Grammar;
+            }
+        }
+
+        public int StateCounter
+        {
+            get
+            {
+                return stateCounter;
+            }
+        }
+
+        public int MaxTokenType
+        {
+            get
+            {
+                return maxTokenType;
+            }
+
+            set
+            {
+                maxTokenType = value;
+            }
+        }
+
+        public IDictionary<string, int> TokenIDToTypeMap
+        {
+            get
+            {
+                return tokenIDToTypeMap;
+            }
+        }
+
+        public IDictionary<string, int> StringLiteralToTypeMap
+        {
+            get
+            {
+                return stringLiteralToTypeMap;
+            }
+        }
+
+        public List<string> TypeToStringLiteralList
+        {
+            get
+            {
+                return typeToStringLiteralList;
+            }
+        }
+
+        public List<string> TypeToTokenList
+        {
+            get
+            {
+                return typeToTokenList;
+            }
+        }
+
+        public ICollection<string> LexerRules
+        {
+            get
+            {
+                return lexerRules;
+            }
+        }
+
+        public List<Rule> RuleIndexToRuleList
+        {
+            get
+            {
+                return ruleIndexToRuleList;
+            }
+        }
+
+        public bool WatchNFAConversion
+        {
+            get
+            {
+                return watchNFAConversion;
+            }
+
+            set
+            {
+                watchNFAConversion = value;
+            }
+        }
+
+        protected internal int RuleIndex
+        {
+            get
+            {
+                return ruleIndex;
+            }
+
+            set
+            {
+                ruleIndex = value;
}
}
+
#endregion

public virtual void SetDelegationRoot( Grammar root )
@@ -216,10 +325,12 @@ namespace Antlr3.Tool
{
return null; // not found
}
-            if ( me.parent != null )
+
+            if ( me.Parent != null )
{
-                return me.parent.grammar;
+                return me.Parent.Grammar;
}
+
return null;
}

@@ -251,7 +362,7 @@ namespace Antlr3.Tool
for ( int i = 0; children != null && i < children.Count; i++ )
{
CompositeGrammarTree child = (CompositeGrammarTree)children[i];
-                grammars.Add( child.grammar );
+                grammars.Add( child.Grammar );
}
return grammars;
}
@@ -273,18 +384,18 @@ namespace Antlr3.Tool
*/
public virtual IList<Grammar> GetDelegators( Grammar g )
{
-            if ( g == delegateGrammarTreeRoot.grammar )
+            if ( g == delegateGrammarTreeRoot.Grammar )
{
return null;
}
List<Grammar> grammars = new List<Grammar>();
CompositeGrammarTree t = delegateGrammarTreeRoot.FindNode( g );
// walk backwards to root, collecting grammars
-            CompositeGrammarTree p = t.parent;
+            CompositeGrammarTree p = t.Parent;
while ( p != null )
{
-                grammars.Insert( 0, p.grammar ); // add to head so in order later
-                p = p.parent;
+                grammars.Insert( 0, p.Grammar ); // add to head so in order later
+                p = p.Parent;
}
return grammars;
}
@@ -300,7 +411,7 @@ namespace Antlr3.Tool
*/
public virtual HashSet<Rule> GetDelegatedRules( Grammar g )
{
-            if ( g != delegateGrammarTreeRoot.grammar )
+            if ( g != delegateGrammarTreeRoot.Grammar )
{
return null;
}
@@ -345,21 +456,12 @@ namespace Antlr3.Tool
return rules;
}

-        public virtual Grammar GetRootGrammar()
-        {
-            if ( delegateGrammarTreeRoot == null )
-            {
-                return null;
-            }
-            return delegateGrammarTreeRoot.grammar;
-        }
-
public virtual Grammar GetGrammar( string grammarName )
{
CompositeGrammarTree t = delegateGrammarTreeRoot.FindNode( grammarName );
if ( t != null )
{
-                return t.grammar;
+                return t.Grammar;
}
return null;
}
@@ -407,7 +509,7 @@ namespace Antlr3.Tool

// the walker has filled literals, tokens, and alias tables.
// now tell it to define them in the root grammar
-            ttypesWalker.DefineTokens(delegateGrammarTreeRoot.grammar);
+            ttypesWalker.DefineTokens(delegateGrammarTreeRoot.Grammar);
}

public virtual void TranslateLeftRecursiveRules()
@@ -476,7 +578,7 @@ namespace Antlr3.Tool
HashSet<string> localRuleDefs = new HashSet<string>();
HashSet<string> overrides = new HashSet<string>();
// compute set of non-overridden rules for this delegate
-            foreach ( Rule r in p.grammar.Rules )
+            foreach ( Rule r in p.Grammar.Rules )
{
if ( !ruleDefs.Contains( r.Name ) )
{
@@ -490,7 +592,7 @@ namespace Antlr3.Tool
}
//System.Console.Out.WriteLine( "rule defs for " + p.grammar.name + ": " + localRuleDefs );
//System.Console.Out.WriteLine( "overridden rule for " + p.grammar.name + ": " + overrides );
-            p.grammar.overriddenRules = overrides;
+            p.Grammar.overriddenRules = overrides;

// make set of all rules defined thus far walking delegation tree.
// the same rule in two delegates resolves in favor of first found
diff --git a/Antlr3/Tool/CompositeGrammarTree.cs b/Antlr3/Tool/CompositeGrammarTree.cs
index 9bf62b4..34eaf98 100644
--- a/Antlr3/Tool/CompositeGrammarTree.cs
+++ b/Antlr3/Tool/CompositeGrammarTree.cs
@@ -38,16 +38,38 @@ namespace Antlr3.Tool
public class CompositeGrammarTree
{
protected internal IList<CompositeGrammarTree> children;
-        public Grammar grammar;
+
+        private readonly Grammar grammar;

/** Who is the parent node of this node; if null, implies node is root */
-        public CompositeGrammarTree parent;
+        private CompositeGrammarTree parent;

public CompositeGrammarTree( Grammar g )
{
grammar = g;
}

+        public Grammar Grammar
+        {
+            get
+            {
+                return grammar;
+            }
+        }
+
+        public CompositeGrammarTree Parent
+        {
+            get
+            {
+                return parent;
+            }
+
+            set
+            {
+                parent = value;
+            }
+        }
+
public virtual void AddChild( CompositeGrammarTree t )
{
//Console.Out.WriteLine("add "+t.toStringTree()+" as child to "+this.toStringTree());
diff --git a/Antlr3/Tool/DOTGenerator.cs b/Antlr3/Tool/DOTGenerator.cs
index c826b87..94ab964 100644
--- a/Antlr3/Tool/DOTGenerator.cs
+++ b/Antlr3/Tool/DOTGenerator.cs
@@ -202,13 +202,13 @@ namespace Antlr3.Tool
// make a DOT edge for each transition
for ( int i = 0; i < s.NumberOfTransitions; i++ )
{
-                Transition edge = (Transition)s.Transition( i );
+                Transition edge = (Transition)s.GetTransition( i );
//Console.Out.WriteLine( "dfa " + s.dfa.decisionNumber + " edge from s"
//    + s.stateNumber + " [" + i + "] of " + s.NumberOfTransitions );
if ( StripNonreducedStates )
{
if ( edge.Target is DFAState &&
-                        ( (DFAState)edge.Target ).AcceptStateReachable != DFA.REACHABLE_YES )
+                        ( (DFAState)edge.Target ).AcceptStateReachable != Reachable.Yes )
{
continue; // don't generate nodes for terminal states
}
@@ -292,19 +292,19 @@ namespace Antlr3.Tool
RuleClosureTransition rr = ( (RuleClosureTransition)edge );
// don't jump to other rules, but display edge to follow node
edgeST = GetTemplates().GetInstanceOf( "edge" );
-                    if ( rr.rule.Grammar != grammar )
+                    if ( rr.Rule.Grammar != grammar )
{
-                        edgeST.SetAttribute( "label", "<" + rr.rule.Grammar.name + "." + rr.rule.Name + ">" );
+                        edgeST.SetAttribute( "label", "<" + rr.Rule.Grammar.name + "." + rr.Rule.Name + ">" );
}
else
{
-                        edgeST.SetAttribute( "label", "<" + rr.rule.Name + ">" );
+                        edgeST.SetAttribute( "label", "<" + rr.Rule.Name + ">" );
}
edgeST.SetAttribute( "src", GetStateLabel( s ) );
-                    edgeST.SetAttribute( "target", GetStateLabel( rr.followState ) );
+                    edgeST.SetAttribute( "target", GetStateLabel( rr.FollowState ) );
edgeST.SetAttribute( "arrowhead", arrowhead );
dot.SetAttribute( "edges", edgeST );
-                    WalkRuleNFACreatingDOT( dot, rr.followState );
+                    WalkRuleNFACreatingDOT( dot, rr.FollowState );
continue;
}
if ( edge.IsAction )
@@ -418,7 +418,7 @@ namespace Antlr3.Tool
{
if ( s is DFAState )
{
-                        if ( ( (DFAState)s ).abortedDueToRecursionOverflow )
+                        if ( ( (DFAState)s ).AbortedDueToRecursionOverflow )
{
buf.Append( "\\n" );
buf.Append( "abortedDueToRecursionOverflow" );
@@ -433,7 +433,7 @@ namespace Antlr3.Tool
//altList.addAll( alts );
//Collections.sort( altList );
List<int> altList = alts.OrderBy( i => i ).ToList();
-                        ICollection<NFAConfiguration> configurations = ( (DFAState)s ).nfaConfigurations;
+                        ICollection<NFAConfiguration> configurations = ( (DFAState)s ).NfaConfigurations;
for ( int altIndex = 0; altIndex < altList.Count; altIndex++ )
{
object altI = altList[altIndex];
@@ -447,24 +447,25 @@ namespace Antlr3.Tool
buf.Append( ':' );
// get a list of configs for just this alt
// it will help us print better later
-                            IList<object> configsInAlt = new List<object>();
+                            IList<NFAConfiguration> configsInAlt = new List<NFAConfiguration>();
foreach ( NFAConfiguration c in configurations )
{
-                                if ( c.alt != alt )
+                                if ( c.Alt != alt )
continue;
configsInAlt.Add( c );
}
+
int n = 0;
for ( int cIndex = 0; cIndex < configsInAlt.Count; cIndex++ )
{
-                                NFAConfiguration c =
-                                    (NFAConfiguration)configsInAlt[cIndex];
+                                NFAConfiguration c = configsInAlt[cIndex];
n++;
buf.Append( c.ToString( false ) );
if ( ( cIndex + 1 ) < configsInAlt.Count )
{
buf.Append( ", " );
}
+
if ( n % 5 == 0 && ( configsInAlt.Count - cIndex ) > 3 )
{
buf.Append( "\\n" );
diff --git a/Antlr3/Tool/DgmlGenerator.cs b/Antlr3/Tool/DgmlGenerator.cs
index 8deb5fb..bc8a848 100644
--- a/Antlr3/Tool/DgmlGenerator.cs
+++ b/Antlr3/Tool/DgmlGenerator.cs
@@ -163,12 +163,12 @@ namespace Antlr3.Tool
// make an edge for each transition
for (int i = 0; i < dfaState.NumberOfTransitions; i++)
{
-                Transition edge = dfaState.Transition(i);
+                Transition edge = dfaState.GetTransition(i);
if (StripNonreducedStates)
{
DFAState target = edge.Target as DFAState;
// don't generate nodes for terminal states
-                    if (target != null && target.AcceptStateReachable != DFA.REACHABLE_YES)
+                    if (target != null && target.AcceptStateReachable != Reachable.Yes)
continue;
}

@@ -240,19 +240,19 @@ namespace Antlr3.Tool
{
string label;

-                    if (rr.rule.Grammar != _grammar)
-                        label = string.Format("<{0}.{1}>", rr.rule.Grammar.name, rr.rule.Name);
+                    if (rr.Rule.Grammar != _grammar)
+                        label = string.Format("<{0}.{1}>", rr.Rule.Grammar.name, rr.Rule.Name);
else
-                        label = string.Format("<{0}>", rr.rule.Name);
+                        label = string.Format("<{0}>", rr.Rule.Name);

XElement link = new XElement(Elements.Link,
new XAttribute(Attributes.Source, "state_" + state.StateNumber),
-                        new XAttribute(Attributes.Target, "state_" + rr.followState),
+                        new XAttribute(Attributes.Target, "state_" + rr.FollowState),
new XAttribute(Attributes.Category, Categories.RuleClosureEdge),
new XAttribute(Attributes.Label, label));

_links.Add(new KeyValuePair<State, Transition>(state, edge), link);
-                    WalkRuleNfaCreatingDgml(rr.followState);
+                    WalkRuleNfaCreatingDgml(rr.FollowState);
}
else
{
@@ -422,7 +422,7 @@ namespace Antlr3.Tool
builder.Append(state.StateNumber);
if (AntlrTool.internalOption_ShowNFAConfigsInDFA)
{
-                    if (dfaState.abortedDueToRecursionOverflow)
+                    if (dfaState.AbortedDueToRecursionOverflow)
{
builder.AppendLine();
builder.AppendLine("AbortedDueToRecursionOverflow");
@@ -433,7 +433,7 @@ namespace Antlr3.Tool
{
builder.AppendLine();
List<int> altList = alts.OrderBy(i => i).ToList();
-                        ICollection<NFAConfiguration> configurations = dfaState.nfaConfigurations;
+                        ICollection<NFAConfiguration> configurations = dfaState.NfaConfigurations;
for (int i = 0; i < altList.Count; i++)
{
int alt = altList[i];
@@ -445,7 +445,7 @@ namespace Antlr3.Tool
List<NFAConfiguration> configsInAlt = new List<NFAConfiguration>();
foreach (NFAConfiguration c in configurations)
{
-                                if (c.alt != alt)
+                                if (c.Alt != alt)
continue;

configsInAlt.Add(c);
diff --git a/Antlr3/Tool/ErrorManager.cs b/Antlr3/Tool/ErrorManager.cs
index e19e0f1..c5a9bcf 100644
--- a/Antlr3/Tool/ErrorManager.cs
+++ b/Antlr3/Tool/ErrorManager.cs
@@ -687,11 +687,11 @@ namespace Antlr3.Tool
GetErrorState().errorMsgIDs.Add( msg.msgID );
ICollection<object> seen;
emitSingleError.TryGetValue("danglingState", out seen);
-            if ( !seen.Contains( d.dfa.decisionNumber + "|" + d.AltSet ) )
+            if ( !seen.Contains( d.Dfa.DecisionNumber + "|" + d.AltSet ) )
{
GetErrorListener().Error( msg );
// we've seen this decision and this alt set; never again
-                seen.Add( d.dfa.decisionNumber + "|" + d.AltSet );
+                seen.Add( d.Dfa.DecisionNumber + "|" + d.AltSet );
}
}

diff --git a/Antlr3/Tool/FASerializer.cs b/Antlr3/Tool/FASerializer.cs
index 4d25114..c4bdeca 100644
--- a/Antlr3/Tool/FASerializer.cs
+++ b/Antlr3/Tool/FASerializer.cs
@@ -147,7 +147,7 @@ namespace Antlr3.Tool
// to it, but don't "draw" an edge.
if ( edge is RuleClosureTransition )
{
-                    WalkFANormalizingStateNumbers( ( (RuleClosureTransition)edge ).followState );
+                    WalkFANormalizingStateNumbers( ( (RuleClosureTransition)edge ).FollowState );
}
}
}
@@ -223,7 +223,7 @@ namespace Antlr3.Tool
// to it, but don't "draw" an edge.
if ( edge is RuleClosureTransition )
{
-                    WalkSerializingFA( lines, ( (RuleClosureTransition)edge ).followState );
+                    WalkSerializingFA( lines, ( (RuleClosureTransition)edge ).FollowState );
}
}

diff --git a/Antlr3/Tool/Grammar.cs b/Antlr3/Tool/Grammar.cs
index 6c41287..0730ae5 100644
--- a/Antlr3/Tool/Grammar.cs
+++ b/Antlr3/Tool/Grammar.cs
@@ -573,13 +573,13 @@ namespace Antlr3.Tool
Tool = tool;
FileName = fileName;
// ensure we have the composite set to something
-            if ( composite.delegateGrammarTreeRoot == null )
+            if ( composite.DelegateGrammarTreeRoot == null )
{
composite.SetDelegationRoot( this );
}
else
{
-                defaultRuleModifier = composite.delegateGrammarTreeRoot.grammar.DefaultRuleModifier;
+                defaultRuleModifier = composite.DelegateGrammarTreeRoot.Grammar.DefaultRuleModifier;
}

TemplateGroup lexerGrammarTemplateGroup = new TemplateGroupString(lexerGrammarTemplateText);
@@ -817,7 +817,7 @@ namespace Antlr3.Tool
{
get
{
-                return composite.delegateGrammarTreeRoot.grammar == this;
+                return composite.DelegateGrammarTreeRoot.Grammar == this;
}
}

@@ -847,7 +847,7 @@ namespace Antlr3.Tool
{
if ( generator != null )
{
-                    return generator.target.GetMaxCharValue( generator );
+                    return generator.Target.GetMaxCharValue( generator );
}
else
{
@@ -860,7 +860,7 @@ namespace Antlr3.Tool
{
get
{
-                return composite.maxTokenType;
+                return composite.MaxTokenType;
}
}
public int MaxLookahead
@@ -908,7 +908,7 @@ namespace Antlr3.Tool
{
get
{
-                return composite.stringLiteralToTypeMap.Keys;
+                return composite.StringLiteralToTypeMap.Keys;
}
}
public IList<KeyValuePair<string, GrammarAST>> SyntacticPredicates
@@ -923,7 +923,7 @@ namespace Antlr3.Tool
{
get
{
-                return composite.tokenIDToTypeMap.Keys;
+                return composite.TokenIDToTypeMap.Keys;
}
}
/** Return a set of all possible token or char types for this grammar */
@@ -1480,7 +1480,7 @@ namespace Antlr3.Tool
{
CreateRuleStartAndStopNFAStates();
}
-            if ( nfa.complete )
+            if ( nfa.Complete )
{
// don't let it create more than once; has side-effects
return;
@@ -1503,7 +1503,7 @@ namespace Antlr3.Tool
name,
re );
}
-            nfa.complete = true;
+            nfa.Complete = true;
}

/** For each decision in this grammar, compute a single DFA using the
@@ -1551,7 +1551,7 @@ namespace Antlr3.Tool
if ( leftRecursiveRules.Contains( decisionStartState.enclosingRule ) )
{
// don't bother to process decisions within left recursive rules.
-                        if ( composite.watchNFAConversion )
+                        if ( composite.WatchNFAConversion )
{
Console.Out.WriteLine( "ignoring decision " + decision +
" within left-recursive rule " + decisionStartState.enclosingRule.Name );
@@ -1574,14 +1574,14 @@ namespace Antlr3.Tool
}
if ( dfa == null )
{
-                            if ( composite.watchNFAConversion )
+                            if ( composite.WatchNFAConversion )
{
Console.Out.WriteLine( "decision " + decision +
" not suitable for LL(1)-optimized DFA analysis" );
}
dfa = CreateLookaheadDFA( decision, wackTempStructures );
}
-                        if ( dfa.startState == null )
+                        if ( dfa.StartState == null )
{
// something went wrong; wipe out DFA
SetLookaheadDFA( decision, null );
@@ -1589,8 +1589,8 @@ namespace Antlr3.Tool
if ( Tool.internalOption_PrintDFA )
{
Console.Out.WriteLine( "DFA d=" + decision );
-                            FASerializer serializer = new FASerializer( nfa.grammar );
-                            string result = serializer.Serialize( dfa.startState );
+                            FASerializer serializer = new FASerializer( nfa.Grammar );
+                            string result = serializer.Serialize( dfa.StartState );
Console.Out.WriteLine( result );
}
}
@@ -1644,7 +1644,7 @@ namespace Antlr3.Tool
Rule r = d.startState.enclosingRule;
NFAState decisionStartState = GetDecisionNFAStartState( decision );

-            if ( composite.watchNFAConversion )
+            if ( composite.WatchNFAConversion )
{
Console.Out.WriteLine( "--------------------\nattempting LL(1) DFA (d="
+ decisionStartState.DecisionNumber + ") for " +
@@ -1732,7 +1732,7 @@ namespace Antlr3.Tool
for ( int i = 1; i < altLook.Length; i++ )
{
LookaheadSet s = altLook[i];
-                edges.Add( (IntervalSet)s.tokenTypeSet );
+                edges.Add( (IntervalSet)s.TokenTypeSet );
}
IList<IIntSet> disjoint = MakeEdgeSetsDisjoint( edges );
//JSystem.@out.println("disjoint="+disjoint);
@@ -1744,7 +1744,7 @@ namespace Antlr3.Tool
for ( int alt = 1; alt < altLook.Length; alt++ )
{
LookaheadSet look = altLook[alt];
-                    if ( !ds.And( look.tokenTypeSet ).IsNil )
+                    if ( !ds.And( look.TokenTypeSet ).IsNil )
{
edgeMap.Map( ds, alt );
}
@@ -1766,7 +1766,7 @@ namespace Antlr3.Tool

private void UpdateLineColumnToLookaheadDFAMap( DFA lookaheadDFA )
{
-            GrammarAST decisionAST = nfa.grammar.GetDecisionBlockAST( lookaheadDFA.decisionNumber );
+            GrammarAST decisionAST = nfa.Grammar.GetDecisionBlockAST( lookaheadDFA.DecisionNumber );
int line = decisionAST.Line;
int col = decisionAST.CharPositionInLine;
lineColumnToLookaheadDFAMap[line + ":" + col] = lookaheadDFA;
@@ -1843,7 +1843,7 @@ namespace Antlr3.Tool
NFAState decisionStartState = GetDecisionNFAStartState( decision );
DateTime startDFA = DateTime.MinValue;
DateTime stopDFA = DateTime.MinValue;
-            if ( composite.watchNFAConversion )
+            if ( composite.WatchNFAConversion )
{
Console.Out.WriteLine( "--------------------\nbuilding lookahead DFA (d="
+ decisionStartState.DecisionNumber + ") for " +
@@ -1855,8 +1855,8 @@ namespace Antlr3.Tool
// Retry to create a simpler DFA if analysis failed (non-LL(*),
// recursion overflow, or time out).
bool failed =
-                lookaheadDFA.probe.IsNonLLStarDecision ||
-                lookaheadDFA.probe.AnalysisOverflowed;
+                lookaheadDFA.Probe.IsNonLLStarDecision ||
+                lookaheadDFA.Probe.AnalysisOverflowed;
if ( failed && lookaheadDFA.OkToRetryWithK1 )
{
// set k=1 option and try again.
@@ -1864,7 +1864,7 @@ namespace Antlr3.Tool
decisionsWhoseDFAsUsesSynPreds.Remove( lookaheadDFA );
// TODO: clean up synPredNamesUsedInDFA also (harder)
d.blockAST.SetBlockOption( this, "k", 1 );
-                if ( composite.watchNFAConversion )
+                if ( composite.WatchNFAConversion )
{
Console.Out.Write( "trying decision " + decision +
" again with k=1; reason: " +
@@ -1887,7 +1887,7 @@ namespace Antlr3.Tool
// create map from line:col to decision DFA (for ANTLRWorks)
UpdateLineColumnToLookaheadDFAMap( lookaheadDFA );

-            if ( composite.watchNFAConversion )
+            if ( composite.WatchNFAConversion )
{
stopDFA = DateTime.Now;
Console.Out.WriteLine( "cost: " + lookaheadDFA.NumberOfStates +
@@ -1912,8 +1912,8 @@ namespace Antlr3.Tool
/** Return a new unique integer in the token type space */
public virtual int GetNewTokenType()
{
-            composite.maxTokenType++;
-            return composite.maxTokenType;
+            composite.MaxTokenType++;
+            return composite.MaxTokenType;
}

/** Define a token at a particular token type value.  Blast an
@@ -1923,7 +1923,7 @@ namespace Antlr3.Tool
public virtual void DefineToken( string text, int tokenType )
{
//JSystem.@out.println("defineToken("+text+", "+tokenType+")");
-            if (composite.tokenIDToTypeMap.ContainsKey( text ))
+            if (composite.TokenIDToTypeMap.ContainsKey( text ))
{
// already defined?  Must be predefined one like EOF;
// do nothing
@@ -1933,31 +1933,31 @@ namespace Antlr3.Tool
// hold faux labels as you cannot have negative indices.
if ( text[0] == '\'' )
{
-                composite.stringLiteralToTypeMap[text] = tokenType;
+                composite.StringLiteralToTypeMap[text] = tokenType;
// track in reverse index too
-                if ( tokenType >= composite.typeToStringLiteralList.Count )
+                if ( tokenType >= composite.TypeToStringLiteralList.Count )
{
-                    composite.typeToStringLiteralList.setSize( tokenType + 1 );
+                    composite.TypeToStringLiteralList.setSize( tokenType + 1 );
}
-                composite.typeToStringLiteralList[tokenType] = text;
+                composite.TypeToStringLiteralList[tokenType] = text;
}
else
{
// must be a label like ID
-                composite.tokenIDToTypeMap[text] = tokenType;
+                composite.TokenIDToTypeMap[text] = tokenType;
}
int index = Label.NUM_FAUX_LABELS + tokenType - 1;
//JSystem.@out.println("defining "+name+" token "+text+" at type="+tokenType+", index="+index);
-            composite.maxTokenType = Math.Max( composite.maxTokenType, tokenType );
-            if ( index >= composite.typeToTokenList.Count )
+            composite.MaxTokenType = Math.Max( composite.MaxTokenType, tokenType );
+            if ( index >= composite.TypeToTokenList.Count )
{
-                composite.typeToTokenList.setSize( index + 1 );
+                composite.TypeToTokenList.setSize( index + 1 );
}
-            string prevToken = (string)composite.typeToTokenList[index];
+            string prevToken = (string)composite.TypeToTokenList[index];
if ( prevToken == null || prevToken[0] == '\'' )
{
// only record if nothing there before or if thing before was a literal
-                composite.typeToTokenList[index] = text;
+                composite.TypeToTokenList[index] = text;
}
}

@@ -1987,7 +1987,7 @@ namespace Antlr3.Tool
return;
}

-            Rule r = new Rule( this, ruleName, composite.ruleIndex, numAlts );
+            Rule r = new Rule( this, ruleName, composite.RuleIndex, numAlts );
/*
JSystem.@out.println("defineRule("+ruleName+",modifier="+modifier+
"): index="+r.index+", nalts="+numAlts);
@@ -1997,9 +1997,9 @@ namespace Antlr3.Tool
SetRuleAST( ruleName, tree );
r.SetOptions( options, ruleToken );
r.ArgActionAST = argActionAST;
-            composite.ruleIndexToRuleList.setSize( composite.ruleIndex + 1 );
-            composite.ruleIndexToRuleList[composite.ruleIndex] = r;
-            composite.ruleIndex++;
+            composite.RuleIndexToRuleList.setSize( composite.RuleIndex + 1 );
+            composite.RuleIndexToRuleList[composite.RuleIndex] = r;
+            composite.RuleIndex++;
if ( ruleName.StartsWith( SynpredRulePrefix ) )
{
r.IsSynPred = true;
@@ -2186,7 +2186,7 @@ namespace Antlr3.Tool
LexerGrammarTemplate.SetAttribute( "rules", ruleText );
}
// track this lexer rule's name
-            composite.lexerRules.Add( ruleToken.Text );
+            composite.LexerRules.Add( ruleToken.Text );
}

/** If someone does PLUS='+' in the parser, must make sure we get
@@ -2205,7 +2205,7 @@ namespace Antlr3.Tool
literal );
}
// track this lexer rule's name
-            composite.lexerRules.Add( tokenID );
+            composite.LexerRules.Add( tokenID );
}

public virtual void DefineLexerRuleForStringLiteral( string literal, int tokenType )
@@ -2275,7 +2275,7 @@ namespace Antlr3.Tool

public virtual string GetRuleName( int ruleIndex )
{
-            Rule r = composite.ruleIndexToRuleList[ruleIndex];
+            Rule r = composite.RuleIndexToRuleList[ruleIndex];
if ( r != null )
{
return r.Name;
@@ -2317,21 +2317,21 @@ namespace Antlr3.Tool
public virtual AttributeScope CreateReturnScope( string ruleName, IToken retAction )
{
AttributeScope scope = new AttributeScope( this, ruleName, retAction );
-            scope.isReturnScope = true;
+            scope.IsReturnScope = true;
return scope;
}

public virtual AttributeScope CreateRuleScope( string ruleName, IToken scopeAction )
{
AttributeScope scope = new AttributeScope( this, ruleName, scopeAction );
-            scope.isDynamicRuleScope = true;
+            scope.IsDynamicRuleScope = true;
return scope;
}

public virtual AttributeScope CreateParameterScope( string ruleName, IToken argAction )
{
AttributeScope scope = new AttributeScope( this, ruleName, argAction );
-            scope.isParameterScope = true;
+            scope.IsParameterScope = true;
return scope;
}

@@ -2695,13 +2695,13 @@ namespace Antlr3.Tool
int i;
if ( tokenName[0] == '\'' )
{
-                if ( composite.stringLiteralToTypeMap.TryGetValue( tokenName, out i ) )
+                if ( composite.StringLiteralToTypeMap.TryGetValue( tokenName, out i ) )
return i;
}
else
{
// must be a label like ID
-                if ( composite.tokenIDToTypeMap.TryGetValue( tokenName, out i ) )
+                if ( composite.TokenIDToTypeMap.TryGetValue( tokenName, out i ) )
return i;
}

@@ -2852,14 +2852,14 @@ namespace Antlr3.Tool
foreach ( string tokenID in importedTokenIDs )
{
int tokenType = importFromGr.GetTokenType( tokenID );
-                composite.maxTokenType = Math.Max( composite.maxTokenType, tokenType );
+                composite.MaxTokenType = Math.Max( composite.MaxTokenType, tokenType );
if ( tokenType >= Label.MIN_TOKEN_TYPE )
{
//JSystem.@out.println("import token from grammar "+tokenID+"="+tokenType);
DefineToken( tokenID, tokenType );
}
}
-            return composite.maxTokenType; // return max found
+            return composite.MaxTokenType; // return max found
}

/** Import the rules/tokens of a delegate grammar. All delegate grammars are
@@ -2956,7 +2956,7 @@ namespace Antlr3.Tool
/** add new delegate to composite tree */
protected virtual void AddDelegateGrammar( Grammar delegateGrammar )
{
-            CompositeGrammarTree t = composite.delegateGrammarTreeRoot.FindNode( this );
+            CompositeGrammarTree t = composite.DelegateGrammarTreeRoot.FindNode( this );
t.AddChild( new CompositeGrammarTree( delegateGrammar ) );
// make sure new grammar shares this composite
delegateGrammar.composite = this.composite;
@@ -2972,7 +2972,7 @@ namespace Antlr3.Tool
this,
tokenVocabOptionAST.Token,
name );
-                return composite.maxTokenType;
+                return composite.MaxTokenType;
}

Regex vocabLine = new Regex( @"^(?<tokenID>'(?:\\'|.)+'|\w+)\s*=\s*(?<tokenType>\d+)$", RegexOptions.Compiled );
@@ -3015,7 +3015,7 @@ namespace Antlr3.Tool
ErrorManager.Error( ErrorManager.MSG_CANNOT_FIND_TOKENS_FILE, fileName );
}

-            return composite.maxTokenType;
+            return composite.MaxTokenType;
}

/** Given a token type, get a meaningful name for it such as the ID
@@ -3035,7 +3035,7 @@ namespace Antlr3.Tool
// faux label?
else if ( ttype < 0 )
{
-                tokenName = (string)composite.typeToTokenList[Label.NUM_FAUX_LABELS + ttype];
+                tokenName = (string)composite.TypeToTokenList[Label.NUM_FAUX_LABELS + ttype];
}
else
{
@@ -3043,13 +3043,13 @@ namespace Antlr3.Tool
index = ttype - 1; // normalize to 0..n-1
index += Label.NUM_FAUX_LABELS;     // jump over faux tokens

-                if ( index < composite.typeToTokenList.Count )
+                if ( index < composite.TypeToTokenList.Count )
{
-                    tokenName = (string)composite.typeToTokenList[index];
+                    tokenName = (string)composite.TypeToTokenList[index];
if ( tokenName != null &&
tokenName.StartsWith( AUTO_GENERATED_TOKEN_NAME_PREFIX ) )
{
-                        tokenName = composite.typeToStringLiteralList[ttype];
+                        tokenName = composite.TypeToStringLiteralList[ttype];
}
}
else
@@ -3107,7 +3107,7 @@ namespace Antlr3.Tool
}
if ( key == "backtrack" && value.ToString() == "true" )
{
-                composite.GetRootGrammar().atLeastOneBacktrackOption = true;
+                composite.RootGrammar.atLeastOneBacktrackOption = true;
}
if ( options == null )
{
@@ -3188,11 +3188,11 @@ namespace Antlr3.Tool
public virtual int GetUserMaxLookahead( int decision )
{
int user_k = 0;
-            GrammarAST blockAST = nfa.grammar.GetDecisionBlockAST( decision );
+            GrammarAST blockAST = nfa.Grammar.GetDecisionBlockAST( decision );
object k = blockAST.GetBlockOption( "k" );
if ( k == null )
{
-                user_k = nfa.grammar.MaxLookahead;
+                user_k = nfa.Grammar.MaxLookahead;
return user_k;
}
if ( k is int )
@@ -3219,7 +3219,7 @@ namespace Antlr3.Tool

if ( autoBacktrack == null )
{
-                autoBacktrack = (string)nfa.grammar.GetOption( "backtrack" );
+                autoBacktrack = (string)nfa.Grammar.GetOption( "backtrack" );
}
return autoBacktrack != null && autoBacktrack.Equals( "true" );
}
diff --git a/Antlr3/Tool/GrammarAST.cs b/Antlr3/Tool/GrammarAST.cs
index cfb9808..50c163f 100644
--- a/Antlr3/Tool/GrammarAST.cs
+++ b/Antlr3/Tool/GrammarAST.cs
@@ -290,7 +290,7 @@ namespace Antlr3.Tool
}
if ( key == "backtrack" && value.ToString() == "true" )
{
-                grammar.composite.GetRootGrammar().atLeastOneBacktrackOption = true;
+                grammar.composite.RootGrammar.atLeastOneBacktrackOption = true;
}
options[key] = value;
return key;
diff --git a/Antlr3/Tool/GrammarAnalysisAbortedMessage.cs b/Antlr3/Tool/GrammarAnalysisAbortedMessage.cs
index f3b493b..2226ca6 100644
--- a/Antlr3/Tool/GrammarAnalysisAbortedMessage.cs
+++ b/Antlr3/Tool/GrammarAnalysisAbortedMessage.cs
@@ -51,17 +51,17 @@ namespace Antlr3.Tool

public override string ToString()
{
-            GrammarAST decisionASTNode = probe.dfa.DecisionASTNode;
+            GrammarAST decisionASTNode = probe.Dfa.DecisionASTNode;
line = decisionASTNode.Line;
charPositionInLine = decisionASTNode.CharPositionInLine;
-            string fileName = probe.dfa.nfa.grammar.FileName;
+            string fileName = probe.Dfa.Nfa.Grammar.FileName;
if ( fileName != null )
{
file = fileName;
}
StringTemplate st = GetMessageTemplate();
st.SetAttribute( "enclosingRule",
-                            probe.dfa.NFADecisionStartState.enclosingRule.Name );
+                            probe.Dfa.NFADecisionStartState.enclosingRule.Name );

return base.ToString( st );
}
diff --git a/Antlr3/Tool/GrammarDanglingStateMessage.cs b/Antlr3/Tool/GrammarDanglingStateMessage.cs
index 8201d91..587071c 100644
--- a/Antlr3/Tool/GrammarDanglingStateMessage.cs
+++ b/Antlr3/Tool/GrammarDanglingStateMessage.cs
@@ -57,10 +57,10 @@ namespace Antlr3.Tool

public override string ToString()
{
-            GrammarAST decisionASTNode = probe.dfa.DecisionASTNode;
+            GrammarAST decisionASTNode = probe.Dfa.DecisionASTNode;
line = decisionASTNode.Line;
charPositionInLine = decisionASTNode.CharPositionInLine;
-            string fileName = probe.dfa.nfa.grammar.FileName;
+            string fileName = probe.Dfa.Nfa.Grammar.FileName;
if ( fileName != null )
{
file = fileName;
diff --git a/Antlr3/Tool/GrammarInsufficientPredicatesMessage.cs b/Antlr3/Tool/GrammarInsufficientPredicatesMessage.cs
index f9ddfce..03c7e3b 100644
--- a/Antlr3/Tool/GrammarInsufficientPredicatesMessage.cs
+++ b/Antlr3/Tool/GrammarInsufficientPredicatesMessage.cs
@@ -58,10 +58,10 @@ namespace Antlr3.Tool

public override string ToString()
{
-            GrammarAST decisionASTNode = probe.dfa.DecisionASTNode;
+            GrammarAST decisionASTNode = probe.Dfa.DecisionASTNode;
line = decisionASTNode.Line;
charPositionInLine = decisionASTNode.CharPositionInLine;
-            string fileName = probe.dfa.nfa.grammar.FileName;
+            string fileName = probe.Dfa.Nfa.Grammar.FileName;
if ( fileName != null )
{
file = fileName;
@@ -87,11 +87,11 @@ namespace Antlr3.Tool
}
st.SetAttribute( "altToLocations", altToLocationsWithStringKey );

-            var sampleInputLabels = problemState.dfa.probe.GetSampleNonDeterministicInputSequence( problemState );
-            string input = problemState.dfa.probe.GetInputSequenceDisplay( sampleInputLabels );
+            var sampleInputLabels = problemState.Dfa.Probe.GetSampleNonDeterministicInputSequence( problemState );
+            string input = problemState.Dfa.Probe.GetInputSequenceDisplay( sampleInputLabels );
st.SetAttribute( "upon", input );

-            st.SetAttribute( "hasPredicateBlockedByAction", problemState.dfa.hasPredicateBlockedByAction );
+            st.SetAttribute( "hasPredicateBlockedByAction", problemState.Dfa.HasPredicateBlockedByAction );

return base.ToString( st );
}
diff --git a/Antlr3/Tool/GrammarNonDeterminismMessage.cs b/Antlr3/Tool/GrammarNonDeterminismMessage.cs
index 56a788c..d261d37 100644
--- a/Antlr3/Tool/GrammarNonDeterminismMessage.cs
+++ b/Antlr3/Tool/GrammarNonDeterminismMessage.cs
@@ -55,7 +55,7 @@ namespace Antlr3.Tool
this.probe = probe;
this.problemState = problemState;
// flip msg ID if alts are actually token refs in Tokens rule
-            if ( probe.dfa.IsTokensRuleDecision )
+            if ( probe.Dfa.IsTokensRuleDecision )
{
MessageID = ErrorManager.MSG_TOKEN_NONDETERMINISM;
}
@@ -63,10 +63,10 @@ namespace Antlr3.Tool

public override string ToString()
{
-            GrammarAST decisionASTNode = probe.dfa.DecisionASTNode;
+            GrammarAST decisionASTNode = probe.Dfa.DecisionASTNode;
line = decisionASTNode.Line;
charPositionInLine = decisionASTNode.CharPositionInLine;
-            string fileName = probe.dfa.nfa.grammar.FileName;
+            string fileName = probe.Dfa.Nfa.Grammar.FileName;
if ( fileName != null )
{
file = fileName;
@@ -78,7 +78,7 @@ namespace Antlr3.Tool
string input = probe.GetInputSequenceDisplay( labels );
st.SetAttribute( "input", input );

-            if ( probe.dfa.IsTokensRuleDecision )
+            if ( probe.Dfa.IsTokensRuleDecision )
{
var disabledAlts = probe.GetDisabledAlternatives( problemState );
foreach ( int altI in disabledAlts )
@@ -87,7 +87,7 @@ namespace Antlr3.Tool
probe.GetTokenNameForTokensRuleAlt( (int)altI );
// reset the line/col to the token definition (pick last one)
NFAState ruleStart =
-                        probe.dfa.nfa.grammar.GetRuleStartState( tokenName );
+                        probe.Dfa.Nfa.Grammar.GetRuleStartState( tokenName );
line = ruleStart.associatedASTNode.Line;
charPositionInLine = ruleStart.associatedASTNode.CharPositionInLine;
st.SetAttribute( "disabled", tokenName );
@@ -99,7 +99,7 @@ namespace Antlr3.Tool
}

var nondetAlts = probe.GetNonDeterministicAltsForState( problemState );
-            NFAState nfaStart = probe.dfa.NFADecisionStartState;
+            NFAState nfaStart = probe.Dfa.NFADecisionStartState;
// all state paths have to begin with same NFA state
int firstAlt = 0;
if ( nondetAlts != null )
@@ -123,7 +123,7 @@ namespace Antlr3.Tool
}
else
{
-                        if ( probe.dfa.IsTokensRuleDecision )
+                        if ( probe.Dfa.IsTokensRuleDecision )
{
// alts are token rules, convert to the names instead of numbers
string tokenName =
@@ -137,7 +137,7 @@ namespace Antlr3.Tool
}
}
}
-            st.SetAttribute( "hasPredicateBlockedByAction", problemState.dfa.hasPredicateBlockedByAction );
+            st.SetAttribute( "hasPredicateBlockedByAction", problemState.Dfa.HasPredicateBlockedByAction );
return base.ToString( st );
}

diff --git a/Antlr3/Tool/GrammarReport.cs b/Antlr3/Tool/GrammarReport.cs
index c26e260..8c33544 100644
--- a/Antlr3/Tool/GrammarReport.cs
+++ b/Antlr3/Tool/GrammarReport.cs
@@ -286,15 +286,15 @@ namespace Antlr3.Tool
foreach ( DFA dfa in dfas )
{
// if we aborted a DFA and redid with k=1, the backtrackin
-                if ( decisions.Contains( dfa.decisionNumber ) )
+                if ( decisions.Contains( dfa.DecisionNumber ) )
{
continue;
}
-                decisions.Add( dfa.decisionNumber );
+                decisions.Add( dfa.DecisionNumber );
buf.Append( "Rule " );
buf.Append( dfa.NFADecisionStartState.enclosingRule.Name );
buf.Append( " decision " );
-                buf.Append( dfa.decisionNumber );
+                buf.Append( dfa.DecisionNumber );
buf.Append( " location " );
GrammarAST decisionAST =
dfa.NFADecisionStartState.associatedASTNode;
diff --git a/Antlr3/Tool/GrammarSanity.cs b/Antlr3/Tool/GrammarSanity.cs
index 9818242..7e04c3b 100644
--- a/Antlr3/Tool/GrammarSanity.cs
+++ b/Antlr3/Tool/GrammarSanity.cs
@@ -63,9 +63,9 @@ namespace Antlr3.Tool
grammar.BuildNFA(); // make sure we have NFAs
grammar.leftRecursiveRules = new HashSet<Rule>();
List<HashSet<Rule>> listOfRecursiveCycles = new List<HashSet<Rule>>();
-            for ( int i = 0; i < grammar.composite.ruleIndexToRuleList.Count; i++ )
+            for ( int i = 0; i < grammar.composite.RuleIndexToRuleList.Count; i++ )
{
-                Rule r = grammar.composite.ruleIndexToRuleList[i];
+                Rule r = grammar.composite.RuleIndexToRuleList[i];
if ( r != null )
{
visitedDuringRecursionCheck = new HashSet<Rule>();
@@ -114,7 +114,7 @@ namespace Antlr3.Tool
if ( t0 is RuleClosureTransition )
{
RuleClosureTransition refTrans = (RuleClosureTransition)t0;
-                Rule refRuleDef = refTrans.rule;
+                Rule refRuleDef = refTrans.Rule;
//String targetRuleName = ((NFAState)t0.target).getEnclosingRule();
if ( visitedDuringRecursionCheck.Contains( refRuleDef ) )
{
@@ -139,7 +139,7 @@ namespace Antlr3.Tool
if ( callReachedAcceptState )
{
NFAState followingState =
-                            ( (RuleClosureTransition)t0 ).followState;
+                            ( (RuleClosureTransition)t0 ).FollowState;
stateReachesAcceptState |=
TraceStatesLookingForLeftRecursion( followingState,
visitedStates,
diff --git a/Antlr3/Tool/GrammarUnreachableAltsMessage.cs b/Antlr3/Tool/GrammarUnreachableAltsMessage.cs
index 2f629df..f05487c 100644
--- a/Antlr3/Tool/GrammarUnreachableAltsMessage.cs
+++ b/Antlr3/Tool/GrammarUnreachableAltsMessage.cs
@@ -56,7 +56,7 @@ namespace Antlr3.Tool
this.probe = probe;
this.alts = alts.ToArray();
// flip msg ID if alts are actually token refs in Tokens rule
-            if ( probe.dfa.IsTokensRuleDecision )
+            if ( probe.Dfa.IsTokensRuleDecision )
{
MessageID = ErrorManager.MSG_UNREACHABLE_TOKENS;
}
@@ -64,10 +64,10 @@ namespace Antlr3.Tool

public override String ToString()
{
-            GrammarAST decisionASTNode = probe.dfa.DecisionASTNode;
+            GrammarAST decisionASTNode = probe.Dfa.DecisionASTNode;
line = decisionASTNode.Line;
charPositionInLine = decisionASTNode.CharPositionInLine;
-            String fileName = probe.dfa.nfa.grammar.FileName;
+            String fileName = probe.Dfa.Nfa.Grammar.FileName;
if ( fileName != null )
{
file = fileName;
@@ -75,7 +75,7 @@ namespace Antlr3.Tool

StringTemplate st = GetMessageTemplate();

-            if ( probe.dfa.IsTokensRuleDecision )
+            if ( probe.Dfa.IsTokensRuleDecision )
{
// alts are token rules, convert to the names instead of numbers
for ( int i = 0; i < alts.Length; i++ )
@@ -83,7 +83,7 @@ namespace Antlr3.Tool
int altI = alts[i];
String tokenName = probe.GetTokenNameForTokensRuleAlt( altI );
// reset the line/col to the token definition
-                    NFAState ruleStart = probe.dfa.nfa.grammar.GetRuleStartState( tokenName );
+                    NFAState ruleStart = probe.Dfa.Nfa.Grammar.GetRuleStartState( tokenName );
line = ruleStart.associatedASTNode.Line;
charPositionInLine = ruleStart.associatedASTNode.CharPositionInLine;
st.SetAttribute( "tokens", tokenName );
diff --git a/Antlr3/Tool/Interpreter.cs b/Antlr3/Tool/Interpreter.cs
index ea4467c..13f6ad2 100644
--- a/Antlr3/Tool/Interpreter.cs
+++ b/Antlr3/Tool/Interpreter.cs
@@ -249,7 +249,7 @@ namespace Antlr3.Tool
NFAState s = start;
if ( actions != null )
{
-                actions.EnterRule( s.nfa.grammar.FileName, start.enclosingRule.Name );
+                actions.EnterRule( s.nfa.Grammar.FileName, start.enclosingRule.Name );
}
int t = input.LA( 1 );
while ( s != stop )
@@ -258,17 +258,17 @@ namespace Antlr3.Tool
{
visitedStates.Add( s );
}
-                //Console.Out.WriteLine( "parse state " + s.stateNumber + " input=" + s.nfa.grammar.getTokenDisplayName( t ) );
+                //Console.Out.WriteLine( "parse state " + s.stateNumber + " input=" + s.nfa.Grammar.getTokenDisplayName( t ) );
// CASE 1: decision state
-                if ( s.DecisionNumber > 0 && s.nfa.grammar.GetNumberOfAltsForDecisionNFA( s ) > 1 )
+                if ( s.DecisionNumber > 0 && s.nfa.Grammar.GetNumberOfAltsForDecisionNFA( s ) > 1 )
{
// decision point, must predict and jump to alt
-                    DFA dfa = s.nfa.grammar.GetLookaheadDFA( s.DecisionNumber );
-                    //if ( s.nfa.grammar.type != GrammarType.Lexer )
+                    DFA dfa = s.nfa.Grammar.GetLookaheadDFA( s.DecisionNumber );
+                    //if ( s.nfa.Grammar.type != GrammarType.Lexer )
//{
//    Console.Out.WriteLine( "decision: " +
//                   dfa.getNFADecisionStartState().Description +
-                    //                   " input=" + s.nfa.grammar.getTokenDisplayName( t ) );
+                    //                   " input=" + s.nfa.Grammar.getTokenDisplayName( t ) );
//}
int m = input.Mark();
int predictedAlt = Predict( dfa );
@@ -277,7 +277,7 @@ namespace Antlr3.Tool
string description = dfa.NFADecisionStartState.Description;
NoViableAltException nvae =
new NoViableAltException( description,
-                                                          dfa.DecisionNumber,
+                                                          dfa.NfaStartStateDecisionNumber,
s.StateNumber,
input );
if ( actions != null )
@@ -290,19 +290,19 @@ namespace Antlr3.Tool
input.Rewind( m );
int parseAlt =
s.TranslateDisplayAltToWalkAlt( predictedAlt );
-                    //if ( s.nfa.grammar.type != GrammarType.Lexer )
+                    //if ( s.nfa.Grammar.type != GrammarType.Lexer )
//{
//    Console.Out.WriteLine( "predicted alt " + predictedAlt + ", parseAlt " + parseAlt );
//}
NFAState alt;
-                    if ( parseAlt > s.nfa.grammar.GetNumberOfAltsForDecisionNFA( s ) )
+                    if ( parseAlt > s.nfa.Grammar.GetNumberOfAltsForDecisionNFA( s ) )
{
// implied branch of loop etc...
-                        alt = s.nfa.grammar.nfa.GetState( s.endOfBlockStateNumber );
+                        alt = s.nfa.Grammar.nfa.GetState( s.endOfBlockStateNumber );
}
else
{
-                        alt = s.nfa.grammar.GetNFAStateForAltOfDecision( s, parseAlt );
+                        alt = s.nfa.Grammar.GetNFAStateForAltOfDecision( s, parseAlt );
}
s = (NFAState)alt.transition[0].Target;
continue;
@@ -313,7 +313,7 @@ namespace Antlr3.Tool
{ // end of rule node
if ( actions != null )
{
-                        actions.ExitRule( s.nfa.grammar.FileName, s.enclosingRule.Name );
+                        actions.ExitRule( s.nfa.Grammar.FileName, s.enclosingRule.Name );
}
if ( ruleInvocationStack.Count == 0 )
{
@@ -326,7 +326,7 @@ namespace Antlr3.Tool
RuleClosureTransition invokingTransition =
(RuleClosureTransition)invokingState.transition[0];
// move to node after state that invoked this rule
-                    s = invokingTransition.followState;
+                    s = invokingTransition.FollowState;
continue;
}

@@ -352,15 +352,15 @@ namespace Antlr3.Tool
{
ruleInvocationStack.Push( s );
s = (NFAState)trans.Target;
-                        //Console.Out.WriteLine( "call " + s.enclosingRule.name + " from " + s.nfa.grammar.getFileName() );
+                        //Console.Out.WriteLine( "call " + s.enclosingRule.name + " from " + s.nfa.Grammar.getFileName() );
if ( actions != null )
{
-                            actions.EnterRule( s.nfa.grammar.FileName, s.enclosingRule.Name );
+                            actions.EnterRule( s.nfa.Grammar.FileName, s.enclosingRule.Name );
}
// could be jumping to new grammar, make sure DFA created
-                        if ( !s.nfa.grammar.AllDecisionDFAHaveBeenCreated )
+                        if ( !s.nfa.Grammar.AllDecisionDFAHaveBeenCreated )
{
-                            s.nfa.grammar.CreateLookaheadDFAs();
+                            s.nfa.Grammar.CreateLookaheadDFAs();
}
}
// CASE 3b: plain old epsilon transition, just move
@@ -375,8 +375,8 @@ namespace Antlr3.Tool
{
if ( actions != null )
{
-                        if ( s.nfa.grammar.type == GrammarType.Parser ||
-                             s.nfa.grammar.type == GrammarType.Combined )
+                        if ( s.nfa.Grammar.type == GrammarType.Parser ||
+                             s.nfa.Grammar.type == GrammarType.Combined )
{
actions.ConsumeToken( ( (ITokenStream)input ).LT( 1 ) );
}
@@ -434,7 +434,7 @@ namespace Antlr3.Tool
//Console.Out.WriteLine( "hit stop state for " + stop.enclosingRule );
if ( actions != null )
{
-                actions.ExitRule( s.nfa.grammar.FileName, stop.enclosingRule.Name );
+                actions.ExitRule( s.nfa.Grammar.FileName, stop.enclosingRule.Name );
}
}

@@ -446,17 +446,17 @@ namespace Antlr3.Tool
*/
public int Predict( DFA dfa )
{
-            DFAState s = dfa.startState;
+            DFAState s = dfa.StartState;
int c = input.LA( 1 );
Transition eotTransition = null;
dfaLoop:
while ( !s.IsAcceptState )
{
-                //Console.Out.WriteLine( "DFA.predict(" + s.stateNumber + ", " + dfa.nfa.grammar.getTokenDisplayName( c ) + ")" );
+                //Console.Out.WriteLine( "DFA.predict(" + s.stateNumber + ", " + dfa.nfa.Grammar.getTokenDisplayName( c ) + ")" );
// for each edge of s, look for intersection with current char
for ( int i = 0; i < s.NumberOfTransitions; i++ )
{
-                    Transition t = s.Transition( i );
+                    Transition t = s.GetTransition( i );
// special case: EOT matches any char
if ( t.Label.Matches( c ) )
{
@@ -479,7 +479,7 @@ namespace Antlr3.Tool
/*
ErrorManager.error(ErrorManager.MSG_NO_VIABLE_DFA_ALT,
s,
-                                   dfa.nfa.grammar.getTokenName(c));
+                                   dfa.nfa.Grammar.getTokenName(c));
*/
return NFA.INVALID_ALT_NUMBER;
}
diff --git a/Antlr3/Tool/NFAFactory.cs b/Antlr3/Tool/NFAFactory.cs
index 1591d3a..cf79b31 100644
--- a/Antlr3/Tool/NFAFactory.cs
+++ b/Antlr3/Tool/NFAFactory.cs
@@ -53,37 +53,35 @@ namespace Antlr3.Tool
/** This factory is attached to a specifc NFA that it is building.
*  The NFA will be filled up with states and transitions.
*/
-        NFA nfa = null;
+        private readonly NFA _nfa;

-        Rule currentRule = null;
+        private Rule _currentRule;

public NFAFactory( NFA nfa )
{
-            nfa.Factory = this;
-            this.nfa = nfa;
+            this._nfa = nfa;
}

-        #region Properties
public Rule CurrentRule
{
get
{
-                return currentRule;
+                return _currentRule;
}
+
set
{
-                currentRule = value;
+                _currentRule = value;
}
}
-        #endregion

public virtual NFAState NewState()
{
-            NFAState n = new NFAState( nfa );
-            int state = nfa.GetNewNFAStateNumber();
+            NFAState n = new NFAState( _nfa );
+            int state = _nfa.GetNewNFAStateNumber();
n.StateNumber = state;
-            nfa.AddState( n );
-            n.enclosingRule = currentRule;
+            _nfa.AddState( n );
+            n.enclosingRule = _currentRule;
return n;
}

@@ -97,19 +95,19 @@ namespace Antlr3.Tool
*/
public virtual void OptimizeAlternative( StateCluster alt )
{
-            NFAState s = alt.left;
-            while ( s != alt.right )
+            NFAState s = alt.Left;
+            while ( s != alt.Right )
{
// if it's a block element, jump over it and continue
if ( s.endOfBlockStateNumber != State.INVALID_STATE_NUMBER )
{
-                    s = nfa.GetState( s.endOfBlockStateNumber );
+                    s = _nfa.GetState( s.endOfBlockStateNumber );
continue;
}
Transition t = s.transition[0];
if ( t is RuleClosureTransition )
{
-                    s = ( (RuleClosureTransition)t ).followState;
+                    s = ( (RuleClosureTransition)t ).FollowState;
continue;
}
if ( t.Label.IsEpsilon && !t.Label.IsAction && s.NumberOfTransitions == 1 )
@@ -144,7 +142,7 @@ namespace Antlr3.Tool

public virtual StateCluster BuildAtom( GrammarAST atomAST )
{
-            int tokenType = nfa.grammar.GetTokenType( atomAST.Text );
+            int tokenType = _nfa.Grammar.GetTokenType( atomAST.Text );
return BuildAtom( tokenType, atomAST );
}

@@ -222,7 +220,7 @@ namespace Antlr3.Tool
*/
public virtual StateCluster BuildStringLiteralAtom( GrammarAST stringLiteralAST )
{
-            if ( nfa.grammar.type == GrammarType.Lexer )
+            if ( _nfa.Grammar.type == GrammarType.Lexer )
{
StringBuilder chars =
Grammar.GetUnescapedStringFromGrammarStringLiteral( stringLiteralAST.Text );
@@ -240,7 +238,7 @@ namespace Antlr3.Tool
}

// a simple token reference in non-Lexers
-            int tokenType = nfa.grammar.GetTokenType( stringLiteralAST.Text );
+            int tokenType = _nfa.Grammar.GetTokenType( stringLiteralAST.Text );
return BuildAtom( tokenType, stringLiteralAST );
}

@@ -291,7 +289,7 @@ namespace Antlr3.Tool
// don't count syn preds
if ( !pred.Text.StartsWith( Grammar.SynpredRulePrefix, StringComparison.OrdinalIgnoreCase ) )
{
-                nfa.grammar.numberOfSemanticPredicates++;
+                _nfa.Grammar.numberOfSemanticPredicates++;
}
NFAState left = NewState();
NFAState right = NewState();
@@ -350,7 +348,7 @@ namespace Antlr3.Tool
{
NFAState end = NewState();
int label = Label.EOF;
-            if ( nfa.grammar.type == GrammarType.Lexer )
+            if ( _nfa.Grammar.type == GrammarType.Lexer )
{
label = Label.EOT;
end.IsEOTTargetState = true;
@@ -377,8 +375,8 @@ namespace Antlr3.Tool
{
return A;
}
-            TransitionBetweenStates( A.right, B.left, Label.EPSILON );
-            StateCluster g = new StateCluster( A.left, B.right );
+            TransitionBetweenStates( A.Right, B.Left, Label.EPSILON );
+            StateCluster g = new StateCluster( A.Left, B.Right );
return g;
}

@@ -395,9 +393,9 @@ namespace Antlr3.Tool

// single alt, no decision, just return only alt state cluster
NFAState startOfAlt = NewState(); // must have this no matter what
-            TransitionBetweenStates( startOfAlt, set.left, Label.EPSILON );
+            TransitionBetweenStates( startOfAlt, set.Left, Label.EPSILON );

-            return new StateCluster( startOfAlt, set.right );
+            return new StateCluster( startOfAlt, set.Right );
}

/** From A|B|..|Z alternative block build
@@ -437,10 +435,10 @@ namespace Antlr3.Tool
// single alt, no decision, just return only alt state cluster
StateCluster g = alternativeStateClusters.First();
NFAState startOfAlt = NewState(); // must have this no matter what
-                TransitionBetweenStates( startOfAlt, g.left, Label.EPSILON );
+                TransitionBetweenStates( startOfAlt, g.Left, Label.EPSILON );

//System.Console.Out.WriteLine( "### opt saved start/stop end in (...)" );
-                return new StateCluster( startOfAlt, g.right );
+                return new StateCluster( startOfAlt, g.Right );
}

// even if we can collapse for lookahead purposes, we will still
@@ -457,8 +455,8 @@ namespace Antlr3.Tool
// add begin NFAState for this alt connected by epsilon
NFAState left = NewState();
left.Description = "alt " + altNum + " of ()";
-                TransitionBetweenStates( left, g.left, Label.EPSILON );
-                TransitionBetweenStates( g.right, blockEndNFAState, Label.EPSILON );
+                TransitionBetweenStates( left, g.Left, Label.EPSILON );
+                TransitionBetweenStates( g.Right, blockEndNFAState, Label.EPSILON );
// Are we the first alternative?
if ( firstAlt == null )
{
@@ -496,18 +494,18 @@ namespace Antlr3.Tool
public virtual StateCluster BuildAoptional( StateCluster A )
{
StateCluster g = null;
-            int n = nfa.grammar.GetNumberOfAltsForDecisionNFA( A.left );
+            int n = _nfa.Grammar.GetNumberOfAltsForDecisionNFA( A.Left );
if ( n == 1 )
{
// no decision, just wrap in an optional path
//NFAState decisionState = newState();
-                NFAState decisionState = A.left; // resuse left edge
+                NFAState decisionState = A.Left; // resuse left edge
decisionState.Description = "only alt of ()? block";
NFAState emptyAlt = NewState();
emptyAlt.Description = "epsilon path of ()? block";
NFAState blockEndNFAState = null;
blockEndNFAState = NewState();
-                TransitionBetweenStates( A.right, blockEndNFAState, Label.EPSILON );
+                TransitionBetweenStates( A.Right, blockEndNFAState, Label.EPSILON );
blockEndNFAState.Description = "end ()? block";
//transitionBetweenStates(decisionState, A.left, Label.EPSILON);
TransitionBetweenStates( decisionState, emptyAlt, Label.EPSILON );
@@ -523,19 +521,19 @@ namespace Antlr3.Tool
{
// a decision block, add an empty alt
NFAState lastRealAlt =
-                        nfa.grammar.GetNFAStateForAltOfDecision( A.left, n );
+                        _nfa.Grammar.GetNFAStateForAltOfDecision( A.Left, n );
NFAState emptyAlt = NewState();
emptyAlt.Description = "epsilon path of ()? block";
TransitionBetweenStates( lastRealAlt, emptyAlt, Label.EPSILON );
-                TransitionBetweenStates( emptyAlt, A.right, Label.EPSILON );
+                TransitionBetweenStates( emptyAlt, A.Right, Label.EPSILON );

// set EOB markers for Jean (I think this is redundant here)
-                A.left.endOfBlockStateNumber = A.right.StateNumber;
-                A.right.decisionStateType = NFAState.RIGHT_EDGE_OF_BLOCK;
+                A.Left.endOfBlockStateNumber = A.Right.StateNumber;
+                A.Right.decisionStateType = NFAState.RIGHT_EDGE_OF_BLOCK;

g = A; // return same block, but now with optional last path
}
-            g.left.decisionStateType = NFAState.OPTIONAL_BLOCK_START;
+            g.Left.decisionStateType = NFAState.OPTIONAL_BLOCK_START;

return g;
}
@@ -560,25 +558,25 @@ namespace Antlr3.Tool
blockEndNFAState.decisionStateType = NFAState.RIGHT_EDGE_OF_BLOCK;

// don't reuse A.right as loopback if it's right edge of another block
-            if ( A.right.decisionStateType == NFAState.RIGHT_EDGE_OF_BLOCK )
+            if ( A.Right.decisionStateType == NFAState.RIGHT_EDGE_OF_BLOCK )
{
// nested A* so make another tail node to be the loop back
// instead of the usual A.right which is the EOB for inner loop
NFAState extraRightEdge = NewState();
-                TransitionBetweenStates( A.right, extraRightEdge, Label.EPSILON );
-                A.right = extraRightEdge;
+                TransitionBetweenStates( A.Right, extraRightEdge, Label.EPSILON );
+                A.Right = extraRightEdge;
}

-            TransitionBetweenStates( A.right, blockEndNFAState, Label.EPSILON ); // follow is Transition 1
+            TransitionBetweenStates( A.Right, blockEndNFAState, Label.EPSILON ); // follow is Transition 1
// turn A's block end into a loopback (acts like alt 2)
-            TransitionBetweenStates( A.right, A.left, Label.EPSILON ); // loop back Transition 2
-            TransitionBetweenStates( left, A.left, Label.EPSILON );
+            TransitionBetweenStates( A.Right, A.Left, Label.EPSILON ); // loop back Transition 2
+            TransitionBetweenStates( left, A.Left, Label.EPSILON );

-            A.right.decisionStateType = NFAState.LOOPBACK;
-            A.left.decisionStateType = NFAState.BLOCK_START;
+            A.Right.decisionStateType = NFAState.LOOPBACK;
+            A.Left.decisionStateType = NFAState.BLOCK_START;

// set EOB markers for Jean
-            A.left.endOfBlockStateNumber = A.right.StateNumber;
+            A.Left.endOfBlockStateNumber = A.Right.StateNumber;

StateCluster g = new StateCluster( left, blockEndNFAState );
return g;
@@ -624,33 +622,33 @@ namespace Antlr3.Tool
blockEndNFAState.decisionStateType = NFAState.RIGHT_EDGE_OF_BLOCK;

// don't reuse A.right as loopback if it's right edge of another block
-            if ( A.right.decisionStateType == NFAState.RIGHT_EDGE_OF_BLOCK )
+            if ( A.Right.decisionStateType == NFAState.RIGHT_EDGE_OF_BLOCK )
{
// nested A* so make another tail node to be the loop back
// instead of the usual A.right which is the EOB for inner loop
NFAState extraRightEdge = NewState();
-                TransitionBetweenStates( A.right, extraRightEdge, Label.EPSILON );
-                A.right = extraRightEdge;
+                TransitionBetweenStates( A.Right, extraRightEdge, Label.EPSILON );
+                A.Right = extraRightEdge;
}

// convert A's end block to loopback
-            A.right.Description = "()* loopback";
+            A.Right.Description = "()* loopback";
// Transition 1 to actual block of stuff
-            TransitionBetweenStates( bypassDecisionState, A.left, Label.EPSILON );
+            TransitionBetweenStates( bypassDecisionState, A.Left, Label.EPSILON );
// Transition 2 optional to bypass
TransitionBetweenStates( bypassDecisionState, optionalAlt, Label.EPSILON );
TransitionBetweenStates( optionalAlt, blockEndNFAState, Label.EPSILON );
// Transition 1 of end block exits
-            TransitionBetweenStates( A.right, blockEndNFAState, Label.EPSILON );
+            TransitionBetweenStates( A.Right, blockEndNFAState, Label.EPSILON );
// Transition 2 of end block loops
-            TransitionBetweenStates( A.right, A.left, Label.EPSILON );
+            TransitionBetweenStates( A.Right, A.Left, Label.EPSILON );

bypassDecisionState.decisionStateType = NFAState.BYPASS;
-            A.left.decisionStateType = NFAState.BLOCK_START;
-            A.right.decisionStateType = NFAState.LOOPBACK;
+            A.Left.decisionStateType = NFAState.BLOCK_START;
+            A.Right.decisionStateType = NFAState.LOOPBACK;

// set EOB markers for Jean
-            A.left.endOfBlockStateNumber = A.right.StateNumber;
+            A.Left.endOfBlockStateNumber = A.Right.StateNumber;
bypassDecisionState.endOfBlockStateNumber = blockEndNFAState.StateNumber;

StateCluster g = new StateCluster( bypassDecisionState, blockEndNFAState );
@@ -730,7 +728,7 @@ namespace Antlr3.Tool
NFAState right = NewState();
left.associatedASTNode = associatedAST;
right.associatedASTNode = associatedAST;
-            Label label = new Label( nfa.grammar.TokenTypes ); // char or tokens
+            Label label = new Label( _nfa.Grammar.TokenTypes ); // char or tokens
Transition e = new Transition( label, right );
left.AddTransition( e );
StateCluster g = new StateCluster( left, right );
diff --git a/Antlr3/Tool/NameSpaceChecker.cs b/Antlr3/Tool/NameSpaceChecker.cs
index 4afbdd4..43d0ea1 100644
--- a/Antlr3/Tool/NameSpaceChecker.cs
+++ b/Antlr3/Tool/NameSpaceChecker.cs
@@ -49,9 +49,9 @@ namespace Antlr3.Tool

public virtual void CheckConflicts()
{
-            for ( int i = CompositeGrammar.MinRuleIndex; i < grammar.composite.ruleIndexToRuleList.Count; i++ )
+            for ( int i = CompositeGrammar.MinRuleIndex; i < grammar.composite.RuleIndexToRuleList.Count; i++ )
{
-                Rule r = grammar.composite.ruleIndexToRuleList[i];
+                Rule r = grammar.composite.RuleIndexToRuleList[i];
if ( r == null )
{
continue;
@@ -168,7 +168,7 @@ namespace Antlr3.Tool
foreach ( IToken tok in grammar.tokenIDRefs )
{
string tokenID = tok.Text;
-                    if ( !grammar.composite.lexerRules.Contains( tokenID ) &&
+                    if ( !grammar.composite.LexerRules.Contains( tokenID ) &&
grammar.GetTokenType( tokenID ) != Label.EOF )
{
ErrorManager.GrammarWarning( ErrorManager.MSG_NO_TOKEN_DEFINITION,
diff --git a/Antlr3/Tool/NonRegularDecisionMessage.cs b/Antlr3/Tool/NonRegularDecisionMessage.cs
index e951946..9ca94e9 100644
--- a/Antlr3/Tool/NonRegularDecisionMessage.cs
+++ b/Antlr3/Tool/NonRegularDecisionMessage.cs
@@ -53,17 +53,17 @@ namespace Antlr3.Tool

public override string ToString()
{
-            GrammarAST decisionASTNode = probe.dfa.DecisionASTNode;
+            GrammarAST decisionASTNode = probe.Dfa.DecisionASTNode;
line = decisionASTNode.Line;
charPositionInLine = decisionASTNode.CharPositionInLine;
-            string fileName = probe.dfa.nfa.grammar.FileName;
+            string fileName = probe.Dfa.Nfa.Grammar.FileName;
if ( fileName != null )
{
file = fileName;
}

StringTemplate st = GetMessageTemplate();
-            string ruleName = probe.dfa.NFADecisionStartState.enclosingRule.Name;
+            string ruleName = probe.Dfa.NFADecisionStartState.enclosingRule.Name;
st.SetAttribute( "ruleName", ruleName );
List<int> sortedAlts = new List<int>();
sortedAlts.AddRange( altsWithRecursion );
diff --git a/Antlr3/Tool/RecursionOverflowMessage.cs b/Antlr3/Tool/RecursionOverflowMessage.cs
index f84e4e0..a00cb2f 100644
--- a/Antlr3/Tool/RecursionOverflowMessage.cs
+++ b/Antlr3/Tool/RecursionOverflowMessage.cs
@@ -66,10 +66,10 @@ namespace Antlr3.Tool

public override String ToString()
{
-            GrammarAST decisionASTNode = probe.dfa.DecisionASTNode;
+            GrammarAST decisionASTNode = probe.Dfa.DecisionASTNode;
line = decisionASTNode.Line;
charPositionInLine = decisionASTNode.CharPositionInLine;
-            String fileName = probe.dfa.nfa.grammar.FileName;
+            String fileName = probe.Dfa.Nfa.Grammar.FileName;
if ( fileName != null )
{
file = fileName;
diff --git a/Antlr3/Tool/Rule.cs b/Antlr3/Tool/Rule.cs
index 4d825e2..dc89319 100644
--- a/Antlr3/Tool/Rule.cs
+++ b/Antlr3/Tool/Rule.cs
@@ -1037,7 +1037,7 @@ namespace Antlr3.Tool
}
if ( key == "backtrack" && value.ToString() == "true" )
{
-                Grammar.composite.GetRootGrammar().atLeastOneBacktrackOption = true;
+                Grammar.composite.RootGrammar.atLeastOneBacktrackOption = true;
}
if ( key.Equals( "k" ) )
{
diff --git a/Antlr3/Tool/RuleLabelScope.cs b/Antlr3/Tool/RuleLabelScope.cs
index d128806..a92a82d 100644
--- a/Antlr3/Tool/RuleLabelScope.cs
+++ b/Antlr3/Tool/RuleLabelScope.cs
@@ -55,14 +55,14 @@ namespace Antlr3.Tool
predefinedRulePropertiesScope.AddAttribute( "stop", null );
predefinedRulePropertiesScope.AddAttribute( "tree", null );
predefinedRulePropertiesScope.AddAttribute( "st", null );
-            predefinedRulePropertiesScope.isPredefinedRuleScope = true;
+            predefinedRulePropertiesScope.IsPredefinedRuleScope = true;

predefinedTreeRulePropertiesScope = new AttributeScope( "RulePredefined", null );
predefinedTreeRulePropertiesScope.AddAttribute( "text", null );
predefinedTreeRulePropertiesScope.AddAttribute( "start", null ); // note: no stop; not meaningful
predefinedTreeRulePropertiesScope.AddAttribute( "tree", null );
predefinedTreeRulePropertiesScope.AddAttribute( "st", null );
-            predefinedTreeRulePropertiesScope.isPredefinedRuleScope = true;
+            predefinedTreeRulePropertiesScope.IsPredefinedRuleScope = true;

predefinedLexerRulePropertiesScope = new AttributeScope( "LexerRulePredefined", null );
predefinedLexerRulePropertiesScope.AddAttribute( "text", null );
@@ -74,7 +74,7 @@ namespace Antlr3.Tool
predefinedLexerRulePropertiesScope.AddAttribute( "start", null );
predefinedLexerRulePropertiesScope.AddAttribute( "stop", null );
predefinedLexerRulePropertiesScope.AddAttribute( "int", null );
-            predefinedLexerRulePropertiesScope.isPredefinedLexerRuleScope = true;
+            predefinedLexerRulePropertiesScope.IsPredefinedLexerRuleScope = true;

grammarTypeToRulePropertiesScope =
new AttributeScope[]

