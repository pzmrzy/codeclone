commit 9559595e04a719882065a583229527df9bf4972b
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Thu Jul 30 13:59:06 2009 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Thu Jul 30 13:59:06 2009 -0800

Antlr3.StringTemplate:
* Merge CL 6135, 6136: Fixed if-false-yields-empty issue; added unit tests
* Merge CL 6140, 6141: <\\> operator, unit tests
* Merge CL 6142: x={<(...)>} as default arg evals early

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 6156]

diff --git a/Antlr3.StringTemplate/Language/ASTExpr.cs b/Antlr3.StringTemplate/Language/ASTExpr.cs
index 7ecd6e9..517164c 100644
--- a/Antlr3.StringTemplate/Language/ASTExpr.cs
+++ b/Antlr3.StringTemplate/Language/ASTExpr.cs
@@ -64,6 +64,8 @@ namespace Antlr3.ST.Language
*/
public class ASTExpr : Expr
{
+        // writing -1 char means missing, not empty
+        public const int Missing = -1;
public const string DefaultAttributeName = "it";
public const string DefaultAttributeNameDeprecated = "attr";
public const string DefaultIndexVariableName = "i";
@@ -946,126 +948,205 @@ namespace Antlr3.ST.Language
{
if ( _nullValue == null )
{
-                    return 0;
+                    return Missing;
}
o = _nullValue; // continue with null option if specified
}
-            int n = 0;
+
try
{
StringTemplate stToWrite = o as StringTemplate;
-                if ( stToWrite != null )
+                if (stToWrite != null)
+                    return WriteTemplate(self, stToWrite, @out);
+
+                // normalize
+                o = ConvertAnythingIteratableToIterator(o);
+                Iterator iter = o as Iterator;
+                if (iter != null)
+                    return WriteIterableValue(self, iter, @out);
+
+                return WriteObject(self, o, @out);
+            }
+            catch ( IOException io )
+            {
+                self.Error( "problem writing object: " + o, io );
+                return 0;
+            }
+        }
+
+        protected virtual int WriteObject(StringTemplate self, object o, IStringTemplateWriter @out)
+        {
+            int n = 0;
+            IAttributeRenderer renderer = self.GetAttributeRenderer(o.GetType());
+            string v = null;
+            if (renderer != null)
+            {
+                if (_formatString != null)
+                    v = renderer.ToString(o, _formatString);
+                else
+                    v = renderer.ToString(o);
+            }
+            else
+            {
+                v = o.ToString();
+            }
+
+            if (_wrapString != null)
+                n = @out.Write(v, _wrapString);
+            else
+                n = @out.Write(v);
+
+            return n;
+        }
+
+        protected virtual int WriteTemplate(StringTemplate self, StringTemplate stToWrite, IStringTemplateWriter @out)
+        {
+            int n = 0;
+            /* failsafe: perhaps enclosing instance not set
+             * Or, it could be set to another context!  This occurs
+             * when you store a template instance as an attribute of more
+             * than one template (like both a header file and C file when
+             * generating C code).  It must execute within the context of
+             * the enclosing template.
+             */
+            stToWrite.EnclosingInstance = self;
+            // if self is found up the enclosing instance chain, then infinite recursion
+            if (StringTemplate.LintMode && StringTemplate.IsRecursiveEnclosingInstance(stToWrite))
+            {
+                // throw exception since sometimes eval keeps going even after I ignore this write of o.
+                throw new InvalidOperationException("infinite recursion to " +
+                        stToWrite.GetTemplateDeclaratorString() + " referenced in " +
+                        stToWrite.EnclosingInstance.TemplateDeclaratorString +
+                        "; stack trace:" + Environment.NewLine + stToWrite.GetEnclosingInstanceStackTrace());
+            }
+            else
+            {
+                // if we have a wrap string, then inform writer it might need to wrap
+                if (_wrapString != null)
{
-                    // failsafe: perhaps enclosing instance not set
-                    // Or, it could be set to another context!  This occurs
-                    // when you store a template instance as an attribute of more
-                    // than one template (like both a header file and C file when
-                    // generating C code).  It must execute within the context of
-                    // the enclosing template.
-                    stToWrite.EnclosingInstance = self;
-                    // if self is found up the enclosing instance chain, then
-                    // infinite recursion
-                    if ( StringTemplate.LintMode &&
-                         StringTemplate.IsRecursiveEnclosingInstance( stToWrite ) )
+                    n = @out.WriteWrapSeparator(_wrapString);
+                }
+
+                // check if formatting needs to be applied to the stToWrite
+                if (_formatString != null)
+                {
+                    IAttributeRenderer renderer = self.GetAttributeRenderer(typeof(string));
+                    if (renderer != null)
{
-                        // throw exception since sometimes eval keeps going
-                        // even after I ignore this write of o.
-                        throw new InvalidOperationException( "infinite recursion to " +
-                                stToWrite.GetTemplateDeclaratorString() + " referenced in " +
-                                stToWrite.EnclosingInstance.GetTemplateDeclaratorString() +
-                                "; stack trace:" + Environment.NewLine + stToWrite.GetEnclosingInstanceStackTrace() );
+                        /* you pay a penalty for applying format option to a template
+                         * because the template must be written to a temp StringWriter so it can
+                         * be formatted before being written to the real output.
+                         */
+                        StringWriter buf = new StringWriter();
+                        IStringTemplateWriter sw = self.Group.GetStringTemplateWriter(buf);
+                        stToWrite.Write(sw);
+                        n = @out.Write(renderer.ToString(buf.ToString(), _formatString));
+                        return n;
}
-                    else
-                    {
-                        // if we have a wrap string, then inform writer it
-                        // might need to wrap
-                        if ( _wrapString != null )
-                        {
-                            n = @out.WriteWrapSeparator( _wrapString );
-                        }
-                        // check if formatting needs to be applied to the stToWrite
-                        if ( _formatString != null )
-                        {
-                            IAttributeRenderer renderer =
-                                self.GetAttributeRenderer( typeof( string ) );
-                            if ( renderer != null )
-                            {
-                                // you pay a penalty for applying format option to a template
-                                // because the template must be written to a temp StringWriter so it can
-                                // be formatted before being written to the real output.
-                                StringWriter buf = new StringWriter();
-                                IStringTemplateWriter sw =
-                                    self.Group.GetStringTemplateWriter( buf );
-                                stToWrite.Write( sw );
-                                n = @out.Write( renderer.ToString( buf.ToString(), _formatString ) );
-                                return n;
-                            }
-                        }
-                        n = stToWrite.Write( @out );
-                    }
-                    return n;
}
-                // normalize anything iteratable to iterator
-                o = ConvertAnythingIteratableToIterator( o );
-                if ( o is Iterator )
+
+                n = stToWrite.Write(@out);
+            }
+
+            return n;
+        }
+
+        protected virtual int WriteIterableValue(StringTemplate self, Iterator iter, IStringTemplateWriter @out)
+        {
+            int n = 0;
+            bool seenAValue = false;
+            while (iter.hasNext())
+            {
+                object iterValue = iter.next() ?? _nullValue;
+
+                if (iterValue != null)
{
-                    Iterator iter = (Iterator)o;
-                    bool seenPrevValue = false;
-                    while ( iter.hasNext() )
+                    // if no separator or separator but iterValue isn't a single IF condition template
+                    if (_separatorString == null)
+                    {
+                        // if no separator, don't waste time writing to temp buffer
+                        int nw = Write(self, iterValue, @out);
+                        if (nw != Missing)
+                            n += nw;
+
+                        continue;
+                    }
+
+                    /* if value to emit is a template, only buffer its
+                     * value if it's nullable (can eval to missing).
+                     * Only a sequence of IF can eval to missing.
+                     */
+                    StringTemplate st = iterValue as StringTemplate;
+                    if (st != null)
{
-                        object iterValue = iter.next();
-                        if ( iterValue == null )
+                        int nchunks = st.Chunks != null ? st.Chunks.Count : 0;
+                        bool nullable = true;
+                        for (int i = 0; i < nchunks; i++)
{
-                            iterValue = _nullValue;
+                            Expr a = st.Chunks[i];
+                            if (!(a is ConditionalExpr))
+                                nullable = false;
}
-                        if ( iterValue != null )
+
+                        // if not all IF, not nullable, spit out w/o buffering
+                        if (!nullable)
{
-                            if ( seenPrevValue /*prevIterValue!=null*/
-                                && _separatorString != null )
+                            if (seenAValue && _separatorString != null)
{
-                                n += @out.WriteSeparator( _separatorString );
+                                n += @out.WriteSeparator(_separatorString);
}
-                            seenPrevValue = true;
-                            int nw = Write( self, iterValue, @out );
+
+                            int nw = Write(self, iterValue, @out);
n += nw;
+                            seenAValue = true;
+                            continue;
}
}
-                }
-                else
-                {
-                    IAttributeRenderer renderer =
-                        self.GetAttributeRenderer( o.GetType() );
-                    string v = null;
-                    if ( renderer != null )
+                    else if (!(iterValue is Iterator))
{
-                        if ( _formatString != null )
+                        // if not possible to be missing, don't waste time
+                        // writing to temp buffer; might need separator though
+                        if (seenAValue && _separatorString != null)
{
-                            v = renderer.ToString( o, _formatString );
+                            n += @out.WriteSeparator(_separatorString);
}
-                        else
-                        {
-                            v = renderer.ToString( o );
-                        }
-                    }
-                    else
-                    {
-                        v = o.ToString();
-                    }
-                    if ( _wrapString != null )
-                    {
-                        n = @out.Write( v, _wrapString );
+
+                        int nw = Write(self, iterValue, @out);
+                        seenAValue = true;
+                        n += nw;
+                        continue;
}
-                    else
+
+                    /* if separator exists, write iterated value to a
+                     * tmp buffer in case we don't need a separator.
+                     * Can't generate separator then test next expr value
+                     * as we can't undo separator emit.
+                     * Write to dummy buffer to if it is MISSING
+                     * but eval/write value again to real out so
+                     * we get proper autowrap etc...
+                     * Ack: you pay a penalty now for a separator
+                     * Later, i can optimze to check if one chunk and
+                     * it's a conditional
+                     */
+                    StringWriter buf = new StringWriter();
+                    IStringTemplateWriter sw = self.Group.GetStringTemplateWriter(buf);
+                    int tmpsize = Write(self, iterValue, sw);
+
+                    if (tmpsize != Missing)
{
-                        n = @out.Write( v );
+                        if (seenAValue && _separatorString != null)
+                        {
+                            n += @out.WriteSeparator(_separatorString);
+                        }
+
+                        // do it to real output stream now
+                        int nw = Write(self, iterValue, @out);
+                        n += nw;
+                        seenAValue = true;
}
-                    return n;
}
}
-            catch ( IOException io )
-            {
-                self.Error( "problem writing object: " + o, io );
-            }
+
return n;
}

@@ -1081,7 +1162,7 @@ namespace Antlr3.ST.Language
*  all the time; must precompute w/o writing to output buffer.
*  </summary>
*/
-        protected virtual string EvaluateExpression( StringTemplate self,
+        public virtual string EvaluateExpression( StringTemplate self,
object expr )
{
if ( expr == null )
diff --git a/Antlr3.StringTemplate/Language/Action.g3 b/Antlr3.StringTemplate/Language/Action.g3
index ecce1c9..6893d08 100644
--- a/Antlr3.StringTemplate/Language/Action.g3
+++ b/Antlr3.StringTemplate/Language/Action.g3
@@ -147,7 +147,7 @@ action returns [IDictionary<string, object> opts=null]
|	'if'^ LPAREN! ifCondition RPAREN!
|	'elseif'! LPAREN! ifCondition RPAREN! // return just conditional
)
-		EOF
+		EOF!
;

optionList! returns [IDictionary<string, object> opts=new Dictionary<string, object>()]
diff --git a/Antlr3.StringTemplate/Language/ActionParser.cs b/Antlr3.StringTemplate/Language/ActionParser.cs
index dc52cd1..13679ee 100644
--- a/Antlr3.StringTemplate/Language/ActionParser.cs
+++ b/Antlr3.StringTemplate/Language/ActionParser.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Language\\Action.g3 2009-04-18 02:24:05
+// $ANTLR 3.1.2 Language\\Action.g3 2009-07-30 16:11:23

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -54,7 +54,7 @@ namespace  Antlr3.ST.Language
{
public partial class ActionParser : Parser
{
-	public static readonly string[] tokenNames = new string[] {
+	internal static readonly string[] tokenNames = new string[] {
"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ANONYMOUS_TEMPLATE", "APPLY", "ARGS", "ASSIGN", "COLON", "COMMA", "CONDITIONAL", "DOT", "DOTDOTDOT", "ELSEIF", "ESC_CHAR", "FIRST", "FUNCTION", "ID", "INCLUDE", "INT", "LAST", "LBRACK", "LENGTH", "LIST", "LPAREN", "MULTI_APPLY", "NESTED_ANONYMOUS_TEMPLATE", "NEWLINE", "NOT", "NOTHING", "PLUS", "RBRACK", "REST", "RPAREN", "SEMI", "SINGLEVALUEARG", "STRING", "STRIP", "SUPER", "TEMPLATE", "TEMPLATE_ARGS", "TRUNC", "VALUE", "WS", "WS_CHAR"
};
public const int EOF=-1;
@@ -139,7 +139,7 @@ public partial class ActionParser : Parser
public class action_return : ParserRuleReturnScope
{
public IDictionary<string, object> opts=null;
-		public StringTemplateAST tree;
+		internal StringTemplateAST tree;
public override object Tree { get { return tree; } }
}

@@ -303,10 +303,6 @@ public partial class ActionParser : Parser
}

EOF12=(IToken)Match(input,EOF,Follow._EOF_in_action241); if (state.failed) return retval;
-			if ( state.backtracking==0 ) {
-			EOF12_tree = (StringTemplateAST)adaptor.Create(EOF12);
-			adaptor.AddChild(root_0, EOF12_tree);
-			}

}

@@ -335,7 +331,7 @@ public partial class ActionParser : Parser
public class optionList_return : ParserRuleReturnScope
{
public IDictionary<string, object> opts=new Dictionary<string, object>();
-		public StringTemplateAST tree;
+		internal StringTemplateAST tree;
public override object Tree { get { return tree; } }
}

@@ -361,7 +357,7 @@ public partial class ActionParser : Parser
{
root_0 = (StringTemplateAST)adaptor.Nil();

-			PushFollow(Follow._option_in_optionList257);
+			PushFollow(Follow._option_in_optionList258);
option13=option(retval.opts);

state._fsp--;
@@ -384,12 +380,12 @@ public partial class ActionParser : Parser
case 1:
// Language\\Action.g3:154:19: COMMA option[$opts]
{
-					COMMA14=(IToken)Match(input,COMMA,Follow._COMMA_in_optionList261); if (state.failed) return retval;
+					COMMA14=(IToken)Match(input,COMMA,Follow._COMMA_in_optionList262); if (state.failed) return retval;
if ( state.backtracking==0 ) {
COMMA14_tree = (StringTemplateAST)adaptor.Create(COMMA14);
adaptor.AddChild(root_0, COMMA14_tree);
}
-					PushFollow(Follow._option_in_optionList263);
+					PushFollow(Follow._option_in_optionList264);
option15=option(retval.opts);

state._fsp--;
@@ -435,7 +431,7 @@ public partial class ActionParser : Parser

public class option_return : ParserRuleReturnScope
{
-		public StringTemplateAST tree;
+		internal StringTemplateAST tree;
public override object Tree { get { return tree; } }
}

@@ -465,7 +461,7 @@ public partial class ActionParser : Parser
{
root_0 = (StringTemplateAST)adaptor.Nil();

-			ID16=(IToken)Match(input,ID,Follow._ID_in_option283); if (state.failed) return retval;
+			ID16=(IToken)Match(input,ID,Follow._ID_in_option284); if (state.failed) return retval;
if ( state.backtracking==0 ) {
ID16_tree = (StringTemplateAST)adaptor.Create(ID16);
adaptor.AddChild(root_0, ID16_tree);
@@ -494,12 +490,12 @@ public partial class ActionParser : Parser
case 1:
// Language\\Action.g3:163:5: ASSIGN nonAlternatingTemplateExpr
{
-				ASSIGN17=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_option289); if (state.failed) return retval;
+				ASSIGN17=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_option290); if (state.failed) return retval;
if ( state.backtracking==0 ) {
ASSIGN17_tree = (StringTemplateAST)adaptor.Create(ASSIGN17);
adaptor.AddChild(root_0, ASSIGN17_tree);
}
-				PushFollow(Follow._nonAlternatingTemplateExpr_in_option291);
+				PushFollow(Follow._nonAlternatingTemplateExpr_in_option292);
nonAlternatingTemplateExpr18=nonAlternatingTemplateExpr();

state._fsp--;
@@ -507,7 +503,7 @@ public partial class ActionParser : Parser
if ( state.backtracking == 0 ) adaptor.AddChild(root_0, nonAlternatingTemplateExpr18.Tree);
if ( state.backtracking == 0 )
{
-					v=(nonAlternatingTemplateExpr18!=null?((StringTemplateAST)nonAlternatingTemplateExpr18.tree):null);
+					v=(nonAlternatingTemplateExpr18!=null?((StringTemplateAST)nonAlternatingTemplateExpr18.Tree):null);
}

}
@@ -556,7 +552,7 @@ public partial class ActionParser : Parser

public class templatesExpr_return : ParserRuleReturnScope
{
-		public StringTemplateAST tree;
+		internal StringTemplateAST tree;
public override object Tree { get { return tree; } }
}

@@ -588,7 +584,7 @@ public partial class ActionParser : Parser
// Language\\Action.g3:171:3: ( expr ( ( COMMA expr )+ colon= COLON anonymousTemplate -> ^( MULTI_APPLY[\"MULTI_APPLY\"] ( expr )+ $colon anonymousTemplate ) | ( -> expr ) (colon= COLON templateList -> ^( APPLY[$colon] $templatesExpr templateList ) )* ) )
// Language\\Action.g3:171:3: expr ( ( COMMA expr )+ colon= COLON anonymousTemplate -> ^( MULTI_APPLY[\"MULTI_APPLY\"] ( expr )+ $colon anonymousTemplate ) | ( -> expr ) (colon= COLON templateList -> ^( APPLY[$colon] $templatesExpr templateList ) )* )
{
-			PushFollow(Follow._expr_in_templatesExpr321);
+			PushFollow(Follow._expr_in_templatesExpr322);
expr19=expr();

state._fsp--;
@@ -636,10 +632,10 @@ public partial class ActionParser : Parser
case 1:
// Language\\Action.g3:172:6: COMMA expr
{
-						COMMA20=(IToken)Match(input,COMMA,Follow._COMMA_in_templatesExpr328); if (state.failed) return retval;
+						COMMA20=(IToken)Match(input,COMMA,Follow._COMMA_in_templatesExpr329); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_COMMA.Add(COMMA20);

-						PushFollow(Follow._expr_in_templatesExpr330);
+						PushFollow(Follow._expr_in_templatesExpr331);
expr21=expr();

state._fsp--;
@@ -663,10 +659,10 @@ public partial class ActionParser : Parser
;


-				colon=(IToken)Match(input,COLON,Follow._COLON_in_templatesExpr336); if (state.failed) return retval;
+				colon=(IToken)Match(input,COLON,Follow._COLON_in_templatesExpr337); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_COLON.Add(colon);

-				PushFollow(Follow._anonymousTemplate_in_templatesExpr338);
+				PushFollow(Follow._anonymousTemplate_in_templatesExpr339);
anonymousTemplate22=anonymousTemplate();

state._fsp--;
@@ -770,10 +766,10 @@ public partial class ActionParser : Parser
case 1:
// Language\\Action.g3:176:6: colon= COLON templateList
{
-						colon=(IToken)Match(input,COLON,Follow._COLON_in_templatesExpr380); if (state.failed) return retval;
+						colon=(IToken)Match(input,COLON,Follow._COLON_in_templatesExpr381); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_COLON.Add(colon);

-						PushFollow(Follow._templateList_in_templatesExpr382);
+						PushFollow(Follow._templateList_in_templatesExpr383);
templateList23=templateList();

state._fsp--;
@@ -858,7 +854,7 @@ public partial class ActionParser : Parser

public class templateList_return : ParserRuleReturnScope
{
-		public StringTemplateAST tree;
+		internal StringTemplateAST tree;
public override object Tree { get { return tree; } }
}

@@ -884,7 +880,7 @@ public partial class ActionParser : Parser
{
root_0 = (StringTemplateAST)adaptor.Nil();

-			PushFollow(Follow._template_in_templateList421);
+			PushFollow(Follow._template_in_templateList422);
template24=template();

state._fsp--;
@@ -907,8 +903,8 @@ public partial class ActionParser : Parser
case 1:
// Language\\Action.g3:183:14: COMMA template
{
-					COMMA25=(IToken)Match(input,COMMA,Follow._COMMA_in_templateList424); if (state.failed) return retval;
-					PushFollow(Follow._template_in_templateList427);
+					COMMA25=(IToken)Match(input,COMMA,Follow._COMMA_in_templateList425); if (state.failed) return retval;
+					PushFollow(Follow._template_in_templateList428);
template26=template();

state._fsp--;
@@ -954,7 +950,7 @@ public partial class ActionParser : Parser

public class ifCondition_return : ParserRuleReturnScope
{
-		public StringTemplateAST tree;
+		internal StringTemplateAST tree;
public override object Tree { get { return tree; } }
}

@@ -1001,7 +997,7 @@ public partial class ActionParser : Parser
{
root_0 = (StringTemplateAST)adaptor.Nil();

-				PushFollow(Follow._ifAtom_in_ifCondition440);
+				PushFollow(Follow._ifAtom_in_ifCondition441);
ifAtom27=ifAtom();

state._fsp--;
@@ -1015,12 +1011,12 @@ public partial class ActionParser : Parser
{
root_0 = (StringTemplateAST)adaptor.Nil();

-				NOT28=(IToken)Match(input,NOT,Follow._NOT_in_ifCondition445); if (state.failed) return retval;
+				NOT28=(IToken)Match(input,NOT,Follow._NOT_in_ifCondition446); if (state.failed) return retval;
if ( state.backtracking == 0 ) {
NOT28_tree = (StringTemplateAST)adaptor.Create(NOT28);
root_0 = (StringTemplateAST)adaptor.BecomeRoot(NOT28_tree, root_0);
}
-				PushFollow(Follow._ifAtom_in_ifCondition448);
+				PushFollow(Follow._ifAtom_in_ifCondition449);
ifAtom29=ifAtom();

state._fsp--;
@@ -1055,7 +1051,7 @@ public partial class ActionParser : Parser

public class ifAtom_return : ParserRuleReturnScope
{
-		public StringTemplateAST tree;
+		internal StringTemplateAST tree;
public override object Tree { get { return tree; } }
}

@@ -1078,7 +1074,7 @@ public partial class ActionParser : Parser
{
root_0 = (StringTemplateAST)adaptor.Nil();

-			PushFollow(Follow._templatesExpr_in_ifAtom459);
+			PushFollow(Follow._templatesExpr_in_ifAtom460);
templatesExpr30=templatesExpr();

state._fsp--;
@@ -1111,7 +1107,7 @@ public partial class ActionParser : Parser

public class expr_return : ParserRuleReturnScope
{
-		public StringTemplateAST tree;
+		internal StringTemplateAST tree;
public override object Tree { get { return tree; } }
}

@@ -1137,7 +1133,7 @@ public partial class ActionParser : Parser
{
root_0 = (StringTemplateAST)adaptor.Nil();

-			PushFollow(Follow._primaryExpr_in_expr470);
+			PushFollow(Follow._primaryExpr_in_expr471);
primaryExpr31=primaryExpr();

state._fsp--;
@@ -1160,12 +1156,12 @@ public partial class ActionParser : Parser
case 1:
// Language\\Action.g3:196:17: PLUS primaryExpr
{
-					PLUS32=(IToken)Match(input,PLUS,Follow._PLUS_in_expr473); if (state.failed) return retval;
+					PLUS32=(IToken)Match(input,PLUS,Follow._PLUS_in_expr474); if (state.failed) return retval;
if ( state.backtracking == 0 ) {
PLUS32_tree = (StringTemplateAST)adaptor.Create(PLUS32);
root_0 = (StringTemplateAST)adaptor.BecomeRoot(PLUS32_tree, root_0);
}
-					PushFollow(Follow._primaryExpr_in_expr476);
+					PushFollow(Follow._primaryExpr_in_expr477);
primaryExpr33=primaryExpr();

state._fsp--;
@@ -1211,7 +1207,7 @@ public partial class ActionParser : Parser

public class primaryExpr_return : ParserRuleReturnScope
{
-		public StringTemplateAST tree;
+		internal StringTemplateAST tree;
public override object Tree { get { return tree; } }
}

@@ -1254,7 +1250,7 @@ public partial class ActionParser : Parser
root_0 = (StringTemplateAST)adaptor.Nil();


-				PushFollow(Follow._templateInclude_in_primaryExpr493);
+				PushFollow(Follow._templateInclude_in_primaryExpr494);
templateInclude34=templateInclude();

state._fsp--;
@@ -1268,7 +1264,7 @@ public partial class ActionParser : Parser
{
root_0 = (StringTemplateAST)adaptor.Nil();

-				PushFollow(Follow._atom_in_primaryExpr500);
+				PushFollow(Follow._atom_in_primaryExpr501);
atom35=atom();

state._fsp--;
@@ -1291,7 +1287,7 @@ public partial class ActionParser : Parser
case 1:
// Language\\Action.g3:202:5: DOT ( ID | valueExpr )
{
-						DOT36=(IToken)Match(input,DOT,Follow._DOT_in_primaryExpr506); if (state.failed) return retval;
+						DOT36=(IToken)Match(input,DOT,Follow._DOT_in_primaryExpr507); if (state.failed) return retval;
if ( state.backtracking == 0 ) {
DOT36_tree = (StringTemplateAST)adaptor.Create(DOT36);
root_0 = (StringTemplateAST)adaptor.BecomeRoot(DOT36_tree, root_0);
@@ -1320,7 +1316,7 @@ public partial class ActionParser : Parser
case 1:
// Language\\Action.g3:203:6: ID
{
-							ID37=(IToken)Match(input,ID,Follow._ID_in_primaryExpr515); if (state.failed) return retval;
+							ID37=(IToken)Match(input,ID,Follow._ID_in_primaryExpr516); if (state.failed) return retval;
if ( state.backtracking==0 ) {
ID37_tree = (StringTemplateAST)adaptor.Create(ID37);
adaptor.AddChild(root_0, ID37_tree);
@@ -1331,7 +1327,7 @@ public partial class ActionParser : Parser
case 2:
// Language\\Action.g3:204:6: valueExpr
{
-							PushFollow(Follow._valueExpr_in_primaryExpr522);
+							PushFollow(Follow._valueExpr_in_primaryExpr523);
valueExpr38=valueExpr();

state._fsp--;
@@ -1364,7 +1360,7 @@ public partial class ActionParser : Parser
{
root_0 = (StringTemplateAST)adaptor.Nil();

-				PushFollow(Follow._function_in_primaryExpr537);
+				PushFollow(Follow._function_in_primaryExpr538);
function39=function();

state._fsp--;
@@ -1387,7 +1383,7 @@ public partial class ActionParser : Parser
case 1:
// Language\\Action.g3:208:5: DOT ( ID | valueExpr )
{
-						DOT40=(IToken)Match(input,DOT,Follow._DOT_in_primaryExpr543); if (state.failed) return retval;
+						DOT40=(IToken)Match(input,DOT,Follow._DOT_in_primaryExpr544); if (state.failed) return retval;
if ( state.backtracking == 0 ) {
DOT40_tree = (StringTemplateAST)adaptor.Create(DOT40);
root_0 = (StringTemplateAST)adaptor.BecomeRoot(DOT40_tree, root_0);
@@ -1416,7 +1412,7 @@ public partial class ActionParser : Parser
case 1:
// Language\\Action.g3:209:6: ID
{
-							ID41=(IToken)Match(input,ID,Follow._ID_in_primaryExpr551); if (state.failed) return retval;
+							ID41=(IToken)Match(input,ID,Follow._ID_in_primaryExpr552); if (state.failed) return retval;
if ( state.backtracking==0 ) {
ID41_tree = (StringTemplateAST)adaptor.Create(ID41);
adaptor.AddChild(root_0, ID41_tree);
@@ -1427,7 +1423,7 @@ public partial class ActionParser : Parser
case 2:
// Language\\Action.g3:210:6: valueExpr
{
-							PushFollow(Follow._valueExpr_in_primaryExpr558);
+							PushFollow(Follow._valueExpr_in_primaryExpr559);
valueExpr42=valueExpr();

state._fsp--;
@@ -1460,7 +1456,7 @@ public partial class ActionParser : Parser
{
root_0 = (StringTemplateAST)adaptor.Nil();

-				PushFollow(Follow._valueExpr_in_primaryExpr573);
+				PushFollow(Follow._valueExpr_in_primaryExpr574);
valueExpr43=valueExpr();

state._fsp--;
@@ -1474,7 +1470,7 @@ public partial class ActionParser : Parser
{
root_0 = (StringTemplateAST)adaptor.Nil();

-				PushFollow(Follow._list_in_primaryExpr578);
+				PushFollow(Follow._list_in_primaryExpr579);
list44=list();

state._fsp--;
@@ -1509,7 +1505,7 @@ public partial class ActionParser : Parser

public class valueExpr_return : ParserRuleReturnScope
{
-		public StringTemplateAST tree;
+		internal StringTemplateAST tree;
public override object Tree { get { return tree; } }
}

@@ -1536,16 +1532,16 @@ public partial class ActionParser : Parser
// Language\\Action.g3:218:4: ( LPAREN templatesExpr RPAREN -> ^( VALUE[$LPAREN,\"value\"] templatesExpr ) )
// Language\\Action.g3:218:4: LPAREN templatesExpr RPAREN
{
-			LPAREN45=(IToken)Match(input,LPAREN,Follow._LPAREN_in_valueExpr589); if (state.failed) return retval;
+			LPAREN45=(IToken)Match(input,LPAREN,Follow._LPAREN_in_valueExpr590); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_LPAREN.Add(LPAREN45);

-			PushFollow(Follow._templatesExpr_in_valueExpr591);
+			PushFollow(Follow._templatesExpr_in_valueExpr592);
templatesExpr46=templatesExpr();

state._fsp--;
if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_templatesExpr.Add(templatesExpr46.Tree);
-			RPAREN47=(IToken)Match(input,RPAREN,Follow._RPAREN_in_valueExpr593); if (state.failed) return retval;
+			RPAREN47=(IToken)Match(input,RPAREN,Follow._RPAREN_in_valueExpr594); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_RPAREN.Add(RPAREN47);


@@ -1607,7 +1603,7 @@ public partial class ActionParser : Parser

public class nonAlternatingTemplateExpr_return : ParserRuleReturnScope
{
-		public StringTemplateAST tree;
+		internal StringTemplateAST tree;
public override object Tree { get { return tree; } }
}

@@ -1636,7 +1632,7 @@ public partial class ActionParser : Parser
// Language\\Action.g3:223:4: ( expr -> expr )
// Language\\Action.g3:223:5: expr
{
-			PushFollow(Follow._expr_in_nonAlternatingTemplateExpr616);
+			PushFollow(Follow._expr_in_nonAlternatingTemplateExpr617);
expr48=expr();

state._fsp--;
@@ -1686,10 +1682,10 @@ public partial class ActionParser : Parser
case 1:
// Language\\Action.g3:223:21: COLON template
{
-					COLON49=(IToken)Match(input,COLON,Follow._COLON_in_nonAlternatingTemplateExpr625); if (state.failed) return retval;
+					COLON49=(IToken)Match(input,COLON,Follow._COLON_in_nonAlternatingTemplateExpr626); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_COLON.Add(COLON49);

-					PushFollow(Follow._template_in_nonAlternatingTemplateExpr627);
+					PushFollow(Follow._template_in_nonAlternatingTemplateExpr628);
template50=template();

state._fsp--;
@@ -1768,7 +1764,7 @@ public partial class ActionParser : Parser

public class function_return : ParserRuleReturnScope
{
-		public StringTemplateAST tree;
+		internal StringTemplateAST tree;
public override object Tree { get { return tree; } }
}

@@ -1855,7 +1851,7 @@ public partial class ActionParser : Parser
case 1:
// Language\\Action.g3:227:6: 'first'
{
-				string_literal51=(IToken)Match(input,FIRST,Follow._FIRST_in_function655); if (state.failed) return retval;
+				string_literal51=(IToken)Match(input,FIRST,Follow._FIRST_in_function656); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_FIRST.Add(string_literal51);


@@ -1864,7 +1860,7 @@ public partial class ActionParser : Parser
case 2:
// Language\\Action.g3:228:5: 'rest'
{
-				string_literal52=(IToken)Match(input,REST,Follow._REST_in_function661); if (state.failed) return retval;
+				string_literal52=(IToken)Match(input,REST,Follow._REST_in_function662); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_REST.Add(string_literal52);


@@ -1873,7 +1869,7 @@ public partial class ActionParser : Parser
case 3:
// Language\\Action.g3:229:5: 'last'
{
-				string_literal53=(IToken)Match(input,LAST,Follow._LAST_in_function667); if (state.failed) return retval;
+				string_literal53=(IToken)Match(input,LAST,Follow._LAST_in_function668); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_LAST.Add(string_literal53);


@@ -1882,7 +1878,7 @@ public partial class ActionParser : Parser
case 4:
// Language\\Action.g3:230:5: 'length'
{
-				string_literal54=(IToken)Match(input,LENGTH,Follow._LENGTH_in_function673); if (state.failed) return retval;
+				string_literal54=(IToken)Match(input,LENGTH,Follow._LENGTH_in_function674); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_LENGTH.Add(string_literal54);


@@ -1891,7 +1887,7 @@ public partial class ActionParser : Parser
case 5:
// Language\\Action.g3:231:5: 'strip'
{
-				string_literal55=(IToken)Match(input,STRIP,Follow._STRIP_in_function679); if (state.failed) return retval;
+				string_literal55=(IToken)Match(input,STRIP,Follow._STRIP_in_function680); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_STRIP.Add(string_literal55);


@@ -1900,7 +1896,7 @@ public partial class ActionParser : Parser
case 6:
// Language\\Action.g3:232:5: 'trunc'
{
-				string_literal56=(IToken)Match(input,TRUNC,Follow._TRUNC_in_function685); if (state.failed) return retval;
+				string_literal56=(IToken)Match(input,TRUNC,Follow._TRUNC_in_function686); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_TRUNC.Add(string_literal56);


@@ -1909,7 +1905,7 @@ public partial class ActionParser : Parser

}

-			PushFollow(Follow._singleArg_in_function693);
+			PushFollow(Follow._singleArg_in_function694);
singleArg57=singleArg();

state._fsp--;
@@ -2016,7 +2012,7 @@ public partial class ActionParser : Parser

public class template_return : ParserRuleReturnScope
{
-		public StringTemplateAST tree;
+		internal StringTemplateAST tree;
public override object Tree { get { return tree; } }
}

@@ -2063,7 +2059,7 @@ public partial class ActionParser : Parser
case 1:
// Language\\Action.g3:239:6: namedTemplate
{
-				PushFollow(Follow._namedTemplate_in_template734);
+				PushFollow(Follow._namedTemplate_in_template735);
namedTemplate58=namedTemplate();

state._fsp--;
@@ -2075,7 +2071,7 @@ public partial class ActionParser : Parser
case 2:
// Language\\Action.g3:240:5: anonymousTemplate
{
-				PushFollow(Follow._anonymousTemplate_in_template743);
+				PushFollow(Follow._anonymousTemplate_in_template744);
anonymousTemplate59=anonymousTemplate();

state._fsp--;
@@ -2159,7 +2155,7 @@ public partial class ActionParser : Parser

public class namedTemplate_return : ParserRuleReturnScope
{
-		public StringTemplateAST tree;
+		internal StringTemplateAST tree;
public override object Tree { get { return tree; } }
}

@@ -2224,10 +2220,10 @@ public partial class ActionParser : Parser
case 1:
// Language\\Action.g3:246:4: ID argList
{
-				ID60=(IToken)Match(input,ID,Follow._ID_in_namedTemplate774); if (state.failed) return retval;
+				ID60=(IToken)Match(input,ID,Follow._ID_in_namedTemplate775); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_ID.Add(ID60);

-				PushFollow(Follow._argList_in_namedTemplate776);
+				PushFollow(Follow._argList_in_namedTemplate777);
argList61=argList();

state._fsp--;
@@ -2264,16 +2260,16 @@ public partial class ActionParser : Parser
case 2:
// Language\\Action.g3:248:4: 'super' DOT qid= ID argList
{
-				string_literal62=(IToken)Match(input,SUPER,Follow._SUPER_in_namedTemplate789); if (state.failed) return retval;
+				string_literal62=(IToken)Match(input,SUPER,Follow._SUPER_in_namedTemplate790); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_SUPER.Add(string_literal62);

-				DOT63=(IToken)Match(input,DOT,Follow._DOT_in_namedTemplate791); if (state.failed) return retval;
+				DOT63=(IToken)Match(input,DOT,Follow._DOT_in_namedTemplate792); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_DOT.Add(DOT63);

-				qid=(IToken)Match(input,ID,Follow._ID_in_namedTemplate795); if (state.failed) return retval;
+				qid=(IToken)Match(input,ID,Follow._ID_in_namedTemplate796); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_ID.Add(qid);

-				PushFollow(Follow._argList_in_namedTemplate797);
+				PushFollow(Follow._argList_in_namedTemplate798);
argList64=argList();

state._fsp--;
@@ -2310,7 +2306,7 @@ public partial class ActionParser : Parser
case 3:
// Language\\Action.g3:250:4: indirectTemplate
{
-				PushFollow(Follow._indirectTemplate_in_namedTemplate811);
+				PushFollow(Follow._indirectTemplate_in_namedTemplate812);
indirectTemplate65=indirectTemplate();

state._fsp--;
@@ -2369,7 +2365,7 @@ public partial class ActionParser : Parser

public class anonymousTemplate_return : ParserRuleReturnScope
{
-		public StringTemplateAST tree;
+		internal StringTemplateAST tree;
public override object Tree { get { return tree; } }
}

@@ -2396,7 +2392,7 @@ public partial class ActionParser : Parser
{
root_0 = (StringTemplateAST)adaptor.Nil();

-			t=(IToken)Match(input,ANONYMOUS_TEMPLATE,Follow._ANONYMOUS_TEMPLATE_in_anonymousTemplate840); if (state.failed) return retval;
+			t=(IToken)Match(input,ANONYMOUS_TEMPLATE,Follow._ANONYMOUS_TEMPLATE_in_anonymousTemplate841); if (state.failed) return retval;
if ( state.backtracking==0 ) {
t_tree = (StringTemplateAST)adaptor.Create(t);
adaptor.AddChild(root_0, t_tree);
@@ -2427,7 +2423,7 @@ public partial class ActionParser : Parser
if ( state.backtracking == 0 )
{

-					((StringTemplateAST)retval.tree).StringTemplate = anonymous;
+					((StringTemplateAST)retval.Tree).StringTemplate = anonymous;

}
}
@@ -2447,7 +2443,7 @@ public partial class ActionParser : Parser

public class atom_return : ParserRuleReturnScope
{
-		public StringTemplateAST tree;
+		internal StringTemplateAST tree;
public override object Tree { get { return tree; } }
}

@@ -2512,7 +2508,7 @@ public partial class ActionParser : Parser

public class list_return : ParserRuleReturnScope
{
-		public StringTemplateAST tree;
+		internal StringTemplateAST tree;
public override object Tree { get { return tree; } }
}

@@ -2543,10 +2539,10 @@ public partial class ActionParser : Parser
// Language\\Action.g3:284:4: (lb= LBRACK listElement ( COMMA listElement )* RBRACK -> ^( LIST[$lb,\"value\"] ( listElement )+ ) )
// Language\\Action.g3:284:4: lb= LBRACK listElement ( COMMA listElement )* RBRACK
{
-			lb=(IToken)Match(input,LBRACK,Follow._LBRACK_in_list883); if (state.failed) return retval;
+			lb=(IToken)Match(input,LBRACK,Follow._LBRACK_in_list884); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_LBRACK.Add(lb);

-			PushFollow(Follow._listElement_in_list887);
+			PushFollow(Follow._listElement_in_list888);
listElement67=listElement();

state._fsp--;
@@ -2569,10 +2565,10 @@ public partial class ActionParser : Parser
case 1:
// Language\\Action.g3:285:16: COMMA listElement
{
-					COMMA68=(IToken)Match(input,COMMA,Follow._COMMA_in_list890); if (state.failed) return retval;
+					COMMA68=(IToken)Match(input,COMMA,Follow._COMMA_in_list891); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_COMMA.Add(COMMA68);

-					PushFollow(Follow._listElement_in_list892);
+					PushFollow(Follow._listElement_in_list893);
listElement69=listElement();

state._fsp--;
@@ -2591,7 +2587,7 @@ public partial class ActionParser : Parser
;


-			RBRACK70=(IToken)Match(input,RBRACK,Follow._RBRACK_in_list898); if (state.failed) return retval;
+			RBRACK70=(IToken)Match(input,RBRACK,Follow._RBRACK_in_list899); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_RBRACK.Add(RBRACK70);


@@ -2662,7 +2658,7 @@ public partial class ActionParser : Parser

public class listElement_return : ParserRuleReturnScope
{
-		public StringTemplateAST tree;
+		internal StringTemplateAST tree;
public override object Tree { get { return tree; } }
}

@@ -2706,7 +2702,7 @@ public partial class ActionParser : Parser
{
root_0 = (StringTemplateAST)adaptor.Nil();

-				PushFollow(Follow._nonAlternatingTemplateExpr_in_listElement921);
+				PushFollow(Follow._nonAlternatingTemplateExpr_in_listElement922);
nonAlternatingTemplateExpr71=nonAlternatingTemplateExpr();

state._fsp--;
@@ -2772,7 +2768,7 @@ public partial class ActionParser : Parser

public class templateInclude_return : ParserRuleReturnScope
{
-		public StringTemplateAST tree;
+		internal StringTemplateAST tree;
public override object Tree { get { return tree; } }
}

@@ -2840,10 +2836,10 @@ public partial class ActionParser : Parser
case 1:
// Language\\Action.g3:297:6: id= ID argList
{
-				id=(IToken)Match(input,ID,Follow._ID_in_templateInclude946); if (state.failed) return retval;
+				id=(IToken)Match(input,ID,Follow._ID_in_templateInclude947); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_ID.Add(id);

-				PushFollow(Follow._argList_in_templateInclude948);
+				PushFollow(Follow._argList_in_templateInclude949);
argList72=argList();

state._fsp--;
@@ -2881,16 +2877,16 @@ public partial class ActionParser : Parser
case 2:
// Language\\Action.g3:298:5: 'super' DOT qid= ID argList
{
-				string_literal73=(IToken)Match(input,SUPER,Follow._SUPER_in_templateInclude961); if (state.failed) return retval;
+				string_literal73=(IToken)Match(input,SUPER,Follow._SUPER_in_templateInclude962); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_SUPER.Add(string_literal73);

-				DOT74=(IToken)Match(input,DOT,Follow._DOT_in_templateInclude963); if (state.failed) return retval;
+				DOT74=(IToken)Match(input,DOT,Follow._DOT_in_templateInclude964); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_DOT.Add(DOT74);

-				qid=(IToken)Match(input,ID,Follow._ID_in_templateInclude967); if (state.failed) return retval;
+				qid=(IToken)Match(input,ID,Follow._ID_in_templateInclude968); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_ID.Add(qid);

-				PushFollow(Follow._argList_in_templateInclude969);
+				PushFollow(Follow._argList_in_templateInclude970);
argList75=argList();

state._fsp--;
@@ -2927,7 +2923,7 @@ public partial class ActionParser : Parser
case 3:
// Language\\Action.g3:299:5: indirectTemplate
{
-				PushFollow(Follow._indirectTemplate_in_templateInclude982);
+				PushFollow(Follow._indirectTemplate_in_templateInclude983);
indirectTemplate76=indirectTemplate();

state._fsp--;
@@ -3022,7 +3018,7 @@ public partial class ActionParser : Parser

public class indirectTemplate_return : ParserRuleReturnScope
{
-		public StringTemplateAST tree;
+		internal StringTemplateAST tree;
public override object Tree { get { return tree; } }
}

@@ -3051,19 +3047,19 @@ public partial class ActionParser : Parser
// Language\\Action.g3:306:4: ( LPAREN e= templatesExpr RPAREN args= argList -> ^( VALUE[\"value\"] $e $args) )
// Language\\Action.g3:306:4: LPAREN e= templatesExpr RPAREN args= argList
{
-			LPAREN77=(IToken)Match(input,LPAREN,Follow._LPAREN_in_indirectTemplate1016); if (state.failed) return retval;
+			LPAREN77=(IToken)Match(input,LPAREN,Follow._LPAREN_in_indirectTemplate1017); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_LPAREN.Add(LPAREN77);

-			PushFollow(Follow._templatesExpr_in_indirectTemplate1020);
+			PushFollow(Follow._templatesExpr_in_indirectTemplate1021);
e=templatesExpr();

state._fsp--;
if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_templatesExpr.Add(e.Tree);
-			RPAREN78=(IToken)Match(input,RPAREN,Follow._RPAREN_in_indirectTemplate1022); if (state.failed) return retval;
+			RPAREN78=(IToken)Match(input,RPAREN,Follow._RPAREN_in_indirectTemplate1023); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_RPAREN.Add(RPAREN78);

-			PushFollow(Follow._argList_in_indirectTemplate1026);
+			PushFollow(Follow._argList_in_indirectTemplate1027);
args=argList();

state._fsp--;
@@ -3131,7 +3127,7 @@ public partial class ActionParser : Parser

public class argList_return : ParserRuleReturnScope
{
-		public StringTemplateAST tree;
+		internal StringTemplateAST tree;
public override object Tree { get { return tree; } }
}

@@ -3233,7 +3229,7 @@ public partial class ActionParser : Parser
case 1:
// Language\\Action.g3:311:4: LPAREN ( argumentAssignment ( COMMA argumentAssignment )* )? RPAREN
{
-				LPAREN79=(IToken)Match(input,LPAREN,Follow._LPAREN_in_argList1053); if (state.failed) return retval;
+				LPAREN79=(IToken)Match(input,LPAREN,Follow._LPAREN_in_argList1054); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_LPAREN.Add(LPAREN79);

// Language\\Action.g3:312:3: ( argumentAssignment ( COMMA argumentAssignment )* )?
@@ -3249,7 +3245,7 @@ public partial class ActionParser : Parser
case 1:
// Language\\Action.g3:312:5: argumentAssignment ( COMMA argumentAssignment )*
{
-					PushFollow(Follow._argumentAssignment_in_argList1059);
+					PushFollow(Follow._argumentAssignment_in_argList1060);
argumentAssignment80=argumentAssignment();

state._fsp--;
@@ -3272,10 +3268,10 @@ public partial class ActionParser : Parser
case 1:
// Language\\Action.g3:312:25: COMMA argumentAssignment
{
-							COMMA81=(IToken)Match(input,COMMA,Follow._COMMA_in_argList1062); if (state.failed) return retval;
+							COMMA81=(IToken)Match(input,COMMA,Follow._COMMA_in_argList1063); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_COMMA.Add(COMMA81);

-							PushFollow(Follow._argumentAssignment_in_argList1064);
+							PushFollow(Follow._argumentAssignment_in_argList1065);
argumentAssignment82=argumentAssignment();

state._fsp--;
@@ -3300,7 +3296,7 @@ public partial class ActionParser : Parser

}

-				RPAREN83=(IToken)Match(input,RPAREN,Follow._RPAREN_in_argList1075); if (state.failed) return retval;
+				RPAREN83=(IToken)Match(input,RPAREN,Follow._RPAREN_in_argList1076); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_RPAREN.Add(RPAREN83);


@@ -3349,7 +3345,7 @@ public partial class ActionParser : Parser
{
root_0 = (StringTemplateAST)adaptor.Nil();

-				PushFollow(Follow._singleArg_in_argList1092);
+				PushFollow(Follow._singleArg_in_argList1093);
singleArg84=singleArg();

state._fsp--;
@@ -3384,7 +3380,7 @@ public partial class ActionParser : Parser

public class singleArg_return : ParserRuleReturnScope
{
-		public StringTemplateAST tree;
+		internal StringTemplateAST tree;
public override object Tree { get { return tree; } }
}

@@ -3411,16 +3407,16 @@ public partial class ActionParser : Parser
// Language\\Action.g3:320:4: ( LPAREN nonAlternatingTemplateExpr RPAREN -> ^( SINGLEVALUEARG[\"SINGLEVALUEARG\"] nonAlternatingTemplateExpr ) )
// Language\\Action.g3:320:4: LPAREN nonAlternatingTemplateExpr RPAREN
{
-			LPAREN85=(IToken)Match(input,LPAREN,Follow._LPAREN_in_singleArg1104); if (state.failed) return retval;
+			LPAREN85=(IToken)Match(input,LPAREN,Follow._LPAREN_in_singleArg1105); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_LPAREN.Add(LPAREN85);

-			PushFollow(Follow._nonAlternatingTemplateExpr_in_singleArg1106);
+			PushFollow(Follow._nonAlternatingTemplateExpr_in_singleArg1107);
nonAlternatingTemplateExpr86=nonAlternatingTemplateExpr();

state._fsp--;
if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_nonAlternatingTemplateExpr.Add(nonAlternatingTemplateExpr86.Tree);
-			RPAREN87=(IToken)Match(input,RPAREN,Follow._RPAREN_in_singleArg1108); if (state.failed) return retval;
+			RPAREN87=(IToken)Match(input,RPAREN,Follow._RPAREN_in_singleArg1109); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_RPAREN.Add(RPAREN87);


@@ -3482,7 +3478,7 @@ public partial class ActionParser : Parser

public class argumentAssignment_return : ParserRuleReturnScope
{
-		public StringTemplateAST tree;
+		internal StringTemplateAST tree;
public override object Tree { get { return tree; } }
}

@@ -3532,17 +3528,17 @@ public partial class ActionParser : Parser
{
root_0 = (StringTemplateAST)adaptor.Nil();

-				ID88=(IToken)Match(input,ID,Follow._ID_in_argumentAssignment1130); if (state.failed) return retval;
+				ID88=(IToken)Match(input,ID,Follow._ID_in_argumentAssignment1131); if (state.failed) return retval;
if ( state.backtracking==0 ) {
ID88_tree = (StringTemplateAST)adaptor.Create(ID88);
adaptor.AddChild(root_0, ID88_tree);
}
-				ASSIGN89=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_argumentAssignment1132); if (state.failed) return retval;
+				ASSIGN89=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_argumentAssignment1133); if (state.failed) return retval;
if ( state.backtracking == 0 ) {
ASSIGN89_tree = (StringTemplateAST)adaptor.Create(ASSIGN89);
root_0 = (StringTemplateAST)adaptor.BecomeRoot(ASSIGN89_tree, root_0);
}
-				PushFollow(Follow._nonAlternatingTemplateExpr_in_argumentAssignment1135);
+				PushFollow(Follow._nonAlternatingTemplateExpr_in_argumentAssignment1136);
nonAlternatingTemplateExpr90=nonAlternatingTemplateExpr();

state._fsp--;
@@ -3556,7 +3552,7 @@ public partial class ActionParser : Parser
{
root_0 = (StringTemplateAST)adaptor.Nil();

-				DOTDOTDOT91=(IToken)Match(input,DOTDOTDOT,Follow._DOTDOTDOT_in_argumentAssignment1140); if (state.failed) return retval;
+				DOTDOTDOT91=(IToken)Match(input,DOTDOTDOT,Follow._DOTDOTDOT_in_argumentAssignment1141); if (state.failed) return retval;
if ( state.backtracking==0 ) {
DOTDOTDOT91_tree = (StringTemplateAST)adaptor.Create(DOTDOTDOT91);
adaptor.AddChild(root_0, DOTDOTDOT91_tree);
@@ -3594,7 +3590,7 @@ public partial class ActionParser : Parser
// Language\\Action.g3:200:4: ( templateInclude )
// Language\\Action.g3:200:5: templateInclude
{
-		PushFollow(Follow._templateInclude_in_synpred1_Action490);
+		PushFollow(Follow._templateInclude_in_synpred1_Action491);
templateInclude();

state._fsp--;
@@ -3778,7 +3774,7 @@ public partial class ActionParser : Parser
#endregion DFA

#region Follow sets
-	public static class Follow
+	static class Follow
{
public static readonly BitSet _templatesExpr_in_action192 = new BitSet(new ulong[]{0x400000000UL});
public static readonly BitSet _SEMI_in_action195 = new BitSet(new ulong[]{0x20000UL});
@@ -3792,95 +3788,95 @@ public partial class ActionParser : Parser
public static readonly BitSet _ifCondition_in_action229 = new BitSet(new ulong[]{0x200000000UL});
public static readonly BitSet _RPAREN_in_action231 = new BitSet(new ulong[]{0x0UL});
public static readonly BitSet _EOF_in_action241 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _option_in_optionList257 = new BitSet(new ulong[]{0x202UL});
-		public static readonly BitSet _COMMA_in_optionList261 = new BitSet(new ulong[]{0x20000UL});
-		public static readonly BitSet _option_in_optionList263 = new BitSet(new ulong[]{0x202UL});
-		public static readonly BitSet _ID_in_option283 = new BitSet(new ulong[]{0x82UL});
-		public static readonly BitSet _ASSIGN_in_option289 = new BitSet(new ulong[]{0x271017A8010UL});
-		public static readonly BitSet _nonAlternatingTemplateExpr_in_option291 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _expr_in_templatesExpr321 = new BitSet(new ulong[]{0x302UL});
-		public static readonly BitSet _COMMA_in_templatesExpr328 = new BitSet(new ulong[]{0x271017A8010UL});
-		public static readonly BitSet _expr_in_templatesExpr330 = new BitSet(new ulong[]{0x300UL});
-		public static readonly BitSet _COLON_in_templatesExpr336 = new BitSet(new ulong[]{0x10UL});
-		public static readonly BitSet _anonymousTemplate_in_templatesExpr338 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _COLON_in_templatesExpr380 = new BitSet(new ulong[]{0x4001020010UL});
-		public static readonly BitSet _templateList_in_templatesExpr382 = new BitSet(new ulong[]{0x102UL});
-		public static readonly BitSet _template_in_templateList421 = new BitSet(new ulong[]{0x202UL});
-		public static readonly BitSet _COMMA_in_templateList424 = new BitSet(new ulong[]{0x4001020010UL});
-		public static readonly BitSet _template_in_templateList427 = new BitSet(new ulong[]{0x202UL});
-		public static readonly BitSet _ifAtom_in_ifCondition440 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _NOT_in_ifCondition445 = new BitSet(new ulong[]{0x271017A8010UL});
-		public static readonly BitSet _ifAtom_in_ifCondition448 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _templatesExpr_in_ifAtom459 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _primaryExpr_in_expr470 = new BitSet(new ulong[]{0x40000002UL});
-		public static readonly BitSet _PLUS_in_expr473 = new BitSet(new ulong[]{0x271017A8010UL});
-		public static readonly BitSet _primaryExpr_in_expr476 = new BitSet(new ulong[]{0x40000002UL});
-		public static readonly BitSet _templateInclude_in_primaryExpr493 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _atom_in_primaryExpr500 = new BitSet(new ulong[]{0x802UL});
-		public static readonly BitSet _DOT_in_primaryExpr506 = new BitSet(new ulong[]{0x1020000UL});
-		public static readonly BitSet _ID_in_primaryExpr515 = new BitSet(new ulong[]{0x802UL});
-		public static readonly BitSet _valueExpr_in_primaryExpr522 = new BitSet(new ulong[]{0x802UL});
-		public static readonly BitSet _function_in_primaryExpr537 = new BitSet(new ulong[]{0x802UL});
-		public static readonly BitSet _DOT_in_primaryExpr543 = new BitSet(new ulong[]{0x1020000UL});
-		public static readonly BitSet _ID_in_primaryExpr551 = new BitSet(new ulong[]{0x802UL});
-		public static readonly BitSet _valueExpr_in_primaryExpr558 = new BitSet(new ulong[]{0x802UL});
-		public static readonly BitSet _valueExpr_in_primaryExpr573 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _list_in_primaryExpr578 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _LPAREN_in_valueExpr589 = new BitSet(new ulong[]{0x271017A8010UL});
-		public static readonly BitSet _templatesExpr_in_valueExpr591 = new BitSet(new ulong[]{0x200000000UL});
-		public static readonly BitSet _RPAREN_in_valueExpr593 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _expr_in_nonAlternatingTemplateExpr616 = new BitSet(new ulong[]{0x102UL});
-		public static readonly BitSet _COLON_in_nonAlternatingTemplateExpr625 = new BitSet(new ulong[]{0x4001020010UL});
-		public static readonly BitSet _template_in_nonAlternatingTemplateExpr627 = new BitSet(new ulong[]{0x102UL});
-		public static readonly BitSet _FIRST_in_function655 = new BitSet(new ulong[]{0x1000000UL});
-		public static readonly BitSet _REST_in_function661 = new BitSet(new ulong[]{0x1000000UL});
-		public static readonly BitSet _LAST_in_function667 = new BitSet(new ulong[]{0x1000000UL});
-		public static readonly BitSet _LENGTH_in_function673 = new BitSet(new ulong[]{0x1000000UL});
-		public static readonly BitSet _STRIP_in_function679 = new BitSet(new ulong[]{0x1000000UL});
-		public static readonly BitSet _TRUNC_in_function685 = new BitSet(new ulong[]{0x1000000UL});
-		public static readonly BitSet _singleArg_in_function693 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _namedTemplate_in_template734 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _anonymousTemplate_in_template743 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ID_in_namedTemplate774 = new BitSet(new ulong[]{0x1000000UL});
-		public static readonly BitSet _argList_in_namedTemplate776 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _SUPER_in_namedTemplate789 = new BitSet(new ulong[]{0x800UL});
-		public static readonly BitSet _DOT_in_namedTemplate791 = new BitSet(new ulong[]{0x20000UL});
-		public static readonly BitSet _ID_in_namedTemplate795 = new BitSet(new ulong[]{0x1000000UL});
-		public static readonly BitSet _argList_in_namedTemplate797 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _indirectTemplate_in_namedTemplate811 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ANONYMOUS_TEMPLATE_in_anonymousTemplate840 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _set_in_atom855 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _LBRACK_in_list883 = new BitSet(new ulong[]{0x271817A8210UL});
-		public static readonly BitSet _listElement_in_list887 = new BitSet(new ulong[]{0x80000200UL});
-		public static readonly BitSet _COMMA_in_list890 = new BitSet(new ulong[]{0x271817A8210UL});
-		public static readonly BitSet _listElement_in_list892 = new BitSet(new ulong[]{0x80000200UL});
-		public static readonly BitSet _RBRACK_in_list898 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _nonAlternatingTemplateExpr_in_listElement921 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ID_in_templateInclude946 = new BitSet(new ulong[]{0x1000000UL});
-		public static readonly BitSet _argList_in_templateInclude948 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _SUPER_in_templateInclude961 = new BitSet(new ulong[]{0x800UL});
-		public static readonly BitSet _DOT_in_templateInclude963 = new BitSet(new ulong[]{0x20000UL});
-		public static readonly BitSet _ID_in_templateInclude967 = new BitSet(new ulong[]{0x1000000UL});
-		public static readonly BitSet _argList_in_templateInclude969 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _indirectTemplate_in_templateInclude982 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _LPAREN_in_indirectTemplate1016 = new BitSet(new ulong[]{0x271017A8010UL});
-		public static readonly BitSet _templatesExpr_in_indirectTemplate1020 = new BitSet(new ulong[]{0x200000000UL});
-		public static readonly BitSet _RPAREN_in_indirectTemplate1022 = new BitSet(new ulong[]{0x1000000UL});
-		public static readonly BitSet _argList_in_indirectTemplate1026 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _LPAREN_in_argList1053 = new BitSet(new ulong[]{0x200021000UL});
-		public static readonly BitSet _argumentAssignment_in_argList1059 = new BitSet(new ulong[]{0x200000200UL});
-		public static readonly BitSet _COMMA_in_argList1062 = new BitSet(new ulong[]{0x21000UL});
-		public static readonly BitSet _argumentAssignment_in_argList1064 = new BitSet(new ulong[]{0x200000200UL});
-		public static readonly BitSet _RPAREN_in_argList1075 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _singleArg_in_argList1092 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _LPAREN_in_singleArg1104 = new BitSet(new ulong[]{0x271017A8010UL});
-		public static readonly BitSet _nonAlternatingTemplateExpr_in_singleArg1106 = new BitSet(new ulong[]{0x200000000UL});
-		public static readonly BitSet _RPAREN_in_singleArg1108 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ID_in_argumentAssignment1130 = new BitSet(new ulong[]{0x80UL});
-		public static readonly BitSet _ASSIGN_in_argumentAssignment1132 = new BitSet(new ulong[]{0x271017A8010UL});
-		public static readonly BitSet _nonAlternatingTemplateExpr_in_argumentAssignment1135 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _DOTDOTDOT_in_argumentAssignment1140 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _templateInclude_in_synpred1_Action490 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _option_in_optionList258 = new BitSet(new ulong[]{0x202UL});
+		public static readonly BitSet _COMMA_in_optionList262 = new BitSet(new ulong[]{0x20000UL});
+		public static readonly BitSet _option_in_optionList264 = new BitSet(new ulong[]{0x202UL});
+		public static readonly BitSet _ID_in_option284 = new BitSet(new ulong[]{0x82UL});
+		public static readonly BitSet _ASSIGN_in_option290 = new BitSet(new ulong[]{0x271017A8010UL});
+		public static readonly BitSet _nonAlternatingTemplateExpr_in_option292 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _expr_in_templatesExpr322 = new BitSet(new ulong[]{0x302UL});
+		public static readonly BitSet _COMMA_in_templatesExpr329 = new BitSet(new ulong[]{0x271017A8010UL});
+		public static readonly BitSet _expr_in_templatesExpr331 = new BitSet(new ulong[]{0x300UL});
+		public static readonly BitSet _COLON_in_templatesExpr337 = new BitSet(new ulong[]{0x10UL});
+		public static readonly BitSet _anonymousTemplate_in_templatesExpr339 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _COLON_in_templatesExpr381 = new BitSet(new ulong[]{0x4001020010UL});
+		public static readonly BitSet _templateList_in_templatesExpr383 = new BitSet(new ulong[]{0x102UL});
+		public static readonly BitSet _template_in_templateList422 = new BitSet(new ulong[]{0x202UL});
+		public static readonly BitSet _COMMA_in_templateList425 = new BitSet(new ulong[]{0x4001020010UL});
+		public static readonly BitSet _template_in_templateList428 = new BitSet(new ulong[]{0x202UL});
+		public static readonly BitSet _ifAtom_in_ifCondition441 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _NOT_in_ifCondition446 = new BitSet(new ulong[]{0x271017A8010UL});
+		public static readonly BitSet _ifAtom_in_ifCondition449 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _templatesExpr_in_ifAtom460 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _primaryExpr_in_expr471 = new BitSet(new ulong[]{0x40000002UL});
+		public static readonly BitSet _PLUS_in_expr474 = new BitSet(new ulong[]{0x271017A8010UL});
+		public static readonly BitSet _primaryExpr_in_expr477 = new BitSet(new ulong[]{0x40000002UL});
+		public static readonly BitSet _templateInclude_in_primaryExpr494 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _atom_in_primaryExpr501 = new BitSet(new ulong[]{0x802UL});
+		public static readonly BitSet _DOT_in_primaryExpr507 = new BitSet(new ulong[]{0x1020000UL});
+		public static readonly BitSet _ID_in_primaryExpr516 = new BitSet(new ulong[]{0x802UL});
+		public static readonly BitSet _valueExpr_in_primaryExpr523 = new BitSet(new ulong[]{0x802UL});
+		public static readonly BitSet _function_in_primaryExpr538 = new BitSet(new ulong[]{0x802UL});
+		public static readonly BitSet _DOT_in_primaryExpr544 = new BitSet(new ulong[]{0x1020000UL});
+		public static readonly BitSet _ID_in_primaryExpr552 = new BitSet(new ulong[]{0x802UL});
+		public static readonly BitSet _valueExpr_in_primaryExpr559 = new BitSet(new ulong[]{0x802UL});
+		public static readonly BitSet _valueExpr_in_primaryExpr574 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _list_in_primaryExpr579 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _LPAREN_in_valueExpr590 = new BitSet(new ulong[]{0x271017A8010UL});
+		public static readonly BitSet _templatesExpr_in_valueExpr592 = new BitSet(new ulong[]{0x200000000UL});
+		public static readonly BitSet _RPAREN_in_valueExpr594 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _expr_in_nonAlternatingTemplateExpr617 = new BitSet(new ulong[]{0x102UL});
+		public static readonly BitSet _COLON_in_nonAlternatingTemplateExpr626 = new BitSet(new ulong[]{0x4001020010UL});
+		public static readonly BitSet _template_in_nonAlternatingTemplateExpr628 = new BitSet(new ulong[]{0x102UL});
+		public static readonly BitSet _FIRST_in_function656 = new BitSet(new ulong[]{0x1000000UL});
+		public static readonly BitSet _REST_in_function662 = new BitSet(new ulong[]{0x1000000UL});
+		public static readonly BitSet _LAST_in_function668 = new BitSet(new ulong[]{0x1000000UL});
+		public static readonly BitSet _LENGTH_in_function674 = new BitSet(new ulong[]{0x1000000UL});
+		public static readonly BitSet _STRIP_in_function680 = new BitSet(new ulong[]{0x1000000UL});
+		public static readonly BitSet _TRUNC_in_function686 = new BitSet(new ulong[]{0x1000000UL});
+		public static readonly BitSet _singleArg_in_function694 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _namedTemplate_in_template735 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _anonymousTemplate_in_template744 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ID_in_namedTemplate775 = new BitSet(new ulong[]{0x1000000UL});
+		public static readonly BitSet _argList_in_namedTemplate777 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _SUPER_in_namedTemplate790 = new BitSet(new ulong[]{0x800UL});
+		public static readonly BitSet _DOT_in_namedTemplate792 = new BitSet(new ulong[]{0x20000UL});
+		public static readonly BitSet _ID_in_namedTemplate796 = new BitSet(new ulong[]{0x1000000UL});
+		public static readonly BitSet _argList_in_namedTemplate798 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _indirectTemplate_in_namedTemplate812 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ANONYMOUS_TEMPLATE_in_anonymousTemplate841 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _set_in_atom856 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _LBRACK_in_list884 = new BitSet(new ulong[]{0x271817A8210UL});
+		public static readonly BitSet _listElement_in_list888 = new BitSet(new ulong[]{0x80000200UL});
+		public static readonly BitSet _COMMA_in_list891 = new BitSet(new ulong[]{0x271817A8210UL});
+		public static readonly BitSet _listElement_in_list893 = new BitSet(new ulong[]{0x80000200UL});
+		public static readonly BitSet _RBRACK_in_list899 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _nonAlternatingTemplateExpr_in_listElement922 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ID_in_templateInclude947 = new BitSet(new ulong[]{0x1000000UL});
+		public static readonly BitSet _argList_in_templateInclude949 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _SUPER_in_templateInclude962 = new BitSet(new ulong[]{0x800UL});
+		public static readonly BitSet _DOT_in_templateInclude964 = new BitSet(new ulong[]{0x20000UL});
+		public static readonly BitSet _ID_in_templateInclude968 = new BitSet(new ulong[]{0x1000000UL});
+		public static readonly BitSet _argList_in_templateInclude970 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _indirectTemplate_in_templateInclude983 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _LPAREN_in_indirectTemplate1017 = new BitSet(new ulong[]{0x271017A8010UL});
+		public static readonly BitSet _templatesExpr_in_indirectTemplate1021 = new BitSet(new ulong[]{0x200000000UL});
+		public static readonly BitSet _RPAREN_in_indirectTemplate1023 = new BitSet(new ulong[]{0x1000000UL});
+		public static readonly BitSet _argList_in_indirectTemplate1027 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _LPAREN_in_argList1054 = new BitSet(new ulong[]{0x200021000UL});
+		public static readonly BitSet _argumentAssignment_in_argList1060 = new BitSet(new ulong[]{0x200000200UL});
+		public static readonly BitSet _COMMA_in_argList1063 = new BitSet(new ulong[]{0x21000UL});
+		public static readonly BitSet _argumentAssignment_in_argList1065 = new BitSet(new ulong[]{0x200000200UL});
+		public static readonly BitSet _RPAREN_in_argList1076 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _singleArg_in_argList1093 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _LPAREN_in_singleArg1105 = new BitSet(new ulong[]{0x271017A8010UL});
+		public static readonly BitSet _nonAlternatingTemplateExpr_in_singleArg1107 = new BitSet(new ulong[]{0x200000000UL});
+		public static readonly BitSet _RPAREN_in_singleArg1109 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ID_in_argumentAssignment1131 = new BitSet(new ulong[]{0x80UL});
+		public static readonly BitSet _ASSIGN_in_argumentAssignment1133 = new BitSet(new ulong[]{0x271017A8010UL});
+		public static readonly BitSet _nonAlternatingTemplateExpr_in_argumentAssignment1136 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _DOTDOTDOT_in_argumentAssignment1141 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _templateInclude_in_synpred1_Action491 = new BitSet(new ulong[]{0x2UL});

}
#endregion Follow sets
diff --git a/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.cs b/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.cs
index 6fd604b..3c75858 100644
--- a/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.cs
+++ b/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Language\\AngleBracketTemplateLexer.g3 2009-04-18 13:36:15
+// $ANTLR 3.1.2 Language\\AngleBracketTemplateLexer.g3 2009-07-30 15:53:49

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -65,13 +65,14 @@ public partial class AngleBracketTemplateLexer : Lexer
public const int IF=13;
public const int IF_EXPR=14;
public const int INDENT=15;
-	public const int LITERAL=16;
-	public const int NESTED_PARENS=17;
-	public const int NEWLINE=18;
-	public const int REGION_DEF=19;
-	public const int REGION_REF=20;
-	public const int SUBTEMPLATE=21;
-	public const int TEMPLATE=22;
+	public const int LINE_BREAK=16;
+	public const int LITERAL=17;
+	public const int NESTED_PARENS=18;
+	public const int NEWLINE=19;
+	public const int REGION_DEF=20;
+	public const int REGION_REF=21;
+	public const int SUBTEMPLATE=22;
+	public const int TEMPLATE=23;

// delegates
// delegators
@@ -154,8 +155,8 @@ public partial class AngleBracketTemplateLexer : Lexer
bool atLeft = false;
string t = null;

-			// Language\\AngleBracketTemplateLexer.g3:95:4: (=> '<' ( ESC_CHAR[out uc] )+ '>' |=> COMMENT | ( options {k=1; } :=> '<if' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? |=> '<elseif' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? |=> '<else>' ( ( '\\r' )? '\\n' )? |=> '<endif>' ({...}? => ( '\\r' )? '\\n' )? |=> '<@' (ch=~ ( '>' | '(' ) )+ ( '()>' | '>' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )? ) | '<' EXPR[out subtext] '>' ) )
-			int alt26=3;
+			// Language\\AngleBracketTemplateLexer.g3:95:4: (=> LINE_BREAK |=> '<' ( ESC_CHAR[out uc] )+ '>' |=> COMMENT | ( options {k=1; } :=> '<if' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? |=> '<elseif' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? |=> '<else>' ( ( '\\r' )? '\\n' )? |=> '<endif>' ({...}? => ( '\\r' )? '\\n' )? |=> '<@' (ch=~ ( '>' | '(' ) )+ ( '()>' | '>' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )? ) | '<' EXPR[out subtext] '>' ) )
+			int alt26=4;
int LA26_0 = input.LA(1);

if ( (LA26_0=='<') )
@@ -170,10 +171,14 @@ public partial class AngleBracketTemplateLexer : Lexer
{
alt26=2;
}
-				else if ( (true) )
+				else if ( (EvaluatePredicate(synpred3_AngleBracketTemplateLexer_fragment)) )
{
alt26=3;
}
+				else if ( (true) )
+				{
+					alt26=4;
+				}
else
{
if (state.backtracking>0) {state.failed=true; return ;}
@@ -192,7 +197,19 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt26 )
{
case 1:
-				// Language\\AngleBracketTemplateLexer.g3:95:4: => '<' ( ESC_CHAR[out uc] )+ '>'
+				// Language\\AngleBracketTemplateLexer.g3:95:4: => LINE_BREAK
+				{
+
+				mLINE_BREAK(); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+					_channel = Hidden;
+				}
+
+				}
+				break;
+			case 2:
+				// Language\\AngleBracketTemplateLexer.g3:96:4: => '<' ( ESC_CHAR[out uc] )+ '>'
{

if ( state.backtracking == 0 )
@@ -203,7 +220,7 @@ public partial class AngleBracketTemplateLexer : Lexer

}
Match('<'); if (state.failed) return ;
-				// Language\\AngleBracketTemplateLexer.g3:101:7: ( ESC_CHAR[out uc] )+
+				// Language\\AngleBracketTemplateLexer.g3:102:7: ( ESC_CHAR[out uc] )+
int cnt2=0;
for ( ; ; )
{
@@ -219,7 +236,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt2 )
{
case 1:
-						// Language\\AngleBracketTemplateLexer.g3:101:8: ESC_CHAR[out uc]
+						// Language\\AngleBracketTemplateLexer.g3:102:8: ESC_CHAR[out uc]
{
mESC_CHAR(out uc); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -255,8 +272,8 @@ public partial class AngleBracketTemplateLexer : Lexer

}
break;
-			case 2:
-				// Language\\AngleBracketTemplateLexer.g3:106:4: => COMMENT
+			case 3:
+				// Language\\AngleBracketTemplateLexer.g3:107:4: => COMMENT
{

mCOMMENT(); if (state.failed) return ;
@@ -267,10 +284,10 @@ public partial class AngleBracketTemplateLexer : Lexer

}
break;
-			case 3:
-				// Language\\AngleBracketTemplateLexer.g3:107:4: ( options {k=1; } :=> '<if' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? |=> '<elseif' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? |=> '<else>' ( ( '\\r' )? '\\n' )? |=> '<endif>' ({...}? => ( '\\r' )? '\\n' )? |=> '<@' (ch=~ ( '>' | '(' ) )+ ( '()>' | '>' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )? ) | '<' EXPR[out subtext] '>' )
+			case 4:
+				// Language\\AngleBracketTemplateLexer.g3:108:4: ( options {k=1; } :=> '<if' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? |=> '<elseif' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? |=> '<else>' ( ( '\\r' )? '\\n' )? |=> '<endif>' ({...}? => ( '\\r' )? '\\n' )? |=> '<@' (ch=~ ( '>' | '(' ) )+ ( '()>' | '>' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )? ) | '<' EXPR[out subtext] '>' )
{
-				// Language\\AngleBracketTemplateLexer.g3:107:4: ( options {k=1; } :=> '<if' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? |=> '<elseif' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? |=> '<else>' ( ( '\\r' )? '\\n' )? |=> '<endif>' ({...}? => ( '\\r' )? '\\n' )? |=> '<@' (ch=~ ( '>' | '(' ) )+ ( '()>' | '>' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )? ) | '<' EXPR[out subtext] '>' )
+				// Language\\AngleBracketTemplateLexer.g3:108:4: ( options {k=1; } :=> '<if' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? |=> '<elseif' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? |=> '<else>' ( ( '\\r' )? '\\n' )? |=> '<endif>' ({...}? => ( '\\r' )? '\\n' )? |=> '<@' (ch=~ ( '>' | '(' ) )+ ( '()>' | '>' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )? ) | '<' EXPR[out subtext] '>' )
int alt25=6;
int LA25_0 = input.LA(1);

@@ -278,23 +295,23 @@ public partial class AngleBracketTemplateLexer : Lexer
{
int LA25_1 = input.LA(2);

-					if ( (EvaluatePredicate(synpred3_AngleBracketTemplateLexer_fragment)) )
+					if ( (EvaluatePredicate(synpred4_AngleBracketTemplateLexer_fragment)) )
{
alt25=1;
}
-					else if ( (EvaluatePredicate(synpred4_AngleBracketTemplateLexer_fragment)) )
+					else if ( (EvaluatePredicate(synpred5_AngleBracketTemplateLexer_fragment)) )
{
alt25=2;
}
-					else if ( (EvaluatePredicate(synpred5_AngleBracketTemplateLexer_fragment)) )
+					else if ( (EvaluatePredicate(synpred6_AngleBracketTemplateLexer_fragment)) )
{
alt25=3;
}
-					else if ( (EvaluatePredicate(synpred6_AngleBracketTemplateLexer_fragment)) )
+					else if ( (EvaluatePredicate(synpred7_AngleBracketTemplateLexer_fragment)) )
{
alt25=4;
}
-					else if ( (EvaluatePredicate(synpred7_AngleBracketTemplateLexer_fragment)) )
+					else if ( (EvaluatePredicate(synpred8_AngleBracketTemplateLexer_fragment)) )
{
alt25=5;
}
@@ -320,12 +337,12 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt25 )
{
case 1:
-					// Language\\AngleBracketTemplateLexer.g3:108:4: => '<if' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )?
+					// Language\\AngleBracketTemplateLexer.g3:109:4: => '<if' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )?
{

Match("<if"); if (state.failed) return ;

-					// Language\\AngleBracketTemplateLexer.g3:109:10: ( ' ' )*
+					// Language\\AngleBracketTemplateLexer.g3:110:10: ( ' ' )*
for ( ; ; )
{
int alt3=2;
@@ -340,7 +357,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt3 )
{
case 1:
-							// Language\\AngleBracketTemplateLexer.g3:109:11: ' '
+							// Language\\AngleBracketTemplateLexer.g3:110:11: ' '
{
Match(' '); if (state.failed) return ;

@@ -357,12 +374,12 @@ public partial class AngleBracketTemplateLexer : Lexer


Match('('); if (state.failed) return ;
-					int expStart171 = CharIndex;
+					int expStart184 = CharIndex;
mIF_EXPR(); if (state.failed) return ;
-					exp = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, expStart171, CharIndex-1);
+					exp = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, expStart184, CharIndex-1);
Match(")>"); if (state.failed) return ;

-					// Language\\AngleBracketTemplateLexer.g3:110:4: ( ( '\\r' )? '\\n' )?
+					// Language\\AngleBracketTemplateLexer.g3:111:4: ( ( '\\r' )? '\\n' )?
int alt5=2;
int LA5_0 = input.LA(1);

@@ -373,9 +390,9 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt5 )
{
case 1:
-						// Language\\AngleBracketTemplateLexer.g3:110:6: ( '\\r' )? '\\n'
+						// Language\\AngleBracketTemplateLexer.g3:111:6: ( '\\r' )? '\\n'
{
-						// Language\\AngleBracketTemplateLexer.g3:110:6: ( '\\r' )?
+						// Language\\AngleBracketTemplateLexer.g3:111:6: ( '\\r' )?
int alt4=2;
int LA4_0 = input.LA(1);

@@ -386,7 +403,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt4 )
{
case 1:
-							// Language\\AngleBracketTemplateLexer.g3:110:7: '\\r'
+							// Language\\AngleBracketTemplateLexer.g3:111:7: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -413,12 +430,12 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 2:
-					// Language\\AngleBracketTemplateLexer.g3:115:5: => '<elseif' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )?
+					// Language\\AngleBracketTemplateLexer.g3:116:5: => '<elseif' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )?
{

Match("<elseif"); if (state.failed) return ;

-					// Language\\AngleBracketTemplateLexer.g3:116:14: ( ' ' )*
+					// Language\\AngleBracketTemplateLexer.g3:117:14: ( ' ' )*
for ( ; ; )
{
int alt6=2;
@@ -433,7 +450,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt6 )
{
case 1:
-							// Language\\AngleBracketTemplateLexer.g3:116:15: ' '
+							// Language\\AngleBracketTemplateLexer.g3:117:15: ' '
{
Match(' '); if (state.failed) return ;

@@ -450,12 +467,12 @@ public partial class AngleBracketTemplateLexer : Lexer


Match('('); if (state.failed) return ;
-					int expStart220 = CharIndex;
+					int expStart233 = CharIndex;
mIF_EXPR(); if (state.failed) return ;
-					exp = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, expStart220, CharIndex-1);
+					exp = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, expStart233, CharIndex-1);
Match(")>"); if (state.failed) return ;

-					// Language\\AngleBracketTemplateLexer.g3:117:4: ( ( '\\r' )? '\\n' )?
+					// Language\\AngleBracketTemplateLexer.g3:118:4: ( ( '\\r' )? '\\n' )?
int alt8=2;
int LA8_0 = input.LA(1);

@@ -466,9 +483,9 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt8 )
{
case 1:
-						// Language\\AngleBracketTemplateLexer.g3:117:6: ( '\\r' )? '\\n'
+						// Language\\AngleBracketTemplateLexer.g3:118:6: ( '\\r' )? '\\n'
{
-						// Language\\AngleBracketTemplateLexer.g3:117:6: ( '\\r' )?
+						// Language\\AngleBracketTemplateLexer.g3:118:6: ( '\\r' )?
int alt7=2;
int LA7_0 = input.LA(1);

@@ -479,7 +496,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt7 )
{
case 1:
-							// Language\\AngleBracketTemplateLexer.g3:117:7: '\\r'
+							// Language\\AngleBracketTemplateLexer.g3:118:7: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -506,12 +523,12 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 3:
-					// Language\\AngleBracketTemplateLexer.g3:122:5: => '<else>' ( ( '\\r' )? '\\n' )?
+					// Language\\AngleBracketTemplateLexer.g3:123:5: => '<else>' ( ( '\\r' )? '\\n' )?
{

Match("<else>"); if (state.failed) return ;

-					// Language\\AngleBracketTemplateLexer.g3:124:4: ( ( '\\r' )? '\\n' )?
+					// Language\\AngleBracketTemplateLexer.g3:125:4: ( ( '\\r' )? '\\n' )?
int alt10=2;
int LA10_0 = input.LA(1);

@@ -522,9 +539,9 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt10 )
{
case 1:
-						// Language\\AngleBracketTemplateLexer.g3:124:6: ( '\\r' )? '\\n'
+						// Language\\AngleBracketTemplateLexer.g3:125:6: ( '\\r' )? '\\n'
{
-						// Language\\AngleBracketTemplateLexer.g3:124:6: ( '\\r' )?
+						// Language\\AngleBracketTemplateLexer.g3:125:6: ( '\\r' )?
int alt9=2;
int LA9_0 = input.LA(1);

@@ -535,7 +552,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt9 )
{
case 1:
-							// Language\\AngleBracketTemplateLexer.g3:124:7: '\\r'
+							// Language\\AngleBracketTemplateLexer.g3:125:7: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -562,12 +579,12 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 4:
-					// Language\\AngleBracketTemplateLexer.g3:129:5: => '<endif>' ({...}? => ( '\\r' )? '\\n' )?
+					// Language\\AngleBracketTemplateLexer.g3:130:5: => '<endif>' ({...}? => ( '\\r' )? '\\n' )?
{

Match("<endif>"); if (state.failed) return ;

-					// Language\\AngleBracketTemplateLexer.g3:131:4: ({...}? => ( '\\r' )? '\\n' )?
+					// Language\\AngleBracketTemplateLexer.g3:132:4: ({...}? => ( '\\r' )? '\\n' )?
int alt12=2;
int LA12_0 = input.LA(1);

@@ -578,14 +595,14 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt12 )
{
case 1:
-						// Language\\AngleBracketTemplateLexer.g3:131:6: {...}? => ( '\\r' )? '\\n'
+						// Language\\AngleBracketTemplateLexer.g3:132:6: {...}? => ( '\\r' )? '\\n'
{
if ( !((startCol==0)) )
{
if (state.backtracking>0) {state.failed=true; return ;}
throw new FailedPredicateException(input, "ACTION", "startCol==0");
}
-						// Language\\AngleBracketTemplateLexer.g3:131:24: ( '\\r' )?
+						// Language\\AngleBracketTemplateLexer.g3:132:24: ( '\\r' )?
int alt11=2;
int LA11_0 = input.LA(1);

@@ -596,7 +613,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt11 )
{
case 1:
-							// Language\\AngleBracketTemplateLexer.g3:131:25: '\\r'
+							// Language\\AngleBracketTemplateLexer.g3:132:25: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -623,7 +640,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 5:
-					// Language\\AngleBracketTemplateLexer.g3:138:4: => '<@' (ch=~ ( '>' | '(' ) )+ ( '()>' | '>' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )? )
+					// Language\\AngleBracketTemplateLexer.g3:139:4: => '<@' (ch=~ ( '>' | '(' ) )+ ( '()>' | '>' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )? )
{

if ( state.backtracking == 0 )
@@ -634,7 +651,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
Match("<@"); if (state.failed) return ;

-					// Language\\AngleBracketTemplateLexer.g3:143:4: (ch=~ ( '>' | '(' ) )+
+					// Language\\AngleBracketTemplateLexer.g3:144:4: (ch=~ ( '>' | '(' ) )+
int cnt13=0;
for ( ; ; )
{
@@ -650,7 +667,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt13 )
{
case 1:
-							// Language\\AngleBracketTemplateLexer.g3:143:6: ch=~ ( '>' | '(' )
+							// Language\\AngleBracketTemplateLexer.g3:144:6: ch=~ ( '>' | '(' )
{
ch= input.LA(1);
input.Consume();
@@ -681,7 +698,7 @@ public partial class AngleBracketTemplateLexer : Lexer
{
t = builder.ToString();
}
-					// Language\\AngleBracketTemplateLexer.g3:145:4: ( '()>' | '>' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )? )
+					// Language\\AngleBracketTemplateLexer.g3:146:4: ( '()>' | '>' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )? )
int alt24=2;
int LA24_0 = input.LA(1);

@@ -703,7 +720,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt24 )
{
case 1:
-						// Language\\AngleBracketTemplateLexer.g3:145:6: '()>'
+						// Language\\AngleBracketTemplateLexer.g3:146:6: '()>'
{
Match("()>"); if (state.failed) return ;

@@ -717,7 +734,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 2:
-						// Language\\AngleBracketTemplateLexer.g3:149:6: '>' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )?
+						// Language\\AngleBracketTemplateLexer.g3:150:6: '>' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )?
{
Match('>'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -727,7 +744,7 @@ public partial class AngleBracketTemplateLexer : Lexer
builder.Append("::=");

}
-						// Language\\AngleBracketTemplateLexer.g3:154:5: (=> ( '\\r' )? '\\n' )?
+						// Language\\AngleBracketTemplateLexer.g3:155:5: (=> ( '\\r' )? '\\n' )?
int alt15=2;
int LA15_0 = input.LA(1);

@@ -739,7 +756,7 @@ public partial class AngleBracketTemplateLexer : Lexer
{
int LA15_4 = input.LA(3);

-								if ( (EvaluatePredicate(synpred8_AngleBracketTemplateLexer_fragment)) )
+								if ( (EvaluatePredicate(synpred9_AngleBracketTemplateLexer_fragment)) )
{
alt15=1;
}
@@ -749,7 +766,7 @@ public partial class AngleBracketTemplateLexer : Lexer
{
int LA15_2 = input.LA(2);

-							if ( (EvaluatePredicate(synpred8_AngleBracketTemplateLexer_fragment)) )
+							if ( (EvaluatePredicate(synpred9_AngleBracketTemplateLexer_fragment)) )
{
alt15=1;
}
@@ -757,10 +774,10 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt15 )
{
case 1:
-							// Language\\AngleBracketTemplateLexer.g3:154:7: => ( '\\r' )? '\\n'
+							// Language\\AngleBracketTemplateLexer.g3:155:7: => ( '\\r' )? '\\n'
{

-							// Language\\AngleBracketTemplateLexer.g3:154:22: ( '\\r' )?
+							// Language\\AngleBracketTemplateLexer.g3:155:22: ( '\\r' )?
int alt14=2;
int LA14_0 = input.LA(1);

@@ -771,7 +788,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt14 )
{
case 1:
-								// Language\\AngleBracketTemplateLexer.g3:154:23: '\\r'
+								// Language\\AngleBracketTemplateLexer.g3:155:23: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -793,7 +810,7 @@ public partial class AngleBracketTemplateLexer : Lexer
atLeft = false;

}
-						// Language\\AngleBracketTemplateLexer.g3:158:5: ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+
+						// Language\\AngleBracketTemplateLexer.g3:159:5: ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+
int cnt18=0;
for ( ; ; )
{
@@ -802,14 +819,14 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt18 )
{
case 1:
-								// Language\\AngleBracketTemplateLexer.g3:158:7: {...}? => (=> ( '\\r' )? '\\n' |ch= . )
+								// Language\\AngleBracketTemplateLexer.g3:159:7: {...}? => (=> ( '\\r' )? '\\n' |ch= . )
{
if ( !((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))) )
{
if (state.backtracking>0) {state.failed=true; return ;}
throw new FailedPredicateException(input, "ACTION", "!(UpcomingAtEND(1) || ( input.LA(1) == '\\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\\r' && input.LA(2) == '\\n' && UpcomingAtEND(3) ))");
}
-								// Language\\AngleBracketTemplateLexer.g3:159:6: (=> ( '\\r' )? '\\n' |ch= . )
+								// Language\\AngleBracketTemplateLexer.g3:160:6: (=> ( '\\r' )? '\\n' |ch= . )
int alt17=2;
int LA17_0 = input.LA(1);

@@ -817,7 +834,7 @@ public partial class AngleBracketTemplateLexer : Lexer
{
int LA17_1 = input.LA(2);

-									if ( (EvaluatePredicate(synpred9_AngleBracketTemplateLexer_fragment)) )
+									if ( (EvaluatePredicate(synpred10_AngleBracketTemplateLexer_fragment)) )
{
alt17=1;
}
@@ -837,7 +854,7 @@ public partial class AngleBracketTemplateLexer : Lexer
{
int LA17_2 = input.LA(2);

-									if ( (EvaluatePredicate(synpred9_AngleBracketTemplateLexer_fragment)) )
+									if ( (EvaluatePredicate(synpred10_AngleBracketTemplateLexer_fragment)) )
{
alt17=1;
}
@@ -867,10 +884,10 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt17 )
{
case 1:
-									// Language\\AngleBracketTemplateLexer.g3:159:8: => ( '\\r' )? '\\n'
+									// Language\\AngleBracketTemplateLexer.g3:160:8: => ( '\\r' )? '\\n'
{

-									// Language\\AngleBracketTemplateLexer.g3:159:23: ( '\\r' )?
+									// Language\\AngleBracketTemplateLexer.g3:160:23: ( '\\r' )?
int alt16=2;
int LA16_0 = input.LA(1);

@@ -881,7 +898,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt16 )
{
case 1:
-										// Language\\AngleBracketTemplateLexer.g3:159:24: '\\r'
+										// Language\\AngleBracketTemplateLexer.g3:160:24: '\\r'
{
Match('\r'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -903,7 +920,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 2:
-									// Language\\AngleBracketTemplateLexer.g3:160:8: ch= .
+									// Language\\AngleBracketTemplateLexer.g3:161:8: ch= .
{
ch = input.LA(1);
MatchAny(); if (state.failed) return ;
@@ -935,7 +952,7 @@ public partial class AngleBracketTemplateLexer : Lexer
;


-						// Language\\AngleBracketTemplateLexer.g3:163:5: (=> ( '\\r' )? '\\n' )?
+						// Language\\AngleBracketTemplateLexer.g3:164:5: (=> ( '\\r' )? '\\n' )?
int alt20=2;
int LA20_0 = input.LA(1);

@@ -947,11 +964,11 @@ public partial class AngleBracketTemplateLexer : Lexer
{
int LA20_4 = input.LA(3);

-								if ( (LA20_4=='<') && (EvaluatePredicate(synpred10_AngleBracketTemplateLexer_fragment)))
+								if ( (LA20_4=='<') && (EvaluatePredicate(synpred11_AngleBracketTemplateLexer_fragment)))
{
alt20=1;
}
-								else if ( ((LA20_4>='\u0000' && LA20_4<=';')||(LA20_4>='=' && LA20_4<='\uFFFF')) && (EvaluatePredicate(synpred10_AngleBracketTemplateLexer_fragment)))
+								else if ( ((LA20_4>='\u0000' && LA20_4<=';')||(LA20_4>='=' && LA20_4<='\uFFFF')) && (EvaluatePredicate(synpred11_AngleBracketTemplateLexer_fragment)))
{
alt20=1;
}
@@ -961,7 +978,7 @@ public partial class AngleBracketTemplateLexer : Lexer
{
int LA20_2 = input.LA(2);

-							if ( (LA20_2=='<') && (EvaluatePredicate(synpred10_AngleBracketTemplateLexer_fragment)))
+							if ( (LA20_2=='<') && (EvaluatePredicate(synpred11_AngleBracketTemplateLexer_fragment)))
{
alt20=1;
}
@@ -969,7 +986,7 @@ public partial class AngleBracketTemplateLexer : Lexer
{
int LA20_6 = input.LA(3);

-								if ( (EvaluatePredicate(synpred10_AngleBracketTemplateLexer_fragment)) )
+								if ( (EvaluatePredicate(synpred11_AngleBracketTemplateLexer_fragment)) )
{
alt20=1;
}
@@ -978,12 +995,12 @@ public partial class AngleBracketTemplateLexer : Lexer
{
int LA20_7 = input.LA(3);

-								if ( (EvaluatePredicate(synpred10_AngleBracketTemplateLexer_fragment)) )
+								if ( (EvaluatePredicate(synpred11_AngleBracketTemplateLexer_fragment)) )
{
alt20=1;
}
}
-							else if ( ((LA20_2>='\u0000' && LA20_2<='\t')||(LA20_2>='\u000B' && LA20_2<='\f')||(LA20_2>='\u000E' && LA20_2<=';')||(LA20_2>='=' && LA20_2<='\uFFFF')) && (EvaluatePredicate(synpred10_AngleBracketTemplateLexer_fragment)))
+							else if ( ((LA20_2>='\u0000' && LA20_2<='\t')||(LA20_2>='\u000B' && LA20_2<='\f')||(LA20_2>='\u000E' && LA20_2<=';')||(LA20_2>='=' && LA20_2<='\uFFFF')) && (EvaluatePredicate(synpred11_AngleBracketTemplateLexer_fragment)))
{
alt20=1;
}
@@ -991,10 +1008,10 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt20 )
{
case 1:
-							// Language\\AngleBracketTemplateLexer.g3:163:7: => ( '\\r' )? '\\n'
+							// Language\\AngleBracketTemplateLexer.g3:164:7: => ( '\\r' )? '\\n'
{

-							// Language\\AngleBracketTemplateLexer.g3:163:22: ( '\\r' )?
+							// Language\\AngleBracketTemplateLexer.g3:164:22: ( '\\r' )?
int alt19=2;
int LA19_0 = input.LA(1);

@@ -1005,7 +1022,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt19 )
{
case 1:
-								// Language\\AngleBracketTemplateLexer.g3:163:23: '\\r'
+								// Language\\AngleBracketTemplateLexer.g3:164:23: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -1025,7 +1042,7 @@ public partial class AngleBracketTemplateLexer : Lexer

}

-						// Language\\AngleBracketTemplateLexer.g3:164:5: ( '<@end>' | . )
+						// Language\\AngleBracketTemplateLexer.g3:165:5: ( '<@end>' | . )
int alt21=2;
int LA21_0 = input.LA(1);

@@ -1055,7 +1072,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt21 )
{
case 1:
-							// Language\\AngleBracketTemplateLexer.g3:164:7: '<@end>'
+							// Language\\AngleBracketTemplateLexer.g3:165:7: '<@end>'
{
Match("<@end>"); if (state.failed) return ;

@@ -1063,7 +1080,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 2:
-							// Language\\AngleBracketTemplateLexer.g3:165:7: .
+							// Language\\AngleBracketTemplateLexer.g3:166:7: .
{
MatchAny(); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1076,7 +1093,7 @@ public partial class AngleBracketTemplateLexer : Lexer

}

-						// Language\\AngleBracketTemplateLexer.g3:167:5: ({...}? => ( '\\r' )? '\\n' )?
+						// Language\\AngleBracketTemplateLexer.g3:168:5: ({...}? => ( '\\r' )? '\\n' )?
int alt23=2;
int LA23_0 = input.LA(1);

@@ -1087,14 +1104,14 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt23 )
{
case 1:
-							// Language\\AngleBracketTemplateLexer.g3:167:7: {...}? => ( '\\r' )? '\\n'
+							// Language\\AngleBracketTemplateLexer.g3:168:7: {...}? => ( '\\r' )? '\\n'
{
if ( !((atLeft)) )
{
if (state.backtracking>0) {state.failed=true; return ;}
throw new FailedPredicateException(input, "ACTION", "atLeft");
}
-							// Language\\AngleBracketTemplateLexer.g3:167:20: ( '\\r' )?
+							// Language\\AngleBracketTemplateLexer.g3:168:20: ( '\\r' )?
int alt22=2;
int LA22_0 = input.LA(1);

@@ -1105,7 +1122,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt22 )
{
case 1:
-								// Language\\AngleBracketTemplateLexer.g3:167:21: '\\r'
+								// Language\\AngleBracketTemplateLexer.g3:168:21: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -1137,7 +1154,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 6:
-					// Language\\AngleBracketTemplateLexer.g3:172:5: '<' EXPR[out subtext] '>'
+					// Language\\AngleBracketTemplateLexer.g3:173:5: '<' EXPR[out subtext] '>'
{
Match('<'); if (state.failed) return ;
mEXPR(out subtext); if (state.failed) return ;
@@ -1189,10 +1206,10 @@ public partial class AngleBracketTemplateLexer : Lexer
int loopStartIndex = 0;
int col = 0;

-			// Language\\AngleBracketTemplateLexer.g3:189:4: ( ( ( '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) ) ) |ind= INDENT |ch=~ ( '\\\\' | ' ' | '\\t' | '<' | '\\r' | '\\n' ) )+ )
-			// Language\\AngleBracketTemplateLexer.g3:189:4: ( ( '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) ) ) |ind= INDENT |ch=~ ( '\\\\' | ' ' | '\\t' | '<' | '\\r' | '\\n' ) )+
+			// Language\\AngleBracketTemplateLexer.g3:190:4: ( ( ( '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) ) ) |ind= INDENT |ch=~ ( '\\\\' | ' ' | '\\t' | '<' | '\\r' | '\\n' ) )+ )
+			// Language\\AngleBracketTemplateLexer.g3:190:4: ( ( '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) ) ) |ind= INDENT |ch=~ ( '\\\\' | ' ' | '\\t' | '<' | '\\r' | '\\n' ) )+
{
-			// Language\\AngleBracketTemplateLexer.g3:189:4: ( ( '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) ) ) |ind= INDENT |ch=~ ( '\\\\' | ' ' | '\\t' | '<' | '\\r' | '\\n' ) )+
+			// Language\\AngleBracketTemplateLexer.g3:190:4: ( ( '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) ) ) |ind= INDENT |ch=~ ( '\\\\' | ' ' | '\\t' | '<' | '\\r' | '\\n' ) )+
int cnt28=0;
for ( ; ; )
{
@@ -1216,13 +1233,13 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt28 )
{
case 1:
-					// Language\\AngleBracketTemplateLexer.g3:189:6: ( '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) ) )
+					// Language\\AngleBracketTemplateLexer.g3:190:6: ( '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) ) )
{
-					// Language\\AngleBracketTemplateLexer.g3:189:6: ( '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) ) )
-					// Language\\AngleBracketTemplateLexer.g3:189:8: '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) )
+					// Language\\AngleBracketTemplateLexer.g3:190:6: ( '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) ) )
+					// Language\\AngleBracketTemplateLexer.g3:190:8: '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) )
{
Match('\\'); if (state.failed) return ;
-					// Language\\AngleBracketTemplateLexer.g3:190:5: ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) )
+					// Language\\AngleBracketTemplateLexer.g3:191:5: ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) )
int alt27=4;
int LA27_0 = input.LA(1);

@@ -1252,7 +1269,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt27 )
{
case 1:
-						// Language\\AngleBracketTemplateLexer.g3:190:7: '<'
+						// Language\\AngleBracketTemplateLexer.g3:191:7: '<'
{
Match('<'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1263,7 +1280,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 2:
-						// Language\\AngleBracketTemplateLexer.g3:191:7: '>'
+						// Language\\AngleBracketTemplateLexer.g3:192:7: '>'
{
Match('>'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1274,7 +1291,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 3:
-						// Language\\AngleBracketTemplateLexer.g3:192:7: '\\\\'
+						// Language\\AngleBracketTemplateLexer.g3:193:7: '\\\\'
{
Match('\\'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1285,7 +1302,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 4:
-						// Language\\AngleBracketTemplateLexer.g3:193:7: ch=~ ( '<' | '>' | '\\\\' )
+						// Language\\AngleBracketTemplateLexer.g3:194:7: ch=~ ( '<' | '>' | '\\\\' )
{
ch= input.LA(1);
input.Consume();
@@ -1307,11 +1324,11 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 2:
-					// Language\\AngleBracketTemplateLexer.g3:196:5: ind= INDENT
+					// Language\\AngleBracketTemplateLexer.g3:197:5: ind= INDENT
{
-					int indStart686 = CharIndex;
+					int indStart699 = CharIndex;
mINDENT(); if (state.failed) return ;
-					ind = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, indStart686, CharIndex-1);
+					ind = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, indStart699, CharIndex-1);
if ( state.backtracking == 0 )
{

@@ -1335,7 +1352,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 3:
-					// Language\\AngleBracketTemplateLexer.g3:213:5: ch=~ ( '\\\\' | ' ' | '\\t' | '<' | '\\r' | '\\n' )
+					// Language\\AngleBracketTemplateLexer.g3:214:5: ch=~ ( '\\\\' | ' ' | '\\t' | '<' | '\\r' | '\\n' )
{
ch= input.LA(1);
input.Consume();
@@ -1389,10 +1406,10 @@ public partial class AngleBracketTemplateLexer : Lexer
{
try
{
-			// Language\\AngleBracketTemplateLexer.g3:226:4: ( ( ' ' | '\\t' )+ )
-			// Language\\AngleBracketTemplateLexer.g3:226:4: ( ' ' | '\\t' )+
+			// Language\\AngleBracketTemplateLexer.g3:227:4: ( ( ' ' | '\\t' )+ )
+			// Language\\AngleBracketTemplateLexer.g3:227:4: ( ' ' | '\\t' )+
{
-			// Language\\AngleBracketTemplateLexer.g3:226:4: ( ' ' | '\\t' )+
+			// Language\\AngleBracketTemplateLexer.g3:227:4: ( ' ' | '\\t' )+
int cnt29=0;
for ( ; ; )
{
@@ -1454,10 +1471,10 @@ public partial class AngleBracketTemplateLexer : Lexer
_text = string.Empty;
System.Text.StringBuilder builder = new System.Text.StringBuilder();

-			// Language\\AngleBracketTemplateLexer.g3:237:4: ( ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '>' ) )+ )
-			// Language\\AngleBracketTemplateLexer.g3:237:4: ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '>' ) )+
+			// Language\\AngleBracketTemplateLexer.g3:238:4: ( ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '>' ) )+ )
+			// Language\\AngleBracketTemplateLexer.g3:238:4: ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '>' ) )+
{
-			// Language\\AngleBracketTemplateLexer.g3:237:4: ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '>' ) )+
+			// Language\\AngleBracketTemplateLexer.g3:238:4: ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '>' ) )+
int cnt32=0;
for ( ; ; )
{
@@ -1485,11 +1502,11 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt32 )
{
case 1:
-					// Language\\AngleBracketTemplateLexer.g3:237:6: ESC
+					// Language\\AngleBracketTemplateLexer.g3:238:6: ESC
{
-					int ESC1Start766 = CharIndex;
+					int ESC1Start778 = CharIndex;
mESC(); if (state.failed) return ;
-					ESC1 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ESC1Start766, CharIndex-1);
+					ESC1 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ESC1Start778, CharIndex-1);
if ( state.backtracking == 0 )
{
builder.Append((ESC1!=null?ESC1.Text:null));
@@ -1498,11 +1515,11 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 2:
-					// Language\\AngleBracketTemplateLexer.g3:238:5: st= SUBTEMPLATE
+					// Language\\AngleBracketTemplateLexer.g3:239:5: st= SUBTEMPLATE
{
-					int stStart784 = CharIndex;
+					int stStart796 = CharIndex;
mSUBTEMPLATE(); if (state.failed) return ;
-					st = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, stStart784, CharIndex-1);
+					st = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, stStart796, CharIndex-1);
if ( state.backtracking == 0 )
{
builder.Append((st!=null?st.Text:null));
@@ -1511,9 +1528,9 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 3:
-					// Language\\AngleBracketTemplateLexer.g3:239:5: ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) )
+					// Language\\AngleBracketTemplateLexer.g3:240:5: ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) )
{
-					// Language\\AngleBracketTemplateLexer.g3:239:5: ( '=' | '+' )
+					// Language\\AngleBracketTemplateLexer.g3:240:5: ( '=' | '+' )
int alt30=2;
int LA30_0 = input.LA(1);

@@ -1535,7 +1552,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt30 )
{
case 1:
-						// Language\\AngleBracketTemplateLexer.g3:239:7: '='
+						// Language\\AngleBracketTemplateLexer.g3:240:7: '='
{
Match('='); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1546,7 +1563,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 2:
-						// Language\\AngleBracketTemplateLexer.g3:240:6: '+'
+						// Language\\AngleBracketTemplateLexer.g3:241:6: '+'
{
Match('+'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1559,7 +1576,7 @@ public partial class AngleBracketTemplateLexer : Lexer

}

-					// Language\\AngleBracketTemplateLexer.g3:242:4: ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) )
+					// Language\\AngleBracketTemplateLexer.g3:243:4: ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) )
int alt31=3;
int LA31_0 = input.LA(1);

@@ -1585,7 +1602,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt31 )
{
case 1:
-						// Language\\AngleBracketTemplateLexer.g3:242:6: TEMPLATE[out subtext]
+						// Language\\AngleBracketTemplateLexer.g3:243:6: TEMPLATE[out subtext]
{
mTEMPLATE(out subtext); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1596,11 +1613,11 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 2:
-						// Language\\AngleBracketTemplateLexer.g3:243:6: st= SUBTEMPLATE
+						// Language\\AngleBracketTemplateLexer.g3:244:6: st= SUBTEMPLATE
{
-						int stStart850 = CharIndex;
+						int stStart862 = CharIndex;
mSUBTEMPLATE(); if (state.failed) return ;
-						st = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, stStart850, CharIndex-1);
+						st = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, stStart862, CharIndex-1);
if ( state.backtracking == 0 )
{
builder.Append((st!=null?st.Text:null));
@@ -1609,7 +1626,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 3:
-						// Language\\AngleBracketTemplateLexer.g3:244:6: ch=~ ( '\"' | '<' | '{' )
+						// Language\\AngleBracketTemplateLexer.g3:245:6: ch=~ ( '\"' | '<' | '{' )
{
ch= input.LA(1);
input.Consume();
@@ -1628,7 +1645,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 4:
-					// Language\\AngleBracketTemplateLexer.g3:246:5: ch=~ ( '\\\\' | '{' | '=' | '+' | '>' )
+					// Language\\AngleBracketTemplateLexer.g3:247:5: ch=~ ( '\\\\' | '{' | '=' | '+' | '>' )
{
ch= input.LA(1);
input.Consume();
@@ -1681,7 +1698,7 @@ public partial class AngleBracketTemplateLexer : Lexer
_text = string.Empty;
System.Text.StringBuilder builder = new System.Text.StringBuilder();

-			// Language\\AngleBracketTemplateLexer.g3:258:4: ( '\"' ( ESC |ch=~ ( '\\\\' | '\"' ) )* '\"' | '<<' (=> ( '\\r' )? '\\n' )? ( options {k=2; } :=> ( '\\r' )? '\\n' |=>ch= . )* '>>' )
+			// Language\\AngleBracketTemplateLexer.g3:259:4: ( '\"' ( ESC |ch=~ ( '\\\\' | '\"' ) )* '\"' | '<<' (=> ( '\\r' )? '\\n' )? ( options {k=2; } :=> ( '\\r' )? '\\n' |=>ch= . )* '>>' )
int alt38=2;
int LA38_0 = input.LA(1);

@@ -1703,14 +1720,14 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt38 )
{
case 1:
-				// Language\\AngleBracketTemplateLexer.g3:258:4: '\"' ( ESC |ch=~ ( '\\\\' | '\"' ) )* '\"'
+				// Language\\AngleBracketTemplateLexer.g3:259:4: '\"' ( ESC |ch=~ ( '\\\\' | '\"' ) )* '\"'
{
Match('\"'); if (state.failed) return ;
if ( state.backtracking == 0 )
{
builder.Append('"');
}
-				// Language\\AngleBracketTemplateLexer.g3:260:3: ( ESC |ch=~ ( '\\\\' | '\"' ) )*
+				// Language\\AngleBracketTemplateLexer.g3:261:3: ( ESC |ch=~ ( '\\\\' | '\"' ) )*
for ( ; ; )
{
int alt33=3;
@@ -1729,11 +1746,11 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt33 )
{
case 1:
-						// Language\\AngleBracketTemplateLexer.g3:260:5: ESC
+						// Language\\AngleBracketTemplateLexer.g3:261:5: ESC
{
-						int ESC2Start943 = CharIndex;
+						int ESC2Start955 = CharIndex;
mESC(); if (state.failed) return ;
-						ESC2 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ESC2Start943, CharIndex-1);
+						ESC2 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ESC2Start955, CharIndex-1);
if ( state.backtracking == 0 )
{
builder.Append((ESC2!=null?ESC2.Text:null));
@@ -1742,7 +1759,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 2:
-						// Language\\AngleBracketTemplateLexer.g3:261:5: ch=~ ( '\\\\' | '\"' )
+						// Language\\AngleBracketTemplateLexer.g3:262:5: ch=~ ( '\\\\' | '\"' )
{
ch= input.LA(1);
input.Consume();
@@ -1776,7 +1793,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 2:
-				// Language\\AngleBracketTemplateLexer.g3:268:4: '<<' (=> ( '\\r' )? '\\n' )? ( options {k=2; } :=> ( '\\r' )? '\\n' |=>ch= . )* '>>'
+				// Language\\AngleBracketTemplateLexer.g3:269:4: '<<' (=> ( '\\r' )? '\\n' )? ( options {k=2; } :=> ( '\\r' )? '\\n' |=>ch= . )* '>>'
{
Match("<<"); if (state.failed) return ;

@@ -1786,7 +1803,7 @@ public partial class AngleBracketTemplateLexer : Lexer
builder.Append("<<");

}
-				// Language\\AngleBracketTemplateLexer.g3:272:3: (=> ( '\\r' )? '\\n' )?
+				// Language\\AngleBracketTemplateLexer.g3:273:3: (=> ( '\\r' )? '\\n' )?
int alt35=2;
int LA35_0 = input.LA(1);

@@ -1798,7 +1815,7 @@ public partial class AngleBracketTemplateLexer : Lexer
{
int LA35_2 = input.LA(3);

-						if ( (EvaluatePredicate(synpred11_AngleBracketTemplateLexer_fragment)) )
+						if ( (EvaluatePredicate(synpred12_AngleBracketTemplateLexer_fragment)) )
{
alt35=1;
}
@@ -1808,7 +1825,7 @@ public partial class AngleBracketTemplateLexer : Lexer
{
int LA35_2 = input.LA(2);

-					if ( (EvaluatePredicate(synpred11_AngleBracketTemplateLexer_fragment)) )
+					if ( (EvaluatePredicate(synpred12_AngleBracketTemplateLexer_fragment)) )
{
alt35=1;
}
@@ -1816,10 +1833,10 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt35 )
{
case 1:
-					// Language\\AngleBracketTemplateLexer.g3:272:5: => ( '\\r' )? '\\n'
+					// Language\\AngleBracketTemplateLexer.g3:273:5: => ( '\\r' )? '\\n'
{

-					// Language\\AngleBracketTemplateLexer.g3:272:20: ( '\\r' )?
+					// Language\\AngleBracketTemplateLexer.g3:273:20: ( '\\r' )?
int alt34=2;
int LA34_0 = input.LA(1);

@@ -1830,7 +1847,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt34 )
{
case 1:
-						// Language\\AngleBracketTemplateLexer.g3:272:21: '\\r'
+						// Language\\AngleBracketTemplateLexer.g3:273:21: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -1846,7 +1863,7 @@ public partial class AngleBracketTemplateLexer : Lexer

}

-				// Language\\AngleBracketTemplateLexer.g3:273:3: ( options {k=2; } :=> ( '\\r' )? '\\n' |=>ch= . )*
+				// Language\\AngleBracketTemplateLexer.g3:274:3: ( options {k=2; } :=> ( '\\r' )? '\\n' |=>ch= . )*
for ( ; ; )
{
int alt37=3;
@@ -1854,10 +1871,10 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt37 )
{
case 1:
-						// Language\\AngleBracketTemplateLexer.g3:274:4: => ( '\\r' )? '\\n'
+						// Language\\AngleBracketTemplateLexer.g3:275:4: => ( '\\r' )? '\\n'
{

-						// Language\\AngleBracketTemplateLexer.g3:274:22: ( '\\r' )?
+						// Language\\AngleBracketTemplateLexer.g3:275:22: ( '\\r' )?
int alt36=2;
int LA36_0 = input.LA(1);

@@ -1868,7 +1885,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt36 )
{
case 1:
-							// Language\\AngleBracketTemplateLexer.g3:274:23: '\\r'
+							// Language\\AngleBracketTemplateLexer.g3:275:23: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -1882,7 +1899,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 2:
-						// Language\\AngleBracketTemplateLexer.g3:275:5: =>ch= .
+						// Language\\AngleBracketTemplateLexer.g3:276:5: =>ch= .
{

ch = input.LA(1);
@@ -1930,10 +1947,10 @@ public partial class AngleBracketTemplateLexer : Lexer
{
try
{
-			// Language\\AngleBracketTemplateLexer.g3:286:4: ( ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+ )
-			// Language\\AngleBracketTemplateLexer.g3:286:4: ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+
+			// Language\\AngleBracketTemplateLexer.g3:287:4: ( ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+ )
+			// Language\\AngleBracketTemplateLexer.g3:287:4: ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+
{
-			// Language\\AngleBracketTemplateLexer.g3:286:4: ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+
+			// Language\\AngleBracketTemplateLexer.g3:287:4: ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+
int cnt39=0;
for ( ; ; )
{
@@ -1961,28 +1978,28 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt39 )
{
case 1:
-					// Language\\AngleBracketTemplateLexer.g3:286:6: ESC
+					// Language\\AngleBracketTemplateLexer.g3:287:6: ESC
{
mESC(); if (state.failed) return ;

}
break;
case 2:
-					// Language\\AngleBracketTemplateLexer.g3:287:5: SUBTEMPLATE
+					// Language\\AngleBracketTemplateLexer.g3:288:5: SUBTEMPLATE
{
mSUBTEMPLATE(); if (state.failed) return ;

}
break;
case 3:
-					// Language\\AngleBracketTemplateLexer.g3:288:5: NESTED_PARENS
+					// Language\\AngleBracketTemplateLexer.g3:289:5: NESTED_PARENS
{
mNESTED_PARENS(); if (state.failed) return ;

}
break;
case 4:
-					// Language\\AngleBracketTemplateLexer.g3:289:5: ~ ( '\\\\' | '{' | '(' | ')' )
+					// Language\\AngleBracketTemplateLexer.g3:290:5: ~ ( '\\\\' | '{' | '(' | ')' )
{
input.Consume();
state.failed=false;
@@ -2027,11 +2044,11 @@ public partial class AngleBracketTemplateLexer : Lexer

uc = '\0';

-			// Language\\AngleBracketTemplateLexer.g3:299:4: ( '\\\\' ( 'n' | 'r' | 't' | ' ' | 'u' a= HEX b= HEX c= HEX d= HEX ) )
-			// Language\\AngleBracketTemplateLexer.g3:299:4: '\\\\' ( 'n' | 'r' | 't' | ' ' | 'u' a= HEX b= HEX c= HEX d= HEX )
+			// Language\\AngleBracketTemplateLexer.g3:300:4: ( '\\\\' ( 'n' | 'r' | 't' | ' ' | 'u' a= HEX b= HEX c= HEX d= HEX ) )
+			// Language\\AngleBracketTemplateLexer.g3:300:4: '\\\\' ( 'n' | 'r' | 't' | ' ' | 'u' a= HEX b= HEX c= HEX d= HEX )
{
Match('\\'); if (state.failed) return ;
-			// Language\\AngleBracketTemplateLexer.g3:300:3: ( 'n' | 'r' | 't' | ' ' | 'u' a= HEX b= HEX c= HEX d= HEX )
+			// Language\\AngleBracketTemplateLexer.g3:301:3: ( 'n' | 'r' | 't' | ' ' | 'u' a= HEX b= HEX c= HEX d= HEX )
int alt40=5;
switch ( input.LA(1) )
{
@@ -2072,7 +2089,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt40 )
{
case 1:
-				// Language\\AngleBracketTemplateLexer.g3:300:5: 'n'
+				// Language\\AngleBracketTemplateLexer.g3:301:5: 'n'
{
Match('n'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -2083,7 +2100,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 2:
-				// Language\\AngleBracketTemplateLexer.g3:301:5: 'r'
+				// Language\\AngleBracketTemplateLexer.g3:302:5: 'r'
{
Match('r'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -2094,7 +2111,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 3:
-				// Language\\AngleBracketTemplateLexer.g3:302:5: 't'
+				// Language\\AngleBracketTemplateLexer.g3:303:5: 't'
{
Match('t'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -2105,7 +2122,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 4:
-				// Language\\AngleBracketTemplateLexer.g3:303:5: ' '
+				// Language\\AngleBracketTemplateLexer.g3:304:5: ' '
{
Match(' '); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -2116,21 +2133,21 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 5:
-				// Language\\AngleBracketTemplateLexer.g3:304:5: 'u' a= HEX b= HEX c= HEX d= HEX
+				// Language\\AngleBracketTemplateLexer.g3:305:5: 'u' a= HEX b= HEX c= HEX d= HEX
{
Match('u'); if (state.failed) return ;
-				int aStart1191 = CharIndex;
+				int aStart1203 = CharIndex;
mHEX(); if (state.failed) return ;
-				a = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, aStart1191, CharIndex-1);
-				int bStart1195 = CharIndex;
+				a = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, aStart1203, CharIndex-1);
+				int bStart1207 = CharIndex;
mHEX(); if (state.failed) return ;
-				b = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, bStart1195, CharIndex-1);
-				int cStart1199 = CharIndex;
+				b = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, bStart1207, CharIndex-1);
+				int cStart1211 = CharIndex;
mHEX(); if (state.failed) return ;
-				c = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, cStart1199, CharIndex-1);
-				int dStart1203 = CharIndex;
+				c = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, cStart1211, CharIndex-1);
+				int dStart1215 = CharIndex;
mHEX(); if (state.failed) return ;
-				d = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, dStart1203, CharIndex-1);
+				d = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, dStart1215, CharIndex-1);
if ( state.backtracking == 0 )
{
uc = (char)int.Parse((a!=null?a.Text:null)+(b!=null?b.Text:null)+(c!=null?c.Text:null)+(d!=null?d.Text:null), System.Globalization.NumberStyles.AllowHexSpecifier);
@@ -2156,8 +2173,8 @@ public partial class AngleBracketTemplateLexer : Lexer
{
try
{
-			// Language\\AngleBracketTemplateLexer.g3:312:4: ( '\\\\' . )
-			// Language\\AngleBracketTemplateLexer.g3:312:4: '\\\\' .
+			// Language\\AngleBracketTemplateLexer.g3:313:4: ( '\\\\' . )
+			// Language\\AngleBracketTemplateLexer.g3:313:4: '\\\\' .
{
Match('\\'); if (state.failed) return ;
MatchAny(); if (state.failed) return ;
@@ -2176,7 +2193,7 @@ public partial class AngleBracketTemplateLexer : Lexer
{
try
{
-			// Language\\AngleBracketTemplateLexer.g3:317:4: ( '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' )
+			// Language\\AngleBracketTemplateLexer.g3:318:4: ( '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' )
// Language\\AngleBracketTemplateLexer.g3:
{
if ( (input.LA(1)>='0' && input.LA(1)<='9')||(input.LA(1)>='A' && input.LA(1)<='F')||(input.LA(1)>='a' && input.LA(1)<='f') )
@@ -2206,11 +2223,11 @@ public partial class AngleBracketTemplateLexer : Lexer
{
try
{
-			// Language\\AngleBracketTemplateLexer.g3:322:4: ( '{' ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )* '}' )
-			// Language\\AngleBracketTemplateLexer.g3:322:4: '{' ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )* '}'
+			// Language\\AngleBracketTemplateLexer.g3:323:4: ( '{' ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )* '}' )
+			// Language\\AngleBracketTemplateLexer.g3:323:4: '{' ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )* '}'
{
Match('{'); if (state.failed) return ;
-			// Language\\AngleBracketTemplateLexer.g3:323:3: ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )*
+			// Language\\AngleBracketTemplateLexer.g3:324:3: ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )*
for ( ; ; )
{
int alt41=4;
@@ -2233,21 +2250,21 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt41 )
{
case 1:
-					// Language\\AngleBracketTemplateLexer.g3:323:5: SUBTEMPLATE
+					// Language\\AngleBracketTemplateLexer.g3:324:5: SUBTEMPLATE
{
mSUBTEMPLATE(); if (state.failed) return ;

}
break;
case 2:
-					// Language\\AngleBracketTemplateLexer.g3:324:5: ESC
+					// Language\\AngleBracketTemplateLexer.g3:325:5: ESC
{
mESC(); if (state.failed) return ;

}
break;
case 3:
-					// Language\\AngleBracketTemplateLexer.g3:325:5: ~ ( '{' | '\\\\' | '}' )
+					// Language\\AngleBracketTemplateLexer.g3:326:5: ~ ( '{' | '\\\\' | '}' )
{
input.Consume();
state.failed=false;
@@ -2280,11 +2297,11 @@ public partial class AngleBracketTemplateLexer : Lexer
{
try
{
-			// Language\\AngleBracketTemplateLexer.g3:332:4: ( '(' ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+ ')' )
-			// Language\\AngleBracketTemplateLexer.g3:332:4: '(' ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+ ')'
+			// Language\\AngleBracketTemplateLexer.g3:333:4: ( '(' ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+ ')' )
+			// Language\\AngleBracketTemplateLexer.g3:333:4: '(' ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+ ')'
{
Match('('); if (state.failed) return ;
-			// Language\\AngleBracketTemplateLexer.g3:333:3: ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+
+			// Language\\AngleBracketTemplateLexer.g3:334:3: ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+
int cnt42=0;
for ( ; ; )
{
@@ -2308,21 +2325,21 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt42 )
{
case 1:
-					// Language\\AngleBracketTemplateLexer.g3:333:5: NESTED_PARENS
+					// Language\\AngleBracketTemplateLexer.g3:334:5: NESTED_PARENS
{
mNESTED_PARENS(); if (state.failed) return ;

}
break;
case 2:
-					// Language\\AngleBracketTemplateLexer.g3:334:5: ESC
+					// Language\\AngleBracketTemplateLexer.g3:335:5: ESC
{
mESC(); if (state.failed) return ;

}
break;
case 3:
-					// Language\\AngleBracketTemplateLexer.g3:335:5: ~ ( '(' | '\\\\' | ')' )
+					// Language\\AngleBracketTemplateLexer.g3:336:5: ~ ( '(' | '\\\\' | ')' )
{
input.Consume();
state.failed=false;
@@ -2363,12 +2380,12 @@ public partial class AngleBracketTemplateLexer : Lexer

int startCol = CharPositionInLine;

-			// Language\\AngleBracketTemplateLexer.g3:346:4: ( '<!' ( . )* '!>' ({...}? => ( '\\r' )? '\\n' )? )
-			// Language\\AngleBracketTemplateLexer.g3:346:4: '<!' ( . )* '!>' ({...}? => ( '\\r' )? '\\n' )?
+			// Language\\AngleBracketTemplateLexer.g3:347:4: ( '<!' ( . )* '!>' ({...}? => ( '\\r' )? '\\n' )? )
+			// Language\\AngleBracketTemplateLexer.g3:347:4: '<!' ( . )* '!>' ({...}? => ( '\\r' )? '\\n' )?
{
Match("<!"); if (state.failed) return ;

-			// Language\\AngleBracketTemplateLexer.g3:346:9: ( . )*
+			// Language\\AngleBracketTemplateLexer.g3:347:9: ( . )*
for ( ; ; )
{
int alt43=2;
@@ -2398,7 +2415,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt43 )
{
case 1:
-					// Language\\AngleBracketTemplateLexer.g3:346:0: .
+					// Language\\AngleBracketTemplateLexer.g3:347:0: .
{
MatchAny(); if (state.failed) return ;

@@ -2416,7 +2433,7 @@ public partial class AngleBracketTemplateLexer : Lexer

Match("!>"); if (state.failed) return ;

-			// Language\\AngleBracketTemplateLexer.g3:347:3: ({...}? => ( '\\r' )? '\\n' )?
+			// Language\\AngleBracketTemplateLexer.g3:348:3: ({...}? => ( '\\r' )? '\\n' )?
int alt45=2;
int LA45_0 = input.LA(1);

@@ -2427,14 +2444,14 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt45 )
{
case 1:
-				// Language\\AngleBracketTemplateLexer.g3:347:5: {...}? => ( '\\r' )? '\\n'
+				// Language\\AngleBracketTemplateLexer.g3:348:5: {...}? => ( '\\r' )? '\\n'
{
if ( !((startCol==0)) )
{
if (state.backtracking>0) {state.failed=true; return ;}
throw new FailedPredicateException(input, "COMMENT", "startCol==0");
}
-				// Language\\AngleBracketTemplateLexer.g3:347:23: ( '\\r' )?
+				// Language\\AngleBracketTemplateLexer.g3:348:23: ( '\\r' )?
int alt44=2;
int LA44_0 = input.LA(1);

@@ -2445,7 +2462,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt44 )
{
case 1:
-					// Language\\AngleBracketTemplateLexer.g3:347:24: '\\r'
+					// Language\\AngleBracketTemplateLexer.g3:348:24: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -2471,32 +2488,113 @@ public partial class AngleBracketTemplateLexer : Lexer
}
// $ANTLR end "COMMENT"

+	// $ANTLR start "LINE_BREAK"
+	private void mLINE_BREAK()
+	{
+		try
+		{
+			// Language\\AngleBracketTemplateLexer.g3:353:4: ( '<\\\\\\\\>' ( INDENT )? ( '\\r' )? '\\n' ( INDENT )? )
+			// Language\\AngleBracketTemplateLexer.g3:353:4: '<\\\\\\\\>' ( INDENT )? ( '\\r' )? '\\n' ( INDENT )?
+			{
+			Match("<\\\\>"); if (state.failed) return ;
+
+			// Language\\AngleBracketTemplateLexer.g3:353:13: ( INDENT )?
+			int alt46=2;
+			int LA46_0 = input.LA(1);
+
+			if ( (LA46_0=='\t'||LA46_0==' ') )
+			{
+				alt46=1;
+			}
+			switch ( alt46 )
+			{
+			case 1:
+				// Language\\AngleBracketTemplateLexer.g3:353:0: INDENT
+				{
+				mINDENT(); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+			// Language\\AngleBracketTemplateLexer.g3:353:21: ( '\\r' )?
+			int alt47=2;
+			int LA47_0 = input.LA(1);
+
+			if ( (LA47_0=='\r') )
+			{
+				alt47=1;
+			}
+			switch ( alt47 )
+			{
+			case 1:
+				// Language\\AngleBracketTemplateLexer.g3:353:0: '\\r'
+				{
+				Match('\r'); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+			Match('\n'); if (state.failed) return ;
+			// Language\\AngleBracketTemplateLexer.g3:353:32: ( INDENT )?
+			int alt48=2;
+			int LA48_0 = input.LA(1);
+
+			if ( (LA48_0=='\t'||LA48_0==' ') )
+			{
+				alt48=1;
+			}
+			switch ( alt48 )
+			{
+			case 1:
+				// Language\\AngleBracketTemplateLexer.g3:353:0: INDENT
+				{
+				mINDENT(); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "LINE_BREAK"
+
public override void mTokens()
{
// Language\\AngleBracketTemplateLexer.g3:1:10: ( NEWLINE | ACTION | LITERAL )
-		int alt46=3;
-		int LA46_0 = input.LA(1);
+		int alt49=3;
+		int LA49_0 = input.LA(1);

-		if ( (LA46_0=='\n'||LA46_0=='\r') )
+		if ( (LA49_0=='\n'||LA49_0=='\r') )
{
-			alt46=1;
+			alt49=1;
}
-		else if ( (LA46_0=='<') )
+		else if ( (LA49_0=='<') )
{
-			alt46=2;
+			alt49=2;
}
-		else if ( ((LA46_0>='\u0000' && LA46_0<='\t')||(LA46_0>='\u000B' && LA46_0<='\f')||(LA46_0>='\u000E' && LA46_0<=';')||(LA46_0>='=' && LA46_0<='\uFFFF')) )
+		else if ( ((LA49_0>='\u0000' && LA49_0<='\t')||(LA49_0>='\u000B' && LA49_0<='\f')||(LA49_0>='\u000E' && LA49_0<=';')||(LA49_0>='=' && LA49_0<='\uFFFF')) )
{
-			alt46=3;
+			alt49=3;
}
else
{
if (state.backtracking>0) {state.failed=true; return ;}
-			NoViableAltException nvae = new NoViableAltException("", 46, 0, input);
+			NoViableAltException nvae = new NoViableAltException("", 49, 0, input);

throw nvae;
}
-		switch ( alt46 )
+		switch ( alt49 )
{
case 1:
// Language\\AngleBracketTemplateLexer.g3:1:10: NEWLINE
@@ -2527,11 +2625,10 @@ public partial class AngleBracketTemplateLexer : Lexer
// $ANTLR start synpred1_AngleBracketTemplateLexer
public void synpred1_AngleBracketTemplateLexer_fragment()
{
-		// Language\\AngleBracketTemplateLexer.g3:95:4: ( '<\\\\' )
-		// Language\\AngleBracketTemplateLexer.g3:95:5: '<\\\\'
+		// Language\\AngleBracketTemplateLexer.g3:95:4: ( LINE_BREAK )
+		// Language\\AngleBracketTemplateLexer.g3:95:5: LINE_BREAK
{
-		Match("<\\"); if (state.failed) return ;
-
+		mLINE_BREAK(); if (state.failed) return ;

}
}
@@ -2540,7 +2637,7 @@ public partial class AngleBracketTemplateLexer : Lexer
// $ANTLR start synpred10_AngleBracketTemplateLexer
public void synpred10_AngleBracketTemplateLexer_fragment()
{
-		// Language\\AngleBracketTemplateLexer.g3:163:7: ( '\\r' | '\\n' )
+		// Language\\AngleBracketTemplateLexer.g3:160:8: ( '\\r' | '\\n' )
// Language\\AngleBracketTemplateLexer.g3:
{
if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
@@ -2563,7 +2660,7 @@ public partial class AngleBracketTemplateLexer : Lexer
// $ANTLR start synpred11_AngleBracketTemplateLexer
public void synpred11_AngleBracketTemplateLexer_fragment()
{
-		// Language\\AngleBracketTemplateLexer.g3:272:5: ( '\\r' | '\\n' )
+		// Language\\AngleBracketTemplateLexer.g3:164:7: ( '\\r' | '\\n' )
// Language\\AngleBracketTemplateLexer.g3:
{
if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
@@ -2586,21 +2683,44 @@ public partial class AngleBracketTemplateLexer : Lexer
// $ANTLR start synpred12_AngleBracketTemplateLexer
public void synpred12_AngleBracketTemplateLexer_fragment()
{
-		// Language\\AngleBracketTemplateLexer.g3:274:4: ( ( '\\r' )? '\\n>>' )
-		// Language\\AngleBracketTemplateLexer.g3:274:5: ( '\\r' )? '\\n>>'
+		// Language\\AngleBracketTemplateLexer.g3:273:5: ( '\\r' | '\\n' )
+		// Language\\AngleBracketTemplateLexer.g3:
+		{
+		if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
{
-		// Language\\AngleBracketTemplateLexer.g3:274:5: ( '\\r' )?
-		int alt47=2;
-		int LA47_0 = input.LA(1);
+			input.Consume();
+		state.failed=false;
+		}
+		else
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			MismatchedSetException mse = new MismatchedSetException(null,input);
+			Recover(mse);
+			throw mse;}

-		if ( (LA47_0=='\r') )
+
+		}
+	}
+	// $ANTLR end synpred12_AngleBracketTemplateLexer
+
+	// $ANTLR start synpred13_AngleBracketTemplateLexer
+	public void synpred13_AngleBracketTemplateLexer_fragment()
+	{
+		// Language\\AngleBracketTemplateLexer.g3:275:4: ( ( '\\r' )? '\\n>>' )
+		// Language\\AngleBracketTemplateLexer.g3:275:5: ( '\\r' )? '\\n>>'
{
-			alt47=1;
+		// Language\\AngleBracketTemplateLexer.g3:275:5: ( '\\r' )?
+		int alt50=2;
+		int LA50_0 = input.LA(1);
+
+		if ( (LA50_0=='\r') )
+		{
+			alt50=1;
}
-		switch ( alt47 )
+		switch ( alt50 )
{
case 1:
-			// Language\\AngleBracketTemplateLexer.g3:274:0: '\\r'
+			// Language\\AngleBracketTemplateLexer.g3:275:0: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -2614,34 +2734,34 @@ public partial class AngleBracketTemplateLexer : Lexer

}
}
-	// $ANTLR end synpred12_AngleBracketTemplateLexer
+	// $ANTLR end synpred13_AngleBracketTemplateLexer

-	// $ANTLR start synpred13_AngleBracketTemplateLexer
-	public void synpred13_AngleBracketTemplateLexer_fragment()
+	// $ANTLR start synpred14_AngleBracketTemplateLexer
+	public void synpred14_AngleBracketTemplateLexer_fragment()
{
-		// Language\\AngleBracketTemplateLexer.g3:275:5: ( '>' ~ '>' |~ '>' )
-		int alt48=2;
-		int LA48_0 = input.LA(1);
+		// Language\\AngleBracketTemplateLexer.g3:276:5: ( '>' ~ '>' |~ '>' )
+		int alt51=2;
+		int LA51_0 = input.LA(1);

-		if ( (LA48_0=='>') )
+		if ( (LA51_0=='>') )
{
-			alt48=1;
+			alt51=1;
}
-		else if ( ((LA48_0>='\u0000' && LA48_0<='=')||(LA48_0>='?' && LA48_0<='\uFFFF')) )
+		else if ( ((LA51_0>='\u0000' && LA51_0<='=')||(LA51_0>='?' && LA51_0<='\uFFFF')) )
{
-			alt48=2;
+			alt51=2;
}
else
{
if (state.backtracking>0) {state.failed=true; return ;}
-			NoViableAltException nvae = new NoViableAltException("", 48, 0, input);
+			NoViableAltException nvae = new NoViableAltException("", 51, 0, input);

throw nvae;
}
-		switch ( alt48 )
+		switch ( alt51 )
{
case 1:
-			// Language\\AngleBracketTemplateLexer.g3:275:6: '>' ~ '>'
+			// Language\\AngleBracketTemplateLexer.g3:276:6: '>' ~ '>'
{
Match('>'); if (state.failed) return ;
if ( (input.LA(1)>='\u0000' && input.LA(1)<='=')||(input.LA(1)>='?' && input.LA(1)<='\uFFFF') )
@@ -2660,7 +2780,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 2:
-			// Language\\AngleBracketTemplateLexer.g3:275:17: ~ '>'
+			// Language\\AngleBracketTemplateLexer.g3:276:17: ~ '>'
{
if ( (input.LA(1)>='\u0000' && input.LA(1)<='=')||(input.LA(1)>='?' && input.LA(1)<='\uFFFF') )
{
@@ -2679,15 +2799,15 @@ public partial class AngleBracketTemplateLexer : Lexer
break;

}}
-	// $ANTLR end synpred13_AngleBracketTemplateLexer
+	// $ANTLR end synpred14_AngleBracketTemplateLexer

// $ANTLR start synpred2_AngleBracketTemplateLexer
public void synpred2_AngleBracketTemplateLexer_fragment()
{
-		// Language\\AngleBracketTemplateLexer.g3:106:4: ( '<!' )
-		// Language\\AngleBracketTemplateLexer.g3:106:5: '<!'
+		// Language\\AngleBracketTemplateLexer.g3:96:4: ( '<\\\\' )
+		// Language\\AngleBracketTemplateLexer.g3:96:5: '<\\\\'
{
-		Match("<!"); if (state.failed) return ;
+		Match("<\\"); if (state.failed) return ;


}
@@ -2697,10 +2817,10 @@ public partial class AngleBracketTemplateLexer : Lexer
// $ANTLR start synpred3_AngleBracketTemplateLexer
public void synpred3_AngleBracketTemplateLexer_fragment()
{
-		// Language\\AngleBracketTemplateLexer.g3:108:4: ( '<if' )
-		// Language\\AngleBracketTemplateLexer.g3:108:5: '<if'
+		// Language\\AngleBracketTemplateLexer.g3:107:4: ( '<!' )
+		// Language\\AngleBracketTemplateLexer.g3:107:5: '<!'
{
-		Match("<if"); if (state.failed) return ;
+		Match("<!"); if (state.failed) return ;


}
@@ -2710,10 +2830,10 @@ public partial class AngleBracketTemplateLexer : Lexer
// $ANTLR start synpred4_AngleBracketTemplateLexer
public void synpred4_AngleBracketTemplateLexer_fragment()
{
-		// Language\\AngleBracketTemplateLexer.g3:115:5: ( '<elseif' )
-		// Language\\AngleBracketTemplateLexer.g3:115:6: '<elseif'
+		// Language\\AngleBracketTemplateLexer.g3:109:4: ( '<if' )
+		// Language\\AngleBracketTemplateLexer.g3:109:5: '<if'
{
-		Match("<elseif"); if (state.failed) return ;
+		Match("<if"); if (state.failed) return ;


}
@@ -2723,10 +2843,10 @@ public partial class AngleBracketTemplateLexer : Lexer
// $ANTLR start synpred5_AngleBracketTemplateLexer
public void synpred5_AngleBracketTemplateLexer_fragment()
{
-		// Language\\AngleBracketTemplateLexer.g3:122:5: ( '<else' )
-		// Language\\AngleBracketTemplateLexer.g3:122:6: '<else'
+		// Language\\AngleBracketTemplateLexer.g3:116:5: ( '<elseif' )
+		// Language\\AngleBracketTemplateLexer.g3:116:6: '<elseif'
{
-		Match("<else"); if (state.failed) return ;
+		Match("<elseif"); if (state.failed) return ;


}
@@ -2736,10 +2856,10 @@ public partial class AngleBracketTemplateLexer : Lexer
// $ANTLR start synpred6_AngleBracketTemplateLexer
public void synpred6_AngleBracketTemplateLexer_fragment()
{
-		// Language\\AngleBracketTemplateLexer.g3:129:5: ( '<endif' )
-		// Language\\AngleBracketTemplateLexer.g3:129:6: '<endif'
+		// Language\\AngleBracketTemplateLexer.g3:123:5: ( '<else' )
+		// Language\\AngleBracketTemplateLexer.g3:123:6: '<else'
{
-		Match("<endif"); if (state.failed) return ;
+		Match("<else"); if (state.failed) return ;


}
@@ -2749,10 +2869,10 @@ public partial class AngleBracketTemplateLexer : Lexer
// $ANTLR start synpred7_AngleBracketTemplateLexer
public void synpred7_AngleBracketTemplateLexer_fragment()
{
-		// Language\\AngleBracketTemplateLexer.g3:138:4: ( '<@' )
-		// Language\\AngleBracketTemplateLexer.g3:138:5: '<@'
+		// Language\\AngleBracketTemplateLexer.g3:130:5: ( '<endif' )
+		// Language\\AngleBracketTemplateLexer.g3:130:6: '<endif'
{
-		Match("<@"); if (state.failed) return ;
+		Match("<endif"); if (state.failed) return ;


}
@@ -2762,20 +2882,10 @@ public partial class AngleBracketTemplateLexer : Lexer
// $ANTLR start synpred8_AngleBracketTemplateLexer
public void synpred8_AngleBracketTemplateLexer_fragment()
{
-		// Language\\AngleBracketTemplateLexer.g3:154:7: ( '\\r' | '\\n' )
-		// Language\\AngleBracketTemplateLexer.g3:
-		{
-		if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
-		{
-			input.Consume();
-		state.failed=false;
-		}
-		else
+		// Language\\AngleBracketTemplateLexer.g3:139:4: ( '<@' )
+		// Language\\AngleBracketTemplateLexer.g3:139:5: '<@'
{
-			if (state.backtracking>0) {state.failed=true; return ;}
-			MismatchedSetException mse = new MismatchedSetException(null,input);
-			Recover(mse);
-			throw mse;}
+		Match("<@"); if (state.failed) return ;


}
@@ -2785,7 +2895,7 @@ public partial class AngleBracketTemplateLexer : Lexer
// $ANTLR start synpred9_AngleBracketTemplateLexer
public void synpred9_AngleBracketTemplateLexer_fragment()
{
-		// Language\\AngleBracketTemplateLexer.g3:159:8: ( '\\r' | '\\n' )
+		// Language\\AngleBracketTemplateLexer.g3:155:7: ( '\\r' | '\\n' )
// Language\\AngleBracketTemplateLexer.g3:
{
if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
@@ -2905,7 +3015,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
public override string GetDescription()
{
-			return "()+ loopback of 158:5: ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+";
+			return "()+ loopback of 159:5: ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+";
}
}

@@ -3192,7 +3302,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
public override string GetDescription()
{
-			return "()* loopback of 273:3: ( options {k=2; } :=> ( '\\r' )? '\\n' |=>ch= . )*";
+			return "()* loopback of 274:3: ( options {k=2; } :=> ( '\\r' )? '\\n' |=>ch= . )*";
}
}

@@ -3216,7 +3326,7 @@ public partial class AngleBracketTemplateLexer : Lexer

else if ( (LA37_0=='\n') ) {s = 3;}

-				else if ( ((LA37_0>='\u0000' && LA37_0<='\t')||(LA37_0>='\u000B' && LA37_0<='\f')||(LA37_0>='\u000E' && LA37_0<='=')||(LA37_0>='?' && LA37_0<='\uFFFF')) && (EvaluatePredicate(synpred13_AngleBracketTemplateLexer_fragment))) {s = 4;}
+				else if ( ((LA37_0>='\u0000' && LA37_0<='\t')||(LA37_0>='\u000B' && LA37_0<='\f')||(LA37_0>='\u000E' && LA37_0<='=')||(LA37_0>='?' && LA37_0<='\uFFFF')) && (EvaluatePredicate(synpred14_AngleBracketTemplateLexer_fragment))) {s = 4;}


input.Seek(index37_0);
@@ -3232,11 +3342,11 @@ public partial class AngleBracketTemplateLexer : Lexer
s = -1;
if ( (LA37_1=='>') ) {s = 5;}

-				else if ( (LA37_1=='\r') && (EvaluatePredicate(synpred13_AngleBracketTemplateLexer_fragment))) {s = 6;}
+				else if ( (LA37_1=='\r') && (EvaluatePredicate(synpred14_AngleBracketTemplateLexer_fragment))) {s = 6;}

-				else if ( (LA37_1=='\n') && (EvaluatePredicate(synpred13_AngleBracketTemplateLexer_fragment))) {s = 7;}
+				else if ( (LA37_1=='\n') && (EvaluatePredicate(synpred14_AngleBracketTemplateLexer_fragment))) {s = 7;}

-				else if ( ((LA37_1>='\u0000' && LA37_1<='\t')||(LA37_1>='\u000B' && LA37_1<='\f')||(LA37_1>='\u000E' && LA37_1<='=')||(LA37_1>='?' && LA37_1<='\uFFFF')) && (EvaluatePredicate(synpred13_AngleBracketTemplateLexer_fragment))) {s = 8;}
+				else if ( ((LA37_1>='\u0000' && LA37_1<='\t')||(LA37_1>='\u000B' && LA37_1<='\f')||(LA37_1>='\u000E' && LA37_1<='=')||(LA37_1>='?' && LA37_1<='\uFFFF')) && (EvaluatePredicate(synpred14_AngleBracketTemplateLexer_fragment))) {s = 8;}


input.Seek(index37_1);
@@ -3250,9 +3360,9 @@ public partial class AngleBracketTemplateLexer : Lexer
int index37_2 = input.Index;
input.Rewind();
s = -1;
-				if ( (EvaluatePredicate(synpred12_AngleBracketTemplateLexer_fragment)) ) {s = 13;}
+				if ( (EvaluatePredicate(synpred13_AngleBracketTemplateLexer_fragment)) ) {s = 13;}

-				else if ( (EvaluatePredicate(synpred13_AngleBracketTemplateLexer_fragment)) ) {s = 8;}
+				else if ( (EvaluatePredicate(synpred14_AngleBracketTemplateLexer_fragment)) ) {s = 8;}


input.Seek(index37_2);
@@ -3266,9 +3376,9 @@ public partial class AngleBracketTemplateLexer : Lexer
int index37_3 = input.Index;
input.Rewind();
s = -1;
-				if ( (EvaluatePredicate(synpred12_AngleBracketTemplateLexer_fragment)) ) {s = 13;}
+				if ( (EvaluatePredicate(synpred13_AngleBracketTemplateLexer_fragment)) ) {s = 13;}

-				else if ( (EvaluatePredicate(synpred13_AngleBracketTemplateLexer_fragment)) ) {s = 8;}
+				else if ( (EvaluatePredicate(synpred14_AngleBracketTemplateLexer_fragment)) ) {s = 8;}


input.Seek(index37_3);
@@ -3282,7 +3392,7 @@ public partial class AngleBracketTemplateLexer : Lexer
int index37_5 = input.Index;
input.Rewind();
s = -1;
-				if ( (EvaluatePredicate(synpred13_AngleBracketTemplateLexer_fragment)) ) {s = 8;}
+				if ( (EvaluatePredicate(synpred14_AngleBracketTemplateLexer_fragment)) ) {s = 8;}

else if ( (true) ) {s = 18;}

diff --git a/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.g3 b/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.g3
index de538be..713132f 100644
--- a/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.g3
+++ b/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.g3
@@ -92,7 +92,8 @@ options { k = 1; }
bool atLeft = false;
string t = null;
}
-	:	('<\\') =>
+	:	(LINE_BREAK) => LINE_BREAK {$channel = Hidden;}
+	|	('<\\') =>
// Match escapes not in a string like <\n\ufea5>
{
buf = new System.Text.StringBuilder();
@@ -222,7 +223,7 @@ LITERAL
;

fragment
-INDENT // done
+INDENT
:	(' ' | '\t')+
;

@@ -346,3 +347,8 @@ COMMENT
:	'<!' .* '!>'
( {startCol==0}? => ('\r')? '\n' )?
;
+
+fragment
+LINE_BREAK
+	:	'<\\\\>' INDENT? '\r'? '\n' INDENT?
+	;
diff --git a/Antlr3.StringTemplate/Language/ConditionalExpr.cs b/Antlr3.StringTemplate/Language/ConditionalExpr.cs
index 3dbcbac..a9bf90d 100644
--- a/Antlr3.StringTemplate/Language/ConditionalExpr.cs
+++ b/Antlr3.StringTemplate/Language/ConditionalExpr.cs
@@ -254,6 +254,9 @@ namespace Antlr3.ST.Language
s.NativeGroup = self.NativeGroup;
n = s.Write( @out );
}
+                // cond==false and no else => Missing output not empty
+                if (!testedTrue && _elseSubtemplate == null)
+                    n = Missing;
}
catch ( RecognitionException re )
{
diff --git a/Antlr3.StringTemplate/Language/Template.g3 b/Antlr3.StringTemplate/Language/Template.g3
index 9c3c379..edba739 100644
--- a/Antlr3.StringTemplate/Language/Template.g3
+++ b/Antlr3.StringTemplate/Language/Template.g3
@@ -278,7 +278,8 @@ ACTION
string t = null;
}
:	(	options { k = 1; } :
-			('$\\') =>
+			(LINE_BREAK) => LINE_BREAK {$channel = Hidden;}
+		|	('$\\') =>
// Match escapes not in a string like <\n\ufea5>
'$' (ESC_CHAR[out uc] {builder.Append(uc);} )+ '$'
{
@@ -368,9 +369,11 @@ LITERAL
System.Text.StringBuilder builder = new System.Text.StringBuilder();
}
:	(	'\\'
-			(	'$'				{builder.Append("$");}  // allow escaped delimiter
-			|	'\\'			{builder.Append("\\");} // always replace \\ with \
-			|	ch=~('$'|'\\')	{builder.Append("\\" + (char)$ch);}  // otherwise ignore escape char
+			(	(EOF) => EOF		{builder.Append("\\");}  // Allow a template that just has a single backslash
+			|	(	'$'				{builder.Append("$");}  // allow escaped delimiter
+				|	'\\'			{builder.Append("\\");} // always replace \\ with \
+				|	ch=~('$'|'\\')	{builder.Append("\\" + (char)$ch);}  // otherwise ignore escape char
+				)
)
|	ind=INDENT
{
@@ -517,3 +520,8 @@ COMMENT
}
:	'$!' .* '!$' ( {startCol==0}? => ('\r')? '\n' )?
;
+
+fragment
+LINE_BREAK
+	:	'$\\\\$' INDENT? '\r'? '\n' INDENT?
+	;
diff --git a/Antlr3.StringTemplate/Language/TemplateLexer.cs b/Antlr3.StringTemplate/Language/TemplateLexer.cs
index 6c2c961..23a8596 100644
--- a/Antlr3.StringTemplate/Language/TemplateLexer.cs
+++ b/Antlr3.StringTemplate/Language/TemplateLexer.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Language\\Template.g3 2009-04-18 13:36:17
+// $ANTLR 3.1.2 Language\\Template.g3 2009-07-30 16:39:08

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -63,13 +63,14 @@ public partial class TemplateLexer : Lexer
public const int IF=13;
public const int IF_EXPR=14;
public const int INDENT=15;
-	public const int LITERAL=16;
-	public const int NESTED_PARENS=17;
-	public const int NEWLINE=18;
-	public const int REGION_DEF=19;
-	public const int REGION_REF=20;
-	public const int SUBTEMPLATE=21;
-	public const int TEMPLATE=22;
+	public const int LINE_BREAK=16;
+	public const int LITERAL=17;
+	public const int NESTED_PARENS=18;
+	public const int NEWLINE=19;
+	public const int REGION_DEF=20;
+	public const int REGION_REF=21;
+	public const int SUBTEMPLATE=22;
+	public const int TEMPLATE=23;

// delegates
// delegators
@@ -266,11 +267,11 @@ public partial class TemplateLexer : Lexer
bool atLeft = false;
string t = null;

-			// Language\\Template.g3:280:4: ( ( options {k=1; } :=> '$' ( ESC_CHAR[out uc] )+ '$' |=> COMMENT | (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' ) ) )
-			// Language\\Template.g3:280:4: ( options {k=1; } :=> '$' ( ESC_CHAR[out uc] )+ '$' |=> COMMENT | (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' ) )
+			// Language\\Template.g3:280:4: ( ( options {k=1; } :=> LINE_BREAK |=> '$' ( ESC_CHAR[out uc] )+ '$' |=> COMMENT | (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' ) ) )
+			// Language\\Template.g3:280:4: ( options {k=1; } :=> LINE_BREAK |=> '$' ( ESC_CHAR[out uc] )+ '$' |=> COMMENT | (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' ) )
{
-			// Language\\Template.g3:280:4: ( options {k=1; } :=> '$' ( ESC_CHAR[out uc] )+ '$' |=> COMMENT | (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' ) )
-			int alt26=3;
+			// Language\\Template.g3:280:4: ( options {k=1; } :=> LINE_BREAK |=> '$' ( ESC_CHAR[out uc] )+ '$' |=> COMMENT | (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' ) )
+			int alt26=4;
int LA26_0 = input.LA(1);

if ( (LA26_0=='$') )
@@ -285,10 +286,14 @@ public partial class TemplateLexer : Lexer
{
alt26=2;
}
-				else if ( (true) )
+				else if ( (EvaluatePredicate(synpred3_Template_fragment)) )
{
alt26=3;
}
+				else if ( (true) )
+				{
+					alt26=4;
+				}
else
{
if (state.backtracking>0) {state.failed=true; return ;}
@@ -307,11 +312,23 @@ public partial class TemplateLexer : Lexer
switch ( alt26 )
{
case 1:
-				// Language\\Template.g3:281:4: => '$' ( ESC_CHAR[out uc] )+ '$'
+				// Language\\Template.g3:281:4: => LINE_BREAK
+				{
+
+				mLINE_BREAK(); if (state.failed) return ;
+				if ( state.backtracking == 0 )
+				{
+					_channel = Hidden;
+				}
+
+				}
+				break;
+			case 2:
+				// Language\\Template.g3:282:5: => '$' ( ESC_CHAR[out uc] )+ '$'
{

Match('$'); if (state.failed) return ;
-				// Language\\Template.g3:283:8: ( ESC_CHAR[out uc] )+
+				// Language\\Template.g3:284:8: ( ESC_CHAR[out uc] )+
int cnt2=0;
for ( ; ; )
{
@@ -327,7 +344,7 @@ public partial class TemplateLexer : Lexer
switch ( alt2 )
{
case 1:
-						// Language\\Template.g3:283:9: ESC_CHAR[out uc]
+						// Language\\Template.g3:284:9: ESC_CHAR[out uc]
{
mESC_CHAR(out uc); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -363,8 +380,8 @@ public partial class TemplateLexer : Lexer

}
break;
-			case 2:
-				// Language\\Template.g3:288:5: => COMMENT
+			case 3:
+				// Language\\Template.g3:289:5: => COMMENT
{

mCOMMENT(); if (state.failed) return ;
@@ -375,10 +392,10 @@ public partial class TemplateLexer : Lexer

}
break;
-			case 3:
-				// Language\\Template.g3:290:5: (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' )
+			case 4:
+				// Language\\Template.g3:291:5: (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' )
{
-				// Language\\Template.g3:290:5: (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' )
+				// Language\\Template.g3:291:5: (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' )
int alt25=6;
int LA25_0 = input.LA(1);

@@ -386,23 +403,23 @@ public partial class TemplateLexer : Lexer
{
int LA25_1 = input.LA(2);

-					if ( (EvaluatePredicate(synpred3_Template_fragment)) )
+					if ( (EvaluatePredicate(synpred4_Template_fragment)) )
{
alt25=1;
}
-					else if ( (EvaluatePredicate(synpred4_Template_fragment)) )
+					else if ( (EvaluatePredicate(synpred5_Template_fragment)) )
{
alt25=2;
}
-					else if ( (EvaluatePredicate(synpred5_Template_fragment)) )
+					else if ( (EvaluatePredicate(synpred6_Template_fragment)) )
{
alt25=3;
}
-					else if ( (EvaluatePredicate(synpred6_Template_fragment)) )
+					else if ( (EvaluatePredicate(synpred7_Template_fragment)) )
{
alt25=4;
}
-					else if ( (EvaluatePredicate(synpred7_Template_fragment)) )
+					else if ( (EvaluatePredicate(synpred8_Template_fragment)) )
{
alt25=5;
}
@@ -428,12 +445,12 @@ public partial class TemplateLexer : Lexer
switch ( alt25 )
{
case 1:
-					// Language\\Template.g3:290:7: => '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )?
+					// Language\\Template.g3:291:7: => '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )?
{

Match("$if"); if (state.failed) return ;

-					// Language\\Template.g3:291:11: ( ' ' )*
+					// Language\\Template.g3:292:11: ( ' ' )*
for ( ; ; )
{
int alt3=2;
@@ -448,7 +465,7 @@ public partial class TemplateLexer : Lexer
switch ( alt3 )
{
case 1:
-							// Language\\Template.g3:291:12: ' '
+							// Language\\Template.g3:292:12: ' '
{
Match(' '); if (state.failed) return ;

@@ -465,9 +482,9 @@ public partial class TemplateLexer : Lexer


Match('('); if (state.failed) return ;
-					int expStart206 = CharIndex;
+					int expStart220 = CharIndex;
mIF_EXPR(); if (state.failed) return ;
-					exp = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, expStart206, CharIndex-1);
+					exp = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, expStart220, CharIndex-1);
Match(")$"); if (state.failed) return ;

if ( state.backtracking == 0 )
@@ -477,7 +494,7 @@ public partial class TemplateLexer : Lexer
_type = TemplateParser.IF;

}
-					// Language\\Template.g3:296:5: ( ( '\\r' )? '\\n' )?
+					// Language\\Template.g3:297:5: ( ( '\\r' )? '\\n' )?
int alt5=2;
int LA5_0 = input.LA(1);

@@ -488,9 +505,9 @@ public partial class TemplateLexer : Lexer
switch ( alt5 )
{
case 1:
-						// Language\\Template.g3:296:7: ( '\\r' )? '\\n'
+						// Language\\Template.g3:297:7: ( '\\r' )? '\\n'
{
-						// Language\\Template.g3:296:7: ( '\\r' )?
+						// Language\\Template.g3:297:7: ( '\\r' )?
int alt4=2;
int LA4_0 = input.LA(1);

@@ -501,7 +518,7 @@ public partial class TemplateLexer : Lexer
switch ( alt4 )
{
case 1:
-							// Language\\Template.g3:296:8: '\\r'
+							// Language\\Template.g3:297:8: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -521,12 +538,12 @@ public partial class TemplateLexer : Lexer
}
break;
case 2:
-					// Language\\Template.g3:297:6: => '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )?
+					// Language\\Template.g3:298:6: => '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )?
{

Match("$elseif"); if (state.failed) return ;

-					// Language\\Template.g3:298:15: ( ' ' )*
+					// Language\\Template.g3:299:15: ( ' ' )*
for ( ; ; )
{
int alt6=2;
@@ -541,7 +558,7 @@ public partial class TemplateLexer : Lexer
switch ( alt6 )
{
case 1:
-							// Language\\Template.g3:298:16: ' '
+							// Language\\Template.g3:299:16: ' '
{
Match(' '); if (state.failed) return ;

@@ -558,9 +575,9 @@ public partial class TemplateLexer : Lexer


Match('('); if (state.failed) return ;
-					int expStart265 = CharIndex;
+					int expStart279 = CharIndex;
mIF_EXPR(); if (state.failed) return ;
-					exp = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, expStart265, CharIndex-1);
+					exp = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, expStart279, CharIndex-1);
Match(")$"); if (state.failed) return ;

if ( state.backtracking == 0 )
@@ -570,7 +587,7 @@ public partial class TemplateLexer : Lexer
_type = TemplateParser.ELSEIF;

}
-					// Language\\Template.g3:303:5: ( ( '\\r' )? '\\n' )?
+					// Language\\Template.g3:304:5: ( ( '\\r' )? '\\n' )?
int alt8=2;
int LA8_0 = input.LA(1);

@@ -581,9 +598,9 @@ public partial class TemplateLexer : Lexer
switch ( alt8 )
{
case 1:
-						// Language\\Template.g3:303:7: ( '\\r' )? '\\n'
+						// Language\\Template.g3:304:7: ( '\\r' )? '\\n'
{
-						// Language\\Template.g3:303:7: ( '\\r' )?
+						// Language\\Template.g3:304:7: ( '\\r' )?
int alt7=2;
int LA7_0 = input.LA(1);

@@ -594,7 +611,7 @@ public partial class TemplateLexer : Lexer
switch ( alt7 )
{
case 1:
-							// Language\\Template.g3:303:8: '\\r'
+							// Language\\Template.g3:304:8: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -614,7 +631,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 3:
-					// Language\\Template.g3:304:6: => '$else$' ( ( '\\r' )? '\\n' )?
+					// Language\\Template.g3:305:6: => '$else$' ( ( '\\r' )? '\\n' )?
{

Match("$else$"); if (state.failed) return ;
@@ -626,7 +643,7 @@ public partial class TemplateLexer : Lexer
_type = (TemplateParser.ELSE);

}
-					// Language\\Template.g3:310:5: ( ( '\\r' )? '\\n' )?
+					// Language\\Template.g3:311:5: ( ( '\\r' )? '\\n' )?
int alt10=2;
int LA10_0 = input.LA(1);

@@ -637,9 +654,9 @@ public partial class TemplateLexer : Lexer
switch ( alt10 )
{
case 1:
-						// Language\\Template.g3:310:7: ( '\\r' )? '\\n'
+						// Language\\Template.g3:311:7: ( '\\r' )? '\\n'
{
-						// Language\\Template.g3:310:7: ( '\\r' )?
+						// Language\\Template.g3:311:7: ( '\\r' )?
int alt9=2;
int LA9_0 = input.LA(1);

@@ -650,7 +667,7 @@ public partial class TemplateLexer : Lexer
switch ( alt9 )
{
case 1:
-							// Language\\Template.g3:310:8: '\\r'
+							// Language\\Template.g3:311:8: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -670,7 +687,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 4:
-					// Language\\Template.g3:311:6: => '$endif$' ({...}? => ( '\\r' )? '\\n' )?
+					// Language\\Template.g3:312:6: => '$endif$' ({...}? => ( '\\r' )? '\\n' )?
{

Match("$endif$"); if (state.failed) return ;
@@ -682,7 +699,7 @@ public partial class TemplateLexer : Lexer
_type = TemplateParser.ENDIF;

}
-					// Language\\Template.g3:317:5: ({...}? => ( '\\r' )? '\\n' )?
+					// Language\\Template.g3:318:5: ({...}? => ( '\\r' )? '\\n' )?
int alt12=2;
int LA12_0 = input.LA(1);

@@ -693,14 +710,14 @@ public partial class TemplateLexer : Lexer
switch ( alt12 )
{
case 1:
-						// Language\\Template.g3:317:7: {...}? => ( '\\r' )? '\\n'
+						// Language\\Template.g3:318:7: {...}? => ( '\\r' )? '\\n'
{
if ( !((startCol==0)) )
{
if (state.backtracking>0) {state.failed=true; return ;}
throw new FailedPredicateException(input, "ACTION", "startCol==0");
}
-						// Language\\Template.g3:317:25: ( '\\r' )?
+						// Language\\Template.g3:318:25: ( '\\r' )?
int alt11=2;
int LA11_0 = input.LA(1);

@@ -711,7 +728,7 @@ public partial class TemplateLexer : Lexer
switch ( alt11 )
{
case 1:
-							// Language\\Template.g3:317:26: '\\r'
+							// Language\\Template.g3:318:26: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -731,7 +748,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 5:
-					// Language\\Template.g3:321:5: => '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? )
+					// Language\\Template.g3:322:5: => '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? )
{

if ( state.backtracking == 0 )
@@ -742,7 +759,7 @@ public partial class TemplateLexer : Lexer
}
Match("$@"); if (state.failed) return ;

-					// Language\\Template.g3:325:10: (ch=~ ( '$' | '(' ) )+
+					// Language\\Template.g3:326:10: (ch=~ ( '$' | '(' ) )+
int cnt13=0;
for ( ; ; )
{
@@ -758,7 +775,7 @@ public partial class TemplateLexer : Lexer
switch ( alt13 )
{
case 1:
-							// Language\\Template.g3:325:12: ch=~ ( '$' | '(' )
+							// Language\\Template.g3:326:12: ch=~ ( '$' | '(' )
{
ch= input.LA(1);
input.Consume();
@@ -789,7 +806,7 @@ public partial class TemplateLexer : Lexer
{
t = builder.ToString();
}
-					// Language\\Template.g3:327:5: ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? )
+					// Language\\Template.g3:328:5: ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? )
int alt24=2;
int LA24_0 = input.LA(1);

@@ -811,7 +828,7 @@ public partial class TemplateLexer : Lexer
switch ( alt24 )
{
case 1:
-						// Language\\Template.g3:327:7: '()$'
+						// Language\\Template.g3:328:7: '()$'
{
Match("()$"); if (state.failed) return ;

@@ -825,7 +842,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 2:
-						// Language\\Template.g3:331:7: '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )?
+						// Language\\Template.g3:332:7: '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )?
{
Match('$'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -835,7 +852,7 @@ public partial class TemplateLexer : Lexer
builder.Append("::=");

}
-						// Language\\Template.g3:336:6: (=> ( '\\r' )? '\\n' )?
+						// Language\\Template.g3:337:6: (=> ( '\\r' )? '\\n' )?
int alt15=2;
int LA15_0 = input.LA(1);

@@ -847,7 +864,7 @@ public partial class TemplateLexer : Lexer
{
int LA15_4 = input.LA(3);

-								if ( (EvaluatePredicate(synpred8_Template_fragment)) )
+								if ( (EvaluatePredicate(synpred9_Template_fragment)) )
{
alt15=1;
}
@@ -857,7 +874,7 @@ public partial class TemplateLexer : Lexer
{
int LA15_2 = input.LA(2);

-							if ( (EvaluatePredicate(synpred8_Template_fragment)) )
+							if ( (EvaluatePredicate(synpred9_Template_fragment)) )
{
alt15=1;
}
@@ -865,10 +882,10 @@ public partial class TemplateLexer : Lexer
switch ( alt15 )
{
case 1:
-							// Language\\Template.g3:336:8: => ( '\\r' )? '\\n'
+							// Language\\Template.g3:337:8: => ( '\\r' )? '\\n'
{

-							// Language\\Template.g3:336:23: ( '\\r' )?
+							// Language\\Template.g3:337:23: ( '\\r' )?
int alt14=2;
int LA14_0 = input.LA(1);

@@ -879,7 +896,7 @@ public partial class TemplateLexer : Lexer
switch ( alt14 )
{
case 1:
-								// Language\\Template.g3:336:24: '\\r'
+								// Language\\Template.g3:337:24: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -899,7 +916,7 @@ public partial class TemplateLexer : Lexer
{
atLeft = false;
}
-						// Language\\Template.g3:338:6: ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+
+						// Language\\Template.g3:339:6: ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+
int cnt18=0;
for ( ; ; )
{
@@ -908,14 +925,14 @@ public partial class TemplateLexer : Lexer
switch ( alt18 )
{
case 1:
-								// Language\\Template.g3:338:8: {...}? => (=> ( '\\r' )? '\\n' |ch= . )
+								// Language\\Template.g3:339:8: {...}? => (=> ( '\\r' )? '\\n' |ch= . )
{
if ( !((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))) )
{
if (state.backtracking>0) {state.failed=true; return ;}
throw new FailedPredicateException(input, "ACTION", "!(UpcomingAtEND(1) || ( input.LA(1) == '\\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\\r' && input.LA(2) == '\\n' && UpcomingAtEND(3) ))");
}
-								// Language\\Template.g3:339:7: (=> ( '\\r' )? '\\n' |ch= . )
+								// Language\\Template.g3:340:7: (=> ( '\\r' )? '\\n' |ch= . )
int alt17=2;
int LA17_0 = input.LA(1);

@@ -923,7 +940,7 @@ public partial class TemplateLexer : Lexer
{
int LA17_1 = input.LA(2);

-									if ( (EvaluatePredicate(synpred9_Template_fragment)) )
+									if ( (EvaluatePredicate(synpred10_Template_fragment)) )
{
alt17=1;
}
@@ -943,7 +960,7 @@ public partial class TemplateLexer : Lexer
{
int LA17_2 = input.LA(2);

-									if ( (EvaluatePredicate(synpred9_Template_fragment)) )
+									if ( (EvaluatePredicate(synpred10_Template_fragment)) )
{
alt17=1;
}
@@ -973,10 +990,10 @@ public partial class TemplateLexer : Lexer
switch ( alt17 )
{
case 1:
-									// Language\\Template.g3:339:9: => ( '\\r' )? '\\n'
+									// Language\\Template.g3:340:9: => ( '\\r' )? '\\n'
{

-									// Language\\Template.g3:339:24: ( '\\r' )?
+									// Language\\Template.g3:340:24: ( '\\r' )?
int alt16=2;
int LA16_0 = input.LA(1);

@@ -987,7 +1004,7 @@ public partial class TemplateLexer : Lexer
switch ( alt16 )
{
case 1:
-										// Language\\Template.g3:339:25: '\\r'
+										// Language\\Template.g3:340:25: '\\r'
{
Match('\r'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1009,7 +1026,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 2:
-									// Language\\Template.g3:340:9: ch= .
+									// Language\\Template.g3:341:9: ch= .
{
ch = input.LA(1);
MatchAny(); if (state.failed) return ;
@@ -1041,7 +1058,7 @@ public partial class TemplateLexer : Lexer
;


-						// Language\\Template.g3:343:6: (=> ( '\\r' )? '\\n' )?
+						// Language\\Template.g3:344:6: (=> ( '\\r' )? '\\n' )?
int alt20=2;
int LA20_0 = input.LA(1);

@@ -1053,11 +1070,11 @@ public partial class TemplateLexer : Lexer
{
int LA20_4 = input.LA(3);

-								if ( (LA20_4=='$') && (EvaluatePredicate(synpred10_Template_fragment)))
+								if ( (LA20_4=='$') && (EvaluatePredicate(synpred11_Template_fragment)))
{
alt20=1;
}
-								else if ( ((LA20_4>='\u0000' && LA20_4<='#')||(LA20_4>='%' && LA20_4<='\uFFFF')) && (EvaluatePredicate(synpred10_Template_fragment)))
+								else if ( ((LA20_4>='\u0000' && LA20_4<='#')||(LA20_4>='%' && LA20_4<='\uFFFF')) && (EvaluatePredicate(synpred11_Template_fragment)))
{
alt20=1;
}
@@ -1067,7 +1084,7 @@ public partial class TemplateLexer : Lexer
{
int LA20_2 = input.LA(2);

-							if ( (LA20_2=='$') && (EvaluatePredicate(synpred10_Template_fragment)))
+							if ( (LA20_2=='$') && (EvaluatePredicate(synpred11_Template_fragment)))
{
alt20=1;
}
@@ -1075,7 +1092,7 @@ public partial class TemplateLexer : Lexer
{
int LA20_6 = input.LA(3);

-								if ( (EvaluatePredicate(synpred10_Template_fragment)) )
+								if ( (EvaluatePredicate(synpred11_Template_fragment)) )
{
alt20=1;
}
@@ -1084,12 +1101,12 @@ public partial class TemplateLexer : Lexer
{
int LA20_7 = input.LA(3);

-								if ( (EvaluatePredicate(synpred10_Template_fragment)) )
+								if ( (EvaluatePredicate(synpred11_Template_fragment)) )
{
alt20=1;
}
}
-							else if ( ((LA20_2>='\u0000' && LA20_2<='\t')||(LA20_2>='\u000B' && LA20_2<='\f')||(LA20_2>='\u000E' && LA20_2<='#')||(LA20_2>='%' && LA20_2<='\uFFFF')) && (EvaluatePredicate(synpred10_Template_fragment)))
+							else if ( ((LA20_2>='\u0000' && LA20_2<='\t')||(LA20_2>='\u000B' && LA20_2<='\f')||(LA20_2>='\u000E' && LA20_2<='#')||(LA20_2>='%' && LA20_2<='\uFFFF')) && (EvaluatePredicate(synpred11_Template_fragment)))
{
alt20=1;
}
@@ -1097,10 +1114,10 @@ public partial class TemplateLexer : Lexer
switch ( alt20 )
{
case 1:
-							// Language\\Template.g3:343:8: => ( '\\r' )? '\\n'
+							// Language\\Template.g3:344:8: => ( '\\r' )? '\\n'
{

-							// Language\\Template.g3:343:23: ( '\\r' )?
+							// Language\\Template.g3:344:23: ( '\\r' )?
int alt19=2;
int LA19_0 = input.LA(1);

@@ -1111,7 +1128,7 @@ public partial class TemplateLexer : Lexer
switch ( alt19 )
{
case 1:
-								// Language\\Template.g3:343:24: '\\r'
+								// Language\\Template.g3:344:24: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -1131,7 +1148,7 @@ public partial class TemplateLexer : Lexer

}

-						// Language\\Template.g3:344:6: (=> '$@end$' | . )
+						// Language\\Template.g3:345:6: (=> '$@end$' | . )
int alt21=2;
int LA21_0 = input.LA(1);

@@ -1139,7 +1156,7 @@ public partial class TemplateLexer : Lexer
{
int LA21_1 = input.LA(2);

-							if ( (LA21_1=='@') && (EvaluatePredicate(synpred11_Template_fragment)))
+							if ( (LA21_1=='@') && (EvaluatePredicate(synpred12_Template_fragment)))
{
alt21=1;
}
@@ -1161,7 +1178,7 @@ public partial class TemplateLexer : Lexer
switch ( alt21 )
{
case 1:
-							// Language\\Template.g3:344:8: => '$@end$'
+							// Language\\Template.g3:345:8: => '$@end$'
{

Match("$@end$"); if (state.failed) return ;
@@ -1170,7 +1187,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 2:
-							// Language\\Template.g3:345:8: .
+							// Language\\Template.g3:346:8: .
{
MatchAny(); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1183,7 +1200,7 @@ public partial class TemplateLexer : Lexer

}

-						// Language\\Template.g3:347:6: ({...}? ( '\\r' )? '\\n' )?
+						// Language\\Template.g3:348:6: ({...}? ( '\\r' )? '\\n' )?
int alt23=2;
int LA23_0 = input.LA(1);

@@ -1194,14 +1211,14 @@ public partial class TemplateLexer : Lexer
switch ( alt23 )
{
case 1:
-							// Language\\Template.g3:347:8: {...}? ( '\\r' )? '\\n'
+							// Language\\Template.g3:348:8: {...}? ( '\\r' )? '\\n'
{
if ( !((atLeft)) )
{
if (state.backtracking>0) {state.failed=true; return ;}
throw new FailedPredicateException(input, "ACTION", "atLeft");
}
-							// Language\\Template.g3:347:18: ( '\\r' )?
+							// Language\\Template.g3:348:18: ( '\\r' )?
int alt22=2;
int LA22_0 = input.LA(1);

@@ -1212,7 +1229,7 @@ public partial class TemplateLexer : Lexer
switch ( alt22 )
{
case 1:
-								// Language\\Template.g3:347:19: '\\r'
+								// Language\\Template.g3:348:19: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -1244,7 +1261,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 6:
-					// Language\\Template.g3:352:6: '$' EXPR[out subtext] '$'
+					// Language\\Template.g3:353:6: '$' EXPR[out subtext] '$'
{
Match('$'); if (state.failed) return ;
mEXPR(out subtext); if (state.failed) return ;
@@ -1300,94 +1317,188 @@ public partial class TemplateLexer : Lexer
int col = CharPositionInLine;
System.Text.StringBuilder builder = new System.Text.StringBuilder();

-			// Language\\Template.g3:370:4: ( ( '\\\\' ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) ) |ind= INDENT |ch=~ ( '$' | '\\r' | '\\n' | '\\\\' | ' ' | '\\t' ) )+ )
-			// Language\\Template.g3:370:4: ( '\\\\' ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) ) |ind= INDENT |ch=~ ( '$' | '\\r' | '\\n' | '\\\\' | ' ' | '\\t' ) )+
+			// Language\\Template.g3:371:4: ( ( '\\\\' (=> EOF | ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) ) ) |ind= INDENT |ch=~ ( '$' | '\\r' | '\\n' | '\\\\' | ' ' | '\\t' ) )+ )
+			// Language\\Template.g3:371:4: ( '\\\\' (=> EOF | ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) ) ) |ind= INDENT |ch=~ ( '$' | '\\r' | '\\n' | '\\\\' | ' ' | '\\t' ) )+
{
-			// Language\\Template.g3:370:4: ( '\\\\' ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) ) |ind= INDENT |ch=~ ( '$' | '\\r' | '\\n' | '\\\\' | ' ' | '\\t' ) )+
-			int cnt28=0;
+			// Language\\Template.g3:371:4: ( '\\\\' (=> EOF | ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) ) ) |ind= INDENT |ch=~ ( '$' | '\\r' | '\\n' | '\\\\' | ' ' | '\\t' ) )+
+			int cnt29=0;
for ( ; ; )
{
-				int alt28=4;
-				int LA28_0 = input.LA(1);
+				int alt29=4;
+				int LA29_0 = input.LA(1);

-				if ( (LA28_0=='\\') )
+				if ( (LA29_0=='\\') )
{
-					alt28=1;
+					alt29=1;
}
-				else if ( (LA28_0=='\t'||LA28_0==' ') )
+				else if ( (LA29_0=='\t'||LA29_0==' ') )
{
-					alt28=2;
+					alt29=2;
}
-				else if ( ((LA28_0>='\u0000' && LA28_0<='\b')||(LA28_0>='\u000B' && LA28_0<='\f')||(LA28_0>='\u000E' && LA28_0<='\u001F')||(LA28_0>='!' && LA28_0<='#')||(LA28_0>='%' && LA28_0<='[')||(LA28_0>=']' && LA28_0<='\uFFFF')) )
+				else if ( ((LA29_0>='\u0000' && LA29_0<='\b')||(LA29_0>='\u000B' && LA29_0<='\f')||(LA29_0>='\u000E' && LA29_0<='\u001F')||(LA29_0>='!' && LA29_0<='#')||(LA29_0>='%' && LA29_0<='[')||(LA29_0>=']' && LA29_0<='\uFFFF')) )
{
-					alt28=3;
+					alt29=3;
}


-				switch ( alt28 )
+				switch ( alt29 )
{
case 1:
-					// Language\\Template.g3:370:6: '\\\\' ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) )
+					// Language\\Template.g3:371:6: '\\\\' (=> EOF | ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) ) )
{
Match('\\'); if (state.failed) return ;
-					// Language\\Template.g3:371:4: ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) )
-					int alt27=3;
-					int LA27_0 = input.LA(1);
+					// Language\\Template.g3:372:4: (=> EOF | ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) ) )
+					int alt28=2;
+					int LA28_0 = input.LA(1);

-					if ( (LA27_0=='$') )
+					if ( (LA28_0=='\\') )
{
-						alt27=1;
+						int LA28_2 = input.LA(2);
+
+						if ( (EvaluatePredicate(synpred13_Template_fragment)) )
+						{
+							alt28=1;
+						}
+						else if ( (true) )
+						{
+							alt28=2;
+						}
+						else
+						{
+							if (state.backtracking>0) {state.failed=true; return ;}
+							NoViableAltException nvae = new NoViableAltException("", 28, 2, input);
+
+							throw nvae;
+						}
}
-					else if ( (LA27_0=='\\') )
+					else if ( (LA28_0=='\t'||LA28_0==' ') )
{
-						alt27=2;
+						int LA28_3 = input.LA(2);
+
+						if ( (EvaluatePredicate(synpred13_Template_fragment)) )
+						{
+							alt28=1;
+						}
+						else if ( (true) )
+						{
+							alt28=2;
+						}
+						else
+						{
+							if (state.backtracking>0) {state.failed=true; return ;}
+							NoViableAltException nvae = new NoViableAltException("", 28, 3, input);
+
+							throw nvae;
+						}
}
-					else if ( ((LA27_0>='\u0000' && LA27_0<='#')||(LA27_0>='%' && LA27_0<='[')||(LA27_0>=']' && LA27_0<='\uFFFF')) )
+					else if ( ((LA28_0>='\u0000' && LA28_0<='\b')||(LA28_0>='\u000B' && LA28_0<='\f')||(LA28_0>='\u000E' && LA28_0<='\u001F')||(LA28_0>='!' && LA28_0<='#')||(LA28_0>='%' && LA28_0<='[')||(LA28_0>=']' && LA28_0<='\uFFFF')) )
{
-						alt27=3;
+						int LA28_4 = input.LA(2);
+
+						if ( (EvaluatePredicate(synpred13_Template_fragment)) )
+						{
+							alt28=1;
+						}
+						else if ( (true) )
+						{
+							alt28=2;
+						}
+						else
+						{
+							if (state.backtracking>0) {state.failed=true; return ;}
+							NoViableAltException nvae = new NoViableAltException("", 28, 4, input);
+
+							throw nvae;
+						}
}
-					else
+					else if ( (LA28_0=='\n'||LA28_0=='\r'||LA28_0=='$') )
{
-						if (state.backtracking>0) {state.failed=true; return ;}
-						NoViableAltException nvae = new NoViableAltException("", 27, 0, input);
-
-						throw nvae;
+						alt28=2;
}
-					switch ( alt27 )
+					else
+					{
+						alt28=1;}
+					switch ( alt28 )
{
case 1:
-						// Language\\Template.g3:371:6: '$'
+						// Language\\Template.g3:372:6: => EOF
{
-						Match('$'); if (state.failed) return ;
+
+						Match(EOF); if (state.failed) return ;
if ( state.backtracking == 0 )
{
-							builder.Append("$");
+							builder.Append("\\");
}

}
break;
case 2:
-						// Language\\Template.g3:372:6: '\\\\'
+						// Language\\Template.g3:373:6: ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) )
{
-						Match('\\'); if (state.failed) return ;
-						if ( state.backtracking == 0 )
+						// Language\\Template.g3:373:6: ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) )
+						int alt27=3;
+						int LA27_0 = input.LA(1);
+
+						if ( (LA27_0=='$') )
{
-							builder.Append("\\");
+							alt27=1;
}
-
+						else if ( (LA27_0=='\\') )
+						{
+							alt27=2;
}
-						break;
-					case 3:
-						// Language\\Template.g3:373:6: ch=~ ( '$' | '\\\\' )
+						else if ( ((LA27_0>='\u0000' && LA27_0<='#')||(LA27_0>='%' && LA27_0<='[')||(LA27_0>=']' && LA27_0<='\uFFFF')) )
{
-						ch= input.LA(1);
-						input.Consume();
-						state.failed=false;
-						if ( state.backtracking == 0 )
+							alt27=3;
+						}
+						else
+						{
+							if (state.backtracking>0) {state.failed=true; return ;}
+							NoViableAltException nvae = new NoViableAltException("", 27, 0, input);
+
+							throw nvae;
+						}
+						switch ( alt27 )
{
-							builder.Append("\\" + (char)ch);
+						case 1:
+							// Language\\Template.g3:373:8: '$'
+							{
+							Match('$'); if (state.failed) return ;
+							if ( state.backtracking == 0 )
+							{
+								builder.Append("$");
+							}
+
+							}
+							break;
+						case 2:
+							// Language\\Template.g3:374:7: '\\\\'
+							{
+							Match('\\'); if (state.failed) return ;
+							if ( state.backtracking == 0 )
+							{
+								builder.Append("\\");
+							}
+
+							}
+							break;
+						case 3:
+							// Language\\Template.g3:375:7: ch=~ ( '$' | '\\\\' )
+							{
+							ch= input.LA(1);
+							input.Consume();
+							state.failed=false;
+							if ( state.backtracking == 0 )
+							{
+								builder.Append("\\" + (char)ch);
+							}
+
+							}
+							break;
+
}

+
}
break;

@@ -1397,11 +1508,11 @@ public partial class TemplateLexer : Lexer
}
break;
case 2:
-					// Language\\Template.g3:375:5: ind= INDENT
+					// Language\\Template.g3:378:5: ind= INDENT
{
-					int indStart759 = CharIndex;
+					int indStart801 = CharIndex;
mINDENT(); if (state.failed) return ;
-					ind = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, indStart759, CharIndex-1);
+					ind = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, indStart801, CharIndex-1);
if ( state.backtracking == 0 )
{

@@ -1426,7 +1537,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 3:
-					// Language\\Template.g3:393:5: ch=~ ( '$' | '\\r' | '\\n' | '\\\\' | ' ' | '\\t' )
+					// Language\\Template.g3:396:5: ch=~ ( '$' | '\\r' | '\\n' | '\\\\' | ' ' | '\\t' )
{
ch= input.LA(1);
input.Consume();
@@ -1440,16 +1551,16 @@ public partial class TemplateLexer : Lexer
break;

default:
-					if ( cnt28 >= 1 )
-						goto loop28;
+					if ( cnt29 >= 1 )
+						goto loop29;

if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee28 = new EarlyExitException( 28, input );
-					throw eee28;
+					EarlyExitException eee29 = new EarlyExitException( 29, input );
+					throw eee29;
}
-				cnt28++;
+				cnt29++;
}
-			loop28:
+			loop29:
;


@@ -1487,42 +1598,42 @@ public partial class TemplateLexer : Lexer
string subtext = string.Empty;
System.Text.StringBuilder builder = new System.Text.StringBuilder();

-			// Language\\Template.g3:408:4: ( ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '$' ) )+ )
-			// Language\\Template.g3:408:4: ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '$' ) )+
+			// Language\\Template.g3:411:4: ( ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '$' ) )+ )
+			// Language\\Template.g3:411:4: ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '$' ) )+
{
-			// Language\\Template.g3:408:4: ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '$' ) )+
-			int cnt31=0;
+			// Language\\Template.g3:411:4: ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '$' ) )+
+			int cnt32=0;
for ( ; ; )
{
-				int alt31=5;
-				int LA31_0 = input.LA(1);
+				int alt32=5;
+				int LA32_0 = input.LA(1);

-				if ( (LA31_0=='\\') )
+				if ( (LA32_0=='\\') )
{
-					alt31=1;
+					alt32=1;
}
-				else if ( (LA31_0=='{') )
+				else if ( (LA32_0=='{') )
{
-					alt31=2;
+					alt32=2;
}
-				else if ( (LA31_0=='+'||LA31_0=='=') )
+				else if ( (LA32_0=='+'||LA32_0=='=') )
{
-					alt31=3;
+					alt32=3;
}
-				else if ( ((LA31_0>='\u0000' && LA31_0<='#')||(LA31_0>='%' && LA31_0<='*')||(LA31_0>=',' && LA31_0<='<')||(LA31_0>='>' && LA31_0<='[')||(LA31_0>=']' && LA31_0<='z')||(LA31_0>='|' && LA31_0<='\uFFFF')) )
+				else if ( ((LA32_0>='\u0000' && LA32_0<='#')||(LA32_0>='%' && LA32_0<='*')||(LA32_0>=',' && LA32_0<='<')||(LA32_0>='>' && LA32_0<='[')||(LA32_0>=']' && LA32_0<='z')||(LA32_0>='|' && LA32_0<='\uFFFF')) )
{
-					alt31=4;
+					alt32=4;
}


-				switch ( alt31 )
+				switch ( alt32 )
{
case 1:
-					// Language\\Template.g3:408:6: ESC
+					// Language\\Template.g3:411:6: ESC
{
-					int ESC1Start821 = CharIndex;
+					int ESC1Start863 = CharIndex;
mESC(); if (state.failed) return ;
-					ESC1 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ESC1Start821, CharIndex-1);
+					ESC1 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ESC1Start863, CharIndex-1);
if ( state.backtracking == 0 )
{
builder.Append((ESC1!=null?ESC1.Text:null));
@@ -1531,11 +1642,11 @@ public partial class TemplateLexer : Lexer
}
break;
case 2:
-					// Language\\Template.g3:409:5: st= SUBTEMPLATE
+					// Language\\Template.g3:412:5: st= SUBTEMPLATE
{
-					int stStart837 = CharIndex;
+					int stStart879 = CharIndex;
mSUBTEMPLATE(); if (state.failed) return ;
-					st = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, stStart837, CharIndex-1);
+					st = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, stStart879, CharIndex-1);
if ( state.backtracking == 0 )
{
builder.Append((st!=null?st.Text:null));
@@ -1544,31 +1655,31 @@ public partial class TemplateLexer : Lexer
}
break;
case 3:
-					// Language\\Template.g3:410:5: ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) )
+					// Language\\Template.g3:413:5: ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) )
{
-					// Language\\Template.g3:410:5: ( '=' | '+' )
-					int alt29=2;
-					int LA29_0 = input.LA(1);
+					// Language\\Template.g3:413:5: ( '=' | '+' )
+					int alt30=2;
+					int LA30_0 = input.LA(1);

-					if ( (LA29_0=='=') )
+					if ( (LA30_0=='=') )
{
-						alt29=1;
+						alt30=1;
}
-					else if ( (LA29_0=='+') )
+					else if ( (LA30_0=='+') )
{
-						alt29=2;
+						alt30=2;
}
else
{
if (state.backtracking>0) {state.failed=true; return ;}
-						NoViableAltException nvae = new NoViableAltException("", 29, 0, input);
+						NoViableAltException nvae = new NoViableAltException("", 30, 0, input);

throw nvae;
}
-					switch ( alt29 )
+					switch ( alt30 )
{
case 1:
-						// Language\\Template.g3:410:7: '='
+						// Language\\Template.g3:413:7: '='
{
Match('='); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1579,7 +1690,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 2:
-						// Language\\Template.g3:411:6: '+'
+						// Language\\Template.g3:414:6: '+'
{
Match('+'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1592,33 +1703,33 @@ public partial class TemplateLexer : Lexer

}

-					// Language\\Template.g3:413:4: ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) )
-					int alt30=3;
-					int LA30_0 = input.LA(1);
+					// Language\\Template.g3:416:4: ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) )
+					int alt31=3;
+					int LA31_0 = input.LA(1);

-					if ( (LA30_0=='\"'||LA30_0=='<') )
+					if ( (LA31_0=='\"'||LA31_0=='<') )
{
-						alt30=1;
+						alt31=1;
}
-					else if ( (LA30_0=='{') )
+					else if ( (LA31_0=='{') )
{
-						alt30=2;
+						alt31=2;
}
-					else if ( ((LA30_0>='\u0000' && LA30_0<='!')||(LA30_0>='#' && LA30_0<=';')||(LA30_0>='=' && LA30_0<='z')||(LA30_0>='|' && LA30_0<='\uFFFF')) )
+					else if ( ((LA31_0>='\u0000' && LA31_0<='!')||(LA31_0>='#' && LA31_0<=';')||(LA31_0>='=' && LA31_0<='z')||(LA31_0>='|' && LA31_0<='\uFFFF')) )
{
-						alt30=3;
+						alt31=3;
}
else
{
if (state.backtracking>0) {state.failed=true; return ;}
-						NoViableAltException nvae = new NoViableAltException("", 30, 0, input);
+						NoViableAltException nvae = new NoViableAltException("", 31, 0, input);

throw nvae;
}
-					switch ( alt30 )
+					switch ( alt31 )
{
case 1:
-						// Language\\Template.g3:413:6: TEMPLATE[out subtext]
+						// Language\\Template.g3:416:6: TEMPLATE[out subtext]
{
mTEMPLATE(out subtext); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1629,11 +1740,11 @@ public partial class TemplateLexer : Lexer
}
break;
case 2:
-						// Language\\Template.g3:414:6: st= SUBTEMPLATE
+						// Language\\Template.g3:417:6: st= SUBTEMPLATE
{
-						int stStart895 = CharIndex;
+						int stStart937 = CharIndex;
mSUBTEMPLATE(); if (state.failed) return ;
-						st = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, stStart895, CharIndex-1);
+						st = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, stStart937, CharIndex-1);
if ( state.backtracking == 0 )
{
builder.Append((st!=null?st.Text:null));
@@ -1642,7 +1753,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 3:
-						// Language\\Template.g3:415:6: ch=~ ( '\"' | '<' | '{' )
+						// Language\\Template.g3:418:6: ch=~ ( '\"' | '<' | '{' )
{
ch= input.LA(1);
input.Consume();
@@ -1661,7 +1772,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 4:
-					// Language\\Template.g3:417:5: ch=~ ( '\\\\' | '{' | '=' | '+' | '$' )
+					// Language\\Template.g3:420:5: ch=~ ( '\\\\' | '{' | '=' | '+' | '$' )
{
ch= input.LA(1);
input.Consume();
@@ -1675,16 +1786,16 @@ public partial class TemplateLexer : Lexer
break;

default:
-					if ( cnt31 >= 1 )
-						goto loop31;
+					if ( cnt32 >= 1 )
+						goto loop32;

if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee31 = new EarlyExitException( 31, input );
-					throw eee31;
+					EarlyExitException eee32 = new EarlyExitException( 32, input );
+					throw eee32;
}
-				cnt31++;
+				cnt32++;
}
-			loop31:
+			loop32:
;


@@ -1714,59 +1825,59 @@ public partial class TemplateLexer : Lexer
_text = string.Empty;
System.Text.StringBuilder builder = new System.Text.StringBuilder();

-			// Language\\Template.g3:429:4: ( '\"' ( ESC |ch=~ ( '\\\\' | '\"' ) )* '\"' | '<<' (=> ( '\\r' )? '\\n' )? (=> ( '\\r' )? '\\n' |ch= . )* '>>' )
-			int alt37=2;
-			int LA37_0 = input.LA(1);
+			// Language\\Template.g3:432:4: ( '\"' ( ESC |ch=~ ( '\\\\' | '\"' ) )* '\"' | '<<' (=> ( '\\r' )? '\\n' )? (=> ( '\\r' )? '\\n' |ch= . )* '>>' )
+			int alt38=2;
+			int LA38_0 = input.LA(1);

-			if ( (LA37_0=='\"') )
+			if ( (LA38_0=='\"') )
{
-				alt37=1;
+				alt38=1;
}
-			else if ( (LA37_0=='<') )
+			else if ( (LA38_0=='<') )
{
-				alt37=2;
+				alt38=2;
}
else
{
if (state.backtracking>0) {state.failed=true; return ;}
-				NoViableAltException nvae = new NoViableAltException("", 37, 0, input);
+				NoViableAltException nvae = new NoViableAltException("", 38, 0, input);

throw nvae;
}
-			switch ( alt37 )
+			switch ( alt38 )
{
case 1:
-				// Language\\Template.g3:429:4: '\"' ( ESC |ch=~ ( '\\\\' | '\"' ) )* '\"'
+				// Language\\Template.g3:432:4: '\"' ( ESC |ch=~ ( '\\\\' | '\"' ) )* '\"'
{
Match('\"'); if (state.failed) return ;
if ( state.backtracking == 0 )
{
builder.Append('"');
}
-				// Language\\Template.g3:431:3: ( ESC |ch=~ ( '\\\\' | '\"' ) )*
+				// Language\\Template.g3:434:3: ( ESC |ch=~ ( '\\\\' | '\"' ) )*
for ( ; ; )
{
-					int alt32=3;
-					int LA32_0 = input.LA(1);
+					int alt33=3;
+					int LA33_0 = input.LA(1);

-					if ( (LA32_0=='\\') )
+					if ( (LA33_0=='\\') )
{
-						alt32=1;
+						alt33=1;
}
-					else if ( ((LA32_0>='\u0000' && LA32_0<='!')||(LA32_0>='#' && LA32_0<='[')||(LA32_0>=']' && LA32_0<='\uFFFF')) )
+					else if ( ((LA33_0>='\u0000' && LA33_0<='!')||(LA33_0>='#' && LA33_0<='[')||(LA33_0>=']' && LA33_0<='\uFFFF')) )
{
-						alt32=2;
+						alt33=2;
}


-					switch ( alt32 )
+					switch ( alt33 )
{
case 1:
-						// Language\\Template.g3:431:5: ESC
+						// Language\\Template.g3:434:5: ESC
{
-						int ESC2Start981 = CharIndex;
+						int ESC2Start1023 = CharIndex;
mESC(); if (state.failed) return ;
-						ESC2 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ESC2Start981, CharIndex-1);
+						ESC2 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ESC2Start1023, CharIndex-1);
if ( state.backtracking == 0 )
{
builder.Append((ESC2!=null?ESC2.Text:null));
@@ -1775,7 +1886,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 2:
-						// Language\\Template.g3:432:5: ch=~ ( '\\\\' | '\"' )
+						// Language\\Template.g3:435:5: ch=~ ( '\\\\' | '\"' )
{
ch= input.LA(1);
input.Consume();
@@ -1789,11 +1900,11 @@ public partial class TemplateLexer : Lexer
break;

default:
-						goto loop32;
+						goto loop33;
}
}

-				loop32:
+				loop33:
;


@@ -1809,7 +1920,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 2:
-				// Language\\Template.g3:439:4: '<<' (=> ( '\\r' )? '\\n' )? (=> ( '\\r' )? '\\n' |ch= . )* '>>'
+				// Language\\Template.g3:442:4: '<<' (=> ( '\\r' )? '\\n' )? (=> ( '\\r' )? '\\n' |ch= . )* '>>'
{
Match("<<"); if (state.failed) return ;

@@ -1819,51 +1930,51 @@ public partial class TemplateLexer : Lexer
builder.Append("<<");

}
-				// Language\\Template.g3:443:4: (=> ( '\\r' )? '\\n' )?
-				int alt34=2;
-				int LA34_0 = input.LA(1);
+				// Language\\Template.g3:446:4: (=> ( '\\r' )? '\\n' )?
+				int alt35=2;
+				int LA35_0 = input.LA(1);

-				if ( (LA34_0=='\r') )
+				if ( (LA35_0=='\r') )
{
-					int LA34_1 = input.LA(2);
+					int LA35_1 = input.LA(2);

-					if ( (LA34_1=='\n') )
+					if ( (LA35_1=='\n') )
{
-						int LA34_2 = input.LA(3);
+						int LA35_2 = input.LA(3);

-						if ( (EvaluatePredicate(synpred12_Template_fragment)) )
+						if ( (EvaluatePredicate(synpred14_Template_fragment)) )
{
-							alt34=1;
+							alt35=1;
}
}
}
-				else if ( (LA34_0=='\n') )
+				else if ( (LA35_0=='\n') )
{
-					int LA34_2 = input.LA(2);
+					int LA35_2 = input.LA(2);

-					if ( (EvaluatePredicate(synpred12_Template_fragment)) )
+					if ( (EvaluatePredicate(synpred14_Template_fragment)) )
{
-						alt34=1;
+						alt35=1;
}
}
-				switch ( alt34 )
+				switch ( alt35 )
{
case 1:
-					// Language\\Template.g3:443:6: => ( '\\r' )? '\\n'
+					// Language\\Template.g3:446:6: => ( '\\r' )? '\\n'
{

-					// Language\\Template.g3:443:21: ( '\\r' )?
-					int alt33=2;
-					int LA33_0 = input.LA(1);
+					// Language\\Template.g3:446:21: ( '\\r' )?
+					int alt34=2;
+					int LA34_0 = input.LA(1);

-					if ( (LA33_0=='\r') )
+					if ( (LA34_0=='\r') )
{
-						alt33=1;
+						alt34=1;
}
-					switch ( alt33 )
+					switch ( alt34 )
{
case 1:
-						// Language\\Template.g3:443:22: '\\r'
+						// Language\\Template.g3:446:22: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -1879,88 +1990,88 @@ public partial class TemplateLexer : Lexer

}

-				// Language\\Template.g3:445:3: (=> ( '\\r' )? '\\n' |ch= . )*
+				// Language\\Template.g3:448:3: (=> ( '\\r' )? '\\n' |ch= . )*
for ( ; ; )
{
-					int alt36=3;
-					int LA36_0 = input.LA(1);
+					int alt37=3;
+					int LA37_0 = input.LA(1);

-					if ( (LA36_0=='>') )
+					if ( (LA37_0=='>') )
{
-						int LA36_1 = input.LA(2);
+						int LA37_1 = input.LA(2);

-						if ( (LA36_1=='>') )
+						if ( (LA37_1=='>') )
{
-							int LA36_5 = input.LA(3);
+							int LA37_5 = input.LA(3);

-							if ( ((LA36_5>='\u0000' && LA36_5<='\uFFFF')) )
+							if ( ((LA37_5>='\u0000' && LA37_5<='\uFFFF')) )
{
-								alt36=2;
+								alt37=2;
}


}
-						else if ( ((LA36_1>='\u0000' && LA36_1<='=')||(LA36_1>='?' && LA36_1<='\uFFFF')) )
+						else if ( ((LA37_1>='\u0000' && LA37_1<='=')||(LA37_1>='?' && LA37_1<='\uFFFF')) )
{
-							alt36=2;
+							alt37=2;
}


}
-					else if ( (LA36_0=='\r') )
+					else if ( (LA37_0=='\r') )
{
-						int LA36_2 = input.LA(2);
+						int LA37_2 = input.LA(2);

-						if ( (EvaluatePredicate(synpred13_Template_fragment)) )
+						if ( (EvaluatePredicate(synpred15_Template_fragment)) )
{
-							alt36=1;
+							alt37=1;
}
else if ( (true) )
{
-							alt36=2;
+							alt37=2;
}


}
-					else if ( (LA36_0=='\n') )
+					else if ( (LA37_0=='\n') )
{
-						int LA36_3 = input.LA(2);
+						int LA37_3 = input.LA(2);

-						if ( (EvaluatePredicate(synpred13_Template_fragment)) )
+						if ( (EvaluatePredicate(synpred15_Template_fragment)) )
{
-							alt36=1;
+							alt37=1;
}
else if ( (true) )
{
-							alt36=2;
+							alt37=2;
}


}
-					else if ( ((LA36_0>='\u0000' && LA36_0<='\t')||(LA36_0>='\u000B' && LA36_0<='\f')||(LA36_0>='\u000E' && LA36_0<='=')||(LA36_0>='?' && LA36_0<='\uFFFF')) )
+					else if ( ((LA37_0>='\u0000' && LA37_0<='\t')||(LA37_0>='\u000B' && LA37_0<='\f')||(LA37_0>='\u000E' && LA37_0<='=')||(LA37_0>='?' && LA37_0<='\uFFFF')) )
{
-						alt36=2;
+						alt37=2;
}


-					switch ( alt36 )
+					switch ( alt37 )
{
case 1:
-						// Language\\Template.g3:445:5: => ( '\\r' )? '\\n'
+						// Language\\Template.g3:448:5: => ( '\\r' )? '\\n'
{

-						// Language\\Template.g3:445:23: ( '\\r' )?
-						int alt35=2;
-						int LA35_0 = input.LA(1);
+						// Language\\Template.g3:448:23: ( '\\r' )?
+						int alt36=2;
+						int LA36_0 = input.LA(1);

-						if ( (LA35_0=='\r') )
+						if ( (LA36_0=='\r') )
{
-							alt35=1;
+							alt36=1;
}
-						switch ( alt35 )
+						switch ( alt36 )
{
case 1:
-							// Language\\Template.g3:445:24: '\\r'
+							// Language\\Template.g3:448:24: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -1974,7 +2085,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 2:
-						// Language\\Template.g3:446:5: ch= .
+						// Language\\Template.g3:449:5: ch= .
{
ch = input.LA(1);
MatchAny(); if (state.failed) return ;
@@ -1987,11 +2098,11 @@ public partial class TemplateLexer : Lexer
break;

default:
-						goto loop36;
+						goto loop37;
}
}

-				loop36:
+				loop37:
;


@@ -2021,59 +2132,59 @@ public partial class TemplateLexer : Lexer
{
try
{
-			// Language\\Template.g3:457:4: ( ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+ )
-			// Language\\Template.g3:457:4: ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+
+			// Language\\Template.g3:460:4: ( ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+ )
+			// Language\\Template.g3:460:4: ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+
{
-			// Language\\Template.g3:457:4: ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+
-			int cnt38=0;
+			// Language\\Template.g3:460:4: ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+
+			int cnt39=0;
for ( ; ; )
{
-				int alt38=5;
-				int LA38_0 = input.LA(1);
+				int alt39=5;
+				int LA39_0 = input.LA(1);

-				if ( (LA38_0=='\\') )
+				if ( (LA39_0=='\\') )
{
-					alt38=1;
+					alt39=1;
}
-				else if ( (LA38_0=='{') )
+				else if ( (LA39_0=='{') )
{
-					alt38=2;
+					alt39=2;
}
-				else if ( (LA38_0=='(') )
+				else if ( (LA39_0=='(') )
{
-					alt38=3;
+					alt39=3;
}
-				else if ( ((LA38_0>='\u0000' && LA38_0<='\'')||(LA38_0>='*' && LA38_0<='[')||(LA38_0>=']' && LA38_0<='z')||(LA38_0>='|' && LA38_0<='\uFFFF')) )
+				else if ( ((LA39_0>='\u0000' && LA39_0<='\'')||(LA39_0>='*' && LA39_0<='[')||(LA39_0>=']' && LA39_0<='z')||(LA39_0>='|' && LA39_0<='\uFFFF')) )
{
-					alt38=4;
+					alt39=4;
}


-				switch ( alt38 )
+				switch ( alt39 )
{
case 1:
-					// Language\\Template.g3:457:6: ESC
+					// Language\\Template.g3:460:6: ESC
{
mESC(); if (state.failed) return ;

}
break;
case 2:
-					// Language\\Template.g3:458:5: SUBTEMPLATE
+					// Language\\Template.g3:461:5: SUBTEMPLATE
{
mSUBTEMPLATE(); if (state.failed) return ;

}
break;
case 3:
-					// Language\\Template.g3:459:5: NESTED_PARENS
+					// Language\\Template.g3:462:5: NESTED_PARENS
{
mNESTED_PARENS(); if (state.failed) return ;

}
break;
case 4:
-					// Language\\Template.g3:460:5: ~ ( '\\\\' | '{' | '(' | ')' )
+					// Language\\Template.g3:463:5: ~ ( '\\\\' | '{' | '(' | ')' )
{
input.Consume();
state.failed=false;
@@ -2082,16 +2193,16 @@ public partial class TemplateLexer : Lexer
break;

default:
-					if ( cnt38 >= 1 )
-						goto loop38;
+					if ( cnt39 >= 1 )
+						goto loop39;

if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee38 = new EarlyExitException( 38, input );
-					throw eee38;
+					EarlyExitException eee39 = new EarlyExitException( 39, input );
+					throw eee39;
}
-				cnt38++;
+				cnt39++;
}
-			loop38:
+			loop39:
;


@@ -2118,43 +2229,43 @@ public partial class TemplateLexer : Lexer

uc = '\0';

-			// Language\\Template.g3:470:4: ( '\\\\n' | '\\\\r' | '\\\\t' | '\\\\ ' | '\\\\u' a= HEX b= HEX c= HEX d= HEX )
-			int alt39=5;
-			int LA39_0 = input.LA(1);
+			// Language\\Template.g3:473:4: ( '\\\\n' | '\\\\r' | '\\\\t' | '\\\\ ' | '\\\\u' a= HEX b= HEX c= HEX d= HEX )
+			int alt40=5;
+			int LA40_0 = input.LA(1);

-			if ( (LA39_0=='\\') )
+			if ( (LA40_0=='\\') )
{
switch ( input.LA(2) )
{
case 'n':
{
-					alt39=1;
+					alt40=1;
}
break;
case 'r':
{
-					alt39=2;
+					alt40=2;
}
break;
case 't':
{
-					alt39=3;
+					alt40=3;
}
break;
case ' ':
{
-					alt39=4;
+					alt40=4;
}
break;
case 'u':
{
-					alt39=5;
+					alt40=5;
}
break;
default:
{
if (state.backtracking>0) {state.failed=true; return ;}
-						NoViableAltException nvae = new NoViableAltException("", 39, 1, input);
+						NoViableAltException nvae = new NoViableAltException("", 40, 1, input);

throw nvae;
}
@@ -2164,14 +2275,14 @@ public partial class TemplateLexer : Lexer
else
{
if (state.backtracking>0) {state.failed=true; return ;}
-				NoViableAltException nvae = new NoViableAltException("", 39, 0, input);
+				NoViableAltException nvae = new NoViableAltException("", 40, 0, input);

throw nvae;
}
-			switch ( alt39 )
+			switch ( alt40 )
{
case 1:
-				// Language\\Template.g3:470:4: '\\\\n'
+				// Language\\Template.g3:473:4: '\\\\n'
{
Match("\\n"); if (state.failed) return ;

@@ -2183,7 +2294,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 2:
-				// Language\\Template.g3:471:4: '\\\\r'
+				// Language\\Template.g3:474:4: '\\\\r'
{
Match("\\r"); if (state.failed) return ;

@@ -2195,7 +2306,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 3:
-				// Language\\Template.g3:472:4: '\\\\t'
+				// Language\\Template.g3:475:4: '\\\\t'
{
Match("\\t"); if (state.failed) return ;

@@ -2207,7 +2318,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 4:
-				// Language\\Template.g3:473:4: '\\\\ '
+				// Language\\Template.g3:476:4: '\\\\ '
{
Match("\\ "); if (state.failed) return ;

@@ -2219,22 +2330,22 @@ public partial class TemplateLexer : Lexer
}
break;
case 5:
-				// Language\\Template.g3:474:4: '\\\\u' a= HEX b= HEX c= HEX d= HEX
+				// Language\\Template.g3:477:4: '\\\\u' a= HEX b= HEX c= HEX d= HEX
{
Match("\\u"); if (state.failed) return ;

-				int aStart1192 = CharIndex;
+				int aStart1234 = CharIndex;
mHEX(); if (state.failed) return ;
-				a = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, aStart1192, CharIndex-1);
-				int bStart1196 = CharIndex;
+				a = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, aStart1234, CharIndex-1);
+				int bStart1238 = CharIndex;
mHEX(); if (state.failed) return ;
-				b = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, bStart1196, CharIndex-1);
-				int cStart1200 = CharIndex;
+				b = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, bStart1238, CharIndex-1);
+				int cStart1242 = CharIndex;
mHEX(); if (state.failed) return ;
-				c = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, cStart1200, CharIndex-1);
-				int dStart1204 = CharIndex;
+				c = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, cStart1242, CharIndex-1);
+				int dStart1246 = CharIndex;
mHEX(); if (state.failed) return ;
-				d = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, dStart1204, CharIndex-1);
+				d = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, dStart1246, CharIndex-1);
if ( state.backtracking == 0 )
{
uc = (char)int.Parse((a!=null?a.Text:null)+(b!=null?b.Text:null)+(c!=null?c.Text:null)+(d!=null?d.Text:null), System.Globalization.NumberStyles.AllowHexSpecifier);
@@ -2256,8 +2367,8 @@ public partial class TemplateLexer : Lexer
{
try
{
-			// Language\\Template.g3:480:4: ( '\\\\' . )
-			// Language\\Template.g3:480:4: '\\\\' .
+			// Language\\Template.g3:483:4: ( '\\\\' . )
+			// Language\\Template.g3:483:4: '\\\\' .
{
Match('\\'); if (state.failed) return ;
MatchAny(); if (state.failed) return ;
@@ -2276,7 +2387,7 @@ public partial class TemplateLexer : Lexer
{
try
{
-			// Language\\Template.g3:485:4: ( '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' )
+			// Language\\Template.g3:488:4: ( '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' )
// Language\\Template.g3:
{
if ( (input.LA(1)>='0' && input.LA(1)<='9')||(input.LA(1)>='A' && input.LA(1)<='F')||(input.LA(1)>='a' && input.LA(1)<='f') )
@@ -2306,48 +2417,48 @@ public partial class TemplateLexer : Lexer
{
try
{
-			// Language\\Template.g3:490:4: ( '{' ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )* '}' )
-			// Language\\Template.g3:490:4: '{' ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )* '}'
+			// Language\\Template.g3:493:4: ( '{' ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )* '}' )
+			// Language\\Template.g3:493:4: '{' ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )* '}'
{
Match('{'); if (state.failed) return ;
-			// Language\\Template.g3:491:3: ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )*
+			// Language\\Template.g3:494:3: ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )*
for ( ; ; )
{
-				int alt40=4;
-				int LA40_0 = input.LA(1);
+				int alt41=4;
+				int LA41_0 = input.LA(1);

-				if ( (LA40_0=='{') )
+				if ( (LA41_0=='{') )
{
-					alt40=1;
+					alt41=1;
}
-				else if ( (LA40_0=='\\') )
+				else if ( (LA41_0=='\\') )
{
-					alt40=2;
+					alt41=2;
}
-				else if ( ((LA40_0>='\u0000' && LA40_0<='[')||(LA40_0>=']' && LA40_0<='z')||LA40_0=='|'||(LA40_0>='~' && LA40_0<='\uFFFF')) )
+				else if ( ((LA41_0>='\u0000' && LA41_0<='[')||(LA41_0>=']' && LA41_0<='z')||LA41_0=='|'||(LA41_0>='~' && LA41_0<='\uFFFF')) )
{
-					alt40=3;
+					alt41=3;
}


-				switch ( alt40 )
+				switch ( alt41 )
{
case 1:
-					// Language\\Template.g3:491:5: SUBTEMPLATE
+					// Language\\Template.g3:494:5: SUBTEMPLATE
{
mSUBTEMPLATE(); if (state.failed) return ;

}
break;
case 2:
-					// Language\\Template.g3:492:5: ESC
+					// Language\\Template.g3:495:5: ESC
{
mESC(); if (state.failed) return ;

}
break;
case 3:
-					// Language\\Template.g3:493:5: ~ ( '{' | '\\\\' | '}' )
+					// Language\\Template.g3:496:5: ~ ( '{' | '\\\\' | '}' )
{
input.Consume();
state.failed=false;
@@ -2356,11 +2467,11 @@ public partial class TemplateLexer : Lexer
break;

default:
-					goto loop40;
+					goto loop41;
}
}

-			loop40:
+			loop41:
;


@@ -2380,49 +2491,49 @@ public partial class TemplateLexer : Lexer
{
try
{
-			// Language\\Template.g3:500:4: ( '(' ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+ ')' )
-			// Language\\Template.g3:500:4: '(' ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+ ')'
+			// Language\\Template.g3:503:4: ( '(' ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+ ')' )
+			// Language\\Template.g3:503:4: '(' ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+ ')'
{
Match('('); if (state.failed) return ;
-			// Language\\Template.g3:501:3: ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+
-			int cnt41=0;
+			// Language\\Template.g3:504:3: ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+
+			int cnt42=0;
for ( ; ; )
{
-				int alt41=4;
-				int LA41_0 = input.LA(1);
+				int alt42=4;
+				int LA42_0 = input.LA(1);

-				if ( (LA41_0=='(') )
+				if ( (LA42_0=='(') )
{
-					alt41=1;
+					alt42=1;
}
-				else if ( (LA41_0=='\\') )
+				else if ( (LA42_0=='\\') )
{
-					alt41=2;
+					alt42=2;
}
-				else if ( ((LA41_0>='\u0000' && LA41_0<='\'')||(LA41_0>='*' && LA41_0<='[')||(LA41_0>=']' && LA41_0<='\uFFFF')) )
+				else if ( ((LA42_0>='\u0000' && LA42_0<='\'')||(LA42_0>='*' && LA42_0<='[')||(LA42_0>=']' && LA42_0<='\uFFFF')) )
{
-					alt41=3;
+					alt42=3;
}


-				switch ( alt41 )
+				switch ( alt42 )
{
case 1:
-					// Language\\Template.g3:501:5: NESTED_PARENS
+					// Language\\Template.g3:504:5: NESTED_PARENS
{
mNESTED_PARENS(); if (state.failed) return ;

}
break;
case 2:
-					// Language\\Template.g3:502:5: ESC
+					// Language\\Template.g3:505:5: ESC
{
mESC(); if (state.failed) return ;

}
break;
case 3:
-					// Language\\Template.g3:503:5: ~ ( '(' | '\\\\' | ')' )
+					// Language\\Template.g3:506:5: ~ ( '(' | '\\\\' | ')' )
{
input.Consume();
state.failed=false;
@@ -2431,16 +2542,16 @@ public partial class TemplateLexer : Lexer
break;

default:
-					if ( cnt41 >= 1 )
-						goto loop41;
+					if ( cnt42 >= 1 )
+						goto loop42;

if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee41 = new EarlyExitException( 41, input );
-					throw eee41;
+					EarlyExitException eee42 = new EarlyExitException( 42, input );
+					throw eee42;
}
-				cnt41++;
+				cnt42++;
}
-			loop41:
+			loop42:
;


@@ -2460,23 +2571,23 @@ public partial class TemplateLexer : Lexer
{
try
{
-			// Language\\Template.g3:510:4: ( ( ' ' | '\\t' )+ )
-			// Language\\Template.g3:510:4: ( ' ' | '\\t' )+
+			// Language\\Template.g3:513:4: ( ( ' ' | '\\t' )+ )
+			// Language\\Template.g3:513:4: ( ' ' | '\\t' )+
{
-			// Language\\Template.g3:510:4: ( ' ' | '\\t' )+
-			int cnt42=0;
+			// Language\\Template.g3:513:4: ( ' ' | '\\t' )+
+			int cnt43=0;
for ( ; ; )
{
-				int alt42=2;
-				int LA42_0 = input.LA(1);
+				int alt43=2;
+				int LA43_0 = input.LA(1);

-				if ( (LA42_0=='\t'||LA42_0==' ') )
+				if ( (LA43_0=='\t'||LA43_0==' ') )
{
-					alt42=1;
+					alt43=1;
}


-				switch ( alt42 )
+				switch ( alt43 )
{
case 1:
// Language\\Template.g3:
@@ -2488,16 +2599,16 @@ public partial class TemplateLexer : Lexer
break;

default:
-					if ( cnt42 >= 1 )
-						goto loop42;
+					if ( cnt43 >= 1 )
+						goto loop43;

if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee42 = new EarlyExitException( 42, input );
-					throw eee42;
+					EarlyExitException eee43 = new EarlyExitException( 43, input );
+					throw eee43;
}
-				cnt42++;
+				cnt43++;
}
-			loop42:
+			loop43:
;


@@ -2519,42 +2630,42 @@ public partial class TemplateLexer : Lexer

int startCol = CharPositionInLine;

-			// Language\\Template.g3:519:4: ( '$!' ( . )* '!$' ({...}? => ( '\\r' )? '\\n' )? )
-			// Language\\Template.g3:519:4: '$!' ( . )* '!$' ({...}? => ( '\\r' )? '\\n' )?
+			// Language\\Template.g3:522:4: ( '$!' ( . )* '!$' ({...}? => ( '\\r' )? '\\n' )? )
+			// Language\\Template.g3:522:4: '$!' ( . )* '!$' ({...}? => ( '\\r' )? '\\n' )?
{
Match("$!"); if (state.failed) return ;

-			// Language\\Template.g3:519:9: ( . )*
+			// Language\\Template.g3:522:9: ( . )*
for ( ; ; )
{
-				int alt43=2;
-				int LA43_0 = input.LA(1);
+				int alt44=2;
+				int LA44_0 = input.LA(1);

-				if ( (LA43_0=='!') )
+				if ( (LA44_0=='!') )
{
-					int LA43_1 = input.LA(2);
+					int LA44_1 = input.LA(2);

-					if ( (LA43_1=='$') )
+					if ( (LA44_1=='$') )
{
-						alt43=2;
+						alt44=2;
}
-					else if ( ((LA43_1>='\u0000' && LA43_1<='#')||(LA43_1>='%' && LA43_1<='\uFFFF')) )
+					else if ( ((LA44_1>='\u0000' && LA44_1<='#')||(LA44_1>='%' && LA44_1<='\uFFFF')) )
{
-						alt43=1;
+						alt44=1;
}


}
-				else if ( ((LA43_0>='\u0000' && LA43_0<=' ')||(LA43_0>='\"' && LA43_0<='\uFFFF')) )
+				else if ( ((LA44_0>='\u0000' && LA44_0<=' ')||(LA44_0>='\"' && LA44_0<='\uFFFF')) )
{
-					alt43=1;
+					alt44=1;
}


-				switch ( alt43 )
+				switch ( alt44 )
{
case 1:
-					// Language\\Template.g3:519:0: .
+					// Language\\Template.g3:522:0: .
{
MatchAny(); if (state.failed) return ;

@@ -2562,46 +2673,46 @@ public partial class TemplateLexer : Lexer
break;

default:
-					goto loop43;
+					goto loop44;
}
}

-			loop43:
+			loop44:
;


Match("!$"); if (state.failed) return ;

-			// Language\\Template.g3:519:17: ({...}? => ( '\\r' )? '\\n' )?
-			int alt45=2;
-			int LA45_0 = input.LA(1);
+			// Language\\Template.g3:522:17: ({...}? => ( '\\r' )? '\\n' )?
+			int alt46=2;
+			int LA46_0 = input.LA(1);

-			if ( (LA45_0=='\n'||LA45_0=='\r') && ((startCol==0)))
+			if ( (LA46_0=='\n'||LA46_0=='\r') && ((startCol==0)))
{
-				alt45=1;
+				alt46=1;
}
-			switch ( alt45 )
+			switch ( alt46 )
{
case 1:
-				// Language\\Template.g3:519:19: {...}? => ( '\\r' )? '\\n'
+				// Language\\Template.g3:522:19: {...}? => ( '\\r' )? '\\n'
{
if ( !((startCol==0)) )
{
if (state.backtracking>0) {state.failed=true; return ;}
throw new FailedPredicateException(input, "COMMENT", "startCol==0");
}
-				// Language\\Template.g3:519:37: ( '\\r' )?
-				int alt44=2;
-				int LA44_0 = input.LA(1);
+				// Language\\Template.g3:522:37: ( '\\r' )?
+				int alt45=2;
+				int LA45_0 = input.LA(1);

-				if ( (LA44_0=='\r') )
+				if ( (LA45_0=='\r') )
{
-					alt44=1;
+					alt45=1;
}
-				switch ( alt44 )
+				switch ( alt45 )
{
case 1:
-					// Language\\Template.g3:519:38: '\\r'
+					// Language\\Template.g3:522:38: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -2627,32 +2738,113 @@ public partial class TemplateLexer : Lexer
}
// $ANTLR end "COMMENT"

+	// $ANTLR start "LINE_BREAK"
+	private void mLINE_BREAK()
+	{
+		try
+		{
+			// Language\\Template.g3:527:4: ( '$\\\\\\\\$' ( INDENT )? ( '\\r' )? '\\n' ( INDENT )? )
+			// Language\\Template.g3:527:4: '$\\\\\\\\$' ( INDENT )? ( '\\r' )? '\\n' ( INDENT )?
+			{
+			Match("$\\\\$"); if (state.failed) return ;
+
+			// Language\\Template.g3:527:13: ( INDENT )?
+			int alt47=2;
+			int LA47_0 = input.LA(1);
+
+			if ( (LA47_0=='\t'||LA47_0==' ') )
+			{
+				alt47=1;
+			}
+			switch ( alt47 )
+			{
+			case 1:
+				// Language\\Template.g3:527:0: INDENT
+				{
+				mINDENT(); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+			// Language\\Template.g3:527:21: ( '\\r' )?
+			int alt48=2;
+			int LA48_0 = input.LA(1);
+
+			if ( (LA48_0=='\r') )
+			{
+				alt48=1;
+			}
+			switch ( alt48 )
+			{
+			case 1:
+				// Language\\Template.g3:527:0: '\\r'
+				{
+				Match('\r'); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+			Match('\n'); if (state.failed) return ;
+			// Language\\Template.g3:527:32: ( INDENT )?
+			int alt49=2;
+			int LA49_0 = input.LA(1);
+
+			if ( (LA49_0=='\t'||LA49_0==' ') )
+			{
+				alt49=1;
+			}
+			switch ( alt49 )
+			{
+			case 1:
+				// Language\\Template.g3:527:0: INDENT
+				{
+				mINDENT(); if (state.failed) return ;
+
+				}
+				break;
+
+			}
+
+
+			}
+
+		}
+		finally
+		{
+		}
+	}
+	// $ANTLR end "LINE_BREAK"
+
public override void mTokens()
{
// Language\\Template.g3:1:10: ( NEWLINE | ACTION | LITERAL )
-		int alt46=3;
-		int LA46_0 = input.LA(1);
+		int alt50=3;
+		int LA50_0 = input.LA(1);

-		if ( (LA46_0=='\n'||LA46_0=='\r') )
+		if ( (LA50_0=='\n'||LA50_0=='\r') )
{
-			alt46=1;
+			alt50=1;
}
-		else if ( (LA46_0=='$') )
+		else if ( (LA50_0=='$') )
{
-			alt46=2;
+			alt50=2;
}
-		else if ( ((LA46_0>='\u0000' && LA46_0<='\t')||(LA46_0>='\u000B' && LA46_0<='\f')||(LA46_0>='\u000E' && LA46_0<='#')||(LA46_0>='%' && LA46_0<='\uFFFF')) )
+		else if ( ((LA50_0>='\u0000' && LA50_0<='\t')||(LA50_0>='\u000B' && LA50_0<='\f')||(LA50_0>='\u000E' && LA50_0<='#')||(LA50_0>='%' && LA50_0<='\uFFFF')) )
{
-			alt46=3;
+			alt50=3;
}
else
{
if (state.backtracking>0) {state.failed=true; return ;}
-			NoViableAltException nvae = new NoViableAltException("", 46, 0, input);
+			NoViableAltException nvae = new NoViableAltException("", 50, 0, input);

throw nvae;
}
-		switch ( alt46 )
+		switch ( alt50 )
{
case 1:
// Language\\Template.g3:1:10: NEWLINE
@@ -2683,11 +2875,10 @@ public partial class TemplateLexer : Lexer
// $ANTLR start synpred1_Template
public void synpred1_Template_fragment()
{
-		// Language\\Template.g3:281:4: ( '$\\\\' )
-		// Language\\Template.g3:281:5: '$\\\\'
+		// Language\\Template.g3:281:4: ( LINE_BREAK )
+		// Language\\Template.g3:281:5: LINE_BREAK
{
-		Match("$\\"); if (state.failed) return ;
-
+		mLINE_BREAK(); if (state.failed) return ;

}
}
@@ -2696,7 +2887,7 @@ public partial class TemplateLexer : Lexer
// $ANTLR start synpred10_Template
public void synpred10_Template_fragment()
{
-		// Language\\Template.g3:343:8: ( '\\r' | '\\n' )
+		// Language\\Template.g3:340:9: ( '\\r' | '\\n' )
// Language\\Template.g3:
{
if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
@@ -2719,10 +2910,20 @@ public partial class TemplateLexer : Lexer
// $ANTLR start synpred11_Template
public void synpred11_Template_fragment()
{
-		// Language\\Template.g3:344:8: ( '$@end$' )
-		// Language\\Template.g3:344:9: '$@end$'
+		// Language\\Template.g3:344:8: ( '\\r' | '\\n' )
+		// Language\\Template.g3:
{
-		Match("$@end$"); if (state.failed) return ;
+		if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
+		{
+			input.Consume();
+		state.failed=false;
+		}
+		else
+		{
+			if (state.backtracking>0) {state.failed=true; return ;}
+			MismatchedSetException mse = new MismatchedSetException(null,input);
+			Recover(mse);
+			throw mse;}


}
@@ -2732,7 +2933,32 @@ public partial class TemplateLexer : Lexer
// $ANTLR start synpred12_Template
public void synpred12_Template_fragment()
{
-		// Language\\Template.g3:443:6: ( '\\r' | '\\n' )
+		// Language\\Template.g3:345:8: ( '$@end$' )
+		// Language\\Template.g3:345:9: '$@end$'
+		{
+		Match("$@end$"); if (state.failed) return ;
+
+
+		}
+	}
+	// $ANTLR end synpred12_Template
+
+	// $ANTLR start synpred13_Template
+	public void synpred13_Template_fragment()
+	{
+		// Language\\Template.g3:372:6: ( EOF )
+		// Language\\Template.g3:372:7: EOF
+		{
+		Match(EOF); if (state.failed) return ;
+
+		}
+	}
+	// $ANTLR end synpred13_Template
+
+	// $ANTLR start synpred14_Template
+	public void synpred14_Template_fragment()
+	{
+		// Language\\Template.g3:446:6: ( '\\r' | '\\n' )
// Language\\Template.g3:
{
if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
@@ -2750,26 +2976,26 @@ public partial class TemplateLexer : Lexer

}
}
-	// $ANTLR end synpred12_Template
+	// $ANTLR end synpred14_Template

-	// $ANTLR start synpred13_Template
-	public void synpred13_Template_fragment()
+	// $ANTLR start synpred15_Template
+	public void synpred15_Template_fragment()
{
-		// Language\\Template.g3:445:5: ( ( '\\r' )? '\\n>>' )
-		// Language\\Template.g3:445:6: ( '\\r' )? '\\n>>'
+		// Language\\Template.g3:448:5: ( ( '\\r' )? '\\n>>' )
+		// Language\\Template.g3:448:6: ( '\\r' )? '\\n>>'
{
-		// Language\\Template.g3:445:6: ( '\\r' )?
-		int alt47=2;
-		int LA47_0 = input.LA(1);
+		// Language\\Template.g3:448:6: ( '\\r' )?
+		int alt51=2;
+		int LA51_0 = input.LA(1);

-		if ( (LA47_0=='\r') )
+		if ( (LA51_0=='\r') )
{
-			alt47=1;
+			alt51=1;
}
-		switch ( alt47 )
+		switch ( alt51 )
{
case 1:
-			// Language\\Template.g3:445:0: '\\r'
+			// Language\\Template.g3:448:0: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -2783,15 +3009,15 @@ public partial class TemplateLexer : Lexer

}
}
-	// $ANTLR end synpred13_Template
+	// $ANTLR end synpred15_Template

// $ANTLR start synpred2_Template
public void synpred2_Template_fragment()
{
-		// Language\\Template.g3:288:5: ( '$!' )
-		// Language\\Template.g3:288:6: '$!'
+		// Language\\Template.g3:282:5: ( '$\\\\' )
+		// Language\\Template.g3:282:6: '$\\\\'
{
-		Match("$!"); if (state.failed) return ;
+		Match("$\\"); if (state.failed) return ;


}
@@ -2801,8 +3027,21 @@ public partial class TemplateLexer : Lexer
// $ANTLR start synpred3_Template
public void synpred3_Template_fragment()
{
-		// Language\\Template.g3:290:7: ( '$if' ( ' ' | '(' ) )
-		// Language\\Template.g3:290:8: '$if' ( ' ' | '(' )
+		// Language\\Template.g3:289:5: ( '$!' )
+		// Language\\Template.g3:289:6: '$!'
+		{
+		Match("$!"); if (state.failed) return ;
+
+
+		}
+	}
+	// $ANTLR end synpred3_Template
+
+	// $ANTLR start synpred4_Template
+	public void synpred4_Template_fragment()
+	{
+		// Language\\Template.g3:291:7: ( '$if' ( ' ' | '(' ) )
+		// Language\\Template.g3:291:8: '$if' ( ' ' | '(' )
{
Match("$if"); if (state.failed) return ;

@@ -2821,13 +3060,13 @@ public partial class TemplateLexer : Lexer

}
}
-	// $ANTLR end synpred3_Template
+	// $ANTLR end synpred4_Template

-	// $ANTLR start synpred4_Template
-	public void synpred4_Template_fragment()
+	// $ANTLR start synpred5_Template
+	public void synpred5_Template_fragment()
{
-		// Language\\Template.g3:297:6: ( '$elseif' ( ' ' | '(' ) )
-		// Language\\Template.g3:297:7: '$elseif' ( ' ' | '(' )
+		// Language\\Template.g3:298:6: ( '$elseif' ( ' ' | '(' ) )
+		// Language\\Template.g3:298:7: '$elseif' ( ' ' | '(' )
{
Match("$elseif"); if (state.failed) return ;

@@ -2846,28 +3085,15 @@ public partial class TemplateLexer : Lexer

}
}
-	// $ANTLR end synpred4_Template
-
-	// $ANTLR start synpred5_Template
-	public void synpred5_Template_fragment()
-	{
-		// Language\\Template.g3:304:6: ( '$else$' )
-		// Language\\Template.g3:304:7: '$else$'
-		{
-		Match("$else$"); if (state.failed) return ;
-
-
-		}
-	}
// $ANTLR end synpred5_Template

// $ANTLR start synpred6_Template
public void synpred6_Template_fragment()
{
-		// Language\\Template.g3:311:6: ( '$endif$' )
-		// Language\\Template.g3:311:7: '$endif$'
+		// Language\\Template.g3:305:6: ( '$else$' )
+		// Language\\Template.g3:305:7: '$else$'
{
-		Match("$endif$"); if (state.failed) return ;
+		Match("$else$"); if (state.failed) return ;


}
@@ -2877,10 +3103,10 @@ public partial class TemplateLexer : Lexer
// $ANTLR start synpred7_Template
public void synpred7_Template_fragment()
{
-		// Language\\Template.g3:321:5: ( '$@' )
-		// Language\\Template.g3:321:6: '$@'
+		// Language\\Template.g3:312:6: ( '$endif$' )
+		// Language\\Template.g3:312:7: '$endif$'
{
-		Match("$@"); if (state.failed) return ;
+		Match("$endif$"); if (state.failed) return ;


}
@@ -2890,20 +3116,10 @@ public partial class TemplateLexer : Lexer
// $ANTLR start synpred8_Template
public void synpred8_Template_fragment()
{
-		// Language\\Template.g3:336:8: ( '\\r' | '\\n' )
-		// Language\\Template.g3:
-		{
-		if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
+		// Language\\Template.g3:322:5: ( '$@' )
+		// Language\\Template.g3:322:6: '$@'
{
-			input.Consume();
-		state.failed=false;
-		}
-		else
-		{
-			if (state.backtracking>0) {state.failed=true; return ;}
-			MismatchedSetException mse = new MismatchedSetException(null,input);
-			Recover(mse);
-			throw mse;}
+		Match("$@"); if (state.failed) return ;


}
@@ -2913,7 +3129,7 @@ public partial class TemplateLexer : Lexer
// $ANTLR start synpred9_Template
public void synpred9_Template_fragment()
{
-		// Language\\Template.g3:339:9: ( '\\r' | '\\n' )
+		// Language\\Template.g3:337:8: ( '\\r' | '\\n' )
// Language\\Template.g3:
{
if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
@@ -3031,7 +3247,7 @@ public partial class TemplateLexer : Lexer
}
public override string GetDescription()
{
-			return "()+ loopback of 338:6: ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+";
+			return "()+ loopback of 339:6: ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+";
}
}

diff --git a/Antlr3.StringTemplate/Language/TemplateParser.cs b/Antlr3.StringTemplate/Language/TemplateParser.cs
index 60a8fd0..963b3ca 100644
--- a/Antlr3.StringTemplate/Language/TemplateParser.cs
+++ b/Antlr3.StringTemplate/Language/TemplateParser.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Language\\Template.g3 2009-04-18 02:24:00
+// $ANTLR 3.1.2 Language\\Template.g3 2009-07-30 16:39:08

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -50,8 +50,8 @@ namespace Antlr3.ST.Language
{
public partial class TemplateParser : Parser
{
-	public static readonly string[] tokenNames = new string[] {
-		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "COMMENT", "ELSE", "ELSEIF", "ENDIF", "ESC", "ESC_CHAR", "EXPR", "HEX", "IF", "IF_EXPR", "INDENT", "LITERAL", "NESTED_PARENS", "NEWLINE", "REGION_DEF", "REGION_REF", "SUBTEMPLATE", "TEMPLATE"
+	internal static readonly string[] tokenNames = new string[] {
+		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "COMMENT", "ELSE", "ELSEIF", "ENDIF", "ESC", "ESC_CHAR", "EXPR", "HEX", "IF", "IF_EXPR", "INDENT", "LINE_BREAK", "LITERAL", "NESTED_PARENS", "NEWLINE", "REGION_DEF", "REGION_REF", "SUBTEMPLATE", "TEMPLATE"
};
public const int EOF=-1;
public const int ACTION=4;
@@ -66,13 +66,14 @@ public partial class TemplateParser : Parser
public const int IF=13;
public const int IF_EXPR=14;
public const int INDENT=15;
-	public const int LITERAL=16;
-	public const int NESTED_PARENS=17;
-	public const int NEWLINE=18;
-	public const int REGION_DEF=19;
-	public const int REGION_REF=20;
-	public const int SUBTEMPLATE=21;
-	public const int TEMPLATE=22;
+	public const int LINE_BREAK=16;
+	public const int LITERAL=17;
+	public const int NESTED_PARENS=18;
+	public const int NEWLINE=19;
+	public const int REGION_DEF=20;
+	public const int REGION_REF=21;
+	public const int SUBTEMPLATE=22;
+	public const int TEMPLATE=23;

// delegates
// delegators
@@ -471,18 +472,18 @@ public partial class TemplateParser : Parser


#region Follow sets
-	public static class Follow
+	static class Follow
{
-		public static readonly BitSet _LITERAL_in_template71 = new BitSet(new ulong[]{0x1D2012UL});
-		public static readonly BitSet _NEWLINE_in_template82 = new BitSet(new ulong[]{0x1D2012UL});
-		public static readonly BitSet _action_in_template93 = new BitSet(new ulong[]{0x1D2012UL});
+		public static readonly BitSet _LITERAL_in_template71 = new BitSet(new ulong[]{0x3A2012UL});
+		public static readonly BitSet _NEWLINE_in_template82 = new BitSet(new ulong[]{0x3A2012UL});
+		public static readonly BitSet _action_in_template93 = new BitSet(new ulong[]{0x3A2012UL});
public static readonly BitSet _EOF_in_template103 = new BitSet(new ulong[]{0x2UL});
public static readonly BitSet _ACTION_in_action118 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _IF_in_action130 = new BitSet(new ulong[]{0x1D2010UL});
+		public static readonly BitSet _IF_in_action130 = new BitSet(new ulong[]{0x3A2010UL});
public static readonly BitSet _template_in_action139 = new BitSet(new ulong[]{0x1C0UL});
-		public static readonly BitSet _ELSEIF_in_action151 = new BitSet(new ulong[]{0x1D2010UL});
+		public static readonly BitSet _ELSEIF_in_action151 = new BitSet(new ulong[]{0x3A2010UL});
public static readonly BitSet _template_in_action162 = new BitSet(new ulong[]{0x1C0UL});
-		public static readonly BitSet _ELSE_in_action181 = new BitSet(new ulong[]{0x1D2010UL});
+		public static readonly BitSet _ELSE_in_action181 = new BitSet(new ulong[]{0x3A2010UL});
public static readonly BitSet _template_in_action192 = new BitSet(new ulong[]{0x100UL});
public static readonly BitSet _ENDIF_in_action208 = new BitSet(new ulong[]{0x2UL});
public static readonly BitSet _REGION_REF_in_action216 = new BitSet(new ulong[]{0x2UL});
diff --git a/Antlr3.StringTemplate/StringTemplate.cs b/Antlr3.StringTemplate/StringTemplate.cs
index 4256a8a..ce5c056 100644
--- a/Antlr3.StringTemplate/StringTemplate.cs
+++ b/Antlr3.StringTemplate/StringTemplate.cs
@@ -962,7 +962,11 @@ namespace Antlr3.ST

public virtual object GetAttribute( string name )
{
-            return Get( this, name );
+            object v = Get(this, name);
+            if (v == null)
+                CheckNullAttributeAgainstFormalArguments(this, name);
+
+            return v;
}

/** <summary>
@@ -980,6 +984,7 @@ namespace Antlr3.ST
_group.EmitTemplateStartDebugString( this, writer );
}
int n = 0;
+            bool missing = true;
SetPredefinedAttributes();
SetDefaultArgumentValues();
int chunkCount = _chunks != null ? _chunks.Count : 0;
@@ -988,7 +993,7 @@ namespace Antlr3.ST
Expr a = _chunks[i];
int chunkN = a.Write( this, writer );
// expr-on-first-line-with-no-output NEWLINE => NEWLINE
-                if ( chunkN == 0 && i == 0 && ( i + 1 ) < chunkCount &&
+                if ( chunkN <= 0 && i == 0 && ( i + 1 ) < chunkCount &&
_chunks[i + 1] is NewlineRef )
{
//System.out.println("found pure first-line-blank \\n pattern");
@@ -998,23 +1003,29 @@ namespace Antlr3.ST
// NEWLINE expr-with-no-output NEWLINE => NEWLINE
// Indented $...$ have the indent stored with the ASTExpr
// so the indent does not come out as a StringRef
-                if ( chunkN == 0 &&
+                if ( chunkN <= 0 &&
( i - 1 ) >= 0 && _chunks[i - 1] is NewlineRef &&
( i + 1 ) < chunkCount && _chunks[i + 1] is NewlineRef )
{
//System.out.println("found pure \\n blank \\n pattern");
i++; // make it skip over the next chunk, the NEWLINE
}
-                n += chunkN;
+                if (chunkN != ASTExpr.Missing)
+                {
+                    n += chunkN;
+                    missing = false;
+                }
}
+
if ( _group.debugTemplateOutput )
-            {
_group.EmitTemplateStopDebugString( this, writer );
-            }
+
if ( LintMode )
-            {
CheckForTrouble();
-            }
+
+            if (missing && _chunks != null && _chunks.Count > 0)
+                return ASTExpr.Missing;
+
return n;
}

@@ -1050,9 +1061,9 @@ namespace Antlr3.ST
*/
public virtual object Get( StringTemplate self, string attribute )
{
-            //Console.Out.WriteLine( "### get(" + self.GetEnclosingInstanceStackString() + ", " + attribute + ")" );
-            //Console.Out.WriteLine( "attributes=" + ( self.Attributes != null ? self.Attributes.keySet().ToString() : "none" ) );
-            if ( self == null )
+            //Console.WriteLine("### get("+self.GetEnclosingInstanceStackString()+", "+attribute+")");
+            //Console.WriteLine("attributes="+(self.Attributes!=null?self.Attributes.Keys.ToString():"none"));
+            if (self == null)
{
return null;
}
@@ -1095,10 +1106,10 @@ namespace Antlr3.ST
{
//Console.Out.WriteLine( "looking for " + Name + "." + attribute + " in super=" + _enclosingInstance.Name );
object valueFromEnclosing = Get( self._enclosingInstance, attribute );
-                if ( valueFromEnclosing == null )
-                {
-                    CheckNullAttributeAgainstFormalArguments( self, attribute );
-                }
+                //if ( valueFromEnclosing == null )
+                //{
+                //    CheckNullAttributeAgainstFormalArguments( self, attribute );
+                //}
o = valueFromEnclosing;
}

@@ -1210,6 +1221,7 @@ namespace Antlr3.ST
*/
public virtual void SetDefaultArgumentValues()
{
+            //Console.WriteLine("setDefaultArgumentValues; " + _name + ": argctx=" + _argumentContext + ", n=" + _numberOfDefaultArgumentValues);
if ( _numberOfDefaultArgumentValues == 0 )
{
return;
@@ -1220,20 +1232,47 @@ namespace Antlr3.ST
}
if ( _formalArguments != FormalArgument.UNKNOWN )
{
+                //Console.WriteLine("formal args=" + _formalArguments);
foreach ( var arg in _formalArguments )
{
string argName = arg.name;
// use the default value then
if ( arg.defaultValueST != null )
{
-                        object existingValue = GetAttribute( argName );
-                        if ( existingValue == null )
-                        { // value unset?
+                        //Console.WriteLine("default value=" + arg.defaultValueST.Chunks);
+                        //Console.WriteLine(GetEnclosingInstanceStackString() + ": get " + argName + " argctx=" + ArgumentContext);
+                        object existingValue = GetAttribute(argName);
+                        //Console.WriteLine("existing value=" + existingValue);
+                        if (existingValue == null)
+                        {
+                            // value unset?
+                            object defaultValue = arg.defaultValueST;
// if no value for attribute, set arg context
// to the default value.  We don't need an instance
// here because no attributes can be set in
// the arg templates by the user.
-                            _argumentContext[argName] = arg.defaultValueST;
+
+                            int nchunks = 0;
+                            if (arg.defaultValueST.Chunks != null)
+                                nchunks = arg.defaultValueST.Chunks.Count;
+
+                            if (nchunks == 1)
+                            {
+                                // If default arg is template with single expression
+                                // wrapped in parens, x={<(...)>}, then eval to string
+                                // rather than setting x to the template for later
+                                // eval.
+                                object a = arg.defaultValueST.Chunks[0];
+                                ASTExpr e = a as ASTExpr;
+                                if (e != null)
+                                {
+                                    if (e.AST.Type == ActionEvaluator.VALUE)
+                                    {
+                                        defaultValue = e.EvaluateExpression(this, e.AST);
+                                    }
+                                }
+                            }
+                            _argumentContext[argName] = defaultValue;
}
}
}
@@ -1290,7 +1329,9 @@ namespace Antlr3.ST

public virtual void DefineFormalArgument( string name, StringTemplate defaultValue )
{
-            if ( defaultValue != null )
+            //Console.WriteLine("define formal arg "+this.Name+"."+name+
+            //                   ", def value="+(defaultValue!=null?defaultValue.Chunks.ToString():"null"));
+            if (defaultValue != null)
{
_numberOfDefaultArgumentValues++;
}
diff --git a/Antlr3.Test/StringTemplateTests.cs b/Antlr3.Test/StringTemplateTests.cs
index 63a298b..f06fba0 100644
--- a/Antlr3.Test/StringTemplateTests.cs
+++ b/Antlr3.Test/StringTemplateTests.cs
@@ -178,7 +178,7 @@ namespace AntlrUnitTests
"bold(item) ::= <<foo>>" + newline +
"duh(a,b,c) ::= <<foo>>" + newline;

-            writeFile( tmpdir, "testG.stg", templates );
+            WriteFile( tmpdir, "testG.stg", templates );

/*StringTemplateGroup group =*/
new StringTemplateGroup( new StreamReader( System.IO.File.OpenRead( tmpdir + "/testG.stg" ) ), errors );
@@ -201,7 +201,7 @@ namespace AntlrUnitTests
"bold(item) ::= <<foo>>" + newline +
"duh(a,b,c) ::= <<foo>>" + newline;

-            writeFile( tmpdir, "testG.stg", templates );
+            WriteFile( tmpdir, "testG.stg", templates );

StringTemplateGroup group =
new StringTemplateGroup( new StreamReader( tmpdir + "/testG.stg" ), errors );
@@ -238,7 +238,7 @@ namespace AntlrUnitTests
"bold(item) ::= <<foo>>" + newline +
"duh(a,b,c) ::= <<foo>>" + newline;

-            writeFile( tmpdir + "/sub", "testG2.stg", templates );
+            WriteFile( tmpdir + "/sub", "testG2.stg", templates );

StringTemplateGroup group =
StringTemplateGroup.LoadGroup( "testG2" );
@@ -261,7 +261,7 @@ namespace AntlrUnitTests
"t();" + newline +
"bold(item);" + newline +
"optional duh(a,b,c);" + newline;
-            writeFile( tmpdir, "testI.sti", groupI );
+            WriteFile( tmpdir, "testI.sti", groupI );

string templates =
"group testG implements testI;" + newline +
@@ -269,7 +269,7 @@ namespace AntlrUnitTests
"bold(item) ::= <<foo>>" + newline +
"duh(a,b,c) ::= <<foo>>" + newline;

-            writeFile( tmpdir, "testG.stg", templates );
+            WriteFile( tmpdir, "testG.stg", templates );

StringTemplateGroup group =
new StringTemplateGroup( new StreamReader( tmpdir + "/testG.stg" ), errors );
@@ -290,13 +290,13 @@ namespace AntlrUnitTests
string superGroup =
"group superG;" + newline +
"bold(item) ::= <<*$item$*>>;\n" + newline;
-            writeFile( tmpdir, "superG.stg", superGroup );
+            WriteFile( tmpdir, "superG.stg", superGroup );

string templates =
"group testG : superG;" + newline +
"main(x) ::= <<$bold(x)$>>" + newline;

-            writeFile( tmpdir, "testG.stg", templates );
+            WriteFile( tmpdir, "testG.stg", templates );

StringTemplateGroup group =
new StringTemplateGroup( new StreamReader( tmpdir + "/testG.stg" ),
@@ -321,13 +321,13 @@ namespace AntlrUnitTests
string superGroup =
"group superG;" + newline +
"bold(item) ::= <<*<item>*>>;\n" + newline;
-            writeFile( tmpdir, "superG.stg", superGroup );
+            WriteFile( tmpdir, "superG.stg", superGroup );

string templates =
"group testG : superG;" + newline +
"main(x) ::= \"<bold(x)>\"" + newline;

-            writeFile( tmpdir, "testG.stg", templates );
+            WriteFile( tmpdir, "testG.stg", templates );

StringTemplateGroup group =
new StringTemplateGroup( new StreamReader( tmpdir + "/testG.stg" ),
@@ -351,14 +351,14 @@ namespace AntlrUnitTests
"t();" + newline +
"bold(item);" + newline +
"optional duh(a,b,c);" + newline;
-            writeFile( tmpdir, "testI.sti", groupI );
+            WriteFile( tmpdir, "testI.sti", groupI );

string templates =
"group testG implements testI;" + newline +
"t() ::= <<foo>>" + newline +
"duh(a,b,c) ::= <<foo>>" + newline;

-            writeFile( tmpdir, "testG.stg", templates );
+            WriteFile( tmpdir, "testG.stg", templates );

StringTemplateGroup group =
new StringTemplateGroup( new StreamReader( tmpdir + "/testG.stg" ), errors );
@@ -379,14 +379,14 @@ namespace AntlrUnitTests
"t();" + newline +
"bold(item);" + newline +
"optional duh(a,b,c);" + newline;
-            writeFile( tmpdir, "testI.sti", groupI );
+            WriteFile( tmpdir, "testI.sti", groupI );

string templates =
"group testG implements testI;" + newline +
"t() ::= <<foo>>" + newline +
"bold(item) ::= <<foo>>";

-            writeFile( tmpdir, "testG.stg", templates );
+            WriteFile( tmpdir, "testG.stg", templates );

StringTemplateGroup group =
new StringTemplateGroup( new StreamReader( tmpdir + "/testG.stg" ), errors );
@@ -407,7 +407,7 @@ namespace AntlrUnitTests
"t();" + newline +
"bold(item);" + newline +
"optional duh(a,b,c);" + newline;
-            writeFile( tmpdir, "testI.sti", groupI );
+            WriteFile( tmpdir, "testI.sti", groupI );

string templates =
"group testG implements testI;" + newline +
@@ -415,7 +415,7 @@ namespace AntlrUnitTests
"bold(item) ::= <<foo>>" + newline +
"duh(a,c) ::= <<foo>>" + newline;

-            writeFile( tmpdir, "testG.stg", templates );
+            WriteFile( tmpdir, "testG.stg", templates );

StringTemplateGroup group =
new StringTemplateGroup( new StreamReader( tmpdir + "/testG.stg" ), errors );
@@ -2975,8 +2975,8 @@ namespace AntlrUnitTests
string templates =
"group dork;" + newline +
"" + newline +
-                    "test(names) ::= <<" +
-                    "<names:(ind)()>" + newline +
+                    "test(names,t) ::= <<" +
+                    "<names:(t)()>" + newline + // t null be must be defined else error: null attr w/o formal def
">>" + newline +
"ind() ::= \"[<it>]\"" + newline;
;
@@ -3137,6 +3137,96 @@ namespace AntlrUnitTests
}

[TestMethod]
+        public void TestLineBreak()
+        {
+            StringTemplate st = new StringTemplate(
+                    "Foo <\\\\>" + newline +
+                    "  \t  bar" + newline,
+                    typeof(AngleBracketTemplateLexer)
+                    );
+            StringWriter sw = new StringWriter();
+            st.Write(new AutoIndentWriter(sw, "\n")); // force \n as newline
+            string result = sw.ToString();
+            string expecting = "Foo bar\n";     // expect \n in output
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestLineBreak2()
+        {
+            StringTemplate st = new StringTemplate(
+                    "Foo <\\\\>       " + newline +
+                    "  \t  bar" + newline,
+                    typeof(AngleBracketTemplateLexer)
+                    );
+            StringWriter sw = new StringWriter();
+            st.Write(new AutoIndentWriter(sw, "\n")); // force \n as newline
+            string result = sw.ToString();
+            string expecting = "Foo bar\n";     // expect \n in output
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestLineBreakNoWhiteSpace()
+        {
+            StringTemplate st = new StringTemplate(
+                    "Foo <\\\\>" + newline +
+                    "bar" + newline,
+                    typeof(AngleBracketTemplateLexer)
+                    );
+            StringWriter sw = new StringWriter();
+            st.Write(new AutoIndentWriter(sw, "\n")); // force \n as newline
+            string result = sw.ToString();
+            string expecting = "Foo bar\n";     // expect \n in output
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestLineBreakDollar()
+        {
+            StringTemplate st = new StringTemplate(
+                    "Foo $\\\\$" + newline +
+                    "  \t  bar" + newline,
+                    typeof(DefaultTemplateLexer)
+                    );
+            StringWriter sw = new StringWriter();
+            st.Write(new AutoIndentWriter(sw, "\n")); // force \n as newline
+            string result = sw.ToString();
+            string expecting = "Foo bar\n";     // expect \n in output
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestLineBreakDollar2()
+        {
+            StringTemplate st = new StringTemplate(
+                    "Foo $\\\\$          " + newline +
+                    "  \t  bar" + newline,
+                    typeof(DefaultTemplateLexer)
+                    );
+            StringWriter sw = new StringWriter();
+            st.Write(new AutoIndentWriter(sw, "\n")); // force \n as newline
+            string result = sw.ToString();
+            string expecting = "Foo bar\n";     // expect \n in output
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestLineBreakNoWhiteSpaceDollar()
+        {
+            StringTemplate st = new StringTemplate(
+                    "Foo $\\\\$" + newline +
+                    "bar" + newline,
+                    typeof(DefaultTemplateLexer)
+                    );
+            StringWriter sw = new StringWriter();
+            st.Write(new AutoIndentWriter(sw, "\n")); // force \n as newline
+            string result = sw.ToString();
+            string expecting = "Foo bar\n";     // expect \n in output
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
public void TestCharLiterals()
{
StringTemplate st = new StringTemplate(
@@ -3258,7 +3348,7 @@ namespace AntlrUnitTests
}

[TestMethod]
-        public void TestEmptyIteratedConditionalValueGetsSeparator()
+        public void TestMissingIteratedConditionalValueGetsNoSeparator()
{
StringTemplateGroup group =
new StringTemplateGroup( "test" );
@@ -3271,13 +3361,47 @@ namespace AntlrUnitTests
t.SetAttribute( "users.{name,ok}", "Frank", ( true ) );
t.SetAttribute( "users.{name,ok}", "Johnny", ( false ) );
// empty conditional values get no separator
-            string expecting = "Terence,,Frank,";
+            string expecting = "Terence,Frank";
string result = t.ToString();
Assert.AreEqual( expecting, result );
}

[TestMethod]
-        public void TestEmptyIteratedConditionalWithElseValueGetsSeparator()
+        public void TestMissingIteratedConditionalValueGetsNoSeparator2()
+        {
+            StringTemplateGroup group = new StringTemplateGroup("test");
+            IStringTemplateErrorListener errors = new ErrorBuffer();
+            group.ErrorListener = errors;
+            StringTemplate t = new StringTemplate(group, "$users:{$if(it.ok)$$it.name$$endif$}; separator=\",\"$");
+            t.SetAttribute("users.{name,ok}", "Terence", true);
+            t.SetAttribute("users.{name,ok}", "Tom", false);
+            t.SetAttribute("users.{name,ok}", "Frank", false);
+            t.SetAttribute("users.{name,ok}", "Johnny", false);
+            // empty conditional values get no separator
+            string expecting = "Terence";
+            string result = t.ToString();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestMissingIteratedDoubleConditionalValueGetsNoSeparator()
+        {
+            StringTemplateGroup group = new StringTemplateGroup("test");
+            IStringTemplateErrorListener errors = new ErrorBuffer();
+            group.ErrorListener = errors;
+            StringTemplate t = new StringTemplate(group, "$users:{$if(it.ok)$$it.name$$endif$$if(it.ok)$$it.name$$endif$}; separator=\",\"$");
+            t.SetAttribute("users.{name,ok}", "Terence", false);
+            t.SetAttribute("users.{name,ok}", "Tom", true);
+            t.SetAttribute("users.{name,ok}", "Frank", true);
+            t.SetAttribute("users.{name,ok}", "Johnny", true);
+            // empty conditional values get no separator
+            string expecting = "TomTom,FrankFrank,JohnnyJohnny";
+            string result = t.ToString();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestIteratedConditionalWithEmptyElseValueGetsSeparator()
{
StringTemplateGroup group =
new StringTemplateGroup( "test" );
@@ -3610,6 +3734,85 @@ namespace AntlrUnitTests
Assert.AreEqual( expecting, result );
}

+        public class Field
+        {
+            public string name = "parrt";
+            public int n = 0;
+
+            public override string ToString()
+            {
+                return "Field";
+            }
+        }
+
+        [TestMethod]
+        public void TestDefaultArgumentManuallySet()
+        {
+            string templates =
+                    "group test;" + newline +
+                    "method(fields) ::= <<" + newline +
+                    "<fields:{f | <stat(f=f)>}>" + newline +
+                    ">>" + newline +
+                    "stat(f,value={<f.name>}) ::= \"x=<value>; // <f.name>\"" + newline
+                    ;
+
+            StringTemplateGroup group = new StringTemplateGroup(new StringReader(templates));
+            StringTemplate m = group.GetInstanceOf("method");
+            m.SetAttribute("fields", new Field());
+            string expecting = "x=parrt; // parrt";
+            string result = m.ToString();
+            Assert.AreEqual(expecting, result);
+        }
+
+        /** This fails because checkNullAttributeAgainstFormalArguments looks
+         *  for a formal argument at the current level not of the original embedded
+         *  template. We have defined it all the way in the embedded, but there is
+         *  no value so we try to look upwards ala dynamic scoping. When it reaches
+         *  the top, it doesn't find a value but it will miss the
+         *  formal argument down in the embedded.
+         *
+         *  By definition, though, the formal parameter exists if we have
+         *  a default value. look up the value to see if it's null without
+         *  checking checkNullAttributeAgainstFormalArguments.
+         */
+        [TestMethod]
+        public void TestDefaultArgumentImplicitlySet()
+        {
+            string templates =
+                    "group test;" + newline +
+                    "method(fields) ::= <<" + newline +
+                    "<fields:{f | <stat(...)>}>" + newline +
+                    ">>" + newline +
+                    "stat(f,value={<f.name>}) ::= \"x=<value>; // <f.name>\"" + newline
+                    ;
+
+            StringTemplateGroup group = new StringTemplateGroup(new StringReader(templates));
+            StringTemplate m = group.GetInstanceOf("method");
+            m.SetAttribute("fields", new Field());
+            string expecting = "x=parrt; // parrt";
+            string result = m.ToString();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDefaultArgumentImplicitlySet2()
+        {
+            string templates =
+                    "group test;" + newline +
+                    "method(fields) ::= <<" + newline +
+                    "<fields:{f | <f:stat()>}>" + newline +  // THIS SHOULD BE ERROR; >1 arg?
+                    ">>" + newline +
+                    "stat(f,value={<f.name>}) ::= \"x=<value>; // <f.name>\"" + newline
+                    ;
+
+            StringTemplateGroup group = new StringTemplateGroup(new StringReader(templates));
+            StringTemplate m = group.GetInstanceOf("method");
+            m.SetAttribute("fields", new Field());
+            string expecting = "x=parrt; // parrt";
+            string result = m.ToString();
+            Assert.AreEqual(expecting, result);
+        }
+
[TestMethod]
public void TestDefaultArgumentAsTemplate()
{
@@ -3641,8 +3844,7 @@ namespace AntlrUnitTests
">>" + newline +
"stat(name,value={ [<name>] }) ::= \"x=<value>; // <name>\"" + newline
;
-            StringTemplateGroup group =
-                    new StringTemplateGroup( new StringReader( templates ) );
+            StringTemplateGroup group = new StringTemplateGroup( new StringReader( templates ) );
StringTemplate b = group.GetInstanceOf( "method" );
b.SetAttribute( "name", "foo" );
b.SetAttribute( "size", "2" );
@@ -3671,6 +3873,33 @@ namespace AntlrUnitTests
Assert.AreEqual( expecting, result );
}

+        private class Counter
+        {
+            int n = 0;
+            public override string ToString()
+            {
+                return (n++).ToString();
+            }
+        }
+
+        [TestMethod]
+        public void TestDefaultArgumentInParensToEvalEarly()
+        {
+            string templates =
+                    "group test;" + newline +
+                    "A(x) ::= \"<B()>\"" + newline +
+                    "B(y={<(x)>}) ::= \"<y> <x> <x> <y>\"" + newline
+                    ;
+
+            StringTemplateGroup group = new StringTemplateGroup(new StringReader(templates));
+            StringTemplate b = group.GetInstanceOf("A");
+            b.SetAttribute("x", new Counter());
+            string expecting = "0 1 2 0";
+            string result = b.ToString();
+            //Console.Error.WriteLine("result='" + result + "'");
+            Assert.AreEqual(expecting, result);
+        }
+
[TestMethod]
public void TestArgumentsAsTemplates()
{
@@ -5770,6 +5999,24 @@ namespace AntlrUnitTests
}

[TestMethod]
+        public void TestBackslash()
+        {
+            StringTemplateGroup group = new StringTemplateGroup("test");
+            StringTemplate t = group.DefineTemplate("t", "\\");
+            string expecting = "\\";
+            Assert.AreEqual(expecting, t.ToString());
+        }
+
+        [TestMethod]
+        public void TestBackslash2()
+        {
+            StringTemplateGroup group = new StringTemplateGroup("test");
+            StringTemplate t = group.DefineTemplate("t", "\\ ");
+            string expecting = "\\ ";
+            Assert.AreEqual(expecting, t.ToString());
+        }
+
+        [TestMethod]
public void TestEscapeEscape()
{
StringTemplateGroup group =
@@ -6350,7 +6597,7 @@ namespace AntlrUnitTests
Assert.AreEqual( expecting, st.ToString() );
}

-        public static void writeFile( string dir, string fileName, string content )
+        public static void WriteFile( string dir, string fileName, string content )
{
try
{

