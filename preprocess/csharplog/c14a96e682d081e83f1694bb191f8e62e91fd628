commit c14a96e682d081e83f1694bb191f8e62e91fd628
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Mon Nov 2 09:14:36 2009 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Mon Nov 2 09:14:36 2009 -0800

C# Port: Merge CL 6183 (new parameters used by the C target)

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 6289]

diff --git a/Antlr3.Targets/Antlr3.Targets.C/CTarget.cs b/Antlr3.Targets/Antlr3.Targets.C/CTarget.cs
index 358d16b..0b33c35 100644
--- a/Antlr3.Targets/Antlr3.Targets.C/CTarget.cs
+++ b/Antlr3.Targets/Antlr3.Targets.C/CTarget.cs
@@ -144,7 +144,6 @@ namespace Antlr3.Targets

public override string GetTargetCharLiteralFromANTLRCharLiteral( CodeGenerator generator, string literal )
{
-
if ( literal.StartsWith( "'\\u" ) )
{
literal = "0x" + literal.Substring( 3, 4 );
@@ -173,7 +172,6 @@ namespace Antlr3.Targets
public override string GetTargetStringLiteralFromANTLRStringLiteral( CodeGenerator generator, string literal )
{
int index;
-            //int outc;
string bytes;
StringBuilder buf = new StringBuilder();

@@ -259,6 +257,57 @@ namespace Antlr3.Targets
return strref;
}

+        /// <summary>
+        /// Overrides the standard grammar analysis so we can prepare the analyser
+        /// a little differently from the other targets.
+        ///
+        /// In particular we want to influence the way the code generator makes assumptions about
+        /// switchs vs ifs, vs table driven DFAs. In general, C code should be generated that
+        /// has the minimum use of tables, and tha meximum use of large switch statements. This
+        /// allows the optimizers to generate very efficient code, it can reduce object code size
+        /// by about 30% and give about a 20% performance improvement over not doing this. Hence,
+        /// for the C target only, we change the defaults here, but only if they are still set to the
+        /// defaults.
+        /// </summary>
+        /// <param name="generator">An instance of the generic code generator class.</param>
+        /// <param name="grammar">The grammar that we are currently analyzing.</param>
+        protected override void PerformGrammarAnalysis(CodeGenerator generator, Grammar grammar)
+        {
+            // Check to see if the maximum inline DFA states is still set to
+            // the default size. If it is then whack it all the way up to the maximum that
+            // we can sensibly get away with.
+            //
+            if (CodeGenerator.MaxAcyclicDfaStatesInline == CodeGenerator.DefaultMaxAcyclicDfaStatesInline)
+            {
+                CodeGenerator.MaxAcyclicDfaStatesInline = 65535;
+            }
+
+            // Check to see if the maximum switch size is still set to the default
+            // and bring it up much higher if it is. Modern C compilers can handle
+            // much bigger switch statements than say Java can and if anyone finds a compiler
+            // that cannot deal with such big switches, all the need do is generate the
+            // code with a reduced -Xmaxswitchcaselabels nnn
+            //
+            if (CodeGenerator.MaxSwitchCaseLabels == CodeGenerator.DefaultMaxSwitchCaseLabels)
+            {
+                CodeGenerator.MaxSwitchCaseLabels = 3000;
+            }
+
+            // Check to see if the number of transitions considered a miminum for using
+            // a switch is still at the default. Because a switch is still generally faster than
+            // an if even with small sets, and given that the optimizer will do the best thing with it
+            // anyway, then we simply want to generate a switch for any number of states.
+            //
+            if (CodeGenerator.MinSwitchAlts == CodeGenerator.DefaultMinSwitchAlts)
+            {
+                CodeGenerator.MinSwitchAlts = 1;
+            }
+
+            // Now we allow the superclass implementation to do whatever it feels it
+            // must do.
+            //
+            base.PerformGrammarAnalysis(generator, grammar);
+        }
}

}
diff --git a/Antlr3/AntlrTool.cs b/Antlr3/AntlrTool.cs
index c018882..f86d920 100644
--- a/Antlr3/AntlrTool.cs
+++ b/Antlr3/AntlrTool.cs
@@ -333,56 +333,88 @@ namespace Antlr3
CodeGenerator.MaxAcyclicDfaStatesInline = int.Parse( args[i] );
}
}
-                else if ( args[i] == "-Xm" )
+                else if (args[i] == "-Xmaxswitchcaselabels")
{
-                    if ( i + 1 >= args.Length )
+                    if (i + 1 >= args.Length)
{
-                        Console.Error.WriteLine( "missing max recursion with -Xm option; ignoring" );
+                        Console.Error.WriteLine("missing max switch case labels -Xmaxswitchcaselabels option; ignoring");
}
else
{
i++;
-                        NFAContext.MAX_SAME_RULE_INVOCATIONS_PER_NFA_CONFIG_STACK = int.Parse( args[i] );
+                        int value;
+                        if (int.TryParse(args[i], out value))
+                            CodeGenerator.MaxSwitchCaseLabels = value;
+                        else
+                            Console.Error.WriteLine(string.Format("invalid value '{0}' for max switch case labels -Xmaxswitchcaselabels option; ignoring", args[i]));
}
}
-                else if ( args[i] == "-Xmaxdfaedges" )
+                else if (args[i] == "-Xminswitchalts")
{
-                    if ( i + 1 >= args.Length )
+                    if (i + 1 >= args.Length)
{
-                        Console.Error.WriteLine( "missing max number of edges with -Xmaxdfaedges option; ignoring" );
+                        Console.Error.WriteLine("missing min switch alternatives -Xminswitchalts option; ignoring");
}
else
{
i++;
-                        DFA.MAX_STATE_TRANSITIONS_FOR_TABLE = int.Parse( args[i] );
+                        int value;
+                        if (int.TryParse(args[i], out value))
+                            CodeGenerator.MinSwitchAlts = value;
+                        else
+                            Console.Error.WriteLine(string.Format("invalid value '{0}' for min switch alternatives -Xminswitchalts option; ignoring", args[i]));
}
}
-                else if ( args[i] == "-Xconversiontimeout" )
+                else if (args[i] == "-Xm")
{
-                    if ( i + 1 >= args.Length )
+                    if (i + 1 >= args.Length)
+                    {
+                        Console.Error.WriteLine("missing max recursion with -Xm option; ignoring");
+                    }
+                    else
+                    {
+                        i++;
+                        NFAContext.MAX_SAME_RULE_INVOCATIONS_PER_NFA_CONFIG_STACK = int.Parse(args[i]);
+                    }
+                }
+                else if (args[i] == "-Xmaxdfaedges")
+                {
+                    if (i + 1 >= args.Length)
+                    {
+                        Console.Error.WriteLine("missing max number of edges with -Xmaxdfaedges option; ignoring");
+                    }
+                    else
+                    {
+                        i++;
+                        DFA.MAX_STATE_TRANSITIONS_FOR_TABLE = int.Parse(args[i]);
+                    }
+                }
+                else if (args[i] == "-Xconversiontimeout")
+                {
+                    if (i + 1 >= args.Length)
{
-                        Console.Error.WriteLine( "missing max time in ms -Xconversiontimeout option; ignoring" );
+                        Console.Error.WriteLine("missing max time in ms -Xconversiontimeout option; ignoring");
}
else
{
i++;
-                        DFA.MAX_TIME_PER_DFA_CREATION = TimeSpan.FromMilliseconds( int.Parse( args[i] ) );
+                        DFA.MAX_TIME_PER_DFA_CREATION = TimeSpan.FromMilliseconds(int.Parse(args[i]));
}
}
-                else if ( args[i] == "-Xnfastates" )
+                else if (args[i] == "-Xnfastates")
{
DecisionProbe.verbose = true;
}
-                else if ( args[i] == "-X" )
+                else if (args[i] == "-X")
{
ExtendedHelp();
}
else
{
-                    if ( args[i][0] != '-' )
+                    if (args[i][0] != '-')
{
// Must be the grammar file
-                        AddGrammarFile( args[i] );
+                        AddGrammarFile(args[i]);
}
}
}
@@ -832,21 +864,23 @@ namespace Antlr3
private static void ExtendedHelp()
{
Version();
-            Console.Error.WriteLine( "  -Xgrtree               print the grammar AST" );
-            Console.Error.WriteLine( "  -Xdfa                  print DFA as text " );
-            Console.Error.WriteLine( "  -Xnoprune              test lookahead against EBNF block exit branches" );
-            Console.Error.WriteLine( "  -Xnocollapse           collapse incident edges into DFA states" );
-            Console.Error.WriteLine( "  -Xdbgconversion        dump lots of info during NFA conversion" );
-            Console.Error.WriteLine( "  -Xmultithreaded        run the analysis in 2 threads" );
-            Console.Error.WriteLine( "  -Xnomergestopstates    do not merge stop states" );
-            Console.Error.WriteLine( "  -Xdfaverbose           generate DFA states in DOT with NFA configs" );
-            Console.Error.WriteLine( "  -Xwatchconversion      print a message for each NFA before converting" );
-            Console.Error.WriteLine( "  -XdbgST                put tags at start/stop of all templates in output" );
-            Console.Error.WriteLine( "  -Xm m                  max number of rule invocations during conversion" );
-            Console.Error.WriteLine( "  -Xmaxdfaedges m        max \"comfortable\" number of edges for single DFA state" );
-            Console.Error.WriteLine( "  -Xconversiontimeout t  set NFA conversion timeout for each decision" );
-            Console.Error.WriteLine( "  -Xmaxinlinedfastates m max DFA states before table used rather than inlining" );
-            Console.Error.WriteLine( "  -Xnfastates            for nondeterminisms, list NFA states for each path" );
+            Console.Error.WriteLine("  -Xgrtree                print the grammar AST");
+            Console.Error.WriteLine("  -Xdfa                   print DFA as text ");
+            Console.Error.WriteLine("  -Xnoprune               test lookahead against EBNF block exit branches");
+            Console.Error.WriteLine("  -Xnocollapse            collapse incident edges into DFA states");
+            Console.Error.WriteLine("  -Xdbgconversion         dump lots of info during NFA conversion");
+            Console.Error.WriteLine("  -Xmultithreaded         run the analysis in 2 threads");
+            Console.Error.WriteLine("  -Xnomergestopstates     do not merge stop states");
+            Console.Error.WriteLine("  -Xdfaverbose            generate DFA states in DOT with NFA configs");
+            Console.Error.WriteLine("  -Xwatchconversion       print a message for each NFA before converting");
+            Console.Error.WriteLine("  -XdbgST                 put tags at start/stop of all templates in output");
+            Console.Error.WriteLine("  -Xnfastates             for nondeterminisms, list NFA states for each path");
+            Console.Error.WriteLine("  -Xm m                   max number of rule invocations during conversion           [" + NFAContext.MAX_SAME_RULE_INVOCATIONS_PER_NFA_CONFIG_STACK + "]");
+            Console.Error.WriteLine("  -Xmaxdfaedges m         max \"comfortable\" number of edges for single DFA state     [" + DFA.MAX_STATE_TRANSITIONS_FOR_TABLE + "]");
+            Console.Error.WriteLine("  -Xconversiontimeout t   set NFA conversion timeout for each decision               [" + DFA.MAX_TIME_PER_DFA_CREATION + "]");
+            Console.Error.WriteLine("  -Xmaxinlinedfastates m  max DFA states before table used rather than inlining      [" + CodeGenerator.DefaultMaxSwitchCaseLabels + "]");
+            Console.Error.WriteLine("  -Xmaxswitchcaselabels m don't generate switch() statements for dfas bigger than m  [" + CodeGenerator.DefaultMaxSwitchCaseLabels + "]");
+            Console.Error.WriteLine("  -Xminswitchalts m       don't generate switch() statements for dfas smaller than m [" + CodeGenerator.DefaultMinSwitchAlts + "]");
}

/// <summary>
diff --git a/Antlr3/Codegen/CodeGenerator.cs b/Antlr3/Codegen/CodeGenerator.cs
index 129e128..9ad68f8 100644
--- a/Antlr3/Codegen/CodeGenerator.cs
+++ b/Antlr3/Codegen/CodeGenerator.cs
@@ -112,12 +112,17 @@ namespace Antlr3.Codegen
*  limit will be hit only for lexers where wildcard in a UNICODE
*  vocabulary environment would generate a SWITCH with 65000 labels.
*/
-        public int MaxSwitchCaseLabels = 300;
-        public int MinSwitchAlts = 3;
-        public bool GenerateSwitchesWhenPossible = true;
-        //public static bool GenAcyclicDfaInline = true;
+
+        public static readonly int DefaultMaxSwitchCaseLabels = 300;
+        public static readonly int DefaultMinSwitchAlts = 3;
+        public static readonly int DefaultMaxAcyclicDfaStatesInline = 10;
+
+        public static int MaxSwitchCaseLabels = DefaultMaxSwitchCaseLabels;
+        public static int MinSwitchAlts = DefaultMinSwitchAlts;
+        public static int MaxAcyclicDfaStatesInline = DefaultMaxAcyclicDfaStatesInline;
public static bool EmitTemplateDelimiters = false;
-        public static int MaxAcyclicDfaStatesInline = 10;
+
+        public bool GenerateSwitchesWhenPossible = true;

/** Which grammar are we generating code for?  Each generator
*  is attached to a specific grammar.

