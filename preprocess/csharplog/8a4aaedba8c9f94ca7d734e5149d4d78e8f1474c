commit 8a4aaedba8c9f94ca7d734e5149d4d78e8f1474c
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Fri Oct 23 07:47:57 2009 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Fri Oct 23 07:47:57 2009 -0800

C# Port: Proper MSBuild integration

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 6257]

diff --git a/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj b/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj
index 2ce6f9a..ff9400e 100644
--- a/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj
+++ b/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj
@@ -60,23 +60,14 @@
<Compile Include="StringTemplateWriter.cs" />
</ItemGroup>
<ItemGroup>
-    <Antlr3 Include="Language\AngleBracketTemplateLexer.g3">
-      <OutputFiles>Language\AngleBracketTemplateLexer.cs;Language\AngleBracketTemplateLexer.tokens</OutputFiles>
-    </Antlr3>
+    <Antlr3 Include="Language\AngleBracketTemplateLexer.g3" />
<Compile Include="JavaExtensions\AntlrJavaExtensions.cs" />
<Compile Include="JavaExtensions\DictionaryExtensions.cs" />
<Compile Include="JavaExtensions\ListExtensions.cs" />
-    <Compile Include="Language\AngleBracketTemplateLexer.cs">
-      <AutoGen>True</AutoGen>
-      <DesignTime>True</DesignTime>
-      <DependentUpon>AngleBracketTemplateLexer.g3</DependentUpon>
-    </Compile>
<Compile Include="Language\AngleBracketTemplateLexerHelper.cs">
<DependentUpon>AngleBracketTemplateLexer.g3</DependentUpon>
</Compile>
-    <Antlr3 Include="Language\Template.g3">
-      <OutputFiles>Language\TemplateLexer.cs;Language\TemplateParser.cs;Language\Template.tokens</OutputFiles>
-    </Antlr3>
+    <Antlr3 Include="Language\Template.g3" />
<Compile Include="Language\ASTExpr.cs" />
<Compile Include="Language\Cat.cs" />
<Compile Include="Language\ChunkToken.cs" />
@@ -89,87 +80,34 @@
<Compile Include="Language\StringTemplateAST.cs" />
<Compile Include="Language\StringTemplateToken.cs" />
<Compile Include="Language\StringTemplateTreeAdaptor.cs" />
-    <Compile Include="Language\TemplateLexer.cs">
-      <AutoGen>True</AutoGen>
-      <DesignTime>True</DesignTime>
-      <DependentUpon>Template.g3</DependentUpon>
-    </Compile>
<Compile Include="Language\TemplateLexerHelper.cs">
<DependentUpon>Template.g3</DependentUpon>
</Compile>
-    <Compile Include="Language\TemplateParser.cs">
-      <AutoGen>True</AutoGen>
-      <DesignTime>True</DesignTime>
-      <DependentUpon>Template.g3</DependentUpon>
-    </Compile>
<Compile Include="Language\TemplateParserHelper.cs">
<DependentUpon>Template.g3</DependentUpon>
</Compile>
-    <Antlr3 Include="Language\Interface.g3">
-      <OutputFiles>Language\InterfaceLexer.cs;Language\InterfaceParser.cs;Language\Interface.tokens</OutputFiles>
-    </Antlr3>
-    <Compile Include="Language\InterfaceLexer.cs">
-      <AutoGen>True</AutoGen>
-      <DesignTime>True</DesignTime>
-      <DependentUpon>Interface.g3</DependentUpon>
-    </Compile>
+    <Antlr3 Include="Language\Interface.g3" />
<Compile Include="Language\InterfaceLexerHelper.cs">
<DependentUpon>Interface.g3</DependentUpon>
</Compile>
-    <Compile Include="Language\InterfaceParser.cs">
-      <AutoGen>True</AutoGen>
-      <DesignTime>True</DesignTime>
-      <DependentUpon>Interface.g3</DependentUpon>
-    </Compile>
<Compile Include="Language\InterfaceParserHelper.cs">
<DependentUpon>Interface.g3</DependentUpon>
</Compile>
-    <Antlr3 Include="Language\Group.g3">
-      <OutputFiles>Language\GroupLexer.cs;Language\GroupParser.cs;Language\Group.tokens</OutputFiles>
-    </Antlr3>
-    <Compile Include="Language\GroupLexer.cs">
-      <AutoGen>True</AutoGen>
-      <DesignTime>True</DesignTime>
-      <DependentUpon>Group.g3</DependentUpon>
-    </Compile>
+    <Antlr3 Include="Language\Group.g3" />
<Compile Include="Language\GroupLexerHelper.cs">
<DependentUpon>Group.g3</DependentUpon>
</Compile>
-    <Compile Include="Language\GroupParser.cs">
-      <AutoGen>True</AutoGen>
-      <DesignTime>True</DesignTime>
-      <DependentUpon>Group.g3</DependentUpon>
-    </Compile>
<Compile Include="Language\GroupParserHelper.cs">
<DependentUpon>Group.g3</DependentUpon>
</Compile>
-    <Antlr3 Include="Language\Action.g3">
-      <OutputFiles>Language\ActionLexer.cs;Language\ActionParser.cs;Language\Action.tokens</OutputFiles>
-    </Antlr3>
-    <Compile Include="Language\ActionLexer.cs">
-      <AutoGen>True</AutoGen>
-      <DesignTime>True</DesignTime>
-      <DependentUpon>Action.g3</DependentUpon>
-    </Compile>
+    <Antlr3 Include="Language\Action.g3" />
<Compile Include="Language\ActionLexerHelper.cs">
<DependentUpon>Action.g3</DependentUpon>
</Compile>
-    <Compile Include="Language\ActionParser.cs">
-      <AutoGen>True</AutoGen>
-      <DesignTime>True</DesignTime>
-      <DependentUpon>Action.g3</DependentUpon>
-    </Compile>
<Compile Include="Language\ActionParserHelper.cs">
<DependentUpon>Action.g3</DependentUpon>
</Compile>
-    <Antlr3 Include="Language\ActionEvaluator.g3">
-      <OutputFiles>Language\ActionEvaluator.cs;Language\ActionEvaluator.tokens</OutputFiles>
-    </Antlr3>
-    <Compile Include="Language\ActionEvaluator.cs">
-      <AutoGen>True</AutoGen>
-      <DesignTime>True</DesignTime>
-      <DependentUpon>ActionEvaluator.g3</DependentUpon>
-    </Compile>
+    <Antlr3 Include="Language\ActionEvaluator.g3" />
<Compile Include="Language\ActionEvaluatorHelper.cs">
<DependentUpon>ActionEvaluator.g3</DependentUpon>
</Compile>
@@ -189,27 +127,17 @@
<Link>Key.snk</Link>
</None>
</ItemGroup>
+
<PropertyGroup>
-    <UseHostCompilerIfAvailable>False</UseHostCompilerIfAvailable>
+    <!-- Folder containing AntlrBuildTask.dll -->
+    <AntlrBuildTaskPath>$(SolutionDir)bin\Bootstrap</AntlrBuildTaskPath>
+    <!-- Path to the ANTLR Tool itself. -->
+    <AntlrToolPath>$(SolutionDir)bin\Bootstrap\Antlr3.exe</AntlrToolPath>
</PropertyGroup>
+
<Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
-  <PropertyGroup>
-    <Antlr3ToolPath>$(MSBuildProjectDirectory)\..\bin\Bootstrap</Antlr3ToolPath>
-    <CoreCompileDependsOn>$(CoreCompileDependsOn);GenerateAntlrCode</CoreCompileDependsOn>
-    <CoreCleanDependsOn>$(CoreCleanDependsOn);CleanAntlrCode</CoreCleanDependsOn>
-  </PropertyGroup>
-  <Target Name="GenerateAntlrCode" Inputs="@(Antlr3)" Outputs="%(OutputFiles)">
-    <Message Importance="normal" Text="Antlr: Transforming '@(Antlr3)' to '%(Antlr3.OutputFiles)'" />
-    <!--<Exec Command="java -cp %22$(Antlr3ToolPath)\antlr3.jar;$(Antlr3ToolPath)\antlr-2.7.7.jar;$(Antlr3ToolPath)\stringtemplate-3.1b1.jar%22 org.antlr.Tool -lib %22%(RootDir)%(Directory).%22 -message-format vs2005 @(Antlr3)" Outputs="%(OutputFiles)" />-->
-    <Exec Command="%22$(Antlr3ToolPath)\Antlr3.exe%22 -Xconversiontimeout 60000 -lib %22%(RootDir)%(Directory).%22 -message-format vs2005 @(Antlr3)" Outputs="%(OutputFiles)" />
-  </Target>
-  <Target Name="CleanAntlrCode">
-    <ItemGroup>
-      <_CleanAntlrFileWrites Include="@(Antlr3->'%(RelativeDir)%(Filename).tokens')" />
-    </ItemGroup>
-    <Message Importance="normal" Text="Antlr: Deleting output files '@(_CleanAntlrFileWrites)'" />
-    <!--<Delete Files="@(_CleanAntlrFileWrites)" />-->
-  </Target>
+  <Import Project="$(SolutionDir)bin\Bootstrap\Antlr3.targets" />
+
<!-- To modify your build process, add your task inside one of the targets below and uncomment it.
Other similar extension points exist, see Microsoft.Common.targets.
<Target Name="BeforeBuild">
diff --git a/Antlr3.StringTemplate/Language/ActionEvaluator.cs b/Antlr3.StringTemplate/Language/ActionEvaluator.cs
deleted file mode 100644
index 639acce..0000000
--- a/Antlr3.StringTemplate/Language/ActionEvaluator.cs
+++ /dev/null
@@ -1,4444 +0,0 @@
-// $ANTLR 3.1.2 Language\\ActionEvaluator.g3 2009-09-30 13:27:21
-
-// The variable 'variable' is assigned but its value is never used.
-#pragma warning disable 219
-// Unreachable code detected.
-#pragma warning disable 162
-
-
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Grammar conversion to ANTLR v3 and C#:
- Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-	notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-	derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-using System.Linq;
-using Antlr.Runtime.JavaExtensions;
-
-using Map = System.Collections.IDictionary;
-using Set = System.Collections.Generic.HashSet<object>;
-using StringWriter = System.IO.StringWriter;
-using Vector = System.Collections.Generic.List<object>;
-
-
-using System.Collections.Generic;
-using Antlr.Runtime;
-using Antlr.Runtime.Tree;
-using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;using Stack = System.Collections.Generic.Stack<object>;
-using List = System.Collections.IList;
-using ArrayList = System.Collections.Generic.List<object>;
-
-namespace Antlr3.ST.Language
-{
-[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.1.2")]
-[System.CLSCompliant(false)]
-public partial class ActionEvaluator : TreeParser
-{
-	internal static readonly string[] tokenNames = new string[] {
-		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ANONYMOUS_TEMPLATE", "APPLY", "ARGS", "ASSIGN", "COLON", "COMMA", "CONDITIONAL", "DOT", "DOTDOTDOT", "ELSEIF", "ESC_CHAR", "FIRST", "FUNCTION", "ID", "INCLUDE", "INT", "LAST", "LBRACK", "LENGTH", "LIST", "LPAREN", "MULTI_APPLY", "NESTED_ANONYMOUS_TEMPLATE", "NEWLINE", "NOT", "NOTHING", "PLUS", "RBRACK", "REST", "RPAREN", "SEMI", "SINGLEVALUEARG", "STRING", "STRIP", "SUPER", "TEMPLATE", "TEMPLATE_ARGS", "TRUNC", "VALUE", "WS", "WS_CHAR"
-	};
-	public const int EOF=-1;
-	public const int ANONYMOUS_TEMPLATE=4;
-	public const int APPLY=5;
-	public const int ARGS=6;
-	public const int ASSIGN=7;
-	public const int COLON=8;
-	public const int COMMA=9;
-	public const int CONDITIONAL=10;
-	public const int DOT=11;
-	public const int DOTDOTDOT=12;
-	public const int ELSEIF=13;
-	public const int ESC_CHAR=14;
-	public const int FIRST=15;
-	public const int FUNCTION=16;
-	public const int ID=17;
-	public const int INCLUDE=18;
-	public const int INT=19;
-	public const int LAST=20;
-	public const int LBRACK=21;
-	public const int LENGTH=22;
-	public const int LIST=23;
-	public const int LPAREN=24;
-	public const int MULTI_APPLY=25;
-	public const int NESTED_ANONYMOUS_TEMPLATE=26;
-	public const int NEWLINE=27;
-	public const int NOT=28;
-	public const int NOTHING=29;
-	public const int PLUS=30;
-	public const int RBRACK=31;
-	public const int REST=32;
-	public const int RPAREN=33;
-	public const int SEMI=34;
-	public const int SINGLEVALUEARG=35;
-	public const int STRING=36;
-	public const int STRIP=37;
-	public const int SUPER=38;
-	public const int TEMPLATE=39;
-	public const int TEMPLATE_ARGS=40;
-	public const int TRUNC=41;
-	public const int VALUE=42;
-	public const int WS=43;
-	public const int WS_CHAR=44;
-
-	// delegates
-	// delegators
-
-	public ActionEvaluator( ITreeNodeStream input )
-		: this( input, new RecognizerSharedState() )
-	{
-	}
-	public ActionEvaluator( ITreeNodeStream input, RecognizerSharedState state )
-		: base( input, state )
-	{
-	}
-
-
-	public override string[] TokenNames { get { return ActionEvaluator.tokenNames; } }
-	public override string GrammarFileName { get { return "Language\\ActionEvaluator.g3"; } }
-
-
-	#region Rules
-
-	// $ANTLR start "action"
-	// Language\\ActionEvaluator.g3:87:0: public action returns [int numCharsWritten=0] : expr ;
-	public int action(  )
-	{
-		int numCharsWritten = 0;
-
-		object expr1 = default(object);
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:88:4: ( expr )
-			// Language\\ActionEvaluator.g3:88:4: expr
-			{
-			PushFollow(Follow._expr_in_action56);
-			expr1=expr();
-
-			state._fsp--;
-
-			numCharsWritten = chunk.WriteAttribute(self,expr1,writer);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return numCharsWritten;
-	}
-	// $ANTLR end "action"
-
-
-	// $ANTLR start "expr"
-	// Language\\ActionEvaluator.g3:91:0: expr returns [object value] : ( ^( PLUS a= expr b= expr ) | templateApplication | attribute | templateInclude | function | list | ^( VALUE e= expr ) );
-	private object expr(  )
-	{
-		object value = default(object);
-
-		object a = default(object);
-		object b = default(object);
-		object e = default(object);
-		object templateApplication2 = default(object);
-		object attribute3 = default(object);
-		object templateInclude4 = default(object);
-		object function5 = default(object);
-		object list6 = default(object);
-
-
-			Map argumentContext=null;
-			value = null;
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:97:4: ( ^( PLUS a= expr b= expr ) | templateApplication | attribute | templateInclude | function | list | ^( VALUE e= expr ) )
-			int alt1=7;
-			switch ( input.LA(1) )
-			{
-			case PLUS:
-				{
-				alt1=1;
-				}
-				break;
-			case APPLY:
-			case MULTI_APPLY:
-				{
-				alt1=2;
-				}
-				break;
-			case ANONYMOUS_TEMPLATE:
-			case DOT:
-			case ID:
-			case INT:
-			case STRING:
-				{
-				alt1=3;
-				}
-				break;
-			case INCLUDE:
-				{
-				alt1=4;
-				}
-				break;
-			case FUNCTION:
-				{
-				alt1=5;
-				}
-				break;
-			case LIST:
-				{
-				alt1=6;
-				}
-				break;
-			case VALUE:
-				{
-				alt1=7;
-				}
-				break;
-			default:
-				{
-					NoViableAltException nvae = new NoViableAltException("", 1, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt1 )
-			{
-			case 1:
-				// Language\\ActionEvaluator.g3:97:4: ^( PLUS a= expr b= expr )
-				{
-				Match(input,PLUS,Follow._PLUS_in_expr79);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._expr_in_expr83);
-				a=expr();
-
-				state._fsp--;
-
-				PushFollow(Follow._expr_in_expr87);
-				b=expr();
-
-				state._fsp--;
-
-				value = chunk.Add(a,b);
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 2:
-				// Language\\ActionEvaluator.g3:98:4: templateApplication
-				{
-				PushFollow(Follow._templateApplication_in_expr95);
-				templateApplication2=templateApplication();
-
-				state._fsp--;
-
-				value = templateApplication2;
-
-				}
-				break;
-			case 3:
-				// Language\\ActionEvaluator.g3:99:4: attribute
-				{
-				PushFollow(Follow._attribute_in_expr102);
-				attribute3=attribute();
-
-				state._fsp--;
-
-				value = attribute3;
-
-				}
-				break;
-			case 4:
-				// Language\\ActionEvaluator.g3:100:4: templateInclude
-				{
-				PushFollow(Follow._templateInclude_in_expr109);
-				templateInclude4=templateInclude();
-
-				state._fsp--;
-
-				value = templateInclude4;
-
-				}
-				break;
-			case 5:
-				// Language\\ActionEvaluator.g3:101:4: function
-				{
-				PushFollow(Follow._function_in_expr116);
-				function5=function();
-
-				state._fsp--;
-
-				value = function5;
-
-				}
-				break;
-			case 6:
-				// Language\\ActionEvaluator.g3:102:4: list
-				{
-				PushFollow(Follow._list_in_expr123);
-				list6=list();
-
-				state._fsp--;
-
-				value = list6;
-
-				}
-				break;
-			case 7:
-				// Language\\ActionEvaluator.g3:103:4: ^( VALUE e= expr )
-				{
-				Match(input,VALUE,Follow._VALUE_in_expr131);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._expr_in_expr135);
-				e=expr();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-							StringWriter buf = new StringWriter();
-							IStringTemplateWriter sw = self.Group.GetStringTemplateWriter(buf);
-							int n = chunk.WriteAttribute(self,e,sw);
-							if ( n > 0 )
-							{
-								value = buf.ToString();
-							}
-
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return value;
-	}
-	// $ANTLR end "expr"
-
-
-	// $ANTLR start "list"
-	// Language\\ActionEvaluator.g3:117:0: list returns [object value=null] : ^( LIST ( expr | NOTHING )+ ) ;
-	private object list(  )
-	{
-		object value = null;
-
-		object expr7 = default(object);
-
-
-			List elements = new ArrayList();
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:122:4: ( ^( LIST ( expr | NOTHING )+ ) )
-			// Language\\ActionEvaluator.g3:122:4: ^( LIST ( expr | NOTHING )+ )
-			{
-			Match(input,LIST,Follow._LIST_in_list167);
-
-			Match(input, TokenTypes.Down, null);
-			// Language\\ActionEvaluator.g3:123:4: ( expr | NOTHING )+
-			int cnt2=0;
-			for ( ; ; )
-			{
-				int alt2=3;
-				int LA2_0 = input.LA(1);
-
-				if ( ((LA2_0>=ANONYMOUS_TEMPLATE && LA2_0<=APPLY)||LA2_0==DOT||(LA2_0>=FUNCTION && LA2_0<=INT)||LA2_0==LIST||LA2_0==MULTI_APPLY||LA2_0==PLUS||LA2_0==STRING||LA2_0==VALUE) )
-				{
-					alt2=1;
-				}
-				else if ( (LA2_0==NOTHING) )
-				{
-					alt2=2;
-				}
-
-
-				switch ( alt2 )
-				{
-				case 1:
-					// Language\\ActionEvaluator.g3:123:6: expr
-					{
-					PushFollow(Follow._expr_in_list174);
-					expr7=expr();
-
-					state._fsp--;
-
-
-										if ( expr7!=null )
-										{
-											elements.Add(expr7);
-										}
-
-
-					}
-					break;
-				case 2:
-					// Language\\ActionEvaluator.g3:130:6: NOTHING
-					{
-					Match(input,NOTHING,Follow._NOTHING_in_list187);
-
-										List nullSingleton = new ArrayList( new object[] {null} );
-										elements.Add(nullSingleton.iterator()); // add a blank
-
-
-					}
-					break;
-
-				default:
-					if ( cnt2 >= 1 )
-						goto loop2;
-
-					EarlyExitException eee2 = new EarlyExitException( 2, input );
-					throw eee2;
-				}
-				cnt2++;
-			}
-			loop2:
-				;
-
-
-
-			Match(input, TokenTypes.Up, null);
-			value = new Cat(elements);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return value;
-	}
-	// $ANTLR end "list"
-
-
-	// $ANTLR start "templateInclude"
-	// Language\\ActionEvaluator.g3:140:0: templateInclude returns [object value=null] : ^( INCLUDE (id= ID a1= . | ^( VALUE n= expr a2= . ) ) ) ;
-	private object templateInclude(  )
-	{
-		object value = null;
-
-		StringTemplateAST id=null;
-		StringTemplateAST a1=null;
-		StringTemplateAST a2=null;
-		object n = default(object);
-
-
-			StringTemplateAST args = null;
-			string name = null;
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:146:4: ( ^( INCLUDE (id= ID a1= . | ^( VALUE n= expr a2= . ) ) ) )
-			// Language\\ActionEvaluator.g3:146:4: ^( INCLUDE (id= ID a1= . | ^( VALUE n= expr a2= . ) ) )
-			{
-			Match(input,INCLUDE,Follow._INCLUDE_in_templateInclude229);
-
-			Match(input, TokenTypes.Down, null);
-			// Language\\ActionEvaluator.g3:148:4: (id= ID a1= . | ^( VALUE n= expr a2= . ) )
-			int alt3=2;
-			int LA3_0 = input.LA(1);
-
-			if ( (LA3_0==ID) )
-			{
-				alt3=1;
-			}
-			else if ( (LA3_0==VALUE) )
-			{
-				alt3=2;
-			}
-			else
-			{
-				NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt3 )
-			{
-			case 1:
-				// Language\\ActionEvaluator.g3:148:6: id= ID a1= .
-				{
-				id=(StringTemplateAST)Match(input,ID,Follow._ID_in_templateInclude242);
-				a1=(StringTemplateAST)input.LT(1);
-				MatchAny(input);
-				name=(id!=null?id.Text:null); args=a1;
-
-				}
-				break;
-			case 2:
-				// Language\\ActionEvaluator.g3:151:6: ^( VALUE n= expr a2= . )
-				{
-				Match(input,VALUE,Follow._VALUE_in_templateInclude262);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._expr_in_templateInclude266);
-				n=expr();
-
-				state._fsp--;
-
-				a2=(StringTemplateAST)input.LT(1);
-				MatchAny(input);
-
-				Match(input, TokenTypes.Up, null);
-				if (n!=null) {name=n.ToString();} args=a2;
-
-				}
-				break;
-
-			}
-
-
-			Match(input, TokenTypes.Up, null);
-
-						if ( name!=null )
-						{
-							value = chunk.GetTemplateInclude(self, name, args);
-						}
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return value;
-	}
-	// $ANTLR end "templateInclude"
-
-
-	// $ANTLR start "templateApplication"
-	// Language\\ActionEvaluator.g3:167:0: templateApplication returns [object value] : ( ^( APPLY a= expr ( template[templatesToApply] )+ ) | ^( MULTI_APPLY (a= expr )+ COLON anon= ANONYMOUS_TEMPLATE ) );
-	private object templateApplication(  )
-	{
-		object value = default(object);
-
-		StringTemplateAST anon=null;
-		object a = default(object);
-
-
-			var templatesToApply = new System.Collections.Generic.List<StringTemplate>();
-			List attributes = new ArrayList();
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:173:4: ( ^( APPLY a= expr ( template[templatesToApply] )+ ) | ^( MULTI_APPLY (a= expr )+ COLON anon= ANONYMOUS_TEMPLATE ) )
-			int alt6=2;
-			int LA6_0 = input.LA(1);
-
-			if ( (LA6_0==APPLY) )
-			{
-				alt6=1;
-			}
-			else if ( (LA6_0==MULTI_APPLY) )
-			{
-				alt6=2;
-			}
-			else
-			{
-				NoViableAltException nvae = new NoViableAltException("", 6, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt6 )
-			{
-			case 1:
-				// Language\\ActionEvaluator.g3:173:4: ^( APPLY a= expr ( template[templatesToApply] )+ )
-				{
-				Match(input,APPLY,Follow._APPLY_in_templateApplication316);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._expr_in_templateApplication320);
-				a=expr();
-
-				state._fsp--;
-
-				// Language\\ActionEvaluator.g3:174:4: ( template[templatesToApply] )+
-				int cnt4=0;
-				for ( ; ; )
-				{
-					int alt4=2;
-					int LA4_0 = input.LA(1);
-
-					if ( (LA4_0==TEMPLATE) )
-					{
-						alt4=1;
-					}
-
-
-					switch ( alt4 )
-					{
-					case 1:
-						// Language\\ActionEvaluator.g3:174:5: template[templatesToApply]
-						{
-						PushFollow(Follow._template_in_templateApplication326);
-						template(templatesToApply);
-
-						state._fsp--;
-
-
-						}
-						break;
-
-					default:
-						if ( cnt4 >= 1 )
-							goto loop4;
-
-						EarlyExitException eee4 = new EarlyExitException( 4, input );
-						throw eee4;
-					}
-					cnt4++;
-				}
-				loop4:
-					;
-
-
-				value = chunk.ApplyListOfAlternatingTemplates(self,a,templatesToApply);
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 2:
-				// Language\\ActionEvaluator.g3:177:4: ^( MULTI_APPLY (a= expr )+ COLON anon= ANONYMOUS_TEMPLATE )
-				{
-				Match(input,MULTI_APPLY,Follow._MULTI_APPLY_in_templateApplication345);
-
-				Match(input, TokenTypes.Down, null);
-				// Language\\ActionEvaluator.g3:177:19: (a= expr )+
-				int cnt5=0;
-				for ( ; ; )
-				{
-					int alt5=2;
-					int LA5_0 = input.LA(1);
-
-					if ( ((LA5_0>=ANONYMOUS_TEMPLATE && LA5_0<=APPLY)||LA5_0==DOT||(LA5_0>=FUNCTION && LA5_0<=INT)||LA5_0==LIST||LA5_0==MULTI_APPLY||LA5_0==PLUS||LA5_0==STRING||LA5_0==VALUE) )
-					{
-						alt5=1;
-					}
-
-
-					switch ( alt5 )
-					{
-					case 1:
-						// Language\\ActionEvaluator.g3:177:20: a= expr
-						{
-						PushFollow(Follow._expr_in_templateApplication350);
-						a=expr();
-
-						state._fsp--;
-
-						attributes.Add(a);
-
-						}
-						break;
-
-					default:
-						if ( cnt5 >= 1 )
-							goto loop5;
-
-						EarlyExitException eee5 = new EarlyExitException( 5, input );
-						throw eee5;
-					}
-					cnt5++;
-				}
-				loop5:
-					;
-
-
-				Match(input,COLON,Follow._COLON_in_templateApplication357);
-				anon=(StringTemplateAST)Match(input,ANONYMOUS_TEMPLATE,Follow._ANONYMOUS_TEMPLATE_in_templateApplication364);
-
-								StringTemplate anonymous = anon.StringTemplate;
-								templatesToApply.Add(anonymous);
-								value = chunk.ApplyTemplateToListOfAttributes(self,
-																			  attributes,
-																			  anon.StringTemplate);
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return value;
-	}
-	// $ANTLR end "templateApplication"
-
-
-	// $ANTLR start "function"
-	// Language\\ActionEvaluator.g3:189:0: function returns [object value] : ^( FUNCTION ( 'first' a= singleFunctionArg | 'rest' a= singleFunctionArg | 'last' a= singleFunctionArg | 'length' a= singleFunctionArg | 'strip' a= singleFunctionArg | 'trunc' a= singleFunctionArg ) ) ;
-	private object function(  )
-	{
-		object value = default(object);
-
-		object a = default(object);
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:190:4: ( ^( FUNCTION ( 'first' a= singleFunctionArg | 'rest' a= singleFunctionArg | 'last' a= singleFunctionArg | 'length' a= singleFunctionArg | 'strip' a= singleFunctionArg | 'trunc' a= singleFunctionArg ) ) )
-			// Language\\ActionEvaluator.g3:190:4: ^( FUNCTION ( 'first' a= singleFunctionArg | 'rest' a= singleFunctionArg | 'last' a= singleFunctionArg | 'length' a= singleFunctionArg | 'strip' a= singleFunctionArg | 'trunc' a= singleFunctionArg ) )
-			{
-			Match(input,FUNCTION,Follow._FUNCTION_in_function390);
-
-			Match(input, TokenTypes.Down, null);
-			// Language\\ActionEvaluator.g3:191:4: ( 'first' a= singleFunctionArg | 'rest' a= singleFunctionArg | 'last' a= singleFunctionArg | 'length' a= singleFunctionArg | 'strip' a= singleFunctionArg | 'trunc' a= singleFunctionArg )
-			int alt7=6;
-			switch ( input.LA(1) )
-			{
-			case FIRST:
-				{
-				alt7=1;
-				}
-				break;
-			case REST:
-				{
-				alt7=2;
-				}
-				break;
-			case LAST:
-				{
-				alt7=3;
-				}
-				break;
-			case LENGTH:
-				{
-				alt7=4;
-				}
-				break;
-			case STRIP:
-				{
-				alt7=5;
-				}
-				break;
-			case TRUNC:
-				{
-				alt7=6;
-				}
-				break;
-			default:
-				{
-					NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt7 )
-			{
-			case 1:
-				// Language\\ActionEvaluator.g3:191:6: 'first' a= singleFunctionArg
-				{
-				Match(input,FIRST,Follow._FIRST_in_function397);
-				PushFollow(Follow._singleFunctionArg_in_function402);
-				a=singleFunctionArg();
-
-				state._fsp--;
-
-				value =chunk.First(a);
-
-				}
-				break;
-			case 2:
-				// Language\\ActionEvaluator.g3:192:6: 'rest' a= singleFunctionArg
-				{
-				Match(input,REST,Follow._REST_in_function411);
-				PushFollow(Follow._singleFunctionArg_in_function416);
-				a=singleFunctionArg();
-
-				state._fsp--;
-
-				value =chunk.Rest(a);
-
-				}
-				break;
-			case 3:
-				// Language\\ActionEvaluator.g3:193:6: 'last' a= singleFunctionArg
-				{
-				Match(input,LAST,Follow._LAST_in_function425);
-				PushFollow(Follow._singleFunctionArg_in_function430);
-				a=singleFunctionArg();
-
-				state._fsp--;
-
-				value =chunk.Last(a);
-
-				}
-				break;
-			case 4:
-				// Language\\ActionEvaluator.g3:194:6: 'length' a= singleFunctionArg
-				{
-				Match(input,LENGTH,Follow._LENGTH_in_function439);
-				PushFollow(Follow._singleFunctionArg_in_function443);
-				a=singleFunctionArg();
-
-				state._fsp--;
-
-				value =chunk.Length(a);
-
-				}
-				break;
-			case 5:
-				// Language\\ActionEvaluator.g3:195:6: 'strip' a= singleFunctionArg
-				{
-				Match(input,STRIP,Follow._STRIP_in_function452);
-				PushFollow(Follow._singleFunctionArg_in_function457);
-				a=singleFunctionArg();
-
-				state._fsp--;
-
-				value =chunk.Strip(a);
-
-				}
-				break;
-			case 6:
-				// Language\\ActionEvaluator.g3:196:6: 'trunc' a= singleFunctionArg
-				{
-				Match(input,TRUNC,Follow._TRUNC_in_function466);
-				PushFollow(Follow._singleFunctionArg_in_function471);
-				a=singleFunctionArg();
-
-				state._fsp--;
-
-				value =chunk.Trunc(a);
-
-				}
-				break;
-
-			}
-
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return value;
-	}
-	// $ANTLR end "function"
-
-
-	// $ANTLR start "singleFunctionArg"
-	// Language\\ActionEvaluator.g3:201:0: singleFunctionArg returns [object value=null] : ^( SINGLEVALUEARG expr ) ;
-	private object singleFunctionArg(  )
-	{
-		object value = null;
-
-		object expr8 = default(object);
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:202:4: ( ^( SINGLEVALUEARG expr ) )
-			// Language\\ActionEvaluator.g3:202:4: ^( SINGLEVALUEARG expr )
-			{
-			Match(input,SINGLEVALUEARG,Follow._SINGLEVALUEARG_in_singleFunctionArg499);
-
-			Match(input, TokenTypes.Down, null);
-			PushFollow(Follow._expr_in_singleFunctionArg501);
-			expr8=expr();
-
-			state._fsp--;
-
-			value = expr8;
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return value;
-	}
-	// $ANTLR end "singleFunctionArg"
-
-
-	// $ANTLR start "template"
-	// Language\\ActionEvaluator.g3:205:0: template[System.Collections.Generic.List<StringTemplate> templatesToApply] : ^( TEMPLATE ( ID args= . |anon= ANONYMOUS_TEMPLATE | ^( VALUE n= expr args2= . ) ) ) ;
-	private void template( System.Collections.Generic.List<StringTemplate> templatesToApply )
-	{
-		StringTemplateAST anon=null;
-		StringTemplateAST ID9=null;
-		StringTemplateAST args=null;
-		StringTemplateAST args2=null;
-		object n = default(object);
-
-
-			Map argumentContext = null;
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:210:4: ( ^( TEMPLATE ( ID args= . |anon= ANONYMOUS_TEMPLATE | ^( VALUE n= expr args2= . ) ) ) )
-			// Language\\ActionEvaluator.g3:210:4: ^( TEMPLATE ( ID args= . |anon= ANONYMOUS_TEMPLATE | ^( VALUE n= expr args2= . ) ) )
-			{
-			Match(input,TEMPLATE,Follow._TEMPLATE_in_template524);
-
-			Match(input, TokenTypes.Down, null);
-			// Language\\ActionEvaluator.g3:211:4: ( ID args= . |anon= ANONYMOUS_TEMPLATE | ^( VALUE n= expr args2= . ) )
-			int alt8=3;
-			switch ( input.LA(1) )
-			{
-			case ID:
-				{
-				alt8=1;
-				}
-				break;
-			case ANONYMOUS_TEMPLATE:
-				{
-				alt8=2;
-				}
-				break;
-			case VALUE:
-				{
-				alt8=3;
-				}
-				break;
-			default:
-				{
-					NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt8 )
-			{
-			case 1:
-				// Language\\ActionEvaluator.g3:211:6: ID args= .
-				{
-				ID9=(StringTemplateAST)Match(input,ID,Follow._ID_in_template531);
-				args=(StringTemplateAST)input.LT(1);
-				MatchAny(input);
-
-									string templateName = (ID9!=null?ID9.Text:null);
-									StringTemplateGroup group = self.Group;
-									StringTemplate embedded = group.GetEmbeddedInstanceOf(self, templateName);
-									if ( embedded!=null )
-									{
-										embedded.ArgumentsAST = args;
-										templatesToApply.Add(embedded);
-									}
-
-
-				}
-				break;
-			case 2:
-				// Language\\ActionEvaluator.g3:223:6: anon= ANONYMOUS_TEMPLATE
-				{
-				anon=(StringTemplateAST)Match(input,ANONYMOUS_TEMPLATE,Follow._ANONYMOUS_TEMPLATE_in_template552);
-
-									StringTemplate anonymous = anon.StringTemplate;
-									// to properly see overridden templates, always set
-									// anonymous' group to be self's group
-									anonymous.Group = self.Group;
-									templatesToApply.Add(anonymous);
-
-
-				}
-				break;
-			case 3:
-				// Language\\ActionEvaluator.g3:232:6: ^( VALUE n= expr args2= . )
-				{
-				Match(input,VALUE,Follow._VALUE_in_template568);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._expr_in_template572);
-				n=expr();
-
-				state._fsp--;
-
-				args2=(StringTemplateAST)input.LT(1);
-				MatchAny(input);
-
-										StringTemplate embedded = null;
-										if ( n!=null )
-										{
-											string templateName = n.ToString();
-											StringTemplateGroup group = self.Group;
-											embedded = group.GetEmbeddedInstanceOf(self, templateName);
-											if ( embedded!=null )
-											{
-												embedded.ArgumentsAST = args2;
-												templatesToApply.Add(embedded);
-											}
-										}
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-
-			}
-
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "template"
-
-
-	// $ANTLR start "ifCondition"
-	// Language\\ActionEvaluator.g3:253:0: public ifCondition returns [bool value] : (a= ifAtom | ^( NOT a= ifAtom ) );
-	public bool ifCondition(  )
-	{
-		bool value = default(bool);
-
-		object a = default(object);
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:254:4: (a= ifAtom | ^( NOT a= ifAtom ) )
-			int alt9=2;
-			int LA9_0 = input.LA(1);
-
-			if ( ((LA9_0>=ANONYMOUS_TEMPLATE && LA9_0<=APPLY)||LA9_0==DOT||(LA9_0>=FUNCTION && LA9_0<=INT)||LA9_0==LIST||LA9_0==MULTI_APPLY||LA9_0==PLUS||LA9_0==STRING||LA9_0==VALUE) )
-			{
-				alt9=1;
-			}
-			else if ( (LA9_0==NOT) )
-			{
-				alt9=2;
-			}
-			else
-			{
-				NoViableAltException nvae = new NoViableAltException("", 9, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt9 )
-			{
-			case 1:
-				// Language\\ActionEvaluator.g3:254:4: a= ifAtom
-				{
-				PushFollow(Follow._ifAtom_in_ifCondition617);
-				a=ifAtom();
-
-				state._fsp--;
-
-				value = chunk.TestAttributeTrue(a);
-
-				}
-				break;
-			case 2:
-				// Language\\ActionEvaluator.g3:255:4: ^( NOT a= ifAtom )
-				{
-				Match(input,NOT,Follow._NOT_in_ifCondition625);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._ifAtom_in_ifCondition629);
-				a=ifAtom();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-				value = !chunk.TestAttributeTrue(a);
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return value;
-	}
-	// $ANTLR end "ifCondition"
-
-
-	// $ANTLR start "ifAtom"
-	// Language\\ActionEvaluator.g3:258:0: ifAtom returns [object value] : expr ;
-	private object ifAtom(  )
-	{
-		object value = default(object);
-
-		object expr10 = default(object);
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:259:4: ( expr )
-			// Language\\ActionEvaluator.g3:259:4: expr
-			{
-			PushFollow(Follow._expr_in_ifAtom647);
-			expr10=expr();
-
-			state._fsp--;
-
-			value = expr10;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return value;
-	}
-	// $ANTLR end "ifAtom"
-
-
-	// $ANTLR start "attribute"
-	// Language\\ActionEvaluator.g3:262:0: attribute returns [object value] : ( ^( DOT obj= expr (prop= ID | ^( VALUE e= expr ) ) ) |i3= ID |i= INT |s= STRING |at= ANONYMOUS_TEMPLATE );
-	private object attribute(  )
-	{
-		object value = default(object);
-
-		StringTemplateAST prop=null;
-		StringTemplateAST i3=null;
-		StringTemplateAST i=null;
-		StringTemplateAST s=null;
-		StringTemplateAST at=null;
-		object obj = default(object);
-		object e = default(object);
-
-
-			object propName = null;
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:267:4: ( ^( DOT obj= expr (prop= ID | ^( VALUE e= expr ) ) ) |i3= ID |i= INT |s= STRING |at= ANONYMOUS_TEMPLATE )
-			int alt11=5;
-			switch ( input.LA(1) )
-			{
-			case DOT:
-				{
-				alt11=1;
-				}
-				break;
-			case ID:
-				{
-				alt11=2;
-				}
-				break;
-			case INT:
-				{
-				alt11=3;
-				}
-				break;
-			case STRING:
-				{
-				alt11=4;
-				}
-				break;
-			case ANONYMOUS_TEMPLATE:
-				{
-				alt11=5;
-				}
-				break;
-			default:
-				{
-					NoViableAltException nvae = new NoViableAltException("", 11, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt11 )
-			{
-			case 1:
-				// Language\\ActionEvaluator.g3:267:4: ^( DOT obj= expr (prop= ID | ^( VALUE e= expr ) ) )
-				{
-				Match(input,DOT,Follow._DOT_in_attribute671);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._expr_in_attribute675);
-				obj=expr();
-
-				state._fsp--;
-
-				// Language\\ActionEvaluator.g3:268:4: (prop= ID | ^( VALUE e= expr ) )
-				int alt10=2;
-				int LA10_0 = input.LA(1);
-
-				if ( (LA10_0==ID) )
-				{
-					alt10=1;
-				}
-				else if ( (LA10_0==VALUE) )
-				{
-					alt10=2;
-				}
-				else
-				{
-					NoViableAltException nvae = new NoViableAltException("", 10, 0, input);
-
-					throw nvae;
-				}
-				switch ( alt10 )
-				{
-				case 1:
-					// Language\\ActionEvaluator.g3:268:6: prop= ID
-					{
-					prop=(StringTemplateAST)Match(input,ID,Follow._ID_in_attribute684);
-					propName = (prop!=null?prop.Text:null);
-
-					}
-					break;
-				case 2:
-					// Language\\ActionEvaluator.g3:273:6: ^( VALUE e= expr )
-					{
-					Match(input,VALUE,Follow._VALUE_in_attribute714);
-
-					Match(input, TokenTypes.Down, null);
-					PushFollow(Follow._expr_in_attribute718);
-					e=expr();
-
-					state._fsp--;
-
-
-					Match(input, TokenTypes.Up, null);
-					if (e!=null) {propName=e;}
-
-					}
-					break;
-
-				}
-
-
-				Match(input, TokenTypes.Up, null);
-				value = chunk.GetObjectProperty(self,obj,propName);
-
-				}
-				break;
-			case 2:
-				// Language\\ActionEvaluator.g3:278:4: i3= ID
-				{
-				i3=(StringTemplateAST)Match(input,ID,Follow._ID_in_attribute742);
-
-						value =self.GetAttribute((i3!=null?i3.Text:null));
-
-
-				}
-				break;
-			case 3:
-				// Language\\ActionEvaluator.g3:283:4: i= INT
-				{
-				i=(StringTemplateAST)Match(input,INT,Follow._INT_in_attribute754);
-				value =int.Parse((i!=null?i.Text:null));
-
-				}
-				break;
-			case 4:
-				// Language\\ActionEvaluator.g3:285:4: s= STRING
-				{
-				s=(StringTemplateAST)Match(input,STRING,Follow._STRING_in_attribute764);
-
-						value =(s!=null?s.Text:null);
-
-
-				}
-				break;
-			case 5:
-				// Language\\ActionEvaluator.g3:290:4: at= ANONYMOUS_TEMPLATE
-				{
-				at=(StringTemplateAST)Match(input,ANONYMOUS_TEMPLATE,Follow._ANONYMOUS_TEMPLATE_in_attribute776);
-
-							value =(at!=null?at.Text:null);
-							if ( (at!=null?at.Text:null)!=null )
-							{
-								StringTemplate valueST =new StringTemplate(self.Group, (at!=null?at.Text:null));
-								valueST.EnclosingInstance = self;
-								valueST.Name = "<anonymous template argument>";
-								value = valueST;
-							}
-
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return value;
-	}
-	// $ANTLR end "attribute"
-
-
-	// $ANTLR start "argList"
-	// Language\\ActionEvaluator.g3:309:0: public argList[StringTemplate embedded, System.Collections.Generic.Dictionary<string, object> initialContext] returns [System.Collections.Generic.Dictionary<string, object> argumentContext=null] : ( ^( ARGS ( argumentAssignment[$embedded,$argumentContext] )* ) | singleTemplateArg[$embedded,$argumentContext] );
-	public System.Collections.Generic.Dictionary<string, object> argList( StringTemplate embedded, System.Collections.Generic.Dictionary<string, object> initialContext )
-	{
-		System.Collections.Generic.Dictionary<string, object> argumentContext = null;
-
-
-			argumentContext = initialContext;
-			if ( argumentContext==null )
-			{
-				argumentContext =new System.Collections.Generic.Dictionary<string, object>();
-			}
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:319:4: ( ^( ARGS ( argumentAssignment[$embedded,$argumentContext] )* ) | singleTemplateArg[$embedded,$argumentContext] )
-			int alt13=2;
-			int LA13_0 = input.LA(1);
-
-			if ( (LA13_0==ARGS) )
-			{
-				alt13=1;
-			}
-			else if ( (LA13_0==SINGLEVALUEARG) )
-			{
-				alt13=2;
-			}
-			else
-			{
-				NoViableAltException nvae = new NoViableAltException("", 13, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt13 )
-			{
-			case 1:
-				// Language\\ActionEvaluator.g3:319:4: ^( ARGS ( argumentAssignment[$embedded,$argumentContext] )* )
-				{
-				Match(input,ARGS,Follow._ARGS_in_argList808);
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null);
-					// Language\\ActionEvaluator.g3:319:12: ( argumentAssignment[$embedded,$argumentContext] )*
-					for ( ; ; )
-					{
-						int alt12=2;
-						int LA12_0 = input.LA(1);
-
-						if ( (LA12_0==ASSIGN||LA12_0==DOTDOTDOT) )
-						{
-							alt12=1;
-						}
-
-
-						switch ( alt12 )
-						{
-						case 1:
-							// Language\\ActionEvaluator.g3:319:13: argumentAssignment[$embedded,$argumentContext]
-							{
-							PushFollow(Follow._argumentAssignment_in_argList811);
-							argumentAssignment(embedded, argumentContext);
-
-							state._fsp--;
-
-
-							}
-							break;
-
-						default:
-							goto loop12;
-						}
-					}
-
-					loop12:
-						;
-
-
-
-					Match(input, TokenTypes.Up, null);
-				}
-
-				}
-				break;
-			case 2:
-				// Language\\ActionEvaluator.g3:320:4: singleTemplateArg[$embedded,$argumentContext]
-				{
-				PushFollow(Follow._singleTemplateArg_in_argList821);
-				singleTemplateArg(embedded, argumentContext);
-
-				state._fsp--;
-
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return argumentContext;
-	}
-	// $ANTLR end "argList"
-
-
-	// $ANTLR start "singleTemplateArg"
-	// Language\\ActionEvaluator.g3:323:0: singleTemplateArg[StringTemplate embedded, Map argumentContext] : ^( SINGLEVALUEARG e= expr ) ;
-	private void singleTemplateArg( StringTemplate embedded, Map argumentContext )
-	{
-		object e = default(object);
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:324:4: ( ^( SINGLEVALUEARG e= expr ) )
-			// Language\\ActionEvaluator.g3:324:4: ^( SINGLEVALUEARG e= expr )
-			{
-			Match(input,SINGLEVALUEARG,Follow._SINGLEVALUEARG_in_singleTemplateArg836);
-
-			Match(input, TokenTypes.Down, null);
-			PushFollow(Follow._expr_in_singleTemplateArg840);
-			e=expr();
-
-			state._fsp--;
-
-
-			Match(input, TokenTypes.Up, null);
-
-						if ( e!=null )
-						{
-							string soleArgName = null;
-							// find the sole defined formal argument for embedded
-							bool error = false;
-							var formalArgs = embedded.FormalArguments;
-							if ( formalArgs!=null )
-							{
-								var argNames = formalArgs.Select( fa => fa.name ).ToArray();
-								if ( argNames.Length==1 )
-								{
-									soleArgName = (string)argNames.ToArray()[0];
-									//System.out.println("sole formal arg of "+embedded.Name+" is "+soleArgName);
-								}
-								else
-								{
-									error=true;
-								}
-							}
-							else
-							{
-								error=true;
-							}
-							if ( error )
-							{
-								self.Error("template "+embedded.Name+
-										   " must have exactly one formal arg in template context "+
-										   self.GetEnclosingInstanceStackString());
-							}
-							else
-							{
-								self.RawSetArgumentAttribute(embedded,argumentContext,soleArgName,e);
-							}
-						}
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "singleTemplateArg"
-
-
-	// $ANTLR start "argumentAssignment"
-	// Language\\ActionEvaluator.g3:363:0: argumentAssignment[StringTemplate embedded, Map argumentContext] : ( ^( ASSIGN arg= ID expr ) | DOTDOTDOT );
-	private void argumentAssignment( StringTemplate embedded, Map argumentContext )
-	{
-		StringTemplateAST arg=null;
-		object expr11 = default(object);
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:364:4: ( ^( ASSIGN arg= ID expr ) | DOTDOTDOT )
-			int alt14=2;
-			int LA14_0 = input.LA(1);
-
-			if ( (LA14_0==ASSIGN) )
-			{
-				alt14=1;
-			}
-			else if ( (LA14_0==DOTDOTDOT) )
-			{
-				alt14=2;
-			}
-			else
-			{
-				NoViableAltException nvae = new NoViableAltException("", 14, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt14 )
-			{
-			case 1:
-				// Language\\ActionEvaluator.g3:364:4: ^( ASSIGN arg= ID expr )
-				{
-				Match(input,ASSIGN,Follow._ASSIGN_in_argumentAssignment860);
-
-				Match(input, TokenTypes.Down, null);
-				arg=(StringTemplateAST)Match(input,ID,Follow._ID_in_argumentAssignment864);
-				PushFollow(Follow._expr_in_argumentAssignment866);
-				expr11=expr();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-							if ( expr11 != null )
-							{
-								self.RawSetArgumentAttribute(embedded,argumentContext,(arg!=null?arg.Text:null),expr11);
-							}
-
-
-				}
-				break;
-			case 2:
-				// Language\\ActionEvaluator.g3:371:4: DOTDOTDOT
-				{
-				Match(input,DOTDOTDOT,Follow._DOTDOTDOT_in_argumentAssignment877);
-				embedded.SetPassThroughAttributes(true);
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "argumentAssignment"
-
-
-	// $ANTLR start "actionCompiled"
-	// Language\\ActionEvaluator.g3:375:0: public actionCompiled[System.Reflection.Emit.ILGenerator gen] : exprCompiled[$gen] ;
-	public void actionCompiled( System.Reflection.Emit.ILGenerator gen )
-	{
-		try
-		{
-			// Language\\ActionEvaluator.g3:376:4: ( exprCompiled[$gen] )
-			// Language\\ActionEvaluator.g3:376:4: exprCompiled[$gen]
-			{
-			PushFollow(Follow._exprCompiled_in_actionCompiled893);
-			exprCompiled(gen);
-
-			state._fsp--;
-
-
-			#if COMPILE_EXPRESSIONS
-						EmitWriteAttribute(gen);
-			#endif
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "actionCompiled"
-
-
-	// $ANTLR start "actionFunctional"
-	// Language\\ActionEvaluator.g3:385:0: public actionFunctional returns [System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,int> func] : exprFunctional ;
-	public System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,int> actionFunctional(  )
-	{
-		System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,int> func = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,int>);
-
-		System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> exprFunctional12 = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:386:4: ( exprFunctional )
-			// Language\\ActionEvaluator.g3:386:4: exprFunctional
-			{
-			PushFollow(Follow._exprFunctional_in_actionFunctional915);
-			exprFunctional12=exprFunctional();
-
-			state._fsp--;
-
-
-			#if COMPILE_EXPRESSIONS
-						func = (chunk,self,writer) => chunk.WriteAttribute(self,exprFunctional12(chunk,self,writer),writer);
-			#endif
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return func;
-	}
-	// $ANTLR end "actionFunctional"
-
-
-	// $ANTLR start "ifConditionCompiled"
-	// Language\\ActionEvaluator.g3:395:0: public ifConditionCompiled[System.Reflection.Emit.ILGenerator gen] : ( ifAtomCompiled[$gen] | ^( NOT ifAtomCompiled[$gen] ) );
-	public void ifConditionCompiled( System.Reflection.Emit.ILGenerator gen )
-	{
-		try
-		{
-			// Language\\ActionEvaluator.g3:396:4: ( ifAtomCompiled[$gen] | ^( NOT ifAtomCompiled[$gen] ) )
-			int alt15=2;
-			int LA15_0 = input.LA(1);
-
-			if ( ((LA15_0>=ANONYMOUS_TEMPLATE && LA15_0<=APPLY)||LA15_0==DOT||(LA15_0>=FUNCTION && LA15_0<=INT)||LA15_0==LIST||LA15_0==MULTI_APPLY||LA15_0==PLUS||LA15_0==STRING||LA15_0==VALUE) )
-			{
-				alt15=1;
-			}
-			else if ( (LA15_0==NOT) )
-			{
-				alt15=2;
-			}
-			else
-			{
-				NoViableAltException nvae = new NoViableAltException("", 15, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt15 )
-			{
-			case 1:
-				// Language\\ActionEvaluator.g3:396:4: ifAtomCompiled[$gen]
-				{
-				PushFollow(Follow._ifAtomCompiled_in_ifConditionCompiled933);
-				ifAtomCompiled(gen);
-
-				state._fsp--;
-
-
-				}
-				break;
-			case 2:
-				// Language\\ActionEvaluator.g3:397:4: ^( NOT ifAtomCompiled[$gen] )
-				{
-				Match(input,NOT,Follow._NOT_in_ifConditionCompiled940);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._ifAtomCompiled_in_ifConditionCompiled942);
-				ifAtomCompiled(gen);
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				#if COMPILE_EXPRESSIONS
-							EmitNot(gen);
-				#endif
-
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "ifConditionCompiled"
-
-
-	// $ANTLR start "ifConditionFunctional"
-	// Language\\ActionEvaluator.g3:406:0: public ifConditionFunctional returns [System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,bool> func] : ( ifAtomFunctional | ^( NOT ifAtomFunctional ) );
-	public System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,bool> ifConditionFunctional(  )
-	{
-		System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,bool> func = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,bool>);
-
-		System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,bool> ifAtomFunctional13 = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,bool>);
-		System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,bool> ifAtomFunctional14 = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,bool>);
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:407:4: ( ifAtomFunctional | ^( NOT ifAtomFunctional ) )
-			int alt16=2;
-			int LA16_0 = input.LA(1);
-
-			if ( ((LA16_0>=ANONYMOUS_TEMPLATE && LA16_0<=APPLY)||LA16_0==DOT||(LA16_0>=FUNCTION && LA16_0<=INT)||LA16_0==LIST||LA16_0==MULTI_APPLY||LA16_0==PLUS||LA16_0==STRING||LA16_0==VALUE) )
-			{
-				alt16=1;
-			}
-			else if ( (LA16_0==NOT) )
-			{
-				alt16=2;
-			}
-			else
-			{
-				NoViableAltException nvae = new NoViableAltException("", 16, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt16 )
-			{
-			case 1:
-				// Language\\ActionEvaluator.g3:407:4: ifAtomFunctional
-				{
-				PushFollow(Follow._ifAtomFunctional_in_ifConditionFunctional965);
-				ifAtomFunctional13=ifAtomFunctional();
-
-				state._fsp--;
-
-
-				#if COMPILE_EXPRESSIONS
-							func = ifAtomFunctional13;
-				#endif
-
-
-				}
-				break;
-			case 2:
-				// Language\\ActionEvaluator.g3:413:4: ^( NOT ifAtomFunctional )
-				{
-				Match(input,NOT,Follow._NOT_in_ifConditionFunctional975);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._ifAtomFunctional_in_ifConditionFunctional977);
-				ifAtomFunctional14=ifAtomFunctional();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				#if COMPILE_EXPRESSIONS
-							func = (chunk,self,writer) => !(ifAtomFunctional14(chunk,self,writer));
-				#endif
-
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return func;
-	}
-	// $ANTLR end "ifConditionFunctional"
-
-
-	// $ANTLR start "ifAtomCompiled"
-	// Language\\ActionEvaluator.g3:421:0: ifAtomCompiled[System.Reflection.Emit.ILGenerator gen] : exprCompiled[$gen] ;
-	private void ifAtomCompiled( System.Reflection.Emit.ILGenerator gen )
-	{
-		try
-		{
-			// Language\\ActionEvaluator.g3:422:4: ( exprCompiled[$gen] )
-			// Language\\ActionEvaluator.g3:422:4: exprCompiled[$gen]
-			{
-			PushFollow(Follow._exprCompiled_in_ifAtomCompiled994);
-			exprCompiled(gen);
-
-			state._fsp--;
-
-
-			#if COMPILE_EXPRESSIONS
-						EmitTest(gen);
-			#endif
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "ifAtomCompiled"
-
-
-	// $ANTLR start "ifAtomFunctional"
-	// Language\\ActionEvaluator.g3:430:0: ifAtomFunctional returns [System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,bool> func] : exprFunctional ;
-	private System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,bool> ifAtomFunctional(  )
-	{
-		System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,bool> func = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,bool>);
-
-		System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> exprFunctional15 = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:431:4: ( exprFunctional )
-			// Language\\ActionEvaluator.g3:431:4: exprFunctional
-			{
-			PushFollow(Follow._exprFunctional_in_ifAtomFunctional1014);
-			exprFunctional15=exprFunctional();
-
-			state._fsp--;
-
-
-			#if COMPILE_EXPRESSIONS
-						func = (chunk,self,writer) => chunk.TestAttributeTrue(exprFunctional15(chunk,self,writer));
-			#endif
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return func;
-	}
-	// $ANTLR end "ifAtomFunctional"
-
-
-	// $ANTLR start "exprCompiled"
-	// Language\\ActionEvaluator.g3:439:0: exprCompiled[System.Reflection.Emit.ILGenerator gen] : ( ^( PLUS exprCompiled[$gen] exprCompiled[$gen] ) | templateApplicationCompiled[$gen] | attributeCompiled[$gen] | templateIncludeCompiled[$gen] | functionCompiled[$gen] | listCompiled[$gen] | ^( VALUE exprCompiled[$gen] ) );
-	private void exprCompiled( System.Reflection.Emit.ILGenerator gen )
-	{
-		try
-		{
-			// Language\\ActionEvaluator.g3:440:4: ( ^( PLUS exprCompiled[$gen] exprCompiled[$gen] ) | templateApplicationCompiled[$gen] | attributeCompiled[$gen] | templateIncludeCompiled[$gen] | functionCompiled[$gen] | listCompiled[$gen] | ^( VALUE exprCompiled[$gen] ) )
-			int alt17=7;
-			switch ( input.LA(1) )
-			{
-			case PLUS:
-				{
-				alt17=1;
-				}
-				break;
-			case APPLY:
-			case MULTI_APPLY:
-				{
-				alt17=2;
-				}
-				break;
-			case ANONYMOUS_TEMPLATE:
-			case DOT:
-			case ID:
-			case INT:
-			case STRING:
-				{
-				alt17=3;
-				}
-				break;
-			case INCLUDE:
-				{
-				alt17=4;
-				}
-				break;
-			case FUNCTION:
-				{
-				alt17=5;
-				}
-				break;
-			case LIST:
-				{
-				alt17=6;
-				}
-				break;
-			case VALUE:
-				{
-				alt17=7;
-				}
-				break;
-			default:
-				{
-					NoViableAltException nvae = new NoViableAltException("", 17, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt17 )
-			{
-			case 1:
-				// Language\\ActionEvaluator.g3:440:4: ^( PLUS exprCompiled[$gen] exprCompiled[$gen] )
-				{
-				Match(input,PLUS,Follow._PLUS_in_exprCompiled1031);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._exprCompiled_in_exprCompiled1033);
-				exprCompiled(gen);
-
-				state._fsp--;
-
-				PushFollow(Follow._exprCompiled_in_exprCompiled1036);
-				exprCompiled(gen);
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				#if COMPILE_EXPRESSIONS
-							EmitAdd(gen);
-				#endif
-
-
-				}
-				break;
-			case 2:
-				// Language\\ActionEvaluator.g3:446:4: templateApplicationCompiled[$gen]
-				{
-				PushFollow(Follow._templateApplicationCompiled_in_exprCompiled1047);
-				templateApplicationCompiled(gen);
-
-				state._fsp--;
-
-
-				}
-				break;
-			case 3:
-				// Language\\ActionEvaluator.g3:447:4: attributeCompiled[$gen]
-				{
-				PushFollow(Follow._attributeCompiled_in_exprCompiled1053);
-				attributeCompiled(gen);
-
-				state._fsp--;
-
-
-				}
-				break;
-			case 4:
-				// Language\\ActionEvaluator.g3:448:4: templateIncludeCompiled[$gen]
-				{
-				PushFollow(Follow._templateIncludeCompiled_in_exprCompiled1059);
-				templateIncludeCompiled(gen);
-
-				state._fsp--;
-
-
-				}
-				break;
-			case 5:
-				// Language\\ActionEvaluator.g3:449:4: functionCompiled[$gen]
-				{
-				PushFollow(Follow._functionCompiled_in_exprCompiled1065);
-				functionCompiled(gen);
-
-				state._fsp--;
-
-
-				}
-				break;
-			case 6:
-				// Language\\ActionEvaluator.g3:450:4: listCompiled[$gen]
-				{
-				PushFollow(Follow._listCompiled_in_exprCompiled1071);
-				listCompiled(gen);
-
-				state._fsp--;
-
-
-				}
-				break;
-			case 7:
-				// Language\\ActionEvaluator.g3:451:4: ^( VALUE exprCompiled[$gen] )
-				{
-				Match(input,VALUE,Follow._VALUE_in_exprCompiled1078);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._exprCompiled_in_exprCompiled1080);
-				exprCompiled(gen);
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				#if COMPILE_EXPRESSIONS
-							EmitWriteToString(gen);
-				#endif
-
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "exprCompiled"
-
-
-	// $ANTLR start "exprFunctional"
-	// Language\\ActionEvaluator.g3:459:0: exprFunctional returns [System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> func] : ( ^( PLUS a= exprFunctional b= exprFunctional ) | templateApplicationFunctional | attributeFunctional | templateIncludeFunctional | functionFunctional | listFunctional | ^( VALUE a= exprFunctional ) );
-	private System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> exprFunctional(  )
-	{
-		System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> func = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
-
-		System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> a = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
-		System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> b = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
-		System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> templateApplicationFunctional16 = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
-		System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> attributeFunctional17 = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
-		System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> templateIncludeFunctional18 = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
-		System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> functionFunctional19 = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
-		System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> listFunctional20 = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:460:4: ( ^( PLUS a= exprFunctional b= exprFunctional ) | templateApplicationFunctional | attributeFunctional | templateIncludeFunctional | functionFunctional | listFunctional | ^( VALUE a= exprFunctional ) )
-			int alt18=7;
-			switch ( input.LA(1) )
-			{
-			case PLUS:
-				{
-				alt18=1;
-				}
-				break;
-			case APPLY:
-			case MULTI_APPLY:
-				{
-				alt18=2;
-				}
-				break;
-			case ANONYMOUS_TEMPLATE:
-			case DOT:
-			case ID:
-			case INT:
-			case STRING:
-				{
-				alt18=3;
-				}
-				break;
-			case INCLUDE:
-				{
-				alt18=4;
-				}
-				break;
-			case FUNCTION:
-				{
-				alt18=5;
-				}
-				break;
-			case LIST:
-				{
-				alt18=6;
-				}
-				break;
-			case VALUE:
-				{
-				alt18=7;
-				}
-				break;
-			default:
-				{
-					NoViableAltException nvae = new NoViableAltException("", 18, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt18 )
-			{
-			case 1:
-				// Language\\ActionEvaluator.g3:460:4: ^( PLUS a= exprFunctional b= exprFunctional )
-				{
-				Match(input,PLUS,Follow._PLUS_in_exprFunctional1102);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._exprFunctional_in_exprFunctional1106);
-				a=exprFunctional();
-
-				state._fsp--;
-
-				PushFollow(Follow._exprFunctional_in_exprFunctional1110);
-				b=exprFunctional();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				#if COMPILE_EXPRESSIONS
-							func = (chunk,self,writer) => chunk.Add(a(chunk,self,writer),b(chunk,self,writer));
-				#endif
-
-
-				}
-				break;
-			case 2:
-				// Language\\ActionEvaluator.g3:466:4: templateApplicationFunctional
-				{
-				PushFollow(Follow._templateApplicationFunctional_in_exprFunctional1120);
-				templateApplicationFunctional16=templateApplicationFunctional();
-
-				state._fsp--;
-
-
-				#if COMPILE_EXPRESSIONS
-							func = templateApplicationFunctional16;
-				#endif
-
-
-				}
-				break;
-			case 3:
-				// Language\\ActionEvaluator.g3:472:4: attributeFunctional
-				{
-				PushFollow(Follow._attributeFunctional_in_exprFunctional1129);
-				attributeFunctional17=attributeFunctional();
-
-				state._fsp--;
-
-
-				#if COMPILE_EXPRESSIONS
-							func = attributeFunctional17;
-				#endif
-
-
-				}
-				break;
-			case 4:
-				// Language\\ActionEvaluator.g3:478:4: templateIncludeFunctional
-				{
-				PushFollow(Follow._templateIncludeFunctional_in_exprFunctional1138);
-				templateIncludeFunctional18=templateIncludeFunctional();
-
-				state._fsp--;
-
-
-				#if COMPILE_EXPRESSIONS
-							func = templateIncludeFunctional18;
-				#endif
-
-
-				}
-				break;
-			case 5:
-				// Language\\ActionEvaluator.g3:484:4: functionFunctional
-				{
-				PushFollow(Follow._functionFunctional_in_exprFunctional1147);
-				functionFunctional19=functionFunctional();
-
-				state._fsp--;
-
-
-				#if COMPILE_EXPRESSIONS
-							func = functionFunctional19;
-				#endif
-
-
-				}
-				break;
-			case 6:
-				// Language\\ActionEvaluator.g3:490:4: listFunctional
-				{
-				PushFollow(Follow._listFunctional_in_exprFunctional1156);
-				listFunctional20=listFunctional();
-
-				state._fsp--;
-
-
-				#if COMPILE_EXPRESSIONS
-							func = listFunctional20;
-				#endif
-
-
-				}
-				break;
-			case 7:
-				// Language\\ActionEvaluator.g3:496:4: ^( VALUE a= exprFunctional )
-				{
-				Match(input,VALUE,Follow._VALUE_in_exprFunctional1166);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._exprFunctional_in_exprFunctional1170);
-				a=exprFunctional();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				#if COMPILE_EXPRESSIONS
-							func = (chunk,self,writer) =>
-								{
-									var value = a(chunk,self,writer);
-									StringWriter buf = new StringWriter();
-									IStringTemplateWriter sw = self.Group.GetStringTemplateWriter( buf );
-									int n = chunk.WriteAttribute( self, value, sw );
-									if ( n > 0 )
-										return buf.ToString();
-									return value;
-								};
-				#endif
-
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return func;
-	}
-	// $ANTLR end "exprFunctional"
-
-
-	// $ANTLR start "templateApplicationCompiled"
-	// Language\\ActionEvaluator.g3:513:0: templateApplicationCompiled[System.Reflection.Emit.ILGenerator gen] : ( ^( APPLY a= exprCompiled[$gen] ( templateCompiled[$gen] )+ ) | ^( MULTI_APPLY ( exprCompiled[$gen] )+ COLON ANONYMOUS_TEMPLATE ) );
-	private void templateApplicationCompiled( System.Reflection.Emit.ILGenerator gen )
-	{
-		StringTemplateAST ANONYMOUS_TEMPLATE21=null;
-
-
-		#if COMPILE_EXPRESSIONS
-			System.Reflection.Emit.LocalBuilder templates = null;
-			System.Reflection.Emit.LocalBuilder attributes = null;
-		#endif
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:521:4: ( ^( APPLY a= exprCompiled[$gen] ( templateCompiled[$gen] )+ ) | ^( MULTI_APPLY ( exprCompiled[$gen] )+ COLON ANONYMOUS_TEMPLATE ) )
-			int alt21=2;
-			int LA21_0 = input.LA(1);
-
-			if ( (LA21_0==APPLY) )
-			{
-				alt21=1;
-			}
-			else if ( (LA21_0==MULTI_APPLY) )
-			{
-				alt21=2;
-			}
-			else
-			{
-				NoViableAltException nvae = new NoViableAltException("", 21, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt21 )
-			{
-			case 1:
-				// Language\\ActionEvaluator.g3:521:4: ^( APPLY a= exprCompiled[$gen] ( templateCompiled[$gen] )+ )
-				{
-				Match(input,APPLY,Follow._APPLY_in_templateApplicationCompiled1194);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._exprCompiled_in_templateApplicationCompiled1198);
-				exprCompiled(gen);
-
-				state._fsp--;
-
-
-				#if COMPILE_EXPRESSIONS
-								templates = EmitCreateList<StringTemplate>(gen);
-				#endif
-
-				// Language\\ActionEvaluator.g3:527:4: ( templateCompiled[$gen] )+
-				int cnt19=0;
-				for ( ; ; )
-				{
-					int alt19=2;
-					int LA19_0 = input.LA(1);
-
-					if ( (LA19_0==TEMPLATE) )
-					{
-						alt19=1;
-					}
-
-
-					switch ( alt19 )
-					{
-					case 1:
-						// Language\\ActionEvaluator.g3:527:6: templateCompiled[$gen]
-						{
-						PushFollow(Follow._templateCompiled_in_templateApplicationCompiled1211);
-						templateCompiled(gen);
-
-						state._fsp--;
-
-
-						#if COMPILE_EXPRESSIONS
-											EmitAddValueToList(gen, templates);
-						#endif
-
-
-						}
-						break;
-
-					default:
-						if ( cnt19 >= 1 )
-							goto loop19;
-
-						EarlyExitException eee19 = new EarlyExitException( 19, input );
-						throw eee19;
-					}
-					cnt19++;
-				}
-				loop19:
-					;
-
-
-
-				#if COMPILE_EXPRESSIONS
-								EmitApplyAlternatingTemplates( gen, templates );
-				#endif
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 2:
-				// Language\\ActionEvaluator.g3:540:4: ^( MULTI_APPLY ( exprCompiled[$gen] )+ COLON ANONYMOUS_TEMPLATE )
-				{
-				Match(input,MULTI_APPLY,Follow._MULTI_APPLY_in_templateApplicationCompiled1240);
-
-
-				#if COMPILE_EXPRESSIONS
-								attributes = EmitCreateList<object>(gen);
-				#endif
-
-
-				Match(input, TokenTypes.Down, null);
-				// Language\\ActionEvaluator.g3:546:4: ( exprCompiled[$gen] )+
-				int cnt20=0;
-				for ( ; ; )
-				{
-					int alt20=2;
-					int LA20_0 = input.LA(1);
-
-					if ( ((LA20_0>=ANONYMOUS_TEMPLATE && LA20_0<=APPLY)||LA20_0==DOT||(LA20_0>=FUNCTION && LA20_0<=INT)||LA20_0==LIST||LA20_0==MULTI_APPLY||LA20_0==PLUS||LA20_0==STRING||LA20_0==VALUE) )
-					{
-						alt20=1;
-					}
-
-
-					switch ( alt20 )
-					{
-					case 1:
-						// Language\\ActionEvaluator.g3:546:6: exprCompiled[$gen]
-						{
-						PushFollow(Follow._exprCompiled_in_templateApplicationCompiled1252);
-						exprCompiled(gen);
-
-						state._fsp--;
-
-
-						#if COMPILE_EXPRESSIONS
-											EmitAddValueToList(gen, attributes);
-						#endif
-
-
-						}
-						break;
-
-					default:
-						if ( cnt20 >= 1 )
-							goto loop20;
-
-						EarlyExitException eee20 = new EarlyExitException( 20, input );
-						throw eee20;
-					}
-					cnt20++;
-				}
-				loop20:
-					;
-
-
-				Match(input,COLON,Follow._COLON_in_templateApplicationCompiled1270);
-				ANONYMOUS_TEMPLATE21=(StringTemplateAST)Match(input,ANONYMOUS_TEMPLATE,Follow._ANONYMOUS_TEMPLATE_in_templateApplicationCompiled1275);
-
-				#if COMPILE_EXPRESSIONS
-								EmitApplyAnonymousTemplate( gen, ANONYMOUS_TEMPLATE21.StringTemplate, attributes );
-				#endif
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "templateApplicationCompiled"
-
-
-	// $ANTLR start "templateApplicationFunctional"
-	// Language\\ActionEvaluator.g3:563:0: templateApplicationFunctional returns [System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> func] : ( ^( APPLY a= exprFunctional ( templateFunctional[templateApplicators] )+ ) | ^( MULTI_APPLY (a= exprFunctional )+ COLON ANONYMOUS_TEMPLATE ) );
-	private System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> templateApplicationFunctional(  )
-	{
-		System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> func = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
-
-		StringTemplateAST ANONYMOUS_TEMPLATE22=null;
-		System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> a = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
-
-
-			var  templateApplicators = new List<System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,StringTemplate>>();
-		#if COMPILE_EXPRESSIONS
-			List<System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>> attributes = new List<System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>>();
-		#endif
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:571:4: ( ^( APPLY a= exprFunctional ( templateFunctional[templateApplicators] )+ ) | ^( MULTI_APPLY (a= exprFunctional )+ COLON ANONYMOUS_TEMPLATE ) )
-			int alt24=2;
-			int LA24_0 = input.LA(1);
-
-			if ( (LA24_0==APPLY) )
-			{
-				alt24=1;
-			}
-			else if ( (LA24_0==MULTI_APPLY) )
-			{
-				alt24=2;
-			}
-			else
-			{
-				NoViableAltException nvae = new NoViableAltException("", 24, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt24 )
-			{
-			case 1:
-				// Language\\ActionEvaluator.g3:571:4: ^( APPLY a= exprFunctional ( templateFunctional[templateApplicators] )+ )
-				{
-				Match(input,APPLY,Follow._APPLY_in_templateApplicationFunctional1306);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._exprFunctional_in_templateApplicationFunctional1310);
-				a=exprFunctional();
-
-				state._fsp--;
-
-				// Language\\ActionEvaluator.g3:572:4: ( templateFunctional[templateApplicators] )+
-				int cnt22=0;
-				for ( ; ; )
-				{
-					int alt22=2;
-					int LA22_0 = input.LA(1);
-
-					if ( (LA22_0==TEMPLATE) )
-					{
-						alt22=1;
-					}
-
-
-					switch ( alt22 )
-					{
-					case 1:
-						// Language\\ActionEvaluator.g3:572:5: templateFunctional[templateApplicators]
-						{
-						PushFollow(Follow._templateFunctional_in_templateApplicationFunctional1316);
-						templateFunctional(templateApplicators);
-
-						state._fsp--;
-
-
-						}
-						break;
-
-					default:
-						if ( cnt22 >= 1 )
-							goto loop22;
-
-						EarlyExitException eee22 = new EarlyExitException( 22, input );
-						throw eee22;
-					}
-					cnt22++;
-				}
-				loop22:
-					;
-
-
-
-				#if COMPILE_EXPRESSIONS
-								func = (chunk,self,writer) =>
-									{
-										var templatesToApply =	( from applicator in templateApplicators
-																  let st = applicator(chunk,self,writer)
-																  where st != null
-																  select st )
-																.ToList();
-										return chunk.ApplyListOfAlternatingTemplates( self, a(chunk,self,writer), templatesToApply );
-									};
-				#endif
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 2:
-				// Language\\ActionEvaluator.g3:587:4: ^( MULTI_APPLY (a= exprFunctional )+ COLON ANONYMOUS_TEMPLATE )
-				{
-				Match(input,MULTI_APPLY,Follow._MULTI_APPLY_in_templateApplicationFunctional1335);
-
-				Match(input, TokenTypes.Down, null);
-				// Language\\ActionEvaluator.g3:588:4: (a= exprFunctional )+
-				int cnt23=0;
-				for ( ; ; )
-				{
-					int alt23=2;
-					int LA23_0 = input.LA(1);
-
-					if ( ((LA23_0>=ANONYMOUS_TEMPLATE && LA23_0<=APPLY)||LA23_0==DOT||(LA23_0>=FUNCTION && LA23_0<=INT)||LA23_0==LIST||LA23_0==MULTI_APPLY||LA23_0==PLUS||LA23_0==STRING||LA23_0==VALUE) )
-					{
-						alt23=1;
-					}
-
-
-					switch ( alt23 )
-					{
-					case 1:
-						// Language\\ActionEvaluator.g3:588:6: a= exprFunctional
-						{
-						PushFollow(Follow._exprFunctional_in_templateApplicationFunctional1344);
-						a=exprFunctional();
-
-						state._fsp--;
-
-
-						#if COMPILE_EXPRESSIONS
-											attributes.Add(a);
-						#endif
-
-
-						}
-						break;
-
-					default:
-						if ( cnt23 >= 1 )
-							goto loop23;
-
-						EarlyExitException eee23 = new EarlyExitException( 23, input );
-						throw eee23;
-					}
-					cnt23++;
-				}
-				loop23:
-					;
-
-
-				Match(input,COLON,Follow._COLON_in_templateApplicationFunctional1361);
-				ANONYMOUS_TEMPLATE22=(StringTemplateAST)Match(input,ANONYMOUS_TEMPLATE,Follow._ANONYMOUS_TEMPLATE_in_templateApplicationFunctional1363);
-
-				#if COMPILE_EXPRESSIONS
-								StringTemplate anonymous = ANONYMOUS_TEMPLATE22.StringTemplate;
-								func = (chunk,self,writer) =>
-									{
-										var attr =	from f in attributes
-													select f(chunk,self,writer);
-										return chunk.ApplyTemplateToListOfAttributes( self, attr.ToList(), anonymous );
-									};
-				#endif
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return func;
-	}
-	// $ANTLR end "templateApplicationFunctional"
-
-
-	// $ANTLR start "attributeCompiled"
-	// Language\\ActionEvaluator.g3:610:0: attributeCompiled[System.Reflection.Emit.ILGenerator gen] : ( ^( DOT exprCompiled[$gen] (id= ID | ^( VALUE exprCompiled[$gen] ) ) ) |id= ID | INT | STRING | ANONYMOUS_TEMPLATE );
-	private void attributeCompiled( System.Reflection.Emit.ILGenerator gen )
-	{
-		StringTemplateAST id=null;
-		StringTemplateAST INT23=null;
-		StringTemplateAST STRING24=null;
-		StringTemplateAST ANONYMOUS_TEMPLATE25=null;
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:611:4: ( ^( DOT exprCompiled[$gen] (id= ID | ^( VALUE exprCompiled[$gen] ) ) ) |id= ID | INT | STRING | ANONYMOUS_TEMPLATE )
-			int alt26=5;
-			switch ( input.LA(1) )
-			{
-			case DOT:
-				{
-				alt26=1;
-				}
-				break;
-			case ID:
-				{
-				alt26=2;
-				}
-				break;
-			case INT:
-				{
-				alt26=3;
-				}
-				break;
-			case STRING:
-				{
-				alt26=4;
-				}
-				break;
-			case ANONYMOUS_TEMPLATE:
-				{
-				alt26=5;
-				}
-				break;
-			default:
-				{
-					NoViableAltException nvae = new NoViableAltException("", 26, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt26 )
-			{
-			case 1:
-				// Language\\ActionEvaluator.g3:611:4: ^( DOT exprCompiled[$gen] (id= ID | ^( VALUE exprCompiled[$gen] ) ) )
-				{
-				Match(input,DOT,Follow._DOT_in_attributeCompiled1386);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._exprCompiled_in_attributeCompiled1388);
-				exprCompiled(gen);
-
-				state._fsp--;
-
-				// Language\\ActionEvaluator.g3:612:4: (id= ID | ^( VALUE exprCompiled[$gen] ) )
-				int alt25=2;
-				int LA25_0 = input.LA(1);
-
-				if ( (LA25_0==ID) )
-				{
-					alt25=1;
-				}
-				else if ( (LA25_0==VALUE) )
-				{
-					alt25=2;
-				}
-				else
-				{
-					NoViableAltException nvae = new NoViableAltException("", 25, 0, input);
-
-					throw nvae;
-				}
-				switch ( alt25 )
-				{
-				case 1:
-					// Language\\ActionEvaluator.g3:612:6: id= ID
-					{
-					id=(StringTemplateAST)Match(input,ID,Follow._ID_in_attributeCompiled1398);
-
-					#if COMPILE_EXPRESSIONS
-										EmitLoadString(gen,(id!=null?id.Text:null));
-					#endif
-
-
-					}
-					break;
-				case 2:
-					// Language\\ActionEvaluator.g3:618:6: ^( VALUE exprCompiled[$gen] )
-					{
-					Match(input,VALUE,Follow._VALUE_in_attributeCompiled1412);
-
-					Match(input, TokenTypes.Down, null);
-					PushFollow(Follow._exprCompiled_in_attributeCompiled1414);
-					exprCompiled(gen);
-
-					state._fsp--;
-
-
-					Match(input, TokenTypes.Up, null);
-
-					}
-					break;
-
-				}
-
-
-				#if COMPILE_EXPRESSIONS
-								EmitObjectProperty(gen);
-				#endif
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 2:
-				// Language\\ActionEvaluator.g3:627:4: id= ID
-				{
-				id=(StringTemplateAST)Match(input,ID,Follow._ID_in_attributeCompiled1438);
-
-				#if COMPILE_EXPRESSIONS
-							EmitAttribute(gen,(id!=null?id.Text:null));
-				#endif
-
-
-				}
-				break;
-			case 3:
-				// Language\\ActionEvaluator.g3:634:4: INT
-				{
-				INT23=(StringTemplateAST)Match(input,INT,Follow._INT_in_attributeCompiled1448);
-
-				#if COMPILE_EXPRESSIONS
-							EmitLoadIntAsObject(gen,int.Parse((INT23!=null?INT23.Text:null)));
-				#endif
-
-
-				}
-				break;
-			case 4:
-				// Language\\ActionEvaluator.g3:641:4: STRING
-				{
-				STRING24=(StringTemplateAST)Match(input,STRING,Follow._STRING_in_attributeCompiled1458);
-
-				#if COMPILE_EXPRESSIONS
-							EmitLoadString(gen,(STRING24!=null?STRING24.Text:null));
-				#endif
-
-
-				}
-				break;
-			case 5:
-				// Language\\ActionEvaluator.g3:648:4: ANONYMOUS_TEMPLATE
-				{
-				ANONYMOUS_TEMPLATE25=(StringTemplateAST)Match(input,ANONYMOUS_TEMPLATE,Follow._ANONYMOUS_TEMPLATE_in_attributeCompiled1468);
-
-				#if COMPILE_EXPRESSIONS
-							EmitAnonymousTemplate(gen,(ANONYMOUS_TEMPLATE25!=null?ANONYMOUS_TEMPLATE25.Text:null));
-				#endif
-
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "attributeCompiled"
-
-
-	// $ANTLR start "attributeFunctional"
-	// Language\\ActionEvaluator.g3:656:0: attributeFunctional returns [System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> func] : ( ^( DOT a= exprFunctional (id= ID | ^( VALUE b= exprFunctional ) ) ) |id= ID | INT | STRING | ANONYMOUS_TEMPLATE );
-	private System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> attributeFunctional(  )
-	{
-		System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> func = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
-
-		StringTemplateAST id=null;
-		StringTemplateAST INT26=null;
-		StringTemplateAST STRING27=null;
-		StringTemplateAST ANONYMOUS_TEMPLATE28=null;
-		System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> a = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
-		System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> b = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:657:4: ( ^( DOT a= exprFunctional (id= ID | ^( VALUE b= exprFunctional ) ) ) |id= ID | INT | STRING | ANONYMOUS_TEMPLATE )
-			int alt28=5;
-			switch ( input.LA(1) )
-			{
-			case DOT:
-				{
-				alt28=1;
-				}
-				break;
-			case ID:
-				{
-				alt28=2;
-				}
-				break;
-			case INT:
-				{
-				alt28=3;
-				}
-				break;
-			case STRING:
-				{
-				alt28=4;
-				}
-				break;
-			case ANONYMOUS_TEMPLATE:
-				{
-				alt28=5;
-				}
-				break;
-			default:
-				{
-					NoViableAltException nvae = new NoViableAltException("", 28, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt28 )
-			{
-			case 1:
-				// Language\\ActionEvaluator.g3:657:4: ^( DOT a= exprFunctional (id= ID | ^( VALUE b= exprFunctional ) ) )
-				{
-				Match(input,DOT,Follow._DOT_in_attributeFunctional1489);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._exprFunctional_in_attributeFunctional1493);
-				a=exprFunctional();
-
-				state._fsp--;
-
-				// Language\\ActionEvaluator.g3:658:4: (id= ID | ^( VALUE b= exprFunctional ) )
-				int alt27=2;
-				int LA27_0 = input.LA(1);
-
-				if ( (LA27_0==ID) )
-				{
-					alt27=1;
-				}
-				else if ( (LA27_0==VALUE) )
-				{
-					alt27=2;
-				}
-				else
-				{
-					NoViableAltException nvae = new NoViableAltException("", 27, 0, input);
-
-					throw nvae;
-				}
-				switch ( alt27 )
-				{
-				case 1:
-					// Language\\ActionEvaluator.g3:658:6: id= ID
-					{
-					id=(StringTemplateAST)Match(input,ID,Follow._ID_in_attributeFunctional1502);
-
-					#if COMPILE_EXPRESSIONS
-										string text = (id!=null?id.Text:null);
-										func = (chunk,self,writer) => chunk.GetObjectProperty( self, a(chunk,self,writer), text );
-					#endif
-
-
-					}
-					break;
-				case 2:
-					// Language\\ActionEvaluator.g3:665:6: ^( VALUE b= exprFunctional )
-					{
-					Match(input,VALUE,Follow._VALUE_in_attributeFunctional1516);
-
-					Match(input, TokenTypes.Down, null);
-					PushFollow(Follow._exprFunctional_in_attributeFunctional1520);
-					b=exprFunctional();
-
-					state._fsp--;
-
-
-					Match(input, TokenTypes.Up, null);
-
-					#if COMPILE_EXPRESSIONS
-										func = (chunk,self,writer) => chunk.GetObjectProperty( self, a(chunk,self,writer), b(chunk,self,writer) );
-					#endif
-
-
-					}
-					break;
-
-				}
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 2:
-				// Language\\ActionEvaluator.g3:674:4: id= ID
-				{
-				id=(StringTemplateAST)Match(input,ID,Follow._ID_in_attributeFunctional1544);
-
-				#if COMPILE_EXPRESSIONS
-							string text = (id!=null?id.Text:null);
-							func = (chunk,self,writer) => self.GetAttribute( text );
-				#endif
-
-
-				}
-				break;
-			case 3:
-				// Language\\ActionEvaluator.g3:682:4: INT
-				{
-				INT26=(StringTemplateAST)Match(input,INT,Follow._INT_in_attributeFunctional1554);
-
-				#if COMPILE_EXPRESSIONS
-							int i = int.Parse((INT26!=null?INT26.Text:null));
-							func = (chunk,self,writer) => i;
-				#endif
-
-
-				}
-				break;
-			case 4:
-				// Language\\ActionEvaluator.g3:690:4: STRING
-				{
-				STRING27=(StringTemplateAST)Match(input,STRING,Follow._STRING_in_attributeFunctional1564);
-
-				#if COMPILE_EXPRESSIONS
-							string text = (STRING27!=null?STRING27.Text:null);
-							func = (chunk,self,writer) => text;
-				#endif
-
-
-				}
-				break;
-			case 5:
-				// Language\\ActionEvaluator.g3:698:4: ANONYMOUS_TEMPLATE
-				{
-				ANONYMOUS_TEMPLATE28=(StringTemplateAST)Match(input,ANONYMOUS_TEMPLATE,Follow._ANONYMOUS_TEMPLATE_in_attributeFunctional1574);
-
-				#if COMPILE_EXPRESSIONS
-							string text = (ANONYMOUS_TEMPLATE28!=null?ANONYMOUS_TEMPLATE28.Text:null);
-							if ( text != null )
-							{
-								func = (chunk,self,writer) =>
-									new StringTemplate( self.Group, text )
-									{
-										EnclosingInstance = self,
-										Name = "<anonymous template argument>"
-									};
-							}
-							else
-							{
-								func = (chunk,self,writer) => null;
-							}
-				#endif
-
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return func;
-	}
-	// $ANTLR end "attributeFunctional"
-
-
-	// $ANTLR start "templateIncludeCompiled"
-	// Language\\ActionEvaluator.g3:719:0: templateIncludeCompiled[System.Reflection.Emit.ILGenerator gen] : ^( INCLUDE ( ID args= . | ^( VALUE exprCompiled[$gen] args= . ) ) ) ;
-	private void templateIncludeCompiled( System.Reflection.Emit.ILGenerator gen )
-	{
-		StringTemplateAST ID29=null;
-		StringTemplateAST args=null;
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:720:4: ( ^( INCLUDE ( ID args= . | ^( VALUE exprCompiled[$gen] args= . ) ) ) )
-			// Language\\ActionEvaluator.g3:720:4: ^( INCLUDE ( ID args= . | ^( VALUE exprCompiled[$gen] args= . ) ) )
-			{
-			Match(input,INCLUDE,Follow._INCLUDE_in_templateIncludeCompiled1592);
-
-			Match(input, TokenTypes.Down, null);
-			// Language\\ActionEvaluator.g3:721:4: ( ID args= . | ^( VALUE exprCompiled[$gen] args= . ) )
-			int alt29=2;
-			int LA29_0 = input.LA(1);
-
-			if ( (LA29_0==ID) )
-			{
-				alt29=1;
-			}
-			else if ( (LA29_0==VALUE) )
-			{
-				alt29=2;
-			}
-			else
-			{
-				NoViableAltException nvae = new NoViableAltException("", 29, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt29 )
-			{
-			case 1:
-				// Language\\ActionEvaluator.g3:721:6: ID args= .
-				{
-				ID29=(StringTemplateAST)Match(input,ID,Follow._ID_in_templateIncludeCompiled1599);
-				args=(StringTemplateAST)input.LT(1);
-				MatchAny(input);
-
-				#if COMPILE_EXPRESSIONS
-									EmitLoadString( gen, (ID29!=null?ID29.Text:null) );
-				#endif
-
-
-				}
-				break;
-			case 2:
-				// Language\\ActionEvaluator.g3:727:6: ^( VALUE exprCompiled[$gen] args= . )
-				{
-				Match(input,VALUE,Follow._VALUE_in_templateIncludeCompiled1618);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._exprCompiled_in_templateIncludeCompiled1620);
-				exprCompiled(gen);
-
-				state._fsp--;
-
-				args=(StringTemplateAST)input.LT(1);
-				MatchAny(input);
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-
-			}
-
-
-			Match(input, TokenTypes.Up, null);
-
-			#if COMPILE_EXPRESSIONS
-						EmitTemplateInclude( gen, args );
-			#endif
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "templateIncludeCompiled"
-
-
-	// $ANTLR start "templateIncludeFunctional"
-	// Language\\ActionEvaluator.g3:737:0: templateIncludeFunctional returns [System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> func] : ^( INCLUDE ( ID args= . | ^( VALUE exprFunctional args= . ) ) ) ;
-	private System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> templateIncludeFunctional(  )
-	{
-		System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> func = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
-
-		StringTemplateAST ID30=null;
-		StringTemplateAST args=null;
-		System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> exprFunctional31 = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:738:4: ( ^( INCLUDE ( ID args= . | ^( VALUE exprFunctional args= . ) ) ) )
-			// Language\\ActionEvaluator.g3:738:4: ^( INCLUDE ( ID args= . | ^( VALUE exprFunctional args= . ) ) )
-			{
-			Match(input,INCLUDE,Follow._INCLUDE_in_templateIncludeFunctional1657);
-
-			Match(input, TokenTypes.Down, null);
-			// Language\\ActionEvaluator.g3:739:4: ( ID args= . | ^( VALUE exprFunctional args= . ) )
-			int alt30=2;
-			int LA30_0 = input.LA(1);
-
-			if ( (LA30_0==ID) )
-			{
-				alt30=1;
-			}
-			else if ( (LA30_0==VALUE) )
-			{
-				alt30=2;
-			}
-			else
-			{
-				NoViableAltException nvae = new NoViableAltException("", 30, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt30 )
-			{
-			case 1:
-				// Language\\ActionEvaluator.g3:739:6: ID args= .
-				{
-				ID30=(StringTemplateAST)Match(input,ID,Follow._ID_in_templateIncludeFunctional1664);
-				args=(StringTemplateAST)input.LT(1);
-				MatchAny(input);
-
-				}
-				break;
-			case 2:
-				// Language\\ActionEvaluator.g3:740:6: ^( VALUE exprFunctional args= . )
-				{
-				Match(input,VALUE,Follow._VALUE_in_templateIncludeFunctional1677);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._exprFunctional_in_templateIncludeFunctional1679);
-				exprFunctional31=exprFunctional();
-
-				state._fsp--;
-
-				args=(StringTemplateAST)input.LT(1);
-				MatchAny(input);
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-
-			}
-
-
-			Match(input, TokenTypes.Up, null);
-
-			#if COMPILE_EXPRESSIONS
-						if ( ID30 != null )
-						{
-							string name = (ID30!=null?ID30.Text:null);
-							if ( name != null )
-							{
-								func = (chunk,self,writer) =>
-									{
-										return chunk.GetTemplateInclude( self, name, args );
-									};
-							}
-							else
-							{
-								func = (chunk,self,writer) => null;
-							}
-						}
-						else
-						{
-							func = (chunk,self,writer) =>
-								{
-									var value = exprFunctional31(chunk,self,writer);
-									if ( value == null )
-										return null;
-
-									string name = value.ToString();
-									if ( name != null )
-									{
-										return chunk.GetTemplateInclude( self, name, args );
-									}
-									return null;
-								};
-						}
-			#endif
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return func;
-	}
-	// $ANTLR end "templateIncludeFunctional"
-
-
-	// $ANTLR start "functionCompiled"
-	// Language\\ActionEvaluator.g3:780:0: functionCompiled[System.Reflection.Emit.ILGenerator gen] : ^( FUNCTION ( 'first' singleFunctionArgCompiled[$gen] | 'rest' singleFunctionArgCompiled[$gen] | 'last' singleFunctionArgCompiled[$gen] | 'length' singleFunctionArgCompiled[$gen] | 'strip' singleFunctionArgCompiled[$gen] | 'trunc' singleFunctionArgCompiled[$gen] ) ) ;
-	private void functionCompiled( System.Reflection.Emit.ILGenerator gen )
-	{
-		try
-		{
-			// Language\\ActionEvaluator.g3:781:4: ( ^( FUNCTION ( 'first' singleFunctionArgCompiled[$gen] | 'rest' singleFunctionArgCompiled[$gen] | 'last' singleFunctionArgCompiled[$gen] | 'length' singleFunctionArgCompiled[$gen] | 'strip' singleFunctionArgCompiled[$gen] | 'trunc' singleFunctionArgCompiled[$gen] ) ) )
-			// Language\\ActionEvaluator.g3:781:4: ^( FUNCTION ( 'first' singleFunctionArgCompiled[$gen] | 'rest' singleFunctionArgCompiled[$gen] | 'last' singleFunctionArgCompiled[$gen] | 'length' singleFunctionArgCompiled[$gen] | 'strip' singleFunctionArgCompiled[$gen] | 'trunc' singleFunctionArgCompiled[$gen] ) )
-			{
-			Match(input,FUNCTION,Follow._FUNCTION_in_functionCompiled1712);
-
-			Match(input, TokenTypes.Down, null);
-			// Language\\ActionEvaluator.g3:782:4: ( 'first' singleFunctionArgCompiled[$gen] | 'rest' singleFunctionArgCompiled[$gen] | 'last' singleFunctionArgCompiled[$gen] | 'length' singleFunctionArgCompiled[$gen] | 'strip' singleFunctionArgCompiled[$gen] | 'trunc' singleFunctionArgCompiled[$gen] )
-			int alt31=6;
-			switch ( input.LA(1) )
-			{
-			case FIRST:
-				{
-				alt31=1;
-				}
-				break;
-			case REST:
-				{
-				alt31=2;
-				}
-				break;
-			case LAST:
-				{
-				alt31=3;
-				}
-				break;
-			case LENGTH:
-				{
-				alt31=4;
-				}
-				break;
-			case STRIP:
-				{
-				alt31=5;
-				}
-				break;
-			case TRUNC:
-				{
-				alt31=6;
-				}
-				break;
-			default:
-				{
-					NoViableAltException nvae = new NoViableAltException("", 31, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt31 )
-			{
-			case 1:
-				// Language\\ActionEvaluator.g3:782:6: 'first' singleFunctionArgCompiled[$gen]
-				{
-				Match(input,FIRST,Follow._FIRST_in_functionCompiled1719);
-				PushFollow(Follow._singleFunctionArgCompiled_in_functionCompiled1722);
-				singleFunctionArgCompiled(gen);
-
-				state._fsp--;
-
-
-				#if COMPILE_EXPRESSIONS
-									EmitFunctionFirst(gen);
-				#endif
-
-
-				}
-				break;
-			case 2:
-				// Language\\ActionEvaluator.g3:788:6: 'rest' singleFunctionArgCompiled[$gen]
-				{
-				Match(input,REST,Follow._REST_in_functionCompiled1736);
-				PushFollow(Follow._singleFunctionArgCompiled_in_functionCompiled1739);
-				singleFunctionArgCompiled(gen);
-
-				state._fsp--;
-
-
-				#if COMPILE_EXPRESSIONS
-									EmitFunctionRest(gen);
-				#endif
-
-
-				}
-				break;
-			case 3:
-				// Language\\ActionEvaluator.g3:794:6: 'last' singleFunctionArgCompiled[$gen]
-				{
-				Match(input,LAST,Follow._LAST_in_functionCompiled1753);
-				PushFollow(Follow._singleFunctionArgCompiled_in_functionCompiled1756);
-				singleFunctionArgCompiled(gen);
-
-				state._fsp--;
-
-
-				#if COMPILE_EXPRESSIONS
-									EmitFunctionLast(gen);
-				#endif
-
-
-				}
-				break;
-			case 4:
-				// Language\\ActionEvaluator.g3:800:6: 'length' singleFunctionArgCompiled[$gen]
-				{
-				Match(input,LENGTH,Follow._LENGTH_in_functionCompiled1770);
-				PushFollow(Follow._singleFunctionArgCompiled_in_functionCompiled1772);
-				singleFunctionArgCompiled(gen);
-
-				state._fsp--;
-
-
-				#if COMPILE_EXPRESSIONS
-									EmitFunctionLength(gen);
-				#endif
-
-
-				}
-				break;
-			case 5:
-				// Language\\ActionEvaluator.g3:806:6: 'strip' singleFunctionArgCompiled[$gen]
-				{
-				Match(input,STRIP,Follow._STRIP_in_functionCompiled1786);
-				PushFollow(Follow._singleFunctionArgCompiled_in_functionCompiled1789);
-				singleFunctionArgCompiled(gen);
-
-				state._fsp--;
-
-
-				#if COMPILE_EXPRESSIONS
-									EmitFunctionStrip(gen);
-				#endif
-
-
-				}
-				break;
-			case 6:
-				// Language\\ActionEvaluator.g3:812:6: 'trunc' singleFunctionArgCompiled[$gen]
-				{
-				Match(input,TRUNC,Follow._TRUNC_in_functionCompiled1803);
-				PushFollow(Follow._singleFunctionArgCompiled_in_functionCompiled1806);
-				singleFunctionArgCompiled(gen);
-
-				state._fsp--;
-
-
-				#if COMPILE_EXPRESSIONS
-									EmitFunctionTrunc(gen);
-				#endif
-
-
-				}
-				break;
-
-			}
-
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "functionCompiled"
-
-
-	// $ANTLR start "functionFunctional"
-	// Language\\ActionEvaluator.g3:822:0: functionFunctional returns [System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> func] : ^( FUNCTION ( 'first' a= singleFunctionArgFunctional | 'rest' a= singleFunctionArgFunctional | 'last' a= singleFunctionArgFunctional | 'length' a= singleFunctionArgFunctional | 'strip' a= singleFunctionArgFunctional | 'trunc' a= singleFunctionArgFunctional ) ) ;
-	private System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> functionFunctional(  )
-	{
-		System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> func = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
-
-		System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> a = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:823:4: ( ^( FUNCTION ( 'first' a= singleFunctionArgFunctional | 'rest' a= singleFunctionArgFunctional | 'last' a= singleFunctionArgFunctional | 'length' a= singleFunctionArgFunctional | 'strip' a= singleFunctionArgFunctional | 'trunc' a= singleFunctionArgFunctional ) ) )
-			// Language\\ActionEvaluator.g3:823:4: ^( FUNCTION ( 'first' a= singleFunctionArgFunctional | 'rest' a= singleFunctionArgFunctional | 'last' a= singleFunctionArgFunctional | 'length' a= singleFunctionArgFunctional | 'strip' a= singleFunctionArgFunctional | 'trunc' a= singleFunctionArgFunctional ) )
-			{
-			Match(input,FUNCTION,Follow._FUNCTION_in_functionFunctional1839);
-
-			Match(input, TokenTypes.Down, null);
-			// Language\\ActionEvaluator.g3:824:4: ( 'first' a= singleFunctionArgFunctional | 'rest' a= singleFunctionArgFunctional | 'last' a= singleFunctionArgFunctional | 'length' a= singleFunctionArgFunctional | 'strip' a= singleFunctionArgFunctional | 'trunc' a= singleFunctionArgFunctional )
-			int alt32=6;
-			switch ( input.LA(1) )
-			{
-			case FIRST:
-				{
-				alt32=1;
-				}
-				break;
-			case REST:
-				{
-				alt32=2;
-				}
-				break;
-			case LAST:
-				{
-				alt32=3;
-				}
-				break;
-			case LENGTH:
-				{
-				alt32=4;
-				}
-				break;
-			case STRIP:
-				{
-				alt32=5;
-				}
-				break;
-			case TRUNC:
-				{
-				alt32=6;
-				}
-				break;
-			default:
-				{
-					NoViableAltException nvae = new NoViableAltException("", 32, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt32 )
-			{
-			case 1:
-				// Language\\ActionEvaluator.g3:824:6: 'first' a= singleFunctionArgFunctional
-				{
-				Match(input,FIRST,Follow._FIRST_in_functionFunctional1846);
-				PushFollow(Follow._singleFunctionArgFunctional_in_functionFunctional1851);
-				a=singleFunctionArgFunctional();
-
-				state._fsp--;
-
-
-				#if COMPILE_EXPRESSIONS
-									func = (chunk,self,writer) => chunk.First( a(chunk,self,writer) );
-				#endif
-
-
-				}
-				break;
-			case 2:
-				// Language\\ActionEvaluator.g3:830:6: 'rest' a= singleFunctionArgFunctional
-				{
-				Match(input,REST,Follow._REST_in_functionFunctional1864);
-				PushFollow(Follow._singleFunctionArgFunctional_in_functionFunctional1869);
-				a=singleFunctionArgFunctional();
-
-				state._fsp--;
-
-
-				#if COMPILE_EXPRESSIONS
-									func = (chunk,self,writer) => chunk.Rest( a(chunk,self,writer) );
-				#endif
-
-
-				}
-				break;
-			case 3:
-				// Language\\ActionEvaluator.g3:836:6: 'last' a= singleFunctionArgFunctional
-				{
-				Match(input,LAST,Follow._LAST_in_functionFunctional1882);
-				PushFollow(Follow._singleFunctionArgFunctional_in_functionFunctional1887);
-				a=singleFunctionArgFunctional();
-
-				state._fsp--;
-
-
-				#if COMPILE_EXPRESSIONS
-									func = (chunk,self,writer) => chunk.Last( a(chunk,self,writer) );
-				#endif
-
-
-				}
-				break;
-			case 4:
-				// Language\\ActionEvaluator.g3:842:6: 'length' a= singleFunctionArgFunctional
-				{
-				Match(input,LENGTH,Follow._LENGTH_in_functionFunctional1900);
-				PushFollow(Follow._singleFunctionArgFunctional_in_functionFunctional1904);
-				a=singleFunctionArgFunctional();
-
-				state._fsp--;
-
-
-				#if COMPILE_EXPRESSIONS
-									func = (chunk,self,writer) => chunk.Length( a(chunk,self,writer) );
-				#endif
-
-
-				}
-				break;
-			case 5:
-				// Language\\ActionEvaluator.g3:848:6: 'strip' a= singleFunctionArgFunctional
-				{
-				Match(input,STRIP,Follow._STRIP_in_functionFunctional1917);
-				PushFollow(Follow._singleFunctionArgFunctional_in_functionFunctional1922);
-				a=singleFunctionArgFunctional();
-
-				state._fsp--;
-
-
-				#if COMPILE_EXPRESSIONS
-									func = (chunk,self,writer) => chunk.Strip( a(chunk,self,writer) );
-				#endif
-
-
-				}
-				break;
-			case 6:
-				// Language\\ActionEvaluator.g3:854:6: 'trunc' a= singleFunctionArgFunctional
-				{
-				Match(input,TRUNC,Follow._TRUNC_in_functionFunctional1935);
-				PushFollow(Follow._singleFunctionArgFunctional_in_functionFunctional1940);
-				a=singleFunctionArgFunctional();
-
-				state._fsp--;
-
-
-				#if COMPILE_EXPRESSIONS
-									func = (chunk,self,writer) => chunk.Trunc( a(chunk,self,writer) );
-				#endif
-
-
-				}
-				break;
-
-			}
-
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return func;
-	}
-	// $ANTLR end "functionFunctional"
-
-
-	// $ANTLR start "listCompiled"
-	// Language\\ActionEvaluator.g3:864:0: listCompiled[System.Reflection.Emit.ILGenerator gen] : ^( LIST ( exprCompiled[$gen] | NOTHING )+ ) ;
-	private void listCompiled( System.Reflection.Emit.ILGenerator gen )
-	{
-
-		#if COMPILE_EXPRESSIONS
-			var elements = EmitCreateList<object>(gen);
-		#endif
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:871:4: ( ^( LIST ( exprCompiled[$gen] | NOTHING )+ ) )
-			// Language\\ActionEvaluator.g3:871:4: ^( LIST ( exprCompiled[$gen] | NOTHING )+ )
-			{
-			Match(input,LIST,Follow._LIST_in_listCompiled1974);
-
-			Match(input, TokenTypes.Down, null);
-			// Language\\ActionEvaluator.g3:872:4: ( exprCompiled[$gen] | NOTHING )+
-			int cnt33=0;
-			for ( ; ; )
-			{
-				int alt33=3;
-				int LA33_0 = input.LA(1);
-
-				if ( ((LA33_0>=ANONYMOUS_TEMPLATE && LA33_0<=APPLY)||LA33_0==DOT||(LA33_0>=FUNCTION && LA33_0<=INT)||LA33_0==LIST||LA33_0==MULTI_APPLY||LA33_0==PLUS||LA33_0==STRING||LA33_0==VALUE) )
-				{
-					alt33=1;
-				}
-				else if ( (LA33_0==NOTHING) )
-				{
-					alt33=2;
-				}
-
-
-				switch ( alt33 )
-				{
-				case 1:
-					// Language\\ActionEvaluator.g3:872:6: exprCompiled[$gen]
-					{
-					PushFollow(Follow._exprCompiled_in_listCompiled1981);
-					exprCompiled(gen);
-
-					state._fsp--;
-
-
-					#if COMPILE_EXPRESSIONS
-										EmitAddValueToList(gen, elements);
-					#endif
-
-
-					}
-					break;
-				case 2:
-					// Language\\ActionEvaluator.g3:878:6: NOTHING
-					{
-					Match(input,NOTHING,Follow._NOTHING_in_listCompiled1995);
-
-					#if COMPILE_EXPRESSIONS
-										EmitAddNothingToList(gen, elements);
-					#endif
-
-
-					}
-					break;
-
-				default:
-					if ( cnt33 >= 1 )
-						goto loop33;
-
-					EarlyExitException eee33 = new EarlyExitException( 33, input );
-					throw eee33;
-				}
-				cnt33++;
-			}
-			loop33:
-				;
-
-
-
-			Match(input, TokenTypes.Up, null);
-
-			#if COMPILE_EXPRESSIONS
-						EmitCatList(gen,elements);
-			#endif
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "listCompiled"
-
-
-	// $ANTLR start "listFunctional"
-	// Language\\ActionEvaluator.g3:893:0: listFunctional returns [System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> func] : ^( LIST ( exprFunctional | NOTHING )+ ) ;
-	private System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> listFunctional(  )
-	{
-		System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> func = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
-
-		System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> exprFunctional32 = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
-
-
-			List<System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>> elements = new List<System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>>();
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:898:4: ( ^( LIST ( exprFunctional | NOTHING )+ ) )
-			// Language\\ActionEvaluator.g3:898:4: ^( LIST ( exprFunctional | NOTHING )+ )
-			{
-			Match(input,LIST,Follow._LIST_in_listFunctional2037);
-
-			Match(input, TokenTypes.Down, null);
-			// Language\\ActionEvaluator.g3:899:4: ( exprFunctional | NOTHING )+
-			int cnt34=0;
-			for ( ; ; )
-			{
-				int alt34=3;
-				int LA34_0 = input.LA(1);
-
-				if ( ((LA34_0>=ANONYMOUS_TEMPLATE && LA34_0<=APPLY)||LA34_0==DOT||(LA34_0>=FUNCTION && LA34_0<=INT)||LA34_0==LIST||LA34_0==MULTI_APPLY||LA34_0==PLUS||LA34_0==STRING||LA34_0==VALUE) )
-				{
-					alt34=1;
-				}
-				else if ( (LA34_0==NOTHING) )
-				{
-					alt34=2;
-				}
-
-
-				switch ( alt34 )
-				{
-				case 1:
-					// Language\\ActionEvaluator.g3:899:6: exprFunctional
-					{
-					PushFollow(Follow._exprFunctional_in_listFunctional2044);
-					exprFunctional32=exprFunctional();
-
-					state._fsp--;
-
-
-					#if COMPILE_EXPRESSIONS
-										if ( exprFunctional32 != null )
-											elements.Add(exprFunctional32);
-					#endif
-
-
-					}
-					break;
-				case 2:
-					// Language\\ActionEvaluator.g3:906:6: NOTHING
-					{
-					Match(input,NOTHING,Follow._NOTHING_in_listFunctional2057);
-
-					#if COMPILE_EXPRESSIONS
-										elements.Add( (chunk,self,writer) => new ArrayList( new object[] { null } ).iterator() );
-					#endif
-
-
-					}
-					break;
-
-				default:
-					if ( cnt34 >= 1 )
-						goto loop34;
-
-					EarlyExitException eee34 = new EarlyExitException( 34, input );
-					throw eee34;
-				}
-				cnt34++;
-			}
-			loop34:
-				;
-
-
-
-			Match(input, TokenTypes.Up, null);
-
-			#if COMPILE_EXPRESSIONS
-						func = (chunk,self,writer) =>
-							new Cat(from f in elements
-									let value = f(chunk,self,writer)
-									where value != null
-									select value
-									);
-			#endif
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return func;
-	}
-	// $ANTLR end "listFunctional"
-
-
-	// $ANTLR start "singleFunctionArgCompiled"
-	// Language\\ActionEvaluator.g3:926:0: singleFunctionArgCompiled[System.Reflection.Emit.ILGenerator gen] : ^( SINGLEVALUEARG exprCompiled[$gen] ) ;
-	private void singleFunctionArgCompiled( System.Reflection.Emit.ILGenerator gen )
-	{
-		try
-		{
-			// Language\\ActionEvaluator.g3:927:4: ( ^( SINGLEVALUEARG exprCompiled[$gen] ) )
-			// Language\\ActionEvaluator.g3:927:4: ^( SINGLEVALUEARG exprCompiled[$gen] )
-			{
-			Match(input,SINGLEVALUEARG,Follow._SINGLEVALUEARG_in_singleFunctionArgCompiled2091);
-
-			Match(input, TokenTypes.Down, null);
-			PushFollow(Follow._exprCompiled_in_singleFunctionArgCompiled2093);
-			exprCompiled(gen);
-
-			state._fsp--;
-
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "singleFunctionArgCompiled"
-
-
-	// $ANTLR start "singleFunctionArgFunctional"
-	// Language\\ActionEvaluator.g3:930:0: singleFunctionArgFunctional returns [System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> func] : ^( SINGLEVALUEARG exprFunctional ) ;
-	private System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> singleFunctionArgFunctional(  )
-	{
-		System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> func = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
-
-		System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object> exprFunctional33 = default(System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,object>);
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:931:4: ( ^( SINGLEVALUEARG exprFunctional ) )
-			// Language\\ActionEvaluator.g3:931:4: ^( SINGLEVALUEARG exprFunctional )
-			{
-			Match(input,SINGLEVALUEARG,Follow._SINGLEVALUEARG_in_singleFunctionArgFunctional2113);
-
-			Match(input, TokenTypes.Down, null);
-			PushFollow(Follow._exprFunctional_in_singleFunctionArgFunctional2115);
-			exprFunctional33=exprFunctional();
-
-			state._fsp--;
-
-			func = exprFunctional33;
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return func;
-	}
-	// $ANTLR end "singleFunctionArgFunctional"
-
-
-	// $ANTLR start "templateCompiled"
-	// Language\\ActionEvaluator.g3:934:0: templateCompiled[System.Reflection.Emit.ILGenerator gen] : ^( TEMPLATE ( ID args= . |anon= ANONYMOUS_TEMPLATE | ^( VALUE n= exprCompiled[$gen] args2= . ) ) ) ;
-	private void templateCompiled( System.Reflection.Emit.ILGenerator gen )
-	{
-		StringTemplateAST anon=null;
-		StringTemplateAST args=null;
-		StringTemplateAST args2=null;
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:935:4: ( ^( TEMPLATE ( ID args= . |anon= ANONYMOUS_TEMPLATE | ^( VALUE n= exprCompiled[$gen] args2= . ) ) ) )
-			// Language\\ActionEvaluator.g3:935:4: ^( TEMPLATE ( ID args= . |anon= ANONYMOUS_TEMPLATE | ^( VALUE n= exprCompiled[$gen] args2= . ) ) )
-			{
-			Match(input,TEMPLATE,Follow._TEMPLATE_in_templateCompiled2133);
-
-			Match(input, TokenTypes.Down, null);
-			// Language\\ActionEvaluator.g3:936:4: ( ID args= . |anon= ANONYMOUS_TEMPLATE | ^( VALUE n= exprCompiled[$gen] args2= . ) )
-			int alt35=3;
-			switch ( input.LA(1) )
-			{
-			case ID:
-				{
-				alt35=1;
-				}
-				break;
-			case ANONYMOUS_TEMPLATE:
-				{
-				alt35=2;
-				}
-				break;
-			case VALUE:
-				{
-				alt35=3;
-				}
-				break;
-			default:
-				{
-					NoViableAltException nvae = new NoViableAltException("", 35, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt35 )
-			{
-			case 1:
-				// Language\\ActionEvaluator.g3:936:6: ID args= .
-				{
-				Match(input,ID,Follow._ID_in_templateCompiled2140);
-				args=(StringTemplateAST)input.LT(1);
-				MatchAny(input);
-
-				#if COMPILE_EXPRESSIONS
-									throw new System.NotImplementedException();
-				#endif
-
-
-				}
-				break;
-			case 2:
-				// Language\\ActionEvaluator.g3:943:6: anon= ANONYMOUS_TEMPLATE
-				{
-				anon=(StringTemplateAST)Match(input,ANONYMOUS_TEMPLATE,Follow._ANONYMOUS_TEMPLATE_in_templateCompiled2161);
-
-				#if COMPILE_EXPRESSIONS
-									throw new System.NotImplementedException();
-				#endif
-
-
-				}
-				break;
-			case 3:
-				// Language\\ActionEvaluator.g3:950:6: ^( VALUE n= exprCompiled[$gen] args2= . )
-				{
-				Match(input,VALUE,Follow._VALUE_in_templateCompiled2177);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._exprCompiled_in_templateCompiled2181);
-				exprCompiled(gen);
-
-				state._fsp--;
-
-				args2=(StringTemplateAST)input.LT(1);
-				MatchAny(input);
-
-				#if COMPILE_EXPRESSIONS
-										throw new System.NotImplementedException();
-				#endif
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-
-			}
-
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "templateCompiled"
-
-
-	// $ANTLR start "templateFunctional"
-	// Language\\ActionEvaluator.g3:961:0: templateFunctional[List<System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,StringTemplate>> templateApplicators] : ^( TEMPLATE ( ID args= . |anon= ANONYMOUS_TEMPLATE | ^( VALUE n= expr args2= . ) ) ) ;
-	private void templateFunctional( List<System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,StringTemplate>> templateApplicators )
-	{
-		StringTemplateAST anon=null;
-		StringTemplateAST ID34=null;
-		StringTemplateAST args=null;
-		StringTemplateAST args2=null;
-		object n = default(object);
-
-
-			Map argumentContext = null;
-
-		try
-		{
-			// Language\\ActionEvaluator.g3:966:4: ( ^( TEMPLATE ( ID args= . |anon= ANONYMOUS_TEMPLATE | ^( VALUE n= expr args2= . ) ) ) )
-			// Language\\ActionEvaluator.g3:966:4: ^( TEMPLATE ( ID args= . |anon= ANONYMOUS_TEMPLATE | ^( VALUE n= expr args2= . ) ) )
-			{
-			Match(input,TEMPLATE,Follow._TEMPLATE_in_templateFunctional2227);
-
-			Match(input, TokenTypes.Down, null);
-			// Language\\ActionEvaluator.g3:967:4: ( ID args= . |anon= ANONYMOUS_TEMPLATE | ^( VALUE n= expr args2= . ) )
-			int alt36=3;
-			switch ( input.LA(1) )
-			{
-			case ID:
-				{
-				alt36=1;
-				}
-				break;
-			case ANONYMOUS_TEMPLATE:
-				{
-				alt36=2;
-				}
-				break;
-			case VALUE:
-				{
-				alt36=3;
-				}
-				break;
-			default:
-				{
-					NoViableAltException nvae = new NoViableAltException("", 36, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt36 )
-			{
-			case 1:
-				// Language\\ActionEvaluator.g3:967:6: ID args= .
-				{
-				ID34=(StringTemplateAST)Match(input,ID,Follow._ID_in_templateFunctional2234);
-				args=(StringTemplateAST)input.LT(1);
-				MatchAny(input);
-
-				#if COMPILE_EXPRESSIONS
-									System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,StringTemplate> func =
-										(chunk,self,writer) =>
-										{
-											string templateName = (ID34!=null?ID34.Text:null);
-											StringTemplateGroup group = self.Group;
-											StringTemplate embedded = group.GetEmbeddedInstanceOf(self, templateName);
-											if ( embedded!=null )
-											{
-												embedded.ArgumentsAST = args;
-											}
-											return embedded;
-										};
-									templateApplicators.Add( func );
-				#endif
-
-
-				}
-				break;
-			case 2:
-				// Language\\ActionEvaluator.g3:986:6: anon= ANONYMOUS_TEMPLATE
-				{
-				anon=(StringTemplateAST)Match(input,ANONYMOUS_TEMPLATE,Follow._ANONYMOUS_TEMPLATE_in_templateFunctional2255);
-
-				#if COMPILE_EXPRESSIONS
-									System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,StringTemplate> func =
-										(chunk,self,writer) =>
-										{
-											StringTemplate anonymous = anon.StringTemplate;
-											// to properly see overridden templates, always set
-											// anonymous' group to be self's group
-											anonymous.Group = self.Group;
-											return anonymous;
-										};
-									templateApplicators.Add( func );
-				#endif
-
-
-				}
-				break;
-			case 3:
-				// Language\\ActionEvaluator.g3:1002:6: ^( VALUE n= expr args2= . )
-				{
-				Match(input,VALUE,Follow._VALUE_in_templateFunctional2271);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._expr_in_templateFunctional2275);
-				n=expr();
-
-				state._fsp--;
-
-				args2=(StringTemplateAST)input.LT(1);
-				MatchAny(input);
-
-				#if COMPILE_EXPRESSIONS
-										System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,StringTemplate> func =
-											(chunk,self,writer) =>
-											{
-												StringTemplate embedded = null;
-												if ( n!=null )
-												{
-													string templateName = n.ToString();
-													StringTemplateGroup group = self.Group;
-													embedded = group.GetEmbeddedInstanceOf(self, templateName);
-													if ( embedded!=null )
-													{
-														embedded.ArgumentsAST = args2;
-													}
-												}
-												return embedded;
-											};
-										templateApplicators.Add( func );
-				#endif
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-
-			}
-
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "templateFunctional"
-	#endregion Rules
-
-
-	#region Follow sets
-	private static class Follow
-	{
-		public static readonly BitSet _expr_in_action56 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _PLUS_in_expr79 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _expr_in_expr83 = new BitSet(new ulong[]{0x410428F0830UL});
-		public static readonly BitSet _expr_in_expr87 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _templateApplication_in_expr95 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _attribute_in_expr102 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _templateInclude_in_expr109 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _function_in_expr116 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _list_in_expr123 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _VALUE_in_expr131 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _expr_in_expr135 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _LIST_in_list167 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _expr_in_list174 = new BitSet(new ulong[]{0x410628F0838UL});
-		public static readonly BitSet _NOTHING_in_list187 = new BitSet(new ulong[]{0x410628F0838UL});
-		public static readonly BitSet _INCLUDE_in_templateInclude229 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_templateInclude242 = new BitSet(new ulong[]{0x1FFFFFFFFFF0UL});
-		public static readonly BitSet _VALUE_in_templateInclude262 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _expr_in_templateInclude266 = new BitSet(new ulong[]{0x1FFFFFFFFFF0UL});
-		public static readonly BitSet _APPLY_in_templateApplication316 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _expr_in_templateApplication320 = new BitSet(new ulong[]{0x8000000000UL});
-		public static readonly BitSet _template_in_templateApplication326 = new BitSet(new ulong[]{0x8000000008UL});
-		public static readonly BitSet _MULTI_APPLY_in_templateApplication345 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _expr_in_templateApplication350 = new BitSet(new ulong[]{0x410428F0930UL});
-		public static readonly BitSet _COLON_in_templateApplication357 = new BitSet(new ulong[]{0x10UL});
-		public static readonly BitSet _ANONYMOUS_TEMPLATE_in_templateApplication364 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _FUNCTION_in_function390 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _FIRST_in_function397 = new BitSet(new ulong[]{0x800000000UL});
-		public static readonly BitSet _singleFunctionArg_in_function402 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _REST_in_function411 = new BitSet(new ulong[]{0x800000000UL});
-		public static readonly BitSet _singleFunctionArg_in_function416 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _LAST_in_function425 = new BitSet(new ulong[]{0x800000000UL});
-		public static readonly BitSet _singleFunctionArg_in_function430 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _LENGTH_in_function439 = new BitSet(new ulong[]{0x800000000UL});
-		public static readonly BitSet _singleFunctionArg_in_function443 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _STRIP_in_function452 = new BitSet(new ulong[]{0x800000000UL});
-		public static readonly BitSet _singleFunctionArg_in_function457 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _TRUNC_in_function466 = new BitSet(new ulong[]{0x800000000UL});
-		public static readonly BitSet _singleFunctionArg_in_function471 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _SINGLEVALUEARG_in_singleFunctionArg499 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _expr_in_singleFunctionArg501 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _TEMPLATE_in_template524 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_template531 = new BitSet(new ulong[]{0x1FFFFFFFFFF0UL});
-		public static readonly BitSet _ANONYMOUS_TEMPLATE_in_template552 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _VALUE_in_template568 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _expr_in_template572 = new BitSet(new ulong[]{0x1FFFFFFFFFF0UL});
-		public static readonly BitSet _ifAtom_in_ifCondition617 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _NOT_in_ifCondition625 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ifAtom_in_ifCondition629 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _expr_in_ifAtom647 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _DOT_in_attribute671 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _expr_in_attribute675 = new BitSet(new ulong[]{0x40000020000UL});
-		public static readonly BitSet _ID_in_attribute684 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _VALUE_in_attribute714 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _expr_in_attribute718 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ID_in_attribute742 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _INT_in_attribute754 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _STRING_in_attribute764 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ANONYMOUS_TEMPLATE_in_attribute776 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ARGS_in_argList808 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _argumentAssignment_in_argList811 = new BitSet(new ulong[]{0x1088UL});
-		public static readonly BitSet _singleTemplateArg_in_argList821 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _SINGLEVALUEARG_in_singleTemplateArg836 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _expr_in_singleTemplateArg840 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ASSIGN_in_argumentAssignment860 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_argumentAssignment864 = new BitSet(new ulong[]{0x410428F0830UL});
-		public static readonly BitSet _expr_in_argumentAssignment866 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _DOTDOTDOT_in_argumentAssignment877 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _exprCompiled_in_actionCompiled893 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _exprFunctional_in_actionFunctional915 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ifAtomCompiled_in_ifConditionCompiled933 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _NOT_in_ifConditionCompiled940 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ifAtomCompiled_in_ifConditionCompiled942 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ifAtomFunctional_in_ifConditionFunctional965 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _NOT_in_ifConditionFunctional975 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ifAtomFunctional_in_ifConditionFunctional977 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _exprCompiled_in_ifAtomCompiled994 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _exprFunctional_in_ifAtomFunctional1014 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _PLUS_in_exprCompiled1031 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _exprCompiled_in_exprCompiled1033 = new BitSet(new ulong[]{0x410428F0830UL});
-		public static readonly BitSet _exprCompiled_in_exprCompiled1036 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _templateApplicationCompiled_in_exprCompiled1047 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _attributeCompiled_in_exprCompiled1053 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _templateIncludeCompiled_in_exprCompiled1059 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _functionCompiled_in_exprCompiled1065 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _listCompiled_in_exprCompiled1071 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _VALUE_in_exprCompiled1078 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _exprCompiled_in_exprCompiled1080 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _PLUS_in_exprFunctional1102 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _exprFunctional_in_exprFunctional1106 = new BitSet(new ulong[]{0x410428F0830UL});
-		public static readonly BitSet _exprFunctional_in_exprFunctional1110 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _templateApplicationFunctional_in_exprFunctional1120 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _attributeFunctional_in_exprFunctional1129 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _templateIncludeFunctional_in_exprFunctional1138 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _functionFunctional_in_exprFunctional1147 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _listFunctional_in_exprFunctional1156 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _VALUE_in_exprFunctional1166 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _exprFunctional_in_exprFunctional1170 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _APPLY_in_templateApplicationCompiled1194 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _exprCompiled_in_templateApplicationCompiled1198 = new BitSet(new ulong[]{0x8000000000UL});
-		public static readonly BitSet _templateCompiled_in_templateApplicationCompiled1211 = new BitSet(new ulong[]{0x8000000008UL});
-		public static readonly BitSet _MULTI_APPLY_in_templateApplicationCompiled1240 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _exprCompiled_in_templateApplicationCompiled1252 = new BitSet(new ulong[]{0x410428F0930UL});
-		public static readonly BitSet _COLON_in_templateApplicationCompiled1270 = new BitSet(new ulong[]{0x10UL});
-		public static readonly BitSet _ANONYMOUS_TEMPLATE_in_templateApplicationCompiled1275 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _APPLY_in_templateApplicationFunctional1306 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _exprFunctional_in_templateApplicationFunctional1310 = new BitSet(new ulong[]{0x8000000000UL});
-		public static readonly BitSet _templateFunctional_in_templateApplicationFunctional1316 = new BitSet(new ulong[]{0x8000000008UL});
-		public static readonly BitSet _MULTI_APPLY_in_templateApplicationFunctional1335 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _exprFunctional_in_templateApplicationFunctional1344 = new BitSet(new ulong[]{0x410428F0930UL});
-		public static readonly BitSet _COLON_in_templateApplicationFunctional1361 = new BitSet(new ulong[]{0x10UL});
-		public static readonly BitSet _ANONYMOUS_TEMPLATE_in_templateApplicationFunctional1363 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _DOT_in_attributeCompiled1386 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _exprCompiled_in_attributeCompiled1388 = new BitSet(new ulong[]{0x40000020000UL});
-		public static readonly BitSet _ID_in_attributeCompiled1398 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _VALUE_in_attributeCompiled1412 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _exprCompiled_in_attributeCompiled1414 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ID_in_attributeCompiled1438 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _INT_in_attributeCompiled1448 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _STRING_in_attributeCompiled1458 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ANONYMOUS_TEMPLATE_in_attributeCompiled1468 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _DOT_in_attributeFunctional1489 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _exprFunctional_in_attributeFunctional1493 = new BitSet(new ulong[]{0x40000020000UL});
-		public static readonly BitSet _ID_in_attributeFunctional1502 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _VALUE_in_attributeFunctional1516 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _exprFunctional_in_attributeFunctional1520 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ID_in_attributeFunctional1544 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _INT_in_attributeFunctional1554 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _STRING_in_attributeFunctional1564 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ANONYMOUS_TEMPLATE_in_attributeFunctional1574 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _INCLUDE_in_templateIncludeCompiled1592 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_templateIncludeCompiled1599 = new BitSet(new ulong[]{0x1FFFFFFFFFF0UL});
-		public static readonly BitSet _VALUE_in_templateIncludeCompiled1618 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _exprCompiled_in_templateIncludeCompiled1620 = new BitSet(new ulong[]{0x1FFFFFFFFFF0UL});
-		public static readonly BitSet _INCLUDE_in_templateIncludeFunctional1657 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_templateIncludeFunctional1664 = new BitSet(new ulong[]{0x1FFFFFFFFFF0UL});
-		public static readonly BitSet _VALUE_in_templateIncludeFunctional1677 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _exprFunctional_in_templateIncludeFunctional1679 = new BitSet(new ulong[]{0x1FFFFFFFFFF0UL});
-		public static readonly BitSet _FUNCTION_in_functionCompiled1712 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _FIRST_in_functionCompiled1719 = new BitSet(new ulong[]{0x800000000UL});
-		public static readonly BitSet _singleFunctionArgCompiled_in_functionCompiled1722 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _REST_in_functionCompiled1736 = new BitSet(new ulong[]{0x800000000UL});
-		public static readonly BitSet _singleFunctionArgCompiled_in_functionCompiled1739 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _LAST_in_functionCompiled1753 = new BitSet(new ulong[]{0x800000000UL});
-		public static readonly BitSet _singleFunctionArgCompiled_in_functionCompiled1756 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _LENGTH_in_functionCompiled1770 = new BitSet(new ulong[]{0x800000000UL});
-		public static readonly BitSet _singleFunctionArgCompiled_in_functionCompiled1772 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _STRIP_in_functionCompiled1786 = new BitSet(new ulong[]{0x800000000UL});
-		public static readonly BitSet _singleFunctionArgCompiled_in_functionCompiled1789 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _TRUNC_in_functionCompiled1803 = new BitSet(new ulong[]{0x800000000UL});
-		public static readonly BitSet _singleFunctionArgCompiled_in_functionCompiled1806 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _FUNCTION_in_functionFunctional1839 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _FIRST_in_functionFunctional1846 = new BitSet(new ulong[]{0x800000000UL});
-		public static readonly BitSet _singleFunctionArgFunctional_in_functionFunctional1851 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _REST_in_functionFunctional1864 = new BitSet(new ulong[]{0x800000000UL});
-		public static readonly BitSet _singleFunctionArgFunctional_in_functionFunctional1869 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _LAST_in_functionFunctional1882 = new BitSet(new ulong[]{0x800000000UL});
-		public static readonly BitSet _singleFunctionArgFunctional_in_functionFunctional1887 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _LENGTH_in_functionFunctional1900 = new BitSet(new ulong[]{0x800000000UL});
-		public static readonly BitSet _singleFunctionArgFunctional_in_functionFunctional1904 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _STRIP_in_functionFunctional1917 = new BitSet(new ulong[]{0x800000000UL});
-		public static readonly BitSet _singleFunctionArgFunctional_in_functionFunctional1922 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _TRUNC_in_functionFunctional1935 = new BitSet(new ulong[]{0x800000000UL});
-		public static readonly BitSet _singleFunctionArgFunctional_in_functionFunctional1940 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _LIST_in_listCompiled1974 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _exprCompiled_in_listCompiled1981 = new BitSet(new ulong[]{0x410628F0838UL});
-		public static readonly BitSet _NOTHING_in_listCompiled1995 = new BitSet(new ulong[]{0x410628F0838UL});
-		public static readonly BitSet _LIST_in_listFunctional2037 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _exprFunctional_in_listFunctional2044 = new BitSet(new ulong[]{0x410628F0838UL});
-		public static readonly BitSet _NOTHING_in_listFunctional2057 = new BitSet(new ulong[]{0x410628F0838UL});
-		public static readonly BitSet _SINGLEVALUEARG_in_singleFunctionArgCompiled2091 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _exprCompiled_in_singleFunctionArgCompiled2093 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _SINGLEVALUEARG_in_singleFunctionArgFunctional2113 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _exprFunctional_in_singleFunctionArgFunctional2115 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _TEMPLATE_in_templateCompiled2133 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_templateCompiled2140 = new BitSet(new ulong[]{0x1FFFFFFFFFF0UL});
-		public static readonly BitSet _ANONYMOUS_TEMPLATE_in_templateCompiled2161 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _VALUE_in_templateCompiled2177 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _exprCompiled_in_templateCompiled2181 = new BitSet(new ulong[]{0x1FFFFFFFFFF0UL});
-		public static readonly BitSet _TEMPLATE_in_templateFunctional2227 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_templateFunctional2234 = new BitSet(new ulong[]{0x1FFFFFFFFFF0UL});
-		public static readonly BitSet _ANONYMOUS_TEMPLATE_in_templateFunctional2255 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _VALUE_in_templateFunctional2271 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _expr_in_templateFunctional2275 = new BitSet(new ulong[]{0x1FFFFFFFFFF0UL});
-
-	}
-	#endregion Follow sets
-}
-
-} // namespace Antlr3.ST.Language
diff --git a/Antlr3.StringTemplate/Language/ActionLexer.cs b/Antlr3.StringTemplate/Language/ActionLexer.cs
deleted file mode 100644
index c7f1acb..0000000
--- a/Antlr3.StringTemplate/Language/ActionLexer.cs
+++ /dev/null
@@ -1,2922 +0,0 @@
-// $ANTLR 3.1.2 Language\\Action.g3 2009-09-30 13:22:28
-
-// The variable 'variable' is assigned but its value is never used.
-#pragma warning disable 219
-// Unreachable code detected.
-#pragma warning disable 162
-
-
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Grammar conversion to ANTLR v3 and C#:
- Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-	notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-	derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-
-using System.Collections.Generic;
-using Antlr.Runtime;
-using Stack = System.Collections.Generic.Stack<object>;
-using List = System.Collections.IList;
-using ArrayList = System.Collections.Generic.List<object>;
-using Map = System.Collections.IDictionary;
-using HashMap = System.Collections.Generic.Dictionary<object, object>;
-namespace  Antlr3.ST.Language
-{
-[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.1.2")]
-[System.CLSCompliant(false)]
-public partial class ActionLexer : Lexer
-{
-	public const int EOF=-1;
-	public const int ANONYMOUS_TEMPLATE=4;
-	public const int APPLY=5;
-	public const int ARGS=6;
-	public const int ASSIGN=7;
-	public const int COLON=8;
-	public const int COMMA=9;
-	public const int CONDITIONAL=10;
-	public const int DOT=11;
-	public const int DOTDOTDOT=12;
-	public const int ELSEIF=13;
-	public const int ESC_CHAR=14;
-	public const int FIRST=15;
-	public const int FUNCTION=16;
-	public const int ID=17;
-	public const int INCLUDE=18;
-	public const int INT=19;
-	public const int LAST=20;
-	public const int LBRACK=21;
-	public const int LENGTH=22;
-	public const int LIST=23;
-	public const int LPAREN=24;
-	public const int MULTI_APPLY=25;
-	public const int NESTED_ANONYMOUS_TEMPLATE=26;
-	public const int NEWLINE=27;
-	public const int NOT=28;
-	public const int NOTHING=29;
-	public const int PLUS=30;
-	public const int RBRACK=31;
-	public const int REST=32;
-	public const int RPAREN=33;
-	public const int SEMI=34;
-	public const int SINGLEVALUEARG=35;
-	public const int STRING=36;
-	public const int STRIP=37;
-	public const int SUPER=38;
-	public const int TEMPLATE=39;
-	public const int TEMPLATE_ARGS=40;
-	public const int TRUNC=41;
-	public const int VALUE=42;
-	public const int WS=43;
-	public const int WS_CHAR=44;
-
-    // delegates
-    // delegators
-
-	public ActionLexer() {}
-	public ActionLexer( ICharStream input )
-		: this( input, new RecognizerSharedState() )
-	{
-	}
-	public ActionLexer( ICharStream input, RecognizerSharedState state )
-		: base( input, state )
-	{
-
-	}
-	public override string GrammarFileName { get { return "Language\\Action.g3"; } }
-
-	// $ANTLR start "CONDITIONAL"
-	private void mCONDITIONAL()
-	{
-		try
-		{
-			int _type = CONDITIONAL;
-			int _channel = DefaultTokenChannel;
-			// Language\\Action.g3:42:15: ( 'if' )
-			// Language\\Action.g3:42:15: 'if'
-			{
-			Match("if"); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "CONDITIONAL"
-
-	// $ANTLR start "ELSEIF"
-	private void mELSEIF()
-	{
-		try
-		{
-			int _type = ELSEIF;
-			int _channel = DefaultTokenChannel;
-			// Language\\Action.g3:43:10: ( 'elseif' )
-			// Language\\Action.g3:43:10: 'elseif'
-			{
-			Match("elseif"); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ELSEIF"
-
-	// $ANTLR start "FIRST"
-	private void mFIRST()
-	{
-		try
-		{
-			int _type = FIRST;
-			int _channel = DefaultTokenChannel;
-			// Language\\Action.g3:44:9: ( 'first' )
-			// Language\\Action.g3:44:9: 'first'
-			{
-			Match("first"); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "FIRST"
-
-	// $ANTLR start "LAST"
-	private void mLAST()
-	{
-		try
-		{
-			int _type = LAST;
-			int _channel = DefaultTokenChannel;
-			// Language\\Action.g3:45:8: ( 'last' )
-			// Language\\Action.g3:45:8: 'last'
-			{
-			Match("last"); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "LAST"
-
-	// $ANTLR start "LENGTH"
-	private void mLENGTH()
-	{
-		try
-		{
-			int _type = LENGTH;
-			int _channel = DefaultTokenChannel;
-			// Language\\Action.g3:46:10: ( 'length' )
-			// Language\\Action.g3:46:10: 'length'
-			{
-			Match("length"); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "LENGTH"
-
-	// $ANTLR start "REST"
-	private void mREST()
-	{
-		try
-		{
-			int _type = REST;
-			int _channel = DefaultTokenChannel;
-			// Language\\Action.g3:47:8: ( 'rest' )
-			// Language\\Action.g3:47:8: 'rest'
-			{
-			Match("rest"); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "REST"
-
-	// $ANTLR start "STRIP"
-	private void mSTRIP()
-	{
-		try
-		{
-			int _type = STRIP;
-			int _channel = DefaultTokenChannel;
-			// Language\\Action.g3:48:9: ( 'strip' )
-			// Language\\Action.g3:48:9: 'strip'
-			{
-			Match("strip"); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "STRIP"
-
-	// $ANTLR start "SUPER"
-	private void mSUPER()
-	{
-		try
-		{
-			int _type = SUPER;
-			int _channel = DefaultTokenChannel;
-			// Language\\Action.g3:49:9: ( 'super' )
-			// Language\\Action.g3:49:9: 'super'
-			{
-			Match("super"); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "SUPER"
-
-	// $ANTLR start "TRUNC"
-	private void mTRUNC()
-	{
-		try
-		{
-			int _type = TRUNC;
-			int _channel = DefaultTokenChannel;
-			// Language\\Action.g3:50:9: ( 'trunc' )
-			// Language\\Action.g3:50:9: 'trunc'
-			{
-			Match("trunc"); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "TRUNC"
-
-	// $ANTLR start "ID"
-	private void mID()
-	{
-		try
-		{
-			int _type = ID;
-			int _channel = DefaultTokenChannel;
-			// Language\\Action.g3:335:4: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' | '/' )* )
-			// Language\\Action.g3:335:4: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' | '/' )*
-			{
-			if ( (input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z') )
-			{
-				input.Consume();
-			state.failed=false;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				MismatchedSetException mse = new MismatchedSetException(null,input);
-				Recover(mse);
-				throw mse;}
-
-			// Language\\Action.g3:335:28: ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' | '/' )*
-			for ( ; ; )
-			{
-				int alt1=2;
-				int LA1_0 = input.LA(1);
-
-				if ( ((LA1_0>='/' && LA1_0<='9')||(LA1_0>='A' && LA1_0<='Z')||LA1_0=='_'||(LA1_0>='a' && LA1_0<='z')) )
-				{
-					alt1=1;
-				}
-
-
-				switch ( alt1 )
-				{
-				case 1:
-					// Language\\Action.g3:
-					{
-					input.Consume();
-					state.failed=false;
-
-					}
-					break;
-
-				default:
-					goto loop1;
-				}
-			}
-
-			loop1:
-				;
-
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ID"
-
-	// $ANTLR start "INT"
-	private void mINT()
-	{
-		try
-		{
-			int _type = INT;
-			int _channel = DefaultTokenChannel;
-			// Language\\Action.g3:339:4: ( ( '0' .. '9' )+ )
-			// Language\\Action.g3:339:4: ( '0' .. '9' )+
-			{
-			// Language\\Action.g3:339:4: ( '0' .. '9' )+
-			int cnt2=0;
-			for ( ; ; )
-			{
-				int alt2=2;
-				int LA2_0 = input.LA(1);
-
-				if ( ((LA2_0>='0' && LA2_0<='9')) )
-				{
-					alt2=1;
-				}
-
-
-				switch ( alt2 )
-				{
-				case 1:
-					// Language\\Action.g3:
-					{
-					input.Consume();
-					state.failed=false;
-
-					}
-					break;
-
-				default:
-					if ( cnt2 >= 1 )
-						goto loop2;
-
-					if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee2 = new EarlyExitException( 2, input );
-					throw eee2;
-				}
-				cnt2++;
-			}
-			loop2:
-				;
-
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "INT"
-
-	// $ANTLR start "STRING"
-	private void mSTRING()
-	{
-		try
-		{
-			int _type = STRING;
-			int _channel = DefaultTokenChannel;
-			int ch;
-
-
-				char uc = '\0';
-				System.Text.StringBuilder builder = new System.Text.StringBuilder();
-
-			// Language\\Action.g3:348:4: ( '\"' ( ESC_CHAR[out uc, true] |ch=~ ( '\\\\' | '\"' ) )* '\"' )
-			// Language\\Action.g3:348:4: '\"' ( ESC_CHAR[out uc, true] |ch=~ ( '\\\\' | '\"' ) )* '\"'
-			{
-			Match('\"'); if (state.failed) return ;
-			// Language\\Action.g3:349:3: ( ESC_CHAR[out uc, true] |ch=~ ( '\\\\' | '\"' ) )*
-			for ( ; ; )
-			{
-				int alt3=3;
-				int LA3_0 = input.LA(1);
-
-				if ( (LA3_0=='\\') )
-				{
-					alt3=1;
-				}
-				else if ( ((LA3_0>='\u0000' && LA3_0<='!')||(LA3_0>='#' && LA3_0<='[')||(LA3_0>=']' && LA3_0<='\uFFFF')) )
-				{
-					alt3=2;
-				}
-
-
-				switch ( alt3 )
-				{
-				case 1:
-					// Language\\Action.g3:349:5: ESC_CHAR[out uc, true]
-					{
-					mESC_CHAR(out uc, true); if (state.failed) return ;
-					if ( state.backtracking == 0 )
-					{
-						builder.Append(uc);
-					}
-
-					}
-					break;
-				case 2:
-					// Language\\Action.g3:350:5: ch=~ ( '\\\\' | '\"' )
-					{
-					ch= input.LA(1);
-					input.Consume();
-					state.failed=false;
-					if ( state.backtracking == 0 )
-					{
-						builder.Append((char)ch);
-					}
-
-					}
-					break;
-
-				default:
-					goto loop3;
-				}
-			}
-
-			loop3:
-				;
-
-
-			Match('\"'); if (state.failed) return ;
-			if ( state.backtracking == 0 )
-			{
-
-							Text = builder.ToString();
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "STRING"
-
-	// $ANTLR start "ANONYMOUS_TEMPLATE"
-	private void mANONYMOUS_TEMPLATE()
-	{
-		try
-		{
-			int _type = ANONYMOUS_TEMPLATE;
-			int _channel = DefaultTokenChannel;
-			CommonToken ESC_CHAR1=null;
-			int ch;
-
-
-				StringTemplateToken t = null;
-				System.Text.StringBuilder builder = new System.Text.StringBuilder();
-				List<string> args = new List<string>();
-				string subtext = string.Empty;
-				char uc = '\0';
-
-			// Language\\Action.g3:367:4: ( '{' (=> TEMPLATE_ARGS[out subtext, args] (=> WS_CHAR )? |) (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '\\\\' | '{' | '}' ) )* '}' )
-			// Language\\Action.g3:367:4: '{' (=> TEMPLATE_ARGS[out subtext, args] (=> WS_CHAR )? |) (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '\\\\' | '{' | '}' ) )* '}'
-			{
-			Match('{'); if (state.failed) return ;
-			// Language\\Action.g3:368:3: (=> TEMPLATE_ARGS[out subtext, args] (=> WS_CHAR )? |)
-			int alt5=2;
-			alt5 = dfa5.Predict(input);
-			switch ( alt5 )
-			{
-			case 1:
-				// Language\\Action.g3:368:5: => TEMPLATE_ARGS[out subtext, args] (=> WS_CHAR )?
-				{
-
-				mTEMPLATE_ARGS(out subtext, args); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-					builder.Append(subtext);
-				}
-				// Language\\Action.g3:368:82: (=> WS_CHAR )?
-				int alt4=2;
-				switch ( input.LA(1) )
-				{
-				case ' ':
-					{
-					int LA4_1 = input.LA(2);
-
-					if ( (EvaluatePredicate(synpred2_Action_fragment)) )
-					{
-						alt4=1;
-					}
-					}
-					break;
-				case '\t':
-					{
-					int LA4_2 = input.LA(2);
-
-					if ( (EvaluatePredicate(synpred2_Action_fragment)) )
-					{
-						alt4=1;
-					}
-					}
-					break;
-				case '\r':
-					{
-					int LA4_3 = input.LA(2);
-
-					if ( (EvaluatePredicate(synpred2_Action_fragment)) )
-					{
-						alt4=1;
-					}
-					}
-					break;
-				case '\n':
-					{
-					int LA4_4 = input.LA(2);
-
-					if ( (EvaluatePredicate(synpred2_Action_fragment)) )
-					{
-						alt4=1;
-					}
-					}
-					break;
-				}
-
-				switch ( alt4 )
-				{
-				case 1:
-					// Language\\Action.g3:368:83: => WS_CHAR
-					{
-
-					mWS_CHAR(); if (state.failed) return ;
-
-					}
-					break;
-
-				}
-
-				if ( state.backtracking == 0 )
-				{
-
-									// create a special token to track args
-									t = new StringTemplateToken(ANONYMOUS_TEMPLATE,Text,args);
-									//setToken(t);
-									state.token = t;
-
-				}
-
-				}
-				break;
-			case 2:
-				// Language\\Action.g3:376:3:
-				{
-
-
-				}
-				break;
-
-			}
-
-			// Language\\Action.g3:377:3: (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '\\\\' | '{' | '}' ) )*
-			for ( ; ; )
-			{
-				int alt6=6;
-				alt6 = dfa6.Predict(input);
-				switch ( alt6 )
-				{
-				case 1:
-					// Language\\Action.g3:377:5: => '\\\\{'
-					{
-
-					Match("\\{"); if (state.failed) return ;
-
-					if ( state.backtracking == 0 )
-					{
-						builder.Append( '{' );
-					}
-
-					}
-					break;
-				case 2:
-					// Language\\Action.g3:378:5: => '\\\\}'
-					{
-
-					Match("\\}"); if (state.failed) return ;
-
-					if ( state.backtracking == 0 )
-					{
-						builder.Append( '}' );
-					}
-
-					}
-					break;
-				case 3:
-					// Language\\Action.g3:379:5: ESC_CHAR[out uc, false]
-					{
-					int ESC_CHAR1Start300 = CharIndex;
-					mESC_CHAR(out uc, false); if (state.failed) return ;
-					ESC_CHAR1 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ESC_CHAR1Start300, CharIndex-1);
-					if ( state.backtracking == 0 )
-					{
-						builder.Append( (ESC_CHAR1!=null?ESC_CHAR1.Text:null) );
-					}
-
-					}
-					break;
-				case 4:
-					// Language\\Action.g3:380:5: NESTED_ANONYMOUS_TEMPLATE[out subtext]
-					{
-					mNESTED_ANONYMOUS_TEMPLATE(out subtext); if (state.failed) return ;
-					if ( state.backtracking == 0 )
-					{
-						builder.Append(subtext);
-					}
-
-					}
-					break;
-				case 5:
-					// Language\\Action.g3:381:5: ch=~ ( '\\\\' | '{' | '}' )
-					{
-					ch= input.LA(1);
-					input.Consume();
-					state.failed=false;
-					if ( state.backtracking == 0 )
-					{
-						builder.Append((char)ch);
-					}
-
-					}
-					break;
-
-				default:
-					goto loop6;
-				}
-			}
-
-			loop6:
-				;
-
-
-			if ( state.backtracking == 0 )
-			{
-
-							Text = builder.ToString();
-							if ( t!=null )
-								t.Text = Text;
-
-			}
-			Match('}'); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ANONYMOUS_TEMPLATE"
-
-	// $ANTLR start "TEMPLATE_ARGS"
-	private void mTEMPLATE_ARGS(out string _text, List<string> args)
-	{
-		try
-		{
-			CommonToken a=null;
-			CommonToken a2=null;
-
-
-				_text = string.Empty; // this template is empty text
-				args.Clear();
-
-			// Language\\Action.g3:399:4: ( ( WS_CHAR )? a= ID ( ( WS_CHAR )? ',' ( WS_CHAR )? a2= ID )* ( WS_CHAR )? '|' )
-			// Language\\Action.g3:399:4: ( WS_CHAR )? a= ID ( ( WS_CHAR )? ',' ( WS_CHAR )? a2= ID )* ( WS_CHAR )? '|'
-			{
-			// Language\\Action.g3:399:4: ( WS_CHAR )?
-			int alt7=2;
-			int LA7_0 = input.LA(1);
-
-			if ( ((LA7_0>='\t' && LA7_0<='\n')||LA7_0=='\r'||LA7_0==' ') )
-			{
-				alt7=1;
-			}
-			switch ( alt7 )
-			{
-			case 1:
-				// Language\\Action.g3:399:5: WS_CHAR
-				{
-				mWS_CHAR(); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-			int aStart368 = CharIndex;
-			mID(); if (state.failed) return ;
-			a = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, aStart368, CharIndex-1);
-			if ( state.backtracking == 0 )
-			{
-				args.Add((a!=null?a.Text:null));
-			}
-			// Language\\Action.g3:400:3: ( ( WS_CHAR )? ',' ( WS_CHAR )? a2= ID )*
-			for ( ; ; )
-			{
-				int alt10=2;
-				switch ( input.LA(1) )
-				{
-				case ' ':
-					{
-					int LA10_1 = input.LA(2);
-
-					if ( (LA10_1==',') )
-					{
-						alt10=1;
-					}
-
-
-					}
-					break;
-				case '\t':
-					{
-					int LA10_2 = input.LA(2);
-
-					if ( (LA10_2==',') )
-					{
-						alt10=1;
-					}
-
-
-					}
-					break;
-				case '\r':
-					{
-					int LA10_3 = input.LA(2);
-
-					if ( (LA10_3=='\n') )
-					{
-						int LA10_7 = input.LA(3);
-
-						if ( (LA10_7==',') )
-						{
-							alt10=1;
-						}
-
-
-					}
-					else if ( (LA10_3==',') )
-					{
-						alt10=1;
-					}
-
-
-					}
-					break;
-				case '\n':
-					{
-					int LA10_4 = input.LA(2);
-
-					if ( (LA10_4==',') )
-					{
-						alt10=1;
-					}
-
-
-					}
-					break;
-				case ',':
-					{
-					alt10=1;
-					}
-					break;
-
-				}
-
-				switch ( alt10 )
-				{
-				case 1:
-					// Language\\Action.g3:400:5: ( WS_CHAR )? ',' ( WS_CHAR )? a2= ID
-					{
-					// Language\\Action.g3:400:5: ( WS_CHAR )?
-					int alt8=2;
-					int LA8_0 = input.LA(1);
-
-					if ( ((LA8_0>='\t' && LA8_0<='\n')||LA8_0=='\r'||LA8_0==' ') )
-					{
-						alt8=1;
-					}
-					switch ( alt8 )
-					{
-					case 1:
-						// Language\\Action.g3:400:6: WS_CHAR
-						{
-						mWS_CHAR(); if (state.failed) return ;
-
-						}
-						break;
-
-					}
-
-					Match(','); if (state.failed) return ;
-					// Language\\Action.g3:400:20: ( WS_CHAR )?
-					int alt9=2;
-					int LA9_0 = input.LA(1);
-
-					if ( ((LA9_0>='\t' && LA9_0<='\n')||LA9_0=='\r'||LA9_0==' ') )
-					{
-						alt9=1;
-					}
-					switch ( alt9 )
-					{
-					case 1:
-						// Language\\Action.g3:400:21: WS_CHAR
-						{
-						mWS_CHAR(); if (state.failed) return ;
-
-						}
-						break;
-
-					}
-
-					int a2Start390 = CharIndex;
-					mID(); if (state.failed) return ;
-					a2 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, a2Start390, CharIndex-1);
-					if ( state.backtracking == 0 )
-					{
-						args.Add((a2!=null?a2.Text:null));
-					}
-
-					}
-					break;
-
-				default:
-					goto loop10;
-				}
-			}
-
-			loop10:
-				;
-
-
-			// Language\\Action.g3:401:3: ( WS_CHAR )?
-			int alt11=2;
-			int LA11_0 = input.LA(1);
-
-			if ( ((LA11_0>='\t' && LA11_0<='\n')||LA11_0=='\r'||LA11_0==' ') )
-			{
-				alt11=1;
-			}
-			switch ( alt11 )
-			{
-			case 1:
-				// Language\\Action.g3:401:4: WS_CHAR
-				{
-				mWS_CHAR(); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-			Match('|'); if (state.failed) return ;
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "TEMPLATE_ARGS"
-
-	// $ANTLR start "NESTED_ANONYMOUS_TEMPLATE"
-	private void mNESTED_ANONYMOUS_TEMPLATE(out string _text)
-	{
-		try
-		{
-			CommonToken ESC_CHAR2=null;
-			int ch;
-
-
-				_text = string.Empty;
-				char uc = '\0';
-				string subtext = string.Empty;
-				System.Text.StringBuilder builder = new System.Text.StringBuilder();
-
-			// Language\\Action.g3:413:4: ( '{' (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '{' | '}' | '\\\\' ) )* '}' )
-			// Language\\Action.g3:413:4: '{' (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '{' | '}' | '\\\\' ) )* '}'
-			{
-			Match('{'); if (state.failed) return ;
-			if ( state.backtracking == 0 )
-			{
-				builder.Append('{');
-			}
-			// Language\\Action.g3:415:3: (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '{' | '}' | '\\\\' ) )*
-			for ( ; ; )
-			{
-				int alt12=6;
-				alt12 = dfa12.Predict(input);
-				switch ( alt12 )
-				{
-				case 1:
-					// Language\\Action.g3:415:5: => '\\\\{'
-					{
-
-					Match("\\{"); if (state.failed) return ;
-
-					if ( state.backtracking == 0 )
-					{
-						builder.Append('{');
-					}
-
-					}
-					break;
-				case 2:
-					// Language\\Action.g3:416:5: => '\\\\}'
-					{
-
-					Match("\\}"); if (state.failed) return ;
-
-					if ( state.backtracking == 0 )
-					{
-						builder.Append('}');
-					}
-
-					}
-					break;
-				case 3:
-					// Language\\Action.g3:417:5: ESC_CHAR[out uc, false]
-					{
-					int ESC_CHAR2Start460 = CharIndex;
-					mESC_CHAR(out uc, false); if (state.failed) return ;
-					ESC_CHAR2 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ESC_CHAR2Start460, CharIndex-1);
-					if ( state.backtracking == 0 )
-					{
-						builder.Append((ESC_CHAR2!=null?ESC_CHAR2.Text:null));
-					}
-
-					}
-					break;
-				case 4:
-					// Language\\Action.g3:418:5: NESTED_ANONYMOUS_TEMPLATE[out subtext]
-					{
-					mNESTED_ANONYMOUS_TEMPLATE(out subtext); if (state.failed) return ;
-					if ( state.backtracking == 0 )
-					{
-						builder.Append(subtext);
-					}
-
-					}
-					break;
-				case 5:
-					// Language\\Action.g3:419:5: ch=~ ( '{' | '}' | '\\\\' )
-					{
-					ch= input.LA(1);
-					input.Consume();
-					state.failed=false;
-					if ( state.backtracking == 0 )
-					{
-						builder.Append((char)ch);
-					}
-
-					}
-					break;
-
-				default:
-					goto loop12;
-				}
-			}
-
-			loop12:
-				;
-
-
-			Match('}'); if (state.failed) return ;
-			if ( state.backtracking == 0 )
-			{
-
-							builder.Append('}');
-							_text = builder.ToString();
-
-			}
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "NESTED_ANONYMOUS_TEMPLATE"
-
-	// $ANTLR start "ESC_CHAR"
-	private void mESC_CHAR(out char uc, bool doEscape)
-	{
-		try
-		{
-			int c;
-
-
-				uc = '\0';
-
-			// Language\\Action.g3:440:4: ( '\\\\' ( 'n' | 'r' | 't' | 'b' | 'f' |c=~ ( 'n' | 'r' | 't' | 'b' | 'f' ) ) )
-			// Language\\Action.g3:440:4: '\\\\' ( 'n' | 'r' | 't' | 'b' | 'f' |c=~ ( 'n' | 'r' | 't' | 'b' | 'f' ) )
-			{
-			Match('\\'); if (state.failed) return ;
-			// Language\\Action.g3:441:3: ( 'n' | 'r' | 't' | 'b' | 'f' |c=~ ( 'n' | 'r' | 't' | 'b' | 'f' ) )
-			int alt13=6;
-			int LA13_0 = input.LA(1);
-
-			if ( (LA13_0=='n') )
-			{
-				alt13=1;
-			}
-			else if ( (LA13_0=='r') )
-			{
-				alt13=2;
-			}
-			else if ( (LA13_0=='t') )
-			{
-				alt13=3;
-			}
-			else if ( (LA13_0=='b') )
-			{
-				alt13=4;
-			}
-			else if ( (LA13_0=='f') )
-			{
-				alt13=5;
-			}
-			else if ( ((LA13_0>='\u0000' && LA13_0<='a')||(LA13_0>='c' && LA13_0<='e')||(LA13_0>='g' && LA13_0<='m')||(LA13_0>='o' && LA13_0<='q')||LA13_0=='s'||(LA13_0>='u' && LA13_0<='\uFFFF')) )
-			{
-				alt13=6;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				NoViableAltException nvae = new NoViableAltException("", 13, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt13 )
-			{
-			case 1:
-				// Language\\Action.g3:441:5: 'n'
-				{
-				Match('n'); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-					if (doEscape) { uc = '\n'; }
-				}
-
-				}
-				break;
-			case 2:
-				// Language\\Action.g3:442:5: 'r'
-				{
-				Match('r'); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-					if (doEscape) { uc = '\r'; }
-				}
-
-				}
-				break;
-			case 3:
-				// Language\\Action.g3:443:5: 't'
-				{
-				Match('t'); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-					if (doEscape) { uc = '\t'; }
-				}
-
-				}
-				break;
-			case 4:
-				// Language\\Action.g3:444:5: 'b'
-				{
-				Match('b'); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-					if (doEscape) { uc = '\b'; }
-				}
-
-				}
-				break;
-			case 5:
-				// Language\\Action.g3:445:5: 'f'
-				{
-				Match('f'); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-					if (doEscape) { uc = '\f'; }
-				}
-
-				}
-				break;
-			case 6:
-				// Language\\Action.g3:446:5: c=~ ( 'n' | 'r' | 't' | 'b' | 'f' )
-				{
-				c= input.LA(1);
-				input.Consume();
-				state.failed=false;
-				if ( state.backtracking == 0 )
-				{
-					if (doEscape) { uc = (char)c; }
-				}
-
-				}
-				break;
-
-			}
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ESC_CHAR"
-
-	// $ANTLR start "LBRACK"
-	private void mLBRACK()
-	{
-		try
-		{
-			int _type = LBRACK;
-			int _channel = DefaultTokenChannel;
-			// Language\\Action.g3:446:11: ( '[' )
-			// Language\\Action.g3:446:11: '['
-			{
-			Match('['); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "LBRACK"
-
-	// $ANTLR start "RBRACK"
-	private void mRBRACK()
-	{
-		try
-		{
-			int _type = RBRACK;
-			int _channel = DefaultTokenChannel;
-			// Language\\Action.g3:447:11: ( ']' )
-			// Language\\Action.g3:447:11: ']'
-			{
-			Match(']'); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "RBRACK"
-
-	// $ANTLR start "LPAREN"
-	private void mLPAREN()
-	{
-		try
-		{
-			int _type = LPAREN;
-			int _channel = DefaultTokenChannel;
-			// Language\\Action.g3:448:11: ( '(' )
-			// Language\\Action.g3:448:11: '('
-			{
-			Match('('); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "LPAREN"
-
-	// $ANTLR start "RPAREN"
-	private void mRPAREN()
-	{
-		try
-		{
-			int _type = RPAREN;
-			int _channel = DefaultTokenChannel;
-			// Language\\Action.g3:449:11: ( ')' )
-			// Language\\Action.g3:449:11: ')'
-			{
-			Match(')'); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "RPAREN"
-
-	// $ANTLR start "COMMA"
-	private void mCOMMA()
-	{
-		try
-		{
-			int _type = COMMA;
-			int _channel = DefaultTokenChannel;
-			// Language\\Action.g3:450:10: ( ',' )
-			// Language\\Action.g3:450:10: ','
-			{
-			Match(','); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "COMMA"
-
-	// $ANTLR start "DOT"
-	private void mDOT()
-	{
-		try
-		{
-			int _type = DOT;
-			int _channel = DefaultTokenChannel;
-			// Language\\Action.g3:451:9: ( '.' )
-			// Language\\Action.g3:451:9: '.'
-			{
-			Match('.'); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "DOT"
-
-	// $ANTLR start "ASSIGN"
-	private void mASSIGN()
-	{
-		try
-		{
-			int _type = ASSIGN;
-			int _channel = DefaultTokenChannel;
-			// Language\\Action.g3:452:11: ( '=' )
-			// Language\\Action.g3:452:11: '='
-			{
-			Match('='); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ASSIGN"
-
-	// $ANTLR start "COLON"
-	private void mCOLON()
-	{
-		try
-		{
-			int _type = COLON;
-			int _channel = DefaultTokenChannel;
-			// Language\\Action.g3:453:10: ( ':' )
-			// Language\\Action.g3:453:10: ':'
-			{
-			Match(':'); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "COLON"
-
-	// $ANTLR start "PLUS"
-	private void mPLUS()
-	{
-		try
-		{
-			int _type = PLUS;
-			int _channel = DefaultTokenChannel;
-			// Language\\Action.g3:454:9: ( '+' )
-			// Language\\Action.g3:454:9: '+'
-			{
-			Match('+'); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "PLUS"
-
-	// $ANTLR start "SEMI"
-	private void mSEMI()
-	{
-		try
-		{
-			int _type = SEMI;
-			int _channel = DefaultTokenChannel;
-			// Language\\Action.g3:455:9: ( ';' )
-			// Language\\Action.g3:455:9: ';'
-			{
-			Match(';'); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "SEMI"
-
-	// $ANTLR start "NOT"
-	private void mNOT()
-	{
-		try
-		{
-			int _type = NOT;
-			int _channel = DefaultTokenChannel;
-			// Language\\Action.g3:456:9: ( '!' )
-			// Language\\Action.g3:456:9: '!'
-			{
-			Match('!'); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "NOT"
-
-	// $ANTLR start "DOTDOTDOT"
-	private void mDOTDOTDOT()
-	{
-		try
-		{
-			int _type = DOTDOTDOT;
-			int _channel = DefaultTokenChannel;
-			// Language\\Action.g3:457:13: ( '...' )
-			// Language\\Action.g3:457:13: '...'
-			{
-			Match("..."); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "DOTDOTDOT"
-
-	// $ANTLR start "WS"
-	private void mWS()
-	{
-		try
-		{
-			int _type = WS;
-			int _channel = DefaultTokenChannel;
-			// Language\\Action.g3:460:4: ( ( ' ' | '\\t' | '\\r' | '\\n' )+ )
-			// Language\\Action.g3:460:4: ( ' ' | '\\t' | '\\r' | '\\n' )+
-			{
-			// Language\\Action.g3:460:4: ( ' ' | '\\t' | '\\r' | '\\n' )+
-			int cnt14=0;
-			for ( ; ; )
-			{
-				int alt14=2;
-				int LA14_0 = input.LA(1);
-
-				if ( ((LA14_0>='\t' && LA14_0<='\n')||LA14_0=='\r'||LA14_0==' ') )
-				{
-					alt14=1;
-				}
-
-
-				switch ( alt14 )
-				{
-				case 1:
-					// Language\\Action.g3:
-					{
-					input.Consume();
-					state.failed=false;
-
-					}
-					break;
-
-				default:
-					if ( cnt14 >= 1 )
-						goto loop14;
-
-					if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee14 = new EarlyExitException( 14, input );
-					throw eee14;
-				}
-				cnt14++;
-			}
-			loop14:
-				;
-
-
-			if ( state.backtracking == 0 )
-			{
-				_channel = Hidden;
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "WS"
-
-	// $ANTLR start "WS_CHAR"
-	private void mWS_CHAR()
-	{
-		try
-		{
-			// Language\\Action.g3:467:4: ( ' ' | '\\t' | NEWLINE )
-			int alt15=3;
-			switch ( input.LA(1) )
-			{
-			case ' ':
-				{
-				alt15=1;
-				}
-				break;
-			case '\t':
-				{
-				alt15=2;
-				}
-				break;
-			case '\n':
-			case '\r':
-				{
-				alt15=3;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					NoViableAltException nvae = new NoViableAltException("", 15, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt15 )
-			{
-			case 1:
-				// Language\\Action.g3:467:4: ' '
-				{
-				Match(' '); if (state.failed) return ;
-
-				}
-				break;
-			case 2:
-				// Language\\Action.g3:467:8: '\\t'
-				{
-				Match('\t'); if (state.failed) return ;
-
-				}
-				break;
-			case 3:
-				// Language\\Action.g3:467:13: NEWLINE
-				{
-				mNEWLINE(); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "WS_CHAR"
-
-	// $ANTLR start "NEWLINE"
-	private void mNEWLINE()
-	{
-		try
-		{
-			// Language\\Action.g3:472:4: ( '\\r' (=> '\\n' )? | '\\n' )
-			int alt17=2;
-			int LA17_0 = input.LA(1);
-
-			if ( (LA17_0=='\r') )
-			{
-				alt17=1;
-			}
-			else if ( (LA17_0=='\n') )
-			{
-				alt17=2;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				NoViableAltException nvae = new NoViableAltException("", 17, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt17 )
-			{
-			case 1:
-				// Language\\Action.g3:472:4: '\\r' (=> '\\n' )?
-				{
-				Match('\r'); if (state.failed) return ;
-				// Language\\Action.g3:472:9: (=> '\\n' )?
-				int alt16=2;
-				int LA16_0 = input.LA(1);
-
-				if ( (LA16_0=='\n') && (EvaluatePredicate(synpred7_Action_fragment)))
-				{
-					alt16=1;
-				}
-				switch ( alt16 )
-				{
-				case 1:
-					// Language\\Action.g3:472:10: => '\\n'
-					{
-
-					Match('\n'); if (state.failed) return ;
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-			case 2:
-				// Language\\Action.g3:473:4: '\\n'
-				{
-				Match('\n'); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "NEWLINE"
-
-	public override void mTokens()
-	{
-		// Language\\Action.g3:1:10: ( CONDITIONAL | ELSEIF | FIRST | LAST | LENGTH | REST | STRIP | SUPER | TRUNC | ID | INT | STRING | ANONYMOUS_TEMPLATE | LBRACK | RBRACK | LPAREN | RPAREN | COMMA | DOT | ASSIGN | COLON | PLUS | SEMI | NOT | DOTDOTDOT | WS )
-		int alt18=26;
-		alt18 = dfa18.Predict(input);
-		switch ( alt18 )
-		{
-		case 1:
-			// Language\\Action.g3:1:10: CONDITIONAL
-			{
-			mCONDITIONAL(); if (state.failed) return ;
-
-			}
-			break;
-		case 2:
-			// Language\\Action.g3:1:22: ELSEIF
-			{
-			mELSEIF(); if (state.failed) return ;
-
-			}
-			break;
-		case 3:
-			// Language\\Action.g3:1:29: FIRST
-			{
-			mFIRST(); if (state.failed) return ;
-
-			}
-			break;
-		case 4:
-			// Language\\Action.g3:1:35: LAST
-			{
-			mLAST(); if (state.failed) return ;
-
-			}
-			break;
-		case 5:
-			// Language\\Action.g3:1:40: LENGTH
-			{
-			mLENGTH(); if (state.failed) return ;
-
-			}
-			break;
-		case 6:
-			// Language\\Action.g3:1:47: REST
-			{
-			mREST(); if (state.failed) return ;
-
-			}
-			break;
-		case 7:
-			// Language\\Action.g3:1:52: STRIP
-			{
-			mSTRIP(); if (state.failed) return ;
-
-			}
-			break;
-		case 8:
-			// Language\\Action.g3:1:58: SUPER
-			{
-			mSUPER(); if (state.failed) return ;
-
-			}
-			break;
-		case 9:
-			// Language\\Action.g3:1:64: TRUNC
-			{
-			mTRUNC(); if (state.failed) return ;
-
-			}
-			break;
-		case 10:
-			// Language\\Action.g3:1:70: ID
-			{
-			mID(); if (state.failed) return ;
-
-			}
-			break;
-		case 11:
-			// Language\\Action.g3:1:73: INT
-			{
-			mINT(); if (state.failed) return ;
-
-			}
-			break;
-		case 12:
-			// Language\\Action.g3:1:77: STRING
-			{
-			mSTRING(); if (state.failed) return ;
-
-			}
-			break;
-		case 13:
-			// Language\\Action.g3:1:84: ANONYMOUS_TEMPLATE
-			{
-			mANONYMOUS_TEMPLATE(); if (state.failed) return ;
-
-			}
-			break;
-		case 14:
-			// Language\\Action.g3:1:103: LBRACK
-			{
-			mLBRACK(); if (state.failed) return ;
-
-			}
-			break;
-		case 15:
-			// Language\\Action.g3:1:110: RBRACK
-			{
-			mRBRACK(); if (state.failed) return ;
-
-			}
-			break;
-		case 16:
-			// Language\\Action.g3:1:117: LPAREN
-			{
-			mLPAREN(); if (state.failed) return ;
-
-			}
-			break;
-		case 17:
-			// Language\\Action.g3:1:124: RPAREN
-			{
-			mRPAREN(); if (state.failed) return ;
-
-			}
-			break;
-		case 18:
-			// Language\\Action.g3:1:131: COMMA
-			{
-			mCOMMA(); if (state.failed) return ;
-
-			}
-			break;
-		case 19:
-			// Language\\Action.g3:1:137: DOT
-			{
-			mDOT(); if (state.failed) return ;
-
-			}
-			break;
-		case 20:
-			// Language\\Action.g3:1:141: ASSIGN
-			{
-			mASSIGN(); if (state.failed) return ;
-
-			}
-			break;
-		case 21:
-			// Language\\Action.g3:1:148: COLON
-			{
-			mCOLON(); if (state.failed) return ;
-
-			}
-			break;
-		case 22:
-			// Language\\Action.g3:1:154: PLUS
-			{
-			mPLUS(); if (state.failed) return ;
-
-			}
-			break;
-		case 23:
-			// Language\\Action.g3:1:159: SEMI
-			{
-			mSEMI(); if (state.failed) return ;
-
-			}
-			break;
-		case 24:
-			// Language\\Action.g3:1:164: NOT
-			{
-			mNOT(); if (state.failed) return ;
-
-			}
-			break;
-		case 25:
-			// Language\\Action.g3:1:168: DOTDOTDOT
-			{
-			mDOTDOTDOT(); if (state.failed) return ;
-
-			}
-			break;
-		case 26:
-			// Language\\Action.g3:1:178: WS
-			{
-			mWS(); if (state.failed) return ;
-
-			}
-			break;
-
-		}
-
-	}
-
-	// $ANTLR start synpred1_Action
-	public void synpred1_Action_fragment()
-	{
-		// Language\\Action.g3:368:5: ( ( WS_CHAR )? ID )
-		// Language\\Action.g3:368:6: ( WS_CHAR )? ID
-		{
-		// Language\\Action.g3:368:6: ( WS_CHAR )?
-		int alt19=2;
-		int LA19_0 = input.LA(1);
-
-		if ( ((LA19_0>='\t' && LA19_0<='\n')||LA19_0=='\r'||LA19_0==' ') )
-		{
-			alt19=1;
-		}
-		switch ( alt19 )
-		{
-		case 1:
-			// Language\\Action.g3:368:0: WS_CHAR
-			{
-			mWS_CHAR(); if (state.failed) return ;
-
-			}
-			break;
-
-		}
-
-		mID(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred1_Action
-
-	// $ANTLR start synpred2_Action
-	public void synpred2_Action_fragment()
-	{
-		// Language\\Action.g3:368:83: ( WS_CHAR )
-		// Language\\Action.g3:368:84: WS_CHAR
-		{
-		mWS_CHAR(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred2_Action
-
-	// $ANTLR start synpred3_Action
-	public void synpred3_Action_fragment()
-	{
-		// Language\\Action.g3:377:5: ( '\\\\{' )
-		// Language\\Action.g3:377:6: '\\\\{'
-		{
-		Match("\\{"); if (state.failed) return ;
-
-
-		}
-	}
-	// $ANTLR end synpred3_Action
-
-	// $ANTLR start synpred4_Action
-	public void synpred4_Action_fragment()
-	{
-		// Language\\Action.g3:378:5: ( '\\\\}' )
-		// Language\\Action.g3:378:6: '\\\\}'
-		{
-		Match("\\}"); if (state.failed) return ;
-
-
-		}
-	}
-	// $ANTLR end synpred4_Action
-
-	// $ANTLR start synpred5_Action
-	public void synpred5_Action_fragment()
-	{
-		// Language\\Action.g3:415:5: ( '\\\\{' )
-		// Language\\Action.g3:415:6: '\\\\{'
-		{
-		Match("\\{"); if (state.failed) return ;
-
-
-		}
-	}
-	// $ANTLR end synpred5_Action
-
-	// $ANTLR start synpred6_Action
-	public void synpred6_Action_fragment()
-	{
-		// Language\\Action.g3:416:5: ( '\\\\}' )
-		// Language\\Action.g3:416:6: '\\\\}'
-		{
-		Match("\\}"); if (state.failed) return ;
-
-
-		}
-	}
-	// $ANTLR end synpred6_Action
-
-	// $ANTLR start synpred7_Action
-	public void synpred7_Action_fragment()
-	{
-		// Language\\Action.g3:472:10: ( '\\n' )
-		// Language\\Action.g3:472:11: '\\n'
-		{
-		Match('\n'); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred7_Action
-
-	#region Synpreds
-	bool EvaluatePredicate( System.Action fragment )
-	{
-		state.backtracking++;
-		int start = input.Mark();
-		try
-		{
-			fragment();
-		}
-		catch ( RecognitionException re )
-		{
-			System.Console.Error.WriteLine("impossible: "+re);
-		}
-		bool success = !state.failed;
-		input.Rewind(start);
-		state.backtracking--;
-		state.failed=false;
-		return success;
-	}
-	#endregion Synpreds
-
-
-	#region DFA
-	DFA5 dfa5;
-	DFA6 dfa6;
-	DFA12 dfa12;
-	DFA18 dfa18;
-
-	protected override void InitDFAs()
-	{
-		base.InitDFAs();
-		dfa5 = new DFA5( this, new SpecialStateTransitionHandler( specialStateTransition5 ) );
-		dfa6 = new DFA6( this, new SpecialStateTransitionHandler( specialStateTransition6 ) );
-		dfa12 = new DFA12( this, new SpecialStateTransitionHandler( specialStateTransition12 ) );
-		dfa18 = new DFA18( this );
-	}
-
-	class DFA5 : DFA
-	{
-
-		const string DFA5_eotS =
-			"\x1D\xFFFF";
-		const string DFA5_eofS =
-			"\x1D\xFFFF";
-		const string DFA5_minS =
-			"\x6\x0\x1\xFFFF\xE\x0\x1\xFFFF\x7\x0";
-		const string DFA5_maxS =
-			"\x6\xFFFF\x1\xFFFF\x7\xFFFF\x1\x0\x6\xFFFF\x1\xFFFF\x7\xFFFF";
-		const string DFA5_acceptS =
-			"\x6\xFFFF\x1\x2\xE\xFFFF\x1\x1\x7\xFFFF";
-		const string DFA5_specialS =
-			"\x1\x0\x1\x1\x1\x2\x1\x3\x1\x4\x1\x5\x1\xFFFF\x1\x6\x1\x7\x1\x8\x1\x9"+
-			"\x1\xA\x1\xB\x1\xC\x1\xD\x1\xE\x1\xF\x1\x10\x1\x11\x1\x12\x1\x13\x1\xFFFF"+
-			"\x1\x14\x1\x15\x1\x16\x1\x17\x1\x18\x1\x19\x1\x1A}>";
-		static readonly string[] DFA5_transitionS =
-			{
-				"\x9\x6\x1\x2\x1\x4\x2\x6\x1\x3\x12\x6\x1\x1\x20\x6\x1A\x5\x4\x6\x1\x5"+
-				"\x1\x6\x1A\x5\xFF85\x6",
-				"\x41\x6\x1A\x5\x4\x6\x1\x5\x1\x6\x1A\x5\xFF85\x6",
-				"\x41\x6\x1A\x5\x4\x6\x1\x5\x1\x6\x1A\x5\xFF85\x6",
-				"\xA\x6\x1\x7\x36\x6\x1A\x5\x4\x6\x1\x5\x1\x6\x1A\x5\xFF85\x6",
-				"\x41\x6\x1A\x5\x4\x6\x1\x5\x1\x6\x1A\x5\xFF85\x6",
-				"\x9\x6\x1\xA\x1\xC\x2\x6\x1\xB\x12\x6\x1\x9\xB\x6\x1\xD\x2\x6\xB\x8"+
-				"\x7\x6\x1A\x8\x4\x6\x1\x8\x1\x6\x1A\x8\x1\x6\x1\xE\xFF83\x6",
-				"",
-				"\x41\x6\x1A\x5\x4\x6\x1\x5\x1\x6\x1A\x5\xFF85\x6",
-				"\x9\x6\x1\xA\x1\xC\x2\x6\x1\xB\x12\x6\x1\x9\xB\x6\x1\xD\x2\x6\xB\x8"+
-				"\x7\x6\x1A\x8\x4\x6\x1\x8\x1\x6\x1A\x8\x1\x6\x1\xE\xFF83\x6",
-				"\x2C\x6\x1\xD\x4F\x6\x1\xE\xFF83\x6",
-				"\x2C\x6\x1\xD\x4F\x6\x1\xE\xFF83\x6",
-				"\xA\x6\x1\xF\x21\x6\x1\xD\x4F\x6\x1\xE\xFF83\x6",
-				"\x2C\x6\x1\xD\x4F\x6\x1\xE\xFF83\x6",
-				"\x9\x6\x1\x11\x1\x13\x2\x6\x1\x12\x12\x6\x1\x10\x20\x6\x1A\x14\x4\x6"+
-				"\x1\x14\x1\x6\x1A\x14\xFF85\x6",
-				"\x1\xFFFF",
-				"\x2C\x6\x1\xD\x4F\x6\x1\xE\xFF83\x6",
-				"\x41\x6\x1A\x14\x4\x6\x1\x14\x1\x6\x1A\x14\xFF85\x6",
-				"\x41\x6\x1A\x14\x4\x6\x1\x14\x1\x6\x1A\x14\xFF85\x6",
-				"\xA\x6\x1\x16\x36\x6\x1A\x14\x4\x6\x1\x14\x1\x6\x1A\x14\xFF85\x6",
-				"\x41\x6\x1A\x14\x4\x6\x1\x14\x1\x6\x1A\x14\xFF85\x6",
-				"\x9\x6\x1\x19\x1\x1B\x2\x6\x1\x1A\x12\x6\x1\x18\xB\x6\x1\xD\x2\x6\xB"+
-				"\x17\x7\x6\x1A\x17\x4\x6\x1\x17\x1\x6\x1A\x17\x1\x6\x1\xE\xFF83\x6",
-				"",
-				"\x41\x6\x1A\x14\x4\x6\x1\x14\x1\x6\x1A\x14\xFF85\x6",
-				"\x9\x6\x1\x19\x1\x1B\x2\x6\x1\x1A\x12\x6\x1\x18\xB\x6\x1\xD\x2\x6\xB"+
-				"\x17\x7\x6\x1A\x17\x4\x6\x1\x17\x1\x6\x1A\x17\x1\x6\x1\xE\xFF83\x6",
-				"\x2C\x6\x1\xD\x4F\x6\x1\xE\xFF83\x6",
-				"\x2C\x6\x1\xD\x4F\x6\x1\xE\xFF83\x6",
-				"\xA\x6\x1\x1C\x21\x6\x1\xD\x4F\x6\x1\xE\xFF83\x6",
-				"\x2C\x6\x1\xD\x4F\x6\x1\xE\xFF83\x6",
-				"\x2C\x6\x1\xD\x4F\x6\x1\xE\xFF83\x6"
-			};
-
-		static readonly short[] DFA5_eot = DFA.UnpackEncodedString(DFA5_eotS);
-		static readonly short[] DFA5_eof = DFA.UnpackEncodedString(DFA5_eofS);
-		static readonly char[] DFA5_min = DFA.UnpackEncodedStringToUnsignedChars(DFA5_minS);
-		static readonly char[] DFA5_max = DFA.UnpackEncodedStringToUnsignedChars(DFA5_maxS);
-		static readonly short[] DFA5_accept = DFA.UnpackEncodedString(DFA5_acceptS);
-		static readonly short[] DFA5_special = DFA.UnpackEncodedString(DFA5_specialS);
-		static readonly short[][] DFA5_transition;
-
-		static DFA5()
-		{
-			int numStates = DFA5_transitionS.Length;
-			DFA5_transition = new short[numStates][];
-			for ( int i=0; i < numStates; i++ )
-			{
-				DFA5_transition[i] = DFA.UnpackEncodedString(DFA5_transitionS[i]);
-			}
-		}
-
-		public DFA5( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
-			: base( specialStateTransition )	{
-			this.recognizer = recognizer;
-			this.decisionNumber = 5;
-			this.eot = DFA5_eot;
-			this.eof = DFA5_eof;
-			this.min = DFA5_min;
-			this.max = DFA5_max;
-			this.accept = DFA5_accept;
-			this.special = DFA5_special;
-			this.transition = DFA5_transition;
-		}
-		public override string GetDescription()
-		{
-			return "368:3: (=> TEMPLATE_ARGS[out subtext, args] (=> WS_CHAR )? |)";
-		}
-	}
-
-	int specialStateTransition5( DFA dfa, int s, IIntStream _input )
-	{
-		IIntStream input = _input;
-		int _s = s;
-		switch ( s )
-		{
-			case 0:
-				int LA5_0 = input.LA(1);
-
-				s = -1;
-				if ( (LA5_0==' ') ) {s = 1;}
-
-				else if ( (LA5_0=='\t') ) {s = 2;}
-
-				else if ( (LA5_0=='\r') ) {s = 3;}
-
-				else if ( (LA5_0=='\n') ) {s = 4;}
-
-				else if ( ((LA5_0>='A' && LA5_0<='Z')||LA5_0=='_'||(LA5_0>='a' && LA5_0<='z')) ) {s = 5;}
-
-				else if ( ((LA5_0>='\u0000' && LA5_0<='\b')||(LA5_0>='\u000B' && LA5_0<='\f')||(LA5_0>='\u000E' && LA5_0<='\u001F')||(LA5_0>='!' && LA5_0<='@')||(LA5_0>='[' && LA5_0<='^')||LA5_0=='`'||(LA5_0>='{' && LA5_0<='\uFFFF')) ) {s = 6;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 1:
-				int LA5_1 = input.LA(1);
-
-				s = -1;
-				if ( ((LA5_1>='A' && LA5_1<='Z')||LA5_1=='_'||(LA5_1>='a' && LA5_1<='z')) ) {s = 5;}
-
-				else if ( ((LA5_1>='\u0000' && LA5_1<='@')||(LA5_1>='[' && LA5_1<='^')||LA5_1=='`'||(LA5_1>='{' && LA5_1<='\uFFFF')) ) {s = 6;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 2:
-				int LA5_2 = input.LA(1);
-
-				s = -1;
-				if ( ((LA5_2>='A' && LA5_2<='Z')||LA5_2=='_'||(LA5_2>='a' && LA5_2<='z')) ) {s = 5;}
-
-				else if ( ((LA5_2>='\u0000' && LA5_2<='@')||(LA5_2>='[' && LA5_2<='^')||LA5_2=='`'||(LA5_2>='{' && LA5_2<='\uFFFF')) ) {s = 6;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 3:
-				int LA5_3 = input.LA(1);
-
-				s = -1;
-				if ( (LA5_3=='\n') ) {s = 7;}
-
-				else if ( ((LA5_3>='A' && LA5_3<='Z')||LA5_3=='_'||(LA5_3>='a' && LA5_3<='z')) ) {s = 5;}
-
-				else if ( ((LA5_3>='\u0000' && LA5_3<='\t')||(LA5_3>='\u000B' && LA5_3<='@')||(LA5_3>='[' && LA5_3<='^')||LA5_3=='`'||(LA5_3>='{' && LA5_3<='\uFFFF')) ) {s = 6;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 4:
-				int LA5_4 = input.LA(1);
-
-				s = -1;
-				if ( ((LA5_4>='A' && LA5_4<='Z')||LA5_4=='_'||(LA5_4>='a' && LA5_4<='z')) ) {s = 5;}
-
-				else if ( ((LA5_4>='\u0000' && LA5_4<='@')||(LA5_4>='[' && LA5_4<='^')||LA5_4=='`'||(LA5_4>='{' && LA5_4<='\uFFFF')) ) {s = 6;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 5:
-				int LA5_5 = input.LA(1);
-
-				s = -1;
-				if ( ((LA5_5>='/' && LA5_5<='9')||(LA5_5>='A' && LA5_5<='Z')||LA5_5=='_'||(LA5_5>='a' && LA5_5<='z')) ) {s = 8;}
-
-				else if ( (LA5_5==' ') ) {s = 9;}
-
-				else if ( (LA5_5=='\t') ) {s = 10;}
-
-				else if ( (LA5_5=='\r') ) {s = 11;}
-
-				else if ( (LA5_5=='\n') ) {s = 12;}
-
-				else if ( (LA5_5==',') ) {s = 13;}
-
-				else if ( (LA5_5=='|') ) {s = 14;}
-
-				else if ( ((LA5_5>='\u0000' && LA5_5<='\b')||(LA5_5>='\u000B' && LA5_5<='\f')||(LA5_5>='\u000E' && LA5_5<='\u001F')||(LA5_5>='!' && LA5_5<='+')||(LA5_5>='-' && LA5_5<='.')||(LA5_5>=':' && LA5_5<='@')||(LA5_5>='[' && LA5_5<='^')||LA5_5=='`'||LA5_5=='{'||(LA5_5>='}' && LA5_5<='\uFFFF')) ) {s = 6;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 6:
-				int LA5_7 = input.LA(1);
-
-				s = -1;
-				if ( ((LA5_7>='A' && LA5_7<='Z')||LA5_7=='_'||(LA5_7>='a' && LA5_7<='z')) ) {s = 5;}
-
-				else if ( ((LA5_7>='\u0000' && LA5_7<='@')||(LA5_7>='[' && LA5_7<='^')||LA5_7=='`'||(LA5_7>='{' && LA5_7<='\uFFFF')) ) {s = 6;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 7:
-				int LA5_8 = input.LA(1);
-
-				s = -1;
-				if ( (LA5_8==' ') ) {s = 9;}
-
-				else if ( (LA5_8=='\t') ) {s = 10;}
-
-				else if ( (LA5_8=='\r') ) {s = 11;}
-
-				else if ( (LA5_8=='\n') ) {s = 12;}
-
-				else if ( (LA5_8==',') ) {s = 13;}
-
-				else if ( (LA5_8=='|') ) {s = 14;}
-
-				else if ( ((LA5_8>='/' && LA5_8<='9')||(LA5_8>='A' && LA5_8<='Z')||LA5_8=='_'||(LA5_8>='a' && LA5_8<='z')) ) {s = 8;}
-
-				else if ( ((LA5_8>='\u0000' && LA5_8<='\b')||(LA5_8>='\u000B' && LA5_8<='\f')||(LA5_8>='\u000E' && LA5_8<='\u001F')||(LA5_8>='!' && LA5_8<='+')||(LA5_8>='-' && LA5_8<='.')||(LA5_8>=':' && LA5_8<='@')||(LA5_8>='[' && LA5_8<='^')||LA5_8=='`'||LA5_8=='{'||(LA5_8>='}' && LA5_8<='\uFFFF')) ) {s = 6;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 8:
-				int LA5_9 = input.LA(1);
-
-				s = -1;
-				if ( (LA5_9==',') ) {s = 13;}
-
-				else if ( (LA5_9=='|') ) {s = 14;}
-
-				else if ( ((LA5_9>='\u0000' && LA5_9<='+')||(LA5_9>='-' && LA5_9<='{')||(LA5_9>='}' && LA5_9<='\uFFFF')) ) {s = 6;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 9:
-				int LA5_10 = input.LA(1);
-
-				s = -1;
-				if ( (LA5_10==',') ) {s = 13;}
-
-				else if ( (LA5_10=='|') ) {s = 14;}
-
-				else if ( ((LA5_10>='\u0000' && LA5_10<='+')||(LA5_10>='-' && LA5_10<='{')||(LA5_10>='}' && LA5_10<='\uFFFF')) ) {s = 6;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 10:
-				int LA5_11 = input.LA(1);
-
-				s = -1;
-				if ( (LA5_11=='\n') ) {s = 15;}
-
-				else if ( (LA5_11==',') ) {s = 13;}
-
-				else if ( (LA5_11=='|') ) {s = 14;}
-
-				else if ( ((LA5_11>='\u0000' && LA5_11<='\t')||(LA5_11>='\u000B' && LA5_11<='+')||(LA5_11>='-' && LA5_11<='{')||(LA5_11>='}' && LA5_11<='\uFFFF')) ) {s = 6;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 11:
-				int LA5_12 = input.LA(1);
-
-				s = -1;
-				if ( (LA5_12==',') ) {s = 13;}
-
-				else if ( (LA5_12=='|') ) {s = 14;}
-
-				else if ( ((LA5_12>='\u0000' && LA5_12<='+')||(LA5_12>='-' && LA5_12<='{')||(LA5_12>='}' && LA5_12<='\uFFFF')) ) {s = 6;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 12:
-				int LA5_13 = input.LA(1);
-
-				s = -1;
-				if ( (LA5_13==' ') ) {s = 16;}
-
-				else if ( (LA5_13=='\t') ) {s = 17;}
-
-				else if ( (LA5_13=='\r') ) {s = 18;}
-
-				else if ( (LA5_13=='\n') ) {s = 19;}
-
-				else if ( ((LA5_13>='A' && LA5_13<='Z')||LA5_13=='_'||(LA5_13>='a' && LA5_13<='z')) ) {s = 20;}
-
-				else if ( ((LA5_13>='\u0000' && LA5_13<='\b')||(LA5_13>='\u000B' && LA5_13<='\f')||(LA5_13>='\u000E' && LA5_13<='\u001F')||(LA5_13>='!' && LA5_13<='@')||(LA5_13>='[' && LA5_13<='^')||LA5_13=='`'||(LA5_13>='{' && LA5_13<='\uFFFF')) ) {s = 6;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 13:
-				int LA5_14 = input.LA(1);
-
-
-				int index5_14 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (EvaluatePredicate(synpred1_Action_fragment)) ) {s = 21;}
-
-				else if ( (true) ) {s = 6;}
-
-
-				input.Seek(index5_14);
-				if ( s>=0 ) return s;
-				break;
-			case 14:
-				int LA5_15 = input.LA(1);
-
-				s = -1;
-				if ( (LA5_15==',') ) {s = 13;}
-
-				else if ( (LA5_15=='|') ) {s = 14;}
-
-				else if ( ((LA5_15>='\u0000' && LA5_15<='+')||(LA5_15>='-' && LA5_15<='{')||(LA5_15>='}' && LA5_15<='\uFFFF')) ) {s = 6;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 15:
-				int LA5_16 = input.LA(1);
-
-				s = -1;
-				if ( ((LA5_16>='A' && LA5_16<='Z')||LA5_16=='_'||(LA5_16>='a' && LA5_16<='z')) ) {s = 20;}
-
-				else if ( ((LA5_16>='\u0000' && LA5_16<='@')||(LA5_16>='[' && LA5_16<='^')||LA5_16=='`'||(LA5_16>='{' && LA5_16<='\uFFFF')) ) {s = 6;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 16:
-				int LA5_17 = input.LA(1);
-
-				s = -1;
-				if ( ((LA5_17>='A' && LA5_17<='Z')||LA5_17=='_'||(LA5_17>='a' && LA5_17<='z')) ) {s = 20;}
-
-				else if ( ((LA5_17>='\u0000' && LA5_17<='@')||(LA5_17>='[' && LA5_17<='^')||LA5_17=='`'||(LA5_17>='{' && LA5_17<='\uFFFF')) ) {s = 6;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 17:
-				int LA5_18 = input.LA(1);
-
-				s = -1;
-				if ( (LA5_18=='\n') ) {s = 22;}
-
-				else if ( ((LA5_18>='A' && LA5_18<='Z')||LA5_18=='_'||(LA5_18>='a' && LA5_18<='z')) ) {s = 20;}
-
-				else if ( ((LA5_18>='\u0000' && LA5_18<='\t')||(LA5_18>='\u000B' && LA5_18<='@')||(LA5_18>='[' && LA5_18<='^')||LA5_18=='`'||(LA5_18>='{' && LA5_18<='\uFFFF')) ) {s = 6;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 18:
-				int LA5_19 = input.LA(1);
-
-				s = -1;
-				if ( ((LA5_19>='A' && LA5_19<='Z')||LA5_19=='_'||(LA5_19>='a' && LA5_19<='z')) ) {s = 20;}
-
-				else if ( ((LA5_19>='\u0000' && LA5_19<='@')||(LA5_19>='[' && LA5_19<='^')||LA5_19=='`'||(LA5_19>='{' && LA5_19<='\uFFFF')) ) {s = 6;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 19:
-				int LA5_20 = input.LA(1);
-
-				s = -1;
-				if ( ((LA5_20>='/' && LA5_20<='9')||(LA5_20>='A' && LA5_20<='Z')||LA5_20=='_'||(LA5_20>='a' && LA5_20<='z')) ) {s = 23;}
-
-				else if ( (LA5_20==' ') ) {s = 24;}
-
-				else if ( (LA5_20=='\t') ) {s = 25;}
-
-				else if ( (LA5_20=='\r') ) {s = 26;}
-
-				else if ( (LA5_20=='\n') ) {s = 27;}
-
-				else if ( (LA5_20=='|') ) {s = 14;}
-
-				else if ( (LA5_20==',') ) {s = 13;}
-
-				else if ( ((LA5_20>='\u0000' && LA5_20<='\b')||(LA5_20>='\u000B' && LA5_20<='\f')||(LA5_20>='\u000E' && LA5_20<='\u001F')||(LA5_20>='!' && LA5_20<='+')||(LA5_20>='-' && LA5_20<='.')||(LA5_20>=':' && LA5_20<='@')||(LA5_20>='[' && LA5_20<='^')||LA5_20=='`'||LA5_20=='{'||(LA5_20>='}' && LA5_20<='\uFFFF')) ) {s = 6;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 20:
-				int LA5_22 = input.LA(1);
-
-				s = -1;
-				if ( ((LA5_22>='A' && LA5_22<='Z')||LA5_22=='_'||(LA5_22>='a' && LA5_22<='z')) ) {s = 20;}
-
-				else if ( ((LA5_22>='\u0000' && LA5_22<='@')||(LA5_22>='[' && LA5_22<='^')||LA5_22=='`'||(LA5_22>='{' && LA5_22<='\uFFFF')) ) {s = 6;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 21:
-				int LA5_23 = input.LA(1);
-
-				s = -1;
-				if ( (LA5_23==' ') ) {s = 24;}
-
-				else if ( (LA5_23=='\t') ) {s = 25;}
-
-				else if ( (LA5_23=='\r') ) {s = 26;}
-
-				else if ( (LA5_23=='\n') ) {s = 27;}
-
-				else if ( (LA5_23=='|') ) {s = 14;}
-
-				else if ( (LA5_23==',') ) {s = 13;}
-
-				else if ( ((LA5_23>='/' && LA5_23<='9')||(LA5_23>='A' && LA5_23<='Z')||LA5_23=='_'||(LA5_23>='a' && LA5_23<='z')) ) {s = 23;}
-
-				else if ( ((LA5_23>='\u0000' && LA5_23<='\b')||(LA5_23>='\u000B' && LA5_23<='\f')||(LA5_23>='\u000E' && LA5_23<='\u001F')||(LA5_23>='!' && LA5_23<='+')||(LA5_23>='-' && LA5_23<='.')||(LA5_23>=':' && LA5_23<='@')||(LA5_23>='[' && LA5_23<='^')||LA5_23=='`'||LA5_23=='{'||(LA5_23>='}' && LA5_23<='\uFFFF')) ) {s = 6;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 22:
-				int LA5_24 = input.LA(1);
-
-				s = -1;
-				if ( (LA5_24=='|') ) {s = 14;}
-
-				else if ( (LA5_24==',') ) {s = 13;}
-
-				else if ( ((LA5_24>='\u0000' && LA5_24<='+')||(LA5_24>='-' && LA5_24<='{')||(LA5_24>='}' && LA5_24<='\uFFFF')) ) {s = 6;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 23:
-				int LA5_25 = input.LA(1);
-
-				s = -1;
-				if ( (LA5_25=='|') ) {s = 14;}
-
-				else if ( (LA5_25==',') ) {s = 13;}
-
-				else if ( ((LA5_25>='\u0000' && LA5_25<='+')||(LA5_25>='-' && LA5_25<='{')||(LA5_25>='}' && LA5_25<='\uFFFF')) ) {s = 6;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 24:
-				int LA5_26 = input.LA(1);
-
-				s = -1;
-				if ( (LA5_26=='\n') ) {s = 28;}
-
-				else if ( (LA5_26=='|') ) {s = 14;}
-
-				else if ( (LA5_26==',') ) {s = 13;}
-
-				else if ( ((LA5_26>='\u0000' && LA5_26<='\t')||(LA5_26>='\u000B' && LA5_26<='+')||(LA5_26>='-' && LA5_26<='{')||(LA5_26>='}' && LA5_26<='\uFFFF')) ) {s = 6;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 25:
-				int LA5_27 = input.LA(1);
-
-				s = -1;
-				if ( (LA5_27=='|') ) {s = 14;}
-
-				else if ( (LA5_27==',') ) {s = 13;}
-
-				else if ( ((LA5_27>='\u0000' && LA5_27<='+')||(LA5_27>='-' && LA5_27<='{')||(LA5_27>='}' && LA5_27<='\uFFFF')) ) {s = 6;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 26:
-				int LA5_28 = input.LA(1);
-
-				s = -1;
-				if ( (LA5_28=='|') ) {s = 14;}
-
-				else if ( (LA5_28==',') ) {s = 13;}
-
-				else if ( ((LA5_28>='\u0000' && LA5_28<='+')||(LA5_28>='-' && LA5_28<='{')||(LA5_28>='}' && LA5_28<='\uFFFF')) ) {s = 6;}
-
-				if ( s>=0 ) return s;
-				break;
-		}
-		if (state.backtracking>0) {state.failed=true; return -1;}
-		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 5, _s, input);
-		dfa.Error(nvae);
-		throw nvae;
-	}
-	class DFA6 : DFA
-	{
-
-		const string DFA6_eotS =
-			"\xA\xFFFF";
-		const string DFA6_eofS =
-			"\xA\xFFFF";
-		const string DFA6_minS =
-			"\x1\x0\x1\xFFFF\x1\x0\x2\xFFFF\x2\x0\x3\xFFFF";
-		const string DFA6_maxS =
-			"\x1\xFFFF\x1\xFFFF\x1\xFFFF\x2\xFFFF\x2\x0\x3\xFFFF";
-		const string DFA6_acceptS =
-			"\x1\xFFFF\x1\x6\x1\xFFFF\x1\x4\x1\x5\x2\xFFFF\x1\x3\x1\x1\x1\x2";
-		const string DFA6_specialS =
-			"\x1\x0\x1\xFFFF\x1\x1\x2\xFFFF\x1\x2\x1\x3\x3\xFFFF}>";
-		static readonly string[] DFA6_transitionS =
-			{
-				"\x5C\x4\x1\x2\x1E\x4\x1\x3\x1\x4\x1\x1\xFF82\x4",
-				"",
-				"\x7B\x7\x1\x5\x1\x7\x1\x6\xFF82\x7",
-				"",
-				"",
-				"\x1\xFFFF",
-				"\x1\xFFFF",
-				"",
-				"",
-				""
-			};
-
-		static readonly short[] DFA6_eot = DFA.UnpackEncodedString(DFA6_eotS);
-		static readonly short[] DFA6_eof = DFA.UnpackEncodedString(DFA6_eofS);
-		static readonly char[] DFA6_min = DFA.UnpackEncodedStringToUnsignedChars(DFA6_minS);
-		static readonly char[] DFA6_max = DFA.UnpackEncodedStringToUnsignedChars(DFA6_maxS);
-		static readonly short[] DFA6_accept = DFA.UnpackEncodedString(DFA6_acceptS);
-		static readonly short[] DFA6_special = DFA.UnpackEncodedString(DFA6_specialS);
-		static readonly short[][] DFA6_transition;
-
-		static DFA6()
-		{
-			int numStates = DFA6_transitionS.Length;
-			DFA6_transition = new short[numStates][];
-			for ( int i=0; i < numStates; i++ )
-			{
-				DFA6_transition[i] = DFA.UnpackEncodedString(DFA6_transitionS[i]);
-			}
-		}
-
-		public DFA6( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
-			: base( specialStateTransition )	{
-			this.recognizer = recognizer;
-			this.decisionNumber = 6;
-			this.eot = DFA6_eot;
-			this.eof = DFA6_eof;
-			this.min = DFA6_min;
-			this.max = DFA6_max;
-			this.accept = DFA6_accept;
-			this.special = DFA6_special;
-			this.transition = DFA6_transition;
-		}
-		public override string GetDescription()
-		{
-			return "()* loopback of 377:3: (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '\\\\' | '{' | '}' ) )*";
-		}
-	}
-
-	int specialStateTransition6( DFA dfa, int s, IIntStream _input )
-	{
-		IIntStream input = _input;
-		int _s = s;
-		switch ( s )
-		{
-			case 0:
-				int LA6_0 = input.LA(1);
-
-				s = -1;
-				if ( (LA6_0=='}') ) {s = 1;}
-
-				else if ( (LA6_0=='\\') ) {s = 2;}
-
-				else if ( (LA6_0=='{') ) {s = 3;}
-
-				else if ( ((LA6_0>='\u0000' && LA6_0<='[')||(LA6_0>=']' && LA6_0<='z')||LA6_0=='|'||(LA6_0>='~' && LA6_0<='\uFFFF')) ) {s = 4;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 1:
-				int LA6_2 = input.LA(1);
-
-				s = -1;
-				if ( (LA6_2=='{') ) {s = 5;}
-
-				else if ( (LA6_2=='}') ) {s = 6;}
-
-				else if ( ((LA6_2>='\u0000' && LA6_2<='z')||LA6_2=='|'||(LA6_2>='~' && LA6_2<='\uFFFF')) ) {s = 7;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 2:
-				int LA6_5 = input.LA(1);
-
-
-				int index6_5 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (EvaluatePredicate(synpred3_Action_fragment)) ) {s = 8;}
-
-				else if ( (true) ) {s = 7;}
-
-
-				input.Seek(index6_5);
-				if ( s>=0 ) return s;
-				break;
-			case 3:
-				int LA6_6 = input.LA(1);
-
-
-				int index6_6 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (EvaluatePredicate(synpred4_Action_fragment)) ) {s = 9;}
-
-				else if ( (true) ) {s = 7;}
-
-
-				input.Seek(index6_6);
-				if ( s>=0 ) return s;
-				break;
-		}
-		if (state.backtracking>0) {state.failed=true; return -1;}
-		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 6, _s, input);
-		dfa.Error(nvae);
-		throw nvae;
-	}
-	class DFA12 : DFA
-	{
-
-		const string DFA12_eotS =
-			"\xA\xFFFF";
-		const string DFA12_eofS =
-			"\xA\xFFFF";
-		const string DFA12_minS =
-			"\x1\x0\x1\xFFFF\x1\x0\x2\xFFFF\x2\x0\x3\xFFFF";
-		const string DFA12_maxS =
-			"\x1\xFFFF\x1\xFFFF\x1\xFFFF\x2\xFFFF\x2\x0\x3\xFFFF";
-		const string DFA12_acceptS =
-			"\x1\xFFFF\x1\x6\x1\xFFFF\x1\x4\x1\x5\x2\xFFFF\x1\x3\x1\x1\x1\x2";
-		const string DFA12_specialS =
-			"\x1\x0\x1\xFFFF\x1\x1\x2\xFFFF\x1\x2\x1\x3\x3\xFFFF}>";
-		static readonly string[] DFA12_transitionS =
-			{
-				"\x5C\x4\x1\x2\x1E\x4\x1\x3\x1\x4\x1\x1\xFF82\x4",
-				"",
-				"\x7B\x7\x1\x5\x1\x7\x1\x6\xFF82\x7",
-				"",
-				"",
-				"\x1\xFFFF",
-				"\x1\xFFFF",
-				"",
-				"",
-				""
-			};
-
-		static readonly short[] DFA12_eot = DFA.UnpackEncodedString(DFA12_eotS);
-		static readonly short[] DFA12_eof = DFA.UnpackEncodedString(DFA12_eofS);
-		static readonly char[] DFA12_min = DFA.UnpackEncodedStringToUnsignedChars(DFA12_minS);
-		static readonly char[] DFA12_max = DFA.UnpackEncodedStringToUnsignedChars(DFA12_maxS);
-		static readonly short[] DFA12_accept = DFA.UnpackEncodedString(DFA12_acceptS);
-		static readonly short[] DFA12_special = DFA.UnpackEncodedString(DFA12_specialS);
-		static readonly short[][] DFA12_transition;
-
-		static DFA12()
-		{
-			int numStates = DFA12_transitionS.Length;
-			DFA12_transition = new short[numStates][];
-			for ( int i=0; i < numStates; i++ )
-			{
-				DFA12_transition[i] = DFA.UnpackEncodedString(DFA12_transitionS[i]);
-			}
-		}
-
-		public DFA12( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
-			: base( specialStateTransition )	{
-			this.recognizer = recognizer;
-			this.decisionNumber = 12;
-			this.eot = DFA12_eot;
-			this.eof = DFA12_eof;
-			this.min = DFA12_min;
-			this.max = DFA12_max;
-			this.accept = DFA12_accept;
-			this.special = DFA12_special;
-			this.transition = DFA12_transition;
-		}
-		public override string GetDescription()
-		{
-			return "()* loopback of 415:3: (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '{' | '}' | '\\\\' ) )*";
-		}
-	}
-
-	int specialStateTransition12( DFA dfa, int s, IIntStream _input )
-	{
-		IIntStream input = _input;
-		int _s = s;
-		switch ( s )
-		{
-			case 0:
-				int LA12_0 = input.LA(1);
-
-				s = -1;
-				if ( (LA12_0=='}') ) {s = 1;}
-
-				else if ( (LA12_0=='\\') ) {s = 2;}
-
-				else if ( (LA12_0=='{') ) {s = 3;}
-
-				else if ( ((LA12_0>='\u0000' && LA12_0<='[')||(LA12_0>=']' && LA12_0<='z')||LA12_0=='|'||(LA12_0>='~' && LA12_0<='\uFFFF')) ) {s = 4;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 1:
-				int LA12_2 = input.LA(1);
-
-				s = -1;
-				if ( (LA12_2=='{') ) {s = 5;}
-
-				else if ( (LA12_2=='}') ) {s = 6;}
-
-				else if ( ((LA12_2>='\u0000' && LA12_2<='z')||LA12_2=='|'||(LA12_2>='~' && LA12_2<='\uFFFF')) ) {s = 7;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 2:
-				int LA12_5 = input.LA(1);
-
-
-				int index12_5 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (EvaluatePredicate(synpred5_Action_fragment)) ) {s = 8;}
-
-				else if ( (true) ) {s = 7;}
-
-
-				input.Seek(index12_5);
-				if ( s>=0 ) return s;
-				break;
-			case 3:
-				int LA12_6 = input.LA(1);
-
-
-				int index12_6 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (EvaluatePredicate(synpred6_Action_fragment)) ) {s = 9;}
-
-				else if ( (true) ) {s = 7;}
-
-
-				input.Seek(index12_6);
-				if ( s>=0 ) return s;
-				break;
-		}
-		if (state.backtracking>0) {state.failed=true; return -1;}
-		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 12, _s, input);
-		dfa.Error(nvae);
-		throw nvae;
-	}
-	class DFA18 : DFA
-	{
-
-		const string DFA18_eotS =
-			"\x1\xFFFF\x7\x8\x9\xFFFF\x1\x22\x6\xFFFF\x1\x23\x8\x8\x3\xFFFF\xA\x8"+
-			"\x1\x36\x1\x8\x1\x38\x4\x8\x1\x3D\x1\xFFFF\x1\x8\x1\xFFFF\x1\x3F\x1\x40"+
-			"\x1\x41\x1\x42\x1\xFFFF\x1\x43\x5\xFFFF";
-		const string DFA18_eofS =
-			"\x44\xFFFF";
-		const string DFA18_minS =
-			"\x1\x9\x1\x66\x1\x6C\x1\x69\x1\x61\x1\x65\x1\x74\x1\x72\x9\xFFFF\x1\x2E"+
-			"\x6\xFFFF\x1\x2F\x1\x73\x1\x72\x1\x73\x1\x6E\x1\x73\x1\x72\x1\x70\x1"+
-			"\x75\x3\xFFFF\x1\x65\x1\x73\x1\x74\x1\x67\x1\x74\x1\x69\x1\x65\x1\x6E"+
-			"\x1\x69\x1\x74\x1\x2F\x1\x74\x1\x2F\x1\x70\x1\x72\x1\x63\x1\x66\x1\x2F"+
-			"\x1\xFFFF\x1\x68\x1\xFFFF\x4\x2F\x1\xFFFF\x1\x2F\x5\xFFFF";
-		const string DFA18_maxS =
-			"\x1\x7B\x1\x66\x1\x6C\x1\x69\x2\x65\x1\x75\x1\x72\x9\xFFFF\x1\x2E\x6"+
-			"\xFFFF\x1\x7A\x1\x73\x1\x72\x1\x73\x1\x6E\x1\x73\x1\x72\x1\x70\x1\x75"+
-			"\x3\xFFFF\x1\x65\x1\x73\x1\x74\x1\x67\x1\x74\x1\x69\x1\x65\x1\x6E\x1"+
-			"\x69\x1\x74\x1\x7A\x1\x74\x1\x7A\x1\x70\x1\x72\x1\x63\x1\x66\x1\x7A\x1"+
-			"\xFFFF\x1\x68\x1\xFFFF\x4\x7A\x1\xFFFF\x1\x7A\x5\xFFFF";
-		const string DFA18_acceptS =
-			"\x8\xFFFF\x1\xA\x1\xB\x1\xC\x1\xD\x1\xE\x1\xF\x1\x10\x1\x11\x1\x12\x1"+
-			"\xFFFF\x1\x14\x1\x15\x1\x16\x1\x17\x1\x18\x1\x1A\x9\xFFFF\x1\x19\x1\x13"+
-			"\x1\x1\x12\xFFFF\x1\x4\x1\xFFFF\x1\x6\x4\xFFFF\x1\x3\x1\xFFFF\x1\x7\x1"+
-			"\x8\x1\x9\x1\x2\x1\x5";
-		const string DFA18_specialS =
-			"\x44\xFFFF}>";
-		static readonly string[] DFA18_transitionS =
-			{
-				"\x2\x17\x2\xFFFF\x1\x17\x12\xFFFF\x1\x17\x1\x16\x1\xA\x5\xFFFF\x1\xE"+
-				"\x1\xF\x1\xFFFF\x1\x14\x1\x10\x1\xFFFF\x1\x11\x1\xFFFF\xA\x9\x1\x13"+
-				"\x1\x15\x1\xFFFF\x1\x12\x3\xFFFF\x1A\x8\x1\xC\x1\xFFFF\x1\xD\x1\xFFFF"+
-				"\x1\x8\x1\xFFFF\x4\x8\x1\x2\x1\x3\x2\x8\x1\x1\x2\x8\x1\x4\x5\x8\x1\x5"+
-				"\x1\x6\x1\x7\x6\x8\x1\xB",
-				"\x1\x18",
-				"\x1\x19",
-				"\x1\x1A",
-				"\x1\x1B\x3\xFFFF\x1\x1C",
-				"\x1\x1D",
-				"\x1\x1E\x1\x1F",
-				"\x1\x20",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"\x1\x21",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"\xB\x8\x7\xFFFF\x1A\x8\x4\xFFFF\x1\x8\x1\xFFFF\x1A\x8",
-				"\x1\x24",
-				"\x1\x25",
-				"\x1\x26",
-				"\x1\x27",
-				"\x1\x28",
-				"\x1\x29",
-				"\x1\x2A",
-				"\x1\x2B",
-				"",
-				"",
-				"",
-				"\x1\x2C",
-				"\x1\x2D",
-				"\x1\x2E",
-				"\x1\x2F",
-				"\x1\x30",
-				"\x1\x31",
-				"\x1\x32",
-				"\x1\x33",
-				"\x1\x34",
-				"\x1\x35",
-				"\xB\x8\x7\xFFFF\x1A\x8\x4\xFFFF\x1\x8\x1\xFFFF\x1A\x8",
-				"\x1\x37",
-				"\xB\x8\x7\xFFFF\x1A\x8\x4\xFFFF\x1\x8\x1\xFFFF\x1A\x8",
-				"\x1\x39",
-				"\x1\x3A",
-				"\x1\x3B",
-				"\x1\x3C",
-				"\xB\x8\x7\xFFFF\x1A\x8\x4\xFFFF\x1\x8\x1\xFFFF\x1A\x8",
-				"",
-				"\x1\x3E",
-				"",
-				"\xB\x8\x7\xFFFF\x1A\x8\x4\xFFFF\x1\x8\x1\xFFFF\x1A\x8",
-				"\xB\x8\x7\xFFFF\x1A\x8\x4\xFFFF\x1\x8\x1\xFFFF\x1A\x8",
-				"\xB\x8\x7\xFFFF\x1A\x8\x4\xFFFF\x1\x8\x1\xFFFF\x1A\x8",
-				"\xB\x8\x7\xFFFF\x1A\x8\x4\xFFFF\x1\x8\x1\xFFFF\x1A\x8",
-				"",
-				"\xB\x8\x7\xFFFF\x1A\x8\x4\xFFFF\x1\x8\x1\xFFFF\x1A\x8",
-				"",
-				"",
-				"",
-				"",
-				""
-			};
-
-		static readonly short[] DFA18_eot = DFA.UnpackEncodedString(DFA18_eotS);
-		static readonly short[] DFA18_eof = DFA.UnpackEncodedString(DFA18_eofS);
-		static readonly char[] DFA18_min = DFA.UnpackEncodedStringToUnsignedChars(DFA18_minS);
-		static readonly char[] DFA18_max = DFA.UnpackEncodedStringToUnsignedChars(DFA18_maxS);
-		static readonly short[] DFA18_accept = DFA.UnpackEncodedString(DFA18_acceptS);
-		static readonly short[] DFA18_special = DFA.UnpackEncodedString(DFA18_specialS);
-		static readonly short[][] DFA18_transition;
-
-		static DFA18()
-		{
-			int numStates = DFA18_transitionS.Length;
-			DFA18_transition = new short[numStates][];
-			for ( int i=0; i < numStates; i++ )
-			{
-				DFA18_transition[i] = DFA.UnpackEncodedString(DFA18_transitionS[i]);
-			}
-		}
-
-		public DFA18( BaseRecognizer recognizer )
-		{
-			this.recognizer = recognizer;
-			this.decisionNumber = 18;
-			this.eot = DFA18_eot;
-			this.eof = DFA18_eof;
-			this.min = DFA18_min;
-			this.max = DFA18_max;
-			this.accept = DFA18_accept;
-			this.special = DFA18_special;
-			this.transition = DFA18_transition;
-		}
-		public override string GetDescription()
-		{
-			return "1:0: Tokens : ( CONDITIONAL | ELSEIF | FIRST | LAST | LENGTH | REST | STRIP | SUPER | TRUNC | ID | INT | STRING | ANONYMOUS_TEMPLATE | LBRACK | RBRACK | LPAREN | RPAREN | COMMA | DOT | ASSIGN | COLON | PLUS | SEMI | NOT | DOTDOTDOT | WS );";
-		}
-	}
-
-
-	#endregion
-
-}
-
-} // namespace  Antlr3.ST.Language
diff --git a/Antlr3.StringTemplate/Language/ActionParser.cs b/Antlr3.StringTemplate/Language/ActionParser.cs
deleted file mode 100644
index e23fe7d..0000000
--- a/Antlr3.StringTemplate/Language/ActionParser.cs
+++ /dev/null
@@ -1,3884 +0,0 @@
-// $ANTLR 3.1.2 Language\\Action.g3 2009-09-30 13:22:27
-
-// The variable 'variable' is assigned but its value is never used.
-#pragma warning disable 219
-// Unreachable code detected.
-#pragma warning disable 162
-
-
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Grammar conversion to ANTLR v3 and C#:
- Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-	notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-	derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-
-using System.Collections.Generic;
-using Antlr.Runtime;
-using Stack = System.Collections.Generic.Stack<object>;
-using List = System.Collections.IList;
-using ArrayList = System.Collections.Generic.List<object>;
-using Map = System.Collections.IDictionary;
-using HashMap = System.Collections.Generic.Dictionary<object, object>;
-
-using Antlr.Runtime.Tree;
-using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;
-
-namespace  Antlr3.ST.Language
-{
-[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.1.2")]
-[System.CLSCompliant(false)]
-public partial class ActionParser : Parser
-{
-	internal static readonly string[] tokenNames = new string[] {
-		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ANONYMOUS_TEMPLATE", "APPLY", "ARGS", "ASSIGN", "COLON", "COMMA", "CONDITIONAL", "DOT", "DOTDOTDOT", "ELSEIF", "ESC_CHAR", "FIRST", "FUNCTION", "ID", "INCLUDE", "INT", "LAST", "LBRACK", "LENGTH", "LIST", "LPAREN", "MULTI_APPLY", "NESTED_ANONYMOUS_TEMPLATE", "NEWLINE", "NOT", "NOTHING", "PLUS", "RBRACK", "REST", "RPAREN", "SEMI", "SINGLEVALUEARG", "STRING", "STRIP", "SUPER", "TEMPLATE", "TEMPLATE_ARGS", "TRUNC", "VALUE", "WS", "WS_CHAR"
-	};
-	public const int EOF=-1;
-	public const int ANONYMOUS_TEMPLATE=4;
-	public const int APPLY=5;
-	public const int ARGS=6;
-	public const int ASSIGN=7;
-	public const int COLON=8;
-	public const int COMMA=9;
-	public const int CONDITIONAL=10;
-	public const int DOT=11;
-	public const int DOTDOTDOT=12;
-	public const int ELSEIF=13;
-	public const int ESC_CHAR=14;
-	public const int FIRST=15;
-	public const int FUNCTION=16;
-	public const int ID=17;
-	public const int INCLUDE=18;
-	public const int INT=19;
-	public const int LAST=20;
-	public const int LBRACK=21;
-	public const int LENGTH=22;
-	public const int LIST=23;
-	public const int LPAREN=24;
-	public const int MULTI_APPLY=25;
-	public const int NESTED_ANONYMOUS_TEMPLATE=26;
-	public const int NEWLINE=27;
-	public const int NOT=28;
-	public const int NOTHING=29;
-	public const int PLUS=30;
-	public const int RBRACK=31;
-	public const int REST=32;
-	public const int RPAREN=33;
-	public const int SEMI=34;
-	public const int SINGLEVALUEARG=35;
-	public const int STRING=36;
-	public const int STRIP=37;
-	public const int SUPER=38;
-	public const int TEMPLATE=39;
-	public const int TEMPLATE_ARGS=40;
-	public const int TRUNC=41;
-	public const int VALUE=42;
-	public const int WS=43;
-	public const int WS_CHAR=44;
-
-	// delegates
-	// delegators
-
-	public ActionParser( ITokenStream input )
-		: this( input, new RecognizerSharedState() )
-	{
-	}
-	public ActionParser( ITokenStream input, RecognizerSharedState state )
-		: base( input, state )
-	{
-		InitializeTreeAdaptor();
-		if ( TreeAdaptor == null )
-			TreeAdaptor = new CommonTreeAdaptor();
-	}
-
-	// Implement this function in your helper file to use a custom tree adaptor
-	partial void InitializeTreeAdaptor();
-	ITreeAdaptor adaptor;
-
-	public ITreeAdaptor TreeAdaptor
-	{
-		get
-		{
-			return adaptor;
-		}
-		set
-		{
-			this.adaptor = value;
-		}
-	}
-
-	public override string[] TokenNames { get { return ActionParser.tokenNames; } }
-	public override string GrammarFileName { get { return "Language\\Action.g3"; } }
-
-
-	#region Rules
-	public class action_return : ParserRuleReturnScope
-	{
-		public IDictionary<string, object> opts=null;
-		internal StringTemplateAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "action"
-	// Language\\Action.g3:145:0: public action returns [IDictionary<string, object> opts=null] : ( templatesExpr ( SEMI optionList )? | 'if' LPAREN ifCondition RPAREN | 'elseif' LPAREN ifCondition RPAREN ) EOF ;
-	public ActionParser.action_return action(  )
-	{
-		ActionParser.action_return retval = new ActionParser.action_return();
-		retval.start = input.LT(1);
-
-		StringTemplateAST root_0 = null;
-
-		IToken SEMI2=null;
-		IToken string_literal4=null;
-		IToken LPAREN5=null;
-		IToken RPAREN7=null;
-		IToken string_literal8=null;
-		IToken LPAREN9=null;
-		IToken RPAREN11=null;
-		IToken EOF12=null;
-		ActionParser.templatesExpr_return templatesExpr1 = default(ActionParser.templatesExpr_return);
-		ActionParser.optionList_return optionList3 = default(ActionParser.optionList_return);
-		ActionParser.ifCondition_return ifCondition6 = default(ActionParser.ifCondition_return);
-		ActionParser.ifCondition_return ifCondition10 = default(ActionParser.ifCondition_return);
-
-		StringTemplateAST SEMI2_tree=null;
-		StringTemplateAST string_literal4_tree=null;
-		StringTemplateAST LPAREN5_tree=null;
-		StringTemplateAST RPAREN7_tree=null;
-		StringTemplateAST string_literal8_tree=null;
-		StringTemplateAST LPAREN9_tree=null;
-		StringTemplateAST RPAREN11_tree=null;
-		StringTemplateAST EOF12_tree=null;
-
-		try
-		{
-			// Language\\Action.g3:146:4: ( ( templatesExpr ( SEMI optionList )? | 'if' LPAREN ifCondition RPAREN | 'elseif' LPAREN ifCondition RPAREN ) EOF )
-			// Language\\Action.g3:146:4: ( templatesExpr ( SEMI optionList )? | 'if' LPAREN ifCondition RPAREN | 'elseif' LPAREN ifCondition RPAREN ) EOF
-			{
-			root_0 = (StringTemplateAST)adaptor.Nil();
-
-			// Language\\Action.g3:146:4: ( templatesExpr ( SEMI optionList )? | 'if' LPAREN ifCondition RPAREN | 'elseif' LPAREN ifCondition RPAREN )
-			int alt2=3;
-			switch ( input.LA(1) )
-			{
-			case ANONYMOUS_TEMPLATE:
-			case FIRST:
-			case ID:
-			case INT:
-			case LAST:
-			case LBRACK:
-			case LENGTH:
-			case LPAREN:
-			case REST:
-			case STRING:
-			case STRIP:
-			case SUPER:
-			case TRUNC:
-				{
-				alt2=1;
-				}
-				break;
-			case CONDITIONAL:
-				{
-				alt2=2;
-				}
-				break;
-			case ELSEIF:
-				{
-				alt2=3;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt2 )
-			{
-			case 1:
-				// Language\\Action.g3:146:6: templatesExpr ( SEMI optionList )?
-				{
-				PushFollow(Follow._templatesExpr_in_action192);
-				templatesExpr1=templatesExpr();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, templatesExpr1.Tree);
-				// Language\\Action.g3:146:20: ( SEMI optionList )?
-				int alt1=2;
-				int LA1_0 = input.LA(1);
-
-				if ( (LA1_0==SEMI) )
-				{
-					alt1=1;
-				}
-				switch ( alt1 )
-				{
-				case 1:
-					// Language\\Action.g3:146:21: SEMI optionList
-					{
-					SEMI2=(IToken)Match(input,SEMI,Follow._SEMI_in_action195); if (state.failed) return retval;
-					PushFollow(Follow._optionList_in_action198);
-					optionList3=optionList();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, optionList3.Tree);
-					if ( state.backtracking == 0 )
-					{
-						retval.opts = (optionList3!=null?optionList3.opts:default(IDictionary<string, object>));
-					}
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-			case 2:
-				// Language\\Action.g3:147:5: 'if' LPAREN ifCondition RPAREN
-				{
-				string_literal4=(IToken)Match(input,CONDITIONAL,Follow._CONDITIONAL_in_action208); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) {
-				string_literal4_tree = (StringTemplateAST)adaptor.Create(string_literal4);
-				root_0 = (StringTemplateAST)adaptor.BecomeRoot(string_literal4_tree, root_0);
-				}
-				LPAREN5=(IToken)Match(input,LPAREN,Follow._LPAREN_in_action211); if (state.failed) return retval;
-				PushFollow(Follow._ifCondition_in_action214);
-				ifCondition6=ifCondition();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, ifCondition6.Tree);
-				RPAREN7=(IToken)Match(input,RPAREN,Follow._RPAREN_in_action216); if (state.failed) return retval;
-
-				}
-				break;
-			case 3:
-				// Language\\Action.g3:148:5: 'elseif' LPAREN ifCondition RPAREN
-				{
-				string_literal8=(IToken)Match(input,ELSEIF,Follow._ELSEIF_in_action223); if (state.failed) return retval;
-				LPAREN9=(IToken)Match(input,LPAREN,Follow._LPAREN_in_action226); if (state.failed) return retval;
-				PushFollow(Follow._ifCondition_in_action229);
-				ifCondition10=ifCondition();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, ifCondition10.Tree);
-				RPAREN11=(IToken)Match(input,RPAREN,Follow._RPAREN_in_action231); if (state.failed) return retval;
-
-				}
-				break;
-
-			}
-
-			EOF12=(IToken)Match(input,EOF,Follow._EOF_in_action241); if (state.failed) return retval;
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "action"
-
-	public class optionList_return : ParserRuleReturnScope
-	{
-		public IDictionary<string, object> opts=new Dictionary<string, object>();
-		internal StringTemplateAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "optionList"
-	// Language\\Action.g3:153:0: optionList returns [IDictionary<string, object> opts=new Dictionary<string, object>()] : option[$opts] ( COMMA option[$opts] )* ;
-	private ActionParser.optionList_return optionList(  )
-	{
-		ActionParser.optionList_return retval = new ActionParser.optionList_return();
-		retval.start = input.LT(1);
-
-		StringTemplateAST root_0 = null;
-
-		IToken COMMA14=null;
-		ActionParser.option_return option13 = default(ActionParser.option_return);
-		ActionParser.option_return option15 = default(ActionParser.option_return);
-
-		StringTemplateAST COMMA14_tree=null;
-
-		try
-		{
-			// Language\\Action.g3:154:4: ( option[$opts] ( COMMA option[$opts] )* )
-			// Language\\Action.g3:154:4: option[$opts] ( COMMA option[$opts] )*
-			{
-			root_0 = (StringTemplateAST)adaptor.Nil();
-
-			PushFollow(Follow._option_in_optionList258);
-			option13=option(retval.opts);
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, option13.Tree);
-			// Language\\Action.g3:154:18: ( COMMA option[$opts] )*
-			for ( ; ; )
-			{
-				int alt3=2;
-				int LA3_0 = input.LA(1);
-
-				if ( (LA3_0==COMMA) )
-				{
-					alt3=1;
-				}
-
-
-				switch ( alt3 )
-				{
-				case 1:
-					// Language\\Action.g3:154:19: COMMA option[$opts]
-					{
-					COMMA14=(IToken)Match(input,COMMA,Follow._COMMA_in_optionList262); if (state.failed) return retval;
-					if ( state.backtracking==0 ) {
-					COMMA14_tree = (StringTemplateAST)adaptor.Create(COMMA14);
-					adaptor.AddChild(root_0, COMMA14_tree);
-					}
-					PushFollow(Follow._option_in_optionList264);
-					option15=option(retval.opts);
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, option15.Tree);
-
-					}
-					break;
-
-				default:
-					goto loop3;
-				}
-			}
-
-			loop3:
-				;
-
-
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "optionList"
-
-	public class option_return : ParserRuleReturnScope
-	{
-		internal StringTemplateAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "option"
-	// Language\\Action.g3:157:0: option[IDictionary<string, object> opts] : ID ( ASSIGN nonAlternatingTemplateExpr |) ;
-	private ActionParser.option_return option( IDictionary<string, object> opts )
-	{
-		ActionParser.option_return retval = new ActionParser.option_return();
-		retval.start = input.LT(1);
-
-		StringTemplateAST root_0 = null;
-
-		IToken ID16=null;
-		IToken ASSIGN17=null;
-		ActionParser.nonAlternatingTemplateExpr_return nonAlternatingTemplateExpr18 = default(ActionParser.nonAlternatingTemplateExpr_return);
-
-		StringTemplateAST ID16_tree=null;
-		StringTemplateAST ASSIGN17_tree=null;
-
-
-		object v=null;
-
-		try
-		{
-			// Language\\Action.g3:162:4: ( ID ( ASSIGN nonAlternatingTemplateExpr |) )
-			// Language\\Action.g3:162:4: ID ( ASSIGN nonAlternatingTemplateExpr |)
-			{
-			root_0 = (StringTemplateAST)adaptor.Nil();
-
-			ID16=(IToken)Match(input,ID,Follow._ID_in_option284); if (state.failed) return retval;
-			if ( state.backtracking==0 ) {
-			ID16_tree = (StringTemplateAST)adaptor.Create(ID16);
-			adaptor.AddChild(root_0, ID16_tree);
-			}
-			// Language\\Action.g3:163:3: ( ASSIGN nonAlternatingTemplateExpr |)
-			int alt4=2;
-			int LA4_0 = input.LA(1);
-
-			if ( (LA4_0==ASSIGN) )
-			{
-				alt4=1;
-			}
-			else if ( (LA4_0==EOF||LA4_0==COMMA) )
-			{
-				alt4=2;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return retval;}
-				NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt4 )
-			{
-			case 1:
-				// Language\\Action.g3:163:5: ASSIGN nonAlternatingTemplateExpr
-				{
-				ASSIGN17=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_option290); if (state.failed) return retval;
-				if ( state.backtracking==0 ) {
-				ASSIGN17_tree = (StringTemplateAST)adaptor.Create(ASSIGN17);
-				adaptor.AddChild(root_0, ASSIGN17_tree);
-				}
-				PushFollow(Follow._nonAlternatingTemplateExpr_in_option292);
-				nonAlternatingTemplateExpr18=nonAlternatingTemplateExpr();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, nonAlternatingTemplateExpr18.Tree);
-				if ( state.backtracking == 0 )
-				{
-					v=(nonAlternatingTemplateExpr18!=null?((StringTemplateAST)nonAlternatingTemplateExpr18.Tree):null);
-				}
-
-				}
-				break;
-			case 2:
-				// Language\\Action.g3:164:5:
-				{
-				if ( state.backtracking == 0 )
-				{
-					v=ASTExpr.EmptyOption;
-				}
-
-				}
-				break;
-
-			}
-
-			if ( state.backtracking == 0 )
-			{
-				opts[(ID16!=null?ID16.Text:null)] = v;
-			}
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "option"
-
-	public class templatesExpr_return : ParserRuleReturnScope
-	{
-		internal StringTemplateAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "templatesExpr"
-	// Language\\Action.g3:169:0: templatesExpr : expr ( ( COMMA expr )+ colon= COLON anonymousTemplate -> ^( MULTI_APPLY[\"MULTI_APPLY\"] ( expr )+ $colon anonymousTemplate ) | ( -> expr ) (colon= COLON templateList -> ^( APPLY[$colon] $templatesExpr templateList ) )* ) ;
-	private ActionParser.templatesExpr_return templatesExpr(  )
-	{
-		ActionParser.templatesExpr_return retval = new ActionParser.templatesExpr_return();
-		retval.start = input.LT(1);
-
-		StringTemplateAST root_0 = null;
-
-		IToken colon=null;
-		IToken COMMA20=null;
-		ActionParser.expr_return expr19 = default(ActionParser.expr_return);
-		ActionParser.expr_return expr21 = default(ActionParser.expr_return);
-		ActionParser.anonymousTemplate_return anonymousTemplate22 = default(ActionParser.anonymousTemplate_return);
-		ActionParser.templateList_return templateList23 = default(ActionParser.templateList_return);
-
-		StringTemplateAST colon_tree=null;
-		StringTemplateAST COMMA20_tree=null;
-		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
-		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
-		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
-		RewriteRuleSubtreeStream stream_anonymousTemplate=new RewriteRuleSubtreeStream(adaptor,"rule anonymousTemplate");
-		RewriteRuleSubtreeStream stream_templateList=new RewriteRuleSubtreeStream(adaptor,"rule templateList");
-		try
-		{
-			// Language\\Action.g3:171:3: ( expr ( ( COMMA expr )+ colon= COLON anonymousTemplate -> ^( MULTI_APPLY[\"MULTI_APPLY\"] ( expr )+ $colon anonymousTemplate ) | ( -> expr ) (colon= COLON templateList -> ^( APPLY[$colon] $templatesExpr templateList ) )* ) )
-			// Language\\Action.g3:171:3: expr ( ( COMMA expr )+ colon= COLON anonymousTemplate -> ^( MULTI_APPLY[\"MULTI_APPLY\"] ( expr )+ $colon anonymousTemplate ) | ( -> expr ) (colon= COLON templateList -> ^( APPLY[$colon] $templatesExpr templateList ) )* )
-			{
-			PushFollow(Follow._expr_in_templatesExpr322);
-			expr19=expr();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_expr.Add(expr19.Tree);
-			// Language\\Action.g3:172:3: ( ( COMMA expr )+ colon= COLON anonymousTemplate -> ^( MULTI_APPLY[\"MULTI_APPLY\"] ( expr )+ $colon anonymousTemplate ) | ( -> expr ) (colon= COLON templateList -> ^( APPLY[$colon] $templatesExpr templateList ) )* )
-			int alt7=2;
-			int LA7_0 = input.LA(1);
-
-			if ( (LA7_0==COMMA) )
-			{
-				alt7=1;
-			}
-			else if ( (LA7_0==EOF||LA7_0==COLON||(LA7_0>=RPAREN && LA7_0<=SEMI)) )
-			{
-				alt7=2;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return retval;}
-				NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt7 )
-			{
-			case 1:
-				// Language\\Action.g3:172:5: ( COMMA expr )+ colon= COLON anonymousTemplate
-				{
-				// Language\\Action.g3:172:5: ( COMMA expr )+
-				int cnt5=0;
-				for ( ; ; )
-				{
-					int alt5=2;
-					int LA5_0 = input.LA(1);
-
-					if ( (LA5_0==COMMA) )
-					{
-						alt5=1;
-					}
-
-
-					switch ( alt5 )
-					{
-					case 1:
-						// Language\\Action.g3:172:6: COMMA expr
-						{
-						COMMA20=(IToken)Match(input,COMMA,Follow._COMMA_in_templatesExpr329); if (state.failed) return retval;
-						if ( state.backtracking == 0 ) stream_COMMA.Add(COMMA20);
-
-						PushFollow(Follow._expr_in_templatesExpr331);
-						expr21=expr();
-
-						state._fsp--;
-						if (state.failed) return retval;
-						if ( state.backtracking == 0 ) stream_expr.Add(expr21.Tree);
-
-						}
-						break;
-
-					default:
-						if ( cnt5 >= 1 )
-							goto loop5;
-
-						if (state.backtracking>0) {state.failed=true; return retval;}
-						EarlyExitException eee5 = new EarlyExitException( 5, input );
-						throw eee5;
-					}
-					cnt5++;
-				}
-				loop5:
-					;
-
-
-				colon=(IToken)Match(input,COLON,Follow._COLON_in_templatesExpr337); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_COLON.Add(colon);
-
-				PushFollow(Follow._anonymousTemplate_in_templatesExpr339);
-				anonymousTemplate22=anonymousTemplate();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_anonymousTemplate.Add(anonymousTemplate22.Tree);
-
-
-				{
-				// AST REWRITE
-				// elements: expr, colon, anonymousTemplate
-				// token labels: colon
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleITokenStream stream_colon=new RewriteRuleITokenStream(adaptor,"token colon",colon);
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (StringTemplateAST)adaptor.Nil();
-				// 173:4: -> ^( MULTI_APPLY[\"MULTI_APPLY\"] ( expr )+ $colon anonymousTemplate )
-				{
-					// Language\\Action.g3:173:7: ^( MULTI_APPLY[\"MULTI_APPLY\"] ( expr )+ $colon anonymousTemplate )
-					{
-					StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
-					root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(MULTI_APPLY, "MULTI_APPLY"), root_1);
-
-					if ( !(stream_expr.HasNext) )
-					{
-						throw new RewriteEarlyExitException();
-					}
-					while ( stream_expr.HasNext )
-					{
-						adaptor.AddChild(root_1, stream_expr.NextTree());
-
-					}
-					stream_expr.Reset();
-					adaptor.AddChild(root_1, stream_colon.NextNode());
-					adaptor.AddChild(root_1, stream_anonymousTemplate.NextTree());
-
-					adaptor.AddChild(root_0, root_1);
-					}
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-			case 2:
-				// Language\\Action.g3:174:5: ( -> expr ) (colon= COLON templateList -> ^( APPLY[$colon] $templatesExpr templateList ) )*
-				{
-				// Language\\Action.g3:174:5: ( -> expr )
-				// Language\\Action.g3:174:7:
-				{
-
-
-
-				{
-				// AST REWRITE
-				// elements: expr
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (StringTemplateAST)adaptor.Nil();
-				// 174:7: -> expr
-				{
-					adaptor.AddChild(root_0, stream_expr.NextTree());
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-
-				// Language\\Action.g3:176:4: (colon= COLON templateList -> ^( APPLY[$colon] $templatesExpr templateList ) )*
-				for ( ; ; )
-				{
-					int alt6=2;
-					int LA6_0 = input.LA(1);
-
-					if ( (LA6_0==COLON) )
-					{
-						alt6=1;
-					}
-
-
-					switch ( alt6 )
-					{
-					case 1:
-						// Language\\Action.g3:176:6: colon= COLON templateList
-						{
-						colon=(IToken)Match(input,COLON,Follow._COLON_in_templatesExpr381); if (state.failed) return retval;
-						if ( state.backtracking == 0 ) stream_COLON.Add(colon);
-
-						PushFollow(Follow._templateList_in_templatesExpr383);
-						templateList23=templateList();
-
-						state._fsp--;
-						if (state.failed) return retval;
-						if ( state.backtracking == 0 ) stream_templateList.Add(templateList23.Tree);
-
-
-						{
-						// AST REWRITE
-						// elements: templatesExpr, templateList
-						// token labels:
-						// rule labels: retval
-						// token list labels:
-						// rule list labels:
-						// wildcard labels:
-						if ( state.backtracking == 0 ) {
-						retval.tree = root_0;
-						RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-						root_0 = (StringTemplateAST)adaptor.Nil();
-						// 177:5: -> ^( APPLY[$colon] $templatesExpr templateList )
-						{
-							// Language\\Action.g3:177:8: ^( APPLY[$colon] $templatesExpr templateList )
-							{
-							StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
-							root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(APPLY, colon), root_1);
-
-							adaptor.AddChild(root_1, stream_retval.NextTree());
-							adaptor.AddChild(root_1, stream_templateList.NextTree());
-
-							adaptor.AddChild(root_0, root_1);
-							}
-
-						}
-
-						retval.tree = root_0;
-						}
-						}
-
-						}
-						break;
-
-					default:
-						goto loop6;
-					}
-				}
-
-				loop6:
-					;
-
-
-
-				}
-				break;
-
-			}
-
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "templatesExpr"
-
-	public class templateList_return : ParserRuleReturnScope
-	{
-		internal StringTemplateAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "templateList"
-	// Language\\Action.g3:182:0: templateList : template ( COMMA template )* ;
-	private ActionParser.templateList_return templateList(  )
-	{
-		ActionParser.templateList_return retval = new ActionParser.templateList_return();
-		retval.start = input.LT(1);
-
-		StringTemplateAST root_0 = null;
-
-		IToken COMMA25=null;
-		ActionParser.template_return template24 = default(ActionParser.template_return);
-		ActionParser.template_return template26 = default(ActionParser.template_return);
-
-		StringTemplateAST COMMA25_tree=null;
-
-		try
-		{
-			// Language\\Action.g3:183:4: ( template ( COMMA template )* )
-			// Language\\Action.g3:183:4: template ( COMMA template )*
-			{
-			root_0 = (StringTemplateAST)adaptor.Nil();
-
-			PushFollow(Follow._template_in_templateList422);
-			template24=template();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, template24.Tree);
-			// Language\\Action.g3:183:13: ( COMMA template )*
-			for ( ; ; )
-			{
-				int alt8=2;
-				int LA8_0 = input.LA(1);
-
-				if ( (LA8_0==COMMA) )
-				{
-					alt8=1;
-				}
-
-
-				switch ( alt8 )
-				{
-				case 1:
-					// Language\\Action.g3:183:14: COMMA template
-					{
-					COMMA25=(IToken)Match(input,COMMA,Follow._COMMA_in_templateList425); if (state.failed) return retval;
-					PushFollow(Follow._template_in_templateList428);
-					template26=template();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, template26.Tree);
-
-					}
-					break;
-
-				default:
-					goto loop8;
-				}
-			}
-
-			loop8:
-				;
-
-
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "templateList"
-
-	public class ifCondition_return : ParserRuleReturnScope
-	{
-		internal StringTemplateAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "ifCondition"
-	// Language\\Action.g3:186:0: ifCondition : ( ifAtom | NOT ifAtom );
-	private ActionParser.ifCondition_return ifCondition(  )
-	{
-		ActionParser.ifCondition_return retval = new ActionParser.ifCondition_return();
-		retval.start = input.LT(1);
-
-		StringTemplateAST root_0 = null;
-
-		IToken NOT28=null;
-		ActionParser.ifAtom_return ifAtom27 = default(ActionParser.ifAtom_return);
-		ActionParser.ifAtom_return ifAtom29 = default(ActionParser.ifAtom_return);
-
-		StringTemplateAST NOT28_tree=null;
-
-		try
-		{
-			// Language\\Action.g3:187:4: ( ifAtom | NOT ifAtom )
-			int alt9=2;
-			int LA9_0 = input.LA(1);
-
-			if ( (LA9_0==ANONYMOUS_TEMPLATE||LA9_0==FIRST||LA9_0==ID||(LA9_0>=INT && LA9_0<=LENGTH)||LA9_0==LPAREN||LA9_0==REST||(LA9_0>=STRING && LA9_0<=SUPER)||LA9_0==TRUNC) )
-			{
-				alt9=1;
-			}
-			else if ( (LA9_0==NOT) )
-			{
-				alt9=2;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return retval;}
-				NoViableAltException nvae = new NoViableAltException("", 9, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt9 )
-			{
-			case 1:
-				// Language\\Action.g3:187:4: ifAtom
-				{
-				root_0 = (StringTemplateAST)adaptor.Nil();
-
-				PushFollow(Follow._ifAtom_in_ifCondition441);
-				ifAtom27=ifAtom();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, ifAtom27.Tree);
-
-				}
-				break;
-			case 2:
-				// Language\\Action.g3:188:4: NOT ifAtom
-				{
-				root_0 = (StringTemplateAST)adaptor.Nil();
-
-				NOT28=(IToken)Match(input,NOT,Follow._NOT_in_ifCondition446); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) {
-				NOT28_tree = (StringTemplateAST)adaptor.Create(NOT28);
-				root_0 = (StringTemplateAST)adaptor.BecomeRoot(NOT28_tree, root_0);
-				}
-				PushFollow(Follow._ifAtom_in_ifCondition449);
-				ifAtom29=ifAtom();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, ifAtom29.Tree);
-
-				}
-				break;
-
-			}
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "ifCondition"
-
-	public class ifAtom_return : ParserRuleReturnScope
-	{
-		internal StringTemplateAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "ifAtom"
-	// Language\\Action.g3:191:0: ifAtom : templatesExpr ;
-	private ActionParser.ifAtom_return ifAtom(  )
-	{
-		ActionParser.ifAtom_return retval = new ActionParser.ifAtom_return();
-		retval.start = input.LT(1);
-
-		StringTemplateAST root_0 = null;
-
-		ActionParser.templatesExpr_return templatesExpr30 = default(ActionParser.templatesExpr_return);
-
-
-		try
-		{
-			// Language\\Action.g3:192:4: ( templatesExpr )
-			// Language\\Action.g3:192:4: templatesExpr
-			{
-			root_0 = (StringTemplateAST)adaptor.Nil();
-
-			PushFollow(Follow._templatesExpr_in_ifAtom460);
-			templatesExpr30=templatesExpr();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, templatesExpr30.Tree);
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "ifAtom"
-
-	public class expr_return : ParserRuleReturnScope
-	{
-		internal StringTemplateAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "expr"
-	// Language\\Action.g3:195:0: expr : primaryExpr ( PLUS primaryExpr )* ;
-	private ActionParser.expr_return expr(  )
-	{
-		ActionParser.expr_return retval = new ActionParser.expr_return();
-		retval.start = input.LT(1);
-
-		StringTemplateAST root_0 = null;
-
-		IToken PLUS32=null;
-		ActionParser.primaryExpr_return primaryExpr31 = default(ActionParser.primaryExpr_return);
-		ActionParser.primaryExpr_return primaryExpr33 = default(ActionParser.primaryExpr_return);
-
-		StringTemplateAST PLUS32_tree=null;
-
-		try
-		{
-			// Language\\Action.g3:196:4: ( primaryExpr ( PLUS primaryExpr )* )
-			// Language\\Action.g3:196:4: primaryExpr ( PLUS primaryExpr )*
-			{
-			root_0 = (StringTemplateAST)adaptor.Nil();
-
-			PushFollow(Follow._primaryExpr_in_expr471);
-			primaryExpr31=primaryExpr();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, primaryExpr31.Tree);
-			// Language\\Action.g3:196:16: ( PLUS primaryExpr )*
-			for ( ; ; )
-			{
-				int alt10=2;
-				int LA10_0 = input.LA(1);
-
-				if ( (LA10_0==PLUS) )
-				{
-					alt10=1;
-				}
-
-
-				switch ( alt10 )
-				{
-				case 1:
-					// Language\\Action.g3:196:17: PLUS primaryExpr
-					{
-					PLUS32=(IToken)Match(input,PLUS,Follow._PLUS_in_expr474); if (state.failed) return retval;
-					if ( state.backtracking == 0 ) {
-					PLUS32_tree = (StringTemplateAST)adaptor.Create(PLUS32);
-					root_0 = (StringTemplateAST)adaptor.BecomeRoot(PLUS32_tree, root_0);
-					}
-					PushFollow(Follow._primaryExpr_in_expr477);
-					primaryExpr33=primaryExpr();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, primaryExpr33.Tree);
-
-					}
-					break;
-
-				default:
-					goto loop10;
-				}
-			}
-
-			loop10:
-				;
-
-
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "expr"
-
-	public class primaryExpr_return : ParserRuleReturnScope
-	{
-		internal StringTemplateAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "primaryExpr"
-	// Language\\Action.g3:199:0: primaryExpr : (=> templateInclude | atom ( DOT ( ID | valueExpr ) )* | function ( DOT ( ID | valueExpr ) )* | valueExpr | list );
-	private ActionParser.primaryExpr_return primaryExpr(  )
-	{
-		ActionParser.primaryExpr_return retval = new ActionParser.primaryExpr_return();
-		retval.start = input.LT(1);
-
-		StringTemplateAST root_0 = null;
-
-		IToken DOT36=null;
-		IToken ID37=null;
-		IToken DOT40=null;
-		IToken ID41=null;
-		ActionParser.templateInclude_return templateInclude34 = default(ActionParser.templateInclude_return);
-		ActionParser.atom_return atom35 = default(ActionParser.atom_return);
-		ActionParser.valueExpr_return valueExpr38 = default(ActionParser.valueExpr_return);
-		ActionParser.function_return function39 = default(ActionParser.function_return);
-		ActionParser.valueExpr_return valueExpr42 = default(ActionParser.valueExpr_return);
-		ActionParser.valueExpr_return valueExpr43 = default(ActionParser.valueExpr_return);
-		ActionParser.list_return list44 = default(ActionParser.list_return);
-
-		StringTemplateAST DOT36_tree=null;
-		StringTemplateAST ID37_tree=null;
-		StringTemplateAST DOT40_tree=null;
-		StringTemplateAST ID41_tree=null;
-
-		try
-		{
-			// Language\\Action.g3:200:4: (=> templateInclude | atom ( DOT ( ID | valueExpr ) )* | function ( DOT ( ID | valueExpr ) )* | valueExpr | list )
-			int alt15=5;
-			alt15 = dfa15.Predict(input);
-			switch ( alt15 )
-			{
-			case 1:
-				// Language\\Action.g3:200:4: => templateInclude
-				{
-				root_0 = (StringTemplateAST)adaptor.Nil();
-
-
-				PushFollow(Follow._templateInclude_in_primaryExpr494);
-				templateInclude34=templateInclude();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, templateInclude34.Tree);
-
-				}
-				break;
-			case 2:
-				// Language\\Action.g3:201:4: atom ( DOT ( ID | valueExpr ) )*
-				{
-				root_0 = (StringTemplateAST)adaptor.Nil();
-
-				PushFollow(Follow._atom_in_primaryExpr501);
-				atom35=atom();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, atom35.Tree);
-				// Language\\Action.g3:202:3: ( DOT ( ID | valueExpr ) )*
-				for ( ; ; )
-				{
-					int alt12=2;
-					int LA12_0 = input.LA(1);
-
-					if ( (LA12_0==DOT) )
-					{
-						alt12=1;
-					}
-
-
-					switch ( alt12 )
-					{
-					case 1:
-						// Language\\Action.g3:202:5: DOT ( ID | valueExpr )
-						{
-						DOT36=(IToken)Match(input,DOT,Follow._DOT_in_primaryExpr507); if (state.failed) return retval;
-						if ( state.backtracking == 0 ) {
-						DOT36_tree = (StringTemplateAST)adaptor.Create(DOT36);
-						root_0 = (StringTemplateAST)adaptor.BecomeRoot(DOT36_tree, root_0);
-						}
-						// Language\\Action.g3:203:4: ( ID | valueExpr )
-						int alt11=2;
-						int LA11_0 = input.LA(1);
-
-						if ( (LA11_0==ID) )
-						{
-							alt11=1;
-						}
-						else if ( (LA11_0==LPAREN) )
-						{
-							alt11=2;
-						}
-						else
-						{
-							if (state.backtracking>0) {state.failed=true; return retval;}
-							NoViableAltException nvae = new NoViableAltException("", 11, 0, input);
-
-							throw nvae;
-						}
-						switch ( alt11 )
-						{
-						case 1:
-							// Language\\Action.g3:203:6: ID
-							{
-							ID37=(IToken)Match(input,ID,Follow._ID_in_primaryExpr516); if (state.failed) return retval;
-							if ( state.backtracking==0 ) {
-							ID37_tree = (StringTemplateAST)adaptor.Create(ID37);
-							adaptor.AddChild(root_0, ID37_tree);
-							}
-
-							}
-							break;
-						case 2:
-							// Language\\Action.g3:204:6: valueExpr
-							{
-							PushFollow(Follow._valueExpr_in_primaryExpr523);
-							valueExpr38=valueExpr();
-
-							state._fsp--;
-							if (state.failed) return retval;
-							if ( state.backtracking == 0 ) adaptor.AddChild(root_0, valueExpr38.Tree);
-
-							}
-							break;
-
-						}
-
-
-						}
-						break;
-
-					default:
-						goto loop12;
-					}
-				}
-
-				loop12:
-					;
-
-
-
-				}
-				break;
-			case 3:
-				// Language\\Action.g3:207:4: function ( DOT ( ID | valueExpr ) )*
-				{
-				root_0 = (StringTemplateAST)adaptor.Nil();
-
-				PushFollow(Follow._function_in_primaryExpr538);
-				function39=function();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, function39.Tree);
-				// Language\\Action.g3:208:3: ( DOT ( ID | valueExpr ) )*
-				for ( ; ; )
-				{
-					int alt14=2;
-					int LA14_0 = input.LA(1);
-
-					if ( (LA14_0==DOT) )
-					{
-						alt14=1;
-					}
-
-
-					switch ( alt14 )
-					{
-					case 1:
-						// Language\\Action.g3:208:5: DOT ( ID | valueExpr )
-						{
-						DOT40=(IToken)Match(input,DOT,Follow._DOT_in_primaryExpr544); if (state.failed) return retval;
-						if ( state.backtracking == 0 ) {
-						DOT40_tree = (StringTemplateAST)adaptor.Create(DOT40);
-						root_0 = (StringTemplateAST)adaptor.BecomeRoot(DOT40_tree, root_0);
-						}
-						// Language\\Action.g3:209:4: ( ID | valueExpr )
-						int alt13=2;
-						int LA13_0 = input.LA(1);
-
-						if ( (LA13_0==ID) )
-						{
-							alt13=1;
-						}
-						else if ( (LA13_0==LPAREN) )
-						{
-							alt13=2;
-						}
-						else
-						{
-							if (state.backtracking>0) {state.failed=true; return retval;}
-							NoViableAltException nvae = new NoViableAltException("", 13, 0, input);
-
-							throw nvae;
-						}
-						switch ( alt13 )
-						{
-						case 1:
-							// Language\\Action.g3:209:6: ID
-							{
-							ID41=(IToken)Match(input,ID,Follow._ID_in_primaryExpr552); if (state.failed) return retval;
-							if ( state.backtracking==0 ) {
-							ID41_tree = (StringTemplateAST)adaptor.Create(ID41);
-							adaptor.AddChild(root_0, ID41_tree);
-							}
-
-							}
-							break;
-						case 2:
-							// Language\\Action.g3:210:6: valueExpr
-							{
-							PushFollow(Follow._valueExpr_in_primaryExpr559);
-							valueExpr42=valueExpr();
-
-							state._fsp--;
-							if (state.failed) return retval;
-							if ( state.backtracking == 0 ) adaptor.AddChild(root_0, valueExpr42.Tree);
-
-							}
-							break;
-
-						}
-
-
-						}
-						break;
-
-					default:
-						goto loop14;
-					}
-				}
-
-				loop14:
-					;
-
-
-
-				}
-				break;
-			case 4:
-				// Language\\Action.g3:213:4: valueExpr
-				{
-				root_0 = (StringTemplateAST)adaptor.Nil();
-
-				PushFollow(Follow._valueExpr_in_primaryExpr574);
-				valueExpr43=valueExpr();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, valueExpr43.Tree);
-
-				}
-				break;
-			case 5:
-				// Language\\Action.g3:214:4: list
-				{
-				root_0 = (StringTemplateAST)adaptor.Nil();
-
-				PushFollow(Follow._list_in_primaryExpr579);
-				list44=list();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, list44.Tree);
-
-				}
-				break;
-
-			}
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "primaryExpr"
-
-	public class valueExpr_return : ParserRuleReturnScope
-	{
-		internal StringTemplateAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "valueExpr"
-	// Language\\Action.g3:217:0: valueExpr : LPAREN templatesExpr RPAREN -> ^( VALUE[$LPAREN,\"value\"] templatesExpr ) ;
-	private ActionParser.valueExpr_return valueExpr(  )
-	{
-		ActionParser.valueExpr_return retval = new ActionParser.valueExpr_return();
-		retval.start = input.LT(1);
-
-		StringTemplateAST root_0 = null;
-
-		IToken LPAREN45=null;
-		IToken RPAREN47=null;
-		ActionParser.templatesExpr_return templatesExpr46 = default(ActionParser.templatesExpr_return);
-
-		StringTemplateAST LPAREN45_tree=null;
-		StringTemplateAST RPAREN47_tree=null;
-		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
-		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
-		RewriteRuleSubtreeStream stream_templatesExpr=new RewriteRuleSubtreeStream(adaptor,"rule templatesExpr");
-		try
-		{
-			// Language\\Action.g3:218:4: ( LPAREN templatesExpr RPAREN -> ^( VALUE[$LPAREN,\"value\"] templatesExpr ) )
-			// Language\\Action.g3:218:4: LPAREN templatesExpr RPAREN
-			{
-			LPAREN45=(IToken)Match(input,LPAREN,Follow._LPAREN_in_valueExpr590); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_LPAREN.Add(LPAREN45);
-
-			PushFollow(Follow._templatesExpr_in_valueExpr592);
-			templatesExpr46=templatesExpr();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_templatesExpr.Add(templatesExpr46.Tree);
-			RPAREN47=(IToken)Match(input,RPAREN,Follow._RPAREN_in_valueExpr594); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_RPAREN.Add(RPAREN47);
-
-
-
-			{
-			// AST REWRITE
-			// elements: templatesExpr
-			// token labels:
-			// rule labels: retval
-			// token list labels:
-			// rule list labels:
-			// wildcard labels:
-			if ( state.backtracking == 0 ) {
-			retval.tree = root_0;
-			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-			root_0 = (StringTemplateAST)adaptor.Nil();
-			// 219:3: -> ^( VALUE[$LPAREN,\"value\"] templatesExpr )
-			{
-				// Language\\Action.g3:219:6: ^( VALUE[$LPAREN,\"value\"] templatesExpr )
-				{
-				StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
-				root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(VALUE, LPAREN45, "value"), root_1);
-
-				adaptor.AddChild(root_1, stream_templatesExpr.NextTree());
-
-				adaptor.AddChild(root_0, root_1);
-				}
-
-			}
-
-			retval.tree = root_0;
-			}
-			}
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "valueExpr"
-
-	public class nonAlternatingTemplateExpr_return : ParserRuleReturnScope
-	{
-		internal StringTemplateAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "nonAlternatingTemplateExpr"
-	// Language\\Action.g3:222:0: nonAlternatingTemplateExpr : ( expr -> expr ) ( COLON template -> ^( APPLY[$COLON] $nonAlternatingTemplateExpr template ) )* ;
-	private ActionParser.nonAlternatingTemplateExpr_return nonAlternatingTemplateExpr(  )
-	{
-		ActionParser.nonAlternatingTemplateExpr_return retval = new ActionParser.nonAlternatingTemplateExpr_return();
-		retval.start = input.LT(1);
-
-		StringTemplateAST root_0 = null;
-
-		IToken COLON49=null;
-		ActionParser.expr_return expr48 = default(ActionParser.expr_return);
-		ActionParser.template_return template50 = default(ActionParser.template_return);
-
-		StringTemplateAST COLON49_tree=null;
-		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
-		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
-		RewriteRuleSubtreeStream stream_template=new RewriteRuleSubtreeStream(adaptor,"rule template");
-		try
-		{
-			// Language\\Action.g3:223:4: ( ( expr -> expr ) ( COLON template -> ^( APPLY[$COLON] $nonAlternatingTemplateExpr template ) )* )
-			// Language\\Action.g3:223:4: ( expr -> expr ) ( COLON template -> ^( APPLY[$COLON] $nonAlternatingTemplateExpr template ) )*
-			{
-			// Language\\Action.g3:223:4: ( expr -> expr )
-			// Language\\Action.g3:223:5: expr
-			{
-			PushFollow(Follow._expr_in_nonAlternatingTemplateExpr617);
-			expr48=expr();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_expr.Add(expr48.Tree);
-
-
-			{
-			// AST REWRITE
-			// elements: expr
-			// token labels:
-			// rule labels: retval
-			// token list labels:
-			// rule list labels:
-			// wildcard labels:
-			if ( state.backtracking == 0 ) {
-			retval.tree = root_0;
-			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-			root_0 = (StringTemplateAST)adaptor.Nil();
-			// 223:10: -> expr
-			{
-				adaptor.AddChild(root_0, stream_expr.NextTree());
-
-			}
-
-			retval.tree = root_0;
-			}
-			}
-
-			}
-
-			// Language\\Action.g3:223:19: ( COLON template -> ^( APPLY[$COLON] $nonAlternatingTemplateExpr template ) )*
-			for ( ; ; )
-			{
-				int alt16=2;
-				int LA16_0 = input.LA(1);
-
-				if ( (LA16_0==COLON) )
-				{
-					alt16=1;
-				}
-
-
-				switch ( alt16 )
-				{
-				case 1:
-					// Language\\Action.g3:223:21: COLON template
-					{
-					COLON49=(IToken)Match(input,COLON,Follow._COLON_in_nonAlternatingTemplateExpr626); if (state.failed) return retval;
-					if ( state.backtracking == 0 ) stream_COLON.Add(COLON49);
-
-					PushFollow(Follow._template_in_nonAlternatingTemplateExpr628);
-					template50=template();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) stream_template.Add(template50.Tree);
-
-
-					{
-					// AST REWRITE
-					// elements: nonAlternatingTemplateExpr, template
-					// token labels:
-					// rule labels: retval
-					// token list labels:
-					// rule list labels:
-					// wildcard labels:
-					if ( state.backtracking == 0 ) {
-					retval.tree = root_0;
-					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-					root_0 = (StringTemplateAST)adaptor.Nil();
-					// 223:36: -> ^( APPLY[$COLON] $nonAlternatingTemplateExpr template )
-					{
-						// Language\\Action.g3:223:39: ^( APPLY[$COLON] $nonAlternatingTemplateExpr template )
-						{
-						StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
-						root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(APPLY, COLON49), root_1);
-
-						adaptor.AddChild(root_1, stream_retval.NextTree());
-						adaptor.AddChild(root_1, stream_template.NextTree());
-
-						adaptor.AddChild(root_0, root_1);
-						}
-
-					}
-
-					retval.tree = root_0;
-					}
-					}
-
-					}
-					break;
-
-				default:
-					goto loop16;
-				}
-			}
-
-			loop16:
-				;
-
-
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "nonAlternatingTemplateExpr"
-
-	public class function_return : ParserRuleReturnScope
-	{
-		internal StringTemplateAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "function"
-	// Language\\Action.g3:226:0: function : ( 'first' | 'rest' | 'last' | 'length' | 'strip' | 'trunc' ) singleArg -> ^( FUNCTION ( 'first' )? ( 'rest' )? ( 'last' )? ( 'length' )? ( 'strip' )? ( 'trunc' )? singleArg ) ;
-	private ActionParser.function_return function(  )
-	{
-		ActionParser.function_return retval = new ActionParser.function_return();
-		retval.start = input.LT(1);
-
-		StringTemplateAST root_0 = null;
-
-		IToken string_literal51=null;
-		IToken string_literal52=null;
-		IToken string_literal53=null;
-		IToken string_literal54=null;
-		IToken string_literal55=null;
-		IToken string_literal56=null;
-		ActionParser.singleArg_return singleArg57 = default(ActionParser.singleArg_return);
-
-		StringTemplateAST string_literal51_tree=null;
-		StringTemplateAST string_literal52_tree=null;
-		StringTemplateAST string_literal53_tree=null;
-		StringTemplateAST string_literal54_tree=null;
-		StringTemplateAST string_literal55_tree=null;
-		StringTemplateAST string_literal56_tree=null;
-		RewriteRuleITokenStream stream_FIRST=new RewriteRuleITokenStream(adaptor,"token FIRST");
-		RewriteRuleITokenStream stream_REST=new RewriteRuleITokenStream(adaptor,"token REST");
-		RewriteRuleITokenStream stream_LAST=new RewriteRuleITokenStream(adaptor,"token LAST");
-		RewriteRuleITokenStream stream_LENGTH=new RewriteRuleITokenStream(adaptor,"token LENGTH");
-		RewriteRuleITokenStream stream_STRIP=new RewriteRuleITokenStream(adaptor,"token STRIP");
-		RewriteRuleITokenStream stream_TRUNC=new RewriteRuleITokenStream(adaptor,"token TRUNC");
-		RewriteRuleSubtreeStream stream_singleArg=new RewriteRuleSubtreeStream(adaptor,"rule singleArg");
-		try
-		{
-			// Language\\Action.g3:227:4: ( ( 'first' | 'rest' | 'last' | 'length' | 'strip' | 'trunc' ) singleArg -> ^( FUNCTION ( 'first' )? ( 'rest' )? ( 'last' )? ( 'length' )? ( 'strip' )? ( 'trunc' )? singleArg ) )
-			// Language\\Action.g3:227:4: ( 'first' | 'rest' | 'last' | 'length' | 'strip' | 'trunc' ) singleArg
-			{
-			// Language\\Action.g3:227:4: ( 'first' | 'rest' | 'last' | 'length' | 'strip' | 'trunc' )
-			int alt17=6;
-			switch ( input.LA(1) )
-			{
-			case FIRST:
-				{
-				alt17=1;
-				}
-				break;
-			case REST:
-				{
-				alt17=2;
-				}
-				break;
-			case LAST:
-				{
-				alt17=3;
-				}
-				break;
-			case LENGTH:
-				{
-				alt17=4;
-				}
-				break;
-			case STRIP:
-				{
-				alt17=5;
-				}
-				break;
-			case TRUNC:
-				{
-				alt17=6;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 17, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt17 )
-			{
-			case 1:
-				// Language\\Action.g3:227:6: 'first'
-				{
-				string_literal51=(IToken)Match(input,FIRST,Follow._FIRST_in_function656); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_FIRST.Add(string_literal51);
-
-
-				}
-				break;
-			case 2:
-				// Language\\Action.g3:228:5: 'rest'
-				{
-				string_literal52=(IToken)Match(input,REST,Follow._REST_in_function662); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_REST.Add(string_literal52);
-
-
-				}
-				break;
-			case 3:
-				// Language\\Action.g3:229:5: 'last'
-				{
-				string_literal53=(IToken)Match(input,LAST,Follow._LAST_in_function668); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_LAST.Add(string_literal53);
-
-
-				}
-				break;
-			case 4:
-				// Language\\Action.g3:230:5: 'length'
-				{
-				string_literal54=(IToken)Match(input,LENGTH,Follow._LENGTH_in_function674); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_LENGTH.Add(string_literal54);
-
-
-				}
-				break;
-			case 5:
-				// Language\\Action.g3:231:5: 'strip'
-				{
-				string_literal55=(IToken)Match(input,STRIP,Follow._STRIP_in_function680); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_STRIP.Add(string_literal55);
-
-
-				}
-				break;
-			case 6:
-				// Language\\Action.g3:232:5: 'trunc'
-				{
-				string_literal56=(IToken)Match(input,TRUNC,Follow._TRUNC_in_function686); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_TRUNC.Add(string_literal56);
-
-
-				}
-				break;
-
-			}
-
-			PushFollow(Follow._singleArg_in_function694);
-			singleArg57=singleArg();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_singleArg.Add(singleArg57.Tree);
-
-
-			{
-			// AST REWRITE
-			// elements: FIRST, REST, LAST, LENGTH, STRIP, TRUNC, singleArg
-			// token labels:
-			// rule labels: retval
-			// token list labels:
-			// rule list labels:
-			// wildcard labels:
-			if ( state.backtracking == 0 ) {
-			retval.tree = root_0;
-			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-			root_0 = (StringTemplateAST)adaptor.Nil();
-			// 235:3: -> ^( FUNCTION ( 'first' )? ( 'rest' )? ( 'last' )? ( 'length' )? ( 'strip' )? ( 'trunc' )? singleArg )
-			{
-				// Language\\Action.g3:235:6: ^( FUNCTION ( 'first' )? ( 'rest' )? ( 'last' )? ( 'length' )? ( 'strip' )? ( 'trunc' )? singleArg )
-				{
-				StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
-				root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(FUNCTION, "FUNCTION"), root_1);
-
-				// Language\\Action.g3:235:17: ( 'first' )?
-				if ( stream_FIRST.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_FIRST.NextNode());
-
-				}
-				stream_FIRST.Reset();
-				// Language\\Action.g3:235:26: ( 'rest' )?
-				if ( stream_REST.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_REST.NextNode());
-
-				}
-				stream_REST.Reset();
-				// Language\\Action.g3:235:34: ( 'last' )?
-				if ( stream_LAST.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_LAST.NextNode());
-
-				}
-				stream_LAST.Reset();
-				// Language\\Action.g3:235:42: ( 'length' )?
-				if ( stream_LENGTH.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_LENGTH.NextNode());
-
-				}
-				stream_LENGTH.Reset();
-				// Language\\Action.g3:235:52: ( 'strip' )?
-				if ( stream_STRIP.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_STRIP.NextNode());
-
-				}
-				stream_STRIP.Reset();
-				// Language\\Action.g3:235:61: ( 'trunc' )?
-				if ( stream_TRUNC.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_TRUNC.NextNode());
-
-				}
-				stream_TRUNC.Reset();
-				adaptor.AddChild(root_1, stream_singleArg.NextTree());
-
-				adaptor.AddChild(root_0, root_1);
-				}
-
-			}
-
-			retval.tree = root_0;
-			}
-			}
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "function"
-
-	public class template_return : ParserRuleReturnScope
-	{
-		internal StringTemplateAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "template"
-	// Language\\Action.g3:238:0: template : ( namedTemplate | anonymousTemplate ) -> ^( TEMPLATE ( namedTemplate )? ( anonymousTemplate )? ) ;
-	private ActionParser.template_return template(  )
-	{
-		ActionParser.template_return retval = new ActionParser.template_return();
-		retval.start = input.LT(1);
-
-		StringTemplateAST root_0 = null;
-
-		ActionParser.namedTemplate_return namedTemplate58 = default(ActionParser.namedTemplate_return);
-		ActionParser.anonymousTemplate_return anonymousTemplate59 = default(ActionParser.anonymousTemplate_return);
-
-		RewriteRuleSubtreeStream stream_namedTemplate=new RewriteRuleSubtreeStream(adaptor,"rule namedTemplate");
-		RewriteRuleSubtreeStream stream_anonymousTemplate=new RewriteRuleSubtreeStream(adaptor,"rule anonymousTemplate");
-		try
-		{
-			// Language\\Action.g3:239:4: ( ( namedTemplate | anonymousTemplate ) -> ^( TEMPLATE ( namedTemplate )? ( anonymousTemplate )? ) )
-			// Language\\Action.g3:239:4: ( namedTemplate | anonymousTemplate )
-			{
-			// Language\\Action.g3:239:4: ( namedTemplate | anonymousTemplate )
-			int alt18=2;
-			int LA18_0 = input.LA(1);
-
-			if ( (LA18_0==ID||LA18_0==LPAREN||LA18_0==SUPER) )
-			{
-				alt18=1;
-			}
-			else if ( (LA18_0==ANONYMOUS_TEMPLATE) )
-			{
-				alt18=2;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return retval;}
-				NoViableAltException nvae = new NoViableAltException("", 18, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt18 )
-			{
-			case 1:
-				// Language\\Action.g3:239:6: namedTemplate
-				{
-				PushFollow(Follow._namedTemplate_in_template735);
-				namedTemplate58=namedTemplate();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_namedTemplate.Add(namedTemplate58.Tree);
-
-				}
-				break;
-			case 2:
-				// Language\\Action.g3:240:5: anonymousTemplate
-				{
-				PushFollow(Follow._anonymousTemplate_in_template744);
-				anonymousTemplate59=anonymousTemplate();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_anonymousTemplate.Add(anonymousTemplate59.Tree);
-
-				}
-				break;
-
-			}
-
-
-
-			{
-			// AST REWRITE
-			// elements: namedTemplate, anonymousTemplate
-			// token labels:
-			// rule labels: retval
-			// token list labels:
-			// rule list labels:
-			// wildcard labels:
-			if ( state.backtracking == 0 ) {
-			retval.tree = root_0;
-			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-			root_0 = (StringTemplateAST)adaptor.Nil();
-			// 242:3: -> ^( TEMPLATE ( namedTemplate )? ( anonymousTemplate )? )
-			{
-				// Language\\Action.g3:242:6: ^( TEMPLATE ( namedTemplate )? ( anonymousTemplate )? )
-				{
-				StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
-				root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(TEMPLATE, "TEMPLATE"), root_1);
-
-				// Language\\Action.g3:242:17: ( namedTemplate )?
-				if ( stream_namedTemplate.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_namedTemplate.NextTree());
-
-				}
-				stream_namedTemplate.Reset();
-				// Language\\Action.g3:242:32: ( anonymousTemplate )?
-				if ( stream_anonymousTemplate.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_anonymousTemplate.NextTree());
-
-				}
-				stream_anonymousTemplate.Reset();
-
-				adaptor.AddChild(root_0, root_1);
-				}
-
-			}
-
-			retval.tree = root_0;
-			}
-			}
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "template"
-
-	public class namedTemplate_return : ParserRuleReturnScope
-	{
-		internal StringTemplateAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "namedTemplate"
-	// Language\\Action.g3:245:0: namedTemplate : ( ID argList -> ID argList | 'super' DOT qid= ID argList -> ID[$qid,\"super.\"+$qid.text] argList | indirectTemplate -> indirectTemplate );
-	private ActionParser.namedTemplate_return namedTemplate(  )
-	{
-		ActionParser.namedTemplate_return retval = new ActionParser.namedTemplate_return();
-		retval.start = input.LT(1);
-
-		StringTemplateAST root_0 = null;
-
-		IToken qid=null;
-		IToken ID60=null;
-		IToken string_literal62=null;
-		IToken DOT63=null;
-		ActionParser.argList_return argList61 = default(ActionParser.argList_return);
-		ActionParser.argList_return argList64 = default(ActionParser.argList_return);
-		ActionParser.indirectTemplate_return indirectTemplate65 = default(ActionParser.indirectTemplate_return);
-
-		StringTemplateAST qid_tree=null;
-		StringTemplateAST ID60_tree=null;
-		StringTemplateAST string_literal62_tree=null;
-		StringTemplateAST DOT63_tree=null;
-		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
-		RewriteRuleITokenStream stream_SUPER=new RewriteRuleITokenStream(adaptor,"token SUPER");
-		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
-		RewriteRuleSubtreeStream stream_argList=new RewriteRuleSubtreeStream(adaptor,"rule argList");
-		RewriteRuleSubtreeStream stream_indirectTemplate=new RewriteRuleSubtreeStream(adaptor,"rule indirectTemplate");
-		try
-		{
-			// Language\\Action.g3:246:4: ( ID argList -> ID argList | 'super' DOT qid= ID argList -> ID[$qid,\"super.\"+$qid.text] argList | indirectTemplate -> indirectTemplate )
-			int alt19=3;
-			switch ( input.LA(1) )
-			{
-			case ID:
-				{
-				alt19=1;
-				}
-				break;
-			case SUPER:
-				{
-				alt19=2;
-				}
-				break;
-			case LPAREN:
-				{
-				alt19=3;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 19, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt19 )
-			{
-			case 1:
-				// Language\\Action.g3:246:4: ID argList
-				{
-				ID60=(IToken)Match(input,ID,Follow._ID_in_namedTemplate775); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_ID.Add(ID60);
-
-				PushFollow(Follow._argList_in_namedTemplate777);
-				argList61=argList();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_argList.Add(argList61.Tree);
-
-
-				{
-				// AST REWRITE
-				// elements: ID, argList
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (StringTemplateAST)adaptor.Nil();
-				// 247:3: -> ID argList
-				{
-					adaptor.AddChild(root_0, stream_ID.NextNode());
-					adaptor.AddChild(root_0, stream_argList.NextTree());
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-			case 2:
-				// Language\\Action.g3:248:4: 'super' DOT qid= ID argList
-				{
-				string_literal62=(IToken)Match(input,SUPER,Follow._SUPER_in_namedTemplate790); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_SUPER.Add(string_literal62);
-
-				DOT63=(IToken)Match(input,DOT,Follow._DOT_in_namedTemplate792); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_DOT.Add(DOT63);
-
-				qid=(IToken)Match(input,ID,Follow._ID_in_namedTemplate796); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_ID.Add(qid);
-
-				PushFollow(Follow._argList_in_namedTemplate798);
-				argList64=argList();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_argList.Add(argList64.Tree);
-
-
-				{
-				// AST REWRITE
-				// elements: ID, argList
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (StringTemplateAST)adaptor.Nil();
-				// 249:3: -> ID[$qid,\"super.\"+$qid.text] argList
-				{
-					adaptor.AddChild(root_0, (StringTemplateAST)adaptor.Create(ID, qid, "super."+(qid!=null?qid.Text:null)));
-					adaptor.AddChild(root_0, stream_argList.NextTree());
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-			case 3:
-				// Language\\Action.g3:250:4: indirectTemplate
-				{
-				PushFollow(Follow._indirectTemplate_in_namedTemplate812);
-				indirectTemplate65=indirectTemplate();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_indirectTemplate.Add(indirectTemplate65.Tree);
-
-
-				{
-				// AST REWRITE
-				// elements: indirectTemplate
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (StringTemplateAST)adaptor.Nil();
-				// 251:3: -> indirectTemplate
-				{
-					adaptor.AddChild(root_0, stream_indirectTemplate.NextTree());
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-
-			}
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "namedTemplate"
-
-	public class anonymousTemplate_return : ParserRuleReturnScope
-	{
-		internal StringTemplateAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "anonymousTemplate"
-	// Language\\Action.g3:254:0: anonymousTemplate : t= ANONYMOUS_TEMPLATE ;
-	private ActionParser.anonymousTemplate_return anonymousTemplate(  )
-	{
-		ActionParser.anonymousTemplate_return retval = new ActionParser.anonymousTemplate_return();
-		retval.start = input.LT(1);
-
-		StringTemplateAST root_0 = null;
-
-		IToken t=null;
-
-		StringTemplateAST t_tree=null;
-
-
-			StringTemplate anonymous = null;
-
-		try
-		{
-			// Language\\Action.g3:263:4: (t= ANONYMOUS_TEMPLATE )
-			// Language\\Action.g3:263:4: t= ANONYMOUS_TEMPLATE
-			{
-			root_0 = (StringTemplateAST)adaptor.Nil();
-
-			t=(IToken)Match(input,ANONYMOUS_TEMPLATE,Follow._ANONYMOUS_TEMPLATE_in_anonymousTemplate841); if (state.failed) return retval;
-			if ( state.backtracking==0 ) {
-			t_tree = (StringTemplateAST)adaptor.Create(t);
-			adaptor.AddChild(root_0, t_tree);
-			}
-			if ( state.backtracking == 0 )
-			{
-
-							anonymous = new StringTemplate();
-							anonymous.Group = self.Group;
-							anonymous.EnclosingInstance = self;
-							anonymous.Template = (t!=null?t.Text:null);
-							if ( t is StringTemplateToken )
-								anonymous.DefineFormalArguments(((StringTemplateToken)t).args);
-							else
-								anonymous.DefineFormalArguments(new string[0]);
-
-			}
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-			if ( state.backtracking == 0 )
-			{
-
-					((StringTemplateAST)retval.Tree).StringTemplate = anonymous;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "anonymousTemplate"
-
-	public class atom_return : ParserRuleReturnScope
-	{
-		internal StringTemplateAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "atom"
-	// Language\\Action.g3:276:0: atom : ( ID | STRING | INT | ANONYMOUS_TEMPLATE );
-	private ActionParser.atom_return atom(  )
-	{
-		ActionParser.atom_return retval = new ActionParser.atom_return();
-		retval.start = input.LT(1);
-
-		StringTemplateAST root_0 = null;
-
-		IToken set66=null;
-
-		StringTemplateAST set66_tree=null;
-
-		try
-		{
-			// Language\\Action.g3:277:4: ( ID | STRING | INT | ANONYMOUS_TEMPLATE )
-			// Language\\Action.g3:
-			{
-			root_0 = (StringTemplateAST)adaptor.Nil();
-
-			set66=(IToken)input.LT(1);
-			if ( input.LA(1)==ANONYMOUS_TEMPLATE||input.LA(1)==ID||input.LA(1)==INT||input.LA(1)==STRING )
-			{
-				input.Consume();
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (StringTemplateAST)adaptor.Create(set66));
-				state.errorRecovery=false;state.failed=false;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return retval;}
-				MismatchedSetException mse = new MismatchedSetException(null,input);
-				throw mse;
-			}
-
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "atom"
-
-	public class list_return : ParserRuleReturnScope
-	{
-		internal StringTemplateAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "list"
-	// Language\\Action.g3:283:0: list : lb= LBRACK listElement ( COMMA listElement )* RBRACK -> ^( LIST[$lb,\"value\"] ( listElement )+ ) ;
-	private ActionParser.list_return list(  )
-	{
-		ActionParser.list_return retval = new ActionParser.list_return();
-		retval.start = input.LT(1);
-
-		StringTemplateAST root_0 = null;
-
-		IToken lb=null;
-		IToken COMMA68=null;
-		IToken RBRACK70=null;
-		ActionParser.listElement_return listElement67 = default(ActionParser.listElement_return);
-		ActionParser.listElement_return listElement69 = default(ActionParser.listElement_return);
-
-		StringTemplateAST lb_tree=null;
-		StringTemplateAST COMMA68_tree=null;
-		StringTemplateAST RBRACK70_tree=null;
-		RewriteRuleITokenStream stream_LBRACK=new RewriteRuleITokenStream(adaptor,"token LBRACK");
-		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
-		RewriteRuleITokenStream stream_RBRACK=new RewriteRuleITokenStream(adaptor,"token RBRACK");
-		RewriteRuleSubtreeStream stream_listElement=new RewriteRuleSubtreeStream(adaptor,"rule listElement");
-		try
-		{
-			// Language\\Action.g3:284:4: (lb= LBRACK listElement ( COMMA listElement )* RBRACK -> ^( LIST[$lb,\"value\"] ( listElement )+ ) )
-			// Language\\Action.g3:284:4: lb= LBRACK listElement ( COMMA listElement )* RBRACK
-			{
-			lb=(IToken)Match(input,LBRACK,Follow._LBRACK_in_list884); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_LBRACK.Add(lb);
-
-			PushFollow(Follow._listElement_in_list888);
-			listElement67=listElement();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_listElement.Add(listElement67.Tree);
-			// Language\\Action.g3:285:15: ( COMMA listElement )*
-			for ( ; ; )
-			{
-				int alt20=2;
-				int LA20_0 = input.LA(1);
-
-				if ( (LA20_0==COMMA) )
-				{
-					alt20=1;
-				}
-
-
-				switch ( alt20 )
-				{
-				case 1:
-					// Language\\Action.g3:285:16: COMMA listElement
-					{
-					COMMA68=(IToken)Match(input,COMMA,Follow._COMMA_in_list891); if (state.failed) return retval;
-					if ( state.backtracking == 0 ) stream_COMMA.Add(COMMA68);
-
-					PushFollow(Follow._listElement_in_list893);
-					listElement69=listElement();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) stream_listElement.Add(listElement69.Tree);
-
-					}
-					break;
-
-				default:
-					goto loop20;
-				}
-			}
-
-			loop20:
-				;
-
-
-			RBRACK70=(IToken)Match(input,RBRACK,Follow._RBRACK_in_list899); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_RBRACK.Add(RBRACK70);
-
-
-
-			{
-			// AST REWRITE
-			// elements: listElement
-			// token labels:
-			// rule labels: retval
-			// token list labels:
-			// rule list labels:
-			// wildcard labels:
-			if ( state.backtracking == 0 ) {
-			retval.tree = root_0;
-			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-			root_0 = (StringTemplateAST)adaptor.Nil();
-			// 287:3: -> ^( LIST[$lb,\"value\"] ( listElement )+ )
-			{
-				// Language\\Action.g3:287:6: ^( LIST[$lb,\"value\"] ( listElement )+ )
-				{
-				StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
-				root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(LIST, lb, "value"), root_1);
-
-				if ( !(stream_listElement.HasNext) )
-				{
-					throw new RewriteEarlyExitException();
-				}
-				while ( stream_listElement.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_listElement.NextTree());
-
-				}
-				stream_listElement.Reset();
-
-				adaptor.AddChild(root_0, root_1);
-				}
-
-			}
-
-			retval.tree = root_0;
-			}
-			}
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "list"
-
-	public class listElement_return : ParserRuleReturnScope
-	{
-		internal StringTemplateAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "listElement"
-	// Language\\Action.g3:290:0: listElement : ( nonAlternatingTemplateExpr | -> NOTHING[\"NOTHING\"] );
-	private ActionParser.listElement_return listElement(  )
-	{
-		ActionParser.listElement_return retval = new ActionParser.listElement_return();
-		retval.start = input.LT(1);
-
-		StringTemplateAST root_0 = null;
-
-		ActionParser.nonAlternatingTemplateExpr_return nonAlternatingTemplateExpr71 = default(ActionParser.nonAlternatingTemplateExpr_return);
-
-
-		try
-		{
-			// Language\\Action.g3:291:4: ( nonAlternatingTemplateExpr | -> NOTHING[\"NOTHING\"] )
-			int alt21=2;
-			int LA21_0 = input.LA(1);
-
-			if ( (LA21_0==ANONYMOUS_TEMPLATE||LA21_0==FIRST||LA21_0==ID||(LA21_0>=INT && LA21_0<=LENGTH)||LA21_0==LPAREN||LA21_0==REST||(LA21_0>=STRING && LA21_0<=SUPER)||LA21_0==TRUNC) )
-			{
-				alt21=1;
-			}
-			else if ( (LA21_0==COMMA||LA21_0==RBRACK) )
-			{
-				alt21=2;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return retval;}
-				NoViableAltException nvae = new NoViableAltException("", 21, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt21 )
-			{
-			case 1:
-				// Language\\Action.g3:291:4: nonAlternatingTemplateExpr
-				{
-				root_0 = (StringTemplateAST)adaptor.Nil();
-
-				PushFollow(Follow._nonAlternatingTemplateExpr_in_listElement922);
-				nonAlternatingTemplateExpr71=nonAlternatingTemplateExpr();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, nonAlternatingTemplateExpr71.Tree);
-
-				}
-				break;
-			case 2:
-				// Language\\Action.g3:293:3:
-				{
-
-
-
-				{
-				// AST REWRITE
-				// elements:
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (StringTemplateAST)adaptor.Nil();
-				// 293:3: -> NOTHING[\"NOTHING\"]
-				{
-					adaptor.AddChild(root_0, (StringTemplateAST)adaptor.Create(NOTHING, "NOTHING"));
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-
-			}
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "listElement"
-
-	public class templateInclude_return : ParserRuleReturnScope
-	{
-		internal StringTemplateAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "templateInclude"
-	// Language\\Action.g3:296:0: templateInclude : (id= ID argList -> $id argList | 'super' DOT qid= ID argList -> ID[$qid,\"super.\"+$qid.text] argList | indirectTemplate -> indirectTemplate ) -> ^( INCLUDE[\"include\"] $templateInclude) ;
-	private ActionParser.templateInclude_return templateInclude(  )
-	{
-		ActionParser.templateInclude_return retval = new ActionParser.templateInclude_return();
-		retval.start = input.LT(1);
-
-		StringTemplateAST root_0 = null;
-
-		IToken id=null;
-		IToken qid=null;
-		IToken string_literal73=null;
-		IToken DOT74=null;
-		ActionParser.argList_return argList72 = default(ActionParser.argList_return);
-		ActionParser.argList_return argList75 = default(ActionParser.argList_return);
-		ActionParser.indirectTemplate_return indirectTemplate76 = default(ActionParser.indirectTemplate_return);
-
-		StringTemplateAST id_tree=null;
-		StringTemplateAST qid_tree=null;
-		StringTemplateAST string_literal73_tree=null;
-		StringTemplateAST DOT74_tree=null;
-		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
-		RewriteRuleITokenStream stream_SUPER=new RewriteRuleITokenStream(adaptor,"token SUPER");
-		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
-		RewriteRuleSubtreeStream stream_argList=new RewriteRuleSubtreeStream(adaptor,"rule argList");
-		RewriteRuleSubtreeStream stream_indirectTemplate=new RewriteRuleSubtreeStream(adaptor,"rule indirectTemplate");
-		try
-		{
-			// Language\\Action.g3:297:4: ( (id= ID argList -> $id argList | 'super' DOT qid= ID argList -> ID[$qid,\"super.\"+$qid.text] argList | indirectTemplate -> indirectTemplate ) -> ^( INCLUDE[\"include\"] $templateInclude) )
-			// Language\\Action.g3:297:4: (id= ID argList -> $id argList | 'super' DOT qid= ID argList -> ID[$qid,\"super.\"+$qid.text] argList | indirectTemplate -> indirectTemplate )
-			{
-			// Language\\Action.g3:297:4: (id= ID argList -> $id argList | 'super' DOT qid= ID argList -> ID[$qid,\"super.\"+$qid.text] argList | indirectTemplate -> indirectTemplate )
-			int alt22=3;
-			switch ( input.LA(1) )
-			{
-			case ID:
-				{
-				alt22=1;
-				}
-				break;
-			case SUPER:
-				{
-				alt22=2;
-				}
-				break;
-			case LPAREN:
-				{
-				alt22=3;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 22, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt22 )
-			{
-			case 1:
-				// Language\\Action.g3:297:6: id= ID argList
-				{
-				id=(IToken)Match(input,ID,Follow._ID_in_templateInclude947); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_ID.Add(id);
-
-				PushFollow(Follow._argList_in_templateInclude949);
-				argList72=argList();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_argList.Add(argList72.Tree);
-
-
-				{
-				// AST REWRITE
-				// elements: id, argList
-				// token labels: id
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleITokenStream stream_id=new RewriteRuleITokenStream(adaptor,"token id",id);
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (StringTemplateAST)adaptor.Nil();
-				// 297:20: -> $id argList
-				{
-					adaptor.AddChild(root_0, stream_id.NextNode());
-					adaptor.AddChild(root_0, stream_argList.NextTree());
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-			case 2:
-				// Language\\Action.g3:298:5: 'super' DOT qid= ID argList
-				{
-				string_literal73=(IToken)Match(input,SUPER,Follow._SUPER_in_templateInclude962); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_SUPER.Add(string_literal73);
-
-				DOT74=(IToken)Match(input,DOT,Follow._DOT_in_templateInclude964); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_DOT.Add(DOT74);
-
-				qid=(IToken)Match(input,ID,Follow._ID_in_templateInclude968); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_ID.Add(qid);
-
-				PushFollow(Follow._argList_in_templateInclude970);
-				argList75=argList();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_argList.Add(argList75.Tree);
-
-
-				{
-				// AST REWRITE
-				// elements: ID, argList
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (StringTemplateAST)adaptor.Nil();
-				// 298:32: -> ID[$qid,\"super.\"+$qid.text] argList
-				{
-					adaptor.AddChild(root_0, (StringTemplateAST)adaptor.Create(ID, qid, "super."+(qid!=null?qid.Text:null)));
-					adaptor.AddChild(root_0, stream_argList.NextTree());
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-			case 3:
-				// Language\\Action.g3:299:5: indirectTemplate
-				{
-				PushFollow(Follow._indirectTemplate_in_templateInclude983);
-				indirectTemplate76=indirectTemplate();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_indirectTemplate.Add(indirectTemplate76.Tree);
-
-
-				{
-				// AST REWRITE
-				// elements: indirectTemplate
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (StringTemplateAST)adaptor.Nil();
-				// 299:22: -> indirectTemplate
-				{
-					adaptor.AddChild(root_0, stream_indirectTemplate.NextTree());
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-
-			}
-
-
-
-			{
-			// AST REWRITE
-			// elements: templateInclude
-			// token labels:
-			// rule labels: retval
-			// token list labels:
-			// rule list labels:
-			// wildcard labels:
-			if ( state.backtracking == 0 ) {
-			retval.tree = root_0;
-			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-			root_0 = (StringTemplateAST)adaptor.Nil();
-			// 301:3: -> ^( INCLUDE[\"include\"] $templateInclude)
-			{
-				// Language\\Action.g3:301:6: ^( INCLUDE[\"include\"] $templateInclude)
-				{
-				StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
-				root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(INCLUDE, "include"), root_1);
-
-				adaptor.AddChild(root_1, stream_retval.NextTree());
-
-				adaptor.AddChild(root_0, root_1);
-				}
-
-			}
-
-			retval.tree = root_0;
-			}
-			}
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "templateInclude"
-
-	public class indirectTemplate_return : ParserRuleReturnScope
-	{
-		internal StringTemplateAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "indirectTemplate"
-	// Language\\Action.g3:305:0: indirectTemplate : LPAREN e= templatesExpr RPAREN args= argList -> ^( VALUE[\"value\"] $e $args) ;
-	private ActionParser.indirectTemplate_return indirectTemplate(  )
-	{
-		ActionParser.indirectTemplate_return retval = new ActionParser.indirectTemplate_return();
-		retval.start = input.LT(1);
-
-		StringTemplateAST root_0 = null;
-
-		IToken LPAREN77=null;
-		IToken RPAREN78=null;
-		ActionParser.templatesExpr_return e = default(ActionParser.templatesExpr_return);
-		ActionParser.argList_return args = default(ActionParser.argList_return);
-
-		StringTemplateAST LPAREN77_tree=null;
-		StringTemplateAST RPAREN78_tree=null;
-		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
-		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
-		RewriteRuleSubtreeStream stream_templatesExpr=new RewriteRuleSubtreeStream(adaptor,"rule templatesExpr");
-		RewriteRuleSubtreeStream stream_argList=new RewriteRuleSubtreeStream(adaptor,"rule argList");
-		try
-		{
-			// Language\\Action.g3:306:4: ( LPAREN e= templatesExpr RPAREN args= argList -> ^( VALUE[\"value\"] $e $args) )
-			// Language\\Action.g3:306:4: LPAREN e= templatesExpr RPAREN args= argList
-			{
-			LPAREN77=(IToken)Match(input,LPAREN,Follow._LPAREN_in_indirectTemplate1017); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_LPAREN.Add(LPAREN77);
-
-			PushFollow(Follow._templatesExpr_in_indirectTemplate1021);
-			e=templatesExpr();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_templatesExpr.Add(e.Tree);
-			RPAREN78=(IToken)Match(input,RPAREN,Follow._RPAREN_in_indirectTemplate1023); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_RPAREN.Add(RPAREN78);
-
-			PushFollow(Follow._argList_in_indirectTemplate1027);
-			args=argList();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_argList.Add(args.Tree);
-
-
-			{
-			// AST REWRITE
-			// elements: e, args
-			// token labels:
-			// rule labels: e, args, retval
-			// token list labels:
-			// rule list labels:
-			// wildcard labels:
-			if ( state.backtracking == 0 ) {
-			retval.tree = root_0;
-			RewriteRuleSubtreeStream stream_e=new RewriteRuleSubtreeStream(adaptor,"rule e",e!=null?e.tree:null);
-			RewriteRuleSubtreeStream stream_args=new RewriteRuleSubtreeStream(adaptor,"rule args",args!=null?args.tree:null);
-			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-			root_0 = (StringTemplateAST)adaptor.Nil();
-			// 307:3: -> ^( VALUE[\"value\"] $e $args)
-			{
-				// Language\\Action.g3:307:6: ^( VALUE[\"value\"] $e $args)
-				{
-				StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
-				root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(VALUE, "value"), root_1);
-
-				adaptor.AddChild(root_1, stream_e.NextTree());
-				adaptor.AddChild(root_1, stream_args.NextTree());
-
-				adaptor.AddChild(root_0, root_1);
-				}
-
-			}
-
-			retval.tree = root_0;
-			}
-			}
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "indirectTemplate"
-
-	public class argList_return : ParserRuleReturnScope
-	{
-		internal StringTemplateAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "argList"
-	// Language\\Action.g3:310:0: argList : ( LPAREN ( argumentAssignment ( COMMA argumentAssignment )* )? RPAREN -> ^( ARGS[\"ARGS\"] ( argumentAssignment )* ) | singleArg );
-	private ActionParser.argList_return argList(  )
-	{
-		ActionParser.argList_return retval = new ActionParser.argList_return();
-		retval.start = input.LT(1);
-
-		StringTemplateAST root_0 = null;
-
-		IToken LPAREN79=null;
-		IToken COMMA81=null;
-		IToken RPAREN83=null;
-		ActionParser.argumentAssignment_return argumentAssignment80 = default(ActionParser.argumentAssignment_return);
-		ActionParser.argumentAssignment_return argumentAssignment82 = default(ActionParser.argumentAssignment_return);
-		ActionParser.singleArg_return singleArg84 = default(ActionParser.singleArg_return);
-
-		StringTemplateAST LPAREN79_tree=null;
-		StringTemplateAST COMMA81_tree=null;
-		StringTemplateAST RPAREN83_tree=null;
-		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
-		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
-		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
-		RewriteRuleSubtreeStream stream_argumentAssignment=new RewriteRuleSubtreeStream(adaptor,"rule argumentAssignment");
-		try
-		{
-			// Language\\Action.g3:311:4: ( LPAREN ( argumentAssignment ( COMMA argumentAssignment )* )? RPAREN -> ^( ARGS[\"ARGS\"] ( argumentAssignment )* ) | singleArg )
-			int alt25=2;
-			int LA25_0 = input.LA(1);
-
-			if ( (LA25_0==LPAREN) )
-			{
-				switch ( input.LA(2) )
-				{
-				case ID:
-					{
-					int LA25_2 = input.LA(3);
-
-					if ( (LA25_2==ASSIGN) )
-					{
-						alt25=1;
-					}
-					else if ( (LA25_2==COLON||LA25_2==DOT||LA25_2==LPAREN||LA25_2==PLUS||LA25_2==RPAREN) )
-					{
-						alt25=2;
-					}
-					else
-					{
-						if (state.backtracking>0) {state.failed=true; return retval;}
-						NoViableAltException nvae = new NoViableAltException("", 25, 2, input);
-
-						throw nvae;
-					}
-					}
-					break;
-				case DOTDOTDOT:
-				case RPAREN:
-					{
-					alt25=1;
-					}
-					break;
-				case ANONYMOUS_TEMPLATE:
-				case FIRST:
-				case INT:
-				case LAST:
-				case LBRACK:
-				case LENGTH:
-				case LPAREN:
-				case REST:
-				case STRING:
-				case STRIP:
-				case SUPER:
-				case TRUNC:
-					{
-					alt25=2;
-					}
-					break;
-				default:
-					{
-						if (state.backtracking>0) {state.failed=true; return retval;}
-						NoViableAltException nvae = new NoViableAltException("", 25, 1, input);
-
-						throw nvae;
-					}
-				}
-
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return retval;}
-				NoViableAltException nvae = new NoViableAltException("", 25, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt25 )
-			{
-			case 1:
-				// Language\\Action.g3:311:4: LPAREN ( argumentAssignment ( COMMA argumentAssignment )* )? RPAREN
-				{
-				LPAREN79=(IToken)Match(input,LPAREN,Follow._LPAREN_in_argList1054); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_LPAREN.Add(LPAREN79);
-
-				// Language\\Action.g3:312:3: ( argumentAssignment ( COMMA argumentAssignment )* )?
-				int alt24=2;
-				int LA24_0 = input.LA(1);
-
-				if ( (LA24_0==DOTDOTDOT||LA24_0==ID) )
-				{
-					alt24=1;
-				}
-				switch ( alt24 )
-				{
-				case 1:
-					// Language\\Action.g3:312:5: argumentAssignment ( COMMA argumentAssignment )*
-					{
-					PushFollow(Follow._argumentAssignment_in_argList1060);
-					argumentAssignment80=argumentAssignment();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) stream_argumentAssignment.Add(argumentAssignment80.Tree);
-					// Language\\Action.g3:312:24: ( COMMA argumentAssignment )*
-					for ( ; ; )
-					{
-						int alt23=2;
-						int LA23_0 = input.LA(1);
-
-						if ( (LA23_0==COMMA) )
-						{
-							alt23=1;
-						}
-
-
-						switch ( alt23 )
-						{
-						case 1:
-							// Language\\Action.g3:312:25: COMMA argumentAssignment
-							{
-							COMMA81=(IToken)Match(input,COMMA,Follow._COMMA_in_argList1063); if (state.failed) return retval;
-							if ( state.backtracking == 0 ) stream_COMMA.Add(COMMA81);
-
-							PushFollow(Follow._argumentAssignment_in_argList1065);
-							argumentAssignment82=argumentAssignment();
-
-							state._fsp--;
-							if (state.failed) return retval;
-							if ( state.backtracking == 0 ) stream_argumentAssignment.Add(argumentAssignment82.Tree);
-
-							}
-							break;
-
-						default:
-							goto loop23;
-						}
-					}
-
-					loop23:
-						;
-
-
-
-					}
-					break;
-
-				}
-
-				RPAREN83=(IToken)Match(input,RPAREN,Follow._RPAREN_in_argList1076); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_RPAREN.Add(RPAREN83);
-
-
-
-				{
-				// AST REWRITE
-				// elements: argumentAssignment
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (StringTemplateAST)adaptor.Nil();
-				// 315:3: -> ^( ARGS[\"ARGS\"] ( argumentAssignment )* )
-				{
-					// Language\\Action.g3:315:6: ^( ARGS[\"ARGS\"] ( argumentAssignment )* )
-					{
-					StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
-					root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(ARGS, "ARGS"), root_1);
-
-					// Language\\Action.g3:315:21: ( argumentAssignment )*
-					while ( stream_argumentAssignment.HasNext )
-					{
-						adaptor.AddChild(root_1, stream_argumentAssignment.NextTree());
-
-					}
-					stream_argumentAssignment.Reset();
-
-					adaptor.AddChild(root_0, root_1);
-					}
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-			case 2:
-				// Language\\Action.g3:316:4: singleArg
-				{
-				root_0 = (StringTemplateAST)adaptor.Nil();
-
-				PushFollow(Follow._singleArg_in_argList1093);
-				singleArg84=singleArg();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, singleArg84.Tree);
-
-				}
-				break;
-
-			}
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "argList"
-
-	public class singleArg_return : ParserRuleReturnScope
-	{
-		internal StringTemplateAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "singleArg"
-	// Language\\Action.g3:319:0: singleArg : LPAREN nonAlternatingTemplateExpr RPAREN -> ^( SINGLEVALUEARG[\"SINGLEVALUEARG\"] nonAlternatingTemplateExpr ) ;
-	private ActionParser.singleArg_return singleArg(  )
-	{
-		ActionParser.singleArg_return retval = new ActionParser.singleArg_return();
-		retval.start = input.LT(1);
-
-		StringTemplateAST root_0 = null;
-
-		IToken LPAREN85=null;
-		IToken RPAREN87=null;
-		ActionParser.nonAlternatingTemplateExpr_return nonAlternatingTemplateExpr86 = default(ActionParser.nonAlternatingTemplateExpr_return);
-
-		StringTemplateAST LPAREN85_tree=null;
-		StringTemplateAST RPAREN87_tree=null;
-		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
-		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
-		RewriteRuleSubtreeStream stream_nonAlternatingTemplateExpr=new RewriteRuleSubtreeStream(adaptor,"rule nonAlternatingTemplateExpr");
-		try
-		{
-			// Language\\Action.g3:320:4: ( LPAREN nonAlternatingTemplateExpr RPAREN -> ^( SINGLEVALUEARG[\"SINGLEVALUEARG\"] nonAlternatingTemplateExpr ) )
-			// Language\\Action.g3:320:4: LPAREN nonAlternatingTemplateExpr RPAREN
-			{
-			LPAREN85=(IToken)Match(input,LPAREN,Follow._LPAREN_in_singleArg1105); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_LPAREN.Add(LPAREN85);
-
-			PushFollow(Follow._nonAlternatingTemplateExpr_in_singleArg1107);
-			nonAlternatingTemplateExpr86=nonAlternatingTemplateExpr();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_nonAlternatingTemplateExpr.Add(nonAlternatingTemplateExpr86.Tree);
-			RPAREN87=(IToken)Match(input,RPAREN,Follow._RPAREN_in_singleArg1109); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_RPAREN.Add(RPAREN87);
-
-
-
-			{
-			// AST REWRITE
-			// elements: nonAlternatingTemplateExpr
-			// token labels:
-			// rule labels: retval
-			// token list labels:
-			// rule list labels:
-			// wildcard labels:
-			if ( state.backtracking == 0 ) {
-			retval.tree = root_0;
-			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-			root_0 = (StringTemplateAST)adaptor.Nil();
-			// 321:3: -> ^( SINGLEVALUEARG[\"SINGLEVALUEARG\"] nonAlternatingTemplateExpr )
-			{
-				// Language\\Action.g3:321:6: ^( SINGLEVALUEARG[\"SINGLEVALUEARG\"] nonAlternatingTemplateExpr )
-				{
-				StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
-				root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(SINGLEVALUEARG, "SINGLEVALUEARG"), root_1);
-
-				adaptor.AddChild(root_1, stream_nonAlternatingTemplateExpr.NextTree());
-
-				adaptor.AddChild(root_0, root_1);
-				}
-
-			}
-
-			retval.tree = root_0;
-			}
-			}
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "singleArg"
-
-	public class argumentAssignment_return : ParserRuleReturnScope
-	{
-		internal StringTemplateAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "argumentAssignment"
-	// Language\\Action.g3:324:0: argumentAssignment : ( ID ASSIGN nonAlternatingTemplateExpr | DOTDOTDOT );
-	private ActionParser.argumentAssignment_return argumentAssignment(  )
-	{
-		ActionParser.argumentAssignment_return retval = new ActionParser.argumentAssignment_return();
-		retval.start = input.LT(1);
-
-		StringTemplateAST root_0 = null;
-
-		IToken ID88=null;
-		IToken ASSIGN89=null;
-		IToken DOTDOTDOT91=null;
-		ActionParser.nonAlternatingTemplateExpr_return nonAlternatingTemplateExpr90 = default(ActionParser.nonAlternatingTemplateExpr_return);
-
-		StringTemplateAST ID88_tree=null;
-		StringTemplateAST ASSIGN89_tree=null;
-		StringTemplateAST DOTDOTDOT91_tree=null;
-
-		try
-		{
-			// Language\\Action.g3:325:4: ( ID ASSIGN nonAlternatingTemplateExpr | DOTDOTDOT )
-			int alt26=2;
-			int LA26_0 = input.LA(1);
-
-			if ( (LA26_0==ID) )
-			{
-				alt26=1;
-			}
-			else if ( (LA26_0==DOTDOTDOT) )
-			{
-				alt26=2;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return retval;}
-				NoViableAltException nvae = new NoViableAltException("", 26, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt26 )
-			{
-			case 1:
-				// Language\\Action.g3:325:4: ID ASSIGN nonAlternatingTemplateExpr
-				{
-				root_0 = (StringTemplateAST)adaptor.Nil();
-
-				ID88=(IToken)Match(input,ID,Follow._ID_in_argumentAssignment1131); if (state.failed) return retval;
-				if ( state.backtracking==0 ) {
-				ID88_tree = (StringTemplateAST)adaptor.Create(ID88);
-				adaptor.AddChild(root_0, ID88_tree);
-				}
-				ASSIGN89=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_argumentAssignment1133); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) {
-				ASSIGN89_tree = (StringTemplateAST)adaptor.Create(ASSIGN89);
-				root_0 = (StringTemplateAST)adaptor.BecomeRoot(ASSIGN89_tree, root_0);
-				}
-				PushFollow(Follow._nonAlternatingTemplateExpr_in_argumentAssignment1136);
-				nonAlternatingTemplateExpr90=nonAlternatingTemplateExpr();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, nonAlternatingTemplateExpr90.Tree);
-
-				}
-				break;
-			case 2:
-				// Language\\Action.g3:326:4: DOTDOTDOT
-				{
-				root_0 = (StringTemplateAST)adaptor.Nil();
-
-				DOTDOTDOT91=(IToken)Match(input,DOTDOTDOT,Follow._DOTDOTDOT_in_argumentAssignment1141); if (state.failed) return retval;
-				if ( state.backtracking==0 ) {
-				DOTDOTDOT91_tree = (StringTemplateAST)adaptor.Create(DOTDOTDOT91);
-				adaptor.AddChild(root_0, DOTDOTDOT91_tree);
-				}
-
-				}
-				break;
-
-			}
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "argumentAssignment"
-
-	// $ANTLR start synpred1_Action
-	public void synpred1_Action_fragment()
-	{
-		// Language\\Action.g3:200:4: ( templateInclude )
-		// Language\\Action.g3:200:5: templateInclude
-		{
-		PushFollow(Follow._templateInclude_in_synpred1_Action491);
-		templateInclude();
-
-		state._fsp--;
-		if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred1_Action
-	#endregion Rules
-
-	#region Synpreds
-	bool EvaluatePredicate( System.Action fragment )
-	{
-		state.backtracking++;
-		int start = input.Mark();
-		try
-		{
-			fragment();
-		}
-		catch ( RecognitionException re )
-		{
-			System.Console.Error.WriteLine("impossible: "+re);
-		}
-		bool success = !state.failed;
-		input.Rewind(start);
-		state.backtracking--;
-		state.failed=false;
-		return success;
-	}
-	#endregion Synpreds
-
-
-	#region DFA
-	DFA15 dfa15;
-
-	protected override void InitDFAs()
-	{
-		base.InitDFAs();
-		dfa15 = new DFA15( this, new SpecialStateTransitionHandler( specialStateTransition15 ) );
-	}
-
-	class DFA15 : DFA
-	{
-
-		const string DFA15_eotS =
-			"\xD\xFFFF";
-		const string DFA15_eofS =
-			"\xD\xFFFF";
-		const string DFA15_minS =
-			"\x1\x4\x1\x0\x1\xFFFF\x1\x0\x9\xFFFF";
-		const string DFA15_maxS =
-			"\x1\x29\x1\x0\x1\xFFFF\x1\x0\x9\xFFFF";
-		const string DFA15_acceptS =
-			"\x2\xFFFF\x1\x1\x1\xFFFF\x1\x2\x1\x3\x5\xFFFF\x1\x5\x1\x4";
-		const string DFA15_specialS =
-			"\x1\x0\x1\x1\x1\xFFFF\x1\x2\x9\xFFFF}>";
-		static readonly string[] DFA15_transitionS =
-			{
-				"\x1\x4\xA\xFFFF\x1\x5\x1\xFFFF\x1\x1\x1\xFFFF\x1\x4\x1\x5\x1\xB\x1\x5"+
-				"\x1\xFFFF\x1\x3\x7\xFFFF\x1\x5\x3\xFFFF\x1\x4\x1\x5\x1\x2\x2\xFFFF\x1"+
-				"\x5",
-				"\x1\xFFFF",
-				"",
-				"\x1\xFFFF",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				""
-			};
-
-		static readonly short[] DFA15_eot = DFA.UnpackEncodedString(DFA15_eotS);
-		static readonly short[] DFA15_eof = DFA.UnpackEncodedString(DFA15_eofS);
-		static readonly char[] DFA15_min = DFA.UnpackEncodedStringToUnsignedChars(DFA15_minS);
-		static readonly char[] DFA15_max = DFA.UnpackEncodedStringToUnsignedChars(DFA15_maxS);
-		static readonly short[] DFA15_accept = DFA.UnpackEncodedString(DFA15_acceptS);
-		static readonly short[] DFA15_special = DFA.UnpackEncodedString(DFA15_specialS);
-		static readonly short[][] DFA15_transition;
-
-		static DFA15()
-		{
-			int numStates = DFA15_transitionS.Length;
-			DFA15_transition = new short[numStates][];
-			for ( int i=0; i < numStates; i++ )
-			{
-				DFA15_transition[i] = DFA.UnpackEncodedString(DFA15_transitionS[i]);
-			}
-		}
-
-		public DFA15( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
-			: base( specialStateTransition )	{
-			this.recognizer = recognizer;
-			this.decisionNumber = 15;
-			this.eot = DFA15_eot;
-			this.eof = DFA15_eof;
-			this.min = DFA15_min;
-			this.max = DFA15_max;
-			this.accept = DFA15_accept;
-			this.special = DFA15_special;
-			this.transition = DFA15_transition;
-		}
-		public override string GetDescription()
-		{
-			return "199:0: primaryExpr : (=> templateInclude | atom ( DOT ( ID | valueExpr ) )* | function ( DOT ( ID | valueExpr ) )* | valueExpr | list );";
-		}
-	}
-
-	int specialStateTransition15( DFA dfa, int s, IIntStream _input )
-	{
-		ITokenStream input = (ITokenStream)_input;
-		int _s = s;
-		switch ( s )
-		{
-			case 0:
-				int LA15_0 = input.LA(1);
-
-
-				int index15_0 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (LA15_0==ID) ) {s = 1;}
-
-				else if ( (LA15_0==SUPER) && (EvaluatePredicate(synpred1_Action_fragment))) {s = 2;}
-
-				else if ( (LA15_0==LPAREN) ) {s = 3;}
-
-				else if ( (LA15_0==ANONYMOUS_TEMPLATE||LA15_0==INT||LA15_0==STRING) ) {s = 4;}
-
-				else if ( (LA15_0==FIRST||LA15_0==LAST||LA15_0==LENGTH||LA15_0==REST||LA15_0==STRIP||LA15_0==TRUNC) ) {s = 5;}
-
-				else if ( (LA15_0==LBRACK) ) {s = 11;}
-
-
-				input.Seek(index15_0);
-				if ( s>=0 ) return s;
-				break;
-			case 1:
-				int LA15_1 = input.LA(1);
-
-
-				int index15_1 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (EvaluatePredicate(synpred1_Action_fragment)) ) {s = 2;}
-
-				else if ( (true) ) {s = 4;}
-
-
-				input.Seek(index15_1);
-				if ( s>=0 ) return s;
-				break;
-			case 2:
-				int LA15_3 = input.LA(1);
-
-
-				int index15_3 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (EvaluatePredicate(synpred1_Action_fragment)) ) {s = 2;}
-
-				else if ( (true) ) {s = 12;}
-
-
-				input.Seek(index15_3);
-				if ( s>=0 ) return s;
-				break;
-		}
-		if (state.backtracking>0) {state.failed=true; return -1;}
-		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 15, _s, input);
-		dfa.Error(nvae);
-		throw nvae;
-	}
-
-	#endregion DFA
-
-	#region Follow sets
-	private static class Follow
-	{
-		public static readonly BitSet _templatesExpr_in_action192 = new BitSet(new ulong[]{0x400000000UL});
-		public static readonly BitSet _SEMI_in_action195 = new BitSet(new ulong[]{0x20000UL});
-		public static readonly BitSet _optionList_in_action198 = new BitSet(new ulong[]{0x0UL});
-		public static readonly BitSet _CONDITIONAL_in_action208 = new BitSet(new ulong[]{0x1000000UL});
-		public static readonly BitSet _LPAREN_in_action211 = new BitSet(new ulong[]{0x271117A8010UL});
-		public static readonly BitSet _ifCondition_in_action214 = new BitSet(new ulong[]{0x200000000UL});
-		public static readonly BitSet _RPAREN_in_action216 = new BitSet(new ulong[]{0x0UL});
-		public static readonly BitSet _ELSEIF_in_action223 = new BitSet(new ulong[]{0x1000000UL});
-		public static readonly BitSet _LPAREN_in_action226 = new BitSet(new ulong[]{0x271117A8010UL});
-		public static readonly BitSet _ifCondition_in_action229 = new BitSet(new ulong[]{0x200000000UL});
-		public static readonly BitSet _RPAREN_in_action231 = new BitSet(new ulong[]{0x0UL});
-		public static readonly BitSet _EOF_in_action241 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _option_in_optionList258 = new BitSet(new ulong[]{0x202UL});
-		public static readonly BitSet _COMMA_in_optionList262 = new BitSet(new ulong[]{0x20000UL});
-		public static readonly BitSet _option_in_optionList264 = new BitSet(new ulong[]{0x202UL});
-		public static readonly BitSet _ID_in_option284 = new BitSet(new ulong[]{0x82UL});
-		public static readonly BitSet _ASSIGN_in_option290 = new BitSet(new ulong[]{0x271017A8010UL});
-		public static readonly BitSet _nonAlternatingTemplateExpr_in_option292 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _expr_in_templatesExpr322 = new BitSet(new ulong[]{0x302UL});
-		public static readonly BitSet _COMMA_in_templatesExpr329 = new BitSet(new ulong[]{0x271017A8010UL});
-		public static readonly BitSet _expr_in_templatesExpr331 = new BitSet(new ulong[]{0x300UL});
-		public static readonly BitSet _COLON_in_templatesExpr337 = new BitSet(new ulong[]{0x10UL});
-		public static readonly BitSet _anonymousTemplate_in_templatesExpr339 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _COLON_in_templatesExpr381 = new BitSet(new ulong[]{0x4001020010UL});
-		public static readonly BitSet _templateList_in_templatesExpr383 = new BitSet(new ulong[]{0x102UL});
-		public static readonly BitSet _template_in_templateList422 = new BitSet(new ulong[]{0x202UL});
-		public static readonly BitSet _COMMA_in_templateList425 = new BitSet(new ulong[]{0x4001020010UL});
-		public static readonly BitSet _template_in_templateList428 = new BitSet(new ulong[]{0x202UL});
-		public static readonly BitSet _ifAtom_in_ifCondition441 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _NOT_in_ifCondition446 = new BitSet(new ulong[]{0x271017A8010UL});
-		public static readonly BitSet _ifAtom_in_ifCondition449 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _templatesExpr_in_ifAtom460 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _primaryExpr_in_expr471 = new BitSet(new ulong[]{0x40000002UL});
-		public static readonly BitSet _PLUS_in_expr474 = new BitSet(new ulong[]{0x271017A8010UL});
-		public static readonly BitSet _primaryExpr_in_expr477 = new BitSet(new ulong[]{0x40000002UL});
-		public static readonly BitSet _templateInclude_in_primaryExpr494 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _atom_in_primaryExpr501 = new BitSet(new ulong[]{0x802UL});
-		public static readonly BitSet _DOT_in_primaryExpr507 = new BitSet(new ulong[]{0x1020000UL});
-		public static readonly BitSet _ID_in_primaryExpr516 = new BitSet(new ulong[]{0x802UL});
-		public static readonly BitSet _valueExpr_in_primaryExpr523 = new BitSet(new ulong[]{0x802UL});
-		public static readonly BitSet _function_in_primaryExpr538 = new BitSet(new ulong[]{0x802UL});
-		public static readonly BitSet _DOT_in_primaryExpr544 = new BitSet(new ulong[]{0x1020000UL});
-		public static readonly BitSet _ID_in_primaryExpr552 = new BitSet(new ulong[]{0x802UL});
-		public static readonly BitSet _valueExpr_in_primaryExpr559 = new BitSet(new ulong[]{0x802UL});
-		public static readonly BitSet _valueExpr_in_primaryExpr574 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _list_in_primaryExpr579 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _LPAREN_in_valueExpr590 = new BitSet(new ulong[]{0x271017A8010UL});
-		public static readonly BitSet _templatesExpr_in_valueExpr592 = new BitSet(new ulong[]{0x200000000UL});
-		public static readonly BitSet _RPAREN_in_valueExpr594 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _expr_in_nonAlternatingTemplateExpr617 = new BitSet(new ulong[]{0x102UL});
-		public static readonly BitSet _COLON_in_nonAlternatingTemplateExpr626 = new BitSet(new ulong[]{0x4001020010UL});
-		public static readonly BitSet _template_in_nonAlternatingTemplateExpr628 = new BitSet(new ulong[]{0x102UL});
-		public static readonly BitSet _FIRST_in_function656 = new BitSet(new ulong[]{0x1000000UL});
-		public static readonly BitSet _REST_in_function662 = new BitSet(new ulong[]{0x1000000UL});
-		public static readonly BitSet _LAST_in_function668 = new BitSet(new ulong[]{0x1000000UL});
-		public static readonly BitSet _LENGTH_in_function674 = new BitSet(new ulong[]{0x1000000UL});
-		public static readonly BitSet _STRIP_in_function680 = new BitSet(new ulong[]{0x1000000UL});
-		public static readonly BitSet _TRUNC_in_function686 = new BitSet(new ulong[]{0x1000000UL});
-		public static readonly BitSet _singleArg_in_function694 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _namedTemplate_in_template735 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _anonymousTemplate_in_template744 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ID_in_namedTemplate775 = new BitSet(new ulong[]{0x1000000UL});
-		public static readonly BitSet _argList_in_namedTemplate777 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _SUPER_in_namedTemplate790 = new BitSet(new ulong[]{0x800UL});
-		public static readonly BitSet _DOT_in_namedTemplate792 = new BitSet(new ulong[]{0x20000UL});
-		public static readonly BitSet _ID_in_namedTemplate796 = new BitSet(new ulong[]{0x1000000UL});
-		public static readonly BitSet _argList_in_namedTemplate798 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _indirectTemplate_in_namedTemplate812 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ANONYMOUS_TEMPLATE_in_anonymousTemplate841 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _set_in_atom856 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _LBRACK_in_list884 = new BitSet(new ulong[]{0x271817A8210UL});
-		public static readonly BitSet _listElement_in_list888 = new BitSet(new ulong[]{0x80000200UL});
-		public static readonly BitSet _COMMA_in_list891 = new BitSet(new ulong[]{0x271817A8210UL});
-		public static readonly BitSet _listElement_in_list893 = new BitSet(new ulong[]{0x80000200UL});
-		public static readonly BitSet _RBRACK_in_list899 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _nonAlternatingTemplateExpr_in_listElement922 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ID_in_templateInclude947 = new BitSet(new ulong[]{0x1000000UL});
-		public static readonly BitSet _argList_in_templateInclude949 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _SUPER_in_templateInclude962 = new BitSet(new ulong[]{0x800UL});
-		public static readonly BitSet _DOT_in_templateInclude964 = new BitSet(new ulong[]{0x20000UL});
-		public static readonly BitSet _ID_in_templateInclude968 = new BitSet(new ulong[]{0x1000000UL});
-		public static readonly BitSet _argList_in_templateInclude970 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _indirectTemplate_in_templateInclude983 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _LPAREN_in_indirectTemplate1017 = new BitSet(new ulong[]{0x271017A8010UL});
-		public static readonly BitSet _templatesExpr_in_indirectTemplate1021 = new BitSet(new ulong[]{0x200000000UL});
-		public static readonly BitSet _RPAREN_in_indirectTemplate1023 = new BitSet(new ulong[]{0x1000000UL});
-		public static readonly BitSet _argList_in_indirectTemplate1027 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _LPAREN_in_argList1054 = new BitSet(new ulong[]{0x200021000UL});
-		public static readonly BitSet _argumentAssignment_in_argList1060 = new BitSet(new ulong[]{0x200000200UL});
-		public static readonly BitSet _COMMA_in_argList1063 = new BitSet(new ulong[]{0x21000UL});
-		public static readonly BitSet _argumentAssignment_in_argList1065 = new BitSet(new ulong[]{0x200000200UL});
-		public static readonly BitSet _RPAREN_in_argList1076 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _singleArg_in_argList1093 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _LPAREN_in_singleArg1105 = new BitSet(new ulong[]{0x271017A8010UL});
-		public static readonly BitSet _nonAlternatingTemplateExpr_in_singleArg1107 = new BitSet(new ulong[]{0x200000000UL});
-		public static readonly BitSet _RPAREN_in_singleArg1109 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ID_in_argumentAssignment1131 = new BitSet(new ulong[]{0x80UL});
-		public static readonly BitSet _ASSIGN_in_argumentAssignment1133 = new BitSet(new ulong[]{0x271017A8010UL});
-		public static readonly BitSet _nonAlternatingTemplateExpr_in_argumentAssignment1136 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _DOTDOTDOT_in_argumentAssignment1141 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _templateInclude_in_synpred1_Action491 = new BitSet(new ulong[]{0x2UL});
-
-	}
-	#endregion Follow sets
-}
-
-} // namespace  Antlr3.ST.Language
diff --git a/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.cs b/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.cs
deleted file mode 100644
index eca009b..0000000
--- a/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.cs
+++ /dev/null
@@ -1,3399 +0,0 @@
-// $ANTLR 3.1.2 Language\\AngleBracketTemplateLexer.g3 2009-09-30 13:27:15
-
-// The variable 'variable' is assigned but its value is never used.
-#pragma warning disable 219
-// Unreachable code detected.
-#pragma warning disable 162
-
-
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Grammar conversion to ANTLR v3 and C#:
- Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-	notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-	derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-using StringBuffer = System.Text.StringBuilder;
-
-
-using System.Collections.Generic;
-using Antlr.Runtime;
-using Stack = System.Collections.Generic.Stack<object>;
-using List = System.Collections.IList;
-using ArrayList = System.Collections.Generic.List<object>;
-using Map = System.Collections.IDictionary;
-using HashMap = System.Collections.Generic.Dictionary<object, object>;
-namespace Antlr3.ST.Language
-{
-[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.1.2")]
-[System.CLSCompliant(false)]
-public partial class AngleBracketTemplateLexer : Lexer
-{
-	public const int EOF=-1;
-	public const int ACTION=4;
-	public const int COMMENT=5;
-	public const int ELSE=6;
-	public const int ELSEIF=7;
-	public const int ENDIF=8;
-	public const int ESC=9;
-	public const int ESC_CHAR=10;
-	public const int EXPR=11;
-	public const int HEX=12;
-	public const int IF=13;
-	public const int IF_EXPR=14;
-	public const int INDENT=15;
-	public const int LINE_BREAK=16;
-	public const int LITERAL=17;
-	public const int NESTED_PARENS=18;
-	public const int NEWLINE=19;
-	public const int REGION_DEF=20;
-	public const int REGION_REF=21;
-	public const int SUBTEMPLATE=22;
-	public const int TEMPLATE=23;
-
-    // delegates
-    // delegators
-
-	public AngleBracketTemplateLexer() {}
-	public AngleBracketTemplateLexer( ICharStream input )
-		: this( input, new RecognizerSharedState() )
-	{
-	}
-	public AngleBracketTemplateLexer( ICharStream input, RecognizerSharedState state )
-		: base( input, state )
-	{
-
-	}
-	public override string GrammarFileName { get { return "Language\\AngleBracketTemplateLexer.g3"; } }
-
-	// $ANTLR start "NEWLINE"
-	private void mNEWLINE()
-	{
-		try
-		{
-			int _type = NEWLINE;
-			int _channel = DefaultTokenChannel;
-			// Language\\AngleBracketTemplateLexer.g3:80:4: ( ( '\\r' )? '\\n' )
-			// Language\\AngleBracketTemplateLexer.g3:80:4: ( '\\r' )? '\\n'
-			{
-			// Language\\AngleBracketTemplateLexer.g3:80:4: ( '\\r' )?
-			int alt1=2;
-			int LA1_0 = input.LA(1);
-
-			if ( (LA1_0=='\r') )
-			{
-				alt1=1;
-			}
-			switch ( alt1 )
-			{
-			case 1:
-				// Language\\AngleBracketTemplateLexer.g3:80:5: '\\r'
-				{
-				Match('\r'); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-			Match('\n'); if (state.failed) return ;
-			if ( state.backtracking == 0 )
-			{
-				currentIndent=null;
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "NEWLINE"
-
-	// $ANTLR start "ACTION"
-	private void mACTION()
-	{
-		try
-		{
-			int _type = ACTION;
-			int _channel = DefaultTokenChannel;
-			CommonToken exp=null;
-			int ch;
-
-
-				int startCol = CharPositionInLine;
-				System.Text.StringBuilder buf = null;
-				string subtext = string.Empty;
-				char uc = '\0';
-				System.Text.StringBuilder builder = null;
-				bool atLeft = false;
-				string t = null;
-
-			// Language\\AngleBracketTemplateLexer.g3:95:4: (=> LINE_BREAK |=> '<' ( ESC_CHAR[out uc] )+ '>' |=> COMMENT | ( options {k=1; } :=> '<if' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? |=> '<elseif' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? |=> '<else>' ( ( '\\r' )? '\\n' )? |=> '<endif>' ({...}? => ( '\\r' )? '\\n' )? |=> '<@' (ch=~ ( '>' | '(' ) )+ ( '()>' | '>' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )? ) | '<' EXPR[out subtext] '>' ) )
-			int alt26=4;
-			int LA26_0 = input.LA(1);
-
-			if ( (LA26_0=='<') )
-			{
-				int LA26_1 = input.LA(2);
-
-				if ( (EvaluatePredicate(synpred1_AngleBracketTemplateLexer_fragment)) )
-				{
-					alt26=1;
-				}
-				else if ( (EvaluatePredicate(synpred2_AngleBracketTemplateLexer_fragment)) )
-				{
-					alt26=2;
-				}
-				else if ( (EvaluatePredicate(synpred3_AngleBracketTemplateLexer_fragment)) )
-				{
-					alt26=3;
-				}
-				else if ( (true) )
-				{
-					alt26=4;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					NoViableAltException nvae = new NoViableAltException("", 26, 1, input);
-
-					throw nvae;
-				}
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				NoViableAltException nvae = new NoViableAltException("", 26, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt26 )
-			{
-			case 1:
-				// Language\\AngleBracketTemplateLexer.g3:95:4: => LINE_BREAK
-				{
-
-				mLINE_BREAK(); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-					_channel = Hidden;
-				}
-
-				}
-				break;
-			case 2:
-				// Language\\AngleBracketTemplateLexer.g3:96:4: => '<' ( ESC_CHAR[out uc] )+ '>'
-				{
-
-				if ( state.backtracking == 0 )
-				{
-
-								buf = new System.Text.StringBuilder();
-								uc = '\0';
-
-				}
-				Match('<'); if (state.failed) return ;
-				// Language\\AngleBracketTemplateLexer.g3:102:7: ( ESC_CHAR[out uc] )+
-				int cnt2=0;
-				for ( ; ; )
-				{
-					int alt2=2;
-					int LA2_0 = input.LA(1);
-
-					if ( (LA2_0=='\\') )
-					{
-						alt2=1;
-					}
-
-
-					switch ( alt2 )
-					{
-					case 1:
-						// Language\\AngleBracketTemplateLexer.g3:102:8: ESC_CHAR[out uc]
-						{
-						mESC_CHAR(out uc); if (state.failed) return ;
-						if ( state.backtracking == 0 )
-						{
-							buf.Append(uc);
-						}
-
-						}
-						break;
-
-					default:
-						if ( cnt2 >= 1 )
-							goto loop2;
-
-						if (state.backtracking>0) {state.failed=true; return ;}
-						EarlyExitException eee2 = new EarlyExitException( 2, input );
-						throw eee2;
-					}
-					cnt2++;
-				}
-				loop2:
-					;
-
-
-				Match('>'); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-
-								Text = buf.ToString();
-								_type = LITERAL;
-
-				}
-
-				}
-				break;
-			case 3:
-				// Language\\AngleBracketTemplateLexer.g3:107:4: => COMMENT
-				{
-
-				mCOMMENT(); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-					_channel = Hidden;
-				}
-
-				}
-				break;
-			case 4:
-				// Language\\AngleBracketTemplateLexer.g3:108:4: ( options {k=1; } :=> '<if' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? |=> '<elseif' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? |=> '<else>' ( ( '\\r' )? '\\n' )? |=> '<endif>' ({...}? => ( '\\r' )? '\\n' )? |=> '<@' (ch=~ ( '>' | '(' ) )+ ( '()>' | '>' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )? ) | '<' EXPR[out subtext] '>' )
-				{
-				// Language\\AngleBracketTemplateLexer.g3:108:4: ( options {k=1; } :=> '<if' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? |=> '<elseif' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? |=> '<else>' ( ( '\\r' )? '\\n' )? |=> '<endif>' ({...}? => ( '\\r' )? '\\n' )? |=> '<@' (ch=~ ( '>' | '(' ) )+ ( '()>' | '>' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )? ) | '<' EXPR[out subtext] '>' )
-				int alt25=6;
-				int LA25_0 = input.LA(1);
-
-				if ( (LA25_0=='<') )
-				{
-					int LA25_1 = input.LA(2);
-
-					if ( (EvaluatePredicate(synpred4_AngleBracketTemplateLexer_fragment)) )
-					{
-						alt25=1;
-					}
-					else if ( (EvaluatePredicate(synpred5_AngleBracketTemplateLexer_fragment)) )
-					{
-						alt25=2;
-					}
-					else if ( (EvaluatePredicate(synpred6_AngleBracketTemplateLexer_fragment)) )
-					{
-						alt25=3;
-					}
-					else if ( (EvaluatePredicate(synpred7_AngleBracketTemplateLexer_fragment)) )
-					{
-						alt25=4;
-					}
-					else if ( (EvaluatePredicate(synpred8_AngleBracketTemplateLexer_fragment)) )
-					{
-						alt25=5;
-					}
-					else if ( (true) )
-					{
-						alt25=6;
-					}
-					else
-					{
-						if (state.backtracking>0) {state.failed=true; return ;}
-						NoViableAltException nvae = new NoViableAltException("", 25, 1, input);
-
-						throw nvae;
-					}
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					NoViableAltException nvae = new NoViableAltException("", 25, 0, input);
-
-					throw nvae;
-				}
-				switch ( alt25 )
-				{
-				case 1:
-					// Language\\AngleBracketTemplateLexer.g3:109:4: => '<if' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )?
-					{
-
-					Match("<if"); if (state.failed) return ;
-
-					// Language\\AngleBracketTemplateLexer.g3:110:10: ( ' ' )*
-					for ( ; ; )
-					{
-						int alt3=2;
-						int LA3_0 = input.LA(1);
-
-						if ( (LA3_0==' ') )
-						{
-							alt3=1;
-						}
-
-
-						switch ( alt3 )
-						{
-						case 1:
-							// Language\\AngleBracketTemplateLexer.g3:110:11: ' '
-							{
-							Match(' '); if (state.failed) return ;
-
-							}
-							break;
-
-						default:
-							goto loop3;
-						}
-					}
-
-					loop3:
-						;
-
-
-					Match('('); if (state.failed) return ;
-					int expStart184 = CharIndex;
-					mIF_EXPR(); if (state.failed) return ;
-					exp = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, expStart184, CharIndex-1);
-					Match(")>"); if (state.failed) return ;
-
-					// Language\\AngleBracketTemplateLexer.g3:111:4: ( ( '\\r' )? '\\n' )?
-					int alt5=2;
-					int LA5_0 = input.LA(1);
-
-					if ( (LA5_0=='\n'||LA5_0=='\r') )
-					{
-						alt5=1;
-					}
-					switch ( alt5 )
-					{
-					case 1:
-						// Language\\AngleBracketTemplateLexer.g3:111:6: ( '\\r' )? '\\n'
-						{
-						// Language\\AngleBracketTemplateLexer.g3:111:6: ( '\\r' )?
-						int alt4=2;
-						int LA4_0 = input.LA(1);
-
-						if ( (LA4_0=='\r') )
-						{
-							alt4=1;
-						}
-						switch ( alt4 )
-						{
-						case 1:
-							// Language\\AngleBracketTemplateLexer.g3:111:7: '\\r'
-							{
-							Match('\r'); if (state.failed) return ;
-
-							}
-							break;
-
-						}
-
-						Match('\n'); if (state.failed) return ;
-
-						}
-						break;
-
-					}
-
-					if ( state.backtracking == 0 )
-					{
-
-										Text = "if(" + (exp!=null?exp.Text:null) + ")";
-										_type = TemplateParser.IF;
-
-					}
-
-					}
-					break;
-				case 2:
-					// Language\\AngleBracketTemplateLexer.g3:116:5: => '<elseif' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )?
-					{
-
-					Match("<elseif"); if (state.failed) return ;
-
-					// Language\\AngleBracketTemplateLexer.g3:117:14: ( ' ' )*
-					for ( ; ; )
-					{
-						int alt6=2;
-						int LA6_0 = input.LA(1);
-
-						if ( (LA6_0==' ') )
-						{
-							alt6=1;
-						}
-
-
-						switch ( alt6 )
-						{
-						case 1:
-							// Language\\AngleBracketTemplateLexer.g3:117:15: ' '
-							{
-							Match(' '); if (state.failed) return ;
-
-							}
-							break;
-
-						default:
-							goto loop6;
-						}
-					}
-
-					loop6:
-						;
-
-
-					Match('('); if (state.failed) return ;
-					int expStart233 = CharIndex;
-					mIF_EXPR(); if (state.failed) return ;
-					exp = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, expStart233, CharIndex-1);
-					Match(")>"); if (state.failed) return ;
-
-					// Language\\AngleBracketTemplateLexer.g3:118:4: ( ( '\\r' )? '\\n' )?
-					int alt8=2;
-					int LA8_0 = input.LA(1);
-
-					if ( (LA8_0=='\n'||LA8_0=='\r') )
-					{
-						alt8=1;
-					}
-					switch ( alt8 )
-					{
-					case 1:
-						// Language\\AngleBracketTemplateLexer.g3:118:6: ( '\\r' )? '\\n'
-						{
-						// Language\\AngleBracketTemplateLexer.g3:118:6: ( '\\r' )?
-						int alt7=2;
-						int LA7_0 = input.LA(1);
-
-						if ( (LA7_0=='\r') )
-						{
-							alt7=1;
-						}
-						switch ( alt7 )
-						{
-						case 1:
-							// Language\\AngleBracketTemplateLexer.g3:118:7: '\\r'
-							{
-							Match('\r'); if (state.failed) return ;
-
-							}
-							break;
-
-						}
-
-						Match('\n'); if (state.failed) return ;
-
-						}
-						break;
-
-					}
-
-					if ( state.backtracking == 0 )
-					{
-
-										Text = "elseif(" + (exp!=null?exp.Text:null) + ")";
-										_type = TemplateParser.ELSEIF;
-
-					}
-
-					}
-					break;
-				case 3:
-					// Language\\AngleBracketTemplateLexer.g3:123:5: => '<else>' ( ( '\\r' )? '\\n' )?
-					{
-
-					Match("<else>"); if (state.failed) return ;
-
-					// Language\\AngleBracketTemplateLexer.g3:125:4: ( ( '\\r' )? '\\n' )?
-					int alt10=2;
-					int LA10_0 = input.LA(1);
-
-					if ( (LA10_0=='\n'||LA10_0=='\r') )
-					{
-						alt10=1;
-					}
-					switch ( alt10 )
-					{
-					case 1:
-						// Language\\AngleBracketTemplateLexer.g3:125:6: ( '\\r' )? '\\n'
-						{
-						// Language\\AngleBracketTemplateLexer.g3:125:6: ( '\\r' )?
-						int alt9=2;
-						int LA9_0 = input.LA(1);
-
-						if ( (LA9_0=='\r') )
-						{
-							alt9=1;
-						}
-						switch ( alt9 )
-						{
-						case 1:
-							// Language\\AngleBracketTemplateLexer.g3:125:7: '\\r'
-							{
-							Match('\r'); if (state.failed) return ;
-
-							}
-							break;
-
-						}
-
-						Match('\n'); if (state.failed) return ;
-
-						}
-						break;
-
-					}
-
-					if ( state.backtracking == 0 )
-					{
-
-										Text = "else";
-										_type = TemplateParser.ELSE;
-
-					}
-
-					}
-					break;
-				case 4:
-					// Language\\AngleBracketTemplateLexer.g3:130:5: => '<endif>' ({...}? => ( '\\r' )? '\\n' )?
-					{
-
-					Match("<endif>"); if (state.failed) return ;
-
-					// Language\\AngleBracketTemplateLexer.g3:132:4: ({...}? => ( '\\r' )? '\\n' )?
-					int alt12=2;
-					int LA12_0 = input.LA(1);
-
-					if ( (LA12_0=='\n'||LA12_0=='\r') && ((startCol==0)))
-					{
-						alt12=1;
-					}
-					switch ( alt12 )
-					{
-					case 1:
-						// Language\\AngleBracketTemplateLexer.g3:132:6: {...}? => ( '\\r' )? '\\n'
-						{
-						if ( !((startCol==0)) )
-						{
-							if (state.backtracking>0) {state.failed=true; return ;}
-							throw new FailedPredicateException(input, "ACTION", "startCol==0");
-						}
-						// Language\\AngleBracketTemplateLexer.g3:132:24: ( '\\r' )?
-						int alt11=2;
-						int LA11_0 = input.LA(1);
-
-						if ( (LA11_0=='\r') )
-						{
-							alt11=1;
-						}
-						switch ( alt11 )
-						{
-						case 1:
-							// Language\\AngleBracketTemplateLexer.g3:132:25: '\\r'
-							{
-							Match('\r'); if (state.failed) return ;
-
-							}
-							break;
-
-						}
-
-						Match('\n'); if (state.failed) return ;
-
-						}
-						break;
-
-					}
-
-					if ( state.backtracking == 0 )
-					{
-
-										Text = "endif";
-										_type = TemplateParser.ENDIF;
-
-					}
-
-					}
-					break;
-				case 5:
-					// Language\\AngleBracketTemplateLexer.g3:139:4: => '<@' (ch=~ ( '>' | '(' ) )+ ( '()>' | '>' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )? )
-					{
-
-					if ( state.backtracking == 0 )
-					{
-
-										builder = new System.Text.StringBuilder();
-
-					}
-					Match("<@"); if (state.failed) return ;
-
-					// Language\\AngleBracketTemplateLexer.g3:144:4: (ch=~ ( '>' | '(' ) )+
-					int cnt13=0;
-					for ( ; ; )
-					{
-						int alt13=2;
-						int LA13_0 = input.LA(1);
-
-						if ( ((LA13_0>='\u0000' && LA13_0<='\'')||(LA13_0>=')' && LA13_0<='=')||(LA13_0>='?' && LA13_0<='\uFFFF')) )
-						{
-							alt13=1;
-						}
-
-
-						switch ( alt13 )
-						{
-						case 1:
-							// Language\\AngleBracketTemplateLexer.g3:144:6: ch=~ ( '>' | '(' )
-							{
-							ch= input.LA(1);
-							input.Consume();
-							state.failed=false;
-							if ( state.backtracking == 0 )
-							{
-								builder.Append((char)ch);
-							}
-
-							}
-							break;
-
-						default:
-							if ( cnt13 >= 1 )
-								goto loop13;
-
-							if (state.backtracking>0) {state.failed=true; return ;}
-							EarlyExitException eee13 = new EarlyExitException( 13, input );
-							throw eee13;
-						}
-						cnt13++;
-					}
-					loop13:
-						;
-
-
-					if ( state.backtracking == 0 )
-					{
-						 t = builder.ToString();
-					}
-					// Language\\AngleBracketTemplateLexer.g3:146:4: ( '()>' | '>' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )? )
-					int alt24=2;
-					int LA24_0 = input.LA(1);
-
-					if ( (LA24_0=='(') )
-					{
-						alt24=1;
-					}
-					else if ( (LA24_0=='>') )
-					{
-						alt24=2;
-					}
-					else
-					{
-						if (state.backtracking>0) {state.failed=true; return ;}
-						NoViableAltException nvae = new NoViableAltException("", 24, 0, input);
-
-						throw nvae;
-					}
-					switch ( alt24 )
-					{
-					case 1:
-						// Language\\AngleBracketTemplateLexer.g3:146:6: '()>'
-						{
-						Match("()>"); if (state.failed) return ;
-
-						if ( state.backtracking == 0 )
-						{
-
-												_type = TemplateParser.REGION_REF;
-
-						}
-
-						}
-						break;
-					case 2:
-						// Language\\AngleBracketTemplateLexer.g3:150:6: '>' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )?
-						{
-						Match('>'); if (state.failed) return ;
-						if ( state.backtracking == 0 )
-						{
-
-												_type = TemplateParser.REGION_DEF;
-												builder.Append("::=");
-
-						}
-						// Language\\AngleBracketTemplateLexer.g3:155:5: (=> ( '\\r' )? '\\n' )?
-						int alt15=2;
-						int LA15_0 = input.LA(1);
-
-						if ( (LA15_0=='\r') )
-						{
-							int LA15_1 = input.LA(2);
-
-							if ( (LA15_1=='\n') )
-							{
-								int LA15_4 = input.LA(3);
-
-								if ( (EvaluatePredicate(synpred9_AngleBracketTemplateLexer_fragment)) )
-								{
-									alt15=1;
-								}
-							}
-						}
-						else if ( (LA15_0=='\n') )
-						{
-							int LA15_2 = input.LA(2);
-
-							if ( (EvaluatePredicate(synpred9_AngleBracketTemplateLexer_fragment)) )
-							{
-								alt15=1;
-							}
-						}
-						switch ( alt15 )
-						{
-						case 1:
-							// Language\\AngleBracketTemplateLexer.g3:155:7: => ( '\\r' )? '\\n'
-							{
-
-							// Language\\AngleBracketTemplateLexer.g3:155:22: ( '\\r' )?
-							int alt14=2;
-							int LA14_0 = input.LA(1);
-
-							if ( (LA14_0=='\r') )
-							{
-								alt14=1;
-							}
-							switch ( alt14 )
-							{
-							case 1:
-								// Language\\AngleBracketTemplateLexer.g3:155:23: '\\r'
-								{
-								Match('\r'); if (state.failed) return ;
-
-								}
-								break;
-
-							}
-
-							Match('\n'); if (state.failed) return ;
-
-							}
-							break;
-
-						}
-
-						if ( state.backtracking == 0 )
-						{
-
-												atLeft = false;
-
-						}
-						// Language\\AngleBracketTemplateLexer.g3:159:5: ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+
-						int cnt18=0;
-						for ( ; ; )
-						{
-							int alt18=2;
-							alt18 = dfa18.Predict(input);
-							switch ( alt18 )
-							{
-							case 1:
-								// Language\\AngleBracketTemplateLexer.g3:159:7: {...}? => (=> ( '\\r' )? '\\n' |ch= . )
-								{
-								if ( !((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))) )
-								{
-									if (state.backtracking>0) {state.failed=true; return ;}
-									throw new FailedPredicateException(input, "ACTION", "!(UpcomingAtEND(1) || ( input.LA(1) == '\\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\\r' && input.LA(2) == '\\n' && UpcomingAtEND(3) ))");
-								}
-								// Language\\AngleBracketTemplateLexer.g3:160:6: (=> ( '\\r' )? '\\n' |ch= . )
-								int alt17=2;
-								int LA17_0 = input.LA(1);
-
-								if ( (LA17_0=='\r') )
-								{
-									int LA17_1 = input.LA(2);
-
-									if ( (EvaluatePredicate(synpred10_AngleBracketTemplateLexer_fragment)) )
-									{
-										alt17=1;
-									}
-									else if ( (true) )
-									{
-										alt17=2;
-									}
-									else
-									{
-										if (state.backtracking>0) {state.failed=true; return ;}
-										NoViableAltException nvae = new NoViableAltException("", 17, 1, input);
-
-										throw nvae;
-									}
-								}
-								else if ( (LA17_0=='\n') )
-								{
-									int LA17_2 = input.LA(2);
-
-									if ( (EvaluatePredicate(synpred10_AngleBracketTemplateLexer_fragment)) )
-									{
-										alt17=1;
-									}
-									else if ( (true) )
-									{
-										alt17=2;
-									}
-									else
-									{
-										if (state.backtracking>0) {state.failed=true; return ;}
-										NoViableAltException nvae = new NoViableAltException("", 17, 2, input);
-
-										throw nvae;
-									}
-								}
-								else if ( ((LA17_0>='\u0000' && LA17_0<='\t')||(LA17_0>='\u000B' && LA17_0<='\f')||(LA17_0>='\u000E' && LA17_0<='\uFFFF')) )
-								{
-									alt17=2;
-								}
-								else
-								{
-									if (state.backtracking>0) {state.failed=true; return ;}
-									NoViableAltException nvae = new NoViableAltException("", 17, 0, input);
-
-									throw nvae;
-								}
-								switch ( alt17 )
-								{
-								case 1:
-									// Language\\AngleBracketTemplateLexer.g3:160:8: => ( '\\r' )? '\\n'
-									{
-
-									// Language\\AngleBracketTemplateLexer.g3:160:23: ( '\\r' )?
-									int alt16=2;
-									int LA16_0 = input.LA(1);
-
-									if ( (LA16_0=='\r') )
-									{
-										alt16=1;
-									}
-									switch ( alt16 )
-									{
-									case 1:
-										// Language\\AngleBracketTemplateLexer.g3:160:24: '\\r'
-										{
-										Match('\r'); if (state.failed) return ;
-										if ( state.backtracking == 0 )
-										{
-											builder.Append('\r');
-										}
-
-										}
-										break;
-
-									}
-
-									Match('\n'); if (state.failed) return ;
-									if ( state.backtracking == 0 )
-									{
-										builder.Append('\n'); atLeft = true;
-									}
-
-									}
-									break;
-								case 2:
-									// Language\\AngleBracketTemplateLexer.g3:161:8: ch= .
-									{
-									ch = input.LA(1);
-									MatchAny(); if (state.failed) return ;
-									if ( state.backtracking == 0 )
-									{
-										builder.Append((char)ch); atLeft = false;
-									}
-
-									}
-									break;
-
-								}
-
-
-								}
-								break;
-
-							default:
-								if ( cnt18 >= 1 )
-									goto loop18;
-
-								if (state.backtracking>0) {state.failed=true; return ;}
-								EarlyExitException eee18 = new EarlyExitException( 18, input );
-								throw eee18;
-							}
-							cnt18++;
-						}
-						loop18:
-							;
-
-
-						// Language\\AngleBracketTemplateLexer.g3:164:5: (=> ( '\\r' )? '\\n' )?
-						int alt20=2;
-						int LA20_0 = input.LA(1);
-
-						if ( (LA20_0=='\r') )
-						{
-							int LA20_1 = input.LA(2);
-
-							if ( (LA20_1=='\n') )
-							{
-								int LA20_4 = input.LA(3);
-
-								if ( (LA20_4=='<') && (EvaluatePredicate(synpred11_AngleBracketTemplateLexer_fragment)))
-								{
-									alt20=1;
-								}
-								else if ( ((LA20_4>='\u0000' && LA20_4<=';')||(LA20_4>='=' && LA20_4<='\uFFFF')) && (EvaluatePredicate(synpred11_AngleBracketTemplateLexer_fragment)))
-								{
-									alt20=1;
-								}
-							}
-						}
-						else if ( (LA20_0=='\n') )
-						{
-							int LA20_2 = input.LA(2);
-
-							if ( (LA20_2=='<') && (EvaluatePredicate(synpred11_AngleBracketTemplateLexer_fragment)))
-							{
-								alt20=1;
-							}
-							else if ( (LA20_2=='\r') )
-							{
-								int LA20_6 = input.LA(3);
-
-								if ( (EvaluatePredicate(synpred11_AngleBracketTemplateLexer_fragment)) )
-								{
-									alt20=1;
-								}
-							}
-							else if ( (LA20_2=='\n') )
-							{
-								int LA20_7 = input.LA(3);
-
-								if ( (EvaluatePredicate(synpred11_AngleBracketTemplateLexer_fragment)) )
-								{
-									alt20=1;
-								}
-							}
-							else if ( ((LA20_2>='\u0000' && LA20_2<='\t')||(LA20_2>='\u000B' && LA20_2<='\f')||(LA20_2>='\u000E' && LA20_2<=';')||(LA20_2>='=' && LA20_2<='\uFFFF')) && (EvaluatePredicate(synpred11_AngleBracketTemplateLexer_fragment)))
-							{
-								alt20=1;
-							}
-						}
-						switch ( alt20 )
-						{
-						case 1:
-							// Language\\AngleBracketTemplateLexer.g3:164:7: => ( '\\r' )? '\\n'
-							{
-
-							// Language\\AngleBracketTemplateLexer.g3:164:22: ( '\\r' )?
-							int alt19=2;
-							int LA19_0 = input.LA(1);
-
-							if ( (LA19_0=='\r') )
-							{
-								alt19=1;
-							}
-							switch ( alt19 )
-							{
-							case 1:
-								// Language\\AngleBracketTemplateLexer.g3:164:23: '\\r'
-								{
-								Match('\r'); if (state.failed) return ;
-
-								}
-								break;
-
-							}
-
-							Match('\n'); if (state.failed) return ;
-							if ( state.backtracking == 0 )
-							{
-								atLeft = true;
-							}
-
-							}
-							break;
-
-						}
-
-						// Language\\AngleBracketTemplateLexer.g3:165:5: ( '<@end>' | . )
-						int alt21=2;
-						int LA21_0 = input.LA(1);
-
-						if ( (LA21_0=='<') )
-						{
-							int LA21_1 = input.LA(2);
-
-							if ( (LA21_1=='@') )
-							{
-								alt21=1;
-							}
-							else
-							{
-								alt21=2;}
-						}
-						else if ( ((LA21_0>='\u0000' && LA21_0<=';')||(LA21_0>='=' && LA21_0<='\uFFFF')) )
-						{
-							alt21=2;
-						}
-						else
-						{
-							if (state.backtracking>0) {state.failed=true; return ;}
-							NoViableAltException nvae = new NoViableAltException("", 21, 0, input);
-
-							throw nvae;
-						}
-						switch ( alt21 )
-						{
-						case 1:
-							// Language\\AngleBracketTemplateLexer.g3:165:7: '<@end>'
-							{
-							Match("<@end>"); if (state.failed) return ;
-
-
-							}
-							break;
-						case 2:
-							// Language\\AngleBracketTemplateLexer.g3:166:7: .
-							{
-							MatchAny(); if (state.failed) return ;
-							if ( state.backtracking == 0 )
-							{
-								self.Error("missing region "+t+" <@end> tag");
-							}
-
-							}
-							break;
-
-						}
-
-						// Language\\AngleBracketTemplateLexer.g3:168:5: ({...}? => ( '\\r' )? '\\n' )?
-						int alt23=2;
-						int LA23_0 = input.LA(1);
-
-						if ( (LA23_0=='\n'||LA23_0=='\r') && ((atLeft)))
-						{
-							alt23=1;
-						}
-						switch ( alt23 )
-						{
-						case 1:
-							// Language\\AngleBracketTemplateLexer.g3:168:7: {...}? => ( '\\r' )? '\\n'
-							{
-							if ( !((atLeft)) )
-							{
-								if (state.backtracking>0) {state.failed=true; return ;}
-								throw new FailedPredicateException(input, "ACTION", "atLeft");
-							}
-							// Language\\AngleBracketTemplateLexer.g3:168:20: ( '\\r' )?
-							int alt22=2;
-							int LA22_0 = input.LA(1);
-
-							if ( (LA22_0=='\r') )
-							{
-								alt22=1;
-							}
-							switch ( alt22 )
-							{
-							case 1:
-								// Language\\AngleBracketTemplateLexer.g3:168:21: '\\r'
-								{
-								Match('\r'); if (state.failed) return ;
-
-								}
-								break;
-
-							}
-
-							Match('\n'); if (state.failed) return ;
-
-							}
-							break;
-
-						}
-
-
-						}
-						break;
-
-					}
-
-					if ( state.backtracking == 0 )
-					{
-
-										Text = builder.ToString();
-
-					}
-
-					}
-					break;
-				case 6:
-					// Language\\AngleBracketTemplateLexer.g3:173:5: '<' EXPR[out subtext] '>'
-					{
-					Match('<'); if (state.failed) return ;
-					mEXPR(out subtext); if (state.failed) return ;
-					Match('>'); if (state.failed) return ;
-					if ( state.backtracking == 0 )
-					{
-						 Text = subtext;
-					}
-
-					}
-					break;
-
-				}
-
-				if ( state.backtracking == 0 )
-				{
-
-								//ChunkToken t = new ChunkToken(_type, Text, currentIndent);
-								//state.token = t; //$ setToken(t);
-								state.token = new ChunkToken(_type, Text, currentIndent);
-
-				}
-
-				}
-				break;
-
-			}
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ACTION"
-
-	// $ANTLR start "LITERAL"
-	private void mLITERAL()
-	{
-		try
-		{
-			int _type = LITERAL;
-			int _channel = DefaultTokenChannel;
-			CommonToken ind=null;
-			int ch;
-
-
-				System.Text.StringBuilder builder = new System.Text.StringBuilder();
-				int loopStartIndex = 0;
-				int col = 0;
-
-			// Language\\AngleBracketTemplateLexer.g3:190:4: ( ( ( '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) ) ) |ind= INDENT |ch=~ ( '\\\\' | ' ' | '\\t' | '<' | '\\r' | '\\n' ) )+ )
-			// Language\\AngleBracketTemplateLexer.g3:190:4: ( ( '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) ) ) |ind= INDENT |ch=~ ( '\\\\' | ' ' | '\\t' | '<' | '\\r' | '\\n' ) )+
-			{
-			// Language\\AngleBracketTemplateLexer.g3:190:4: ( ( '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) ) ) |ind= INDENT |ch=~ ( '\\\\' | ' ' | '\\t' | '<' | '\\r' | '\\n' ) )+
-			int cnt28=0;
-			for ( ; ; )
-			{
-				int alt28=4;
-				int LA28_0 = input.LA(1);
-
-				if ( (LA28_0=='\\') )
-				{
-					alt28=1;
-				}
-				else if ( (LA28_0=='\t'||LA28_0==' ') )
-				{
-					alt28=2;
-				}
-				else if ( ((LA28_0>='\u0000' && LA28_0<='\b')||(LA28_0>='\u000B' && LA28_0<='\f')||(LA28_0>='\u000E' && LA28_0<='\u001F')||(LA28_0>='!' && LA28_0<=';')||(LA28_0>='=' && LA28_0<='[')||(LA28_0>=']' && LA28_0<='\uFFFF')) )
-				{
-					alt28=3;
-				}
-
-
-				switch ( alt28 )
-				{
-				case 1:
-					// Language\\AngleBracketTemplateLexer.g3:190:6: ( '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) ) )
-					{
-					// Language\\AngleBracketTemplateLexer.g3:190:6: ( '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) ) )
-					// Language\\AngleBracketTemplateLexer.g3:190:8: '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) )
-					{
-					Match('\\'); if (state.failed) return ;
-					// Language\\AngleBracketTemplateLexer.g3:191:5: ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) )
-					int alt27=4;
-					int LA27_0 = input.LA(1);
-
-					if ( (LA27_0=='<') )
-					{
-						alt27=1;
-					}
-					else if ( (LA27_0=='>') )
-					{
-						alt27=2;
-					}
-					else if ( (LA27_0=='\\') )
-					{
-						alt27=3;
-					}
-					else if ( ((LA27_0>='\u0000' && LA27_0<=';')||LA27_0=='='||(LA27_0>='?' && LA27_0<='[')||(LA27_0>=']' && LA27_0<='\uFFFF')) )
-					{
-						alt27=4;
-					}
-					else
-					{
-						if (state.backtracking>0) {state.failed=true; return ;}
-						NoViableAltException nvae = new NoViableAltException("", 27, 0, input);
-
-						throw nvae;
-					}
-					switch ( alt27 )
-					{
-					case 1:
-						// Language\\AngleBracketTemplateLexer.g3:191:7: '<'
-						{
-						Match('<'); if (state.failed) return ;
-						if ( state.backtracking == 0 )
-						{
-							 builder.Append('<');
-						}
-
-						}
-						break;
-					case 2:
-						// Language\\AngleBracketTemplateLexer.g3:192:7: '>'
-						{
-						Match('>'); if (state.failed) return ;
-						if ( state.backtracking == 0 )
-						{
-							 builder.Append('>');
-						}
-
-						}
-						break;
-					case 3:
-						// Language\\AngleBracketTemplateLexer.g3:193:7: '\\\\'
-						{
-						Match('\\'); if (state.failed) return ;
-						if ( state.backtracking == 0 )
-						{
-							 builder.Append('\\');
-						}
-
-						}
-						break;
-					case 4:
-						// Language\\AngleBracketTemplateLexer.g3:194:7: ch=~ ( '<' | '>' | '\\\\' )
-						{
-						ch= input.LA(1);
-						input.Consume();
-						state.failed=false;
-						if ( state.backtracking == 0 )
-						{
-							 builder.Append( "\\" + (char)ch );
-						}
-
-						}
-						break;
-
-					}
-
-
-					}
-
-
-					}
-					break;
-				case 2:
-					// Language\\AngleBracketTemplateLexer.g3:197:5: ind= INDENT
-					{
-					int indStart699 = CharIndex;
-					mINDENT(); if (state.failed) return ;
-					ind = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, indStart699, CharIndex-1);
-					if ( state.backtracking == 0 )
-					{
-
-										loopStartIndex = builder.Length;
-										col = CharPositionInLine - (ind!=null?ind.Text:null).Length;
-
-										builder.Append( (ind!=null?ind.Text:null) );
-										if ( col==0 && input.LA(1)=='<' )
-										{
-											// store indent in ASTExpr not in a literal
-											currentIndent=(ind!=null?ind.Text:null);
-											builder.Length = loopStartIndex; // reset length to wack text
-										}
-										else
-										{
-											currentIndent=null;
-										}
-
-					}
-
-					}
-					break;
-				case 3:
-					// Language\\AngleBracketTemplateLexer.g3:214:5: ch=~ ( '\\\\' | ' ' | '\\t' | '<' | '\\r' | '\\n' )
-					{
-					ch= input.LA(1);
-					input.Consume();
-					state.failed=false;
-					if ( state.backtracking == 0 )
-					{
-						 builder.Append( (char)ch );
-					}
-
-					}
-					break;
-
-				default:
-					if ( cnt28 >= 1 )
-						goto loop28;
-
-					if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee28 = new EarlyExitException( 28, input );
-					throw eee28;
-				}
-				cnt28++;
-			}
-			loop28:
-				;
-
-
-			if ( state.backtracking == 0 )
-			{
-
-							Text = builder.ToString();
-							if ( Text.Length == 0 )
-							{
-								_channel = Hidden;
-							}
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "LITERAL"
-
-	// $ANTLR start "INDENT"
-	private void mINDENT()
-	{
-		try
-		{
-			// Language\\AngleBracketTemplateLexer.g3:227:4: ( ( ' ' | '\\t' )+ )
-			// Language\\AngleBracketTemplateLexer.g3:227:4: ( ' ' | '\\t' )+
-			{
-			// Language\\AngleBracketTemplateLexer.g3:227:4: ( ' ' | '\\t' )+
-			int cnt29=0;
-			for ( ; ; )
-			{
-				int alt29=2;
-				int LA29_0 = input.LA(1);
-
-				if ( (LA29_0=='\t'||LA29_0==' ') )
-				{
-					alt29=1;
-				}
-
-
-				switch ( alt29 )
-				{
-				case 1:
-					// Language\\AngleBracketTemplateLexer.g3:
-					{
-					input.Consume();
-					state.failed=false;
-
-					}
-					break;
-
-				default:
-					if ( cnt29 >= 1 )
-						goto loop29;
-
-					if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee29 = new EarlyExitException( 29, input );
-					throw eee29;
-				}
-				cnt29++;
-			}
-			loop29:
-				;
-
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "INDENT"
-
-	// $ANTLR start "EXPR"
-	private void mEXPR(out string _text)
-	{
-		try
-		{
-			CommonToken st=null;
-			CommonToken ESC1=null;
-			int ch;
-
-
-				string subtext = string.Empty;
-				_text = string.Empty;
-				System.Text.StringBuilder builder = new System.Text.StringBuilder();
-
-			// Language\\AngleBracketTemplateLexer.g3:238:4: ( ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '>' ) )+ )
-			// Language\\AngleBracketTemplateLexer.g3:238:4: ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '>' ) )+
-			{
-			// Language\\AngleBracketTemplateLexer.g3:238:4: ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '>' ) )+
-			int cnt32=0;
-			for ( ; ; )
-			{
-				int alt32=5;
-				int LA32_0 = input.LA(1);
-
-				if ( (LA32_0=='\\') )
-				{
-					alt32=1;
-				}
-				else if ( (LA32_0=='{') )
-				{
-					alt32=2;
-				}
-				else if ( (LA32_0=='+'||LA32_0=='=') )
-				{
-					alt32=3;
-				}
-				else if ( ((LA32_0>='\u0000' && LA32_0<='*')||(LA32_0>=',' && LA32_0<='<')||(LA32_0>='?' && LA32_0<='[')||(LA32_0>=']' && LA32_0<='z')||(LA32_0>='|' && LA32_0<='\uFFFF')) )
-				{
-					alt32=4;
-				}
-
-
-				switch ( alt32 )
-				{
-				case 1:
-					// Language\\AngleBracketTemplateLexer.g3:238:6: ESC
-					{
-					int ESC1Start778 = CharIndex;
-					mESC(); if (state.failed) return ;
-					ESC1 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ESC1Start778, CharIndex-1);
-					if ( state.backtracking == 0 )
-					{
-						builder.Append((ESC1!=null?ESC1.Text:null));
-					}
-
-					}
-					break;
-				case 2:
-					// Language\\AngleBracketTemplateLexer.g3:239:5: st= SUBTEMPLATE
-					{
-					int stStart796 = CharIndex;
-					mSUBTEMPLATE(); if (state.failed) return ;
-					st = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, stStart796, CharIndex-1);
-					if ( state.backtracking == 0 )
-					{
-						builder.Append((st!=null?st.Text:null));
-					}
-
-					}
-					break;
-				case 3:
-					// Language\\AngleBracketTemplateLexer.g3:240:5: ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) )
-					{
-					// Language\\AngleBracketTemplateLexer.g3:240:5: ( '=' | '+' )
-					int alt30=2;
-					int LA30_0 = input.LA(1);
-
-					if ( (LA30_0=='=') )
-					{
-						alt30=1;
-					}
-					else if ( (LA30_0=='+') )
-					{
-						alt30=2;
-					}
-					else
-					{
-						if (state.backtracking>0) {state.failed=true; return ;}
-						NoViableAltException nvae = new NoViableAltException("", 30, 0, input);
-
-						throw nvae;
-					}
-					switch ( alt30 )
-					{
-					case 1:
-						// Language\\AngleBracketTemplateLexer.g3:240:7: '='
-						{
-						Match('='); if (state.failed) return ;
-						if ( state.backtracking == 0 )
-						{
-							builder.Append('=');
-						}
-
-						}
-						break;
-					case 2:
-						// Language\\AngleBracketTemplateLexer.g3:241:6: '+'
-						{
-						Match('+'); if (state.failed) return ;
-						if ( state.backtracking == 0 )
-						{
-							builder.Append('+');
-						}
-
-						}
-						break;
-
-					}
-
-					// Language\\AngleBracketTemplateLexer.g3:243:4: ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) )
-					int alt31=3;
-					int LA31_0 = input.LA(1);
-
-					if ( (LA31_0=='\"'||LA31_0=='<') )
-					{
-						alt31=1;
-					}
-					else if ( (LA31_0=='{') )
-					{
-						alt31=2;
-					}
-					else if ( ((LA31_0>='\u0000' && LA31_0<='!')||(LA31_0>='#' && LA31_0<=';')||(LA31_0>='=' && LA31_0<='z')||(LA31_0>='|' && LA31_0<='\uFFFF')) )
-					{
-						alt31=3;
-					}
-					else
-					{
-						if (state.backtracking>0) {state.failed=true; return ;}
-						NoViableAltException nvae = new NoViableAltException("", 31, 0, input);
-
-						throw nvae;
-					}
-					switch ( alt31 )
-					{
-					case 1:
-						// Language\\AngleBracketTemplateLexer.g3:243:6: TEMPLATE[out subtext]
-						{
-						mTEMPLATE(out subtext); if (state.failed) return ;
-						if ( state.backtracking == 0 )
-						{
-							builder.Append(subtext);
-						}
-
-						}
-						break;
-					case 2:
-						// Language\\AngleBracketTemplateLexer.g3:244:6: st= SUBTEMPLATE
-						{
-						int stStart862 = CharIndex;
-						mSUBTEMPLATE(); if (state.failed) return ;
-						st = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, stStart862, CharIndex-1);
-						if ( state.backtracking == 0 )
-						{
-							builder.Append((st!=null?st.Text:null));
-						}
-
-						}
-						break;
-					case 3:
-						// Language\\AngleBracketTemplateLexer.g3:245:6: ch=~ ( '\"' | '<' | '{' )
-						{
-						ch= input.LA(1);
-						input.Consume();
-						state.failed=false;
-						if ( state.backtracking == 0 )
-						{
-							builder.Append((char)ch);
-						}
-
-						}
-						break;
-
-					}
-
-
-					}
-					break;
-				case 4:
-					// Language\\AngleBracketTemplateLexer.g3:247:5: ch=~ ( '\\\\' | '{' | '=' | '+' | '>' )
-					{
-					ch= input.LA(1);
-					input.Consume();
-					state.failed=false;
-					if ( state.backtracking == 0 )
-					{
-						builder.Append((char)ch);
-					}
-
-					}
-					break;
-
-				default:
-					if ( cnt32 >= 1 )
-						goto loop32;
-
-					if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee32 = new EarlyExitException( 32, input );
-					throw eee32;
-				}
-				cnt32++;
-			}
-			loop32:
-				;
-
-
-			if ( state.backtracking == 0 )
-			{
-				_text = builder.ToString();
-			}
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "EXPR"
-
-	// $ANTLR start "TEMPLATE"
-	private void mTEMPLATE(out string _text)
-	{
-		try
-		{
-			CommonToken ESC2=null;
-			int ch;
-
-
-				_text = string.Empty;
-				System.Text.StringBuilder builder = new System.Text.StringBuilder();
-
-			// Language\\AngleBracketTemplateLexer.g3:259:4: ( '\"' ( ESC |ch=~ ( '\\\\' | '\"' ) )* '\"' | '<<' (=> ( '\\r' )? '\\n' )? ( options {k=2; } :=> ( '\\r' )? '\\n' |=>ch= . )* '>>' )
-			int alt38=2;
-			int LA38_0 = input.LA(1);
-
-			if ( (LA38_0=='\"') )
-			{
-				alt38=1;
-			}
-			else if ( (LA38_0=='<') )
-			{
-				alt38=2;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				NoViableAltException nvae = new NoViableAltException("", 38, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt38 )
-			{
-			case 1:
-				// Language\\AngleBracketTemplateLexer.g3:259:4: '\"' ( ESC |ch=~ ( '\\\\' | '\"' ) )* '\"'
-				{
-				Match('\"'); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-					builder.Append('"');
-				}
-				// Language\\AngleBracketTemplateLexer.g3:261:3: ( ESC |ch=~ ( '\\\\' | '\"' ) )*
-				for ( ; ; )
-				{
-					int alt33=3;
-					int LA33_0 = input.LA(1);
-
-					if ( (LA33_0=='\\') )
-					{
-						alt33=1;
-					}
-					else if ( ((LA33_0>='\u0000' && LA33_0<='!')||(LA33_0>='#' && LA33_0<='[')||(LA33_0>=']' && LA33_0<='\uFFFF')) )
-					{
-						alt33=2;
-					}
-
-
-					switch ( alt33 )
-					{
-					case 1:
-						// Language\\AngleBracketTemplateLexer.g3:261:5: ESC
-						{
-						int ESC2Start955 = CharIndex;
-						mESC(); if (state.failed) return ;
-						ESC2 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ESC2Start955, CharIndex-1);
-						if ( state.backtracking == 0 )
-						{
-							builder.Append((ESC2!=null?ESC2.Text:null));
-						}
-
-						}
-						break;
-					case 2:
-						// Language\\AngleBracketTemplateLexer.g3:262:5: ch=~ ( '\\\\' | '\"' )
-						{
-						ch= input.LA(1);
-						input.Consume();
-						state.failed=false;
-						if ( state.backtracking == 0 )
-						{
-							builder.Append((char)ch);
-						}
-
-						}
-						break;
-
-					default:
-						goto loop33;
-					}
-				}
-
-				loop33:
-					;
-
-
-				Match('\"'); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-
-								builder.Append('"');
-								_text = builder.ToString();
-
-				}
-
-				}
-				break;
-			case 2:
-				// Language\\AngleBracketTemplateLexer.g3:269:4: '<<' (=> ( '\\r' )? '\\n' )? ( options {k=2; } :=> ( '\\r' )? '\\n' |=>ch= . )* '>>'
-				{
-				Match("<<"); if (state.failed) return ;
-
-				if ( state.backtracking == 0 )
-				{
-
-								builder.Append("<<");
-
-				}
-				// Language\\AngleBracketTemplateLexer.g3:273:3: (=> ( '\\r' )? '\\n' )?
-				int alt35=2;
-				int LA35_0 = input.LA(1);
-
-				if ( (LA35_0=='\r') )
-				{
-					int LA35_1 = input.LA(2);
-
-					if ( (LA35_1=='\n') )
-					{
-						int LA35_2 = input.LA(3);
-
-						if ( (EvaluatePredicate(synpred12_AngleBracketTemplateLexer_fragment)) )
-						{
-							alt35=1;
-						}
-					}
-				}
-				else if ( (LA35_0=='\n') )
-				{
-					int LA35_2 = input.LA(2);
-
-					if ( (EvaluatePredicate(synpred12_AngleBracketTemplateLexer_fragment)) )
-					{
-						alt35=1;
-					}
-				}
-				switch ( alt35 )
-				{
-				case 1:
-					// Language\\AngleBracketTemplateLexer.g3:273:5: => ( '\\r' )? '\\n'
-					{
-
-					// Language\\AngleBracketTemplateLexer.g3:273:20: ( '\\r' )?
-					int alt34=2;
-					int LA34_0 = input.LA(1);
-
-					if ( (LA34_0=='\r') )
-					{
-						alt34=1;
-					}
-					switch ( alt34 )
-					{
-					case 1:
-						// Language\\AngleBracketTemplateLexer.g3:273:21: '\\r'
-						{
-						Match('\r'); if (state.failed) return ;
-
-						}
-						break;
-
-					}
-
-					Match('\n'); if (state.failed) return ;
-
-					}
-					break;
-
-				}
-
-				// Language\\AngleBracketTemplateLexer.g3:274:3: ( options {k=2; } :=> ( '\\r' )? '\\n' |=>ch= . )*
-				for ( ; ; )
-				{
-					int alt37=3;
-					alt37 = dfa37.Predict(input);
-					switch ( alt37 )
-					{
-					case 1:
-						// Language\\AngleBracketTemplateLexer.g3:275:4: => ( '\\r' )? '\\n'
-						{
-
-						// Language\\AngleBracketTemplateLexer.g3:275:22: ( '\\r' )?
-						int alt36=2;
-						int LA36_0 = input.LA(1);
-
-						if ( (LA36_0=='\r') )
-						{
-							alt36=1;
-						}
-						switch ( alt36 )
-						{
-						case 1:
-							// Language\\AngleBracketTemplateLexer.g3:275:23: '\\r'
-							{
-							Match('\r'); if (state.failed) return ;
-
-							}
-							break;
-
-						}
-
-						Match('\n'); if (state.failed) return ;
-
-						}
-						break;
-					case 2:
-						// Language\\AngleBracketTemplateLexer.g3:276:5: =>ch= .
-						{
-
-						ch = input.LA(1);
-						MatchAny(); if (state.failed) return ;
-						if ( state.backtracking == 0 )
-						{
-							builder.Append((char)ch);
-						}
-
-						}
-						break;
-
-					default:
-						goto loop37;
-					}
-				}
-
-				loop37:
-					;
-
-
-				Match(">>"); if (state.failed) return ;
-
-				if ( state.backtracking == 0 )
-				{
-
-								builder.Append(">>");
-								_text = builder.ToString();
-
-				}
-
-				}
-				break;
-
-			}
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "TEMPLATE"
-
-	// $ANTLR start "IF_EXPR"
-	private void mIF_EXPR()
-	{
-		try
-		{
-			// Language\\AngleBracketTemplateLexer.g3:287:4: ( ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+ )
-			// Language\\AngleBracketTemplateLexer.g3:287:4: ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+
-			{
-			// Language\\AngleBracketTemplateLexer.g3:287:4: ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+
-			int cnt39=0;
-			for ( ; ; )
-			{
-				int alt39=5;
-				int LA39_0 = input.LA(1);
-
-				if ( (LA39_0=='\\') )
-				{
-					alt39=1;
-				}
-				else if ( (LA39_0=='{') )
-				{
-					alt39=2;
-				}
-				else if ( (LA39_0=='(') )
-				{
-					alt39=3;
-				}
-				else if ( ((LA39_0>='\u0000' && LA39_0<='\'')||(LA39_0>='*' && LA39_0<='[')||(LA39_0>=']' && LA39_0<='z')||(LA39_0>='|' && LA39_0<='\uFFFF')) )
-				{
-					alt39=4;
-				}
-
-
-				switch ( alt39 )
-				{
-				case 1:
-					// Language\\AngleBracketTemplateLexer.g3:287:6: ESC
-					{
-					mESC(); if (state.failed) return ;
-
-					}
-					break;
-				case 2:
-					// Language\\AngleBracketTemplateLexer.g3:288:5: SUBTEMPLATE
-					{
-					mSUBTEMPLATE(); if (state.failed) return ;
-
-					}
-					break;
-				case 3:
-					// Language\\AngleBracketTemplateLexer.g3:289:5: NESTED_PARENS
-					{
-					mNESTED_PARENS(); if (state.failed) return ;
-
-					}
-					break;
-				case 4:
-					// Language\\AngleBracketTemplateLexer.g3:290:5: ~ ( '\\\\' | '{' | '(' | ')' )
-					{
-					input.Consume();
-					state.failed=false;
-
-					}
-					break;
-
-				default:
-					if ( cnt39 >= 1 )
-						goto loop39;
-
-					if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee39 = new EarlyExitException( 39, input );
-					throw eee39;
-				}
-				cnt39++;
-			}
-			loop39:
-				;
-
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "IF_EXPR"
-
-	// $ANTLR start "ESC_CHAR"
-	private void mESC_CHAR(out char uc)
-	{
-		try
-		{
-			CommonToken a=null;
-			CommonToken b=null;
-			CommonToken c=null;
-			CommonToken d=null;
-
-
-				uc = '\0';
-
-			// Language\\AngleBracketTemplateLexer.g3:300:4: ( '\\\\' ( 'n' | 'r' | 't' | ' ' | 'u' a= HEX b= HEX c= HEX d= HEX ) )
-			// Language\\AngleBracketTemplateLexer.g3:300:4: '\\\\' ( 'n' | 'r' | 't' | ' ' | 'u' a= HEX b= HEX c= HEX d= HEX )
-			{
-			Match('\\'); if (state.failed) return ;
-			// Language\\AngleBracketTemplateLexer.g3:301:3: ( 'n' | 'r' | 't' | ' ' | 'u' a= HEX b= HEX c= HEX d= HEX )
-			int alt40=5;
-			switch ( input.LA(1) )
-			{
-			case 'n':
-				{
-				alt40=1;
-				}
-				break;
-			case 'r':
-				{
-				alt40=2;
-				}
-				break;
-			case 't':
-				{
-				alt40=3;
-				}
-				break;
-			case ' ':
-				{
-				alt40=4;
-				}
-				break;
-			case 'u':
-				{
-				alt40=5;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					NoViableAltException nvae = new NoViableAltException("", 40, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt40 )
-			{
-			case 1:
-				// Language\\AngleBracketTemplateLexer.g3:301:5: 'n'
-				{
-				Match('n'); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-					uc = '\n';
-				}
-
-				}
-				break;
-			case 2:
-				// Language\\AngleBracketTemplateLexer.g3:302:5: 'r'
-				{
-				Match('r'); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-					uc = '\r';
-				}
-
-				}
-				break;
-			case 3:
-				// Language\\AngleBracketTemplateLexer.g3:303:5: 't'
-				{
-				Match('t'); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-					uc = '\t';
-				}
-
-				}
-				break;
-			case 4:
-				// Language\\AngleBracketTemplateLexer.g3:304:5: ' '
-				{
-				Match(' '); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-					uc = ' ';
-				}
-
-				}
-				break;
-			case 5:
-				// Language\\AngleBracketTemplateLexer.g3:305:5: 'u' a= HEX b= HEX c= HEX d= HEX
-				{
-				Match('u'); if (state.failed) return ;
-				int aStart1203 = CharIndex;
-				mHEX(); if (state.failed) return ;
-				a = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, aStart1203, CharIndex-1);
-				int bStart1207 = CharIndex;
-				mHEX(); if (state.failed) return ;
-				b = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, bStart1207, CharIndex-1);
-				int cStart1211 = CharIndex;
-				mHEX(); if (state.failed) return ;
-				c = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, cStart1211, CharIndex-1);
-				int dStart1215 = CharIndex;
-				mHEX(); if (state.failed) return ;
-				d = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, dStart1215, CharIndex-1);
-				if ( state.backtracking == 0 )
-				{
-					 uc = (char)int.Parse((a!=null?a.Text:null)+(b!=null?b.Text:null)+(c!=null?c.Text:null)+(d!=null?d.Text:null), System.Globalization.NumberStyles.AllowHexSpecifier);
-				}
-
-				}
-				break;
-
-			}
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ESC_CHAR"
-
-	// $ANTLR start "ESC"
-	private void mESC()
-	{
-		try
-		{
-			// Language\\AngleBracketTemplateLexer.g3:313:4: ( '\\\\' . )
-			// Language\\AngleBracketTemplateLexer.g3:313:4: '\\\\' .
-			{
-			Match('\\'); if (state.failed) return ;
-			MatchAny(); if (state.failed) return ;
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ESC"
-
-	// $ANTLR start "HEX"
-	private void mHEX()
-	{
-		try
-		{
-			// Language\\AngleBracketTemplateLexer.g3:318:4: ( '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' )
-			// Language\\AngleBracketTemplateLexer.g3:
-			{
-			if ( (input.LA(1)>='0' && input.LA(1)<='9')||(input.LA(1)>='A' && input.LA(1)<='F')||(input.LA(1)>='a' && input.LA(1)<='f') )
-			{
-				input.Consume();
-			state.failed=false;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				MismatchedSetException mse = new MismatchedSetException(null,input);
-				Recover(mse);
-				throw mse;}
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "HEX"
-
-	// $ANTLR start "SUBTEMPLATE"
-	private void mSUBTEMPLATE()
-	{
-		try
-		{
-			// Language\\AngleBracketTemplateLexer.g3:323:4: ( '{' ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )* '}' )
-			// Language\\AngleBracketTemplateLexer.g3:323:4: '{' ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )* '}'
-			{
-			Match('{'); if (state.failed) return ;
-			// Language\\AngleBracketTemplateLexer.g3:324:3: ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )*
-			for ( ; ; )
-			{
-				int alt41=4;
-				int LA41_0 = input.LA(1);
-
-				if ( (LA41_0=='{') )
-				{
-					alt41=1;
-				}
-				else if ( (LA41_0=='\\') )
-				{
-					alt41=2;
-				}
-				else if ( ((LA41_0>='\u0000' && LA41_0<='[')||(LA41_0>=']' && LA41_0<='z')||LA41_0=='|'||(LA41_0>='~' && LA41_0<='\uFFFF')) )
-				{
-					alt41=3;
-				}
-
-
-				switch ( alt41 )
-				{
-				case 1:
-					// Language\\AngleBracketTemplateLexer.g3:324:5: SUBTEMPLATE
-					{
-					mSUBTEMPLATE(); if (state.failed) return ;
-
-					}
-					break;
-				case 2:
-					// Language\\AngleBracketTemplateLexer.g3:325:5: ESC
-					{
-					mESC(); if (state.failed) return ;
-
-					}
-					break;
-				case 3:
-					// Language\\AngleBracketTemplateLexer.g3:326:5: ~ ( '{' | '\\\\' | '}' )
-					{
-					input.Consume();
-					state.failed=false;
-
-					}
-					break;
-
-				default:
-					goto loop41;
-				}
-			}
-
-			loop41:
-				;
-
-
-			Match('}'); if (state.failed) return ;
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "SUBTEMPLATE"
-
-	// $ANTLR start "NESTED_PARENS"
-	private void mNESTED_PARENS()
-	{
-		try
-		{
-			// Language\\AngleBracketTemplateLexer.g3:333:4: ( '(' ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+ ')' )
-			// Language\\AngleBracketTemplateLexer.g3:333:4: '(' ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+ ')'
-			{
-			Match('('); if (state.failed) return ;
-			// Language\\AngleBracketTemplateLexer.g3:334:3: ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+
-			int cnt42=0;
-			for ( ; ; )
-			{
-				int alt42=4;
-				int LA42_0 = input.LA(1);
-
-				if ( (LA42_0=='(') )
-				{
-					alt42=1;
-				}
-				else if ( (LA42_0=='\\') )
-				{
-					alt42=2;
-				}
-				else if ( ((LA42_0>='\u0000' && LA42_0<='\'')||(LA42_0>='*' && LA42_0<='[')||(LA42_0>=']' && LA42_0<='\uFFFF')) )
-				{
-					alt42=3;
-				}
-
-
-				switch ( alt42 )
-				{
-				case 1:
-					// Language\\AngleBracketTemplateLexer.g3:334:5: NESTED_PARENS
-					{
-					mNESTED_PARENS(); if (state.failed) return ;
-
-					}
-					break;
-				case 2:
-					// Language\\AngleBracketTemplateLexer.g3:335:5: ESC
-					{
-					mESC(); if (state.failed) return ;
-
-					}
-					break;
-				case 3:
-					// Language\\AngleBracketTemplateLexer.g3:336:5: ~ ( '(' | '\\\\' | ')' )
-					{
-					input.Consume();
-					state.failed=false;
-
-					}
-					break;
-
-				default:
-					if ( cnt42 >= 1 )
-						goto loop42;
-
-					if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee42 = new EarlyExitException( 42, input );
-					throw eee42;
-				}
-				cnt42++;
-			}
-			loop42:
-				;
-
-
-			Match(')'); if (state.failed) return ;
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "NESTED_PARENS"
-
-	// $ANTLR start "COMMENT"
-	private void mCOMMENT()
-	{
-		try
-		{
-
-			    int startCol = CharPositionInLine;
-
-			// Language\\AngleBracketTemplateLexer.g3:347:4: ( '<!' ( . )* '!>' ({...}? => ( '\\r' )? '\\n' )? )
-			// Language\\AngleBracketTemplateLexer.g3:347:4: '<!' ( . )* '!>' ({...}? => ( '\\r' )? '\\n' )?
-			{
-			Match("<!"); if (state.failed) return ;
-
-			// Language\\AngleBracketTemplateLexer.g3:347:9: ( . )*
-			for ( ; ; )
-			{
-				int alt43=2;
-				int LA43_0 = input.LA(1);
-
-				if ( (LA43_0=='!') )
-				{
-					int LA43_1 = input.LA(2);
-
-					if ( (LA43_1=='>') )
-					{
-						alt43=2;
-					}
-					else if ( ((LA43_1>='\u0000' && LA43_1<='=')||(LA43_1>='?' && LA43_1<='\uFFFF')) )
-					{
-						alt43=1;
-					}
-
-
-				}
-				else if ( ((LA43_0>='\u0000' && LA43_0<=' ')||(LA43_0>='\"' && LA43_0<='\uFFFF')) )
-				{
-					alt43=1;
-				}
-
-
-				switch ( alt43 )
-				{
-				case 1:
-					// Language\\AngleBracketTemplateLexer.g3:347:0: .
-					{
-					MatchAny(); if (state.failed) return ;
-
-					}
-					break;
-
-				default:
-					goto loop43;
-				}
-			}
-
-			loop43:
-				;
-
-
-			Match("!>"); if (state.failed) return ;
-
-			// Language\\AngleBracketTemplateLexer.g3:348:3: ({...}? => ( '\\r' )? '\\n' )?
-			int alt45=2;
-			int LA45_0 = input.LA(1);
-
-			if ( (LA45_0=='\n'||LA45_0=='\r') && ((startCol==0)))
-			{
-				alt45=1;
-			}
-			switch ( alt45 )
-			{
-			case 1:
-				// Language\\AngleBracketTemplateLexer.g3:348:5: {...}? => ( '\\r' )? '\\n'
-				{
-				if ( !((startCol==0)) )
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					throw new FailedPredicateException(input, "COMMENT", "startCol==0");
-				}
-				// Language\\AngleBracketTemplateLexer.g3:348:23: ( '\\r' )?
-				int alt44=2;
-				int LA44_0 = input.LA(1);
-
-				if ( (LA44_0=='\r') )
-				{
-					alt44=1;
-				}
-				switch ( alt44 )
-				{
-				case 1:
-					// Language\\AngleBracketTemplateLexer.g3:348:24: '\\r'
-					{
-					Match('\r'); if (state.failed) return ;
-
-					}
-					break;
-
-				}
-
-				Match('\n'); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "COMMENT"
-
-	// $ANTLR start "LINE_BREAK"
-	private void mLINE_BREAK()
-	{
-		try
-		{
-			// Language\\AngleBracketTemplateLexer.g3:353:4: ( '<\\\\\\\\>' ( INDENT )? ( '\\r' )? '\\n' ( INDENT )? )
-			// Language\\AngleBracketTemplateLexer.g3:353:4: '<\\\\\\\\>' ( INDENT )? ( '\\r' )? '\\n' ( INDENT )?
-			{
-			Match("<\\\\>"); if (state.failed) return ;
-
-			// Language\\AngleBracketTemplateLexer.g3:353:13: ( INDENT )?
-			int alt46=2;
-			int LA46_0 = input.LA(1);
-
-			if ( (LA46_0=='\t'||LA46_0==' ') )
-			{
-				alt46=1;
-			}
-			switch ( alt46 )
-			{
-			case 1:
-				// Language\\AngleBracketTemplateLexer.g3:353:0: INDENT
-				{
-				mINDENT(); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-			// Language\\AngleBracketTemplateLexer.g3:353:21: ( '\\r' )?
-			int alt47=2;
-			int LA47_0 = input.LA(1);
-
-			if ( (LA47_0=='\r') )
-			{
-				alt47=1;
-			}
-			switch ( alt47 )
-			{
-			case 1:
-				// Language\\AngleBracketTemplateLexer.g3:353:0: '\\r'
-				{
-				Match('\r'); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-			Match('\n'); if (state.failed) return ;
-			// Language\\AngleBracketTemplateLexer.g3:353:32: ( INDENT )?
-			int alt48=2;
-			int LA48_0 = input.LA(1);
-
-			if ( (LA48_0=='\t'||LA48_0==' ') )
-			{
-				alt48=1;
-			}
-			switch ( alt48 )
-			{
-			case 1:
-				// Language\\AngleBracketTemplateLexer.g3:353:0: INDENT
-				{
-				mINDENT(); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "LINE_BREAK"
-
-	public override void mTokens()
-	{
-		// Language\\AngleBracketTemplateLexer.g3:1:10: ( NEWLINE | ACTION | LITERAL )
-		int alt49=3;
-		int LA49_0 = input.LA(1);
-
-		if ( (LA49_0=='\n'||LA49_0=='\r') )
-		{
-			alt49=1;
-		}
-		else if ( (LA49_0=='<') )
-		{
-			alt49=2;
-		}
-		else if ( ((LA49_0>='\u0000' && LA49_0<='\t')||(LA49_0>='\u000B' && LA49_0<='\f')||(LA49_0>='\u000E' && LA49_0<=';')||(LA49_0>='=' && LA49_0<='\uFFFF')) )
-		{
-			alt49=3;
-		}
-		else
-		{
-			if (state.backtracking>0) {state.failed=true; return ;}
-			NoViableAltException nvae = new NoViableAltException("", 49, 0, input);
-
-			throw nvae;
-		}
-		switch ( alt49 )
-		{
-		case 1:
-			// Language\\AngleBracketTemplateLexer.g3:1:10: NEWLINE
-			{
-			mNEWLINE(); if (state.failed) return ;
-
-			}
-			break;
-		case 2:
-			// Language\\AngleBracketTemplateLexer.g3:1:18: ACTION
-			{
-			mACTION(); if (state.failed) return ;
-
-			}
-			break;
-		case 3:
-			// Language\\AngleBracketTemplateLexer.g3:1:25: LITERAL
-			{
-			mLITERAL(); if (state.failed) return ;
-
-			}
-			break;
-
-		}
-
-	}
-
-	// $ANTLR start synpred1_AngleBracketTemplateLexer
-	public void synpred1_AngleBracketTemplateLexer_fragment()
-	{
-		// Language\\AngleBracketTemplateLexer.g3:95:4: ( LINE_BREAK )
-		// Language\\AngleBracketTemplateLexer.g3:95:5: LINE_BREAK
-		{
-		mLINE_BREAK(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred1_AngleBracketTemplateLexer
-
-	// $ANTLR start synpred10_AngleBracketTemplateLexer
-	public void synpred10_AngleBracketTemplateLexer_fragment()
-	{
-		// Language\\AngleBracketTemplateLexer.g3:160:8: ( '\\r' | '\\n' )
-		// Language\\AngleBracketTemplateLexer.g3:
-		{
-		if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
-		{
-			input.Consume();
-		state.failed=false;
-		}
-		else
-		{
-			if (state.backtracking>0) {state.failed=true; return ;}
-			MismatchedSetException mse = new MismatchedSetException(null,input);
-			Recover(mse);
-			throw mse;}
-
-
-		}
-	}
-	// $ANTLR end synpred10_AngleBracketTemplateLexer
-
-	// $ANTLR start synpred11_AngleBracketTemplateLexer
-	public void synpred11_AngleBracketTemplateLexer_fragment()
-	{
-		// Language\\AngleBracketTemplateLexer.g3:164:7: ( '\\r' | '\\n' )
-		// Language\\AngleBracketTemplateLexer.g3:
-		{
-		if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
-		{
-			input.Consume();
-		state.failed=false;
-		}
-		else
-		{
-			if (state.backtracking>0) {state.failed=true; return ;}
-			MismatchedSetException mse = new MismatchedSetException(null,input);
-			Recover(mse);
-			throw mse;}
-
-
-		}
-	}
-	// $ANTLR end synpred11_AngleBracketTemplateLexer
-
-	// $ANTLR start synpred12_AngleBracketTemplateLexer
-	public void synpred12_AngleBracketTemplateLexer_fragment()
-	{
-		// Language\\AngleBracketTemplateLexer.g3:273:5: ( '\\r' | '\\n' )
-		// Language\\AngleBracketTemplateLexer.g3:
-		{
-		if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
-		{
-			input.Consume();
-		state.failed=false;
-		}
-		else
-		{
-			if (state.backtracking>0) {state.failed=true; return ;}
-			MismatchedSetException mse = new MismatchedSetException(null,input);
-			Recover(mse);
-			throw mse;}
-
-
-		}
-	}
-	// $ANTLR end synpred12_AngleBracketTemplateLexer
-
-	// $ANTLR start synpred13_AngleBracketTemplateLexer
-	public void synpred13_AngleBracketTemplateLexer_fragment()
-	{
-		// Language\\AngleBracketTemplateLexer.g3:275:4: ( ( '\\r' )? '\\n>>' )
-		// Language\\AngleBracketTemplateLexer.g3:275:5: ( '\\r' )? '\\n>>'
-		{
-		// Language\\AngleBracketTemplateLexer.g3:275:5: ( '\\r' )?
-		int alt50=2;
-		int LA50_0 = input.LA(1);
-
-		if ( (LA50_0=='\r') )
-		{
-			alt50=1;
-		}
-		switch ( alt50 )
-		{
-		case 1:
-			// Language\\AngleBracketTemplateLexer.g3:275:0: '\\r'
-			{
-			Match('\r'); if (state.failed) return ;
-
-			}
-			break;
-
-		}
-
-		Match("\n>>"); if (state.failed) return ;
-
-
-		}
-	}
-	// $ANTLR end synpred13_AngleBracketTemplateLexer
-
-	// $ANTLR start synpred14_AngleBracketTemplateLexer
-	public void synpred14_AngleBracketTemplateLexer_fragment()
-	{
-		// Language\\AngleBracketTemplateLexer.g3:276:5: ( '>' ~ '>' |~ '>' )
-		int alt51=2;
-		int LA51_0 = input.LA(1);
-
-		if ( (LA51_0=='>') )
-		{
-			alt51=1;
-		}
-		else if ( ((LA51_0>='\u0000' && LA51_0<='=')||(LA51_0>='?' && LA51_0<='\uFFFF')) )
-		{
-			alt51=2;
-		}
-		else
-		{
-			if (state.backtracking>0) {state.failed=true; return ;}
-			NoViableAltException nvae = new NoViableAltException("", 51, 0, input);
-
-			throw nvae;
-		}
-		switch ( alt51 )
-		{
-		case 1:
-			// Language\\AngleBracketTemplateLexer.g3:276:6: '>' ~ '>'
-			{
-			Match('>'); if (state.failed) return ;
-			if ( (input.LA(1)>='\u0000' && input.LA(1)<='=')||(input.LA(1)>='?' && input.LA(1)<='\uFFFF') )
-			{
-				input.Consume();
-			state.failed=false;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				MismatchedSetException mse = new MismatchedSetException(null,input);
-				Recover(mse);
-				throw mse;}
-
-
-			}
-			break;
-		case 2:
-			// Language\\AngleBracketTemplateLexer.g3:276:17: ~ '>'
-			{
-			if ( (input.LA(1)>='\u0000' && input.LA(1)<='=')||(input.LA(1)>='?' && input.LA(1)<='\uFFFF') )
-			{
-				input.Consume();
-			state.failed=false;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				MismatchedSetException mse = new MismatchedSetException(null,input);
-				Recover(mse);
-				throw mse;}
-
-
-			}
-			break;
-
-		}}
-	// $ANTLR end synpred14_AngleBracketTemplateLexer
-
-	// $ANTLR start synpred2_AngleBracketTemplateLexer
-	public void synpred2_AngleBracketTemplateLexer_fragment()
-	{
-		// Language\\AngleBracketTemplateLexer.g3:96:4: ( '<\\\\' )
-		// Language\\AngleBracketTemplateLexer.g3:96:5: '<\\\\'
-		{
-		Match("<\\"); if (state.failed) return ;
-
-
-		}
-	}
-	// $ANTLR end synpred2_AngleBracketTemplateLexer
-
-	// $ANTLR start synpred3_AngleBracketTemplateLexer
-	public void synpred3_AngleBracketTemplateLexer_fragment()
-	{
-		// Language\\AngleBracketTemplateLexer.g3:107:4: ( '<!' )
-		// Language\\AngleBracketTemplateLexer.g3:107:5: '<!'
-		{
-		Match("<!"); if (state.failed) return ;
-
-
-		}
-	}
-	// $ANTLR end synpred3_AngleBracketTemplateLexer
-
-	// $ANTLR start synpred4_AngleBracketTemplateLexer
-	public void synpred4_AngleBracketTemplateLexer_fragment()
-	{
-		// Language\\AngleBracketTemplateLexer.g3:109:4: ( '<if' )
-		// Language\\AngleBracketTemplateLexer.g3:109:5: '<if'
-		{
-		Match("<if"); if (state.failed) return ;
-
-
-		}
-	}
-	// $ANTLR end synpred4_AngleBracketTemplateLexer
-
-	// $ANTLR start synpred5_AngleBracketTemplateLexer
-	public void synpred5_AngleBracketTemplateLexer_fragment()
-	{
-		// Language\\AngleBracketTemplateLexer.g3:116:5: ( '<elseif' )
-		// Language\\AngleBracketTemplateLexer.g3:116:6: '<elseif'
-		{
-		Match("<elseif"); if (state.failed) return ;
-
-
-		}
-	}
-	// $ANTLR end synpred5_AngleBracketTemplateLexer
-
-	// $ANTLR start synpred6_AngleBracketTemplateLexer
-	public void synpred6_AngleBracketTemplateLexer_fragment()
-	{
-		// Language\\AngleBracketTemplateLexer.g3:123:5: ( '<else' )
-		// Language\\AngleBracketTemplateLexer.g3:123:6: '<else'
-		{
-		Match("<else"); if (state.failed) return ;
-
-
-		}
-	}
-	// $ANTLR end synpred6_AngleBracketTemplateLexer
-
-	// $ANTLR start synpred7_AngleBracketTemplateLexer
-	public void synpred7_AngleBracketTemplateLexer_fragment()
-	{
-		// Language\\AngleBracketTemplateLexer.g3:130:5: ( '<endif' )
-		// Language\\AngleBracketTemplateLexer.g3:130:6: '<endif'
-		{
-		Match("<endif"); if (state.failed) return ;
-
-
-		}
-	}
-	// $ANTLR end synpred7_AngleBracketTemplateLexer
-
-	// $ANTLR start synpred8_AngleBracketTemplateLexer
-	public void synpred8_AngleBracketTemplateLexer_fragment()
-	{
-		// Language\\AngleBracketTemplateLexer.g3:139:4: ( '<@' )
-		// Language\\AngleBracketTemplateLexer.g3:139:5: '<@'
-		{
-		Match("<@"); if (state.failed) return ;
-
-
-		}
-	}
-	// $ANTLR end synpred8_AngleBracketTemplateLexer
-
-	// $ANTLR start synpred9_AngleBracketTemplateLexer
-	public void synpred9_AngleBracketTemplateLexer_fragment()
-	{
-		// Language\\AngleBracketTemplateLexer.g3:155:7: ( '\\r' | '\\n' )
-		// Language\\AngleBracketTemplateLexer.g3:
-		{
-		if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
-		{
-			input.Consume();
-		state.failed=false;
-		}
-		else
-		{
-			if (state.backtracking>0) {state.failed=true; return ;}
-			MismatchedSetException mse = new MismatchedSetException(null,input);
-			Recover(mse);
-			throw mse;}
-
-
-		}
-	}
-	// $ANTLR end synpred9_AngleBracketTemplateLexer
-
-	#region Synpreds
-	bool EvaluatePredicate( System.Action fragment )
-	{
-		state.backtracking++;
-		int start = input.Mark();
-		try
-		{
-			fragment();
-		}
-		catch ( RecognitionException re )
-		{
-			System.Console.Error.WriteLine("impossible: "+re);
-		}
-		bool success = !state.failed;
-		input.Rewind(start);
-		state.backtracking--;
-		state.failed=false;
-		return success;
-	}
-	#endregion Synpreds
-
-
-	#region DFA
-	DFA18 dfa18;
-	DFA37 dfa37;
-
-	protected override void InitDFAs()
-	{
-		base.InitDFAs();
-		dfa18 = new DFA18( this, new SpecialStateTransitionHandler( specialStateTransition18 ) );
-		dfa37 = new DFA37( this, new SpecialStateTransitionHandler( specialStateTransition37 ) );
-	}
-
-	class DFA18 : DFA
-	{
-
-		const string DFA18_eotS =
-			"\x3\xFFFF\x2\x6\x2\xFFFF\x1\x5\x2\xFFFF\x3\x5\x1\xFFFF";
-		const string DFA18_eofS =
-			"\xE\xFFFF";
-		const string DFA18_minS =
-			"\x5\x0\x2\xFFFF\x1\x65\x2\x0\x1\x6E\x1\x64\x1\x3E\x1\x0";
-		const string DFA18_maxS =
-			"\x1\xFFFF\x2\x0\x2\xFFFF\x2\xFFFF\x1\x65\x2\x0\x1\x6E\x1\x64\x1\x3E\x1"+
-			"\x0";
-		const string DFA18_acceptS =
-			"\x5\xFFFF\x1\x1\x1\x2\x7\xFFFF";
-		const string DFA18_specialS =
-			"\x1\x0\x1\x1\x1\x2\x1\x3\x1\x4\x2\xFFFF\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9"+
-			"\x1\xA\x1\xB}>";
-		static readonly string[] DFA18_transitionS =
-			{
-				"\xA\x4\x1\x2\x2\x4\x1\x1\x2E\x4\x1\x3\xFFC3\x4",
-				"\x1\xFFFF",
-				"\x1\xFFFF",
-				"\xA\x5\x1\x9\x2\x5\x1\x8\x32\x5\x1\x7\xFFBF\x5",
-				"\xA\x5\x1\x9\x2\x5\x1\x8\xFFF2\x5",
-				"",
-				"",
-				"\x1\xA",
-				"\x1\xFFFF",
-				"\x1\xFFFF",
-				"\x1\xB",
-				"\x1\xC",
-				"\x1\xD",
-				"\x1\xFFFF"
-			};
-
-		static readonly short[] DFA18_eot = DFA.UnpackEncodedString(DFA18_eotS);
-		static readonly short[] DFA18_eof = DFA.UnpackEncodedString(DFA18_eofS);
-		static readonly char[] DFA18_min = DFA.UnpackEncodedStringToUnsignedChars(DFA18_minS);
-		static readonly char[] DFA18_max = DFA.UnpackEncodedStringToUnsignedChars(DFA18_maxS);
-		static readonly short[] DFA18_accept = DFA.UnpackEncodedString(DFA18_acceptS);
-		static readonly short[] DFA18_special = DFA.UnpackEncodedString(DFA18_specialS);
-		static readonly short[][] DFA18_transition;
-
-		static DFA18()
-		{
-			int numStates = DFA18_transitionS.Length;
-			DFA18_transition = new short[numStates][];
-			for ( int i=0; i < numStates; i++ )
-			{
-				DFA18_transition[i] = DFA.UnpackEncodedString(DFA18_transitionS[i]);
-			}
-		}
-
-		public DFA18( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
-			: base( specialStateTransition )	{
-			this.recognizer = recognizer;
-			this.decisionNumber = 18;
-			this.eot = DFA18_eot;
-			this.eof = DFA18_eof;
-			this.min = DFA18_min;
-			this.max = DFA18_max;
-			this.accept = DFA18_accept;
-			this.special = DFA18_special;
-			this.transition = DFA18_transition;
-		}
-		public override string GetDescription()
-		{
-			return "()+ loopback of 159:5: ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+";
-		}
-	}
-
-	int specialStateTransition18( DFA dfa, int s, IIntStream _input )
-	{
-		IIntStream input = _input;
-		int _s = s;
-		switch ( s )
-		{
-			case 0:
-				int LA18_0 = input.LA(1);
-
-				s = -1;
-				if ( (LA18_0=='\r') ) {s = 1;}
-
-				else if ( (LA18_0=='\n') ) {s = 2;}
-
-				else if ( (LA18_0=='<') ) {s = 3;}
-
-				else if ( ((LA18_0>='\u0000' && LA18_0<='\t')||(LA18_0>='\u000B' && LA18_0<='\f')||(LA18_0>='\u000E' && LA18_0<=';')||(LA18_0>='=' && LA18_0<='\uFFFF')) ) {s = 4;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 1:
-				int LA18_1 = input.LA(1);
-
-
-				int index18_1 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( ((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))) ) {s = 5;}
-
-				else if ( (true) ) {s = 6;}
-
-
-				input.Seek(index18_1);
-				if ( s>=0 ) return s;
-				break;
-			case 2:
-				int LA18_2 = input.LA(1);
-
-
-				int index18_2 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( ((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))) ) {s = 5;}
-
-				else if ( (true) ) {s = 6;}
-
-
-				input.Seek(index18_2);
-				if ( s>=0 ) return s;
-				break;
-			case 3:
-				int LA18_3 = input.LA(1);
-
-
-				int index18_3 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (LA18_3=='@') ) {s = 7;}
-
-				else if ( (LA18_3=='\r') ) {s = 8;}
-
-				else if ( (LA18_3=='\n') ) {s = 9;}
-
-				else if ( ((LA18_3>='\u0000' && LA18_3<='\t')||(LA18_3>='\u000B' && LA18_3<='\f')||(LA18_3>='\u000E' && LA18_3<='?')||(LA18_3>='A' && LA18_3<='\uFFFF')) && ((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) ))))) {s = 5;}
-
-				else s = 6;
-
-
-				input.Seek(index18_3);
-				if ( s>=0 ) return s;
-				break;
-			case 4:
-				int LA18_4 = input.LA(1);
-
-
-				int index18_4 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (LA18_4=='\r') ) {s = 8;}
-
-				else if ( (LA18_4=='\n') ) {s = 9;}
-
-				else if ( ((LA18_4>='\u0000' && LA18_4<='\t')||(LA18_4>='\u000B' && LA18_4<='\f')||(LA18_4>='\u000E' && LA18_4<='\uFFFF')) && ((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) ))))) {s = 5;}
-
-				else s = 6;
-
-
-				input.Seek(index18_4);
-				if ( s>=0 ) return s;
-				break;
-			case 5:
-				int LA18_7 = input.LA(1);
-
-
-				int index18_7 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (LA18_7=='e') ) {s = 10;}
-
-				else s = 5;
-
-
-				input.Seek(index18_7);
-				if ( s>=0 ) return s;
-				break;
-			case 6:
-				int LA18_8 = input.LA(1);
-
-
-				int index18_8 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( ((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))) ) {s = 5;}
-
-				else if ( (true) ) {s = 6;}
-
-
-				input.Seek(index18_8);
-				if ( s>=0 ) return s;
-				break;
-			case 7:
-				int LA18_9 = input.LA(1);
-
-
-				int index18_9 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( ((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))) ) {s = 5;}
-
-				else if ( (true) ) {s = 6;}
-
-
-				input.Seek(index18_9);
-				if ( s>=0 ) return s;
-				break;
-			case 8:
-				int LA18_10 = input.LA(1);
-
-
-				int index18_10 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (LA18_10=='n') ) {s = 11;}
-
-				else s = 5;
-
-
-				input.Seek(index18_10);
-				if ( s>=0 ) return s;
-				break;
-			case 9:
-				int LA18_11 = input.LA(1);
-
-
-				int index18_11 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (LA18_11=='d') ) {s = 12;}
-
-				else s = 5;
-
-
-				input.Seek(index18_11);
-				if ( s>=0 ) return s;
-				break;
-			case 10:
-				int LA18_12 = input.LA(1);
-
-
-				int index18_12 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (LA18_12=='>') ) {s = 13;}
-
-				else s = 5;
-
-
-				input.Seek(index18_12);
-				if ( s>=0 ) return s;
-				break;
-			case 11:
-				int LA18_13 = input.LA(1);
-
-
-				int index18_13 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( ((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))) ) {s = 5;}
-
-				else if ( (true) ) {s = 6;}
-
-
-				input.Seek(index18_13);
-				if ( s>=0 ) return s;
-				break;
-		}
-		if (state.backtracking>0) {state.failed=true; return -1;}
-		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 18, _s, input);
-		dfa.Error(nvae);
-		throw nvae;
-	}
-	class DFA37 : DFA
-	{
-
-		const string DFA37_eotS =
-			"\x13\xFFFF";
-		const string DFA37_eofS =
-			"\x13\xFFFF";
-		const string DFA37_minS =
-			"\x4\x0\x1\xFFFF\x1\x0\xD\xFFFF";
-		const string DFA37_maxS =
-			"\x2\xFFFF\x2\x0\x1\xFFFF\x1\x0\xD\xFFFF";
-		const string DFA37_acceptS =
-			"\x4\xFFFF\x1\x2\x1\xFFFF\x3\x2\x4\xFFFF\x1\x1\x4\xFFFF\x1\x3";
-		const string DFA37_specialS =
-			"\x1\x0\x1\x1\x1\x2\x1\x3\x1\xFFFF\x1\x4\xD\xFFFF}>";
-		static readonly string[] DFA37_transitionS =
-			{
-				"\xA\x4\x1\x3\x2\x4\x1\x2\x30\x4\x1\x1\xFFC1\x4",
-				"\xA\x8\x1\x7\x2\x8\x1\x6\x30\x8\x1\x5\xFFC1\x8",
-				"\x1\xFFFF",
-				"\x1\xFFFF",
-				"",
-				"\x1\xFFFF",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				""
-			};
-
-		static readonly short[] DFA37_eot = DFA.UnpackEncodedString(DFA37_eotS);
-		static readonly short[] DFA37_eof = DFA.UnpackEncodedString(DFA37_eofS);
-		static readonly char[] DFA37_min = DFA.UnpackEncodedStringToUnsignedChars(DFA37_minS);
-		static readonly char[] DFA37_max = DFA.UnpackEncodedStringToUnsignedChars(DFA37_maxS);
-		static readonly short[] DFA37_accept = DFA.UnpackEncodedString(DFA37_acceptS);
-		static readonly short[] DFA37_special = DFA.UnpackEncodedString(DFA37_specialS);
-		static readonly short[][] DFA37_transition;
-
-		static DFA37()
-		{
-			int numStates = DFA37_transitionS.Length;
-			DFA37_transition = new short[numStates][];
-			for ( int i=0; i < numStates; i++ )
-			{
-				DFA37_transition[i] = DFA.UnpackEncodedString(DFA37_transitionS[i]);
-			}
-		}
-
-		public DFA37( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
-			: base( specialStateTransition )	{
-			this.recognizer = recognizer;
-			this.decisionNumber = 37;
-			this.eot = DFA37_eot;
-			this.eof = DFA37_eof;
-			this.min = DFA37_min;
-			this.max = DFA37_max;
-			this.accept = DFA37_accept;
-			this.special = DFA37_special;
-			this.transition = DFA37_transition;
-		}
-		public override string GetDescription()
-		{
-			return "()* loopback of 274:3: ( options {k=2; } :=> ( '\\r' )? '\\n' |=>ch= . )*";
-		}
-	}
-
-	int specialStateTransition37( DFA dfa, int s, IIntStream _input )
-	{
-		IIntStream input = _input;
-		int _s = s;
-		switch ( s )
-		{
-			case 0:
-				int LA37_0 = input.LA(1);
-
-
-				int index37_0 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (LA37_0=='>') ) {s = 1;}
-
-				else if ( (LA37_0=='\r') ) {s = 2;}
-
-				else if ( (LA37_0=='\n') ) {s = 3;}
-
-				else if ( ((LA37_0>='\u0000' && LA37_0<='\t')||(LA37_0>='\u000B' && LA37_0<='\f')||(LA37_0>='\u000E' && LA37_0<='=')||(LA37_0>='?' && LA37_0<='\uFFFF')) && (EvaluatePredicate(synpred14_AngleBracketTemplateLexer_fragment))) {s = 4;}
-
-
-				input.Seek(index37_0);
-				if ( s>=0 ) return s;
-				break;
-			case 1:
-				int LA37_1 = input.LA(1);
-
-
-				int index37_1 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (LA37_1=='>') ) {s = 5;}
-
-				else if ( (LA37_1=='\r') && (EvaluatePredicate(synpred14_AngleBracketTemplateLexer_fragment))) {s = 6;}
-
-				else if ( (LA37_1=='\n') && (EvaluatePredicate(synpred14_AngleBracketTemplateLexer_fragment))) {s = 7;}
-
-				else if ( ((LA37_1>='\u0000' && LA37_1<='\t')||(LA37_1>='\u000B' && LA37_1<='\f')||(LA37_1>='\u000E' && LA37_1<='=')||(LA37_1>='?' && LA37_1<='\uFFFF')) && (EvaluatePredicate(synpred14_AngleBracketTemplateLexer_fragment))) {s = 8;}
-
-
-				input.Seek(index37_1);
-				if ( s>=0 ) return s;
-				break;
-			case 2:
-				int LA37_2 = input.LA(1);
-
-
-				int index37_2 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (EvaluatePredicate(synpred13_AngleBracketTemplateLexer_fragment)) ) {s = 13;}
-
-				else if ( (EvaluatePredicate(synpred14_AngleBracketTemplateLexer_fragment)) ) {s = 8;}
-
-
-				input.Seek(index37_2);
-				if ( s>=0 ) return s;
-				break;
-			case 3:
-				int LA37_3 = input.LA(1);
-
-
-				int index37_3 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (EvaluatePredicate(synpred13_AngleBracketTemplateLexer_fragment)) ) {s = 13;}
-
-				else if ( (EvaluatePredicate(synpred14_AngleBracketTemplateLexer_fragment)) ) {s = 8;}
-
-
-				input.Seek(index37_3);
-				if ( s>=0 ) return s;
-				break;
-			case 4:
-				int LA37_5 = input.LA(1);
-
-
-				int index37_5 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (EvaluatePredicate(synpred14_AngleBracketTemplateLexer_fragment)) ) {s = 8;}
-
-				else if ( (true) ) {s = 18;}
-
-
-				input.Seek(index37_5);
-				if ( s>=0 ) return s;
-				break;
-		}
-		if (state.backtracking>0) {state.failed=true; return -1;}
-		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 37, _s, input);
-		dfa.Error(nvae);
-		throw nvae;
-	}
-
-	#endregion
-
-}
-
-} // namespace Antlr3.ST.Language
diff --git a/Antlr3.StringTemplate/Language/GroupLexer.cs b/Antlr3.StringTemplate/Language/GroupLexer.cs
deleted file mode 100644
index b52850f..0000000
--- a/Antlr3.StringTemplate/Language/GroupLexer.cs
+++ /dev/null
@@ -1,1480 +0,0 @@
-// $ANTLR 3.1.2 Language\\Group.g3 2009-04-18 13:37:02
-
-// The variable 'variable' is assigned but its value is never used.
-#pragma warning disable 219
-// Unreachable code detected.
-#pragma warning disable 162
-
-
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Grammar conversion to ANTLR v3 and C#:
- Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-	notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-	derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-
-using System.Collections.Generic;
-using Antlr.Runtime;
-using Stack = System.Collections.Generic.Stack<object>;
-using List = System.Collections.IList;
-using ArrayList = System.Collections.Generic.List<object>;
-
-namespace Antlr3.ST.Language
-{
-[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.1.2")]
-[System.CLSCompliant(false)]
-public partial class GroupLexer : Lexer
-{
-	public const int EOF=-1;
-	public const int ANONYMOUS_TEMPLATE=4;
-	public const int ASSIGN=5;
-	public const int AT=6;
-	public const int BIGSTRING=7;
-	public const int COLON=8;
-	public const int COMMA=9;
-	public const int DEFINED_TO_BE=10;
-	public const int DOT=11;
-	public const int ID=12;
-	public const int KWDEFAULT=13;
-	public const int KWGROUP=14;
-	public const int KWIMPLEMENTS=15;
-	public const int LBRACK=16;
-	public const int LPAREN=17;
-	public const int ML_COMMENT=18;
-	public const int OPTIONAL=19;
-	public const int PLUS=20;
-	public const int RBRACK=21;
-	public const int RPAREN=22;
-	public const int SEMI=23;
-	public const int SL_COMMENT=24;
-	public const int STAR=25;
-	public const int STRING=26;
-	public const int WS=27;
-
-    // delegates
-    // delegators
-
-	public GroupLexer() {}
-	public GroupLexer( ICharStream input )
-		: this( input, new RecognizerSharedState() )
-	{
-	}
-	public GroupLexer( ICharStream input, RecognizerSharedState state )
-		: base( input, state )
-	{
-
-	}
-	public override string GrammarFileName { get { return "Language\\Group.g3"; } }
-
-	// $ANTLR start "KWDEFAULT"
-	private void mKWDEFAULT()
-	{
-		try
-		{
-			int _type = KWDEFAULT;
-			int _channel = DefaultTokenChannel;
-			// Language\\Group.g3:42:13: ( 'default' )
-			// Language\\Group.g3:42:13: 'default'
-			{
-			Match("default");
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "KWDEFAULT"
-
-	// $ANTLR start "KWGROUP"
-	private void mKWGROUP()
-	{
-		try
-		{
-			int _type = KWGROUP;
-			int _channel = DefaultTokenChannel;
-			// Language\\Group.g3:43:11: ( 'group' )
-			// Language\\Group.g3:43:11: 'group'
-			{
-			Match("group");
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "KWGROUP"
-
-	// $ANTLR start "KWIMPLEMENTS"
-	private void mKWIMPLEMENTS()
-	{
-		try
-		{
-			int _type = KWIMPLEMENTS;
-			int _channel = DefaultTokenChannel;
-			// Language\\Group.g3:44:16: ( 'implements' )
-			// Language\\Group.g3:44:16: 'implements'
-			{
-			Match("implements");
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "KWIMPLEMENTS"
-
-	// $ANTLR start "ID"
-	private void mID()
-	{
-		try
-		{
-			int _type = ID;
-			int _channel = DefaultTokenChannel;
-			// Language\\Group.g3:290:4: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '-' | '_' )* )
-			// Language\\Group.g3:290:4: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '-' | '_' )*
-			{
-			if ( (input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z') )
-			{
-				input.Consume();
-
-			}
-			else
-			{
-				MismatchedSetException mse = new MismatchedSetException(null,input);
-				Recover(mse);
-				throw mse;}
-
-			// Language\\Group.g3:290:28: ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '-' | '_' )*
-			for ( ; ; )
-			{
-				int alt1=2;
-				int LA1_0 = input.LA(1);
-
-				if ( (LA1_0=='-'||(LA1_0>='0' && LA1_0<='9')||(LA1_0>='A' && LA1_0<='Z')||LA1_0=='_'||(LA1_0>='a' && LA1_0<='z')) )
-				{
-					alt1=1;
-				}
-
-
-				switch ( alt1 )
-				{
-				case 1:
-					// Language\\Group.g3:
-					{
-					input.Consume();
-
-
-					}
-					break;
-
-				default:
-					goto loop1;
-				}
-			}
-
-			loop1:
-				;
-
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ID"
-
-	// $ANTLR start "STRING"
-	private void mSTRING()
-	{
-		try
-		{
-			int _type = STRING;
-			int _channel = DefaultTokenChannel;
-			int ch;
-
-
-				System.Text.StringBuilder builder = new System.Text.StringBuilder();
-
-			// Language\\Group.g3:298:4: ( '\"' ( '\\\\' ( '\"' |ch=~ '\"' ) |ch=~ ( '\\\\' | '\"' ) )* '\"' )
-			// Language\\Group.g3:298:4: '\"' ( '\\\\' ( '\"' |ch=~ '\"' ) |ch=~ ( '\\\\' | '\"' ) )* '\"'
-			{
-			Match('\"');
-			// Language\\Group.g3:299:3: ( '\\\\' ( '\"' |ch=~ '\"' ) |ch=~ ( '\\\\' | '\"' ) )*
-			for ( ; ; )
-			{
-				int alt3=3;
-				int LA3_0 = input.LA(1);
-
-				if ( (LA3_0=='\\') )
-				{
-					alt3=1;
-				}
-				else if ( ((LA3_0>='\u0000' && LA3_0<='!')||(LA3_0>='#' && LA3_0<='[')||(LA3_0>=']' && LA3_0<='\uFFFF')) )
-				{
-					alt3=2;
-				}
-
-
-				switch ( alt3 )
-				{
-				case 1:
-					// Language\\Group.g3:299:5: '\\\\' ( '\"' |ch=~ '\"' )
-					{
-					Match('\\');
-					// Language\\Group.g3:300:4: ( '\"' |ch=~ '\"' )
-					int alt2=2;
-					int LA2_0 = input.LA(1);
-
-					if ( (LA2_0=='\"') )
-					{
-						alt2=1;
-					}
-					else if ( ((LA2_0>='\u0000' && LA2_0<='!')||(LA2_0>='#' && LA2_0<='\uFFFF')) )
-					{
-						alt2=2;
-					}
-					else
-					{
-						NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
-
-						throw nvae;
-					}
-					switch ( alt2 )
-					{
-					case 1:
-						// Language\\Group.g3:300:6: '\"'
-						{
-						Match('\"');
-						builder.Append('"');
-
-						}
-						break;
-					case 2:
-						// Language\\Group.g3:301:6: ch=~ '\"'
-						{
-						ch= input.LA(1);
-						input.Consume();
-
-						builder.Append("\\" + (char)ch);
-
-						}
-						break;
-
-					}
-
-
-					}
-					break;
-				case 2:
-					// Language\\Group.g3:303:5: ch=~ ( '\\\\' | '\"' )
-					{
-					ch= input.LA(1);
-					input.Consume();
-
-					builder.Append((char)ch);
-
-					}
-					break;
-
-				default:
-					goto loop3;
-				}
-			}
-
-			loop3:
-				;
-
-
-			Match('\"');
-
-						Text = builder.ToString();
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "STRING"
-
-	// $ANTLR start "BIGSTRING"
-	private void mBIGSTRING()
-	{
-		try
-		{
-			int _type = BIGSTRING;
-			int _channel = DefaultTokenChannel;
-			// Language\\Group.g3:312:4: ( '<<' ( '\\\\>' | '\\\\' ~ '>' | '>' ~ '>' |~ ( '\\\\' | '>' ) )* '>>' )
-			// Language\\Group.g3:312:4: '<<' ( '\\\\>' | '\\\\' ~ '>' | '>' ~ '>' |~ ( '\\\\' | '>' ) )* '>>'
-			{
-			Match("<<");
-
-			// Language\\Group.g3:312:9: ( '\\\\>' | '\\\\' ~ '>' | '>' ~ '>' |~ ( '\\\\' | '>' ) )*
-			for ( ; ; )
-			{
-				int alt4=5;
-				int LA4_0 = input.LA(1);
-
-				if ( (LA4_0=='>') )
-				{
-					int LA4_1 = input.LA(2);
-
-					if ( ((LA4_1>='\u0000' && LA4_1<='=')||(LA4_1>='?' && LA4_1<='\uFFFF')) )
-					{
-						alt4=3;
-					}
-
-
-				}
-				else if ( (LA4_0=='\\') )
-				{
-					int LA4_2 = input.LA(2);
-
-					if ( (LA4_2=='>') )
-					{
-						alt4=1;
-					}
-					else if ( ((LA4_2>='\u0000' && LA4_2<='=')||(LA4_2>='?' && LA4_2<='\uFFFF')) )
-					{
-						alt4=2;
-					}
-
-
-				}
-				else if ( ((LA4_0>='\u0000' && LA4_0<='=')||(LA4_0>='?' && LA4_0<='[')||(LA4_0>=']' && LA4_0<='\uFFFF')) )
-				{
-					alt4=4;
-				}
-
-
-				switch ( alt4 )
-				{
-				case 1:
-					// Language\\Group.g3:312:10: '\\\\>'
-					{
-					Match("\\>");
-
-
-					}
-					break;
-				case 2:
-					// Language\\Group.g3:312:18: '\\\\' ~ '>'
-					{
-					Match('\\');
-					input.Consume();
-
-
-					}
-					break;
-				case 3:
-					// Language\\Group.g3:312:30: '>' ~ '>'
-					{
-					Match('>');
-					input.Consume();
-
-
-					}
-					break;
-				case 4:
-					// Language\\Group.g3:312:41: ~ ( '\\\\' | '>' )
-					{
-					input.Consume();
-
-
-					}
-					break;
-
-				default:
-					goto loop4;
-				}
-			}
-
-			loop4:
-				;
-
-
-			Match(">>");
-
-
-						System.Text.StringBuilder builder = new System.Text.StringBuilder( input.substring( state.tokenStartCharIndex + 2, CharIndex - 3 ) );
-						Text = ProcessBigString( builder );
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "BIGSTRING"
-
-	// $ANTLR start "ANONYMOUS_TEMPLATE"
-	private void mANONYMOUS_TEMPLATE()
-	{
-		try
-		{
-			int _type = ANONYMOUS_TEMPLATE;
-			int _channel = DefaultTokenChannel;
-			// Language\\Group.g3:320:4: ( '{' ( '\\\\}' | '\\\\' ~ '}' |~ ( '\\\\' | '}' ) )* '}' )
-			// Language\\Group.g3:320:4: '{' ( '\\\\}' | '\\\\' ~ '}' |~ ( '\\\\' | '}' ) )* '}'
-			{
-			Match('{');
-			// Language\\Group.g3:321:3: ( '\\\\}' | '\\\\' ~ '}' |~ ( '\\\\' | '}' ) )*
-			for ( ; ; )
-			{
-				int alt5=4;
-				int LA5_0 = input.LA(1);
-
-				if ( (LA5_0=='\\') )
-				{
-					int LA5_2 = input.LA(2);
-
-					if ( (LA5_2=='}') )
-					{
-						alt5=1;
-					}
-					else if ( ((LA5_2>='\u0000' && LA5_2<='|')||(LA5_2>='~' && LA5_2<='\uFFFF')) )
-					{
-						alt5=2;
-					}
-
-
-				}
-				else if ( ((LA5_0>='\u0000' && LA5_0<='[')||(LA5_0>=']' && LA5_0<='|')||(LA5_0>='~' && LA5_0<='\uFFFF')) )
-				{
-					alt5=3;
-				}
-
-
-				switch ( alt5 )
-				{
-				case 1:
-					// Language\\Group.g3:321:5: '\\\\}'
-					{
-					Match("\\}");
-
-
-					}
-					break;
-				case 2:
-					// Language\\Group.g3:322:5: '\\\\' ~ '}'
-					{
-					Match('\\');
-					input.Consume();
-
-
-					}
-					break;
-				case 3:
-					// Language\\Group.g3:323:5: ~ ( '\\\\' | '}' )
-					{
-					input.Consume();
-
-
-					}
-					break;
-
-				default:
-					goto loop5;
-				}
-			}
-
-			loop5:
-				;
-
-
-			Match('}');
-
-						System.Text.StringBuilder builder = new System.Text.StringBuilder( input.substring( state.tokenStartCharIndex + 1, CharIndex - 2 ) );
-						Text = ProcessAnonymousTemplate( builder );
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ANONYMOUS_TEMPLATE"
-
-	// $ANTLR start "AT"
-	private void mAT()
-	{
-		try
-		{
-			int _type = AT;
-			int _channel = DefaultTokenChannel;
-			// Language\\Group.g3:332:6: ( '@' )
-			// Language\\Group.g3:332:6: '@'
-			{
-			Match('@');
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "AT"
-
-	// $ANTLR start "LPAREN"
-	private void mLPAREN()
-	{
-		try
-		{
-			int _type = LPAREN;
-			int _channel = DefaultTokenChannel;
-			// Language\\Group.g3:333:9: ( '(' )
-			// Language\\Group.g3:333:9: '('
-			{
-			Match('(');
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "LPAREN"
-
-	// $ANTLR start "RPAREN"
-	private void mRPAREN()
-	{
-		try
-		{
-			int _type = RPAREN;
-			int _channel = DefaultTokenChannel;
-			// Language\\Group.g3:334:9: ( ')' )
-			// Language\\Group.g3:334:9: ')'
-			{
-			Match(')');
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "RPAREN"
-
-	// $ANTLR start "LBRACK"
-	private void mLBRACK()
-	{
-		try
-		{
-			int _type = LBRACK;
-			int _channel = DefaultTokenChannel;
-			// Language\\Group.g3:335:9: ( '[' )
-			// Language\\Group.g3:335:9: '['
-			{
-			Match('[');
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "LBRACK"
-
-	// $ANTLR start "RBRACK"
-	private void mRBRACK()
-	{
-		try
-		{
-			int _type = RBRACK;
-			int _channel = DefaultTokenChannel;
-			// Language\\Group.g3:336:9: ( ']' )
-			// Language\\Group.g3:336:9: ']'
-			{
-			Match(']');
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "RBRACK"
-
-	// $ANTLR start "COMMA"
-	private void mCOMMA()
-	{
-		try
-		{
-			int _type = COMMA;
-			int _channel = DefaultTokenChannel;
-			// Language\\Group.g3:337:9: ( ',' )
-			// Language\\Group.g3:337:9: ','
-			{
-			Match(',');
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "COMMA"
-
-	// $ANTLR start "DOT"
-	private void mDOT()
-	{
-		try
-		{
-			int _type = DOT;
-			int _channel = DefaultTokenChannel;
-			// Language\\Group.g3:338:7: ( '.' )
-			// Language\\Group.g3:338:7: '.'
-			{
-			Match('.');
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "DOT"
-
-	// $ANTLR start "DEFINED_TO_BE"
-	private void mDEFINED_TO_BE()
-	{
-		try
-		{
-			int _type = DEFINED_TO_BE;
-			int _channel = DefaultTokenChannel;
-			// Language\\Group.g3:339:17: ( '::=' )
-			// Language\\Group.g3:339:17: '::='
-			{
-			Match("::=");
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "DEFINED_TO_BE"
-
-	// $ANTLR start "SEMI"
-	private void mSEMI()
-	{
-		try
-		{
-			int _type = SEMI;
-			int _channel = DefaultTokenChannel;
-			// Language\\Group.g3:340:9: ( ';' )
-			// Language\\Group.g3:340:9: ';'
-			{
-			Match(';');
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "SEMI"
-
-	// $ANTLR start "COLON"
-	private void mCOLON()
-	{
-		try
-		{
-			int _type = COLON;
-			int _channel = DefaultTokenChannel;
-			// Language\\Group.g3:341:9: ( ':' )
-			// Language\\Group.g3:341:9: ':'
-			{
-			Match(':');
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "COLON"
-
-	// $ANTLR start "STAR"
-	private void mSTAR()
-	{
-		try
-		{
-			int _type = STAR;
-			int _channel = DefaultTokenChannel;
-			// Language\\Group.g3:342:9: ( '*' )
-			// Language\\Group.g3:342:9: '*'
-			{
-			Match('*');
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "STAR"
-
-	// $ANTLR start "PLUS"
-	private void mPLUS()
-	{
-		try
-		{
-			int _type = PLUS;
-			int _channel = DefaultTokenChannel;
-			// Language\\Group.g3:343:9: ( '+' )
-			// Language\\Group.g3:343:9: '+'
-			{
-			Match('+');
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "PLUS"
-
-	// $ANTLR start "ASSIGN"
-	private void mASSIGN()
-	{
-		try
-		{
-			int _type = ASSIGN;
-			int _channel = DefaultTokenChannel;
-			// Language\\Group.g3:344:11: ( '=' )
-			// Language\\Group.g3:344:11: '='
-			{
-			Match('=');
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ASSIGN"
-
-	// $ANTLR start "OPTIONAL"
-	private void mOPTIONAL()
-	{
-		try
-		{
-			int _type = OPTIONAL;
-			int _channel = DefaultTokenChannel;
-			// Language\\Group.g3:345:12: ( '?' )
-			// Language\\Group.g3:345:12: '?'
-			{
-			Match('?');
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "OPTIONAL"
-
-	// $ANTLR start "SL_COMMENT"
-	private void mSL_COMMENT()
-	{
-		try
-		{
-			int _type = SL_COMMENT;
-			int _channel = DefaultTokenChannel;
-			// Language\\Group.g3:349:4: ( '//' (~ ( '\\n' | '\\r' ) )* ( ( '\\r' )? '\\n' )? )
-			// Language\\Group.g3:349:4: '//' (~ ( '\\n' | '\\r' ) )* ( ( '\\r' )? '\\n' )?
-			{
-			Match("//");
-
-			// Language\\Group.g3:350:3: (~ ( '\\n' | '\\r' ) )*
-			for ( ; ; )
-			{
-				int alt6=2;
-				int LA6_0 = input.LA(1);
-
-				if ( ((LA6_0>='\u0000' && LA6_0<='\t')||(LA6_0>='\u000B' && LA6_0<='\f')||(LA6_0>='\u000E' && LA6_0<='\uFFFF')) )
-				{
-					alt6=1;
-				}
-
-
-				switch ( alt6 )
-				{
-				case 1:
-					// Language\\Group.g3:
-					{
-					input.Consume();
-
-
-					}
-					break;
-
-				default:
-					goto loop6;
-				}
-			}
-
-			loop6:
-				;
-
-
-			// Language\\Group.g3:350:19: ( ( '\\r' )? '\\n' )?
-			int alt8=2;
-			int LA8_0 = input.LA(1);
-
-			if ( (LA8_0=='\n'||LA8_0=='\r') )
-			{
-				alt8=1;
-			}
-			switch ( alt8 )
-			{
-			case 1:
-				// Language\\Group.g3:350:20: ( '\\r' )? '\\n'
-				{
-				// Language\\Group.g3:350:20: ( '\\r' )?
-				int alt7=2;
-				int LA7_0 = input.LA(1);
-
-				if ( (LA7_0=='\r') )
-				{
-					alt7=1;
-				}
-				switch ( alt7 )
-				{
-				case 1:
-					// Language\\Group.g3:350:21: '\\r'
-					{
-					Match('\r');
-
-					}
-					break;
-
-				}
-
-				Match('\n');
-
-				}
-				break;
-
-			}
-
-			 _channel = Hidden;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "SL_COMMENT"
-
-	// $ANTLR start "ML_COMMENT"
-	private void mML_COMMENT()
-	{
-		try
-		{
-			int _type = ML_COMMENT;
-			int _channel = DefaultTokenChannel;
-			// Language\\Group.g3:356:4: ( '/*' ( . )* '*/' )
-			// Language\\Group.g3:356:4: '/*' ( . )* '*/'
-			{
-			Match("/*");
-
-			// Language\\Group.g3:356:9: ( . )*
-			for ( ; ; )
-			{
-				int alt9=2;
-				int LA9_0 = input.LA(1);
-
-				if ( (LA9_0=='*') )
-				{
-					int LA9_1 = input.LA(2);
-
-					if ( (LA9_1=='/') )
-					{
-						alt9=2;
-					}
-					else if ( ((LA9_1>='\u0000' && LA9_1<='.')||(LA9_1>='0' && LA9_1<='\uFFFF')) )
-					{
-						alt9=1;
-					}
-
-
-				}
-				else if ( ((LA9_0>='\u0000' && LA9_0<=')')||(LA9_0>='+' && LA9_0<='\uFFFF')) )
-				{
-					alt9=1;
-				}
-
-
-				switch ( alt9 )
-				{
-				case 1:
-					// Language\\Group.g3:356:0: .
-					{
-					MatchAny();
-
-					}
-					break;
-
-				default:
-					goto loop9;
-				}
-			}
-
-			loop9:
-				;
-
-
-			Match("*/");
-
-			 _channel = Hidden;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ML_COMMENT"
-
-	// $ANTLR start "WS"
-	private void mWS()
-	{
-		try
-		{
-			int _type = WS;
-			int _channel = DefaultTokenChannel;
-			// Language\\Group.g3:361:9: ( ( ' ' | '\\t' | '\\f' | ( '\\r' )? '\\n' )+ )
-			// Language\\Group.g3:361:9: ( ' ' | '\\t' | '\\f' | ( '\\r' )? '\\n' )+
-			{
-			// Language\\Group.g3:361:9: ( ' ' | '\\t' | '\\f' | ( '\\r' )? '\\n' )+
-			int cnt11=0;
-			for ( ; ; )
-			{
-				int alt11=5;
-				switch ( input.LA(1) )
-				{
-				case ' ':
-					{
-					alt11=1;
-					}
-					break;
-				case '\t':
-					{
-					alt11=2;
-					}
-					break;
-				case '\f':
-					{
-					alt11=3;
-					}
-					break;
-				case '\n':
-				case '\r':
-					{
-					alt11=4;
-					}
-					break;
-
-				}
-
-				switch ( alt11 )
-				{
-				case 1:
-					// Language\\Group.g3:361:13: ' '
-					{
-					Match(' ');
-
-					}
-					break;
-				case 2:
-					// Language\\Group.g3:362:13: '\\t'
-					{
-					Match('\t');
-
-					}
-					break;
-				case 3:
-					// Language\\Group.g3:363:13: '\\f'
-					{
-					Match('\f');
-
-					}
-					break;
-				case 4:
-					// Language\\Group.g3:364:13: ( '\\r' )? '\\n'
-					{
-					// Language\\Group.g3:364:13: ( '\\r' )?
-					int alt10=2;
-					int LA10_0 = input.LA(1);
-
-					if ( (LA10_0=='\r') )
-					{
-						alt10=1;
-					}
-					switch ( alt10 )
-					{
-					case 1:
-						// Language\\Group.g3:364:14: '\\r'
-						{
-						Match('\r');
-
-						}
-						break;
-
-					}
-
-					Match('\n');
-
-					}
-					break;
-
-				default:
-					if ( cnt11 >= 1 )
-						goto loop11;
-
-					EarlyExitException eee11 = new EarlyExitException( 11, input );
-					throw eee11;
-				}
-				cnt11++;
-			}
-			loop11:
-				;
-
-
-			 _channel = Hidden;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "WS"
-
-	public override void mTokens()
-	{
-		// Language\\Group.g3:1:10: ( KWDEFAULT | KWGROUP | KWIMPLEMENTS | ID | STRING | BIGSTRING | ANONYMOUS_TEMPLATE | AT | LPAREN | RPAREN | LBRACK | RBRACK | COMMA | DOT | DEFINED_TO_BE | SEMI | COLON | STAR | PLUS | ASSIGN | OPTIONAL | SL_COMMENT | ML_COMMENT | WS )
-		int alt12=24;
-		alt12 = dfa12.Predict(input);
-		switch ( alt12 )
-		{
-		case 1:
-			// Language\\Group.g3:1:10: KWDEFAULT
-			{
-			mKWDEFAULT();
-
-			}
-			break;
-		case 2:
-			// Language\\Group.g3:1:20: KWGROUP
-			{
-			mKWGROUP();
-
-			}
-			break;
-		case 3:
-			// Language\\Group.g3:1:28: KWIMPLEMENTS
-			{
-			mKWIMPLEMENTS();
-
-			}
-			break;
-		case 4:
-			// Language\\Group.g3:1:41: ID
-			{
-			mID();
-
-			}
-			break;
-		case 5:
-			// Language\\Group.g3:1:44: STRING
-			{
-			mSTRING();
-
-			}
-			break;
-		case 6:
-			// Language\\Group.g3:1:51: BIGSTRING
-			{
-			mBIGSTRING();
-
-			}
-			break;
-		case 7:
-			// Language\\Group.g3:1:61: ANONYMOUS_TEMPLATE
-			{
-			mANONYMOUS_TEMPLATE();
-
-			}
-			break;
-		case 8:
-			// Language\\Group.g3:1:80: AT
-			{
-			mAT();
-
-			}
-			break;
-		case 9:
-			// Language\\Group.g3:1:83: LPAREN
-			{
-			mLPAREN();
-
-			}
-			break;
-		case 10:
-			// Language\\Group.g3:1:90: RPAREN
-			{
-			mRPAREN();
-
-			}
-			break;
-		case 11:
-			// Language\\Group.g3:1:97: LBRACK
-			{
-			mLBRACK();
-
-			}
-			break;
-		case 12:
-			// Language\\Group.g3:1:104: RBRACK
-			{
-			mRBRACK();
-
-			}
-			break;
-		case 13:
-			// Language\\Group.g3:1:111: COMMA
-			{
-			mCOMMA();
-
-			}
-			break;
-		case 14:
-			// Language\\Group.g3:1:117: DOT
-			{
-			mDOT();
-
-			}
-			break;
-		case 15:
-			// Language\\Group.g3:1:121: DEFINED_TO_BE
-			{
-			mDEFINED_TO_BE();
-
-			}
-			break;
-		case 16:
-			// Language\\Group.g3:1:135: SEMI
-			{
-			mSEMI();
-
-			}
-			break;
-		case 17:
-			// Language\\Group.g3:1:140: COLON
-			{
-			mCOLON();
-
-			}
-			break;
-		case 18:
-			// Language\\Group.g3:1:146: STAR
-			{
-			mSTAR();
-
-			}
-			break;
-		case 19:
-			// Language\\Group.g3:1:151: PLUS
-			{
-			mPLUS();
-
-			}
-			break;
-		case 20:
-			// Language\\Group.g3:1:156: ASSIGN
-			{
-			mASSIGN();
-
-			}
-			break;
-		case 21:
-			// Language\\Group.g3:1:163: OPTIONAL
-			{
-			mOPTIONAL();
-
-			}
-			break;
-		case 22:
-			// Language\\Group.g3:1:172: SL_COMMENT
-			{
-			mSL_COMMENT();
-
-			}
-			break;
-		case 23:
-			// Language\\Group.g3:1:183: ML_COMMENT
-			{
-			mML_COMMENT();
-
-			}
-			break;
-		case 24:
-			// Language\\Group.g3:1:194: WS
-			{
-			mWS();
-
-			}
-			break;
-
-		}
-
-	}
-
-
-	#region DFA
-	DFA12 dfa12;
-
-	protected override void InitDFAs()
-	{
-		base.InitDFAs();
-		dfa12 = new DFA12( this );
-	}
-
-	class DFA12 : DFA
-	{
-
-		const string DFA12_eotS =
-			"\x1\xFFFF\x3\x4\xB\xFFFF\x1\x1B\x7\xFFFF\x3\x4\x4\xFFFF\x7\x4\x1\x28"+
-			"\x2\x4\x1\xFFFF\x1\x4\x1\x2C\x1\x4\x1\xFFFF\x2\x4\x1\x30\x1\xFFFF";
-		const string DFA12_eofS =
-			"\x31\xFFFF";
-		const string DFA12_minS =
-			"\x1\x9\x1\x65\x1\x72\x1\x6D\xB\xFFFF\x1\x3A\x5\xFFFF\x1\x2A\x1\xFFFF"+
-			"\x1\x66\x1\x6F\x1\x70\x4\xFFFF\x1\x61\x1\x75\x1\x6C\x1\x75\x1\x70\x1"+
-			"\x65\x1\x6C\x1\x2D\x1\x6D\x1\x74\x1\xFFFF\x1\x65\x1\x2D\x1\x6E\x1\xFFFF"+
-			"\x1\x74\x1\x73\x1\x2D\x1\xFFFF";
-		const string DFA12_maxS =
-			"\x1\x7B\x1\x65\x1\x72\x1\x6D\xB\xFFFF\x1\x3A\x5\xFFFF\x1\x2F\x1\xFFFF"+
-			"\x1\x66\x1\x6F\x1\x70\x4\xFFFF\x1\x61\x1\x75\x1\x6C\x1\x75\x1\x70\x1"+
-			"\x65\x1\x6C\x1\x7A\x1\x6D\x1\x74\x1\xFFFF\x1\x65\x1\x7A\x1\x6E\x1\xFFFF"+
-			"\x1\x74\x1\x73\x1\x7A\x1\xFFFF";
-		const string DFA12_acceptS =
-			"\x4\xFFFF\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9\x1\xA\x1\xB\x1\xC\x1\xD"+
-			"\x1\xE\x1\xFFFF\x1\x10\x1\x12\x1\x13\x1\x14\x1\x15\x1\xFFFF\x1\x18\x3"+
-			"\xFFFF\x1\xF\x1\x11\x1\x16\x1\x17\xA\xFFFF\x1\x2\x3\xFFFF\x1\x1\x3\xFFFF"+
-			"\x1\x3";
-		const string DFA12_specialS =
-			"\x31\xFFFF}>";
-		static readonly string[] DFA12_transitionS =
-			{
-				"\x2\x16\x1\xFFFF\x2\x16\x12\xFFFF\x1\x16\x1\xFFFF\x1\x5\x5\xFFFF\x1"+
-				"\x9\x1\xA\x1\x11\x1\x12\x1\xD\x1\xFFFF\x1\xE\x1\x15\xA\xFFFF\x1\xF\x1"+
-				"\x10\x1\x6\x1\x13\x1\xFFFF\x1\x14\x1\x8\x1A\x4\x1\xB\x1\xFFFF\x1\xC"+
-				"\x1\xFFFF\x1\x4\x1\xFFFF\x3\x4\x1\x1\x2\x4\x1\x2\x1\x4\x1\x3\x11\x4"+
-				"\x1\x7",
-				"\x1\x17",
-				"\x1\x18",
-				"\x1\x19",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"\x1\x1A",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"\x1\x1D\x4\xFFFF\x1\x1C",
-				"",
-				"\x1\x1E",
-				"\x1\x1F",
-				"\x1\x20",
-				"",
-				"",
-				"",
-				"",
-				"\x1\x21",
-				"\x1\x22",
-				"\x1\x23",
-				"\x1\x24",
-				"\x1\x25",
-				"\x1\x26",
-				"\x1\x27",
-				"\x1\x4\x2\xFFFF\xA\x4\x7\xFFFF\x1A\x4\x4\xFFFF\x1\x4\x1\xFFFF\x1A\x4",
-				"\x1\x29",
-				"\x1\x2A",
-				"",
-				"\x1\x2B",
-				"\x1\x4\x2\xFFFF\xA\x4\x7\xFFFF\x1A\x4\x4\xFFFF\x1\x4\x1\xFFFF\x1A\x4",
-				"\x1\x2D",
-				"",
-				"\x1\x2E",
-				"\x1\x2F",
-				"\x1\x4\x2\xFFFF\xA\x4\x7\xFFFF\x1A\x4\x4\xFFFF\x1\x4\x1\xFFFF\x1A\x4",
-				""
-			};
-
-		static readonly short[] DFA12_eot = DFA.UnpackEncodedString(DFA12_eotS);
-		static readonly short[] DFA12_eof = DFA.UnpackEncodedString(DFA12_eofS);
-		static readonly char[] DFA12_min = DFA.UnpackEncodedStringToUnsignedChars(DFA12_minS);
-		static readonly char[] DFA12_max = DFA.UnpackEncodedStringToUnsignedChars(DFA12_maxS);
-		static readonly short[] DFA12_accept = DFA.UnpackEncodedString(DFA12_acceptS);
-		static readonly short[] DFA12_special = DFA.UnpackEncodedString(DFA12_specialS);
-		static readonly short[][] DFA12_transition;
-
-		static DFA12()
-		{
-			int numStates = DFA12_transitionS.Length;
-			DFA12_transition = new short[numStates][];
-			for ( int i=0; i < numStates; i++ )
-			{
-				DFA12_transition[i] = DFA.UnpackEncodedString(DFA12_transitionS[i]);
-			}
-		}
-
-		public DFA12( BaseRecognizer recognizer )
-		{
-			this.recognizer = recognizer;
-			this.decisionNumber = 12;
-			this.eot = DFA12_eot;
-			this.eof = DFA12_eof;
-			this.min = DFA12_min;
-			this.max = DFA12_max;
-			this.accept = DFA12_accept;
-			this.special = DFA12_special;
-			this.transition = DFA12_transition;
-		}
-		public override string GetDescription()
-		{
-			return "1:0: Tokens : ( KWDEFAULT | KWGROUP | KWIMPLEMENTS | ID | STRING | BIGSTRING | ANONYMOUS_TEMPLATE | AT | LPAREN | RPAREN | LBRACK | RBRACK | COMMA | DOT | DEFINED_TO_BE | SEMI | COLON | STAR | PLUS | ASSIGN | OPTIONAL | SL_COMMENT | ML_COMMENT | WS );";
-		}
-	}
-
-
-	#endregion
-
-}
-
-} // namespace Antlr3.ST.Language
diff --git a/Antlr3.StringTemplate/Language/GroupParser.cs b/Antlr3.StringTemplate/Language/GroupParser.cs
deleted file mode 100644
index 96ab089..0000000
--- a/Antlr3.StringTemplate/Language/GroupParser.cs
+++ /dev/null
@@ -1,1162 +0,0 @@
-// $ANTLR 3.1.2 Language\\Group.g3 2009-09-30 13:27:19
-
-// The variable 'variable' is assigned but its value is never used.
-#pragma warning disable 219
-// Unreachable code detected.
-#pragma warning disable 162
-
-
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Grammar conversion to ANTLR v3 and C#:
- Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-	notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-	derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-using HashMap = System.Collections.Hashtable;
-using Map = System.Collections.IDictionary;
-
-
-using System.Collections.Generic;
-using Antlr.Runtime;
-using Stack = System.Collections.Generic.Stack<object>;
-using List = System.Collections.IList;
-using ArrayList = System.Collections.Generic.List<object>;
-
-namespace Antlr3.ST.Language
-{
-[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.1.2")]
-[System.CLSCompliant(false)]
-public partial class GroupParser : Parser
-{
-	internal static readonly string[] tokenNames = new string[] {
-		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ANONYMOUS_TEMPLATE", "ASSIGN", "AT", "BIGSTRING", "COLON", "COMMA", "DEFINED_TO_BE", "DOT", "ID", "KWDEFAULT", "KWGROUP", "KWIMPLEMENTS", "LBRACK", "LPAREN", "ML_COMMENT", "OPTIONAL", "PLUS", "RBRACK", "RPAREN", "SEMI", "SL_COMMENT", "STAR", "STRING", "WS"
-	};
-	public const int EOF=-1;
-	public const int ANONYMOUS_TEMPLATE=4;
-	public const int ASSIGN=5;
-	public const int AT=6;
-	public const int BIGSTRING=7;
-	public const int COLON=8;
-	public const int COMMA=9;
-	public const int DEFINED_TO_BE=10;
-	public const int DOT=11;
-	public const int ID=12;
-	public const int KWDEFAULT=13;
-	public const int KWGROUP=14;
-	public const int KWIMPLEMENTS=15;
-	public const int LBRACK=16;
-	public const int LPAREN=17;
-	public const int ML_COMMENT=18;
-	public const int OPTIONAL=19;
-	public const int PLUS=20;
-	public const int RBRACK=21;
-	public const int RPAREN=22;
-	public const int SEMI=23;
-	public const int SL_COMMENT=24;
-	public const int STAR=25;
-	public const int STRING=26;
-	public const int WS=27;
-
-	// delegates
-	// delegators
-
-	public GroupParser( ITokenStream input )
-		: this( input, new RecognizerSharedState() )
-	{
-	}
-	public GroupParser( ITokenStream input, RecognizerSharedState state )
-		: base( input, state )
-	{
-	}
-
-
-	public override string[] TokenNames { get { return GroupParser.tokenNames; } }
-	public override string GrammarFileName { get { return "Language\\Group.g3"; } }
-
-
-	#region Rules
-
-	// $ANTLR start "group"
-	// Language\\Group.g3:123:0: public group[StringTemplateGroup g] : 'group' name= ID ( COLON s= ID )? ( 'implements' i= ID ( COMMA i2= ID )* )? SEMI ( template[g] | mapdef[g] )+ EOF ;
-	public void group( StringTemplateGroup g )
-	{
-		IToken name=null;
-		IToken s=null;
-		IToken i=null;
-		IToken i2=null;
-
-
-		this._group = g;
-
-		try
-		{
-			// Language\\Group.g3:128:4: ( 'group' name= ID ( COLON s= ID )? ( 'implements' i= ID ( COMMA i2= ID )* )? SEMI ( template[g] | mapdef[g] )+ EOF )
-			// Language\\Group.g3:128:4: 'group' name= ID ( COLON s= ID )? ( 'implements' i= ID ( COMMA i2= ID )* )? SEMI ( template[g] | mapdef[g] )+ EOF
-			{
-			Match(input,KWGROUP,Follow._KWGROUP_in_group93);
-			name=(IToken)Match(input,ID,Follow._ID_in_group97);
-			g.Name = (name!=null?name.Text:null);
-			// Language\\Group.g3:129:3: ( COLON s= ID )?
-			int alt1=2;
-			int LA1_0 = input.LA(1);
-
-			if ( (LA1_0==COLON) )
-			{
-				alt1=1;
-			}
-			switch ( alt1 )
-			{
-			case 1:
-				// Language\\Group.g3:129:5: COLON s= ID
-				{
-				Match(input,COLON,Follow._COLON_in_group105);
-				s=(IToken)Match(input,ID,Follow._ID_in_group109);
-				g.SetSuperGroup((s!=null?s.Text:null));
-
-				}
-				break;
-
-			}
-
-			// Language\\Group.g3:130:3: ( 'implements' i= ID ( COMMA i2= ID )* )?
-			int alt3=2;
-			int LA3_0 = input.LA(1);
-
-			if ( (LA3_0==KWIMPLEMENTS) )
-			{
-				alt3=1;
-			}
-			switch ( alt3 )
-			{
-			case 1:
-				// Language\\Group.g3:130:5: 'implements' i= ID ( COMMA i2= ID )*
-				{
-				Match(input,KWIMPLEMENTS,Follow._KWIMPLEMENTS_in_group120);
-				i=(IToken)Match(input,ID,Follow._ID_in_group124);
-				g.ImplementInterface((i!=null?i.Text:null));
-				// Language\\Group.g3:131:4: ( COMMA i2= ID )*
-				for ( ; ; )
-				{
-					int alt2=2;
-					int LA2_0 = input.LA(1);
-
-					if ( (LA2_0==COMMA) )
-					{
-						alt2=1;
-					}
-
-
-					switch ( alt2 )
-					{
-					case 1:
-						// Language\\Group.g3:131:5: COMMA i2= ID
-						{
-						Match(input,COMMA,Follow._COMMA_in_group132);
-						i2=(IToken)Match(input,ID,Follow._ID_in_group136);
-						g.ImplementInterface((i2!=null?i2.Text:null));
-
-						}
-						break;
-
-					default:
-						goto loop2;
-					}
-				}
-
-				loop2:
-					;
-
-
-
-				}
-				break;
-
-			}
-
-			Match(input,SEMI,Follow._SEMI_in_group150);
-			// Language\\Group.g3:134:3: ( template[g] | mapdef[g] )+
-			int cnt4=0;
-			for ( ; ; )
-			{
-				int alt4=3;
-				int LA4_0 = input.LA(1);
-
-				if ( (LA4_0==AT) )
-				{
-					alt4=1;
-				}
-				else if ( (LA4_0==ID) )
-				{
-					int LA4_3 = input.LA(2);
-
-					if ( (LA4_3==DEFINED_TO_BE) )
-					{
-						int LA4_4 = input.LA(3);
-
-						if ( (LA4_4==ID) )
-						{
-							alt4=1;
-						}
-						else if ( (LA4_4==LBRACK) )
-						{
-							alt4=2;
-						}
-
-
-					}
-					else if ( (LA4_3==LPAREN) )
-					{
-						alt4=1;
-					}
-
-
-				}
-
-
-				switch ( alt4 )
-				{
-				case 1:
-					// Language\\Group.g3:134:5: template[g]
-					{
-					PushFollow(Follow._template_in_group156);
-					template(g);
-
-					state._fsp--;
-
-
-					}
-					break;
-				case 2:
-					// Language\\Group.g3:134:19: mapdef[g]
-					{
-					PushFollow(Follow._mapdef_in_group161);
-					mapdef(g);
-
-					state._fsp--;
-
-
-					}
-					break;
-
-				default:
-					if ( cnt4 >= 1 )
-						goto loop4;
-
-					EarlyExitException eee4 = new EarlyExitException( 4, input );
-					throw eee4;
-				}
-				cnt4++;
-			}
-			loop4:
-				;
-
-
-			Match(input,EOF,Follow._EOF_in_group169);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "group"
-
-
-	// $ANTLR start "template"
-	// Language\\Group.g3:138:0: template[StringTemplateGroup g] : ( ( AT scope2= ID DOT region= ID |name= ID ) LPAREN ( args[st] |) RPAREN DEFINED_TO_BE (t= STRING |bt= BIGSTRING ) |alias= ID DEFINED_TO_BE target= ID );
-	private void template( StringTemplateGroup g )
-	{
-		IToken scope2=null;
-		IToken region=null;
-		IToken name=null;
-		IToken t=null;
-		IToken bt=null;
-		IToken alias=null;
-		IToken target=null;
-
-
-			Map formalArgs = null;
-			StringTemplate st = null;
-			bool ignore = false;
-			string templateName=null;
-			int line = input.LT(1).Line;
-
-		try
-		{
-			// Language\\Group.g3:147:4: ( ( AT scope2= ID DOT region= ID |name= ID ) LPAREN ( args[st] |) RPAREN DEFINED_TO_BE (t= STRING |bt= BIGSTRING ) |alias= ID DEFINED_TO_BE target= ID )
-			int alt8=2;
-			int LA8_0 = input.LA(1);
-
-			if ( (LA8_0==AT) )
-			{
-				alt8=1;
-			}
-			else if ( (LA8_0==ID) )
-			{
-				int LA8_2 = input.LA(2);
-
-				if ( (LA8_2==DEFINED_TO_BE) )
-				{
-					alt8=2;
-				}
-				else if ( (LA8_2==LPAREN) )
-				{
-					alt8=1;
-				}
-				else
-				{
-					NoViableAltException nvae = new NoViableAltException("", 8, 2, input);
-
-					throw nvae;
-				}
-			}
-			else
-			{
-				NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt8 )
-			{
-			case 1:
-				// Language\\Group.g3:147:4: ( AT scope2= ID DOT region= ID |name= ID ) LPAREN ( args[st] |) RPAREN DEFINED_TO_BE (t= STRING |bt= BIGSTRING )
-				{
-				// Language\\Group.g3:147:4: ( AT scope2= ID DOT region= ID |name= ID )
-				int alt5=2;
-				int LA5_0 = input.LA(1);
-
-				if ( (LA5_0==AT) )
-				{
-					alt5=1;
-				}
-				else if ( (LA5_0==ID) )
-				{
-					alt5=2;
-				}
-				else
-				{
-					NoViableAltException nvae = new NoViableAltException("", 5, 0, input);
-
-					throw nvae;
-				}
-				switch ( alt5 )
-				{
-				case 1:
-					// Language\\Group.g3:147:6: AT scope2= ID DOT region= ID
-					{
-					Match(input,AT,Follow._AT_in_template188);
-					scope2=(IToken)Match(input,ID,Follow._ID_in_template192);
-					Match(input,DOT,Follow._DOT_in_template194);
-					region=(IToken)Match(input,ID,Follow._ID_in_template198);
-
-									templateName=g.GetMangledRegionName((scope2!=null?scope2.Text:null),(region!=null?region.Text:null));
-									if ( g.IsDefinedInThisGroup(templateName) )
-									{
-										g.Error("group "+g.Name+" line "+line+": redefinition of template region: @"+
-											(scope2!=null?scope2.Text:null)+"."+(region!=null?region.Text:null));
-										st = new StringTemplate(); // create bogus template to fill in
-									}
-									else
-									{
-										bool err = false;
-										// @template.region() ::= "..."
-										StringTemplate scopeST = g.LookupTemplate((scope2!=null?scope2.Text:null));
-										if ( scopeST == null )
-										{
-											g.Error("group "+g.Name+" line "+line+": reference to region within undefined template: "+
-												(scope2!=null?scope2.Text:null));
-											err=true;
-										}
-										else if ( !scopeST.ContainsRegionName((region!=null?region.Text:null)) )
-										{
-											g.Error("group "+g.Name+" line "+line+": template "+(scope2!=null?scope2.Text:null)+" has no region called "+
-												(region!=null?region.Text:null));
-											err=true;
-										}
-										if ( err )
-										{
-											st = new StringTemplate();
-										}
-										else
-										{
-											st = g.DefineRegionTemplate((scope2!=null?scope2.Text:null),
-																		(region!=null?region.Text:null),
-																		null,
-																		RegionType.Explicit);
-										}
-									}
-
-
-					}
-					break;
-				case 2:
-					// Language\\Group.g3:186:5: name= ID
-					{
-					name=(IToken)Match(input,ID,Follow._ID_in_template211);
-					templateName = (name!=null?name.Text:null);
-
-									if ( g.IsDefinedInThisGroup(templateName) )
-									{
-										g.Error("redefinition of template: "+templateName);
-										st = new StringTemplate(); // create bogus template to fill in
-									}
-									else
-									{
-										st = g.DefineTemplate(templateName, null);
-									}
-
-
-					}
-					break;
-
-				}
-
-				if ( st!=null ) {st.GroupFileLine = line;}
-				Match(input,LPAREN,Follow._LPAREN_in_template230);
-				// Language\\Group.g3:201:4: ( args[st] |)
-				int alt6=2;
-				int LA6_0 = input.LA(1);
-
-				if ( (LA6_0==ID) )
-				{
-					alt6=1;
-				}
-				else if ( (LA6_0==RPAREN) )
-				{
-					alt6=2;
-				}
-				else
-				{
-					NoViableAltException nvae = new NoViableAltException("", 6, 0, input);
-
-					throw nvae;
-				}
-				switch ( alt6 )
-				{
-				case 1:
-					// Language\\Group.g3:201:5: args[st]
-					{
-					PushFollow(Follow._args_in_template236);
-					args(st);
-
-					state._fsp--;
-
-
-					}
-					break;
-				case 2:
-					// Language\\Group.g3:201:14:
-					{
-					st.DefineEmptyFormalArgumentList();
-
-					}
-					break;
-
-				}
-
-				Match(input,RPAREN,Follow._RPAREN_in_template244);
-				Match(input,DEFINED_TO_BE,Follow._DEFINED_TO_BE_in_template248);
-				// Language\\Group.g3:204:3: (t= STRING |bt= BIGSTRING )
-				int alt7=2;
-				int LA7_0 = input.LA(1);
-
-				if ( (LA7_0==STRING) )
-				{
-					alt7=1;
-				}
-				else if ( (LA7_0==BIGSTRING) )
-				{
-					alt7=2;
-				}
-				else
-				{
-					NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
-
-					throw nvae;
-				}
-				switch ( alt7 )
-				{
-				case 1:
-					// Language\\Group.g3:204:5: t= STRING
-					{
-					t=(IToken)Match(input,STRING,Follow._STRING_in_template256);
-					st.Template = (t!=null?t.Text:null);
-
-					}
-					break;
-				case 2:
-					// Language\\Group.g3:205:5: bt= BIGSTRING
-					{
-					bt=(IToken)Match(input,BIGSTRING,Follow._BIGSTRING_in_template270);
-					st.Template = (bt!=null?bt.Text:null);
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-			case 2:
-				// Language\\Group.g3:208:6: alias= ID DEFINED_TO_BE target= ID
-				{
-				alias=(IToken)Match(input,ID,Follow._ID_in_template286);
-				Match(input,DEFINED_TO_BE,Follow._DEFINED_TO_BE_in_template288);
-				target=(IToken)Match(input,ID,Follow._ID_in_template292);
-				g.DefineTemplateAlias((alias!=null?alias.Text:null), (target!=null?target.Text:null));
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "template"
-
-
-	// $ANTLR start "args"
-	// Language\\Group.g3:212:0: args[StringTemplate st] : arg[st] ( COMMA arg[st] )* ;
-	private void args( StringTemplate st )
-	{
-		try
-		{
-			// Language\\Group.g3:213:4: ( arg[st] ( COMMA arg[st] )* )
-			// Language\\Group.g3:213:4: arg[st] ( COMMA arg[st] )*
-			{
-			PushFollow(Follow._arg_in_args308);
-			arg(st);
-
-			state._fsp--;
-
-			// Language\\Group.g3:213:12: ( COMMA arg[st] )*
-			for ( ; ; )
-			{
-				int alt9=2;
-				int LA9_0 = input.LA(1);
-
-				if ( (LA9_0==COMMA) )
-				{
-					alt9=1;
-				}
-
-
-				switch ( alt9 )
-				{
-				case 1:
-					// Language\\Group.g3:213:14: COMMA arg[st]
-					{
-					Match(input,COMMA,Follow._COMMA_in_args313);
-					PushFollow(Follow._arg_in_args315);
-					arg(st);
-
-					state._fsp--;
-
-
-					}
-					break;
-
-				default:
-					goto loop9;
-				}
-			}
-
-			loop9:
-				;
-
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "args"
-
-
-	// $ANTLR start "arg"
-	// Language\\Group.g3:216:0: arg[StringTemplate st] : name= ID ( ASSIGN s= STRING | ASSIGN bs= ANONYMOUS_TEMPLATE )? ;
-	private void arg( StringTemplate st )
-	{
-		IToken name=null;
-		IToken s=null;
-		IToken bs=null;
-
-
-			StringTemplate defaultValue = null;
-
-		try
-		{
-			// Language\\Group.g3:221:4: (name= ID ( ASSIGN s= STRING | ASSIGN bs= ANONYMOUS_TEMPLATE )? )
-			// Language\\Group.g3:221:4: name= ID ( ASSIGN s= STRING | ASSIGN bs= ANONYMOUS_TEMPLATE )?
-			{
-			name=(IToken)Match(input,ID,Follow._ID_in_arg338);
-			// Language\\Group.g3:222:3: ( ASSIGN s= STRING | ASSIGN bs= ANONYMOUS_TEMPLATE )?
-			int alt10=3;
-			int LA10_0 = input.LA(1);
-
-			if ( (LA10_0==ASSIGN) )
-			{
-				int LA10_1 = input.LA(2);
-
-				if ( (LA10_1==STRING) )
-				{
-					alt10=1;
-				}
-				else if ( (LA10_1==ANONYMOUS_TEMPLATE) )
-				{
-					alt10=2;
-				}
-			}
-			switch ( alt10 )
-			{
-			case 1:
-				// Language\\Group.g3:222:5: ASSIGN s= STRING
-				{
-				Match(input,ASSIGN,Follow._ASSIGN_in_arg344);
-				s=(IToken)Match(input,STRING,Follow._STRING_in_arg348);
-
-								defaultValue=new StringTemplate("$_val_$");
-								defaultValue.SetAttribute("_val_", (s!=null?s.Text:null));
-								defaultValue.DefineFormalArgument("_val_");
-								defaultValue.Name = "<"+st.Name+"'s arg "+(name!=null?name.Text:null)+" default value subtemplate>";
-
-
-				}
-				break;
-			case 2:
-				// Language\\Group.g3:229:5: ASSIGN bs= ANONYMOUS_TEMPLATE
-				{
-				Match(input,ASSIGN,Follow._ASSIGN_in_arg359);
-				bs=(IToken)Match(input,ANONYMOUS_TEMPLATE,Follow._ANONYMOUS_TEMPLATE_in_arg363);
-
-								defaultValue=new StringTemplate(st.Group, (bs!=null?bs.Text:null));
-								defaultValue.Name = "<"+st.Name+"'s arg "+(name!=null?name.Text:null)+" default value subtemplate>";
-
-
-				}
-				break;
-
-			}
-
-			st.DefineFormalArgument((name!=null?name.Text:null), defaultValue);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "arg"
-
-
-	// $ANTLR start "mapdef"
-	// Language\\Group.g3:238:0: mapdef[StringTemplateGroup g] : name= ID DEFINED_TO_BE m= map ;
-	private void mapdef( StringTemplateGroup g )
-	{
-		IToken name=null;
-		Map m = default(Map);
-
-		try
-		{
-			// Language\\Group.g3:239:4: (name= ID DEFINED_TO_BE m= map )
-			// Language\\Group.g3:239:4: name= ID DEFINED_TO_BE m= map
-			{
-			name=(IToken)Match(input,ID,Follow._ID_in_mapdef391);
-			Match(input,DEFINED_TO_BE,Follow._DEFINED_TO_BE_in_mapdef395);
-			PushFollow(Follow._map_in_mapdef399);
-			m=map();
-
-			state._fsp--;
-
-
-						if ( g.GetMap((name!=null?name.Text:null))!=null )
-						{
-							g.Error("redefinition of map: "+(name!=null?name.Text:null));
-						}
-						else if ( g.IsDefinedInThisGroup((name!=null?name.Text:null)) )
-						{
-							g.Error("redefinition of template as map: "+(name!=null?name.Text:null));
-						}
-						else
-						{
-							g.DefineMap((name!=null?name.Text:null), m);
-						}
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "mapdef"
-
-
-	// $ANTLR start "map"
-	// Language\\Group.g3:257:0: map returns [Map mapping=new HashMap()] : LBRACK mapPairs[mapping] RBRACK ;
-	private Map map(  )
-	{
-		Map mapping = new HashMap();
-
-		try
-		{
-			// Language\\Group.g3:258:6: ( LBRACK mapPairs[mapping] RBRACK )
-			// Language\\Group.g3:258:6: LBRACK mapPairs[mapping] RBRACK
-			{
-			Match(input,LBRACK,Follow._LBRACK_in_map420);
-			PushFollow(Follow._mapPairs_in_map422);
-			mapPairs(mapping);
-
-			state._fsp--;
-
-			Match(input,RBRACK,Follow._RBRACK_in_map425);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return mapping;
-	}
-	// $ANTLR end "map"
-
-
-	// $ANTLR start "mapPairs"
-	// Language\\Group.g3:261:0: mapPairs[Map mapping] : ( keyValuePair[mapping] ( COMMA keyValuePair[mapping] )* ( COMMA defaultValuePair[mapping] )? | defaultValuePair[mapping] );
-	private void mapPairs( Map mapping )
-	{
-		try
-		{
-			// Language\\Group.g3:262:4: ( keyValuePair[mapping] ( COMMA keyValuePair[mapping] )* ( COMMA defaultValuePair[mapping] )? | defaultValuePair[mapping] )
-			int alt13=2;
-			int LA13_0 = input.LA(1);
-
-			if ( (LA13_0==STRING) )
-			{
-				alt13=1;
-			}
-			else if ( (LA13_0==KWDEFAULT) )
-			{
-				alt13=2;
-			}
-			else
-			{
-				NoViableAltException nvae = new NoViableAltException("", 13, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt13 )
-			{
-			case 1:
-				// Language\\Group.g3:262:4: keyValuePair[mapping] ( COMMA keyValuePair[mapping] )* ( COMMA defaultValuePair[mapping] )?
-				{
-				PushFollow(Follow._keyValuePair_in_mapPairs438);
-				keyValuePair(mapping);
-
-				state._fsp--;
-
-				// Language\\Group.g3:262:26: ( COMMA keyValuePair[mapping] )*
-				for ( ; ; )
-				{
-					int alt11=2;
-					int LA11_0 = input.LA(1);
-
-					if ( (LA11_0==COMMA) )
-					{
-						int LA11_1 = input.LA(2);
-
-						if ( (LA11_1==STRING) )
-						{
-							alt11=1;
-						}
-
-
-					}
-
-
-					switch ( alt11 )
-					{
-					case 1:
-						// Language\\Group.g3:262:27: COMMA keyValuePair[mapping]
-						{
-						Match(input,COMMA,Follow._COMMA_in_mapPairs442);
-						PushFollow(Follow._keyValuePair_in_mapPairs444);
-						keyValuePair(mapping);
-
-						state._fsp--;
-
-
-						}
-						break;
-
-					default:
-						goto loop11;
-					}
-				}
-
-				loop11:
-					;
-
-
-				// Language\\Group.g3:263:3: ( COMMA defaultValuePair[mapping] )?
-				int alt12=2;
-				int LA12_0 = input.LA(1);
-
-				if ( (LA12_0==COMMA) )
-				{
-					alt12=1;
-				}
-				switch ( alt12 )
-				{
-				case 1:
-					// Language\\Group.g3:263:4: COMMA defaultValuePair[mapping]
-					{
-					Match(input,COMMA,Follow._COMMA_in_mapPairs452);
-					PushFollow(Follow._defaultValuePair_in_mapPairs454);
-					defaultValuePair(mapping);
-
-					state._fsp--;
-
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-			case 2:
-				// Language\\Group.g3:264:4: defaultValuePair[mapping]
-				{
-				PushFollow(Follow._defaultValuePair_in_mapPairs462);
-				defaultValuePair(mapping);
-
-				state._fsp--;
-
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "mapPairs"
-
-
-	// $ANTLR start "defaultValuePair"
-	// Language\\Group.g3:267:0: defaultValuePair[Map mapping] : 'default' COLON v= keyValue ;
-	private void defaultValuePair( Map mapping )
-	{
-		StringTemplate v = default(StringTemplate);
-
-		try
-		{
-			// Language\\Group.g3:268:4: ( 'default' COLON v= keyValue )
-			// Language\\Group.g3:268:4: 'default' COLON v= keyValue
-			{
-			Match(input,KWDEFAULT,Follow._KWDEFAULT_in_defaultValuePair476);
-			Match(input,COLON,Follow._COLON_in_defaultValuePair478);
-			PushFollow(Follow._keyValue_in_defaultValuePair482);
-			v=keyValue();
-
-			state._fsp--;
-
-			mapping[ASTExpr.DefaultMapValueName] = v;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "defaultValuePair"
-
-
-	// $ANTLR start "keyValuePair"
-	// Language\\Group.g3:272:0: keyValuePair[Map mapping] : key= STRING COLON v= keyValue ;
-	private void keyValuePair( Map mapping )
-	{
-		IToken key=null;
-		StringTemplate v = default(StringTemplate);
-
-		try
-		{
-			// Language\\Group.g3:273:4: (key= STRING COLON v= keyValue )
-			// Language\\Group.g3:273:4: key= STRING COLON v= keyValue
-			{
-			key=(IToken)Match(input,STRING,Follow._STRING_in_keyValuePair500);
-			Match(input,COLON,Follow._COLON_in_keyValuePair502);
-			PushFollow(Follow._keyValue_in_keyValuePair506);
-			v=keyValue();
-
-			state._fsp--;
-
-			mapping[(key!=null?key.Text:null)] = v;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "keyValuePair"
-
-
-	// $ANTLR start "keyValue"
-	// Language\\Group.g3:276:0: keyValue returns [StringTemplate value=null] : (s1= BIGSTRING |s2= STRING |k= ID {...}?|);
-	private StringTemplate keyValue(  )
-	{
-		StringTemplate value = null;
-
-		IToken s1=null;
-		IToken s2=null;
-		IToken k=null;
-
-		try
-		{
-			// Language\\Group.g3:277:4: (s1= BIGSTRING |s2= STRING |k= ID {...}?|)
-			int alt14=4;
-			switch ( input.LA(1) )
-			{
-			case BIGSTRING:
-				{
-				alt14=1;
-				}
-				break;
-			case STRING:
-				{
-				alt14=2;
-				}
-				break;
-			case ID:
-				{
-				alt14=3;
-				}
-				break;
-			case COMMA:
-			case RBRACK:
-				{
-				alt14=4;
-				}
-				break;
-			default:
-				{
-					NoViableAltException nvae = new NoViableAltException("", 14, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt14 )
-			{
-			case 1:
-				// Language\\Group.g3:277:4: s1= BIGSTRING
-				{
-				s1=(IToken)Match(input,BIGSTRING,Follow._BIGSTRING_in_keyValue525);
-				value = new StringTemplate(_group,(s1!=null?s1.Text:null));
-
-				}
-				break;
-			case 2:
-				// Language\\Group.g3:278:4: s2= STRING
-				{
-				s2=(IToken)Match(input,STRING,Follow._STRING_in_keyValue534);
-				value = new StringTemplate(_group,(s2!=null?s2.Text:null));
-
-				}
-				break;
-			case 3:
-				// Language\\Group.g3:279:4: k= ID {...}?
-				{
-				k=(IToken)Match(input,ID,Follow._ID_in_keyValue544);
-				if ( !(((k!=null?k.Text:null) == "key")) )
-				{
-					throw new FailedPredicateException(input, "keyValue", "$k.text == \"key\"");
-				}
-				value = ASTExpr.MapKeyValue;
-
-				}
-				break;
-			case 4:
-				// Language\\Group.g3:281:8:
-				{
-				value = null;
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return value;
-	}
-	// $ANTLR end "keyValue"
-	#endregion Rules
-
-
-	#region Follow sets
-	private static class Follow
-	{
-		public static readonly BitSet _KWGROUP_in_group93 = new BitSet(new ulong[]{0x1000UL});
-		public static readonly BitSet _ID_in_group97 = new BitSet(new ulong[]{0x808100UL});
-		public static readonly BitSet _COLON_in_group105 = new BitSet(new ulong[]{0x1000UL});
-		public static readonly BitSet _ID_in_group109 = new BitSet(new ulong[]{0x808000UL});
-		public static readonly BitSet _KWIMPLEMENTS_in_group120 = new BitSet(new ulong[]{0x1000UL});
-		public static readonly BitSet _ID_in_group124 = new BitSet(new ulong[]{0x800200UL});
-		public static readonly BitSet _COMMA_in_group132 = new BitSet(new ulong[]{0x1000UL});
-		public static readonly BitSet _ID_in_group136 = new BitSet(new ulong[]{0x800200UL});
-		public static readonly BitSet _SEMI_in_group150 = new BitSet(new ulong[]{0x1040UL});
-		public static readonly BitSet _template_in_group156 = new BitSet(new ulong[]{0x1040UL});
-		public static readonly BitSet _mapdef_in_group161 = new BitSet(new ulong[]{0x1040UL});
-		public static readonly BitSet _EOF_in_group169 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _AT_in_template188 = new BitSet(new ulong[]{0x1000UL});
-		public static readonly BitSet _ID_in_template192 = new BitSet(new ulong[]{0x800UL});
-		public static readonly BitSet _DOT_in_template194 = new BitSet(new ulong[]{0x1000UL});
-		public static readonly BitSet _ID_in_template198 = new BitSet(new ulong[]{0x20000UL});
-		public static readonly BitSet _ID_in_template211 = new BitSet(new ulong[]{0x20000UL});
-		public static readonly BitSet _LPAREN_in_template230 = new BitSet(new ulong[]{0x401000UL});
-		public static readonly BitSet _args_in_template236 = new BitSet(new ulong[]{0x400000UL});
-		public static readonly BitSet _RPAREN_in_template244 = new BitSet(new ulong[]{0x400UL});
-		public static readonly BitSet _DEFINED_TO_BE_in_template248 = new BitSet(new ulong[]{0x4000080UL});
-		public static readonly BitSet _STRING_in_template256 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _BIGSTRING_in_template270 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ID_in_template286 = new BitSet(new ulong[]{0x400UL});
-		public static readonly BitSet _DEFINED_TO_BE_in_template288 = new BitSet(new ulong[]{0x1000UL});
-		public static readonly BitSet _ID_in_template292 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _arg_in_args308 = new BitSet(new ulong[]{0x202UL});
-		public static readonly BitSet _COMMA_in_args313 = new BitSet(new ulong[]{0x1000UL});
-		public static readonly BitSet _arg_in_args315 = new BitSet(new ulong[]{0x202UL});
-		public static readonly BitSet _ID_in_arg338 = new BitSet(new ulong[]{0x22UL});
-		public static readonly BitSet _ASSIGN_in_arg344 = new BitSet(new ulong[]{0x4000000UL});
-		public static readonly BitSet _STRING_in_arg348 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ASSIGN_in_arg359 = new BitSet(new ulong[]{0x10UL});
-		public static readonly BitSet _ANONYMOUS_TEMPLATE_in_arg363 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ID_in_mapdef391 = new BitSet(new ulong[]{0x400UL});
-		public static readonly BitSet _DEFINED_TO_BE_in_mapdef395 = new BitSet(new ulong[]{0x10000UL});
-		public static readonly BitSet _map_in_mapdef399 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _LBRACK_in_map420 = new BitSet(new ulong[]{0x4002000UL});
-		public static readonly BitSet _mapPairs_in_map422 = new BitSet(new ulong[]{0x200000UL});
-		public static readonly BitSet _RBRACK_in_map425 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _keyValuePair_in_mapPairs438 = new BitSet(new ulong[]{0x202UL});
-		public static readonly BitSet _COMMA_in_mapPairs442 = new BitSet(new ulong[]{0x4000000UL});
-		public static readonly BitSet _keyValuePair_in_mapPairs444 = new BitSet(new ulong[]{0x202UL});
-		public static readonly BitSet _COMMA_in_mapPairs452 = new BitSet(new ulong[]{0x4002000UL});
-		public static readonly BitSet _defaultValuePair_in_mapPairs454 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _defaultValuePair_in_mapPairs462 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _KWDEFAULT_in_defaultValuePair476 = new BitSet(new ulong[]{0x100UL});
-		public static readonly BitSet _COLON_in_defaultValuePair478 = new BitSet(new ulong[]{0x4001080UL});
-		public static readonly BitSet _keyValue_in_defaultValuePair482 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _STRING_in_keyValuePair500 = new BitSet(new ulong[]{0x100UL});
-		public static readonly BitSet _COLON_in_keyValuePair502 = new BitSet(new ulong[]{0x4001080UL});
-		public static readonly BitSet _keyValue_in_keyValuePair506 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _BIGSTRING_in_keyValue525 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _STRING_in_keyValue534 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ID_in_keyValue544 = new BitSet(new ulong[]{0x2UL});
-
-	}
-	#endregion Follow sets
-}
-
-} // namespace Antlr3.ST.Language
diff --git a/Antlr3.StringTemplate/Language/InterfaceLexer.cs b/Antlr3.StringTemplate/Language/InterfaceLexer.cs
deleted file mode 100644
index 75564b9..0000000
--- a/Antlr3.StringTemplate/Language/InterfaceLexer.cs
+++ /dev/null
@@ -1,794 +0,0 @@
-// $ANTLR 3.1.2 Language\\Interface.g3 2009-03-23 17:53:08
-
-// The variable 'variable' is assigned but its value is never used.
-#pragma warning disable 219
-// Unreachable code detected.
-#pragma warning disable 162
-
-
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Grammar conversion to ANTLR v3 and C#:
- Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-	notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-	derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-
-using System.Collections.Generic;
-using Antlr.Runtime;
-using Stack = System.Collections.Generic.Stack<object>;
-using List = System.Collections.IList;
-using ArrayList = System.Collections.Generic.List<object>;
-
-namespace Antlr3.ST.Language
-{
-[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.1.2")]
-[System.CLSCompliant(false)]
-public partial class InterfaceLexer : Lexer
-{
-	public const int EOF=-1;
-	public const int COLON=4;
-	public const int COMMA=5;
-	public const int ID=6;
-	public const int INTERFACE=7;
-	public const int LPAREN=8;
-	public const int ML_COMMENT=9;
-	public const int OPTIONAL=10;
-	public const int RPAREN=11;
-	public const int SEMI=12;
-	public const int SL_COMMENT=13;
-	public const int WS=14;
-
-    // delegates
-    // delegators
-
-	public InterfaceLexer() {}
-	public InterfaceLexer( ICharStream input )
-		: this( input, new RecognizerSharedState() )
-	{
-	}
-	public InterfaceLexer( ICharStream input, RecognizerSharedState state )
-		: base( input, state )
-	{
-
-	}
-	public override string GrammarFileName { get { return "Language\\Interface.g3"; } }
-
-	// $ANTLR start "INTERFACE"
-	private void mINTERFACE()
-	{
-		try
-		{
-			int _type = INTERFACE;
-			int _channel = DefaultTokenChannel;
-			// Language\\Interface.g3:42:13: ( 'interface' )
-			// Language\\Interface.g3:42:13: 'interface'
-			{
-			Match("interface");
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "INTERFACE"
-
-	// $ANTLR start "OPTIONAL"
-	private void mOPTIONAL()
-	{
-		try
-		{
-			int _type = OPTIONAL;
-			int _channel = DefaultTokenChannel;
-			// Language\\Interface.g3:43:12: ( 'optional' )
-			// Language\\Interface.g3:43:12: 'optional'
-			{
-			Match("optional");
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "OPTIONAL"
-
-	// $ANTLR start "ID"
-	private void mID()
-	{
-		try
-		{
-			int _type = ID;
-			int _channel = DefaultTokenChannel;
-			// Language\\Interface.g3:156:6: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '-' | '_' )* )
-			// Language\\Interface.g3:156:6: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '-' | '_' )*
-			{
-			if ( (input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z') )
-			{
-				input.Consume();
-
-			}
-			else
-			{
-				MismatchedSetException mse = new MismatchedSetException(null,input);
-				Recover(mse);
-				throw mse;}
-
-			// Language\\Interface.g3:156:30: ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '-' | '_' )*
-			for ( ; ; )
-			{
-				int alt1=2;
-				int LA1_0 = input.LA(1);
-
-				if ( (LA1_0=='-'||(LA1_0>='0' && LA1_0<='9')||(LA1_0>='A' && LA1_0<='Z')||LA1_0=='_'||(LA1_0>='a' && LA1_0<='z')) )
-				{
-					alt1=1;
-				}
-
-
-				switch ( alt1 )
-				{
-				case 1:
-					// Language\\Interface.g3:
-					{
-					input.Consume();
-
-
-					}
-					break;
-
-				default:
-					goto loop1;
-				}
-			}
-
-			loop1:
-				;
-
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ID"
-
-	// $ANTLR start "LPAREN"
-	private void mLPAREN()
-	{
-		try
-		{
-			int _type = LPAREN;
-			int _channel = DefaultTokenChannel;
-			// Language\\Interface.g3:159:10: ( '(' )
-			// Language\\Interface.g3:159:10: '('
-			{
-			Match('(');
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "LPAREN"
-
-	// $ANTLR start "RPAREN"
-	private void mRPAREN()
-	{
-		try
-		{
-			int _type = RPAREN;
-			int _channel = DefaultTokenChannel;
-			// Language\\Interface.g3:160:10: ( ')' )
-			// Language\\Interface.g3:160:10: ')'
-			{
-			Match(')');
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "RPAREN"
-
-	// $ANTLR start "COMMA"
-	private void mCOMMA()
-	{
-		try
-		{
-			int _type = COMMA;
-			int _channel = DefaultTokenChannel;
-			// Language\\Interface.g3:161:9: ( ',' )
-			// Language\\Interface.g3:161:9: ','
-			{
-			Match(',');
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "COMMA"
-
-	// $ANTLR start "SEMI"
-	private void mSEMI()
-	{
-		try
-		{
-			int _type = SEMI;
-			int _channel = DefaultTokenChannel;
-			// Language\\Interface.g3:162:8: ( ';' )
-			// Language\\Interface.g3:162:8: ';'
-			{
-			Match(';');
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "SEMI"
-
-	// $ANTLR start "COLON"
-	private void mCOLON()
-	{
-		try
-		{
-			int _type = COLON;
-			int _channel = DefaultTokenChannel;
-			// Language\\Interface.g3:163:9: ( ':' )
-			// Language\\Interface.g3:163:9: ':'
-			{
-			Match(':');
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "COLON"
-
-	// $ANTLR start "SL_COMMENT"
-	private void mSL_COMMENT()
-	{
-		try
-		{
-			int _type = SL_COMMENT;
-			int _channel = DefaultTokenChannel;
-			// Language\\Interface.g3:167:4: ( '//' (~ ( '\\n' | '\\r' ) )* ( ( '\\r' )? '\\n' )? )
-			// Language\\Interface.g3:167:4: '//' (~ ( '\\n' | '\\r' ) )* ( ( '\\r' )? '\\n' )?
-			{
-			Match("//");
-
-			// Language\\Interface.g3:168:3: (~ ( '\\n' | '\\r' ) )*
-			for ( ; ; )
-			{
-				int alt2=2;
-				int LA2_0 = input.LA(1);
-
-				if ( ((LA2_0>='\u0000' && LA2_0<='\t')||(LA2_0>='\u000B' && LA2_0<='\f')||(LA2_0>='\u000E' && LA2_0<='\uFFFF')) )
-				{
-					alt2=1;
-				}
-
-
-				switch ( alt2 )
-				{
-				case 1:
-					// Language\\Interface.g3:
-					{
-					input.Consume();
-
-
-					}
-					break;
-
-				default:
-					goto loop2;
-				}
-			}
-
-			loop2:
-				;
-
-
-			// Language\\Interface.g3:168:19: ( ( '\\r' )? '\\n' )?
-			int alt4=2;
-			int LA4_0 = input.LA(1);
-
-			if ( (LA4_0=='\n'||LA4_0=='\r') )
-			{
-				alt4=1;
-			}
-			switch ( alt4 )
-			{
-			case 1:
-				// Language\\Interface.g3:168:20: ( '\\r' )? '\\n'
-				{
-				// Language\\Interface.g3:168:20: ( '\\r' )?
-				int alt3=2;
-				int LA3_0 = input.LA(1);
-
-				if ( (LA3_0=='\r') )
-				{
-					alt3=1;
-				}
-				switch ( alt3 )
-				{
-				case 1:
-					// Language\\Interface.g3:168:21: '\\r'
-					{
-					Match('\r');
-
-					}
-					break;
-
-				}
-
-				Match('\n');
-
-				}
-				break;
-
-			}
-
-			 _channel = Hidden;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "SL_COMMENT"
-
-	// $ANTLR start "ML_COMMENT"
-	private void mML_COMMENT()
-	{
-		try
-		{
-			int _type = ML_COMMENT;
-			int _channel = DefaultTokenChannel;
-			// Language\\Interface.g3:173:4: ( '/*' ( . )* '*/' )
-			// Language\\Interface.g3:173:4: '/*' ( . )* '*/'
-			{
-			Match("/*");
-
-			// Language\\Interface.g3:173:9: ( . )*
-			for ( ; ; )
-			{
-				int alt5=2;
-				int LA5_0 = input.LA(1);
-
-				if ( (LA5_0=='*') )
-				{
-					int LA5_1 = input.LA(2);
-
-					if ( (LA5_1=='/') )
-					{
-						alt5=2;
-					}
-					else if ( ((LA5_1>='\u0000' && LA5_1<='.')||(LA5_1>='0' && LA5_1<='\uFFFF')) )
-					{
-						alt5=1;
-					}
-
-
-				}
-				else if ( ((LA5_0>='\u0000' && LA5_0<=')')||(LA5_0>='+' && LA5_0<='\uFFFF')) )
-				{
-					alt5=1;
-				}
-
-
-				switch ( alt5 )
-				{
-				case 1:
-					// Language\\Interface.g3:173:0: .
-					{
-					MatchAny();
-
-					}
-					break;
-
-				default:
-					goto loop5;
-				}
-			}
-
-			loop5:
-				;
-
-
-			Match("*/");
-
-			 _channel = Hidden;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ML_COMMENT"
-
-	// $ANTLR start "WS"
-	private void mWS()
-	{
-		try
-		{
-			int _type = WS;
-			int _channel = DefaultTokenChannel;
-			// Language\\Interface.g3:178:4: ( ( ' ' | '\\t' | '\\f' | ( '\\r' )? '\\n' )+ )
-			// Language\\Interface.g3:178:4: ( ' ' | '\\t' | '\\f' | ( '\\r' )? '\\n' )+
-			{
-			// Language\\Interface.g3:178:4: ( ' ' | '\\t' | '\\f' | ( '\\r' )? '\\n' )+
-			int cnt7=0;
-			for ( ; ; )
-			{
-				int alt7=5;
-				switch ( input.LA(1) )
-				{
-				case ' ':
-					{
-					alt7=1;
-					}
-					break;
-				case '\t':
-					{
-					alt7=2;
-					}
-					break;
-				case '\f':
-					{
-					alt7=3;
-					}
-					break;
-				case '\n':
-				case '\r':
-					{
-					alt7=4;
-					}
-					break;
-
-				}
-
-				switch ( alt7 )
-				{
-				case 1:
-					// Language\\Interface.g3:178:6: ' '
-					{
-					Match(' ');
-
-					}
-					break;
-				case 2:
-					// Language\\Interface.g3:179:5: '\\t'
-					{
-					Match('\t');
-
-					}
-					break;
-				case 3:
-					// Language\\Interface.g3:180:5: '\\f'
-					{
-					Match('\f');
-
-					}
-					break;
-				case 4:
-					// Language\\Interface.g3:181:5: ( '\\r' )? '\\n'
-					{
-					// Language\\Interface.g3:181:5: ( '\\r' )?
-					int alt6=2;
-					int LA6_0 = input.LA(1);
-
-					if ( (LA6_0=='\r') )
-					{
-						alt6=1;
-					}
-					switch ( alt6 )
-					{
-					case 1:
-						// Language\\Interface.g3:181:6: '\\r'
-						{
-						Match('\r');
-
-						}
-						break;
-
-					}
-
-					Match('\n');
-
-					}
-					break;
-
-				default:
-					if ( cnt7 >= 1 )
-						goto loop7;
-
-					EarlyExitException eee7 = new EarlyExitException( 7, input );
-					throw eee7;
-				}
-				cnt7++;
-			}
-			loop7:
-				;
-
-
-			 _channel = Hidden;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "WS"
-
-	public override void mTokens()
-	{
-		// Language\\Interface.g3:1:10: ( INTERFACE | OPTIONAL | ID | LPAREN | RPAREN | COMMA | SEMI | COLON | SL_COMMENT | ML_COMMENT | WS )
-		int alt8=11;
-		alt8 = dfa8.Predict(input);
-		switch ( alt8 )
-		{
-		case 1:
-			// Language\\Interface.g3:1:10: INTERFACE
-			{
-			mINTERFACE();
-
-			}
-			break;
-		case 2:
-			// Language\\Interface.g3:1:20: OPTIONAL
-			{
-			mOPTIONAL();
-
-			}
-			break;
-		case 3:
-			// Language\\Interface.g3:1:29: ID
-			{
-			mID();
-
-			}
-			break;
-		case 4:
-			// Language\\Interface.g3:1:32: LPAREN
-			{
-			mLPAREN();
-
-			}
-			break;
-		case 5:
-			// Language\\Interface.g3:1:39: RPAREN
-			{
-			mRPAREN();
-
-			}
-			break;
-		case 6:
-			// Language\\Interface.g3:1:46: COMMA
-			{
-			mCOMMA();
-
-			}
-			break;
-		case 7:
-			// Language\\Interface.g3:1:52: SEMI
-			{
-			mSEMI();
-
-			}
-			break;
-		case 8:
-			// Language\\Interface.g3:1:57: COLON
-			{
-			mCOLON();
-
-			}
-			break;
-		case 9:
-			// Language\\Interface.g3:1:63: SL_COMMENT
-			{
-			mSL_COMMENT();
-
-			}
-			break;
-		case 10:
-			// Language\\Interface.g3:1:74: ML_COMMENT
-			{
-			mML_COMMENT();
-
-			}
-			break;
-		case 11:
-			// Language\\Interface.g3:1:85: WS
-			{
-			mWS();
-
-			}
-			break;
-
-		}
-
-	}
-
-
-	#region DFA
-	DFA8 dfa8;
-
-	protected override void InitDFAs()
-	{
-		base.InitDFAs();
-		dfa8 = new DFA8( this );
-	}
-
-	class DFA8 : DFA
-	{
-
-		const string DFA8_eotS =
-			"\x1\xFFFF\x2\x3\x8\xFFFF\x2\x3\x2\xFFFF\xB\x3\x1\x1C\x1\x1D\x2\xFFFF";
-		const string DFA8_eofS =
-			"\x1E\xFFFF";
-		const string DFA8_minS =
-			"\x1\x9\x1\x6E\x1\x70\x6\xFFFF\x1\x2A\x1\xFFFF\x2\x74\x2\xFFFF\x1\x65"+
-			"\x1\x69\x1\x72\x1\x6F\x1\x66\x1\x6E\x2\x61\x1\x63\x1\x6C\x1\x65\x2\x2D"+
-			"\x2\xFFFF";
-		const string DFA8_maxS =
-			"\x1\x7A\x1\x6E\x1\x70\x6\xFFFF\x1\x2F\x1\xFFFF\x2\x74\x2\xFFFF\x1\x65"+
-			"\x1\x69\x1\x72\x1\x6F\x1\x66\x1\x6E\x2\x61\x1\x63\x1\x6C\x1\x65\x2\x7A"+
-			"\x2\xFFFF";
-		const string DFA8_acceptS =
-			"\x3\xFFFF\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1\xFFFF\x1\xB\x2\xFFFF"+
-			"\x1\x9\x1\xA\xD\xFFFF\x1\x2\x1\x1";
-		const string DFA8_specialS =
-			"\x1E\xFFFF}>";
-		static readonly string[] DFA8_transitionS =
-			{
-				"\x2\xA\x1\xFFFF\x2\xA\x12\xFFFF\x1\xA\x7\xFFFF\x1\x4\x1\x5\x2\xFFFF"+
-				"\x1\x6\x2\xFFFF\x1\x9\xA\xFFFF\x1\x8\x1\x7\x5\xFFFF\x1A\x3\x4\xFFFF"+
-				"\x1\x3\x1\xFFFF\x8\x3\x1\x1\x5\x3\x1\x2\xB\x3",
-				"\x1\xB",
-				"\x1\xC",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"\x1\xE\x4\xFFFF\x1\xD",
-				"",
-				"\x1\xF",
-				"\x1\x10",
-				"",
-				"",
-				"\x1\x11",
-				"\x1\x12",
-				"\x1\x13",
-				"\x1\x14",
-				"\x1\x15",
-				"\x1\x16",
-				"\x1\x17",
-				"\x1\x18",
-				"\x1\x19",
-				"\x1\x1A",
-				"\x1\x1B",
-				"\x1\x3\x2\xFFFF\xA\x3\x7\xFFFF\x1A\x3\x4\xFFFF\x1\x3\x1\xFFFF\x1A\x3",
-				"\x1\x3\x2\xFFFF\xA\x3\x7\xFFFF\x1A\x3\x4\xFFFF\x1\x3\x1\xFFFF\x1A\x3",
-				"",
-				""
-			};
-
-		static readonly short[] DFA8_eot = DFA.UnpackEncodedString(DFA8_eotS);
-		static readonly short[] DFA8_eof = DFA.UnpackEncodedString(DFA8_eofS);
-		static readonly char[] DFA8_min = DFA.UnpackEncodedStringToUnsignedChars(DFA8_minS);
-		static readonly char[] DFA8_max = DFA.UnpackEncodedStringToUnsignedChars(DFA8_maxS);
-		static readonly short[] DFA8_accept = DFA.UnpackEncodedString(DFA8_acceptS);
-		static readonly short[] DFA8_special = DFA.UnpackEncodedString(DFA8_specialS);
-		static readonly short[][] DFA8_transition;
-
-		static DFA8()
-		{
-			int numStates = DFA8_transitionS.Length;
-			DFA8_transition = new short[numStates][];
-			for ( int i=0; i < numStates; i++ )
-			{
-				DFA8_transition[i] = DFA.UnpackEncodedString(DFA8_transitionS[i]);
-			}
-		}
-
-		public DFA8( BaseRecognizer recognizer )
-		{
-			this.recognizer = recognizer;
-			this.decisionNumber = 8;
-			this.eot = DFA8_eot;
-			this.eof = DFA8_eof;
-			this.min = DFA8_min;
-			this.max = DFA8_max;
-			this.accept = DFA8_accept;
-			this.special = DFA8_special;
-			this.transition = DFA8_transition;
-		}
-		public override string GetDescription()
-		{
-			return "1:0: Tokens : ( INTERFACE | OPTIONAL | ID | LPAREN | RPAREN | COMMA | SEMI | COLON | SL_COMMENT | ML_COMMENT | WS );";
-		}
-	}
-
-
-	#endregion
-
-}
-
-} // namespace Antlr3.ST.Language
diff --git a/Antlr3.StringTemplate/Language/InterfaceParser.cs b/Antlr3.StringTemplate/Language/InterfaceParser.cs
deleted file mode 100644
index 0a30630..0000000
--- a/Antlr3.StringTemplate/Language/InterfaceParser.cs
+++ /dev/null
@@ -1,342 +0,0 @@
-// $ANTLR 3.1.2 Language\\Interface.g3 2009-09-30 13:27:17
-
-// The variable 'variable' is assigned but its value is never used.
-#pragma warning disable 219
-// Unreachable code detected.
-#pragma warning disable 162
-
-
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Grammar conversion to ANTLR v3 and C#:
- Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-	notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-	derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-
-using System.Collections.Generic;
-using Antlr.Runtime;
-using Stack = System.Collections.Generic.Stack<object>;
-using List = System.Collections.IList;
-using ArrayList = System.Collections.Generic.List<object>;
-
-namespace Antlr3.ST.Language
-{
-[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.1.2")]
-[System.CLSCompliant(false)]
-public partial class InterfaceParser : Parser
-{
-	internal static readonly string[] tokenNames = new string[] {
-		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "COLON", "COMMA", "ID", "INTERFACE", "LPAREN", "ML_COMMENT", "OPTIONAL", "RPAREN", "SEMI", "SL_COMMENT", "WS"
-	};
-	public const int EOF=-1;
-	public const int COLON=4;
-	public const int COMMA=5;
-	public const int ID=6;
-	public const int INTERFACE=7;
-	public const int LPAREN=8;
-	public const int ML_COMMENT=9;
-	public const int OPTIONAL=10;
-	public const int RPAREN=11;
-	public const int SEMI=12;
-	public const int SL_COMMENT=13;
-	public const int WS=14;
-
-	// delegates
-	// delegators
-
-	public InterfaceParser( ITokenStream input )
-		: this( input, new RecognizerSharedState() )
-	{
-	}
-	public InterfaceParser( ITokenStream input, RecognizerSharedState state )
-		: base( input, state )
-	{
-	}
-
-
-	public override string[] TokenNames { get { return InterfaceParser.tokenNames; } }
-	public override string GrammarFileName { get { return "Language\\Interface.g3"; } }
-
-
-	#region Rules
-
-	// $ANTLR start "groupInterface"
-	// Language\\Interface.g3:119:0: public groupInterface[StringTemplateGroupInterface groupI] : 'interface' name= ID SEMI ( template[groupI] )+ EOF ;
-	public void groupInterface( StringTemplateGroupInterface groupI )
-	{
-		IToken name=null;
-
-
-			this.groupI = groupI;
-
-		try
-		{
-			// Language\\Interface.g3:124:4: ( 'interface' name= ID SEMI ( template[groupI] )+ EOF )
-			// Language\\Interface.g3:124:4: 'interface' name= ID SEMI ( template[groupI] )+ EOF
-			{
-			Match(input,INTERFACE,Follow._INTERFACE_in_groupInterface88);
-			name=(IToken)Match(input,ID,Follow._ID_in_groupInterface92);
-			groupI.Name = (name!=null?name.Text:null);
-			Match(input,SEMI,Follow._SEMI_in_groupInterface96);
-			// Language\\Interface.g3:125:3: ( template[groupI] )+
-			int cnt1=0;
-			for ( ; ; )
-			{
-				int alt1=2;
-				int LA1_0 = input.LA(1);
-
-				if ( (LA1_0==ID||LA1_0==OPTIONAL) )
-				{
-					alt1=1;
-				}
-
-
-				switch ( alt1 )
-				{
-				case 1:
-					// Language\\Interface.g3:125:5: template[groupI]
-					{
-					PushFollow(Follow._template_in_groupInterface102);
-					template(groupI);
-
-					state._fsp--;
-
-
-					}
-					break;
-
-				default:
-					if ( cnt1 >= 1 )
-						goto loop1;
-
-					EarlyExitException eee1 = new EarlyExitException( 1, input );
-					throw eee1;
-				}
-				cnt1++;
-			}
-			loop1:
-				;
-
-
-			Match(input,EOF,Follow._EOF_in_groupInterface110);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "groupInterface"
-
-
-	// $ANTLR start "template"
-	// Language\\Interface.g3:130:0: template[StringTemplateGroupInterface groupI] : (opt= 'optional' )? name= ID LPAREN (formalArgs= args )? RPAREN SEMI ;
-	private void template( StringTemplateGroupInterface groupI )
-	{
-		IToken opt=null;
-		IToken name=null;
-		System.Collections.Generic.SortedList<string, FormalArgument> formalArgs = default(System.Collections.Generic.SortedList<string, FormalArgument>);
-
-
-			string templateName = null;
-
-		try
-		{
-			// Language\\Interface.g3:135:4: ( (opt= 'optional' )? name= ID LPAREN (formalArgs= args )? RPAREN SEMI )
-			// Language\\Interface.g3:135:4: (opt= 'optional' )? name= ID LPAREN (formalArgs= args )? RPAREN SEMI
-			{
-			// Language\\Interface.g3:135:4: (opt= 'optional' )?
-			int alt2=2;
-			int LA2_0 = input.LA(1);
-
-			if ( (LA2_0==OPTIONAL) )
-			{
-				alt2=1;
-			}
-			switch ( alt2 )
-			{
-			case 1:
-				// Language\\Interface.g3:135:5: opt= 'optional'
-				{
-				opt=(IToken)Match(input,OPTIONAL,Follow._OPTIONAL_in_template131);
-
-				}
-				break;
-
-			}
-
-			name=(IToken)Match(input,ID,Follow._ID_in_template137);
-			Match(input,LPAREN,Follow._LPAREN_in_template139);
-			// Language\\Interface.g3:135:37: (formalArgs= args )?
-			int alt3=2;
-			int LA3_0 = input.LA(1);
-
-			if ( (LA3_0==ID) )
-			{
-				alt3=1;
-			}
-			switch ( alt3 )
-			{
-			case 1:
-				// Language\\Interface.g3:135:38: formalArgs= args
-				{
-				PushFollow(Follow._args_in_template144);
-				formalArgs=args();
-
-				state._fsp--;
-
-
-				}
-				break;
-
-			}
-
-			Match(input,RPAREN,Follow._RPAREN_in_template148);
-			Match(input,SEMI,Follow._SEMI_in_template150);
-
-						templateName = (name!=null?name.Text:null);
-						groupI.DefineTemplate( templateName, formalArgs ?? new System.Collections.Generic.SortedList<string, FormalArgument>(), opt!=null );
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "template"
-
-
-	// $ANTLR start "args"
-	// Language\\Interface.g3:142:0: args returns [System.Collections.Generic.SortedList<string, FormalArgument> args] : a= ID ( COMMA b= ID )* ;
-	private System.Collections.Generic.SortedList<string, FormalArgument> args(  )
-	{
-		System.Collections.Generic.SortedList<string, FormalArgument> args = default(System.Collections.Generic.SortedList<string, FormalArgument>);
-
-		IToken a=null;
-		IToken b=null;
-
-
-			args = new System.Collections.Generic.SortedList<string, FormalArgument>();
-
-		try
-		{
-			// Language\\Interface.g3:147:4: (a= ID ( COMMA b= ID )* )
-			// Language\\Interface.g3:147:4: a= ID ( COMMA b= ID )*
-			{
-			a=(IToken)Match(input,ID,Follow._ID_in_args175);
-			args[(a!=null?a.Text:null)] = new FormalArgument((a!=null?a.Text:null));
-			// Language\\Interface.g3:148:3: ( COMMA b= ID )*
-			for ( ; ; )
-			{
-				int alt4=2;
-				int LA4_0 = input.LA(1);
-
-				if ( (LA4_0==COMMA) )
-				{
-					alt4=1;
-				}
-
-
-				switch ( alt4 )
-				{
-				case 1:
-					// Language\\Interface.g3:148:5: COMMA b= ID
-					{
-					Match(input,COMMA,Follow._COMMA_in_args183);
-					b=(IToken)Match(input,ID,Follow._ID_in_args187);
-					args[(b!=null?b.Text:null)] = new FormalArgument((b!=null?b.Text:null));
-
-					}
-					break;
-
-				default:
-					goto loop4;
-				}
-			}
-
-			loop4:
-				;
-
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return args;
-	}
-	// $ANTLR end "args"
-	#endregion Rules
-
-
-	#region Follow sets
-	private static class Follow
-	{
-		public static readonly BitSet _INTERFACE_in_groupInterface88 = new BitSet(new ulong[]{0x40UL});
-		public static readonly BitSet _ID_in_groupInterface92 = new BitSet(new ulong[]{0x1000UL});
-		public static readonly BitSet _SEMI_in_groupInterface96 = new BitSet(new ulong[]{0x440UL});
-		public static readonly BitSet _template_in_groupInterface102 = new BitSet(new ulong[]{0x440UL});
-		public static readonly BitSet _EOF_in_groupInterface110 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _OPTIONAL_in_template131 = new BitSet(new ulong[]{0x40UL});
-		public static readonly BitSet _ID_in_template137 = new BitSet(new ulong[]{0x100UL});
-		public static readonly BitSet _LPAREN_in_template139 = new BitSet(new ulong[]{0x840UL});
-		public static readonly BitSet _args_in_template144 = new BitSet(new ulong[]{0x800UL});
-		public static readonly BitSet _RPAREN_in_template148 = new BitSet(new ulong[]{0x1000UL});
-		public static readonly BitSet _SEMI_in_template150 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ID_in_args175 = new BitSet(new ulong[]{0x22UL});
-		public static readonly BitSet _COMMA_in_args183 = new BitSet(new ulong[]{0x40UL});
-		public static readonly BitSet _ID_in_args187 = new BitSet(new ulong[]{0x22UL});
-
-	}
-	#endregion Follow sets
-}
-
-} // namespace Antlr3.ST.Language
diff --git a/Antlr3.StringTemplate/Language/TemplateLexer.cs b/Antlr3.StringTemplate/Language/TemplateLexer.cs
deleted file mode 100644
index 186287b..0000000
--- a/Antlr3.StringTemplate/Language/TemplateLexer.cs
+++ /dev/null
@@ -1,3462 +0,0 @@
-// $ANTLR 3.1.2 Language\\Template.g3 2009-09-30 13:26:49
-
-// The variable 'variable' is assigned but its value is never used.
-#pragma warning disable 219
-// Unreachable code detected.
-#pragma warning disable 162
-
-
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Grammar conversion to ANTLR v3 and C#:
- Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-	notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-	derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-
-using System.Collections.Generic;
-using Antlr.Runtime;
-using Stack = System.Collections.Generic.Stack<object>;
-using List = System.Collections.IList;
-using ArrayList = System.Collections.Generic.List<object>;
-using Map = System.Collections.IDictionary;
-using HashMap = System.Collections.Generic.Dictionary<object, object>;
-namespace Antlr3.ST.Language
-{
-[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.1.2")]
-[System.CLSCompliant(false)]
-public partial class TemplateLexer : Lexer
-{
-	public const int EOF=-1;
-	public const int ACTION=4;
-	public const int COMMENT=5;
-	public const int ELSE=6;
-	public const int ELSEIF=7;
-	public const int ENDIF=8;
-	public const int ESC=9;
-	public const int ESC_CHAR=10;
-	public const int EXPR=11;
-	public const int HEX=12;
-	public const int IF=13;
-	public const int IF_EXPR=14;
-	public const int INDENT=15;
-	public const int LINE_BREAK=16;
-	public const int LITERAL=17;
-	public const int NESTED_PARENS=18;
-	public const int NEWLINE=19;
-	public const int REGION_DEF=20;
-	public const int REGION_REF=21;
-	public const int SUBTEMPLATE=22;
-	public const int TEMPLATE=23;
-
-    // delegates
-    // delegators
-
-	public TemplateLexer() {}
-	public TemplateLexer( ICharStream input )
-		: this( input, new RecognizerSharedState() )
-	{
-	}
-	public TemplateLexer( ICharStream input, RecognizerSharedState state )
-		: base( input, state )
-	{
-
-	}
-	public override string GrammarFileName { get { return "Language\\Template.g3"; } }
-
-	// $ANTLR start "IF"
-	private void mIF()
-	{
-		try
-		{
-			// Language\\Template.g3:258:15: ()
-			// Language\\Template.g3:258:15:
-			{
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "IF"
-
-	// $ANTLR start "ELSEIF"
-	private void mELSEIF()
-	{
-		try
-		{
-			// Language\\Template.g3:259:19: ()
-			// Language\\Template.g3:259:19:
-			{
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ELSEIF"
-
-	// $ANTLR start "ELSE"
-	private void mELSE()
-	{
-		try
-		{
-			// Language\\Template.g3:260:17: ()
-			// Language\\Template.g3:260:17:
-			{
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ELSE"
-
-	// $ANTLR start "ENDIF"
-	private void mENDIF()
-	{
-		try
-		{
-			// Language\\Template.g3:261:18: ()
-			// Language\\Template.g3:261:18:
-			{
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ENDIF"
-
-	// $ANTLR start "REGION_DEF"
-	private void mREGION_DEF()
-	{
-		try
-		{
-			// Language\\Template.g3:262:23: ()
-			// Language\\Template.g3:262:23:
-			{
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "REGION_DEF"
-
-	// $ANTLR start "REGION_REF"
-	private void mREGION_REF()
-	{
-		try
-		{
-			// Language\\Template.g3:263:23: ()
-			// Language\\Template.g3:263:23:
-			{
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "REGION_REF"
-
-	// $ANTLR start "NEWLINE"
-	private void mNEWLINE()
-	{
-		try
-		{
-			int _type = NEWLINE;
-			int _channel = DefaultTokenChannel;
-			// Language\\Template.g3:266:4: ( ( '\\r' )? '\\n' )
-			// Language\\Template.g3:266:4: ( '\\r' )? '\\n'
-			{
-			// Language\\Template.g3:266:4: ( '\\r' )?
-			int alt1=2;
-			int LA1_0 = input.LA(1);
-
-			if ( (LA1_0=='\r') )
-			{
-				alt1=1;
-			}
-			switch ( alt1 )
-			{
-			case 1:
-				// Language\\Template.g3:266:5: '\\r'
-				{
-				Match('\r'); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-			Match('\n'); if (state.failed) return ;
-			if ( state.backtracking == 0 )
-			{
-				currentIndent=null;
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "NEWLINE"
-
-	// $ANTLR start "ACTION"
-	private void mACTION()
-	{
-		try
-		{
-			int _type = ACTION;
-			int _channel = DefaultTokenChannel;
-			CommonToken exp=null;
-			int ch;
-
-
-				int startCol = CharPositionInLine;
-				System.Text.StringBuilder builder = new System.Text.StringBuilder();
-				System.Text.StringBuilder buf = null;
-				string subtext = string.Empty;
-				char uc = '\0';
-				bool atLeft = false;
-				string t = null;
-
-			// Language\\Template.g3:280:4: ( ( options {k=1; } :=> LINE_BREAK |=> '$' ( ESC_CHAR[out uc] )+ '$' |=> COMMENT | (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' ) ) )
-			// Language\\Template.g3:280:4: ( options {k=1; } :=> LINE_BREAK |=> '$' ( ESC_CHAR[out uc] )+ '$' |=> COMMENT | (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' ) )
-			{
-			// Language\\Template.g3:280:4: ( options {k=1; } :=> LINE_BREAK |=> '$' ( ESC_CHAR[out uc] )+ '$' |=> COMMENT | (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' ) )
-			int alt26=4;
-			int LA26_0 = input.LA(1);
-
-			if ( (LA26_0=='$') )
-			{
-				int LA26_1 = input.LA(2);
-
-				if ( (EvaluatePredicate(synpred1_Template_fragment)) )
-				{
-					alt26=1;
-				}
-				else if ( (EvaluatePredicate(synpred2_Template_fragment)) )
-				{
-					alt26=2;
-				}
-				else if ( (EvaluatePredicate(synpred3_Template_fragment)) )
-				{
-					alt26=3;
-				}
-				else if ( (true) )
-				{
-					alt26=4;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					NoViableAltException nvae = new NoViableAltException("", 26, 1, input);
-
-					throw nvae;
-				}
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				NoViableAltException nvae = new NoViableAltException("", 26, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt26 )
-			{
-			case 1:
-				// Language\\Template.g3:281:4: => LINE_BREAK
-				{
-
-				mLINE_BREAK(); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-					_channel = Hidden;
-				}
-
-				}
-				break;
-			case 2:
-				// Language\\Template.g3:282:5: => '$' ( ESC_CHAR[out uc] )+ '$'
-				{
-
-				Match('$'); if (state.failed) return ;
-				// Language\\Template.g3:284:8: ( ESC_CHAR[out uc] )+
-				int cnt2=0;
-				for ( ; ; )
-				{
-					int alt2=2;
-					int LA2_0 = input.LA(1);
-
-					if ( (LA2_0=='\\') )
-					{
-						alt2=1;
-					}
-
-
-					switch ( alt2 )
-					{
-					case 1:
-						// Language\\Template.g3:284:9: ESC_CHAR[out uc]
-						{
-						mESC_CHAR(out uc); if (state.failed) return ;
-						if ( state.backtracking == 0 )
-						{
-							builder.Append(uc);
-						}
-
-						}
-						break;
-
-					default:
-						if ( cnt2 >= 1 )
-							goto loop2;
-
-						if (state.backtracking>0) {state.failed=true; return ;}
-						EarlyExitException eee2 = new EarlyExitException( 2, input );
-						throw eee2;
-					}
-					cnt2++;
-				}
-				loop2:
-					;
-
-
-				Match('$'); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-
-									Text = builder.ToString();
-									_type = LITERAL;
-
-				}
-
-				}
-				break;
-			case 3:
-				// Language\\Template.g3:289:5: => COMMENT
-				{
-
-				mCOMMENT(); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-					 _channel = Hidden;
-				}
-
-				}
-				break;
-			case 4:
-				// Language\\Template.g3:291:5: (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' )
-				{
-				// Language\\Template.g3:291:5: (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' )
-				int alt25=6;
-				int LA25_0 = input.LA(1);
-
-				if ( (LA25_0=='$') )
-				{
-					int LA25_1 = input.LA(2);
-
-					if ( (EvaluatePredicate(synpred4_Template_fragment)) )
-					{
-						alt25=1;
-					}
-					else if ( (EvaluatePredicate(synpred5_Template_fragment)) )
-					{
-						alt25=2;
-					}
-					else if ( (EvaluatePredicate(synpred6_Template_fragment)) )
-					{
-						alt25=3;
-					}
-					else if ( (EvaluatePredicate(synpred7_Template_fragment)) )
-					{
-						alt25=4;
-					}
-					else if ( (EvaluatePredicate(synpred8_Template_fragment)) )
-					{
-						alt25=5;
-					}
-					else if ( (true) )
-					{
-						alt25=6;
-					}
-					else
-					{
-						if (state.backtracking>0) {state.failed=true; return ;}
-						NoViableAltException nvae = new NoViableAltException("", 25, 1, input);
-
-						throw nvae;
-					}
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					NoViableAltException nvae = new NoViableAltException("", 25, 0, input);
-
-					throw nvae;
-				}
-				switch ( alt25 )
-				{
-				case 1:
-					// Language\\Template.g3:291:7: => '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )?
-					{
-
-					Match("$if"); if (state.failed) return ;
-
-					// Language\\Template.g3:292:11: ( ' ' )*
-					for ( ; ; )
-					{
-						int alt3=2;
-						int LA3_0 = input.LA(1);
-
-						if ( (LA3_0==' ') )
-						{
-							alt3=1;
-						}
-
-
-						switch ( alt3 )
-						{
-						case 1:
-							// Language\\Template.g3:292:12: ' '
-							{
-							Match(' '); if (state.failed) return ;
-
-							}
-							break;
-
-						default:
-							goto loop3;
-						}
-					}
-
-					loop3:
-						;
-
-
-					Match('('); if (state.failed) return ;
-					int expStart220 = CharIndex;
-					mIF_EXPR(); if (state.failed) return ;
-					exp = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, expStart220, CharIndex-1);
-					Match(")$"); if (state.failed) return ;
-
-					if ( state.backtracking == 0 )
-					{
-
-											Text = "if(" + (exp!=null?exp.Text:null) + ")";
-											_type = TemplateParser.IF;
-
-					}
-					// Language\\Template.g3:297:5: ( ( '\\r' )? '\\n' )?
-					int alt5=2;
-					int LA5_0 = input.LA(1);
-
-					if ( (LA5_0=='\n'||LA5_0=='\r') )
-					{
-						alt5=1;
-					}
-					switch ( alt5 )
-					{
-					case 1:
-						// Language\\Template.g3:297:7: ( '\\r' )? '\\n'
-						{
-						// Language\\Template.g3:297:7: ( '\\r' )?
-						int alt4=2;
-						int LA4_0 = input.LA(1);
-
-						if ( (LA4_0=='\r') )
-						{
-							alt4=1;
-						}
-						switch ( alt4 )
-						{
-						case 1:
-							// Language\\Template.g3:297:8: '\\r'
-							{
-							Match('\r'); if (state.failed) return ;
-
-							}
-							break;
-
-						}
-
-						Match('\n'); if (state.failed) return ;
-
-						}
-						break;
-
-					}
-
-
-					}
-					break;
-				case 2:
-					// Language\\Template.g3:298:6: => '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )?
-					{
-
-					Match("$elseif"); if (state.failed) return ;
-
-					// Language\\Template.g3:299:15: ( ' ' )*
-					for ( ; ; )
-					{
-						int alt6=2;
-						int LA6_0 = input.LA(1);
-
-						if ( (LA6_0==' ') )
-						{
-							alt6=1;
-						}
-
-
-						switch ( alt6 )
-						{
-						case 1:
-							// Language\\Template.g3:299:16: ' '
-							{
-							Match(' '); if (state.failed) return ;
-
-							}
-							break;
-
-						default:
-							goto loop6;
-						}
-					}
-
-					loop6:
-						;
-
-
-					Match('('); if (state.failed) return ;
-					int expStart279 = CharIndex;
-					mIF_EXPR(); if (state.failed) return ;
-					exp = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, expStart279, CharIndex-1);
-					Match(")$"); if (state.failed) return ;
-
-					if ( state.backtracking == 0 )
-					{
-
-											Text = "elseif(" + (exp!=null?exp.Text:null) + ")";
-											_type = TemplateParser.ELSEIF;
-
-					}
-					// Language\\Template.g3:304:5: ( ( '\\r' )? '\\n' )?
-					int alt8=2;
-					int LA8_0 = input.LA(1);
-
-					if ( (LA8_0=='\n'||LA8_0=='\r') )
-					{
-						alt8=1;
-					}
-					switch ( alt8 )
-					{
-					case 1:
-						// Language\\Template.g3:304:7: ( '\\r' )? '\\n'
-						{
-						// Language\\Template.g3:304:7: ( '\\r' )?
-						int alt7=2;
-						int LA7_0 = input.LA(1);
-
-						if ( (LA7_0=='\r') )
-						{
-							alt7=1;
-						}
-						switch ( alt7 )
-						{
-						case 1:
-							// Language\\Template.g3:304:8: '\\r'
-							{
-							Match('\r'); if (state.failed) return ;
-
-							}
-							break;
-
-						}
-
-						Match('\n'); if (state.failed) return ;
-
-						}
-						break;
-
-					}
-
-
-					}
-					break;
-				case 3:
-					// Language\\Template.g3:305:6: => '$else$' ( ( '\\r' )? '\\n' )?
-					{
-
-					Match("$else$"); if (state.failed) return ;
-
-					if ( state.backtracking == 0 )
-					{
-
-											Text = "else";
-											_type = (TemplateParser.ELSE);
-
-					}
-					// Language\\Template.g3:311:5: ( ( '\\r' )? '\\n' )?
-					int alt10=2;
-					int LA10_0 = input.LA(1);
-
-					if ( (LA10_0=='\n'||LA10_0=='\r') )
-					{
-						alt10=1;
-					}
-					switch ( alt10 )
-					{
-					case 1:
-						// Language\\Template.g3:311:7: ( '\\r' )? '\\n'
-						{
-						// Language\\Template.g3:311:7: ( '\\r' )?
-						int alt9=2;
-						int LA9_0 = input.LA(1);
-
-						if ( (LA9_0=='\r') )
-						{
-							alt9=1;
-						}
-						switch ( alt9 )
-						{
-						case 1:
-							// Language\\Template.g3:311:8: '\\r'
-							{
-							Match('\r'); if (state.failed) return ;
-
-							}
-							break;
-
-						}
-
-						Match('\n'); if (state.failed) return ;
-
-						}
-						break;
-
-					}
-
-
-					}
-					break;
-				case 4:
-					// Language\\Template.g3:312:6: => '$endif$' ({...}? => ( '\\r' )? '\\n' )?
-					{
-
-					Match("$endif$"); if (state.failed) return ;
-
-					if ( state.backtracking == 0 )
-					{
-
-											Text = "endif";
-											_type = TemplateParser.ENDIF;
-
-					}
-					// Language\\Template.g3:318:5: ({...}? => ( '\\r' )? '\\n' )?
-					int alt12=2;
-					int LA12_0 = input.LA(1);
-
-					if ( (LA12_0=='\n'||LA12_0=='\r') && ((startCol==0)))
-					{
-						alt12=1;
-					}
-					switch ( alt12 )
-					{
-					case 1:
-						// Language\\Template.g3:318:7: {...}? => ( '\\r' )? '\\n'
-						{
-						if ( !((startCol==0)) )
-						{
-							if (state.backtracking>0) {state.failed=true; return ;}
-							throw new FailedPredicateException(input, "ACTION", "startCol==0");
-						}
-						// Language\\Template.g3:318:25: ( '\\r' )?
-						int alt11=2;
-						int LA11_0 = input.LA(1);
-
-						if ( (LA11_0=='\r') )
-						{
-							alt11=1;
-						}
-						switch ( alt11 )
-						{
-						case 1:
-							// Language\\Template.g3:318:26: '\\r'
-							{
-							Match('\r'); if (state.failed) return ;
-
-							}
-							break;
-
-						}
-
-						Match('\n'); if (state.failed) return ;
-
-						}
-						break;
-
-					}
-
-
-					}
-					break;
-				case 5:
-					// Language\\Template.g3:322:5: => '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? )
-					{
-
-					if ( state.backtracking == 0 )
-					{
-
-											builder = new System.Text.StringBuilder();
-
-					}
-					Match("$@"); if (state.failed) return ;
-
-					// Language\\Template.g3:326:10: (ch=~ ( '$' | '(' ) )+
-					int cnt13=0;
-					for ( ; ; )
-					{
-						int alt13=2;
-						int LA13_0 = input.LA(1);
-
-						if ( ((LA13_0>='\u0000' && LA13_0<='#')||(LA13_0>='%' && LA13_0<='\'')||(LA13_0>=')' && LA13_0<='\uFFFF')) )
-						{
-							alt13=1;
-						}
-
-
-						switch ( alt13 )
-						{
-						case 1:
-							// Language\\Template.g3:326:12: ch=~ ( '$' | '(' )
-							{
-							ch= input.LA(1);
-							input.Consume();
-							state.failed=false;
-							if ( state.backtracking == 0 )
-							{
-								builder.Append((char)ch);
-							}
-
-							}
-							break;
-
-						default:
-							if ( cnt13 >= 1 )
-								goto loop13;
-
-							if (state.backtracking>0) {state.failed=true; return ;}
-							EarlyExitException eee13 = new EarlyExitException( 13, input );
-							throw eee13;
-						}
-						cnt13++;
-					}
-					loop13:
-						;
-
-
-					if ( state.backtracking == 0 )
-					{
-						 t = builder.ToString();
-					}
-					// Language\\Template.g3:328:5: ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? )
-					int alt24=2;
-					int LA24_0 = input.LA(1);
-
-					if ( (LA24_0=='(') )
-					{
-						alt24=1;
-					}
-					else if ( (LA24_0=='$') )
-					{
-						alt24=2;
-					}
-					else
-					{
-						if (state.backtracking>0) {state.failed=true; return ;}
-						NoViableAltException nvae = new NoViableAltException("", 24, 0, input);
-
-						throw nvae;
-					}
-					switch ( alt24 )
-					{
-					case 1:
-						// Language\\Template.g3:328:7: '()$'
-						{
-						Match("()$"); if (state.failed) return ;
-
-						if ( state.backtracking == 0 )
-						{
-
-													_type = TemplateParser.REGION_REF;
-
-						}
-
-						}
-						break;
-					case 2:
-						// Language\\Template.g3:332:7: '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )?
-						{
-						Match('$'); if (state.failed) return ;
-						if ( state.backtracking == 0 )
-						{
-
-													_type = TemplateParser.REGION_DEF;
-													builder.Append("::=");
-
-						}
-						// Language\\Template.g3:337:6: (=> ( '\\r' )? '\\n' )?
-						int alt15=2;
-						int LA15_0 = input.LA(1);
-
-						if ( (LA15_0=='\r') )
-						{
-							int LA15_1 = input.LA(2);
-
-							if ( (LA15_1=='\n') )
-							{
-								int LA15_4 = input.LA(3);
-
-								if ( (EvaluatePredicate(synpred9_Template_fragment)) )
-								{
-									alt15=1;
-								}
-							}
-						}
-						else if ( (LA15_0=='\n') )
-						{
-							int LA15_2 = input.LA(2);
-
-							if ( (EvaluatePredicate(synpred9_Template_fragment)) )
-							{
-								alt15=1;
-							}
-						}
-						switch ( alt15 )
-						{
-						case 1:
-							// Language\\Template.g3:337:8: => ( '\\r' )? '\\n'
-							{
-
-							// Language\\Template.g3:337:23: ( '\\r' )?
-							int alt14=2;
-							int LA14_0 = input.LA(1);
-
-							if ( (LA14_0=='\r') )
-							{
-								alt14=1;
-							}
-							switch ( alt14 )
-							{
-							case 1:
-								// Language\\Template.g3:337:24: '\\r'
-								{
-								Match('\r'); if (state.failed) return ;
-
-								}
-								break;
-
-							}
-
-							Match('\n'); if (state.failed) return ;
-
-							}
-							break;
-
-						}
-
-						if ( state.backtracking == 0 )
-						{
-							atLeft = false;
-						}
-						// Language\\Template.g3:339:6: ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+
-						int cnt18=0;
-						for ( ; ; )
-						{
-							int alt18=2;
-							alt18 = dfa18.Predict(input);
-							switch ( alt18 )
-							{
-							case 1:
-								// Language\\Template.g3:339:8: {...}? => (=> ( '\\r' )? '\\n' |ch= . )
-								{
-								if ( !((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))) )
-								{
-									if (state.backtracking>0) {state.failed=true; return ;}
-									throw new FailedPredicateException(input, "ACTION", "!(UpcomingAtEND(1) || ( input.LA(1) == '\\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\\r' && input.LA(2) == '\\n' && UpcomingAtEND(3) ))");
-								}
-								// Language\\Template.g3:340:7: (=> ( '\\r' )? '\\n' |ch= . )
-								int alt17=2;
-								int LA17_0 = input.LA(1);
-
-								if ( (LA17_0=='\r') )
-								{
-									int LA17_1 = input.LA(2);
-
-									if ( (EvaluatePredicate(synpred10_Template_fragment)) )
-									{
-										alt17=1;
-									}
-									else if ( (true) )
-									{
-										alt17=2;
-									}
-									else
-									{
-										if (state.backtracking>0) {state.failed=true; return ;}
-										NoViableAltException nvae = new NoViableAltException("", 17, 1, input);
-
-										throw nvae;
-									}
-								}
-								else if ( (LA17_0=='\n') )
-								{
-									int LA17_2 = input.LA(2);
-
-									if ( (EvaluatePredicate(synpred10_Template_fragment)) )
-									{
-										alt17=1;
-									}
-									else if ( (true) )
-									{
-										alt17=2;
-									}
-									else
-									{
-										if (state.backtracking>0) {state.failed=true; return ;}
-										NoViableAltException nvae = new NoViableAltException("", 17, 2, input);
-
-										throw nvae;
-									}
-								}
-								else if ( ((LA17_0>='\u0000' && LA17_0<='\t')||(LA17_0>='\u000B' && LA17_0<='\f')||(LA17_0>='\u000E' && LA17_0<='\uFFFF')) )
-								{
-									alt17=2;
-								}
-								else
-								{
-									if (state.backtracking>0) {state.failed=true; return ;}
-									NoViableAltException nvae = new NoViableAltException("", 17, 0, input);
-
-									throw nvae;
-								}
-								switch ( alt17 )
-								{
-								case 1:
-									// Language\\Template.g3:340:9: => ( '\\r' )? '\\n'
-									{
-
-									// Language\\Template.g3:340:24: ( '\\r' )?
-									int alt16=2;
-									int LA16_0 = input.LA(1);
-
-									if ( (LA16_0=='\r') )
-									{
-										alt16=1;
-									}
-									switch ( alt16 )
-									{
-									case 1:
-										// Language\\Template.g3:340:25: '\\r'
-										{
-										Match('\r'); if (state.failed) return ;
-										if ( state.backtracking == 0 )
-										{
-											builder.Append('\r');
-										}
-
-										}
-										break;
-
-									}
-
-									Match('\n'); if (state.failed) return ;
-									if ( state.backtracking == 0 )
-									{
-										builder.Append('\n'); atLeft = true;
-									}
-
-									}
-									break;
-								case 2:
-									// Language\\Template.g3:341:9: ch= .
-									{
-									ch = input.LA(1);
-									MatchAny(); if (state.failed) return ;
-									if ( state.backtracking == 0 )
-									{
-										builder.Append((char)ch); atLeft = false;
-									}
-
-									}
-									break;
-
-								}
-
-
-								}
-								break;
-
-							default:
-								if ( cnt18 >= 1 )
-									goto loop18;
-
-								if (state.backtracking>0) {state.failed=true; return ;}
-								EarlyExitException eee18 = new EarlyExitException( 18, input );
-								throw eee18;
-							}
-							cnt18++;
-						}
-						loop18:
-							;
-
-
-						// Language\\Template.g3:344:6: (=> ( '\\r' )? '\\n' )?
-						int alt20=2;
-						int LA20_0 = input.LA(1);
-
-						if ( (LA20_0=='\r') )
-						{
-							int LA20_1 = input.LA(2);
-
-							if ( (LA20_1=='\n') )
-							{
-								int LA20_4 = input.LA(3);
-
-								if ( (LA20_4=='$') && (EvaluatePredicate(synpred11_Template_fragment)))
-								{
-									alt20=1;
-								}
-								else if ( ((LA20_4>='\u0000' && LA20_4<='#')||(LA20_4>='%' && LA20_4<='\uFFFF')) && (EvaluatePredicate(synpred11_Template_fragment)))
-								{
-									alt20=1;
-								}
-							}
-						}
-						else if ( (LA20_0=='\n') )
-						{
-							int LA20_2 = input.LA(2);
-
-							if ( (LA20_2=='$') && (EvaluatePredicate(synpred11_Template_fragment)))
-							{
-								alt20=1;
-							}
-							else if ( (LA20_2=='\r') )
-							{
-								int LA20_6 = input.LA(3);
-
-								if ( (EvaluatePredicate(synpred11_Template_fragment)) )
-								{
-									alt20=1;
-								}
-							}
-							else if ( (LA20_2=='\n') )
-							{
-								int LA20_7 = input.LA(3);
-
-								if ( (EvaluatePredicate(synpred11_Template_fragment)) )
-								{
-									alt20=1;
-								}
-							}
-							else if ( ((LA20_2>='\u0000' && LA20_2<='\t')||(LA20_2>='\u000B' && LA20_2<='\f')||(LA20_2>='\u000E' && LA20_2<='#')||(LA20_2>='%' && LA20_2<='\uFFFF')) && (EvaluatePredicate(synpred11_Template_fragment)))
-							{
-								alt20=1;
-							}
-						}
-						switch ( alt20 )
-						{
-						case 1:
-							// Language\\Template.g3:344:8: => ( '\\r' )? '\\n'
-							{
-
-							// Language\\Template.g3:344:23: ( '\\r' )?
-							int alt19=2;
-							int LA19_0 = input.LA(1);
-
-							if ( (LA19_0=='\r') )
-							{
-								alt19=1;
-							}
-							switch ( alt19 )
-							{
-							case 1:
-								// Language\\Template.g3:344:24: '\\r'
-								{
-								Match('\r'); if (state.failed) return ;
-
-								}
-								break;
-
-							}
-
-							Match('\n'); if (state.failed) return ;
-							if ( state.backtracking == 0 )
-							{
-								atLeft = true;
-							}
-
-							}
-							break;
-
-						}
-
-						// Language\\Template.g3:345:6: (=> '$@end$' | . )
-						int alt21=2;
-						int LA21_0 = input.LA(1);
-
-						if ( (LA21_0=='$') )
-						{
-							int LA21_1 = input.LA(2);
-
-							if ( (LA21_1=='@') && (EvaluatePredicate(synpred12_Template_fragment)))
-							{
-								alt21=1;
-							}
-							else
-							{
-								alt21=2;}
-						}
-						else if ( ((LA21_0>='\u0000' && LA21_0<='#')||(LA21_0>='%' && LA21_0<='\uFFFF')) )
-						{
-							alt21=2;
-						}
-						else
-						{
-							if (state.backtracking>0) {state.failed=true; return ;}
-							NoViableAltException nvae = new NoViableAltException("", 21, 0, input);
-
-							throw nvae;
-						}
-						switch ( alt21 )
-						{
-						case 1:
-							// Language\\Template.g3:345:8: => '$@end$'
-							{
-
-							Match("$@end$"); if (state.failed) return ;
-
-
-							}
-							break;
-						case 2:
-							// Language\\Template.g3:346:8: .
-							{
-							MatchAny(); if (state.failed) return ;
-							if ( state.backtracking == 0 )
-							{
-								self.Error("missing region "+t+" $@end$ tag");
-							}
-
-							}
-							break;
-
-						}
-
-						// Language\\Template.g3:348:6: ({...}? ( '\\r' )? '\\n' )?
-						int alt23=2;
-						int LA23_0 = input.LA(1);
-
-						if ( (LA23_0=='\n'||LA23_0=='\r') )
-						{
-							alt23=1;
-						}
-						switch ( alt23 )
-						{
-						case 1:
-							// Language\\Template.g3:348:8: {...}? ( '\\r' )? '\\n'
-							{
-							if ( !((atLeft)) )
-							{
-								if (state.backtracking>0) {state.failed=true; return ;}
-								throw new FailedPredicateException(input, "ACTION", "atLeft");
-							}
-							// Language\\Template.g3:348:18: ( '\\r' )?
-							int alt22=2;
-							int LA22_0 = input.LA(1);
-
-							if ( (LA22_0=='\r') )
-							{
-								alt22=1;
-							}
-							switch ( alt22 )
-							{
-							case 1:
-								// Language\\Template.g3:348:19: '\\r'
-								{
-								Match('\r'); if (state.failed) return ;
-
-								}
-								break;
-
-							}
-
-							Match('\n'); if (state.failed) return ;
-
-							}
-							break;
-
-						}
-
-
-						}
-						break;
-
-					}
-
-					if ( state.backtracking == 0 )
-					{
-
-											Text = builder.ToString();
-
-					}
-
-					}
-					break;
-				case 6:
-					// Language\\Template.g3:353:6: '$' EXPR[out subtext] '$'
-					{
-					Match('$'); if (state.failed) return ;
-					mEXPR(out subtext); if (state.failed) return ;
-					Match('$'); if (state.failed) return ;
-					if ( state.backtracking == 0 )
-					{
-						 Text = subtext;
-					}
-
-					}
-					break;
-
-				}
-
-				if ( state.backtracking == 0 )
-				{
-
-									//ChunkToken t = new ChunkToken(_type, Text, currentIndent);
-									//state.token = t;
-									state.token = new ChunkToken(_type, Text, currentIndent);
-
-				}
-
-				}
-				break;
-
-			}
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ACTION"
-
-	// $ANTLR start "LITERAL"
-	private void mLITERAL()
-	{
-		try
-		{
-			int _type = LITERAL;
-			int _channel = DefaultTokenChannel;
-			CommonToken ind=null;
-			int ch;
-
-
-				int loopStartIndex = Text.Length;
-				int col = CharPositionInLine;
-				System.Text.StringBuilder builder = new System.Text.StringBuilder();
-
-			// Language\\Template.g3:371:4: ( ( '\\\\' (=> EOF | ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) ) ) |ind= INDENT |ch=~ ( '$' | '\\r' | '\\n' | '\\\\' | ' ' | '\\t' ) )+ )
-			// Language\\Template.g3:371:4: ( '\\\\' (=> EOF | ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) ) ) |ind= INDENT |ch=~ ( '$' | '\\r' | '\\n' | '\\\\' | ' ' | '\\t' ) )+
-			{
-			// Language\\Template.g3:371:4: ( '\\\\' (=> EOF | ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) ) ) |ind= INDENT |ch=~ ( '$' | '\\r' | '\\n' | '\\\\' | ' ' | '\\t' ) )+
-			int cnt29=0;
-			for ( ; ; )
-			{
-				int alt29=4;
-				int LA29_0 = input.LA(1);
-
-				if ( (LA29_0=='\\') )
-				{
-					alt29=1;
-				}
-				else if ( (LA29_0=='\t'||LA29_0==' ') )
-				{
-					alt29=2;
-				}
-				else if ( ((LA29_0>='\u0000' && LA29_0<='\b')||(LA29_0>='\u000B' && LA29_0<='\f')||(LA29_0>='\u000E' && LA29_0<='\u001F')||(LA29_0>='!' && LA29_0<='#')||(LA29_0>='%' && LA29_0<='[')||(LA29_0>=']' && LA29_0<='\uFFFF')) )
-				{
-					alt29=3;
-				}
-
-
-				switch ( alt29 )
-				{
-				case 1:
-					// Language\\Template.g3:371:6: '\\\\' (=> EOF | ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) ) )
-					{
-					Match('\\'); if (state.failed) return ;
-					// Language\\Template.g3:372:4: (=> EOF | ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) ) )
-					int alt28=2;
-					int LA28_0 = input.LA(1);
-
-					if ( (LA28_0=='\\') )
-					{
-						int LA28_2 = input.LA(2);
-
-						if ( (EvaluatePredicate(synpred13_Template_fragment)) )
-						{
-							alt28=1;
-						}
-						else if ( (true) )
-						{
-							alt28=2;
-						}
-						else
-						{
-							if (state.backtracking>0) {state.failed=true; return ;}
-							NoViableAltException nvae = new NoViableAltException("", 28, 2, input);
-
-							throw nvae;
-						}
-					}
-					else if ( (LA28_0=='\t'||LA28_0==' ') )
-					{
-						int LA28_3 = input.LA(2);
-
-						if ( (EvaluatePredicate(synpred13_Template_fragment)) )
-						{
-							alt28=1;
-						}
-						else if ( (true) )
-						{
-							alt28=2;
-						}
-						else
-						{
-							if (state.backtracking>0) {state.failed=true; return ;}
-							NoViableAltException nvae = new NoViableAltException("", 28, 3, input);
-
-							throw nvae;
-						}
-					}
-					else if ( ((LA28_0>='\u0000' && LA28_0<='\b')||(LA28_0>='\u000B' && LA28_0<='\f')||(LA28_0>='\u000E' && LA28_0<='\u001F')||(LA28_0>='!' && LA28_0<='#')||(LA28_0>='%' && LA28_0<='[')||(LA28_0>=']' && LA28_0<='\uFFFF')) )
-					{
-						int LA28_4 = input.LA(2);
-
-						if ( (EvaluatePredicate(synpred13_Template_fragment)) )
-						{
-							alt28=1;
-						}
-						else if ( (true) )
-						{
-							alt28=2;
-						}
-						else
-						{
-							if (state.backtracking>0) {state.failed=true; return ;}
-							NoViableAltException nvae = new NoViableAltException("", 28, 4, input);
-
-							throw nvae;
-						}
-					}
-					else if ( (LA28_0=='\n'||LA28_0=='\r'||LA28_0=='$') )
-					{
-						alt28=2;
-					}
-					else
-					{
-						alt28=1;}
-					switch ( alt28 )
-					{
-					case 1:
-						// Language\\Template.g3:372:6: => EOF
-						{
-
-						Match(EOF); if (state.failed) return ;
-						if ( state.backtracking == 0 )
-						{
-							builder.Append("\\");
-						}
-
-						}
-						break;
-					case 2:
-						// Language\\Template.g3:373:6: ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) )
-						{
-						// Language\\Template.g3:373:6: ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) )
-						int alt27=3;
-						int LA27_0 = input.LA(1);
-
-						if ( (LA27_0=='$') )
-						{
-							alt27=1;
-						}
-						else if ( (LA27_0=='\\') )
-						{
-							alt27=2;
-						}
-						else if ( ((LA27_0>='\u0000' && LA27_0<='#')||(LA27_0>='%' && LA27_0<='[')||(LA27_0>=']' && LA27_0<='\uFFFF')) )
-						{
-							alt27=3;
-						}
-						else
-						{
-							if (state.backtracking>0) {state.failed=true; return ;}
-							NoViableAltException nvae = new NoViableAltException("", 27, 0, input);
-
-							throw nvae;
-						}
-						switch ( alt27 )
-						{
-						case 1:
-							// Language\\Template.g3:373:8: '$'
-							{
-							Match('$'); if (state.failed) return ;
-							if ( state.backtracking == 0 )
-							{
-								builder.Append("$");
-							}
-
-							}
-							break;
-						case 2:
-							// Language\\Template.g3:374:7: '\\\\'
-							{
-							Match('\\'); if (state.failed) return ;
-							if ( state.backtracking == 0 )
-							{
-								builder.Append("\\");
-							}
-
-							}
-							break;
-						case 3:
-							// Language\\Template.g3:375:7: ch=~ ( '$' | '\\\\' )
-							{
-							ch= input.LA(1);
-							input.Consume();
-							state.failed=false;
-							if ( state.backtracking == 0 )
-							{
-								builder.Append("\\" + (char)ch);
-							}
-
-							}
-							break;
-
-						}
-
-
-						}
-						break;
-
-					}
-
-
-					}
-					break;
-				case 2:
-					// Language\\Template.g3:378:5: ind= INDENT
-					{
-					int indStart801 = CharIndex;
-					mINDENT(); if (state.failed) return ;
-					ind = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, indStart801, CharIndex-1);
-					if ( state.backtracking == 0 )
-					{
-
-										loopStartIndex = builder.Length;
-										col = CharPositionInLine - (ind!=null?ind.Text:null).Length;
-
-										builder.Append( (ind!=null?ind.Text:null) );
-										if ( col==0 && input.LA(1)=='$' )
-										{
-											// store indent in ASTExpr not in a literal
-											currentIndent=(ind!=null?ind.Text:null);
-											//text.setLength(loopStartIndex); // reset length to wack text
-											builder.Length = loopStartIndex; //= Text.Substring( 0, loopStartIndex );
-										}
-										else
-										{
-											currentIndent=null;
-										}
-
-					}
-
-					}
-					break;
-				case 3:
-					// Language\\Template.g3:396:5: ch=~ ( '$' | '\\r' | '\\n' | '\\\\' | ' ' | '\\t' )
-					{
-					ch= input.LA(1);
-					input.Consume();
-					state.failed=false;
-					if ( state.backtracking == 0 )
-					{
-						builder.Append((char)ch);
-					}
-
-					}
-					break;
-
-				default:
-					if ( cnt29 >= 1 )
-						goto loop29;
-
-					if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee29 = new EarlyExitException( 29, input );
-					throw eee29;
-				}
-				cnt29++;
-			}
-			loop29:
-				;
-
-
-			if ( state.backtracking == 0 )
-			{
-				Text = builder.ToString();
-			}
-			if ( state.backtracking == 0 )
-			{
-				if (Text.Length==0) {_channel = Hidden;}
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "LITERAL"
-
-	// $ANTLR start "EXPR"
-	private void mEXPR(out string _text)
-	{
-		try
-		{
-			CommonToken st=null;
-			CommonToken ESC1=null;
-			int ch;
-
-
-				_text = string.Empty;
-				string subtext = string.Empty;
-				System.Text.StringBuilder builder = new System.Text.StringBuilder();
-
-			// Language\\Template.g3:411:4: ( ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '$' ) )+ )
-			// Language\\Template.g3:411:4: ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '$' ) )+
-			{
-			// Language\\Template.g3:411:4: ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '$' ) )+
-			int cnt32=0;
-			for ( ; ; )
-			{
-				int alt32=5;
-				int LA32_0 = input.LA(1);
-
-				if ( (LA32_0=='\\') )
-				{
-					alt32=1;
-				}
-				else if ( (LA32_0=='{') )
-				{
-					alt32=2;
-				}
-				else if ( (LA32_0=='+'||LA32_0=='=') )
-				{
-					alt32=3;
-				}
-				else if ( ((LA32_0>='\u0000' && LA32_0<='#')||(LA32_0>='%' && LA32_0<='*')||(LA32_0>=',' && LA32_0<='<')||(LA32_0>='>' && LA32_0<='[')||(LA32_0>=']' && LA32_0<='z')||(LA32_0>='|' && LA32_0<='\uFFFF')) )
-				{
-					alt32=4;
-				}
-
-
-				switch ( alt32 )
-				{
-				case 1:
-					// Language\\Template.g3:411:6: ESC
-					{
-					int ESC1Start863 = CharIndex;
-					mESC(); if (state.failed) return ;
-					ESC1 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ESC1Start863, CharIndex-1);
-					if ( state.backtracking == 0 )
-					{
-						builder.Append((ESC1!=null?ESC1.Text:null));
-					}
-
-					}
-					break;
-				case 2:
-					// Language\\Template.g3:412:5: st= SUBTEMPLATE
-					{
-					int stStart879 = CharIndex;
-					mSUBTEMPLATE(); if (state.failed) return ;
-					st = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, stStart879, CharIndex-1);
-					if ( state.backtracking == 0 )
-					{
-						builder.Append((st!=null?st.Text:null));
-					}
-
-					}
-					break;
-				case 3:
-					// Language\\Template.g3:413:5: ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) )
-					{
-					// Language\\Template.g3:413:5: ( '=' | '+' )
-					int alt30=2;
-					int LA30_0 = input.LA(1);
-
-					if ( (LA30_0=='=') )
-					{
-						alt30=1;
-					}
-					else if ( (LA30_0=='+') )
-					{
-						alt30=2;
-					}
-					else
-					{
-						if (state.backtracking>0) {state.failed=true; return ;}
-						NoViableAltException nvae = new NoViableAltException("", 30, 0, input);
-
-						throw nvae;
-					}
-					switch ( alt30 )
-					{
-					case 1:
-						// Language\\Template.g3:413:7: '='
-						{
-						Match('='); if (state.failed) return ;
-						if ( state.backtracking == 0 )
-						{
-							builder.Append('=');
-						}
-
-						}
-						break;
-					case 2:
-						// Language\\Template.g3:414:6: '+'
-						{
-						Match('+'); if (state.failed) return ;
-						if ( state.backtracking == 0 )
-						{
-							builder.Append('+');
-						}
-
-						}
-						break;
-
-					}
-
-					// Language\\Template.g3:416:4: ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) )
-					int alt31=3;
-					int LA31_0 = input.LA(1);
-
-					if ( (LA31_0=='\"'||LA31_0=='<') )
-					{
-						alt31=1;
-					}
-					else if ( (LA31_0=='{') )
-					{
-						alt31=2;
-					}
-					else if ( ((LA31_0>='\u0000' && LA31_0<='!')||(LA31_0>='#' && LA31_0<=';')||(LA31_0>='=' && LA31_0<='z')||(LA31_0>='|' && LA31_0<='\uFFFF')) )
-					{
-						alt31=3;
-					}
-					else
-					{
-						if (state.backtracking>0) {state.failed=true; return ;}
-						NoViableAltException nvae = new NoViableAltException("", 31, 0, input);
-
-						throw nvae;
-					}
-					switch ( alt31 )
-					{
-					case 1:
-						// Language\\Template.g3:416:6: TEMPLATE[out subtext]
-						{
-						mTEMPLATE(out subtext); if (state.failed) return ;
-						if ( state.backtracking == 0 )
-						{
-							builder.Append(subtext);
-						}
-
-						}
-						break;
-					case 2:
-						// Language\\Template.g3:417:6: st= SUBTEMPLATE
-						{
-						int stStart937 = CharIndex;
-						mSUBTEMPLATE(); if (state.failed) return ;
-						st = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, stStart937, CharIndex-1);
-						if ( state.backtracking == 0 )
-						{
-							builder.Append((st!=null?st.Text:null));
-						}
-
-						}
-						break;
-					case 3:
-						// Language\\Template.g3:418:6: ch=~ ( '\"' | '<' | '{' )
-						{
-						ch= input.LA(1);
-						input.Consume();
-						state.failed=false;
-						if ( state.backtracking == 0 )
-						{
-							builder.Append((char)ch);
-						}
-
-						}
-						break;
-
-					}
-
-
-					}
-					break;
-				case 4:
-					// Language\\Template.g3:420:5: ch=~ ( '\\\\' | '{' | '=' | '+' | '$' )
-					{
-					ch= input.LA(1);
-					input.Consume();
-					state.failed=false;
-					if ( state.backtracking == 0 )
-					{
-						builder.Append((char)ch);
-					}
-
-					}
-					break;
-
-				default:
-					if ( cnt32 >= 1 )
-						goto loop32;
-
-					if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee32 = new EarlyExitException( 32, input );
-					throw eee32;
-				}
-				cnt32++;
-			}
-			loop32:
-				;
-
-
-			if ( state.backtracking == 0 )
-			{
-				_text = builder.ToString();
-			}
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "EXPR"
-
-	// $ANTLR start "TEMPLATE"
-	private void mTEMPLATE(out string _text)
-	{
-		try
-		{
-			CommonToken ESC2=null;
-			int ch;
-
-
-				_text = string.Empty;
-				System.Text.StringBuilder builder = new System.Text.StringBuilder();
-
-			// Language\\Template.g3:432:4: ( '\"' ( ESC |ch=~ ( '\\\\' | '\"' ) )* '\"' | '<<' (=> ( '\\r' )? '\\n' )? (=> ( '\\r' )? '\\n' |ch= . )* '>>' )
-			int alt38=2;
-			int LA38_0 = input.LA(1);
-
-			if ( (LA38_0=='\"') )
-			{
-				alt38=1;
-			}
-			else if ( (LA38_0=='<') )
-			{
-				alt38=2;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				NoViableAltException nvae = new NoViableAltException("", 38, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt38 )
-			{
-			case 1:
-				// Language\\Template.g3:432:4: '\"' ( ESC |ch=~ ( '\\\\' | '\"' ) )* '\"'
-				{
-				Match('\"'); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-					builder.Append('"');
-				}
-				// Language\\Template.g3:434:3: ( ESC |ch=~ ( '\\\\' | '\"' ) )*
-				for ( ; ; )
-				{
-					int alt33=3;
-					int LA33_0 = input.LA(1);
-
-					if ( (LA33_0=='\\') )
-					{
-						alt33=1;
-					}
-					else if ( ((LA33_0>='\u0000' && LA33_0<='!')||(LA33_0>='#' && LA33_0<='[')||(LA33_0>=']' && LA33_0<='\uFFFF')) )
-					{
-						alt33=2;
-					}
-
-
-					switch ( alt33 )
-					{
-					case 1:
-						// Language\\Template.g3:434:5: ESC
-						{
-						int ESC2Start1023 = CharIndex;
-						mESC(); if (state.failed) return ;
-						ESC2 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ESC2Start1023, CharIndex-1);
-						if ( state.backtracking == 0 )
-						{
-							builder.Append((ESC2!=null?ESC2.Text:null));
-						}
-
-						}
-						break;
-					case 2:
-						// Language\\Template.g3:435:5: ch=~ ( '\\\\' | '\"' )
-						{
-						ch= input.LA(1);
-						input.Consume();
-						state.failed=false;
-						if ( state.backtracking == 0 )
-						{
-							builder.Append((char)ch);
-						}
-
-						}
-						break;
-
-					default:
-						goto loop33;
-					}
-				}
-
-				loop33:
-					;
-
-
-				Match('\"'); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-
-								builder.Append('"');
-								_text = builder.ToString();
-
-				}
-
-				}
-				break;
-			case 2:
-				// Language\\Template.g3:442:4: '<<' (=> ( '\\r' )? '\\n' )? (=> ( '\\r' )? '\\n' |ch= . )* '>>'
-				{
-				Match("<<"); if (state.failed) return ;
-
-				if ( state.backtracking == 0 )
-				{
-
-								builder.Append("<<");
-
-				}
-				// Language\\Template.g3:446:4: (=> ( '\\r' )? '\\n' )?
-				int alt35=2;
-				int LA35_0 = input.LA(1);
-
-				if ( (LA35_0=='\r') )
-				{
-					int LA35_1 = input.LA(2);
-
-					if ( (LA35_1=='\n') )
-					{
-						int LA35_2 = input.LA(3);
-
-						if ( (EvaluatePredicate(synpred14_Template_fragment)) )
-						{
-							alt35=1;
-						}
-					}
-				}
-				else if ( (LA35_0=='\n') )
-				{
-					int LA35_2 = input.LA(2);
-
-					if ( (EvaluatePredicate(synpred14_Template_fragment)) )
-					{
-						alt35=1;
-					}
-				}
-				switch ( alt35 )
-				{
-				case 1:
-					// Language\\Template.g3:446:6: => ( '\\r' )? '\\n'
-					{
-
-					// Language\\Template.g3:446:21: ( '\\r' )?
-					int alt34=2;
-					int LA34_0 = input.LA(1);
-
-					if ( (LA34_0=='\r') )
-					{
-						alt34=1;
-					}
-					switch ( alt34 )
-					{
-					case 1:
-						// Language\\Template.g3:446:22: '\\r'
-						{
-						Match('\r'); if (state.failed) return ;
-
-						}
-						break;
-
-					}
-
-					Match('\n'); if (state.failed) return ;
-
-					}
-					break;
-
-				}
-
-				// Language\\Template.g3:448:3: (=> ( '\\r' )? '\\n' |ch= . )*
-				for ( ; ; )
-				{
-					int alt37=3;
-					int LA37_0 = input.LA(1);
-
-					if ( (LA37_0=='>') )
-					{
-						int LA37_1 = input.LA(2);
-
-						if ( (LA37_1=='>') )
-						{
-							int LA37_5 = input.LA(3);
-
-							if ( ((LA37_5>='\u0000' && LA37_5<='\uFFFF')) )
-							{
-								alt37=2;
-							}
-
-
-						}
-						else if ( ((LA37_1>='\u0000' && LA37_1<='=')||(LA37_1>='?' && LA37_1<='\uFFFF')) )
-						{
-							alt37=2;
-						}
-
-
-					}
-					else if ( (LA37_0=='\r') )
-					{
-						int LA37_2 = input.LA(2);
-
-						if ( (EvaluatePredicate(synpred15_Template_fragment)) )
-						{
-							alt37=1;
-						}
-						else if ( (true) )
-						{
-							alt37=2;
-						}
-
-
-					}
-					else if ( (LA37_0=='\n') )
-					{
-						int LA37_3 = input.LA(2);
-
-						if ( (EvaluatePredicate(synpred15_Template_fragment)) )
-						{
-							alt37=1;
-						}
-						else if ( (true) )
-						{
-							alt37=2;
-						}
-
-
-					}
-					else if ( ((LA37_0>='\u0000' && LA37_0<='\t')||(LA37_0>='\u000B' && LA37_0<='\f')||(LA37_0>='\u000E' && LA37_0<='=')||(LA37_0>='?' && LA37_0<='\uFFFF')) )
-					{
-						alt37=2;
-					}
-
-
-					switch ( alt37 )
-					{
-					case 1:
-						// Language\\Template.g3:448:5: => ( '\\r' )? '\\n'
-						{
-
-						// Language\\Template.g3:448:23: ( '\\r' )?
-						int alt36=2;
-						int LA36_0 = input.LA(1);
-
-						if ( (LA36_0=='\r') )
-						{
-							alt36=1;
-						}
-						switch ( alt36 )
-						{
-						case 1:
-							// Language\\Template.g3:448:24: '\\r'
-							{
-							Match('\r'); if (state.failed) return ;
-
-							}
-							break;
-
-						}
-
-						Match('\n'); if (state.failed) return ;
-
-						}
-						break;
-					case 2:
-						// Language\\Template.g3:449:5: ch= .
-						{
-						ch = input.LA(1);
-						MatchAny(); if (state.failed) return ;
-						if ( state.backtracking == 0 )
-						{
-							builder.Append((char)ch);
-						}
-
-						}
-						break;
-
-					default:
-						goto loop37;
-					}
-				}
-
-				loop37:
-					;
-
-
-				Match(">>"); if (state.failed) return ;
-
-				if ( state.backtracking == 0 )
-				{
-
-								builder.Append(">>");
-								_text = builder.ToString();
-
-				}
-
-				}
-				break;
-
-			}
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "TEMPLATE"
-
-	// $ANTLR start "IF_EXPR"
-	private void mIF_EXPR()
-	{
-		try
-		{
-			// Language\\Template.g3:460:4: ( ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+ )
-			// Language\\Template.g3:460:4: ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+
-			{
-			// Language\\Template.g3:460:4: ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+
-			int cnt39=0;
-			for ( ; ; )
-			{
-				int alt39=5;
-				int LA39_0 = input.LA(1);
-
-				if ( (LA39_0=='\\') )
-				{
-					alt39=1;
-				}
-				else if ( (LA39_0=='{') )
-				{
-					alt39=2;
-				}
-				else if ( (LA39_0=='(') )
-				{
-					alt39=3;
-				}
-				else if ( ((LA39_0>='\u0000' && LA39_0<='\'')||(LA39_0>='*' && LA39_0<='[')||(LA39_0>=']' && LA39_0<='z')||(LA39_0>='|' && LA39_0<='\uFFFF')) )
-				{
-					alt39=4;
-				}
-
-
-				switch ( alt39 )
-				{
-				case 1:
-					// Language\\Template.g3:460:6: ESC
-					{
-					mESC(); if (state.failed) return ;
-
-					}
-					break;
-				case 2:
-					// Language\\Template.g3:461:5: SUBTEMPLATE
-					{
-					mSUBTEMPLATE(); if (state.failed) return ;
-
-					}
-					break;
-				case 3:
-					// Language\\Template.g3:462:5: NESTED_PARENS
-					{
-					mNESTED_PARENS(); if (state.failed) return ;
-
-					}
-					break;
-				case 4:
-					// Language\\Template.g3:463:5: ~ ( '\\\\' | '{' | '(' | ')' )
-					{
-					input.Consume();
-					state.failed=false;
-
-					}
-					break;
-
-				default:
-					if ( cnt39 >= 1 )
-						goto loop39;
-
-					if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee39 = new EarlyExitException( 39, input );
-					throw eee39;
-				}
-				cnt39++;
-			}
-			loop39:
-				;
-
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "IF_EXPR"
-
-	// $ANTLR start "ESC_CHAR"
-	private void mESC_CHAR(out char uc)
-	{
-		try
-		{
-			CommonToken a=null;
-			CommonToken b=null;
-			CommonToken c=null;
-			CommonToken d=null;
-
-
-				uc = '\0';
-
-			// Language\\Template.g3:473:4: ( '\\\\n' | '\\\\r' | '\\\\t' | '\\\\ ' | '\\\\u' a= HEX b= HEX c= HEX d= HEX )
-			int alt40=5;
-			int LA40_0 = input.LA(1);
-
-			if ( (LA40_0=='\\') )
-			{
-				switch ( input.LA(2) )
-				{
-				case 'n':
-					{
-					alt40=1;
-					}
-					break;
-				case 'r':
-					{
-					alt40=2;
-					}
-					break;
-				case 't':
-					{
-					alt40=3;
-					}
-					break;
-				case ' ':
-					{
-					alt40=4;
-					}
-					break;
-				case 'u':
-					{
-					alt40=5;
-					}
-					break;
-				default:
-					{
-						if (state.backtracking>0) {state.failed=true; return ;}
-						NoViableAltException nvae = new NoViableAltException("", 40, 1, input);
-
-						throw nvae;
-					}
-				}
-
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				NoViableAltException nvae = new NoViableAltException("", 40, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt40 )
-			{
-			case 1:
-				// Language\\Template.g3:473:4: '\\\\n'
-				{
-				Match("\\n"); if (state.failed) return ;
-
-				if ( state.backtracking == 0 )
-				{
-					uc = '\n';
-				}
-
-				}
-				break;
-			case 2:
-				// Language\\Template.g3:474:4: '\\\\r'
-				{
-				Match("\\r"); if (state.failed) return ;
-
-				if ( state.backtracking == 0 )
-				{
-					uc = '\r';
-				}
-
-				}
-				break;
-			case 3:
-				// Language\\Template.g3:475:4: '\\\\t'
-				{
-				Match("\\t"); if (state.failed) return ;
-
-				if ( state.backtracking == 0 )
-				{
-					uc = '\t';
-				}
-
-				}
-				break;
-			case 4:
-				// Language\\Template.g3:476:4: '\\\\ '
-				{
-				Match("\\ "); if (state.failed) return ;
-
-				if ( state.backtracking == 0 )
-				{
-					uc = ' ';
-				}
-
-				}
-				break;
-			case 5:
-				// Language\\Template.g3:477:4: '\\\\u' a= HEX b= HEX c= HEX d= HEX
-				{
-				Match("\\u"); if (state.failed) return ;
-
-				int aStart1234 = CharIndex;
-				mHEX(); if (state.failed) return ;
-				a = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, aStart1234, CharIndex-1);
-				int bStart1238 = CharIndex;
-				mHEX(); if (state.failed) return ;
-				b = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, bStart1238, CharIndex-1);
-				int cStart1242 = CharIndex;
-				mHEX(); if (state.failed) return ;
-				c = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, cStart1242, CharIndex-1);
-				int dStart1246 = CharIndex;
-				mHEX(); if (state.failed) return ;
-				d = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, dStart1246, CharIndex-1);
-				if ( state.backtracking == 0 )
-				{
-					uc = (char)int.Parse((a!=null?a.Text:null)+(b!=null?b.Text:null)+(c!=null?c.Text:null)+(d!=null?d.Text:null), System.Globalization.NumberStyles.AllowHexSpecifier);
-				}
-
-				}
-				break;
-
-			}
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ESC_CHAR"
-
-	// $ANTLR start "ESC"
-	private void mESC()
-	{
-		try
-		{
-			// Language\\Template.g3:483:4: ( '\\\\' . )
-			// Language\\Template.g3:483:4: '\\\\' .
-			{
-			Match('\\'); if (state.failed) return ;
-			MatchAny(); if (state.failed) return ;
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ESC"
-
-	// $ANTLR start "HEX"
-	private void mHEX()
-	{
-		try
-		{
-			// Language\\Template.g3:488:4: ( '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' )
-			// Language\\Template.g3:
-			{
-			if ( (input.LA(1)>='0' && input.LA(1)<='9')||(input.LA(1)>='A' && input.LA(1)<='F')||(input.LA(1)>='a' && input.LA(1)<='f') )
-			{
-				input.Consume();
-			state.failed=false;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				MismatchedSetException mse = new MismatchedSetException(null,input);
-				Recover(mse);
-				throw mse;}
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "HEX"
-
-	// $ANTLR start "SUBTEMPLATE"
-	private void mSUBTEMPLATE()
-	{
-		try
-		{
-			// Language\\Template.g3:493:4: ( '{' ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )* '}' )
-			// Language\\Template.g3:493:4: '{' ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )* '}'
-			{
-			Match('{'); if (state.failed) return ;
-			// Language\\Template.g3:494:3: ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )*
-			for ( ; ; )
-			{
-				int alt41=4;
-				int LA41_0 = input.LA(1);
-
-				if ( (LA41_0=='{') )
-				{
-					alt41=1;
-				}
-				else if ( (LA41_0=='\\') )
-				{
-					alt41=2;
-				}
-				else if ( ((LA41_0>='\u0000' && LA41_0<='[')||(LA41_0>=']' && LA41_0<='z')||LA41_0=='|'||(LA41_0>='~' && LA41_0<='\uFFFF')) )
-				{
-					alt41=3;
-				}
-
-
-				switch ( alt41 )
-				{
-				case 1:
-					// Language\\Template.g3:494:5: SUBTEMPLATE
-					{
-					mSUBTEMPLATE(); if (state.failed) return ;
-
-					}
-					break;
-				case 2:
-					// Language\\Template.g3:495:5: ESC
-					{
-					mESC(); if (state.failed) return ;
-
-					}
-					break;
-				case 3:
-					// Language\\Template.g3:496:5: ~ ( '{' | '\\\\' | '}' )
-					{
-					input.Consume();
-					state.failed=false;
-
-					}
-					break;
-
-				default:
-					goto loop41;
-				}
-			}
-
-			loop41:
-				;
-
-
-			Match('}'); if (state.failed) return ;
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "SUBTEMPLATE"
-
-	// $ANTLR start "NESTED_PARENS"
-	private void mNESTED_PARENS()
-	{
-		try
-		{
-			// Language\\Template.g3:503:4: ( '(' ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+ ')' )
-			// Language\\Template.g3:503:4: '(' ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+ ')'
-			{
-			Match('('); if (state.failed) return ;
-			// Language\\Template.g3:504:3: ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+
-			int cnt42=0;
-			for ( ; ; )
-			{
-				int alt42=4;
-				int LA42_0 = input.LA(1);
-
-				if ( (LA42_0=='(') )
-				{
-					alt42=1;
-				}
-				else if ( (LA42_0=='\\') )
-				{
-					alt42=2;
-				}
-				else if ( ((LA42_0>='\u0000' && LA42_0<='\'')||(LA42_0>='*' && LA42_0<='[')||(LA42_0>=']' && LA42_0<='\uFFFF')) )
-				{
-					alt42=3;
-				}
-
-
-				switch ( alt42 )
-				{
-				case 1:
-					// Language\\Template.g3:504:5: NESTED_PARENS
-					{
-					mNESTED_PARENS(); if (state.failed) return ;
-
-					}
-					break;
-				case 2:
-					// Language\\Template.g3:505:5: ESC
-					{
-					mESC(); if (state.failed) return ;
-
-					}
-					break;
-				case 3:
-					// Language\\Template.g3:506:5: ~ ( '(' | '\\\\' | ')' )
-					{
-					input.Consume();
-					state.failed=false;
-
-					}
-					break;
-
-				default:
-					if ( cnt42 >= 1 )
-						goto loop42;
-
-					if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee42 = new EarlyExitException( 42, input );
-					throw eee42;
-				}
-				cnt42++;
-			}
-			loop42:
-				;
-
-
-			Match(')'); if (state.failed) return ;
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "NESTED_PARENS"
-
-	// $ANTLR start "INDENT"
-	private void mINDENT()
-	{
-		try
-		{
-			// Language\\Template.g3:513:4: ( ( ' ' | '\\t' )+ )
-			// Language\\Template.g3:513:4: ( ' ' | '\\t' )+
-			{
-			// Language\\Template.g3:513:4: ( ' ' | '\\t' )+
-			int cnt43=0;
-			for ( ; ; )
-			{
-				int alt43=2;
-				int LA43_0 = input.LA(1);
-
-				if ( (LA43_0=='\t'||LA43_0==' ') )
-				{
-					alt43=1;
-				}
-
-
-				switch ( alt43 )
-				{
-				case 1:
-					// Language\\Template.g3:
-					{
-					input.Consume();
-					state.failed=false;
-
-					}
-					break;
-
-				default:
-					if ( cnt43 >= 1 )
-						goto loop43;
-
-					if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee43 = new EarlyExitException( 43, input );
-					throw eee43;
-				}
-				cnt43++;
-			}
-			loop43:
-				;
-
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "INDENT"
-
-	// $ANTLR start "COMMENT"
-	private void mCOMMENT()
-	{
-		try
-		{
-
-				int startCol = CharPositionInLine;
-
-			// Language\\Template.g3:522:4: ( '$!' ( . )* '!$' ({...}? => ( '\\r' )? '\\n' )? )
-			// Language\\Template.g3:522:4: '$!' ( . )* '!$' ({...}? => ( '\\r' )? '\\n' )?
-			{
-			Match("$!"); if (state.failed) return ;
-
-			// Language\\Template.g3:522:9: ( . )*
-			for ( ; ; )
-			{
-				int alt44=2;
-				int LA44_0 = input.LA(1);
-
-				if ( (LA44_0=='!') )
-				{
-					int LA44_1 = input.LA(2);
-
-					if ( (LA44_1=='$') )
-					{
-						alt44=2;
-					}
-					else if ( ((LA44_1>='\u0000' && LA44_1<='#')||(LA44_1>='%' && LA44_1<='\uFFFF')) )
-					{
-						alt44=1;
-					}
-
-
-				}
-				else if ( ((LA44_0>='\u0000' && LA44_0<=' ')||(LA44_0>='\"' && LA44_0<='\uFFFF')) )
-				{
-					alt44=1;
-				}
-
-
-				switch ( alt44 )
-				{
-				case 1:
-					// Language\\Template.g3:522:0: .
-					{
-					MatchAny(); if (state.failed) return ;
-
-					}
-					break;
-
-				default:
-					goto loop44;
-				}
-			}
-
-			loop44:
-				;
-
-
-			Match("!$"); if (state.failed) return ;
-
-			// Language\\Template.g3:522:17: ({...}? => ( '\\r' )? '\\n' )?
-			int alt46=2;
-			int LA46_0 = input.LA(1);
-
-			if ( (LA46_0=='\n'||LA46_0=='\r') && ((startCol==0)))
-			{
-				alt46=1;
-			}
-			switch ( alt46 )
-			{
-			case 1:
-				// Language\\Template.g3:522:19: {...}? => ( '\\r' )? '\\n'
-				{
-				if ( !((startCol==0)) )
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					throw new FailedPredicateException(input, "COMMENT", "startCol==0");
-				}
-				// Language\\Template.g3:522:37: ( '\\r' )?
-				int alt45=2;
-				int LA45_0 = input.LA(1);
-
-				if ( (LA45_0=='\r') )
-				{
-					alt45=1;
-				}
-				switch ( alt45 )
-				{
-				case 1:
-					// Language\\Template.g3:522:38: '\\r'
-					{
-					Match('\r'); if (state.failed) return ;
-
-					}
-					break;
-
-				}
-
-				Match('\n'); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "COMMENT"
-
-	// $ANTLR start "LINE_BREAK"
-	private void mLINE_BREAK()
-	{
-		try
-		{
-			// Language\\Template.g3:527:4: ( '$\\\\\\\\$' ( INDENT )? ( '\\r' )? '\\n' ( INDENT )? )
-			// Language\\Template.g3:527:4: '$\\\\\\\\$' ( INDENT )? ( '\\r' )? '\\n' ( INDENT )?
-			{
-			Match("$\\\\$"); if (state.failed) return ;
-
-			// Language\\Template.g3:527:13: ( INDENT )?
-			int alt47=2;
-			int LA47_0 = input.LA(1);
-
-			if ( (LA47_0=='\t'||LA47_0==' ') )
-			{
-				alt47=1;
-			}
-			switch ( alt47 )
-			{
-			case 1:
-				// Language\\Template.g3:527:0: INDENT
-				{
-				mINDENT(); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-			// Language\\Template.g3:527:21: ( '\\r' )?
-			int alt48=2;
-			int LA48_0 = input.LA(1);
-
-			if ( (LA48_0=='\r') )
-			{
-				alt48=1;
-			}
-			switch ( alt48 )
-			{
-			case 1:
-				// Language\\Template.g3:527:0: '\\r'
-				{
-				Match('\r'); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-			Match('\n'); if (state.failed) return ;
-			// Language\\Template.g3:527:32: ( INDENT )?
-			int alt49=2;
-			int LA49_0 = input.LA(1);
-
-			if ( (LA49_0=='\t'||LA49_0==' ') )
-			{
-				alt49=1;
-			}
-			switch ( alt49 )
-			{
-			case 1:
-				// Language\\Template.g3:527:0: INDENT
-				{
-				mINDENT(); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "LINE_BREAK"
-
-	public override void mTokens()
-	{
-		// Language\\Template.g3:1:10: ( NEWLINE | ACTION | LITERAL )
-		int alt50=3;
-		int LA50_0 = input.LA(1);
-
-		if ( (LA50_0=='\n'||LA50_0=='\r') )
-		{
-			alt50=1;
-		}
-		else if ( (LA50_0=='$') )
-		{
-			alt50=2;
-		}
-		else if ( ((LA50_0>='\u0000' && LA50_0<='\t')||(LA50_0>='\u000B' && LA50_0<='\f')||(LA50_0>='\u000E' && LA50_0<='#')||(LA50_0>='%' && LA50_0<='\uFFFF')) )
-		{
-			alt50=3;
-		}
-		else
-		{
-			if (state.backtracking>0) {state.failed=true; return ;}
-			NoViableAltException nvae = new NoViableAltException("", 50, 0, input);
-
-			throw nvae;
-		}
-		switch ( alt50 )
-		{
-		case 1:
-			// Language\\Template.g3:1:10: NEWLINE
-			{
-			mNEWLINE(); if (state.failed) return ;
-
-			}
-			break;
-		case 2:
-			// Language\\Template.g3:1:18: ACTION
-			{
-			mACTION(); if (state.failed) return ;
-
-			}
-			break;
-		case 3:
-			// Language\\Template.g3:1:25: LITERAL
-			{
-			mLITERAL(); if (state.failed) return ;
-
-			}
-			break;
-
-		}
-
-	}
-
-	// $ANTLR start synpred1_Template
-	public void synpred1_Template_fragment()
-	{
-		// Language\\Template.g3:281:4: ( LINE_BREAK )
-		// Language\\Template.g3:281:5: LINE_BREAK
-		{
-		mLINE_BREAK(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred1_Template
-
-	// $ANTLR start synpred10_Template
-	public void synpred10_Template_fragment()
-	{
-		// Language\\Template.g3:340:9: ( '\\r' | '\\n' )
-		// Language\\Template.g3:
-		{
-		if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
-		{
-			input.Consume();
-		state.failed=false;
-		}
-		else
-		{
-			if (state.backtracking>0) {state.failed=true; return ;}
-			MismatchedSetException mse = new MismatchedSetException(null,input);
-			Recover(mse);
-			throw mse;}
-
-
-		}
-	}
-	// $ANTLR end synpred10_Template
-
-	// $ANTLR start synpred11_Template
-	public void synpred11_Template_fragment()
-	{
-		// Language\\Template.g3:344:8: ( '\\r' | '\\n' )
-		// Language\\Template.g3:
-		{
-		if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
-		{
-			input.Consume();
-		state.failed=false;
-		}
-		else
-		{
-			if (state.backtracking>0) {state.failed=true; return ;}
-			MismatchedSetException mse = new MismatchedSetException(null,input);
-			Recover(mse);
-			throw mse;}
-
-
-		}
-	}
-	// $ANTLR end synpred11_Template
-
-	// $ANTLR start synpred12_Template
-	public void synpred12_Template_fragment()
-	{
-		// Language\\Template.g3:345:8: ( '$@end$' )
-		// Language\\Template.g3:345:9: '$@end$'
-		{
-		Match("$@end$"); if (state.failed) return ;
-
-
-		}
-	}
-	// $ANTLR end synpred12_Template
-
-	// $ANTLR start synpred13_Template
-	public void synpred13_Template_fragment()
-	{
-		// Language\\Template.g3:372:6: ( EOF )
-		// Language\\Template.g3:372:7: EOF
-		{
-		Match(EOF); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred13_Template
-
-	// $ANTLR start synpred14_Template
-	public void synpred14_Template_fragment()
-	{
-		// Language\\Template.g3:446:6: ( '\\r' | '\\n' )
-		// Language\\Template.g3:
-		{
-		if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
-		{
-			input.Consume();
-		state.failed=false;
-		}
-		else
-		{
-			if (state.backtracking>0) {state.failed=true; return ;}
-			MismatchedSetException mse = new MismatchedSetException(null,input);
-			Recover(mse);
-			throw mse;}
-
-
-		}
-	}
-	// $ANTLR end synpred14_Template
-
-	// $ANTLR start synpred15_Template
-	public void synpred15_Template_fragment()
-	{
-		// Language\\Template.g3:448:5: ( ( '\\r' )? '\\n>>' )
-		// Language\\Template.g3:448:6: ( '\\r' )? '\\n>>'
-		{
-		// Language\\Template.g3:448:6: ( '\\r' )?
-		int alt51=2;
-		int LA51_0 = input.LA(1);
-
-		if ( (LA51_0=='\r') )
-		{
-			alt51=1;
-		}
-		switch ( alt51 )
-		{
-		case 1:
-			// Language\\Template.g3:448:0: '\\r'
-			{
-			Match('\r'); if (state.failed) return ;
-
-			}
-			break;
-
-		}
-
-		Match("\n>>"); if (state.failed) return ;
-
-
-		}
-	}
-	// $ANTLR end synpred15_Template
-
-	// $ANTLR start synpred2_Template
-	public void synpred2_Template_fragment()
-	{
-		// Language\\Template.g3:282:5: ( '$\\\\' )
-		// Language\\Template.g3:282:6: '$\\\\'
-		{
-		Match("$\\"); if (state.failed) return ;
-
-
-		}
-	}
-	// $ANTLR end synpred2_Template
-
-	// $ANTLR start synpred3_Template
-	public void synpred3_Template_fragment()
-	{
-		// Language\\Template.g3:289:5: ( '$!' )
-		// Language\\Template.g3:289:6: '$!'
-		{
-		Match("$!"); if (state.failed) return ;
-
-
-		}
-	}
-	// $ANTLR end synpred3_Template
-
-	// $ANTLR start synpred4_Template
-	public void synpred4_Template_fragment()
-	{
-		// Language\\Template.g3:291:7: ( '$if' ( ' ' | '(' ) )
-		// Language\\Template.g3:291:8: '$if' ( ' ' | '(' )
-		{
-		Match("$if"); if (state.failed) return ;
-
-		if ( input.LA(1)==' '||input.LA(1)=='(' )
-		{
-			input.Consume();
-		state.failed=false;
-		}
-		else
-		{
-			if (state.backtracking>0) {state.failed=true; return ;}
-			MismatchedSetException mse = new MismatchedSetException(null,input);
-			Recover(mse);
-			throw mse;}
-
-
-		}
-	}
-	// $ANTLR end synpred4_Template
-
-	// $ANTLR start synpred5_Template
-	public void synpred5_Template_fragment()
-	{
-		// Language\\Template.g3:298:6: ( '$elseif' ( ' ' | '(' ) )
-		// Language\\Template.g3:298:7: '$elseif' ( ' ' | '(' )
-		{
-		Match("$elseif"); if (state.failed) return ;
-
-		if ( input.LA(1)==' '||input.LA(1)=='(' )
-		{
-			input.Consume();
-		state.failed=false;
-		}
-		else
-		{
-			if (state.backtracking>0) {state.failed=true; return ;}
-			MismatchedSetException mse = new MismatchedSetException(null,input);
-			Recover(mse);
-			throw mse;}
-
-
-		}
-	}
-	// $ANTLR end synpred5_Template
-
-	// $ANTLR start synpred6_Template
-	public void synpred6_Template_fragment()
-	{
-		// Language\\Template.g3:305:6: ( '$else$' )
-		// Language\\Template.g3:305:7: '$else$'
-		{
-		Match("$else$"); if (state.failed) return ;
-
-
-		}
-	}
-	// $ANTLR end synpred6_Template
-
-	// $ANTLR start synpred7_Template
-	public void synpred7_Template_fragment()
-	{
-		// Language\\Template.g3:312:6: ( '$endif$' )
-		// Language\\Template.g3:312:7: '$endif$'
-		{
-		Match("$endif$"); if (state.failed) return ;
-
-
-		}
-	}
-	// $ANTLR end synpred7_Template
-
-	// $ANTLR start synpred8_Template
-	public void synpred8_Template_fragment()
-	{
-		// Language\\Template.g3:322:5: ( '$@' )
-		// Language\\Template.g3:322:6: '$@'
-		{
-		Match("$@"); if (state.failed) return ;
-
-
-		}
-	}
-	// $ANTLR end synpred8_Template
-
-	// $ANTLR start synpred9_Template
-	public void synpred9_Template_fragment()
-	{
-		// Language\\Template.g3:337:8: ( '\\r' | '\\n' )
-		// Language\\Template.g3:
-		{
-		if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
-		{
-			input.Consume();
-		state.failed=false;
-		}
-		else
-		{
-			if (state.backtracking>0) {state.failed=true; return ;}
-			MismatchedSetException mse = new MismatchedSetException(null,input);
-			Recover(mse);
-			throw mse;}
-
-
-		}
-	}
-	// $ANTLR end synpred9_Template
-
-	#region Synpreds
-	bool EvaluatePredicate( System.Action fragment )
-	{
-		state.backtracking++;
-		int start = input.Mark();
-		try
-		{
-			fragment();
-		}
-		catch ( RecognitionException re )
-		{
-			System.Console.Error.WriteLine("impossible: "+re);
-		}
-		bool success = !state.failed;
-		input.Rewind(start);
-		state.backtracking--;
-		state.failed=false;
-		return success;
-	}
-	#endregion Synpreds
-
-
-	#region DFA
-	DFA18 dfa18;
-
-	protected override void InitDFAs()
-	{
-		base.InitDFAs();
-		dfa18 = new DFA18( this, new SpecialStateTransitionHandler( specialStateTransition18 ) );
-	}
-
-	class DFA18 : DFA
-	{
-
-		const string DFA18_eotS =
-			"\x3\xFFFF\x2\x6\x2\xFFFF\x1\x5\x2\xFFFF\x3\x5\x1\xFFFF";
-		const string DFA18_eofS =
-			"\xE\xFFFF";
-		const string DFA18_minS =
-			"\x5\x0\x2\xFFFF\x1\x65\x2\x0\x1\x6E\x1\x64\x1\x24\x1\x0";
-		const string DFA18_maxS =
-			"\x1\xFFFF\x2\x0\x2\xFFFF\x2\xFFFF\x1\x65\x2\x0\x1\x6E\x1\x64\x1\x24\x1"+
-			"\x0";
-		const string DFA18_acceptS =
-			"\x5\xFFFF\x1\x1\x1\x2\x7\xFFFF";
-		const string DFA18_specialS =
-			"\x1\x0\x1\x1\x1\x2\x1\x3\x1\x4\x2\xFFFF\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9"+
-			"\x1\xA\x1\xB}>";
-		static readonly string[] DFA18_transitionS =
-			{
-				"\xA\x4\x1\x2\x2\x4\x1\x1\x16\x4\x1\x3\xFFDB\x4",
-				"\x1\xFFFF",
-				"\x1\xFFFF",
-				"\xA\x5\x1\x9\x2\x5\x1\x8\x32\x5\x1\x7\xFFBF\x5",
-				"\xA\x5\x1\x9\x2\x5\x1\x8\xFFF2\x5",
-				"",
-				"",
-				"\x1\xA",
-				"\x1\xFFFF",
-				"\x1\xFFFF",
-				"\x1\xB",
-				"\x1\xC",
-				"\x1\xD",
-				"\x1\xFFFF"
-			};
-
-		static readonly short[] DFA18_eot = DFA.UnpackEncodedString(DFA18_eotS);
-		static readonly short[] DFA18_eof = DFA.UnpackEncodedString(DFA18_eofS);
-		static readonly char[] DFA18_min = DFA.UnpackEncodedStringToUnsignedChars(DFA18_minS);
-		static readonly char[] DFA18_max = DFA.UnpackEncodedStringToUnsignedChars(DFA18_maxS);
-		static readonly short[] DFA18_accept = DFA.UnpackEncodedString(DFA18_acceptS);
-		static readonly short[] DFA18_special = DFA.UnpackEncodedString(DFA18_specialS);
-		static readonly short[][] DFA18_transition;
-
-		static DFA18()
-		{
-			int numStates = DFA18_transitionS.Length;
-			DFA18_transition = new short[numStates][];
-			for ( int i=0; i < numStates; i++ )
-			{
-				DFA18_transition[i] = DFA.UnpackEncodedString(DFA18_transitionS[i]);
-			}
-		}
-
-		public DFA18( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
-			: base( specialStateTransition )	{
-			this.recognizer = recognizer;
-			this.decisionNumber = 18;
-			this.eot = DFA18_eot;
-			this.eof = DFA18_eof;
-			this.min = DFA18_min;
-			this.max = DFA18_max;
-			this.accept = DFA18_accept;
-			this.special = DFA18_special;
-			this.transition = DFA18_transition;
-		}
-		public override string GetDescription()
-		{
-			return "()+ loopback of 339:6: ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+";
-		}
-	}
-
-	int specialStateTransition18( DFA dfa, int s, IIntStream _input )
-	{
-		IIntStream input = _input;
-		int _s = s;
-		switch ( s )
-		{
-			case 0:
-				int LA18_0 = input.LA(1);
-
-				s = -1;
-				if ( (LA18_0=='\r') ) {s = 1;}
-
-				else if ( (LA18_0=='\n') ) {s = 2;}
-
-				else if ( (LA18_0=='$') ) {s = 3;}
-
-				else if ( ((LA18_0>='\u0000' && LA18_0<='\t')||(LA18_0>='\u000B' && LA18_0<='\f')||(LA18_0>='\u000E' && LA18_0<='#')||(LA18_0>='%' && LA18_0<='\uFFFF')) ) {s = 4;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 1:
-				int LA18_1 = input.LA(1);
-
-
-				int index18_1 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( ((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))) ) {s = 5;}
-
-				else if ( (true) ) {s = 6;}
-
-
-				input.Seek(index18_1);
-				if ( s>=0 ) return s;
-				break;
-			case 2:
-				int LA18_2 = input.LA(1);
-
-
-				int index18_2 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( ((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))) ) {s = 5;}
-
-				else if ( (true) ) {s = 6;}
-
-
-				input.Seek(index18_2);
-				if ( s>=0 ) return s;
-				break;
-			case 3:
-				int LA18_3 = input.LA(1);
-
-
-				int index18_3 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (LA18_3=='@') ) {s = 7;}
-
-				else if ( (LA18_3=='\r') ) {s = 8;}
-
-				else if ( (LA18_3=='\n') ) {s = 9;}
-
-				else if ( ((LA18_3>='\u0000' && LA18_3<='\t')||(LA18_3>='\u000B' && LA18_3<='\f')||(LA18_3>='\u000E' && LA18_3<='?')||(LA18_3>='A' && LA18_3<='\uFFFF')) && ((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) ))))) {s = 5;}
-
-				else s = 6;
-
-
-				input.Seek(index18_3);
-				if ( s>=0 ) return s;
-				break;
-			case 4:
-				int LA18_4 = input.LA(1);
-
-
-				int index18_4 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (LA18_4=='\r') ) {s = 8;}
-
-				else if ( (LA18_4=='\n') ) {s = 9;}
-
-				else if ( ((LA18_4>='\u0000' && LA18_4<='\t')||(LA18_4>='\u000B' && LA18_4<='\f')||(LA18_4>='\u000E' && LA18_4<='\uFFFF')) && ((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) ))))) {s = 5;}
-
-				else s = 6;
-
-
-				input.Seek(index18_4);
-				if ( s>=0 ) return s;
-				break;
-			case 5:
-				int LA18_7 = input.LA(1);
-
-
-				int index18_7 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (LA18_7=='e') ) {s = 10;}
-
-				else s = 5;
-
-
-				input.Seek(index18_7);
-				if ( s>=0 ) return s;
-				break;
-			case 6:
-				int LA18_8 = input.LA(1);
-
-
-				int index18_8 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( ((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))) ) {s = 5;}
-
-				else if ( (true) ) {s = 6;}
-
-
-				input.Seek(index18_8);
-				if ( s>=0 ) return s;
-				break;
-			case 7:
-				int LA18_9 = input.LA(1);
-
-
-				int index18_9 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( ((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))) ) {s = 5;}
-
-				else if ( (true) ) {s = 6;}
-
-
-				input.Seek(index18_9);
-				if ( s>=0 ) return s;
-				break;
-			case 8:
-				int LA18_10 = input.LA(1);
-
-
-				int index18_10 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (LA18_10=='n') ) {s = 11;}
-
-				else s = 5;
-
-
-				input.Seek(index18_10);
-				if ( s>=0 ) return s;
-				break;
-			case 9:
-				int LA18_11 = input.LA(1);
-
-
-				int index18_11 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (LA18_11=='d') ) {s = 12;}
-
-				else s = 5;
-
-
-				input.Seek(index18_11);
-				if ( s>=0 ) return s;
-				break;
-			case 10:
-				int LA18_12 = input.LA(1);
-
-
-				int index18_12 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (LA18_12=='$') ) {s = 13;}
-
-				else s = 5;
-
-
-				input.Seek(index18_12);
-				if ( s>=0 ) return s;
-				break;
-			case 11:
-				int LA18_13 = input.LA(1);
-
-
-				int index18_13 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( ((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))) ) {s = 5;}
-
-				else if ( (true) ) {s = 6;}
-
-
-				input.Seek(index18_13);
-				if ( s>=0 ) return s;
-				break;
-		}
-		if (state.backtracking>0) {state.failed=true; return -1;}
-		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 18, _s, input);
-		dfa.Error(nvae);
-		throw nvae;
-	}
-
-	#endregion
-
-}
-
-} // namespace Antlr3.ST.Language
diff --git a/Antlr3.StringTemplate/Language/TemplateParser.cs b/Antlr3.StringTemplate/Language/TemplateParser.cs
deleted file mode 100644
index 775fc7b..0000000
--- a/Antlr3.StringTemplate/Language/TemplateParser.cs
+++ /dev/null
@@ -1,498 +0,0 @@
-// $ANTLR 3.1.2 Language\\Template.g3 2009-09-30 13:26:48
-
-// The variable 'variable' is assigned but its value is never used.
-#pragma warning disable 219
-// Unreachable code detected.
-#pragma warning disable 162
-
-
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Grammar conversion to ANTLR v3 and C#:
- Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-	notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-	derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-using Antlr.Runtime.JavaExtensions;
-
-
-using System.Collections.Generic;
-using Antlr.Runtime;
-using Stack = System.Collections.Generic.Stack<object>;
-using List = System.Collections.IList;
-using ArrayList = System.Collections.Generic.List<object>;
-
-namespace Antlr3.ST.Language
-{
-[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.1.2")]
-[System.CLSCompliant(false)]
-public partial class TemplateParser : Parser
-{
-	internal static readonly string[] tokenNames = new string[] {
-		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "COMMENT", "ELSE", "ELSEIF", "ENDIF", "ESC", "ESC_CHAR", "EXPR", "HEX", "IF", "IF_EXPR", "INDENT", "LINE_BREAK", "LITERAL", "NESTED_PARENS", "NEWLINE", "REGION_DEF", "REGION_REF", "SUBTEMPLATE", "TEMPLATE"
-	};
-	public const int EOF=-1;
-	public const int ACTION=4;
-	public const int COMMENT=5;
-	public const int ELSE=6;
-	public const int ELSEIF=7;
-	public const int ENDIF=8;
-	public const int ESC=9;
-	public const int ESC_CHAR=10;
-	public const int EXPR=11;
-	public const int HEX=12;
-	public const int IF=13;
-	public const int IF_EXPR=14;
-	public const int INDENT=15;
-	public const int LINE_BREAK=16;
-	public const int LITERAL=17;
-	public const int NESTED_PARENS=18;
-	public const int NEWLINE=19;
-	public const int REGION_DEF=20;
-	public const int REGION_REF=21;
-	public const int SUBTEMPLATE=22;
-	public const int TEMPLATE=23;
-
-	// delegates
-	// delegators
-
-	public TemplateParser( ITokenStream input )
-		: this( input, new RecognizerSharedState() )
-	{
-	}
-	public TemplateParser( ITokenStream input, RecognizerSharedState state )
-		: base( input, state )
-	{
-	}
-
-
-	public override string[] TokenNames { get { return TemplateParser.tokenNames; } }
-	public override string GrammarFileName { get { return "Language\\Template.g3"; } }
-
-
-	#region Rules
-
-	// $ANTLR start "template"
-	// Language\\Template.g3:114:0: public template[StringTemplate self] : (s= LITERAL |nl= NEWLINE | action[self] )* ( EOF )? ;
-	public void template( StringTemplate self )
-	{
-		IToken s=null;
-		IToken nl=null;
-
-
-			this.self = self;
-
-		try
-		{
-			// Language\\Template.g3:119:4: ( (s= LITERAL |nl= NEWLINE | action[self] )* ( EOF )? )
-			// Language\\Template.g3:119:4: (s= LITERAL |nl= NEWLINE | action[self] )* ( EOF )?
-			{
-			// Language\\Template.g3:119:4: (s= LITERAL |nl= NEWLINE | action[self] )*
-			for ( ; ; )
-			{
-				int alt1=4;
-				switch ( input.LA(1) )
-				{
-				case LITERAL:
-					{
-					alt1=1;
-					}
-					break;
-				case NEWLINE:
-					{
-					alt1=2;
-					}
-					break;
-				case ACTION:
-				case IF:
-				case REGION_DEF:
-				case REGION_REF:
-					{
-					alt1=3;
-					}
-					break;
-
-				}
-
-				switch ( alt1 )
-				{
-				case 1:
-					// Language\\Template.g3:119:6: s= LITERAL
-					{
-					s=(IToken)Match(input,LITERAL,Follow._LITERAL_in_template71);
-					self.AddChunk(new StringRef(self,(s!=null?s.Text:null)));
-
-					}
-					break;
-				case 2:
-					// Language\\Template.g3:120:5: nl= NEWLINE
-					{
-					nl=(IToken)Match(input,NEWLINE,Follow._NEWLINE_in_template82);
-
-									int next = input.LA(1);
-									if ( next!=ELSE && next!=ENDIF )
-									{
-										self.AddChunk(new NewlineRef(self,(nl!=null?nl.Text:null)));
-									}
-
-
-					}
-					break;
-				case 3:
-					// Language\\Template.g3:128:5: action[self]
-					{
-					PushFollow(Follow._action_in_template93);
-					action(self);
-
-					state._fsp--;
-
-
-					}
-					break;
-
-				default:
-					goto loop1;
-				}
-			}
-
-			loop1:
-				;
-
-
-			// Language\\Template.g3:130:3: ( EOF )?
-			int alt2=2;
-			int LA2_0 = input.LA(1);
-
-			if ( (LA2_0==EOF) )
-			{
-				alt2=1;
-			}
-			switch ( alt2 )
-			{
-			case 1:
-				// Language\\Template.g3:130:0: EOF
-				{
-				Match(input,EOF,Follow._EOF_in_template103);
-
-				}
-				break;
-
-			}
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "template"
-
-
-	// $ANTLR start "action"
-	// Language\\Template.g3:133:0: action[StringTemplate self] : (a= ACTION |i= IF template[subtemplate] (ei= ELSEIF template[elseIfSubtemplate] )* ( ELSE template[elseSubtemplate] )? ENDIF |rr= REGION_REF |rd= REGION_DEF );
-	private void action( StringTemplate self )
-	{
-		IToken a=null;
-		IToken i=null;
-		IToken ei=null;
-		IToken rr=null;
-		IToken rd=null;
-
-		try
-		{
-			// Language\\Template.g3:134:4: (a= ACTION |i= IF template[subtemplate] (ei= ELSEIF template[elseIfSubtemplate] )* ( ELSE template[elseSubtemplate] )? ENDIF |rr= REGION_REF |rd= REGION_DEF )
-			int alt5=4;
-			switch ( input.LA(1) )
-			{
-			case ACTION:
-				{
-				alt5=1;
-				}
-				break;
-			case IF:
-				{
-				alt5=2;
-				}
-				break;
-			case REGION_REF:
-				{
-				alt5=3;
-				}
-				break;
-			case REGION_DEF:
-				{
-				alt5=4;
-				}
-				break;
-			default:
-				{
-					NoViableAltException nvae = new NoViableAltException("", 5, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt5 )
-			{
-			case 1:
-				// Language\\Template.g3:134:4: a= ACTION
-				{
-				a=(IToken)Match(input,ACTION,Follow._ACTION_in_action118);
-
-							string indent = ((ChunkToken)a).Indentation;
-							ASTExpr c = self.ParseAction((a!=null?a.Text:null));
-							c.Indentation = indent;
-							self.AddChunk(c);
-
-
-				}
-				break;
-			case 2:
-				// Language\\Template.g3:142:4: i= IF template[subtemplate] (ei= ELSEIF template[elseIfSubtemplate] )* ( ELSE template[elseSubtemplate] )? ENDIF
-				{
-				i=(IToken)Match(input,IF,Follow._IF_in_action130);
-
-							ConditionalExpr c = (ConditionalExpr)self.ParseAction((i!=null?i.Text:null));
-							// create and precompile the subtemplate
-							StringTemplate subtemplate = new StringTemplate(self.Group, null);
-							subtemplate.EnclosingInstance = self;
-							subtemplate.Name = (i!=null?i.Text:null) + "_subtemplate";
-							self.AddChunk(c);
-
-				PushFollow(Follow._template_in_action139);
-				template(subtemplate);
-
-				state._fsp--;
-
-				if ( c!=null ) c.Subtemplate = subtemplate;
-				// Language\\Template.g3:154:3: (ei= ELSEIF template[elseIfSubtemplate] )*
-				for ( ; ; )
-				{
-					int alt3=2;
-					int LA3_0 = input.LA(1);
-
-					if ( (LA3_0==ELSEIF) )
-					{
-						alt3=1;
-					}
-
-
-					switch ( alt3 )
-					{
-					case 1:
-						// Language\\Template.g3:154:5: ei= ELSEIF template[elseIfSubtemplate]
-						{
-						ei=(IToken)Match(input,ELSEIF,Follow._ELSEIF_in_action151);
-
-										ASTExpr ec = self.ParseAction((ei!=null?ei.Text:null));
-										// create and precompile the subtemplate
-										StringTemplate elseIfSubtemplate = new StringTemplate(self.Group, null);
-										elseIfSubtemplate.EnclosingInstance = self;
-										elseIfSubtemplate.Name = (ei!=null?ei.Text:null) + "_subtemplate";
-
-						PushFollow(Follow._template_in_action162);
-						template(elseIfSubtemplate);
-
-						state._fsp--;
-
-						if ( c!=null ) c.AddElseIfSubtemplate(ec, elseIfSubtemplate);
-
-						}
-						break;
-
-					default:
-						goto loop3;
-					}
-				}
-
-				loop3:
-					;
-
-
-				// Language\\Template.g3:168:3: ( ELSE template[elseSubtemplate] )?
-				int alt4=2;
-				int LA4_0 = input.LA(1);
-
-				if ( (LA4_0==ELSE) )
-				{
-					alt4=1;
-				}
-				switch ( alt4 )
-				{
-				case 1:
-					// Language\\Template.g3:168:5: ELSE template[elseSubtemplate]
-					{
-					Match(input,ELSE,Follow._ELSE_in_action181);
-
-									// create and precompile the subtemplate
-									StringTemplate elseSubtemplate = new StringTemplate(self.Group, null);
-									elseSubtemplate.EnclosingInstance = self;
-									elseSubtemplate.Name = "else_subtemplate";
-
-					PushFollow(Follow._template_in_action192);
-					template(elseSubtemplate);
-
-					state._fsp--;
-
-					if ( c!=null ) c.ElseSubtemplate = elseSubtemplate;
-
-					}
-					break;
-
-				}
-
-				Match(input,ENDIF,Follow._ENDIF_in_action208);
-
-				}
-				break;
-			case 3:
-				// Language\\Template.g3:182:4: rr= REGION_REF
-				{
-				rr=(IToken)Match(input,REGION_REF,Follow._REGION_REF_in_action216);
-
-							// define implicit template and
-							// convert <@r()> to <region__enclosingTemplate__r()>
-							string regionName = (rr!=null?rr.Text:null);
-							string mangledRef = null;
-							bool err = false;
-							// watch out for <@super.r()>; that does NOT def implicit region
-							// convert to <super.region__enclosingTemplate__r()>
-							if ( regionName.StartsWith("super.") )
-							{
-								//System.Console.Out.WriteLine( "super region ref " + regionName );
-								string regionRef = regionName.substring("super.".Length,regionName.Length);
-								string templateScope = self.Group.GetUnMangledTemplateName(self.Name);
-								StringTemplate scopeST = self.Group.LookupTemplate(templateScope);
-								if ( scopeST==null )
-								{
-									self.Group.Error("reference to region within undefined template: "+templateScope);
-									err=true;
-								}
-								if ( !scopeST.ContainsRegionName(regionRef) )
-								{
-									self.Group.Error("template "+templateScope+" has no region called "+regionRef);
-									err=true;
-								}
-								else
-								{
-									mangledRef = self.Group.GetMangledRegionName(templateScope,regionRef);
-									mangledRef = "super."+mangledRef;
-								}
-							}
-							else
-							{
-								//System.out.println("region ref "+regionName);
-								StringTemplate regionST = self.Group.DefineImplicitRegionTemplate(self,regionName);
-								mangledRef = regionST.Name;
-							}
-
-							if ( !err )
-							{
-								// treat as regular action: mangled template include
-								string indent = ((ChunkToken)rr).Indentation;
-								ASTExpr c = self.ParseAction(mangledRef+"()");
-								c.Indentation = indent;
-								self.AddChunk(c);
-							}
-
-
-				}
-				break;
-			case 4:
-				// Language\\Template.g3:230:4: rd= REGION_DEF
-				{
-				rd=(IToken)Match(input,REGION_DEF,Follow._REGION_DEF_in_action228);
-
-							string combinedNameTemplateStr = (rd!=null?rd.Text:null);
-							int indexOfDefSymbol = combinedNameTemplateStr.IndexOf("::=");
-							if ( indexOfDefSymbol>=1 )
-							{
-								string regionName = combinedNameTemplateStr.substring(0,indexOfDefSymbol);
-								string template = combinedNameTemplateStr.substring(indexOfDefSymbol+3, combinedNameTemplateStr.Length);
-								StringTemplate regionST = self.Group.DefineRegionTemplate(self,regionName,template,RegionType.Embedded);
-								// treat as regular action: mangled template include
-								string indent = ((ChunkToken)rd).Indentation;
-								ASTExpr c = self.ParseAction(regionST.Name+"()");
-								c.Indentation = indent;
-								self.AddChunk(c);
-							}
-							else
-							{
-								self.Error("embedded region definition screwed up");
-							}
-
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "action"
-	#endregion Rules
-
-
-	#region Follow sets
-	private static class Follow
-	{
-		public static readonly BitSet _LITERAL_in_template71 = new BitSet(new ulong[]{0x3A2012UL});
-		public static readonly BitSet _NEWLINE_in_template82 = new BitSet(new ulong[]{0x3A2012UL});
-		public static readonly BitSet _action_in_template93 = new BitSet(new ulong[]{0x3A2012UL});
-		public static readonly BitSet _EOF_in_template103 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ACTION_in_action118 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _IF_in_action130 = new BitSet(new ulong[]{0x3A2010UL});
-		public static readonly BitSet _template_in_action139 = new BitSet(new ulong[]{0x1C0UL});
-		public static readonly BitSet _ELSEIF_in_action151 = new BitSet(new ulong[]{0x3A2010UL});
-		public static readonly BitSet _template_in_action162 = new BitSet(new ulong[]{0x1C0UL});
-		public static readonly BitSet _ELSE_in_action181 = new BitSet(new ulong[]{0x3A2010UL});
-		public static readonly BitSet _template_in_action192 = new BitSet(new ulong[]{0x100UL});
-		public static readonly BitSet _ENDIF_in_action208 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _REGION_REF_in_action216 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _REGION_DEF_in_action228 = new BitSet(new ulong[]{0x2UL});
-
-	}
-	#endregion Follow sets
-}
-
-} // namespace Antlr3.ST.Language
diff --git a/Antlr3.sln b/Antlr3.sln
index 4de56e8..f8f8c3d 100644
--- a/Antlr3.sln
+++ b/Antlr3.sln
@@ -64,12 +64,14 @@ Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Antlr3.Runtime.JavaExtensio
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Antlr3.Runtime.Test", "..\..\antlr\main\runtime\CSharp3\Sources\Antlr3.Runtime.Test\Antlr3.Runtime.Test.csproj", "{19B965DE-5100-4064-A580-159644F6980E}"
EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AntlrBuildTask", "AntlrBuildTask\AntlrBuildTask.csproj", "{60F8B554-5C53-4DE2-B868-A0BFEF4EF80E}"
+EndProject
Global
GlobalSection(TestCaseManagementSettings) = postSolution
CategoryFile = Antlr3.vsmdi
EndGlobalSection
GlobalSection(SourceCodeControl) = preSolution
-		SccNumberOfProjects = 21
+		SccNumberOfProjects = 22
SccProjectName0 = Perforce\u0020Project
SccLocalPath0 = ..\\..
SccProvider0 = MSSCCI:Perforce\u0020SCM
@@ -147,6 +149,9 @@ Global
SccProjectUniqueName20 = ..\\..\\antlr\\main\\runtime\\CSharp3\\Sources\\Antlr3.Runtime.JavaExtensions\\Antlr3.Runtime.JavaExtensions.csproj
SccLocalPath20 = ..\\..
SccProjectFilePathRelativizedFromConnection20 = antlr\\main\\runtime\\CSharp3\\Sources\\Antlr3.Runtime.JavaExtensions\\
+		SccProjectUniqueName21 = AntlrBuildTask\\AntlrBuildTask.csproj
+		SccLocalPath21 = ..\\..
+		SccProjectFilePathRelativizedFromConnection21 = antlrcs\\main\\AntlrBuildTask\\
EndGlobalSection
GlobalSection(SolutionConfigurationPlatforms) = preSolution
Debug|Any CPU = Debug|Any CPU
@@ -233,6 +238,9 @@ Global
{19B965DE-5100-4064-A580-159644F6980E}.Debug|Any CPU.Build.0 = Debug|Any CPU
{19B965DE-5100-4064-A580-159644F6980E}.Release|Any CPU.ActiveCfg = Release|Any CPU
{19B965DE-5100-4064-A580-159644F6980E}.Release|Any CPU.Build.0 = Release|Any CPU
+		{60F8B554-5C53-4DE2-B868-A0BFEF4EF80E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{60F8B554-5C53-4DE2-B868-A0BFEF4EF80E}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{60F8B554-5C53-4DE2-B868-A0BFEF4EF80E}.Release|Any CPU.Build.0 = Release|Any CPU
EndGlobalSection
GlobalSection(SolutionProperties) = preSolution
HideSolutionNode = FALSE
diff --git a/Antlr3/Antlr3.csproj b/Antlr3/Antlr3.csproj
index c9cc195..8c36b96 100644
--- a/Antlr3/Antlr3.csproj
+++ b/Antlr3/Antlr3.csproj
@@ -89,9 +89,7 @@
<Compile Include="Tool\ToolMessage.cs" />
</ItemGroup>
<ItemGroup>
-    <Antlr3 Include="Grammars\ActionTranslator.g3">
-      <OutputFiles>Grammars\ActionTranslator.cs;Grammars\ActionTranslator.tokens</OutputFiles>
-    </Antlr3>
+    <Antlr3 Include="Grammars\ActionTranslator.g3" />
<Compile Include="Codegen\ACyclicDFACodeGenerator.cs" />
<Compile Include="Tool\Attribute.cs" />
<Compile Include="Tool\AttributeScope.cs" />
@@ -100,104 +98,49 @@
<Compile Include="Tool\GrammarSanity.cs" />
<Compile Include="Tool\NameSpaceChecker.cs" />
<Compile Include="Tool\NFAFactory.cs" />
-    <Compile Include="Grammars\ActionTranslator.cs">
-      <AutoGen>True</AutoGen>
-      <DesignTime>True</DesignTime>
-      <DependentUpon>ActionTranslator.g3</DependentUpon>
-    </Compile>
<Compile Include="Grammars\ActionTranslatorHelper.cs">
<DependentUpon>ActionTranslator.g3</DependentUpon>
</Compile>
-    <Antlr3 Include="Grammars\CodeGenTreeWalker.g3">
-      <OutputFiles>Grammars\CodeGenTreeWalker.cs;Grammars\CodeGenTreeWalker.tokens</OutputFiles>
-    </Antlr3>
-    <Compile Include="Grammars\CodeGenTreeWalker.cs">
-      <AutoGen>True</AutoGen>
-      <DesignTime>True</DesignTime>
-      <DependentUpon>CodeGenTreeWalker.g3</DependentUpon>
-    </Compile>
+    <Antlr3 Include="Grammars\CodeGenTreeWalker.g3" />
<Compile Include="Grammars\CodeGenTreeWalkerHelper.cs">
<DependentUpon>CodeGenTreeWalker.g3</DependentUpon>
</Compile>
</ItemGroup>
<ItemGroup>
-    <Antlr3 Include="Grammars\ActionAnalysisLexer.g3">
-      <OutputFiles>Grammars\ActionAnalysisLexer.cs;Grammars\ActionAnalysisLexer.tokens</OutputFiles>
-    </Antlr3>
-    <Compile Include="Grammars\ActionAnalysisLexer.cs">
-      <AutoGen>True</AutoGen>
-      <DesignTime>True</DesignTime>
-      <DependentUpon>ActionAnalysisLexer.g3</DependentUpon>
-    </Compile>
+    <Antlr3 Include="Grammars\ActionAnalysisLexer.g3" />
<Compile Include="Grammars\ActionAnalysisLexerHelper.cs">
<DependentUpon>ActionAnalysisLexer.g3</DependentUpon>
</Compile>
</ItemGroup>
<ItemGroup>
-    <Antlr3 Include="Grammars\ANTLR.g3">
-      <OutputFiles>Grammars\ANTLRParser.cs;Grammars\ANTLRLexer.cs;Grammars\ANTLR.tokens</OutputFiles>
-      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
-    </Antlr3>
-    <Compile Include="Grammars\ANTLRParser.cs">
-      <AutoGen>True</AutoGen>
-      <DesignTime>True</DesignTime>
-      <DependentUpon>ANTLR.g3</DependentUpon>
-    </Compile>
+    <Antlr3 Include="Grammars\ANTLR.g3" />
<Compile Include="Grammars\ANTLRParserHelper.cs">
<DependentUpon>ANTLR.g3</DependentUpon>
</Compile>
-    <Compile Include="Grammars\ANTLRLexer.cs">
-      <AutoGen>True</AutoGen>
-      <DesignTime>True</DesignTime>
-      <DependentUpon>ANTLR.g3</DependentUpon>
-    </Compile>
<Compile Include="Grammars\ANTLRLexerHelper.cs">
<DependentUpon>ANTLR.g3</DependentUpon>
</Compile>
</ItemGroup>
<ItemGroup>
-    <Antlr3 Include="Grammars\ANTLRTreePrinter.g3">
-      <OutputFiles>Grammars\ANTLRTreePrinter.cs;Grammars\ANTLRTreePrinter.tokens</OutputFiles>
-    </Antlr3>
-    <Compile Include="Grammars\ANTLRTreePrinter.cs">
-      <AutoGen>True</AutoGen>
-      <DesignTime>True</DesignTime>
-      <DependentUpon>ANTLRTreePrinter.g3</DependentUpon>
-    </Compile>
+    <Antlr3 Include="Grammars\ANTLRTreePrinter.g3" />
<Compile Include="Grammars\ANTLRTreePrinterHelper.cs">
<DependentUpon>ANTLRTreePrinter.g3</DependentUpon>
</Compile>
</ItemGroup>
<ItemGroup>
-    <Antlr3 Include="Grammars\AssignTokenTypesWalker.g3">
-      <OutputFiles>Grammars\AssignTokenTypesWalker.cs;Grammars\AssignTokenTypesWalker.tokens</OutputFiles>
-    </Antlr3>
-    <Compile Include="Grammars\AssignTokenTypesWalker.cs">
-      <AutoGen>True</AutoGen>
-      <DesignTime>True</DesignTime>
-      <DependentUpon>AssignTokenTypesWalker.g3</DependentUpon>
-    </Compile>
+    <Antlr3 Include="Grammars\AssignTokenTypesWalker.g3" />
<Compile Include="Grammars\AssignTokenTypesWalkerHelper.cs">
<DependentUpon>AssignTokenTypesWalker.g3</DependentUpon>
</Compile>
</ItemGroup>
<ItemGroup>
-    <Antlr3 Include="Grammars\DefineGrammarItemsWalker.g3">
-      <OutputFiles>Grammars\DefineGrammarItemsWalker.cs;Grammars\DefineGrammarItemsWalker.tokens</OutputFiles>
-    </Antlr3>
-    <Compile Include="Grammars\DefineGrammarItemsWalker.cs">
-      <AutoGen>True</AutoGen>
-      <DesignTime>True</DesignTime>
-      <DependentUpon>DefineGrammarItemsWalker.g3</DependentUpon>
-    </Compile>
+    <Antlr3 Include="Grammars\DefineGrammarItemsWalker.g3" />
<Compile Include="Grammars\DefineGrammarItemsWalkerHelper.cs">
<DependentUpon>DefineGrammarItemsWalker.g3</DependentUpon>
</Compile>
</ItemGroup>
<ItemGroup>
-    <Antlr3 Include="Grammars\TreeToNFAConverter.g3">
-      <OutputFiles>Grammars\TreeToNFAConverter.cs;Grammars\TreeToNFAConverter.tokens</OutputFiles>
-    </Antlr3>
+    <Antlr3 Include="Grammars\TreeToNFAConverter.g3" />
<Compile Include="Extensions\EnumerableExtensions.cs" />
<Compile Include="Extensions\FuncEqualityComparer.cs" />
<Compile Include="Extensions\ListExtensions.cs" />
@@ -224,11 +167,6 @@
<Compile Include="Tool\NonRegularDecisionMessage.cs" />
<Compile Include="Tool\RecursionOverflowMessage.cs" />
<Compile Include="Tool\RuleLabelScope.cs" />
-    <Compile Include="Grammars\TreeToNFAConverter.cs">
-      <AutoGen>True</AutoGen>
-      <DesignTime>True</DesignTime>
-      <DependentUpon>TreeToNFAConverter.g3</DependentUpon>
-    </Compile>
<Compile Include="Grammars\TreeToNFAConverterHelper.cs">
<DependentUpon>TreeToNFAConverter.g3</DependentUpon>
</Compile>
@@ -561,29 +499,17 @@
<Name>Antlr3.StringTemplate</Name>
</ProjectReference>
</ItemGroup>
+
<PropertyGroup>
-    <UseHostCompilerIfAvailable>False</UseHostCompilerIfAvailable>
+    <!-- Folder containing AntlrBuildTask.dll -->
+    <AntlrBuildTaskPath>$(SolutionDir)bin\Bootstrap</AntlrBuildTaskPath>
+    <!-- Path to the ANTLR Tool itself. -->
+    <AntlrToolPath>$(SolutionDir)bin\Bootstrap\Antlr3.exe</AntlrToolPath>
</PropertyGroup>
+
<Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
-  <PropertyGroup>
-    <Antlr3ToolPath>$(MSBuildProjectDirectory)\..\bin\Bootstrap</Antlr3ToolPath>
-    <CoreCompileDependsOn>$(CoreCompileDependsOn);GenerateAntlrCode</CoreCompileDependsOn>
-    <CoreCleanDependsOn>$(CoreCleanDependsOn);CleanAntlrCode</CoreCleanDependsOn>
-    <PostBuildEvent>
-    </PostBuildEvent>
-  </PropertyGroup>
-  <Target Name="GenerateAntlrCode" Inputs="@(Antlr3)" Outputs="%(OutputFiles)">
-    <Message Importance="normal" Text="Antlr: Transforming '@(Antlr3)' to '%(Antlr3.OutputFiles)'" />
-    <!--<Exec Command="java -cp %22$(Antlr3ToolPath)\antlr3.jar;$(Antlr3ToolPath)\antlr-2.7.7.jar;$(Antlr3ToolPath)\stringtemplate-3.1b1.jar%22 org.antlr.Tool -lib %22%(RootDir)%(Directory).%22 -message-format vs2005 @(Antlr3)" Outputs="%(OutputFiles)" />-->
-    <Exec Command="%22$(Antlr3ToolPath)\Antlr3.exe%22 -Xconversiontimeout 60000 -lib %22%(RootDir)%(Directory).%22 -message-format vs2005 @(Antlr3)" Outputs="%(OutputFiles)" />
-  </Target>
-  <Target Name="CleanAntlrCode">
-    <ItemGroup>
-      <_CleanAntlrFileWrites Include="@(Antlr3->'%(RelativeDir)%(Filename).tokens')" />
-    </ItemGroup>
-    <Message Importance="normal" Text="Antlr: Deleting output files '@(_CleanAntlrFileWrites)'" />
-    <!--<Delete Files="@(_CleanAntlrFileWrites)" />-->
-  </Target>
+  <Import Project="$(SolutionDir)bin\Bootstrap\Antlr3.targets" />
+
<!-- To modify your build process, add your task inside one of the targets below and uncomment it.
Other similar extension points exist, see Microsoft.Common.targets.
<Target Name="BeforeBuild">
diff --git a/Antlr3/Grammars/ANTLRLexer.cs b/Antlr3/Grammars/ANTLRLexer.cs
deleted file mode 100644
index 9c8ad0a..0000000
--- a/Antlr3/Grammars/ANTLRLexer.cs
+++ /dev/null
@@ -1,3958 +0,0 @@
-// $ANTLR 3.1.2 Grammars\\ANTLR.g3 2009-09-30 13:27:50
-
-// The variable 'variable' is assigned but its value is never used.
-#pragma warning disable 219
-// Unreachable code detected.
-#pragma warning disable 162
-
-
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Grammar conversion to ANTLR v3 and C#:
- Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-	notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-	derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-using ErrorManager = Antlr3.Tool.ErrorManager;
-using Grammar = Antlr3.Tool.Grammar;
-using StringBuffer = System.Text.StringBuilder;
-
-
-using System.Collections.Generic;
-using Antlr.Runtime;
-using Stack = System.Collections.Generic.Stack<object>;
-using List = System.Collections.IList;
-using ArrayList = System.Collections.Generic.List<object>;
-using Map = System.Collections.IDictionary;
-using HashMap = System.Collections.Generic.Dictionary<object, object>;
-namespace Antlr3.Grammars
-{
-[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.1.2")]
-[System.CLSCompliant(false)]
-public partial class ANTLRLexer : Lexer
-{
-	public const int EOF=-1;
-	public const int ACTION=4;
-	public const int ACTION_CHAR_LITERAL=5;
-	public const int ACTION_ESC=6;
-	public const int ACTION_STRING_LITERAL=7;
-	public const int ALT=8;
-	public const int AMPERSAND=9;
-	public const int ARG=10;
-	public const int ARG_ACTION=11;
-	public const int ARGLIST=12;
-	public const int ASSIGN=13;
-	public const int BACKTRACK_SEMPRED=14;
-	public const int BANG=15;
-	public const int BLOCK=16;
-	public const int CATCH=17;
-	public const int CHAR_LITERAL=18;
-	public const int CHAR_RANGE=19;
-	public const int CLOSE_ELEMENT_OPTION=20;
-	public const int CLOSURE=21;
-	public const int COLON=22;
-	public const int COMBINED_GRAMMAR=23;
-	public const int COMMA=24;
-	public const int COMMENT=25;
-	public const int DIGIT=26;
-	public const int DOC_COMMENT=27;
-	public const int DOLLAR=28;
-	public const int DOT=29;
-	public const int DOUBLE_ANGLE_STRING_LITERAL=30;
-	public const int DOUBLE_QUOTE_STRING_LITERAL=31;
-	public const int EOA=32;
-	public const int EOB=33;
-	public const int EOR=34;
-	public const int EPSILON=35;
-	public const int ESC=36;
-	public const int ETC=37;
-	public const int FINALLY=38;
-	public const int FORCED_ACTION=39;
-	public const int FRAGMENT=40;
-	public const int GATED_SEMPRED=41;
-	public const int GRAMMAR=42;
-	public const int ID=43;
-	public const int IMPLIES=44;
-	public const int IMPORT=45;
-	public const int INITACTION=46;
-	public const int INT=47;
-	public const int LABEL=48;
-	public const int LEXER=49;
-	public const int LEXER_GRAMMAR=50;
-	public const int LPAREN=51;
-	public const int ML_COMMENT=52;
-	public const int NESTED_ACTION=53;
-	public const int NESTED_ARG_ACTION=54;
-	public const int NOT=55;
-	public const int OPEN_ELEMENT_OPTION=56;
-	public const int OPTIONAL=57;
-	public const int OPTIONS=58;
-	public const int OR=59;
-	public const int PARSER=60;
-	public const int PARSER_GRAMMAR=61;
-	public const int PLUS=62;
-	public const int PLUS_ASSIGN=63;
-	public const int POSITIVE_CLOSURE=64;
-	public const int PRIVATE=65;
-	public const int PROTECTED=66;
-	public const int PUBLIC=67;
-	public const int QUESTION=68;
-	public const int RANGE=69;
-	public const int RCURLY=70;
-	public const int RET=71;
-	public const int RETURNS=72;
-	public const int REWRITE=73;
-	public const int ROOT=74;
-	public const int RPAREN=75;
-	public const int RULE=76;
-	public const int RULE_REF=77;
-	public const int SCOPE=78;
-	public const int SEMI=79;
-	public const int SEMPRED=80;
-	public const int SL_COMMENT=81;
-	public const int SRC=82;
-	public const int STAR=83;
-	public const int STRAY_BRACKET=84;
-	public const int STRING_LITERAL=85;
-	public const int SYN_SEMPRED=86;
-	public const int SYNPRED=87;
-	public const int TEMPLATE=88;
-	public const int THROWS=89;
-	public const int TOKEN_REF=90;
-	public const int TOKENS=91;
-	public const int TREE=92;
-	public const int TREE_BEGIN=93;
-	public const int TREE_GRAMMAR=94;
-	public const int WILDCARD=95;
-	public const int WS=96;
-	public const int WS_LOOP=97;
-	public const int WS_OPT=98;
-	public const int XDIGIT=99;
-
-    // delegates
-    // delegators
-
-	public ANTLRLexer() {}
-	public ANTLRLexer( ICharStream input )
-		: this( input, new RecognizerSharedState() )
-	{
-	}
-	public ANTLRLexer( ICharStream input, RecognizerSharedState state )
-		: base( input, state )
-	{
-
-	}
-	public override string GrammarFileName { get { return "Grammars\\ANTLR.g3"; } }
-
-	// $ANTLR start "CATCH"
-	private void mCATCH()
-	{
-		try
-		{
-			int _type = CATCH;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:46:9: ( 'catch' )
-			// Grammars\\ANTLR.g3:46:9: 'catch'
-			{
-			Match("catch"); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "CATCH"
-
-	// $ANTLR start "FINALLY"
-	private void mFINALLY()
-	{
-		try
-		{
-			int _type = FINALLY;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:47:11: ( 'finally' )
-			// Grammars\\ANTLR.g3:47:11: 'finally'
-			{
-			Match("finally"); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "FINALLY"
-
-	// $ANTLR start "FRAGMENT"
-	private void mFRAGMENT()
-	{
-		try
-		{
-			int _type = FRAGMENT;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:48:12: ( 'fragment' )
-			// Grammars\\ANTLR.g3:48:12: 'fragment'
-			{
-			Match("fragment"); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "FRAGMENT"
-
-	// $ANTLR start "GRAMMAR"
-	private void mGRAMMAR()
-	{
-		try
-		{
-			int _type = GRAMMAR;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:49:11: ( 'grammar' )
-			// Grammars\\ANTLR.g3:49:11: 'grammar'
-			{
-			Match("grammar"); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "GRAMMAR"
-
-	// $ANTLR start "IMPORT"
-	private void mIMPORT()
-	{
-		try
-		{
-			int _type = IMPORT;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:50:10: ( 'import' )
-			// Grammars\\ANTLR.g3:50:10: 'import'
-			{
-			Match("import"); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "IMPORT"
-
-	// $ANTLR start "LEXER"
-	private void mLEXER()
-	{
-		try
-		{
-			int _type = LEXER;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:51:9: ( 'lexer' )
-			// Grammars\\ANTLR.g3:51:9: 'lexer'
-			{
-			Match("lexer"); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "LEXER"
-
-	// $ANTLR start "PARSER"
-	private void mPARSER()
-	{
-		try
-		{
-			int _type = PARSER;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:52:10: ( 'parser' )
-			// Grammars\\ANTLR.g3:52:10: 'parser'
-			{
-			Match("parser"); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "PARSER"
-
-	// $ANTLR start "PRIVATE"
-	private void mPRIVATE()
-	{
-		try
-		{
-			int _type = PRIVATE;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:53:11: ( 'private' )
-			// Grammars\\ANTLR.g3:53:11: 'private'
-			{
-			Match("private"); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "PRIVATE"
-
-	// $ANTLR start "PROTECTED"
-	private void mPROTECTED()
-	{
-		try
-		{
-			int _type = PROTECTED;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:54:13: ( 'protected' )
-			// Grammars\\ANTLR.g3:54:13: 'protected'
-			{
-			Match("protected"); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "PROTECTED"
-
-	// $ANTLR start "PUBLIC"
-	private void mPUBLIC()
-	{
-		try
-		{
-			int _type = PUBLIC;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:55:10: ( 'public' )
-			// Grammars\\ANTLR.g3:55:10: 'public'
-			{
-			Match("public"); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "PUBLIC"
-
-	// $ANTLR start "RETURNS"
-	private void mRETURNS()
-	{
-		try
-		{
-			int _type = RETURNS;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:56:11: ( 'returns' )
-			// Grammars\\ANTLR.g3:56:11: 'returns'
-			{
-			Match("returns"); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "RETURNS"
-
-	// $ANTLR start "SCOPE"
-	private void mSCOPE()
-	{
-		try
-		{
-			int _type = SCOPE;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:57:9: ( 'scope' )
-			// Grammars\\ANTLR.g3:57:9: 'scope'
-			{
-			Match("scope"); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "SCOPE"
-
-	// $ANTLR start "THROWS"
-	private void mTHROWS()
-	{
-		try
-		{
-			int _type = THROWS;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:58:10: ( 'throws' )
-			// Grammars\\ANTLR.g3:58:10: 'throws'
-			{
-			Match("throws"); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "THROWS"
-
-	// $ANTLR start "TREE"
-	private void mTREE()
-	{
-		try
-		{
-			int _type = TREE;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:59:8: ( 'tree' )
-			// Grammars\\ANTLR.g3:59:8: 'tree'
-			{
-			Match("tree"); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "TREE"
-
-	// $ANTLR start "STRING_LITERAL"
-	private void mSTRING_LITERAL()
-	{
-		try
-		{
-			// Grammars\\ANTLR.g3:805:27: ()
-			// Grammars\\ANTLR.g3:805:27:
-			{
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "STRING_LITERAL"
-
-	// $ANTLR start "FORCED_ACTION"
-	private void mFORCED_ACTION()
-	{
-		try
-		{
-			// Grammars\\ANTLR.g3:806:26: ()
-			// Grammars\\ANTLR.g3:806:26:
-			{
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "FORCED_ACTION"
-
-	// $ANTLR start "DOC_COMMENT"
-	private void mDOC_COMMENT()
-	{
-		try
-		{
-			// Grammars\\ANTLR.g3:807:24: ()
-			// Grammars\\ANTLR.g3:807:24:
-			{
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "DOC_COMMENT"
-
-	// $ANTLR start "SEMPRED"
-	private void mSEMPRED()
-	{
-		try
-		{
-			// Grammars\\ANTLR.g3:808:20: ()
-			// Grammars\\ANTLR.g3:808:20:
-			{
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "SEMPRED"
-
-	// $ANTLR start "WS"
-	private void mWS()
-	{
-		try
-		{
-			int _type = WS;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:811:4: ( ( ' ' | '\\t' | ( '\\r' )? '\\n' ) )
-			// Grammars\\ANTLR.g3:811:4: ( ' ' | '\\t' | ( '\\r' )? '\\n' )
-			{
-			// Grammars\\ANTLR.g3:811:4: ( ' ' | '\\t' | ( '\\r' )? '\\n' )
-			int alt2=3;
-			switch ( input.LA(1) )
-			{
-			case ' ':
-				{
-				alt2=1;
-				}
-				break;
-			case '\t':
-				{
-				alt2=2;
-				}
-				break;
-			case '\n':
-			case '\r':
-				{
-				alt2=3;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt2 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:811:6: ' '
-				{
-				Match(' '); if (state.failed) return ;
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:812:5: '\\t'
-				{
-				Match('\t'); if (state.failed) return ;
-
-				}
-				break;
-			case 3:
-				// Grammars\\ANTLR.g3:813:5: ( '\\r' )? '\\n'
-				{
-				// Grammars\\ANTLR.g3:813:5: ( '\\r' )?
-				int alt1=2;
-				int LA1_0 = input.LA(1);
-
-				if ( (LA1_0=='\r') )
-				{
-					alt1=1;
-				}
-				switch ( alt1 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:813:6: '\\r'
-					{
-					Match('\r'); if (state.failed) return ;
-
-					}
-					break;
-
-				}
-
-				Match('\n'); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-			if ( state.backtracking == 0 )
-			{
-				 _channel = Hidden;
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "WS"
-
-	// $ANTLR start "COMMENT"
-	private void mCOMMENT()
-	{
-		try
-		{
-			int _type = COMMENT;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:819:4: ( ( SL_COMMENT | ML_COMMENT[ref $type] ) )
-			// Grammars\\ANTLR.g3:819:4: ( SL_COMMENT | ML_COMMENT[ref $type] )
-			{
-			// Grammars\\ANTLR.g3:819:4: ( SL_COMMENT | ML_COMMENT[ref $type] )
-			int alt3=2;
-			int LA3_0 = input.LA(1);
-
-			if ( (LA3_0=='/') )
-			{
-				int LA3_1 = input.LA(2);
-
-				if ( (LA3_1=='/') )
-				{
-					alt3=1;
-				}
-				else if ( (LA3_1=='*') )
-				{
-					alt3=2;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					NoViableAltException nvae = new NoViableAltException("", 3, 1, input);
-
-					throw nvae;
-				}
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt3 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:819:6: SL_COMMENT
-				{
-				mSL_COMMENT(); if (state.failed) return ;
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:819:19: ML_COMMENT[ref $type]
-				{
-				mML_COMMENT(ref _type); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-			if ( state.backtracking == 0 )
-			{
-
-							if ( _type != DOC_COMMENT )
-								_channel = Hidden;
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "COMMENT"
-
-	// $ANTLR start "SL_COMMENT"
-	private void mSL_COMMENT()
-	{
-		try
-		{
-			// Grammars\\ANTLR.g3:829:4: ( '//' (=> ' $ANTLR ' SRC ( ( '\\r' )? '\\n' )? | (~ ( '\\r' | '\\n' ) )* ( ( '\\r' )? '\\n' )? ) )
-			// Grammars\\ANTLR.g3:829:4: '//' (=> ' $ANTLR ' SRC ( ( '\\r' )? '\\n' )? | (~ ( '\\r' | '\\n' ) )* ( ( '\\r' )? '\\n' )? )
-			{
-			Match("//"); if (state.failed) return ;
-
-			// Grammars\\ANTLR.g3:830:3: (=> ' $ANTLR ' SRC ( ( '\\r' )? '\\n' )? | (~ ( '\\r' | '\\n' ) )* ( ( '\\r' )? '\\n' )? )
-			int alt9=2;
-			alt9 = dfa9.Predict(input);
-			switch ( alt9 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:830:5: => ' $ANTLR ' SRC ( ( '\\r' )? '\\n' )?
-				{
-
-				Match(" $ANTLR "); if (state.failed) return ;
-
-				mSRC(); if (state.failed) return ;
-				// Grammars\\ANTLR.g3:830:35: ( ( '\\r' )? '\\n' )?
-				int alt5=2;
-				int LA5_0 = input.LA(1);
-
-				if ( (LA5_0=='\n'||LA5_0=='\r') )
-				{
-					alt5=1;
-				}
-				switch ( alt5 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:830:36: ( '\\r' )? '\\n'
-					{
-					// Grammars\\ANTLR.g3:830:36: ( '\\r' )?
-					int alt4=2;
-					int LA4_0 = input.LA(1);
-
-					if ( (LA4_0=='\r') )
-					{
-						alt4=1;
-					}
-					switch ( alt4 )
-					{
-					case 1:
-						// Grammars\\ANTLR.g3:830:37: '\\r'
-						{
-						Match('\r'); if (state.failed) return ;
-
-						}
-						break;
-
-					}
-
-					Match('\n'); if (state.failed) return ;
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:831:5: (~ ( '\\r' | '\\n' ) )* ( ( '\\r' )? '\\n' )?
-				{
-				// Grammars\\ANTLR.g3:831:5: (~ ( '\\r' | '\\n' ) )*
-				for ( ; ; )
-				{
-					int alt6=2;
-					int LA6_0 = input.LA(1);
-
-					if ( ((LA6_0>='\u0000' && LA6_0<='\t')||(LA6_0>='\u000B' && LA6_0<='\f')||(LA6_0>='\u000E' && LA6_0<='\uFFFF')) )
-					{
-						alt6=1;
-					}
-
-
-					switch ( alt6 )
-					{
-					case 1:
-						// Grammars\\ANTLR.g3:
-						{
-						input.Consume();
-						state.failed=false;
-
-						}
-						break;
-
-					default:
-						goto loop6;
-					}
-				}
-
-				loop6:
-					;
-
-
-				// Grammars\\ANTLR.g3:831:19: ( ( '\\r' )? '\\n' )?
-				int alt8=2;
-				int LA8_0 = input.LA(1);
-
-				if ( (LA8_0=='\n'||LA8_0=='\r') )
-				{
-					alt8=1;
-				}
-				switch ( alt8 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:831:20: ( '\\r' )? '\\n'
-					{
-					// Grammars\\ANTLR.g3:831:20: ( '\\r' )?
-					int alt7=2;
-					int LA7_0 = input.LA(1);
-
-					if ( (LA7_0=='\r') )
-					{
-						alt7=1;
-					}
-					switch ( alt7 )
-					{
-					case 1:
-						// Grammars\\ANTLR.g3:831:21: '\\r'
-						{
-						Match('\r'); if (state.failed) return ;
-
-						}
-						break;
-
-					}
-
-					Match('\n'); if (state.failed) return ;
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-
-			}
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "SL_COMMENT"
-
-	// $ANTLR start "ML_COMMENT"
-	private void mML_COMMENT(ref int type)
-	{
-		try
-		{
-			// Grammars\\ANTLR.g3:837:4: ( '/*' ( . )* '*/' )
-			// Grammars\\ANTLR.g3:837:4: '/*' ( . )* '*/'
-			{
-			Match("/*"); if (state.failed) return ;
-
-			if ( state.backtracking == 0 )
-			{
-				type = (input.LA(1) == '*' && input.LA(2) != '/') ? DOC_COMMENT : ML_COMMENT;
-			}
-			// Grammars\\ANTLR.g3:839:3: ( . )*
-			for ( ; ; )
-			{
-				int alt10=2;
-				int LA10_0 = input.LA(1);
-
-				if ( (LA10_0=='*') )
-				{
-					int LA10_1 = input.LA(2);
-
-					if ( (LA10_1=='/') )
-					{
-						alt10=2;
-					}
-					else if ( ((LA10_1>='\u0000' && LA10_1<='.')||(LA10_1>='0' && LA10_1<='\uFFFF')) )
-					{
-						alt10=1;
-					}
-
-
-				}
-				else if ( ((LA10_0>='\u0000' && LA10_0<=')')||(LA10_0>='+' && LA10_0<='\uFFFF')) )
-				{
-					alt10=1;
-				}
-
-
-				switch ( alt10 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:839:0: .
-					{
-					MatchAny(); if (state.failed) return ;
-
-					}
-					break;
-
-				default:
-					goto loop10;
-				}
-			}
-
-			loop10:
-				;
-
-
-			Match("*/"); if (state.failed) return ;
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ML_COMMENT"
-
-	// $ANTLR start "OPEN_ELEMENT_OPTION"
-	private void mOPEN_ELEMENT_OPTION()
-	{
-		try
-		{
-			int _type = OPEN_ELEMENT_OPTION;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:843:4: ( '<' )
-			// Grammars\\ANTLR.g3:843:4: '<'
-			{
-			Match('<'); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "OPEN_ELEMENT_OPTION"
-
-	// $ANTLR start "CLOSE_ELEMENT_OPTION"
-	private void mCLOSE_ELEMENT_OPTION()
-	{
-		try
-		{
-			int _type = CLOSE_ELEMENT_OPTION;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:847:4: ( '>' )
-			// Grammars\\ANTLR.g3:847:4: '>'
-			{
-			Match('>'); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "CLOSE_ELEMENT_OPTION"
-
-	// $ANTLR start "AMPERSAND"
-	private void mAMPERSAND()
-	{
-		try
-		{
-			int _type = AMPERSAND;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:850:13: ( '@' )
-			// Grammars\\ANTLR.g3:850:13: '@'
-			{
-			Match('@'); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "AMPERSAND"
-
-	// $ANTLR start "COMMA"
-	private void mCOMMA()
-	{
-		try
-		{
-			int _type = COMMA;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:852:9: ( ',' )
-			// Grammars\\ANTLR.g3:852:9: ','
-			{
-			Match(','); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "COMMA"
-
-	// $ANTLR start "QUESTION"
-	private void mQUESTION()
-	{
-		try
-		{
-			int _type = QUESTION;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:854:12: ( '?' )
-			// Grammars\\ANTLR.g3:854:12: '?'
-			{
-			Match('?'); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "QUESTION"
-
-	// $ANTLR start "TREE_BEGIN"
-	private void mTREE_BEGIN()
-	{
-		try
-		{
-			int _type = TREE_BEGIN;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:856:14: ( '^(' )
-			// Grammars\\ANTLR.g3:856:14: '^('
-			{
-			Match("^("); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "TREE_BEGIN"
-
-	// $ANTLR start "LPAREN"
-	private void mLPAREN()
-	{
-		try
-		{
-			int _type = LPAREN;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:858:9: ( '(' )
-			// Grammars\\ANTLR.g3:858:9: '('
-			{
-			Match('('); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "LPAREN"
-
-	// $ANTLR start "RPAREN"
-	private void mRPAREN()
-	{
-		try
-		{
-			int _type = RPAREN;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:860:9: ( ')' )
-			// Grammars\\ANTLR.g3:860:9: ')'
-			{
-			Match(')'); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "RPAREN"
-
-	// $ANTLR start "COLON"
-	private void mCOLON()
-	{
-		try
-		{
-			int _type = COLON;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:862:9: ( ':' )
-			// Grammars\\ANTLR.g3:862:9: ':'
-			{
-			Match(':'); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "COLON"
-
-	// $ANTLR start "STAR"
-	private void mSTAR()
-	{
-		try
-		{
-			int _type = STAR;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:864:7: ( '*' )
-			// Grammars\\ANTLR.g3:864:7: '*'
-			{
-			Match('*'); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "STAR"
-
-	// $ANTLR start "PLUS"
-	private void mPLUS()
-	{
-		try
-		{
-			int _type = PLUS;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:866:7: ( '+' )
-			// Grammars\\ANTLR.g3:866:7: '+'
-			{
-			Match('+'); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "PLUS"
-
-	// $ANTLR start "ASSIGN"
-	private void mASSIGN()
-	{
-		try
-		{
-			int _type = ASSIGN;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:868:10: ( '=' )
-			// Grammars\\ANTLR.g3:868:10: '='
-			{
-			Match('='); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ASSIGN"
-
-	// $ANTLR start "PLUS_ASSIGN"
-	private void mPLUS_ASSIGN()
-	{
-		try
-		{
-			int _type = PLUS_ASSIGN;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:870:15: ( '+=' )
-			// Grammars\\ANTLR.g3:870:15: '+='
-			{
-			Match("+="); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "PLUS_ASSIGN"
-
-	// $ANTLR start "IMPLIES"
-	private void mIMPLIES()
-	{
-		try
-		{
-			int _type = IMPLIES;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:872:11: ( '=>' )
-			// Grammars\\ANTLR.g3:872:11: '=>'
-			{
-			Match("=>"); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "IMPLIES"
-
-	// $ANTLR start "REWRITE"
-	private void mREWRITE()
-	{
-		try
-		{
-			int _type = REWRITE;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:874:11: ( '->' )
-			// Grammars\\ANTLR.g3:874:11: '->'
-			{
-			Match("->"); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "REWRITE"
-
-	// $ANTLR start "SEMI"
-	private void mSEMI()
-	{
-		try
-		{
-			int _type = SEMI;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:876:7: ( ';' )
-			// Grammars\\ANTLR.g3:876:7: ';'
-			{
-			Match(';'); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "SEMI"
-
-	// $ANTLR start "ROOT"
-	private void mROOT()
-	{
-		try
-		{
-			int _type = ROOT;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:878:8: ( '^' )
-			// Grammars\\ANTLR.g3:878:8: '^'
-			{
-			Match('^'); if (state.failed) return ;
-			if ( state.backtracking == 0 )
-			{
-				hasASTOperator=true;
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ROOT"
-
-	// $ANTLR start "BANG"
-	private void mBANG()
-	{
-		try
-		{
-			int _type = BANG;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:880:8: ( '!' )
-			// Grammars\\ANTLR.g3:880:8: '!'
-			{
-			Match('!'); if (state.failed) return ;
-			if ( state.backtracking == 0 )
-			{
-				hasASTOperator=true;
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "BANG"
-
-	// $ANTLR start "OR"
-	private void mOR()
-	{
-		try
-		{
-			int _type = OR;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:882:6: ( '|' )
-			// Grammars\\ANTLR.g3:882:6: '|'
-			{
-			Match('|'); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "OR"
-
-	// $ANTLR start "WILDCARD"
-	private void mWILDCARD()
-	{
-		try
-		{
-			int _type = WILDCARD;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:884:12: ( '.' )
-			// Grammars\\ANTLR.g3:884:12: '.'
-			{
-			Match('.'); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "WILDCARD"
-
-	// $ANTLR start "ETC"
-	private void mETC()
-	{
-		try
-		{
-			int _type = ETC;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:886:7: ( '...' )
-			// Grammars\\ANTLR.g3:886:7: '...'
-			{
-			Match("..."); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ETC"
-
-	// $ANTLR start "RANGE"
-	private void mRANGE()
-	{
-		try
-		{
-			int _type = RANGE;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:888:9: ( '..' )
-			// Grammars\\ANTLR.g3:888:9: '..'
-			{
-			Match(".."); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "RANGE"
-
-	// $ANTLR start "NOT"
-	private void mNOT()
-	{
-		try
-		{
-			int _type = NOT;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:890:7: ( '~' )
-			// Grammars\\ANTLR.g3:890:7: '~'
-			{
-			Match('~'); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "NOT"
-
-	// $ANTLR start "RCURLY"
-	private void mRCURLY()
-	{
-		try
-		{
-			int _type = RCURLY;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:892:9: ( '}' )
-			// Grammars\\ANTLR.g3:892:9: '}'
-			{
-			Match('}'); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "RCURLY"
-
-	// $ANTLR start "DOLLAR"
-	private void mDOLLAR()
-	{
-		try
-		{
-			int _type = DOLLAR;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:894:10: ( '$' )
-			// Grammars\\ANTLR.g3:894:10: '$'
-			{
-			Match('$'); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "DOLLAR"
-
-	// $ANTLR start "STRAY_BRACKET"
-	private void mSTRAY_BRACKET()
-	{
-		try
-		{
-			int _type = STRAY_BRACKET;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:897:4: ( ']' )
-			// Grammars\\ANTLR.g3:897:4: ']'
-			{
-			Match(']'); if (state.failed) return ;
-			if ( state.backtracking == 0 )
-			{
-
-							ErrorManager.SyntaxError(
-								ErrorManager.MSG_SYNTAX_ERROR,
-								null,
-								state.token,
-								"antlr: dangling ']'? make sure to escape with \\]",
-								null);
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "STRAY_BRACKET"
-
-	// $ANTLR start "CHAR_LITERAL"
-	private void mCHAR_LITERAL()
-	{
-		try
-		{
-			int _type = CHAR_LITERAL;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:909:4: ( '\\'' ( ESC |~ ( '\\\\' | '\\'' ) )* '\\'' )
-			// Grammars\\ANTLR.g3:909:4: '\\'' ( ESC |~ ( '\\\\' | '\\'' ) )* '\\''
-			{
-			Match('\''); if (state.failed) return ;
-			// Grammars\\ANTLR.g3:910:3: ( ESC |~ ( '\\\\' | '\\'' ) )*
-			for ( ; ; )
-			{
-				int alt11=3;
-				int LA11_0 = input.LA(1);
-
-				if ( (LA11_0=='\\') )
-				{
-					alt11=1;
-				}
-				else if ( ((LA11_0>='\u0000' && LA11_0<='&')||(LA11_0>='(' && LA11_0<='[')||(LA11_0>=']' && LA11_0<='\uFFFF')) )
-				{
-					alt11=2;
-				}
-
-
-				switch ( alt11 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:910:5: ESC
-					{
-					mESC(); if (state.failed) return ;
-
-					}
-					break;
-				case 2:
-					// Grammars\\ANTLR.g3:911:5: ~ ( '\\\\' | '\\'' )
-					{
-					input.Consume();
-					state.failed=false;
-
-					}
-					break;
-
-				default:
-					goto loop11;
-				}
-			}
-
-			loop11:
-				;
-
-
-			Match('\''); if (state.failed) return ;
-			if ( state.backtracking == 0 )
-			{
-
-							StringBuffer s = Grammar.GetUnescapedStringFromGrammarStringLiteral(Text);
-							if ( s.Length > 1 )
-							{
-								_type = STRING_LITERAL;
-							}
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "CHAR_LITERAL"
-
-	// $ANTLR start "DOUBLE_QUOTE_STRING_LITERAL"
-	private void mDOUBLE_QUOTE_STRING_LITERAL()
-	{
-		try
-		{
-			int _type = DOUBLE_QUOTE_STRING_LITERAL;
-			int _channel = DefaultTokenChannel;
-			int c;
-
-
-				System.Text.StringBuilder builder = new System.Text.StringBuilder();
-
-			// Grammars\\ANTLR.g3:928:4: ( '\"' (=> '\\\\' '\"' | '\\\\' c=~ '\"' |c=~ ( '\\\\' | '\"' ) )* '\"' )
-			// Grammars\\ANTLR.g3:928:4: '\"' (=> '\\\\' '\"' | '\\\\' c=~ '\"' |c=~ ( '\\\\' | '\"' ) )* '\"'
-			{
-			Match('\"'); if (state.failed) return ;
-			if ( state.backtracking == 0 )
-			{
-				builder.Append('"');
-			}
-			// Grammars\\ANTLR.g3:929:3: (=> '\\\\' '\"' | '\\\\' c=~ '\"' |c=~ ( '\\\\' | '\"' ) )*
-			for ( ; ; )
-			{
-				int alt12=4;
-				int LA12_0 = input.LA(1);
-
-				if ( (LA12_0=='\\') )
-				{
-					int LA12_2 = input.LA(2);
-
-					if ( (LA12_2=='\"') && (EvaluatePredicate(synpred2_ANTLR_fragment)))
-					{
-						alt12=1;
-					}
-					else if ( ((LA12_2>='\u0000' && LA12_2<='!')||(LA12_2>='#' && LA12_2<='\uFFFF')) )
-					{
-						alt12=2;
-					}
-
-
-				}
-				else if ( ((LA12_0>='\u0000' && LA12_0<='!')||(LA12_0>='#' && LA12_0<='[')||(LA12_0>=']' && LA12_0<='\uFFFF')) )
-				{
-					alt12=3;
-				}
-
-
-				switch ( alt12 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:929:5: => '\\\\' '\"'
-					{
-
-					Match('\\'); if (state.failed) return ;
-					Match('\"'); if (state.failed) return ;
-					if ( state.backtracking == 0 )
-					{
-						builder.Append('"');
-					}
-
-					}
-					break;
-				case 2:
-					// Grammars\\ANTLR.g3:930:5: '\\\\' c=~ '\"'
-					{
-					Match('\\'); if (state.failed) return ;
-					c= input.LA(1);
-					input.Consume();
-					state.failed=false;
-					if ( state.backtracking == 0 )
-					{
-						builder.Append("\\" + (char)c);
-					}
-
-					}
-					break;
-				case 3:
-					// Grammars\\ANTLR.g3:931:5: c=~ ( '\\\\' | '\"' )
-					{
-					c= input.LA(1);
-					input.Consume();
-					state.failed=false;
-					if ( state.backtracking == 0 )
-					{
-						builder.Append((char)c);
-					}
-
-					}
-					break;
-
-				default:
-					goto loop12;
-				}
-			}
-
-			loop12:
-				;
-
-
-			Match('\"'); if (state.failed) return ;
-			if ( state.backtracking == 0 )
-			{
-				builder.Append('"');
-			}
-			if ( state.backtracking == 0 )
-			{
-
-							Text = builder.ToString();
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "DOUBLE_QUOTE_STRING_LITERAL"
-
-	// $ANTLR start "DOUBLE_ANGLE_STRING_LITERAL"
-	private void mDOUBLE_ANGLE_STRING_LITERAL()
-	{
-		try
-		{
-			int _type = DOUBLE_ANGLE_STRING_LITERAL;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:940:4: ( '<<' ( . )* '>>' )
-			// Grammars\\ANTLR.g3:940:4: '<<' ( . )* '>>'
-			{
-			Match("<<"); if (state.failed) return ;
-
-			// Grammars\\ANTLR.g3:940:9: ( . )*
-			for ( ; ; )
-			{
-				int alt13=2;
-				int LA13_0 = input.LA(1);
-
-				if ( (LA13_0=='>') )
-				{
-					int LA13_1 = input.LA(2);
-
-					if ( (LA13_1=='>') )
-					{
-						alt13=2;
-					}
-					else if ( ((LA13_1>='\u0000' && LA13_1<='=')||(LA13_1>='?' && LA13_1<='\uFFFF')) )
-					{
-						alt13=1;
-					}
-
-
-				}
-				else if ( ((LA13_0>='\u0000' && LA13_0<='=')||(LA13_0>='?' && LA13_0<='\uFFFF')) )
-				{
-					alt13=1;
-				}
-
-
-				switch ( alt13 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:940:0: .
-					{
-					MatchAny(); if (state.failed) return ;
-
-					}
-					break;
-
-				default:
-					goto loop13;
-				}
-			}
-
-			loop13:
-				;
-
-
-			Match(">>"); if (state.failed) return ;
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "DOUBLE_ANGLE_STRING_LITERAL"
-
-	// $ANTLR start "ESC"
-	private void mESC()
-	{
-		try
-		{
-			// Grammars\\ANTLR.g3:946:4: ( '\\\\' ( . ) )
-			// Grammars\\ANTLR.g3:946:4: '\\\\' ( . )
-			{
-			Match('\\'); if (state.failed) return ;
-			// Grammars\\ANTLR.g3:947:3: ( . )
-			// Grammars\\ANTLR.g3:958:7: .
-			{
-			MatchAny(); if (state.failed) return ;
-
-			}
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ESC"
-
-	// $ANTLR start "DIGIT"
-	private void mDIGIT()
-	{
-		try
-		{
-			// Grammars\\ANTLR.g3:964:4: ( '0' .. '9' )
-			// Grammars\\ANTLR.g3:
-			{
-			if ( (input.LA(1)>='0' && input.LA(1)<='9') )
-			{
-				input.Consume();
-			state.failed=false;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				MismatchedSetException mse = new MismatchedSetException(null,input);
-				Recover(mse);
-				throw mse;}
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "DIGIT"
-
-	// $ANTLR start "XDIGIT"
-	private void mXDIGIT()
-	{
-		try
-		{
-			// Grammars\\ANTLR.g3:969:4: ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )
-			// Grammars\\ANTLR.g3:
-			{
-			if ( (input.LA(1)>='0' && input.LA(1)<='9')||(input.LA(1)>='A' && input.LA(1)<='F')||(input.LA(1)>='a' && input.LA(1)<='f') )
-			{
-				input.Consume();
-			state.failed=false;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				MismatchedSetException mse = new MismatchedSetException(null,input);
-				Recover(mse);
-				throw mse;}
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "XDIGIT"
-
-	// $ANTLR start "INT"
-	private void mINT()
-	{
-		try
-		{
-			int _type = INT;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:974:4: ( ( '0' .. '9' )+ )
-			// Grammars\\ANTLR.g3:974:4: ( '0' .. '9' )+
-			{
-			// Grammars\\ANTLR.g3:974:4: ( '0' .. '9' )+
-			int cnt14=0;
-			for ( ; ; )
-			{
-				int alt14=2;
-				int LA14_0 = input.LA(1);
-
-				if ( ((LA14_0>='0' && LA14_0<='9')) )
-				{
-					alt14=1;
-				}
-
-
-				switch ( alt14 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:
-					{
-					input.Consume();
-					state.failed=false;
-
-					}
-					break;
-
-				default:
-					if ( cnt14 >= 1 )
-						goto loop14;
-
-					if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee14 = new EarlyExitException( 14, input );
-					throw eee14;
-				}
-				cnt14++;
-			}
-			loop14:
-				;
-
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "INT"
-
-	// $ANTLR start "ARG_ACTION"
-	private void mARG_ACTION()
-	{
-		try
-		{
-			int _type = ARG_ACTION;
-			int _channel = DefaultTokenChannel;
-
-				string text_ = string.Empty;
-
-			// Grammars\\ANTLR.g3:982:4: ( '[' NESTED_ARG_ACTION[out text_] ']' )
-			// Grammars\\ANTLR.g3:982:4: '[' NESTED_ARG_ACTION[out text_] ']'
-			{
-			Match('['); if (state.failed) return ;
-			mNESTED_ARG_ACTION(out text_); if (state.failed) return ;
-			Match(']'); if (state.failed) return ;
-			if ( state.backtracking == 0 )
-			{
-				 Text = text_;
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ARG_ACTION"
-
-	// $ANTLR start "NESTED_ARG_ACTION"
-	private void mNESTED_ARG_ACTION(out string text_)
-	{
-		try
-		{
-			CommonToken ACTION_STRING_LITERAL1=null;
-			CommonToken ACTION_CHAR_LITERAL2=null;
-			int c;
-
-
-				text_ = string.Empty;
-				System.Text.StringBuilder builder = new System.Text.StringBuilder();
-
-			// Grammars\\ANTLR.g3:996:4: ( (=> '\\\\' ']' | '\\\\' c=~ ( ']' ) | ACTION_STRING_LITERAL | ACTION_CHAR_LITERAL |c=~ ( '\\\\' | '\"' | '\\'' | ']' ) )* )
-			// Grammars\\ANTLR.g3:996:4: (=> '\\\\' ']' | '\\\\' c=~ ( ']' ) | ACTION_STRING_LITERAL | ACTION_CHAR_LITERAL |c=~ ( '\\\\' | '\"' | '\\'' | ']' ) )*
-			{
-			// Grammars\\ANTLR.g3:996:4: (=> '\\\\' ']' | '\\\\' c=~ ( ']' ) | ACTION_STRING_LITERAL | ACTION_CHAR_LITERAL |c=~ ( '\\\\' | '\"' | '\\'' | ']' ) )*
-			for ( ; ; )
-			{
-				int alt15=6;
-				int LA15_0 = input.LA(1);
-
-				if ( (LA15_0=='\\') )
-				{
-					int LA15_2 = input.LA(2);
-
-					if ( (LA15_2==']') && (EvaluatePredicate(synpred3_ANTLR_fragment)))
-					{
-						alt15=1;
-					}
-					else if ( ((LA15_2>='\u0000' && LA15_2<='\\')||(LA15_2>='^' && LA15_2<='\uFFFF')) )
-					{
-						alt15=2;
-					}
-
-
-				}
-				else if ( (LA15_0=='\"') )
-				{
-					alt15=3;
-				}
-				else if ( (LA15_0=='\'') )
-				{
-					alt15=4;
-				}
-				else if ( ((LA15_0>='\u0000' && LA15_0<='!')||(LA15_0>='#' && LA15_0<='&')||(LA15_0>='(' && LA15_0<='[')||(LA15_0>='^' && LA15_0<='\uFFFF')) )
-				{
-					alt15=5;
-				}
-
-
-				switch ( alt15 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:996:6: => '\\\\' ']'
-					{
-
-					Match('\\'); if (state.failed) return ;
-					Match(']'); if (state.failed) return ;
-					if ( state.backtracking == 0 )
-					{
-						builder.Append("]");
-					}
-
-					}
-					break;
-				case 2:
-					// Grammars\\ANTLR.g3:997:5: '\\\\' c=~ ( ']' )
-					{
-					Match('\\'); if (state.failed) return ;
-					c= input.LA(1);
-					input.Consume();
-					state.failed=false;
-					if ( state.backtracking == 0 )
-					{
-						builder.Append("\\" + (char)c);
-					}
-
-					}
-					break;
-				case 3:
-					// Grammars\\ANTLR.g3:998:5: ACTION_STRING_LITERAL
-					{
-					int ACTION_STRING_LITERAL1Start857 = CharIndex;
-					mACTION_STRING_LITERAL(); if (state.failed) return ;
-					ACTION_STRING_LITERAL1 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ACTION_STRING_LITERAL1Start857, CharIndex-1);
-					if ( state.backtracking == 0 )
-					{
-						builder.Append((ACTION_STRING_LITERAL1!=null?ACTION_STRING_LITERAL1.Text:null));
-					}
-
-					}
-					break;
-				case 4:
-					// Grammars\\ANTLR.g3:999:5: ACTION_CHAR_LITERAL
-					{
-					int ACTION_CHAR_LITERAL2Start865 = CharIndex;
-					mACTION_CHAR_LITERAL(); if (state.failed) return ;
-					ACTION_CHAR_LITERAL2 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ACTION_CHAR_LITERAL2Start865, CharIndex-1);
-					if ( state.backtracking == 0 )
-					{
-						builder.Append((ACTION_CHAR_LITERAL2!=null?ACTION_CHAR_LITERAL2.Text:null));
-					}
-
-					}
-					break;
-				case 5:
-					// Grammars\\ANTLR.g3:1000:5: c=~ ( '\\\\' | '\"' | '\\'' | ']' )
-					{
-					c= input.LA(1);
-					input.Consume();
-					state.failed=false;
-					if ( state.backtracking == 0 )
-					{
-						builder.Append((char)c);
-					}
-
-					}
-					break;
-
-				default:
-					goto loop15;
-				}
-			}
-
-			loop15:
-				;
-
-
-			if ( state.backtracking == 0 )
-			{
-
-							text_ = builder.ToString();
-
-			}
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "NESTED_ARG_ACTION"
-
-	// $ANTLR start "ACTION"
-	private void mACTION()
-	{
-		try
-		{
-			int _type = ACTION;
-			int _channel = DefaultTokenChannel;
-
-				int actionLine = Line;
-				int actionColumn = CharPositionInLine;
-
-			// Grammars\\ANTLR.g3:1012:4: ( NESTED_ACTION ( '?' )? )
-			// Grammars\\ANTLR.g3:1012:4: NESTED_ACTION ( '?' )?
-			{
-			mNESTED_ACTION(); if (state.failed) return ;
-			// Grammars\\ANTLR.g3:1013:3: ( '?' )?
-			int alt16=2;
-			int LA16_0 = input.LA(1);
-
-			if ( (LA16_0=='?') )
-			{
-				alt16=1;
-			}
-			switch ( alt16 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:1013:4: '?'
-				{
-				Match('?'); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-					_type = SEMPRED;
-				}
-
-				}
-				break;
-
-			}
-
-			if ( state.backtracking == 0 )
-			{
-
-							string action = Text;
-							int n = 1; // num delimiter chars
-							if ( action.StartsWith("{{") && action.EndsWith("}}") )
-							{
-								_type = FORCED_ACTION;
-								n = 2;
-							}
-							action = action.Substring(n,action.Length-n - (_type==SEMPRED ? 1 : 0) - n);
-							Text = action;
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ACTION"
-
-	// $ANTLR start "NESTED_ACTION"
-	private void mNESTED_ACTION()
-	{
-		try
-		{
-			// Grammars\\ANTLR.g3:1030:4: ( '{' ( NESTED_ACTION | ACTION_CHAR_LITERAL |=> COMMENT | ACTION_STRING_LITERAL | ACTION_ESC |~ ( '{' | '\\'' | '\"' | '\\\\' | '}' ) )* '}' )
-			// Grammars\\ANTLR.g3:1030:4: '{' ( NESTED_ACTION | ACTION_CHAR_LITERAL |=> COMMENT | ACTION_STRING_LITERAL | ACTION_ESC |~ ( '{' | '\\'' | '\"' | '\\\\' | '}' ) )* '}'
-			{
-			Match('{'); if (state.failed) return ;
-			// Grammars\\ANTLR.g3:1031:3: ( NESTED_ACTION | ACTION_CHAR_LITERAL |=> COMMENT | ACTION_STRING_LITERAL | ACTION_ESC |~ ( '{' | '\\'' | '\"' | '\\\\' | '}' ) )*
-			for ( ; ; )
-			{
-				int alt17=7;
-				int LA17_0 = input.LA(1);
-
-				if ( (LA17_0=='{') )
-				{
-					alt17=1;
-				}
-				else if ( (LA17_0=='\'') )
-				{
-					alt17=2;
-				}
-				else if ( (LA17_0=='/') )
-				{
-					int LA17_4 = input.LA(2);
-
-					if ( (EvaluatePredicate(synpred4_ANTLR_fragment)) )
-					{
-						alt17=3;
-					}
-					else if ( (true) )
-					{
-						alt17=6;
-					}
-
-
-				}
-				else if ( (LA17_0=='\"') )
-				{
-					alt17=4;
-				}
-				else if ( (LA17_0=='\\') )
-				{
-					alt17=5;
-				}
-				else if ( ((LA17_0>='\u0000' && LA17_0<='!')||(LA17_0>='#' && LA17_0<='&')||(LA17_0>='(' && LA17_0<='.')||(LA17_0>='0' && LA17_0<='[')||(LA17_0>=']' && LA17_0<='z')||LA17_0=='|'||(LA17_0>='~' && LA17_0<='\uFFFF')) )
-				{
-					alt17=6;
-				}
-
-
-				switch ( alt17 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:1031:5: NESTED_ACTION
-					{
-					mNESTED_ACTION(); if (state.failed) return ;
-
-					}
-					break;
-				case 2:
-					// Grammars\\ANTLR.g3:1032:5: ACTION_CHAR_LITERAL
-					{
-					mACTION_CHAR_LITERAL(); if (state.failed) return ;
-
-					}
-					break;
-				case 3:
-					// Grammars\\ANTLR.g3:1033:5: => COMMENT
-					{
-
-					mCOMMENT(); if (state.failed) return ;
-
-					}
-					break;
-				case 4:
-					// Grammars\\ANTLR.g3:1034:5: ACTION_STRING_LITERAL
-					{
-					mACTION_STRING_LITERAL(); if (state.failed) return ;
-
-					}
-					break;
-				case 5:
-					// Grammars\\ANTLR.g3:1035:5: ACTION_ESC
-					{
-					mACTION_ESC(); if (state.failed) return ;
-
-					}
-					break;
-				case 6:
-					// Grammars\\ANTLR.g3:1036:5: ~ ( '{' | '\\'' | '\"' | '\\\\' | '}' )
-					{
-					input.Consume();
-					state.failed=false;
-
-					}
-					break;
-
-				default:
-					goto loop17;
-				}
-			}
-
-			loop17:
-				;
-
-
-			Match('}'); if (state.failed) return ;
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "NESTED_ACTION"
-
-	// $ANTLR start "ACTION_CHAR_LITERAL"
-	private void mACTION_CHAR_LITERAL()
-	{
-		try
-		{
-			// Grammars\\ANTLR.g3:1043:4: ( '\\'' ( ACTION_ESC |~ ( '\\\\' | '\\'' ) )* '\\'' )
-			// Grammars\\ANTLR.g3:1043:4: '\\'' ( ACTION_ESC |~ ( '\\\\' | '\\'' ) )* '\\''
-			{
-			Match('\''); if (state.failed) return ;
-			// Grammars\\ANTLR.g3:1044:3: ( ACTION_ESC |~ ( '\\\\' | '\\'' ) )*
-			for ( ; ; )
-			{
-				int alt18=3;
-				int LA18_0 = input.LA(1);
-
-				if ( (LA18_0=='\\') )
-				{
-					alt18=1;
-				}
-				else if ( ((LA18_0>='\u0000' && LA18_0<='&')||(LA18_0>='(' && LA18_0<='[')||(LA18_0>=']' && LA18_0<='\uFFFF')) )
-				{
-					alt18=2;
-				}
-
-
-				switch ( alt18 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:1044:5: ACTION_ESC
-					{
-					mACTION_ESC(); if (state.failed) return ;
-
-					}
-					break;
-				case 2:
-					// Grammars\\ANTLR.g3:1045:5: ~ ( '\\\\' | '\\'' )
-					{
-					input.Consume();
-					state.failed=false;
-
-					}
-					break;
-
-				default:
-					goto loop18;
-				}
-			}
-
-			loop18:
-				;
-
-
-			Match('\''); if (state.failed) return ;
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ACTION_CHAR_LITERAL"
-
-	// $ANTLR start "ACTION_STRING_LITERAL"
-	private void mACTION_STRING_LITERAL()
-	{
-		try
-		{
-			// Grammars\\ANTLR.g3:1052:4: ( '\"' ( ACTION_ESC |~ ( '\\\\' | '\"' ) )* '\"' )
-			// Grammars\\ANTLR.g3:1052:4: '\"' ( ACTION_ESC |~ ( '\\\\' | '\"' ) )* '\"'
-			{
-			Match('\"'); if (state.failed) return ;
-			// Grammars\\ANTLR.g3:1053:3: ( ACTION_ESC |~ ( '\\\\' | '\"' ) )*
-			for ( ; ; )
-			{
-				int alt19=3;
-				int LA19_0 = input.LA(1);
-
-				if ( (LA19_0=='\\') )
-				{
-					alt19=1;
-				}
-				else if ( ((LA19_0>='\u0000' && LA19_0<='!')||(LA19_0>='#' && LA19_0<='[')||(LA19_0>=']' && LA19_0<='\uFFFF')) )
-				{
-					alt19=2;
-				}
-
-
-				switch ( alt19 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:1053:5: ACTION_ESC
-					{
-					mACTION_ESC(); if (state.failed) return ;
-
-					}
-					break;
-				case 2:
-					// Grammars\\ANTLR.g3:1054:5: ~ ( '\\\\' | '\"' )
-					{
-					input.Consume();
-					state.failed=false;
-
-					}
-					break;
-
-				default:
-					goto loop19;
-				}
-			}
-
-			loop19:
-				;
-
-
-			Match('\"'); if (state.failed) return ;
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ACTION_STRING_LITERAL"
-
-	// $ANTLR start "ACTION_ESC"
-	private void mACTION_ESC()
-	{
-		try
-		{
-			// Grammars\\ANTLR.g3:1061:4: ( '\\\\\\'' | '\\\\\\\"' | '\\\\' ~ ( '\\'' | '\"' ) )
-			int alt20=3;
-			int LA20_0 = input.LA(1);
-
-			if ( (LA20_0=='\\') )
-			{
-				int LA20_1 = input.LA(2);
-
-				if ( (LA20_1=='\'') )
-				{
-					alt20=1;
-				}
-				else if ( (LA20_1=='\"') )
-				{
-					alt20=2;
-				}
-				else if ( ((LA20_1>='\u0000' && LA20_1<='!')||(LA20_1>='#' && LA20_1<='&')||(LA20_1>='(' && LA20_1<='\uFFFF')) )
-				{
-					alt20=3;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					NoViableAltException nvae = new NoViableAltException("", 20, 1, input);
-
-					throw nvae;
-				}
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				NoViableAltException nvae = new NoViableAltException("", 20, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt20 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:1061:4: '\\\\\\''
-				{
-				Match("\\'"); if (state.failed) return ;
-
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:1062:4: '\\\\\\\"'
-				{
-				Match("\\\""); if (state.failed) return ;
-
-
-				}
-				break;
-			case 3:
-				// Grammars\\ANTLR.g3:1063:4: '\\\\' ~ ( '\\'' | '\"' )
-				{
-				Match('\\'); if (state.failed) return ;
-				input.Consume();
-				state.failed=false;
-
-				}
-				break;
-
-			}
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ACTION_ESC"
-
-	// $ANTLR start "TOKEN_REF"
-	private void mTOKEN_REF()
-	{
-		try
-		{
-			int _type = TOKEN_REF;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:1066:4: ( 'A' .. 'Z' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
-			// Grammars\\ANTLR.g3:1066:4: 'A' .. 'Z' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
-			{
-			MatchRange('A','Z'); if (state.failed) return ;
-			// Grammars\\ANTLR.g3:1067:3: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
-			for ( ; ; )
-			{
-				int alt21=2;
-				int LA21_0 = input.LA(1);
-
-				if ( ((LA21_0>='0' && LA21_0<='9')||(LA21_0>='A' && LA21_0<='Z')||LA21_0=='_'||(LA21_0>='a' && LA21_0<='z')) )
-				{
-					alt21=1;
-				}
-
-
-				switch ( alt21 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:
-					{
-					input.Consume();
-					state.failed=false;
-
-					}
-					break;
-
-				default:
-					goto loop21;
-				}
-			}
-
-			loop21:
-				;
-
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "TOKEN_REF"
-
-	// $ANTLR start "TOKENS"
-	private void mTOKENS()
-	{
-		try
-		{
-			int _type = TOKENS;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:1072:4: ( 'tokens' WS_LOOP '{' )
-			// Grammars\\ANTLR.g3:1072:4: 'tokens' WS_LOOP '{'
-			{
-			Match("tokens"); if (state.failed) return ;
-
-			mWS_LOOP(); if (state.failed) return ;
-			Match('{'); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "TOKENS"
-
-	// $ANTLR start "OPTIONS"
-	private void mOPTIONS()
-	{
-		try
-		{
-			int _type = OPTIONS;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ANTLR.g3:1076:4: ( 'options' WS_LOOP '{' )
-			// Grammars\\ANTLR.g3:1076:4: 'options' WS_LOOP '{'
-			{
-			Match("options"); if (state.failed) return ;
-
-			mWS_LOOP(); if (state.failed) return ;
-			Match('{'); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "OPTIONS"
-
-	// $ANTLR start "RULE_REF"
-	private void mRULE_REF()
-	{
-		try
-		{
-			int _type = RULE_REF;
-			int _channel = DefaultTokenChannel;
-
-				int t=0;
-
-			// Grammars\\ANTLR.g3:1085:4: ( 'a' .. 'z' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
-			// Grammars\\ANTLR.g3:1085:4: 'a' .. 'z' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
-			{
-			MatchRange('a','z'); if (state.failed) return ;
-			// Grammars\\ANTLR.g3:1085:13: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
-			for ( ; ; )
-			{
-				int alt22=2;
-				int LA22_0 = input.LA(1);
-
-				if ( ((LA22_0>='0' && LA22_0<='9')||(LA22_0>='A' && LA22_0<='Z')||LA22_0=='_'||(LA22_0>='a' && LA22_0<='z')) )
-				{
-					alt22=1;
-				}
-
-
-				switch ( alt22 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:
-					{
-					input.Consume();
-					state.failed=false;
-
-					}
-					break;
-
-				default:
-					goto loop22;
-				}
-			}
-
-			loop22:
-				;
-
-
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "RULE_REF"
-
-	// $ANTLR start "WS_LOOP"
-	private void mWS_LOOP()
-	{
-		try
-		{
-			// Grammars\\ANTLR.g3:1091:4: ( ( WS | COMMENT )* )
-			// Grammars\\ANTLR.g3:1091:4: ( WS | COMMENT )*
-			{
-			// Grammars\\ANTLR.g3:1091:4: ( WS | COMMENT )*
-			for ( ; ; )
-			{
-				int alt23=3;
-				int LA23_0 = input.LA(1);
-
-				if ( ((LA23_0>='\t' && LA23_0<='\n')||LA23_0=='\r'||LA23_0==' ') )
-				{
-					alt23=1;
-				}
-				else if ( (LA23_0=='/') )
-				{
-					alt23=2;
-				}
-
-
-				switch ( alt23 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:1091:6: WS
-					{
-					mWS(); if (state.failed) return ;
-
-					}
-					break;
-				case 2:
-					// Grammars\\ANTLR.g3:1092:5: COMMENT
-					{
-					mCOMMENT(); if (state.failed) return ;
-
-					}
-					break;
-
-				default:
-					goto loop23;
-				}
-			}
-
-			loop23:
-				;
-
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "WS_LOOP"
-
-	// $ANTLR start "WS_OPT"
-	private void mWS_OPT()
-	{
-		try
-		{
-			// Grammars\\ANTLR.g3:1098:4: ( ( WS )? )
-			// Grammars\\ANTLR.g3:1098:4: ( WS )?
-			{
-			// Grammars\\ANTLR.g3:1098:4: ( WS )?
-			int alt24=2;
-			int LA24_0 = input.LA(1);
-
-			if ( ((LA24_0>='\t' && LA24_0<='\n')||LA24_0=='\r'||LA24_0==' ') )
-			{
-				alt24=1;
-			}
-			switch ( alt24 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:1098:5: WS
-				{
-				mWS(); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "WS_OPT"
-
-	// $ANTLR start "SRC"
-	private void mSRC()
-	{
-		try
-		{
-			CommonToken file=null;
-			CommonToken line=null;
-
-			// Grammars\\ANTLR.g3:1111:4: ( 'src' ' ' file= ACTION_STRING_LITERAL ' ' line= INT )
-			// Grammars\\ANTLR.g3:1111:4: 'src' ' ' file= ACTION_STRING_LITERAL ' ' line= INT
-			{
-			Match("src"); if (state.failed) return ;
-
-			Match(' '); if (state.failed) return ;
-			int fileStart1270 = CharIndex;
-			mACTION_STRING_LITERAL(); if (state.failed) return ;
-			file = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, fileStart1270, CharIndex-1);
-			Match(' '); if (state.failed) return ;
-			int lineStart1276 = CharIndex;
-			mINT(); if (state.failed) return ;
-			line = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, lineStart1276, CharIndex-1);
-			if ( state.backtracking == 0 )
-			{
-
-							Filename = (file!=null?file.Text:null).Substring(1,(file!=null?file.Text:null).Length-2);
-							Line = int.Parse((line!=null?line.Text:null)) - 1;  // -1 because SL_COMMENT will increment the line no. KR
-
-			}
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "SRC"
-
-	public override void mTokens()
-	{
-		// Grammars\\ANTLR.g3:1:10: ( CATCH | FINALLY | FRAGMENT | GRAMMAR | IMPORT | LEXER | PARSER | PRIVATE | PROTECTED | PUBLIC | RETURNS | SCOPE | THROWS | TREE | WS | COMMENT | OPEN_ELEMENT_OPTION | CLOSE_ELEMENT_OPTION | AMPERSAND | COMMA | QUESTION | TREE_BEGIN | LPAREN | RPAREN | COLON | STAR | PLUS | ASSIGN | PLUS_ASSIGN | IMPLIES | REWRITE | SEMI | ROOT | BANG | OR | WILDCARD | ETC | RANGE | NOT | RCURLY | DOLLAR | STRAY_BRACKET | CHAR_LITERAL | DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL | INT | ARG_ACTION | ACTION | TOKEN_REF | TOKENS | OPTIONS | RULE_REF )
-		int alt25=52;
-		alt25 = dfa25.Predict(input);
-		switch ( alt25 )
-		{
-		case 1:
-			// Grammars\\ANTLR.g3:1:10: CATCH
-			{
-			mCATCH(); if (state.failed) return ;
-
-			}
-			break;
-		case 2:
-			// Grammars\\ANTLR.g3:1:16: FINALLY
-			{
-			mFINALLY(); if (state.failed) return ;
-
-			}
-			break;
-		case 3:
-			// Grammars\\ANTLR.g3:1:24: FRAGMENT
-			{
-			mFRAGMENT(); if (state.failed) return ;
-
-			}
-			break;
-		case 4:
-			// Grammars\\ANTLR.g3:1:33: GRAMMAR
-			{
-			mGRAMMAR(); if (state.failed) return ;
-
-			}
-			break;
-		case 5:
-			// Grammars\\ANTLR.g3:1:41: IMPORT
-			{
-			mIMPORT(); if (state.failed) return ;
-
-			}
-			break;
-		case 6:
-			// Grammars\\ANTLR.g3:1:48: LEXER
-			{
-			mLEXER(); if (state.failed) return ;
-
-			}
-			break;
-		case 7:
-			// Grammars\\ANTLR.g3:1:54: PARSER
-			{
-			mPARSER(); if (state.failed) return ;
-
-			}
-			break;
-		case 8:
-			// Grammars\\ANTLR.g3:1:61: PRIVATE
-			{
-			mPRIVATE(); if (state.failed) return ;
-
-			}
-			break;
-		case 9:
-			// Grammars\\ANTLR.g3:1:69: PROTECTED
-			{
-			mPROTECTED(); if (state.failed) return ;
-
-			}
-			break;
-		case 10:
-			// Grammars\\ANTLR.g3:1:79: PUBLIC
-			{
-			mPUBLIC(); if (state.failed) return ;
-
-			}
-			break;
-		case 11:
-			// Grammars\\ANTLR.g3:1:86: RETURNS
-			{
-			mRETURNS(); if (state.failed) return ;
-
-			}
-			break;
-		case 12:
-			// Grammars\\ANTLR.g3:1:94: SCOPE
-			{
-			mSCOPE(); if (state.failed) return ;
-
-			}
-			break;
-		case 13:
-			// Grammars\\ANTLR.g3:1:100: THROWS
-			{
-			mTHROWS(); if (state.failed) return ;
-
-			}
-			break;
-		case 14:
-			// Grammars\\ANTLR.g3:1:107: TREE
-			{
-			mTREE(); if (state.failed) return ;
-
-			}
-			break;
-		case 15:
-			// Grammars\\ANTLR.g3:1:112: WS
-			{
-			mWS(); if (state.failed) return ;
-
-			}
-			break;
-		case 16:
-			// Grammars\\ANTLR.g3:1:115: COMMENT
-			{
-			mCOMMENT(); if (state.failed) return ;
-
-			}
-			break;
-		case 17:
-			// Grammars\\ANTLR.g3:1:123: OPEN_ELEMENT_OPTION
-			{
-			mOPEN_ELEMENT_OPTION(); if (state.failed) return ;
-
-			}
-			break;
-		case 18:
-			// Grammars\\ANTLR.g3:1:143: CLOSE_ELEMENT_OPTION
-			{
-			mCLOSE_ELEMENT_OPTION(); if (state.failed) return ;
-
-			}
-			break;
-		case 19:
-			// Grammars\\ANTLR.g3:1:164: AMPERSAND
-			{
-			mAMPERSAND(); if (state.failed) return ;
-
-			}
-			break;
-		case 20:
-			// Grammars\\ANTLR.g3:1:174: COMMA
-			{
-			mCOMMA(); if (state.failed) return ;
-
-			}
-			break;
-		case 21:
-			// Grammars\\ANTLR.g3:1:180: QUESTION
-			{
-			mQUESTION(); if (state.failed) return ;
-
-			}
-			break;
-		case 22:
-			// Grammars\\ANTLR.g3:1:189: TREE_BEGIN
-			{
-			mTREE_BEGIN(); if (state.failed) return ;
-
-			}
-			break;
-		case 23:
-			// Grammars\\ANTLR.g3:1:200: LPAREN
-			{
-			mLPAREN(); if (state.failed) return ;
-
-			}
-			break;
-		case 24:
-			// Grammars\\ANTLR.g3:1:207: RPAREN
-			{
-			mRPAREN(); if (state.failed) return ;
-
-			}
-			break;
-		case 25:
-			// Grammars\\ANTLR.g3:1:214: COLON
-			{
-			mCOLON(); if (state.failed) return ;
-
-			}
-			break;
-		case 26:
-			// Grammars\\ANTLR.g3:1:220: STAR
-			{
-			mSTAR(); if (state.failed) return ;
-
-			}
-			break;
-		case 27:
-			// Grammars\\ANTLR.g3:1:225: PLUS
-			{
-			mPLUS(); if (state.failed) return ;
-
-			}
-			break;
-		case 28:
-			// Grammars\\ANTLR.g3:1:230: ASSIGN
-			{
-			mASSIGN(); if (state.failed) return ;
-
-			}
-			break;
-		case 29:
-			// Grammars\\ANTLR.g3:1:237: PLUS_ASSIGN
-			{
-			mPLUS_ASSIGN(); if (state.failed) return ;
-
-			}
-			break;
-		case 30:
-			// Grammars\\ANTLR.g3:1:249: IMPLIES
-			{
-			mIMPLIES(); if (state.failed) return ;
-
-			}
-			break;
-		case 31:
-			// Grammars\\ANTLR.g3:1:257: REWRITE
-			{
-			mREWRITE(); if (state.failed) return ;
-
-			}
-			break;
-		case 32:
-			// Grammars\\ANTLR.g3:1:265: SEMI
-			{
-			mSEMI(); if (state.failed) return ;
-
-			}
-			break;
-		case 33:
-			// Grammars\\ANTLR.g3:1:270: ROOT
-			{
-			mROOT(); if (state.failed) return ;
-
-			}
-			break;
-		case 34:
-			// Grammars\\ANTLR.g3:1:275: BANG
-			{
-			mBANG(); if (state.failed) return ;
-
-			}
-			break;
-		case 35:
-			// Grammars\\ANTLR.g3:1:280: OR
-			{
-			mOR(); if (state.failed) return ;
-
-			}
-			break;
-		case 36:
-			// Grammars\\ANTLR.g3:1:283: WILDCARD
-			{
-			mWILDCARD(); if (state.failed) return ;
-
-			}
-			break;
-		case 37:
-			// Grammars\\ANTLR.g3:1:292: ETC
-			{
-			mETC(); if (state.failed) return ;
-
-			}
-			break;
-		case 38:
-			// Grammars\\ANTLR.g3:1:296: RANGE
-			{
-			mRANGE(); if (state.failed) return ;
-
-			}
-			break;
-		case 39:
-			// Grammars\\ANTLR.g3:1:302: NOT
-			{
-			mNOT(); if (state.failed) return ;
-
-			}
-			break;
-		case 40:
-			// Grammars\\ANTLR.g3:1:306: RCURLY
-			{
-			mRCURLY(); if (state.failed) return ;
-
-			}
-			break;
-		case 41:
-			// Grammars\\ANTLR.g3:1:313: DOLLAR
-			{
-			mDOLLAR(); if (state.failed) return ;
-
-			}
-			break;
-		case 42:
-			// Grammars\\ANTLR.g3:1:320: STRAY_BRACKET
-			{
-			mSTRAY_BRACKET(); if (state.failed) return ;
-
-			}
-			break;
-		case 43:
-			// Grammars\\ANTLR.g3:1:334: CHAR_LITERAL
-			{
-			mCHAR_LITERAL(); if (state.failed) return ;
-
-			}
-			break;
-		case 44:
-			// Grammars\\ANTLR.g3:1:347: DOUBLE_QUOTE_STRING_LITERAL
-			{
-			mDOUBLE_QUOTE_STRING_LITERAL(); if (state.failed) return ;
-
-			}
-			break;
-		case 45:
-			// Grammars\\ANTLR.g3:1:375: DOUBLE_ANGLE_STRING_LITERAL
-			{
-			mDOUBLE_ANGLE_STRING_LITERAL(); if (state.failed) return ;
-
-			}
-			break;
-		case 46:
-			// Grammars\\ANTLR.g3:1:403: INT
-			{
-			mINT(); if (state.failed) return ;
-
-			}
-			break;
-		case 47:
-			// Grammars\\ANTLR.g3:1:407: ARG_ACTION
-			{
-			mARG_ACTION(); if (state.failed) return ;
-
-			}
-			break;
-		case 48:
-			// Grammars\\ANTLR.g3:1:418: ACTION
-			{
-			mACTION(); if (state.failed) return ;
-
-			}
-			break;
-		case 49:
-			// Grammars\\ANTLR.g3:1:425: TOKEN_REF
-			{
-			mTOKEN_REF(); if (state.failed) return ;
-
-			}
-			break;
-		case 50:
-			// Grammars\\ANTLR.g3:1:435: TOKENS
-			{
-			mTOKENS(); if (state.failed) return ;
-
-			}
-			break;
-		case 51:
-			// Grammars\\ANTLR.g3:1:442: OPTIONS
-			{
-			mOPTIONS(); if (state.failed) return ;
-
-			}
-			break;
-		case 52:
-			// Grammars\\ANTLR.g3:1:450: RULE_REF
-			{
-			mRULE_REF(); if (state.failed) return ;
-
-			}
-			break;
-
-		}
-
-	}
-
-	// $ANTLR start synpred1_ANTLR
-	public void synpred1_ANTLR_fragment()
-	{
-		// Grammars\\ANTLR.g3:830:5: ( ' $ANTLR' )
-		// Grammars\\ANTLR.g3:830:6: ' $ANTLR'
-		{
-		Match(" $ANTLR"); if (state.failed) return ;
-
-
-		}
-	}
-	// $ANTLR end synpred1_ANTLR
-
-	// $ANTLR start synpred2_ANTLR
-	public void synpred2_ANTLR_fragment()
-	{
-		// Grammars\\ANTLR.g3:929:5: ( '\\\\\\\"' )
-		// Grammars\\ANTLR.g3:929:6: '\\\\\\\"'
-		{
-		Match("\\\""); if (state.failed) return ;
-
-
-		}
-	}
-	// $ANTLR end synpred2_ANTLR
-
-	// $ANTLR start synpred3_ANTLR
-	public void synpred3_ANTLR_fragment()
-	{
-		// Grammars\\ANTLR.g3:996:6: ( '\\\\]' )
-		// Grammars\\ANTLR.g3:996:7: '\\\\]'
-		{
-		Match("\\]"); if (state.failed) return ;
-
-
-		}
-	}
-	// $ANTLR end synpred3_ANTLR
-
-	// $ANTLR start synpred4_ANTLR
-	public void synpred4_ANTLR_fragment()
-	{
-		// Grammars\\ANTLR.g3:1033:5: ( '//' | '/*' )
-		int alt26=2;
-		int LA26_0 = input.LA(1);
-
-		if ( (LA26_0=='/') )
-		{
-			int LA26_1 = input.LA(2);
-
-			if ( (LA26_1=='/') )
-			{
-				alt26=1;
-			}
-			else if ( (LA26_1=='*') )
-			{
-				alt26=2;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				NoViableAltException nvae = new NoViableAltException("", 26, 1, input);
-
-				throw nvae;
-			}
-		}
-		else
-		{
-			if (state.backtracking>0) {state.failed=true; return ;}
-			NoViableAltException nvae = new NoViableAltException("", 26, 0, input);
-
-			throw nvae;
-		}
-		switch ( alt26 )
-		{
-		case 1:
-			// Grammars\\ANTLR.g3:1033:6: '//'
-			{
-			Match("//"); if (state.failed) return ;
-
-
-			}
-			break;
-		case 2:
-			// Grammars\\ANTLR.g3:1033:13: '/*'
-			{
-			Match("/*"); if (state.failed) return ;
-
-
-			}
-			break;
-
-		}}
-	// $ANTLR end synpred4_ANTLR
-
-	#region Synpreds
-	bool EvaluatePredicate( System.Action fragment )
-	{
-		state.backtracking++;
-		int start = input.Mark();
-		try
-		{
-			fragment();
-		}
-		catch ( RecognitionException re )
-		{
-			System.Console.Error.WriteLine("impossible: "+re);
-		}
-		bool success = !state.failed;
-		input.Rewind(start);
-		state.backtracking--;
-		state.failed=false;
-		return success;
-	}
-	#endregion Synpreds
-
-
-	#region DFA
-	DFA9 dfa9;
-	DFA25 dfa25;
-
-	protected override void InitDFAs()
-	{
-		base.InitDFAs();
-		dfa9 = new DFA9( this, new SpecialStateTransitionHandler( specialStateTransition9 ) );
-		dfa25 = new DFA25( this );
-	}
-
-	class DFA9 : DFA
-	{
-
-		const string DFA9_eotS =
-			"\x2\x2\x1\xFFFF\xD\x2\x1\xFFFF\x5\x2\x1\xFFFF\x2\x2\x3\xFFFF\x1\x2\x1"+
-			"\xFFFF";
-		const string DFA9_eofS =
-			"\x1E\xFFFF";
-		const string DFA9_minS =
-			"\x1\x20\x1\x24\x1\xFFFF\x1\x41\x1\x4E\x1\x54\x1\x4C\x1\x52\x1\x20\x1"+
-			"\x73\x1\x72\x1\x63\x1\x20\x1\x22\x3\x0\x1\x20\x7\x0\x3\xFFFF\x1\x30\x1"+
-			"\x0";
-		const string DFA9_maxS =
-			"\x1\x20\x1\x24\x1\xFFFF\x1\x41\x1\x4E\x1\x54\x1\x4C\x1\x52\x1\x20\x1"+
-			"\x73\x1\x72\x1\x63\x1\x20\x1\x22\x3\xFFFF\x1\x20\x7\xFFFF\x3\xFFFF\x1"+
-			"\x39\x1\x0";
-		const string DFA9_acceptS =
-			"\x2\xFFFF\x1\x2\x16\xFFFF\x3\x1\x2\xFFFF";
-		const string DFA9_specialS =
-			"\xE\xFFFF\x1\x0\x1\x1\x1\x2\x1\xFFFF\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1"+
-			"\x8\x1\x9\x4\xFFFF\x1\xA}>";
-		static readonly string[] DFA9_transitionS =
-			{
-				"\x1\x1",
-				"\x1\x3",
-				"",
-				"\x1\x4",
-				"\x1\x5",
-				"\x1\x6",
-				"\x1\x7",
-				"\x1\x8",
-				"\x1\x9",
-				"\x1\xA",
-				"\x1\xB",
-				"\x1\xC",
-				"\x1\xD",
-				"\x1\xE",
-				"\xA\x13\x1\x12\x2\x13\x1\x10\x14\x13\x1\x11\x39\x13\x1\xF\xFFA3\x13",
-				"\xA\x18\x1\x17\x2\x18\x1\x16\x14\x18\x1\x15\x4\x18\x1\x14\xFFD8\x18",
-				"\xA\x1B\x1\x12\x17\x1B\x1\x19\x39\x1B\x1\x1A\xFFA3\x1B",
-				"\x1\x1C",
-				"\x22\x1B\x1\x19\x39\x1B\x1\x1A\xFFA3\x1B",
-				"\xA\x13\x1\x12\x2\x13\x1\x10\x14\x13\x1\x11\x39\x13\x1\xF\xFFA3\x13",
-				"\xA\x13\x1\x12\x2\x13\x1\x10\x14\x13\x1\x11\x39\x13\x1\xF\xFFA3\x13",
-				"\xA\x13\x1\x12\x2\x13\x1\x10\x14\x13\x1\x11\x39\x13\x1\xF\xFFA3\x13",
-				"\xA\x1B\x1\x12\x17\x1B\x1\x19\x39\x1B\x1\x1A\xFFA3\x1B",
-				"\x22\x1B\x1\x19\x39\x1B\x1\x1A\xFFA3\x1B",
-				"\xA\x13\x1\x12\x2\x13\x1\x10\x14\x13\x1\x11\x39\x13\x1\xF\xFFA3\x13",
-				"",
-				"",
-				"",
-				"\xA\x1D",
-				"\x1\xFFFF"
-			};
-
-		static readonly short[] DFA9_eot = DFA.UnpackEncodedString(DFA9_eotS);
-		static readonly short[] DFA9_eof = DFA.UnpackEncodedString(DFA9_eofS);
-		static readonly char[] DFA9_min = DFA.UnpackEncodedStringToUnsignedChars(DFA9_minS);
-		static readonly char[] DFA9_max = DFA.UnpackEncodedStringToUnsignedChars(DFA9_maxS);
-		static readonly short[] DFA9_accept = DFA.UnpackEncodedString(DFA9_acceptS);
-		static readonly short[] DFA9_special = DFA.UnpackEncodedString(DFA9_specialS);
-		static readonly short[][] DFA9_transition;
-
-		static DFA9()
-		{
-			int numStates = DFA9_transitionS.Length;
-			DFA9_transition = new short[numStates][];
-			for ( int i=0; i < numStates; i++ )
-			{
-				DFA9_transition[i] = DFA.UnpackEncodedString(DFA9_transitionS[i]);
-			}
-		}
-
-		public DFA9( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
-			: base( specialStateTransition )	{
-			this.recognizer = recognizer;
-			this.decisionNumber = 9;
-			this.eot = DFA9_eot;
-			this.eof = DFA9_eof;
-			this.min = DFA9_min;
-			this.max = DFA9_max;
-			this.accept = DFA9_accept;
-			this.special = DFA9_special;
-			this.transition = DFA9_transition;
-		}
-		public override string GetDescription()
-		{
-			return "830:3: (=> ' $ANTLR ' SRC ( ( '\\r' )? '\\n' )? | (~ ( '\\r' | '\\n' ) )* ( ( '\\r' )? '\\n' )? )";
-		}
-	}
-
-	int specialStateTransition9( DFA dfa, int s, IIntStream _input )
-	{
-		IIntStream input = _input;
-		int _s = s;
-		switch ( s )
-		{
-			case 0:
-				int LA9_14 = input.LA(1);
-
-				s = -1;
-				if ( (LA9_14=='\\') ) {s = 15;}
-
-				else if ( (LA9_14=='\r') ) {s = 16;}
-
-				else if ( (LA9_14=='\"') ) {s = 17;}
-
-				else if ( (LA9_14=='\n') ) {s = 18;}
-
-				else if ( ((LA9_14>='\u0000' && LA9_14<='\t')||(LA9_14>='\u000B' && LA9_14<='\f')||(LA9_14>='\u000E' && LA9_14<='!')||(LA9_14>='#' && LA9_14<='[')||(LA9_14>=']' && LA9_14<='\uFFFF')) ) {s = 19;}
-
-				else s = 2;
-
-				if ( s>=0 ) return s;
-				break;
-			case 1:
-				int LA9_15 = input.LA(1);
-
-				s = -1;
-				if ( (LA9_15=='\'') ) {s = 20;}
-
-				else if ( (LA9_15=='\"') ) {s = 21;}
-
-				else if ( (LA9_15=='\r') ) {s = 22;}
-
-				else if ( (LA9_15=='\n') ) {s = 23;}
-
-				else if ( ((LA9_15>='\u0000' && LA9_15<='\t')||(LA9_15>='\u000B' && LA9_15<='\f')||(LA9_15>='\u000E' && LA9_15<='!')||(LA9_15>='#' && LA9_15<='&')||(LA9_15>='(' && LA9_15<='\uFFFF')) ) {s = 24;}
-
-				else s = 2;
-
-				if ( s>=0 ) return s;
-				break;
-			case 2:
-				int LA9_16 = input.LA(1);
-
-
-				int index9_16 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (LA9_16=='\"') && (EvaluatePredicate(synpred1_ANTLR_fragment))) {s = 25;}
-
-				else if ( (LA9_16=='\\') && (EvaluatePredicate(synpred1_ANTLR_fragment))) {s = 26;}
-
-				else if ( (LA9_16=='\n') ) {s = 18;}
-
-				else if ( ((LA9_16>='\u0000' && LA9_16<='\t')||(LA9_16>='\u000B' && LA9_16<='!')||(LA9_16>='#' && LA9_16<='[')||(LA9_16>=']' && LA9_16<='\uFFFF')) && (EvaluatePredicate(synpred1_ANTLR_fragment))) {s = 27;}
-
-
-				input.Seek(index9_16);
-				if ( s>=0 ) return s;
-				break;
-			case 3:
-				int LA9_18 = input.LA(1);
-
-
-				int index9_18 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (LA9_18=='\"') && (EvaluatePredicate(synpred1_ANTLR_fragment))) {s = 25;}
-
-				else if ( (LA9_18=='\\') && (EvaluatePredicate(synpred1_ANTLR_fragment))) {s = 26;}
-
-				else if ( ((LA9_18>='\u0000' && LA9_18<='!')||(LA9_18>='#' && LA9_18<='[')||(LA9_18>=']' && LA9_18<='\uFFFF')) && (EvaluatePredicate(synpred1_ANTLR_fragment))) {s = 27;}
-
-				else s = 2;
-
-
-				input.Seek(index9_18);
-				if ( s>=0 ) return s;
-				break;
-			case 4:
-				int LA9_19 = input.LA(1);
-
-				s = -1;
-				if ( (LA9_19=='\"') ) {s = 17;}
-
-				else if ( (LA9_19=='\\') ) {s = 15;}
-
-				else if ( (LA9_19=='\r') ) {s = 16;}
-
-				else if ( (LA9_19=='\n') ) {s = 18;}
-
-				else if ( ((LA9_19>='\u0000' && LA9_19<='\t')||(LA9_19>='\u000B' && LA9_19<='\f')||(LA9_19>='\u000E' && LA9_19<='!')||(LA9_19>='#' && LA9_19<='[')||(LA9_19>=']' && LA9_19<='\uFFFF')) ) {s = 19;}
-
-				else s = 2;
-
-				if ( s>=0 ) return s;
-				break;
-			case 5:
-				int LA9_20 = input.LA(1);
-
-				s = -1;
-				if ( (LA9_20=='\"') ) {s = 17;}
-
-				else if ( (LA9_20=='\\') ) {s = 15;}
-
-				else if ( (LA9_20=='\r') ) {s = 16;}
-
-				else if ( (LA9_20=='\n') ) {s = 18;}
-
-				else if ( ((LA9_20>='\u0000' && LA9_20<='\t')||(LA9_20>='\u000B' && LA9_20<='\f')||(LA9_20>='\u000E' && LA9_20<='!')||(LA9_20>='#' && LA9_20<='[')||(LA9_20>=']' && LA9_20<='\uFFFF')) ) {s = 19;}
-
-				else s = 2;
-
-				if ( s>=0 ) return s;
-				break;
-			case 6:
-				int LA9_21 = input.LA(1);
-
-				s = -1;
-				if ( (LA9_21=='\"') ) {s = 17;}
-
-				else if ( (LA9_21=='\\') ) {s = 15;}
-
-				else if ( (LA9_21=='\r') ) {s = 16;}
-
-				else if ( (LA9_21=='\n') ) {s = 18;}
-
-				else if ( ((LA9_21>='\u0000' && LA9_21<='\t')||(LA9_21>='\u000B' && LA9_21<='\f')||(LA9_21>='\u000E' && LA9_21<='!')||(LA9_21>='#' && LA9_21<='[')||(LA9_21>=']' && LA9_21<='\uFFFF')) ) {s = 19;}
-
-				else s = 2;
-
-				if ( s>=0 ) return s;
-				break;
-			case 7:
-				int LA9_22 = input.LA(1);
-
-
-				int index9_22 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (LA9_22=='\"') && (EvaluatePredicate(synpred1_ANTLR_fragment))) {s = 25;}
-
-				else if ( (LA9_22=='\\') && (EvaluatePredicate(synpred1_ANTLR_fragment))) {s = 26;}
-
-				else if ( (LA9_22=='\n') ) {s = 18;}
-
-				else if ( ((LA9_22>='\u0000' && LA9_22<='\t')||(LA9_22>='\u000B' && LA9_22<='!')||(LA9_22>='#' && LA9_22<='[')||(LA9_22>=']' && LA9_22<='\uFFFF')) && (EvaluatePredicate(synpred1_ANTLR_fragment))) {s = 27;}
-
-
-				input.Seek(index9_22);
-				if ( s>=0 ) return s;
-				break;
-			case 8:
-				int LA9_23 = input.LA(1);
-
-
-				int index9_23 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (LA9_23=='\"') && (EvaluatePredicate(synpred1_ANTLR_fragment))) {s = 25;}
-
-				else if ( (LA9_23=='\\') && (EvaluatePredicate(synpred1_ANTLR_fragment))) {s = 26;}
-
-				else if ( ((LA9_23>='\u0000' && LA9_23<='!')||(LA9_23>='#' && LA9_23<='[')||(LA9_23>=']' && LA9_23<='\uFFFF')) && (EvaluatePredicate(synpred1_ANTLR_fragment))) {s = 27;}
-
-				else s = 2;
-
-
-				input.Seek(index9_23);
-				if ( s>=0 ) return s;
-				break;
-			case 9:
-				int LA9_24 = input.LA(1);
-
-				s = -1;
-				if ( (LA9_24=='\"') ) {s = 17;}
-
-				else if ( (LA9_24=='\\') ) {s = 15;}
-
-				else if ( (LA9_24=='\r') ) {s = 16;}
-
-				else if ( (LA9_24=='\n') ) {s = 18;}
-
-				else if ( ((LA9_24>='\u0000' && LA9_24<='\t')||(LA9_24>='\u000B' && LA9_24<='\f')||(LA9_24>='\u000E' && LA9_24<='!')||(LA9_24>='#' && LA9_24<='[')||(LA9_24>=']' && LA9_24<='\uFFFF')) ) {s = 19;}
-
-				else s = 2;
-
-				if ( s>=0 ) return s;
-				break;
-			case 10:
-				int LA9_29 = input.LA(1);
-
-
-				int index9_29 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (EvaluatePredicate(synpred1_ANTLR_fragment)) ) {s = 27;}
-
-				else if ( (true) ) {s = 2;}
-
-
-				input.Seek(index9_29);
-				if ( s>=0 ) return s;
-				break;
-		}
-		if (state.backtracking>0) {state.failed=true; return -1;}
-		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 9, _s, input);
-		dfa.Error(nvae);
-		throw nvae;
-	}
-	class DFA25 : DFA
-	{
-
-		const string DFA25_eotS =
-			"\x1\xFFFF\x9\x28\x2\xFFFF\x1\x38\x4\xFFFF\x1\x3A\x4\xFFFF\x1\x3C\x1\x3E"+
-			"\x4\xFFFF\x1\x40\xA\xFFFF\x1\x28\x1\xFFFF\xE\x28\x8\xFFFF\x1\x52\x1\xFFFF"+
-			"\x10\x28\x2\xFFFF\xE\x28\x1\x71\x2\x28\x1\x74\x4\x28\x1\x79\x5\x28\x1"+
-			"\x7F\x1\x28\x1\xFFFF\x2\x28\x1\xFFFF\x3\x28\x1\x86\x1\xFFFF\x1\x87\x2"+
-			"\x28\x1\x8A\x1\x28\x1\xFFFF\x1\x8C\x2\x28\x1\x8F\x1\x28\x1\x91\x2\xFFFF"+
-			"\x1\x92\x1\x28\x1\xFFFF\x1\x94\x2\xFFFF\x1\x28\x1\xFFFF\x1\x96\x2\xFFFF"+
-			"\x1\x28\x3\xFFFF\x1\x98\x1\xFFFF";
-		const string DFA25_eofS =
-			"\x99\xFFFF";
-		const string DFA25_minS =
-			"\x1\x9\x1\x61\x1\x69\x1\x72\x1\x6D\x1\x65\x1\x61\x1\x65\x1\x63\x1\x68"+
-			"\x2\xFFFF\x1\x3C\x4\xFFFF\x1\x28\x4\xFFFF\x1\x3D\x1\x3E\x4\xFFFF\x1\x2E"+
-			"\xA\xFFFF\x1\x70\x1\xFFFF\x1\x74\x1\x6E\x2\x61\x1\x70\x1\x78\x1\x72\x1"+
-			"\x69\x1\x62\x1\x74\x1\x6F\x1\x72\x1\x65\x1\x6B\x8\xFFFF\x1\x2E\x1\xFFFF"+
-			"\x1\x74\x1\x63\x1\x61\x1\x67\x1\x6D\x1\x6F\x1\x65\x1\x73\x1\x76\x1\x74"+
-			"\x1\x6C\x1\x75\x1\x70\x1\x6F\x2\x65\x2\xFFFF\x1\x69\x1\x68\x1\x6C\x2"+
-			"\x6D\x2\x72\x1\x65\x1\x61\x1\x65\x1\x69\x1\x72\x1\x65\x1\x77\x1\x30\x1"+
-			"\x6E\x1\x6F\x1\x30\x1\x6C\x1\x65\x1\x61\x1\x74\x1\x30\x1\x72\x1\x74\x2"+
-			"\x63\x1\x6E\x1\x30\x1\x73\x1\xFFFF\x1\x73\x1\x6E\x1\xFFFF\x1\x79\x1\x6E"+
-			"\x1\x72\x1\x30\x1\xFFFF\x1\x30\x1\x65\x1\x74\x1\x30\x1\x73\x1\xFFFF\x1"+
-			"\x30\x1\x9\x1\x73\x1\x30\x1\x74\x1\x30\x2\xFFFF\x1\x30\x1\x65\x1\xFFFF"+
-			"\x1\x30\x2\xFFFF\x1\x9\x1\xFFFF\x1\x30\x2\xFFFF\x1\x64\x3\xFFFF\x1\x30"+
-			"\x1\xFFFF";
-		const string DFA25_maxS =
-			"\x1\x7E\x1\x61\x2\x72\x1\x6D\x1\x65\x1\x75\x1\x65\x1\x63\x1\x72\x2\xFFFF"+
-			"\x1\x3C\x4\xFFFF\x1\x28\x4\xFFFF\x1\x3D\x1\x3E\x4\xFFFF\x1\x2E\xA\xFFFF"+
-			"\x1\x70\x1\xFFFF\x1\x74\x1\x6E\x2\x61\x1\x70\x1\x78\x1\x72\x1\x6F\x1"+
-			"\x62\x1\x74\x1\x6F\x1\x72\x1\x65\x1\x6B\x8\xFFFF\x1\x2E\x1\xFFFF\x1\x74"+
-			"\x1\x63\x1\x61\x1\x67\x1\x6D\x1\x6F\x1\x65\x1\x73\x1\x76\x1\x74\x1\x6C"+
-			"\x1\x75\x1\x70\x1\x6F\x2\x65\x2\xFFFF\x1\x69\x1\x68\x1\x6C\x2\x6D\x2"+
-			"\x72\x1\x65\x1\x61\x1\x65\x1\x69\x1\x72\x1\x65\x1\x77\x1\x7A\x1\x6E\x1"+
-			"\x6F\x1\x7A\x1\x6C\x1\x65\x1\x61\x1\x74\x1\x7A\x1\x72\x1\x74\x2\x63\x1"+
-			"\x6E\x1\x7A\x1\x73\x1\xFFFF\x1\x73\x1\x6E\x1\xFFFF\x1\x79\x1\x6E\x1\x72"+
-			"\x1\x7A\x1\xFFFF\x1\x7A\x1\x65\x1\x74\x1\x7A\x1\x73\x1\xFFFF\x1\x7A\x1"+
-			"\x7B\x1\x73\x1\x7A\x1\x74\x1\x7A\x2\xFFFF\x1\x7A\x1\x65\x1\xFFFF\x1\x7A"+
-			"\x2\xFFFF\x1\x7B\x1\xFFFF\x1\x7A\x2\xFFFF\x1\x64\x3\xFFFF\x1\x7A\x1\xFFFF";
-		const string DFA25_acceptS =
-			"\xA\xFFFF\x1\xF\x1\x10\x1\xFFFF\x1\x12\x1\x13\x1\x14\x1\x15\x1\xFFFF"+
-			"\x1\x17\x1\x18\x1\x19\x1\x1A\x2\xFFFF\x1\x1F\x1\x20\x1\x22\x1\x23\x1"+
-			"\xFFFF\x1\x27\x1\x28\x1\x29\x1\x2A\x1\x2B\x1\x2C\x1\x2E\x1\x2F\x1\x30"+
-			"\x1\x31\x1\xFFFF\x1\x34\xE\xFFFF\x1\x2D\x1\x11\x1\x16\x1\x21\x1\x1D\x1"+
-			"\x1B\x1\x1E\x1\x1C\x1\xFFFF\x1\x24\x10\xFFFF\x1\x25\x1\x26\x1E\xFFFF"+
-			"\x1\xE\x2\xFFFF\x1\x1\x4\xFFFF\x1\x6\x5\xFFFF\x1\xC\x6\xFFFF\x1\x5\x1"+
-			"\x7\x2\xFFFF\x1\xA\x1\xFFFF\x1\xD\x1\x32\x1\xFFFF\x1\x2\x1\xFFFF\x1\x4"+
-			"\x1\x8\x1\xFFFF\x1\xB\x1\x33\x1\x3\x1\xFFFF\x1\x9";
-		const string DFA25_specialS =
-			"\x99\xFFFF}>";
-		static readonly string[] DFA25_transitionS =
-			{
-				"\x2\xA\x2\xFFFF\x1\xA\x12\xFFFF\x1\xA\x1\x1A\x1\x22\x1\xFFFF\x1\x1F"+
-				"\x2\xFFFF\x1\x21\x1\x12\x1\x13\x1\x15\x1\x16\x1\xF\x1\x18\x1\x1C\x1"+
-				"\xB\xA\x23\x1\x14\x1\x19\x1\xC\x1\x17\x1\xD\x1\x10\x1\xE\x1A\x26\x1"+
-				"\x24\x1\xFFFF\x1\x20\x1\x11\x2\xFFFF\x2\x28\x1\x1\x2\x28\x1\x2\x1\x3"+
-				"\x1\x28\x1\x4\x2\x28\x1\x5\x2\x28\x1\x27\x1\x6\x1\x28\x1\x7\x1\x8\x1"+
-				"\x9\x6\x28\x1\x25\x1\x1B\x1\x1E\x1\x1D",
-				"\x1\x29",
-				"\x1\x2A\x8\xFFFF\x1\x2B",
-				"\x1\x2C",
-				"\x1\x2D",
-				"\x1\x2E",
-				"\x1\x2F\x10\xFFFF\x1\x30\x2\xFFFF\x1\x31",
-				"\x1\x32",
-				"\x1\x33",
-				"\x1\x34\x6\xFFFF\x1\x36\x2\xFFFF\x1\x35",
-				"",
-				"",
-				"\x1\x37",
-				"",
-				"",
-				"",
-				"",
-				"\x1\x39",
-				"",
-				"",
-				"",
-				"",
-				"\x1\x3B",
-				"\x1\x3D",
-				"",
-				"",
-				"",
-				"",
-				"\x1\x3F",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"\x1\x41",
-				"",
-				"\x1\x42",
-				"\x1\x43",
-				"\x1\x44",
-				"\x1\x45",
-				"\x1\x46",
-				"\x1\x47",
-				"\x1\x48",
-				"\x1\x49\x5\xFFFF\x1\x4A",
-				"\x1\x4B",
-				"\x1\x4C",
-				"\x1\x4D",
-				"\x1\x4E",
-				"\x1\x4F",
-				"\x1\x50",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"\x1\x51",
-				"",
-				"\x1\x53",
-				"\x1\x54",
-				"\x1\x55",
-				"\x1\x56",
-				"\x1\x57",
-				"\x1\x58",
-				"\x1\x59",
-				"\x1\x5A",
-				"\x1\x5B",
-				"\x1\x5C",
-				"\x1\x5D",
-				"\x1\x5E",
-				"\x1\x5F",
-				"\x1\x60",
-				"\x1\x61",
-				"\x1\x62",
-				"",
-				"",
-				"\x1\x63",
-				"\x1\x64",
-				"\x1\x65",
-				"\x1\x66",
-				"\x1\x67",
-				"\x1\x68",
-				"\x1\x69",
-				"\x1\x6A",
-				"\x1\x6B",
-				"\x1\x6C",
-				"\x1\x6D",
-				"\x1\x6E",
-				"\x1\x6F",
-				"\x1\x70",
-				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
-				"\x1\x72",
-				"\x1\x73",
-				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
-				"\x1\x75",
-				"\x1\x76",
-				"\x1\x77",
-				"\x1\x78",
-				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
-				"\x1\x7A",
-				"\x1\x7B",
-				"\x1\x7C",
-				"\x1\x7D",
-				"\x1\x7E",
-				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
-				"\x1\x80",
-				"",
-				"\x1\x81",
-				"\x1\x82",
-				"",
-				"\x1\x83",
-				"\x1\x84",
-				"\x1\x85",
-				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
-				"",
-				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
-				"\x1\x88",
-				"\x1\x89",
-				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
-				"\x1\x8B",
-				"",
-				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
-				"\x2\x8D\x2\xFFFF\x1\x8D\x12\xFFFF\x1\x8D\xE\xFFFF\x1\x8D\x4B\xFFFF\x1"+
-				"\x8D",
-				"\x1\x8E",
-				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
-				"\x1\x90",
-				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
-				"",
-				"",
-				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
-				"\x1\x93",
-				"",
-				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
-				"",
-				"",
-				"\x2\x95\x2\xFFFF\x1\x95\x12\xFFFF\x1\x95\xE\xFFFF\x1\x95\x4B\xFFFF\x1"+
-				"\x95",
-				"",
-				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
-				"",
-				"",
-				"\x1\x97",
-				"",
-				"",
-				"",
-				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
-				""
-			};
-
-		static readonly short[] DFA25_eot = DFA.UnpackEncodedString(DFA25_eotS);
-		static readonly short[] DFA25_eof = DFA.UnpackEncodedString(DFA25_eofS);
-		static readonly char[] DFA25_min = DFA.UnpackEncodedStringToUnsignedChars(DFA25_minS);
-		static readonly char[] DFA25_max = DFA.UnpackEncodedStringToUnsignedChars(DFA25_maxS);
-		static readonly short[] DFA25_accept = DFA.UnpackEncodedString(DFA25_acceptS);
-		static readonly short[] DFA25_special = DFA.UnpackEncodedString(DFA25_specialS);
-		static readonly short[][] DFA25_transition;
-
-		static DFA25()
-		{
-			int numStates = DFA25_transitionS.Length;
-			DFA25_transition = new short[numStates][];
-			for ( int i=0; i < numStates; i++ )
-			{
-				DFA25_transition[i] = DFA.UnpackEncodedString(DFA25_transitionS[i]);
-			}
-		}
-
-		public DFA25( BaseRecognizer recognizer )
-		{
-			this.recognizer = recognizer;
-			this.decisionNumber = 25;
-			this.eot = DFA25_eot;
-			this.eof = DFA25_eof;
-			this.min = DFA25_min;
-			this.max = DFA25_max;
-			this.accept = DFA25_accept;
-			this.special = DFA25_special;
-			this.transition = DFA25_transition;
-		}
-		public override string GetDescription()
-		{
-			return "1:0: Tokens : ( CATCH | FINALLY | FRAGMENT | GRAMMAR | IMPORT | LEXER | PARSER | PRIVATE | PROTECTED | PUBLIC | RETURNS | SCOPE | THROWS | TREE | WS | COMMENT | OPEN_ELEMENT_OPTION | CLOSE_ELEMENT_OPTION | AMPERSAND | COMMA | QUESTION | TREE_BEGIN | LPAREN | RPAREN | COLON | STAR | PLUS | ASSIGN | PLUS_ASSIGN | IMPLIES | REWRITE | SEMI | ROOT | BANG | OR | WILDCARD | ETC | RANGE | NOT | RCURLY | DOLLAR | STRAY_BRACKET | CHAR_LITERAL | DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL | INT | ARG_ACTION | ACTION | TOKEN_REF | TOKENS | OPTIONS | RULE_REF );";
-		}
-	}
-
-
-	#endregion
-
-}
-
-} // namespace Antlr3.Grammars
diff --git a/Antlr3/Grammars/ANTLRParser.cs b/Antlr3/Grammars/ANTLRParser.cs
deleted file mode 100644
index dcc09c2..0000000
--- a/Antlr3/Grammars/ANTLRParser.cs
+++ /dev/null
@@ -1,11045 +0,0 @@
-// $ANTLR 3.1.2 Grammars\\ANTLR.g3 2009-09-30 13:27:49
-
-// The variable 'variable' is assigned but its value is never used.
-#pragma warning disable 219
-// Unreachable code detected.
-#pragma warning disable 162
-
-
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Grammar conversion to ANTLR v3 and C#:
- Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-	notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-	derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-using ErrorManager = Antlr3.Tool.ErrorManager;
-using Grammar = Antlr3.Tool.Grammar;
-using GrammarAST = Antlr3.Tool.GrammarAST;
-using GrammarType = Antlr3.Tool.GrammarType;
-using IntSet = Antlr3.Misc.IIntSet;
-using StringBuffer = System.Text.StringBuilder;
-using TokenWithIndex = Antlr.Runtime.CommonToken;
-
-
-using System.Collections.Generic;
-using Antlr.Runtime;
-using Stack = System.Collections.Generic.Stack<object>;
-using List = System.Collections.IList;
-using ArrayList = System.Collections.Generic.List<object>;
-using Map = System.Collections.IDictionary;
-using HashMap = System.Collections.Generic.Dictionary<object, object>;
-
-using Antlr.Runtime.Tree;
-using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;
-
-namespace Antlr3.Grammars
-{
-/** Read in an ANTLR grammar and build an AST.  Try not to do
- *  any actions, just build the tree.
- *
- *  The phases are:
- *
- *		antlr.g (this file)
- *		assign.types.g
- *		define.g
- *		buildnfa.g
- *		antlr.print.g (optional)
- *		codegen.g
- *
- *  Terence Parr
- *  University of San Francisco
- *  2005
- */
-[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.1.2")]
-[System.CLSCompliant(false)]
-public partial class ANTLRParser : Parser
-{
-	internal static readonly string[] tokenNames = new string[] {
-		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", "ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARG_ACTION", "ARGLIST", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", "CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", "COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", "DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", "EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", "GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", "LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", "NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", "OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", "RET", "RETURNS", "REWRITE", "ROOT", "RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", "SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYN_SEMPRED", "SYNPRED", "TEMPLATE", "THROWS", "TOKEN_REF", "TOKENS", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", "WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT"
-	};
-	public const int EOF=-1;
-	public const int ACTION=4;
-	public const int ACTION_CHAR_LITERAL=5;
-	public const int ACTION_ESC=6;
-	public const int ACTION_STRING_LITERAL=7;
-	public const int ALT=8;
-	public const int AMPERSAND=9;
-	public const int ARG=10;
-	public const int ARG_ACTION=11;
-	public const int ARGLIST=12;
-	public const int ASSIGN=13;
-	public const int BACKTRACK_SEMPRED=14;
-	public const int BANG=15;
-	public const int BLOCK=16;
-	public const int CATCH=17;
-	public const int CHAR_LITERAL=18;
-	public const int CHAR_RANGE=19;
-	public const int CLOSE_ELEMENT_OPTION=20;
-	public const int CLOSURE=21;
-	public const int COLON=22;
-	public const int COMBINED_GRAMMAR=23;
-	public const int COMMA=24;
-	public const int COMMENT=25;
-	public const int DIGIT=26;
-	public const int DOC_COMMENT=27;
-	public const int DOLLAR=28;
-	public const int DOT=29;
-	public const int DOUBLE_ANGLE_STRING_LITERAL=30;
-	public const int DOUBLE_QUOTE_STRING_LITERAL=31;
-	public const int EOA=32;
-	public const int EOB=33;
-	public const int EOR=34;
-	public const int EPSILON=35;
-	public const int ESC=36;
-	public const int ETC=37;
-	public const int FINALLY=38;
-	public const int FORCED_ACTION=39;
-	public const int FRAGMENT=40;
-	public const int GATED_SEMPRED=41;
-	public const int GRAMMAR=42;
-	public const int ID=43;
-	public const int IMPLIES=44;
-	public const int IMPORT=45;
-	public const int INITACTION=46;
-	public const int INT=47;
-	public const int LABEL=48;
-	public const int LEXER=49;
-	public const int LEXER_GRAMMAR=50;
-	public const int LPAREN=51;
-	public const int ML_COMMENT=52;
-	public const int NESTED_ACTION=53;
-	public const int NESTED_ARG_ACTION=54;
-	public const int NOT=55;
-	public const int OPEN_ELEMENT_OPTION=56;
-	public const int OPTIONAL=57;
-	public const int OPTIONS=58;
-	public const int OR=59;
-	public const int PARSER=60;
-	public const int PARSER_GRAMMAR=61;
-	public const int PLUS=62;
-	public const int PLUS_ASSIGN=63;
-	public const int POSITIVE_CLOSURE=64;
-	public const int PRIVATE=65;
-	public const int PROTECTED=66;
-	public const int PUBLIC=67;
-	public const int QUESTION=68;
-	public const int RANGE=69;
-	public const int RCURLY=70;
-	public const int RET=71;
-	public const int RETURNS=72;
-	public const int REWRITE=73;
-	public const int ROOT=74;
-	public const int RPAREN=75;
-	public const int RULE=76;
-	public const int RULE_REF=77;
-	public const int SCOPE=78;
-	public const int SEMI=79;
-	public const int SEMPRED=80;
-	public const int SL_COMMENT=81;
-	public const int SRC=82;
-	public const int STAR=83;
-	public const int STRAY_BRACKET=84;
-	public const int STRING_LITERAL=85;
-	public const int SYN_SEMPRED=86;
-	public const int SYNPRED=87;
-	public const int TEMPLATE=88;
-	public const int THROWS=89;
-	public const int TOKEN_REF=90;
-	public const int TOKENS=91;
-	public const int TREE=92;
-	public const int TREE_BEGIN=93;
-	public const int TREE_GRAMMAR=94;
-	public const int WILDCARD=95;
-	public const int WS=96;
-	public const int WS_LOOP=97;
-	public const int WS_OPT=98;
-	public const int XDIGIT=99;
-
-	// delegates
-	// delegators
-
-	public ANTLRParser( ITokenStream input )
-		: this( input, new RecognizerSharedState() )
-	{
-	}
-	public ANTLRParser( ITokenStream input, RecognizerSharedState state )
-		: base( input, state )
-	{
-		InitializeTreeAdaptor();
-		if ( TreeAdaptor == null )
-			TreeAdaptor = new CommonTreeAdaptor();
-	}
-
-	// Implement this function in your helper file to use a custom tree adaptor
-	partial void InitializeTreeAdaptor();
-	ITreeAdaptor adaptor;
-
-	public ITreeAdaptor TreeAdaptor
-	{
-		get
-		{
-			return adaptor;
-		}
-		set
-		{
-			this.adaptor = value;
-		}
-	}
-
-	public override string[] TokenNames { get { return ANTLRParser.tokenNames; } }
-	public override string GrammarFileName { get { return "Grammars\\ANTLR.g3"; } }
-
-
-	#region Rules
-	public class grammar__return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "grammar_"
-	// Grammars\\ANTLR.g3:194:0: public grammar_[Grammar g] : ( ACTION )? (cmt= DOC_COMMENT )? gr= grammarType gid= id SEMI ( optionsSpec )? (ig= delegateGrammars )? (ts= tokensSpec )? scopes= attrScopes (a= actions )? r= rules EOF -> ^( $gr $gid ( $cmt)? ( optionsSpec )? ( $ig)? ( $ts)? ( $scopes)? ( $a)? $r) ;
-	public ANTLRParser.grammar__return grammar_( Grammar g )
-	{
-		ANTLRParser.grammar__return retval = new ANTLRParser.grammar__return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken cmt=null;
-		IToken ACTION1=null;
-		IToken SEMI2=null;
-		IToken EOF4=null;
-		ANTLRParser.grammarType_return gr = default(ANTLRParser.grammarType_return);
-		ANTLRParser.id_return gid = default(ANTLRParser.id_return);
-		ANTLRParser.delegateGrammars_return ig = default(ANTLRParser.delegateGrammars_return);
-		ANTLRParser.tokensSpec_return ts = default(ANTLRParser.tokensSpec_return);
-		ANTLRParser.attrScopes_return scopes = default(ANTLRParser.attrScopes_return);
-		ANTLRParser.actions_return a = default(ANTLRParser.actions_return);
-		ANTLRParser.rules_return r = default(ANTLRParser.rules_return);
-		ANTLRParser.optionsSpec_return optionsSpec3 = default(ANTLRParser.optionsSpec_return);
-
-		GrammarAST cmt_tree=null;
-		GrammarAST ACTION1_tree=null;
-		GrammarAST SEMI2_tree=null;
-		GrammarAST EOF4_tree=null;
-		RewriteRuleITokenStream stream_ACTION=new RewriteRuleITokenStream(adaptor,"token ACTION");
-		RewriteRuleITokenStream stream_DOC_COMMENT=new RewriteRuleITokenStream(adaptor,"token DOC_COMMENT");
-		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
-		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
-		RewriteRuleSubtreeStream stream_grammarType=new RewriteRuleSubtreeStream(adaptor,"rule grammarType");
-		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
-		RewriteRuleSubtreeStream stream_optionsSpec=new RewriteRuleSubtreeStream(adaptor,"rule optionsSpec");
-		RewriteRuleSubtreeStream stream_delegateGrammars=new RewriteRuleSubtreeStream(adaptor,"rule delegateGrammars");
-		RewriteRuleSubtreeStream stream_tokensSpec=new RewriteRuleSubtreeStream(adaptor,"rule tokensSpec");
-		RewriteRuleSubtreeStream stream_attrScopes=new RewriteRuleSubtreeStream(adaptor,"rule attrScopes");
-		RewriteRuleSubtreeStream stream_actions=new RewriteRuleSubtreeStream(adaptor,"rule actions");
-		RewriteRuleSubtreeStream stream_rules=new RewriteRuleSubtreeStream(adaptor,"rule rules");
-
-			this.Grammar = g;
-			IDictionary<string, object> opts;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:205:3: ( ( ACTION )? (cmt= DOC_COMMENT )? gr= grammarType gid= id SEMI ( optionsSpec )? (ig= delegateGrammars )? (ts= tokensSpec )? scopes= attrScopes (a= actions )? r= rules EOF -> ^( $gr $gid ( $cmt)? ( optionsSpec )? ( $ig)? ( $ts)? ( $scopes)? ( $a)? $r) )
-			// Grammars\\ANTLR.g3:205:3: ( ACTION )? (cmt= DOC_COMMENT )? gr= grammarType gid= id SEMI ( optionsSpec )? (ig= delegateGrammars )? (ts= tokensSpec )? scopes= attrScopes (a= actions )? r= rules EOF
-			{
-			// Grammars\\ANTLR.g3:205:3: ( ACTION )?
-			int alt1=2;
-			int LA1_0 = input.LA(1);
-
-			if ( (LA1_0==ACTION) )
-			{
-				alt1=1;
-			}
-			switch ( alt1 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:205:5: ACTION
-				{
-				ACTION1=(IToken)Match(input,ACTION,Follow._ACTION_in_grammar_308); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_ACTION.Add(ACTION1);
-
-
-				}
-				break;
-
-			}
-
-			// Grammars\\ANTLR.g3:206:3: (cmt= DOC_COMMENT )?
-			int alt2=2;
-			int LA2_0 = input.LA(1);
-
-			if ( (LA2_0==DOC_COMMENT) )
-			{
-				alt2=1;
-			}
-			switch ( alt2 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:206:5: cmt= DOC_COMMENT
-				{
-				cmt=(IToken)Match(input,DOC_COMMENT,Follow._DOC_COMMENT_in_grammar_319); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_DOC_COMMENT.Add(cmt);
-
-
-				}
-				break;
-
-			}
-
-			PushFollow(Follow._grammarType_in_grammar_329);
-			gr=grammarType();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_grammarType.Add(gr.Tree);
-			PushFollow(Follow._id_in_grammar_333);
-			gid=id();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_id.Add(gid.Tree);
-			if ( state.backtracking == 0 )
-			{
-				Grammar.SetName((gid!=null?input.ToString(gid.start,gid.stop):null));
-			}
-			SEMI2=(IToken)Match(input,SEMI,Follow._SEMI_in_grammar_337); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_SEMI.Add(SEMI2);
-
-			// Grammars\\ANTLR.g3:208:3: ( optionsSpec )?
-			int alt3=2;
-			int LA3_0 = input.LA(1);
-
-			if ( (LA3_0==OPTIONS) )
-			{
-				alt3=1;
-			}
-			switch ( alt3 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:208:5: optionsSpec
-				{
-				PushFollow(Follow._optionsSpec_in_grammar_343);
-				optionsSpec3=optionsSpec();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_optionsSpec.Add(optionsSpec3.Tree);
-				if ( state.backtracking == 0 )
-				{
-					opts = (optionsSpec3!=null?optionsSpec3.opts:default(IDictionary<string, object>)); Grammar.SetOptions(opts, (optionsSpec3!=null?((IToken)optionsSpec3.Start):null));
-				}
-
-				}
-				break;
-
-			}
-
-			// Grammars\\ANTLR.g3:210:3: (ig= delegateGrammars )?
-			int alt4=2;
-			int LA4_0 = input.LA(1);
-
-			if ( (LA4_0==IMPORT) )
-			{
-				alt4=1;
-			}
-			switch ( alt4 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:210:4: ig= delegateGrammars
-				{
-				PushFollow(Follow._delegateGrammars_in_grammar_357);
-				ig=delegateGrammars();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_delegateGrammars.Add(ig.Tree);
-
-				}
-				break;
-
-			}
-
-			// Grammars\\ANTLR.g3:211:3: (ts= tokensSpec )?
-			int alt5=2;
-			int LA5_0 = input.LA(1);
-
-			if ( (LA5_0==TOKENS) )
-			{
-				alt5=1;
-			}
-			switch ( alt5 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:211:4: ts= tokensSpec
-				{
-				PushFollow(Follow._tokensSpec_in_grammar_366);
-				ts=tokensSpec();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_tokensSpec.Add(ts.Tree);
-
-				}
-				break;
-
-			}
-
-			PushFollow(Follow._attrScopes_in_grammar_374);
-			scopes=attrScopes();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_attrScopes.Add(scopes.Tree);
-			// Grammars\\ANTLR.g3:213:3: (a= actions )?
-			int alt6=2;
-			int LA6_0 = input.LA(1);
-
-			if ( (LA6_0==AMPERSAND) )
-			{
-				alt6=1;
-			}
-			switch ( alt6 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:213:4: a= actions
-				{
-				PushFollow(Follow._actions_in_grammar_381);
-				a=actions();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_actions.Add(a.Tree);
-
-				}
-				break;
-
-			}
-
-			PushFollow(Follow._rules_in_grammar_389);
-			r=rules();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_rules.Add(r.Tree);
-			EOF4=(IToken)Match(input,EOF,Follow._EOF_in_grammar_393); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_EOF.Add(EOF4);
-
-
-
-			{
-			// AST REWRITE
-			// elements: gr, gid, cmt, optionsSpec, ig, ts, scopes, a, r
-			// token labels: cmt
-			// rule labels: gr, gid, ig, ts, scopes, a, r, retval
-			// token list labels:
-			// rule list labels:
-			// wildcard labels:
-			if ( state.backtracking == 0 ) {
-			retval.tree = root_0;
-			RewriteRuleITokenStream stream_cmt=new RewriteRuleITokenStream(adaptor,"token cmt",cmt);
-			RewriteRuleSubtreeStream stream_gr=new RewriteRuleSubtreeStream(adaptor,"rule gr",gr!=null?gr.tree:null);
-			RewriteRuleSubtreeStream stream_gid=new RewriteRuleSubtreeStream(adaptor,"rule gid",gid!=null?gid.tree:null);
-			RewriteRuleSubtreeStream stream_ig=new RewriteRuleSubtreeStream(adaptor,"rule ig",ig!=null?ig.tree:null);
-			RewriteRuleSubtreeStream stream_ts=new RewriteRuleSubtreeStream(adaptor,"rule ts",ts!=null?ts.tree:null);
-			RewriteRuleSubtreeStream stream_scopes=new RewriteRuleSubtreeStream(adaptor,"rule scopes",scopes!=null?scopes.tree:null);
-			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.tree:null);
-			RewriteRuleSubtreeStream stream_r=new RewriteRuleSubtreeStream(adaptor,"rule r",r!=null?r.tree:null);
-			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-			root_0 = (GrammarAST)adaptor.Nil();
-			// 216:3: -> ^( $gr $gid ( $cmt)? ( optionsSpec )? ( $ig)? ( $ts)? ( $scopes)? ( $a)? $r)
-			{
-				// Grammars\\ANTLR.g3:216:6: ^( $gr $gid ( $cmt)? ( optionsSpec )? ( $ig)? ( $ts)? ( $scopes)? ( $a)? $r)
-				{
-				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-				root_1 = (GrammarAST)adaptor.BecomeRoot(stream_gr.NextNode(), root_1);
-
-				adaptor.AddChild(root_1, stream_gid.NextTree());
-				// Grammars\\ANTLR.g3:216:18: ( $cmt)?
-				if ( stream_cmt.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_cmt.NextNode());
-
-				}
-				stream_cmt.Reset();
-				// Grammars\\ANTLR.g3:216:23: ( optionsSpec )?
-				if ( stream_optionsSpec.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_optionsSpec.NextTree());
-
-				}
-				stream_optionsSpec.Reset();
-				// Grammars\\ANTLR.g3:216:37: ( $ig)?
-				if ( stream_ig.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_ig.NextTree());
-
-				}
-				stream_ig.Reset();
-				// Grammars\\ANTLR.g3:216:42: ( $ts)?
-				if ( stream_ts.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_ts.NextTree());
-
-				}
-				stream_ts.Reset();
-				// Grammars\\ANTLR.g3:216:47: ( $scopes)?
-				if ( stream_scopes.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_scopes.NextTree());
-
-				}
-				stream_scopes.Reset();
-				// Grammars\\ANTLR.g3:216:56: ( $a)?
-				if ( stream_a.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_a.NextTree());
-
-				}
-				stream_a.Reset();
-				adaptor.AddChild(root_1, stream_r.NextTree());
-
-				adaptor.AddChild(root_0, root_1);
-				}
-
-			}
-
-			retval.tree = root_0;
-			}
-			}
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-			if ( state.backtracking == 0 )
-			{
-
-					Cleanup( ((GrammarAST)retval.Tree) );
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "grammar_"
-
-	public class grammarType_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "grammarType"
-	// Grammars\\ANTLR.g3:219:0: grammarType : ( 'lexer' gr= 'grammar' -> LEXER_GRAMMAR[$gr] | 'parser' gr= 'grammar' -> PARSER_GRAMMAR[$gr] | 'tree' gr= 'grammar' -> TREE_GRAMMAR[$gr] |gr= 'grammar' -> COMBINED_GRAMMAR[$gr] ) ;
-	private ANTLRParser.grammarType_return grammarType(  )
-	{
-		ANTLRParser.grammarType_return retval = new ANTLRParser.grammarType_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken gr=null;
-		IToken string_literal5=null;
-		IToken string_literal6=null;
-		IToken string_literal7=null;
-
-		GrammarAST gr_tree=null;
-		GrammarAST string_literal5_tree=null;
-		GrammarAST string_literal6_tree=null;
-		GrammarAST string_literal7_tree=null;
-		RewriteRuleITokenStream stream_LEXER=new RewriteRuleITokenStream(adaptor,"token LEXER");
-		RewriteRuleITokenStream stream_GRAMMAR=new RewriteRuleITokenStream(adaptor,"token GRAMMAR");
-		RewriteRuleITokenStream stream_PARSER=new RewriteRuleITokenStream(adaptor,"token PARSER");
-		RewriteRuleITokenStream stream_TREE=new RewriteRuleITokenStream(adaptor,"token TREE");
-
-		try
-		{
-			// Grammars\\ANTLR.g3:220:4: ( ( 'lexer' gr= 'grammar' -> LEXER_GRAMMAR[$gr] | 'parser' gr= 'grammar' -> PARSER_GRAMMAR[$gr] | 'tree' gr= 'grammar' -> TREE_GRAMMAR[$gr] |gr= 'grammar' -> COMBINED_GRAMMAR[$gr] ) )
-			// Grammars\\ANTLR.g3:220:4: ( 'lexer' gr= 'grammar' -> LEXER_GRAMMAR[$gr] | 'parser' gr= 'grammar' -> PARSER_GRAMMAR[$gr] | 'tree' gr= 'grammar' -> TREE_GRAMMAR[$gr] |gr= 'grammar' -> COMBINED_GRAMMAR[$gr] )
-			{
-			// Grammars\\ANTLR.g3:220:4: ( 'lexer' gr= 'grammar' -> LEXER_GRAMMAR[$gr] | 'parser' gr= 'grammar' -> PARSER_GRAMMAR[$gr] | 'tree' gr= 'grammar' -> TREE_GRAMMAR[$gr] |gr= 'grammar' -> COMBINED_GRAMMAR[$gr] )
-			int alt7=4;
-			switch ( input.LA(1) )
-			{
-			case LEXER:
-				{
-				alt7=1;
-				}
-				break;
-			case PARSER:
-				{
-				alt7=2;
-				}
-				break;
-			case TREE:
-				{
-				alt7=3;
-				}
-				break;
-			case GRAMMAR:
-				{
-				alt7=4;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt7 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:220:6: 'lexer' gr= 'grammar'
-				{
-				string_literal5=(IToken)Match(input,LEXER,Follow._LEXER_in_grammarType444); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_LEXER.Add(string_literal5);
-
-				gr=(IToken)Match(input,GRAMMAR,Follow._GRAMMAR_in_grammarType449); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_GRAMMAR.Add(gr);
-
-				if ( state.backtracking == 0 )
-				{
-					GrammarType=GrammarType.Lexer; Grammar.type = GrammarType.Lexer;
-				}
-
-
-				{
-				// AST REWRITE
-				// elements:
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 221:4: -> LEXER_GRAMMAR[$gr]
-				{
-					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(LEXER_GRAMMAR, gr));
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:222:5: 'parser' gr= 'grammar'
-				{
-				string_literal6=(IToken)Match(input,PARSER,Follow._PARSER_in_grammarType472); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_PARSER.Add(string_literal6);
-
-				gr=(IToken)Match(input,GRAMMAR,Follow._GRAMMAR_in_grammarType476); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_GRAMMAR.Add(gr);
-
-				if ( state.backtracking == 0 )
-				{
-					GrammarType=GrammarType.Parser; Grammar.type = GrammarType.Parser;
-				}
-
-
-				{
-				// AST REWRITE
-				// elements:
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 223:4: -> PARSER_GRAMMAR[$gr]
-				{
-					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(PARSER_GRAMMAR, gr));
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-			case 3:
-				// Grammars\\ANTLR.g3:224:5: 'tree' gr= 'grammar'
-				{
-				string_literal7=(IToken)Match(input,TREE,Follow._TREE_in_grammarType497); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_TREE.Add(string_literal7);
-
-				gr=(IToken)Match(input,GRAMMAR,Follow._GRAMMAR_in_grammarType503); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_GRAMMAR.Add(gr);
-
-				if ( state.backtracking == 0 )
-				{
-					GrammarType=GrammarType.TreeParser; Grammar.type = GrammarType.TreeParser;
-				}
-
-
-				{
-				// AST REWRITE
-				// elements:
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 225:4: -> TREE_GRAMMAR[$gr]
-				{
-					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(TREE_GRAMMAR, gr));
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-			case 4:
-				// Grammars\\ANTLR.g3:226:8: gr= 'grammar'
-				{
-				gr=(IToken)Match(input,GRAMMAR,Follow._GRAMMAR_in_grammarType526); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_GRAMMAR.Add(gr);
-
-				if ( state.backtracking == 0 )
-				{
-					GrammarType=GrammarType.Combined; Grammar.type = GrammarType.Combined;
-				}
-
-
-				{
-				// AST REWRITE
-				// elements:
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 227:4: -> COMBINED_GRAMMAR[$gr]
-				{
-					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(COMBINED_GRAMMAR, gr));
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-
-			}
-
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "grammarType"
-
-	public class actions_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "actions"
-	// Grammars\\ANTLR.g3:231:0: actions : ( action )+ ;
-	private ANTLRParser.actions_return actions(  )
-	{
-		ANTLRParser.actions_return retval = new ANTLRParser.actions_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		ANTLRParser.action_return action8 = default(ANTLRParser.action_return);
-
-
-		try
-		{
-			// Grammars\\ANTLR.g3:232:4: ( ( action )+ )
-			// Grammars\\ANTLR.g3:232:4: ( action )+
-			{
-			root_0 = (GrammarAST)adaptor.Nil();
-
-			// Grammars\\ANTLR.g3:232:4: ( action )+
-			int cnt8=0;
-			for ( ; ; )
-			{
-				int alt8=2;
-				int LA8_0 = input.LA(1);
-
-				if ( (LA8_0==AMPERSAND) )
-				{
-					alt8=1;
-				}
-
-
-				switch ( alt8 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:232:5: action
-					{
-					PushFollow(Follow._action_in_actions553);
-					action8=action();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, action8.Tree);
-
-					}
-					break;
-
-				default:
-					if ( cnt8 >= 1 )
-						goto loop8;
-
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					EarlyExitException eee8 = new EarlyExitException( 8, input );
-					throw eee8;
-				}
-				cnt8++;
-			}
-			loop8:
-				;
-
-
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "actions"
-
-	public class action_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "action"
-	// Grammars\\ANTLR.g3:236:0: action : AMPERSAND ( actionScopeName COLON COLON )? id ACTION ;
-	private ANTLRParser.action_return action(  )
-	{
-		ANTLRParser.action_return retval = new ANTLRParser.action_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken AMPERSAND9=null;
-		IToken COLON11=null;
-		IToken COLON12=null;
-		IToken ACTION14=null;
-		ANTLRParser.actionScopeName_return actionScopeName10 = default(ANTLRParser.actionScopeName_return);
-		ANTLRParser.id_return id13 = default(ANTLRParser.id_return);
-
-		GrammarAST AMPERSAND9_tree=null;
-		GrammarAST COLON11_tree=null;
-		GrammarAST COLON12_tree=null;
-		GrammarAST ACTION14_tree=null;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:237:4: ( AMPERSAND ( actionScopeName COLON COLON )? id ACTION )
-			// Grammars\\ANTLR.g3:237:4: AMPERSAND ( actionScopeName COLON COLON )? id ACTION
-			{
-			root_0 = (GrammarAST)adaptor.Nil();
-
-			AMPERSAND9=(IToken)Match(input,AMPERSAND,Follow._AMPERSAND_in_action568); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) {
-			AMPERSAND9_tree = (GrammarAST)adaptor.Create(AMPERSAND9);
-			root_0 = (GrammarAST)adaptor.BecomeRoot(AMPERSAND9_tree, root_0);
-			}
-			// Grammars\\ANTLR.g3:237:15: ( actionScopeName COLON COLON )?
-			int alt9=2;
-			switch ( input.LA(1) )
-			{
-			case TOKEN_REF:
-				{
-				int LA9_1 = input.LA(2);
-
-				if ( (LA9_1==COLON) )
-				{
-					alt9=1;
-				}
-				}
-				break;
-			case RULE_REF:
-				{
-				int LA9_2 = input.LA(2);
-
-				if ( (LA9_2==COLON) )
-				{
-					alt9=1;
-				}
-				}
-				break;
-			case LEXER:
-			case PARSER:
-				{
-				alt9=1;
-				}
-				break;
-			}
-
-			switch ( alt9 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:237:16: actionScopeName COLON COLON
-				{
-				PushFollow(Follow._actionScopeName_in_action572);
-				actionScopeName10=actionScopeName();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, actionScopeName10.Tree);
-				COLON11=(IToken)Match(input,COLON,Follow._COLON_in_action574); if (state.failed) return retval;
-				COLON12=(IToken)Match(input,COLON,Follow._COLON_in_action577); if (state.failed) return retval;
-
-				}
-				break;
-
-			}
-
-			PushFollow(Follow._id_in_action582);
-			id13=id();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, id13.Tree);
-			ACTION14=(IToken)Match(input,ACTION,Follow._ACTION_in_action584); if (state.failed) return retval;
-			if ( state.backtracking==0 ) {
-			ACTION14_tree = (GrammarAST)adaptor.Create(ACTION14);
-			adaptor.AddChild(root_0, ACTION14_tree);
-			}
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "action"
-
-	public class actionScopeName_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "actionScopeName"
-	// Grammars\\ANTLR.g3:243:0: actionScopeName : ( id |l= 'lexer' -> ID[l] |p= 'parser' -> ID[p] );
-	private ANTLRParser.actionScopeName_return actionScopeName(  )
-	{
-		ANTLRParser.actionScopeName_return retval = new ANTLRParser.actionScopeName_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken l=null;
-		IToken p=null;
-		ANTLRParser.id_return id15 = default(ANTLRParser.id_return);
-
-		GrammarAST l_tree=null;
-		GrammarAST p_tree=null;
-		RewriteRuleITokenStream stream_LEXER=new RewriteRuleITokenStream(adaptor,"token LEXER");
-		RewriteRuleITokenStream stream_PARSER=new RewriteRuleITokenStream(adaptor,"token PARSER");
-
-		try
-		{
-			// Grammars\\ANTLR.g3:244:4: ( id |l= 'lexer' -> ID[l] |p= 'parser' -> ID[p] )
-			int alt10=3;
-			switch ( input.LA(1) )
-			{
-			case RULE_REF:
-			case TOKEN_REF:
-				{
-				alt10=1;
-				}
-				break;
-			case LEXER:
-				{
-				alt10=2;
-				}
-				break;
-			case PARSER:
-				{
-				alt10=3;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 10, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt10 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:244:4: id
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				PushFollow(Follow._id_in_actionScopeName597);
-				id15=id();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, id15.Tree);
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:245:4: l= 'lexer'
-				{
-				l=(IToken)Match(input,LEXER,Follow._LEXER_in_actionScopeName604); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_LEXER.Add(l);
-
-
-
-				{
-				// AST REWRITE
-				// elements:
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 246:3: -> ID[l]
-				{
-					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(ID, l));
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-			case 3:
-				// Grammars\\ANTLR.g3:247:4: p= 'parser'
-				{
-				p=(IToken)Match(input,PARSER,Follow._PARSER_in_actionScopeName618); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_PARSER.Add(p);
-
-
-
-				{
-				// AST REWRITE
-				// elements:
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 248:3: -> ID[p]
-				{
-					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(ID, p));
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-
-			}
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "actionScopeName"
-
-	public class optionsSpec_return : ParserRuleReturnScope
-	{
-		public IDictionary<string, object> opts=new Dictionary<string, object>();
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "optionsSpec"
-	// Grammars\\ANTLR.g3:251:0: optionsSpec returns [IDictionary<string, object> opts=new Dictionary<string, object>()] : OPTIONS ( option[$opts] SEMI )+ RCURLY ;
-	private ANTLRParser.optionsSpec_return optionsSpec(  )
-	{
-		ANTLRParser.optionsSpec_return retval = new ANTLRParser.optionsSpec_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken OPTIONS16=null;
-		IToken SEMI18=null;
-		IToken RCURLY19=null;
-		ANTLRParser.option_return option17 = default(ANTLRParser.option_return);
-
-		GrammarAST OPTIONS16_tree=null;
-		GrammarAST SEMI18_tree=null;
-		GrammarAST RCURLY19_tree=null;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:252:4: ( OPTIONS ( option[$opts] SEMI )+ RCURLY )
-			// Grammars\\ANTLR.g3:252:4: OPTIONS ( option[$opts] SEMI )+ RCURLY
-			{
-			root_0 = (GrammarAST)adaptor.Nil();
-
-			OPTIONS16=(IToken)Match(input,OPTIONS,Follow._OPTIONS_in_optionsSpec640); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) {
-			OPTIONS16_tree = (GrammarAST)adaptor.Create(OPTIONS16);
-			root_0 = (GrammarAST)adaptor.BecomeRoot(OPTIONS16_tree, root_0);
-			}
-			// Grammars\\ANTLR.g3:252:13: ( option[$opts] SEMI )+
-			int cnt11=0;
-			for ( ; ; )
-			{
-				int alt11=2;
-				int LA11_0 = input.LA(1);
-
-				if ( (LA11_0==RULE_REF||LA11_0==TOKEN_REF) )
-				{
-					alt11=1;
-				}
-
-
-				switch ( alt11 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:252:14: option[$opts] SEMI
-					{
-					PushFollow(Follow._option_in_optionsSpec644);
-					option17=option(retval.opts);
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, option17.Tree);
-					SEMI18=(IToken)Match(input,SEMI,Follow._SEMI_in_optionsSpec647); if (state.failed) return retval;
-
-					}
-					break;
-
-				default:
-					if ( cnt11 >= 1 )
-						goto loop11;
-
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					EarlyExitException eee11 = new EarlyExitException( 11, input );
-					throw eee11;
-				}
-				cnt11++;
-			}
-			loop11:
-				;
-
-
-			RCURLY19=(IToken)Match(input,RCURLY,Follow._RCURLY_in_optionsSpec652); if (state.failed) return retval;
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "optionsSpec"
-
-	public class option_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "option"
-	// Grammars\\ANTLR.g3:255:0: option[IDictionary<string, object> opts] : id ASSIGN optionValue ;
-	private ANTLRParser.option_return option( IDictionary<string, object> opts )
-	{
-		ANTLRParser.option_return retval = new ANTLRParser.option_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken ASSIGN21=null;
-		ANTLRParser.id_return id20 = default(ANTLRParser.id_return);
-		ANTLRParser.optionValue_return optionValue22 = default(ANTLRParser.optionValue_return);
-
-		GrammarAST ASSIGN21_tree=null;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:256:4: ( id ASSIGN optionValue )
-			// Grammars\\ANTLR.g3:256:4: id ASSIGN optionValue
-			{
-			root_0 = (GrammarAST)adaptor.Nil();
-
-			PushFollow(Follow._id_in_option665);
-			id20=id();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, id20.Tree);
-			ASSIGN21=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_option667); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) {
-			ASSIGN21_tree = (GrammarAST)adaptor.Create(ASSIGN21);
-			root_0 = (GrammarAST)adaptor.BecomeRoot(ASSIGN21_tree, root_0);
-			}
-			PushFollow(Follow._optionValue_in_option670);
-			optionValue22=optionValue();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, optionValue22.Tree);
-			if ( state.backtracking == 0 )
-			{
-
-							opts[(id20!=null?input.ToString(id20.start,id20.stop):null)] = (optionValue22!=null?optionValue22.value:default(object));
-
-			}
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "option"
-
-	public class optionValue_return : ParserRuleReturnScope
-	{
-		public object value=null;
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "optionValue"
-	// Grammars\\ANTLR.g3:262:0: optionValue returns [object value=null] : (x= id |s= STRING_LITERAL |c= CHAR_LITERAL |i= INT |ss= STAR -> STRING_LITERAL[$ss] );
-	private ANTLRParser.optionValue_return optionValue(  )
-	{
-		ANTLRParser.optionValue_return retval = new ANTLRParser.optionValue_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken s=null;
-		IToken c=null;
-		IToken i=null;
-		IToken ss=null;
-		ANTLRParser.id_return x = default(ANTLRParser.id_return);
-
-		GrammarAST s_tree=null;
-		GrammarAST c_tree=null;
-		GrammarAST i_tree=null;
-		GrammarAST ss_tree=null;
-		RewriteRuleITokenStream stream_STAR=new RewriteRuleITokenStream(adaptor,"token STAR");
-
-		try
-		{
-			// Grammars\\ANTLR.g3:263:4: (x= id |s= STRING_LITERAL |c= CHAR_LITERAL |i= INT |ss= STAR -> STRING_LITERAL[$ss] )
-			int alt12=5;
-			switch ( input.LA(1) )
-			{
-			case RULE_REF:
-			case TOKEN_REF:
-				{
-				alt12=1;
-				}
-				break;
-			case STRING_LITERAL:
-				{
-				alt12=2;
-				}
-				break;
-			case CHAR_LITERAL:
-				{
-				alt12=3;
-				}
-				break;
-			case INT:
-				{
-				alt12=4;
-				}
-				break;
-			case STAR:
-				{
-				alt12=5;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 12, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt12 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:263:4: x= id
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				PushFollow(Follow._id_in_optionValue691);
-				x=id();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, x.Tree);
-				if ( state.backtracking == 0 )
-				{
-					retval.value = (x!=null?input.ToString(x.start,x.stop):null);
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:264:4: s= STRING_LITERAL
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				s=(IToken)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_optionValue703); if (state.failed) return retval;
-				if ( state.backtracking==0 ) {
-				s_tree = (GrammarAST)adaptor.Create(s);
-				adaptor.AddChild(root_0, s_tree);
-				}
-				if ( state.backtracking == 0 )
-				{
-					string vs = (s!=null?s.Text:null);
-											  // remove the quotes:
-											  retval.value =vs.Substring(1,vs.Length-2);
-				}
-
-				}
-				break;
-			case 3:
-				// Grammars\\ANTLR.g3:267:4: c= CHAR_LITERAL
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				c=(IToken)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_optionValue712); if (state.failed) return retval;
-				if ( state.backtracking==0 ) {
-				c_tree = (GrammarAST)adaptor.Create(c);
-				adaptor.AddChild(root_0, c_tree);
-				}
-				if ( state.backtracking == 0 )
-				{
-					string vs = (c!=null?c.Text:null);
-											  // remove the quotes:
-											  retval.value =vs.Substring(1,vs.Length-2);
-				}
-
-				}
-				break;
-			case 4:
-				// Grammars\\ANTLR.g3:270:4: i= INT
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				i=(IToken)Match(input,INT,Follow._INT_in_optionValue723); if (state.failed) return retval;
-				if ( state.backtracking==0 ) {
-				i_tree = (GrammarAST)adaptor.Create(i);
-				adaptor.AddChild(root_0, i_tree);
-				}
-				if ( state.backtracking == 0 )
-				{
-					retval.value = int.Parse((i!=null?i.Text:null));
-				}
-
-				}
-				break;
-			case 5:
-				// Grammars\\ANTLR.g3:271:4: ss= STAR
-				{
-				ss=(IToken)Match(input,STAR,Follow._STAR_in_optionValue743); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_STAR.Add(ss);
-
-				if ( state.backtracking == 0 )
-				{
-					retval.value = "*";
-				}
-
-
-				{
-				// AST REWRITE
-				// elements:
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 272:3: -> STRING_LITERAL[$ss]
-				{
-					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(STRING_LITERAL, ss));
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-
-			}
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "optionValue"
-
-	public class delegateGrammars_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "delegateGrammars"
-	// Grammars\\ANTLR.g3:276:0: delegateGrammars : 'import' delegateGrammar ( COMMA delegateGrammar )* SEMI ;
-	private ANTLRParser.delegateGrammars_return delegateGrammars(  )
-	{
-		ANTLRParser.delegateGrammars_return retval = new ANTLRParser.delegateGrammars_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken string_literal23=null;
-		IToken COMMA25=null;
-		IToken SEMI27=null;
-		ANTLRParser.delegateGrammar_return delegateGrammar24 = default(ANTLRParser.delegateGrammar_return);
-		ANTLRParser.delegateGrammar_return delegateGrammar26 = default(ANTLRParser.delegateGrammar_return);
-
-		GrammarAST string_literal23_tree=null;
-		GrammarAST COMMA25_tree=null;
-		GrammarAST SEMI27_tree=null;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:277:4: ( 'import' delegateGrammar ( COMMA delegateGrammar )* SEMI )
-			// Grammars\\ANTLR.g3:277:4: 'import' delegateGrammar ( COMMA delegateGrammar )* SEMI
-			{
-			root_0 = (GrammarAST)adaptor.Nil();
-
-			string_literal23=(IToken)Match(input,IMPORT,Follow._IMPORT_in_delegateGrammars768); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) {
-			string_literal23_tree = (GrammarAST)adaptor.Create(string_literal23);
-			root_0 = (GrammarAST)adaptor.BecomeRoot(string_literal23_tree, root_0);
-			}
-			PushFollow(Follow._delegateGrammar_in_delegateGrammars771);
-			delegateGrammar24=delegateGrammar();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, delegateGrammar24.Tree);
-			// Grammars\\ANTLR.g3:277:30: ( COMMA delegateGrammar )*
-			for ( ; ; )
-			{
-				int alt13=2;
-				int LA13_0 = input.LA(1);
-
-				if ( (LA13_0==COMMA) )
-				{
-					alt13=1;
-				}
-
-
-				switch ( alt13 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:277:31: COMMA delegateGrammar
-					{
-					COMMA25=(IToken)Match(input,COMMA,Follow._COMMA_in_delegateGrammars774); if (state.failed) return retval;
-					PushFollow(Follow._delegateGrammar_in_delegateGrammars777);
-					delegateGrammar26=delegateGrammar();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, delegateGrammar26.Tree);
-
-					}
-					break;
-
-				default:
-					goto loop13;
-				}
-			}
-
-			loop13:
-				;
-
-
-			SEMI27=(IToken)Match(input,SEMI,Follow._SEMI_in_delegateGrammars781); if (state.failed) return retval;
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "delegateGrammars"
-
-	public class delegateGrammar_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "delegateGrammar"
-	// Grammars\\ANTLR.g3:280:0: delegateGrammar : (lab= id ASSIGN g= id |g2= id );
-	private ANTLRParser.delegateGrammar_return delegateGrammar(  )
-	{
-		ANTLRParser.delegateGrammar_return retval = new ANTLRParser.delegateGrammar_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken ASSIGN28=null;
-		ANTLRParser.id_return lab = default(ANTLRParser.id_return);
-		ANTLRParser.id_return g = default(ANTLRParser.id_return);
-		ANTLRParser.id_return g2 = default(ANTLRParser.id_return);
-
-		GrammarAST ASSIGN28_tree=null;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:281:4: (lab= id ASSIGN g= id |g2= id )
-			int alt14=2;
-			int LA14_0 = input.LA(1);
-
-			if ( (LA14_0==TOKEN_REF) )
-			{
-				int LA14_1 = input.LA(2);
-
-				if ( (LA14_1==ASSIGN) )
-				{
-					alt14=1;
-				}
-				else if ( (LA14_1==COMMA||LA14_1==SEMI) )
-				{
-					alt14=2;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 14, 1, input);
-
-					throw nvae;
-				}
-			}
-			else if ( (LA14_0==RULE_REF) )
-			{
-				int LA14_2 = input.LA(2);
-
-				if ( (LA14_2==ASSIGN) )
-				{
-					alt14=1;
-				}
-				else if ( (LA14_2==COMMA||LA14_2==SEMI) )
-				{
-					alt14=2;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 14, 2, input);
-
-					throw nvae;
-				}
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return retval;}
-				NoViableAltException nvae = new NoViableAltException("", 14, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt14 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:281:4: lab= id ASSIGN g= id
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				PushFollow(Follow._id_in_delegateGrammar795);
-				lab=id();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, lab.Tree);
-				ASSIGN28=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_delegateGrammar797); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) {
-				ASSIGN28_tree = (GrammarAST)adaptor.Create(ASSIGN28);
-				root_0 = (GrammarAST)adaptor.BecomeRoot(ASSIGN28_tree, root_0);
-				}
-				PushFollow(Follow._id_in_delegateGrammar802);
-				g=id();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, g.Tree);
-				if ( state.backtracking == 0 )
-				{
-					Grammar.ImportGrammar((g!=null?((GrammarAST)g.Tree):null), (lab!=null?input.ToString(lab.start,lab.stop):null));
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:282:4: g2= id
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				PushFollow(Follow._id_in_delegateGrammar811);
-				g2=id();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, g2.Tree);
-				if ( state.backtracking == 0 )
-				{
-					Grammar.ImportGrammar((g2!=null?((GrammarAST)g2.Tree):null),null);
-				}
-
-				}
-				break;
-
-			}
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "delegateGrammar"
-
-	public class tokensSpec_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "tokensSpec"
-	// Grammars\\ANTLR.g3:285:0: tokensSpec : TOKENS ( tokenSpec )+ RCURLY ;
-	private ANTLRParser.tokensSpec_return tokensSpec(  )
-	{
-		ANTLRParser.tokensSpec_return retval = new ANTLRParser.tokensSpec_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken TOKENS29=null;
-		IToken RCURLY31=null;
-		ANTLRParser.tokenSpec_return tokenSpec30 = default(ANTLRParser.tokenSpec_return);
-
-		GrammarAST TOKENS29_tree=null;
-		GrammarAST RCURLY31_tree=null;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:286:4: ( TOKENS ( tokenSpec )+ RCURLY )
-			// Grammars\\ANTLR.g3:286:4: TOKENS ( tokenSpec )+ RCURLY
-			{
-			root_0 = (GrammarAST)adaptor.Nil();
-
-			TOKENS29=(IToken)Match(input,TOKENS,Follow._TOKENS_in_tokensSpec838); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) {
-			TOKENS29_tree = (GrammarAST)adaptor.Create(TOKENS29);
-			root_0 = (GrammarAST)adaptor.BecomeRoot(TOKENS29_tree, root_0);
-			}
-			// Grammars\\ANTLR.g3:287:4: ( tokenSpec )+
-			int cnt15=0;
-			for ( ; ; )
-			{
-				int alt15=2;
-				int LA15_0 = input.LA(1);
-
-				if ( (LA15_0==TOKEN_REF) )
-				{
-					alt15=1;
-				}
-
-
-				switch ( alt15 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:287:6: tokenSpec
-					{
-					PushFollow(Follow._tokenSpec_in_tokensSpec846);
-					tokenSpec30=tokenSpec();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, tokenSpec30.Tree);
-
-					}
-					break;
-
-				default:
-					if ( cnt15 >= 1 )
-						goto loop15;
-
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					EarlyExitException eee15 = new EarlyExitException( 15, input );
-					throw eee15;
-				}
-				cnt15++;
-			}
-			loop15:
-				;
-
-
-			RCURLY31=(IToken)Match(input,RCURLY,Follow._RCURLY_in_tokensSpec853); if (state.failed) return retval;
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "tokensSpec"
-
-	public class tokenSpec_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "tokenSpec"
-	// Grammars\\ANTLR.g3:291:0: tokenSpec : TOKEN_REF ( ASSIGN ( STRING_LITERAL | CHAR_LITERAL ) )? SEMI ;
-	private ANTLRParser.tokenSpec_return tokenSpec(  )
-	{
-		ANTLRParser.tokenSpec_return retval = new ANTLRParser.tokenSpec_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken TOKEN_REF32=null;
-		IToken ASSIGN33=null;
-		IToken set34=null;
-		IToken SEMI35=null;
-
-		GrammarAST TOKEN_REF32_tree=null;
-		GrammarAST ASSIGN33_tree=null;
-		GrammarAST set34_tree=null;
-		GrammarAST SEMI35_tree=null;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:292:4: ( TOKEN_REF ( ASSIGN ( STRING_LITERAL | CHAR_LITERAL ) )? SEMI )
-			// Grammars\\ANTLR.g3:292:4: TOKEN_REF ( ASSIGN ( STRING_LITERAL | CHAR_LITERAL ) )? SEMI
-			{
-			root_0 = (GrammarAST)adaptor.Nil();
-
-			TOKEN_REF32=(IToken)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_tokenSpec865); if (state.failed) return retval;
-			if ( state.backtracking==0 ) {
-			TOKEN_REF32_tree = (GrammarAST)adaptor.Create(TOKEN_REF32);
-			adaptor.AddChild(root_0, TOKEN_REF32_tree);
-			}
-			// Grammars\\ANTLR.g3:292:14: ( ASSIGN ( STRING_LITERAL | CHAR_LITERAL ) )?
-			int alt16=2;
-			int LA16_0 = input.LA(1);
-
-			if ( (LA16_0==ASSIGN) )
-			{
-				alt16=1;
-			}
-			switch ( alt16 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:292:16: ASSIGN ( STRING_LITERAL | CHAR_LITERAL )
-				{
-				ASSIGN33=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_tokenSpec869); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) {
-				ASSIGN33_tree = (GrammarAST)adaptor.Create(ASSIGN33);
-				root_0 = (GrammarAST)adaptor.BecomeRoot(ASSIGN33_tree, root_0);
-				}
-				set34=(IToken)input.LT(1);
-				if ( input.LA(1)==CHAR_LITERAL||input.LA(1)==STRING_LITERAL )
-				{
-					input.Consume();
-					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(set34));
-					state.errorRecovery=false;state.failed=false;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					MismatchedSetException mse = new MismatchedSetException(null,input);
-					throw mse;
-				}
-
-
-				}
-				break;
-
-			}
-
-			SEMI35=(IToken)Match(input,SEMI,Follow._SEMI_in_tokenSpec881); if (state.failed) return retval;
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "tokenSpec"
-
-	public class attrScopes_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "attrScopes"
-	// Grammars\\ANTLR.g3:295:0: attrScopes : ( attrScope )* ;
-	private ANTLRParser.attrScopes_return attrScopes(  )
-	{
-		ANTLRParser.attrScopes_return retval = new ANTLRParser.attrScopes_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		ANTLRParser.attrScope_return attrScope36 = default(ANTLRParser.attrScope_return);
-
-
-		try
-		{
-			// Grammars\\ANTLR.g3:296:4: ( ( attrScope )* )
-			// Grammars\\ANTLR.g3:296:4: ( attrScope )*
-			{
-			root_0 = (GrammarAST)adaptor.Nil();
-
-			// Grammars\\ANTLR.g3:296:4: ( attrScope )*
-			for ( ; ; )
-			{
-				int alt17=2;
-				int LA17_0 = input.LA(1);
-
-				if ( (LA17_0==SCOPE) )
-				{
-					alt17=1;
-				}
-
-
-				switch ( alt17 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:296:5: attrScope
-					{
-					PushFollow(Follow._attrScope_in_attrScopes894);
-					attrScope36=attrScope();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, attrScope36.Tree);
-
-					}
-					break;
-
-				default:
-					goto loop17;
-				}
-			}
-
-			loop17:
-				;
-
-
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "attrScopes"
-
-	public class attrScope_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "attrScope"
-	// Grammars\\ANTLR.g3:299:0: attrScope : 'scope' id ( ruleActions )? ACTION ;
-	private ANTLRParser.attrScope_return attrScope(  )
-	{
-		ANTLRParser.attrScope_return retval = new ANTLRParser.attrScope_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken string_literal37=null;
-		IToken ACTION40=null;
-		ANTLRParser.id_return id38 = default(ANTLRParser.id_return);
-		ANTLRParser.ruleActions_return ruleActions39 = default(ANTLRParser.ruleActions_return);
-
-		GrammarAST string_literal37_tree=null;
-		GrammarAST ACTION40_tree=null;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:300:4: ( 'scope' id ( ruleActions )? ACTION )
-			// Grammars\\ANTLR.g3:300:4: 'scope' id ( ruleActions )? ACTION
-			{
-			root_0 = (GrammarAST)adaptor.Nil();
-
-			string_literal37=(IToken)Match(input,SCOPE,Follow._SCOPE_in_attrScope907); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) {
-			string_literal37_tree = (GrammarAST)adaptor.Create(string_literal37);
-			root_0 = (GrammarAST)adaptor.BecomeRoot(string_literal37_tree, root_0);
-			}
-			PushFollow(Follow._id_in_attrScope910);
-			id38=id();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, id38.Tree);
-			// Grammars\\ANTLR.g3:300:16: ( ruleActions )?
-			int alt18=2;
-			int LA18_0 = input.LA(1);
-
-			if ( (LA18_0==AMPERSAND) )
-			{
-				alt18=1;
-			}
-			switch ( alt18 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:300:0: ruleActions
-				{
-				PushFollow(Follow._ruleActions_in_attrScope912);
-				ruleActions39=ruleActions();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, ruleActions39.Tree);
-
-				}
-				break;
-
-			}
-
-			ACTION40=(IToken)Match(input,ACTION,Follow._ACTION_in_attrScope915); if (state.failed) return retval;
-			if ( state.backtracking==0 ) {
-			ACTION40_tree = (GrammarAST)adaptor.Create(ACTION40);
-			adaptor.AddChild(root_0, ACTION40_tree);
-			}
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "attrScope"
-
-	public class rules_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "rules"
-	// Grammars\\ANTLR.g3:303:0: rules : ( rule )+ ;
-	private ANTLRParser.rules_return rules(  )
-	{
-		ANTLRParser.rules_return retval = new ANTLRParser.rules_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		ANTLRParser.rule_return rule41 = default(ANTLRParser.rule_return);
-
-
-		try
-		{
-			// Grammars\\ANTLR.g3:304:4: ( ( rule )+ )
-			// Grammars\\ANTLR.g3:304:4: ( rule )+
-			{
-			root_0 = (GrammarAST)adaptor.Nil();
-
-			// Grammars\\ANTLR.g3:304:4: ( rule )+
-			int cnt19=0;
-			for ( ; ; )
-			{
-				int alt19=2;
-				int LA19_0 = input.LA(1);
-
-				if ( (LA19_0==DOC_COMMENT||LA19_0==FRAGMENT||(LA19_0>=PRIVATE && LA19_0<=PUBLIC)||LA19_0==RULE_REF||LA19_0==TOKEN_REF) )
-				{
-					alt19=1;
-				}
-
-
-				switch ( alt19 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:304:6: rule
-					{
-					PushFollow(Follow._rule_in_rules928);
-					rule41=rule();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, rule41.Tree);
-
-					}
-					break;
-
-				default:
-					if ( cnt19 >= 1 )
-						goto loop19;
-
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					EarlyExitException eee19 = new EarlyExitException( 19, input );
-					throw eee19;
-				}
-				cnt19++;
-			}
-			loop19:
-				;
-
-
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "rules"
-
-	public class rule_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "rule"
-	// Grammars\\ANTLR.g3:309:0: public rule : ( (d= DOC_COMMENT )? (p1= 'protected' |p2= 'public' |p3= 'private' |p4= 'fragment' )? ruleName= id ( BANG )? (aa= ARG_ACTION )? ( 'returns' rt= ARG_ACTION )? ( throwsSpec )? ( optionsSpec )? scopes= ruleScopeSpec ( ruleActions )? COLON altList[$optionsSpec.opts] SEMI (ex= exceptionGroup )? -> ^( RULE[\"rule\"] ^( $ruleName) ( $p1)? ( $p2)? ( $p3)? ( $p4)? ^( ARG[\"ARG\"] ( $aa)? ) ^( RET[\"RET\"] ( $rt)? ) ( throwsSpec )? ( optionsSpec )? ^( $scopes) ( ruleActions )? altList ( $ex)? EOR[$SEMI,\"<end-of-rule>\"] ) ) ;
-	public ANTLRParser.rule_return rule(  )
-	{
-		ANTLRParser.rule_return retval = new ANTLRParser.rule_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken d=null;
-		IToken p1=null;
-		IToken p2=null;
-		IToken p3=null;
-		IToken p4=null;
-		IToken aa=null;
-		IToken rt=null;
-		IToken BANG42=null;
-		IToken string_literal43=null;
-		IToken COLON47=null;
-		IToken SEMI49=null;
-		ANTLRParser.id_return ruleName = default(ANTLRParser.id_return);
-		ANTLRParser.ruleScopeSpec_return scopes = default(ANTLRParser.ruleScopeSpec_return);
-		ANTLRParser.exceptionGroup_return ex = default(ANTLRParser.exceptionGroup_return);
-		ANTLRParser.throwsSpec_return throwsSpec44 = default(ANTLRParser.throwsSpec_return);
-		ANTLRParser.optionsSpec_return optionsSpec45 = default(ANTLRParser.optionsSpec_return);
-		ANTLRParser.ruleActions_return ruleActions46 = default(ANTLRParser.ruleActions_return);
-		ANTLRParser.altList_return altList48 = default(ANTLRParser.altList_return);
-
-		GrammarAST d_tree=null;
-		GrammarAST p1_tree=null;
-		GrammarAST p2_tree=null;
-		GrammarAST p3_tree=null;
-		GrammarAST p4_tree=null;
-		GrammarAST aa_tree=null;
-		GrammarAST rt_tree=null;
-		GrammarAST BANG42_tree=null;
-		GrammarAST string_literal43_tree=null;
-		GrammarAST COLON47_tree=null;
-		GrammarAST SEMI49_tree=null;
-		RewriteRuleITokenStream stream_DOC_COMMENT=new RewriteRuleITokenStream(adaptor,"token DOC_COMMENT");
-		RewriteRuleITokenStream stream_PROTECTED=new RewriteRuleITokenStream(adaptor,"token PROTECTED");
-		RewriteRuleITokenStream stream_PUBLIC=new RewriteRuleITokenStream(adaptor,"token PUBLIC");
-		RewriteRuleITokenStream stream_PRIVATE=new RewriteRuleITokenStream(adaptor,"token PRIVATE");
-		RewriteRuleITokenStream stream_FRAGMENT=new RewriteRuleITokenStream(adaptor,"token FRAGMENT");
-		RewriteRuleITokenStream stream_BANG=new RewriteRuleITokenStream(adaptor,"token BANG");
-		RewriteRuleITokenStream stream_ARG_ACTION=new RewriteRuleITokenStream(adaptor,"token ARG_ACTION");
-		RewriteRuleITokenStream stream_RETURNS=new RewriteRuleITokenStream(adaptor,"token RETURNS");
-		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
-		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
-		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
-		RewriteRuleSubtreeStream stream_throwsSpec=new RewriteRuleSubtreeStream(adaptor,"rule throwsSpec");
-		RewriteRuleSubtreeStream stream_optionsSpec=new RewriteRuleSubtreeStream(adaptor,"rule optionsSpec");
-		RewriteRuleSubtreeStream stream_ruleScopeSpec=new RewriteRuleSubtreeStream(adaptor,"rule ruleScopeSpec");
-		RewriteRuleSubtreeStream stream_ruleActions=new RewriteRuleSubtreeStream(adaptor,"rule ruleActions");
-		RewriteRuleSubtreeStream stream_altList=new RewriteRuleSubtreeStream(adaptor,"rule altList");
-		RewriteRuleSubtreeStream stream_exceptionGroup=new RewriteRuleSubtreeStream(adaptor,"rule exceptionGroup");
-
-			GrammarAST eob=null;
-			int start = ((CommonToken)LT(1)).TokenIndex;
-			int startLine = LT(1).Line;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:317:2: ( ( (d= DOC_COMMENT )? (p1= 'protected' |p2= 'public' |p3= 'private' |p4= 'fragment' )? ruleName= id ( BANG )? (aa= ARG_ACTION )? ( 'returns' rt= ARG_ACTION )? ( throwsSpec )? ( optionsSpec )? scopes= ruleScopeSpec ( ruleActions )? COLON altList[$optionsSpec.opts] SEMI (ex= exceptionGroup )? -> ^( RULE[\"rule\"] ^( $ruleName) ( $p1)? ( $p2)? ( $p3)? ( $p4)? ^( ARG[\"ARG\"] ( $aa)? ) ^( RET[\"RET\"] ( $rt)? ) ( throwsSpec )? ( optionsSpec )? ^( $scopes) ( ruleActions )? altList ( $ex)? EOR[$SEMI,\"<end-of-rule>\"] ) ) )
-			// Grammars\\ANTLR.g3:317:2: ( (d= DOC_COMMENT )? (p1= 'protected' |p2= 'public' |p3= 'private' |p4= 'fragment' )? ruleName= id ( BANG )? (aa= ARG_ACTION )? ( 'returns' rt= ARG_ACTION )? ( throwsSpec )? ( optionsSpec )? scopes= ruleScopeSpec ( ruleActions )? COLON altList[$optionsSpec.opts] SEMI (ex= exceptionGroup )? -> ^( RULE[\"rule\"] ^( $ruleName) ( $p1)? ( $p2)? ( $p3)? ( $p4)? ^( ARG[\"ARG\"] ( $aa)? ) ^( RET[\"RET\"] ( $rt)? ) ( throwsSpec )? ( optionsSpec )? ^( $scopes) ( ruleActions )? altList ( $ex)? EOR[$SEMI,\"<end-of-rule>\"] ) )
-			{
-			// Grammars\\ANTLR.g3:317:2: ( (d= DOC_COMMENT )? (p1= 'protected' |p2= 'public' |p3= 'private' |p4= 'fragment' )? ruleName= id ( BANG )? (aa= ARG_ACTION )? ( 'returns' rt= ARG_ACTION )? ( throwsSpec )? ( optionsSpec )? scopes= ruleScopeSpec ( ruleActions )? COLON altList[$optionsSpec.opts] SEMI (ex= exceptionGroup )? -> ^( RULE[\"rule\"] ^( $ruleName) ( $p1)? ( $p2)? ( $p3)? ( $p4)? ^( ARG[\"ARG\"] ( $aa)? ) ^( RET[\"RET\"] ( $rt)? ) ( throwsSpec )? ( optionsSpec )? ^( $scopes) ( ruleActions )? altList ( $ex)? EOR[$SEMI,\"<end-of-rule>\"] ) )
-			// Grammars\\ANTLR.g3:317:4: (d= DOC_COMMENT )? (p1= 'protected' |p2= 'public' |p3= 'private' |p4= 'fragment' )? ruleName= id ( BANG )? (aa= ARG_ACTION )? ( 'returns' rt= ARG_ACTION )? ( throwsSpec )? ( optionsSpec )? scopes= ruleScopeSpec ( ruleActions )? COLON altList[$optionsSpec.opts] SEMI (ex= exceptionGroup )?
-			{
-			// Grammars\\ANTLR.g3:317:4: (d= DOC_COMMENT )?
-			int alt20=2;
-			int LA20_0 = input.LA(1);
-
-			if ( (LA20_0==DOC_COMMENT) )
-			{
-				alt20=1;
-			}
-			switch ( alt20 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:317:6: d= DOC_COMMENT
-				{
-				d=(IToken)Match(input,DOC_COMMENT,Follow._DOC_COMMENT_in_rule958); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_DOC_COMMENT.Add(d);
-
-
-				}
-				break;
-
-			}
-
-			// Grammars\\ANTLR.g3:319:3: (p1= 'protected' |p2= 'public' |p3= 'private' |p4= 'fragment' )?
-			int alt21=5;
-			switch ( input.LA(1) )
-			{
-			case PROTECTED:
-				{
-				alt21=1;
-				}
-				break;
-			case PUBLIC:
-				{
-				alt21=2;
-				}
-				break;
-			case PRIVATE:
-				{
-				alt21=3;
-				}
-				break;
-			case FRAGMENT:
-				{
-				alt21=4;
-				}
-				break;
-			}
-
-			switch ( alt21 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:319:5: p1= 'protected'
-				{
-				p1=(IToken)Match(input,PROTECTED,Follow._PROTECTED_in_rule971); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_PROTECTED.Add(p1);
-
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:320:5: p2= 'public'
-				{
-				p2=(IToken)Match(input,PUBLIC,Follow._PUBLIC_in_rule980); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_PUBLIC.Add(p2);
-
-
-				}
-				break;
-			case 3:
-				// Grammars\\ANTLR.g3:321:5: p3= 'private'
-				{
-				p3=(IToken)Match(input,PRIVATE,Follow._PRIVATE_in_rule990); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_PRIVATE.Add(p3);
-
-
-				}
-				break;
-			case 4:
-				// Grammars\\ANTLR.g3:322:5: p4= 'fragment'
-				{
-				p4=(IToken)Match(input,FRAGMENT,Follow._FRAGMENT_in_rule999); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_FRAGMENT.Add(p4);
-
-
-				}
-				break;
-
-			}
-
-			PushFollow(Follow._id_in_rule1011);
-			ruleName=id();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_id.Add(ruleName.Tree);
-			if ( state.backtracking == 0 )
-			{
-
-							currentRuleName=(ruleName!=null?input.ToString(ruleName.start,ruleName.stop):null);
-							if ( GrammarType==GrammarType.Lexer && p4==null )
-								Grammar.lexerRuleNamesInCombined.Add(currentRuleName);
-
-			}
-			// Grammars\\ANTLR.g3:330:3: ( BANG )?
-			int alt22=2;
-			int LA22_0 = input.LA(1);
-
-			if ( (LA22_0==BANG) )
-			{
-				alt22=1;
-			}
-			switch ( alt22 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:330:5: BANG
-				{
-				BANG42=(IToken)Match(input,BANG,Follow._BANG_in_rule1021); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_BANG.Add(BANG42);
-
-
-				}
-				break;
-
-			}
-
-			// Grammars\\ANTLR.g3:331:3: (aa= ARG_ACTION )?
-			int alt23=2;
-			int LA23_0 = input.LA(1);
-
-			if ( (LA23_0==ARG_ACTION) )
-			{
-				alt23=1;
-			}
-			switch ( alt23 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:331:5: aa= ARG_ACTION
-				{
-				aa=(IToken)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule1032); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_ARG_ACTION.Add(aa);
-
-
-				}
-				break;
-
-			}
-
-			// Grammars\\ANTLR.g3:332:3: ( 'returns' rt= ARG_ACTION )?
-			int alt24=2;
-			int LA24_0 = input.LA(1);
-
-			if ( (LA24_0==RETURNS) )
-			{
-				alt24=1;
-			}
-			switch ( alt24 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:332:5: 'returns' rt= ARG_ACTION
-				{
-				string_literal43=(IToken)Match(input,RETURNS,Follow._RETURNS_in_rule1041); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_RETURNS.Add(string_literal43);
-
-				rt=(IToken)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule1045); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_ARG_ACTION.Add(rt);
-
-
-				}
-				break;
-
-			}
-
-			// Grammars\\ANTLR.g3:333:3: ( throwsSpec )?
-			int alt25=2;
-			int LA25_0 = input.LA(1);
-
-			if ( (LA25_0==THROWS) )
-			{
-				alt25=1;
-			}
-			switch ( alt25 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:333:5: throwsSpec
-				{
-				PushFollow(Follow._throwsSpec_in_rule1055);
-				throwsSpec44=throwsSpec();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_throwsSpec.Add(throwsSpec44.Tree);
-
-				}
-				break;
-
-			}
-
-			// Grammars\\ANTLR.g3:334:3: ( optionsSpec )?
-			int alt26=2;
-			int LA26_0 = input.LA(1);
-
-			if ( (LA26_0==OPTIONS) )
-			{
-				alt26=1;
-			}
-			switch ( alt26 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:334:5: optionsSpec
-				{
-				PushFollow(Follow._optionsSpec_in_rule1064);
-				optionsSpec45=optionsSpec();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_optionsSpec.Add(optionsSpec45.Tree);
-
-				}
-				break;
-
-			}
-
-			PushFollow(Follow._ruleScopeSpec_in_rule1073);
-			scopes=ruleScopeSpec();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_ruleScopeSpec.Add(scopes.Tree);
-			// Grammars\\ANTLR.g3:336:3: ( ruleActions )?
-			int alt27=2;
-			int LA27_0 = input.LA(1);
-
-			if ( (LA27_0==AMPERSAND) )
-			{
-				alt27=1;
-			}
-			switch ( alt27 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:336:4: ruleActions
-				{
-				PushFollow(Follow._ruleActions_in_rule1078);
-				ruleActions46=ruleActions();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_ruleActions.Add(ruleActions46.Tree);
-
-				}
-				break;
-
-			}
-
-			COLON47=(IToken)Match(input,COLON,Follow._COLON_in_rule1084); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_COLON.Add(COLON47);
-
-			PushFollow(Follow._altList_in_rule1088);
-			altList48=altList((optionsSpec45!=null?optionsSpec45.opts:default(IDictionary<string, object>)));
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_altList.Add(altList48.Tree);
-			SEMI49=(IToken)Match(input,SEMI,Follow._SEMI_in_rule1093); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_SEMI.Add(SEMI49);
-
-			// Grammars\\ANTLR.g3:340:3: (ex= exceptionGroup )?
-			int alt28=2;
-			int LA28_0 = input.LA(1);
-
-			if ( (LA28_0==CATCH||LA28_0==FINALLY) )
-			{
-				alt28=1;
-			}
-			switch ( alt28 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:340:5: ex= exceptionGroup
-				{
-				PushFollow(Follow._exceptionGroup_in_rule1101);
-				ex=exceptionGroup();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_exceptionGroup.Add(ex.Tree);
-
-				}
-				break;
-
-			}
-
-
-
-			{
-			// AST REWRITE
-			// elements: ruleName, p1, p2, p3, p4, aa, rt, throwsSpec, optionsSpec, scopes, ruleActions, altList, ex
-			// token labels: p1, p2, p3, p4, aa, rt
-			// rule labels: ruleName, scopes, ex, retval
-			// token list labels:
-			// rule list labels:
-			// wildcard labels:
-			if ( state.backtracking == 0 ) {
-			retval.tree = root_0;
-			RewriteRuleITokenStream stream_p1=new RewriteRuleITokenStream(adaptor,"token p1",p1);
-			RewriteRuleITokenStream stream_p2=new RewriteRuleITokenStream(adaptor,"token p2",p2);
-			RewriteRuleITokenStream stream_p3=new RewriteRuleITokenStream(adaptor,"token p3",p3);
-			RewriteRuleITokenStream stream_p4=new RewriteRuleITokenStream(adaptor,"token p4",p4);
-			RewriteRuleITokenStream stream_aa=new RewriteRuleITokenStream(adaptor,"token aa",aa);
-			RewriteRuleITokenStream stream_rt=new RewriteRuleITokenStream(adaptor,"token rt",rt);
-			RewriteRuleSubtreeStream stream_ruleName=new RewriteRuleSubtreeStream(adaptor,"rule ruleName",ruleName!=null?ruleName.tree:null);
-			RewriteRuleSubtreeStream stream_scopes=new RewriteRuleSubtreeStream(adaptor,"rule scopes",scopes!=null?scopes.tree:null);
-			RewriteRuleSubtreeStream stream_ex=new RewriteRuleSubtreeStream(adaptor,"rule ex",ex!=null?ex.tree:null);
-			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-			root_0 = (GrammarAST)adaptor.Nil();
-			// 341:3: -> ^( RULE[\"rule\"] ^( $ruleName) ( $p1)? ( $p2)? ( $p3)? ( $p4)? ^( ARG[\"ARG\"] ( $aa)? ) ^( RET[\"RET\"] ( $rt)? ) ( throwsSpec )? ( optionsSpec )? ^( $scopes) ( ruleActions )? altList ( $ex)? EOR[$SEMI,\"<end-of-rule>\"] )
-			{
-				// Grammars\\ANTLR.g3:341:6: ^( RULE[\"rule\"] ^( $ruleName) ( $p1)? ( $p2)? ( $p3)? ( $p4)? ^( ARG[\"ARG\"] ( $aa)? ) ^( RET[\"RET\"] ( $rt)? ) ( throwsSpec )? ( optionsSpec )? ^( $scopes) ( ruleActions )? altList ( $ex)? EOR[$SEMI,\"<end-of-rule>\"] )
-				{
-				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-				root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(RULE, "rule"), root_1);
-
-				// Grammars\\ANTLR.g3:342:5: ^( $ruleName)
-				{
-				GrammarAST root_2 = (GrammarAST)adaptor.Nil();
-				root_2 = (GrammarAST)adaptor.BecomeRoot(stream_ruleName.NextNode(), root_2);
-
-				adaptor.AddChild(root_1, root_2);
-				}
-				// Grammars\\ANTLR.g3:344:6: ( $p1)?
-				if ( stream_p1.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_p1.NextNode());
-
-				}
-				stream_p1.Reset();
-				// Grammars\\ANTLR.g3:344:11: ( $p2)?
-				if ( stream_p2.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_p2.NextNode());
-
-				}
-				stream_p2.Reset();
-				// Grammars\\ANTLR.g3:344:16: ( $p3)?
-				if ( stream_p3.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_p3.NextNode());
-
-				}
-				stream_p3.Reset();
-				// Grammars\\ANTLR.g3:344:21: ( $p4)?
-				if ( stream_p4.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_p4.NextNode());
-
-				}
-				stream_p4.Reset();
-				// Grammars\\ANTLR.g3:345:5: ^( ARG[\"ARG\"] ( $aa)? )
-				{
-				GrammarAST root_2 = (GrammarAST)adaptor.Nil();
-				root_2 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(ARG, "ARG"), root_2);
-
-				// Grammars\\ANTLR.g3:345:19: ( $aa)?
-				if ( stream_aa.HasNext )
-				{
-					adaptor.AddChild(root_2, stream_aa.NextNode());
-
-				}
-				stream_aa.Reset();
-
-				adaptor.AddChild(root_1, root_2);
-				}
-				// Grammars\\ANTLR.g3:346:5: ^( RET[\"RET\"] ( $rt)? )
-				{
-				GrammarAST root_2 = (GrammarAST)adaptor.Nil();
-				root_2 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(RET, "RET"), root_2);
-
-				// Grammars\\ANTLR.g3:346:19: ( $rt)?
-				if ( stream_rt.HasNext )
-				{
-					adaptor.AddChild(root_2, stream_rt.NextNode());
-
-				}
-				stream_rt.Reset();
-
-				adaptor.AddChild(root_1, root_2);
-				}
-				// Grammars\\ANTLR.g3:347:5: ( throwsSpec )?
-				if ( stream_throwsSpec.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_throwsSpec.NextTree());
-
-				}
-				stream_throwsSpec.Reset();
-				// Grammars\\ANTLR.g3:348:5: ( optionsSpec )?
-				if ( stream_optionsSpec.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_optionsSpec.NextTree());
-
-				}
-				stream_optionsSpec.Reset();
-				// Grammars\\ANTLR.g3:349:5: ^( $scopes)
-				{
-				GrammarAST root_2 = (GrammarAST)adaptor.Nil();
-				root_2 = (GrammarAST)adaptor.BecomeRoot(stream_scopes.NextNode(), root_2);
-
-				adaptor.AddChild(root_1, root_2);
-				}
-				// Grammars\\ANTLR.g3:350:5: ( ruleActions )?
-				if ( stream_ruleActions.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_ruleActions.NextTree());
-
-				}
-				stream_ruleActions.Reset();
-				adaptor.AddChild(root_1, stream_altList.NextTree());
-				// Grammars\\ANTLR.g3:352:6: ( $ex)?
-				if ( stream_ex.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_ex.NextTree());
-
-				}
-				stream_ex.Reset();
-				adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EOR, SEMI49, "<end-of-rule>"));
-
-				adaptor.AddChild(root_0, root_1);
-				}
-
-			}
-
-			retval.tree = root_0;
-			}
-			}
-
-			}
-
-			if ( state.backtracking == 0 )
-			{
-
-						((GrammarAST)((GrammarAST)retval.Tree).GetChild(0)).BlockOptions = (optionsSpec45!=null?optionsSpec45.opts:default(IDictionary<string, object>));
-
-			}
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "rule"
-
-	public class ruleActions_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "ruleActions"
-	// Grammars\\ANTLR.g3:360:0: ruleActions : ( ruleAction )+ ;
-	private ANTLRParser.ruleActions_return ruleActions(  )
-	{
-		ANTLRParser.ruleActions_return retval = new ANTLRParser.ruleActions_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		ANTLRParser.ruleAction_return ruleAction50 = default(ANTLRParser.ruleAction_return);
-
-
-		try
-		{
-			// Grammars\\ANTLR.g3:361:4: ( ( ruleAction )+ )
-			// Grammars\\ANTLR.g3:361:4: ( ruleAction )+
-			{
-			root_0 = (GrammarAST)adaptor.Nil();
-
-			// Grammars\\ANTLR.g3:361:4: ( ruleAction )+
-			int cnt29=0;
-			for ( ; ; )
-			{
-				int alt29=2;
-				int LA29_0 = input.LA(1);
-
-				if ( (LA29_0==AMPERSAND) )
-				{
-					alt29=1;
-				}
-
-
-				switch ( alt29 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:361:5: ruleAction
-					{
-					PushFollow(Follow._ruleAction_in_ruleActions1243);
-					ruleAction50=ruleAction();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, ruleAction50.Tree);
-
-					}
-					break;
-
-				default:
-					if ( cnt29 >= 1 )
-						goto loop29;
-
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					EarlyExitException eee29 = new EarlyExitException( 29, input );
-					throw eee29;
-				}
-				cnt29++;
-			}
-			loop29:
-				;
-
-
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "ruleActions"
-
-	public class ruleAction_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "ruleAction"
-	// Grammars\\ANTLR.g3:365:0: ruleAction : AMPERSAND id ACTION ;
-	private ANTLRParser.ruleAction_return ruleAction(  )
-	{
-		ANTLRParser.ruleAction_return retval = new ANTLRParser.ruleAction_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken AMPERSAND51=null;
-		IToken ACTION53=null;
-		ANTLRParser.id_return id52 = default(ANTLRParser.id_return);
-
-		GrammarAST AMPERSAND51_tree=null;
-		GrammarAST ACTION53_tree=null;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:366:4: ( AMPERSAND id ACTION )
-			// Grammars\\ANTLR.g3:366:4: AMPERSAND id ACTION
-			{
-			root_0 = (GrammarAST)adaptor.Nil();
-
-			AMPERSAND51=(IToken)Match(input,AMPERSAND,Follow._AMPERSAND_in_ruleAction1258); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) {
-			AMPERSAND51_tree = (GrammarAST)adaptor.Create(AMPERSAND51);
-			root_0 = (GrammarAST)adaptor.BecomeRoot(AMPERSAND51_tree, root_0);
-			}
-			PushFollow(Follow._id_in_ruleAction1261);
-			id52=id();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, id52.Tree);
-			ACTION53=(IToken)Match(input,ACTION,Follow._ACTION_in_ruleAction1263); if (state.failed) return retval;
-			if ( state.backtracking==0 ) {
-			ACTION53_tree = (GrammarAST)adaptor.Create(ACTION53);
-			adaptor.AddChild(root_0, ACTION53_tree);
-			}
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "ruleAction"
-
-	public class throwsSpec_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "throwsSpec"
-	// Grammars\\ANTLR.g3:369:0: throwsSpec : 'throws' id ( COMMA id )* ;
-	private ANTLRParser.throwsSpec_return throwsSpec(  )
-	{
-		ANTLRParser.throwsSpec_return retval = new ANTLRParser.throwsSpec_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken string_literal54=null;
-		IToken COMMA56=null;
-		ANTLRParser.id_return id55 = default(ANTLRParser.id_return);
-		ANTLRParser.id_return id57 = default(ANTLRParser.id_return);
-
-		GrammarAST string_literal54_tree=null;
-		GrammarAST COMMA56_tree=null;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:370:4: ( 'throws' id ( COMMA id )* )
-			// Grammars\\ANTLR.g3:370:4: 'throws' id ( COMMA id )*
-			{
-			root_0 = (GrammarAST)adaptor.Nil();
-
-			string_literal54=(IToken)Match(input,THROWS,Follow._THROWS_in_throwsSpec1274); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) {
-			string_literal54_tree = (GrammarAST)adaptor.Create(string_literal54);
-			root_0 = (GrammarAST)adaptor.BecomeRoot(string_literal54_tree, root_0);
-			}
-			PushFollow(Follow._id_in_throwsSpec1277);
-			id55=id();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, id55.Tree);
-			// Grammars\\ANTLR.g3:370:17: ( COMMA id )*
-			for ( ; ; )
-			{
-				int alt30=2;
-				int LA30_0 = input.LA(1);
-
-				if ( (LA30_0==COMMA) )
-				{
-					alt30=1;
-				}
-
-
-				switch ( alt30 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:370:19: COMMA id
-					{
-					COMMA56=(IToken)Match(input,COMMA,Follow._COMMA_in_throwsSpec1281); if (state.failed) return retval;
-					PushFollow(Follow._id_in_throwsSpec1284);
-					id57=id();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, id57.Tree);
-
-					}
-					break;
-
-				default:
-					goto loop30;
-				}
-			}
-
-			loop30:
-				;
-
-
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "throwsSpec"
-
-	public class ruleScopeSpec_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "ruleScopeSpec"
-	// Grammars\\ANTLR.g3:373:0: ruleScopeSpec : ( 'scope' ( ruleActions )? ACTION )? ( 'scope' idList SEMI )* -> ^( SCOPE[$start,\"scope\"] ( ruleActions )? ( ACTION )? ( idList )* ) ;
-	private ANTLRParser.ruleScopeSpec_return ruleScopeSpec(  )
-	{
-		ANTLRParser.ruleScopeSpec_return retval = new ANTLRParser.ruleScopeSpec_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken string_literal58=null;
-		IToken ACTION60=null;
-		IToken string_literal61=null;
-		IToken SEMI63=null;
-		ANTLRParser.ruleActions_return ruleActions59 = default(ANTLRParser.ruleActions_return);
-		ANTLRParser.idList_return idList62 = default(ANTLRParser.idList_return);
-
-		GrammarAST string_literal58_tree=null;
-		GrammarAST ACTION60_tree=null;
-		GrammarAST string_literal61_tree=null;
-		GrammarAST SEMI63_tree=null;
-		RewriteRuleITokenStream stream_SCOPE=new RewriteRuleITokenStream(adaptor,"token SCOPE");
-		RewriteRuleITokenStream stream_ACTION=new RewriteRuleITokenStream(adaptor,"token ACTION");
-		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
-		RewriteRuleSubtreeStream stream_ruleActions=new RewriteRuleSubtreeStream(adaptor,"rule ruleActions");
-		RewriteRuleSubtreeStream stream_idList=new RewriteRuleSubtreeStream(adaptor,"rule idList");
-		try
-		{
-			// Grammars\\ANTLR.g3:374:4: ( ( 'scope' ( ruleActions )? ACTION )? ( 'scope' idList SEMI )* -> ^( SCOPE[$start,\"scope\"] ( ruleActions )? ( ACTION )? ( idList )* ) )
-			// Grammars\\ANTLR.g3:374:4: ( 'scope' ( ruleActions )? ACTION )? ( 'scope' idList SEMI )*
-			{
-			// Grammars\\ANTLR.g3:374:4: ( 'scope' ( ruleActions )? ACTION )?
-			int alt32=2;
-			int LA32_0 = input.LA(1);
-
-			if ( (LA32_0==SCOPE) )
-			{
-				int LA32_1 = input.LA(2);
-
-				if ( (LA32_1==ACTION||LA32_1==AMPERSAND) )
-				{
-					alt32=1;
-				}
-			}
-			switch ( alt32 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:374:6: 'scope' ( ruleActions )? ACTION
-				{
-				string_literal58=(IToken)Match(input,SCOPE,Follow._SCOPE_in_ruleScopeSpec1300); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_SCOPE.Add(string_literal58);
-
-				// Grammars\\ANTLR.g3:374:14: ( ruleActions )?
-				int alt31=2;
-				int LA31_0 = input.LA(1);
-
-				if ( (LA31_0==AMPERSAND) )
-				{
-					alt31=1;
-				}
-				switch ( alt31 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:374:0: ruleActions
-					{
-					PushFollow(Follow._ruleActions_in_ruleScopeSpec1302);
-					ruleActions59=ruleActions();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) stream_ruleActions.Add(ruleActions59.Tree);
-
-					}
-					break;
-
-				}
-
-				ACTION60=(IToken)Match(input,ACTION,Follow._ACTION_in_ruleScopeSpec1305); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_ACTION.Add(ACTION60);
-
-
-				}
-				break;
-
-			}
-
-			// Grammars\\ANTLR.g3:375:3: ( 'scope' idList SEMI )*
-			for ( ; ; )
-			{
-				int alt33=2;
-				int LA33_0 = input.LA(1);
-
-				if ( (LA33_0==SCOPE) )
-				{
-					alt33=1;
-				}
-
-
-				switch ( alt33 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:375:5: 'scope' idList SEMI
-					{
-					string_literal61=(IToken)Match(input,SCOPE,Follow._SCOPE_in_ruleScopeSpec1314); if (state.failed) return retval;
-					if ( state.backtracking == 0 ) stream_SCOPE.Add(string_literal61);
-
-					PushFollow(Follow._idList_in_ruleScopeSpec1316);
-					idList62=idList();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) stream_idList.Add(idList62.Tree);
-					SEMI63=(IToken)Match(input,SEMI,Follow._SEMI_in_ruleScopeSpec1318); if (state.failed) return retval;
-					if ( state.backtracking == 0 ) stream_SEMI.Add(SEMI63);
-
-
-					}
-					break;
-
-				default:
-					goto loop33;
-				}
-			}
-
-			loop33:
-				;
-
-
-
-
-			{
-			// AST REWRITE
-			// elements: ruleActions, ACTION, idList
-			// token labels:
-			// rule labels: retval
-			// token list labels:
-			// rule list labels:
-			// wildcard labels:
-			if ( state.backtracking == 0 ) {
-			retval.tree = root_0;
-			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-			root_0 = (GrammarAST)adaptor.Nil();
-			// 376:3: -> ^( SCOPE[$start,\"scope\"] ( ruleActions )? ( ACTION )? ( idList )* )
-			{
-				// Grammars\\ANTLR.g3:376:6: ^( SCOPE[$start,\"scope\"] ( ruleActions )? ( ACTION )? ( idList )* )
-				{
-				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-				root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(SCOPE, ((IToken)retval.Start), "scope"), root_1);
-
-				// Grammars\\ANTLR.g3:376:30: ( ruleActions )?
-				if ( stream_ruleActions.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_ruleActions.NextTree());
-
-				}
-				stream_ruleActions.Reset();
-				// Grammars\\ANTLR.g3:376:43: ( ACTION )?
-				if ( stream_ACTION.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_ACTION.NextNode());
-
-				}
-				stream_ACTION.Reset();
-				// Grammars\\ANTLR.g3:376:51: ( idList )*
-				while ( stream_idList.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_idList.NextTree());
-
-				}
-				stream_idList.Reset();
-
-				adaptor.AddChild(root_0, root_1);
-				}
-
-			}
-
-			retval.tree = root_0;
-			}
-			}
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "ruleScopeSpec"
-
-	public class block_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "block"
-	// Grammars\\ANTLR.g3:380:0: block : (lp= LPAREN -> BLOCK[$lp,\"BLOCK\"] ) ( ( optionsSpec )? ( ruleActions )? COLON | ACTION COLON )? a= alternative r= rewrite ( OR a= alternative r= rewrite )* rp= RPAREN -> ^( $block ( optionsSpec )? ( ruleActions )? ( ACTION )? ( alternative )+ EOB[$rp,\"<end-of-block>\"] ) ;
-	private ANTLRParser.block_return block(  )
-	{
-		ANTLRParser.block_return retval = new ANTLRParser.block_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken lp=null;
-		IToken rp=null;
-		IToken COLON66=null;
-		IToken ACTION67=null;
-		IToken COLON68=null;
-		IToken OR69=null;
-		ANTLRParser.alternative_return a = default(ANTLRParser.alternative_return);
-		ANTLRParser.rewrite_return r = default(ANTLRParser.rewrite_return);
-		ANTLRParser.optionsSpec_return optionsSpec64 = default(ANTLRParser.optionsSpec_return);
-		ANTLRParser.ruleActions_return ruleActions65 = default(ANTLRParser.ruleActions_return);
-
-		GrammarAST lp_tree=null;
-		GrammarAST rp_tree=null;
-		GrammarAST COLON66_tree=null;
-		GrammarAST ACTION67_tree=null;
-		GrammarAST COLON68_tree=null;
-		GrammarAST OR69_tree=null;
-		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
-		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
-		RewriteRuleITokenStream stream_ACTION=new RewriteRuleITokenStream(adaptor,"token ACTION");
-		RewriteRuleITokenStream stream_OR=new RewriteRuleITokenStream(adaptor,"token OR");
-		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
-		RewriteRuleSubtreeStream stream_optionsSpec=new RewriteRuleSubtreeStream(adaptor,"rule optionsSpec");
-		RewriteRuleSubtreeStream stream_ruleActions=new RewriteRuleSubtreeStream(adaptor,"rule ruleActions");
-		RewriteRuleSubtreeStream stream_alternative=new RewriteRuleSubtreeStream(adaptor,"rule alternative");
-		RewriteRuleSubtreeStream stream_rewrite=new RewriteRuleSubtreeStream(adaptor,"rule rewrite");
-
-			GrammarAST save = currentBlockAST;
-			Map opts=null;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:386:4: ( (lp= LPAREN -> BLOCK[$lp,\"BLOCK\"] ) ( ( optionsSpec )? ( ruleActions )? COLON | ACTION COLON )? a= alternative r= rewrite ( OR a= alternative r= rewrite )* rp= RPAREN -> ^( $block ( optionsSpec )? ( ruleActions )? ( ACTION )? ( alternative )+ EOB[$rp,\"<end-of-block>\"] ) )
-			// Grammars\\ANTLR.g3:386:4: (lp= LPAREN -> BLOCK[$lp,\"BLOCK\"] ) ( ( optionsSpec )? ( ruleActions )? COLON | ACTION COLON )? a= alternative r= rewrite ( OR a= alternative r= rewrite )* rp= RPAREN
-			{
-			// Grammars\\ANTLR.g3:386:4: (lp= LPAREN -> BLOCK[$lp,\"BLOCK\"] )
-			// Grammars\\ANTLR.g3:386:6: lp= LPAREN
-			{
-			lp=(IToken)Match(input,LPAREN,Follow._LPAREN_in_block1361); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_LPAREN.Add(lp);
-
-
-
-			{
-			// AST REWRITE
-			// elements:
-			// token labels:
-			// rule labels: retval
-			// token list labels:
-			// rule list labels:
-			// wildcard labels:
-			if ( state.backtracking == 0 ) {
-			retval.tree = root_0;
-			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-			root_0 = (GrammarAST)adaptor.Nil();
-			// 387:4: -> BLOCK[$lp,\"BLOCK\"]
-			{
-				adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(BLOCK, lp, "BLOCK"));
-
-			}
-
-			retval.tree = root_0;
-			}
-			}
-
-			}
-
-			if ( state.backtracking == 0 )
-			{
-				currentBlockAST = (GrammarAST)((GrammarAST)retval.Tree).GetChild(0);
-			}
-			// Grammars\\ANTLR.g3:390:3: ( ( optionsSpec )? ( ruleActions )? COLON | ACTION COLON )?
-			int alt36=3;
-			int LA36_0 = input.LA(1);
-
-			if ( (LA36_0==AMPERSAND||LA36_0==COLON||LA36_0==OPTIONS) )
-			{
-				alt36=1;
-			}
-			else if ( (LA36_0==ACTION) )
-			{
-				int LA36_2 = input.LA(2);
-
-				if ( (LA36_2==COLON) )
-				{
-					alt36=2;
-				}
-			}
-			switch ( alt36 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:394:4: ( optionsSpec )? ( ruleActions )? COLON
-				{
-				// Grammars\\ANTLR.g3:394:4: ( optionsSpec )?
-				int alt34=2;
-				int LA34_0 = input.LA(1);
-
-				if ( (LA34_0==OPTIONS) )
-				{
-					alt34=1;
-				}
-				switch ( alt34 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:394:5: optionsSpec
-					{
-					PushFollow(Follow._optionsSpec_in_block1399);
-					optionsSpec64=optionsSpec();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) stream_optionsSpec.Add(optionsSpec64.Tree);
-					if ( state.backtracking == 0 )
-					{
-						((GrammarAST)((GrammarAST)retval.Tree).GetChild(0)).SetOptions(Grammar,(optionsSpec64!=null?optionsSpec64.opts:default(IDictionary<string, object>)));
-					}
-
-					}
-					break;
-
-				}
-
-				// Grammars\\ANTLR.g3:395:4: ( ruleActions )?
-				int alt35=2;
-				int LA35_0 = input.LA(1);
-
-				if ( (LA35_0==AMPERSAND) )
-				{
-					alt35=1;
-				}
-				switch ( alt35 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:395:6: ruleActions
-					{
-					PushFollow(Follow._ruleActions_in_block1410);
-					ruleActions65=ruleActions();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) stream_ruleActions.Add(ruleActions65.Tree);
-
-					}
-					break;
-
-				}
-
-				COLON66=(IToken)Match(input,COLON,Follow._COLON_in_block1418); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_COLON.Add(COLON66);
-
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:397:5: ACTION COLON
-				{
-				ACTION67=(IToken)Match(input,ACTION,Follow._ACTION_in_block1424); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_ACTION.Add(ACTION67);
-
-				COLON68=(IToken)Match(input,COLON,Follow._COLON_in_block1426); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_COLON.Add(COLON68);
-
-
-				}
-				break;
-
-			}
-
-			PushFollow(Follow._alternative_in_block1438);
-			a=alternative();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_alternative.Add(a.Tree);
-			PushFollow(Follow._rewrite_in_block1442);
-			r=rewrite();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_rewrite.Add(r.Tree);
-			if ( state.backtracking == 0 )
-			{
-
-							stream_alternative.Add( (r!=null?((GrammarAST)r.Tree):null) );
-							if ( LA(1)==OR || (LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR) )
-								PrefixWithSynPred((a!=null?((GrammarAST)a.Tree):null));
-
-			}
-			// Grammars\\ANTLR.g3:406:3: ( OR a= alternative r= rewrite )*
-			for ( ; ; )
-			{
-				int alt37=2;
-				int LA37_0 = input.LA(1);
-
-				if ( (LA37_0==OR) )
-				{
-					alt37=1;
-				}
-
-
-				switch ( alt37 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:406:5: OR a= alternative r= rewrite
-					{
-					OR69=(IToken)Match(input,OR,Follow._OR_in_block1452); if (state.failed) return retval;
-					if ( state.backtracking == 0 ) stream_OR.Add(OR69);
-
-					PushFollow(Follow._alternative_in_block1456);
-					a=alternative();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) stream_alternative.Add(a.Tree);
-					PushFollow(Follow._rewrite_in_block1460);
-					r=rewrite();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) stream_rewrite.Add(r.Tree);
-					if ( state.backtracking == 0 )
-					{
-
-										stream_alternative.Add( (r!=null?((GrammarAST)r.Tree):null) );
-										if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR))
-											PrefixWithSynPred((a!=null?((GrammarAST)a.Tree):null));
-
-					}
-
-					}
-					break;
-
-				default:
-					goto loop37;
-				}
-			}
-
-			loop37:
-				;
-
-
-			rp=(IToken)Match(input,RPAREN,Follow._RPAREN_in_block1477); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_RPAREN.Add(rp);
-
-
-
-			{
-			// AST REWRITE
-			// elements: block, optionsSpec, ruleActions, ACTION, alternative
-			// token labels:
-			// rule labels: retval
-			// token list labels:
-			// rule list labels:
-			// wildcard labels:
-			if ( state.backtracking == 0 ) {
-			retval.tree = root_0;
-			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-			root_0 = (GrammarAST)adaptor.Nil();
-			// 415:3: -> ^( $block ( optionsSpec )? ( ruleActions )? ( ACTION )? ( alternative )+ EOB[$rp,\"<end-of-block>\"] )
-			{
-				// Grammars\\ANTLR.g3:415:6: ^( $block ( optionsSpec )? ( ruleActions )? ( ACTION )? ( alternative )+ EOB[$rp,\"<end-of-block>\"] )
-				{
-				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-				root_1 = (GrammarAST)adaptor.BecomeRoot(stream_retval.NextNode(), root_1);
-
-				// Grammars\\ANTLR.g3:415:15: ( optionsSpec )?
-				if ( stream_optionsSpec.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_optionsSpec.NextTree());
-
-				}
-				stream_optionsSpec.Reset();
-				// Grammars\\ANTLR.g3:415:28: ( ruleActions )?
-				if ( stream_ruleActions.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_ruleActions.NextTree());
-
-				}
-				stream_ruleActions.Reset();
-				// Grammars\\ANTLR.g3:415:41: ( ACTION )?
-				if ( stream_ACTION.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_ACTION.NextNode());
-
-				}
-				stream_ACTION.Reset();
-				if ( !(stream_alternative.HasNext) )
-				{
-					throw new RewriteEarlyExitException();
-				}
-				while ( stream_alternative.HasNext )
-				{
-					adaptor.AddChild(root_1, stream_alternative.NextTree());
-
-				}
-				stream_alternative.Reset();
-				adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EOB, rp, "<end-of-block>"));
-
-				adaptor.AddChild(root_0, root_1);
-				}
-
-			}
-
-			retval.tree = root_0;
-			}
-			}
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-			 currentBlockAST = save;
-		}
-		return retval;
-	}
-	// $ANTLR end "block"
-
-	public class altList_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "altList"
-	// Grammars\\ANTLR.g3:419:0: altList[IDictionary<string, object> opts] : ( -> BLOCK[$start,\"BLOCK\"] ) (a1= alternative r1= rewrite -> $a1 ( $r1)? ) ( OR a2= alternative r2= rewrite -> $altList $a2 ( $r2)? )* -> ^( $altList EOB[\"<end-of-block>\"] ) ;
-	private ANTLRParser.altList_return altList( IDictionary<string, object> opts )
-	{
-		ANTLRParser.altList_return retval = new ANTLRParser.altList_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken OR70=null;
-		ANTLRParser.alternative_return a1 = default(ANTLRParser.alternative_return);
-		ANTLRParser.rewrite_return r1 = default(ANTLRParser.rewrite_return);
-		ANTLRParser.alternative_return a2 = default(ANTLRParser.alternative_return);
-		ANTLRParser.rewrite_return r2 = default(ANTLRParser.rewrite_return);
-
-		GrammarAST OR70_tree=null;
-		RewriteRuleITokenStream stream_OR=new RewriteRuleITokenStream(adaptor,"token OR");
-		RewriteRuleSubtreeStream stream_alternative=new RewriteRuleSubtreeStream(adaptor,"rule alternative");
-		RewriteRuleSubtreeStream stream_rewrite=new RewriteRuleSubtreeStream(adaptor,"rule rewrite");
-
-			GrammarAST blkRoot = null;
-			GrammarAST save = currentBlockAST;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:425:4: ( ( -> BLOCK[$start,\"BLOCK\"] ) (a1= alternative r1= rewrite -> $a1 ( $r1)? ) ( OR a2= alternative r2= rewrite -> $altList $a2 ( $r2)? )* -> ^( $altList EOB[\"<end-of-block>\"] ) )
-			// Grammars\\ANTLR.g3:425:4: ( -> BLOCK[$start,\"BLOCK\"] ) (a1= alternative r1= rewrite -> $a1 ( $r1)? ) ( OR a2= alternative r2= rewrite -> $altList $a2 ( $r2)? )*
-			{
-			// Grammars\\ANTLR.g3:425:4: ( -> BLOCK[$start,\"BLOCK\"] )
-			// Grammars\\ANTLR.g3:425:6:
-			{
-
-
-
-			{
-			// AST REWRITE
-			// elements:
-			// token labels:
-			// rule labels: retval
-			// token list labels:
-			// rule list labels:
-			// wildcard labels:
-			if ( state.backtracking == 0 ) {
-			retval.tree = root_0;
-			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-			root_0 = (GrammarAST)adaptor.Nil();
-			// 425:6: -> BLOCK[$start,\"BLOCK\"]
-			{
-				adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(BLOCK, ((IToken)retval.Start), "BLOCK"));
-
-			}
-
-			retval.tree = root_0;
-			}
-			}
-
-			}
-
-			if ( state.backtracking == 0 )
-			{
-
-							blkRoot = (GrammarAST)((GrammarAST)retval.Tree).GetChild(0);
-							blkRoot.BlockOptions = opts;
-							currentBlockAST = blkRoot;
-
-			}
-			// Grammars\\ANTLR.g3:431:3: (a1= alternative r1= rewrite -> $a1 ( $r1)? )
-			// Grammars\\ANTLR.g3:431:5: a1= alternative r1= rewrite
-			{
-			PushFollow(Follow._alternative_in_altList1541);
-			a1=alternative();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_alternative.Add(a1.Tree);
-			PushFollow(Follow._rewrite_in_altList1545);
-			r1=rewrite();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_rewrite.Add(r1.Tree);
-			if ( state.backtracking == 0 )
-			{
-				if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR)) PrefixWithSynPred((a1!=null?((GrammarAST)a1.Tree):null));
-			}
-
-
-			{
-			// AST REWRITE
-			// elements: a1, r1
-			// token labels:
-			// rule labels: a1, r1, retval
-			// token list labels:
-			// rule list labels:
-			// wildcard labels:
-			if ( state.backtracking == 0 ) {
-			retval.tree = root_0;
-			RewriteRuleSubtreeStream stream_a1=new RewriteRuleSubtreeStream(adaptor,"rule a1",a1!=null?a1.tree:null);
-			RewriteRuleSubtreeStream stream_r1=new RewriteRuleSubtreeStream(adaptor,"rule r1",r1!=null?r1.tree:null);
-			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-			root_0 = (GrammarAST)adaptor.Nil();
-			// 433:4: -> $a1 ( $r1)?
-			{
-				adaptor.AddChild(root_0, stream_a1.NextTree());
-				// Grammars\\ANTLR.g3:433:12: ( $r1)?
-				if ( stream_r1.HasNext )
-				{
-					adaptor.AddChild(root_0, stream_r1.NextTree());
-
-				}
-				stream_r1.Reset();
-
-			}
-
-			retval.tree = root_0;
-			}
-			}
-
-			}
-
-			// Grammars\\ANTLR.g3:435:3: ( OR a2= alternative r2= rewrite -> $altList $a2 ( $r2)? )*
-			for ( ; ; )
-			{
-				int alt38=2;
-				int LA38_0 = input.LA(1);
-
-				if ( (LA38_0==OR) )
-				{
-					alt38=1;
-				}
-
-
-				switch ( alt38 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:435:5: OR a2= alternative r2= rewrite
-					{
-					OR70=(IToken)Match(input,OR,Follow._OR_in_altList1572); if (state.failed) return retval;
-					if ( state.backtracking == 0 ) stream_OR.Add(OR70);
-
-					PushFollow(Follow._alternative_in_altList1576);
-					a2=alternative();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) stream_alternative.Add(a2.Tree);
-					PushFollow(Follow._rewrite_in_altList1580);
-					r2=rewrite();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) stream_rewrite.Add(r2.Tree);
-					if ( state.backtracking == 0 )
-					{
-						if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR)) PrefixWithSynPred((a2!=null?((GrammarAST)a2.Tree):null));
-					}
-
-
-					{
-					// AST REWRITE
-					// elements: altList, a2, r2
-					// token labels:
-					// rule labels: a2, r2, retval
-					// token list labels:
-					// rule list labels:
-					// wildcard labels:
-					if ( state.backtracking == 0 ) {
-					retval.tree = root_0;
-					RewriteRuleSubtreeStream stream_a2=new RewriteRuleSubtreeStream(adaptor,"rule a2",a2!=null?a2.tree:null);
-					RewriteRuleSubtreeStream stream_r2=new RewriteRuleSubtreeStream(adaptor,"rule r2",r2!=null?r2.tree:null);
-					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-					root_0 = (GrammarAST)adaptor.Nil();
-					// 437:4: -> $altList $a2 ( $r2)?
-					{
-						adaptor.AddChild(root_0, stream_retval.NextTree());
-						adaptor.AddChild(root_0, stream_a2.NextTree());
-						// Grammars\\ANTLR.g3:437:21: ( $r2)?
-						if ( stream_r2.HasNext )
-						{
-							adaptor.AddChild(root_0, stream_r2.NextTree());
-
-						}
-						stream_r2.Reset();
-
-					}
-
-					retval.tree = root_0;
-					}
-					}
-
-					}
-					break;
-
-				default:
-					goto loop38;
-				}
-			}
-
-			loop38:
-				;
-
-
-
-
-			{
-			// AST REWRITE
-			// elements: altList
-			// token labels:
-			// rule labels: retval
-			// token list labels:
-			// rule list labels:
-			// wildcard labels:
-			if ( state.backtracking == 0 ) {
-			retval.tree = root_0;
-			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-			root_0 = (GrammarAST)adaptor.Nil();
-			// 439:3: -> ^( $altList EOB[\"<end-of-block>\"] )
-			{
-				// Grammars\\ANTLR.g3:439:6: ^( $altList EOB[\"<end-of-block>\"] )
-				{
-				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-				root_1 = (GrammarAST)adaptor.BecomeRoot(blkRoot, root_1);
-
-				adaptor.AddChild(root_1, stream_retval.NextTree());
-				adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EOB, "<end-of-block>"));
-
-				adaptor.AddChild(root_0, root_1);
-				}
-
-			}
-
-			retval.tree = root_0;
-			}
-			}
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-			 currentBlockAST = save;
-		}
-		return retval;
-	}
-	// $ANTLR end "altList"
-
-	public class alternative_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "alternative"
-	// Grammars\\ANTLR.g3:443:0: alternative : ( ( element )+ -> ^( ALT[$start,\"ALT\"] ( element )+ EOA[\"<end-of-alt>\"] ) | -> ^( ALT[$start,\"ALT\"] EPSILON[$start,\"epsilon\"] EOA[\"<end-of-alt>\"] ) );
-	private ANTLRParser.alternative_return alternative(  )
-	{
-		ANTLRParser.alternative_return retval = new ANTLRParser.alternative_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		ANTLRParser.element_return element71 = default(ANTLRParser.element_return);
-
-		RewriteRuleSubtreeStream stream_element=new RewriteRuleSubtreeStream(adaptor,"rule element");
-		try
-		{
-			// Grammars\\ANTLR.g3:444:4: ( ( element )+ -> ^( ALT[$start,\"ALT\"] ( element )+ EOA[\"<end-of-alt>\"] ) | -> ^( ALT[$start,\"ALT\"] EPSILON[$start,\"epsilon\"] EOA[\"<end-of-alt>\"] ) )
-			int alt40=2;
-			int LA40_0 = input.LA(1);
-
-			if ( (LA40_0==ACTION||LA40_0==CHAR_LITERAL||LA40_0==FORCED_ACTION||LA40_0==LPAREN||LA40_0==NOT||LA40_0==RULE_REF||LA40_0==SEMPRED||LA40_0==STRING_LITERAL||LA40_0==TOKEN_REF||LA40_0==TREE_BEGIN||LA40_0==WILDCARD) )
-			{
-				alt40=1;
-			}
-			else if ( (LA40_0==OR||LA40_0==REWRITE||LA40_0==RPAREN||LA40_0==SEMI) )
-			{
-				alt40=2;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return retval;}
-				NoViableAltException nvae = new NoViableAltException("", 40, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt40 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:444:4: ( element )+
-				{
-				// Grammars\\ANTLR.g3:444:4: ( element )+
-				int cnt39=0;
-				for ( ; ; )
-				{
-					int alt39=2;
-					int LA39_0 = input.LA(1);
-
-					if ( (LA39_0==ACTION||LA39_0==CHAR_LITERAL||LA39_0==FORCED_ACTION||LA39_0==LPAREN||LA39_0==NOT||LA39_0==RULE_REF||LA39_0==SEMPRED||LA39_0==STRING_LITERAL||LA39_0==TOKEN_REF||LA39_0==TREE_BEGIN||LA39_0==WILDCARD) )
-					{
-						alt39=1;
-					}
-
-
-					switch ( alt39 )
-					{
-					case 1:
-						// Grammars\\ANTLR.g3:444:0: element
-						{
-						PushFollow(Follow._element_in_alternative1634);
-						element71=element();
-
-						state._fsp--;
-						if (state.failed) return retval;
-						if ( state.backtracking == 0 ) stream_element.Add(element71.Tree);
-
-						}
-						break;
-
-					default:
-						if ( cnt39 >= 1 )
-							goto loop39;
-
-						if (state.backtracking>0) {state.failed=true; return retval;}
-						EarlyExitException eee39 = new EarlyExitException( 39, input );
-						throw eee39;
-					}
-					cnt39++;
-				}
-				loop39:
-					;
-
-
-
-
-				{
-				// AST REWRITE
-				// elements: element
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 445:3: -> ^( ALT[$start,\"ALT\"] ( element )+ EOA[\"<end-of-alt>\"] )
-				{
-					// Grammars\\ANTLR.g3:445:6: ^( ALT[$start,\"ALT\"] ( element )+ EOA[\"<end-of-alt>\"] )
-					{
-					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(ALT, ((IToken)retval.Start), "ALT"), root_1);
-
-					if ( !(stream_element.HasNext) )
-					{
-						throw new RewriteEarlyExitException();
-					}
-					while ( stream_element.HasNext )
-					{
-						adaptor.AddChild(root_1, stream_element.NextTree());
-
-					}
-					stream_element.Reset();
-					adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EOA, "<end-of-alt>"));
-
-					adaptor.AddChild(root_0, root_1);
-					}
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:447:3:
-				{
-
-
-
-				{
-				// AST REWRITE
-				// elements:
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 447:3: -> ^( ALT[$start,\"ALT\"] EPSILON[$start,\"epsilon\"] EOA[\"<end-of-alt>\"] )
-				{
-					// Grammars\\ANTLR.g3:447:6: ^( ALT[$start,\"ALT\"] EPSILON[$start,\"epsilon\"] EOA[\"<end-of-alt>\"] )
-					{
-					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(ALT, ((IToken)retval.Start), "ALT"), root_1);
-
-					adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EPSILON, ((IToken)retval.Start), "epsilon"));
-					adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EOA, "<end-of-alt>"));
-
-					adaptor.AddChild(root_0, root_1);
-					}
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-
-			}
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "alternative"
-
-	public class exceptionGroup_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "exceptionGroup"
-	// Grammars\\ANTLR.g3:450:0: exceptionGroup : ( ( exceptionHandler )+ ( finallyClause )? | finallyClause );
-	private ANTLRParser.exceptionGroup_return exceptionGroup(  )
-	{
-		ANTLRParser.exceptionGroup_return retval = new ANTLRParser.exceptionGroup_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		ANTLRParser.exceptionHandler_return exceptionHandler72 = default(ANTLRParser.exceptionHandler_return);
-		ANTLRParser.finallyClause_return finallyClause73 = default(ANTLRParser.finallyClause_return);
-		ANTLRParser.finallyClause_return finallyClause74 = default(ANTLRParser.finallyClause_return);
-
-
-		try
-		{
-			// Grammars\\ANTLR.g3:451:4: ( ( exceptionHandler )+ ( finallyClause )? | finallyClause )
-			int alt43=2;
-			int LA43_0 = input.LA(1);
-
-			if ( (LA43_0==CATCH) )
-			{
-				alt43=1;
-			}
-			else if ( (LA43_0==FINALLY) )
-			{
-				alt43=2;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return retval;}
-				NoViableAltException nvae = new NoViableAltException("", 43, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt43 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:451:4: ( exceptionHandler )+ ( finallyClause )?
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				// Grammars\\ANTLR.g3:451:4: ( exceptionHandler )+
-				int cnt41=0;
-				for ( ; ; )
-				{
-					int alt41=2;
-					int LA41_0 = input.LA(1);
-
-					if ( (LA41_0==CATCH) )
-					{
-						alt41=1;
-					}
-
-
-					switch ( alt41 )
-					{
-					case 1:
-						// Grammars\\ANTLR.g3:451:0: exceptionHandler
-						{
-						PushFollow(Follow._exceptionHandler_in_exceptionGroup1680);
-						exceptionHandler72=exceptionHandler();
-
-						state._fsp--;
-						if (state.failed) return retval;
-						if ( state.backtracking == 0 ) adaptor.AddChild(root_0, exceptionHandler72.Tree);
-
-						}
-						break;
-
-					default:
-						if ( cnt41 >= 1 )
-							goto loop41;
-
-						if (state.backtracking>0) {state.failed=true; return retval;}
-						EarlyExitException eee41 = new EarlyExitException( 41, input );
-						throw eee41;
-					}
-					cnt41++;
-				}
-				loop41:
-					;
-
-
-				// Grammars\\ANTLR.g3:451:22: ( finallyClause )?
-				int alt42=2;
-				int LA42_0 = input.LA(1);
-
-				if ( (LA42_0==FINALLY) )
-				{
-					alt42=1;
-				}
-				switch ( alt42 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:451:0: finallyClause
-					{
-					PushFollow(Follow._finallyClause_in_exceptionGroup1683);
-					finallyClause73=finallyClause();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, finallyClause73.Tree);
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:452:4: finallyClause
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				PushFollow(Follow._finallyClause_in_exceptionGroup1689);
-				finallyClause74=finallyClause();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, finallyClause74.Tree);
-
-				}
-				break;
-
-			}
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "exceptionGroup"
-
-	public class exceptionHandler_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "exceptionHandler"
-	// Grammars\\ANTLR.g3:455:0: exceptionHandler : 'catch' ARG_ACTION ACTION ;
-	private ANTLRParser.exceptionHandler_return exceptionHandler(  )
-	{
-		ANTLRParser.exceptionHandler_return retval = new ANTLRParser.exceptionHandler_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken string_literal75=null;
-		IToken ARG_ACTION76=null;
-		IToken ACTION77=null;
-
-		GrammarAST string_literal75_tree=null;
-		GrammarAST ARG_ACTION76_tree=null;
-		GrammarAST ACTION77_tree=null;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:456:4: ( 'catch' ARG_ACTION ACTION )
-			// Grammars\\ANTLR.g3:456:4: 'catch' ARG_ACTION ACTION
-			{
-			root_0 = (GrammarAST)adaptor.Nil();
-
-			string_literal75=(IToken)Match(input,CATCH,Follow._CATCH_in_exceptionHandler1700); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) {
-			string_literal75_tree = (GrammarAST)adaptor.Create(string_literal75);
-			root_0 = (GrammarAST)adaptor.BecomeRoot(string_literal75_tree, root_0);
-			}
-			ARG_ACTION76=(IToken)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_exceptionHandler1703); if (state.failed) return retval;
-			if ( state.backtracking==0 ) {
-			ARG_ACTION76_tree = (GrammarAST)adaptor.Create(ARG_ACTION76);
-			adaptor.AddChild(root_0, ARG_ACTION76_tree);
-			}
-			ACTION77=(IToken)Match(input,ACTION,Follow._ACTION_in_exceptionHandler1705); if (state.failed) return retval;
-			if ( state.backtracking==0 ) {
-			ACTION77_tree = (GrammarAST)adaptor.Create(ACTION77);
-			adaptor.AddChild(root_0, ACTION77_tree);
-			}
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "exceptionHandler"
-
-	public class finallyClause_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "finallyClause"
-	// Grammars\\ANTLR.g3:459:0: finallyClause : 'finally' ACTION ;
-	private ANTLRParser.finallyClause_return finallyClause(  )
-	{
-		ANTLRParser.finallyClause_return retval = new ANTLRParser.finallyClause_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken string_literal78=null;
-		IToken ACTION79=null;
-
-		GrammarAST string_literal78_tree=null;
-		GrammarAST ACTION79_tree=null;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:460:4: ( 'finally' ACTION )
-			// Grammars\\ANTLR.g3:460:4: 'finally' ACTION
-			{
-			root_0 = (GrammarAST)adaptor.Nil();
-
-			string_literal78=(IToken)Match(input,FINALLY,Follow._FINALLY_in_finallyClause1716); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) {
-			string_literal78_tree = (GrammarAST)adaptor.Create(string_literal78);
-			root_0 = (GrammarAST)adaptor.BecomeRoot(string_literal78_tree, root_0);
-			}
-			ACTION79=(IToken)Match(input,ACTION,Follow._ACTION_in_finallyClause1719); if (state.failed) return retval;
-			if ( state.backtracking==0 ) {
-			ACTION79_tree = (GrammarAST)adaptor.Create(ACTION79);
-			adaptor.AddChild(root_0, ACTION79_tree);
-			}
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "finallyClause"
-
-	public class element_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "element"
-	// Grammars\\ANTLR.g3:463:0: element : elementNoOptionSpec ;
-	private ANTLRParser.element_return element(  )
-	{
-		ANTLRParser.element_return retval = new ANTLRParser.element_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		ANTLRParser.elementNoOptionSpec_return elementNoOptionSpec80 = default(ANTLRParser.elementNoOptionSpec_return);
-
-
-		try
-		{
-			// Grammars\\ANTLR.g3:464:4: ( elementNoOptionSpec )
-			// Grammars\\ANTLR.g3:464:4: elementNoOptionSpec
-			{
-			root_0 = (GrammarAST)adaptor.Nil();
-
-			PushFollow(Follow._elementNoOptionSpec_in_element1730);
-			elementNoOptionSpec80=elementNoOptionSpec();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, elementNoOptionSpec80.Tree);
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "element"
-
-	public class elementNoOptionSpec_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "elementNoOptionSpec"
-	// Grammars\\ANTLR.g3:467:0: elementNoOptionSpec : ( ( id ( ASSIGN | PLUS_ASSIGN ) ( atom | block ) ) (sub= ebnfSuffix[root_0,false] )? |a= atom (sub2= ebnfSuffix[$a.tree,false] )? | ebnf | FORCED_ACTION | ACTION |p= SEMPRED ( IMPLIES )? |t3= tree_ ) ;
-	private ANTLRParser.elementNoOptionSpec_return elementNoOptionSpec(  )
-	{
-		ANTLRParser.elementNoOptionSpec_return retval = new ANTLRParser.elementNoOptionSpec_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken p=null;
-		IToken ASSIGN82=null;
-		IToken PLUS_ASSIGN83=null;
-		IToken FORCED_ACTION87=null;
-		IToken ACTION88=null;
-		IToken IMPLIES89=null;
-		ANTLRParser.ebnfSuffix_return sub = default(ANTLRParser.ebnfSuffix_return);
-		ANTLRParser.atom_return a = default(ANTLRParser.atom_return);
-		ANTLRParser.ebnfSuffix_return sub2 = default(ANTLRParser.ebnfSuffix_return);
-		ANTLRParser.tree__return t3 = default(ANTLRParser.tree__return);
-		ANTLRParser.id_return id81 = default(ANTLRParser.id_return);
-		ANTLRParser.atom_return atom84 = default(ANTLRParser.atom_return);
-		ANTLRParser.block_return block85 = default(ANTLRParser.block_return);
-		ANTLRParser.ebnf_return ebnf86 = default(ANTLRParser.ebnf_return);
-
-		GrammarAST p_tree=null;
-		GrammarAST ASSIGN82_tree=null;
-		GrammarAST PLUS_ASSIGN83_tree=null;
-		GrammarAST FORCED_ACTION87_tree=null;
-		GrammarAST ACTION88_tree=null;
-		GrammarAST IMPLIES89_tree=null;
-
-
-			IntSet elements=null;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:472:4: ( ( ( id ( ASSIGN | PLUS_ASSIGN ) ( atom | block ) ) (sub= ebnfSuffix[root_0,false] )? |a= atom (sub2= ebnfSuffix[$a.tree,false] )? | ebnf | FORCED_ACTION | ACTION |p= SEMPRED ( IMPLIES )? |t3= tree_ ) )
-			// Grammars\\ANTLR.g3:472:4: ( ( id ( ASSIGN | PLUS_ASSIGN ) ( atom | block ) ) (sub= ebnfSuffix[root_0,false] )? |a= atom (sub2= ebnfSuffix[$a.tree,false] )? | ebnf | FORCED_ACTION | ACTION |p= SEMPRED ( IMPLIES )? |t3= tree_ )
-			{
-			root_0 = (GrammarAST)adaptor.Nil();
-
-			// Grammars\\ANTLR.g3:472:4: ( ( id ( ASSIGN | PLUS_ASSIGN ) ( atom | block ) ) (sub= ebnfSuffix[root_0,false] )? |a= atom (sub2= ebnfSuffix[$a.tree,false] )? | ebnf | FORCED_ACTION | ACTION |p= SEMPRED ( IMPLIES )? |t3= tree_ )
-			int alt49=7;
-			alt49 = dfa49.Predict(input);
-			switch ( alt49 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:472:6: ( id ( ASSIGN | PLUS_ASSIGN ) ( atom | block ) ) (sub= ebnfSuffix[root_0,false] )?
-				{
-				// Grammars\\ANTLR.g3:472:6: ( id ( ASSIGN | PLUS_ASSIGN ) ( atom | block ) )
-				// Grammars\\ANTLR.g3:472:8: id ( ASSIGN | PLUS_ASSIGN ) ( atom | block )
-				{
-				PushFollow(Follow._id_in_elementNoOptionSpec1750);
-				id81=id();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, id81.Tree);
-				// Grammars\\ANTLR.g3:472:11: ( ASSIGN | PLUS_ASSIGN )
-				int alt44=2;
-				int LA44_0 = input.LA(1);
-
-				if ( (LA44_0==ASSIGN) )
-				{
-					alt44=1;
-				}
-				else if ( (LA44_0==PLUS_ASSIGN) )
-				{
-					alt44=2;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 44, 0, input);
-
-					throw nvae;
-				}
-				switch ( alt44 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:472:12: ASSIGN
-					{
-					ASSIGN82=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_elementNoOptionSpec1753); if (state.failed) return retval;
-					if ( state.backtracking == 0 ) {
-					ASSIGN82_tree = (GrammarAST)adaptor.Create(ASSIGN82);
-					root_0 = (GrammarAST)adaptor.BecomeRoot(ASSIGN82_tree, root_0);
-					}
-
-					}
-					break;
-				case 2:
-					// Grammars\\ANTLR.g3:472:20: PLUS_ASSIGN
-					{
-					PLUS_ASSIGN83=(IToken)Match(input,PLUS_ASSIGN,Follow._PLUS_ASSIGN_in_elementNoOptionSpec1756); if (state.failed) return retval;
-					if ( state.backtracking == 0 ) {
-					PLUS_ASSIGN83_tree = (GrammarAST)adaptor.Create(PLUS_ASSIGN83);
-					root_0 = (GrammarAST)adaptor.BecomeRoot(PLUS_ASSIGN83_tree, root_0);
-					}
-
-					}
-					break;
-
-				}
-
-				// Grammars\\ANTLR.g3:472:34: ( atom | block )
-				int alt45=2;
-				int LA45_0 = input.LA(1);
-
-				if ( (LA45_0==CHAR_LITERAL||LA45_0==NOT||LA45_0==RULE_REF||LA45_0==STRING_LITERAL||LA45_0==TOKEN_REF||LA45_0==WILDCARD) )
-				{
-					alt45=1;
-				}
-				else if ( (LA45_0==LPAREN) )
-				{
-					alt45=2;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 45, 0, input);
-
-					throw nvae;
-				}
-				switch ( alt45 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:472:35: atom
-					{
-					PushFollow(Follow._atom_in_elementNoOptionSpec1761);
-					atom84=atom();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, atom84.Tree);
-
-					}
-					break;
-				case 2:
-					// Grammars\\ANTLR.g3:472:40: block
-					{
-					PushFollow(Follow._block_in_elementNoOptionSpec1763);
-					block85=block();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, block85.Tree);
-
-					}
-					break;
-
-				}
-
-
-				}
-
-				// Grammars\\ANTLR.g3:474:4: (sub= ebnfSuffix[root_0,false] )?
-				int alt46=2;
-				int LA46_0 = input.LA(1);
-
-				if ( (LA46_0==PLUS||LA46_0==QUESTION||LA46_0==STAR) )
-				{
-					alt46=1;
-				}
-				switch ( alt46 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:474:6: sub= ebnfSuffix[root_0,false]
-					{
-					PushFollow(Follow._ebnfSuffix_in_elementNoOptionSpec1778);
-					sub=ebnfSuffix(root_0, false);
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 )
-					{
-						root_0 = (sub!=null?((GrammarAST)sub.Tree):null);
-					}
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:476:5: a= atom (sub2= ebnfSuffix[$a.tree,false] )?
-				{
-				PushFollow(Follow._atom_in_elementNoOptionSpec1796);
-				a=atom();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, a.Tree);
-				// Grammars\\ANTLR.g3:477:4: (sub2= ebnfSuffix[$a.tree,false] )?
-				int alt47=2;
-				int LA47_0 = input.LA(1);
-
-				if ( (LA47_0==PLUS||LA47_0==QUESTION||LA47_0==STAR) )
-				{
-					alt47=1;
-				}
-				switch ( alt47 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:477:6: sub2= ebnfSuffix[$a.tree,false]
-					{
-					PushFollow(Follow._ebnfSuffix_in_elementNoOptionSpec1805);
-					sub2=ebnfSuffix((a!=null?((GrammarAST)a.Tree):null), false);
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 )
-					{
-						root_0=(sub2!=null?((GrammarAST)sub2.Tree):null);
-					}
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-			case 3:
-				// Grammars\\ANTLR.g3:479:5: ebnf
-				{
-				PushFollow(Follow._ebnf_in_elementNoOptionSpec1821);
-				ebnf86=ebnf();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, ebnf86.Tree);
-
-				}
-				break;
-			case 4:
-				// Grammars\\ANTLR.g3:480:5: FORCED_ACTION
-				{
-				FORCED_ACTION87=(IToken)Match(input,FORCED_ACTION,Follow._FORCED_ACTION_in_elementNoOptionSpec1827); if (state.failed) return retval;
-				if ( state.backtracking==0 ) {
-				FORCED_ACTION87_tree = (GrammarAST)adaptor.Create(FORCED_ACTION87);
-				adaptor.AddChild(root_0, FORCED_ACTION87_tree);
-				}
-
-				}
-				break;
-			case 5:
-				// Grammars\\ANTLR.g3:481:5: ACTION
-				{
-				ACTION88=(IToken)Match(input,ACTION,Follow._ACTION_in_elementNoOptionSpec1833); if (state.failed) return retval;
-				if ( state.backtracking==0 ) {
-				ACTION88_tree = (GrammarAST)adaptor.Create(ACTION88);
-				adaptor.AddChild(root_0, ACTION88_tree);
-				}
-
-				}
-				break;
-			case 6:
-				// Grammars\\ANTLR.g3:482:5: p= SEMPRED ( IMPLIES )?
-				{
-				p=(IToken)Match(input,SEMPRED,Follow._SEMPRED_in_elementNoOptionSpec1841); if (state.failed) return retval;
-				if ( state.backtracking==0 ) {
-				p_tree = (GrammarAST)adaptor.Create(p);
-				adaptor.AddChild(root_0, p_tree);
-				}
-				// Grammars\\ANTLR.g3:482:15: ( IMPLIES )?
-				int alt48=2;
-				int LA48_0 = input.LA(1);
-
-				if ( (LA48_0==IMPLIES) )
-				{
-					alt48=1;
-				}
-				switch ( alt48 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:482:17: IMPLIES
-					{
-					IMPLIES89=(IToken)Match(input,IMPLIES,Follow._IMPLIES_in_elementNoOptionSpec1845); if (state.failed) return retval;
-					if ( state.backtracking == 0 )
-					{
-						p.Type = GATED_SEMPRED;
-					}
-
-					}
-					break;
-
-				}
-
-				if ( state.backtracking == 0 )
-				{
-
-								Grammar.blocksWithSemPreds.Add(currentBlockAST);
-
-				}
-
-				}
-				break;
-			case 7:
-				// Grammars\\ANTLR.g3:486:5: t3= tree_
-				{
-				PushFollow(Follow._tree__in_elementNoOptionSpec1864);
-				t3=tree_();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, t3.Tree);
-
-				}
-				break;
-
-			}
-
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "elementNoOptionSpec"
-
-	public class atom_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "atom"
-	// Grammars\\ANTLR.g3:490:0: atom : ( range ( ROOT | BANG )? | (=> id w= WILDCARD ( terminal | ruleref ) | terminal | ruleref ) | notSet ( ROOT | BANG )? );
-	private ANTLRParser.atom_return atom(  )
-	{
-		ANTLRParser.atom_return retval = new ANTLRParser.atom_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken w=null;
-		IToken ROOT91=null;
-		IToken BANG92=null;
-		IToken ROOT99=null;
-		IToken BANG100=null;
-		ANTLRParser.range_return range90 = default(ANTLRParser.range_return);
-		ANTLRParser.id_return id93 = default(ANTLRParser.id_return);
-		ANTLRParser.terminal_return terminal94 = default(ANTLRParser.terminal_return);
-		ANTLRParser.ruleref_return ruleref95 = default(ANTLRParser.ruleref_return);
-		ANTLRParser.terminal_return terminal96 = default(ANTLRParser.terminal_return);
-		ANTLRParser.ruleref_return ruleref97 = default(ANTLRParser.ruleref_return);
-		ANTLRParser.notSet_return notSet98 = default(ANTLRParser.notSet_return);
-
-		GrammarAST w_tree=null;
-		GrammarAST ROOT91_tree=null;
-		GrammarAST BANG92_tree=null;
-		GrammarAST ROOT99_tree=null;
-		GrammarAST BANG100_tree=null;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:491:4: ( range ( ROOT | BANG )? | (=> id w= WILDCARD ( terminal | ruleref ) | terminal | ruleref ) | notSet ( ROOT | BANG )? )
-			int alt54=3;
-			switch ( input.LA(1) )
-			{
-			case CHAR_LITERAL:
-				{
-				int LA54_1 = input.LA(2);
-
-				if ( (LA54_1==RANGE) )
-				{
-					alt54=1;
-				}
-				else if ( (LA54_1==ACTION||LA54_1==BANG||LA54_1==CHAR_LITERAL||LA54_1==FORCED_ACTION||LA54_1==LPAREN||(LA54_1>=NOT && LA54_1<=OPEN_ELEMENT_OPTION)||LA54_1==OR||LA54_1==PLUS||LA54_1==QUESTION||(LA54_1>=REWRITE && LA54_1<=RPAREN)||LA54_1==RULE_REF||(LA54_1>=SEMI && LA54_1<=SEMPRED)||LA54_1==STAR||LA54_1==STRING_LITERAL||LA54_1==TOKEN_REF||LA54_1==TREE_BEGIN||LA54_1==WILDCARD) )
-				{
-					alt54=2;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 54, 1, input);
-
-					throw nvae;
-				}
-				}
-				break;
-			case RULE_REF:
-			case STRING_LITERAL:
-			case TOKEN_REF:
-			case WILDCARD:
-				{
-				alt54=2;
-				}
-				break;
-			case NOT:
-				{
-				alt54=3;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 54, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt54 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:491:4: range ( ROOT | BANG )?
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				PushFollow(Follow._range_in_atom1879);
-				range90=range();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, range90.Tree);
-				// Grammars\\ANTLR.g3:491:10: ( ROOT | BANG )?
-				int alt50=3;
-				int LA50_0 = input.LA(1);
-
-				if ( (LA50_0==ROOT) )
-				{
-					alt50=1;
-				}
-				else if ( (LA50_0==BANG) )
-				{
-					alt50=2;
-				}
-				switch ( alt50 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:491:11: ROOT
-					{
-					ROOT91=(IToken)Match(input,ROOT,Follow._ROOT_in_atom1882); if (state.failed) return retval;
-					if ( state.backtracking == 0 ) {
-					ROOT91_tree = (GrammarAST)adaptor.Create(ROOT91);
-					root_0 = (GrammarAST)adaptor.BecomeRoot(ROOT91_tree, root_0);
-					}
-
-					}
-					break;
-				case 2:
-					// Grammars\\ANTLR.g3:491:17: BANG
-					{
-					BANG92=(IToken)Match(input,BANG,Follow._BANG_in_atom1885); if (state.failed) return retval;
-					if ( state.backtracking == 0 ) {
-					BANG92_tree = (GrammarAST)adaptor.Create(BANG92);
-					root_0 = (GrammarAST)adaptor.BecomeRoot(BANG92_tree, root_0);
-					}
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:492:4: (=> id w= WILDCARD ( terminal | ruleref ) | terminal | ruleref )
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				// Grammars\\ANTLR.g3:492:4: (=> id w= WILDCARD ( terminal | ruleref ) | terminal | ruleref )
-				int alt52=3;
-				alt52 = dfa52.Predict(input);
-				switch ( alt52 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:495:4: => id w= WILDCARD ( terminal | ruleref )
-					{
-
-					PushFollow(Follow._id_in_atom1925);
-					id93=id();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, id93.Tree);
-					w=(IToken)Match(input,WILDCARD,Follow._WILDCARD_in_atom1929); if (state.failed) return retval;
-					if ( state.backtracking == 0 ) {
-					w_tree = (GrammarAST)adaptor.Create(w);
-					root_0 = (GrammarAST)adaptor.BecomeRoot(w_tree, root_0);
-					}
-					// Grammars\\ANTLR.g3:497:19: ( terminal | ruleref )
-					int alt51=2;
-					int LA51_0 = input.LA(1);
-
-					if ( (LA51_0==CHAR_LITERAL||LA51_0==STRING_LITERAL||LA51_0==TOKEN_REF||LA51_0==WILDCARD) )
-					{
-						alt51=1;
-					}
-					else if ( (LA51_0==RULE_REF) )
-					{
-						alt51=2;
-					}
-					else
-					{
-						if (state.backtracking>0) {state.failed=true; return retval;}
-						NoViableAltException nvae = new NoViableAltException("", 51, 0, input);
-
-						throw nvae;
-					}
-					switch ( alt51 )
-					{
-					case 1:
-						// Grammars\\ANTLR.g3:497:20: terminal
-						{
-						PushFollow(Follow._terminal_in_atom1933);
-						terminal94=terminal();
-
-						state._fsp--;
-						if (state.failed) return retval;
-						if ( state.backtracking == 0 ) adaptor.AddChild(root_0, terminal94.Tree);
-
-						}
-						break;
-					case 2:
-						// Grammars\\ANTLR.g3:497:29: ruleref
-						{
-						PushFollow(Follow._ruleref_in_atom1935);
-						ruleref95=ruleref();
-
-						state._fsp--;
-						if (state.failed) return retval;
-						if ( state.backtracking == 0 ) adaptor.AddChild(root_0, ruleref95.Tree);
-
-						}
-						break;
-
-					}
-
-					if ( state.backtracking == 0 )
-					{
-						w.Type = DOT;
-					}
-
-					}
-					break;
-				case 2:
-					// Grammars\\ANTLR.g3:498:5: terminal
-					{
-					PushFollow(Follow._terminal_in_atom1944);
-					terminal96=terminal();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, terminal96.Tree);
-
-					}
-					break;
-				case 3:
-					// Grammars\\ANTLR.g3:499:5: ruleref
-					{
-					PushFollow(Follow._ruleref_in_atom1950);
-					ruleref97=ruleref();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, ruleref97.Tree);
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-			case 3:
-				// Grammars\\ANTLR.g3:501:4: notSet ( ROOT | BANG )?
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				PushFollow(Follow._notSet_in_atom1959);
-				notSet98=notSet();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, notSet98.Tree);
-				// Grammars\\ANTLR.g3:501:11: ( ROOT | BANG )?
-				int alt53=3;
-				int LA53_0 = input.LA(1);
-
-				if ( (LA53_0==ROOT) )
-				{
-					alt53=1;
-				}
-				else if ( (LA53_0==BANG) )
-				{
-					alt53=2;
-				}
-				switch ( alt53 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:501:12: ROOT
-					{
-					ROOT99=(IToken)Match(input,ROOT,Follow._ROOT_in_atom1962); if (state.failed) return retval;
-					if ( state.backtracking == 0 ) {
-					ROOT99_tree = (GrammarAST)adaptor.Create(ROOT99);
-					root_0 = (GrammarAST)adaptor.BecomeRoot(ROOT99_tree, root_0);
-					}
-
-					}
-					break;
-				case 2:
-					// Grammars\\ANTLR.g3:501:18: BANG
-					{
-					BANG100=(IToken)Match(input,BANG,Follow._BANG_in_atom1965); if (state.failed) return retval;
-					if ( state.backtracking == 0 ) {
-					BANG100_tree = (GrammarAST)adaptor.Create(BANG100);
-					root_0 = (GrammarAST)adaptor.BecomeRoot(BANG100_tree, root_0);
-					}
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-
-			}
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "atom"
-
-	public class ruleref_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "ruleref"
-	// Grammars\\ANTLR.g3:504:0: ruleref : RULE_REF ( ARG_ACTION )? ( ROOT | BANG )? ;
-	private ANTLRParser.ruleref_return ruleref(  )
-	{
-		ANTLRParser.ruleref_return retval = new ANTLRParser.ruleref_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken RULE_REF101=null;
-		IToken ARG_ACTION102=null;
-		IToken ROOT103=null;
-		IToken BANG104=null;
-
-		GrammarAST RULE_REF101_tree=null;
-		GrammarAST ARG_ACTION102_tree=null;
-		GrammarAST ROOT103_tree=null;
-		GrammarAST BANG104_tree=null;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:505:4: ( RULE_REF ( ARG_ACTION )? ( ROOT | BANG )? )
-			// Grammars\\ANTLR.g3:505:4: RULE_REF ( ARG_ACTION )? ( ROOT | BANG )?
-			{
-			root_0 = (GrammarAST)adaptor.Nil();
-
-			RULE_REF101=(IToken)Match(input,RULE_REF,Follow._RULE_REF_in_ruleref1979); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) {
-			RULE_REF101_tree = (GrammarAST)adaptor.Create(RULE_REF101);
-			root_0 = (GrammarAST)adaptor.BecomeRoot(RULE_REF101_tree, root_0);
-			}
-			// Grammars\\ANTLR.g3:505:14: ( ARG_ACTION )?
-			int alt55=2;
-			int LA55_0 = input.LA(1);
-
-			if ( (LA55_0==ARG_ACTION) )
-			{
-				alt55=1;
-			}
-			switch ( alt55 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:505:0: ARG_ACTION
-				{
-				ARG_ACTION102=(IToken)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_ruleref1982); if (state.failed) return retval;
-				if ( state.backtracking==0 ) {
-				ARG_ACTION102_tree = (GrammarAST)adaptor.Create(ARG_ACTION102);
-				adaptor.AddChild(root_0, ARG_ACTION102_tree);
-				}
-
-				}
-				break;
-
-			}
-
-			// Grammars\\ANTLR.g3:505:26: ( ROOT | BANG )?
-			int alt56=3;
-			int LA56_0 = input.LA(1);
-
-			if ( (LA56_0==ROOT) )
-			{
-				alt56=1;
-			}
-			else if ( (LA56_0==BANG) )
-			{
-				alt56=2;
-			}
-			switch ( alt56 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:505:27: ROOT
-				{
-				ROOT103=(IToken)Match(input,ROOT,Follow._ROOT_in_ruleref1986); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) {
-				ROOT103_tree = (GrammarAST)adaptor.Create(ROOT103);
-				root_0 = (GrammarAST)adaptor.BecomeRoot(ROOT103_tree, root_0);
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:505:33: BANG
-				{
-				BANG104=(IToken)Match(input,BANG,Follow._BANG_in_ruleref1989); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) {
-				BANG104_tree = (GrammarAST)adaptor.Create(BANG104);
-				root_0 = (GrammarAST)adaptor.BecomeRoot(BANG104_tree, root_0);
-				}
-
-				}
-				break;
-
-			}
-
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "ruleref"
-
-	public class notSet_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "notSet"
-	// Grammars\\ANTLR.g3:508:0: notSet : NOT ( notTerminal | block ) ;
-	private ANTLRParser.notSet_return notSet(  )
-	{
-		ANTLRParser.notSet_return retval = new ANTLRParser.notSet_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken NOT105=null;
-		ANTLRParser.notTerminal_return notTerminal106 = default(ANTLRParser.notTerminal_return);
-		ANTLRParser.block_return block107 = default(ANTLRParser.block_return);
-
-		GrammarAST NOT105_tree=null;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:509:4: ( NOT ( notTerminal | block ) )
-			// Grammars\\ANTLR.g3:509:4: NOT ( notTerminal | block )
-			{
-			root_0 = (GrammarAST)adaptor.Nil();
-
-			NOT105=(IToken)Match(input,NOT,Follow._NOT_in_notSet2003); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) {
-			NOT105_tree = (GrammarAST)adaptor.Create(NOT105);
-			root_0 = (GrammarAST)adaptor.BecomeRoot(NOT105_tree, root_0);
-			}
-			// Grammars\\ANTLR.g3:510:3: ( notTerminal | block )
-			int alt57=2;
-			int LA57_0 = input.LA(1);
-
-			if ( (LA57_0==CHAR_LITERAL||LA57_0==STRING_LITERAL||LA57_0==TOKEN_REF) )
-			{
-				alt57=1;
-			}
-			else if ( (LA57_0==LPAREN) )
-			{
-				alt57=2;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return retval;}
-				NoViableAltException nvae = new NoViableAltException("", 57, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt57 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:510:5: notTerminal
-				{
-				PushFollow(Follow._notTerminal_in_notSet2010);
-				notTerminal106=notTerminal();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, notTerminal106.Tree);
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:511:5: block
-				{
-				PushFollow(Follow._block_in_notSet2016);
-				block107=block();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, block107.Tree);
-
-				}
-				break;
-
-			}
-
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "notSet"
-
-	public class treeRoot_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "treeRoot"
-	// Grammars\\ANTLR.g3:515:0: treeRoot : ( id ( ASSIGN | PLUS_ASSIGN ) ( atom | block ) | atom | block );
-	private ANTLRParser.treeRoot_return treeRoot(  )
-	{
-		ANTLRParser.treeRoot_return retval = new ANTLRParser.treeRoot_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken ASSIGN109=null;
-		IToken PLUS_ASSIGN110=null;
-		ANTLRParser.id_return id108 = default(ANTLRParser.id_return);
-		ANTLRParser.atom_return atom111 = default(ANTLRParser.atom_return);
-		ANTLRParser.block_return block112 = default(ANTLRParser.block_return);
-		ANTLRParser.atom_return atom113 = default(ANTLRParser.atom_return);
-		ANTLRParser.block_return block114 = default(ANTLRParser.block_return);
-
-		GrammarAST ASSIGN109_tree=null;
-		GrammarAST PLUS_ASSIGN110_tree=null;
-
-		atTreeRoot=true;
-		try
-		{
-			// Grammars\\ANTLR.g3:518:4: ( id ( ASSIGN | PLUS_ASSIGN ) ( atom | block ) | atom | block )
-			int alt60=3;
-			switch ( input.LA(1) )
-			{
-			case TOKEN_REF:
-				{
-				int LA60_1 = input.LA(2);
-
-				if ( (LA60_1==ASSIGN||LA60_1==PLUS_ASSIGN) )
-				{
-					alt60=1;
-				}
-				else if ( (LA60_1==ACTION||LA60_1==ARG_ACTION||LA60_1==BANG||LA60_1==CHAR_LITERAL||LA60_1==FORCED_ACTION||LA60_1==LPAREN||(LA60_1>=NOT && LA60_1<=OPEN_ELEMENT_OPTION)||LA60_1==ROOT||LA60_1==RULE_REF||LA60_1==SEMPRED||LA60_1==STRING_LITERAL||LA60_1==TOKEN_REF||LA60_1==TREE_BEGIN||LA60_1==WILDCARD) )
-				{
-					alt60=2;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 60, 1, input);
-
-					throw nvae;
-				}
-				}
-				break;
-			case RULE_REF:
-				{
-				int LA60_2 = input.LA(2);
-
-				if ( (LA60_2==ASSIGN||LA60_2==PLUS_ASSIGN) )
-				{
-					alt60=1;
-				}
-				else if ( (LA60_2==ACTION||LA60_2==ARG_ACTION||LA60_2==BANG||LA60_2==CHAR_LITERAL||LA60_2==FORCED_ACTION||LA60_2==LPAREN||LA60_2==NOT||LA60_2==ROOT||LA60_2==RULE_REF||LA60_2==SEMPRED||LA60_2==STRING_LITERAL||LA60_2==TOKEN_REF||LA60_2==TREE_BEGIN||LA60_2==WILDCARD) )
-				{
-					alt60=2;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 60, 2, input);
-
-					throw nvae;
-				}
-				}
-				break;
-			case CHAR_LITERAL:
-			case NOT:
-			case STRING_LITERAL:
-			case WILDCARD:
-				{
-				alt60=2;
-				}
-				break;
-			case LPAREN:
-				{
-				alt60=3;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 60, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt60 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:518:4: id ( ASSIGN | PLUS_ASSIGN ) ( atom | block )
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				PushFollow(Follow._id_in_treeRoot2039);
-				id108=id();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, id108.Tree);
-				// Grammars\\ANTLR.g3:518:7: ( ASSIGN | PLUS_ASSIGN )
-				int alt58=2;
-				int LA58_0 = input.LA(1);
-
-				if ( (LA58_0==ASSIGN) )
-				{
-					alt58=1;
-				}
-				else if ( (LA58_0==PLUS_ASSIGN) )
-				{
-					alt58=2;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 58, 0, input);
-
-					throw nvae;
-				}
-				switch ( alt58 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:518:8: ASSIGN
-					{
-					ASSIGN109=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_treeRoot2042); if (state.failed) return retval;
-					if ( state.backtracking == 0 ) {
-					ASSIGN109_tree = (GrammarAST)adaptor.Create(ASSIGN109);
-					root_0 = (GrammarAST)adaptor.BecomeRoot(ASSIGN109_tree, root_0);
-					}
-
-					}
-					break;
-				case 2:
-					// Grammars\\ANTLR.g3:518:16: PLUS_ASSIGN
-					{
-					PLUS_ASSIGN110=(IToken)Match(input,PLUS_ASSIGN,Follow._PLUS_ASSIGN_in_treeRoot2045); if (state.failed) return retval;
-					if ( state.backtracking == 0 ) {
-					PLUS_ASSIGN110_tree = (GrammarAST)adaptor.Create(PLUS_ASSIGN110);
-					root_0 = (GrammarAST)adaptor.BecomeRoot(PLUS_ASSIGN110_tree, root_0);
-					}
-
-					}
-					break;
-
-				}
-
-				// Grammars\\ANTLR.g3:518:30: ( atom | block )
-				int alt59=2;
-				int LA59_0 = input.LA(1);
-
-				if ( (LA59_0==CHAR_LITERAL||LA59_0==NOT||LA59_0==RULE_REF||LA59_0==STRING_LITERAL||LA59_0==TOKEN_REF||LA59_0==WILDCARD) )
-				{
-					alt59=1;
-				}
-				else if ( (LA59_0==LPAREN) )
-				{
-					alt59=2;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 59, 0, input);
-
-					throw nvae;
-				}
-				switch ( alt59 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:518:31: atom
-					{
-					PushFollow(Follow._atom_in_treeRoot2050);
-					atom111=atom();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, atom111.Tree);
-
-					}
-					break;
-				case 2:
-					// Grammars\\ANTLR.g3:518:36: block
-					{
-					PushFollow(Follow._block_in_treeRoot2052);
-					block112=block();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, block112.Tree);
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:519:4: atom
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				PushFollow(Follow._atom_in_treeRoot2058);
-				atom113=atom();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, atom113.Tree);
-
-				}
-				break;
-			case 3:
-				// Grammars\\ANTLR.g3:520:4: block
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				PushFollow(Follow._block_in_treeRoot2063);
-				block114=block();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, block114.Tree);
-
-				}
-				break;
-
-			}
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-			if ( state.backtracking == 0 )
-			{
-				atTreeRoot=false;
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "treeRoot"
-
-	public class tree__return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "tree_"
-	// Grammars\\ANTLR.g3:523:0: tree_ : TREE_BEGIN treeRoot ( element )+ RPAREN ;
-	private ANTLRParser.tree__return tree_(  )
-	{
-		ANTLRParser.tree__return retval = new ANTLRParser.tree__return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken TREE_BEGIN115=null;
-		IToken RPAREN118=null;
-		ANTLRParser.treeRoot_return treeRoot116 = default(ANTLRParser.treeRoot_return);
-		ANTLRParser.element_return element117 = default(ANTLRParser.element_return);
-
-		GrammarAST TREE_BEGIN115_tree=null;
-		GrammarAST RPAREN118_tree=null;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:524:4: ( TREE_BEGIN treeRoot ( element )+ RPAREN )
-			// Grammars\\ANTLR.g3:524:4: TREE_BEGIN treeRoot ( element )+ RPAREN
-			{
-			root_0 = (GrammarAST)adaptor.Nil();
-
-			TREE_BEGIN115=(IToken)Match(input,TREE_BEGIN,Follow._TREE_BEGIN_in_tree_2074); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) {
-			TREE_BEGIN115_tree = (GrammarAST)adaptor.Create(TREE_BEGIN115);
-			root_0 = (GrammarAST)adaptor.BecomeRoot(TREE_BEGIN115_tree, root_0);
-			}
-			PushFollow(Follow._treeRoot_in_tree_2079);
-			treeRoot116=treeRoot();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, treeRoot116.Tree);
-			// Grammars\\ANTLR.g3:525:12: ( element )+
-			int cnt61=0;
-			for ( ; ; )
-			{
-				int alt61=2;
-				int LA61_0 = input.LA(1);
-
-				if ( (LA61_0==ACTION||LA61_0==CHAR_LITERAL||LA61_0==FORCED_ACTION||LA61_0==LPAREN||LA61_0==NOT||LA61_0==RULE_REF||LA61_0==SEMPRED||LA61_0==STRING_LITERAL||LA61_0==TOKEN_REF||LA61_0==TREE_BEGIN||LA61_0==WILDCARD) )
-				{
-					alt61=1;
-				}
-
-
-				switch ( alt61 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:525:0: element
-					{
-					PushFollow(Follow._element_in_tree_2081);
-					element117=element();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, element117.Tree);
-
-					}
-					break;
-
-				default:
-					if ( cnt61 >= 1 )
-						goto loop61;
-
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					EarlyExitException eee61 = new EarlyExitException( 61, input );
-					throw eee61;
-				}
-				cnt61++;
-			}
-			loop61:
-				;
-
-
-			RPAREN118=(IToken)Match(input,RPAREN,Follow._RPAREN_in_tree_2086); if (state.failed) return retval;
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "tree_"
-
-	public class ebnf_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "ebnf"
-	// Grammars\\ANTLR.g3:530:0: ebnf : block ( QUESTION -> ^( OPTIONAL[$start,\"?\"] block ) | STAR -> ^( CLOSURE[$start,\"*\"] block ) | PLUS -> ^( POSITIVE_CLOSURE[$start,\"+\"] block ) | IMPLIES -> {GrammarType == GrammarType.Combined && char.IsUpper(currentRuleName[0])}? ^( SYNPRED[$start,\"=>\"] block ) ->| ROOT -> ^( ROOT block ) | BANG -> ^( BANG block ) | -> block ) ;
-	private ANTLRParser.ebnf_return ebnf(  )
-	{
-		ANTLRParser.ebnf_return retval = new ANTLRParser.ebnf_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken QUESTION120=null;
-		IToken STAR121=null;
-		IToken PLUS122=null;
-		IToken IMPLIES123=null;
-		IToken ROOT124=null;
-		IToken BANG125=null;
-		ANTLRParser.block_return block119 = default(ANTLRParser.block_return);
-
-		GrammarAST QUESTION120_tree=null;
-		GrammarAST STAR121_tree=null;
-		GrammarAST PLUS122_tree=null;
-		GrammarAST IMPLIES123_tree=null;
-		GrammarAST ROOT124_tree=null;
-		GrammarAST BANG125_tree=null;
-		RewriteRuleITokenStream stream_QUESTION=new RewriteRuleITokenStream(adaptor,"token QUESTION");
-		RewriteRuleITokenStream stream_STAR=new RewriteRuleITokenStream(adaptor,"token STAR");
-		RewriteRuleITokenStream stream_PLUS=new RewriteRuleITokenStream(adaptor,"token PLUS");
-		RewriteRuleITokenStream stream_IMPLIES=new RewriteRuleITokenStream(adaptor,"token IMPLIES");
-		RewriteRuleITokenStream stream_ROOT=new RewriteRuleITokenStream(adaptor,"token ROOT");
-		RewriteRuleITokenStream stream_BANG=new RewriteRuleITokenStream(adaptor,"token BANG");
-		RewriteRuleSubtreeStream stream_block=new RewriteRuleSubtreeStream(adaptor,"rule block");
-		try
-		{
-			// Grammars\\ANTLR.g3:531:4: ( block ( QUESTION -> ^( OPTIONAL[$start,\"?\"] block ) | STAR -> ^( CLOSURE[$start,\"*\"] block ) | PLUS -> ^( POSITIVE_CLOSURE[$start,\"+\"] block ) | IMPLIES -> {GrammarType == GrammarType.Combined && char.IsUpper(currentRuleName[0])}? ^( SYNPRED[$start,\"=>\"] block ) ->| ROOT -> ^( ROOT block ) | BANG -> ^( BANG block ) | -> block ) )
-			// Grammars\\ANTLR.g3:531:4: block ( QUESTION -> ^( OPTIONAL[$start,\"?\"] block ) | STAR -> ^( CLOSURE[$start,\"*\"] block ) | PLUS -> ^( POSITIVE_CLOSURE[$start,\"+\"] block ) | IMPLIES -> {GrammarType == GrammarType.Combined && char.IsUpper(currentRuleName[0])}? ^( SYNPRED[$start,\"=>\"] block ) ->| ROOT -> ^( ROOT block ) | BANG -> ^( BANG block ) | -> block )
-			{
-			PushFollow(Follow._block_in_ebnf2100);
-			block119=block();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_block.Add(block119.Tree);
-			// Grammars\\ANTLR.g3:532:3: ( QUESTION -> ^( OPTIONAL[$start,\"?\"] block ) | STAR -> ^( CLOSURE[$start,\"*\"] block ) | PLUS -> ^( POSITIVE_CLOSURE[$start,\"+\"] block ) | IMPLIES -> {GrammarType == GrammarType.Combined && char.IsUpper(currentRuleName[0])}? ^( SYNPRED[$start,\"=>\"] block ) ->| ROOT -> ^( ROOT block ) | BANG -> ^( BANG block ) | -> block )
-			int alt62=7;
-			switch ( input.LA(1) )
-			{
-			case QUESTION:
-				{
-				alt62=1;
-				}
-				break;
-			case STAR:
-				{
-				alt62=2;
-				}
-				break;
-			case PLUS:
-				{
-				alt62=3;
-				}
-				break;
-			case IMPLIES:
-				{
-				alt62=4;
-				}
-				break;
-			case ROOT:
-				{
-				alt62=5;
-				}
-				break;
-			case BANG:
-				{
-				alt62=6;
-				}
-				break;
-			case ACTION:
-			case CHAR_LITERAL:
-			case FORCED_ACTION:
-			case LPAREN:
-			case NOT:
-			case OR:
-			case REWRITE:
-			case RPAREN:
-			case RULE_REF:
-			case SEMI:
-			case SEMPRED:
-			case STRING_LITERAL:
-			case TOKEN_REF:
-			case TREE_BEGIN:
-			case WILDCARD:
-				{
-				alt62=7;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 62, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt62 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:532:5: QUESTION
-				{
-				QUESTION120=(IToken)Match(input,QUESTION,Follow._QUESTION_in_ebnf2106); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_QUESTION.Add(QUESTION120);
-
-
-
-				{
-				// AST REWRITE
-				// elements: block
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 533:4: -> ^( OPTIONAL[$start,\"?\"] block )
-				{
-					// Grammars\\ANTLR.g3:533:7: ^( OPTIONAL[$start,\"?\"] block )
-					{
-					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(OPTIONAL, ((IToken)retval.Start), "?"), root_1);
-
-					adaptor.AddChild(root_1, stream_block.NextTree());
-
-					adaptor.AddChild(root_0, root_1);
-					}
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:534:5: STAR
-				{
-				STAR121=(IToken)Match(input,STAR,Follow._STAR_in_ebnf2124); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_STAR.Add(STAR121);
-
-
-
-				{
-				// AST REWRITE
-				// elements: block
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 535:4: -> ^( CLOSURE[$start,\"*\"] block )
-				{
-					// Grammars\\ANTLR.g3:535:7: ^( CLOSURE[$start,\"*\"] block )
-					{
-					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(CLOSURE, ((IToken)retval.Start), "*"), root_1);
-
-					adaptor.AddChild(root_1, stream_block.NextTree());
-
-					adaptor.AddChild(root_0, root_1);
-					}
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-			case 3:
-				// Grammars\\ANTLR.g3:536:5: PLUS
-				{
-				PLUS122=(IToken)Match(input,PLUS,Follow._PLUS_in_ebnf2142); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_PLUS.Add(PLUS122);
-
-
-
-				{
-				// AST REWRITE
-				// elements: block
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 537:4: -> ^( POSITIVE_CLOSURE[$start,\"+\"] block )
-				{
-					// Grammars\\ANTLR.g3:537:7: ^( POSITIVE_CLOSURE[$start,\"+\"] block )
-					{
-					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(POSITIVE_CLOSURE, ((IToken)retval.Start), "+"), root_1);
-
-					adaptor.AddChild(root_1, stream_block.NextTree());
-
-					adaptor.AddChild(root_0, root_1);
-					}
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-			case 4:
-				// Grammars\\ANTLR.g3:538:5: IMPLIES
-				{
-				IMPLIES123=(IToken)Match(input,IMPLIES,Follow._IMPLIES_in_ebnf2160); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_IMPLIES.Add(IMPLIES123);
-
-
-
-				{
-				// AST REWRITE
-				// elements: block
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 540:4: -> {GrammarType == GrammarType.Combined && char.IsUpper(currentRuleName[0])}? ^( SYNPRED[$start,\"=>\"] block )
-				if (GrammarType == GrammarType.Combined && char.IsUpper(currentRuleName[0]))
-				{
-					// Grammars\\ANTLR.g3:540:82: ^( SYNPRED[$start,\"=>\"] block )
-					{
-					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(SYNPRED, ((IToken)retval.Start), "=>"), root_1);
-
-					adaptor.AddChild(root_1, stream_block.NextTree());
-
-					adaptor.AddChild(root_0, root_1);
-					}
-
-				}
-				else // 542:4: ->
-				{
-					adaptor.AddChild(root_0, CreateSynSemPredFromBlock((block119!=null?((GrammarAST)block119.Tree):null), SYN_SEMPRED));
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-			case 5:
-				// Grammars\\ANTLR.g3:543:5: ROOT
-				{
-				ROOT124=(IToken)Match(input,ROOT,Follow._ROOT_in_ebnf2196); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_ROOT.Add(ROOT124);
-
-
-
-				{
-				// AST REWRITE
-				// elements: ROOT, block
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 544:4: -> ^( ROOT block )
-				{
-					// Grammars\\ANTLR.g3:544:7: ^( ROOT block )
-					{
-					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-					root_1 = (GrammarAST)adaptor.BecomeRoot(stream_ROOT.NextNode(), root_1);
-
-					adaptor.AddChild(root_1, stream_block.NextTree());
-
-					adaptor.AddChild(root_0, root_1);
-					}
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-			case 6:
-				// Grammars\\ANTLR.g3:545:5: BANG
-				{
-				BANG125=(IToken)Match(input,BANG,Follow._BANG_in_ebnf2213); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_BANG.Add(BANG125);
-
-
-
-				{
-				// AST REWRITE
-				// elements: BANG, block
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 546:4: -> ^( BANG block )
-				{
-					// Grammars\\ANTLR.g3:546:7: ^( BANG block )
-					{
-					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-					root_1 = (GrammarAST)adaptor.BecomeRoot(stream_BANG.NextNode(), root_1);
-
-					adaptor.AddChild(root_1, stream_block.NextTree());
-
-					adaptor.AddChild(root_0, root_1);
-					}
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-			case 7:
-				// Grammars\\ANTLR.g3:548:4:
-				{
-
-
-
-				{
-				// AST REWRITE
-				// elements: block
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 548:4: -> block
-				{
-					adaptor.AddChild(root_0, stream_block.NextTree());
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-
-			}
-
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "ebnf"
-
-	public class range_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "range"
-	// Grammars\\ANTLR.g3:552:0: range : c1= CHAR_LITERAL RANGE c2= CHAR_LITERAL -> ^( CHAR_RANGE[$c1,\"..\"] $c1 $c2) ;
-	private ANTLRParser.range_return range(  )
-	{
-		ANTLRParser.range_return retval = new ANTLRParser.range_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken c1=null;
-		IToken c2=null;
-		IToken RANGE126=null;
-
-		GrammarAST c1_tree=null;
-		GrammarAST c2_tree=null;
-		GrammarAST RANGE126_tree=null;
-		RewriteRuleITokenStream stream_CHAR_LITERAL=new RewriteRuleITokenStream(adaptor,"token CHAR_LITERAL");
-		RewriteRuleITokenStream stream_RANGE=new RewriteRuleITokenStream(adaptor,"token RANGE");
-
-		try
-		{
-			// Grammars\\ANTLR.g3:553:4: (c1= CHAR_LITERAL RANGE c2= CHAR_LITERAL -> ^( CHAR_RANGE[$c1,\"..\"] $c1 $c2) )
-			// Grammars\\ANTLR.g3:553:4: c1= CHAR_LITERAL RANGE c2= CHAR_LITERAL
-			{
-			c1=(IToken)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_range2252); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_CHAR_LITERAL.Add(c1);
-
-			RANGE126=(IToken)Match(input,RANGE,Follow._RANGE_in_range2254); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_RANGE.Add(RANGE126);
-
-			c2=(IToken)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_range2258); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_CHAR_LITERAL.Add(c2);
-
-
-
-			{
-			// AST REWRITE
-			// elements: c1, c2
-			// token labels: c1, c2
-			// rule labels: retval
-			// token list labels:
-			// rule list labels:
-			// wildcard labels:
-			if ( state.backtracking == 0 ) {
-			retval.tree = root_0;
-			RewriteRuleITokenStream stream_c1=new RewriteRuleITokenStream(adaptor,"token c1",c1);
-			RewriteRuleITokenStream stream_c2=new RewriteRuleITokenStream(adaptor,"token c2",c2);
-			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-			root_0 = (GrammarAST)adaptor.Nil();
-			// 554:3: -> ^( CHAR_RANGE[$c1,\"..\"] $c1 $c2)
-			{
-				// Grammars\\ANTLR.g3:554:6: ^( CHAR_RANGE[$c1,\"..\"] $c1 $c2)
-				{
-				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-				root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(CHAR_RANGE, c1, ".."), root_1);
-
-				adaptor.AddChild(root_1, stream_c1.NextNode());
-				adaptor.AddChild(root_1, stream_c2.NextNode());
-
-				adaptor.AddChild(root_0, root_1);
-				}
-
-			}
-
-			retval.tree = root_0;
-			}
-			}
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "range"
-
-	public class terminal_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "terminal"
-	// Grammars\\ANTLR.g3:557:0: terminal : (cl= CHAR_LITERAL ( elementOptions[$cl.tree] )? ( ROOT | BANG )? |tr= TOKEN_REF ( elementOptions[$tr.tree] )? ( ARG_ACTION )? ( ROOT | BANG )? |sl= STRING_LITERAL ( elementOptions[$sl.tree] )? ( ROOT | BANG )? |wi= WILDCARD ( ROOT | BANG )? );
-	private ANTLRParser.terminal_return terminal(  )
-	{
-		ANTLRParser.terminal_return retval = new ANTLRParser.terminal_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken cl=null;
-		IToken tr=null;
-		IToken sl=null;
-		IToken wi=null;
-		IToken ROOT128=null;
-		IToken BANG129=null;
-		IToken ARG_ACTION131=null;
-		IToken ROOT132=null;
-		IToken BANG133=null;
-		IToken ROOT135=null;
-		IToken BANG136=null;
-		IToken ROOT137=null;
-		IToken BANG138=null;
-		ANTLRParser.elementOptions_return elementOptions127 = default(ANTLRParser.elementOptions_return);
-		ANTLRParser.elementOptions_return elementOptions130 = default(ANTLRParser.elementOptions_return);
-		ANTLRParser.elementOptions_return elementOptions134 = default(ANTLRParser.elementOptions_return);
-
-		GrammarAST cl_tree=null;
-		GrammarAST tr_tree=null;
-		GrammarAST sl_tree=null;
-		GrammarAST wi_tree=null;
-		GrammarAST ROOT128_tree=null;
-		GrammarAST BANG129_tree=null;
-		GrammarAST ARG_ACTION131_tree=null;
-		GrammarAST ROOT132_tree=null;
-		GrammarAST BANG133_tree=null;
-		GrammarAST ROOT135_tree=null;
-		GrammarAST BANG136_tree=null;
-		GrammarAST ROOT137_tree=null;
-		GrammarAST BANG138_tree=null;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:558:4: (cl= CHAR_LITERAL ( elementOptions[$cl.tree] )? ( ROOT | BANG )? |tr= TOKEN_REF ( elementOptions[$tr.tree] )? ( ARG_ACTION )? ( ROOT | BANG )? |sl= STRING_LITERAL ( elementOptions[$sl.tree] )? ( ROOT | BANG )? |wi= WILDCARD ( ROOT | BANG )? )
-			int alt71=4;
-			switch ( input.LA(1) )
-			{
-			case CHAR_LITERAL:
-				{
-				alt71=1;
-				}
-				break;
-			case TOKEN_REF:
-				{
-				alt71=2;
-				}
-				break;
-			case STRING_LITERAL:
-				{
-				alt71=3;
-				}
-				break;
-			case WILDCARD:
-				{
-				alt71=4;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 71, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt71 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:558:4: cl= CHAR_LITERAL ( elementOptions[$cl.tree] )? ( ROOT | BANG )?
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				cl=(IToken)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_terminal2286); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) {
-				cl_tree = (GrammarAST)adaptor.Create(cl);
-				root_0 = (GrammarAST)adaptor.BecomeRoot(cl_tree, root_0);
-				}
-				// Grammars\\ANTLR.g3:558:21: ( elementOptions[$cl.tree] )?
-				int alt63=2;
-				int LA63_0 = input.LA(1);
-
-				if ( (LA63_0==OPEN_ELEMENT_OPTION) )
-				{
-					alt63=1;
-				}
-				switch ( alt63 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:558:23: elementOptions[$cl.tree]
-					{
-					PushFollow(Follow._elementOptions_in_terminal2291);
-					elementOptions127=elementOptions(cl_tree);
-
-					state._fsp--;
-					if (state.failed) return retval;
-
-					}
-					break;
-
-				}
-
-				// Grammars\\ANTLR.g3:558:52: ( ROOT | BANG )?
-				int alt64=3;
-				int LA64_0 = input.LA(1);
-
-				if ( (LA64_0==ROOT) )
-				{
-					alt64=1;
-				}
-				else if ( (LA64_0==BANG) )
-				{
-					alt64=2;
-				}
-				switch ( alt64 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:558:53: ROOT
-					{
-					ROOT128=(IToken)Match(input,ROOT,Follow._ROOT_in_terminal2299); if (state.failed) return retval;
-					if ( state.backtracking == 0 ) {
-					ROOT128_tree = (GrammarAST)adaptor.Create(ROOT128);
-					root_0 = (GrammarAST)adaptor.BecomeRoot(ROOT128_tree, root_0);
-					}
-
-					}
-					break;
-				case 2:
-					// Grammars\\ANTLR.g3:558:59: BANG
-					{
-					BANG129=(IToken)Match(input,BANG,Follow._BANG_in_terminal2302); if (state.failed) return retval;
-					if ( state.backtracking == 0 ) {
-					BANG129_tree = (GrammarAST)adaptor.Create(BANG129);
-					root_0 = (GrammarAST)adaptor.BecomeRoot(BANG129_tree, root_0);
-					}
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:560:4: tr= TOKEN_REF ( elementOptions[$tr.tree] )? ( ARG_ACTION )? ( ROOT | BANG )?
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				tr=(IToken)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_terminal2313); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) {
-				tr_tree = (GrammarAST)adaptor.Create(tr);
-				root_0 = (GrammarAST)adaptor.BecomeRoot(tr_tree, root_0);
-				}
-				// Grammars\\ANTLR.g3:561:3: ( elementOptions[$tr.tree] )?
-				int alt65=2;
-				int LA65_0 = input.LA(1);
-
-				if ( (LA65_0==OPEN_ELEMENT_OPTION) )
-				{
-					alt65=1;
-				}
-				switch ( alt65 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:561:5: elementOptions[$tr.tree]
-					{
-					PushFollow(Follow._elementOptions_in_terminal2320);
-					elementOptions130=elementOptions(tr_tree);
-
-					state._fsp--;
-					if (state.failed) return retval;
-
-					}
-					break;
-
-				}
-
-				// Grammars\\ANTLR.g3:562:3: ( ARG_ACTION )?
-				int alt66=2;
-				int LA66_0 = input.LA(1);
-
-				if ( (LA66_0==ARG_ACTION) )
-				{
-					alt66=1;
-				}
-				switch ( alt66 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:562:5: ARG_ACTION
-					{
-					ARG_ACTION131=(IToken)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_terminal2331); if (state.failed) return retval;
-					if ( state.backtracking==0 ) {
-					ARG_ACTION131_tree = (GrammarAST)adaptor.Create(ARG_ACTION131);
-					adaptor.AddChild(root_0, ARG_ACTION131_tree);
-					}
-
-					}
-					break;
-
-				}
-
-				// Grammars\\ANTLR.g3:563:3: ( ROOT | BANG )?
-				int alt67=3;
-				int LA67_0 = input.LA(1);
-
-				if ( (LA67_0==ROOT) )
-				{
-					alt67=1;
-				}
-				else if ( (LA67_0==BANG) )
-				{
-					alt67=2;
-				}
-				switch ( alt67 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:563:4: ROOT
-					{
-					ROOT132=(IToken)Match(input,ROOT,Follow._ROOT_in_terminal2340); if (state.failed) return retval;
-					if ( state.backtracking == 0 ) {
-					ROOT132_tree = (GrammarAST)adaptor.Create(ROOT132);
-					root_0 = (GrammarAST)adaptor.BecomeRoot(ROOT132_tree, root_0);
-					}
-
-					}
-					break;
-				case 2:
-					// Grammars\\ANTLR.g3:563:10: BANG
-					{
-					BANG133=(IToken)Match(input,BANG,Follow._BANG_in_terminal2343); if (state.failed) return retval;
-					if ( state.backtracking == 0 ) {
-					BANG133_tree = (GrammarAST)adaptor.Create(BANG133);
-					root_0 = (GrammarAST)adaptor.BecomeRoot(BANG133_tree, root_0);
-					}
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-			case 3:
-				// Grammars\\ANTLR.g3:565:4: sl= STRING_LITERAL ( elementOptions[$sl.tree] )? ( ROOT | BANG )?
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				sl=(IToken)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_terminal2354); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) {
-				sl_tree = (GrammarAST)adaptor.Create(sl);
-				root_0 = (GrammarAST)adaptor.BecomeRoot(sl_tree, root_0);
-				}
-				// Grammars\\ANTLR.g3:565:23: ( elementOptions[$sl.tree] )?
-				int alt68=2;
-				int LA68_0 = input.LA(1);
-
-				if ( (LA68_0==OPEN_ELEMENT_OPTION) )
-				{
-					alt68=1;
-				}
-				switch ( alt68 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:565:25: elementOptions[$sl.tree]
-					{
-					PushFollow(Follow._elementOptions_in_terminal2359);
-					elementOptions134=elementOptions(sl_tree);
-
-					state._fsp--;
-					if (state.failed) return retval;
-
-					}
-					break;
-
-				}
-
-				// Grammars\\ANTLR.g3:565:54: ( ROOT | BANG )?
-				int alt69=3;
-				int LA69_0 = input.LA(1);
-
-				if ( (LA69_0==ROOT) )
-				{
-					alt69=1;
-				}
-				else if ( (LA69_0==BANG) )
-				{
-					alt69=2;
-				}
-				switch ( alt69 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:565:55: ROOT
-					{
-					ROOT135=(IToken)Match(input,ROOT,Follow._ROOT_in_terminal2367); if (state.failed) return retval;
-					if ( state.backtracking == 0 ) {
-					ROOT135_tree = (GrammarAST)adaptor.Create(ROOT135);
-					root_0 = (GrammarAST)adaptor.BecomeRoot(ROOT135_tree, root_0);
-					}
-
-					}
-					break;
-				case 2:
-					// Grammars\\ANTLR.g3:565:61: BANG
-					{
-					BANG136=(IToken)Match(input,BANG,Follow._BANG_in_terminal2370); if (state.failed) return retval;
-					if ( state.backtracking == 0 ) {
-					BANG136_tree = (GrammarAST)adaptor.Create(BANG136);
-					root_0 = (GrammarAST)adaptor.BecomeRoot(BANG136_tree, root_0);
-					}
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-			case 4:
-				// Grammars\\ANTLR.g3:567:4: wi= WILDCARD ( ROOT | BANG )?
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				wi=(IToken)Match(input,WILDCARD,Follow._WILDCARD_in_terminal2381); if (state.failed) return retval;
-				if ( state.backtracking==0 ) {
-				wi_tree = (GrammarAST)adaptor.Create(wi);
-				adaptor.AddChild(root_0, wi_tree);
-				}
-				// Grammars\\ANTLR.g3:567:16: ( ROOT | BANG )?
-				int alt70=3;
-				int LA70_0 = input.LA(1);
-
-				if ( (LA70_0==ROOT) )
-				{
-					alt70=1;
-				}
-				else if ( (LA70_0==BANG) )
-				{
-					alt70=2;
-				}
-				switch ( alt70 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:567:17: ROOT
-					{
-					ROOT137=(IToken)Match(input,ROOT,Follow._ROOT_in_terminal2384); if (state.failed) return retval;
-					if ( state.backtracking == 0 ) {
-					ROOT137_tree = (GrammarAST)adaptor.Create(ROOT137);
-					root_0 = (GrammarAST)adaptor.BecomeRoot(ROOT137_tree, root_0);
-					}
-
-					}
-					break;
-				case 2:
-					// Grammars\\ANTLR.g3:567:23: BANG
-					{
-					BANG138=(IToken)Match(input,BANG,Follow._BANG_in_terminal2387); if (state.failed) return retval;
-					if ( state.backtracking == 0 ) {
-					BANG138_tree = (GrammarAST)adaptor.Create(BANG138);
-					root_0 = (GrammarAST)adaptor.BecomeRoot(BANG138_tree, root_0);
-					}
-
-					}
-					break;
-
-				}
-
-				if ( state.backtracking == 0 )
-				{
-
-								if ( atTreeRoot )
-								{
-									ErrorManager.SyntaxError(
-										ErrorManager.MSG_WILDCARD_AS_ROOT,Grammar,wi,null,null);
-								}
-
-				}
-
-				}
-				break;
-
-			}
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "terminal"
-
-	public class elementOptions_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "elementOptions"
-	// Grammars\\ANTLR.g3:577:0: elementOptions[GrammarAST terminalAST] : ( OPEN_ELEMENT_OPTION defaultNodeOption[terminalAST] CLOSE_ELEMENT_OPTION | OPEN_ELEMENT_OPTION elementOption[terminalAST] ( SEMI elementOption[terminalAST] )* CLOSE_ELEMENT_OPTION );
-	private ANTLRParser.elementOptions_return elementOptions( GrammarAST terminalAST )
-	{
-		ANTLRParser.elementOptions_return retval = new ANTLRParser.elementOptions_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken OPEN_ELEMENT_OPTION139=null;
-		IToken CLOSE_ELEMENT_OPTION141=null;
-		IToken OPEN_ELEMENT_OPTION142=null;
-		IToken SEMI144=null;
-		IToken CLOSE_ELEMENT_OPTION146=null;
-		ANTLRParser.defaultNodeOption_return defaultNodeOption140 = default(ANTLRParser.defaultNodeOption_return);
-		ANTLRParser.elementOption_return elementOption143 = default(ANTLRParser.elementOption_return);
-		ANTLRParser.elementOption_return elementOption145 = default(ANTLRParser.elementOption_return);
-
-		GrammarAST OPEN_ELEMENT_OPTION139_tree=null;
-		GrammarAST CLOSE_ELEMENT_OPTION141_tree=null;
-		GrammarAST OPEN_ELEMENT_OPTION142_tree=null;
-		GrammarAST SEMI144_tree=null;
-		GrammarAST CLOSE_ELEMENT_OPTION146_tree=null;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:578:4: ( OPEN_ELEMENT_OPTION defaultNodeOption[terminalAST] CLOSE_ELEMENT_OPTION | OPEN_ELEMENT_OPTION elementOption[terminalAST] ( SEMI elementOption[terminalAST] )* CLOSE_ELEMENT_OPTION )
-			int alt73=2;
-			int LA73_0 = input.LA(1);
-
-			if ( (LA73_0==OPEN_ELEMENT_OPTION) )
-			{
-				int LA73_1 = input.LA(2);
-
-				if ( (LA73_1==TOKEN_REF) )
-				{
-					int LA73_2 = input.LA(3);
-
-					if ( (LA73_2==CLOSE_ELEMENT_OPTION||LA73_2==WILDCARD) )
-					{
-						alt73=1;
-					}
-					else if ( (LA73_2==ASSIGN) )
-					{
-						alt73=2;
-					}
-					else
-					{
-						if (state.backtracking>0) {state.failed=true; return retval;}
-						NoViableAltException nvae = new NoViableAltException("", 73, 2, input);
-
-						throw nvae;
-					}
-				}
-				else if ( (LA73_1==RULE_REF) )
-				{
-					int LA73_3 = input.LA(3);
-
-					if ( (LA73_3==CLOSE_ELEMENT_OPTION||LA73_3==WILDCARD) )
-					{
-						alt73=1;
-					}
-					else if ( (LA73_3==ASSIGN) )
-					{
-						alt73=2;
-					}
-					else
-					{
-						if (state.backtracking>0) {state.failed=true; return retval;}
-						NoViableAltException nvae = new NoViableAltException("", 73, 3, input);
-
-						throw nvae;
-					}
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 73, 1, input);
-
-					throw nvae;
-				}
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return retval;}
-				NoViableAltException nvae = new NoViableAltException("", 73, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt73 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:578:4: OPEN_ELEMENT_OPTION defaultNodeOption[terminalAST] CLOSE_ELEMENT_OPTION
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				OPEN_ELEMENT_OPTION139=(IToken)Match(input,OPEN_ELEMENT_OPTION,Follow._OPEN_ELEMENT_OPTION_in_elementOptions2406); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) {
-				OPEN_ELEMENT_OPTION139_tree = (GrammarAST)adaptor.Create(OPEN_ELEMENT_OPTION139);
-				root_0 = (GrammarAST)adaptor.BecomeRoot(OPEN_ELEMENT_OPTION139_tree, root_0);
-				}
-				PushFollow(Follow._defaultNodeOption_in_elementOptions2409);
-				defaultNodeOption140=defaultNodeOption(terminalAST);
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, defaultNodeOption140.Tree);
-				CLOSE_ELEMENT_OPTION141=(IToken)Match(input,CLOSE_ELEMENT_OPTION,Follow._CLOSE_ELEMENT_OPTION_in_elementOptions2412); if (state.failed) return retval;
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:579:4: OPEN_ELEMENT_OPTION elementOption[terminalAST] ( SEMI elementOption[terminalAST] )* CLOSE_ELEMENT_OPTION
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				OPEN_ELEMENT_OPTION142=(IToken)Match(input,OPEN_ELEMENT_OPTION,Follow._OPEN_ELEMENT_OPTION_in_elementOptions2418); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) {
-				OPEN_ELEMENT_OPTION142_tree = (GrammarAST)adaptor.Create(OPEN_ELEMENT_OPTION142);
-				root_0 = (GrammarAST)adaptor.BecomeRoot(OPEN_ELEMENT_OPTION142_tree, root_0);
-				}
-				PushFollow(Follow._elementOption_in_elementOptions2421);
-				elementOption143=elementOption(terminalAST);
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, elementOption143.Tree);
-				// Grammars\\ANTLR.g3:579:52: ( SEMI elementOption[terminalAST] )*
-				for ( ; ; )
-				{
-					int alt72=2;
-					int LA72_0 = input.LA(1);
-
-					if ( (LA72_0==SEMI) )
-					{
-						alt72=1;
-					}
-
-
-					switch ( alt72 )
-					{
-					case 1:
-						// Grammars\\ANTLR.g3:579:53: SEMI elementOption[terminalAST]
-						{
-						SEMI144=(IToken)Match(input,SEMI,Follow._SEMI_in_elementOptions2425); if (state.failed) return retval;
-						PushFollow(Follow._elementOption_in_elementOptions2428);
-						elementOption145=elementOption(terminalAST);
-
-						state._fsp--;
-						if (state.failed) return retval;
-						if ( state.backtracking == 0 ) adaptor.AddChild(root_0, elementOption145.Tree);
-
-						}
-						break;
-
-					default:
-						goto loop72;
-					}
-				}
-
-				loop72:
-					;
-
-
-				CLOSE_ELEMENT_OPTION146=(IToken)Match(input,CLOSE_ELEMENT_OPTION,Follow._CLOSE_ELEMENT_OPTION_in_elementOptions2433); if (state.failed) return retval;
-
-				}
-				break;
-
-			}
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "elementOptions"
-
-	public class defaultNodeOption_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "defaultNodeOption"
-	// Grammars\\ANTLR.g3:582:0: defaultNodeOption[GrammarAST terminalAST] : i= id ( WILDCARD i2= id )* ;
-	private ANTLRParser.defaultNodeOption_return defaultNodeOption( GrammarAST terminalAST )
-	{
-		ANTLRParser.defaultNodeOption_return retval = new ANTLRParser.defaultNodeOption_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken WILDCARD147=null;
-		ANTLRParser.id_return i = default(ANTLRParser.id_return);
-		ANTLRParser.id_return i2 = default(ANTLRParser.id_return);
-
-		GrammarAST WILDCARD147_tree=null;
-
-
-		StringBuffer buf = new StringBuffer();
-
-		try
-		{
-			// Grammars\\ANTLR.g3:587:4: (i= id ( WILDCARD i2= id )* )
-			// Grammars\\ANTLR.g3:587:4: i= id ( WILDCARD i2= id )*
-			{
-			root_0 = (GrammarAST)adaptor.Nil();
-
-			PushFollow(Follow._id_in_defaultNodeOption2453);
-			i=id();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, i.Tree);
-			if ( state.backtracking == 0 )
-			{
-				buf.Append((i!=null?input.ToString(i.start,i.stop):null));
-			}
-			// Grammars\\ANTLR.g3:587:32: ( WILDCARD i2= id )*
-			for ( ; ; )
-			{
-				int alt74=2;
-				int LA74_0 = input.LA(1);
-
-				if ( (LA74_0==WILDCARD) )
-				{
-					alt74=1;
-				}
-
-
-				switch ( alt74 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:587:33: WILDCARD i2= id
-					{
-					WILDCARD147=(IToken)Match(input,WILDCARD,Follow._WILDCARD_in_defaultNodeOption2458); if (state.failed) return retval;
-					if ( state.backtracking==0 ) {
-					WILDCARD147_tree = (GrammarAST)adaptor.Create(WILDCARD147);
-					adaptor.AddChild(root_0, WILDCARD147_tree);
-					}
-					PushFollow(Follow._id_in_defaultNodeOption2462);
-					i2=id();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, i2.Tree);
-					if ( state.backtracking == 0 )
-					{
-						buf.Append("."+(i2!=null?input.ToString(i2.start,i2.stop):null));
-					}
-
-					}
-					break;
-
-				default:
-					goto loop74;
-				}
-			}
-
-			loop74:
-				;
-
-
-			if ( state.backtracking == 0 )
-			{
-				terminalAST.SetTerminalOption(Grammar,Grammar.defaultTokenOption,buf.ToString());
-			}
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "defaultNodeOption"
-
-	public class elementOption_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "elementOption"
-	// Grammars\\ANTLR.g3:591:0: elementOption[GrammarAST terminalAST] : a= id ASSIGN (b= id |s= STRING_LITERAL ) ;
-	private ANTLRParser.elementOption_return elementOption( GrammarAST terminalAST )
-	{
-		ANTLRParser.elementOption_return retval = new ANTLRParser.elementOption_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken s=null;
-		IToken ASSIGN148=null;
-		ANTLRParser.id_return a = default(ANTLRParser.id_return);
-		ANTLRParser.id_return b = default(ANTLRParser.id_return);
-
-		GrammarAST s_tree=null;
-		GrammarAST ASSIGN148_tree=null;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:592:4: (a= id ASSIGN (b= id |s= STRING_LITERAL ) )
-			// Grammars\\ANTLR.g3:592:4: a= id ASSIGN (b= id |s= STRING_LITERAL )
-			{
-			root_0 = (GrammarAST)adaptor.Nil();
-
-			PushFollow(Follow._id_in_elementOption2484);
-			a=id();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, a.Tree);
-			ASSIGN148=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_elementOption2486); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) {
-			ASSIGN148_tree = (GrammarAST)adaptor.Create(ASSIGN148);
-			root_0 = (GrammarAST)adaptor.BecomeRoot(ASSIGN148_tree, root_0);
-			}
-			// Grammars\\ANTLR.g3:592:17: (b= id |s= STRING_LITERAL )
-			int alt75=2;
-			int LA75_0 = input.LA(1);
-
-			if ( (LA75_0==RULE_REF||LA75_0==TOKEN_REF) )
-			{
-				alt75=1;
-			}
-			else if ( (LA75_0==STRING_LITERAL) )
-			{
-				alt75=2;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return retval;}
-				NoViableAltException nvae = new NoViableAltException("", 75, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt75 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:592:18: b= id
-				{
-				PushFollow(Follow._id_in_elementOption2492);
-				b=id();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, b.Tree);
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:592:23: s= STRING_LITERAL
-				{
-				s=(IToken)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_elementOption2496); if (state.failed) return retval;
-				if ( state.backtracking==0 ) {
-				s_tree = (GrammarAST)adaptor.Create(s);
-				adaptor.AddChild(root_0, s_tree);
-				}
-
-				}
-				break;
-
-			}
-
-			if ( state.backtracking == 0 )
-			{
-
-						object v = ((b!=null?((GrammarAST)b.Tree):null)!=null)?(b!=null?input.ToString(b.start,b.stop):null):(s!=null?s.Text:null);
-						terminalAST.SetTerminalOption(Grammar,(a!=null?input.ToString(a.start,a.stop):null),v);
-
-			}
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "elementOption"
-
-	public class ebnfSuffix_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "ebnfSuffix"
-	// Grammars\\ANTLR.g3:599:0: ebnfSuffix[GrammarAST elemAST, bool inRewrite] : ( -> BLOCK[\"BLOCK\"] ) ( -> ^( ALT[\"ALT\"] EOA[\"<end-of-alt>\"] ) ) ( QUESTION -> OPTIONAL[$elemAST.Token,\"?\"] | STAR -> CLOSURE[$elemAST.Token,\"*\"] | PLUS -> POSITIVE_CLOSURE[$elemAST.Token,\"+\"] ) -> ^( $ebnfSuffix ^( EOB[$elemAST.Token, \"<end-of-block>\"] ) ) ;
-	private ANTLRParser.ebnfSuffix_return ebnfSuffix( GrammarAST elemAST, bool inRewrite )
-	{
-		ANTLRParser.ebnfSuffix_return retval = new ANTLRParser.ebnfSuffix_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken QUESTION149=null;
-		IToken STAR150=null;
-		IToken PLUS151=null;
-
-		GrammarAST QUESTION149_tree=null;
-		GrammarAST STAR150_tree=null;
-		GrammarAST PLUS151_tree=null;
-		RewriteRuleITokenStream stream_QUESTION=new RewriteRuleITokenStream(adaptor,"token QUESTION");
-		RewriteRuleITokenStream stream_STAR=new RewriteRuleITokenStream(adaptor,"token STAR");
-		RewriteRuleITokenStream stream_PLUS=new RewriteRuleITokenStream(adaptor,"token PLUS");
-
-
-		GrammarAST blkRoot=null;
-		GrammarAST alt=null;
-		GrammarAST save = currentBlockAST;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:610:4: ( ( -> BLOCK[\"BLOCK\"] ) ( -> ^( ALT[\"ALT\"] EOA[\"<end-of-alt>\"] ) ) ( QUESTION -> OPTIONAL[$elemAST.Token,\"?\"] | STAR -> CLOSURE[$elemAST.Token,\"*\"] | PLUS -> POSITIVE_CLOSURE[$elemAST.Token,\"+\"] ) -> ^( $ebnfSuffix ^( EOB[$elemAST.Token, \"<end-of-block>\"] ) ) )
-			// Grammars\\ANTLR.g3:610:4: ( -> BLOCK[\"BLOCK\"] ) ( -> ^( ALT[\"ALT\"] EOA[\"<end-of-alt>\"] ) ) ( QUESTION -> OPTIONAL[$elemAST.Token,\"?\"] | STAR -> CLOSURE[$elemAST.Token,\"*\"] | PLUS -> POSITIVE_CLOSURE[$elemAST.Token,\"+\"] )
-			{
-			// Grammars\\ANTLR.g3:610:4: ( -> BLOCK[\"BLOCK\"] )
-			// Grammars\\ANTLR.g3:610:6:
-			{
-
-
-
-			{
-			// AST REWRITE
-			// elements:
-			// token labels:
-			// rule labels: retval
-			// token list labels:
-			// rule list labels:
-			// wildcard labels:
-			if ( state.backtracking == 0 ) {
-			retval.tree = root_0;
-			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-			root_0 = (GrammarAST)adaptor.Nil();
-			// 610:6: -> BLOCK[\"BLOCK\"]
-			{
-				adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(BLOCK, "BLOCK"));
-
-			}
-
-			retval.tree = root_0;
-			}
-			}
-
-			}
-
-			if ( state.backtracking == 0 )
-			{
-				 blkRoot = (GrammarAST)((GrammarAST)retval.Tree).GetChild(0); currentBlockAST = blkRoot;
-			}
-			// Grammars\\ANTLR.g3:613:3: ( -> ^( ALT[\"ALT\"] EOA[\"<end-of-alt>\"] ) )
-			// Grammars\\ANTLR.g3:614:4:
-			{
-
-
-
-			{
-			// AST REWRITE
-			// elements:
-			// token labels:
-			// rule labels: retval
-			// token list labels:
-			// rule list labels:
-			// wildcard labels:
-			if ( state.backtracking == 0 ) {
-			retval.tree = root_0;
-			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-			root_0 = (GrammarAST)adaptor.Nil();
-			// 614:4: -> ^( ALT[\"ALT\"] EOA[\"<end-of-alt>\"] )
-			{
-				// Grammars\\ANTLR.g3:614:7: ^( ALT[\"ALT\"] EOA[\"<end-of-alt>\"] )
-				{
-				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-				root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(ALT, "ALT"), root_1);
-
-				adaptor.AddChild(root_1, elemAST);
-				adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EOA, "<end-of-alt>"));
-
-				adaptor.AddChild(root_0, root_1);
-				}
-
-			}
-
-			retval.tree = root_0;
-			}
-			}
-
-			}
-
-			if ( state.backtracking == 0 )
-			{
-
-							alt = (GrammarAST)((GrammarAST)retval.Tree).GetChild(0);
-							if ( !inRewrite )
-								PrefixWithSynPred(alt);
-
-			}
-			// Grammars\\ANTLR.g3:621:3: ( QUESTION -> OPTIONAL[$elemAST.Token,\"?\"] | STAR -> CLOSURE[$elemAST.Token,\"*\"] | PLUS -> POSITIVE_CLOSURE[$elemAST.Token,\"+\"] )
-			int alt76=3;
-			switch ( input.LA(1) )
-			{
-			case QUESTION:
-				{
-				alt76=1;
-				}
-				break;
-			case STAR:
-				{
-				alt76=2;
-				}
-				break;
-			case PLUS:
-				{
-				alt76=3;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 76, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt76 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:621:5: QUESTION
-				{
-				QUESTION149=(IToken)Match(input,QUESTION,Follow._QUESTION_in_ebnfSuffix2570); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_QUESTION.Add(QUESTION149);
-
-
-
-				{
-				// AST REWRITE
-				// elements:
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 622:4: -> OPTIONAL[$elemAST.Token,\"?\"]
-				{
-					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(OPTIONAL, elemAST.Token, "?"));
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:623:5: STAR
-				{
-				STAR150=(IToken)Match(input,STAR,Follow._STAR_in_ebnfSuffix2584); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_STAR.Add(STAR150);
-
-
-
-				{
-				// AST REWRITE
-				// elements:
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 624:4: -> CLOSURE[$elemAST.Token,\"*\"]
-				{
-					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(CLOSURE, elemAST.Token, "*"));
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-			case 3:
-				// Grammars\\ANTLR.g3:625:5: PLUS
-				{
-				PLUS151=(IToken)Match(input,PLUS,Follow._PLUS_in_ebnfSuffix2598); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_PLUS.Add(PLUS151);
-
-
-
-				{
-				// AST REWRITE
-				// elements:
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 626:4: -> POSITIVE_CLOSURE[$elemAST.Token,\"+\"]
-				{
-					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(POSITIVE_CLOSURE, elemAST.Token, "+"));
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-
-			}
-
-
-
-			{
-			// AST REWRITE
-			// elements: ebnfSuffix
-			// token labels:
-			// rule labels: retval
-			// token list labels:
-			// rule list labels:
-			// wildcard labels:
-			if ( state.backtracking == 0 ) {
-			retval.tree = root_0;
-			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-			root_0 = (GrammarAST)adaptor.Nil();
-			// 628:3: -> ^( $ebnfSuffix ^( EOB[$elemAST.Token, \"<end-of-block>\"] ) )
-			{
-				// Grammars\\ANTLR.g3:628:6: ^( $ebnfSuffix ^( EOB[$elemAST.Token, \"<end-of-block>\"] ) )
-				{
-				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-				root_1 = (GrammarAST)adaptor.BecomeRoot(stream_retval.NextNode(), root_1);
-
-				// Grammars\\ANTLR.g3:628:20: ^( EOB[$elemAST.Token, \"<end-of-block>\"] )
-				{
-				GrammarAST root_2 = (GrammarAST)adaptor.Nil();
-				root_2 = (GrammarAST)adaptor.BecomeRoot(blkRoot, root_2);
-
-				adaptor.AddChild(root_2, alt);
-				adaptor.AddChild(root_2, (GrammarAST)adaptor.Create(EOB, elemAST.Token, "<end-of-block>"));
-
-				adaptor.AddChild(root_1, root_2);
-				}
-
-				adaptor.AddChild(root_0, root_1);
-				}
-
-			}
-
-			retval.tree = root_0;
-			}
-			}
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-			if ( state.backtracking == 0 )
-			{
-
-				currentBlockAST = save;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "ebnfSuffix"
-
-	public class notTerminal_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "notTerminal"
-	// Grammars\\ANTLR.g3:631:0: notTerminal : ( CHAR_LITERAL | TOKEN_REF | STRING_LITERAL );
-	private ANTLRParser.notTerminal_return notTerminal(  )
-	{
-		ANTLRParser.notTerminal_return retval = new ANTLRParser.notTerminal_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken set152=null;
-
-		GrammarAST set152_tree=null;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:632:4: ( CHAR_LITERAL | TOKEN_REF | STRING_LITERAL )
-			// Grammars\\ANTLR.g3:
-			{
-			root_0 = (GrammarAST)adaptor.Nil();
-
-			set152=(IToken)input.LT(1);
-			if ( input.LA(1)==CHAR_LITERAL||input.LA(1)==STRING_LITERAL||input.LA(1)==TOKEN_REF )
-			{
-				input.Consume();
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(set152));
-				state.errorRecovery=false;state.failed=false;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return retval;}
-				MismatchedSetException mse = new MismatchedSetException(null,input);
-				throw mse;
-			}
-
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "notTerminal"
-
-	public class idList_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "idList"
-	// Grammars\\ANTLR.g3:637:0: idList : id ( COMMA id )* ;
-	private ANTLRParser.idList_return idList(  )
-	{
-		ANTLRParser.idList_return retval = new ANTLRParser.idList_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken COMMA154=null;
-		ANTLRParser.id_return id153 = default(ANTLRParser.id_return);
-		ANTLRParser.id_return id155 = default(ANTLRParser.id_return);
-
-		GrammarAST COMMA154_tree=null;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:638:4: ( id ( COMMA id )* )
-			// Grammars\\ANTLR.g3:638:4: id ( COMMA id )*
-			{
-			root_0 = (GrammarAST)adaptor.Nil();
-
-			PushFollow(Follow._id_in_idList2660);
-			id153=id();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, id153.Tree);
-			// Grammars\\ANTLR.g3:638:7: ( COMMA id )*
-			for ( ; ; )
-			{
-				int alt77=2;
-				int LA77_0 = input.LA(1);
-
-				if ( (LA77_0==COMMA) )
-				{
-					alt77=1;
-				}
-
-
-				switch ( alt77 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:638:8: COMMA id
-					{
-					COMMA154=(IToken)Match(input,COMMA,Follow._COMMA_in_idList2663); if (state.failed) return retval;
-					PushFollow(Follow._id_in_idList2666);
-					id155=id();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, id155.Tree);
-
-					}
-					break;
-
-				default:
-					goto loop77;
-				}
-			}
-
-			loop77:
-				;
-
-
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "idList"
-
-	public class id_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "id"
-	// Grammars\\ANTLR.g3:641:0: id : ( TOKEN_REF -> ID[$TOKEN_REF] | RULE_REF -> ID[$RULE_REF] );
-	private ANTLRParser.id_return id(  )
-	{
-		ANTLRParser.id_return retval = new ANTLRParser.id_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken TOKEN_REF156=null;
-		IToken RULE_REF157=null;
-
-		GrammarAST TOKEN_REF156_tree=null;
-		GrammarAST RULE_REF157_tree=null;
-		RewriteRuleITokenStream stream_TOKEN_REF=new RewriteRuleITokenStream(adaptor,"token TOKEN_REF");
-		RewriteRuleITokenStream stream_RULE_REF=new RewriteRuleITokenStream(adaptor,"token RULE_REF");
-
-		try
-		{
-			// Grammars\\ANTLR.g3:642:4: ( TOKEN_REF -> ID[$TOKEN_REF] | RULE_REF -> ID[$RULE_REF] )
-			int alt78=2;
-			int LA78_0 = input.LA(1);
-
-			if ( (LA78_0==TOKEN_REF) )
-			{
-				alt78=1;
-			}
-			else if ( (LA78_0==RULE_REF) )
-			{
-				alt78=2;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return retval;}
-				NoViableAltException nvae = new NoViableAltException("", 78, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt78 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:642:4: TOKEN_REF
-				{
-				TOKEN_REF156=(IToken)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_id2679); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_TOKEN_REF.Add(TOKEN_REF156);
-
-
-
-				{
-				// AST REWRITE
-				// elements:
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 643:3: -> ID[$TOKEN_REF]
-				{
-					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(ID, TOKEN_REF156));
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:644:4: RULE_REF
-				{
-				RULE_REF157=(IToken)Match(input,RULE_REF,Follow._RULE_REF_in_id2691); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_RULE_REF.Add(RULE_REF157);
-
-
-
-				{
-				// AST REWRITE
-				// elements:
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 645:3: -> ID[$RULE_REF]
-				{
-					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(ID, RULE_REF157));
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-
-			}
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "id"
-
-	public class rewrite_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "rewrite"
-	// Grammars\\ANTLR.g3:650:0: rewrite : ( ( rewrite_with_sempred )* REWRITE rewrite_alternative -> ( rewrite_with_sempred )* ^( REWRITE rewrite_alternative ) |);
-	private ANTLRParser.rewrite_return rewrite(  )
-	{
-		ANTLRParser.rewrite_return retval = new ANTLRParser.rewrite_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken REWRITE159=null;
-		ANTLRParser.rewrite_with_sempred_return rewrite_with_sempred158 = default(ANTLRParser.rewrite_with_sempred_return);
-		ANTLRParser.rewrite_alternative_return rewrite_alternative160 = default(ANTLRParser.rewrite_alternative_return);
-
-		GrammarAST REWRITE159_tree=null;
-		RewriteRuleITokenStream stream_REWRITE=new RewriteRuleITokenStream(adaptor,"token REWRITE");
-		RewriteRuleSubtreeStream stream_rewrite_with_sempred=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_with_sempred");
-		RewriteRuleSubtreeStream stream_rewrite_alternative=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_alternative");
-		try
-		{
-			// Grammars\\ANTLR.g3:651:4: ( ( rewrite_with_sempred )* REWRITE rewrite_alternative -> ( rewrite_with_sempred )* ^( REWRITE rewrite_alternative ) |)
-			int alt80=2;
-			int LA80_0 = input.LA(1);
-
-			if ( (LA80_0==REWRITE) )
-			{
-				alt80=1;
-			}
-			else if ( (LA80_0==OR||LA80_0==RPAREN||LA80_0==SEMI) )
-			{
-				alt80=2;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return retval;}
-				NoViableAltException nvae = new NoViableAltException("", 80, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt80 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:651:4: ( rewrite_with_sempred )* REWRITE rewrite_alternative
-				{
-				// Grammars\\ANTLR.g3:651:4: ( rewrite_with_sempred )*
-				for ( ; ; )
-				{
-					int alt79=2;
-					int LA79_0 = input.LA(1);
-
-					if ( (LA79_0==REWRITE) )
-					{
-						int LA79_1 = input.LA(2);
-
-						if ( (LA79_1==SEMPRED) )
-						{
-							alt79=1;
-						}
-
-
-					}
-
-
-					switch ( alt79 )
-					{
-					case 1:
-						// Grammars\\ANTLR.g3:651:0: rewrite_with_sempred
-						{
-						PushFollow(Follow._rewrite_with_sempred_in_rewrite2711);
-						rewrite_with_sempred158=rewrite_with_sempred();
-
-						state._fsp--;
-						if (state.failed) return retval;
-						if ( state.backtracking == 0 ) stream_rewrite_with_sempred.Add(rewrite_with_sempred158.Tree);
-
-						}
-						break;
-
-					default:
-						goto loop79;
-					}
-				}
-
-				loop79:
-					;
-
-
-				REWRITE159=(IToken)Match(input,REWRITE,Follow._REWRITE_in_rewrite2716); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_REWRITE.Add(REWRITE159);
-
-				PushFollow(Follow._rewrite_alternative_in_rewrite2718);
-				rewrite_alternative160=rewrite_alternative();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_rewrite_alternative.Add(rewrite_alternative160.Tree);
-
-
-				{
-				// AST REWRITE
-				// elements: rewrite_with_sempred, REWRITE, rewrite_alternative
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 653:3: -> ( rewrite_with_sempred )* ^( REWRITE rewrite_alternative )
-				{
-					// Grammars\\ANTLR.g3:653:6: ( rewrite_with_sempred )*
-					while ( stream_rewrite_with_sempred.HasNext )
-					{
-						adaptor.AddChild(root_0, stream_rewrite_with_sempred.NextTree());
-
-					}
-					stream_rewrite_with_sempred.Reset();
-					// Grammars\\ANTLR.g3:653:28: ^( REWRITE rewrite_alternative )
-					{
-					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-					root_1 = (GrammarAST)adaptor.BecomeRoot(stream_REWRITE.NextNode(), root_1);
-
-					adaptor.AddChild(root_1, stream_rewrite_alternative.NextTree());
-
-					adaptor.AddChild(root_0, root_1);
-					}
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:655:2:
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-
-
-				}
-				break;
-
-			}
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "rewrite"
-
-	public class rewrite_with_sempred_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "rewrite_with_sempred"
-	// Grammars\\ANTLR.g3:657:0: rewrite_with_sempred : REWRITE SEMPRED rewrite_alternative ;
-	private ANTLRParser.rewrite_with_sempred_return rewrite_with_sempred(  )
-	{
-		ANTLRParser.rewrite_with_sempred_return retval = new ANTLRParser.rewrite_with_sempred_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken REWRITE161=null;
-		IToken SEMPRED162=null;
-		ANTLRParser.rewrite_alternative_return rewrite_alternative163 = default(ANTLRParser.rewrite_alternative_return);
-
-		GrammarAST REWRITE161_tree=null;
-		GrammarAST SEMPRED162_tree=null;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:658:4: ( REWRITE SEMPRED rewrite_alternative )
-			// Grammars\\ANTLR.g3:658:4: REWRITE SEMPRED rewrite_alternative
-			{
-			root_0 = (GrammarAST)adaptor.Nil();
-
-			REWRITE161=(IToken)Match(input,REWRITE,Follow._REWRITE_in_rewrite_with_sempred2745); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) {
-			REWRITE161_tree = (GrammarAST)adaptor.Create(REWRITE161);
-			root_0 = (GrammarAST)adaptor.BecomeRoot(REWRITE161_tree, root_0);
-			}
-			SEMPRED162=(IToken)Match(input,SEMPRED,Follow._SEMPRED_in_rewrite_with_sempred2748); if (state.failed) return retval;
-			if ( state.backtracking==0 ) {
-			SEMPRED162_tree = (GrammarAST)adaptor.Create(SEMPRED162);
-			adaptor.AddChild(root_0, SEMPRED162_tree);
-			}
-			PushFollow(Follow._rewrite_alternative_in_rewrite_with_sempred2750);
-			rewrite_alternative163=rewrite_alternative();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, rewrite_alternative163.Tree);
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "rewrite_with_sempred"
-
-	public class rewrite_block_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "rewrite_block"
-	// Grammars\\ANTLR.g3:661:0: rewrite_block : LPAREN rewrite_alternative RPAREN -> ^( BLOCK[$LPAREN,\"BLOCK\"] rewrite_alternative EOB[$RPAREN,\"<end-of-block>\"] ) ;
-	private ANTLRParser.rewrite_block_return rewrite_block(  )
-	{
-		ANTLRParser.rewrite_block_return retval = new ANTLRParser.rewrite_block_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken LPAREN164=null;
-		IToken RPAREN166=null;
-		ANTLRParser.rewrite_alternative_return rewrite_alternative165 = default(ANTLRParser.rewrite_alternative_return);
-
-		GrammarAST LPAREN164_tree=null;
-		GrammarAST RPAREN166_tree=null;
-		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
-		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
-		RewriteRuleSubtreeStream stream_rewrite_alternative=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_alternative");
-		try
-		{
-			// Grammars\\ANTLR.g3:662:4: ( LPAREN rewrite_alternative RPAREN -> ^( BLOCK[$LPAREN,\"BLOCK\"] rewrite_alternative EOB[$RPAREN,\"<end-of-block>\"] ) )
-			// Grammars\\ANTLR.g3:662:4: LPAREN rewrite_alternative RPAREN
-			{
-			LPAREN164=(IToken)Match(input,LPAREN,Follow._LPAREN_in_rewrite_block2761); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_LPAREN.Add(LPAREN164);
-
-			PushFollow(Follow._rewrite_alternative_in_rewrite_block2765);
-			rewrite_alternative165=rewrite_alternative();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_rewrite_alternative.Add(rewrite_alternative165.Tree);
-			RPAREN166=(IToken)Match(input,RPAREN,Follow._RPAREN_in_rewrite_block2769); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_RPAREN.Add(RPAREN166);
-
-
-
-			{
-			// AST REWRITE
-			// elements: rewrite_alternative
-			// token labels:
-			// rule labels: retval
-			// token list labels:
-			// rule list labels:
-			// wildcard labels:
-			if ( state.backtracking == 0 ) {
-			retval.tree = root_0;
-			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-			root_0 = (GrammarAST)adaptor.Nil();
-			// 665:3: -> ^( BLOCK[$LPAREN,\"BLOCK\"] rewrite_alternative EOB[$RPAREN,\"<end-of-block>\"] )
-			{
-				// Grammars\\ANTLR.g3:665:6: ^( BLOCK[$LPAREN,\"BLOCK\"] rewrite_alternative EOB[$RPAREN,\"<end-of-block>\"] )
-				{
-				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-				root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(BLOCK, LPAREN164, "BLOCK"), root_1);
-
-				adaptor.AddChild(root_1, stream_rewrite_alternative.NextTree());
-				adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EOB, RPAREN166, "<end-of-block>"));
-
-				adaptor.AddChild(root_0, root_1);
-				}
-
-			}
-
-			retval.tree = root_0;
-			}
-			}
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "rewrite_block"
-
-	public class rewrite_alternative_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "rewrite_alternative"
-	// Grammars\\ANTLR.g3:668:0: rewrite_alternative options {k=1; } : ({...}? => rewrite_template |{...}? => ( rewrite_element )+ -> {!stream_rewrite_element.HasNext}? ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] ) -> ^( ALT[LT(1),\"ALT\"] ( rewrite_element )+ EOA[\"<end-of-alt>\"] ) | -> ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] ) |{...}? ETC );
-	private ANTLRParser.rewrite_alternative_return rewrite_alternative(  )
-	{
-		ANTLRParser.rewrite_alternative_return retval = new ANTLRParser.rewrite_alternative_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken ETC169=null;
-		ANTLRParser.rewrite_template_return rewrite_template167 = default(ANTLRParser.rewrite_template_return);
-		ANTLRParser.rewrite_element_return rewrite_element168 = default(ANTLRParser.rewrite_element_return);
-
-		GrammarAST ETC169_tree=null;
-		RewriteRuleSubtreeStream stream_rewrite_element=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_element");
-		try
-		{
-			// Grammars\\ANTLR.g3:670:4: ({...}? => rewrite_template |{...}? => ( rewrite_element )+ -> {!stream_rewrite_element.HasNext}? ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] ) -> ^( ALT[LT(1),\"ALT\"] ( rewrite_element )+ EOA[\"<end-of-alt>\"] ) | -> ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] ) |{...}? ETC )
-			int alt82=4;
-			alt82 = dfa82.Predict(input);
-			switch ( alt82 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:670:4: {...}? => rewrite_template
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				if ( !((Grammar.BuildTemplate)) )
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					throw new FailedPredicateException(input, "rewrite_alternative", "Grammar.BuildTemplate");
-				}
-				PushFollow(Follow._rewrite_template_in_rewrite_alternative2805);
-				rewrite_template167=rewrite_template();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, rewrite_template167.Tree);
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:672:4: {...}? => ( rewrite_element )+
-				{
-				if ( !((Grammar.BuildAST)) )
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					throw new FailedPredicateException(input, "rewrite_alternative", "Grammar.BuildAST");
-				}
-				// Grammars\\ANTLR.g3:672:27: ( rewrite_element )+
-				int cnt81=0;
-				for ( ; ; )
-				{
-					int alt81=2;
-					int LA81_0 = input.LA(1);
-
-					if ( (LA81_0==ACTION||LA81_0==CHAR_LITERAL||LA81_0==DOLLAR||LA81_0==LPAREN||LA81_0==RULE_REF||LA81_0==STRING_LITERAL||LA81_0==TOKEN_REF||LA81_0==TREE_BEGIN) )
-					{
-						alt81=1;
-					}
-
-
-					switch ( alt81 )
-					{
-					case 1:
-						// Grammars\\ANTLR.g3:672:29: rewrite_element
-						{
-						PushFollow(Follow._rewrite_element_in_rewrite_alternative2817);
-						rewrite_element168=rewrite_element();
-
-						state._fsp--;
-						if (state.failed) return retval;
-						if ( state.backtracking == 0 ) stream_rewrite_element.Add(rewrite_element168.Tree);
-
-						}
-						break;
-
-					default:
-						if ( cnt81 >= 1 )
-							goto loop81;
-
-						if (state.backtracking>0) {state.failed=true; return retval;}
-						EarlyExitException eee81 = new EarlyExitException( 81, input );
-						throw eee81;
-					}
-					cnt81++;
-				}
-				loop81:
-					;
-
-
-
-
-				{
-				// AST REWRITE
-				// elements: rewrite_element
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 673:3: -> {!stream_rewrite_element.HasNext}? ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] )
-				if (!stream_rewrite_element.HasNext)
-				{
-					// Grammars\\ANTLR.g3:673:41: ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] )
-					{
-					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(ALT, LT(1), "ALT"), root_1);
-
-					adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EPSILON, "epsilon"));
-					adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EOA, "<end-of-alt>"));
-
-					adaptor.AddChild(root_0, root_1);
-					}
-
-				}
-				else // 674:3: -> ^( ALT[LT(1),\"ALT\"] ( rewrite_element )+ EOA[\"<end-of-alt>\"] )
-				{
-					// Grammars\\ANTLR.g3:674:6: ^( ALT[LT(1),\"ALT\"] ( rewrite_element )+ EOA[\"<end-of-alt>\"] )
-					{
-					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(ALT, LT(1), "ALT"), root_1);
-
-					if ( !(stream_rewrite_element.HasNext) )
-					{
-						throw new RewriteEarlyExitException();
-					}
-					while ( stream_rewrite_element.HasNext )
-					{
-						adaptor.AddChild(root_1, stream_rewrite_element.NextTree());
-
-					}
-					stream_rewrite_element.Reset();
-					adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EOA, "<end-of-alt>"));
-
-					adaptor.AddChild(root_0, root_1);
-					}
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-			case 3:
-				// Grammars\\ANTLR.g3:677:3:
-				{
-
-
-
-				{
-				// AST REWRITE
-				// elements:
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 677:3: -> ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] )
-				{
-					// Grammars\\ANTLR.g3:677:6: ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] )
-					{
-					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(ALT, LT(1), "ALT"), root_1);
-
-					adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EPSILON, "epsilon"));
-					adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EOA, "<end-of-alt>"));
-
-					adaptor.AddChild(root_0, root_1);
-					}
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-			case 4:
-				// Grammars\\ANTLR.g3:678:4: {...}? ETC
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				if ( !((Grammar.BuildAST)) )
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					throw new FailedPredicateException(input, "rewrite_alternative", "Grammar.BuildAST");
-				}
-				ETC169=(IToken)Match(input,ETC,Follow._ETC_in_rewrite_alternative2878); if (state.failed) return retval;
-				if ( state.backtracking==0 ) {
-				ETC169_tree = (GrammarAST)adaptor.Create(ETC169);
-				adaptor.AddChild(root_0, ETC169_tree);
-				}
-
-				}
-				break;
-
-			}
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "rewrite_alternative"
-
-	public class rewrite_element_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "rewrite_element"
-	// Grammars\\ANTLR.g3:681:0: rewrite_element : ( (t= rewrite_atom -> $t) (subrule= ebnfSuffix[$t.tree,true] -> $subrule)? | rewrite_ebnf | (tr= rewrite_tree -> $tr) (subrule= ebnfSuffix[$tr.tree,true] -> $subrule)? );
-	private ANTLRParser.rewrite_element_return rewrite_element(  )
-	{
-		ANTLRParser.rewrite_element_return retval = new ANTLRParser.rewrite_element_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		ANTLRParser.rewrite_atom_return t = default(ANTLRParser.rewrite_atom_return);
-		ANTLRParser.ebnfSuffix_return subrule = default(ANTLRParser.ebnfSuffix_return);
-		ANTLRParser.rewrite_tree_return tr = default(ANTLRParser.rewrite_tree_return);
-		ANTLRParser.rewrite_ebnf_return rewrite_ebnf170 = default(ANTLRParser.rewrite_ebnf_return);
-
-		RewriteRuleSubtreeStream stream_rewrite_atom=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_atom");
-		RewriteRuleSubtreeStream stream_ebnfSuffix=new RewriteRuleSubtreeStream(adaptor,"rule ebnfSuffix");
-		RewriteRuleSubtreeStream stream_rewrite_tree=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_tree");
-		try
-		{
-			// Grammars\\ANTLR.g3:682:4: ( (t= rewrite_atom -> $t) (subrule= ebnfSuffix[$t.tree,true] -> $subrule)? | rewrite_ebnf | (tr= rewrite_tree -> $tr) (subrule= ebnfSuffix[$tr.tree,true] -> $subrule)? )
-			int alt85=3;
-			switch ( input.LA(1) )
-			{
-			case ACTION:
-			case CHAR_LITERAL:
-			case DOLLAR:
-			case RULE_REF:
-			case STRING_LITERAL:
-			case TOKEN_REF:
-				{
-				alt85=1;
-				}
-				break;
-			case LPAREN:
-				{
-				alt85=2;
-				}
-				break;
-			case TREE_BEGIN:
-				{
-				alt85=3;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 85, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt85 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:682:4: (t= rewrite_atom -> $t) (subrule= ebnfSuffix[$t.tree,true] -> $subrule)?
-				{
-				// Grammars\\ANTLR.g3:682:4: (t= rewrite_atom -> $t)
-				// Grammars\\ANTLR.g3:682:6: t= rewrite_atom
-				{
-				PushFollow(Follow._rewrite_atom_in_rewrite_element2893);
-				t=rewrite_atom();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_rewrite_atom.Add(t.Tree);
-
-
-				{
-				// AST REWRITE
-				// elements: t
-				// token labels:
-				// rule labels: t, retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_t=new RewriteRuleSubtreeStream(adaptor,"rule t",t!=null?t.tree:null);
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 683:4: -> $t
-				{
-					adaptor.AddChild(root_0, stream_t.NextTree());
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-
-				// Grammars\\ANTLR.g3:685:3: (subrule= ebnfSuffix[$t.tree,true] -> $subrule)?
-				int alt83=2;
-				int LA83_0 = input.LA(1);
-
-				if ( (LA83_0==PLUS||LA83_0==QUESTION||LA83_0==STAR) )
-				{
-					alt83=1;
-				}
-				switch ( alt83 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:685:5: subrule= ebnfSuffix[$t.tree,true]
-					{
-					PushFollow(Follow._ebnfSuffix_in_rewrite_element2913);
-					subrule=ebnfSuffix((t!=null?((GrammarAST)t.Tree):null), true);
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) stream_ebnfSuffix.Add(subrule.Tree);
-
-
-					{
-					// AST REWRITE
-					// elements: subrule
-					// token labels:
-					// rule labels: subrule, retval
-					// token list labels:
-					// rule list labels:
-					// wildcard labels:
-					if ( state.backtracking == 0 ) {
-					retval.tree = root_0;
-					RewriteRuleSubtreeStream stream_subrule=new RewriteRuleSubtreeStream(adaptor,"rule subrule",subrule!=null?subrule.tree:null);
-					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-					root_0 = (GrammarAST)adaptor.Nil();
-					// 686:4: -> $subrule
-					{
-						adaptor.AddChild(root_0, stream_subrule.NextTree());
-
-					}
-
-					retval.tree = root_0;
-					}
-					}
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:688:4: rewrite_ebnf
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				PushFollow(Follow._rewrite_ebnf_in_rewrite_element2932);
-				rewrite_ebnf170=rewrite_ebnf();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, rewrite_ebnf170.Tree);
-
-				}
-				break;
-			case 3:
-				// Grammars\\ANTLR.g3:689:4: (tr= rewrite_tree -> $tr) (subrule= ebnfSuffix[$tr.tree,true] -> $subrule)?
-				{
-				// Grammars\\ANTLR.g3:689:4: (tr= rewrite_tree -> $tr)
-				// Grammars\\ANTLR.g3:689:6: tr= rewrite_tree
-				{
-				PushFollow(Follow._rewrite_tree_in_rewrite_element2941);
-				tr=rewrite_tree();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_rewrite_tree.Add(tr.Tree);
-
-
-				{
-				// AST REWRITE
-				// elements: tr
-				// token labels:
-				// rule labels: tr, retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_tr=new RewriteRuleSubtreeStream(adaptor,"rule tr",tr!=null?tr.tree:null);
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 690:4: -> $tr
-				{
-					adaptor.AddChild(root_0, stream_tr.NextTree());
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-
-				// Grammars\\ANTLR.g3:692:3: (subrule= ebnfSuffix[$tr.tree,true] -> $subrule)?
-				int alt84=2;
-				int LA84_0 = input.LA(1);
-
-				if ( (LA84_0==PLUS||LA84_0==QUESTION||LA84_0==STAR) )
-				{
-					alt84=1;
-				}
-				switch ( alt84 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:692:5: subrule= ebnfSuffix[$tr.tree,true]
-					{
-					PushFollow(Follow._ebnfSuffix_in_rewrite_element2961);
-					subrule=ebnfSuffix((tr!=null?((GrammarAST)tr.Tree):null), true);
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) stream_ebnfSuffix.Add(subrule.Tree);
-
-
-					{
-					// AST REWRITE
-					// elements: subrule
-					// token labels:
-					// rule labels: subrule, retval
-					// token list labels:
-					// rule list labels:
-					// wildcard labels:
-					if ( state.backtracking == 0 ) {
-					retval.tree = root_0;
-					RewriteRuleSubtreeStream stream_subrule=new RewriteRuleSubtreeStream(adaptor,"rule subrule",subrule!=null?subrule.tree:null);
-					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-					root_0 = (GrammarAST)adaptor.Nil();
-					// 693:4: -> $subrule
-					{
-						adaptor.AddChild(root_0, stream_subrule.NextTree());
-
-					}
-
-					retval.tree = root_0;
-					}
-					}
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-
-			}
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "rewrite_element"
-
-	public class rewrite_atom_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "rewrite_atom"
-	// Grammars\\ANTLR.g3:697:0: rewrite_atom : ( (tr= TOKEN_REF -> $tr) ( elementOptions[(GrammarAST)$tree.GetChild(0)] )? ( ARG_ACTION )? -> ^( $rewrite_atom ( ARG_ACTION )? ) |rr= RULE_REF | (cl= CHAR_LITERAL -> $cl) ( elementOptions[(GrammarAST)$tree.GetChild(0)] )? | (sl= STRING_LITERAL -> $sl) (eo= elementOptions[(GrammarAST)$tree.GetChild(0)] )? |d= DOLLAR i= id -> LABEL[$i.start,$i.text] | ACTION );
-	private ANTLRParser.rewrite_atom_return rewrite_atom(  )
-	{
-		ANTLRParser.rewrite_atom_return retval = new ANTLRParser.rewrite_atom_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken tr=null;
-		IToken rr=null;
-		IToken cl=null;
-		IToken sl=null;
-		IToken d=null;
-		IToken ARG_ACTION172=null;
-		IToken ACTION174=null;
-		ANTLRParser.elementOptions_return eo = default(ANTLRParser.elementOptions_return);
-		ANTLRParser.id_return i = default(ANTLRParser.id_return);
-		ANTLRParser.elementOptions_return elementOptions171 = default(ANTLRParser.elementOptions_return);
-		ANTLRParser.elementOptions_return elementOptions173 = default(ANTLRParser.elementOptions_return);
-
-		GrammarAST tr_tree=null;
-		GrammarAST rr_tree=null;
-		GrammarAST cl_tree=null;
-		GrammarAST sl_tree=null;
-		GrammarAST d_tree=null;
-		GrammarAST ARG_ACTION172_tree=null;
-		GrammarAST ACTION174_tree=null;
-		RewriteRuleITokenStream stream_TOKEN_REF=new RewriteRuleITokenStream(adaptor,"token TOKEN_REF");
-		RewriteRuleITokenStream stream_ARG_ACTION=new RewriteRuleITokenStream(adaptor,"token ARG_ACTION");
-		RewriteRuleITokenStream stream_CHAR_LITERAL=new RewriteRuleITokenStream(adaptor,"token CHAR_LITERAL");
-		RewriteRuleITokenStream stream_STRING_LITERAL=new RewriteRuleITokenStream(adaptor,"token STRING_LITERAL");
-		RewriteRuleITokenStream stream_DOLLAR=new RewriteRuleITokenStream(adaptor,"token DOLLAR");
-		RewriteRuleSubtreeStream stream_elementOptions=new RewriteRuleSubtreeStream(adaptor,"rule elementOptions");
-		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
-
-		GrammarAST subrule=null;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:702:4: ( (tr= TOKEN_REF -> $tr) ( elementOptions[(GrammarAST)$tree.GetChild(0)] )? ( ARG_ACTION )? -> ^( $rewrite_atom ( ARG_ACTION )? ) |rr= RULE_REF | (cl= CHAR_LITERAL -> $cl) ( elementOptions[(GrammarAST)$tree.GetChild(0)] )? | (sl= STRING_LITERAL -> $sl) (eo= elementOptions[(GrammarAST)$tree.GetChild(0)] )? |d= DOLLAR i= id -> LABEL[$i.start,$i.text] | ACTION )
-			int alt90=6;
-			switch ( input.LA(1) )
-			{
-			case TOKEN_REF:
-				{
-				alt90=1;
-				}
-				break;
-			case RULE_REF:
-				{
-				alt90=2;
-				}
-				break;
-			case CHAR_LITERAL:
-				{
-				alt90=3;
-				}
-				break;
-			case STRING_LITERAL:
-				{
-				alt90=4;
-				}
-				break;
-			case DOLLAR:
-				{
-				alt90=5;
-				}
-				break;
-			case ACTION:
-				{
-				alt90=6;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 90, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt90 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:702:4: (tr= TOKEN_REF -> $tr) ( elementOptions[(GrammarAST)$tree.GetChild(0)] )? ( ARG_ACTION )?
-				{
-				// Grammars\\ANTLR.g3:702:4: (tr= TOKEN_REF -> $tr)
-				// Grammars\\ANTLR.g3:702:6: tr= TOKEN_REF
-				{
-				tr=(IToken)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_rewrite_atom2995); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_TOKEN_REF.Add(tr);
-
-
-
-				{
-				// AST REWRITE
-				// elements: tr
-				// token labels: tr
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleITokenStream stream_tr=new RewriteRuleITokenStream(adaptor,"token tr",tr);
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 703:4: -> $tr
-				{
-					adaptor.AddChild(root_0, stream_tr.NextNode());
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-
-				// Grammars\\ANTLR.g3:705:3: ( elementOptions[(GrammarAST)$tree.GetChild(0)] )?
-				int alt86=2;
-				int LA86_0 = input.LA(1);
-
-				if ( (LA86_0==OPEN_ELEMENT_OPTION) )
-				{
-					alt86=1;
-				}
-				switch ( alt86 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:705:4: elementOptions[(GrammarAST)$tree.GetChild(0)]
-					{
-					PushFollow(Follow._elementOptions_in_rewrite_atom3012);
-					elementOptions171=elementOptions((GrammarAST)((GrammarAST)retval.Tree).GetChild(0));
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) stream_elementOptions.Add(elementOptions171.Tree);
-
-					}
-					break;
-
-				}
-
-				// Grammars\\ANTLR.g3:705:52: ( ARG_ACTION )?
-				int alt87=2;
-				int LA87_0 = input.LA(1);
-
-				if ( (LA87_0==ARG_ACTION) )
-				{
-					alt87=1;
-				}
-				switch ( alt87 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:705:53: ARG_ACTION
-					{
-					ARG_ACTION172=(IToken)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rewrite_atom3018); if (state.failed) return retval;
-					if ( state.backtracking == 0 ) stream_ARG_ACTION.Add(ARG_ACTION172);
-
-
-					}
-					break;
-
-				}
-
-
-
-				{
-				// AST REWRITE
-				// elements: rewrite_atom, ARG_ACTION
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 706:3: -> ^( $rewrite_atom ( ARG_ACTION )? )
-				{
-					// Grammars\\ANTLR.g3:706:6: ^( $rewrite_atom ( ARG_ACTION )? )
-					{
-					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-					root_1 = (GrammarAST)adaptor.BecomeRoot(stream_retval.NextNode(), root_1);
-
-					// Grammars\\ANTLR.g3:706:22: ( ARG_ACTION )?
-					if ( stream_ARG_ACTION.HasNext )
-					{
-						adaptor.AddChild(root_1, stream_ARG_ACTION.NextNode());
-
-					}
-					stream_ARG_ACTION.Reset();
-
-					adaptor.AddChild(root_0, root_1);
-					}
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:707:4: rr= RULE_REF
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				rr=(IToken)Match(input,RULE_REF,Follow._RULE_REF_in_rewrite_atom3040); if (state.failed) return retval;
-				if ( state.backtracking==0 ) {
-				rr_tree = (GrammarAST)adaptor.Create(rr);
-				adaptor.AddChild(root_0, rr_tree);
-				}
-
-				}
-				break;
-			case 3:
-				// Grammars\\ANTLR.g3:708:4: (cl= CHAR_LITERAL -> $cl) ( elementOptions[(GrammarAST)$tree.GetChild(0)] )?
-				{
-				// Grammars\\ANTLR.g3:708:4: (cl= CHAR_LITERAL -> $cl)
-				// Grammars\\ANTLR.g3:708:6: cl= CHAR_LITERAL
-				{
-				cl=(IToken)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_rewrite_atom3049); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_CHAR_LITERAL.Add(cl);
-
-
-
-				{
-				// AST REWRITE
-				// elements: cl
-				// token labels: cl
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleITokenStream stream_cl=new RewriteRuleITokenStream(adaptor,"token cl",cl);
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 709:4: -> $cl
-				{
-					adaptor.AddChild(root_0, stream_cl.NextNode());
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-
-				// Grammars\\ANTLR.g3:711:3: ( elementOptions[(GrammarAST)$tree.GetChild(0)] )?
-				int alt88=2;
-				int LA88_0 = input.LA(1);
-
-				if ( (LA88_0==OPEN_ELEMENT_OPTION) )
-				{
-					alt88=1;
-				}
-				switch ( alt88 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:711:4: elementOptions[(GrammarAST)$tree.GetChild(0)]
-					{
-					PushFollow(Follow._elementOptions_in_rewrite_atom3066);
-					elementOptions173=elementOptions((GrammarAST)((GrammarAST)retval.Tree).GetChild(0));
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) stream_elementOptions.Add(elementOptions173.Tree);
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-			case 4:
-				// Grammars\\ANTLR.g3:712:4: (sl= STRING_LITERAL -> $sl) (eo= elementOptions[(GrammarAST)$tree.GetChild(0)] )?
-				{
-				// Grammars\\ANTLR.g3:712:4: (sl= STRING_LITERAL -> $sl)
-				// Grammars\\ANTLR.g3:712:6: sl= STRING_LITERAL
-				{
-				sl=(IToken)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_rewrite_atom3078); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_STRING_LITERAL.Add(sl);
-
-
-
-				{
-				// AST REWRITE
-				// elements: sl
-				// token labels: sl
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleITokenStream stream_sl=new RewriteRuleITokenStream(adaptor,"token sl",sl);
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 713:4: -> $sl
-				{
-					adaptor.AddChild(root_0, stream_sl.NextNode());
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-
-				// Grammars\\ANTLR.g3:715:3: (eo= elementOptions[(GrammarAST)$tree.GetChild(0)] )?
-				int alt89=2;
-				int LA89_0 = input.LA(1);
-
-				if ( (LA89_0==OPEN_ELEMENT_OPTION) )
-				{
-					alt89=1;
-				}
-				switch ( alt89 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:715:4: eo= elementOptions[(GrammarAST)$tree.GetChild(0)]
-					{
-					PushFollow(Follow._elementOptions_in_rewrite_atom3097);
-					eo=elementOptions((GrammarAST)((GrammarAST)retval.Tree).GetChild(0));
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) stream_elementOptions.Add(eo.Tree);
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-			case 5:
-				// Grammars\\ANTLR.g3:716:4: d= DOLLAR i= id
-				{
-				d=(IToken)Match(input,DOLLAR,Follow._DOLLAR_in_rewrite_atom3107); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_DOLLAR.Add(d);
-
-				PushFollow(Follow._id_in_rewrite_atom3111);
-				i=id();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_id.Add(i.Tree);
-
-
-				{
-				// AST REWRITE
-				// elements:
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 717:3: -> LABEL[$i.start,$i.text]
-				{
-					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(LABEL, (i!=null?((IToken)i.Start):null), (i!=null?input.ToString(i.start,i.stop):null)));
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-			case 6:
-				// Grammars\\ANTLR.g3:718:4: ACTION
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				ACTION174=(IToken)Match(input,ACTION,Follow._ACTION_in_rewrite_atom3124); if (state.failed) return retval;
-				if ( state.backtracking==0 ) {
-				ACTION174_tree = (GrammarAST)adaptor.Create(ACTION174);
-				adaptor.AddChild(root_0, ACTION174_tree);
-				}
-
-				}
-				break;
-
-			}
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "rewrite_atom"
-
-	public class rewrite_ebnf_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "rewrite_ebnf"
-	// Grammars\\ANTLR.g3:721:0: rewrite_ebnf : b= rewrite_block ( QUESTION -> ^( OPTIONAL[$b.start,\"?\"] $b) | STAR -> ^( CLOSURE[$b.start,\"*\"] $b) | PLUS -> ^( POSITIVE_CLOSURE[$b.start,\"+\"] $b) ) ;
-	private ANTLRParser.rewrite_ebnf_return rewrite_ebnf(  )
-	{
-		ANTLRParser.rewrite_ebnf_return retval = new ANTLRParser.rewrite_ebnf_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken QUESTION175=null;
-		IToken STAR176=null;
-		IToken PLUS177=null;
-		ANTLRParser.rewrite_block_return b = default(ANTLRParser.rewrite_block_return);
-
-		GrammarAST QUESTION175_tree=null;
-		GrammarAST STAR176_tree=null;
-		GrammarAST PLUS177_tree=null;
-		RewriteRuleITokenStream stream_QUESTION=new RewriteRuleITokenStream(adaptor,"token QUESTION");
-		RewriteRuleITokenStream stream_STAR=new RewriteRuleITokenStream(adaptor,"token STAR");
-		RewriteRuleITokenStream stream_PLUS=new RewriteRuleITokenStream(adaptor,"token PLUS");
-		RewriteRuleSubtreeStream stream_rewrite_block=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_block");
-		try
-		{
-			// Grammars\\ANTLR.g3:722:4: (b= rewrite_block ( QUESTION -> ^( OPTIONAL[$b.start,\"?\"] $b) | STAR -> ^( CLOSURE[$b.start,\"*\"] $b) | PLUS -> ^( POSITIVE_CLOSURE[$b.start,\"+\"] $b) ) )
-			// Grammars\\ANTLR.g3:722:4: b= rewrite_block ( QUESTION -> ^( OPTIONAL[$b.start,\"?\"] $b) | STAR -> ^( CLOSURE[$b.start,\"*\"] $b) | PLUS -> ^( POSITIVE_CLOSURE[$b.start,\"+\"] $b) )
-			{
-			PushFollow(Follow._rewrite_block_in_rewrite_ebnf3137);
-			b=rewrite_block();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_rewrite_block.Add(b.Tree);
-			// Grammars\\ANTLR.g3:723:3: ( QUESTION -> ^( OPTIONAL[$b.start,\"?\"] $b) | STAR -> ^( CLOSURE[$b.start,\"*\"] $b) | PLUS -> ^( POSITIVE_CLOSURE[$b.start,\"+\"] $b) )
-			int alt91=3;
-			switch ( input.LA(1) )
-			{
-			case QUESTION:
-				{
-				alt91=1;
-				}
-				break;
-			case STAR:
-				{
-				alt91=2;
-				}
-				break;
-			case PLUS:
-				{
-				alt91=3;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 91, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt91 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:723:5: QUESTION
-				{
-				QUESTION175=(IToken)Match(input,QUESTION,Follow._QUESTION_in_rewrite_ebnf3143); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_QUESTION.Add(QUESTION175);
-
-
-
-				{
-				// AST REWRITE
-				// elements: b
-				// token labels:
-				// rule labels: b, retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"rule b",b!=null?b.tree:null);
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 724:4: -> ^( OPTIONAL[$b.start,\"?\"] $b)
-				{
-					// Grammars\\ANTLR.g3:724:7: ^( OPTIONAL[$b.start,\"?\"] $b)
-					{
-					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(OPTIONAL, (b!=null?((IToken)b.Start):null), "?"), root_1);
-
-					adaptor.AddChild(root_1, stream_b.NextTree());
-
-					adaptor.AddChild(root_0, root_1);
-					}
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:725:5: STAR
-				{
-				STAR176=(IToken)Match(input,STAR,Follow._STAR_in_rewrite_ebnf3162); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_STAR.Add(STAR176);
-
-
-
-				{
-				// AST REWRITE
-				// elements: b
-				// token labels:
-				// rule labels: b, retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"rule b",b!=null?b.tree:null);
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 726:4: -> ^( CLOSURE[$b.start,\"*\"] $b)
-				{
-					// Grammars\\ANTLR.g3:726:7: ^( CLOSURE[$b.start,\"*\"] $b)
-					{
-					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(CLOSURE, (b!=null?((IToken)b.Start):null), "*"), root_1);
-
-					adaptor.AddChild(root_1, stream_b.NextTree());
-
-					adaptor.AddChild(root_0, root_1);
-					}
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-			case 3:
-				// Grammars\\ANTLR.g3:727:5: PLUS
-				{
-				PLUS177=(IToken)Match(input,PLUS,Follow._PLUS_in_rewrite_ebnf3181); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_PLUS.Add(PLUS177);
-
-
-
-				{
-				// AST REWRITE
-				// elements: b
-				// token labels:
-				// rule labels: b, retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"rule b",b!=null?b.tree:null);
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 728:4: -> ^( POSITIVE_CLOSURE[$b.start,\"+\"] $b)
-				{
-					// Grammars\\ANTLR.g3:728:7: ^( POSITIVE_CLOSURE[$b.start,\"+\"] $b)
-					{
-					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(POSITIVE_CLOSURE, (b!=null?((IToken)b.Start):null), "+"), root_1);
-
-					adaptor.AddChild(root_1, stream_b.NextTree());
-
-					adaptor.AddChild(root_0, root_1);
-					}
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-
-			}
-
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "rewrite_ebnf"
-
-	public class rewrite_tree_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "rewrite_tree"
-	// Grammars\\ANTLR.g3:732:0: rewrite_tree : TREE_BEGIN rewrite_atom ( rewrite_element )* RPAREN ;
-	private ANTLRParser.rewrite_tree_return rewrite_tree(  )
-	{
-		ANTLRParser.rewrite_tree_return retval = new ANTLRParser.rewrite_tree_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken TREE_BEGIN178=null;
-		IToken RPAREN181=null;
-		ANTLRParser.rewrite_atom_return rewrite_atom179 = default(ANTLRParser.rewrite_atom_return);
-		ANTLRParser.rewrite_element_return rewrite_element180 = default(ANTLRParser.rewrite_element_return);
-
-		GrammarAST TREE_BEGIN178_tree=null;
-		GrammarAST RPAREN181_tree=null;
-
-		try
-		{
-			// Grammars\\ANTLR.g3:733:4: ( TREE_BEGIN rewrite_atom ( rewrite_element )* RPAREN )
-			// Grammars\\ANTLR.g3:733:4: TREE_BEGIN rewrite_atom ( rewrite_element )* RPAREN
-			{
-			root_0 = (GrammarAST)adaptor.Nil();
-
-			TREE_BEGIN178=(IToken)Match(input,TREE_BEGIN,Follow._TREE_BEGIN_in_rewrite_tree3209); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) {
-			TREE_BEGIN178_tree = (GrammarAST)adaptor.Create(TREE_BEGIN178);
-			root_0 = (GrammarAST)adaptor.BecomeRoot(TREE_BEGIN178_tree, root_0);
-			}
-			PushFollow(Follow._rewrite_atom_in_rewrite_tree3215);
-			rewrite_atom179=rewrite_atom();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) adaptor.AddChild(root_0, rewrite_atom179.Tree);
-			// Grammars\\ANTLR.g3:734:17: ( rewrite_element )*
-			for ( ; ; )
-			{
-				int alt92=2;
-				int LA92_0 = input.LA(1);
-
-				if ( (LA92_0==ACTION||LA92_0==CHAR_LITERAL||LA92_0==DOLLAR||LA92_0==LPAREN||LA92_0==RULE_REF||LA92_0==STRING_LITERAL||LA92_0==TOKEN_REF||LA92_0==TREE_BEGIN) )
-				{
-					alt92=1;
-				}
-
-
-				switch ( alt92 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:734:0: rewrite_element
-					{
-					PushFollow(Follow._rewrite_element_in_rewrite_tree3217);
-					rewrite_element180=rewrite_element();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 ) adaptor.AddChild(root_0, rewrite_element180.Tree);
-
-					}
-					break;
-
-				default:
-					goto loop92;
-				}
-			}
-
-			loop92:
-				;
-
-
-			RPAREN181=(IToken)Match(input,RPAREN,Follow._RPAREN_in_rewrite_tree3222); if (state.failed) return retval;
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "rewrite_tree"
-
-	public class rewrite_template_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "rewrite_template"
-	// Grammars\\ANTLR.g3:750:0: public rewrite_template options {k=1; } : ({...}? => ( rewrite_template_head -> rewrite_template_head ) (st= DOUBLE_QUOTE_STRING_LITERAL |st= DOUBLE_ANGLE_STRING_LITERAL ) | rewrite_template_head | rewrite_indirect_template_head | ACTION );
-	public ANTLRParser.rewrite_template_return rewrite_template(  )
-	{
-		ANTLRParser.rewrite_template_return retval = new ANTLRParser.rewrite_template_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken st=null;
-		IToken ACTION185=null;
-		ANTLRParser.rewrite_template_head_return rewrite_template_head182 = default(ANTLRParser.rewrite_template_head_return);
-		ANTLRParser.rewrite_template_head_return rewrite_template_head183 = default(ANTLRParser.rewrite_template_head_return);
-		ANTLRParser.rewrite_indirect_template_head_return rewrite_indirect_template_head184 = default(ANTLRParser.rewrite_indirect_template_head_return);
-
-		GrammarAST st_tree=null;
-		GrammarAST ACTION185_tree=null;
-		RewriteRuleITokenStream stream_DOUBLE_QUOTE_STRING_LITERAL=new RewriteRuleITokenStream(adaptor,"token DOUBLE_QUOTE_STRING_LITERAL");
-		RewriteRuleITokenStream stream_DOUBLE_ANGLE_STRING_LITERAL=new RewriteRuleITokenStream(adaptor,"token DOUBLE_ANGLE_STRING_LITERAL");
-		RewriteRuleSubtreeStream stream_rewrite_template_head=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_template_head");
-		try
-		{
-			// Grammars\\ANTLR.g3:753:3: ({...}? => ( rewrite_template_head -> rewrite_template_head ) (st= DOUBLE_QUOTE_STRING_LITERAL |st= DOUBLE_ANGLE_STRING_LITERAL ) | rewrite_template_head | rewrite_indirect_template_head | ACTION )
-			int alt94=4;
-			switch ( input.LA(1) )
-			{
-			case TOKEN_REF:
-				{
-				int LA94_1 = input.LA(2);
-
-				if ( ((LT(1).Text.Equals("template"))) )
-				{
-					alt94=1;
-				}
-				else if ( (true) )
-				{
-					alt94=2;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 94, 1, input);
-
-					throw nvae;
-				}
-				}
-				break;
-			case RULE_REF:
-				{
-				int LA94_2 = input.LA(2);
-
-				if ( ((LT(1).Text.Equals("template"))) )
-				{
-					alt94=1;
-				}
-				else if ( (true) )
-				{
-					alt94=2;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 94, 2, input);
-
-					throw nvae;
-				}
-				}
-				break;
-			case LPAREN:
-				{
-				alt94=3;
-				}
-				break;
-			case ACTION:
-				{
-				alt94=4;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 94, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt94 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:753:3: {...}? => ( rewrite_template_head -> rewrite_template_head ) (st= DOUBLE_QUOTE_STRING_LITERAL |st= DOUBLE_ANGLE_STRING_LITERAL )
-				{
-				if ( !((LT(1).Text.Equals("template"))) )
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					throw new FailedPredicateException(input, "rewrite_template", "LT(1).Text.Equals(\"template\")");
-				}
-				// Grammars\\ANTLR.g3:754:3: ( rewrite_template_head -> rewrite_template_head )
-				// Grammars\\ANTLR.g3:754:5: rewrite_template_head
-				{
-				PushFollow(Follow._rewrite_template_head_in_rewrite_template3257);
-				rewrite_template_head182=rewrite_template_head();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_rewrite_template_head.Add(rewrite_template_head182.Tree);
-
-
-				{
-				// AST REWRITE
-				// elements: rewrite_template_head
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 755:4: -> rewrite_template_head
-				{
-					adaptor.AddChild(root_0, stream_rewrite_template_head.NextTree());
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-
-				// Grammars\\ANTLR.g3:757:3: (st= DOUBLE_QUOTE_STRING_LITERAL |st= DOUBLE_ANGLE_STRING_LITERAL )
-				int alt93=2;
-				int LA93_0 = input.LA(1);
-
-				if ( (LA93_0==DOUBLE_QUOTE_STRING_LITERAL) )
-				{
-					alt93=1;
-				}
-				else if ( (LA93_0==DOUBLE_ANGLE_STRING_LITERAL) )
-				{
-					alt93=2;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 93, 0, input);
-
-					throw nvae;
-				}
-				switch ( alt93 )
-				{
-				case 1:
-					// Grammars\\ANTLR.g3:757:5: st= DOUBLE_QUOTE_STRING_LITERAL
-					{
-					st=(IToken)Match(input,DOUBLE_QUOTE_STRING_LITERAL,Follow._DOUBLE_QUOTE_STRING_LITERAL_in_rewrite_template3276); if (state.failed) return retval;
-					if ( state.backtracking == 0 ) stream_DOUBLE_QUOTE_STRING_LITERAL.Add(st);
-
-
-					}
-					break;
-				case 2:
-					// Grammars\\ANTLR.g3:757:38: st= DOUBLE_ANGLE_STRING_LITERAL
-					{
-					st=(IToken)Match(input,DOUBLE_ANGLE_STRING_LITERAL,Follow._DOUBLE_ANGLE_STRING_LITERAL_in_rewrite_template3282); if (state.failed) return retval;
-					if ( state.backtracking == 0 ) stream_DOUBLE_ANGLE_STRING_LITERAL.Add(st);
-
-
-					}
-					break;
-
-				}
-
-				if ( state.backtracking == 0 )
-				{
-					 adaptor.AddChild( ((GrammarAST)retval.Tree).GetChild(0), adaptor.Create(st) );
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:761:3: rewrite_template_head
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				PushFollow(Follow._rewrite_template_head_in_rewrite_template3297);
-				rewrite_template_head183=rewrite_template_head();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, rewrite_template_head183.Tree);
-
-				}
-				break;
-			case 3:
-				// Grammars\\ANTLR.g3:764:3: rewrite_indirect_template_head
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				PushFollow(Follow._rewrite_indirect_template_head_in_rewrite_template3306);
-				rewrite_indirect_template_head184=rewrite_indirect_template_head();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, rewrite_indirect_template_head184.Tree);
-
-				}
-				break;
-			case 4:
-				// Grammars\\ANTLR.g3:767:3: ACTION
-				{
-				root_0 = (GrammarAST)adaptor.Nil();
-
-				ACTION185=(IToken)Match(input,ACTION,Follow._ACTION_in_rewrite_template3315); if (state.failed) return retval;
-				if ( state.backtracking==0 ) {
-				ACTION185_tree = (GrammarAST)adaptor.Create(ACTION185);
-				adaptor.AddChild(root_0, ACTION185_tree);
-				}
-
-				}
-				break;
-
-			}
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "rewrite_template"
-
-	public class rewrite_template_head_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "rewrite_template_head"
-	// Grammars\\ANTLR.g3:771:0: rewrite_template_head : id lp= LPAREN rewrite_template_args RPAREN -> ^( TEMPLATE[$lp,\"TEMPLATE\"] id rewrite_template_args ) ;
-	private ANTLRParser.rewrite_template_head_return rewrite_template_head(  )
-	{
-		ANTLRParser.rewrite_template_head_return retval = new ANTLRParser.rewrite_template_head_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken lp=null;
-		IToken RPAREN188=null;
-		ANTLRParser.id_return id186 = default(ANTLRParser.id_return);
-		ANTLRParser.rewrite_template_args_return rewrite_template_args187 = default(ANTLRParser.rewrite_template_args_return);
-
-		GrammarAST lp_tree=null;
-		GrammarAST RPAREN188_tree=null;
-		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
-		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
-		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
-		RewriteRuleSubtreeStream stream_rewrite_template_args=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_template_args");
-		try
-		{
-			// Grammars\\ANTLR.g3:772:4: ( id lp= LPAREN rewrite_template_args RPAREN -> ^( TEMPLATE[$lp,\"TEMPLATE\"] id rewrite_template_args ) )
-			// Grammars\\ANTLR.g3:772:4: id lp= LPAREN rewrite_template_args RPAREN
-			{
-			PushFollow(Follow._id_in_rewrite_template_head3328);
-			id186=id();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_id.Add(id186.Tree);
-			lp=(IToken)Match(input,LPAREN,Follow._LPAREN_in_rewrite_template_head3332); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_LPAREN.Add(lp);
-
-			PushFollow(Follow._rewrite_template_args_in_rewrite_template_head3336);
-			rewrite_template_args187=rewrite_template_args();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_rewrite_template_args.Add(rewrite_template_args187.Tree);
-			RPAREN188=(IToken)Match(input,RPAREN,Follow._RPAREN_in_rewrite_template_head3340); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_RPAREN.Add(RPAREN188);
-
-
-
-			{
-			// AST REWRITE
-			// elements: id, rewrite_template_args
-			// token labels:
-			// rule labels: retval
-			// token list labels:
-			// rule list labels:
-			// wildcard labels:
-			if ( state.backtracking == 0 ) {
-			retval.tree = root_0;
-			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-			root_0 = (GrammarAST)adaptor.Nil();
-			// 775:3: -> ^( TEMPLATE[$lp,\"TEMPLATE\"] id rewrite_template_args )
-			{
-				// Grammars\\ANTLR.g3:775:6: ^( TEMPLATE[$lp,\"TEMPLATE\"] id rewrite_template_args )
-				{
-				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-				root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(TEMPLATE, lp, "TEMPLATE"), root_1);
-
-				adaptor.AddChild(root_1, stream_id.NextTree());
-				adaptor.AddChild(root_1, stream_rewrite_template_args.NextTree());
-
-				adaptor.AddChild(root_0, root_1);
-				}
-
-			}
-
-			retval.tree = root_0;
-			}
-			}
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "rewrite_template_head"
-
-	public class rewrite_indirect_template_head_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "rewrite_indirect_template_head"
-	// Grammars\\ANTLR.g3:779:0: rewrite_indirect_template_head : lp= LPAREN ACTION RPAREN LPAREN rewrite_template_args RPAREN -> ^( TEMPLATE[$lp,\"TEMPLATE\"] ACTION rewrite_template_args ) ;
-	private ANTLRParser.rewrite_indirect_template_head_return rewrite_indirect_template_head(  )
-	{
-		ANTLRParser.rewrite_indirect_template_head_return retval = new ANTLRParser.rewrite_indirect_template_head_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken lp=null;
-		IToken ACTION189=null;
-		IToken RPAREN190=null;
-		IToken LPAREN191=null;
-		IToken RPAREN193=null;
-		ANTLRParser.rewrite_template_args_return rewrite_template_args192 = default(ANTLRParser.rewrite_template_args_return);
-
-		GrammarAST lp_tree=null;
-		GrammarAST ACTION189_tree=null;
-		GrammarAST RPAREN190_tree=null;
-		GrammarAST LPAREN191_tree=null;
-		GrammarAST RPAREN193_tree=null;
-		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
-		RewriteRuleITokenStream stream_ACTION=new RewriteRuleITokenStream(adaptor,"token ACTION");
-		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
-		RewriteRuleSubtreeStream stream_rewrite_template_args=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_template_args");
-		try
-		{
-			// Grammars\\ANTLR.g3:780:4: (lp= LPAREN ACTION RPAREN LPAREN rewrite_template_args RPAREN -> ^( TEMPLATE[$lp,\"TEMPLATE\"] ACTION rewrite_template_args ) )
-			// Grammars\\ANTLR.g3:780:4: lp= LPAREN ACTION RPAREN LPAREN rewrite_template_args RPAREN
-			{
-			lp=(IToken)Match(input,LPAREN,Follow._LPAREN_in_rewrite_indirect_template_head3368); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_LPAREN.Add(lp);
-
-			ACTION189=(IToken)Match(input,ACTION,Follow._ACTION_in_rewrite_indirect_template_head3372); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_ACTION.Add(ACTION189);
-
-			RPAREN190=(IToken)Match(input,RPAREN,Follow._RPAREN_in_rewrite_indirect_template_head3376); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_RPAREN.Add(RPAREN190);
-
-			LPAREN191=(IToken)Match(input,LPAREN,Follow._LPAREN_in_rewrite_indirect_template_head3380); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_LPAREN.Add(LPAREN191);
-
-			PushFollow(Follow._rewrite_template_args_in_rewrite_indirect_template_head3382);
-			rewrite_template_args192=rewrite_template_args();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_rewrite_template_args.Add(rewrite_template_args192.Tree);
-			RPAREN193=(IToken)Match(input,RPAREN,Follow._RPAREN_in_rewrite_indirect_template_head3384); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_RPAREN.Add(RPAREN193);
-
-
-
-			{
-			// AST REWRITE
-			// elements: ACTION, rewrite_template_args
-			// token labels:
-			// rule labels: retval
-			// token list labels:
-			// rule list labels:
-			// wildcard labels:
-			if ( state.backtracking == 0 ) {
-			retval.tree = root_0;
-			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-			root_0 = (GrammarAST)adaptor.Nil();
-			// 784:3: -> ^( TEMPLATE[$lp,\"TEMPLATE\"] ACTION rewrite_template_args )
-			{
-				// Grammars\\ANTLR.g3:784:6: ^( TEMPLATE[$lp,\"TEMPLATE\"] ACTION rewrite_template_args )
-				{
-				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-				root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(TEMPLATE, lp, "TEMPLATE"), root_1);
-
-				adaptor.AddChild(root_1, stream_ACTION.NextNode());
-				adaptor.AddChild(root_1, stream_rewrite_template_args.NextTree());
-
-				adaptor.AddChild(root_0, root_1);
-				}
-
-			}
-
-			retval.tree = root_0;
-			}
-			}
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "rewrite_indirect_template_head"
-
-	public class rewrite_template_args_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "rewrite_template_args"
-	// Grammars\\ANTLR.g3:787:0: rewrite_template_args : ( rewrite_template_arg ( COMMA rewrite_template_arg )* -> ^( ARGLIST[\"ARGLIST\"] ( rewrite_template_arg )+ ) | -> ARGLIST[\"ARGLIST\"] );
-	private ANTLRParser.rewrite_template_args_return rewrite_template_args(  )
-	{
-		ANTLRParser.rewrite_template_args_return retval = new ANTLRParser.rewrite_template_args_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken COMMA195=null;
-		ANTLRParser.rewrite_template_arg_return rewrite_template_arg194 = default(ANTLRParser.rewrite_template_arg_return);
-		ANTLRParser.rewrite_template_arg_return rewrite_template_arg196 = default(ANTLRParser.rewrite_template_arg_return);
-
-		GrammarAST COMMA195_tree=null;
-		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
-		RewriteRuleSubtreeStream stream_rewrite_template_arg=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_template_arg");
-		try
-		{
-			// Grammars\\ANTLR.g3:788:4: ( rewrite_template_arg ( COMMA rewrite_template_arg )* -> ^( ARGLIST[\"ARGLIST\"] ( rewrite_template_arg )+ ) | -> ARGLIST[\"ARGLIST\"] )
-			int alt96=2;
-			int LA96_0 = input.LA(1);
-
-			if ( (LA96_0==RULE_REF||LA96_0==TOKEN_REF) )
-			{
-				alt96=1;
-			}
-			else if ( (LA96_0==RPAREN) )
-			{
-				alt96=2;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return retval;}
-				NoViableAltException nvae = new NoViableAltException("", 96, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt96 )
-			{
-			case 1:
-				// Grammars\\ANTLR.g3:788:4: rewrite_template_arg ( COMMA rewrite_template_arg )*
-				{
-				PushFollow(Follow._rewrite_template_arg_in_rewrite_template_args3408);
-				rewrite_template_arg194=rewrite_template_arg();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_rewrite_template_arg.Add(rewrite_template_arg194.Tree);
-				// Grammars\\ANTLR.g3:788:25: ( COMMA rewrite_template_arg )*
-				for ( ; ; )
-				{
-					int alt95=2;
-					int LA95_0 = input.LA(1);
-
-					if ( (LA95_0==COMMA) )
-					{
-						alt95=1;
-					}
-
-
-					switch ( alt95 )
-					{
-					case 1:
-						// Grammars\\ANTLR.g3:788:26: COMMA rewrite_template_arg
-						{
-						COMMA195=(IToken)Match(input,COMMA,Follow._COMMA_in_rewrite_template_args3411); if (state.failed) return retval;
-						if ( state.backtracking == 0 ) stream_COMMA.Add(COMMA195);
-
-						PushFollow(Follow._rewrite_template_arg_in_rewrite_template_args3413);
-						rewrite_template_arg196=rewrite_template_arg();
-
-						state._fsp--;
-						if (state.failed) return retval;
-						if ( state.backtracking == 0 ) stream_rewrite_template_arg.Add(rewrite_template_arg196.Tree);
-
-						}
-						break;
-
-					default:
-						goto loop95;
-					}
-				}
-
-				loop95:
-					;
-
-
-
-
-				{
-				// AST REWRITE
-				// elements: rewrite_template_arg
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 789:3: -> ^( ARGLIST[\"ARGLIST\"] ( rewrite_template_arg )+ )
-				{
-					// Grammars\\ANTLR.g3:789:6: ^( ARGLIST[\"ARGLIST\"] ( rewrite_template_arg )+ )
-					{
-					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(ARGLIST, "ARGLIST"), root_1);
-
-					if ( !(stream_rewrite_template_arg.HasNext) )
-					{
-						throw new RewriteEarlyExitException();
-					}
-					while ( stream_rewrite_template_arg.HasNext )
-					{
-						adaptor.AddChild(root_1, stream_rewrite_template_arg.NextTree());
-
-					}
-					stream_rewrite_template_arg.Reset();
-
-					adaptor.AddChild(root_0, root_1);
-					}
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:791:3:
-				{
-
-
-
-				{
-				// AST REWRITE
-				// elements:
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (GrammarAST)adaptor.Nil();
-				// 791:3: -> ARGLIST[\"ARGLIST\"]
-				{
-					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(ARGLIST, "ARGLIST"));
-
-				}
-
-				retval.tree = root_0;
-				}
-				}
-
-				}
-				break;
-
-			}
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "rewrite_template_args"
-
-	public class rewrite_template_arg_return : ParserRuleReturnScope
-	{
-		internal GrammarAST tree;
-		public override object Tree { get { return tree; } }
-	}
-
-	// $ANTLR start "rewrite_template_arg"
-	// Grammars\\ANTLR.g3:794:0: rewrite_template_arg : id a= ASSIGN ACTION -> ^( ARG[$a,\"ARG\"] id ACTION ) ;
-	private ANTLRParser.rewrite_template_arg_return rewrite_template_arg(  )
-	{
-		ANTLRParser.rewrite_template_arg_return retval = new ANTLRParser.rewrite_template_arg_return();
-		retval.start = input.LT(1);
-
-		GrammarAST root_0 = null;
-
-		IToken a=null;
-		IToken ACTION198=null;
-		ANTLRParser.id_return id197 = default(ANTLRParser.id_return);
-
-		GrammarAST a_tree=null;
-		GrammarAST ACTION198_tree=null;
-		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
-		RewriteRuleITokenStream stream_ACTION=new RewriteRuleITokenStream(adaptor,"token ACTION");
-		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
-		try
-		{
-			// Grammars\\ANTLR.g3:795:4: ( id a= ASSIGN ACTION -> ^( ARG[$a,\"ARG\"] id ACTION ) )
-			// Grammars\\ANTLR.g3:795:4: id a= ASSIGN ACTION
-			{
-			PushFollow(Follow._id_in_rewrite_template_arg3448);
-			id197=id();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_id.Add(id197.Tree);
-			a=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_rewrite_template_arg3452); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_ASSIGN.Add(a);
-
-			ACTION198=(IToken)Match(input,ACTION,Follow._ACTION_in_rewrite_template_arg3454); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_ACTION.Add(ACTION198);
-
-
-
-			{
-			// AST REWRITE
-			// elements: id, ACTION
-			// token labels:
-			// rule labels: retval
-			// token list labels:
-			// rule list labels:
-			// wildcard labels:
-			if ( state.backtracking == 0 ) {
-			retval.tree = root_0;
-			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-			root_0 = (GrammarAST)adaptor.Nil();
-			// 796:3: -> ^( ARG[$a,\"ARG\"] id ACTION )
-			{
-				// Grammars\\ANTLR.g3:796:6: ^( ARG[$a,\"ARG\"] id ACTION )
-				{
-				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-				root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(ARG, a, "ARG"), root_1);
-
-				adaptor.AddChild(root_1, stream_id.NextTree());
-				adaptor.AddChild(root_1, stream_ACTION.NextNode());
-
-				adaptor.AddChild(root_0, root_1);
-				}
-
-			}
-
-			retval.tree = root_0;
-			}
-			}
-
-			}
-
-			retval.stop = input.LT(-1);
-
-			if ( state.backtracking == 0 ) {
-
-			retval.tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
-			adaptor.SetTokenBoundaries(retval.tree, retval.start, retval.stop);
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		retval.tree = (GrammarAST)adaptor.ErrorNode(input, retval.start, input.LT(-1), re);
-
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "rewrite_template_arg"
-
-	// $ANTLR start synpred1_ANTLR
-	public void synpred1_ANTLR_fragment()
-	{
-		// Grammars\\ANTLR.g3:495:4: ({...}? id WILDCARD ( terminal | ruleref ) )
-		// Grammars\\ANTLR.g3:495:5: {...}? id WILDCARD ( terminal | ruleref )
-		{
-		if ( !((LT(1).CharPositionInLine+LT(1).Text.Length==LT(2).CharPositionInLine&&
-					 LT(2).CharPositionInLine+1==LT(3).CharPositionInLine)) )
-		{
-			if (state.backtracking>0) {state.failed=true; return ;}
-			throw new FailedPredicateException(input, "synpred1_ANTLR", "LT(1).CharPositionInLine+LT(1).Text.Length==LT(2).CharPositionInLine&&\r\n\t\t\t LT(2).CharPositionInLine+1==LT(3).CharPositionInLine");
-		}
-		PushFollow(Follow._id_in_synpred1_ANTLR1909);
-		id();
-
-		state._fsp--;
-		if (state.failed) return ;
-		Match(input,WILDCARD,Follow._WILDCARD_in_synpred1_ANTLR1911); if (state.failed) return ;
-		// Grammars\\ANTLR.g3:496:72: ( terminal | ruleref )
-		int alt97=2;
-		int LA97_0 = input.LA(1);
-
-		if ( (LA97_0==CHAR_LITERAL||LA97_0==STRING_LITERAL||LA97_0==TOKEN_REF||LA97_0==WILDCARD) )
-		{
-			alt97=1;
-		}
-		else if ( (LA97_0==RULE_REF) )
-		{
-			alt97=2;
-		}
-		else
-		{
-			if (state.backtracking>0) {state.failed=true; return ;}
-			NoViableAltException nvae = new NoViableAltException("", 97, 0, input);
-
-			throw nvae;
-		}
-		switch ( alt97 )
-		{
-		case 1:
-			// Grammars\\ANTLR.g3:496:73: terminal
-			{
-			PushFollow(Follow._terminal_in_synpred1_ANTLR1914);
-			terminal();
-
-			state._fsp--;
-			if (state.failed) return ;
-
-			}
-			break;
-		case 2:
-			// Grammars\\ANTLR.g3:496:82: ruleref
-			{
-			PushFollow(Follow._ruleref_in_synpred1_ANTLR1916);
-			ruleref();
-
-			state._fsp--;
-			if (state.failed) return ;
-
-			}
-			break;
-
-		}
-
-
-		}
-	}
-	// $ANTLR end synpred1_ANTLR
-	#endregion Rules
-
-	#region Synpreds
-	bool EvaluatePredicate( System.Action fragment )
-	{
-		state.backtracking++;
-		int start = input.Mark();
-		try
-		{
-			fragment();
-		}
-		catch ( RecognitionException re )
-		{
-			System.Console.Error.WriteLine("impossible: "+re);
-		}
-		bool success = !state.failed;
-		input.Rewind(start);
-		state.backtracking--;
-		state.failed=false;
-		return success;
-	}
-	#endregion Synpreds
-
-
-	#region DFA
-	DFA49 dfa49;
-	DFA52 dfa52;
-	DFA82 dfa82;
-
-	protected override void InitDFAs()
-	{
-		base.InitDFAs();
-		dfa49 = new DFA49( this );
-		dfa52 = new DFA52( this, new SpecialStateTransitionHandler( specialStateTransition52 ) );
-		dfa82 = new DFA82( this, new SpecialStateTransitionHandler( specialStateTransition82 ) );
-	}
-
-	class DFA49 : DFA
-	{
-
-		const string DFA49_eotS =
-			"\xA\xFFFF";
-		const string DFA49_eofS =
-			"\xA\xFFFF";
-		const string DFA49_minS =
-			"\x3\x4\x7\xFFFF";
-		const string DFA49_maxS =
-			"\x3\x5F\x7\xFFFF";
-		const string DFA49_acceptS =
-			"\x3\xFFFF\x1\x2\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x1";
-		const string DFA49_specialS =
-			"\xA\xFFFF}>";
-		static readonly string[] DFA49_transitionS =
-			{
-				"\x1\x6\xD\xFFFF\x1\x3\x14\xFFFF\x1\x5\xB\xFFFF\x1\x4\x3\xFFFF\x1\x3"+
-				"\x15\xFFFF\x1\x2\x2\xFFFF\x1\x7\x4\xFFFF\x1\x3\x4\xFFFF\x1\x1\x2\xFFFF"+
-				"\x1\x8\x1\xFFFF\x1\x3",
-				"\x1\x3\x6\xFFFF\x1\x3\x1\xFFFF\x1\x9\x1\xFFFF\x1\x3\x2\xFFFF\x1\x3\x14"+
-				"\xFFFF\x1\x3\xB\xFFFF\x1\x3\x3\xFFFF\x2\x3\x2\xFFFF\x1\x3\x2\xFFFF\x1"+
-				"\x3\x1\x9\x4\xFFFF\x1\x3\x4\xFFFF\x3\x3\x1\xFFFF\x1\x3\x1\xFFFF\x2\x3"+
-				"\x2\xFFFF\x1\x3\x1\xFFFF\x1\x3\x4\xFFFF\x1\x3\x2\xFFFF\x1\x3\x1\xFFFF"+
-				"\x1\x3",
-				"\x1\x3\x6\xFFFF\x1\x3\x1\xFFFF\x1\x9\x1\xFFFF\x1\x3\x2\xFFFF\x1\x3\x14"+
-				"\xFFFF\x1\x3\xB\xFFFF\x1\x3\x3\xFFFF\x1\x3\x3\xFFFF\x1\x3\x2\xFFFF\x1"+
-				"\x3\x1\x9\x4\xFFFF\x1\x3\x4\xFFFF\x3\x3\x1\xFFFF\x1\x3\x1\xFFFF\x2\x3"+
-				"\x2\xFFFF\x1\x3\x1\xFFFF\x1\x3\x4\xFFFF\x1\x3\x2\xFFFF\x1\x3\x1\xFFFF"+
-				"\x1\x3",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				""
-			};
-
-		static readonly short[] DFA49_eot = DFA.UnpackEncodedString(DFA49_eotS);
-		static readonly short[] DFA49_eof = DFA.UnpackEncodedString(DFA49_eofS);
-		static readonly char[] DFA49_min = DFA.UnpackEncodedStringToUnsignedChars(DFA49_minS);
-		static readonly char[] DFA49_max = DFA.UnpackEncodedStringToUnsignedChars(DFA49_maxS);
-		static readonly short[] DFA49_accept = DFA.UnpackEncodedString(DFA49_acceptS);
-		static readonly short[] DFA49_special = DFA.UnpackEncodedString(DFA49_specialS);
-		static readonly short[][] DFA49_transition;
-
-		static DFA49()
-		{
-			int numStates = DFA49_transitionS.Length;
-			DFA49_transition = new short[numStates][];
-			for ( int i=0; i < numStates; i++ )
-			{
-				DFA49_transition[i] = DFA.UnpackEncodedString(DFA49_transitionS[i]);
-			}
-		}
-
-		public DFA49( BaseRecognizer recognizer )
-		{
-			this.recognizer = recognizer;
-			this.decisionNumber = 49;
-			this.eot = DFA49_eot;
-			this.eof = DFA49_eof;
-			this.min = DFA49_min;
-			this.max = DFA49_max;
-			this.accept = DFA49_accept;
-			this.special = DFA49_special;
-			this.transition = DFA49_transition;
-		}
-		public override string GetDescription()
-		{
-			return "472:4: ( ( id ( ASSIGN | PLUS_ASSIGN ) ( atom | block ) ) (sub= ebnfSuffix[root_0,false] )? |a= atom (sub2= ebnfSuffix[$a.tree,false] )? | ebnf | FORCED_ACTION | ACTION |p= SEMPRED ( IMPLIES )? |t3= tree_ )";
-		}
-	}
-
-	class DFA52 : DFA
-	{
-
-		const string DFA52_eotS =
-			"\x12\xFFFF";
-		const string DFA52_eofS =
-			"\x12\xFFFF";
-		const string DFA52_minS =
-			"\x1\x12\x2\x4\x1\xFFFF\x2\x4\x1\xFFFF\xA\x0\x1\xFFFF";
-		const string DFA52_maxS =
-			"\x3\x5F\x1\xFFFF\x2\x5F\x1\xFFFF\xA\x0\x1\xFFFF";
-		const string DFA52_acceptS =
-			"\x3\xFFFF\x1\x2\x2\xFFFF\x1\x3\xA\xFFFF\x1\x1";
-		const string DFA52_specialS =
-			"\x7\xFFFF\x1\x0\x1\x1\x1\x2\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9"+
-			"\x1\xFFFF}>";
-		static readonly string[] DFA52_transitionS =
-			{
-				"\x1\x3\x3A\xFFFF\x1\x2\x7\xFFFF\x1\x3\x4\xFFFF\x1\x1\x4\xFFFF\x1\x3",
-				"\x1\x3\x6\xFFFF\x1\x3\x3\xFFFF\x1\x3\x2\xFFFF\x1\x3\x14\xFFFF\x1\x3"+
-				"\xB\xFFFF\x1\x3\x3\xFFFF\x2\x3\x2\xFFFF\x1\x3\x2\xFFFF\x1\x3\x5\xFFFF"+
-				"\x1\x3\x4\xFFFF\x3\x3\x1\xFFFF\x1\x3\x1\xFFFF\x2\x3\x2\xFFFF\x1\x3\x1"+
-				"\xFFFF\x1\x3\x4\xFFFF\x1\x3\x2\xFFFF\x1\x3\x1\xFFFF\x1\x4",
-				"\x1\x6\x6\xFFFF\x1\x6\x3\xFFFF\x1\x6\x2\xFFFF\x1\x6\x14\xFFFF\x1\x6"+
-				"\xB\xFFFF\x1\x6\x3\xFFFF\x1\x6\x3\xFFFF\x1\x6\x2\xFFFF\x1\x6\x5\xFFFF"+
-				"\x1\x6\x4\xFFFF\x3\x6\x1\xFFFF\x1\x6\x1\xFFFF\x2\x6\x2\xFFFF\x1\x6\x1"+
-				"\xFFFF\x1\x6\x4\xFFFF\x1\x6\x2\xFFFF\x1\x6\x1\xFFFF\x1\x5",
-				"",
-				"\x1\x3\xA\xFFFF\x1\x3\x2\xFFFF\x1\x7\x14\xFFFF\x1\x3\xB\xFFFF\x1\x3"+
-				"\x3\xFFFF\x1\x3\x3\xFFFF\x1\x3\x2\xFFFF\x1\x3\x5\xFFFF\x1\x3\x4\xFFFF"+
-				"\x3\x3\x1\xFFFF\x1\xB\x1\xFFFF\x2\x3\x2\xFFFF\x1\x3\x1\xFFFF\x1\x9\x4"+
-				"\xFFFF\x1\x8\x2\xFFFF\x1\x3\x1\xFFFF\x1\xA",
-				"\x1\x6\xA\xFFFF\x1\x6\x2\xFFFF\x1\xC\x14\xFFFF\x1\x6\xB\xFFFF\x1\x6"+
-				"\x3\xFFFF\x1\x6\x3\xFFFF\x1\x6\x2\xFFFF\x1\x6\x5\xFFFF\x1\x6\x4\xFFFF"+
-				"\x3\x6\x1\xFFFF\x1\x10\x1\xFFFF\x2\x6\x2\xFFFF\x1\x6\x1\xFFFF\x1\xE"+
-				"\x4\xFFFF\x1\xD\x2\xFFFF\x1\x6\x1\xFFFF\x1\xF",
-				"",
-				"\x1\xFFFF",
-				"\x1\xFFFF",
-				"\x1\xFFFF",
-				"\x1\xFFFF",
-				"\x1\xFFFF",
-				"\x1\xFFFF",
-				"\x1\xFFFF",
-				"\x1\xFFFF",
-				"\x1\xFFFF",
-				"\x1\xFFFF",
-				""
-			};
-
-		static readonly short[] DFA52_eot = DFA.UnpackEncodedString(DFA52_eotS);
-		static readonly short[] DFA52_eof = DFA.UnpackEncodedString(DFA52_eofS);
-		static readonly char[] DFA52_min = DFA.UnpackEncodedStringToUnsignedChars(DFA52_minS);
-		static readonly char[] DFA52_max = DFA.UnpackEncodedStringToUnsignedChars(DFA52_maxS);
-		static readonly short[] DFA52_accept = DFA.UnpackEncodedString(DFA52_acceptS);
-		static readonly short[] DFA52_special = DFA.UnpackEncodedString(DFA52_specialS);
-		static readonly short[][] DFA52_transition;
-
-		static DFA52()
-		{
-			int numStates = DFA52_transitionS.Length;
-			DFA52_transition = new short[numStates][];
-			for ( int i=0; i < numStates; i++ )
-			{
-				DFA52_transition[i] = DFA.UnpackEncodedString(DFA52_transitionS[i]);
-			}
-		}
-
-		public DFA52( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
-			: base( specialStateTransition )	{
-			this.recognizer = recognizer;
-			this.decisionNumber = 52;
-			this.eot = DFA52_eot;
-			this.eof = DFA52_eof;
-			this.min = DFA52_min;
-			this.max = DFA52_max;
-			this.accept = DFA52_accept;
-			this.special = DFA52_special;
-			this.transition = DFA52_transition;
-		}
-		public override string GetDescription()
-		{
-			return "492:4: (=> id w= WILDCARD ( terminal | ruleref ) | terminal | ruleref )";
-		}
-	}
-
-	int specialStateTransition52( DFA dfa, int s, IIntStream _input )
-	{
-		ITokenStream input = (ITokenStream)_input;
-		int _s = s;
-		switch ( s )
-		{
-			case 0:
-				int LA52_7 = input.LA(1);
-
-
-				int index52_7 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (EvaluatePredicate(synpred1_ANTLR_fragment)) ) {s = 17;}
-
-				else if ( (true) ) {s = 3;}
-
-
-				input.Seek(index52_7);
-				if ( s>=0 ) return s;
-				break;
-			case 1:
-				int LA52_8 = input.LA(1);
-
-
-				int index52_8 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (EvaluatePredicate(synpred1_ANTLR_fragment)) ) {s = 17;}
-
-				else if ( (true) ) {s = 3;}
-
-
-				input.Seek(index52_8);
-				if ( s>=0 ) return s;
-				break;
-			case 2:
-				int LA52_9 = input.LA(1);
-
-
-				int index52_9 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (EvaluatePredicate(synpred1_ANTLR_fragment)) ) {s = 17;}
-
-				else if ( (true) ) {s = 3;}
-
-
-				input.Seek(index52_9);
-				if ( s>=0 ) return s;
-				break;
-			case 3:
-				int LA52_10 = input.LA(1);
-
-
-				int index52_10 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (EvaluatePredicate(synpred1_ANTLR_fragment)) ) {s = 17;}
-
-				else if ( (true) ) {s = 3;}
-
-
-				input.Seek(index52_10);
-				if ( s>=0 ) return s;
-				break;
-			case 4:
-				int LA52_11 = input.LA(1);
-
-
-				int index52_11 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (EvaluatePredicate(synpred1_ANTLR_fragment)) ) {s = 17;}
-
-				else if ( (true) ) {s = 3;}
-
-
-				input.Seek(index52_11);
-				if ( s>=0 ) return s;
-				break;
-			case 5:
-				int LA52_12 = input.LA(1);
-
-
-				int index52_12 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (EvaluatePredicate(synpred1_ANTLR_fragment)) ) {s = 17;}
-
-				else if ( (true) ) {s = 6;}
-
-
-				input.Seek(index52_12);
-				if ( s>=0 ) return s;
-				break;
-			case 6:
-				int LA52_13 = input.LA(1);
-
-
-				int index52_13 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (EvaluatePredicate(synpred1_ANTLR_fragment)) ) {s = 17;}
-
-				else if ( (true) ) {s = 6;}
-
-
-				input.Seek(index52_13);
-				if ( s>=0 ) return s;
-				break;
-			case 7:
-				int LA52_14 = input.LA(1);
-
-
-				int index52_14 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (EvaluatePredicate(synpred1_ANTLR_fragment)) ) {s = 17;}
-
-				else if ( (true) ) {s = 6;}
-
-
-				input.Seek(index52_14);
-				if ( s>=0 ) return s;
-				break;
-			case 8:
-				int LA52_15 = input.LA(1);
-
-
-				int index52_15 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (EvaluatePredicate(synpred1_ANTLR_fragment)) ) {s = 17;}
-
-				else if ( (true) ) {s = 6;}
-
-
-				input.Seek(index52_15);
-				if ( s>=0 ) return s;
-				break;
-			case 9:
-				int LA52_16 = input.LA(1);
-
-
-				int index52_16 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (EvaluatePredicate(synpred1_ANTLR_fragment)) ) {s = 17;}
-
-				else if ( (true) ) {s = 6;}
-
-
-				input.Seek(index52_16);
-				if ( s>=0 ) return s;
-				break;
-		}
-		if (state.backtracking>0) {state.failed=true; return -1;}
-		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 52, _s, input);
-		dfa.Error(nvae);
-		throw nvae;
-	}
-	class DFA82 : DFA
-	{
-
-		const string DFA82_eotS =
-			"\xF\xFFFF";
-		const string DFA82_eofS =
-			"\xF\xFFFF";
-		const string DFA82_minS =
-			"\x1\x4\x4\x0\xA\xFFFF";
-		const string DFA82_maxS =
-			"\x1\x5D\x4\x0\xA\xFFFF";
-		const string DFA82_acceptS =
-			"\x5\xFFFF\x1\x2\x3\xFFFF\x1\x3\x3\xFFFF\x1\x4\x1\x1";
-		const string DFA82_specialS =
-			"\x1\x0\x1\x1\x1\x2\x1\x3\x1\x4\xA\xFFFF}>";
-		static readonly string[] DFA82_transitionS =
-			{
-				"\x1\x4\xD\xFFFF\x1\x5\x9\xFFFF\x1\x5\x8\xFFFF\x1\xD\xD\xFFFF\x1\x3\x7"+
-				"\xFFFF\x1\x9\xD\xFFFF\x1\x9\x1\xFFFF\x1\x9\x1\xFFFF\x1\x2\x1\xFFFF\x1"+
-				"\x9\x5\xFFFF\x1\x5\x4\xFFFF\x1\x1\x2\xFFFF\x1\x5",
-				"\x1\xFFFF",
-				"\x1\xFFFF",
-				"\x1\xFFFF",
-				"\x1\xFFFF",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				""
-			};
-
-		static readonly short[] DFA82_eot = DFA.UnpackEncodedString(DFA82_eotS);
-		static readonly short[] DFA82_eof = DFA.UnpackEncodedString(DFA82_eofS);
-		static readonly char[] DFA82_min = DFA.UnpackEncodedStringToUnsignedChars(DFA82_minS);
-		static readonly char[] DFA82_max = DFA.UnpackEncodedStringToUnsignedChars(DFA82_maxS);
-		static readonly short[] DFA82_accept = DFA.UnpackEncodedString(DFA82_acceptS);
-		static readonly short[] DFA82_special = DFA.UnpackEncodedString(DFA82_specialS);
-		static readonly short[][] DFA82_transition;
-
-		static DFA82()
-		{
-			int numStates = DFA82_transitionS.Length;
-			DFA82_transition = new short[numStates][];
-			for ( int i=0; i < numStates; i++ )
-			{
-				DFA82_transition[i] = DFA.UnpackEncodedString(DFA82_transitionS[i]);
-			}
-		}
-
-		public DFA82( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
-			: base( specialStateTransition )	{
-			this.recognizer = recognizer;
-			this.decisionNumber = 82;
-			this.eot = DFA82_eot;
-			this.eof = DFA82_eof;
-			this.min = DFA82_min;
-			this.max = DFA82_max;
-			this.accept = DFA82_accept;
-			this.special = DFA82_special;
-			this.transition = DFA82_transition;
-		}
-		public override string GetDescription()
-		{
-			return "668:0: rewrite_alternative options {k=1; } : ({...}? => rewrite_template |{...}? => ( rewrite_element )+ -> {!stream_rewrite_element.HasNext}? ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] ) -> ^( ALT[LT(1),\"ALT\"] ( rewrite_element )+ EOA[\"<end-of-alt>\"] ) | -> ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] ) |{...}? ETC );";
-		}
-	}
-
-	int specialStateTransition82( DFA dfa, int s, IIntStream _input )
-	{
-		ITokenStream input = (ITokenStream)_input;
-		int _s = s;
-		switch ( s )
-		{
-			case 0:
-				int LA82_0 = input.LA(1);
-
-
-				int index82_0 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (LA82_0==TOKEN_REF) && ((((Grammar.BuildTemplate)&&(LT(1).Text.Equals("template")))||(Grammar.BuildTemplate)||(Grammar.BuildAST)||((Grammar.BuildTemplate)&&(LT(1).Text.Equals("template")))||((Grammar.BuildTemplate)&&(LT(1).Text.Equals("template")))||((Grammar.BuildTemplate)&&(LT(1).Text.Equals("template")))))) {s = 1;}
-
-				else if ( (LA82_0==RULE_REF) && ((((Grammar.BuildTemplate)&&(LT(1).Text.Equals("template")))||(Grammar.BuildTemplate)||(Grammar.BuildAST)||((Grammar.BuildTemplate)&&(LT(1).Text.Equals("template")))||((Grammar.BuildTemplate)&&(LT(1).Text.Equals("template")))||((Grammar.BuildTemplate)&&(LT(1).Text.Equals("template")))))) {s = 2;}
-
-				else if ( (LA82_0==LPAREN) && (((Grammar.BuildTemplate)||(Grammar.BuildAST)))) {s = 3;}
-
-				else if ( (LA82_0==ACTION) && (((Grammar.BuildTemplate)||(Grammar.BuildAST)))) {s = 4;}
-
-				else if ( (LA82_0==CHAR_LITERAL||LA82_0==DOLLAR||LA82_0==STRING_LITERAL||LA82_0==TREE_BEGIN) && ((Grammar.BuildAST))) {s = 5;}
-
-				else if ( (LA82_0==OR||LA82_0==REWRITE||LA82_0==RPAREN||LA82_0==SEMI) ) {s = 9;}
-
-				else if ( (LA82_0==ETC) ) {s = 13;}
-
-
-				input.Seek(index82_0);
-				if ( s>=0 ) return s;
-				break;
-			case 1:
-				int LA82_1 = input.LA(1);
-
-
-				int index82_1 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( ((((Grammar.BuildTemplate)&&(LT(1).Text.Equals("template")))||(Grammar.BuildTemplate))) ) {s = 14;}
-
-				else if ( ((Grammar.BuildAST)) ) {s = 5;}
-
-
-				input.Seek(index82_1);
-				if ( s>=0 ) return s;
-				break;
-			case 2:
-				int LA82_2 = input.LA(1);
-
-
-				int index82_2 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( ((((Grammar.BuildTemplate)&&(LT(1).Text.Equals("template")))||(Grammar.BuildTemplate))) ) {s = 14;}
-
-				else if ( ((Grammar.BuildAST)) ) {s = 5;}
-
-
-				input.Seek(index82_2);
-				if ( s>=0 ) return s;
-				break;
-			case 3:
-				int LA82_3 = input.LA(1);
-
-
-				int index82_3 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( ((Grammar.BuildTemplate)) ) {s = 14;}
-
-				else if ( ((Grammar.BuildAST)) ) {s = 5;}
-
-
-				input.Seek(index82_3);
-				if ( s>=0 ) return s;
-				break;
-			case 4:
-				int LA82_4 = input.LA(1);
-
-
-				int index82_4 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( ((Grammar.BuildTemplate)) ) {s = 14;}
-
-				else if ( ((Grammar.BuildAST)) ) {s = 5;}
-
-
-				input.Seek(index82_4);
-				if ( s>=0 ) return s;
-				break;
-		}
-		if (state.backtracking>0) {state.failed=true; return -1;}
-		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 82, _s, input);
-		dfa.Error(nvae);
-		throw nvae;
-	}
-
-	#endregion DFA
-
-	#region Follow sets
-	private static class Follow
-	{
-		public static readonly BitSet _ACTION_in_grammar_308 = new BitSet(new ulong[]{0x1002040008000000UL,0x10000000UL});
-		public static readonly BitSet _DOC_COMMENT_in_grammar_319 = new BitSet(new ulong[]{0x1002040008000000UL,0x10000000UL});
-		public static readonly BitSet _grammarType_in_grammar_329 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
-		public static readonly BitSet _id_in_grammar_333 = new BitSet(new ulong[]{0x0UL,0x8000UL});
-		public static readonly BitSet _SEMI_in_grammar_337 = new BitSet(new ulong[]{0x400210008000200UL,0xC00600EUL});
-		public static readonly BitSet _optionsSpec_in_grammar_343 = new BitSet(new ulong[]{0x400210008000200UL,0xC00600EUL});
-		public static readonly BitSet _delegateGrammars_in_grammar_357 = new BitSet(new ulong[]{0x400210008000200UL,0xC00600EUL});
-		public static readonly BitSet _tokensSpec_in_grammar_366 = new BitSet(new ulong[]{0x400210008000200UL,0xC00600EUL});
-		public static readonly BitSet _attrScopes_in_grammar_374 = new BitSet(new ulong[]{0x400210008000200UL,0xC00600EUL});
-		public static readonly BitSet _actions_in_grammar_381 = new BitSet(new ulong[]{0x400210008000200UL,0xC00600EUL});
-		public static readonly BitSet _rules_in_grammar_389 = new BitSet(new ulong[]{0x0UL});
-		public static readonly BitSet _EOF_in_grammar_393 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _LEXER_in_grammarType444 = new BitSet(new ulong[]{0x40000000000UL});
-		public static readonly BitSet _GRAMMAR_in_grammarType449 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _PARSER_in_grammarType472 = new BitSet(new ulong[]{0x40000000000UL});
-		public static readonly BitSet _GRAMMAR_in_grammarType476 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _TREE_in_grammarType497 = new BitSet(new ulong[]{0x40000000000UL});
-		public static readonly BitSet _GRAMMAR_in_grammarType503 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _GRAMMAR_in_grammarType526 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _action_in_actions553 = new BitSet(new ulong[]{0x202UL});
-		public static readonly BitSet _AMPERSAND_in_action568 = new BitSet(new ulong[]{0x1002000000000000UL,0x4002000UL});
-		public static readonly BitSet _actionScopeName_in_action572 = new BitSet(new ulong[]{0x400000UL});
-		public static readonly BitSet _COLON_in_action574 = new BitSet(new ulong[]{0x400000UL});
-		public static readonly BitSet _COLON_in_action577 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
-		public static readonly BitSet _id_in_action582 = new BitSet(new ulong[]{0x10UL});
-		public static readonly BitSet _ACTION_in_action584 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _id_in_actionScopeName597 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _LEXER_in_actionScopeName604 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _PARSER_in_actionScopeName618 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _OPTIONS_in_optionsSpec640 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
-		public static readonly BitSet _option_in_optionsSpec644 = new BitSet(new ulong[]{0x0UL,0x8000UL});
-		public static readonly BitSet _SEMI_in_optionsSpec647 = new BitSet(new ulong[]{0x0UL,0x4002040UL});
-		public static readonly BitSet _RCURLY_in_optionsSpec652 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _id_in_option665 = new BitSet(new ulong[]{0x2000UL});
-		public static readonly BitSet _ASSIGN_in_option667 = new BitSet(new ulong[]{0x800000040000UL,0x4282000UL});
-		public static readonly BitSet _optionValue_in_option670 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _id_in_optionValue691 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _STRING_LITERAL_in_optionValue703 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _CHAR_LITERAL_in_optionValue712 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _INT_in_optionValue723 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _STAR_in_optionValue743 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _IMPORT_in_delegateGrammars768 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
-		public static readonly BitSet _delegateGrammar_in_delegateGrammars771 = new BitSet(new ulong[]{0x1000000UL,0x8000UL});
-		public static readonly BitSet _COMMA_in_delegateGrammars774 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
-		public static readonly BitSet _delegateGrammar_in_delegateGrammars777 = new BitSet(new ulong[]{0x1000000UL,0x8000UL});
-		public static readonly BitSet _SEMI_in_delegateGrammars781 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _id_in_delegateGrammar795 = new BitSet(new ulong[]{0x2000UL});
-		public static readonly BitSet _ASSIGN_in_delegateGrammar797 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
-		public static readonly BitSet _id_in_delegateGrammar802 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _id_in_delegateGrammar811 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _TOKENS_in_tokensSpec838 = new BitSet(new ulong[]{0x0UL,0x4000000UL});
-		public static readonly BitSet _tokenSpec_in_tokensSpec846 = new BitSet(new ulong[]{0x0UL,0x4000040UL});
-		public static readonly BitSet _RCURLY_in_tokensSpec853 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _TOKEN_REF_in_tokenSpec865 = new BitSet(new ulong[]{0x2000UL,0x8000UL});
-		public static readonly BitSet _ASSIGN_in_tokenSpec869 = new BitSet(new ulong[]{0x40000UL,0x200000UL});
-		public static readonly BitSet _set_in_tokenSpec872 = new BitSet(new ulong[]{0x0UL,0x8000UL});
-		public static readonly BitSet _SEMI_in_tokenSpec881 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _attrScope_in_attrScopes894 = new BitSet(new ulong[]{0x2UL,0x4000UL});
-		public static readonly BitSet _SCOPE_in_attrScope907 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
-		public static readonly BitSet _id_in_attrScope910 = new BitSet(new ulong[]{0x210UL});
-		public static readonly BitSet _ruleActions_in_attrScope912 = new BitSet(new ulong[]{0x10UL});
-		public static readonly BitSet _ACTION_in_attrScope915 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _rule_in_rules928 = new BitSet(new ulong[]{0x400210008000202UL,0xC00600EUL});
-		public static readonly BitSet _DOC_COMMENT_in_rule958 = new BitSet(new ulong[]{0x10000000000UL,0x400200EUL});
-		public static readonly BitSet _PROTECTED_in_rule971 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
-		public static readonly BitSet _PUBLIC_in_rule980 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
-		public static readonly BitSet _PRIVATE_in_rule990 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
-		public static readonly BitSet _FRAGMENT_in_rule999 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
-		public static readonly BitSet _id_in_rule1011 = new BitSet(new ulong[]{0x400000000408A00UL,0x2004100UL});
-		public static readonly BitSet _BANG_in_rule1021 = new BitSet(new ulong[]{0x400000000400A00UL,0x2004100UL});
-		public static readonly BitSet _ARG_ACTION_in_rule1032 = new BitSet(new ulong[]{0x400000000400200UL,0x2004100UL});
-		public static readonly BitSet _RETURNS_in_rule1041 = new BitSet(new ulong[]{0x800UL});
-		public static readonly BitSet _ARG_ACTION_in_rule1045 = new BitSet(new ulong[]{0x400000000400200UL,0x2004000UL});
-		public static readonly BitSet _throwsSpec_in_rule1055 = new BitSet(new ulong[]{0x400000000400200UL,0x4000UL});
-		public static readonly BitSet _optionsSpec_in_rule1064 = new BitSet(new ulong[]{0x400200UL,0x4000UL});
-		public static readonly BitSet _ruleScopeSpec_in_rule1073 = new BitSet(new ulong[]{0x400200UL});
-		public static readonly BitSet _ruleActions_in_rule1078 = new BitSet(new ulong[]{0x400000UL});
-		public static readonly BitSet _COLON_in_rule1084 = new BitSet(new ulong[]{0x888008000040010UL,0xA4212200UL});
-		public static readonly BitSet _altList_in_rule1088 = new BitSet(new ulong[]{0x0UL,0x8000UL});
-		public static readonly BitSet _SEMI_in_rule1093 = new BitSet(new ulong[]{0x4000020002UL});
-		public static readonly BitSet _exceptionGroup_in_rule1101 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ruleAction_in_ruleActions1243 = new BitSet(new ulong[]{0x202UL});
-		public static readonly BitSet _AMPERSAND_in_ruleAction1258 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
-		public static readonly BitSet _id_in_ruleAction1261 = new BitSet(new ulong[]{0x10UL});
-		public static readonly BitSet _ACTION_in_ruleAction1263 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _THROWS_in_throwsSpec1274 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
-		public static readonly BitSet _id_in_throwsSpec1277 = new BitSet(new ulong[]{0x1000002UL});
-		public static readonly BitSet _COMMA_in_throwsSpec1281 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
-		public static readonly BitSet _id_in_throwsSpec1284 = new BitSet(new ulong[]{0x1000002UL});
-		public static readonly BitSet _SCOPE_in_ruleScopeSpec1300 = new BitSet(new ulong[]{0x210UL});
-		public static readonly BitSet _ruleActions_in_ruleScopeSpec1302 = new BitSet(new ulong[]{0x10UL});
-		public static readonly BitSet _ACTION_in_ruleScopeSpec1305 = new BitSet(new ulong[]{0x2UL,0x4000UL});
-		public static readonly BitSet _SCOPE_in_ruleScopeSpec1314 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
-		public static readonly BitSet _idList_in_ruleScopeSpec1316 = new BitSet(new ulong[]{0x0UL,0x8000UL});
-		public static readonly BitSet _SEMI_in_ruleScopeSpec1318 = new BitSet(new ulong[]{0x2UL,0x4000UL});
-		public static readonly BitSet _LPAREN_in_block1361 = new BitSet(new ulong[]{0xC88008000440210UL,0xA4212A00UL});
-		public static readonly BitSet _optionsSpec_in_block1399 = new BitSet(new ulong[]{0x400200UL});
-		public static readonly BitSet _ruleActions_in_block1410 = new BitSet(new ulong[]{0x400000UL});
-		public static readonly BitSet _COLON_in_block1418 = new BitSet(new ulong[]{0x888008000040010UL,0xA4212A00UL});
-		public static readonly BitSet _ACTION_in_block1424 = new BitSet(new ulong[]{0x400000UL});
-		public static readonly BitSet _COLON_in_block1426 = new BitSet(new ulong[]{0x888008000040010UL,0xA4212A00UL});
-		public static readonly BitSet _alternative_in_block1438 = new BitSet(new ulong[]{0x800000000000000UL,0xA00UL});
-		public static readonly BitSet _rewrite_in_block1442 = new BitSet(new ulong[]{0x800000000000000UL,0x800UL});
-		public static readonly BitSet _OR_in_block1452 = new BitSet(new ulong[]{0x888008000040010UL,0xA4212A00UL});
-		public static readonly BitSet _alternative_in_block1456 = new BitSet(new ulong[]{0x800000000000000UL,0xA00UL});
-		public static readonly BitSet _rewrite_in_block1460 = new BitSet(new ulong[]{0x800000000000000UL,0x800UL});
-		public static readonly BitSet _RPAREN_in_block1477 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _alternative_in_altList1541 = new BitSet(new ulong[]{0x800000000000000UL,0x200UL});
-		public static readonly BitSet _rewrite_in_altList1545 = new BitSet(new ulong[]{0x800000000000002UL});
-		public static readonly BitSet _OR_in_altList1572 = new BitSet(new ulong[]{0x888008000040010UL,0xA4212200UL});
-		public static readonly BitSet _alternative_in_altList1576 = new BitSet(new ulong[]{0x800000000000000UL,0x200UL});
-		public static readonly BitSet _rewrite_in_altList1580 = new BitSet(new ulong[]{0x800000000000002UL});
-		public static readonly BitSet _element_in_alternative1634 = new BitSet(new ulong[]{0x88008000040012UL,0xA4212000UL});
-		public static readonly BitSet _exceptionHandler_in_exceptionGroup1680 = new BitSet(new ulong[]{0x4000020002UL});
-		public static readonly BitSet _finallyClause_in_exceptionGroup1683 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _finallyClause_in_exceptionGroup1689 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _CATCH_in_exceptionHandler1700 = new BitSet(new ulong[]{0x800UL});
-		public static readonly BitSet _ARG_ACTION_in_exceptionHandler1703 = new BitSet(new ulong[]{0x10UL});
-		public static readonly BitSet _ACTION_in_exceptionHandler1705 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _FINALLY_in_finallyClause1716 = new BitSet(new ulong[]{0x10UL});
-		public static readonly BitSet _ACTION_in_finallyClause1719 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _elementNoOptionSpec_in_element1730 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _id_in_elementNoOptionSpec1750 = new BitSet(new ulong[]{0x8000000000002000UL});
-		public static readonly BitSet _ASSIGN_in_elementNoOptionSpec1753 = new BitSet(new ulong[]{0x88000000040000UL,0x84202000UL});
-		public static readonly BitSet _PLUS_ASSIGN_in_elementNoOptionSpec1756 = new BitSet(new ulong[]{0x88000000040000UL,0x84202000UL});
-		public static readonly BitSet _atom_in_elementNoOptionSpec1761 = new BitSet(new ulong[]{0x4000000000000002UL,0x80010UL});
-		public static readonly BitSet _block_in_elementNoOptionSpec1763 = new BitSet(new ulong[]{0x4000000000000002UL,0x80010UL});
-		public static readonly BitSet _ebnfSuffix_in_elementNoOptionSpec1778 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _atom_in_elementNoOptionSpec1796 = new BitSet(new ulong[]{0x4000000000000002UL,0x80010UL});
-		public static readonly BitSet _ebnfSuffix_in_elementNoOptionSpec1805 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ebnf_in_elementNoOptionSpec1821 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _FORCED_ACTION_in_elementNoOptionSpec1827 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ACTION_in_elementNoOptionSpec1833 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _SEMPRED_in_elementNoOptionSpec1841 = new BitSet(new ulong[]{0x100000000002UL});
-		public static readonly BitSet _IMPLIES_in_elementNoOptionSpec1845 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _tree__in_elementNoOptionSpec1864 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _range_in_atom1879 = new BitSet(new ulong[]{0x8002UL,0x400UL});
-		public static readonly BitSet _ROOT_in_atom1882 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _BANG_in_atom1885 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _id_in_atom1925 = new BitSet(new ulong[]{0x0UL,0x80000000UL});
-		public static readonly BitSet _WILDCARD_in_atom1929 = new BitSet(new ulong[]{0x40000UL,0x84202000UL});
-		public static readonly BitSet _terminal_in_atom1933 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ruleref_in_atom1935 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _terminal_in_atom1944 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ruleref_in_atom1950 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _notSet_in_atom1959 = new BitSet(new ulong[]{0x8002UL,0x400UL});
-		public static readonly BitSet _ROOT_in_atom1962 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _BANG_in_atom1965 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _RULE_REF_in_ruleref1979 = new BitSet(new ulong[]{0x8802UL,0x400UL});
-		public static readonly BitSet _ARG_ACTION_in_ruleref1982 = new BitSet(new ulong[]{0x8002UL,0x400UL});
-		public static readonly BitSet _ROOT_in_ruleref1986 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _BANG_in_ruleref1989 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _NOT_in_notSet2003 = new BitSet(new ulong[]{0x8000000040000UL,0x4200000UL});
-		public static readonly BitSet _notTerminal_in_notSet2010 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _block_in_notSet2016 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _id_in_treeRoot2039 = new BitSet(new ulong[]{0x8000000000002000UL});
-		public static readonly BitSet _ASSIGN_in_treeRoot2042 = new BitSet(new ulong[]{0x88000000040000UL,0x84202000UL});
-		public static readonly BitSet _PLUS_ASSIGN_in_treeRoot2045 = new BitSet(new ulong[]{0x88000000040000UL,0x84202000UL});
-		public static readonly BitSet _atom_in_treeRoot2050 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _block_in_treeRoot2052 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _atom_in_treeRoot2058 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _block_in_treeRoot2063 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _TREE_BEGIN_in_tree_2074 = new BitSet(new ulong[]{0x88000000040000UL,0x84202000UL});
-		public static readonly BitSet _treeRoot_in_tree_2079 = new BitSet(new ulong[]{0x88008000040010UL,0xA4212000UL});
-		public static readonly BitSet _element_in_tree_2081 = new BitSet(new ulong[]{0x88008000040010UL,0xA4212800UL});
-		public static readonly BitSet _RPAREN_in_tree_2086 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _block_in_ebnf2100 = new BitSet(new ulong[]{0x4000100000008002UL,0x80410UL});
-		public static readonly BitSet _QUESTION_in_ebnf2106 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _STAR_in_ebnf2124 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _PLUS_in_ebnf2142 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _IMPLIES_in_ebnf2160 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ROOT_in_ebnf2196 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _BANG_in_ebnf2213 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _CHAR_LITERAL_in_range2252 = new BitSet(new ulong[]{0x0UL,0x20UL});
-		public static readonly BitSet _RANGE_in_range2254 = new BitSet(new ulong[]{0x40000UL});
-		public static readonly BitSet _CHAR_LITERAL_in_range2258 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _CHAR_LITERAL_in_terminal2286 = new BitSet(new ulong[]{0x100000000008002UL,0x400UL});
-		public static readonly BitSet _elementOptions_in_terminal2291 = new BitSet(new ulong[]{0x8002UL,0x400UL});
-		public static readonly BitSet _ROOT_in_terminal2299 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _BANG_in_terminal2302 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _TOKEN_REF_in_terminal2313 = new BitSet(new ulong[]{0x100000000008802UL,0x400UL});
-		public static readonly BitSet _elementOptions_in_terminal2320 = new BitSet(new ulong[]{0x8802UL,0x400UL});
-		public static readonly BitSet _ARG_ACTION_in_terminal2331 = new BitSet(new ulong[]{0x8002UL,0x400UL});
-		public static readonly BitSet _ROOT_in_terminal2340 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _BANG_in_terminal2343 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _STRING_LITERAL_in_terminal2354 = new BitSet(new ulong[]{0x100000000008002UL,0x400UL});
-		public static readonly BitSet _elementOptions_in_terminal2359 = new BitSet(new ulong[]{0x8002UL,0x400UL});
-		public static readonly BitSet _ROOT_in_terminal2367 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _BANG_in_terminal2370 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _WILDCARD_in_terminal2381 = new BitSet(new ulong[]{0x8002UL,0x400UL});
-		public static readonly BitSet _ROOT_in_terminal2384 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _BANG_in_terminal2387 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _OPEN_ELEMENT_OPTION_in_elementOptions2406 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
-		public static readonly BitSet _defaultNodeOption_in_elementOptions2409 = new BitSet(new ulong[]{0x100000UL});
-		public static readonly BitSet _CLOSE_ELEMENT_OPTION_in_elementOptions2412 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _OPEN_ELEMENT_OPTION_in_elementOptions2418 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
-		public static readonly BitSet _elementOption_in_elementOptions2421 = new BitSet(new ulong[]{0x100000UL,0x8000UL});
-		public static readonly BitSet _SEMI_in_elementOptions2425 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
-		public static readonly BitSet _elementOption_in_elementOptions2428 = new BitSet(new ulong[]{0x100000UL,0x8000UL});
-		public static readonly BitSet _CLOSE_ELEMENT_OPTION_in_elementOptions2433 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _id_in_defaultNodeOption2453 = new BitSet(new ulong[]{0x2UL,0x80000000UL});
-		public static readonly BitSet _WILDCARD_in_defaultNodeOption2458 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
-		public static readonly BitSet _id_in_defaultNodeOption2462 = new BitSet(new ulong[]{0x2UL,0x80000000UL});
-		public static readonly BitSet _id_in_elementOption2484 = new BitSet(new ulong[]{0x2000UL});
-		public static readonly BitSet _ASSIGN_in_elementOption2486 = new BitSet(new ulong[]{0x0UL,0x4202000UL});
-		public static readonly BitSet _id_in_elementOption2492 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _STRING_LITERAL_in_elementOption2496 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _QUESTION_in_ebnfSuffix2570 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _STAR_in_ebnfSuffix2584 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _PLUS_in_ebnfSuffix2598 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _set_in_notTerminal2639 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _id_in_idList2660 = new BitSet(new ulong[]{0x1000002UL});
-		public static readonly BitSet _COMMA_in_idList2663 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
-		public static readonly BitSet _id_in_idList2666 = new BitSet(new ulong[]{0x1000002UL});
-		public static readonly BitSet _TOKEN_REF_in_id2679 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _RULE_REF_in_id2691 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _rewrite_with_sempred_in_rewrite2711 = new BitSet(new ulong[]{0x0UL,0x200UL});
-		public static readonly BitSet _REWRITE_in_rewrite2716 = new BitSet(new ulong[]{0x8002010040010UL,0x24202000UL});
-		public static readonly BitSet _rewrite_alternative_in_rewrite2718 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _REWRITE_in_rewrite_with_sempred2745 = new BitSet(new ulong[]{0x0UL,0x10000UL});
-		public static readonly BitSet _SEMPRED_in_rewrite_with_sempred2748 = new BitSet(new ulong[]{0x8002010040010UL,0x24202000UL});
-		public static readonly BitSet _rewrite_alternative_in_rewrite_with_sempred2750 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _LPAREN_in_rewrite_block2761 = new BitSet(new ulong[]{0x8002010040010UL,0x24202800UL});
-		public static readonly BitSet _rewrite_alternative_in_rewrite_block2765 = new BitSet(new ulong[]{0x0UL,0x800UL});
-		public static readonly BitSet _RPAREN_in_rewrite_block2769 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _rewrite_template_in_rewrite_alternative2805 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _rewrite_element_in_rewrite_alternative2817 = new BitSet(new ulong[]{0x8000010040012UL,0x24202000UL});
-		public static readonly BitSet _ETC_in_rewrite_alternative2878 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _rewrite_atom_in_rewrite_element2893 = new BitSet(new ulong[]{0x4000000000000002UL,0x80010UL});
-		public static readonly BitSet _ebnfSuffix_in_rewrite_element2913 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _rewrite_ebnf_in_rewrite_element2932 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _rewrite_tree_in_rewrite_element2941 = new BitSet(new ulong[]{0x4000000000000002UL,0x80010UL});
-		public static readonly BitSet _ebnfSuffix_in_rewrite_element2961 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _TOKEN_REF_in_rewrite_atom2995 = new BitSet(new ulong[]{0x100000000000802UL});
-		public static readonly BitSet _elementOptions_in_rewrite_atom3012 = new BitSet(new ulong[]{0x802UL});
-		public static readonly BitSet _ARG_ACTION_in_rewrite_atom3018 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _RULE_REF_in_rewrite_atom3040 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _CHAR_LITERAL_in_rewrite_atom3049 = new BitSet(new ulong[]{0x100000000000002UL});
-		public static readonly BitSet _elementOptions_in_rewrite_atom3066 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _STRING_LITERAL_in_rewrite_atom3078 = new BitSet(new ulong[]{0x100000000000002UL});
-		public static readonly BitSet _elementOptions_in_rewrite_atom3097 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _DOLLAR_in_rewrite_atom3107 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
-		public static readonly BitSet _id_in_rewrite_atom3111 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ACTION_in_rewrite_atom3124 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _rewrite_block_in_rewrite_ebnf3137 = new BitSet(new ulong[]{0x4000000000000000UL,0x80010UL});
-		public static readonly BitSet _QUESTION_in_rewrite_ebnf3143 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _STAR_in_rewrite_ebnf3162 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _PLUS_in_rewrite_ebnf3181 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _TREE_BEGIN_in_rewrite_tree3209 = new BitSet(new ulong[]{0x10040010UL,0x4202000UL});
-		public static readonly BitSet _rewrite_atom_in_rewrite_tree3215 = new BitSet(new ulong[]{0x8000010040010UL,0x24202800UL});
-		public static readonly BitSet _rewrite_element_in_rewrite_tree3217 = new BitSet(new ulong[]{0x8000010040010UL,0x24202800UL});
-		public static readonly BitSet _RPAREN_in_rewrite_tree3222 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _rewrite_template_head_in_rewrite_template3257 = new BitSet(new ulong[]{0xC0000000UL});
-		public static readonly BitSet _DOUBLE_QUOTE_STRING_LITERAL_in_rewrite_template3276 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _DOUBLE_ANGLE_STRING_LITERAL_in_rewrite_template3282 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _rewrite_template_head_in_rewrite_template3297 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _rewrite_indirect_template_head_in_rewrite_template3306 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ACTION_in_rewrite_template3315 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _id_in_rewrite_template_head3328 = new BitSet(new ulong[]{0x8000000000000UL});
-		public static readonly BitSet _LPAREN_in_rewrite_template_head3332 = new BitSet(new ulong[]{0x0UL,0x4002800UL});
-		public static readonly BitSet _rewrite_template_args_in_rewrite_template_head3336 = new BitSet(new ulong[]{0x0UL,0x800UL});
-		public static readonly BitSet _RPAREN_in_rewrite_template_head3340 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _LPAREN_in_rewrite_indirect_template_head3368 = new BitSet(new ulong[]{0x10UL});
-		public static readonly BitSet _ACTION_in_rewrite_indirect_template_head3372 = new BitSet(new ulong[]{0x0UL,0x800UL});
-		public static readonly BitSet _RPAREN_in_rewrite_indirect_template_head3376 = new BitSet(new ulong[]{0x8000000000000UL});
-		public static readonly BitSet _LPAREN_in_rewrite_indirect_template_head3380 = new BitSet(new ulong[]{0x0UL,0x4002800UL});
-		public static readonly BitSet _rewrite_template_args_in_rewrite_indirect_template_head3382 = new BitSet(new ulong[]{0x0UL,0x800UL});
-		public static readonly BitSet _RPAREN_in_rewrite_indirect_template_head3384 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _rewrite_template_arg_in_rewrite_template_args3408 = new BitSet(new ulong[]{0x1000002UL});
-		public static readonly BitSet _COMMA_in_rewrite_template_args3411 = new BitSet(new ulong[]{0x0UL,0x4002000UL});
-		public static readonly BitSet _rewrite_template_arg_in_rewrite_template_args3413 = new BitSet(new ulong[]{0x1000002UL});
-		public static readonly BitSet _id_in_rewrite_template_arg3448 = new BitSet(new ulong[]{0x2000UL});
-		public static readonly BitSet _ASSIGN_in_rewrite_template_arg3452 = new BitSet(new ulong[]{0x10UL});
-		public static readonly BitSet _ACTION_in_rewrite_template_arg3454 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _id_in_synpred1_ANTLR1909 = new BitSet(new ulong[]{0x0UL,0x80000000UL});
-		public static readonly BitSet _WILDCARD_in_synpred1_ANTLR1911 = new BitSet(new ulong[]{0x40000UL,0x84202000UL});
-		public static readonly BitSet _terminal_in_synpred1_ANTLR1914 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ruleref_in_synpred1_ANTLR1916 = new BitSet(new ulong[]{0x2UL});
-
-	}
-	#endregion Follow sets
-}
-
-} // namespace Antlr3.Grammars
diff --git a/Antlr3/Grammars/ANTLRTreePrinter.cs b/Antlr3/Grammars/ANTLRTreePrinter.cs
deleted file mode 100644
index 2caa00c..0000000
--- a/Antlr3/Grammars/ANTLRTreePrinter.cs
+++ /dev/null
@@ -1,3914 +0,0 @@
-// $ANTLR 3.1.2 Grammars\\ANTLRTreePrinter.g3 2009-09-30 13:28:41
-
-// The variable 'variable' is assigned but its value is never used.
-#pragma warning disable 219
-// Unreachable code detected.
-#pragma warning disable 162
-
-
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Grammar conversion to ANTLR v3 and C#:
- Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-	notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-	derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-using Antlr3.Tool;
-
-
-using System.Collections.Generic;
-using Antlr.Runtime;
-using Antlr.Runtime.Tree;
-using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;using Stack = System.Collections.Generic.Stack<object>;
-using List = System.Collections.IList;
-using ArrayList = System.Collections.Generic.List<object>;
-
-namespace Antlr3.Grammars
-{
-/** Print out a grammar (no pretty printing).
- *
- *  Terence Parr
- *  University of San Francisco
- *  August 19, 2003
- */
-[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.1.2")]
-[System.CLSCompliant(false)]
-public partial class ANTLRTreePrinter : TreeParser
-{
-	internal static readonly string[] tokenNames = new string[] {
-		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", "ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARG_ACTION", "ARGLIST", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", "CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", "COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", "DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", "EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", "GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", "LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", "NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", "OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", "RET", "RETURNS", "REWRITE", "ROOT", "RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", "SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYN_SEMPRED", "SYNPRED", "TEMPLATE", "THROWS", "TOKEN_REF", "TOKENS", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", "WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT"
-	};
-	public const int EOF=-1;
-	public const int ACTION=4;
-	public const int ACTION_CHAR_LITERAL=5;
-	public const int ACTION_ESC=6;
-	public const int ACTION_STRING_LITERAL=7;
-	public const int ALT=8;
-	public const int AMPERSAND=9;
-	public const int ARG=10;
-	public const int ARG_ACTION=11;
-	public const int ARGLIST=12;
-	public const int ASSIGN=13;
-	public const int BACKTRACK_SEMPRED=14;
-	public const int BANG=15;
-	public const int BLOCK=16;
-	public const int CATCH=17;
-	public const int CHAR_LITERAL=18;
-	public const int CHAR_RANGE=19;
-	public const int CLOSE_ELEMENT_OPTION=20;
-	public const int CLOSURE=21;
-	public const int COLON=22;
-	public const int COMBINED_GRAMMAR=23;
-	public const int COMMA=24;
-	public const int COMMENT=25;
-	public const int DIGIT=26;
-	public const int DOC_COMMENT=27;
-	public const int DOLLAR=28;
-	public const int DOT=29;
-	public const int DOUBLE_ANGLE_STRING_LITERAL=30;
-	public const int DOUBLE_QUOTE_STRING_LITERAL=31;
-	public const int EOA=32;
-	public const int EOB=33;
-	public const int EOR=34;
-	public const int EPSILON=35;
-	public const int ESC=36;
-	public const int ETC=37;
-	public const int FINALLY=38;
-	public const int FORCED_ACTION=39;
-	public const int FRAGMENT=40;
-	public const int GATED_SEMPRED=41;
-	public const int GRAMMAR=42;
-	public const int ID=43;
-	public const int IMPLIES=44;
-	public const int IMPORT=45;
-	public const int INITACTION=46;
-	public const int INT=47;
-	public const int LABEL=48;
-	public const int LEXER=49;
-	public const int LEXER_GRAMMAR=50;
-	public const int LPAREN=51;
-	public const int ML_COMMENT=52;
-	public const int NESTED_ACTION=53;
-	public const int NESTED_ARG_ACTION=54;
-	public const int NOT=55;
-	public const int OPEN_ELEMENT_OPTION=56;
-	public const int OPTIONAL=57;
-	public const int OPTIONS=58;
-	public const int OR=59;
-	public const int PARSER=60;
-	public const int PARSER_GRAMMAR=61;
-	public const int PLUS=62;
-	public const int PLUS_ASSIGN=63;
-	public const int POSITIVE_CLOSURE=64;
-	public const int PRIVATE=65;
-	public const int PROTECTED=66;
-	public const int PUBLIC=67;
-	public const int QUESTION=68;
-	public const int RANGE=69;
-	public const int RCURLY=70;
-	public const int RET=71;
-	public const int RETURNS=72;
-	public const int REWRITE=73;
-	public const int ROOT=74;
-	public const int RPAREN=75;
-	public const int RULE=76;
-	public const int RULE_REF=77;
-	public const int SCOPE=78;
-	public const int SEMI=79;
-	public const int SEMPRED=80;
-	public const int SL_COMMENT=81;
-	public const int SRC=82;
-	public const int STAR=83;
-	public const int STRAY_BRACKET=84;
-	public const int STRING_LITERAL=85;
-	public const int SYN_SEMPRED=86;
-	public const int SYNPRED=87;
-	public const int TEMPLATE=88;
-	public const int THROWS=89;
-	public const int TOKEN_REF=90;
-	public const int TOKENS=91;
-	public const int TREE=92;
-	public const int TREE_BEGIN=93;
-	public const int TREE_GRAMMAR=94;
-	public const int WILDCARD=95;
-	public const int WS=96;
-	public const int WS_LOOP=97;
-	public const int WS_OPT=98;
-	public const int XDIGIT=99;
-
-	// delegates
-	// delegators
-
-	public ANTLRTreePrinter( ITreeNodeStream input )
-		: this( input, new RecognizerSharedState() )
-	{
-	}
-	public ANTLRTreePrinter( ITreeNodeStream input, RecognizerSharedState state )
-		: base( input, state )
-	{
-	}
-
-
-	public override string[] TokenNames { get { return ANTLRTreePrinter.tokenNames; } }
-	public override string GrammarFileName { get { return "Grammars\\ANTLRTreePrinter.g3"; } }
-
-
-	#region Rules
-
-	// $ANTLR start "toString"
-	// Grammars\\ANTLRTreePrinter.g3:89:0: public toString[Grammar g, bool showActions] returns [string s=null] : ( grammar_ | rule | alternative | element | single_rewrite | EOR ) ;
-	public string toString( Grammar g, bool showActions )
-	{
-		string s = null;
-
-
-			grammar = g;
-			this.showActions = showActions;
-
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:95:4: ( ( grammar_ | rule | alternative | element | single_rewrite | EOR ) )
-			// Grammars\\ANTLRTreePrinter.g3:95:4: ( grammar_ | rule | alternative | element | single_rewrite | EOR )
-			{
-			// Grammars\\ANTLRTreePrinter.g3:95:4: ( grammar_ | rule | alternative | element | single_rewrite | EOR )
-			int alt1=6;
-			switch ( input.LA(1) )
-			{
-			case COMBINED_GRAMMAR:
-			case LEXER_GRAMMAR:
-			case PARSER_GRAMMAR:
-			case TREE_GRAMMAR:
-				{
-				alt1=1;
-				}
-				break;
-			case RULE:
-				{
-				alt1=2;
-				}
-				break;
-			case ALT:
-				{
-				alt1=3;
-				}
-				break;
-			case ACTION:
-			case ASSIGN:
-			case BACKTRACK_SEMPRED:
-			case BANG:
-			case BLOCK:
-			case CHAR_LITERAL:
-			case CHAR_RANGE:
-			case CLOSURE:
-			case DOT:
-			case EPSILON:
-			case FORCED_ACTION:
-			case GATED_SEMPRED:
-			case LABEL:
-			case NOT:
-			case OPTIONAL:
-			case PLUS_ASSIGN:
-			case POSITIVE_CLOSURE:
-			case RANGE:
-			case ROOT:
-			case RULE_REF:
-			case SEMPRED:
-			case STRING_LITERAL:
-			case SYN_SEMPRED:
-			case SYNPRED:
-			case TOKEN_REF:
-			case TREE_BEGIN:
-			case WILDCARD:
-				{
-				alt1=4;
-				}
-				break;
-			case REWRITE:
-				{
-				alt1=5;
-				}
-				break;
-			case EOR:
-				{
-				alt1=6;
-				}
-				break;
-			default:
-				{
-					NoViableAltException nvae = new NoViableAltException("", 1, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt1 )
-			{
-			case 1:
-				// Grammars\\ANTLRTreePrinter.g3:95:6: grammar_
-				{
-				PushFollow(Follow._grammar__in_toString72);
-				grammar_();
-
-				state._fsp--;
-
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLRTreePrinter.g3:96:5: rule
-				{
-				PushFollow(Follow._rule_in_toString78);
-				rule();
-
-				state._fsp--;
-
-
-				}
-				break;
-			case 3:
-				// Grammars\\ANTLRTreePrinter.g3:97:5: alternative
-				{
-				PushFollow(Follow._alternative_in_toString84);
-				alternative();
-
-				state._fsp--;
-
-
-				}
-				break;
-			case 4:
-				// Grammars\\ANTLRTreePrinter.g3:98:5: element
-				{
-				PushFollow(Follow._element_in_toString90);
-				element();
-
-				state._fsp--;
-
-
-				}
-				break;
-			case 5:
-				// Grammars\\ANTLRTreePrinter.g3:99:5: single_rewrite
-				{
-				PushFollow(Follow._single_rewrite_in_toString96);
-				single_rewrite();
-
-				state._fsp--;
-
-
-				}
-				break;
-			case 6:
-				// Grammars\\ANTLRTreePrinter.g3:100:5: EOR
-				{
-				Match(input,EOR,Follow._EOR_in_toString102);
-				s="EOR";
-
-				}
-				break;
-
-			}
-
-			return Normalize(buf.ToString());
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return s;
-	}
-	// $ANTLR end "toString"
-
-
-	// $ANTLR start "grammar_"
-	// Grammars\\ANTLRTreePrinter.g3:107:0: grammar_ : ( ^( LEXER_GRAMMAR grammarSpec[\"lexer \" ] ) | ^( PARSER_GRAMMAR grammarSpec[\"parser \"] ) | ^( TREE_GRAMMAR grammarSpec[\"tree \"] ) | ^( COMBINED_GRAMMAR grammarSpec[\"\"] ) );
-	private void grammar_(  )
-	{
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:108:4: ( ^( LEXER_GRAMMAR grammarSpec[\"lexer \" ] ) | ^( PARSER_GRAMMAR grammarSpec[\"parser \"] ) | ^( TREE_GRAMMAR grammarSpec[\"tree \"] ) | ^( COMBINED_GRAMMAR grammarSpec[\"\"] ) )
-			int alt2=4;
-			switch ( input.LA(1) )
-			{
-			case LEXER_GRAMMAR:
-				{
-				alt2=1;
-				}
-				break;
-			case PARSER_GRAMMAR:
-				{
-				alt2=2;
-				}
-				break;
-			case TREE_GRAMMAR:
-				{
-				alt2=3;
-				}
-				break;
-			case COMBINED_GRAMMAR:
-				{
-				alt2=4;
-				}
-				break;
-			default:
-				{
-					NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt2 )
-			{
-			case 1:
-				// Grammars\\ANTLRTreePrinter.g3:108:4: ^( LEXER_GRAMMAR grammarSpec[\"lexer \" ] )
-				{
-				Match(input,LEXER_GRAMMAR,Follow._LEXER_GRAMMAR_in_grammar_127);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._grammarSpec_in_grammar_129);
-				grammarSpec("lexer ");
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLRTreePrinter.g3:109:4: ^( PARSER_GRAMMAR grammarSpec[\"parser \"] )
-				{
-				Match(input,PARSER_GRAMMAR,Follow._PARSER_GRAMMAR_in_grammar_139);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._grammarSpec_in_grammar_141);
-				grammarSpec("parser ");
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 3:
-				// Grammars\\ANTLRTreePrinter.g3:110:4: ^( TREE_GRAMMAR grammarSpec[\"tree \"] )
-				{
-				Match(input,TREE_GRAMMAR,Follow._TREE_GRAMMAR_in_grammar_151);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._grammarSpec_in_grammar_153);
-				grammarSpec("tree ");
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 4:
-				// Grammars\\ANTLRTreePrinter.g3:111:4: ^( COMBINED_GRAMMAR grammarSpec[\"\"] )
-				{
-				Match(input,COMBINED_GRAMMAR,Follow._COMBINED_GRAMMAR_in_grammar_163);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._grammarSpec_in_grammar_165);
-				grammarSpec("");
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "grammar_"
-
-
-	// $ANTLR start "attrScope"
-	// Grammars\\ANTLRTreePrinter.g3:114:0: attrScope : ^( 'scope' ID ( ruleAction )* ACTION ) ;
-	private void attrScope(  )
-	{
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:115:4: ( ^( 'scope' ID ( ruleAction )* ACTION ) )
-			// Grammars\\ANTLRTreePrinter.g3:115:4: ^( 'scope' ID ( ruleAction )* ACTION )
-			{
-			Match(input,SCOPE,Follow._SCOPE_in_attrScope181);
-
-			Match(input, TokenTypes.Down, null);
-			Match(input,ID,Follow._ID_in_attrScope183);
-			// Grammars\\ANTLRTreePrinter.g3:115:18: ( ruleAction )*
-			for ( ; ; )
-			{
-				int alt3=2;
-				int LA3_0 = input.LA(1);
-
-				if ( (LA3_0==AMPERSAND) )
-				{
-					alt3=1;
-				}
-
-
-				switch ( alt3 )
-				{
-				case 1:
-					// Grammars\\ANTLRTreePrinter.g3:115:0: ruleAction
-					{
-					PushFollow(Follow._ruleAction_in_attrScope185);
-					ruleAction();
-
-					state._fsp--;
-
-
-					}
-					break;
-
-				default:
-					goto loop3;
-				}
-			}
-
-			loop3:
-				;
-
-
-			Match(input,ACTION,Follow._ACTION_in_attrScope188);
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "attrScope"
-
-
-	// $ANTLR start "grammarSpec"
-	// Grammars\\ANTLRTreePrinter.g3:118:0: grammarSpec[string gtype] : id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( actions )? rules ;
-	private void grammarSpec( string gtype )
-	{
-		GrammarAST id=null;
-		GrammarAST cmt=null;
-
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:119:4: (id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( actions )? rules )
-			// Grammars\\ANTLRTreePrinter.g3:119:4: id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( actions )? rules
-			{
-			id=(GrammarAST)Match(input,ID,Follow._ID_in_grammarSpec204);
-			@out(gtype+"grammar "+(id!=null?id.Text:null));
-			// Grammars\\ANTLRTreePrinter.g3:120:3: (cmt= DOC_COMMENT )?
-			int alt4=2;
-			int LA4_0 = input.LA(1);
-
-			if ( (LA4_0==DOC_COMMENT) )
-			{
-				alt4=1;
-			}
-			switch ( alt4 )
-			{
-			case 1:
-				// Grammars\\ANTLRTreePrinter.g3:120:4: cmt= DOC_COMMENT
-				{
-				cmt=(GrammarAST)Match(input,DOC_COMMENT,Follow._DOC_COMMENT_in_grammarSpec213);
-				@out((cmt!=null?cmt.Text:null)+"\n");
-
-				}
-				break;
-
-			}
-
-			// Grammars\\ANTLRTreePrinter.g3:121:3: ( optionsSpec )?
-			int alt5=2;
-			int LA5_0 = input.LA(1);
-
-			if ( (LA5_0==OPTIONS) )
-			{
-				alt5=1;
-			}
-			switch ( alt5 )
-			{
-			case 1:
-				// Grammars\\ANTLRTreePrinter.g3:121:4: optionsSpec
-				{
-				PushFollow(Follow._optionsSpec_in_grammarSpec223);
-				optionsSpec();
-
-				state._fsp--;
-
-
-				}
-				break;
-
-			}
-
-			@out(";\n");
-			// Grammars\\ANTLRTreePrinter.g3:122:3: ( delegateGrammars )?
-			int alt6=2;
-			int LA6_0 = input.LA(1);
-
-			if ( (LA6_0==IMPORT) )
-			{
-				alt6=1;
-			}
-			switch ( alt6 )
-			{
-			case 1:
-				// Grammars\\ANTLRTreePrinter.g3:122:4: delegateGrammars
-				{
-				PushFollow(Follow._delegateGrammars_in_grammarSpec232);
-				delegateGrammars();
-
-				state._fsp--;
-
-
-				}
-				break;
-
-			}
-
-			// Grammars\\ANTLRTreePrinter.g3:123:3: ( tokensSpec )?
-			int alt7=2;
-			int LA7_0 = input.LA(1);
-
-			if ( (LA7_0==TOKENS) )
-			{
-				alt7=1;
-			}
-			switch ( alt7 )
-			{
-			case 1:
-				// Grammars\\ANTLRTreePrinter.g3:123:4: tokensSpec
-				{
-				PushFollow(Follow._tokensSpec_in_grammarSpec239);
-				tokensSpec();
-
-				state._fsp--;
-
-
-				}
-				break;
-
-			}
-
-			// Grammars\\ANTLRTreePrinter.g3:124:3: ( attrScope )*
-			for ( ; ; )
-			{
-				int alt8=2;
-				int LA8_0 = input.LA(1);
-
-				if ( (LA8_0==SCOPE) )
-				{
-					alt8=1;
-				}
-
-
-				switch ( alt8 )
-				{
-				case 1:
-					// Grammars\\ANTLRTreePrinter.g3:124:4: attrScope
-					{
-					PushFollow(Follow._attrScope_in_grammarSpec246);
-					attrScope();
-
-					state._fsp--;
-
-
-					}
-					break;
-
-				default:
-					goto loop8;
-				}
-			}
-
-			loop8:
-				;
-
-
-			// Grammars\\ANTLRTreePrinter.g3:125:3: ( actions )?
-			int alt9=2;
-			int LA9_0 = input.LA(1);
-
-			if ( (LA9_0==AMPERSAND) )
-			{
-				alt9=1;
-			}
-			switch ( alt9 )
-			{
-			case 1:
-				// Grammars\\ANTLRTreePrinter.g3:125:4: actions
-				{
-				PushFollow(Follow._actions_in_grammarSpec253);
-				actions();
-
-				state._fsp--;
-
-
-				}
-				break;
-
-			}
-
-			PushFollow(Follow._rules_in_grammarSpec259);
-			rules();
-
-			state._fsp--;
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "grammarSpec"
-
-
-	// $ANTLR start "actions"
-	// Grammars\\ANTLRTreePrinter.g3:129:0: actions : ( action )+ ;
-	private void actions(  )
-	{
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:130:4: ( ( action )+ )
-			// Grammars\\ANTLRTreePrinter.g3:130:4: ( action )+
-			{
-			// Grammars\\ANTLRTreePrinter.g3:130:4: ( action )+
-			int cnt10=0;
-			for ( ; ; )
-			{
-				int alt10=2;
-				int LA10_0 = input.LA(1);
-
-				if ( (LA10_0==AMPERSAND) )
-				{
-					alt10=1;
-				}
-
-
-				switch ( alt10 )
-				{
-				case 1:
-					// Grammars\\ANTLRTreePrinter.g3:130:6: action
-					{
-					PushFollow(Follow._action_in_actions272);
-					action();
-
-					state._fsp--;
-
-
-					}
-					break;
-
-				default:
-					if ( cnt10 >= 1 )
-						goto loop10;
-
-					EarlyExitException eee10 = new EarlyExitException( 10, input );
-					throw eee10;
-				}
-				cnt10++;
-			}
-			loop10:
-				;
-
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "actions"
-
-
-	// $ANTLR start "action"
-	// Grammars\\ANTLRTreePrinter.g3:133:0: action : ^( AMPERSAND id1= ID (id2= ID a1= ACTION |a2= ACTION ) ) ;
-	private void action(  )
-	{
-		GrammarAST id1=null;
-		GrammarAST id2=null;
-		GrammarAST a1=null;
-		GrammarAST a2=null;
-
-
-			string scope=null, name=null;
-			string action=null;
-
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:139:4: ( ^( AMPERSAND id1= ID (id2= ID a1= ACTION |a2= ACTION ) ) )
-			// Grammars\\ANTLRTreePrinter.g3:139:4: ^( AMPERSAND id1= ID (id2= ID a1= ACTION |a2= ACTION ) )
-			{
-			Match(input,AMPERSAND,Follow._AMPERSAND_in_action293);
-
-			Match(input, TokenTypes.Down, null);
-			id1=(GrammarAST)Match(input,ID,Follow._ID_in_action297);
-			// Grammars\\ANTLRTreePrinter.g3:140:4: (id2= ID a1= ACTION |a2= ACTION )
-			int alt11=2;
-			int LA11_0 = input.LA(1);
-
-			if ( (LA11_0==ID) )
-			{
-				alt11=1;
-			}
-			else if ( (LA11_0==ACTION) )
-			{
-				alt11=2;
-			}
-			else
-			{
-				NoViableAltException nvae = new NoViableAltException("", 11, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt11 )
-			{
-			case 1:
-				// Grammars\\ANTLRTreePrinter.g3:140:6: id2= ID a1= ACTION
-				{
-				id2=(GrammarAST)Match(input,ID,Follow._ID_in_action306);
-				a1=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_action310);
-				scope=(id1!=null?id1.Text:null); name=(a1!=null?a1.Text:null); action=(a1!=null?a1.Text:null);
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLRTreePrinter.g3:142:6: a2= ACTION
-				{
-				a2=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_action325);
-				scope=null; name=(id1!=null?id1.Text:null); action=(a2!=null?a2.Text:null);
-
-				}
-				break;
-
-			}
-
-
-			Match(input, TokenTypes.Up, null);
-
-						if ( showActions )
-						{
-							@out("@"+(scope!=null?scope+"::":"")+name+action);
-						}
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "action"
-
-
-	// $ANTLR start "optionsSpec"
-	// Grammars\\ANTLRTreePrinter.g3:154:0: optionsSpec : ^( OPTIONS ( option )+ ) ;
-	private void optionsSpec(  )
-	{
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:155:4: ( ^( OPTIONS ( option )+ ) )
-			// Grammars\\ANTLRTreePrinter.g3:155:4: ^( OPTIONS ( option )+ )
-			{
-			Match(input,OPTIONS,Follow._OPTIONS_in_optionsSpec357);
-
-			@out(" options {");
-
-			Match(input, TokenTypes.Down, null);
-			// Grammars\\ANTLRTreePrinter.g3:156:4: ( option )+
-			int cnt12=0;
-			for ( ; ; )
-			{
-				int alt12=2;
-				int LA12_0 = input.LA(1);
-
-				if ( (LA12_0==ASSIGN) )
-				{
-					alt12=1;
-				}
-
-
-				switch ( alt12 )
-				{
-				case 1:
-					// Grammars\\ANTLRTreePrinter.g3:156:5: option
-					{
-					PushFollow(Follow._option_in_optionsSpec365);
-					option();
-
-					state._fsp--;
-
-					@out("; ");
-
-					}
-					break;
-
-				default:
-					if ( cnt12 >= 1 )
-						goto loop12;
-
-					EarlyExitException eee12 = new EarlyExitException( 12, input );
-					throw eee12;
-				}
-				cnt12++;
-			}
-			loop12:
-				;
-
-
-			@out("} ");
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "optionsSpec"
-
-
-	// $ANTLR start "option"
-	// Grammars\\ANTLRTreePrinter.g3:161:0: option : ^( ASSIGN id= ID optionValue ) ;
-	private void option(  )
-	{
-		GrammarAST id=null;
-
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:162:4: ( ^( ASSIGN id= ID optionValue ) )
-			// Grammars\\ANTLRTreePrinter.g3:162:4: ^( ASSIGN id= ID optionValue )
-			{
-			Match(input,ASSIGN,Follow._ASSIGN_in_option391);
-
-			Match(input, TokenTypes.Down, null);
-			id=(GrammarAST)Match(input,ID,Follow._ID_in_option395);
-			@out((id!=null?id.Text:null)+"=");
-			PushFollow(Follow._optionValue_in_option399);
-			optionValue();
-
-			state._fsp--;
-
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "option"
-
-
-	// $ANTLR start "optionValue"
-	// Grammars\\ANTLRTreePrinter.g3:165:0: optionValue : (id= ID |s= STRING_LITERAL |c= CHAR_LITERAL |i= INT );
-	private void optionValue(  )
-	{
-		GrammarAST id=null;
-		GrammarAST s=null;
-		GrammarAST c=null;
-		GrammarAST i=null;
-
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:166:4: (id= ID |s= STRING_LITERAL |c= CHAR_LITERAL |i= INT )
-			int alt13=4;
-			switch ( input.LA(1) )
-			{
-			case ID:
-				{
-				alt13=1;
-				}
-				break;
-			case STRING_LITERAL:
-				{
-				alt13=2;
-				}
-				break;
-			case CHAR_LITERAL:
-				{
-				alt13=3;
-				}
-				break;
-			case INT:
-				{
-				alt13=4;
-				}
-				break;
-			default:
-				{
-					NoViableAltException nvae = new NoViableAltException("", 13, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt13 )
-			{
-			case 1:
-				// Grammars\\ANTLRTreePrinter.g3:166:4: id= ID
-				{
-				id=(GrammarAST)Match(input,ID,Follow._ID_in_optionValue414);
-				@out((id!=null?id.Text:null));
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLRTreePrinter.g3:167:4: s= STRING_LITERAL
-				{
-				s=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_optionValue434);
-				@out((s!=null?s.Text:null));
-
-				}
-				break;
-			case 3:
-				// Grammars\\ANTLRTreePrinter.g3:168:4: c= CHAR_LITERAL
-				{
-				c=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_optionValue443);
-				@out((c!=null?c.Text:null));
-
-				}
-				break;
-			case 4:
-				// Grammars\\ANTLRTreePrinter.g3:169:4: i= INT
-				{
-				i=(GrammarAST)Match(input,INT,Follow._INT_in_optionValue454);
-				@out((i!=null?i.Text:null));
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "optionValue"
-
-
-	// $ANTLR start "delegateGrammars"
-	// Grammars\\ANTLRTreePrinter.g3:185:0: delegateGrammars : ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ ) ;
-	private void delegateGrammars(  )
-	{
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:186:4: ( ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ ) )
-			// Grammars\\ANTLRTreePrinter.g3:186:4: ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ )
-			{
-			Match(input,IMPORT,Follow._IMPORT_in_delegateGrammars484);
-
-			Match(input, TokenTypes.Down, null);
-			// Grammars\\ANTLRTreePrinter.g3:186:16: ( ^( ASSIGN ID ID ) | ID )+
-			int cnt14=0;
-			for ( ; ; )
-			{
-				int alt14=3;
-				int LA14_0 = input.LA(1);
-
-				if ( (LA14_0==ASSIGN) )
-				{
-					alt14=1;
-				}
-				else if ( (LA14_0==ID) )
-				{
-					alt14=2;
-				}
-
-
-				switch ( alt14 )
-				{
-				case 1:
-					// Grammars\\ANTLRTreePrinter.g3:186:18: ^( ASSIGN ID ID )
-					{
-					Match(input,ASSIGN,Follow._ASSIGN_in_delegateGrammars489);
-
-					Match(input, TokenTypes.Down, null);
-					Match(input,ID,Follow._ID_in_delegateGrammars491);
-					Match(input,ID,Follow._ID_in_delegateGrammars493);
-
-					Match(input, TokenTypes.Up, null);
-
-					}
-					break;
-				case 2:
-					// Grammars\\ANTLRTreePrinter.g3:186:36: ID
-					{
-					Match(input,ID,Follow._ID_in_delegateGrammars498);
-
-					}
-					break;
-
-				default:
-					if ( cnt14 >= 1 )
-						goto loop14;
-
-					EarlyExitException eee14 = new EarlyExitException( 14, input );
-					throw eee14;
-				}
-				cnt14++;
-			}
-			loop14:
-				;
-
-
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "delegateGrammars"
-
-
-	// $ANTLR start "tokensSpec"
-	// Grammars\\ANTLRTreePrinter.g3:189:0: tokensSpec : ^( TOKENS ( tokenSpec )+ ) ;
-	private void tokensSpec(  )
-	{
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:190:4: ( ^( TOKENS ( tokenSpec )+ ) )
-			// Grammars\\ANTLRTreePrinter.g3:190:4: ^( TOKENS ( tokenSpec )+ )
-			{
-			Match(input,TOKENS,Follow._TOKENS_in_tokensSpec516);
-
-			Match(input, TokenTypes.Down, null);
-			// Grammars\\ANTLRTreePrinter.g3:190:14: ( tokenSpec )+
-			int cnt15=0;
-			for ( ; ; )
-			{
-				int alt15=2;
-				int LA15_0 = input.LA(1);
-
-				if ( (LA15_0==ASSIGN||LA15_0==TOKEN_REF) )
-				{
-					alt15=1;
-				}
-
-
-				switch ( alt15 )
-				{
-				case 1:
-					// Grammars\\ANTLRTreePrinter.g3:190:16: tokenSpec
-					{
-					PushFollow(Follow._tokenSpec_in_tokensSpec520);
-					tokenSpec();
-
-					state._fsp--;
-
-
-					}
-					break;
-
-				default:
-					if ( cnt15 >= 1 )
-						goto loop15;
-
-					EarlyExitException eee15 = new EarlyExitException( 15, input );
-					throw eee15;
-				}
-				cnt15++;
-			}
-			loop15:
-				;
-
-
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "tokensSpec"
-
-
-	// $ANTLR start "tokenSpec"
-	// Grammars\\ANTLRTreePrinter.g3:193:0: tokenSpec : ( TOKEN_REF | ^( ASSIGN TOKEN_REF ( STRING_LITERAL | CHAR_LITERAL ) ) );
-	private void tokenSpec(  )
-	{
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:194:4: ( TOKEN_REF | ^( ASSIGN TOKEN_REF ( STRING_LITERAL | CHAR_LITERAL ) ) )
-			int alt16=2;
-			int LA16_0 = input.LA(1);
-
-			if ( (LA16_0==TOKEN_REF) )
-			{
-				alt16=1;
-			}
-			else if ( (LA16_0==ASSIGN) )
-			{
-				alt16=2;
-			}
-			else
-			{
-				NoViableAltException nvae = new NoViableAltException("", 16, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt16 )
-			{
-			case 1:
-				// Grammars\\ANTLRTreePrinter.g3:194:4: TOKEN_REF
-				{
-				Match(input,TOKEN_REF,Follow._TOKEN_REF_in_tokenSpec536);
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLRTreePrinter.g3:195:4: ^( ASSIGN TOKEN_REF ( STRING_LITERAL | CHAR_LITERAL ) )
-				{
-				Match(input,ASSIGN,Follow._ASSIGN_in_tokenSpec543);
-
-				Match(input, TokenTypes.Down, null);
-				Match(input,TOKEN_REF,Follow._TOKEN_REF_in_tokenSpec545);
-				if ( input.LA(1)==CHAR_LITERAL||input.LA(1)==STRING_LITERAL )
-				{
-					input.Consume();
-					state.errorRecovery=false;
-				}
-				else
-				{
-					MismatchedSetException mse = new MismatchedSetException(null,input);
-					throw mse;
-				}
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "tokenSpec"
-
-
-	// $ANTLR start "rules"
-	// Grammars\\ANTLRTreePrinter.g3:198:0: rules : ( rule )+ ;
-	private void rules(  )
-	{
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:199:4: ( ( rule )+ )
-			// Grammars\\ANTLRTreePrinter.g3:199:4: ( rule )+
-			{
-			// Grammars\\ANTLRTreePrinter.g3:199:4: ( rule )+
-			int cnt17=0;
-			for ( ; ; )
-			{
-				int alt17=2;
-				int LA17_0 = input.LA(1);
-
-				if ( (LA17_0==RULE) )
-				{
-					alt17=1;
-				}
-
-
-				switch ( alt17 )
-				{
-				case 1:
-					// Grammars\\ANTLRTreePrinter.g3:199:6: rule
-					{
-					PushFollow(Follow._rule_in_rules566);
-					rule();
-
-					state._fsp--;
-
-
-					}
-					break;
-
-				default:
-					if ( cnt17 >= 1 )
-						goto loop17;
-
-					EarlyExitException eee17 = new EarlyExitException( 17, input );
-					throw eee17;
-				}
-				cnt17++;
-			}
-			loop17:
-				;
-
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "rules"
-
-
-	// $ANTLR start "rule"
-	// Grammars\\ANTLRTreePrinter.g3:202:0: rule : ^( RULE id= ID ( modifier )? ^( ARG (arg= ARG_ACTION )? ) ^( RET (ret= ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ruleAction )* b= block[false] ( exceptionGroup )? EOR ) ;
-	private void rule(  )
-	{
-		GrammarAST id=null;
-		GrammarAST arg=null;
-		GrammarAST ret=null;
-		ANTLRTreePrinter.block_return b = default(ANTLRTreePrinter.block_return);
-
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:203:4: ( ^( RULE id= ID ( modifier )? ^( ARG (arg= ARG_ACTION )? ) ^( RET (ret= ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ruleAction )* b= block[false] ( exceptionGroup )? EOR ) )
-			// Grammars\\ANTLRTreePrinter.g3:203:4: ^( RULE id= ID ( modifier )? ^( ARG (arg= ARG_ACTION )? ) ^( RET (ret= ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ruleAction )* b= block[false] ( exceptionGroup )? EOR )
-			{
-			Match(input,RULE,Follow._RULE_in_rule582);
-
-			Match(input, TokenTypes.Down, null);
-			id=(GrammarAST)Match(input,ID,Follow._ID_in_rule586);
-			// Grammars\\ANTLRTreePrinter.g3:204:4: ( modifier )?
-			int alt18=2;
-			int LA18_0 = input.LA(1);
-
-			if ( (LA18_0==FRAGMENT||(LA18_0>=PRIVATE && LA18_0<=PUBLIC)) )
-			{
-				alt18=1;
-			}
-			switch ( alt18 )
-			{
-			case 1:
-				// Grammars\\ANTLRTreePrinter.g3:204:5: modifier
-				{
-				PushFollow(Follow._modifier_in_rule592);
-				modifier();
-
-				state._fsp--;
-
-
-				}
-				break;
-
-			}
-
-			@out((id!=null?id.Text:null));
-			Match(input,ARG,Follow._ARG_in_rule605);
-
-			if ( input.LA(1)==TokenTypes.Down )
-			{
-				Match(input, TokenTypes.Down, null);
-				// Grammars\\ANTLRTreePrinter.g3:206:10: (arg= ARG_ACTION )?
-				int alt19=2;
-				int LA19_0 = input.LA(1);
-
-				if ( (LA19_0==ARG_ACTION) )
-				{
-					alt19=1;
-				}
-				switch ( alt19 )
-				{
-				case 1:
-					// Grammars\\ANTLRTreePrinter.g3:206:11: arg= ARG_ACTION
-					{
-					arg=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule610);
-					@out("["+(arg!=null?arg.Text:null)+"]");
-
-					}
-					break;
-
-				}
-
-
-				Match(input, TokenTypes.Up, null);
-			}
-			Match(input,RET,Follow._RET_in_rule623);
-
-			if ( input.LA(1)==TokenTypes.Down )
-			{
-				Match(input, TokenTypes.Down, null);
-				// Grammars\\ANTLRTreePrinter.g3:207:10: (ret= ARG_ACTION )?
-				int alt20=2;
-				int LA20_0 = input.LA(1);
-
-				if ( (LA20_0==ARG_ACTION) )
-				{
-					alt20=1;
-				}
-				switch ( alt20 )
-				{
-				case 1:
-					// Grammars\\ANTLRTreePrinter.g3:207:11: ret= ARG_ACTION
-					{
-					ret=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule628);
-					@out(" returns ["+(ret!=null?ret.Text:null)+"]");
-
-					}
-					break;
-
-				}
-
-
-				Match(input, TokenTypes.Up, null);
-			}
-			// Grammars\\ANTLRTreePrinter.g3:208:4: ( throwsSpec )?
-			int alt21=2;
-			int LA21_0 = input.LA(1);
-
-			if ( (LA21_0==THROWS) )
-			{
-				alt21=1;
-			}
-			switch ( alt21 )
-			{
-			case 1:
-				// Grammars\\ANTLRTreePrinter.g3:208:5: throwsSpec
-				{
-				PushFollow(Follow._throwsSpec_in_rule641);
-				throwsSpec();
-
-				state._fsp--;
-
-
-				}
-				break;
-
-			}
-
-			// Grammars\\ANTLRTreePrinter.g3:209:4: ( optionsSpec )?
-			int alt22=2;
-			int LA22_0 = input.LA(1);
-
-			if ( (LA22_0==OPTIONS) )
-			{
-				alt22=1;
-			}
-			switch ( alt22 )
-			{
-			case 1:
-				// Grammars\\ANTLRTreePrinter.g3:209:5: optionsSpec
-				{
-				PushFollow(Follow._optionsSpec_in_rule649);
-				optionsSpec();
-
-				state._fsp--;
-
-
-				}
-				break;
-
-			}
-
-			// Grammars\\ANTLRTreePrinter.g3:210:4: ( ruleScopeSpec )?
-			int alt23=2;
-			int LA23_0 = input.LA(1);
-
-			if ( (LA23_0==SCOPE) )
-			{
-				alt23=1;
-			}
-			switch ( alt23 )
-			{
-			case 1:
-				// Grammars\\ANTLRTreePrinter.g3:210:5: ruleScopeSpec
-				{
-				PushFollow(Follow._ruleScopeSpec_in_rule657);
-				ruleScopeSpec();
-
-				state._fsp--;
-
-
-				}
-				break;
-
-			}
-
-			// Grammars\\ANTLRTreePrinter.g3:211:4: ( ruleAction )*
-			for ( ; ; )
-			{
-				int alt24=2;
-				int LA24_0 = input.LA(1);
-
-				if ( (LA24_0==AMPERSAND) )
-				{
-					alt24=1;
-				}
-
-
-				switch ( alt24 )
-				{
-				case 1:
-					// Grammars\\ANTLRTreePrinter.g3:211:5: ruleAction
-					{
-					PushFollow(Follow._ruleAction_in_rule665);
-					ruleAction();
-
-					state._fsp--;
-
-
-					}
-					break;
-
-				default:
-					goto loop24;
-				}
-			}
-
-			loop24:
-				;
-
-
-			@out(" :");
-
-							if ( input.LA(5) == NOT || input.LA(5) == ASSIGN )
-								@out(" ");
-
-			PushFollow(Follow._block_in_rule684);
-			b=block(false);
-
-			state._fsp--;
-
-			// Grammars\\ANTLRTreePrinter.g3:218:4: ( exceptionGroup )?
-			int alt25=2;
-			int LA25_0 = input.LA(1);
-
-			if ( (LA25_0==CATCH||LA25_0==FINALLY) )
-			{
-				alt25=1;
-			}
-			switch ( alt25 )
-			{
-			case 1:
-				// Grammars\\ANTLRTreePrinter.g3:218:5: exceptionGroup
-				{
-				PushFollow(Follow._exceptionGroup_in_rule691);
-				exceptionGroup();
-
-				state._fsp--;
-
-
-				}
-				break;
-
-			}
-
-			Match(input,EOR,Follow._EOR_in_rule698);
-			@out(";\n");
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "rule"
-
-
-	// $ANTLR start "ruleAction"
-	// Grammars\\ANTLRTreePrinter.g3:223:0: ruleAction : ^( AMPERSAND id= ID a= ACTION ) ;
-	private void ruleAction(  )
-	{
-		GrammarAST id=null;
-		GrammarAST a=null;
-
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:224:4: ( ^( AMPERSAND id= ID a= ACTION ) )
-			// Grammars\\ANTLRTreePrinter.g3:224:4: ^( AMPERSAND id= ID a= ACTION )
-			{
-			Match(input,AMPERSAND,Follow._AMPERSAND_in_ruleAction716);
-
-			Match(input, TokenTypes.Down, null);
-			id=(GrammarAST)Match(input,ID,Follow._ID_in_ruleAction720);
-			a=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_ruleAction724);
-
-			Match(input, TokenTypes.Up, null);
-			if ( showActions ) @out("@"+(id!=null?id.Text:null)+"{"+(a!=null?a.Text:null)+"}");
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "ruleAction"
-
-	public class modifier_return : TreeRuleReturnScope
-	{
-	}
-
-	// $ANTLR start "modifier"
-	// Grammars\\ANTLRTreePrinter.g3:228:0: modifier : ( 'protected' | 'public' | 'private' | 'fragment' );
-	private ANTLRTreePrinter.modifier_return modifier(  )
-	{
-		ANTLRTreePrinter.modifier_return retval = new ANTLRTreePrinter.modifier_return();
-		retval.start = input.LT(1);
-
-		@out(((GrammarAST)retval.Start).Text); @out(" ");
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:231:4: ( 'protected' | 'public' | 'private' | 'fragment' )
-			// Grammars\\ANTLRTreePrinter.g3:
-			{
-			if ( input.LA(1)==FRAGMENT||(input.LA(1)>=PRIVATE && input.LA(1)<=PUBLIC) )
-			{
-				input.Consume();
-				state.errorRecovery=false;
-			}
-			else
-			{
-				MismatchedSetException mse = new MismatchedSetException(null,input);
-				throw mse;
-			}
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "modifier"
-
-
-	// $ANTLR start "throwsSpec"
-	// Grammars\\ANTLRTreePrinter.g3:237:0: throwsSpec : ^( 'throws' ( ID )+ ) ;
-	private void throwsSpec(  )
-	{
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:238:4: ( ^( 'throws' ( ID )+ ) )
-			// Grammars\\ANTLRTreePrinter.g3:238:4: ^( 'throws' ( ID )+ )
-			{
-			Match(input,THROWS,Follow._THROWS_in_throwsSpec773);
-
-			Match(input, TokenTypes.Down, null);
-			// Grammars\\ANTLRTreePrinter.g3:238:15: ( ID )+
-			int cnt26=0;
-			for ( ; ; )
-			{
-				int alt26=2;
-				int LA26_0 = input.LA(1);
-
-				if ( (LA26_0==ID) )
-				{
-					alt26=1;
-				}
-
-
-				switch ( alt26 )
-				{
-				case 1:
-					// Grammars\\ANTLRTreePrinter.g3:238:0: ID
-					{
-					Match(input,ID,Follow._ID_in_throwsSpec775);
-
-					}
-					break;
-
-				default:
-					if ( cnt26 >= 1 )
-						goto loop26;
-
-					EarlyExitException eee26 = new EarlyExitException( 26, input );
-					throw eee26;
-				}
-				cnt26++;
-			}
-			loop26:
-				;
-
-
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "throwsSpec"
-
-
-	// $ANTLR start "ruleScopeSpec"
-	// Grammars\\ANTLRTreePrinter.g3:241:0: ruleScopeSpec : ^( 'scope' ( ruleAction )* ( ACTION )? ( ID )* ) ;
-	private void ruleScopeSpec(  )
-	{
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:242:4: ( ^( 'scope' ( ruleAction )* ( ACTION )? ( ID )* ) )
-			// Grammars\\ANTLRTreePrinter.g3:242:4: ^( 'scope' ( ruleAction )* ( ACTION )? ( ID )* )
-			{
-			Match(input,SCOPE,Follow._SCOPE_in_ruleScopeSpec790);
-
-			if ( input.LA(1)==TokenTypes.Down )
-			{
-				Match(input, TokenTypes.Down, null);
-				// Grammars\\ANTLRTreePrinter.g3:242:15: ( ruleAction )*
-				for ( ; ; )
-				{
-					int alt27=2;
-					int LA27_0 = input.LA(1);
-
-					if ( (LA27_0==AMPERSAND) )
-					{
-						alt27=1;
-					}
-
-
-					switch ( alt27 )
-					{
-					case 1:
-						// Grammars\\ANTLRTreePrinter.g3:242:0: ruleAction
-						{
-						PushFollow(Follow._ruleAction_in_ruleScopeSpec792);
-						ruleAction();
-
-						state._fsp--;
-
-
-						}
-						break;
-
-					default:
-						goto loop27;
-					}
-				}
-
-				loop27:
-					;
-
-
-				// Grammars\\ANTLRTreePrinter.g3:242:27: ( ACTION )?
-				int alt28=2;
-				int LA28_0 = input.LA(1);
-
-				if ( (LA28_0==ACTION) )
-				{
-					alt28=1;
-				}
-				switch ( alt28 )
-				{
-				case 1:
-					// Grammars\\ANTLRTreePrinter.g3:242:28: ACTION
-					{
-					Match(input,ACTION,Follow._ACTION_in_ruleScopeSpec796);
-
-					}
-					break;
-
-				}
-
-				// Grammars\\ANTLRTreePrinter.g3:242:37: ( ID )*
-				for ( ; ; )
-				{
-					int alt29=2;
-					int LA29_0 = input.LA(1);
-
-					if ( (LA29_0==ID) )
-					{
-						alt29=1;
-					}
-
-
-					switch ( alt29 )
-					{
-					case 1:
-						// Grammars\\ANTLRTreePrinter.g3:242:39: ID
-						{
-						Match(input,ID,Follow._ID_in_ruleScopeSpec802);
-
-						}
-						break;
-
-					default:
-						goto loop29;
-					}
-				}
-
-				loop29:
-					;
-
-
-
-				Match(input, TokenTypes.Up, null);
-			}
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "ruleScopeSpec"
-
-	public class block_return : TreeRuleReturnScope
-	{
-	}
-
-	// $ANTLR start "block"
-	// Grammars\\ANTLRTreePrinter.g3:245:0: block[bool forceParens] : ^( BLOCK ( optionsSpec )? alternative rewrite ( alternative rewrite )* EOB ) ;
-	private ANTLRTreePrinter.block_return block( bool forceParens )
-	{
-		ANTLRTreePrinter.block_return retval = new ANTLRTreePrinter.block_return();
-		retval.start = input.LT(1);
-
-
-		int numAlts = CountAltsForBlock(((GrammarAST)retval.Start));
-
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:250:4: ( ^( BLOCK ( optionsSpec )? alternative rewrite ( alternative rewrite )* EOB ) )
-			// Grammars\\ANTLRTreePrinter.g3:250:4: ^( BLOCK ( optionsSpec )? alternative rewrite ( alternative rewrite )* EOB )
-			{
-			Match(input,BLOCK,Follow._BLOCK_in_block826);
-
-
-							if ( forceParens||numAlts>1 )
-							{
-								//for ( Antlr.Runtime.Tree.Tree parent = ((GrammarAST)retval.Start).getParent(); parent != null && parent.getType() != RULE; parent = parent.getParent() )
-								//{
-								//	if ( parent.getType() == BLOCK && countAltsForBlock((GrammarAST)parent) > 1 )
-								//	{
-								//		@out(" ");
-								//		break;
-								//	}
-								//}
-								@out(" (");
-							}
-
-
-			Match(input, TokenTypes.Down, null);
-			// Grammars\\ANTLRTreePrinter.g3:265:4: ( optionsSpec )?
-			int alt30=2;
-			int LA30_0 = input.LA(1);
-
-			if ( (LA30_0==OPTIONS) )
-			{
-				alt30=1;
-			}
-			switch ( alt30 )
-			{
-			case 1:
-				// Grammars\\ANTLRTreePrinter.g3:265:5: optionsSpec
-				{
-				PushFollow(Follow._optionsSpec_in_block837);
-				optionsSpec();
-
-				state._fsp--;
-
-				@out(" :");
-
-				}
-				break;
-
-			}
-
-			PushFollow(Follow._alternative_in_block847);
-			alternative();
-
-			state._fsp--;
-
-			PushFollow(Follow._rewrite_in_block849);
-			rewrite();
-
-			state._fsp--;
-
-			// Grammars\\ANTLRTreePrinter.g3:266:24: ( alternative rewrite )*
-			for ( ; ; )
-			{
-				int alt31=2;
-				int LA31_0 = input.LA(1);
-
-				if ( (LA31_0==ALT) )
-				{
-					alt31=1;
-				}
-
-
-				switch ( alt31 )
-				{
-				case 1:
-					// Grammars\\ANTLRTreePrinter.g3:266:26: alternative rewrite
-					{
-					@out("|");
-					PushFollow(Follow._alternative_in_block855);
-					alternative();
-
-					state._fsp--;
-
-					PushFollow(Follow._rewrite_in_block857);
-					rewrite();
-
-					state._fsp--;
-
-
-					}
-					break;
-
-				default:
-					goto loop31;
-				}
-			}
-
-			loop31:
-				;
-
-
-			Match(input,EOB,Follow._EOB_in_block865);
-			if ( forceParens||numAlts>1 ) @out(")");
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "block"
-
-
-	// $ANTLR start "alternative"
-	// Grammars\\ANTLRTreePrinter.g3:271:0: alternative : ^( ALT ( element )+ EOA ) ;
-	private void alternative(  )
-	{
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:272:4: ( ^( ALT ( element )+ EOA ) )
-			// Grammars\\ANTLRTreePrinter.g3:272:4: ^( ALT ( element )+ EOA )
-			{
-			Match(input,ALT,Follow._ALT_in_alternative887);
-
-			Match(input, TokenTypes.Down, null);
-			// Grammars\\ANTLRTreePrinter.g3:272:11: ( element )+
-			int cnt32=0;
-			for ( ; ; )
-			{
-				int alt32=2;
-				int LA32_0 = input.LA(1);
-
-				if ( (LA32_0==ACTION||(LA32_0>=ASSIGN && LA32_0<=BLOCK)||(LA32_0>=CHAR_LITERAL && LA32_0<=CHAR_RANGE)||LA32_0==CLOSURE||LA32_0==DOT||LA32_0==EPSILON||LA32_0==FORCED_ACTION||LA32_0==GATED_SEMPRED||LA32_0==LABEL||LA32_0==NOT||LA32_0==OPTIONAL||(LA32_0>=PLUS_ASSIGN && LA32_0<=POSITIVE_CLOSURE)||LA32_0==RANGE||LA32_0==ROOT||LA32_0==RULE_REF||LA32_0==SEMPRED||(LA32_0>=STRING_LITERAL && LA32_0<=SYNPRED)||LA32_0==TOKEN_REF||LA32_0==TREE_BEGIN||LA32_0==WILDCARD) )
-				{
-					alt32=1;
-				}
-
-
-				switch ( alt32 )
-				{
-				case 1:
-					// Grammars\\ANTLRTreePrinter.g3:272:12: element
-					{
-					PushFollow(Follow._element_in_alternative890);
-					element();
-
-					state._fsp--;
-
-
-					}
-					break;
-
-				default:
-					if ( cnt32 >= 1 )
-						goto loop32;
-
-					EarlyExitException eee32 = new EarlyExitException( 32, input );
-					throw eee32;
-				}
-				cnt32++;
-			}
-			loop32:
-				;
-
-
-			Match(input,EOA,Follow._EOA_in_alternative894);
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "alternative"
-
-
-	// $ANTLR start "exceptionGroup"
-	// Grammars\\ANTLRTreePrinter.g3:275:0: exceptionGroup : ( ( exceptionHandler )+ ( finallyClause )? | finallyClause );
-	private void exceptionGroup(  )
-	{
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:276:4: ( ( exceptionHandler )+ ( finallyClause )? | finallyClause )
-			int alt35=2;
-			int LA35_0 = input.LA(1);
-
-			if ( (LA35_0==CATCH) )
-			{
-				alt35=1;
-			}
-			else if ( (LA35_0==FINALLY) )
-			{
-				alt35=2;
-			}
-			else
-			{
-				NoViableAltException nvae = new NoViableAltException("", 35, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt35 )
-			{
-			case 1:
-				// Grammars\\ANTLRTreePrinter.g3:276:4: ( exceptionHandler )+ ( finallyClause )?
-				{
-				// Grammars\\ANTLRTreePrinter.g3:276:4: ( exceptionHandler )+
-				int cnt33=0;
-				for ( ; ; )
-				{
-					int alt33=2;
-					int LA33_0 = input.LA(1);
-
-					if ( (LA33_0==CATCH) )
-					{
-						alt33=1;
-					}
-
-
-					switch ( alt33 )
-					{
-					case 1:
-						// Grammars\\ANTLRTreePrinter.g3:276:6: exceptionHandler
-						{
-						PushFollow(Follow._exceptionHandler_in_exceptionGroup909);
-						exceptionHandler();
-
-						state._fsp--;
-
-
-						}
-						break;
-
-					default:
-						if ( cnt33 >= 1 )
-							goto loop33;
-
-						EarlyExitException eee33 = new EarlyExitException( 33, input );
-						throw eee33;
-					}
-					cnt33++;
-				}
-				loop33:
-					;
-
-
-				// Grammars\\ANTLRTreePrinter.g3:276:26: ( finallyClause )?
-				int alt34=2;
-				int LA34_0 = input.LA(1);
-
-				if ( (LA34_0==FINALLY) )
-				{
-					alt34=1;
-				}
-				switch ( alt34 )
-				{
-				case 1:
-					// Grammars\\ANTLRTreePrinter.g3:276:27: finallyClause
-					{
-					PushFollow(Follow._finallyClause_in_exceptionGroup915);
-					finallyClause();
-
-					state._fsp--;
-
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLRTreePrinter.g3:277:4: finallyClause
-				{
-				PushFollow(Follow._finallyClause_in_exceptionGroup922);
-				finallyClause();
-
-				state._fsp--;
-
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "exceptionGroup"
-
-
-	// $ANTLR start "exceptionHandler"
-	// Grammars\\ANTLRTreePrinter.g3:280:0: exceptionHandler : ^( 'catch' ARG_ACTION ACTION ) ;
-	private void exceptionHandler(  )
-	{
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:281:4: ( ^( 'catch' ARG_ACTION ACTION ) )
-			// Grammars\\ANTLRTreePrinter.g3:281:4: ^( 'catch' ARG_ACTION ACTION )
-			{
-			Match(input,CATCH,Follow._CATCH_in_exceptionHandler934);
-
-			Match(input, TokenTypes.Down, null);
-			Match(input,ARG_ACTION,Follow._ARG_ACTION_in_exceptionHandler936);
-			Match(input,ACTION,Follow._ACTION_in_exceptionHandler938);
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "exceptionHandler"
-
-
-	// $ANTLR start "finallyClause"
-	// Grammars\\ANTLRTreePrinter.g3:284:0: finallyClause : ^( 'finally' ACTION ) ;
-	private void finallyClause(  )
-	{
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:285:4: ( ^( 'finally' ACTION ) )
-			// Grammars\\ANTLRTreePrinter.g3:285:4: ^( 'finally' ACTION )
-			{
-			Match(input,FINALLY,Follow._FINALLY_in_finallyClause951);
-
-			Match(input, TokenTypes.Down, null);
-			Match(input,ACTION,Follow._ACTION_in_finallyClause953);
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "finallyClause"
-
-
-	// $ANTLR start "single_rewrite"
-	// Grammars\\ANTLRTreePrinter.g3:288:0: single_rewrite : ^( REWRITE ( SEMPRED )? ( alternative | rewrite_template | ETC | ACTION ) ) ;
-	private void single_rewrite(  )
-	{
-		GrammarAST SEMPRED1=null;
-		GrammarAST ACTION2=null;
-
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:289:4: ( ^( REWRITE ( SEMPRED )? ( alternative | rewrite_template | ETC | ACTION ) ) )
-			// Grammars\\ANTLRTreePrinter.g3:289:4: ^( REWRITE ( SEMPRED )? ( alternative | rewrite_template | ETC | ACTION ) )
-			{
-			Match(input,REWRITE,Follow._REWRITE_in_single_rewrite967);
-
-			@out(" ->");
-
-			Match(input, TokenTypes.Down, null);
-			// Grammars\\ANTLRTreePrinter.g3:290:4: ( SEMPRED )?
-			int alt36=2;
-			int LA36_0 = input.LA(1);
-
-			if ( (LA36_0==SEMPRED) )
-			{
-				alt36=1;
-			}
-			switch ( alt36 )
-			{
-			case 1:
-				// Grammars\\ANTLRTreePrinter.g3:290:6: SEMPRED
-				{
-				SEMPRED1=(GrammarAST)Match(input,SEMPRED,Follow._SEMPRED_in_single_rewrite976);
-				@out(" {"+(SEMPRED1!=null?SEMPRED1.Text:null)+"}?");
-
-				}
-				break;
-
-			}
-
-			// Grammars\\ANTLRTreePrinter.g3:292:4: ( alternative | rewrite_template | ETC | ACTION )
-			int alt37=4;
-			switch ( input.LA(1) )
-			{
-			case ALT:
-				{
-				alt37=1;
-				}
-				break;
-			case TEMPLATE:
-				{
-				alt37=2;
-				}
-				break;
-			case ETC:
-				{
-				alt37=3;
-				}
-				break;
-			case ACTION:
-				{
-				alt37=4;
-				}
-				break;
-			default:
-				{
-					NoViableAltException nvae = new NoViableAltException("", 37, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt37 )
-			{
-			case 1:
-				// Grammars\\ANTLRTreePrinter.g3:292:6: alternative
-				{
-				PushFollow(Follow._alternative_in_single_rewrite991);
-				alternative();
-
-				state._fsp--;
-
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLRTreePrinter.g3:293:6: rewrite_template
-				{
-				PushFollow(Follow._rewrite_template_in_single_rewrite998);
-				rewrite_template();
-
-				state._fsp--;
-
-
-				}
-				break;
-			case 3:
-				// Grammars\\ANTLRTreePrinter.g3:294:6: ETC
-				{
-				Match(input,ETC,Follow._ETC_in_single_rewrite1005);
-				@out("...");
-
-				}
-				break;
-			case 4:
-				// Grammars\\ANTLRTreePrinter.g3:295:6: ACTION
-				{
-				ACTION2=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_single_rewrite1014);
-				@out(" {"+(ACTION2!=null?ACTION2.Text:null)+"}");
-
-				}
-				break;
-
-			}
-
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "single_rewrite"
-
-
-	// $ANTLR start "rewrite_template"
-	// Grammars\\ANTLRTreePrinter.g3:300:0: rewrite_template : ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? ) ;
-	private void rewrite_template(  )
-	{
-		GrammarAST id=null;
-		GrammarAST ind=null;
-		GrammarAST arg=null;
-		GrammarAST a=null;
-		GrammarAST DOUBLE_QUOTE_STRING_LITERAL3=null;
-		GrammarAST DOUBLE_ANGLE_STRING_LITERAL4=null;
-
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:301:4: ( ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? ) )
-			// Grammars\\ANTLRTreePrinter.g3:301:4: ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? )
-			{
-			Match(input,TEMPLATE,Follow._TEMPLATE_in_rewrite_template1038);
-
-			Match(input, TokenTypes.Down, null);
-			// Grammars\\ANTLRTreePrinter.g3:302:4: (id= ID |ind= ACTION )
-			int alt38=2;
-			int LA38_0 = input.LA(1);
-
-			if ( (LA38_0==ID) )
-			{
-				alt38=1;
-			}
-			else if ( (LA38_0==ACTION) )
-			{
-				alt38=2;
-			}
-			else
-			{
-				NoViableAltException nvae = new NoViableAltException("", 38, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt38 )
-			{
-			case 1:
-				// Grammars\\ANTLRTreePrinter.g3:302:6: id= ID
-				{
-				id=(GrammarAST)Match(input,ID,Follow._ID_in_rewrite_template1047);
-				@out(" "+(id!=null?id.Text:null));
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLRTreePrinter.g3:303:6: ind= ACTION
-				{
-				ind=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_rewrite_template1058);
-				@out(" ({"+(ind!=null?ind.Text:null)+"})");
-
-				}
-				break;
-
-			}
-
-			Match(input,ARGLIST,Follow._ARGLIST_in_rewrite_template1072);
-
-			@out("(");
-
-			if ( input.LA(1)==TokenTypes.Down )
-			{
-				Match(input, TokenTypes.Down, null);
-				// Grammars\\ANTLRTreePrinter.g3:307:5: ( ^( ARG arg= ID a= ACTION ) )*
-				for ( ; ; )
-				{
-					int alt39=2;
-					int LA39_0 = input.LA(1);
-
-					if ( (LA39_0==ARG) )
-					{
-						alt39=1;
-					}
-
-
-					switch ( alt39 )
-					{
-					case 1:
-						// Grammars\\ANTLRTreePrinter.g3:307:7: ^( ARG arg= ID a= ACTION )
-						{
-						Match(input,ARG,Follow._ARG_in_rewrite_template1088);
-
-						Match(input, TokenTypes.Down, null);
-						arg=(GrammarAST)Match(input,ID,Follow._ID_in_rewrite_template1092);
-						@out((arg!=null?arg.Text:null)+"=");
-						a=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_rewrite_template1104);
-						@out((a!=null?a.Text:null));
-
-						Match(input, TokenTypes.Up, null);
-
-						}
-						break;
-
-					default:
-						goto loop39;
-					}
-				}
-
-				loop39:
-					;
-
-
-				@out(")");
-
-				Match(input, TokenTypes.Up, null);
-			}
-			// Grammars\\ANTLRTreePrinter.g3:313:4: ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )?
-			int alt40=3;
-			int LA40_0 = input.LA(1);
-
-			if ( (LA40_0==DOUBLE_QUOTE_STRING_LITERAL) )
-			{
-				alt40=1;
-			}
-			else if ( (LA40_0==DOUBLE_ANGLE_STRING_LITERAL) )
-			{
-				alt40=2;
-			}
-			switch ( alt40 )
-			{
-			case 1:
-				// Grammars\\ANTLRTreePrinter.g3:313:6: DOUBLE_QUOTE_STRING_LITERAL
-				{
-				DOUBLE_QUOTE_STRING_LITERAL3=(GrammarAST)Match(input,DOUBLE_QUOTE_STRING_LITERAL,Follow._DOUBLE_QUOTE_STRING_LITERAL_in_rewrite_template1140);
-				@out(" "+(DOUBLE_QUOTE_STRING_LITERAL3!=null?DOUBLE_QUOTE_STRING_LITERAL3.Text:null));
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLRTreePrinter.g3:314:6: DOUBLE_ANGLE_STRING_LITERAL
-				{
-				DOUBLE_ANGLE_STRING_LITERAL4=(GrammarAST)Match(input,DOUBLE_ANGLE_STRING_LITERAL,Follow._DOUBLE_ANGLE_STRING_LITERAL_in_rewrite_template1149);
-				@out(" "+(DOUBLE_ANGLE_STRING_LITERAL4!=null?DOUBLE_ANGLE_STRING_LITERAL4.Text:null));
-
-				}
-				break;
-
-			}
-
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "rewrite_template"
-
-
-	// $ANTLR start "rewrite"
-	// Grammars\\ANTLRTreePrinter.g3:319:0: rewrite : ( single_rewrite )* ;
-	private void rewrite(  )
-	{
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:320:4: ( ( single_rewrite )* )
-			// Grammars\\ANTLRTreePrinter.g3:320:4: ( single_rewrite )*
-			{
-			// Grammars\\ANTLRTreePrinter.g3:320:4: ( single_rewrite )*
-			for ( ; ; )
-			{
-				int alt41=2;
-				int LA41_0 = input.LA(1);
-
-				if ( (LA41_0==REWRITE) )
-				{
-					alt41=1;
-				}
-
-
-				switch ( alt41 )
-				{
-				case 1:
-					// Grammars\\ANTLRTreePrinter.g3:320:5: single_rewrite
-					{
-					PushFollow(Follow._single_rewrite_in_rewrite1173);
-					single_rewrite();
-
-					state._fsp--;
-
-
-					}
-					break;
-
-				default:
-					goto loop41;
-				}
-			}
-
-			loop41:
-				;
-
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "rewrite"
-
-
-	// $ANTLR start "element"
-	// Grammars\\ANTLRTreePrinter.g3:323:0: element : ( ^( ROOT element ) | ^( BANG element ) | atom | ^( NOT element ) | ^( RANGE atom atom ) | ^( CHAR_RANGE atom atom ) | ^( ASSIGN id= ID element ) | ^( PLUS_ASSIGN id2= ID element ) | ebnf | tree_ | ^( SYNPRED block[true] ) |a= ACTION |a2= FORCED_ACTION |pred= SEMPRED |spred= SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) |gpred= GATED_SEMPRED | EPSILON );
-	private void element(  )
-	{
-		GrammarAST id=null;
-		GrammarAST id2=null;
-		GrammarAST a=null;
-		GrammarAST a2=null;
-		GrammarAST pred=null;
-		GrammarAST spred=null;
-		GrammarAST gpred=null;
-
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:324:4: ( ^( ROOT element ) | ^( BANG element ) | atom | ^( NOT element ) | ^( RANGE atom atom ) | ^( CHAR_RANGE atom atom ) | ^( ASSIGN id= ID element ) | ^( PLUS_ASSIGN id2= ID element ) | ebnf | tree_ | ^( SYNPRED block[true] ) |a= ACTION |a2= FORCED_ACTION |pred= SEMPRED |spred= SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) |gpred= GATED_SEMPRED | EPSILON )
-			int alt43=18;
-			switch ( input.LA(1) )
-			{
-			case ROOT:
-				{
-				alt43=1;
-				}
-				break;
-			case BANG:
-				{
-				alt43=2;
-				}
-				break;
-			case CHAR_LITERAL:
-			case DOT:
-			case LABEL:
-			case RULE_REF:
-			case STRING_LITERAL:
-			case TOKEN_REF:
-			case WILDCARD:
-				{
-				alt43=3;
-				}
-				break;
-			case NOT:
-				{
-				alt43=4;
-				}
-				break;
-			case RANGE:
-				{
-				alt43=5;
-				}
-				break;
-			case CHAR_RANGE:
-				{
-				alt43=6;
-				}
-				break;
-			case ASSIGN:
-				{
-				alt43=7;
-				}
-				break;
-			case PLUS_ASSIGN:
-				{
-				alt43=8;
-				}
-				break;
-			case BLOCK:
-			case CLOSURE:
-			case OPTIONAL:
-			case POSITIVE_CLOSURE:
-				{
-				alt43=9;
-				}
-				break;
-			case TREE_BEGIN:
-				{
-				alt43=10;
-				}
-				break;
-			case SYNPRED:
-				{
-				alt43=11;
-				}
-				break;
-			case ACTION:
-				{
-				alt43=12;
-				}
-				break;
-			case FORCED_ACTION:
-				{
-				alt43=13;
-				}
-				break;
-			case SEMPRED:
-				{
-				alt43=14;
-				}
-				break;
-			case SYN_SEMPRED:
-				{
-				alt43=15;
-				}
-				break;
-			case BACKTRACK_SEMPRED:
-				{
-				alt43=16;
-				}
-				break;
-			case GATED_SEMPRED:
-				{
-				alt43=17;
-				}
-				break;
-			case EPSILON:
-				{
-				alt43=18;
-				}
-				break;
-			default:
-				{
-					NoViableAltException nvae = new NoViableAltException("", 43, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt43 )
-			{
-			case 1:
-				// Grammars\\ANTLRTreePrinter.g3:324:4: ^( ROOT element )
-				{
-				Match(input,ROOT,Follow._ROOT_in_element1187);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._element_in_element1189);
-				element();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLRTreePrinter.g3:325:4: ^( BANG element )
-				{
-				Match(input,BANG,Follow._BANG_in_element1196);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._element_in_element1198);
-				element();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 3:
-				// Grammars\\ANTLRTreePrinter.g3:326:4: atom
-				{
-				PushFollow(Follow._atom_in_element1204);
-				atom();
-
-				state._fsp--;
-
-
-				}
-				break;
-			case 4:
-				// Grammars\\ANTLRTreePrinter.g3:327:4: ^( NOT element )
-				{
-				Match(input,NOT,Follow._NOT_in_element1210);
-
-				@out("~");
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._element_in_element1214);
-				element();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 5:
-				// Grammars\\ANTLRTreePrinter.g3:328:4: ^( RANGE atom atom )
-				{
-				Match(input,RANGE,Follow._RANGE_in_element1221);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._atom_in_element1223);
-				atom();
-
-				state._fsp--;
-
-				@out("..");
-				PushFollow(Follow._atom_in_element1227);
-				atom();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 6:
-				// Grammars\\ANTLRTreePrinter.g3:329:4: ^( CHAR_RANGE atom atom )
-				{
-				Match(input,CHAR_RANGE,Follow._CHAR_RANGE_in_element1234);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._atom_in_element1236);
-				atom();
-
-				state._fsp--;
-
-				@out("..");
-				PushFollow(Follow._atom_in_element1240);
-				atom();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 7:
-				// Grammars\\ANTLRTreePrinter.g3:330:4: ^( ASSIGN id= ID element )
-				{
-				Match(input,ASSIGN,Follow._ASSIGN_in_element1247);
-
-				Match(input, TokenTypes.Down, null);
-				id=(GrammarAST)Match(input,ID,Follow._ID_in_element1251);
-				@out((id!=null?id.Text:null)+"=");
-				PushFollow(Follow._element_in_element1255);
-				element();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 8:
-				// Grammars\\ANTLRTreePrinter.g3:331:4: ^( PLUS_ASSIGN id2= ID element )
-				{
-				Match(input,PLUS_ASSIGN,Follow._PLUS_ASSIGN_in_element1262);
-
-				Match(input, TokenTypes.Down, null);
-				id2=(GrammarAST)Match(input,ID,Follow._ID_in_element1266);
-				@out((id2!=null?id2.Text:null)+"+=");
-				PushFollow(Follow._element_in_element1270);
-				element();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 9:
-				// Grammars\\ANTLRTreePrinter.g3:332:4: ebnf
-				{
-				PushFollow(Follow._ebnf_in_element1276);
-				ebnf();
-
-				state._fsp--;
-
-
-				}
-				break;
-			case 10:
-				// Grammars\\ANTLRTreePrinter.g3:333:4: tree_
-				{
-				PushFollow(Follow._tree__in_element1281);
-				tree_();
-
-				state._fsp--;
-
-
-				}
-				break;
-			case 11:
-				// Grammars\\ANTLRTreePrinter.g3:334:4: ^( SYNPRED block[true] )
-				{
-				Match(input,SYNPRED,Follow._SYNPRED_in_element1288);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._block_in_element1290);
-				block(true);
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-				@out("=>");
-
-				}
-				break;
-			case 12:
-				// Grammars\\ANTLRTreePrinter.g3:335:4: a= ACTION
-				{
-				a=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_element1302);
-				if ( showActions ) {@out("{"); @out((a!=null?a.Text:null)); @out("}");}
-
-				}
-				break;
-			case 13:
-				// Grammars\\ANTLRTreePrinter.g3:336:4: a2= FORCED_ACTION
-				{
-				a2=(GrammarAST)Match(input,FORCED_ACTION,Follow._FORCED_ACTION_in_element1312);
-				if ( showActions ) {@out("{{"); @out((a2!=null?a2.Text:null)); @out("}}");}
-
-				}
-				break;
-			case 14:
-				// Grammars\\ANTLRTreePrinter.g3:337:4: pred= SEMPRED
-				{
-				pred=(GrammarAST)Match(input,SEMPRED,Follow._SEMPRED_in_element1322);
-
-							if ( showActions )
-							{
-								@out("{");
-								@out((pred!=null?pred.Text:null));
-								@out("}?");
-							}
-							else
-							{
-								@out("{...}?");
-							}
-
-
-				}
-				break;
-			case 15:
-				// Grammars\\ANTLRTreePrinter.g3:350:4: spred= SYN_SEMPRED
-				{
-				spred=(GrammarAST)Match(input,SYN_SEMPRED,Follow._SYN_SEMPRED_in_element1333);
-
-							string name = (spred!=null?spred.Text:null);
-							GrammarAST predAST=grammar.GetSyntacticPredicate(name);
-							Block(predAST, true);
-							@out("=>");
-
-
-				}
-				break;
-			case 16:
-				// Grammars\\ANTLRTreePrinter.g3:357:4: ^( BACKTRACK_SEMPRED ( . )* )
-				{
-				Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_element1343);
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null);
-					// Grammars\\ANTLRTreePrinter.g3:357:24: ( . )*
-					for ( ; ; )
-					{
-						int alt42=2;
-						int LA42_0 = input.LA(1);
-
-						if ( ((LA42_0>=ACTION && LA42_0<=XDIGIT)) )
-						{
-							alt42=1;
-						}
-						else if ( (LA42_0==UP) )
-						{
-							alt42=2;
-						}
-
-
-						switch ( alt42 )
-						{
-						case 1:
-							// Grammars\\ANTLRTreePrinter.g3:357:0: .
-							{
-							MatchAny(input);
-
-							}
-							break;
-
-						default:
-							goto loop42;
-						}
-					}
-
-					loop42:
-						;
-
-
-
-					Match(input, TokenTypes.Up, null);
-				}
-
-				}
-				break;
-			case 17:
-				// Grammars\\ANTLRTreePrinter.g3:358:4: gpred= GATED_SEMPRED
-				{
-				gpred=(GrammarAST)Match(input,GATED_SEMPRED,Follow._GATED_SEMPRED_in_element1355);
-
-						if ( showActions ) {@out("{"); @out((gpred!=null?gpred.Text:null)); @out("}? =>");}
-						else {@out("{...}? =>");}
-
-
-				}
-				break;
-			case 18:
-				// Grammars\\ANTLRTreePrinter.g3:363:4: EPSILON
-				{
-				Match(input,EPSILON,Follow._EPSILON_in_element1364);
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "element"
-
-
-	// $ANTLR start "ebnf"
-	// Grammars\\ANTLRTreePrinter.g3:366:0: ebnf : ( block[true] | ^( OPTIONAL block[true] ) | ^( CLOSURE block[true] ) | ^( POSITIVE_CLOSURE block[true] ) );
-	private void ebnf(  )
-	{
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:367:4: ( block[true] | ^( OPTIONAL block[true] ) | ^( CLOSURE block[true] ) | ^( POSITIVE_CLOSURE block[true] ) )
-			int alt44=4;
-			switch ( input.LA(1) )
-			{
-			case BLOCK:
-				{
-				alt44=1;
-				}
-				break;
-			case OPTIONAL:
-				{
-				alt44=2;
-				}
-				break;
-			case CLOSURE:
-				{
-				alt44=3;
-				}
-				break;
-			case POSITIVE_CLOSURE:
-				{
-				alt44=4;
-				}
-				break;
-			default:
-				{
-					NoViableAltException nvae = new NoViableAltException("", 44, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt44 )
-			{
-			case 1:
-				// Grammars\\ANTLRTreePrinter.g3:367:4: block[true]
-				{
-				PushFollow(Follow._block_in_ebnf1375);
-				block(true);
-
-				state._fsp--;
-
-				@out(" ");
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLRTreePrinter.g3:368:4: ^( OPTIONAL block[true] )
-				{
-				Match(input,OPTIONAL,Follow._OPTIONAL_in_ebnf1385);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._block_in_ebnf1387);
-				block(true);
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-				@out("? ");
-
-				}
-				break;
-			case 3:
-				// Grammars\\ANTLRTreePrinter.g3:369:4: ^( CLOSURE block[true] )
-				{
-				Match(input,CLOSURE,Follow._CLOSURE_in_ebnf1399);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._block_in_ebnf1401);
-				block(true);
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-				@out("* ");
-
-				}
-				break;
-			case 4:
-				// Grammars\\ANTLRTreePrinter.g3:370:4: ^( POSITIVE_CLOSURE block[true] )
-				{
-				Match(input,POSITIVE_CLOSURE,Follow._POSITIVE_CLOSURE_in_ebnf1414);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._block_in_ebnf1416);
-				block(true);
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-				@out("+ ");
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "ebnf"
-
-
-	// $ANTLR start "tree_"
-	// Grammars\\ANTLRTreePrinter.g3:373:0: tree_ : ^( TREE_BEGIN element ( element )* ) ;
-	private void tree_(  )
-	{
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:374:4: ( ^( TREE_BEGIN element ( element )* ) )
-			// Grammars\\ANTLRTreePrinter.g3:374:4: ^( TREE_BEGIN element ( element )* )
-			{
-			Match(input,TREE_BEGIN,Follow._TREE_BEGIN_in_tree_1433);
-
-			@out(" ^(");
-
-			Match(input, TokenTypes.Down, null);
-			PushFollow(Follow._element_in_tree_1437);
-			element();
-
-			state._fsp--;
-
-			// Grammars\\ANTLRTreePrinter.g3:374:40: ( element )*
-			for ( ; ; )
-			{
-				int alt45=2;
-				int LA45_0 = input.LA(1);
-
-				if ( (LA45_0==ACTION||(LA45_0>=ASSIGN && LA45_0<=BLOCK)||(LA45_0>=CHAR_LITERAL && LA45_0<=CHAR_RANGE)||LA45_0==CLOSURE||LA45_0==DOT||LA45_0==EPSILON||LA45_0==FORCED_ACTION||LA45_0==GATED_SEMPRED||LA45_0==LABEL||LA45_0==NOT||LA45_0==OPTIONAL||(LA45_0>=PLUS_ASSIGN && LA45_0<=POSITIVE_CLOSURE)||LA45_0==RANGE||LA45_0==ROOT||LA45_0==RULE_REF||LA45_0==SEMPRED||(LA45_0>=STRING_LITERAL && LA45_0<=SYNPRED)||LA45_0==TOKEN_REF||LA45_0==TREE_BEGIN||LA45_0==WILDCARD) )
-				{
-					alt45=1;
-				}
-
-
-				switch ( alt45 )
-				{
-				case 1:
-					// Grammars\\ANTLRTreePrinter.g3:374:41: element
-					{
-					PushFollow(Follow._element_in_tree_1440);
-					element();
-
-					state._fsp--;
-
-
-					}
-					break;
-
-				default:
-					goto loop45;
-				}
-			}
-
-			loop45:
-				;
-
-
-			@out(") ");
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "tree_"
-
-	public class atom_return : TreeRuleReturnScope
-	{
-	}
-
-	// $ANTLR start "atom"
-	// Grammars\\ANTLRTreePrinter.g3:377:0: atom : ( ( ^( RULE_REF (rarg= ARG_ACTION )? ( ast_suffix )? ) | ^( TOKEN_REF (targ= ARG_ACTION )? ( ast_suffix )? ) | ^( CHAR_LITERAL ( ast_suffix )? ) | ^( STRING_LITERAL ( ast_suffix )? ) | ^( WILDCARD ( ast_suffix )? ) ) | LABEL | ^( DOT ID atom ) );
-	private ANTLRTreePrinter.atom_return atom(  )
-	{
-		ANTLRTreePrinter.atom_return retval = new ANTLRTreePrinter.atom_return();
-		retval.start = input.LT(1);
-
-		GrammarAST rarg=null;
-		GrammarAST targ=null;
-		GrammarAST LABEL5=null;
-		GrammarAST ID6=null;
-
-		@out(" ");
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:380:4: ( ( ^( RULE_REF (rarg= ARG_ACTION )? ( ast_suffix )? ) | ^( TOKEN_REF (targ= ARG_ACTION )? ( ast_suffix )? ) | ^( CHAR_LITERAL ( ast_suffix )? ) | ^( STRING_LITERAL ( ast_suffix )? ) | ^( WILDCARD ( ast_suffix )? ) ) | LABEL | ^( DOT ID atom ) )
-			int alt54=3;
-			switch ( input.LA(1) )
-			{
-			case CHAR_LITERAL:
-			case RULE_REF:
-			case STRING_LITERAL:
-			case TOKEN_REF:
-			case WILDCARD:
-				{
-				alt54=1;
-				}
-				break;
-			case LABEL:
-				{
-				alt54=2;
-				}
-				break;
-			case DOT:
-				{
-				alt54=3;
-				}
-				break;
-			default:
-				{
-					NoViableAltException nvae = new NoViableAltException("", 54, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt54 )
-			{
-			case 1:
-				// Grammars\\ANTLRTreePrinter.g3:380:4: ( ^( RULE_REF (rarg= ARG_ACTION )? ( ast_suffix )? ) | ^( TOKEN_REF (targ= ARG_ACTION )? ( ast_suffix )? ) | ^( CHAR_LITERAL ( ast_suffix )? ) | ^( STRING_LITERAL ( ast_suffix )? ) | ^( WILDCARD ( ast_suffix )? ) )
-				{
-				// Grammars\\ANTLRTreePrinter.g3:380:4: ( ^( RULE_REF (rarg= ARG_ACTION )? ( ast_suffix )? ) | ^( TOKEN_REF (targ= ARG_ACTION )? ( ast_suffix )? ) | ^( CHAR_LITERAL ( ast_suffix )? ) | ^( STRING_LITERAL ( ast_suffix )? ) | ^( WILDCARD ( ast_suffix )? ) )
-				int alt53=5;
-				switch ( input.LA(1) )
-				{
-				case RULE_REF:
-					{
-					alt53=1;
-					}
-					break;
-				case TOKEN_REF:
-					{
-					alt53=2;
-					}
-					break;
-				case CHAR_LITERAL:
-					{
-					alt53=3;
-					}
-					break;
-				case STRING_LITERAL:
-					{
-					alt53=4;
-					}
-					break;
-				case WILDCARD:
-					{
-					alt53=5;
-					}
-					break;
-				default:
-					{
-						NoViableAltException nvae = new NoViableAltException("", 53, 0, input);
-
-						throw nvae;
-					}
-				}
-
-				switch ( alt53 )
-				{
-				case 1:
-					// Grammars\\ANTLRTreePrinter.g3:380:6: ^( RULE_REF (rarg= ARG_ACTION )? ( ast_suffix )? )
-					{
-					Match(input,RULE_REF,Follow._RULE_REF_in_atom1466);
-
-					@out(((GrammarAST)retval.Start).ToString());
-
-					if ( input.LA(1)==TokenTypes.Down )
-					{
-						Match(input, TokenTypes.Down, null);
-						// Grammars\\ANTLRTreePrinter.g3:381:5: (rarg= ARG_ACTION )?
-						int alt46=2;
-						int LA46_0 = input.LA(1);
-
-						if ( (LA46_0==ARG_ACTION) )
-						{
-							alt46=1;
-						}
-						switch ( alt46 )
-						{
-						case 1:
-							// Grammars\\ANTLRTreePrinter.g3:381:6: rarg= ARG_ACTION
-							{
-							rarg=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1478);
-							@out("["+rarg.ToString()+"]");
-
-							}
-							break;
-
-						}
-
-						// Grammars\\ANTLRTreePrinter.g3:382:5: ( ast_suffix )?
-						int alt47=2;
-						int LA47_0 = input.LA(1);
-
-						if ( (LA47_0==BANG||LA47_0==ROOT) )
-						{
-							alt47=1;
-						}
-						switch ( alt47 )
-						{
-						case 1:
-							// Grammars\\ANTLRTreePrinter.g3:382:6: ast_suffix
-							{
-							PushFollow(Follow._ast_suffix_in_atom1489);
-							ast_suffix();
-
-							state._fsp--;
-
-
-							}
-							break;
-
-						}
-
-
-						Match(input, TokenTypes.Up, null);
-					}
-
-					}
-					break;
-				case 2:
-					// Grammars\\ANTLRTreePrinter.g3:384:5: ^( TOKEN_REF (targ= ARG_ACTION )? ( ast_suffix )? )
-					{
-					Match(input,TOKEN_REF,Follow._TOKEN_REF_in_atom1504);
-
-					@out(((GrammarAST)retval.Start).ToString());
-
-					if ( input.LA(1)==TokenTypes.Down )
-					{
-						Match(input, TokenTypes.Down, null);
-						// Grammars\\ANTLRTreePrinter.g3:385:5: (targ= ARG_ACTION )?
-						int alt48=2;
-						int LA48_0 = input.LA(1);
-
-						if ( (LA48_0==ARG_ACTION) )
-						{
-							alt48=1;
-						}
-						switch ( alt48 )
-						{
-						case 1:
-							// Grammars\\ANTLRTreePrinter.g3:385:6: targ= ARG_ACTION
-							{
-							targ=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1517);
-							@out("["+targ.ToString()+"]");
-
-							}
-							break;
-
-						}
-
-						// Grammars\\ANTLRTreePrinter.g3:386:5: ( ast_suffix )?
-						int alt49=2;
-						int LA49_0 = input.LA(1);
-
-						if ( (LA49_0==BANG||LA49_0==ROOT) )
-						{
-							alt49=1;
-						}
-						switch ( alt49 )
-						{
-						case 1:
-							// Grammars\\ANTLRTreePrinter.g3:386:6: ast_suffix
-							{
-							PushFollow(Follow._ast_suffix_in_atom1529);
-							ast_suffix();
-
-							state._fsp--;
-
-
-							}
-							break;
-
-						}
-
-
-						Match(input, TokenTypes.Up, null);
-					}
-
-					}
-					break;
-				case 3:
-					// Grammars\\ANTLRTreePrinter.g3:388:5: ^( CHAR_LITERAL ( ast_suffix )? )
-					{
-					Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_atom1544);
-
-					@out(((GrammarAST)retval.Start).ToString());
-
-					if ( input.LA(1)==TokenTypes.Down )
-					{
-						Match(input, TokenTypes.Down, null);
-						// Grammars\\ANTLRTreePrinter.g3:389:5: ( ast_suffix )?
-						int alt50=2;
-						int LA50_0 = input.LA(1);
-
-						if ( (LA50_0==BANG||LA50_0==ROOT) )
-						{
-							alt50=1;
-						}
-						switch ( alt50 )
-						{
-						case 1:
-							// Grammars\\ANTLRTreePrinter.g3:389:6: ast_suffix
-							{
-							PushFollow(Follow._ast_suffix_in_atom1553);
-							ast_suffix();
-
-							state._fsp--;
-
-
-							}
-							break;
-
-						}
-
-
-						Match(input, TokenTypes.Up, null);
-					}
-
-					}
-					break;
-				case 4:
-					// Grammars\\ANTLRTreePrinter.g3:391:5: ^( STRING_LITERAL ( ast_suffix )? )
-					{
-					Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_atom1568);
-
-					@out(((GrammarAST)retval.Start).ToString());
-
-					if ( input.LA(1)==TokenTypes.Down )
-					{
-						Match(input, TokenTypes.Down, null);
-						// Grammars\\ANTLRTreePrinter.g3:392:5: ( ast_suffix )?
-						int alt51=2;
-						int LA51_0 = input.LA(1);
-
-						if ( (LA51_0==BANG||LA51_0==ROOT) )
-						{
-							alt51=1;
-						}
-						switch ( alt51 )
-						{
-						case 1:
-							// Grammars\\ANTLRTreePrinter.g3:392:6: ast_suffix
-							{
-							PushFollow(Follow._ast_suffix_in_atom1577);
-							ast_suffix();
-
-							state._fsp--;
-
-
-							}
-							break;
-
-						}
-
-
-						Match(input, TokenTypes.Up, null);
-					}
-
-					}
-					break;
-				case 5:
-					// Grammars\\ANTLRTreePrinter.g3:394:5: ^( WILDCARD ( ast_suffix )? )
-					{
-					Match(input,WILDCARD,Follow._WILDCARD_in_atom1592);
-
-					@out(((GrammarAST)retval.Start).ToString());
-
-					if ( input.LA(1)==TokenTypes.Down )
-					{
-						Match(input, TokenTypes.Down, null);
-						// Grammars\\ANTLRTreePrinter.g3:395:5: ( ast_suffix )?
-						int alt52=2;
-						int LA52_0 = input.LA(1);
-
-						if ( (LA52_0==BANG||LA52_0==ROOT) )
-						{
-							alt52=1;
-						}
-						switch ( alt52 )
-						{
-						case 1:
-							// Grammars\\ANTLRTreePrinter.g3:395:6: ast_suffix
-							{
-							PushFollow(Follow._ast_suffix_in_atom1602);
-							ast_suffix();
-
-							state._fsp--;
-
-
-							}
-							break;
-
-						}
-
-
-						Match(input, TokenTypes.Up, null);
-					}
-
-					}
-					break;
-
-				}
-
-				@out(" ");
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLRTreePrinter.g3:399:4: LABEL
-				{
-				LABEL5=(GrammarAST)Match(input,LABEL,Follow._LABEL_in_atom1622);
-				@out(" $"+(LABEL5!=null?LABEL5.Text:null));
-
-				}
-				break;
-			case 3:
-				// Grammars\\ANTLRTreePrinter.g3:400:4: ^( DOT ID atom )
-				{
-				Match(input,DOT,Follow._DOT_in_atom1631);
-
-				Match(input, TokenTypes.Down, null);
-				ID6=(GrammarAST)Match(input,ID,Follow._ID_in_atom1633);
-				@out((ID6!=null?ID6.Text:null)+".");
-				PushFollow(Follow._atom_in_atom1637);
-				atom();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "atom"
-
-
-	// $ANTLR start "ast_suffix"
-	// Grammars\\ANTLRTreePrinter.g3:403:0: ast_suffix : ( ROOT | BANG );
-	private void ast_suffix(  )
-	{
-		try
-		{
-			// Grammars\\ANTLRTreePrinter.g3:404:4: ( ROOT | BANG )
-			int alt55=2;
-			int LA55_0 = input.LA(1);
-
-			if ( (LA55_0==ROOT) )
-			{
-				alt55=1;
-			}
-			else if ( (LA55_0==BANG) )
-			{
-				alt55=2;
-			}
-			else
-			{
-				NoViableAltException nvae = new NoViableAltException("", 55, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt55 )
-			{
-			case 1:
-				// Grammars\\ANTLRTreePrinter.g3:404:4: ROOT
-				{
-				Match(input,ROOT,Follow._ROOT_in_ast_suffix1650);
-				@out("^");
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLRTreePrinter.g3:405:4: BANG
-				{
-				Match(input,BANG,Follow._BANG_in_ast_suffix1657);
-				@out("!");
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "ast_suffix"
-	#endregion Rules
-
-
-	#region Follow sets
-	private static class Follow
-	{
-		public static readonly BitSet _grammar__in_toString72 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _rule_in_toString78 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _alternative_in_toString84 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _element_in_toString90 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _single_rewrite_in_toString96 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _EOR_in_toString102 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _LEXER_GRAMMAR_in_grammar_127 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _grammarSpec_in_grammar_129 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _PARSER_GRAMMAR_in_grammar_139 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _grammarSpec_in_grammar_141 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _TREE_GRAMMAR_in_grammar_151 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _grammarSpec_in_grammar_153 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _COMBINED_GRAMMAR_in_grammar_163 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _grammarSpec_in_grammar_165 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _SCOPE_in_attrScope181 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_attrScope183 = new BitSet(new ulong[]{0x210UL});
-		public static readonly BitSet _ruleAction_in_attrScope185 = new BitSet(new ulong[]{0x210UL});
-		public static readonly BitSet _ACTION_in_attrScope188 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ID_in_grammarSpec204 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
-		public static readonly BitSet _DOC_COMMENT_in_grammarSpec213 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
-		public static readonly BitSet _optionsSpec_in_grammarSpec223 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
-		public static readonly BitSet _delegateGrammars_in_grammarSpec232 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
-		public static readonly BitSet _tokensSpec_in_grammarSpec239 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
-		public static readonly BitSet _attrScope_in_grammarSpec246 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
-		public static readonly BitSet _actions_in_grammarSpec253 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
-		public static readonly BitSet _rules_in_grammarSpec259 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _action_in_actions272 = new BitSet(new ulong[]{0x202UL});
-		public static readonly BitSet _AMPERSAND_in_action293 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_action297 = new BitSet(new ulong[]{0x80000000010UL});
-		public static readonly BitSet _ID_in_action306 = new BitSet(new ulong[]{0x10UL});
-		public static readonly BitSet _ACTION_in_action310 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ACTION_in_action325 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _OPTIONS_in_optionsSpec357 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _option_in_optionsSpec365 = new BitSet(new ulong[]{0x2008UL});
-		public static readonly BitSet _ASSIGN_in_option391 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_option395 = new BitSet(new ulong[]{0x880000040000UL,0x200000UL});
-		public static readonly BitSet _optionValue_in_option399 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ID_in_optionValue414 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _STRING_LITERAL_in_optionValue434 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _CHAR_LITERAL_in_optionValue443 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _INT_in_optionValue454 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _IMPORT_in_delegateGrammars484 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ASSIGN_in_delegateGrammars489 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_delegateGrammars491 = new BitSet(new ulong[]{0x80000000000UL});
-		public static readonly BitSet _ID_in_delegateGrammars493 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ID_in_delegateGrammars498 = new BitSet(new ulong[]{0x80000002008UL});
-		public static readonly BitSet _TOKENS_in_tokensSpec516 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _tokenSpec_in_tokensSpec520 = new BitSet(new ulong[]{0x2008UL,0x4000000UL});
-		public static readonly BitSet _TOKEN_REF_in_tokenSpec536 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ASSIGN_in_tokenSpec543 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _TOKEN_REF_in_tokenSpec545 = new BitSet(new ulong[]{0x40000UL,0x200000UL});
-		public static readonly BitSet _set_in_tokenSpec547 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _rule_in_rules566 = new BitSet(new ulong[]{0x400200008000202UL,0x8005000UL});
-		public static readonly BitSet _RULE_in_rule582 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_rule586 = new BitSet(new ulong[]{0x10000000400UL,0xEUL});
-		public static readonly BitSet _modifier_in_rule592 = new BitSet(new ulong[]{0x400UL});
-		public static readonly BitSet _ARG_in_rule605 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_ACTION_in_rule610 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _RET_in_rule623 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_ACTION_in_rule628 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _throwsSpec_in_rule641 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
-		public static readonly BitSet _optionsSpec_in_rule649 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
-		public static readonly BitSet _ruleScopeSpec_in_rule657 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
-		public static readonly BitSet _ruleAction_in_rule665 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
-		public static readonly BitSet _block_in_rule684 = new BitSet(new ulong[]{0x4400020000UL});
-		public static readonly BitSet _exceptionGroup_in_rule691 = new BitSet(new ulong[]{0x400000000UL});
-		public static readonly BitSet _EOR_in_rule698 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _AMPERSAND_in_ruleAction716 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_ruleAction720 = new BitSet(new ulong[]{0x10UL});
-		public static readonly BitSet _ACTION_in_ruleAction724 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _set_in_modifier746 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _THROWS_in_throwsSpec773 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_throwsSpec775 = new BitSet(new ulong[]{0x80000000008UL});
-		public static readonly BitSet _SCOPE_in_ruleScopeSpec790 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ruleAction_in_ruleScopeSpec792 = new BitSet(new ulong[]{0x80000000218UL});
-		public static readonly BitSet _ACTION_in_ruleScopeSpec796 = new BitSet(new ulong[]{0x80000000008UL});
-		public static readonly BitSet _ID_in_ruleScopeSpec802 = new BitSet(new ulong[]{0x80000000008UL});
-		public static readonly BitSet _BLOCK_in_block826 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _optionsSpec_in_block837 = new BitSet(new ulong[]{0x100UL});
-		public static readonly BitSet _alternative_in_block847 = new BitSet(new ulong[]{0x200000100UL,0x200UL});
-		public static readonly BitSet _rewrite_in_block849 = new BitSet(new ulong[]{0x200000100UL});
-		public static readonly BitSet _alternative_in_block855 = new BitSet(new ulong[]{0x200000100UL,0x200UL});
-		public static readonly BitSet _rewrite_in_block857 = new BitSet(new ulong[]{0x200000100UL});
-		public static readonly BitSet _EOB_in_block865 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ALT_in_alternative887 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _element_in_alternative890 = new BitSet(new ulong[]{0x86810289202DE210UL,0xA4E16421UL});
-		public static readonly BitSet _EOA_in_alternative894 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _exceptionHandler_in_exceptionGroup909 = new BitSet(new ulong[]{0x4000020002UL});
-		public static readonly BitSet _finallyClause_in_exceptionGroup915 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _finallyClause_in_exceptionGroup922 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _CATCH_in_exceptionHandler934 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_ACTION_in_exceptionHandler936 = new BitSet(new ulong[]{0x10UL});
-		public static readonly BitSet _ACTION_in_exceptionHandler938 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _FINALLY_in_finallyClause951 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ACTION_in_finallyClause953 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _REWRITE_in_single_rewrite967 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _SEMPRED_in_single_rewrite976 = new BitSet(new ulong[]{0x2000000110UL,0x1000000UL});
-		public static readonly BitSet _alternative_in_single_rewrite991 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _rewrite_template_in_single_rewrite998 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ETC_in_single_rewrite1005 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ACTION_in_single_rewrite1014 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _TEMPLATE_in_rewrite_template1038 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_rewrite_template1047 = new BitSet(new ulong[]{0x1000UL});
-		public static readonly BitSet _ACTION_in_rewrite_template1058 = new BitSet(new ulong[]{0x1000UL});
-		public static readonly BitSet _ARGLIST_in_rewrite_template1072 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_in_rewrite_template1088 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_rewrite_template1092 = new BitSet(new ulong[]{0x10UL});
-		public static readonly BitSet _ACTION_in_rewrite_template1104 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _DOUBLE_QUOTE_STRING_LITERAL_in_rewrite_template1140 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _DOUBLE_ANGLE_STRING_LITERAL_in_rewrite_template1149 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _single_rewrite_in_rewrite1173 = new BitSet(new ulong[]{0x2UL,0x200UL});
-		public static readonly BitSet _ROOT_in_element1187 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _element_in_element1189 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _BANG_in_element1196 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _element_in_element1198 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _atom_in_element1204 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _NOT_in_element1210 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _element_in_element1214 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _RANGE_in_element1221 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _atom_in_element1223 = new BitSet(new ulong[]{0x1000020040000UL,0x84202000UL});
-		public static readonly BitSet _atom_in_element1227 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _CHAR_RANGE_in_element1234 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _atom_in_element1236 = new BitSet(new ulong[]{0x1000020040000UL,0x84202000UL});
-		public static readonly BitSet _atom_in_element1240 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ASSIGN_in_element1247 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_element1251 = new BitSet(new ulong[]{0x86810289202DE210UL,0xA4E16421UL});
-		public static readonly BitSet _element_in_element1255 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _PLUS_ASSIGN_in_element1262 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_element1266 = new BitSet(new ulong[]{0x86810289202DE210UL,0xA4E16421UL});
-		public static readonly BitSet _element_in_element1270 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ebnf_in_element1276 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _tree__in_element1281 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _SYNPRED_in_element1288 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _block_in_element1290 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ACTION_in_element1302 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _FORCED_ACTION_in_element1312 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _SEMPRED_in_element1322 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _SYN_SEMPRED_in_element1333 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _BACKTRACK_SEMPRED_in_element1343 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _GATED_SEMPRED_in_element1355 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _EPSILON_in_element1364 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _block_in_ebnf1375 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _OPTIONAL_in_ebnf1385 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _block_in_ebnf1387 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _CLOSURE_in_ebnf1399 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _block_in_ebnf1401 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _POSITIVE_CLOSURE_in_ebnf1414 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _block_in_ebnf1416 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _TREE_BEGIN_in_tree_1433 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _element_in_tree_1437 = new BitSet(new ulong[]{0x86810289202DE218UL,0xA4E16421UL});
-		public static readonly BitSet _element_in_tree_1440 = new BitSet(new ulong[]{0x86810289202DE218UL,0xA4E16421UL});
-		public static readonly BitSet _RULE_REF_in_atom1466 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_ACTION_in_atom1478 = new BitSet(new ulong[]{0x8008UL,0x400UL});
-		public static readonly BitSet _ast_suffix_in_atom1489 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _TOKEN_REF_in_atom1504 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_ACTION_in_atom1517 = new BitSet(new ulong[]{0x8008UL,0x400UL});
-		public static readonly BitSet _ast_suffix_in_atom1529 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _CHAR_LITERAL_in_atom1544 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ast_suffix_in_atom1553 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _STRING_LITERAL_in_atom1568 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ast_suffix_in_atom1577 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _WILDCARD_in_atom1592 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ast_suffix_in_atom1602 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _LABEL_in_atom1622 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _DOT_in_atom1631 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_atom1633 = new BitSet(new ulong[]{0x1000020040000UL,0x84202000UL});
-		public static readonly BitSet _atom_in_atom1637 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ROOT_in_ast_suffix1650 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _BANG_in_ast_suffix1657 = new BitSet(new ulong[]{0x2UL});
-
-	}
-	#endregion Follow sets
-}
-
-} // namespace Antlr3.Grammars
diff --git a/Antlr3/Grammars/ActionAnalysisLexer.cs b/Antlr3/Grammars/ActionAnalysisLexer.cs
deleted file mode 100644
index 09ba29c..0000000
--- a/Antlr3/Grammars/ActionAnalysisLexer.cs
+++ /dev/null
@@ -1,490 +0,0 @@
-// $ANTLR 3.1.2 Grammars\\ActionAnalysisLexer.g3 2009-09-30 13:28:39
-
-// The variable 'variable' is assigned but its value is never used.
-#pragma warning disable 219
-// Unreachable code detected.
-#pragma warning disable 162
-
-
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Grammar conversion to ANTLR v3 and C#:
- Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-	notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-	derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-using Antlr3.Tool;
-
-
-using System.Collections.Generic;
-using Antlr.Runtime;
-using Stack = System.Collections.Generic.Stack<object>;
-using List = System.Collections.IList;
-using ArrayList = System.Collections.Generic.List<object>;
-using Map = System.Collections.IDictionary;
-using HashMap = System.Collections.Generic.Dictionary<object, object>;
-namespace Antlr3.Grammars
-{
-/** We need to set Rule.referencedPredefinedRuleAttributes before
- *  code generation.  This filter looks at an action in context of
- *  its rule and outer alternative number and figures out which
- *  rules have predefined prefs referenced.  I need this so I can
- *  remove unusued labels.  This also tracks, for labeled rules,
- *  which are referenced by actions.
- */
-[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.1.2")]
-[System.CLSCompliant(false)]
-public partial class ActionAnalysisLexer : Lexer
-{
-	public const int EOF=-1;
-	public const int ID=4;
-	public const int X=5;
-	public const int X_Y=6;
-	public const int Y=7;
-
-    // delegates
-    // delegators
-
-	public ActionAnalysisLexer() {}
-	public ActionAnalysisLexer( ICharStream input )
-		: this( input, new RecognizerSharedState() )
-	{
-	}
-	public ActionAnalysisLexer( ICharStream input, RecognizerSharedState state )
-		: base( input, state )
-	{
-
-	}
-	public override string GrammarFileName { get { return "Grammars\\ActionAnalysisLexer.g3"; } }
-
-	public override IToken NextToken()
-	{
-		for ( ; ;)
-		{
-			if ( input.LA(1)==CharStreamConstants.EndOfFile )
-			{
-				return Tokens.EndOfFile;
-			}
-			state.token = null;
-			state.channel = TokenChannels.Default;
-			state.tokenStartCharIndex = input.Index;
-			state.tokenStartCharPositionInLine = input.CharPositionInLine;
-			state.tokenStartLine = input.Line;
-			state.text = null;
-			try
-			{
-				int m = input.Mark();
-				state.backtracking=1;
-				state.failed=false;
-				mTokens();
-				state.backtracking=0;
-
-				if ( state.failed )
-				{
-					input.Rewind(m);
-					input.Consume();
-				}
-				else
-				{
-					Emit();
-					return state.token;
-				}
-			}
-			catch ( RecognitionException re )
-			{
-				// shouldn't happen in backtracking mode, but...
-				ReportError(re);
-				Recover(re);
-			}
-		}
-	}
-
-	public override void Memoize( IIntStream input, int ruleIndex, int ruleStartIndex )
-	{
-		if ( state.backtracking > 1 )
-			base.Memoize( input, ruleIndex, ruleStartIndex );
-	}
-
-	public override bool AlreadyParsedRule(IIntStream input, int ruleIndex)
-	{
-		if ( state.backtracking > 1 )
-			return base.AlreadyParsedRule(input, ruleIndex);
-
-		return false;
-	}// $ANTLR start "X_Y"
-	private void mX_Y()
-	{
-		try
-		{
-			int _type = X_Y;
-			int _channel = DefaultTokenChannel;
-			CommonToken x=null;
-			CommonToken y=null;
-
-			// Grammars\\ActionAnalysisLexer.g3:92:4: ( '$' x= ID '.' y= ID {...}?)
-			// Grammars\\ActionAnalysisLexer.g3:92:4: '$' x= ID '.' y= ID {...}?
-			{
-			Match('$'); if (state.failed) return ;
-			int xStart57 = CharIndex;
-			mID(); if (state.failed) return ;
-			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart57, CharIndex-1);
-			Match('.'); if (state.failed) return ;
-			int yStart63 = CharIndex;
-			mID(); if (state.failed) return ;
-			y = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, yStart63, CharIndex-1);
-			if ( !((enclosingRule!=null)) )
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "X_Y", "enclosingRule!=null");
-			}
-			if ( state.backtracking==1 )
-			{
-
-							AttributeScope scope = null;
-							string refdRuleName = null;
-							if ( (x!=null?x.Text:null).Equals(enclosingRule.name) )
-							{
-								// ref to enclosing rule.
-								refdRuleName = (x!=null?x.Text:null);
-								scope = enclosingRule.GetLocalAttributeScope((y!=null?y.Text:null));
-							}
-							else if ( enclosingRule.GetRuleLabel((x!=null?x.Text:null))!=null )
-							{
-								// ref to rule label
-								Grammar.LabelElementPair pair = enclosingRule.GetRuleLabel((x!=null?x.Text:null));
-								pair.actionReferencesLabel = true;
-								refdRuleName = pair.referencedRuleName;
-								Rule refdRule = grammar.GetRule(refdRuleName);
-								if ( refdRule!=null )
-								{
-									scope = refdRule.GetLocalAttributeScope((y!=null?y.Text:null));
-								}
-							}
-							else if ( enclosingRule.GetRuleRefsInAlt(x.Text, outerAltNum)!=null )
-							{
-								// ref to rule referenced in this alt
-								refdRuleName = (x!=null?x.Text:null);
-								Rule refdRule = grammar.GetRule(refdRuleName);
-								if ( refdRule!=null )
-								{
-									scope = refdRule.GetLocalAttributeScope((y!=null?y.Text:null));
-								}
-							}
-							if ( scope!=null &&
-								 (scope.isPredefinedRuleScope||scope.isPredefinedLexerRuleScope) )
-							{
-								grammar.ReferenceRuleLabelPredefinedAttribute(refdRuleName);
-								//System.out.println("referenceRuleLabelPredefinedAttribute for "+refdRuleName);
-							}
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "X_Y"
-
-	// $ANTLR start "X"
-	private void mX()
-	{
-		try
-		{
-			int _type = X;
-			int _channel = DefaultTokenChannel;
-			CommonToken ID1=null;
-
-			// Grammars\\ActionAnalysisLexer.g3:135:4: ( '$' ID {...}?)
-			// Grammars\\ActionAnalysisLexer.g3:135:4: '$' ID {...}?
-			{
-			Match('$'); if (state.failed) return ;
-			int ID1Start84 = CharIndex;
-			mID(); if (state.failed) return ;
-			ID1 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ID1Start84, CharIndex-1);
-			if ( !((enclosingRule!=null && enclosingRule.GetRuleLabel((ID1!=null?ID1.Text:null))!=null)) )
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "X", "enclosingRule!=null && enclosingRule.GetRuleLabel($ID.text)!=null");
-			}
-			if ( state.backtracking==1 )
-			{
-
-							Grammar.LabelElementPair pair = enclosingRule.GetRuleLabel((ID1!=null?ID1.Text:null));
-							pair.actionReferencesLabel = true;
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "X"
-
-	// $ANTLR start "Y"
-	private void mY()
-	{
-		try
-		{
-			int _type = Y;
-			int _channel = DefaultTokenChannel;
-			CommonToken ID2=null;
-
-			// Grammars\\ActionAnalysisLexer.g3:144:4: ( '$' ID {...}?)
-			// Grammars\\ActionAnalysisLexer.g3:144:4: '$' ID {...}?
-			{
-			Match('$'); if (state.failed) return ;
-			int ID2Start106 = CharIndex;
-			mID(); if (state.failed) return ;
-			ID2 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ID2Start106, CharIndex-1);
-			if ( !((enclosingRule!=null && enclosingRule.GetLocalAttributeScope((ID2!=null?ID2.Text:null))!=null)) )
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "Y", "enclosingRule!=null && enclosingRule.GetLocalAttributeScope($ID.text)!=null");
-			}
-			if ( state.backtracking==1 )
-			{
-
-							AttributeScope scope = enclosingRule.GetLocalAttributeScope((ID2!=null?ID2.Text:null));
-							if ( scope!=null &&
-								 (scope.isPredefinedRuleScope||scope.isPredefinedLexerRuleScope) )
-							{
-								grammar.ReferenceRuleLabelPredefinedAttribute(enclosingRule.name);
-								//System.out.println("referenceRuleLabelPredefinedAttribute for "+(ID2!=null?ID2.Text:null));
-							}
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "Y"
-
-	// $ANTLR start "ID"
-	private void mID()
-	{
-		try
-		{
-			// Grammars\\ActionAnalysisLexer.g3:158:4: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
-			// Grammars\\ActionAnalysisLexer.g3:158:4: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
-			{
-			if ( (input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z') )
-			{
-				input.Consume();
-			state.failed=false;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				MismatchedSetException mse = new MismatchedSetException(null,input);
-				Recover(mse);
-				throw mse;}
-
-			// Grammars\\ActionAnalysisLexer.g3:158:28: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
-			for ( ; ; )
-			{
-				int alt1=2;
-				int LA1_0 = input.LA(1);
-
-				if ( ((LA1_0>='0' && LA1_0<='9')||(LA1_0>='A' && LA1_0<='Z')||LA1_0=='_'||(LA1_0>='a' && LA1_0<='z')) )
-				{
-					alt1=1;
-				}
-
-
-				switch ( alt1 )
-				{
-				case 1:
-					// Grammars\\ActionAnalysisLexer.g3:
-					{
-					input.Consume();
-					state.failed=false;
-
-					}
-					break;
-
-				default:
-					goto loop1;
-				}
-			}
-
-			loop1:
-				;
-
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ID"
-
-	public override void mTokens()
-	{
-		// Grammars\\ActionAnalysisLexer.g3:1:41: ( X_Y | X | Y )
-		int alt2=3;
-		int LA2_0 = input.LA(1);
-
-		if ( (LA2_0=='$') )
-		{
-			int LA2_1 = input.LA(2);
-
-			if ( (EvaluatePredicate(synpred1_ActionAnalysisLexer_fragment)) )
-			{
-				alt2=1;
-			}
-			else if ( (EvaluatePredicate(synpred2_ActionAnalysisLexer_fragment)) )
-			{
-				alt2=2;
-			}
-			else if ( (true) )
-			{
-				alt2=3;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				NoViableAltException nvae = new NoViableAltException("", 2, 1, input);
-
-				throw nvae;
-			}
-		}
-		else
-		{
-			if (state.backtracking>0) {state.failed=true; return ;}
-			NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
-
-			throw nvae;
-		}
-		switch ( alt2 )
-		{
-		case 1:
-			// Grammars\\ActionAnalysisLexer.g3:1:41: X_Y
-			{
-
-			mX_Y(); if (state.failed) return ;
-
-			}
-			break;
-		case 2:
-			// Grammars\\ActionAnalysisLexer.g3:1:45: X
-			{
-
-			mX(); if (state.failed) return ;
-
-			}
-			break;
-		case 3:
-			// Grammars\\ActionAnalysisLexer.g3:1:47: Y
-			{
-			mY(); if (state.failed) return ;
-
-			}
-			break;
-
-		}
-
-	}
-
-	// $ANTLR start synpred1_ActionAnalysisLexer
-	public void synpred1_ActionAnalysisLexer_fragment()
-	{
-		// Grammars\\ActionAnalysisLexer.g3:1:0: ( X_Y )
-		// Grammars\\ActionAnalysisLexer.g3:1:41: X_Y
-		{
-		mX_Y(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred1_ActionAnalysisLexer
-
-	// $ANTLR start synpred2_ActionAnalysisLexer
-	public void synpred2_ActionAnalysisLexer_fragment()
-	{
-		// Grammars\\ActionAnalysisLexer.g3:1:0: ( X )
-		// Grammars\\ActionAnalysisLexer.g3:1:45: X
-		{
-		mX(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred2_ActionAnalysisLexer
-
-	#region Synpreds
-	bool EvaluatePredicate( System.Action fragment )
-	{
-		state.backtracking++;
-		int start = input.Mark();
-		try
-		{
-			fragment();
-		}
-		catch ( RecognitionException re )
-		{
-			System.Console.Error.WriteLine("impossible: "+re);
-		}
-		bool success = !state.failed;
-		input.Rewind(start);
-		state.backtracking--;
-		state.failed=false;
-		return success;
-	}
-	#endregion Synpreds
-
-
-	#region DFA
-
-	protected override void InitDFAs()
-	{
-		base.InitDFAs();
-	}
-
-
-	#endregion
-
-}
-
-} // namespace Antlr3.Grammars
diff --git a/Antlr3/Grammars/ActionTranslator.cs b/Antlr3/Grammars/ActionTranslator.cs
deleted file mode 100644
index 600d0d5..0000000
--- a/Antlr3/Grammars/ActionTranslator.cs
+++ /dev/null
@@ -1,3385 +0,0 @@
-// $ANTLR 3.1.2 Grammars\\ActionTranslator.g3 2009-09-30 13:28:35
-
-// The variable 'variable' is assigned but its value is never used.
-#pragma warning disable 219
-// Unreachable code detected.
-#pragma warning disable 162
-
-
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Grammar conversion to ANTLR v3 and C#:
- Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-	notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-	derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-using Antlr3.Tool;
-using StringTemplate = Antlr3.ST.StringTemplate;
-
-
-using System.Collections.Generic;
-using Antlr.Runtime;
-using Stack = System.Collections.Generic.Stack<object>;
-using List = System.Collections.IList;
-using ArrayList = System.Collections.Generic.List<object>;
-using Map = System.Collections.IDictionary;
-using HashMap = System.Collections.Generic.Dictionary<object, object>;
-namespace Antlr3.Grammars
-{
-[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.1.2")]
-[System.CLSCompliant(false)]
-public partial class ActionTranslator : Lexer
-{
-	public const int EOF=-1;
-	public const int ACTION=4;
-	public const int ARG=5;
-	public const int ATTR_VALUE_EXPR=6;
-	public const int DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR=7;
-	public const int DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR=8;
-	public const int DYNAMIC_SCOPE_ATTR=9;
-	public const int ENCLOSING_RULE_SCOPE_ATTR=10;
-	public const int ERROR_SCOPED_XY=11;
-	public const int ERROR_X=12;
-	public const int ERROR_XY=13;
-	public const int ESC=14;
-	public const int ID=15;
-	public const int INDIRECT_TEMPLATE_INSTANCE=16;
-	public const int INT=17;
-	public const int ISOLATED_DYNAMIC_SCOPE=18;
-	public const int ISOLATED_LEXER_RULE_REF=19;
-	public const int ISOLATED_TOKEN_REF=20;
-	public const int LABEL_REF=21;
-	public const int LOCAL_ATTR=22;
-	public const int RULE_SCOPE_ATTR=23;
-	public const int SCOPE_INDEX_EXPR=24;
-	public const int SET_ATTRIBUTE=25;
-	public const int SET_DYNAMIC_SCOPE_ATTR=26;
-	public const int SET_ENCLOSING_RULE_SCOPE_ATTR=27;
-	public const int SET_EXPR_ATTRIBUTE=28;
-	public const int SET_LOCAL_ATTR=29;
-	public const int SET_RULE_SCOPE_ATTR=30;
-	public const int SET_TOKEN_SCOPE_ATTR=31;
-	public const int TEMPLATE_EXPR=32;
-	public const int TEMPLATE_INSTANCE=33;
-	public const int TEXT=34;
-	public const int TOKEN_SCOPE_ATTR=35;
-	public const int UNKNOWN_SYNTAX=36;
-	public const int WS=37;
-
-    // delegates
-    // delegators
-
-	public ActionTranslator() {}
-	public ActionTranslator( ICharStream input )
-		: this( input, new RecognizerSharedState() )
-	{
-	}
-	public ActionTranslator( ICharStream input, RecognizerSharedState state )
-		: base( input, state )
-	{
-
-	}
-	public override string GrammarFileName { get { return "Grammars\\ActionTranslator.g3"; } }
-
-	public override IToken NextToken()
-	{
-		for ( ; ;)
-		{
-			if ( input.LA(1)==CharStreamConstants.EndOfFile )
-			{
-				return Tokens.EndOfFile;
-			}
-			state.token = null;
-			state.channel = TokenChannels.Default;
-			state.tokenStartCharIndex = input.Index;
-			state.tokenStartCharPositionInLine = input.CharPositionInLine;
-			state.tokenStartLine = input.Line;
-			state.text = null;
-			try
-			{
-				int m = input.Mark();
-				state.backtracking=1;
-				state.failed=false;
-				mTokens();
-				state.backtracking=0;
-
-				if ( state.failed )
-				{
-					input.Rewind(m);
-					input.Consume();
-				}
-				else
-				{
-					Emit();
-					return state.token;
-				}
-			}
-			catch ( RecognitionException re )
-			{
-				// shouldn't happen in backtracking mode, but...
-				ReportError(re);
-				Recover(re);
-			}
-		}
-	}
-
-	public override void Memoize( IIntStream input, int ruleIndex, int ruleStartIndex )
-	{
-		if ( state.backtracking > 1 )
-			base.Memoize( input, ruleIndex, ruleStartIndex );
-	}
-
-	public override bool AlreadyParsedRule(IIntStream input, int ruleIndex)
-	{
-		if ( state.backtracking > 1 )
-			return base.AlreadyParsedRule(input, ruleIndex);
-
-		return false;
-	}// $ANTLR start "SET_ENCLOSING_RULE_SCOPE_ATTR"
-	private void mSET_ENCLOSING_RULE_SCOPE_ATTR()
-	{
-		try
-		{
-			int _type = SET_ENCLOSING_RULE_SCOPE_ATTR;
-			int _channel = DefaultTokenChannel;
-			CommonToken x=null;
-			CommonToken y=null;
-			CommonToken expr=null;
-
-			// Grammars\\ActionTranslator.g3:91:4: ( '$' x= ID '.' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?)
-			// Grammars\\ActionTranslator.g3:91:4: '$' x= ID '.' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?
-			{
-			Match('$'); if (state.failed) return ;
-			int xStart60 = CharIndex;
-			mID(); if (state.failed) return ;
-			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart60, CharIndex-1);
-			Match('.'); if (state.failed) return ;
-			int yStart66 = CharIndex;
-			mID(); if (state.failed) return ;
-			y = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, yStart66, CharIndex-1);
-			// Grammars\\ActionTranslator.g3:91:22: ( WS )?
-			int alt1=2;
-			int LA1_0 = input.LA(1);
-
-			if ( ((LA1_0>='\t' && LA1_0<='\n')||LA1_0=='\r'||LA1_0==' ') )
-			{
-				alt1=1;
-			}
-			switch ( alt1 )
-			{
-			case 1:
-				// Grammars\\ActionTranslator.g3:91:0: WS
-				{
-				mWS(); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-			Match('='); if (state.failed) return ;
-			int exprStart75 = CharIndex;
-			mATTR_VALUE_EXPR(); if (state.failed) return ;
-			expr = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, exprStart75, CharIndex-1);
-			Match(';'); if (state.failed) return ;
-			if ( !((enclosingRule!=null &&
-				                         (x!=null?x.Text:null).Equals(enclosingRule.name) &&
-				                         enclosingRule.GetLocalAttributeScope((y!=null?y.Text:null))!=null)) )
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "SET_ENCLOSING_RULE_SCOPE_ATTR", "enclosingRule!=null &&\r\n\t                         $x.text.Equals(enclosingRule.name) &&\r\n\t                         enclosingRule.GetLocalAttributeScope($y.text)!=null");
-			}
-			if ( state.backtracking==1 )
-			{
-
-							StringTemplate st = null;
-							AttributeScope scope = enclosingRule.GetLocalAttributeScope((y!=null?y.Text:null));
-							if ( scope.isPredefinedRuleScope )
-							{
-								if ( (y!=null?y.Text:null).Equals("st") || (y!=null?y.Text:null).Equals("tree") )
-								{
-									st = Template("ruleSetPropertyRef_"+(y!=null?y.Text:null));
-									grammar.ReferenceRuleLabelPredefinedAttribute((x!=null?x.Text:null));
-									st.SetAttribute("scope", (x!=null?x.Text:null));
-									st.SetAttribute("attr", (y!=null?y.Text:null));
-									st.SetAttribute("expr", TranslateAction((expr!=null?expr.Text:null)));
-								}
-								else
-								{
-									ErrorManager.GrammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
-															  grammar,
-															  actionToken,
-															  (x!=null?x.Text:null),
-															  (y!=null?y.Text:null));
-								}
-							}
-							else if ( scope.isPredefinedLexerRuleScope )
-							{
-					    		// this is a better message to emit than the previous one...
-								ErrorManager.GrammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
-														  grammar,
-														  actionToken,
-														  (x!=null?x.Text:null),
-														  (y!=null?y.Text:null));
-							}
-							else if ( scope.isParameterScope )
-							{
-								st = Template("parameterSetAttributeRef");
-								st.SetAttribute("attr", scope.GetAttribute((y!=null?y.Text:null)));
-								st.SetAttribute("expr", TranslateAction((expr!=null?expr.Text:null)));
-							}
-							else
-							{ // must be return value
-								st = Template("returnSetAttributeRef");
-								st.SetAttribute("ruleDescriptor", enclosingRule);
-								st.SetAttribute("attr", scope.GetAttribute((y!=null?y.Text:null)));
-								st.SetAttribute("expr", TranslateAction((expr!=null?expr.Text:null)));
-							}
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "SET_ENCLOSING_RULE_SCOPE_ATTR"
-
-	// $ANTLR start "ENCLOSING_RULE_SCOPE_ATTR"
-	private void mENCLOSING_RULE_SCOPE_ATTR()
-	{
-		try
-		{
-			int _type = ENCLOSING_RULE_SCOPE_ATTR;
-			int _channel = DefaultTokenChannel;
-			CommonToken x=null;
-			CommonToken y=null;
-
-			// Grammars\\ActionTranslator.g3:143:4: ( '$' x= ID '.' y= ID {...}?)
-			// Grammars\\ActionTranslator.g3:143:4: '$' x= ID '.' y= ID {...}?
-			{
-			Match('$'); if (state.failed) return ;
-			int xStart107 = CharIndex;
-			mID(); if (state.failed) return ;
-			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart107, CharIndex-1);
-			Match('.'); if (state.failed) return ;
-			int yStart113 = CharIndex;
-			mID(); if (state.failed) return ;
-			y = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, yStart113, CharIndex-1);
-			if ( !((enclosingRule!=null &&
-				                         (x!=null?x.Text:null).Equals(enclosingRule.name) &&
-				                         enclosingRule.GetLocalAttributeScope((y!=null?y.Text:null))!=null)) )
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "ENCLOSING_RULE_SCOPE_ATTR", "enclosingRule!=null &&\r\n\t                         $x.text.Equals(enclosingRule.name) &&\r\n\t                         enclosingRule.GetLocalAttributeScope($y.text)!=null");
-			}
-			if ( state.backtracking==1 )
-			{
-
-							if ( IsRuleRefInAlt((x!=null?x.Text:null)) )
-							{
-								ErrorManager.GrammarError(ErrorManager.MSG_RULE_REF_AMBIG_WITH_RULE_IN_ALT,
-														  grammar,
-														  actionToken,
-														  (x!=null?x.Text:null));
-							}
-							StringTemplate st = null;
-							AttributeScope scope = enclosingRule.GetLocalAttributeScope((y!=null?y.Text:null));
-							if ( scope.isPredefinedRuleScope )
-							{
-								st = Template("rulePropertyRef_"+(y!=null?y.Text:null));
-								grammar.ReferenceRuleLabelPredefinedAttribute((x!=null?x.Text:null));
-								st.SetAttribute("scope", (x!=null?x.Text:null));
-								st.SetAttribute("attr", (y!=null?y.Text:null));
-							}
-							else if ( scope.isPredefinedLexerRuleScope )
-							{
-								// perhaps not the most precise error message to use, but...
-								ErrorManager.GrammarError(ErrorManager.MSG_RULE_HAS_NO_ARGS,
-														  grammar,
-														  actionToken,
-														  (x!=null?x.Text:null));
-							}
-							else if ( scope.isParameterScope )
-							{
-								st = Template("parameterAttributeRef");
-								st.SetAttribute("attr", scope.GetAttribute((y!=null?y.Text:null)));
-							}
-							else
-							{ // must be return value
-								st = Template("returnAttributeRef");
-								st.SetAttribute("ruleDescriptor", enclosingRule);
-								st.SetAttribute("attr", scope.GetAttribute((y!=null?y.Text:null)));
-							}
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ENCLOSING_RULE_SCOPE_ATTR"
-
-	// $ANTLR start "SET_TOKEN_SCOPE_ATTR"
-	private void mSET_TOKEN_SCOPE_ATTR()
-	{
-		try
-		{
-			int _type = SET_TOKEN_SCOPE_ATTR;
-			int _channel = DefaultTokenChannel;
-			CommonToken x=null;
-			CommonToken y=null;
-
-			// Grammars\\ActionTranslator.g3:188:4: ( '$' x= ID '.' y= ID ( WS )? '=' {...}?)
-			// Grammars\\ActionTranslator.g3:188:4: '$' x= ID '.' y= ID ( WS )? '=' {...}?
-			{
-			Match('$'); if (state.failed) return ;
-			int xStart139 = CharIndex;
-			mID(); if (state.failed) return ;
-			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart139, CharIndex-1);
-			Match('.'); if (state.failed) return ;
-			int yStart145 = CharIndex;
-			mID(); if (state.failed) return ;
-			y = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, yStart145, CharIndex-1);
-			// Grammars\\ActionTranslator.g3:188:22: ( WS )?
-			int alt2=2;
-			int LA2_0 = input.LA(1);
-
-			if ( ((LA2_0>='\t' && LA2_0<='\n')||LA2_0=='\r'||LA2_0==' ') )
-			{
-				alt2=1;
-			}
-			switch ( alt2 )
-			{
-			case 1:
-				// Grammars\\ActionTranslator.g3:188:0: WS
-				{
-				mWS(); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-			Match('='); if (state.failed) return ;
-			if ( !((enclosingRule!=null && input.LA(1)!='=' &&
-				                         (enclosingRule.GetTokenLabel((x!=null?x.Text:null))!=null||
-				                          IsTokenRefInAlt((x!=null?x.Text:null))) &&
-				                         AttributeScope.tokenScope.GetAttribute((y!=null?y.Text:null))!=null)) )
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "SET_TOKEN_SCOPE_ATTR", "enclosingRule!=null && input.LA(1)!='=' &&\r\n\t                         (enclosingRule.GetTokenLabel($x.text)!=null||\r\n\t                          IsTokenRefInAlt($x.text)) &&\r\n\t                         AttributeScope.tokenScope.GetAttribute($y.text)!=null");
-			}
-			if ( state.backtracking==1 )
-			{
-
-							ErrorManager.GrammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
-													  grammar,
-													  actionToken,
-													  (x!=null?x.Text:null),
-													  (y!=null?y.Text:null));
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "SET_TOKEN_SCOPE_ATTR"
-
-	// $ANTLR start "TOKEN_SCOPE_ATTR"
-	private void mTOKEN_SCOPE_ATTR()
-	{
-		try
-		{
-			int _type = TOKEN_SCOPE_ATTR;
-			int _channel = DefaultTokenChannel;
-			CommonToken x=null;
-			CommonToken y=null;
-
-			// Grammars\\ActionTranslator.g3:207:4: ( '$' x= ID '.' y= ID {...}?)
-			// Grammars\\ActionTranslator.g3:207:4: '$' x= ID '.' y= ID {...}?
-			{
-			Match('$'); if (state.failed) return ;
-			int xStart184 = CharIndex;
-			mID(); if (state.failed) return ;
-			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart184, CharIndex-1);
-			Match('.'); if (state.failed) return ;
-			int yStart190 = CharIndex;
-			mID(); if (state.failed) return ;
-			y = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, yStart190, CharIndex-1);
-			if ( !((enclosingRule!=null &&
-				                         (enclosingRule.GetTokenLabel((x!=null?x.Text:null))!=null||
-				                          IsTokenRefInAlt((x!=null?x.Text:null))) &&
-				                         AttributeScope.tokenScope.GetAttribute((y!=null?y.Text:null))!=null &&
-				                         (grammar.type!=GrammarType.Lexer ||
-				                         GetElementLabel((x!=null?x.Text:null)).elementRef.token.Type==ANTLRParser.TOKEN_REF ||
-				                         GetElementLabel((x!=null?x.Text:null)).elementRef.token.Type==ANTLRParser.STRING_LITERAL))) )
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "TOKEN_SCOPE_ATTR", "enclosingRule!=null &&\r\n\t                         (enclosingRule.GetTokenLabel($x.text)!=null||\r\n\t                          IsTokenRefInAlt($x.text)) &&\r\n\t                         AttributeScope.tokenScope.GetAttribute($y.text)!=null &&\r\n\t                         (grammar.type!=GrammarType.Lexer ||\r\n\t                         GetElementLabel($x.text).elementRef.token.Type==ANTLRParser.TOKEN_REF ||\r\n\t                         GetElementLabel($x.text).elementRef.token.Type==ANTLRParser.STRING_LITERAL)");
-			}
-			if ( state.backtracking==1 )
-			{
-
-							string label = (x!=null?x.Text:null);
-							if ( enclosingRule.GetTokenLabel((x!=null?x.Text:null))==null )
-							{
-								// $tokenref.attr  gotta get old label or compute new one
-								CheckElementRefUniqueness((x!=null?x.Text:null), true);
-								label = enclosingRule.GetElementLabel((x!=null?x.Text:null), outerAltNum, generator);
-								if ( label==null )
-								{
-									ErrorManager.GrammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
-															  grammar,
-															  actionToken,
-															  "$"+(x!=null?x.Text:null)+"."+(y!=null?y.Text:null));
-									label = (x!=null?x.Text:null);
-								}
-							}
-							StringTemplate st = Template("tokenLabelPropertyRef_"+(y!=null?y.Text:null));
-							st.SetAttribute("scope", label);
-							st.SetAttribute("attr", AttributeScope.tokenScope.GetAttribute((y!=null?y.Text:null)));
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "TOKEN_SCOPE_ATTR"
-
-	// $ANTLR start "SET_RULE_SCOPE_ATTR"
-	private void mSET_RULE_SCOPE_ATTR()
-	{
-		try
-		{
-			int _type = SET_RULE_SCOPE_ATTR;
-			int _channel = DefaultTokenChannel;
-			CommonToken x=null;
-			CommonToken y=null;
-
-
-			Grammar.LabelElementPair pair=null;
-			string refdRuleName=null;
-
-			// Grammars\\ActionTranslator.g3:248:4: ( '$' x= ID '.' y= ID ( WS )? '=' {...}?{...}?)
-			// Grammars\\ActionTranslator.g3:248:4: '$' x= ID '.' y= ID ( WS )? '=' {...}?{...}?
-			{
-			Match('$'); if (state.failed) return ;
-			int xStart221 = CharIndex;
-			mID(); if (state.failed) return ;
-			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart221, CharIndex-1);
-			Match('.'); if (state.failed) return ;
-			int yStart227 = CharIndex;
-			mID(); if (state.failed) return ;
-			y = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, yStart227, CharIndex-1);
-			// Grammars\\ActionTranslator.g3:248:22: ( WS )?
-			int alt3=2;
-			int LA3_0 = input.LA(1);
-
-			if ( ((LA3_0>='\t' && LA3_0<='\n')||LA3_0=='\r'||LA3_0==' ') )
-			{
-				alt3=1;
-			}
-			switch ( alt3 )
-			{
-			case 1:
-				// Grammars\\ActionTranslator.g3:248:0: WS
-				{
-				mWS(); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-			Match('='); if (state.failed) return ;
-			if ( !((enclosingRule!=null && input.LA(1)!='=')) )
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "SET_RULE_SCOPE_ATTR", "enclosingRule!=null && input.LA(1)!='='");
-			}
-			if ( state.backtracking==1 )
-			{
-
-							pair = enclosingRule.GetRuleLabel((x!=null?x.Text:null));
-							refdRuleName = (x!=null?x.Text:null);
-							if ( pair!=null )
-							{
-								refdRuleName = pair.referencedRuleName;
-							}
-
-			}
-			if ( !(((enclosingRule.GetRuleLabel((x!=null?x.Text:null))!=null || IsRuleRefInAlt((x!=null?x.Text:null))) &&
-				      GetRuleLabelAttribute(enclosingRule.GetRuleLabel((x!=null?x.Text:null))!=null?enclosingRule.GetRuleLabel((x!=null?x.Text:null)).referencedRuleName:(x!=null?x.Text:null),(y!=null?y.Text:null))!=null)) )
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "SET_RULE_SCOPE_ATTR", "(enclosingRule.GetRuleLabel($x.text)!=null || IsRuleRefInAlt($x.text)) &&\r\n\t      GetRuleLabelAttribute(enclosingRule.GetRuleLabel($x.text)!=null?enclosingRule.GetRuleLabel($x.text).referencedRuleName:$x.text,$y.text)!=null");
-			}
-			if ( state.backtracking==1 )
-			{
-
-							ErrorManager.GrammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
-													  grammar,
-													  actionToken,
-													  (x!=null?x.Text:null),
-													  (y!=null?y.Text:null));
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "SET_RULE_SCOPE_ATTR"
-
-	// $ANTLR start "RULE_SCOPE_ATTR"
-	private void mRULE_SCOPE_ATTR()
-	{
-		try
-		{
-			int _type = RULE_SCOPE_ATTR;
-			int _channel = DefaultTokenChannel;
-			CommonToken x=null;
-			CommonToken y=null;
-
-
-				Grammar.LabelElementPair pair=null;
-				string refdRuleName=null;
-
-			// Grammars\\ActionTranslator.g3:279:4: ( '$' x= ID '.' y= ID {...}?{...}?)
-			// Grammars\\ActionTranslator.g3:279:4: '$' x= ID '.' y= ID {...}?{...}?
-			{
-			Match('$'); if (state.failed) return ;
-			int xStart280 = CharIndex;
-			mID(); if (state.failed) return ;
-			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart280, CharIndex-1);
-			Match('.'); if (state.failed) return ;
-			int yStart286 = CharIndex;
-			mID(); if (state.failed) return ;
-			y = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, yStart286, CharIndex-1);
-			if ( !((enclosingRule!=null)) )
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "RULE_SCOPE_ATTR", "enclosingRule!=null");
-			}
-			if ( state.backtracking==1 )
-			{
-
-						pair = enclosingRule.GetRuleLabel((x!=null?x.Text:null));
-						refdRuleName = (x!=null?x.Text:null);
-						if ( pair!=null ) {
-							refdRuleName = pair.referencedRuleName;
-						}
-
-			}
-			if ( !(((enclosingRule.GetRuleLabel((x!=null?x.Text:null))!=null || IsRuleRefInAlt((x!=null?x.Text:null))) &&
-				      GetRuleLabelAttribute(enclosingRule.GetRuleLabel((x!=null?x.Text:null))!=null?enclosingRule.GetRuleLabel((x!=null?x.Text:null)).referencedRuleName:(x!=null?x.Text:null),(y!=null?y.Text:null))!=null)) )
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "RULE_SCOPE_ATTR", "(enclosingRule.GetRuleLabel($x.text)!=null || IsRuleRefInAlt($x.text)) &&\r\n\t      GetRuleLabelAttribute(enclosingRule.GetRuleLabel($x.text)!=null?enclosingRule.GetRuleLabel($x.text).referencedRuleName:$x.text,$y.text)!=null");
-			}
-			if ( state.backtracking==1 )
-			{
-
-							string label = (x!=null?x.Text:null);
-							if ( pair==null )
-							{
-								// $ruleref.attr  gotta get old label or compute new one
-								CheckElementRefUniqueness((x!=null?x.Text:null), false);
-								label = enclosingRule.GetElementLabel((x!=null?x.Text:null), outerAltNum, generator);
-								if ( label==null )
-								{
-									ErrorManager.GrammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
-															  grammar,
-															  actionToken,
-															  "$"+(x!=null?x.Text:null)+"."+(y!=null?y.Text:null));
-									label = (x!=null?x.Text:null);
-								}
-							}
-							StringTemplate st;
-							Rule refdRule = grammar.GetRule(refdRuleName);
-							AttributeScope scope = refdRule.GetLocalAttributeScope((y!=null?y.Text:null));
-							if ( scope.isPredefinedRuleScope )
-							{
-								st = Template("ruleLabelPropertyRef_"+(y!=null?y.Text:null));
-								grammar.ReferenceRuleLabelPredefinedAttribute(refdRuleName);
-								st.SetAttribute("scope", label);
-								st.SetAttribute("attr", (y!=null?y.Text:null));
-							}
-							else if ( scope.isPredefinedLexerRuleScope )
-							{
-								st = Template("lexerRuleLabelPropertyRef_"+(y!=null?y.Text:null));
-								grammar.ReferenceRuleLabelPredefinedAttribute(refdRuleName);
-								st.SetAttribute("scope", label);
-								st.SetAttribute("attr", (y!=null?y.Text:null));
-							}
-							else if ( scope.isParameterScope )
-							{
-								// TODO: error!
-							}
-							else
-							{
-								st = Template("ruleLabelRef");
-								st.SetAttribute("referencedRule", refdRule);
-								st.SetAttribute("scope", label);
-								st.SetAttribute("attr", scope.GetAttribute((y!=null?y.Text:null)));
-							}
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "RULE_SCOPE_ATTR"
-
-	// $ANTLR start "LABEL_REF"
-	private void mLABEL_REF()
-	{
-		try
-		{
-			int _type = LABEL_REF;
-			int _channel = DefaultTokenChannel;
-			CommonToken ID1=null;
-
-			// Grammars\\ActionTranslator.g3:343:4: ( '$' ID {...}?)
-			// Grammars\\ActionTranslator.g3:343:4: '$' ID {...}?
-			{
-			Match('$'); if (state.failed) return ;
-			int ID1Start328 = CharIndex;
-			mID(); if (state.failed) return ;
-			ID1 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ID1Start328, CharIndex-1);
-			if ( !((enclosingRule!=null &&
-				            GetElementLabel((ID1!=null?ID1.Text:null))!=null &&
-					        enclosingRule.GetRuleLabel((ID1!=null?ID1.Text:null))==null)) )
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "LABEL_REF", "enclosingRule!=null &&\r\n\t            GetElementLabel($ID.text)!=null &&\r\n\t\t        enclosingRule.GetRuleLabel($ID.text)==null");
-			}
-			if ( state.backtracking==1 )
-			{
-
-							StringTemplate st;
-							Grammar.LabelElementPair pair = GetElementLabel((ID1!=null?ID1.Text:null));
-							if ( pair.type==LabelType.RuleList ||
-								  pair.type==LabelType.TokenList ||
-								  pair.type == LabelType.WildcardTreeList )
-							{
-								st = Template("listLabelRef");
-							}
-							else
-							{
-								st = Template("tokenLabelRef");
-							}
-							st.SetAttribute("label", (ID1!=null?ID1.Text:null));
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "LABEL_REF"
-
-	// $ANTLR start "ISOLATED_TOKEN_REF"
-	private void mISOLATED_TOKEN_REF()
-	{
-		try
-		{
-			int _type = ISOLATED_TOKEN_REF;
-			int _channel = DefaultTokenChannel;
-			CommonToken ID2=null;
-
-			// Grammars\\ActionTranslator.g3:366:4: ( '$' ID {...}?)
-			// Grammars\\ActionTranslator.g3:366:4: '$' ID {...}?
-			{
-			Match('$'); if (state.failed) return ;
-			int ID2Start352 = CharIndex;
-			mID(); if (state.failed) return ;
-			ID2 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ID2Start352, CharIndex-1);
-			if ( !((grammar.type!=GrammarType.Lexer && enclosingRule!=null && IsTokenRefInAlt((ID2!=null?ID2.Text:null)))) )
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "ISOLATED_TOKEN_REF", "grammar.type!=GrammarType.Lexer && enclosingRule!=null && IsTokenRefInAlt($ID.text)");
-			}
-			if ( state.backtracking==1 )
-			{
-
-							string label = enclosingRule.GetElementLabel((ID2!=null?ID2.Text:null), outerAltNum, generator);
-							CheckElementRefUniqueness((ID2!=null?ID2.Text:null), true);
-							if ( label==null )
-							{
-								ErrorManager.GrammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
-														  grammar,
-														  actionToken,
-														  (ID2!=null?ID2.Text:null));
-							}
-							else
-							{
-								StringTemplate st = Template("tokenLabelRef");
-								st.SetAttribute("label", label);
-							}
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ISOLATED_TOKEN_REF"
-
-	// $ANTLR start "ISOLATED_LEXER_RULE_REF"
-	private void mISOLATED_LEXER_RULE_REF()
-	{
-		try
-		{
-			int _type = ISOLATED_LEXER_RULE_REF;
-			int _channel = DefaultTokenChannel;
-			CommonToken ID3=null;
-
-			// Grammars\\ActionTranslator.g3:388:4: ( '$' ID {...}?)
-			// Grammars\\ActionTranslator.g3:388:4: '$' ID {...}?
-			{
-			Match('$'); if (state.failed) return ;
-			int ID3Start376 = CharIndex;
-			mID(); if (state.failed) return ;
-			ID3 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ID3Start376, CharIndex-1);
-			if ( !((grammar.type==GrammarType.Lexer &&
-				             enclosingRule!=null &&
-				             IsRuleRefInAlt((ID3!=null?ID3.Text:null)))) )
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "ISOLATED_LEXER_RULE_REF", "grammar.type==GrammarType.Lexer &&\r\n\t             enclosingRule!=null &&\r\n\t             IsRuleRefInAlt($ID.text)");
-			}
-			if ( state.backtracking==1 )
-			{
-
-							string label = enclosingRule.GetElementLabel((ID3!=null?ID3.Text:null), outerAltNum, generator);
-							CheckElementRefUniqueness((ID3!=null?ID3.Text:null), false);
-							if ( label==null )
-							{
-								ErrorManager.GrammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
-														  grammar,
-														  actionToken,
-														  (ID3!=null?ID3.Text:null));
-							}
-							else
-							{
-								StringTemplate st = Template("lexerRuleLabel");
-								st.SetAttribute("label", label);
-							}
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ISOLATED_LEXER_RULE_REF"
-
-	// $ANTLR start "SET_LOCAL_ATTR"
-	private void mSET_LOCAL_ATTR()
-	{
-		try
-		{
-			int _type = SET_LOCAL_ATTR;
-			int _channel = DefaultTokenChannel;
-			CommonToken expr=null;
-			CommonToken ID4=null;
-
-			// Grammars\\ActionTranslator.g3:422:4: ( '$' ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?)
-			// Grammars\\ActionTranslator.g3:422:4: '$' ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?
-			{
-			Match('$'); if (state.failed) return ;
-			int ID4Start400 = CharIndex;
-			mID(); if (state.failed) return ;
-			ID4 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ID4Start400, CharIndex-1);
-			// Grammars\\ActionTranslator.g3:422:11: ( WS )?
-			int alt4=2;
-			int LA4_0 = input.LA(1);
-
-			if ( ((LA4_0>='\t' && LA4_0<='\n')||LA4_0=='\r'||LA4_0==' ') )
-			{
-				alt4=1;
-			}
-			switch ( alt4 )
-			{
-			case 1:
-				// Grammars\\ActionTranslator.g3:422:0: WS
-				{
-				mWS(); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-			Match('='); if (state.failed) return ;
-			int exprStart409 = CharIndex;
-			mATTR_VALUE_EXPR(); if (state.failed) return ;
-			expr = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, exprStart409, CharIndex-1);
-			Match(';'); if (state.failed) return ;
-			if ( !((enclosingRule!=null
-																&& enclosingRule.GetLocalAttributeScope((ID4!=null?ID4.Text:null))!=null
-																&& !enclosingRule.GetLocalAttributeScope((ID4!=null?ID4.Text:null)).isPredefinedLexerRuleScope)) )
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "SET_LOCAL_ATTR", "enclosingRule!=null\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t&& enclosingRule.GetLocalAttributeScope($ID.text)!=null\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t&& !enclosingRule.GetLocalAttributeScope($ID.text).isPredefinedLexerRuleScope");
-			}
-			if ( state.backtracking==1 )
-			{
-
-							StringTemplate st;
-							AttributeScope scope = enclosingRule.GetLocalAttributeScope((ID4!=null?ID4.Text:null));
-							if ( scope.isPredefinedRuleScope )
-							{
-								if ((ID4!=null?ID4.Text:null).Equals("tree") || (ID4!=null?ID4.Text:null).Equals("st"))
-								{
-									st = Template("ruleSetPropertyRef_"+(ID4!=null?ID4.Text:null));
-									grammar.ReferenceRuleLabelPredefinedAttribute(enclosingRule.name);
-									st.SetAttribute("scope", enclosingRule.name);
-									st.SetAttribute("attr", (ID4!=null?ID4.Text:null));
-									st.SetAttribute("expr", TranslateAction((expr!=null?expr.Text:null)));
-								}
-								else
-								{
-									ErrorManager.GrammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
-															 grammar,
-															 actionToken,
-															 (ID4!=null?ID4.Text:null),
-															 "");
-								}
-							}
-							else if ( scope.isParameterScope )
-							{
-								st = Template("parameterSetAttributeRef");
-								st.SetAttribute("attr", scope.GetAttribute((ID4!=null?ID4.Text:null)));
-								st.SetAttribute("expr", TranslateAction((expr!=null?expr.Text:null)));
-							}
-							else
-							{
-								st = Template("returnSetAttributeRef");
-								st.SetAttribute("ruleDescriptor", enclosingRule);
-								st.SetAttribute("attr", scope.GetAttribute((ID4!=null?ID4.Text:null)));
-								st.SetAttribute("expr", TranslateAction((expr!=null?expr.Text:null)));
-							}
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "SET_LOCAL_ATTR"
-
-	// $ANTLR start "LOCAL_ATTR"
-	private void mLOCAL_ATTR()
-	{
-		try
-		{
-			int _type = LOCAL_ATTR;
-			int _channel = DefaultTokenChannel;
-			CommonToken ID5=null;
-
-			// Grammars\\ActionTranslator.g3:464:4: ( '$' ID {...}?)
-			// Grammars\\ActionTranslator.g3:464:4: '$' ID {...}?
-			{
-			Match('$'); if (state.failed) return ;
-			int ID5Start432 = CharIndex;
-			mID(); if (state.failed) return ;
-			ID5 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ID5Start432, CharIndex-1);
-			if ( !((enclosingRule!=null && enclosingRule.GetLocalAttributeScope((ID5!=null?ID5.Text:null))!=null)) )
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "LOCAL_ATTR", "enclosingRule!=null && enclosingRule.GetLocalAttributeScope($ID.text)!=null");
-			}
-			if ( state.backtracking==1 )
-			{
-
-							StringTemplate st;
-							AttributeScope scope = enclosingRule.GetLocalAttributeScope((ID5!=null?ID5.Text:null));
-							if ( scope.isPredefinedRuleScope )
-							{
-								st = Template("rulePropertyRef_"+(ID5!=null?ID5.Text:null));
-								grammar.ReferenceRuleLabelPredefinedAttribute(enclosingRule.name);
-								st.SetAttribute("scope", enclosingRule.name);
-								st.SetAttribute("attr", (ID5!=null?ID5.Text:null));
-							}
-							else if ( scope.isPredefinedLexerRuleScope )
-							{
-								st = Template("lexerRulePropertyRef_"+(ID5!=null?ID5.Text:null));
-								st.SetAttribute("scope", enclosingRule.name);
-								st.SetAttribute("attr", (ID5!=null?ID5.Text:null));
-							}
-							else if ( scope.isParameterScope )
-							{
-								st = Template("parameterAttributeRef");
-								st.SetAttribute("attr", scope.GetAttribute((ID5!=null?ID5.Text:null)));
-							}
-							else
-							{
-								st = Template("returnAttributeRef");
-								st.SetAttribute("ruleDescriptor", enclosingRule);
-								st.SetAttribute("attr", scope.GetAttribute((ID5!=null?ID5.Text:null)));
-							}
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "LOCAL_ATTR"
-
-	// $ANTLR start "SET_DYNAMIC_SCOPE_ATTR"
-	private void mSET_DYNAMIC_SCOPE_ATTR()
-	{
-		try
-		{
-			int _type = SET_DYNAMIC_SCOPE_ATTR;
-			int _channel = DefaultTokenChannel;
-			CommonToken x=null;
-			CommonToken y=null;
-			CommonToken expr=null;
-
-			// Grammars\\ActionTranslator.g3:509:4: ( '$' x= ID '::' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?)
-			// Grammars\\ActionTranslator.g3:509:4: '$' x= ID '::' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?
-			{
-			Match('$'); if (state.failed) return ;
-			int xStart458 = CharIndex;
-			mID(); if (state.failed) return ;
-			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart458, CharIndex-1);
-			Match("::"); if (state.failed) return ;
-
-			int yStart464 = CharIndex;
-			mID(); if (state.failed) return ;
-			y = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, yStart464, CharIndex-1);
-			// Grammars\\ActionTranslator.g3:509:23: ( WS )?
-			int alt5=2;
-			int LA5_0 = input.LA(1);
-
-			if ( ((LA5_0>='\t' && LA5_0<='\n')||LA5_0=='\r'||LA5_0==' ') )
-			{
-				alt5=1;
-			}
-			switch ( alt5 )
-			{
-			case 1:
-				// Grammars\\ActionTranslator.g3:509:0: WS
-				{
-				mWS(); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-			Match('='); if (state.failed) return ;
-			int exprStart473 = CharIndex;
-			mATTR_VALUE_EXPR(); if (state.failed) return ;
-			expr = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, exprStart473, CharIndex-1);
-			Match(';'); if (state.failed) return ;
-			if ( !((ResolveDynamicScope((x!=null?x.Text:null))!=null &&
-									     ResolveDynamicScope((x!=null?x.Text:null)).GetAttribute((y!=null?y.Text:null))!=null)) )
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "SET_DYNAMIC_SCOPE_ATTR", "ResolveDynamicScope($x.text)!=null &&\r\n\t\t\t\t\t\t     ResolveDynamicScope($x.text).GetAttribute($y.text)!=null");
-			}
-			if ( state.backtracking==1 )
-			{
-
-							AttributeScope scope = ResolveDynamicScope((x!=null?x.Text:null));
-							if ( scope!=null )
-							{
-								StringTemplate st = Template("scopeSetAttributeRef");
-								st.SetAttribute("scope", (x!=null?x.Text:null));
-								st.SetAttribute("attr",  scope.GetAttribute((y!=null?y.Text:null)));
-								st.SetAttribute("expr",  TranslateAction((expr!=null?expr.Text:null)));
-							}
-							else
-							{
-								// error: invalid dynamic attribute
-							}
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "SET_DYNAMIC_SCOPE_ATTR"
-
-	// $ANTLR start "DYNAMIC_SCOPE_ATTR"
-	private void mDYNAMIC_SCOPE_ATTR()
-	{
-		try
-		{
-			int _type = DYNAMIC_SCOPE_ATTR;
-			int _channel = DefaultTokenChannel;
-			CommonToken x=null;
-			CommonToken y=null;
-
-			// Grammars\\ActionTranslator.g3:530:4: ( '$' x= ID '::' y= ID {...}?)
-			// Grammars\\ActionTranslator.g3:530:4: '$' x= ID '::' y= ID {...}?
-			{
-			Match('$'); if (state.failed) return ;
-			int xStart508 = CharIndex;
-			mID(); if (state.failed) return ;
-			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart508, CharIndex-1);
-			Match("::"); if (state.failed) return ;
-
-			int yStart514 = CharIndex;
-			mID(); if (state.failed) return ;
-			y = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, yStart514, CharIndex-1);
-			if ( !((ResolveDynamicScope((x!=null?x.Text:null))!=null &&
-									     ResolveDynamicScope((x!=null?x.Text:null)).GetAttribute((y!=null?y.Text:null))!=null)) )
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "DYNAMIC_SCOPE_ATTR", "ResolveDynamicScope($x.text)!=null &&\r\n\t\t\t\t\t\t     ResolveDynamicScope($x.text).GetAttribute($y.text)!=null");
-			}
-			if ( state.backtracking==1 )
-			{
-
-							AttributeScope scope = ResolveDynamicScope((x!=null?x.Text:null));
-							if ( scope!=null )
-							{
-								StringTemplate st = Template("scopeAttributeRef");
-								st.SetAttribute("scope", (x!=null?x.Text:null));
-								st.SetAttribute("attr",  scope.GetAttribute((y!=null?y.Text:null)));
-							}
-							else
-							{
-								// error: invalid dynamic attribute
-							}
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "DYNAMIC_SCOPE_ATTR"
-
-	// $ANTLR start "ERROR_SCOPED_XY"
-	private void mERROR_SCOPED_XY()
-	{
-		try
-		{
-			int _type = ERROR_SCOPED_XY;
-			int _channel = DefaultTokenChannel;
-			CommonToken x=null;
-			CommonToken y=null;
-
-			// Grammars\\ActionTranslator.g3:551:4: ( '$' x= ID '::' y= ID )
-			// Grammars\\ActionTranslator.g3:551:4: '$' x= ID '::' y= ID
-			{
-			Match('$'); if (state.failed) return ;
-			int xStart548 = CharIndex;
-			mID(); if (state.failed) return ;
-			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart548, CharIndex-1);
-			Match("::"); if (state.failed) return ;
-
-			int yStart554 = CharIndex;
-			mID(); if (state.failed) return ;
-			y = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, yStart554, CharIndex-1);
-			if ( state.backtracking==1 )
-			{
-
-						chunks.Add(Text);
-						generator.IssueInvalidScopeError((x!=null?x.Text:null),(y!=null?y.Text:null),
-						                                 enclosingRule,actionToken,
-						                                 outerAltNum);
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ERROR_SCOPED_XY"
-
-	// $ANTLR start "DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR"
-	private void mDYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR()
-	{
-		try
-		{
-			int _type = DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR;
-			int _channel = DefaultTokenChannel;
-			CommonToken x=null;
-			CommonToken expr=null;
-			CommonToken y=null;
-
-			// Grammars\\ActionTranslator.g3:569:4: ( '$' x= ID '[' '-' expr= SCOPE_INDEX_EXPR ']' '::' y= ID )
-			// Grammars\\ActionTranslator.g3:569:4: '$' x= ID '[' '-' expr= SCOPE_INDEX_EXPR ']' '::' y= ID
-			{
-			Match('$'); if (state.failed) return ;
-			int xStart576 = CharIndex;
-			mID(); if (state.failed) return ;
-			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart576, CharIndex-1);
-			Match('['); if (state.failed) return ;
-			Match('-'); if (state.failed) return ;
-			int exprStart584 = CharIndex;
-			mSCOPE_INDEX_EXPR(); if (state.failed) return ;
-			expr = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, exprStart584, CharIndex-1);
-			Match(']'); if (state.failed) return ;
-			Match("::"); if (state.failed) return ;
-
-			int yStart592 = CharIndex;
-			mID(); if (state.failed) return ;
-			y = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, yStart592, CharIndex-1);
-			if ( state.backtracking==1 )
-			{
-
-							StringTemplate st = Template("scopeAttributeRef");
-							st.SetAttribute("scope",    (x!=null?x.Text:null));
-							st.SetAttribute("attr",     ResolveDynamicScope((x!=null?x.Text:null)).GetAttribute((y!=null?y.Text:null)));
-							st.SetAttribute("negIndex", (expr!=null?expr.Text:null));
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR"
-
-	// $ANTLR start "DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR"
-	private void mDYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR()
-	{
-		try
-		{
-			int _type = DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR;
-			int _channel = DefaultTokenChannel;
-			CommonToken x=null;
-			CommonToken expr=null;
-			CommonToken y=null;
-
-			// Grammars\\ActionTranslator.g3:580:4: ( '$' x= ID '[' expr= SCOPE_INDEX_EXPR ']' '::' y= ID )
-			// Grammars\\ActionTranslator.g3:580:4: '$' x= ID '[' expr= SCOPE_INDEX_EXPR ']' '::' y= ID
-			{
-			Match('$'); if (state.failed) return ;
-			int xStart616 = CharIndex;
-			mID(); if (state.failed) return ;
-			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart616, CharIndex-1);
-			Match('['); if (state.failed) return ;
-			int exprStart622 = CharIndex;
-			mSCOPE_INDEX_EXPR(); if (state.failed) return ;
-			expr = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, exprStart622, CharIndex-1);
-			Match(']'); if (state.failed) return ;
-			Match("::"); if (state.failed) return ;
-
-			int yStart630 = CharIndex;
-			mID(); if (state.failed) return ;
-			y = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, yStart630, CharIndex-1);
-			if ( state.backtracking==1 )
-			{
-
-							StringTemplate st = Template("scopeAttributeRef");
-							st.SetAttribute("scope", (x!=null?x.Text:null));
-							st.SetAttribute("attr",  ResolveDynamicScope((x!=null?x.Text:null)).GetAttribute((y!=null?y.Text:null)));
-							st.SetAttribute("index", (expr!=null?expr.Text:null));
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR"
-
-	// $ANTLR start "SCOPE_INDEX_EXPR"
-	private void mSCOPE_INDEX_EXPR()
-	{
-		try
-		{
-			// Grammars\\ActionTranslator.g3:592:4: ( (~ ']' )+ )
-			// Grammars\\ActionTranslator.g3:592:4: (~ ']' )+
-			{
-			// Grammars\\ActionTranslator.g3:592:4: (~ ']' )+
-			int cnt6=0;
-			for ( ; ; )
-			{
-				int alt6=2;
-				int LA6_0 = input.LA(1);
-
-				if ( ((LA6_0>='\u0000' && LA6_0<='\\')||(LA6_0>='^' && LA6_0<='\uFFFF')) )
-				{
-					alt6=1;
-				}
-
-
-				switch ( alt6 )
-				{
-				case 1:
-					// Grammars\\ActionTranslator.g3:
-					{
-					input.Consume();
-					state.failed=false;
-
-					}
-					break;
-
-				default:
-					if ( cnt6 >= 1 )
-						goto loop6;
-
-					if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee6 = new EarlyExitException( 6, input );
-					throw eee6;
-				}
-				cnt6++;
-			}
-			loop6:
-				;
-
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "SCOPE_INDEX_EXPR"
-
-	// $ANTLR start "ISOLATED_DYNAMIC_SCOPE"
-	private void mISOLATED_DYNAMIC_SCOPE()
-	{
-		try
-		{
-			int _type = ISOLATED_DYNAMIC_SCOPE;
-			int _channel = DefaultTokenChannel;
-			CommonToken ID6=null;
-
-			// Grammars\\ActionTranslator.g3:601:4: ( '$' ID {...}?)
-			// Grammars\\ActionTranslator.g3:601:4: '$' ID {...}?
-			{
-			Match('$'); if (state.failed) return ;
-			int ID6Start673 = CharIndex;
-			mID(); if (state.failed) return ;
-			ID6 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ID6Start673, CharIndex-1);
-			if ( !((ResolveDynamicScope((ID6!=null?ID6.Text:null))!=null)) )
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "ISOLATED_DYNAMIC_SCOPE", "ResolveDynamicScope($ID.text)!=null");
-			}
-			if ( state.backtracking==1 )
-			{
-
-							StringTemplate st = Template("isolatedDynamicScopeRef");
-							st.SetAttribute("scope", (ID6!=null?ID6.Text:null));
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ISOLATED_DYNAMIC_SCOPE"
-
-	// $ANTLR start "TEMPLATE_INSTANCE"
-	private void mTEMPLATE_INSTANCE()
-	{
-		try
-		{
-			int _type = TEMPLATE_INSTANCE;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ActionTranslator.g3:614:4: ( '%' ID '(' ( ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )? )? ')' )
-			// Grammars\\ActionTranslator.g3:614:4: '%' ID '(' ( ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )? )? ')'
-			{
-			Match('%'); if (state.failed) return ;
-			mID(); if (state.failed) return ;
-			Match('('); if (state.failed) return ;
-			// Grammars\\ActionTranslator.g3:614:15: ( ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )? )?
-			int alt11=2;
-			int LA11_0 = input.LA(1);
-
-			if ( ((LA11_0>='\t' && LA11_0<='\n')||LA11_0=='\r'||LA11_0==' '||(LA11_0>='A' && LA11_0<='Z')||LA11_0=='_'||(LA11_0>='a' && LA11_0<='z')) )
-			{
-				alt11=1;
-			}
-			switch ( alt11 )
-			{
-			case 1:
-				// Grammars\\ActionTranslator.g3:614:17: ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )?
-				{
-				// Grammars\\ActionTranslator.g3:614:17: ( WS )?
-				int alt7=2;
-				int LA7_0 = input.LA(1);
-
-				if ( ((LA7_0>='\t' && LA7_0<='\n')||LA7_0=='\r'||LA7_0==' ') )
-				{
-					alt7=1;
-				}
-				switch ( alt7 )
-				{
-				case 1:
-					// Grammars\\ActionTranslator.g3:614:0: WS
-					{
-					mWS(); if (state.failed) return ;
-
-					}
-					break;
-
-				}
-
-				mARG(); if (state.failed) return ;
-				// Grammars\\ActionTranslator.g3:614:25: ( ',' ( WS )? ARG )*
-				for ( ; ; )
-				{
-					int alt9=2;
-					int LA9_0 = input.LA(1);
-
-					if ( (LA9_0==',') )
-					{
-						alt9=1;
-					}
-
-
-					switch ( alt9 )
-					{
-					case 1:
-						// Grammars\\ActionTranslator.g3:614:26: ',' ( WS )? ARG
-						{
-						Match(','); if (state.failed) return ;
-						// Grammars\\ActionTranslator.g3:614:30: ( WS )?
-						int alt8=2;
-						int LA8_0 = input.LA(1);
-
-						if ( ((LA8_0>='\t' && LA8_0<='\n')||LA8_0=='\r'||LA8_0==' ') )
-						{
-							alt8=1;
-						}
-						switch ( alt8 )
-						{
-						case 1:
-							// Grammars\\ActionTranslator.g3:614:0: WS
-							{
-							mWS(); if (state.failed) return ;
-
-							}
-							break;
-
-						}
-
-						mARG(); if (state.failed) return ;
-
-						}
-						break;
-
-					default:
-						goto loop9;
-					}
-				}
-
-				loop9:
-					;
-
-
-				// Grammars\\ActionTranslator.g3:614:40: ( WS )?
-				int alt10=2;
-				int LA10_0 = input.LA(1);
-
-				if ( ((LA10_0>='\t' && LA10_0<='\n')||LA10_0=='\r'||LA10_0==' ') )
-				{
-					alt10=1;
-				}
-				switch ( alt10 )
-				{
-				case 1:
-					// Grammars\\ActionTranslator.g3:614:0: WS
-					{
-					mWS(); if (state.failed) return ;
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-
-			}
-
-			Match(')'); if (state.failed) return ;
-			if ( state.backtracking==1 )
-			{
-
-							string action = Text.Substring( 1, Text.Length - 1 );
-							string ruleName = "<outside-of-rule>";
-							if ( enclosingRule!=null )
-							{
-								ruleName = enclosingRule.name;
-							}
-							StringTemplate st =
-								generator.TranslateTemplateConstructor(ruleName,
-																	   outerAltNum,
-																	   actionToken,
-																	   action);
-							if ( st!=null )
-							{
-								chunks.Add(st);
-							}
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "TEMPLATE_INSTANCE"
-
-	// $ANTLR start "INDIRECT_TEMPLATE_INSTANCE"
-	private void mINDIRECT_TEMPLATE_INSTANCE()
-	{
-		try
-		{
-			int _type = INDIRECT_TEMPLATE_INSTANCE;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ActionTranslator.g3:637:4: ( '%' '(' ACTION ')' '(' ( ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )? )? ')' )
-			// Grammars\\ActionTranslator.g3:637:4: '%' '(' ACTION ')' '(' ( ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )? )? ')'
-			{
-			Match('%'); if (state.failed) return ;
-			Match('('); if (state.failed) return ;
-			mACTION(); if (state.failed) return ;
-			Match(')'); if (state.failed) return ;
-			Match('('); if (state.failed) return ;
-			// Grammars\\ActionTranslator.g3:637:27: ( ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )? )?
-			int alt16=2;
-			int LA16_0 = input.LA(1);
-
-			if ( ((LA16_0>='\t' && LA16_0<='\n')||LA16_0=='\r'||LA16_0==' '||(LA16_0>='A' && LA16_0<='Z')||LA16_0=='_'||(LA16_0>='a' && LA16_0<='z')) )
-			{
-				alt16=1;
-			}
-			switch ( alt16 )
-			{
-			case 1:
-				// Grammars\\ActionTranslator.g3:637:29: ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )?
-				{
-				// Grammars\\ActionTranslator.g3:637:29: ( WS )?
-				int alt12=2;
-				int LA12_0 = input.LA(1);
-
-				if ( ((LA12_0>='\t' && LA12_0<='\n')||LA12_0=='\r'||LA12_0==' ') )
-				{
-					alt12=1;
-				}
-				switch ( alt12 )
-				{
-				case 1:
-					// Grammars\\ActionTranslator.g3:637:0: WS
-					{
-					mWS(); if (state.failed) return ;
-
-					}
-					break;
-
-				}
-
-				mARG(); if (state.failed) return ;
-				// Grammars\\ActionTranslator.g3:637:37: ( ',' ( WS )? ARG )*
-				for ( ; ; )
-				{
-					int alt14=2;
-					int LA14_0 = input.LA(1);
-
-					if ( (LA14_0==',') )
-					{
-						alt14=1;
-					}
-
-
-					switch ( alt14 )
-					{
-					case 1:
-						// Grammars\\ActionTranslator.g3:637:38: ',' ( WS )? ARG
-						{
-						Match(','); if (state.failed) return ;
-						// Grammars\\ActionTranslator.g3:637:42: ( WS )?
-						int alt13=2;
-						int LA13_0 = input.LA(1);
-
-						if ( ((LA13_0>='\t' && LA13_0<='\n')||LA13_0=='\r'||LA13_0==' ') )
-						{
-							alt13=1;
-						}
-						switch ( alt13 )
-						{
-						case 1:
-							// Grammars\\ActionTranslator.g3:637:0: WS
-							{
-							mWS(); if (state.failed) return ;
-
-							}
-							break;
-
-						}
-
-						mARG(); if (state.failed) return ;
-
-						}
-						break;
-
-					default:
-						goto loop14;
-					}
-				}
-
-				loop14:
-					;
-
-
-				// Grammars\\ActionTranslator.g3:637:52: ( WS )?
-				int alt15=2;
-				int LA15_0 = input.LA(1);
-
-				if ( ((LA15_0>='\t' && LA15_0<='\n')||LA15_0=='\r'||LA15_0==' ') )
-				{
-					alt15=1;
-				}
-				switch ( alt15 )
-				{
-				case 1:
-					// Grammars\\ActionTranslator.g3:637:0: WS
-					{
-					mWS(); if (state.failed) return ;
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-
-			}
-
-			Match(')'); if (state.failed) return ;
-			if ( state.backtracking==1 )
-			{
-
-							string action = Text.Substring( 1, Text.Length - 1 );
-							StringTemplate st =
-								generator.TranslateTemplateConstructor(enclosingRule.name,
-																	   outerAltNum,
-																	   actionToken,
-																	   action);
-							chunks.Add(st);
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "INDIRECT_TEMPLATE_INSTANCE"
-
-	// $ANTLR start "ARG"
-	private void mARG()
-	{
-		try
-		{
-			// Grammars\\ActionTranslator.g3:651:7: ( ID '=' ACTION )
-			// Grammars\\ActionTranslator.g3:651:7: ID '=' ACTION
-			{
-			mID(); if (state.failed) return ;
-			Match('='); if (state.failed) return ;
-			mACTION(); if (state.failed) return ;
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ARG"
-
-	// $ANTLR start "SET_EXPR_ATTRIBUTE"
-	private void mSET_EXPR_ATTRIBUTE()
-	{
-		try
-		{
-			int _type = SET_EXPR_ATTRIBUTE;
-			int _channel = DefaultTokenChannel;
-			CommonToken a=null;
-			CommonToken expr=null;
-			CommonToken ID7=null;
-
-			// Grammars\\ActionTranslator.g3:656:4: ( '%' a= ACTION '.' ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' )
-			// Grammars\\ActionTranslator.g3:656:4: '%' a= ACTION '.' ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';'
-			{
-			Match('%'); if (state.failed) return ;
-			int aStart823 = CharIndex;
-			mACTION(); if (state.failed) return ;
-			a = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, aStart823, CharIndex-1);
-			Match('.'); if (state.failed) return ;
-			int ID7Start827 = CharIndex;
-			mID(); if (state.failed) return ;
-			ID7 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ID7Start827, CharIndex-1);
-			// Grammars\\ActionTranslator.g3:656:24: ( WS )?
-			int alt17=2;
-			int LA17_0 = input.LA(1);
-
-			if ( ((LA17_0>='\t' && LA17_0<='\n')||LA17_0=='\r'||LA17_0==' ') )
-			{
-				alt17=1;
-			}
-			switch ( alt17 )
-			{
-			case 1:
-				// Grammars\\ActionTranslator.g3:656:0: WS
-				{
-				mWS(); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-			Match('='); if (state.failed) return ;
-			int exprStart836 = CharIndex;
-			mATTR_VALUE_EXPR(); if (state.failed) return ;
-			expr = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, exprStart836, CharIndex-1);
-			Match(';'); if (state.failed) return ;
-			if ( state.backtracking==1 )
-			{
-
-							StringTemplate st = Template("actionSetAttribute");
-							string action = (a!=null?a.Text:null);
-							action = action.Substring( 1, action.Length - 2 ); // stuff inside {...}
-							st.SetAttribute("st", TranslateAction(action));
-							st.SetAttribute("attrName", (ID7!=null?ID7.Text:null));
-							st.SetAttribute("expr", TranslateAction((expr!=null?expr.Text:null)));
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "SET_EXPR_ATTRIBUTE"
-
-	// $ANTLR start "SET_ATTRIBUTE"
-	private void mSET_ATTRIBUTE()
-	{
-		try
-		{
-			int _type = SET_ATTRIBUTE;
-			int _channel = DefaultTokenChannel;
-			CommonToken x=null;
-			CommonToken y=null;
-			CommonToken expr=null;
-
-			// Grammars\\ActionTranslator.g3:673:4: ( '%' x= ID '.' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' )
-			// Grammars\\ActionTranslator.g3:673:4: '%' x= ID '.' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';'
-			{
-			Match('%'); if (state.failed) return ;
-			int xStart863 = CharIndex;
-			mID(); if (state.failed) return ;
-			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart863, CharIndex-1);
-			Match('.'); if (state.failed) return ;
-			int yStart869 = CharIndex;
-			mID(); if (state.failed) return ;
-			y = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, yStart869, CharIndex-1);
-			// Grammars\\ActionTranslator.g3:673:22: ( WS )?
-			int alt18=2;
-			int LA18_0 = input.LA(1);
-
-			if ( ((LA18_0>='\t' && LA18_0<='\n')||LA18_0=='\r'||LA18_0==' ') )
-			{
-				alt18=1;
-			}
-			switch ( alt18 )
-			{
-			case 1:
-				// Grammars\\ActionTranslator.g3:673:0: WS
-				{
-				mWS(); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-			Match('='); if (state.failed) return ;
-			int exprStart878 = CharIndex;
-			mATTR_VALUE_EXPR(); if (state.failed) return ;
-			expr = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, exprStart878, CharIndex-1);
-			Match(';'); if (state.failed) return ;
-			if ( state.backtracking==1 )
-			{
-
-							StringTemplate st = Template("actionSetAttribute");
-							st.SetAttribute("st", (x!=null?x.Text:null));
-							st.SetAttribute("attrName", (y!=null?y.Text:null));
-							st.SetAttribute("expr", TranslateAction((expr!=null?expr.Text:null)));
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "SET_ATTRIBUTE"
-
-	// $ANTLR start "ATTR_VALUE_EXPR"
-	private void mATTR_VALUE_EXPR()
-	{
-		try
-		{
-			// Grammars\\ActionTranslator.g3:686:4: (~ '=' (~ ';' )* )
-			// Grammars\\ActionTranslator.g3:686:4: ~ '=' (~ ';' )*
-			{
-			if ( (input.LA(1)>='\u0000' && input.LA(1)<='<')||(input.LA(1)>='>' && input.LA(1)<='\uFFFF') )
-			{
-				input.Consume();
-			state.failed=false;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				MismatchedSetException mse = new MismatchedSetException(null,input);
-				Recover(mse);
-				throw mse;}
-
-			// Grammars\\ActionTranslator.g3:686:9: (~ ';' )*
-			for ( ; ; )
-			{
-				int alt19=2;
-				int LA19_0 = input.LA(1);
-
-				if ( ((LA19_0>='\u0000' && LA19_0<=':')||(LA19_0>='<' && LA19_0<='\uFFFF')) )
-				{
-					alt19=1;
-				}
-
-
-				switch ( alt19 )
-				{
-				case 1:
-					// Grammars\\ActionTranslator.g3:
-					{
-					input.Consume();
-					state.failed=false;
-
-					}
-					break;
-
-				default:
-					goto loop19;
-				}
-			}
-
-			loop19:
-				;
-
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ATTR_VALUE_EXPR"
-
-	// $ANTLR start "TEMPLATE_EXPR"
-	private void mTEMPLATE_EXPR()
-	{
-		try
-		{
-			int _type = TEMPLATE_EXPR;
-			int _channel = DefaultTokenChannel;
-			CommonToken a=null;
-
-			// Grammars\\ActionTranslator.g3:691:4: ( '%' a= ACTION )
-			// Grammars\\ActionTranslator.g3:691:4: '%' a= ACTION
-			{
-			Match('%'); if (state.failed) return ;
-			int aStart927 = CharIndex;
-			mACTION(); if (state.failed) return ;
-			a = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, aStart927, CharIndex-1);
-			if ( state.backtracking==1 )
-			{
-
-							StringTemplate st = Template("actionStringConstructor");
-							string action = (a!=null?a.Text:null);
-							action = action.Substring( 1, action.Length - 2 ); // stuff inside {...}
-							st.SetAttribute("stringExpr", TranslateAction(action));
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "TEMPLATE_EXPR"
-
-	// $ANTLR start "ACTION"
-	private void mACTION()
-	{
-		try
-		{
-			// Grammars\\ActionTranslator.g3:703:4: ( '{' ( options {greedy=false; } : . )* '}' )
-			// Grammars\\ActionTranslator.g3:703:4: '{' ( options {greedy=false; } : . )* '}'
-			{
-			Match('{'); if (state.failed) return ;
-			// Grammars\\ActionTranslator.g3:703:8: ( options {greedy=false; } : . )*
-			for ( ; ; )
-			{
-				int alt20=2;
-				int LA20_0 = input.LA(1);
-
-				if ( (LA20_0=='}') )
-				{
-					alt20=2;
-				}
-				else if ( ((LA20_0>='\u0000' && LA20_0<='|')||(LA20_0>='~' && LA20_0<='\uFFFF')) )
-				{
-					alt20=1;
-				}
-
-
-				switch ( alt20 )
-				{
-				case 1:
-					// Grammars\\ActionTranslator.g3:703:33: .
-					{
-					MatchAny(); if (state.failed) return ;
-
-					}
-					break;
-
-				default:
-					goto loop20;
-				}
-			}
-
-			loop20:
-				;
-
-
-			Match('}'); if (state.failed) return ;
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ACTION"
-
-	// $ANTLR start "ESC"
-	private void mESC()
-	{
-		try
-		{
-			int _type = ESC;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ActionTranslator.g3:707:4: ( '\\\\' '$' | '\\\\' '%' | '\\\\' ~ ( '$' | '%' ) )
-			int alt21=3;
-			int LA21_0 = input.LA(1);
-
-			if ( (LA21_0=='\\') )
-			{
-				int LA21_1 = input.LA(2);
-
-				if ( (LA21_1=='$') )
-				{
-					alt21=1;
-				}
-				else if ( (LA21_1=='%') )
-				{
-					alt21=2;
-				}
-				else if ( ((LA21_1>='\u0000' && LA21_1<='#')||(LA21_1>='&' && LA21_1<='\uFFFF')) )
-				{
-					alt21=3;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					NoViableAltException nvae = new NoViableAltException("", 21, 1, input);
-
-					throw nvae;
-				}
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				NoViableAltException nvae = new NoViableAltException("", 21, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt21 )
-			{
-			case 1:
-				// Grammars\\ActionTranslator.g3:707:4: '\\\\' '$'
-				{
-				Match('\\'); if (state.failed) return ;
-				Match('$'); if (state.failed) return ;
-				if ( state.backtracking==1 )
-				{
-					chunks.Add("$");
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\ActionTranslator.g3:708:4: '\\\\' '%'
-				{
-				Match('\\'); if (state.failed) return ;
-				Match('%'); if (state.failed) return ;
-				if ( state.backtracking==1 )
-				{
-					chunks.Add("%");
-				}
-
-				}
-				break;
-			case 3:
-				// Grammars\\ActionTranslator.g3:709:4: '\\\\' ~ ( '$' | '%' )
-				{
-				Match('\\'); if (state.failed) return ;
-				input.Consume();
-				state.failed=false;
-				if ( state.backtracking==1 )
-				{
-					chunks.Add(Text);
-				}
-
-				}
-				break;
-
-			}
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ESC"
-
-	// $ANTLR start "ERROR_XY"
-	private void mERROR_XY()
-	{
-		try
-		{
-			int _type = ERROR_XY;
-			int _channel = DefaultTokenChannel;
-			CommonToken x=null;
-			CommonToken y=null;
-
-			// Grammars\\ActionTranslator.g3:713:4: ( '$' x= ID '.' y= ID )
-			// Grammars\\ActionTranslator.g3:713:4: '$' x= ID '.' y= ID
-			{
-			Match('$'); if (state.failed) return ;
-			int xStart1016 = CharIndex;
-			mID(); if (state.failed) return ;
-			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart1016, CharIndex-1);
-			Match('.'); if (state.failed) return ;
-			int yStart1022 = CharIndex;
-			mID(); if (state.failed) return ;
-			y = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, yStart1022, CharIndex-1);
-			if ( state.backtracking==1 )
-			{
-
-							chunks.Add(Text);
-							generator.IssueInvalidAttributeError((x!=null?x.Text:null),(y!=null?y.Text:null),
-																 enclosingRule,actionToken,
-																 outerAltNum);
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ERROR_XY"
-
-	// $ANTLR start "ERROR_X"
-	private void mERROR_X()
-	{
-		try
-		{
-			int _type = ERROR_X;
-			int _channel = DefaultTokenChannel;
-			CommonToken x=null;
-
-			// Grammars\\ActionTranslator.g3:723:4: ( '$' x= ID )
-			// Grammars\\ActionTranslator.g3:723:4: '$' x= ID
-			{
-			Match('$'); if (state.failed) return ;
-			int xStart1042 = CharIndex;
-			mID(); if (state.failed) return ;
-			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart1042, CharIndex-1);
-			if ( state.backtracking==1 )
-			{
-
-							chunks.Add(Text);
-							generator.IssueInvalidAttributeError((x!=null?x.Text:null),
-																 enclosingRule,actionToken,
-																 outerAltNum);
-
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ERROR_X"
-
-	// $ANTLR start "UNKNOWN_SYNTAX"
-	private void mUNKNOWN_SYNTAX()
-	{
-		try
-		{
-			int _type = UNKNOWN_SYNTAX;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ActionTranslator.g3:733:4: ( '$' | '%' ( ID | '.' | '(' | ')' | ',' | '{' | '}' | '\"' )* )
-			int alt23=2;
-			int LA23_0 = input.LA(1);
-
-			if ( (LA23_0=='$') )
-			{
-				alt23=1;
-			}
-			else if ( (LA23_0=='%') )
-			{
-				alt23=2;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				NoViableAltException nvae = new NoViableAltException("", 23, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt23 )
-			{
-			case 1:
-				// Grammars\\ActionTranslator.g3:733:4: '$'
-				{
-				Match('$'); if (state.failed) return ;
-				if ( state.backtracking==1 )
-				{
-
-								chunks.Add(Text);
-								// shouldn't need an error here.  Just accept $ if it doesn't look like anything
-
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\ActionTranslator.g3:738:4: '%' ( ID | '.' | '(' | ')' | ',' | '{' | '}' | '\"' )*
-				{
-				Match('%'); if (state.failed) return ;
-				// Grammars\\ActionTranslator.g3:738:8: ( ID | '.' | '(' | ')' | ',' | '{' | '}' | '\"' )*
-				for ( ; ; )
-				{
-					int alt22=9;
-					alt22 = dfa22.Predict(input);
-					switch ( alt22 )
-					{
-					case 1:
-						// Grammars\\ActionTranslator.g3:738:9: ID
-						{
-						mID(); if (state.failed) return ;
-
-						}
-						break;
-					case 2:
-						// Grammars\\ActionTranslator.g3:738:12: '.'
-						{
-						Match('.'); if (state.failed) return ;
-
-						}
-						break;
-					case 3:
-						// Grammars\\ActionTranslator.g3:738:16: '('
-						{
-						Match('('); if (state.failed) return ;
-
-						}
-						break;
-					case 4:
-						// Grammars\\ActionTranslator.g3:738:20: ')'
-						{
-						Match(')'); if (state.failed) return ;
-
-						}
-						break;
-					case 5:
-						// Grammars\\ActionTranslator.g3:738:24: ','
-						{
-						Match(','); if (state.failed) return ;
-
-						}
-						break;
-					case 6:
-						// Grammars\\ActionTranslator.g3:738:28: '{'
-						{
-						Match('{'); if (state.failed) return ;
-
-						}
-						break;
-					case 7:
-						// Grammars\\ActionTranslator.g3:738:32: '}'
-						{
-						Match('}'); if (state.failed) return ;
-
-						}
-						break;
-					case 8:
-						// Grammars\\ActionTranslator.g3:738:36: '\"'
-						{
-						Match('\"'); if (state.failed) return ;
-
-						}
-						break;
-
-					default:
-						goto loop22;
-					}
-				}
-
-				loop22:
-					;
-
-
-				if ( state.backtracking==1 )
-				{
-
-								chunks.Add(Text);
-								ErrorManager.GrammarError(ErrorManager.MSG_INVALID_TEMPLATE_ACTION,
-														  grammar,
-														  actionToken,
-														  Text);
-
-				}
-
-				}
-				break;
-
-			}
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "UNKNOWN_SYNTAX"
-
-	// $ANTLR start "TEXT"
-	private void mTEXT()
-	{
-		try
-		{
-			int _type = TEXT;
-			int _channel = DefaultTokenChannel;
-			// Grammars\\ActionTranslator.g3:749:4: ( (~ ( '$' | '%' | '\\\\' ) )+ )
-			// Grammars\\ActionTranslator.g3:749:4: (~ ( '$' | '%' | '\\\\' ) )+
-			{
-			// Grammars\\ActionTranslator.g3:749:4: (~ ( '$' | '%' | '\\\\' ) )+
-			int cnt24=0;
-			for ( ; ; )
-			{
-				int alt24=2;
-				int LA24_0 = input.LA(1);
-
-				if ( ((LA24_0>='\u0000' && LA24_0<='#')||(LA24_0>='&' && LA24_0<='[')||(LA24_0>=']' && LA24_0<='\uFFFF')) )
-				{
-					alt24=1;
-				}
-
-
-				switch ( alt24 )
-				{
-				case 1:
-					// Grammars\\ActionTranslator.g3:
-					{
-					input.Consume();
-					state.failed=false;
-
-					}
-					break;
-
-				default:
-					if ( cnt24 >= 1 )
-						goto loop24;
-
-					if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee24 = new EarlyExitException( 24, input );
-					throw eee24;
-				}
-				cnt24++;
-			}
-			loop24:
-				;
-
-
-			if ( state.backtracking==1 )
-			{
-				chunks.Add(Text);
-			}
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "TEXT"
-
-	// $ANTLR start "ID"
-	private void mID()
-	{
-		try
-		{
-			// Grammars\\ActionTranslator.g3:754:4: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
-			// Grammars\\ActionTranslator.g3:754:4: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
-			{
-			if ( (input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z') )
-			{
-				input.Consume();
-			state.failed=false;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				MismatchedSetException mse = new MismatchedSetException(null,input);
-				Recover(mse);
-				throw mse;}
-
-			// Grammars\\ActionTranslator.g3:754:28: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
-			for ( ; ; )
-			{
-				int alt25=2;
-				int LA25_0 = input.LA(1);
-
-				if ( ((LA25_0>='0' && LA25_0<='9')||(LA25_0>='A' && LA25_0<='Z')||LA25_0=='_'||(LA25_0>='a' && LA25_0<='z')) )
-				{
-					alt25=1;
-				}
-
-
-				switch ( alt25 )
-				{
-				case 1:
-					// Grammars\\ActionTranslator.g3:
-					{
-					input.Consume();
-					state.failed=false;
-
-					}
-					break;
-
-				default:
-					goto loop25;
-				}
-			}
-
-			loop25:
-				;
-
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ID"
-
-	// $ANTLR start "INT"
-	private void mINT()
-	{
-		try
-		{
-			// Grammars\\ActionTranslator.g3:759:4: ( ( '0' .. '9' )+ )
-			// Grammars\\ActionTranslator.g3:759:4: ( '0' .. '9' )+
-			{
-			// Grammars\\ActionTranslator.g3:759:4: ( '0' .. '9' )+
-			int cnt26=0;
-			for ( ; ; )
-			{
-				int alt26=2;
-				int LA26_0 = input.LA(1);
-
-				if ( ((LA26_0>='0' && LA26_0<='9')) )
-				{
-					alt26=1;
-				}
-
-
-				switch ( alt26 )
-				{
-				case 1:
-					// Grammars\\ActionTranslator.g3:
-					{
-					input.Consume();
-					state.failed=false;
-
-					}
-					break;
-
-				default:
-					if ( cnt26 >= 1 )
-						goto loop26;
-
-					if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee26 = new EarlyExitException( 26, input );
-					throw eee26;
-				}
-				cnt26++;
-			}
-			loop26:
-				;
-
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "INT"
-
-	// $ANTLR start "WS"
-	private void mWS()
-	{
-		try
-		{
-			// Grammars\\ActionTranslator.g3:764:4: ( ( ' ' | '\\t' | '\\n' | '\\r' )+ )
-			// Grammars\\ActionTranslator.g3:764:4: ( ' ' | '\\t' | '\\n' | '\\r' )+
-			{
-			// Grammars\\ActionTranslator.g3:764:4: ( ' ' | '\\t' | '\\n' | '\\r' )+
-			int cnt27=0;
-			for ( ; ; )
-			{
-				int alt27=2;
-				int LA27_0 = input.LA(1);
-
-				if ( ((LA27_0>='\t' && LA27_0<='\n')||LA27_0=='\r'||LA27_0==' ') )
-				{
-					alt27=1;
-				}
-
-
-				switch ( alt27 )
-				{
-				case 1:
-					// Grammars\\ActionTranslator.g3:
-					{
-					input.Consume();
-					state.failed=false;
-
-					}
-					break;
-
-				default:
-					if ( cnt27 >= 1 )
-						goto loop27;
-
-					if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee27 = new EarlyExitException( 27, input );
-					throw eee27;
-				}
-				cnt27++;
-			}
-			loop27:
-				;
-
-
-
-			}
-
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "WS"
-
-	public override void mTokens()
-	{
-		// Grammars\\ActionTranslator.g3:1:41: ( SET_ENCLOSING_RULE_SCOPE_ATTR | ENCLOSING_RULE_SCOPE_ATTR | SET_TOKEN_SCOPE_ATTR | TOKEN_SCOPE_ATTR | SET_RULE_SCOPE_ATTR | RULE_SCOPE_ATTR | LABEL_REF | ISOLATED_TOKEN_REF | ISOLATED_LEXER_RULE_REF | SET_LOCAL_ATTR | LOCAL_ATTR | SET_DYNAMIC_SCOPE_ATTR | DYNAMIC_SCOPE_ATTR | ERROR_SCOPED_XY | DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR | DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR | ISOLATED_DYNAMIC_SCOPE | TEMPLATE_INSTANCE | INDIRECT_TEMPLATE_INSTANCE | SET_EXPR_ATTRIBUTE | SET_ATTRIBUTE | TEMPLATE_EXPR | ESC | ERROR_XY | ERROR_X | UNKNOWN_SYNTAX | TEXT )
-		int alt28=27;
-		alt28 = dfa28.Predict(input);
-		switch ( alt28 )
-		{
-		case 1:
-			// Grammars\\ActionTranslator.g3:1:41: SET_ENCLOSING_RULE_SCOPE_ATTR
-			{
-
-			mSET_ENCLOSING_RULE_SCOPE_ATTR(); if (state.failed) return ;
-
-			}
-			break;
-		case 2:
-			// Grammars\\ActionTranslator.g3:1:71: ENCLOSING_RULE_SCOPE_ATTR
-			{
-
-			mENCLOSING_RULE_SCOPE_ATTR(); if (state.failed) return ;
-
-			}
-			break;
-		case 3:
-			// Grammars\\ActionTranslator.g3:1:97: SET_TOKEN_SCOPE_ATTR
-			{
-
-			mSET_TOKEN_SCOPE_ATTR(); if (state.failed) return ;
-
-			}
-			break;
-		case 4:
-			// Grammars\\ActionTranslator.g3:1:118: TOKEN_SCOPE_ATTR
-			{
-
-			mTOKEN_SCOPE_ATTR(); if (state.failed) return ;
-
-			}
-			break;
-		case 5:
-			// Grammars\\ActionTranslator.g3:1:135: SET_RULE_SCOPE_ATTR
-			{
-
-			mSET_RULE_SCOPE_ATTR(); if (state.failed) return ;
-
-			}
-			break;
-		case 6:
-			// Grammars\\ActionTranslator.g3:1:155: RULE_SCOPE_ATTR
-			{
-
-			mRULE_SCOPE_ATTR(); if (state.failed) return ;
-
-			}
-			break;
-		case 7:
-			// Grammars\\ActionTranslator.g3:1:171: LABEL_REF
-			{
-
-			mLABEL_REF(); if (state.failed) return ;
-
-			}
-			break;
-		case 8:
-			// Grammars\\ActionTranslator.g3:1:181: ISOLATED_TOKEN_REF
-			{
-
-			mISOLATED_TOKEN_REF(); if (state.failed) return ;
-
-			}
-			break;
-		case 9:
-			// Grammars\\ActionTranslator.g3:1:200: ISOLATED_LEXER_RULE_REF
-			{
-
-			mISOLATED_LEXER_RULE_REF(); if (state.failed) return ;
-
-			}
-			break;
-		case 10:
-			// Grammars\\ActionTranslator.g3:1:224: SET_LOCAL_ATTR
-			{
-
-			mSET_LOCAL_ATTR(); if (state.failed) return ;
-
-			}
-			break;
-		case 11:
-			// Grammars\\ActionTranslator.g3:1:239: LOCAL_ATTR
-			{
-
-			mLOCAL_ATTR(); if (state.failed) return ;
-
-			}
-			break;
-		case 12:
-			// Grammars\\ActionTranslator.g3:1:250: SET_DYNAMIC_SCOPE_ATTR
-			{
-
-			mSET_DYNAMIC_SCOPE_ATTR(); if (state.failed) return ;
-
-			}
-			break;
-		case 13:
-			// Grammars\\ActionTranslator.g3:1:273: DYNAMIC_SCOPE_ATTR
-			{
-
-			mDYNAMIC_SCOPE_ATTR(); if (state.failed) return ;
-
-			}
-			break;
-		case 14:
-			// Grammars\\ActionTranslator.g3:1:292: ERROR_SCOPED_XY
-			{
-
-			mERROR_SCOPED_XY(); if (state.failed) return ;
-
-			}
-			break;
-		case 15:
-			// Grammars\\ActionTranslator.g3:1:308: DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR
-			{
-
-			mDYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR(); if (state.failed) return ;
-
-			}
-			break;
-		case 16:
-			// Grammars\\ActionTranslator.g3:1:344: DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR
-			{
-
-			mDYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR(); if (state.failed) return ;
-
-			}
-			break;
-		case 17:
-			// Grammars\\ActionTranslator.g3:1:380: ISOLATED_DYNAMIC_SCOPE
-			{
-
-			mISOLATED_DYNAMIC_SCOPE(); if (state.failed) return ;
-
-			}
-			break;
-		case 18:
-			// Grammars\\ActionTranslator.g3:1:403: TEMPLATE_INSTANCE
-			{
-
-			mTEMPLATE_INSTANCE(); if (state.failed) return ;
-
-			}
-			break;
-		case 19:
-			// Grammars\\ActionTranslator.g3:1:421: INDIRECT_TEMPLATE_INSTANCE
-			{
-
-			mINDIRECT_TEMPLATE_INSTANCE(); if (state.failed) return ;
-
-			}
-			break;
-		case 20:
-			// Grammars\\ActionTranslator.g3:1:448: SET_EXPR_ATTRIBUTE
-			{
-
-			mSET_EXPR_ATTRIBUTE(); if (state.failed) return ;
-
-			}
-			break;
-		case 21:
-			// Grammars\\ActionTranslator.g3:1:467: SET_ATTRIBUTE
-			{
-
-			mSET_ATTRIBUTE(); if (state.failed) return ;
-
-			}
-			break;
-		case 22:
-			// Grammars\\ActionTranslator.g3:1:481: TEMPLATE_EXPR
-			{
-
-			mTEMPLATE_EXPR(); if (state.failed) return ;
-
-			}
-			break;
-		case 23:
-			// Grammars\\ActionTranslator.g3:1:495: ESC
-			{
-
-			mESC(); if (state.failed) return ;
-
-			}
-			break;
-		case 24:
-			// Grammars\\ActionTranslator.g3:1:499: ERROR_XY
-			{
-
-			mERROR_XY(); if (state.failed) return ;
-
-			}
-			break;
-		case 25:
-			// Grammars\\ActionTranslator.g3:1:508: ERROR_X
-			{
-
-			mERROR_X(); if (state.failed) return ;
-
-			}
-			break;
-		case 26:
-			// Grammars\\ActionTranslator.g3:1:516: UNKNOWN_SYNTAX
-			{
-
-			mUNKNOWN_SYNTAX(); if (state.failed) return ;
-
-			}
-			break;
-		case 27:
-			// Grammars\\ActionTranslator.g3:1:531: TEXT
-			{
-			mTEXT(); if (state.failed) return ;
-
-			}
-			break;
-
-		}
-
-	}
-
-	// $ANTLR start synpred1_ActionTranslator
-	public void synpred1_ActionTranslator_fragment()
-	{
-		// Grammars\\ActionTranslator.g3:1:0: ( SET_ENCLOSING_RULE_SCOPE_ATTR )
-		// Grammars\\ActionTranslator.g3:1:41: SET_ENCLOSING_RULE_SCOPE_ATTR
-		{
-		mSET_ENCLOSING_RULE_SCOPE_ATTR(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred1_ActionTranslator
-
-	// $ANTLR start synpred10_ActionTranslator
-	public void synpred10_ActionTranslator_fragment()
-	{
-		// Grammars\\ActionTranslator.g3:1:0: ( SET_LOCAL_ATTR )
-		// Grammars\\ActionTranslator.g3:1:224: SET_LOCAL_ATTR
-		{
-		mSET_LOCAL_ATTR(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred10_ActionTranslator
-
-	// $ANTLR start synpred11_ActionTranslator
-	public void synpred11_ActionTranslator_fragment()
-	{
-		// Grammars\\ActionTranslator.g3:1:0: ( LOCAL_ATTR )
-		// Grammars\\ActionTranslator.g3:1:239: LOCAL_ATTR
-		{
-		mLOCAL_ATTR(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred11_ActionTranslator
-
-	// $ANTLR start synpred12_ActionTranslator
-	public void synpred12_ActionTranslator_fragment()
-	{
-		// Grammars\\ActionTranslator.g3:1:0: ( SET_DYNAMIC_SCOPE_ATTR )
-		// Grammars\\ActionTranslator.g3:1:250: SET_DYNAMIC_SCOPE_ATTR
-		{
-		mSET_DYNAMIC_SCOPE_ATTR(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred12_ActionTranslator
-
-	// $ANTLR start synpred13_ActionTranslator
-	public void synpred13_ActionTranslator_fragment()
-	{
-		// Grammars\\ActionTranslator.g3:1:0: ( DYNAMIC_SCOPE_ATTR )
-		// Grammars\\ActionTranslator.g3:1:273: DYNAMIC_SCOPE_ATTR
-		{
-		mDYNAMIC_SCOPE_ATTR(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred13_ActionTranslator
-
-	// $ANTLR start synpred14_ActionTranslator
-	public void synpred14_ActionTranslator_fragment()
-	{
-		// Grammars\\ActionTranslator.g3:1:0: ( ERROR_SCOPED_XY )
-		// Grammars\\ActionTranslator.g3:1:292: ERROR_SCOPED_XY
-		{
-		mERROR_SCOPED_XY(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred14_ActionTranslator
-
-	// $ANTLR start synpred15_ActionTranslator
-	public void synpred15_ActionTranslator_fragment()
-	{
-		// Grammars\\ActionTranslator.g3:1:0: ( DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR )
-		// Grammars\\ActionTranslator.g3:1:308: DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR
-		{
-		mDYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred15_ActionTranslator
-
-	// $ANTLR start synpred16_ActionTranslator
-	public void synpred16_ActionTranslator_fragment()
-	{
-		// Grammars\\ActionTranslator.g3:1:0: ( DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR )
-		// Grammars\\ActionTranslator.g3:1:344: DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR
-		{
-		mDYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred16_ActionTranslator
-
-	// $ANTLR start synpred17_ActionTranslator
-	public void synpred17_ActionTranslator_fragment()
-	{
-		// Grammars\\ActionTranslator.g3:1:0: ( ISOLATED_DYNAMIC_SCOPE )
-		// Grammars\\ActionTranslator.g3:1:380: ISOLATED_DYNAMIC_SCOPE
-		{
-		mISOLATED_DYNAMIC_SCOPE(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred17_ActionTranslator
-
-	// $ANTLR start synpred18_ActionTranslator
-	public void synpred18_ActionTranslator_fragment()
-	{
-		// Grammars\\ActionTranslator.g3:1:0: ( TEMPLATE_INSTANCE )
-		// Grammars\\ActionTranslator.g3:1:403: TEMPLATE_INSTANCE
-		{
-		mTEMPLATE_INSTANCE(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred18_ActionTranslator
-
-	// $ANTLR start synpred19_ActionTranslator
-	public void synpred19_ActionTranslator_fragment()
-	{
-		// Grammars\\ActionTranslator.g3:1:0: ( INDIRECT_TEMPLATE_INSTANCE )
-		// Grammars\\ActionTranslator.g3:1:421: INDIRECT_TEMPLATE_INSTANCE
-		{
-		mINDIRECT_TEMPLATE_INSTANCE(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred19_ActionTranslator
-
-	// $ANTLR start synpred2_ActionTranslator
-	public void synpred2_ActionTranslator_fragment()
-	{
-		// Grammars\\ActionTranslator.g3:1:0: ( ENCLOSING_RULE_SCOPE_ATTR )
-		// Grammars\\ActionTranslator.g3:1:71: ENCLOSING_RULE_SCOPE_ATTR
-		{
-		mENCLOSING_RULE_SCOPE_ATTR(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred2_ActionTranslator
-
-	// $ANTLR start synpred20_ActionTranslator
-	public void synpred20_ActionTranslator_fragment()
-	{
-		// Grammars\\ActionTranslator.g3:1:0: ( SET_EXPR_ATTRIBUTE )
-		// Grammars\\ActionTranslator.g3:1:448: SET_EXPR_ATTRIBUTE
-		{
-		mSET_EXPR_ATTRIBUTE(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred20_ActionTranslator
-
-	// $ANTLR start synpred21_ActionTranslator
-	public void synpred21_ActionTranslator_fragment()
-	{
-		// Grammars\\ActionTranslator.g3:1:0: ( SET_ATTRIBUTE )
-		// Grammars\\ActionTranslator.g3:1:467: SET_ATTRIBUTE
-		{
-		mSET_ATTRIBUTE(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred21_ActionTranslator
-
-	// $ANTLR start synpred22_ActionTranslator
-	public void synpred22_ActionTranslator_fragment()
-	{
-		// Grammars\\ActionTranslator.g3:1:0: ( TEMPLATE_EXPR )
-		// Grammars\\ActionTranslator.g3:1:481: TEMPLATE_EXPR
-		{
-		mTEMPLATE_EXPR(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred22_ActionTranslator
-
-	// $ANTLR start synpred24_ActionTranslator
-	public void synpred24_ActionTranslator_fragment()
-	{
-		// Grammars\\ActionTranslator.g3:1:0: ( ERROR_XY )
-		// Grammars\\ActionTranslator.g3:1:499: ERROR_XY
-		{
-		mERROR_XY(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred24_ActionTranslator
-
-	// $ANTLR start synpred25_ActionTranslator
-	public void synpred25_ActionTranslator_fragment()
-	{
-		// Grammars\\ActionTranslator.g3:1:0: ( ERROR_X )
-		// Grammars\\ActionTranslator.g3:1:508: ERROR_X
-		{
-		mERROR_X(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred25_ActionTranslator
-
-	// $ANTLR start synpred26_ActionTranslator
-	public void synpred26_ActionTranslator_fragment()
-	{
-		// Grammars\\ActionTranslator.g3:1:0: ( UNKNOWN_SYNTAX )
-		// Grammars\\ActionTranslator.g3:1:516: UNKNOWN_SYNTAX
-		{
-		mUNKNOWN_SYNTAX(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred26_ActionTranslator
-
-	// $ANTLR start synpred3_ActionTranslator
-	public void synpred3_ActionTranslator_fragment()
-	{
-		// Grammars\\ActionTranslator.g3:1:0: ( SET_TOKEN_SCOPE_ATTR )
-		// Grammars\\ActionTranslator.g3:1:97: SET_TOKEN_SCOPE_ATTR
-		{
-		mSET_TOKEN_SCOPE_ATTR(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred3_ActionTranslator
-
-	// $ANTLR start synpred4_ActionTranslator
-	public void synpred4_ActionTranslator_fragment()
-	{
-		// Grammars\\ActionTranslator.g3:1:0: ( TOKEN_SCOPE_ATTR )
-		// Grammars\\ActionTranslator.g3:1:118: TOKEN_SCOPE_ATTR
-		{
-		mTOKEN_SCOPE_ATTR(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred4_ActionTranslator
-
-	// $ANTLR start synpred5_ActionTranslator
-	public void synpred5_ActionTranslator_fragment()
-	{
-		// Grammars\\ActionTranslator.g3:1:0: ( SET_RULE_SCOPE_ATTR )
-		// Grammars\\ActionTranslator.g3:1:135: SET_RULE_SCOPE_ATTR
-		{
-		mSET_RULE_SCOPE_ATTR(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred5_ActionTranslator
-
-	// $ANTLR start synpred6_ActionTranslator
-	public void synpred6_ActionTranslator_fragment()
-	{
-		// Grammars\\ActionTranslator.g3:1:0: ( RULE_SCOPE_ATTR )
-		// Grammars\\ActionTranslator.g3:1:155: RULE_SCOPE_ATTR
-		{
-		mRULE_SCOPE_ATTR(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred6_ActionTranslator
-
-	// $ANTLR start synpred7_ActionTranslator
-	public void synpred7_ActionTranslator_fragment()
-	{
-		// Grammars\\ActionTranslator.g3:1:0: ( LABEL_REF )
-		// Grammars\\ActionTranslator.g3:1:171: LABEL_REF
-		{
-		mLABEL_REF(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred7_ActionTranslator
-
-	// $ANTLR start synpred8_ActionTranslator
-	public void synpred8_ActionTranslator_fragment()
-	{
-		// Grammars\\ActionTranslator.g3:1:0: ( ISOLATED_TOKEN_REF )
-		// Grammars\\ActionTranslator.g3:1:181: ISOLATED_TOKEN_REF
-		{
-		mISOLATED_TOKEN_REF(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred8_ActionTranslator
-
-	// $ANTLR start synpred9_ActionTranslator
-	public void synpred9_ActionTranslator_fragment()
-	{
-		// Grammars\\ActionTranslator.g3:1:0: ( ISOLATED_LEXER_RULE_REF )
-		// Grammars\\ActionTranslator.g3:1:200: ISOLATED_LEXER_RULE_REF
-		{
-		mISOLATED_LEXER_RULE_REF(); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred9_ActionTranslator
-
-	#region Synpreds
-	bool EvaluatePredicate( System.Action fragment )
-	{
-		state.backtracking++;
-		int start = input.Mark();
-		try
-		{
-			fragment();
-		}
-		catch ( RecognitionException re )
-		{
-			System.Console.Error.WriteLine("impossible: "+re);
-		}
-		bool success = !state.failed;
-		input.Rewind(start);
-		state.backtracking--;
-		state.failed=false;
-		return success;
-	}
-	#endregion Synpreds
-
-
-	#region DFA
-	DFA22 dfa22;
-	DFA28 dfa28;
-
-	protected override void InitDFAs()
-	{
-		base.InitDFAs();
-		dfa22 = new DFA22( this );
-		dfa28 = new DFA28( this, new SpecialStateTransitionHandler( specialStateTransition28 ) );
-	}
-
-	class DFA22 : DFA
-	{
-
-		const string DFA22_eotS =
-			"\x1\x1\x9\xFFFF";
-		const string DFA22_eofS =
-			"\xA\xFFFF";
-		const string DFA22_minS =
-			"\x1\x22\x9\xFFFF";
-		const string DFA22_maxS =
-			"\x1\x7D\x9\xFFFF";
-		const string DFA22_acceptS =
-			"\x1\xFFFF\x1\x9\x1\x1\x1\x2\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8";
-		const string DFA22_specialS =
-			"\xA\xFFFF}>";
-		static readonly string[] DFA22_transitionS =
-			{
-				"\x1\x9\x5\xFFFF\x1\x4\x1\x5\x2\xFFFF\x1\x6\x1\xFFFF\x1\x3\x12\xFFFF"+
-				"\x1A\x2\x4\xFFFF\x1\x2\x1\xFFFF\x1A\x2\x1\x7\x1\xFFFF\x1\x8",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				""
-			};
-
-		static readonly short[] DFA22_eot = DFA.UnpackEncodedString(DFA22_eotS);
-		static readonly short[] DFA22_eof = DFA.UnpackEncodedString(DFA22_eofS);
-		static readonly char[] DFA22_min = DFA.UnpackEncodedStringToUnsignedChars(DFA22_minS);
-		static readonly char[] DFA22_max = DFA.UnpackEncodedStringToUnsignedChars(DFA22_maxS);
-		static readonly short[] DFA22_accept = DFA.UnpackEncodedString(DFA22_acceptS);
-		static readonly short[] DFA22_special = DFA.UnpackEncodedString(DFA22_specialS);
-		static readonly short[][] DFA22_transition;
-
-		static DFA22()
-		{
-			int numStates = DFA22_transitionS.Length;
-			DFA22_transition = new short[numStates][];
-			for ( int i=0; i < numStates; i++ )
-			{
-				DFA22_transition[i] = DFA.UnpackEncodedString(DFA22_transitionS[i]);
-			}
-		}
-
-		public DFA22( BaseRecognizer recognizer )
-		{
-			this.recognizer = recognizer;
-			this.decisionNumber = 22;
-			this.eot = DFA22_eot;
-			this.eof = DFA22_eof;
-			this.min = DFA22_min;
-			this.max = DFA22_max;
-			this.accept = DFA22_accept;
-			this.special = DFA22_special;
-			this.transition = DFA22_transition;
-		}
-		public override string GetDescription()
-		{
-			return "()* loopback of 738:8: ( ID | '.' | '(' | ')' | ',' | '{' | '}' | '\"' )*";
-		}
-	}
-
-	class DFA28 : DFA
-	{
-
-		const string DFA28_eotS =
-			"\x1E\xFFFF";
-		const string DFA28_eofS =
-			"\x1E\xFFFF";
-		const string DFA28_minS =
-			"\x2\x0\x14\xFFFF\x1\x0\x7\xFFFF";
-		const string DFA28_maxS =
-			"\x1\xFFFF\x1\x0\x14\xFFFF\x1\x0\x7\xFFFF";
-		const string DFA28_acceptS =
-			"\x2\xFFFF\x1\x1\x1\x2\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9\x1\xA"+
-			"\x1\xB\x1\xC\x1\xD\x1\xE\x1\xF\x1\x10\x1\x11\x1\x18\x1\x19\x1\x1A\x1"+
-			"\xFFFF\x1\x12\x1\x13\x1\x14\x1\x15\x1\x16\x1\x17\x1\x1B";
-		const string DFA28_specialS =
-			"\x1\x0\x1\x1\x14\xFFFF\x1\x2\x7\xFFFF}>";
-		static readonly string[] DFA28_transitionS =
-			{
-				"\x24\x1D\x1\x1\x1\x16\x36\x1D\x1\x1C\xFFA3\x1D",
-				"\x1\xFFFF",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"\x1\xFFFF",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				""
-			};
-
-		static readonly short[] DFA28_eot = DFA.UnpackEncodedString(DFA28_eotS);
-		static readonly short[] DFA28_eof = DFA.UnpackEncodedString(DFA28_eofS);
-		static readonly char[] DFA28_min = DFA.UnpackEncodedStringToUnsignedChars(DFA28_minS);
-		static readonly char[] DFA28_max = DFA.UnpackEncodedStringToUnsignedChars(DFA28_maxS);
-		static readonly short[] DFA28_accept = DFA.UnpackEncodedString(DFA28_acceptS);
-		static readonly short[] DFA28_special = DFA.UnpackEncodedString(DFA28_specialS);
-		static readonly short[][] DFA28_transition;
-
-		static DFA28()
-		{
-			int numStates = DFA28_transitionS.Length;
-			DFA28_transition = new short[numStates][];
-			for ( int i=0; i < numStates; i++ )
-			{
-				DFA28_transition[i] = DFA.UnpackEncodedString(DFA28_transitionS[i]);
-			}
-		}
-
-		public DFA28( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
-			: base( specialStateTransition )	{
-			this.recognizer = recognizer;
-			this.decisionNumber = 28;
-			this.eot = DFA28_eot;
-			this.eof = DFA28_eof;
-			this.min = DFA28_min;
-			this.max = DFA28_max;
-			this.accept = DFA28_accept;
-			this.special = DFA28_special;
-			this.transition = DFA28_transition;
-		}
-		public override string GetDescription()
-		{
-			return "1:0: Tokens options {k=1; backtrack=true; } : ( SET_ENCLOSING_RULE_SCOPE_ATTR | ENCLOSING_RULE_SCOPE_ATTR | SET_TOKEN_SCOPE_ATTR | TOKEN_SCOPE_ATTR | SET_RULE_SCOPE_ATTR | RULE_SCOPE_ATTR | LABEL_REF | ISOLATED_TOKEN_REF | ISOLATED_LEXER_RULE_REF | SET_LOCAL_ATTR | LOCAL_ATTR | SET_DYNAMIC_SCOPE_ATTR | DYNAMIC_SCOPE_ATTR | ERROR_SCOPED_XY | DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR | DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR | ISOLATED_DYNAMIC_SCOPE | TEMPLATE_INSTANCE | INDIRECT_TEMPLATE_INSTANCE | SET_EXPR_ATTRIBUTE | SET_ATTRIBUTE | TEMPLATE_EXPR | ESC | ERROR_XY | ERROR_X | UNKNOWN_SYNTAX | TEXT );";
-		}
-	}
-
-	int specialStateTransition28( DFA dfa, int s, IIntStream _input )
-	{
-		IIntStream input = _input;
-		int _s = s;
-		switch ( s )
-		{
-			case 0:
-				int LA28_0 = input.LA(1);
-
-				s = -1;
-				if ( (LA28_0=='$') ) {s = 1;}
-
-				else if ( (LA28_0=='%') ) {s = 22;}
-
-				else if ( (LA28_0=='\\') ) {s = 28;}
-
-				else if ( ((LA28_0>='\u0000' && LA28_0<='#')||(LA28_0>='&' && LA28_0<='[')||(LA28_0>=']' && LA28_0<='\uFFFF')) ) {s = 29;}
-
-				if ( s>=0 ) return s;
-				break;
-			case 1:
-				int LA28_1 = input.LA(1);
-
-
-				int index28_1 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (EvaluatePredicate(synpred1_ActionTranslator_fragment)) ) {s = 2;}
-
-				else if ( (EvaluatePredicate(synpred2_ActionTranslator_fragment)) ) {s = 3;}
-
-				else if ( (EvaluatePredicate(synpred3_ActionTranslator_fragment)) ) {s = 4;}
-
-				else if ( (EvaluatePredicate(synpred4_ActionTranslator_fragment)) ) {s = 5;}
-
-				else if ( (EvaluatePredicate(synpred5_ActionTranslator_fragment)) ) {s = 6;}
-
-				else if ( (EvaluatePredicate(synpred6_ActionTranslator_fragment)) ) {s = 7;}
-
-				else if ( (EvaluatePredicate(synpred7_ActionTranslator_fragment)) ) {s = 8;}
-
-				else if ( (EvaluatePredicate(synpred8_ActionTranslator_fragment)) ) {s = 9;}
-
-				else if ( (EvaluatePredicate(synpred9_ActionTranslator_fragment)) ) {s = 10;}
-
-				else if ( (EvaluatePredicate(synpred10_ActionTranslator_fragment)) ) {s = 11;}
-
-				else if ( (EvaluatePredicate(synpred11_ActionTranslator_fragment)) ) {s = 12;}
-
-				else if ( (EvaluatePredicate(synpred12_ActionTranslator_fragment)) ) {s = 13;}
-
-				else if ( (EvaluatePredicate(synpred13_ActionTranslator_fragment)) ) {s = 14;}
-
-				else if ( (EvaluatePredicate(synpred14_ActionTranslator_fragment)) ) {s = 15;}
-
-				else if ( (EvaluatePredicate(synpred15_ActionTranslator_fragment)) ) {s = 16;}
-
-				else if ( (EvaluatePredicate(synpred16_ActionTranslator_fragment)) ) {s = 17;}
-
-				else if ( (EvaluatePredicate(synpred17_ActionTranslator_fragment)) ) {s = 18;}
-
-				else if ( (EvaluatePredicate(synpred24_ActionTranslator_fragment)) ) {s = 19;}
-
-				else if ( (EvaluatePredicate(synpred25_ActionTranslator_fragment)) ) {s = 20;}
-
-				else if ( (EvaluatePredicate(synpred26_ActionTranslator_fragment)) ) {s = 21;}
-
-
-				input.Seek(index28_1);
-				if ( s>=0 ) return s;
-				break;
-			case 2:
-				int LA28_22 = input.LA(1);
-
-
-				int index28_22 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (EvaluatePredicate(synpred18_ActionTranslator_fragment)) ) {s = 23;}
-
-				else if ( (EvaluatePredicate(synpred19_ActionTranslator_fragment)) ) {s = 24;}
-
-				else if ( (EvaluatePredicate(synpred20_ActionTranslator_fragment)) ) {s = 25;}
-
-				else if ( (EvaluatePredicate(synpred21_ActionTranslator_fragment)) ) {s = 26;}
-
-				else if ( (EvaluatePredicate(synpred22_ActionTranslator_fragment)) ) {s = 27;}
-
-				else if ( (EvaluatePredicate(synpred26_ActionTranslator_fragment)) ) {s = 21;}
-
-
-				input.Seek(index28_22);
-				if ( s>=0 ) return s;
-				break;
-		}
-		if (state.backtracking>0) {state.failed=true; return -1;}
-		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 28, _s, input);
-		dfa.Error(nvae);
-		throw nvae;
-	}
-
-	#endregion
-
-}
-
-} // namespace Antlr3.Grammars
diff --git a/Antlr3/Grammars/AssignTokenTypesWalker.cs b/Antlr3/Grammars/AssignTokenTypesWalker.cs
deleted file mode 100644
index f94d450..0000000
--- a/Antlr3/Grammars/AssignTokenTypesWalker.cs
+++ /dev/null
@@ -1,3350 +0,0 @@
-// $ANTLR 3.1.2 Grammars\\AssignTokenTypesWalker.g3 2009-09-30 13:28:43
-
-// The variable 'variable' is assigned but its value is never used.
-#pragma warning disable 219
-// Unreachable code detected.
-#pragma warning disable 162
-
-
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Grammar conversion to ANTLR v3 and C#:
- Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-	notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-	derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-using System;
-using Antlr3.Analysis;
-using Antlr3.Misc;
-using Antlr3.Tool;
-
-using BitSet = Antlr.Runtime.BitSet;
-using DFA = Antlr.Runtime.DFA;
-using HashMap = System.Collections.Generic.Dictionary<object, object>;
-using Map = System.Collections.IDictionary;
-
-
-using System.Collections.Generic;
-using Antlr.Runtime;
-using Antlr.Runtime.Tree;
-using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;using Stack = System.Collections.Generic.Stack<object>;
-using List = System.Collections.IList;
-using ArrayList = System.Collections.Generic.List<object>;
-
-namespace Antlr3.Grammars
-{
-/** [Warning: TJP says that this is probably out of date as of 11/19/2005,
- *   but since it's probably still useful, I'll leave in.  Don't have energy
- *   to update at the moment.]
- *
- *  Compute the token types for all literals and rules etc..  There are
- *  a few different cases to consider for grammar types and a few situations
- *  within.
- *
- *  CASE 1 : pure parser grammar
- *	a) Any reference to a token gets a token type.
- *  b) The tokens section may alias a token name to a string or char
- *
- *  CASE 2 : pure lexer grammar
- *  a) Import token vocabulary if available. Set token types for any new tokens
- *     to values above last imported token type
- *  b) token rule definitions get token types if not already defined
- *  c) literals do NOT get token types
- *
- *  CASE 3 : merged parser / lexer grammar
- *	a) Any char or string literal gets a token type in a parser rule
- *  b) Any reference to a token gets a token type if not referencing
- *     a fragment lexer rule
- *  c) The tokens section may alias a token name to a string or char
- *     which must add a rule to the lexer
- *  d) token rule definitions get token types if not already defined
- *  e) token rule definitions may also alias a token name to a literal.
- *     E.g., Rule 'FOR : "for";' will alias FOR to "for" in the sense that
- *     references to either in the parser grammar will yield the token type
- *
- *  What this pass does:
- *
- *  0. Collects basic info about the grammar like grammar name and type;
- *     Oh, I have go get the options in case they affect the token types.
- *     E.g., tokenVocab option.
- *     Imports any token vocab name/type pairs into a local hashtable.
- *  1. Finds a list of all literals and token names.
- *  2. Finds a list of all token name rule definitions;
- *     no token rules implies pure parser.
- *  3. Finds a list of all simple token rule defs of form "<NAME> : <literal>;"
- *     and aliases them.
- *  4. Walks token names table and assign types to any unassigned
- *  5. Walks aliases and assign types to referenced literals
- *  6. Walks literals, assigning types if untyped
- *  4. Informs the Grammar object of the type definitions such as:
- *     g.defineToken(<charliteral>, ttype);
- *     g.defineToken(<stringliteral>, ttype);
- *     g.defineToken(<tokenID>, ttype);
- *     where some of the ttype values will be the same for aliases tokens.
- */
-[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.1.2")]
-[System.CLSCompliant(false)]
-public partial class AssignTokenTypesWalker : TreeParser
-{
-	internal static readonly string[] tokenNames = new string[] {
-		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", "ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARG_ACTION", "ARGLIST", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", "CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", "COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", "DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", "EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", "GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", "LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", "NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", "OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", "RET", "RETURNS", "REWRITE", "ROOT", "RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", "SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYN_SEMPRED", "SYNPRED", "TEMPLATE", "THROWS", "TOKEN_REF", "TOKENS", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", "WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT", "CHARSET"
-	};
-	public const int EOF=-1;
-	public const int ACTION=4;
-	public const int ACTION_CHAR_LITERAL=5;
-	public const int ACTION_ESC=6;
-	public const int ACTION_STRING_LITERAL=7;
-	public const int ALT=8;
-	public const int AMPERSAND=9;
-	public const int ARG=10;
-	public const int ARG_ACTION=11;
-	public const int ARGLIST=12;
-	public const int ASSIGN=13;
-	public const int BACKTRACK_SEMPRED=14;
-	public const int BANG=15;
-	public const int BLOCK=16;
-	public const int CATCH=17;
-	public const int CHAR_LITERAL=18;
-	public const int CHAR_RANGE=19;
-	public const int CLOSE_ELEMENT_OPTION=20;
-	public const int CLOSURE=21;
-	public const int COLON=22;
-	public const int COMBINED_GRAMMAR=23;
-	public const int COMMA=24;
-	public const int COMMENT=25;
-	public const int DIGIT=26;
-	public const int DOC_COMMENT=27;
-	public const int DOLLAR=28;
-	public const int DOT=29;
-	public const int DOUBLE_ANGLE_STRING_LITERAL=30;
-	public const int DOUBLE_QUOTE_STRING_LITERAL=31;
-	public const int EOA=32;
-	public const int EOB=33;
-	public const int EOR=34;
-	public const int EPSILON=35;
-	public const int ESC=36;
-	public const int ETC=37;
-	public const int FINALLY=38;
-	public const int FORCED_ACTION=39;
-	public const int FRAGMENT=40;
-	public const int GATED_SEMPRED=41;
-	public const int GRAMMAR=42;
-	public const int ID=43;
-	public const int IMPLIES=44;
-	public const int IMPORT=45;
-	public const int INITACTION=46;
-	public const int INT=47;
-	public const int LABEL=48;
-	public const int LEXER=49;
-	public const int LEXER_GRAMMAR=50;
-	public const int LPAREN=51;
-	public const int ML_COMMENT=52;
-	public const int NESTED_ACTION=53;
-	public const int NESTED_ARG_ACTION=54;
-	public const int NOT=55;
-	public const int OPEN_ELEMENT_OPTION=56;
-	public const int OPTIONAL=57;
-	public const int OPTIONS=58;
-	public const int OR=59;
-	public const int PARSER=60;
-	public const int PARSER_GRAMMAR=61;
-	public const int PLUS=62;
-	public const int PLUS_ASSIGN=63;
-	public const int POSITIVE_CLOSURE=64;
-	public const int PRIVATE=65;
-	public const int PROTECTED=66;
-	public const int PUBLIC=67;
-	public const int QUESTION=68;
-	public const int RANGE=69;
-	public const int RCURLY=70;
-	public const int RET=71;
-	public const int RETURNS=72;
-	public const int REWRITE=73;
-	public const int ROOT=74;
-	public const int RPAREN=75;
-	public const int RULE=76;
-	public const int RULE_REF=77;
-	public const int SCOPE=78;
-	public const int SEMI=79;
-	public const int SEMPRED=80;
-	public const int SL_COMMENT=81;
-	public const int SRC=82;
-	public const int STAR=83;
-	public const int STRAY_BRACKET=84;
-	public const int STRING_LITERAL=85;
-	public const int SYN_SEMPRED=86;
-	public const int SYNPRED=87;
-	public const int TEMPLATE=88;
-	public const int THROWS=89;
-	public const int TOKEN_REF=90;
-	public const int TOKENS=91;
-	public const int TREE=92;
-	public const int TREE_BEGIN=93;
-	public const int TREE_GRAMMAR=94;
-	public const int WILDCARD=95;
-	public const int WS=96;
-	public const int WS_LOOP=97;
-	public const int WS_OPT=98;
-	public const int XDIGIT=99;
-	public const int CHARSET=100;
-
-	// delegates
-	// delegators
-
-	public AssignTokenTypesWalker( ITreeNodeStream input )
-		: this( input, new RecognizerSharedState() )
-	{
-	}
-	public AssignTokenTypesWalker( ITreeNodeStream input, RecognizerSharedState state )
-		: base( input, state )
-	{
-	}
-
-
-	public override string[] TokenNames { get { return AssignTokenTypesWalker.tokenNames; } }
-	public override string GrammarFileName { get { return "Grammars\\AssignTokenTypesWalker.g3"; } }
-
-
-	#region Rules
-
-	// $ANTLR start "grammar_"
-	// Grammars\\AssignTokenTypesWalker.g3:139:0: public grammar_[Grammar g] : ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) ) ;
-	public void grammar_( Grammar g )
-	{
-
-			if ( state.backtracking == 0 )
-				Init(g);
-
-		try
-		{
-			// Grammars\\AssignTokenTypesWalker.g3:145:4: ( ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) ) )
-			// Grammars\\AssignTokenTypesWalker.g3:145:4: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
-			{
-			// Grammars\\AssignTokenTypesWalker.g3:145:4: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
-			int alt1=4;
-			switch ( input.LA(1) )
-			{
-			case LEXER_GRAMMAR:
-				{
-				alt1=1;
-				}
-				break;
-			case PARSER_GRAMMAR:
-				{
-				alt1=2;
-				}
-				break;
-			case TREE_GRAMMAR:
-				{
-				alt1=3;
-				}
-				break;
-			case COMBINED_GRAMMAR:
-				{
-				alt1=4;
-				}
-				break;
-			default:
-				{
-					NoViableAltException nvae = new NoViableAltException("", 1, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt1 )
-			{
-			case 1:
-				// Grammars\\AssignTokenTypesWalker.g3:145:6: ^( LEXER_GRAMMAR grammarSpec )
-				{
-				Match(input,LEXER_GRAMMAR,Follow._LEXER_GRAMMAR_in_grammar_68);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._grammarSpec_in_grammar_73);
-				grammarSpec();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 2:
-				// Grammars\\AssignTokenTypesWalker.g3:146:5: ^( PARSER_GRAMMAR grammarSpec )
-				{
-				Match(input,PARSER_GRAMMAR,Follow._PARSER_GRAMMAR_in_grammar_83);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._grammarSpec_in_grammar_87);
-				grammarSpec();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 3:
-				// Grammars\\AssignTokenTypesWalker.g3:147:5: ^( TREE_GRAMMAR grammarSpec )
-				{
-				Match(input,TREE_GRAMMAR,Follow._TREE_GRAMMAR_in_grammar_97);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._grammarSpec_in_grammar_103);
-				grammarSpec();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 4:
-				// Grammars\\AssignTokenTypesWalker.g3:148:5: ^( COMBINED_GRAMMAR grammarSpec )
-				{
-				Match(input,COMBINED_GRAMMAR,Follow._COMBINED_GRAMMAR_in_grammar_113);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._grammarSpec_in_grammar_115);
-				grammarSpec();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-
-			}
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "grammar_"
-
-
-	// $ANTLR start "grammarSpec"
-	// Grammars\\AssignTokenTypesWalker.g3:152:0: grammarSpec : id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules ;
-	private void grammarSpec(  )
-	{
-		GrammarAST id=null;
-		GrammarAST cmt=null;
-
-		try
-		{
-			// Grammars\\AssignTokenTypesWalker.g3:153:4: (id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules )
-			// Grammars\\AssignTokenTypesWalker.g3:153:4: id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules
-			{
-			id=(GrammarAST)Match(input,ID,Follow._ID_in_grammarSpec134);
-			// Grammars\\AssignTokenTypesWalker.g3:154:3: (cmt= DOC_COMMENT )?
-			int alt2=2;
-			int LA2_0 = input.LA(1);
-
-			if ( (LA2_0==DOC_COMMENT) )
-			{
-				alt2=1;
-			}
-			switch ( alt2 )
-			{
-			case 1:
-				// Grammars\\AssignTokenTypesWalker.g3:154:4: cmt= DOC_COMMENT
-				{
-				cmt=(GrammarAST)Match(input,DOC_COMMENT,Follow._DOC_COMMENT_in_grammarSpec141);
-
-				}
-				break;
-
-			}
-
-			// Grammars\\AssignTokenTypesWalker.g3:155:3: ( optionsSpec )?
-			int alt3=2;
-			int LA3_0 = input.LA(1);
-
-			if ( (LA3_0==OPTIONS) )
-			{
-				alt3=1;
-			}
-			switch ( alt3 )
-			{
-			case 1:
-				// Grammars\\AssignTokenTypesWalker.g3:155:4: optionsSpec
-				{
-				PushFollow(Follow._optionsSpec_in_grammarSpec148);
-				optionsSpec();
-
-				state._fsp--;
-
-
-				}
-				break;
-
-			}
-
-			// Grammars\\AssignTokenTypesWalker.g3:156:3: ( delegateGrammars )?
-			int alt4=2;
-			int LA4_0 = input.LA(1);
-
-			if ( (LA4_0==IMPORT) )
-			{
-				alt4=1;
-			}
-			switch ( alt4 )
-			{
-			case 1:
-				// Grammars\\AssignTokenTypesWalker.g3:156:4: delegateGrammars
-				{
-				PushFollow(Follow._delegateGrammars_in_grammarSpec155);
-				delegateGrammars();
-
-				state._fsp--;
-
-
-				}
-				break;
-
-			}
-
-			// Grammars\\AssignTokenTypesWalker.g3:157:3: ( tokensSpec )?
-			int alt5=2;
-			int LA5_0 = input.LA(1);
-
-			if ( (LA5_0==TOKENS) )
-			{
-				alt5=1;
-			}
-			switch ( alt5 )
-			{
-			case 1:
-				// Grammars\\AssignTokenTypesWalker.g3:157:4: tokensSpec
-				{
-				PushFollow(Follow._tokensSpec_in_grammarSpec162);
-				tokensSpec();
-
-				state._fsp--;
-
-
-				}
-				break;
-
-			}
-
-			// Grammars\\AssignTokenTypesWalker.g3:158:3: ( attrScope )*
-			for ( ; ; )
-			{
-				int alt6=2;
-				int LA6_0 = input.LA(1);
-
-				if ( (LA6_0==SCOPE) )
-				{
-					alt6=1;
-				}
-
-
-				switch ( alt6 )
-				{
-				case 1:
-					// Grammars\\AssignTokenTypesWalker.g3:158:4: attrScope
-					{
-					PushFollow(Follow._attrScope_in_grammarSpec169);
-					attrScope();
-
-					state._fsp--;
-
-
-					}
-					break;
-
-				default:
-					goto loop6;
-				}
-			}
-
-			loop6:
-				;
-
-
-			// Grammars\\AssignTokenTypesWalker.g3:159:3: ( ^( AMPERSAND ( . )* ) )*
-			for ( ; ; )
-			{
-				int alt8=2;
-				int LA8_0 = input.LA(1);
-
-				if ( (LA8_0==AMPERSAND) )
-				{
-					alt8=1;
-				}
-
-
-				switch ( alt8 )
-				{
-				case 1:
-					// Grammars\\AssignTokenTypesWalker.g3:159:5: ^( AMPERSAND ( . )* )
-					{
-					Match(input,AMPERSAND,Follow._AMPERSAND_in_grammarSpec178);
-
-					if ( input.LA(1)==TokenTypes.Down )
-					{
-						Match(input, TokenTypes.Down, null);
-						// Grammars\\AssignTokenTypesWalker.g3:159:17: ( . )*
-						for ( ; ; )
-						{
-							int alt7=2;
-							int LA7_0 = input.LA(1);
-
-							if ( ((LA7_0>=ACTION && LA7_0<=CHARSET)) )
-							{
-								alt7=1;
-							}
-							else if ( (LA7_0==UP) )
-							{
-								alt7=2;
-							}
-
-
-							switch ( alt7 )
-							{
-							case 1:
-								// Grammars\\AssignTokenTypesWalker.g3:159:0: .
-								{
-								MatchAny(input);
-
-								}
-								break;
-
-							default:
-								goto loop7;
-							}
-						}
-
-						loop7:
-							;
-
-
-
-						Match(input, TokenTypes.Up, null);
-					}
-
-					}
-					break;
-
-				default:
-					goto loop8;
-				}
-			}
-
-			loop8:
-				;
-
-
-			PushFollow(Follow._rules_in_grammarSpec190);
-			rules();
-
-			state._fsp--;
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "grammarSpec"
-
-
-	// $ANTLR start "attrScope"
-	// Grammars\\AssignTokenTypesWalker.g3:163:0: attrScope : ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION ) ;
-	private void attrScope(  )
-	{
-		try
-		{
-			// Grammars\\AssignTokenTypesWalker.g3:164:4: ( ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION ) )
-			// Grammars\\AssignTokenTypesWalker.g3:164:4: ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION )
-			{
-			Match(input,SCOPE,Follow._SCOPE_in_attrScope203);
-
-			Match(input, TokenTypes.Down, null);
-			Match(input,ID,Follow._ID_in_attrScope205);
-			// Grammars\\AssignTokenTypesWalker.g3:164:18: ( ^( AMPERSAND ( . )* ) )*
-			for ( ; ; )
-			{
-				int alt10=2;
-				int LA10_0 = input.LA(1);
-
-				if ( (LA10_0==AMPERSAND) )
-				{
-					alt10=1;
-				}
-
-
-				switch ( alt10 )
-				{
-				case 1:
-					// Grammars\\AssignTokenTypesWalker.g3:164:20: ^( AMPERSAND ( . )* )
-					{
-					Match(input,AMPERSAND,Follow._AMPERSAND_in_attrScope210);
-
-					if ( input.LA(1)==TokenTypes.Down )
-					{
-						Match(input, TokenTypes.Down, null);
-						// Grammars\\AssignTokenTypesWalker.g3:164:32: ( . )*
-						for ( ; ; )
-						{
-							int alt9=2;
-							int LA9_0 = input.LA(1);
-
-							if ( ((LA9_0>=ACTION && LA9_0<=CHARSET)) )
-							{
-								alt9=1;
-							}
-							else if ( (LA9_0==UP) )
-							{
-								alt9=2;
-							}
-
-
-							switch ( alt9 )
-							{
-							case 1:
-								// Grammars\\AssignTokenTypesWalker.g3:164:0: .
-								{
-								MatchAny(input);
-
-								}
-								break;
-
-							default:
-								goto loop9;
-							}
-						}
-
-						loop9:
-							;
-
-
-
-						Match(input, TokenTypes.Up, null);
-					}
-
-					}
-					break;
-
-				default:
-					goto loop10;
-				}
-			}
-
-			loop10:
-				;
-
-
-			Match(input,ACTION,Follow._ACTION_in_attrScope219);
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "attrScope"
-
-
-	// $ANTLR start "optionsSpec"
-	// Grammars\\AssignTokenTypesWalker.g3:167:0: optionsSpec returns [Map opts=new HashMap()] : ^( OPTIONS ( option[$opts] )+ ) ;
-	private Map optionsSpec(  )
-	{
-		Map opts = new HashMap();
-
-		try
-		{
-			// Grammars\\AssignTokenTypesWalker.g3:168:4: ( ^( OPTIONS ( option[$opts] )+ ) )
-			// Grammars\\AssignTokenTypesWalker.g3:168:4: ^( OPTIONS ( option[$opts] )+ )
-			{
-			Match(input,OPTIONS,Follow._OPTIONS_in_optionsSpec238);
-
-			Match(input, TokenTypes.Down, null);
-			// Grammars\\AssignTokenTypesWalker.g3:168:15: ( option[$opts] )+
-			int cnt11=0;
-			for ( ; ; )
-			{
-				int alt11=2;
-				int LA11_0 = input.LA(1);
-
-				if ( (LA11_0==ASSIGN) )
-				{
-					alt11=1;
-				}
-
-
-				switch ( alt11 )
-				{
-				case 1:
-					// Grammars\\AssignTokenTypesWalker.g3:168:16: option[$opts]
-					{
-					PushFollow(Follow._option_in_optionsSpec241);
-					option(opts);
-
-					state._fsp--;
-
-
-					}
-					break;
-
-				default:
-					if ( cnt11 >= 1 )
-						goto loop11;
-
-					EarlyExitException eee11 = new EarlyExitException( 11, input );
-					throw eee11;
-				}
-				cnt11++;
-			}
-			loop11:
-				;
-
-
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return opts;
-	}
-	// $ANTLR end "optionsSpec"
-
-
-	// $ANTLR start "option"
-	// Grammars\\AssignTokenTypesWalker.g3:171:0: option[Map opts] : ^( ASSIGN ID optionValue ) ;
-	private void option( Map opts )
-	{
-		GrammarAST ID1=null;
-		AssignTokenTypesWalker.optionValue_return optionValue2 = default(AssignTokenTypesWalker.optionValue_return);
-
-		try
-		{
-			// Grammars\\AssignTokenTypesWalker.g3:172:4: ( ^( ASSIGN ID optionValue ) )
-			// Grammars\\AssignTokenTypesWalker.g3:172:4: ^( ASSIGN ID optionValue )
-			{
-			Match(input,ASSIGN,Follow._ASSIGN_in_option260);
-
-			Match(input, TokenTypes.Down, null);
-			ID1=(GrammarAST)Match(input,ID,Follow._ID_in_option262);
-			PushFollow(Follow._optionValue_in_option264);
-			optionValue2=optionValue();
-
-			state._fsp--;
-
-
-			Match(input, TokenTypes.Up, null);
-
-						string key = (ID1!=null?ID1.Text:null);
-						opts[key] = (optionValue2!=null?optionValue2.value:default(Object));
-						// check for grammar-level option to import vocabulary
-						if ( currentRuleName==null && key.Equals("tokenVocab") )
-						{
-							grammar.ImportTokenVocabulary(ID1,(string)(optionValue2!=null?optionValue2.value:default(Object)));
-						}
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "option"
-
-	public class optionValue_return : TreeRuleReturnScope
-	{
-		public Object value=null;
-	}
-
-	// $ANTLR start "optionValue"
-	// Grammars\\AssignTokenTypesWalker.g3:184:0: optionValue returns [Object value=null] : ( ID | STRING_LITERAL | CHAR_LITERAL | INT );
-	private AssignTokenTypesWalker.optionValue_return optionValue(  )
-	{
-		AssignTokenTypesWalker.optionValue_return retval = new AssignTokenTypesWalker.optionValue_return();
-		retval.start = input.LT(1);
-
-		GrammarAST INT3=null;
-
-
-			if ( state.backtracking == 0 )
-				retval.value = ((GrammarAST)retval.Start).Text;
-
-		try
-		{
-			// Grammars\\AssignTokenTypesWalker.g3:190:4: ( ID | STRING_LITERAL | CHAR_LITERAL | INT )
-			int alt12=4;
-			switch ( input.LA(1) )
-			{
-			case ID:
-				{
-				alt12=1;
-				}
-				break;
-			case STRING_LITERAL:
-				{
-				alt12=2;
-				}
-				break;
-			case CHAR_LITERAL:
-				{
-				alt12=3;
-				}
-				break;
-			case INT:
-				{
-				alt12=4;
-				}
-				break;
-			default:
-				{
-					NoViableAltException nvae = new NoViableAltException("", 12, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt12 )
-			{
-			case 1:
-				// Grammars\\AssignTokenTypesWalker.g3:190:4: ID
-				{
-				Match(input,ID,Follow._ID_in_optionValue290);
-
-				}
-				break;
-			case 2:
-				// Grammars\\AssignTokenTypesWalker.g3:191:4: STRING_LITERAL
-				{
-				Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_optionValue295);
-
-				}
-				break;
-			case 3:
-				// Grammars\\AssignTokenTypesWalker.g3:192:4: CHAR_LITERAL
-				{
-				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_optionValue300);
-
-				}
-				break;
-			case 4:
-				// Grammars\\AssignTokenTypesWalker.g3:193:4: INT
-				{
-				INT3=(GrammarAST)Match(input,INT,Follow._INT_in_optionValue305);
-				 retval.value = int.Parse( (INT3!=null?INT3.Text:null) );
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "optionValue"
-
-
-	// $ANTLR start "charSet"
-	// Grammars\\AssignTokenTypesWalker.g3:198:0: charSet : ^( CHARSET charSetElement ) ;
-	private void charSet(  )
-	{
-		try
-		{
-			// Grammars\\AssignTokenTypesWalker.g3:199:4: ( ^( CHARSET charSetElement ) )
-			// Grammars\\AssignTokenTypesWalker.g3:199:4: ^( CHARSET charSetElement )
-			{
-			Match(input,CHARSET,Follow._CHARSET_in_charSet323);
-
-			Match(input, TokenTypes.Down, null);
-			PushFollow(Follow._charSetElement_in_charSet325);
-			charSetElement();
-
-			state._fsp--;
-
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "charSet"
-
-
-	// $ANTLR start "charSetElement"
-	// Grammars\\AssignTokenTypesWalker.g3:202:0: charSetElement : ( CHAR_LITERAL | ^( OR CHAR_LITERAL CHAR_LITERAL ) | ^( RANGE CHAR_LITERAL CHAR_LITERAL ) );
-	private void charSetElement(  )
-	{
-		try
-		{
-			// Grammars\\AssignTokenTypesWalker.g3:203:4: ( CHAR_LITERAL | ^( OR CHAR_LITERAL CHAR_LITERAL ) | ^( RANGE CHAR_LITERAL CHAR_LITERAL ) )
-			int alt13=3;
-			switch ( input.LA(1) )
-			{
-			case CHAR_LITERAL:
-				{
-				alt13=1;
-				}
-				break;
-			case OR:
-				{
-				alt13=2;
-				}
-				break;
-			case RANGE:
-				{
-				alt13=3;
-				}
-				break;
-			default:
-				{
-					NoViableAltException nvae = new NoViableAltException("", 13, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt13 )
-			{
-			case 1:
-				// Grammars\\AssignTokenTypesWalker.g3:203:4: CHAR_LITERAL
-				{
-				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_charSetElement338);
-
-				}
-				break;
-			case 2:
-				// Grammars\\AssignTokenTypesWalker.g3:204:4: ^( OR CHAR_LITERAL CHAR_LITERAL )
-				{
-				Match(input,OR,Follow._OR_in_charSetElement345);
-
-				Match(input, TokenTypes.Down, null);
-				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_charSetElement347);
-				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_charSetElement349);
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 3:
-				// Grammars\\AssignTokenTypesWalker.g3:205:4: ^( RANGE CHAR_LITERAL CHAR_LITERAL )
-				{
-				Match(input,RANGE,Follow._RANGE_in_charSetElement358);
-
-				Match(input, TokenTypes.Down, null);
-				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_charSetElement360);
-				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_charSetElement362);
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "charSetElement"
-
-
-	// $ANTLR start "delegateGrammars"
-	// Grammars\\AssignTokenTypesWalker.g3:208:0: delegateGrammars : ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ ) ;
-	private void delegateGrammars(  )
-	{
-		try
-		{
-			// Grammars\\AssignTokenTypesWalker.g3:209:4: ( ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ ) )
-			// Grammars\\AssignTokenTypesWalker.g3:209:4: ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ )
-			{
-			Match(input,IMPORT,Follow._IMPORT_in_delegateGrammars377);
-
-			Match(input, TokenTypes.Down, null);
-			// Grammars\\AssignTokenTypesWalker.g3:210:4: ( ^( ASSIGN ID ID ) | ID )+
-			int cnt14=0;
-			for ( ; ; )
-			{
-				int alt14=3;
-				int LA14_0 = input.LA(1);
-
-				if ( (LA14_0==ASSIGN) )
-				{
-					alt14=1;
-				}
-				else if ( (LA14_0==ID) )
-				{
-					alt14=2;
-				}
-
-
-				switch ( alt14 )
-				{
-				case 1:
-					// Grammars\\AssignTokenTypesWalker.g3:210:6: ^( ASSIGN ID ID )
-					{
-					Match(input,ASSIGN,Follow._ASSIGN_in_delegateGrammars385);
-
-					Match(input, TokenTypes.Down, null);
-					Match(input,ID,Follow._ID_in_delegateGrammars387);
-					Match(input,ID,Follow._ID_in_delegateGrammars389);
-
-					Match(input, TokenTypes.Up, null);
-
-					}
-					break;
-				case 2:
-					// Grammars\\AssignTokenTypesWalker.g3:211:6: ID
-					{
-					Match(input,ID,Follow._ID_in_delegateGrammars397);
-
-					}
-					break;
-
-				default:
-					if ( cnt14 >= 1 )
-						goto loop14;
-
-					EarlyExitException eee14 = new EarlyExitException( 14, input );
-					throw eee14;
-				}
-				cnt14++;
-			}
-			loop14:
-				;
-
-
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "delegateGrammars"
-
-
-	// $ANTLR start "tokensSpec"
-	// Grammars\\AssignTokenTypesWalker.g3:216:0: tokensSpec : ^( TOKENS ( tokenSpec )+ ) ;
-	private void tokensSpec(  )
-	{
-		try
-		{
-			// Grammars\\AssignTokenTypesWalker.g3:217:4: ( ^( TOKENS ( tokenSpec )+ ) )
-			// Grammars\\AssignTokenTypesWalker.g3:217:4: ^( TOKENS ( tokenSpec )+ )
-			{
-			Match(input,TOKENS,Follow._TOKENS_in_tokensSpec420);
-
-			Match(input, TokenTypes.Down, null);
-			// Grammars\\AssignTokenTypesWalker.g3:217:14: ( tokenSpec )+
-			int cnt15=0;
-			for ( ; ; )
-			{
-				int alt15=2;
-				int LA15_0 = input.LA(1);
-
-				if ( (LA15_0==ASSIGN||LA15_0==TOKEN_REF) )
-				{
-					alt15=1;
-				}
-
-
-				switch ( alt15 )
-				{
-				case 1:
-					// Grammars\\AssignTokenTypesWalker.g3:217:0: tokenSpec
-					{
-					PushFollow(Follow._tokenSpec_in_tokensSpec422);
-					tokenSpec();
-
-					state._fsp--;
-
-
-					}
-					break;
-
-				default:
-					if ( cnt15 >= 1 )
-						goto loop15;
-
-					EarlyExitException eee15 = new EarlyExitException( 15, input );
-					throw eee15;
-				}
-				cnt15++;
-			}
-			loop15:
-				;
-
-
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "tokensSpec"
-
-
-	// $ANTLR start "tokenSpec"
-	// Grammars\\AssignTokenTypesWalker.g3:220:0: tokenSpec : (t= TOKEN_REF | ^( ASSIGN t2= TOKEN_REF (s= STRING_LITERAL |c= CHAR_LITERAL ) ) );
-	private void tokenSpec(  )
-	{
-		GrammarAST t=null;
-		GrammarAST t2=null;
-		GrammarAST s=null;
-		GrammarAST c=null;
-
-		try
-		{
-			// Grammars\\AssignTokenTypesWalker.g3:221:4: (t= TOKEN_REF | ^( ASSIGN t2= TOKEN_REF (s= STRING_LITERAL |c= CHAR_LITERAL ) ) )
-			int alt17=2;
-			int LA17_0 = input.LA(1);
-
-			if ( (LA17_0==TOKEN_REF) )
-			{
-				alt17=1;
-			}
-			else if ( (LA17_0==ASSIGN) )
-			{
-				alt17=2;
-			}
-			else
-			{
-				NoViableAltException nvae = new NoViableAltException("", 17, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt17 )
-			{
-			case 1:
-				// Grammars\\AssignTokenTypesWalker.g3:221:4: t= TOKEN_REF
-				{
-				t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_tokenSpec438);
-				TrackToken(t);
-
-				}
-				break;
-			case 2:
-				// Grammars\\AssignTokenTypesWalker.g3:222:4: ^( ASSIGN t2= TOKEN_REF (s= STRING_LITERAL |c= CHAR_LITERAL ) )
-				{
-				Match(input,ASSIGN,Follow._ASSIGN_in_tokenSpec458);
-
-				Match(input, TokenTypes.Down, null);
-				t2=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_tokenSpec465);
-				TrackToken(t2);
-				// Grammars\\AssignTokenTypesWalker.g3:224:4: (s= STRING_LITERAL |c= CHAR_LITERAL )
-				int alt16=2;
-				int LA16_0 = input.LA(1);
-
-				if ( (LA16_0==STRING_LITERAL) )
-				{
-					alt16=1;
-				}
-				else if ( (LA16_0==CHAR_LITERAL) )
-				{
-					alt16=2;
-				}
-				else
-				{
-					NoViableAltException nvae = new NoViableAltException("", 16, 0, input);
-
-					throw nvae;
-				}
-				switch ( alt16 )
-				{
-				case 1:
-					// Grammars\\AssignTokenTypesWalker.g3:224:6: s= STRING_LITERAL
-					{
-					s=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_tokenSpec482);
-					TrackString(s); Alias(t2,s);
-
-					}
-					break;
-				case 2:
-					// Grammars\\AssignTokenTypesWalker.g3:225:6: c= CHAR_LITERAL
-					{
-					c=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_tokenSpec493);
-					TrackString(c); Alias(t2,c);
-
-					}
-					break;
-
-				}
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "tokenSpec"
-
-
-	// $ANTLR start "rules"
-	// Grammars\\AssignTokenTypesWalker.g3:230:0: rules : ( rule )+ ;
-	private void rules(  )
-	{
-		try
-		{
-			// Grammars\\AssignTokenTypesWalker.g3:231:4: ( ( rule )+ )
-			// Grammars\\AssignTokenTypesWalker.g3:231:4: ( rule )+
-			{
-			// Grammars\\AssignTokenTypesWalker.g3:231:4: ( rule )+
-			int cnt18=0;
-			for ( ; ; )
-			{
-				int alt18=2;
-				int LA18_0 = input.LA(1);
-
-				if ( (LA18_0==RULE) )
-				{
-					alt18=1;
-				}
-
-
-				switch ( alt18 )
-				{
-				case 1:
-					// Grammars\\AssignTokenTypesWalker.g3:231:0: rule
-					{
-					PushFollow(Follow._rule_in_rules517);
-					rule();
-
-					state._fsp--;
-
-
-					}
-					break;
-
-				default:
-					if ( cnt18 >= 1 )
-						goto loop18;
-
-					EarlyExitException eee18 = new EarlyExitException( 18, input );
-					throw eee18;
-				}
-				cnt18++;
-			}
-			loop18:
-				;
-
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "rules"
-
-
-	// $ANTLR start "rule"
-	// Grammars\\AssignTokenTypesWalker.g3:234:0: rule : ^( RULE id= ID (m= modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block ( exceptionGroup )? EOR ) ;
-	private void rule(  )
-	{
-		GrammarAST id=null;
-		AssignTokenTypesWalker.modifier_return m = default(AssignTokenTypesWalker.modifier_return);
-		AssignTokenTypesWalker.block_return b = default(AssignTokenTypesWalker.block_return);
-
-		try
-		{
-			// Grammars\\AssignTokenTypesWalker.g3:235:4: ( ^( RULE id= ID (m= modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block ( exceptionGroup )? EOR ) )
-			// Grammars\\AssignTokenTypesWalker.g3:235:4: ^( RULE id= ID (m= modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block ( exceptionGroup )? EOR )
-			{
-			Match(input,RULE,Follow._RULE_in_rule531);
-
-			Match(input, TokenTypes.Down, null);
-			id=(GrammarAST)Match(input,ID,Follow._ID_in_rule535);
-			currentRuleName=(id!=null?id.Text:null);
-			// Grammars\\AssignTokenTypesWalker.g3:236:4: (m= modifier )?
-			int alt19=2;
-			int LA19_0 = input.LA(1);
-
-			if ( (LA19_0==FRAGMENT||(LA19_0>=PRIVATE && LA19_0<=PUBLIC)) )
-			{
-				alt19=1;
-			}
-			switch ( alt19 )
-			{
-			case 1:
-				// Grammars\\AssignTokenTypesWalker.g3:236:5: m= modifier
-				{
-				PushFollow(Follow._modifier_in_rule545);
-				m=modifier();
-
-				state._fsp--;
-
-
-				}
-				break;
-
-			}
-
-			Match(input,ARG,Follow._ARG_in_rule553);
-
-			if ( input.LA(1)==TokenTypes.Down )
-			{
-				Match(input, TokenTypes.Down, null);
-				// Grammars\\AssignTokenTypesWalker.g3:237:10: ( ARG_ACTION )?
-				int alt20=2;
-				int LA20_0 = input.LA(1);
-
-				if ( (LA20_0==ARG_ACTION) )
-				{
-					alt20=1;
-				}
-				switch ( alt20 )
-				{
-				case 1:
-					// Grammars\\AssignTokenTypesWalker.g3:237:11: ARG_ACTION
-					{
-					Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule556);
-
-					}
-					break;
-
-				}
-
-
-				Match(input, TokenTypes.Up, null);
-			}
-			Match(input,RET,Follow._RET_in_rule565);
-
-			if ( input.LA(1)==TokenTypes.Down )
-			{
-				Match(input, TokenTypes.Down, null);
-				// Grammars\\AssignTokenTypesWalker.g3:238:10: ( ARG_ACTION )?
-				int alt21=2;
-				int LA21_0 = input.LA(1);
-
-				if ( (LA21_0==ARG_ACTION) )
-				{
-					alt21=1;
-				}
-				switch ( alt21 )
-				{
-				case 1:
-					// Grammars\\AssignTokenTypesWalker.g3:238:11: ARG_ACTION
-					{
-					Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule568);
-
-					}
-					break;
-
-				}
-
-
-				Match(input, TokenTypes.Up, null);
-			}
-			// Grammars\\AssignTokenTypesWalker.g3:239:4: ( throwsSpec )?
-			int alt22=2;
-			int LA22_0 = input.LA(1);
-
-			if ( (LA22_0==THROWS) )
-			{
-				alt22=1;
-			}
-			switch ( alt22 )
-			{
-			case 1:
-				// Grammars\\AssignTokenTypesWalker.g3:239:5: throwsSpec
-				{
-				PushFollow(Follow._throwsSpec_in_rule577);
-				throwsSpec();
-
-				state._fsp--;
-
-
-				}
-				break;
-
-			}
-
-			// Grammars\\AssignTokenTypesWalker.g3:240:4: ( optionsSpec )?
-			int alt23=2;
-			int LA23_0 = input.LA(1);
-
-			if ( (LA23_0==OPTIONS) )
-			{
-				alt23=1;
-			}
-			switch ( alt23 )
-			{
-			case 1:
-				// Grammars\\AssignTokenTypesWalker.g3:240:5: optionsSpec
-				{
-				PushFollow(Follow._optionsSpec_in_rule585);
-				optionsSpec();
-
-				state._fsp--;
-
-
-				}
-				break;
-
-			}
-
-			// Grammars\\AssignTokenTypesWalker.g3:241:4: ( ruleScopeSpec )?
-			int alt24=2;
-			int LA24_0 = input.LA(1);
-
-			if ( (LA24_0==SCOPE) )
-			{
-				alt24=1;
-			}
-			switch ( alt24 )
-			{
-			case 1:
-				// Grammars\\AssignTokenTypesWalker.g3:241:5: ruleScopeSpec
-				{
-				PushFollow(Follow._ruleScopeSpec_in_rule593);
-				ruleScopeSpec();
-
-				state._fsp--;
-
-
-				}
-				break;
-
-			}
-
-			// Grammars\\AssignTokenTypesWalker.g3:242:4: ( ^( AMPERSAND ( . )* ) )*
-			for ( ; ; )
-			{
-				int alt26=2;
-				int LA26_0 = input.LA(1);
-
-				if ( (LA26_0==AMPERSAND) )
-				{
-					alt26=1;
-				}
-
-
-				switch ( alt26 )
-				{
-				case 1:
-					// Grammars\\AssignTokenTypesWalker.g3:242:6: ^( AMPERSAND ( . )* )
-					{
-					Match(input,AMPERSAND,Follow._AMPERSAND_in_rule603);
-
-					if ( input.LA(1)==TokenTypes.Down )
-					{
-						Match(input, TokenTypes.Down, null);
-						// Grammars\\AssignTokenTypesWalker.g3:242:18: ( . )*
-						for ( ; ; )
-						{
-							int alt25=2;
-							int LA25_0 = input.LA(1);
-
-							if ( ((LA25_0>=ACTION && LA25_0<=CHARSET)) )
-							{
-								alt25=1;
-							}
-							else if ( (LA25_0==UP) )
-							{
-								alt25=2;
-							}
-
-
-							switch ( alt25 )
-							{
-							case 1:
-								// Grammars\\AssignTokenTypesWalker.g3:242:0: .
-								{
-								MatchAny(input);
-
-								}
-								break;
-
-							default:
-								goto loop25;
-							}
-						}
-
-						loop25:
-							;
-
-
-
-						Match(input, TokenTypes.Up, null);
-					}
-
-					}
-					break;
-
-				default:
-					goto loop26;
-				}
-			}
-
-			loop26:
-				;
-
-
-			PushFollow(Follow._block_in_rule617);
-			b=block();
-
-			state._fsp--;
-
-			// Grammars\\AssignTokenTypesWalker.g3:244:4: ( exceptionGroup )?
-			int alt27=2;
-			int LA27_0 = input.LA(1);
-
-			if ( (LA27_0==CATCH||LA27_0==FINALLY) )
-			{
-				alt27=1;
-			}
-			switch ( alt27 )
-			{
-			case 1:
-				// Grammars\\AssignTokenTypesWalker.g3:244:5: exceptionGroup
-				{
-				PushFollow(Follow._exceptionGroup_in_rule623);
-				exceptionGroup();
-
-				state._fsp--;
-
-
-				}
-				break;
-
-			}
-
-			Match(input,EOR,Follow._EOR_in_rule630);
-			TrackTokenRule(id,(m!=null?((GrammarAST)m.Start):null),(b!=null?((GrammarAST)b.Start):null));
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "rule"
-
-	public class modifier_return : TreeRuleReturnScope
-	{
-	}
-
-	// $ANTLR start "modifier"
-	// Grammars\\AssignTokenTypesWalker.g3:250:0: modifier : ( 'protected' | 'public' | 'private' | 'fragment' );
-	private AssignTokenTypesWalker.modifier_return modifier(  )
-	{
-		AssignTokenTypesWalker.modifier_return retval = new AssignTokenTypesWalker.modifier_return();
-		retval.start = input.LT(1);
-
-		try
-		{
-			// Grammars\\AssignTokenTypesWalker.g3:251:4: ( 'protected' | 'public' | 'private' | 'fragment' )
-			// Grammars\\AssignTokenTypesWalker.g3:
-			{
-			if ( input.LA(1)==FRAGMENT||(input.LA(1)>=PRIVATE && input.LA(1)<=PUBLIC) )
-			{
-				input.Consume();
-				state.errorRecovery=false;
-			}
-			else
-			{
-				MismatchedSetException mse = new MismatchedSetException(null,input);
-				throw mse;
-			}
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "modifier"
-
-
-	// $ANTLR start "throwsSpec"
-	// Grammars\\AssignTokenTypesWalker.g3:257:0: throwsSpec : ^( 'throws' ( ID )+ ) ;
-	private void throwsSpec(  )
-	{
-		try
-		{
-			// Grammars\\AssignTokenTypesWalker.g3:258:4: ( ^( 'throws' ( ID )+ ) )
-			// Grammars\\AssignTokenTypesWalker.g3:258:4: ^( 'throws' ( ID )+ )
-			{
-			Match(input,THROWS,Follow._THROWS_in_throwsSpec677);
-
-			Match(input, TokenTypes.Down, null);
-			// Grammars\\AssignTokenTypesWalker.g3:258:15: ( ID )+
-			int cnt28=0;
-			for ( ; ; )
-			{
-				int alt28=2;
-				int LA28_0 = input.LA(1);
-
-				if ( (LA28_0==ID) )
-				{
-					alt28=1;
-				}
-
-
-				switch ( alt28 )
-				{
-				case 1:
-					// Grammars\\AssignTokenTypesWalker.g3:258:0: ID
-					{
-					Match(input,ID,Follow._ID_in_throwsSpec679);
-
-					}
-					break;
-
-				default:
-					if ( cnt28 >= 1 )
-						goto loop28;
-
-					EarlyExitException eee28 = new EarlyExitException( 28, input );
-					throw eee28;
-				}
-				cnt28++;
-			}
-			loop28:
-				;
-
-
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "throwsSpec"
-
-
-	// $ANTLR start "ruleScopeSpec"
-	// Grammars\\AssignTokenTypesWalker.g3:261:0: ruleScopeSpec : ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* ) ;
-	private void ruleScopeSpec(  )
-	{
-		try
-		{
-			// Grammars\\AssignTokenTypesWalker.g3:262:4: ( ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* ) )
-			// Grammars\\AssignTokenTypesWalker.g3:262:4: ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* )
-			{
-			Match(input,SCOPE,Follow._SCOPE_in_ruleScopeSpec694);
-
-			if ( input.LA(1)==TokenTypes.Down )
-			{
-				Match(input, TokenTypes.Down, null);
-				// Grammars\\AssignTokenTypesWalker.g3:262:15: ( ^( AMPERSAND ( . )* ) )*
-				for ( ; ; )
-				{
-					int alt30=2;
-					int LA30_0 = input.LA(1);
-
-					if ( (LA30_0==AMPERSAND) )
-					{
-						alt30=1;
-					}
-
-
-					switch ( alt30 )
-					{
-					case 1:
-						// Grammars\\AssignTokenTypesWalker.g3:262:17: ^( AMPERSAND ( . )* )
-						{
-						Match(input,AMPERSAND,Follow._AMPERSAND_in_ruleScopeSpec699);
-
-						if ( input.LA(1)==TokenTypes.Down )
-						{
-							Match(input, TokenTypes.Down, null);
-							// Grammars\\AssignTokenTypesWalker.g3:262:29: ( . )*
-							for ( ; ; )
-							{
-								int alt29=2;
-								int LA29_0 = input.LA(1);
-
-								if ( ((LA29_0>=ACTION && LA29_0<=CHARSET)) )
-								{
-									alt29=1;
-								}
-								else if ( (LA29_0==UP) )
-								{
-									alt29=2;
-								}
-
-
-								switch ( alt29 )
-								{
-								case 1:
-									// Grammars\\AssignTokenTypesWalker.g3:262:0: .
-									{
-									MatchAny(input);
-
-									}
-									break;
-
-								default:
-									goto loop29;
-								}
-							}
-
-							loop29:
-								;
-
-
-
-							Match(input, TokenTypes.Up, null);
-						}
-
-						}
-						break;
-
-					default:
-						goto loop30;
-					}
-				}
-
-				loop30:
-					;
-
-
-				// Grammars\\AssignTokenTypesWalker.g3:262:36: ( ACTION )?
-				int alt31=2;
-				int LA31_0 = input.LA(1);
-
-				if ( (LA31_0==ACTION) )
-				{
-					alt31=1;
-				}
-				switch ( alt31 )
-				{
-				case 1:
-					// Grammars\\AssignTokenTypesWalker.g3:262:37: ACTION
-					{
-					Match(input,ACTION,Follow._ACTION_in_ruleScopeSpec709);
-
-					}
-					break;
-
-				}
-
-				// Grammars\\AssignTokenTypesWalker.g3:262:46: ( ID )*
-				for ( ; ; )
-				{
-					int alt32=2;
-					int LA32_0 = input.LA(1);
-
-					if ( (LA32_0==ID) )
-					{
-						alt32=1;
-					}
-
-
-					switch ( alt32 )
-					{
-					case 1:
-						// Grammars\\AssignTokenTypesWalker.g3:262:48: ID
-						{
-						Match(input,ID,Follow._ID_in_ruleScopeSpec715);
-
-						}
-						break;
-
-					default:
-						goto loop32;
-					}
-				}
-
-				loop32:
-					;
-
-
-
-				Match(input, TokenTypes.Up, null);
-			}
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "ruleScopeSpec"
-
-	public class block_return : TreeRuleReturnScope
-	{
-	}
-
-	// $ANTLR start "block"
-	// Grammars\\AssignTokenTypesWalker.g3:265:0: block : ^( BLOCK ( optionsSpec )? ( alternative rewrite )+ EOB ) ;
-	private AssignTokenTypesWalker.block_return block(  )
-	{
-		AssignTokenTypesWalker.block_return retval = new AssignTokenTypesWalker.block_return();
-		retval.start = input.LT(1);
-
-		try
-		{
-			// Grammars\\AssignTokenTypesWalker.g3:266:4: ( ^( BLOCK ( optionsSpec )? ( alternative rewrite )+ EOB ) )
-			// Grammars\\AssignTokenTypesWalker.g3:266:4: ^( BLOCK ( optionsSpec )? ( alternative rewrite )+ EOB )
-			{
-			Match(input,BLOCK,Follow._BLOCK_in_block733);
-
-			Match(input, TokenTypes.Down, null);
-			// Grammars\\AssignTokenTypesWalker.g3:267:4: ( optionsSpec )?
-			int alt33=2;
-			int LA33_0 = input.LA(1);
-
-			if ( (LA33_0==OPTIONS) )
-			{
-				alt33=1;
-			}
-			switch ( alt33 )
-			{
-			case 1:
-				// Grammars\\AssignTokenTypesWalker.g3:267:5: optionsSpec
-				{
-				PushFollow(Follow._optionsSpec_in_block739);
-				optionsSpec();
-
-				state._fsp--;
-
-
-				}
-				break;
-
-			}
-
-			// Grammars\\AssignTokenTypesWalker.g3:268:4: ( alternative rewrite )+
-			int cnt34=0;
-			for ( ; ; )
-			{
-				int alt34=2;
-				int LA34_0 = input.LA(1);
-
-				if ( (LA34_0==ALT) )
-				{
-					alt34=1;
-				}
-
-
-				switch ( alt34 )
-				{
-				case 1:
-					// Grammars\\AssignTokenTypesWalker.g3:268:6: alternative rewrite
-					{
-					PushFollow(Follow._alternative_in_block748);
-					alternative();
-
-					state._fsp--;
-
-					PushFollow(Follow._rewrite_in_block750);
-					rewrite();
-
-					state._fsp--;
-
-
-					}
-					break;
-
-				default:
-					if ( cnt34 >= 1 )
-						goto loop34;
-
-					EarlyExitException eee34 = new EarlyExitException( 34, input );
-					throw eee34;
-				}
-				cnt34++;
-			}
-			loop34:
-				;
-
-
-			Match(input,EOB,Follow._EOB_in_block758);
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "block"
-
-
-	// $ANTLR start "alternative"
-	// Grammars\\AssignTokenTypesWalker.g3:273:0: alternative : ^( ALT ( element )+ EOA ) ;
-	private void alternative(  )
-	{
-		try
-		{
-			// Grammars\\AssignTokenTypesWalker.g3:274:4: ( ^( ALT ( element )+ EOA ) )
-			// Grammars\\AssignTokenTypesWalker.g3:274:4: ^( ALT ( element )+ EOA )
-			{
-			Match(input,ALT,Follow._ALT_in_alternative775);
-
-			Match(input, TokenTypes.Down, null);
-			// Grammars\\AssignTokenTypesWalker.g3:274:11: ( element )+
-			int cnt35=0;
-			for ( ; ; )
-			{
-				int alt35=2;
-				int LA35_0 = input.LA(1);
-
-				if ( (LA35_0==ACTION||(LA35_0>=ASSIGN && LA35_0<=BLOCK)||(LA35_0>=CHAR_LITERAL && LA35_0<=CHAR_RANGE)||LA35_0==CLOSURE||LA35_0==DOT||LA35_0==EPSILON||LA35_0==FORCED_ACTION||LA35_0==GATED_SEMPRED||LA35_0==NOT||LA35_0==OPTIONAL||(LA35_0>=PLUS_ASSIGN && LA35_0<=POSITIVE_CLOSURE)||LA35_0==RANGE||LA35_0==ROOT||LA35_0==RULE_REF||LA35_0==SEMPRED||(LA35_0>=STRING_LITERAL && LA35_0<=SYNPRED)||LA35_0==TOKEN_REF||LA35_0==TREE_BEGIN||LA35_0==WILDCARD) )
-				{
-					alt35=1;
-				}
-
-
-				switch ( alt35 )
-				{
-				case 1:
-					// Grammars\\AssignTokenTypesWalker.g3:274:12: element
-					{
-					PushFollow(Follow._element_in_alternative778);
-					element();
-
-					state._fsp--;
-
-
-					}
-					break;
-
-				default:
-					if ( cnt35 >= 1 )
-						goto loop35;
-
-					EarlyExitException eee35 = new EarlyExitException( 35, input );
-					throw eee35;
-				}
-				cnt35++;
-			}
-			loop35:
-				;
-
-
-			Match(input,EOA,Follow._EOA_in_alternative782);
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "alternative"
-
-
-	// $ANTLR start "exceptionGroup"
-	// Grammars\\AssignTokenTypesWalker.g3:277:0: exceptionGroup : ( ( exceptionHandler )+ ( finallyClause )? | finallyClause );
-	private void exceptionGroup(  )
-	{
-		try
-		{
-			// Grammars\\AssignTokenTypesWalker.g3:278:4: ( ( exceptionHandler )+ ( finallyClause )? | finallyClause )
-			int alt38=2;
-			int LA38_0 = input.LA(1);
-
-			if ( (LA38_0==CATCH) )
-			{
-				alt38=1;
-			}
-			else if ( (LA38_0==FINALLY) )
-			{
-				alt38=2;
-			}
-			else
-			{
-				NoViableAltException nvae = new NoViableAltException("", 38, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt38 )
-			{
-			case 1:
-				// Grammars\\AssignTokenTypesWalker.g3:278:4: ( exceptionHandler )+ ( finallyClause )?
-				{
-				// Grammars\\AssignTokenTypesWalker.g3:278:4: ( exceptionHandler )+
-				int cnt36=0;
-				for ( ; ; )
-				{
-					int alt36=2;
-					int LA36_0 = input.LA(1);
-
-					if ( (LA36_0==CATCH) )
-					{
-						alt36=1;
-					}
-
-
-					switch ( alt36 )
-					{
-					case 1:
-						// Grammars\\AssignTokenTypesWalker.g3:278:6: exceptionHandler
-						{
-						PushFollow(Follow._exceptionHandler_in_exceptionGroup797);
-						exceptionHandler();
-
-						state._fsp--;
-
-
-						}
-						break;
-
-					default:
-						if ( cnt36 >= 1 )
-							goto loop36;
-
-						EarlyExitException eee36 = new EarlyExitException( 36, input );
-						throw eee36;
-					}
-					cnt36++;
-				}
-				loop36:
-					;
-
-
-				// Grammars\\AssignTokenTypesWalker.g3:278:26: ( finallyClause )?
-				int alt37=2;
-				int LA37_0 = input.LA(1);
-
-				if ( (LA37_0==FINALLY) )
-				{
-					alt37=1;
-				}
-				switch ( alt37 )
-				{
-				case 1:
-					// Grammars\\AssignTokenTypesWalker.g3:278:27: finallyClause
-					{
-					PushFollow(Follow._finallyClause_in_exceptionGroup803);
-					finallyClause();
-
-					state._fsp--;
-
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-			case 2:
-				// Grammars\\AssignTokenTypesWalker.g3:279:4: finallyClause
-				{
-				PushFollow(Follow._finallyClause_in_exceptionGroup810);
-				finallyClause();
-
-				state._fsp--;
-
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "exceptionGroup"
-
-
-	// $ANTLR start "exceptionHandler"
-	// Grammars\\AssignTokenTypesWalker.g3:282:0: exceptionHandler : ^( 'catch' ARG_ACTION ACTION ) ;
-	private void exceptionHandler(  )
-	{
-		try
-		{
-			// Grammars\\AssignTokenTypesWalker.g3:283:4: ( ^( 'catch' ARG_ACTION ACTION ) )
-			// Grammars\\AssignTokenTypesWalker.g3:283:4: ^( 'catch' ARG_ACTION ACTION )
-			{
-			Match(input,CATCH,Follow._CATCH_in_exceptionHandler822);
-
-			Match(input, TokenTypes.Down, null);
-			Match(input,ARG_ACTION,Follow._ARG_ACTION_in_exceptionHandler824);
-			Match(input,ACTION,Follow._ACTION_in_exceptionHandler826);
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "exceptionHandler"
-
-
-	// $ANTLR start "finallyClause"
-	// Grammars\\AssignTokenTypesWalker.g3:286:0: finallyClause : ^( 'finally' ACTION ) ;
-	private void finallyClause(  )
-	{
-		try
-		{
-			// Grammars\\AssignTokenTypesWalker.g3:287:4: ( ^( 'finally' ACTION ) )
-			// Grammars\\AssignTokenTypesWalker.g3:287:4: ^( 'finally' ACTION )
-			{
-			Match(input,FINALLY,Follow._FINALLY_in_finallyClause839);
-
-			Match(input, TokenTypes.Down, null);
-			Match(input,ACTION,Follow._ACTION_in_finallyClause841);
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "finallyClause"
-
-
-	// $ANTLR start "rewrite"
-	// Grammars\\AssignTokenTypesWalker.g3:290:0: rewrite : ( ^( REWRITE ( . )* ) )* ;
-	private void rewrite(  )
-	{
-		try
-		{
-			// Grammars\\AssignTokenTypesWalker.g3:291:4: ( ( ^( REWRITE ( . )* ) )* )
-			// Grammars\\AssignTokenTypesWalker.g3:291:4: ( ^( REWRITE ( . )* ) )*
-			{
-			// Grammars\\AssignTokenTypesWalker.g3:291:4: ( ^( REWRITE ( . )* ) )*
-			for ( ; ; )
-			{
-				int alt40=2;
-				int LA40_0 = input.LA(1);
-
-				if ( (LA40_0==REWRITE) )
-				{
-					alt40=1;
-				}
-
-
-				switch ( alt40 )
-				{
-				case 1:
-					// Grammars\\AssignTokenTypesWalker.g3:291:6: ^( REWRITE ( . )* )
-					{
-					Match(input,REWRITE,Follow._REWRITE_in_rewrite856);
-
-					if ( input.LA(1)==TokenTypes.Down )
-					{
-						Match(input, TokenTypes.Down, null);
-						// Grammars\\AssignTokenTypesWalker.g3:291:16: ( . )*
-						for ( ; ; )
-						{
-							int alt39=2;
-							int LA39_0 = input.LA(1);
-
-							if ( ((LA39_0>=ACTION && LA39_0<=CHARSET)) )
-							{
-								alt39=1;
-							}
-							else if ( (LA39_0==UP) )
-							{
-								alt39=2;
-							}
-
-
-							switch ( alt39 )
-							{
-							case 1:
-								// Grammars\\AssignTokenTypesWalker.g3:291:0: .
-								{
-								MatchAny(input);
-
-								}
-								break;
-
-							default:
-								goto loop39;
-							}
-						}
-
-						loop39:
-							;
-
-
-
-						Match(input, TokenTypes.Up, null);
-					}
-
-					}
-					break;
-
-				default:
-					goto loop40;
-				}
-			}
-
-			loop40:
-				;
-
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "rewrite"
-
-
-	// $ANTLR start "element"
-	// Grammars\\AssignTokenTypesWalker.g3:294:0: element : ( ^( ROOT element ) | ^( BANG element ) | atom | ^( NOT element ) | ^( RANGE atom atom ) | ^( CHAR_RANGE atom atom ) | ^( ASSIGN ID element ) | ^( PLUS_ASSIGN ID element ) | ebnf | tree_ | ^( SYNPRED block ) | FORCED_ACTION | ACTION | SEMPRED | SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) | GATED_SEMPRED | EPSILON );
-	private void element(  )
-	{
-		try
-		{
-			// Grammars\\AssignTokenTypesWalker.g3:295:4: ( ^( ROOT element ) | ^( BANG element ) | atom | ^( NOT element ) | ^( RANGE atom atom ) | ^( CHAR_RANGE atom atom ) | ^( ASSIGN ID element ) | ^( PLUS_ASSIGN ID element ) | ebnf | tree_ | ^( SYNPRED block ) | FORCED_ACTION | ACTION | SEMPRED | SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) | GATED_SEMPRED | EPSILON )
-			int alt42=18;
-			switch ( input.LA(1) )
-			{
-			case ROOT:
-				{
-				alt42=1;
-				}
-				break;
-			case BANG:
-				{
-				alt42=2;
-				}
-				break;
-			case CHAR_LITERAL:
-			case DOT:
-			case RULE_REF:
-			case STRING_LITERAL:
-			case TOKEN_REF:
-			case WILDCARD:
-				{
-				alt42=3;
-				}
-				break;
-			case NOT:
-				{
-				alt42=4;
-				}
-				break;
-			case RANGE:
-				{
-				alt42=5;
-				}
-				break;
-			case CHAR_RANGE:
-				{
-				alt42=6;
-				}
-				break;
-			case ASSIGN:
-				{
-				alt42=7;
-				}
-				break;
-			case PLUS_ASSIGN:
-				{
-				alt42=8;
-				}
-				break;
-			case BLOCK:
-			case CLOSURE:
-			case OPTIONAL:
-			case POSITIVE_CLOSURE:
-				{
-				alt42=9;
-				}
-				break;
-			case TREE_BEGIN:
-				{
-				alt42=10;
-				}
-				break;
-			case SYNPRED:
-				{
-				alt42=11;
-				}
-				break;
-			case FORCED_ACTION:
-				{
-				alt42=12;
-				}
-				break;
-			case ACTION:
-				{
-				alt42=13;
-				}
-				break;
-			case SEMPRED:
-				{
-				alt42=14;
-				}
-				break;
-			case SYN_SEMPRED:
-				{
-				alt42=15;
-				}
-				break;
-			case BACKTRACK_SEMPRED:
-				{
-				alt42=16;
-				}
-				break;
-			case GATED_SEMPRED:
-				{
-				alt42=17;
-				}
-				break;
-			case EPSILON:
-				{
-				alt42=18;
-				}
-				break;
-			default:
-				{
-					NoViableAltException nvae = new NoViableAltException("", 42, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt42 )
-			{
-			case 1:
-				// Grammars\\AssignTokenTypesWalker.g3:295:4: ^( ROOT element )
-				{
-				Match(input,ROOT,Follow._ROOT_in_element875);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._element_in_element877);
-				element();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 2:
-				// Grammars\\AssignTokenTypesWalker.g3:296:4: ^( BANG element )
-				{
-				Match(input,BANG,Follow._BANG_in_element884);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._element_in_element886);
-				element();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 3:
-				// Grammars\\AssignTokenTypesWalker.g3:297:4: atom
-				{
-				PushFollow(Follow._atom_in_element892);
-				atom();
-
-				state._fsp--;
-
-
-				}
-				break;
-			case 4:
-				// Grammars\\AssignTokenTypesWalker.g3:298:4: ^( NOT element )
-				{
-				Match(input,NOT,Follow._NOT_in_element898);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._element_in_element900);
-				element();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 5:
-				// Grammars\\AssignTokenTypesWalker.g3:299:4: ^( RANGE atom atom )
-				{
-				Match(input,RANGE,Follow._RANGE_in_element907);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._atom_in_element909);
-				atom();
-
-				state._fsp--;
-
-				PushFollow(Follow._atom_in_element911);
-				atom();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 6:
-				// Grammars\\AssignTokenTypesWalker.g3:300:4: ^( CHAR_RANGE atom atom )
-				{
-				Match(input,CHAR_RANGE,Follow._CHAR_RANGE_in_element918);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._atom_in_element920);
-				atom();
-
-				state._fsp--;
-
-				PushFollow(Follow._atom_in_element922);
-				atom();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 7:
-				// Grammars\\AssignTokenTypesWalker.g3:301:4: ^( ASSIGN ID element )
-				{
-				Match(input,ASSIGN,Follow._ASSIGN_in_element929);
-
-				Match(input, TokenTypes.Down, null);
-				Match(input,ID,Follow._ID_in_element931);
-				PushFollow(Follow._element_in_element933);
-				element();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 8:
-				// Grammars\\AssignTokenTypesWalker.g3:302:4: ^( PLUS_ASSIGN ID element )
-				{
-				Match(input,PLUS_ASSIGN,Follow._PLUS_ASSIGN_in_element940);
-
-				Match(input, TokenTypes.Down, null);
-				Match(input,ID,Follow._ID_in_element942);
-				PushFollow(Follow._element_in_element944);
-				element();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 9:
-				// Grammars\\AssignTokenTypesWalker.g3:303:4: ebnf
-				{
-				PushFollow(Follow._ebnf_in_element950);
-				ebnf();
-
-				state._fsp--;
-
-
-				}
-				break;
-			case 10:
-				// Grammars\\AssignTokenTypesWalker.g3:304:4: tree_
-				{
-				PushFollow(Follow._tree__in_element955);
-				tree_();
-
-				state._fsp--;
-
-
-				}
-				break;
-			case 11:
-				// Grammars\\AssignTokenTypesWalker.g3:305:4: ^( SYNPRED block )
-				{
-				Match(input,SYNPRED,Follow._SYNPRED_in_element962);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._block_in_element964);
-				block();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 12:
-				// Grammars\\AssignTokenTypesWalker.g3:306:4: FORCED_ACTION
-				{
-				Match(input,FORCED_ACTION,Follow._FORCED_ACTION_in_element971);
-
-				}
-				break;
-			case 13:
-				// Grammars\\AssignTokenTypesWalker.g3:307:4: ACTION
-				{
-				Match(input,ACTION,Follow._ACTION_in_element976);
-
-				}
-				break;
-			case 14:
-				// Grammars\\AssignTokenTypesWalker.g3:308:4: SEMPRED
-				{
-				Match(input,SEMPRED,Follow._SEMPRED_in_element981);
-
-				}
-				break;
-			case 15:
-				// Grammars\\AssignTokenTypesWalker.g3:309:4: SYN_SEMPRED
-				{
-				Match(input,SYN_SEMPRED,Follow._SYN_SEMPRED_in_element986);
-
-				}
-				break;
-			case 16:
-				// Grammars\\AssignTokenTypesWalker.g3:310:4: ^( BACKTRACK_SEMPRED ( . )* )
-				{
-				Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_element992);
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null);
-					// Grammars\\AssignTokenTypesWalker.g3:310:24: ( . )*
-					for ( ; ; )
-					{
-						int alt41=2;
-						int LA41_0 = input.LA(1);
-
-						if ( ((LA41_0>=ACTION && LA41_0<=CHARSET)) )
-						{
-							alt41=1;
-						}
-						else if ( (LA41_0==UP) )
-						{
-							alt41=2;
-						}
-
-
-						switch ( alt41 )
-						{
-						case 1:
-							// Grammars\\AssignTokenTypesWalker.g3:310:0: .
-							{
-							MatchAny(input);
-
-							}
-							break;
-
-						default:
-							goto loop41;
-						}
-					}
-
-					loop41:
-						;
-
-
-
-					Match(input, TokenTypes.Up, null);
-				}
-
-				}
-				break;
-			case 17:
-				// Grammars\\AssignTokenTypesWalker.g3:311:4: GATED_SEMPRED
-				{
-				Match(input,GATED_SEMPRED,Follow._GATED_SEMPRED_in_element1001);
-
-				}
-				break;
-			case 18:
-				// Grammars\\AssignTokenTypesWalker.g3:312:4: EPSILON
-				{
-				Match(input,EPSILON,Follow._EPSILON_in_element1006);
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "element"
-
-
-	// $ANTLR start "ebnf"
-	// Grammars\\AssignTokenTypesWalker.g3:315:0: ebnf : ( block | ^( OPTIONAL block ) | ^( CLOSURE block ) | ^( POSITIVE_CLOSURE block ) );
-	private void ebnf(  )
-	{
-		try
-		{
-			// Grammars\\AssignTokenTypesWalker.g3:316:4: ( block | ^( OPTIONAL block ) | ^( CLOSURE block ) | ^( POSITIVE_CLOSURE block ) )
-			int alt43=4;
-			switch ( input.LA(1) )
-			{
-			case BLOCK:
-				{
-				alt43=1;
-				}
-				break;
-			case OPTIONAL:
-				{
-				alt43=2;
-				}
-				break;
-			case CLOSURE:
-				{
-				alt43=3;
-				}
-				break;
-			case POSITIVE_CLOSURE:
-				{
-				alt43=4;
-				}
-				break;
-			default:
-				{
-					NoViableAltException nvae = new NoViableAltException("", 43, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt43 )
-			{
-			case 1:
-				// Grammars\\AssignTokenTypesWalker.g3:316:4: block
-				{
-				PushFollow(Follow._block_in_ebnf1017);
-				block();
-
-				state._fsp--;
-
-
-				}
-				break;
-			case 2:
-				// Grammars\\AssignTokenTypesWalker.g3:317:4: ^( OPTIONAL block )
-				{
-				Match(input,OPTIONAL,Follow._OPTIONAL_in_ebnf1024);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._block_in_ebnf1026);
-				block();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 3:
-				// Grammars\\AssignTokenTypesWalker.g3:318:4: ^( CLOSURE block )
-				{
-				Match(input,CLOSURE,Follow._CLOSURE_in_ebnf1035);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._block_in_ebnf1037);
-				block();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-			case 4:
-				// Grammars\\AssignTokenTypesWalker.g3:319:4: ^( POSITIVE_CLOSURE block )
-				{
-				Match(input,POSITIVE_CLOSURE,Follow._POSITIVE_CLOSURE_in_ebnf1046);
-
-				Match(input, TokenTypes.Down, null);
-				PushFollow(Follow._block_in_ebnf1048);
-				block();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "ebnf"
-
-
-	// $ANTLR start "tree_"
-	// Grammars\\AssignTokenTypesWalker.g3:322:0: tree_ : ^( TREE_BEGIN ( element )+ ) ;
-	private void tree_(  )
-	{
-		try
-		{
-			// Grammars\\AssignTokenTypesWalker.g3:323:4: ( ^( TREE_BEGIN ( element )+ ) )
-			// Grammars\\AssignTokenTypesWalker.g3:323:4: ^( TREE_BEGIN ( element )+ )
-			{
-			Match(input,TREE_BEGIN,Follow._TREE_BEGIN_in_tree_1062);
-
-			Match(input, TokenTypes.Down, null);
-			// Grammars\\AssignTokenTypesWalker.g3:323:17: ( element )+
-			int cnt44=0;
-			for ( ; ; )
-			{
-				int alt44=2;
-				int LA44_0 = input.LA(1);
-
-				if ( (LA44_0==ACTION||(LA44_0>=ASSIGN && LA44_0<=BLOCK)||(LA44_0>=CHAR_LITERAL && LA44_0<=CHAR_RANGE)||LA44_0==CLOSURE||LA44_0==DOT||LA44_0==EPSILON||LA44_0==FORCED_ACTION||LA44_0==GATED_SEMPRED||LA44_0==NOT||LA44_0==OPTIONAL||(LA44_0>=PLUS_ASSIGN && LA44_0<=POSITIVE_CLOSURE)||LA44_0==RANGE||LA44_0==ROOT||LA44_0==RULE_REF||LA44_0==SEMPRED||(LA44_0>=STRING_LITERAL && LA44_0<=SYNPRED)||LA44_0==TOKEN_REF||LA44_0==TREE_BEGIN||LA44_0==WILDCARD) )
-				{
-					alt44=1;
-				}
-
-
-				switch ( alt44 )
-				{
-				case 1:
-					// Grammars\\AssignTokenTypesWalker.g3:323:0: element
-					{
-					PushFollow(Follow._element_in_tree_1064);
-					element();
-
-					state._fsp--;
-
-
-					}
-					break;
-
-				default:
-					if ( cnt44 >= 1 )
-						goto loop44;
-
-					EarlyExitException eee44 = new EarlyExitException( 44, input );
-					throw eee44;
-				}
-				cnt44++;
-			}
-			loop44:
-				;
-
-
-
-			Match(input, TokenTypes.Up, null);
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "tree_"
-
-
-	// $ANTLR start "atom"
-	// Grammars\\AssignTokenTypesWalker.g3:326:0: atom : ( ^( RULE_REF ( ARG_ACTION )? ) | ^(t= TOKEN_REF ( ARG_ACTION )? ) |c= CHAR_LITERAL |s= STRING_LITERAL | WILDCARD | ^( DOT ID atom ) );
-	private void atom(  )
-	{
-		GrammarAST t=null;
-		GrammarAST c=null;
-		GrammarAST s=null;
-
-		try
-		{
-			// Grammars\\AssignTokenTypesWalker.g3:327:4: ( ^( RULE_REF ( ARG_ACTION )? ) | ^(t= TOKEN_REF ( ARG_ACTION )? ) |c= CHAR_LITERAL |s= STRING_LITERAL | WILDCARD | ^( DOT ID atom ) )
-			int alt47=6;
-			switch ( input.LA(1) )
-			{
-			case RULE_REF:
-				{
-				alt47=1;
-				}
-				break;
-			case TOKEN_REF:
-				{
-				alt47=2;
-				}
-				break;
-			case CHAR_LITERAL:
-				{
-				alt47=3;
-				}
-				break;
-			case STRING_LITERAL:
-				{
-				alt47=4;
-				}
-				break;
-			case WILDCARD:
-				{
-				alt47=5;
-				}
-				break;
-			case DOT:
-				{
-				alt47=6;
-				}
-				break;
-			default:
-				{
-					NoViableAltException nvae = new NoViableAltException("", 47, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt47 )
-			{
-			case 1:
-				// Grammars\\AssignTokenTypesWalker.g3:327:4: ^( RULE_REF ( ARG_ACTION )? )
-				{
-				Match(input,RULE_REF,Follow._RULE_REF_in_atom1079);
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null);
-					// Grammars\\AssignTokenTypesWalker.g3:327:16: ( ARG_ACTION )?
-					int alt45=2;
-					int LA45_0 = input.LA(1);
-
-					if ( (LA45_0==ARG_ACTION) )
-					{
-						alt45=1;
-					}
-					switch ( alt45 )
-					{
-					case 1:
-						// Grammars\\AssignTokenTypesWalker.g3:327:17: ARG_ACTION
-						{
-						Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1082);
-
-						}
-						break;
-
-					}
-
-
-					Match(input, TokenTypes.Up, null);
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\AssignTokenTypesWalker.g3:328:4: ^(t= TOKEN_REF ( ARG_ACTION )? )
-				{
-				t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_atom1095);
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null);
-					// Grammars\\AssignTokenTypesWalker.g3:328:19: ( ARG_ACTION )?
-					int alt46=2;
-					int LA46_0 = input.LA(1);
-
-					if ( (LA46_0==ARG_ACTION) )
-					{
-						alt46=1;
-					}
-					switch ( alt46 )
-					{
-					case 1:
-						// Grammars\\AssignTokenTypesWalker.g3:328:20: ARG_ACTION
-						{
-						Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1098);
-
-						}
-						break;
-
-					}
-
-
-					Match(input, TokenTypes.Up, null);
-				}
-				TrackToken(t);
-
-				}
-				break;
-			case 3:
-				// Grammars\\AssignTokenTypesWalker.g3:329:4: c= CHAR_LITERAL
-				{
-				c=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_atom1112);
-				TrackString(c);
-
-				}
-				break;
-			case 4:
-				// Grammars\\AssignTokenTypesWalker.g3:330:4: s= STRING_LITERAL
-				{
-				s=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_atom1123);
-				TrackString(s);
-
-				}
-				break;
-			case 5:
-				// Grammars\\AssignTokenTypesWalker.g3:331:4: WILDCARD
-				{
-				Match(input,WILDCARD,Follow._WILDCARD_in_atom1130);
-
-				}
-				break;
-			case 6:
-				// Grammars\\AssignTokenTypesWalker.g3:332:4: ^( DOT ID atom )
-				{
-				Match(input,DOT,Follow._DOT_in_atom1136);
-
-				Match(input, TokenTypes.Down, null);
-				Match(input,ID,Follow._ID_in_atom1138);
-				PushFollow(Follow._atom_in_atom1140);
-				atom();
-
-				state._fsp--;
-
-
-				Match(input, TokenTypes.Up, null);
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "atom"
-
-
-	// $ANTLR start "ast_suffix"
-	// Grammars\\AssignTokenTypesWalker.g3:335:0: ast_suffix : ( ROOT | BANG );
-	private void ast_suffix(  )
-	{
-		try
-		{
-			// Grammars\\AssignTokenTypesWalker.g3:336:4: ( ROOT | BANG )
-			// Grammars\\AssignTokenTypesWalker.g3:
-			{
-			if ( input.LA(1)==BANG||input.LA(1)==ROOT )
-			{
-				input.Consume();
-				state.errorRecovery=false;
-			}
-			else
-			{
-				MismatchedSetException mse = new MismatchedSetException(null,input);
-				throw mse;
-			}
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "ast_suffix"
-	#endregion Rules
-
-
-	#region Follow sets
-	private static class Follow
-	{
-		public static readonly BitSet _LEXER_GRAMMAR_in_grammar_68 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _grammarSpec_in_grammar_73 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _PARSER_GRAMMAR_in_grammar_83 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _grammarSpec_in_grammar_87 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _TREE_GRAMMAR_in_grammar_97 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _grammarSpec_in_grammar_103 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _COMBINED_GRAMMAR_in_grammar_113 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _grammarSpec_in_grammar_115 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ID_in_grammarSpec134 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
-		public static readonly BitSet _DOC_COMMENT_in_grammarSpec141 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
-		public static readonly BitSet _optionsSpec_in_grammarSpec148 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
-		public static readonly BitSet _delegateGrammars_in_grammarSpec155 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
-		public static readonly BitSet _tokensSpec_in_grammarSpec162 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
-		public static readonly BitSet _attrScope_in_grammarSpec169 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
-		public static readonly BitSet _AMPERSAND_in_grammarSpec178 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _rules_in_grammarSpec190 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _SCOPE_in_attrScope203 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_attrScope205 = new BitSet(new ulong[]{0x210UL});
-		public static readonly BitSet _AMPERSAND_in_attrScope210 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ACTION_in_attrScope219 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _OPTIONS_in_optionsSpec238 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _option_in_optionsSpec241 = new BitSet(new ulong[]{0x2008UL});
-		public static readonly BitSet _ASSIGN_in_option260 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_option262 = new BitSet(new ulong[]{0x880000040000UL,0x200000UL});
-		public static readonly BitSet _optionValue_in_option264 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ID_in_optionValue290 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _STRING_LITERAL_in_optionValue295 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _CHAR_LITERAL_in_optionValue300 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _INT_in_optionValue305 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _CHARSET_in_charSet323 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _charSetElement_in_charSet325 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _CHAR_LITERAL_in_charSetElement338 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _OR_in_charSetElement345 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _CHAR_LITERAL_in_charSetElement347 = new BitSet(new ulong[]{0x40000UL});
-		public static readonly BitSet _CHAR_LITERAL_in_charSetElement349 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _RANGE_in_charSetElement358 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _CHAR_LITERAL_in_charSetElement360 = new BitSet(new ulong[]{0x40000UL});
-		public static readonly BitSet _CHAR_LITERAL_in_charSetElement362 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _IMPORT_in_delegateGrammars377 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ASSIGN_in_delegateGrammars385 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_delegateGrammars387 = new BitSet(new ulong[]{0x80000000000UL});
-		public static readonly BitSet _ID_in_delegateGrammars389 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ID_in_delegateGrammars397 = new BitSet(new ulong[]{0x80000002008UL});
-		public static readonly BitSet _TOKENS_in_tokensSpec420 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _tokenSpec_in_tokensSpec422 = new BitSet(new ulong[]{0x2008UL,0x4000000UL});
-		public static readonly BitSet _TOKEN_REF_in_tokenSpec438 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ASSIGN_in_tokenSpec458 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _TOKEN_REF_in_tokenSpec465 = new BitSet(new ulong[]{0x40000UL,0x200000UL});
-		public static readonly BitSet _STRING_LITERAL_in_tokenSpec482 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _CHAR_LITERAL_in_tokenSpec493 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _rule_in_rules517 = new BitSet(new ulong[]{0x400200008000202UL,0x8005000UL});
-		public static readonly BitSet _RULE_in_rule531 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_rule535 = new BitSet(new ulong[]{0x10000000400UL,0xEUL});
-		public static readonly BitSet _modifier_in_rule545 = new BitSet(new ulong[]{0x400UL});
-		public static readonly BitSet _ARG_in_rule553 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_ACTION_in_rule556 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _RET_in_rule565 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_ACTION_in_rule568 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _throwsSpec_in_rule577 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
-		public static readonly BitSet _optionsSpec_in_rule585 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
-		public static readonly BitSet _ruleScopeSpec_in_rule593 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
-		public static readonly BitSet _AMPERSAND_in_rule603 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _block_in_rule617 = new BitSet(new ulong[]{0x4400020000UL});
-		public static readonly BitSet _exceptionGroup_in_rule623 = new BitSet(new ulong[]{0x400000000UL});
-		public static readonly BitSet _EOR_in_rule630 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _set_in_modifier650 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _THROWS_in_throwsSpec677 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_throwsSpec679 = new BitSet(new ulong[]{0x80000000008UL});
-		public static readonly BitSet _SCOPE_in_ruleScopeSpec694 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _AMPERSAND_in_ruleScopeSpec699 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ACTION_in_ruleScopeSpec709 = new BitSet(new ulong[]{0x80000000008UL});
-		public static readonly BitSet _ID_in_ruleScopeSpec715 = new BitSet(new ulong[]{0x80000000008UL});
-		public static readonly BitSet _BLOCK_in_block733 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _optionsSpec_in_block739 = new BitSet(new ulong[]{0x100UL});
-		public static readonly BitSet _alternative_in_block748 = new BitSet(new ulong[]{0x200000100UL,0x200UL});
-		public static readonly BitSet _rewrite_in_block750 = new BitSet(new ulong[]{0x200000100UL});
-		public static readonly BitSet _EOB_in_block758 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ALT_in_alternative775 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _element_in_alternative778 = new BitSet(new ulong[]{0x86800289202DE210UL,0xA4E16421UL});
-		public static readonly BitSet _EOA_in_alternative782 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _exceptionHandler_in_exceptionGroup797 = new BitSet(new ulong[]{0x4000020002UL});
-		public static readonly BitSet _finallyClause_in_exceptionGroup803 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _finallyClause_in_exceptionGroup810 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _CATCH_in_exceptionHandler822 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_ACTION_in_exceptionHandler824 = new BitSet(new ulong[]{0x10UL});
-		public static readonly BitSet _ACTION_in_exceptionHandler826 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _FINALLY_in_finallyClause839 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ACTION_in_finallyClause841 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _REWRITE_in_rewrite856 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ROOT_in_element875 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _element_in_element877 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _BANG_in_element884 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _element_in_element886 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _atom_in_element892 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _NOT_in_element898 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _element_in_element900 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _RANGE_in_element907 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _atom_in_element909 = new BitSet(new ulong[]{0x20040000UL,0x84202000UL});
-		public static readonly BitSet _atom_in_element911 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _CHAR_RANGE_in_element918 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _atom_in_element920 = new BitSet(new ulong[]{0x20040000UL,0x84202000UL});
-		public static readonly BitSet _atom_in_element922 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ASSIGN_in_element929 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_element931 = new BitSet(new ulong[]{0x86800289202DE210UL,0xA4E16421UL});
-		public static readonly BitSet _element_in_element933 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _PLUS_ASSIGN_in_element940 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_element942 = new BitSet(new ulong[]{0x86800289202DE210UL,0xA4E16421UL});
-		public static readonly BitSet _element_in_element944 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ebnf_in_element950 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _tree__in_element955 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _SYNPRED_in_element962 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _block_in_element964 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _FORCED_ACTION_in_element971 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ACTION_in_element976 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _SEMPRED_in_element981 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _SYN_SEMPRED_in_element986 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _BACKTRACK_SEMPRED_in_element992 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _GATED_SEMPRED_in_element1001 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _EPSILON_in_element1006 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _block_in_ebnf1017 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _OPTIONAL_in_ebnf1024 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _block_in_ebnf1026 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _CLOSURE_in_ebnf1035 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _block_in_ebnf1037 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _POSITIVE_CLOSURE_in_ebnf1046 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _block_in_ebnf1048 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _TREE_BEGIN_in_tree_1062 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _element_in_tree_1064 = new BitSet(new ulong[]{0x86800289202DE218UL,0xA4E16421UL});
-		public static readonly BitSet _RULE_REF_in_atom1079 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_ACTION_in_atom1082 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _TOKEN_REF_in_atom1095 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_ACTION_in_atom1098 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _CHAR_LITERAL_in_atom1112 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _STRING_LITERAL_in_atom1123 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _WILDCARD_in_atom1130 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _DOT_in_atom1136 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_atom1138 = new BitSet(new ulong[]{0x20040000UL,0x84202000UL});
-		public static readonly BitSet _atom_in_atom1140 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _set_in_ast_suffix1153 = new BitSet(new ulong[]{0x2UL});
-
-	}
-	#endregion Follow sets
-}
-
-} // namespace Antlr3.Grammars
diff --git a/Antlr3/Grammars/CodeGenTreeWalker.cs b/Antlr3/Grammars/CodeGenTreeWalker.cs
deleted file mode 100644
index 755130d..0000000
--- a/Antlr3/Grammars/CodeGenTreeWalker.cs
+++ /dev/null
@@ -1,6148 +0,0 @@
-// $ANTLR 3.1.2 Grammars\\CodeGenTreeWalker.g3 2009-09-30 13:28:37
-
-// The variable 'variable' is assigned but its value is never used.
-#pragma warning disable 219
-// Unreachable code detected.
-#pragma warning disable 162
-
-
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Grammar conversion to ANTLR v3 and C#:
- Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-	notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-	derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-using Antlr3.Analysis;
-using Antlr3.Misc;
-using Antlr3.Tool;
-
-using BitSet = Antlr.Runtime.BitSet;
-using DFA = Antlr.Runtime.DFA;
-using StringTemplate = Antlr3.ST.StringTemplate;
-using StringTemplateGroup = Antlr3.ST.StringTemplateGroup;
-using TokenWithIndex = Antlr.Runtime.CommonToken;
-
-
-using System.Collections.Generic;
-using Antlr.Runtime;
-using Antlr.Runtime.Tree;
-using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;using Stack = System.Collections.Generic.Stack<object>;
-using List = System.Collections.IList;
-using ArrayList = System.Collections.Generic.List<object>;
-using Map = System.Collections.IDictionary;
-using HashMap = System.Collections.Generic.Dictionary<object, object>;
-namespace Antlr3.Grammars
-{
-/** Walk a grammar and generate code by gradually building up
- *  a bigger and bigger StringTemplate.
- *
- *  Terence Parr
- *  University of San Francisco
- *  June 15, 2004
- */
-[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.1.2")]
-[System.CLSCompliant(false)]
-public partial class CodeGenTreeWalker : TreeParser
-{
-	internal static readonly string[] tokenNames = new string[] {
-		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", "ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARG_ACTION", "ARGLIST", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", "CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", "COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", "DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", "EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", "GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", "LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", "NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", "OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", "RET", "RETURNS", "REWRITE", "ROOT", "RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", "SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYN_SEMPRED", "SYNPRED", "TEMPLATE", "THROWS", "TOKEN_REF", "TOKENS", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", "WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT"
-	};
-	public const int EOF=-1;
-	public const int ACTION=4;
-	public const int ACTION_CHAR_LITERAL=5;
-	public const int ACTION_ESC=6;
-	public const int ACTION_STRING_LITERAL=7;
-	public const int ALT=8;
-	public const int AMPERSAND=9;
-	public const int ARG=10;
-	public const int ARG_ACTION=11;
-	public const int ARGLIST=12;
-	public const int ASSIGN=13;
-	public const int BACKTRACK_SEMPRED=14;
-	public const int BANG=15;
-	public const int BLOCK=16;
-	public const int CATCH=17;
-	public const int CHAR_LITERAL=18;
-	public const int CHAR_RANGE=19;
-	public const int CLOSE_ELEMENT_OPTION=20;
-	public const int CLOSURE=21;
-	public const int COLON=22;
-	public const int COMBINED_GRAMMAR=23;
-	public const int COMMA=24;
-	public const int COMMENT=25;
-	public const int DIGIT=26;
-	public const int DOC_COMMENT=27;
-	public const int DOLLAR=28;
-	public const int DOT=29;
-	public const int DOUBLE_ANGLE_STRING_LITERAL=30;
-	public const int DOUBLE_QUOTE_STRING_LITERAL=31;
-	public const int EOA=32;
-	public const int EOB=33;
-	public const int EOR=34;
-	public const int EPSILON=35;
-	public const int ESC=36;
-	public const int ETC=37;
-	public const int FINALLY=38;
-	public const int FORCED_ACTION=39;
-	public const int FRAGMENT=40;
-	public const int GATED_SEMPRED=41;
-	public const int GRAMMAR=42;
-	public const int ID=43;
-	public const int IMPLIES=44;
-	public const int IMPORT=45;
-	public const int INITACTION=46;
-	public const int INT=47;
-	public const int LABEL=48;
-	public const int LEXER=49;
-	public const int LEXER_GRAMMAR=50;
-	public const int LPAREN=51;
-	public const int ML_COMMENT=52;
-	public const int NESTED_ACTION=53;
-	public const int NESTED_ARG_ACTION=54;
-	public const int NOT=55;
-	public const int OPEN_ELEMENT_OPTION=56;
-	public const int OPTIONAL=57;
-	public const int OPTIONS=58;
-	public const int OR=59;
-	public const int PARSER=60;
-	public const int PARSER_GRAMMAR=61;
-	public const int PLUS=62;
-	public const int PLUS_ASSIGN=63;
-	public const int POSITIVE_CLOSURE=64;
-	public const int PRIVATE=65;
-	public const int PROTECTED=66;
-	public const int PUBLIC=67;
-	public const int QUESTION=68;
-	public const int RANGE=69;
-	public const int RCURLY=70;
-	public const int RET=71;
-	public const int RETURNS=72;
-	public const int REWRITE=73;
-	public const int ROOT=74;
-	public const int RPAREN=75;
-	public const int RULE=76;
-	public const int RULE_REF=77;
-	public const int SCOPE=78;
-	public const int SEMI=79;
-	public const int SEMPRED=80;
-	public const int SL_COMMENT=81;
-	public const int SRC=82;
-	public const int STAR=83;
-	public const int STRAY_BRACKET=84;
-	public const int STRING_LITERAL=85;
-	public const int SYN_SEMPRED=86;
-	public const int SYNPRED=87;
-	public const int TEMPLATE=88;
-	public const int THROWS=89;
-	public const int TOKEN_REF=90;
-	public const int TOKENS=91;
-	public const int TREE=92;
-	public const int TREE_BEGIN=93;
-	public const int TREE_GRAMMAR=94;
-	public const int WILDCARD=95;
-	public const int WS=96;
-	public const int WS_LOOP=97;
-	public const int WS_OPT=98;
-	public const int XDIGIT=99;
-
-	// delegates
-	// delegators
-
-	public CodeGenTreeWalker( ITreeNodeStream input )
-		: this( input, new RecognizerSharedState() )
-	{
-	}
-	public CodeGenTreeWalker( ITreeNodeStream input, RecognizerSharedState state )
-		: base( input, state )
-	{
-	}
-
-
-	public override string[] TokenNames { get { return CodeGenTreeWalker.tokenNames; } }
-	public override string GrammarFileName { get { return "Grammars\\CodeGenTreeWalker.g3"; } }
-
-
-	#region Rules
-
-	// $ANTLR start "grammar_"
-	// Grammars\\CodeGenTreeWalker.g3:97:0: public grammar_[Grammar g,\r\n\t\tStringTemplate recognizerST,\r\n\t\tStringTemplate outputFileST,\r\n\t\tStringTemplate headerFileST] : ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) ) ;
-	public void grammar_( Grammar g, StringTemplate recognizerST, StringTemplate outputFileST, StringTemplate headerFileST )
-	{
-
-			if ( state.backtracking == 0 )
-			{
-				Init(g);
-				this.recognizerST = recognizerST;
-				this.outputFileST = outputFileST;
-				this.headerFileST = headerFileST;
-				string superClass = (string)g.GetOption("superClass");
-				outputOption = (string)g.GetOption("output");
-				recognizerST.SetAttribute("superClass", superClass);
-				if ( g.type!=GrammarType.Lexer ) {
-					recognizerST.SetAttribute("ASTLabelType", g.GetOption("ASTLabelType"));
-				}
-				if ( g.type==GrammarType.TreeParser && g.GetOption("ASTLabelType")==null ) {
-					ErrorManager.GrammarWarning(ErrorManager.MSG_MISSING_AST_TYPE_IN_TREE_GRAMMAR,
-											   g,
-											   null,
-											   g.name);
-				}
-				if ( g.type!=GrammarType.TreeParser ) {
-					recognizerST.SetAttribute("labelType", g.GetOption("TokenLabelType"));
-				}
-				recognizerST.SetAttribute("numRules", grammar.Rules.Count);
-				outputFileST.SetAttribute("numRules", grammar.Rules.Count);
-				headerFileST.SetAttribute("numRules", grammar.Rules.Count);
-			}
-
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:129:4: ( ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) ) )
-			// Grammars\\CodeGenTreeWalker.g3:129:4: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
-			{
-			// Grammars\\CodeGenTreeWalker.g3:129:4: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
-			int alt1=4;
-			switch ( input.LA(1) )
-			{
-			case LEXER_GRAMMAR:
-				{
-				alt1=1;
-				}
-				break;
-			case PARSER_GRAMMAR:
-				{
-				alt1=2;
-				}
-				break;
-			case TREE_GRAMMAR:
-				{
-				alt1=3;
-				}
-				break;
-			case COMBINED_GRAMMAR:
-				{
-				alt1=4;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					NoViableAltException nvae = new NoViableAltException("", 1, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt1 )
-			{
-			case 1:
-				// Grammars\\CodeGenTreeWalker.g3:129:6: ^( LEXER_GRAMMAR grammarSpec )
-				{
-				Match(input,LEXER_GRAMMAR,Follow._LEXER_GRAMMAR_in_grammar_66); if (state.failed) return ;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return ;
-				PushFollow(Follow._grammarSpec_in_grammar_68);
-				grammarSpec();
-
-				state._fsp--;
-				if (state.failed) return ;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-				}
-				break;
-			case 2:
-				// Grammars\\CodeGenTreeWalker.g3:130:5: ^( PARSER_GRAMMAR grammarSpec )
-				{
-				Match(input,PARSER_GRAMMAR,Follow._PARSER_GRAMMAR_in_grammar_78); if (state.failed) return ;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return ;
-				PushFollow(Follow._grammarSpec_in_grammar_80);
-				grammarSpec();
-
-				state._fsp--;
-				if (state.failed) return ;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-				}
-				break;
-			case 3:
-				// Grammars\\CodeGenTreeWalker.g3:131:5: ^( TREE_GRAMMAR grammarSpec )
-				{
-				Match(input,TREE_GRAMMAR,Follow._TREE_GRAMMAR_in_grammar_90); if (state.failed) return ;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return ;
-				PushFollow(Follow._grammarSpec_in_grammar_92);
-				grammarSpec();
-
-				state._fsp--;
-				if (state.failed) return ;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-				}
-				break;
-			case 4:
-				// Grammars\\CodeGenTreeWalker.g3:132:5: ^( COMBINED_GRAMMAR grammarSpec )
-				{
-				Match(input,COMBINED_GRAMMAR,Follow._COMBINED_GRAMMAR_in_grammar_102); if (state.failed) return ;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return ;
-				PushFollow(Follow._grammarSpec_in_grammar_104);
-				grammarSpec();
-
-				state._fsp--;
-				if (state.failed) return ;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "grammar_"
-
-
-	// $ANTLR start "attrScope"
-	// Grammars\\CodeGenTreeWalker.g3:136:0: attrScope : ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION ) ;
-	private void attrScope(  )
-	{
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:137:4: ( ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION ) )
-			// Grammars\\CodeGenTreeWalker.g3:137:4: ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION )
-			{
-			Match(input,SCOPE,Follow._SCOPE_in_attrScope123); if (state.failed) return ;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return ;
-			Match(input,ID,Follow._ID_in_attrScope125); if (state.failed) return ;
-			// Grammars\\CodeGenTreeWalker.g3:137:18: ( ^( AMPERSAND ( . )* ) )*
-			for ( ; ; )
-			{
-				int alt3=2;
-				int LA3_0 = input.LA(1);
-
-				if ( (LA3_0==AMPERSAND) )
-				{
-					alt3=1;
-				}
-
-
-				switch ( alt3 )
-				{
-				case 1:
-					// Grammars\\CodeGenTreeWalker.g3:137:20: ^( AMPERSAND ( . )* )
-					{
-					Match(input,AMPERSAND,Follow._AMPERSAND_in_attrScope130); if (state.failed) return ;
-
-					if ( input.LA(1)==TokenTypes.Down )
-					{
-						Match(input, TokenTypes.Down, null); if (state.failed) return ;
-						// Grammars\\CodeGenTreeWalker.g3:137:32: ( . )*
-						for ( ; ; )
-						{
-							int alt2=2;
-							int LA2_0 = input.LA(1);
-
-							if ( ((LA2_0>=ACTION && LA2_0<=XDIGIT)) )
-							{
-								alt2=1;
-							}
-							else if ( (LA2_0==UP) )
-							{
-								alt2=2;
-							}
-
-
-							switch ( alt2 )
-							{
-							case 1:
-								// Grammars\\CodeGenTreeWalker.g3:137:0: .
-								{
-								MatchAny(input); if (state.failed) return ;
-
-								}
-								break;
-
-							default:
-								goto loop2;
-							}
-						}
-
-						loop2:
-							;
-
-
-
-						Match(input, TokenTypes.Up, null); if (state.failed) return ;
-					}
-
-					}
-					break;
-
-				default:
-					goto loop3;
-				}
-			}
-
-			loop3:
-				;
-
-
-			Match(input,ACTION,Follow._ACTION_in_attrScope139); if (state.failed) return ;
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "attrScope"
-
-
-	// $ANTLR start "grammarSpec"
-	// Grammars\\CodeGenTreeWalker.g3:140:0: grammarSpec : name= ID (cmt= DOC_COMMENT )? ( ^( OPTIONS ( . )* ) )? ( ^( IMPORT ( . )* ) )? ( ^( TOKENS ( . )* ) )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules[recognizerST] ;
-	private void grammarSpec(  )
-	{
-		GrammarAST name=null;
-		GrammarAST cmt=null;
-
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:141:6: (name= ID (cmt= DOC_COMMENT )? ( ^( OPTIONS ( . )* ) )? ( ^( IMPORT ( . )* ) )? ( ^( TOKENS ( . )* ) )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules[recognizerST] )
-			// Grammars\\CodeGenTreeWalker.g3:141:6: name= ID (cmt= DOC_COMMENT )? ( ^( OPTIONS ( . )* ) )? ( ^( IMPORT ( . )* ) )? ( ^( TOKENS ( . )* ) )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules[recognizerST]
-			{
-			name=(GrammarAST)Match(input,ID,Follow._ID_in_grammarSpec156); if (state.failed) return ;
-			// Grammars\\CodeGenTreeWalker.g3:142:3: (cmt= DOC_COMMENT )?
-			int alt4=2;
-			int LA4_0 = input.LA(1);
-
-			if ( (LA4_0==DOC_COMMENT) )
-			{
-				alt4=1;
-			}
-			switch ( alt4 )
-			{
-			case 1:
-				// Grammars\\CodeGenTreeWalker.g3:142:5: cmt= DOC_COMMENT
-				{
-				cmt=(GrammarAST)Match(input,DOC_COMMENT,Follow._DOC_COMMENT_in_grammarSpec164); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-
-									outputFileST.SetAttribute("docComment", (cmt!=null?cmt.Text:null));
-									headerFileST.SetAttribute("docComment", (cmt!=null?cmt.Text:null));
-
-				}
-
-				}
-				break;
-
-			}
-
-			if ( state.backtracking == 0 )
-			{
-
-							recognizerST.SetAttribute("name", grammar.GetRecognizerName());
-							outputFileST.SetAttribute("name", grammar.GetRecognizerName());
-							headerFileST.SetAttribute("name", grammar.GetRecognizerName());
-							recognizerST.SetAttribute("scopes", grammar.GlobalScopes);
-							headerFileST.SetAttribute("scopes", grammar.GlobalScopes);
-
-			}
-			// Grammars\\CodeGenTreeWalker.g3:155:3: ( ^( OPTIONS ( . )* ) )?
-			int alt6=2;
-			int LA6_0 = input.LA(1);
-
-			if ( (LA6_0==OPTIONS) )
-			{
-				alt6=1;
-			}
-			switch ( alt6 )
-			{
-			case 1:
-				// Grammars\\CodeGenTreeWalker.g3:155:5: ^( OPTIONS ( . )* )
-				{
-				Match(input,OPTIONS,Follow._OPTIONS_in_grammarSpec185); if (state.failed) return ;
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null); if (state.failed) return ;
-					// Grammars\\CodeGenTreeWalker.g3:155:15: ( . )*
-					for ( ; ; )
-					{
-						int alt5=2;
-						int LA5_0 = input.LA(1);
-
-						if ( ((LA5_0>=ACTION && LA5_0<=XDIGIT)) )
-						{
-							alt5=1;
-						}
-						else if ( (LA5_0==UP) )
-						{
-							alt5=2;
-						}
-
-
-						switch ( alt5 )
-						{
-						case 1:
-							// Grammars\\CodeGenTreeWalker.g3:155:0: .
-							{
-							MatchAny(input); if (state.failed) return ;
-
-							}
-							break;
-
-						default:
-							goto loop5;
-						}
-					}
-
-					loop5:
-						;
-
-
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return ;
-				}
-
-				}
-				break;
-
-			}
-
-			// Grammars\\CodeGenTreeWalker.g3:156:3: ( ^( IMPORT ( . )* ) )?
-			int alt8=2;
-			int LA8_0 = input.LA(1);
-
-			if ( (LA8_0==IMPORT) )
-			{
-				alt8=1;
-			}
-			switch ( alt8 )
-			{
-			case 1:
-				// Grammars\\CodeGenTreeWalker.g3:156:5: ^( IMPORT ( . )* )
-				{
-				Match(input,IMPORT,Follow._IMPORT_in_grammarSpec199); if (state.failed) return ;
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null); if (state.failed) return ;
-					// Grammars\\CodeGenTreeWalker.g3:156:14: ( . )*
-					for ( ; ; )
-					{
-						int alt7=2;
-						int LA7_0 = input.LA(1);
-
-						if ( ((LA7_0>=ACTION && LA7_0<=XDIGIT)) )
-						{
-							alt7=1;
-						}
-						else if ( (LA7_0==UP) )
-						{
-							alt7=2;
-						}
-
-
-						switch ( alt7 )
-						{
-						case 1:
-							// Grammars\\CodeGenTreeWalker.g3:156:0: .
-							{
-							MatchAny(input); if (state.failed) return ;
-
-							}
-							break;
-
-						default:
-							goto loop7;
-						}
-					}
-
-					loop7:
-						;
-
-
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return ;
-				}
-
-				}
-				break;
-
-			}
-
-			// Grammars\\CodeGenTreeWalker.g3:157:3: ( ^( TOKENS ( . )* ) )?
-			int alt10=2;
-			int LA10_0 = input.LA(1);
-
-			if ( (LA10_0==TOKENS) )
-			{
-				alt10=1;
-			}
-			switch ( alt10 )
-			{
-			case 1:
-				// Grammars\\CodeGenTreeWalker.g3:157:5: ^( TOKENS ( . )* )
-				{
-				Match(input,TOKENS,Follow._TOKENS_in_grammarSpec213); if (state.failed) return ;
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null); if (state.failed) return ;
-					// Grammars\\CodeGenTreeWalker.g3:157:14: ( . )*
-					for ( ; ; )
-					{
-						int alt9=2;
-						int LA9_0 = input.LA(1);
-
-						if ( ((LA9_0>=ACTION && LA9_0<=XDIGIT)) )
-						{
-							alt9=1;
-						}
-						else if ( (LA9_0==UP) )
-						{
-							alt9=2;
-						}
-
-
-						switch ( alt9 )
-						{
-						case 1:
-							// Grammars\\CodeGenTreeWalker.g3:157:0: .
-							{
-							MatchAny(input); if (state.failed) return ;
-
-							}
-							break;
-
-						default:
-							goto loop9;
-						}
-					}
-
-					loop9:
-						;
-
-
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return ;
-				}
-
-				}
-				break;
-
-			}
-
-			// Grammars\\CodeGenTreeWalker.g3:158:3: ( attrScope )*
-			for ( ; ; )
-			{
-				int alt11=2;
-				int LA11_0 = input.LA(1);
-
-				if ( (LA11_0==SCOPE) )
-				{
-					alt11=1;
-				}
-
-
-				switch ( alt11 )
-				{
-				case 1:
-					// Grammars\\CodeGenTreeWalker.g3:158:4: attrScope
-					{
-					PushFollow(Follow._attrScope_in_grammarSpec225);
-					attrScope();
-
-					state._fsp--;
-					if (state.failed) return ;
-
-					}
-					break;
-
-				default:
-					goto loop11;
-				}
-			}
-
-			loop11:
-				;
-
-
-			// Grammars\\CodeGenTreeWalker.g3:159:3: ( ^( AMPERSAND ( . )* ) )*
-			for ( ; ; )
-			{
-				int alt13=2;
-				int LA13_0 = input.LA(1);
-
-				if ( (LA13_0==AMPERSAND) )
-				{
-					alt13=1;
-				}
-
-
-				switch ( alt13 )
-				{
-				case 1:
-					// Grammars\\CodeGenTreeWalker.g3:159:5: ^( AMPERSAND ( . )* )
-					{
-					Match(input,AMPERSAND,Follow._AMPERSAND_in_grammarSpec234); if (state.failed) return ;
-
-					if ( input.LA(1)==TokenTypes.Down )
-					{
-						Match(input, TokenTypes.Down, null); if (state.failed) return ;
-						// Grammars\\CodeGenTreeWalker.g3:159:17: ( . )*
-						for ( ; ; )
-						{
-							int alt12=2;
-							int LA12_0 = input.LA(1);
-
-							if ( ((LA12_0>=ACTION && LA12_0<=XDIGIT)) )
-							{
-								alt12=1;
-							}
-							else if ( (LA12_0==UP) )
-							{
-								alt12=2;
-							}
-
-
-							switch ( alt12 )
-							{
-							case 1:
-								// Grammars\\CodeGenTreeWalker.g3:159:0: .
-								{
-								MatchAny(input); if (state.failed) return ;
-
-								}
-								break;
-
-							default:
-								goto loop12;
-							}
-						}
-
-						loop12:
-							;
-
-
-
-						Match(input, TokenTypes.Up, null); if (state.failed) return ;
-					}
-
-					}
-					break;
-
-				default:
-					goto loop13;
-				}
-			}
-
-			loop13:
-				;
-
-
-			PushFollow(Follow._rules_in_grammarSpec245);
-			rules(recognizerST);
-
-			state._fsp--;
-			if (state.failed) return ;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "grammarSpec"
-
-
-	// $ANTLR start "rules"
-	// Grammars\\CodeGenTreeWalker.g3:163:0: rules[StringTemplate recognizerST] : ( ( options {k=1; } :{...}? =>rST= rule | ^( RULE ( . )* ) ) )+ ;
-	private void rules( StringTemplate recognizerST )
-	{
-		CodeGenTreeWalker.rule_return rST = default(CodeGenTreeWalker.rule_return);
-
-
-			string ruleName = ((GrammarAST)input.LT(1)).GetChild(0).Text;
-			bool generated = grammar.GenerateMethodForRule(ruleName);
-
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:169:4: ( ( ( options {k=1; } :{...}? =>rST= rule | ^( RULE ( . )* ) ) )+ )
-			// Grammars\\CodeGenTreeWalker.g3:169:4: ( ( options {k=1; } :{...}? =>rST= rule | ^( RULE ( . )* ) ) )+
-			{
-			// Grammars\\CodeGenTreeWalker.g3:169:4: ( ( options {k=1; } :{...}? =>rST= rule | ^( RULE ( . )* ) ) )+
-			int cnt16=0;
-			for ( ; ; )
-			{
-				int alt16=2;
-				int LA16_0 = input.LA(1);
-
-				if ( (LA16_0==RULE) )
-				{
-					alt16=1;
-				}
-
-
-				switch ( alt16 )
-				{
-				case 1:
-					// Grammars\\CodeGenTreeWalker.g3:169:6: ( options {k=1; } :{...}? =>rST= rule | ^( RULE ( . )* ) )
-					{
-					// Grammars\\CodeGenTreeWalker.g3:169:6: ( options {k=1; } :{...}? =>rST= rule | ^( RULE ( . )* ) )
-					int alt15=2;
-					int LA15_0 = input.LA(1);
-
-					if ( (LA15_0==RULE) )
-					{
-						int LA15_1 = input.LA(2);
-
-						if ( ((generated)) )
-						{
-							alt15=1;
-						}
-						else if ( (true) )
-						{
-							alt15=2;
-						}
-						else
-						{
-							if (state.backtracking>0) {state.failed=true; return ;}
-							NoViableAltException nvae = new NoViableAltException("", 15, 1, input);
-
-							throw nvae;
-						}
-					}
-					else
-					{
-						if (state.backtracking>0) {state.failed=true; return ;}
-						NoViableAltException nvae = new NoViableAltException("", 15, 0, input);
-
-						throw nvae;
-					}
-					switch ( alt15 )
-					{
-					case 1:
-						// Grammars\\CodeGenTreeWalker.g3:170:5: {...}? =>rST= rule
-						{
-						if ( !((generated)) )
-						{
-							if (state.backtracking>0) {state.failed=true; return ;}
-							throw new FailedPredicateException(input, "rules", "generated");
-						}
-						PushFollow(Follow._rule_in_rules290);
-						rST=rule();
-
-						state._fsp--;
-						if (state.failed) return ;
-						if ( state.backtracking == 0 )
-						{
-
-												if ( (rST!=null?rST.code:default(StringTemplate)) != null )
-												{
-													recognizerST.SetAttribute("rules", (rST!=null?rST.code:default(StringTemplate)));
-													outputFileST.SetAttribute("rules", (rST!=null?rST.code:default(StringTemplate)));
-													headerFileST.SetAttribute("rules", (rST!=null?rST.code:default(StringTemplate)));
-												}
-
-						}
-
-						}
-						break;
-					case 2:
-						// Grammars\\CodeGenTreeWalker.g3:180:6: ^( RULE ( . )* )
-						{
-						Match(input,RULE,Follow._RULE_in_rules304); if (state.failed) return ;
-
-						if ( input.LA(1)==TokenTypes.Down )
-						{
-							Match(input, TokenTypes.Down, null); if (state.failed) return ;
-							// Grammars\\CodeGenTreeWalker.g3:180:13: ( . )*
-							for ( ; ; )
-							{
-								int alt14=2;
-								int LA14_0 = input.LA(1);
-
-								if ( ((LA14_0>=ACTION && LA14_0<=XDIGIT)) )
-								{
-									alt14=1;
-								}
-								else if ( (LA14_0==UP) )
-								{
-									alt14=2;
-								}
-
-
-								switch ( alt14 )
-								{
-								case 1:
-									// Grammars\\CodeGenTreeWalker.g3:180:0: .
-									{
-									MatchAny(input); if (state.failed) return ;
-
-									}
-									break;
-
-								default:
-									goto loop14;
-								}
-							}
-
-							loop14:
-								;
-
-
-
-							Match(input, TokenTypes.Up, null); if (state.failed) return ;
-						}
-
-						}
-						break;
-
-					}
-
-
-									if ( input.LA(1) == RULE )
-									{
-										ruleName = ((GrammarAST)input.LT(1)).GetChild(0).Text;
-										//System.Diagnostics.Debug.Assert( ruleName == ((GrammarAST)input.LT(1)).enclosingRuleName );
-										generated = grammar.GenerateMethodForRule(ruleName);
-									}
-
-
-					}
-					break;
-
-				default:
-					if ( cnt16 >= 1 )
-						goto loop16;
-
-					if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee16 = new EarlyExitException( 16, input );
-					throw eee16;
-				}
-				cnt16++;
-			}
-			loop16:
-				;
-
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "rules"
-
-	public class rule_return : TreeRuleReturnScope
-	{
-		public StringTemplate code=null;
-	}
-
-	// $ANTLR start "rule"
-	// Grammars\\CodeGenTreeWalker.g3:193:0: rule returns [StringTemplate code=null] : ^( RULE id= ID (mod= modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block[\"ruleBlock\", dfa] ( exceptionGroup[$code] )? EOR ) ;
-	private CodeGenTreeWalker.rule_return rule(  )
-	{
-		CodeGenTreeWalker.rule_return retval = new CodeGenTreeWalker.rule_return();
-		retval.start = input.LT(1);
-
-		GrammarAST id=null;
-		CodeGenTreeWalker.modifier_return mod = default(CodeGenTreeWalker.modifier_return);
-		CodeGenTreeWalker.block_return b = default(CodeGenTreeWalker.block_return);
-
-
-			string initAction = null;
-			// get the dfa for the BLOCK
-			GrammarAST block2=(GrammarAST)((GrammarAST)retval.Start).GetFirstChildWithType(BLOCK);
-			Antlr3.Analysis.DFA dfa=block2.LookaheadDFA;
-			// init blockNestingLevel so it's block level RULE_BLOCK_NESTING_LEVEL
-			// for alts of rule
-			blockNestingLevel = RULE_BLOCK_NESTING_LEVEL-1;
-			Rule ruleDescr = grammar.GetRule(((GrammarAST)retval.Start).GetChild(0).Text);
-			currentRuleName = ((GrammarAST)retval.Start).GetChild(0).Text;
-
-			// For syn preds, we don't want any AST code etc... in there.
-			// Save old templates ptr and restore later.  Base templates include Dbg.
-			StringTemplateGroup saveGroup = templates;
-			if ( ruleDescr.isSynPred )
-			{
-				templates = generator.BaseTemplates;
-			}
-
-			string description = string.Empty;
-
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:216:4: ( ^( RULE id= ID (mod= modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block[\"ruleBlock\", dfa] ( exceptionGroup[$code] )? EOR ) )
-			// Grammars\\CodeGenTreeWalker.g3:216:4: ^( RULE id= ID (mod= modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block[\"ruleBlock\", dfa] ( exceptionGroup[$code] )? EOR )
-			{
-			Match(input,RULE,Follow._RULE_in_rule345); if (state.failed) return retval;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-			id=(GrammarAST)Match(input,ID,Follow._ID_in_rule349); if (state.failed) return retval;
-			if ( state.backtracking == 0 )
-			{
-				 System.Diagnostics.Debug.Assert( currentRuleName == (id!=null?id.Text:null) );
-			}
-			// Grammars\\CodeGenTreeWalker.g3:218:4: (mod= modifier )?
-			int alt17=2;
-			int LA17_0 = input.LA(1);
-
-			if ( (LA17_0==FRAGMENT||(LA17_0>=PRIVATE && LA17_0<=PUBLIC)) )
-			{
-				alt17=1;
-			}
-			switch ( alt17 )
-			{
-			case 1:
-				// Grammars\\CodeGenTreeWalker.g3:218:5: mod= modifier
-				{
-				PushFollow(Follow._modifier_in_rule362);
-				mod=modifier();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				}
-				break;
-
-			}
-
-			Match(input,ARG,Follow._ARG_in_rule370); if (state.failed) return retval;
-
-			if ( input.LA(1)==TokenTypes.Down )
-			{
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				// Grammars\\CodeGenTreeWalker.g3:219:10: ( ARG_ACTION )?
-				int alt18=2;
-				int LA18_0 = input.LA(1);
-
-				if ( (LA18_0==ARG_ACTION) )
-				{
-					alt18=1;
-				}
-				switch ( alt18 )
-				{
-				case 1:
-					// Grammars\\CodeGenTreeWalker.g3:219:11: ARG_ACTION
-					{
-					Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule373); if (state.failed) return retval;
-
-					}
-					break;
-
-				}
-
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-			}
-			Match(input,RET,Follow._RET_in_rule382); if (state.failed) return retval;
-
-			if ( input.LA(1)==TokenTypes.Down )
-			{
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				// Grammars\\CodeGenTreeWalker.g3:220:10: ( ARG_ACTION )?
-				int alt19=2;
-				int LA19_0 = input.LA(1);
-
-				if ( (LA19_0==ARG_ACTION) )
-				{
-					alt19=1;
-				}
-				switch ( alt19 )
-				{
-				case 1:
-					// Grammars\\CodeGenTreeWalker.g3:220:11: ARG_ACTION
-					{
-					Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule385); if (state.failed) return retval;
-
-					}
-					break;
-
-				}
-
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-			}
-			// Grammars\\CodeGenTreeWalker.g3:221:4: ( throwsSpec )?
-			int alt20=2;
-			int LA20_0 = input.LA(1);
-
-			if ( (LA20_0==THROWS) )
-			{
-				alt20=1;
-			}
-			switch ( alt20 )
-			{
-			case 1:
-				// Grammars\\CodeGenTreeWalker.g3:221:5: throwsSpec
-				{
-				PushFollow(Follow._throwsSpec_in_rule394);
-				throwsSpec();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				}
-				break;
-
-			}
-
-			// Grammars\\CodeGenTreeWalker.g3:222:4: ( ^( OPTIONS ( . )* ) )?
-			int alt22=2;
-			int LA22_0 = input.LA(1);
-
-			if ( (LA22_0==OPTIONS) )
-			{
-				alt22=1;
-			}
-			switch ( alt22 )
-			{
-			case 1:
-				// Grammars\\CodeGenTreeWalker.g3:222:6: ^( OPTIONS ( . )* )
-				{
-				Match(input,OPTIONS,Follow._OPTIONS_in_rule404); if (state.failed) return retval;
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-					// Grammars\\CodeGenTreeWalker.g3:222:16: ( . )*
-					for ( ; ; )
-					{
-						int alt21=2;
-						int LA21_0 = input.LA(1);
-
-						if ( ((LA21_0>=ACTION && LA21_0<=XDIGIT)) )
-						{
-							alt21=1;
-						}
-						else if ( (LA21_0==UP) )
-						{
-							alt21=2;
-						}
-
-
-						switch ( alt21 )
-						{
-						case 1:
-							// Grammars\\CodeGenTreeWalker.g3:222:0: .
-							{
-							MatchAny(input); if (state.failed) return retval;
-
-							}
-							break;
-
-						default:
-							goto loop21;
-						}
-					}
-
-					loop21:
-						;
-
-
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				}
-
-				}
-				break;
-
-			}
-
-			// Grammars\\CodeGenTreeWalker.g3:223:4: ( ruleScopeSpec )?
-			int alt23=2;
-			int LA23_0 = input.LA(1);
-
-			if ( (LA23_0==SCOPE) )
-			{
-				alt23=1;
-			}
-			switch ( alt23 )
-			{
-			case 1:
-				// Grammars\\CodeGenTreeWalker.g3:223:5: ruleScopeSpec
-				{
-				PushFollow(Follow._ruleScopeSpec_in_rule417);
-				ruleScopeSpec();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				}
-				break;
-
-			}
-
-			// Grammars\\CodeGenTreeWalker.g3:224:4: ( ^( AMPERSAND ( . )* ) )*
-			for ( ; ; )
-			{
-				int alt25=2;
-				int LA25_0 = input.LA(1);
-
-				if ( (LA25_0==AMPERSAND) )
-				{
-					alt25=1;
-				}
-
-
-				switch ( alt25 )
-				{
-				case 1:
-					// Grammars\\CodeGenTreeWalker.g3:224:6: ^( AMPERSAND ( . )* )
-					{
-					Match(input,AMPERSAND,Follow._AMPERSAND_in_rule427); if (state.failed) return retval;
-
-					if ( input.LA(1)==TokenTypes.Down )
-					{
-						Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-						// Grammars\\CodeGenTreeWalker.g3:224:18: ( . )*
-						for ( ; ; )
-						{
-							int alt24=2;
-							int LA24_0 = input.LA(1);
-
-							if ( ((LA24_0>=ACTION && LA24_0<=XDIGIT)) )
-							{
-								alt24=1;
-							}
-							else if ( (LA24_0==UP) )
-							{
-								alt24=2;
-							}
-
-
-							switch ( alt24 )
-							{
-							case 1:
-								// Grammars\\CodeGenTreeWalker.g3:224:0: .
-								{
-								MatchAny(input); if (state.failed) return retval;
-
-								}
-								break;
-
-							default:
-								goto loop24;
-							}
-						}
-
-						loop24:
-							;
-
-
-
-						Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-					}
-
-					}
-					break;
-
-				default:
-					goto loop25;
-				}
-			}
-
-			loop25:
-				;
-
-
-			PushFollow(Follow._block_in_rule441);
-			b=block("ruleBlock", dfa);
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 )
-			{
-
-								description =
-									grammar.GrammarTreeToString((GrammarAST)((GrammarAST)retval.Start).GetFirstChildWithType(BLOCK),
-																false);
-								description =
-									generator.target.GetTargetStringLiteralFromString(description);
-								(b!=null?b.code:default(StringTemplate)).SetAttribute("description", description);
-								// do not generate lexer rules in combined grammar
-								string stName = null;
-								if ( ruleDescr.isSynPred )
-								{
-									stName = "synpredRule";
-								}
-								else if ( grammar.type==GrammarType.Lexer )
-								{
-									if ( currentRuleName.Equals(Grammar.ArtificialTokensRuleName) )
-									{
-										stName = "tokensRule";
-									}
-									else
-									{
-										stName = "lexerRule";
-									}
-								}
-								else
-								{
-									if ( !(grammar.type==GrammarType.Combined &&
-										 char.IsUpper(currentRuleName[0])) )
-									{
-										stName = "rule";
-									}
-								}
-								retval.code = templates.GetInstanceOf(stName);
-								if ( retval.code.Name.Equals("rule") )
-								{
-									retval.code.SetAttribute("emptyRule", grammar.IsEmptyRule(block2));
-								}
-								retval.code.SetAttribute("ruleDescriptor", ruleDescr);
-								string memo = (string)grammar.GetBlockOption(((GrammarAST)retval.Start),"memoize");
-								if ( memo==null )
-								{
-									memo = (string)grammar.GetOption("memoize");
-								}
-								if ( memo!=null && memo.Equals("true") &&
-									 (stName.Equals("rule")||stName.Equals("lexerRule")) )
-								{
-									retval.code.SetAttribute("memoize", memo!=null && memo.Equals("true"));
-								}
-
-			}
-			// Grammars\\CodeGenTreeWalker.g3:276:4: ( exceptionGroup[$code] )?
-			int alt26=2;
-			int LA26_0 = input.LA(1);
-
-			if ( (LA26_0==CATCH||LA26_0==FINALLY) )
-			{
-				alt26=1;
-			}
-			switch ( alt26 )
-			{
-			case 1:
-				// Grammars\\CodeGenTreeWalker.g3:276:5: exceptionGroup[$code]
-				{
-				PushFollow(Follow._exceptionGroup_in_rule454);
-				exceptionGroup(retval.code);
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				}
-				break;
-
-			}
-
-			Match(input,EOR,Follow._EOR_in_rule462); if (state.failed) return retval;
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-			if ( state.backtracking == 0 )
-			{
-
-							if ( retval.code!=null )
-							{
-								if ( grammar.type==GrammarType.Lexer )
-								{
-									bool naked =
-										currentRuleName.Equals(Grammar.ArtificialTokensRuleName) ||
-										((mod!=null?((GrammarAST)mod.Start):null)!=null&&(mod!=null?((GrammarAST)mod.Start):null).Text.Equals(Grammar.FragmentRuleModifier));
-									retval.code.SetAttribute("nakedBlock", naked);
-								}
-								else
-								{
-									description = grammar.GrammarTreeToString(((GrammarAST)retval.Start),false);
-									description = generator.target.GetTargetStringLiteralFromString(description);
-									retval.code.SetAttribute("description", description);
-								}
-								Rule theRule = grammar.GetRule(currentRuleName);
-								generator.TranslateActionAttributeReferencesForSingleScope(
-									theRule,
-									theRule.Actions
-								);
-								retval.code.SetAttribute("ruleName", currentRuleName);
-								retval.code.SetAttribute("block", (b!=null?b.code:default(StringTemplate)));
-								if ( initAction!=null )
-								{
-									retval.code.SetAttribute("initAction", initAction);
-								}
-							}
-
-			}
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-			 templates = saveGroup;
-		}
-		return retval;
-	}
-	// $ANTLR end "rule"
-
-	public class modifier_return : TreeRuleReturnScope
-	{
-	}
-
-	// $ANTLR start "modifier"
-	// Grammars\\CodeGenTreeWalker.g3:311:0: modifier : ( 'protected' | 'public' | 'private' | 'fragment' );
-	private CodeGenTreeWalker.modifier_return modifier(  )
-	{
-		CodeGenTreeWalker.modifier_return retval = new CodeGenTreeWalker.modifier_return();
-		retval.start = input.LT(1);
-
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:312:4: ( 'protected' | 'public' | 'private' | 'fragment' )
-			// Grammars\\CodeGenTreeWalker.g3:
-			{
-			if ( input.LA(1)==FRAGMENT||(input.LA(1)>=PRIVATE && input.LA(1)<=PUBLIC) )
-			{
-				input.Consume();
-				state.errorRecovery=false;state.failed=false;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return retval;}
-				MismatchedSetException mse = new MismatchedSetException(null,input);
-				throw mse;
-			}
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "modifier"
-
-
-	// $ANTLR start "throwsSpec"
-	// Grammars\\CodeGenTreeWalker.g3:318:0: throwsSpec : ^( 'throws' ( ID )+ ) ;
-	private void throwsSpec(  )
-	{
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:319:4: ( ^( 'throws' ( ID )+ ) )
-			// Grammars\\CodeGenTreeWalker.g3:319:4: ^( 'throws' ( ID )+ )
-			{
-			Match(input,THROWS,Follow._THROWS_in_throwsSpec512); if (state.failed) return ;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return ;
-			// Grammars\\CodeGenTreeWalker.g3:319:15: ( ID )+
-			int cnt27=0;
-			for ( ; ; )
-			{
-				int alt27=2;
-				int LA27_0 = input.LA(1);
-
-				if ( (LA27_0==ID) )
-				{
-					alt27=1;
-				}
-
-
-				switch ( alt27 )
-				{
-				case 1:
-					// Grammars\\CodeGenTreeWalker.g3:319:0: ID
-					{
-					Match(input,ID,Follow._ID_in_throwsSpec514); if (state.failed) return ;
-
-					}
-					break;
-
-				default:
-					if ( cnt27 >= 1 )
-						goto loop27;
-
-					if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee27 = new EarlyExitException( 27, input );
-					throw eee27;
-				}
-				cnt27++;
-			}
-			loop27:
-				;
-
-
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "throwsSpec"
-
-
-	// $ANTLR start "ruleScopeSpec"
-	// Grammars\\CodeGenTreeWalker.g3:322:0: ruleScopeSpec : ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* ) ;
-	private void ruleScopeSpec(  )
-	{
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:323:4: ( ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* ) )
-			// Grammars\\CodeGenTreeWalker.g3:323:4: ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* )
-			{
-			Match(input,SCOPE,Follow._SCOPE_in_ruleScopeSpec529); if (state.failed) return ;
-
-			if ( input.LA(1)==TokenTypes.Down )
-			{
-				Match(input, TokenTypes.Down, null); if (state.failed) return ;
-				// Grammars\\CodeGenTreeWalker.g3:323:15: ( ^( AMPERSAND ( . )* ) )*
-				for ( ; ; )
-				{
-					int alt29=2;
-					int LA29_0 = input.LA(1);
-
-					if ( (LA29_0==AMPERSAND) )
-					{
-						alt29=1;
-					}
-
-
-					switch ( alt29 )
-					{
-					case 1:
-						// Grammars\\CodeGenTreeWalker.g3:323:17: ^( AMPERSAND ( . )* )
-						{
-						Match(input,AMPERSAND,Follow._AMPERSAND_in_ruleScopeSpec534); if (state.failed) return ;
-
-						if ( input.LA(1)==TokenTypes.Down )
-						{
-							Match(input, TokenTypes.Down, null); if (state.failed) return ;
-							// Grammars\\CodeGenTreeWalker.g3:323:29: ( . )*
-							for ( ; ; )
-							{
-								int alt28=2;
-								int LA28_0 = input.LA(1);
-
-								if ( ((LA28_0>=ACTION && LA28_0<=XDIGIT)) )
-								{
-									alt28=1;
-								}
-								else if ( (LA28_0==UP) )
-								{
-									alt28=2;
-								}
-
-
-								switch ( alt28 )
-								{
-								case 1:
-									// Grammars\\CodeGenTreeWalker.g3:323:0: .
-									{
-									MatchAny(input); if (state.failed) return ;
-
-									}
-									break;
-
-								default:
-									goto loop28;
-								}
-							}
-
-							loop28:
-								;
-
-
-
-							Match(input, TokenTypes.Up, null); if (state.failed) return ;
-						}
-
-						}
-						break;
-
-					default:
-						goto loop29;
-					}
-				}
-
-				loop29:
-					;
-
-
-				// Grammars\\CodeGenTreeWalker.g3:323:36: ( ACTION )?
-				int alt30=2;
-				int LA30_0 = input.LA(1);
-
-				if ( (LA30_0==ACTION) )
-				{
-					alt30=1;
-				}
-				switch ( alt30 )
-				{
-				case 1:
-					// Grammars\\CodeGenTreeWalker.g3:323:37: ACTION
-					{
-					Match(input,ACTION,Follow._ACTION_in_ruleScopeSpec544); if (state.failed) return ;
-
-					}
-					break;
-
-				}
-
-				// Grammars\\CodeGenTreeWalker.g3:323:46: ( ID )*
-				for ( ; ; )
-				{
-					int alt31=2;
-					int LA31_0 = input.LA(1);
-
-					if ( (LA31_0==ID) )
-					{
-						alt31=1;
-					}
-
-
-					switch ( alt31 )
-					{
-					case 1:
-						// Grammars\\CodeGenTreeWalker.g3:323:48: ID
-						{
-						Match(input,ID,Follow._ID_in_ruleScopeSpec550); if (state.failed) return ;
-
-						}
-						break;
-
-					default:
-						goto loop31;
-					}
-				}
-
-				loop31:
-					;
-
-
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return ;
-			}
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "ruleScopeSpec"
-
-	public class block_return : TreeRuleReturnScope
-	{
-		public StringTemplate code=null;
-	}
-
-	// $ANTLR start "block"
-	// Grammars\\CodeGenTreeWalker.g3:326:0: block[string blockTemplateName, Antlr3.Analysis.DFA dfa] returns [StringTemplate code=null] options {k=1; } : ({...}? => setBlock | ^( BLOCK ( ^( OPTIONS ( . )* ) )? (alt= alternative rew= rewrite )+ EOB ) );
-	private CodeGenTreeWalker.block_return block( string blockTemplateName, Antlr3.Analysis.DFA dfa )
-	{
-		CodeGenTreeWalker.block_return retval = new CodeGenTreeWalker.block_return();
-		retval.start = input.LT(1);
-
-		CodeGenTreeWalker.alternative_return alt = default(CodeGenTreeWalker.alternative_return);
-		CodeGenTreeWalker.rewrite_return rew = default(CodeGenTreeWalker.rewrite_return);
-		CodeGenTreeWalker.setBlock_return setBlock1 = default(CodeGenTreeWalker.setBlock_return);
-
-
-			int altNum = 0;
-
-			blockNestingLevel++;
-			if ( state.backtracking == 0 )
-			{
-				StringTemplate decision = null;
-				if ( dfa != null )
-				{
-					retval.code = templates.GetInstanceOf(blockTemplateName);
-					decision = generator.GenLookaheadDecision(recognizerST,dfa);
-					retval.code.SetAttribute("decision", decision);
-					retval.code.SetAttribute("decisionNumber", dfa.DecisionNumber);
-					retval.code.SetAttribute("maxK",dfa.MaxLookaheadDepth);
-					retval.code.SetAttribute("maxAlt",dfa.NumberOfAlts);
-				}
-				else
-				{
-					retval.code = templates.GetInstanceOf(blockTemplateName+"SingleAlt");
-				}
-				retval.code.SetAttribute("blockLevel", blockNestingLevel);
-				retval.code.SetAttribute("enclosingBlockLevel", blockNestingLevel-1);
-				altNum = 1;
-				if ( this.blockNestingLevel==RULE_BLOCK_NESTING_LEVEL ) {
-					this.outerAltNum=1;
-				}
-			}
-
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:358:4: ({...}? => setBlock | ^( BLOCK ( ^( OPTIONS ( . )* ) )? (alt= alternative rew= rewrite )+ EOB ) )
-			int alt35=2;
-			int LA35_0 = input.LA(1);
-
-			if ( (LA35_0==BLOCK) )
-			{
-				int LA35_1 = input.LA(2);
-
-				if ( ((((GrammarAST)retval.Start).SetValue!=null)) )
-				{
-					alt35=1;
-				}
-				else if ( (true) )
-				{
-					alt35=2;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 35, 1, input);
-
-					throw nvae;
-				}
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return retval;}
-				NoViableAltException nvae = new NoViableAltException("", 35, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt35 )
-			{
-			case 1:
-				// Grammars\\CodeGenTreeWalker.g3:358:4: {...}? => setBlock
-				{
-				if ( !((((GrammarAST)retval.Start).SetValue!=null)) )
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					throw new FailedPredicateException(input, "block", "$start.SetValue!=null");
-				}
-				PushFollow(Follow._setBlock_in_block591);
-				setBlock1=setBlock();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-
-								retval.code.SetAttribute("alts",(setBlock1!=null?setBlock1.code:default(StringTemplate)));
-
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\CodeGenTreeWalker.g3:363:4: ^( BLOCK ( ^( OPTIONS ( . )* ) )? (alt= alternative rew= rewrite )+ EOB )
-				{
-				Match(input,BLOCK,Follow._BLOCK_in_block604); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				// Grammars\\CodeGenTreeWalker.g3:364:4: ( ^( OPTIONS ( . )* ) )?
-				int alt33=2;
-				int LA33_0 = input.LA(1);
-
-				if ( (LA33_0==OPTIONS) )
-				{
-					alt33=1;
-				}
-				switch ( alt33 )
-				{
-				case 1:
-					// Grammars\\CodeGenTreeWalker.g3:364:6: ^( OPTIONS ( . )* )
-					{
-					Match(input,OPTIONS,Follow._OPTIONS_in_block612); if (state.failed) return retval;
-
-					if ( input.LA(1)==TokenTypes.Down )
-					{
-						Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-						// Grammars\\CodeGenTreeWalker.g3:364:16: ( . )*
-						for ( ; ; )
-						{
-							int alt32=2;
-							int LA32_0 = input.LA(1);
-
-							if ( ((LA32_0>=ACTION && LA32_0<=XDIGIT)) )
-							{
-								alt32=1;
-							}
-							else if ( (LA32_0==UP) )
-							{
-								alt32=2;
-							}
-
-
-							switch ( alt32 )
-							{
-							case 1:
-								// Grammars\\CodeGenTreeWalker.g3:364:0: .
-								{
-								MatchAny(input); if (state.failed) return retval;
-
-								}
-								break;
-
-							default:
-								goto loop32;
-							}
-						}
-
-						loop32:
-							;
-
-
-
-						Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-					}
-
-					}
-					break;
-
-				}
-
-				// Grammars\\CodeGenTreeWalker.g3:365:4: (alt= alternative rew= rewrite )+
-				int cnt34=0;
-				for ( ; ; )
-				{
-					int alt34=2;
-					int LA34_0 = input.LA(1);
-
-					if ( (LA34_0==ALT) )
-					{
-						alt34=1;
-					}
-
-
-					switch ( alt34 )
-					{
-					case 1:
-						// Grammars\\CodeGenTreeWalker.g3:365:6: alt= alternative rew= rewrite
-						{
-						PushFollow(Follow._alternative_in_block629);
-						alt=alternative();
-
-						state._fsp--;
-						if (state.failed) return retval;
-						PushFollow(Follow._rewrite_in_block633);
-						rew=rewrite();
-
-						state._fsp--;
-						if (state.failed) return retval;
-						if ( state.backtracking == 0 )
-						{
-
-												if ( this.blockNestingLevel==RULE_BLOCK_NESTING_LEVEL )
-												{
-													this.outerAltNum++;
-												}
-												// add the rewrite code as just another element in the alt :)
-												// (unless it's a " -> ..." rewrite
-												// ( -> ... )
-												bool etc =
-													(rew!=null?((GrammarAST)rew.Start):null).Type==REWRITE &&
-													(rew!=null?((GrammarAST)rew.Start):null).GetChild(0)!=null &&
-													(rew!=null?((GrammarAST)rew.Start):null).GetChild(0).Type==ETC;
-												if ( (rew!=null?rew.code:default(StringTemplate))!=null && !etc )
-												{
-													(alt!=null?alt.code:default(StringTemplate)).SetAttribute("rew", (rew!=null?rew.code:default(StringTemplate)));
-												}
-												// add this alt to the list of alts for this block
-												retval.code.SetAttribute("alts",(alt!=null?alt.code:default(StringTemplate)));
-												(alt!=null?alt.code:default(StringTemplate)).SetAttribute("altNum", altNum);
-												(alt!=null?alt.code:default(StringTemplate)).SetAttribute("outerAlt", blockNestingLevel==RULE_BLOCK_NESTING_LEVEL);
-												altNum++;
-
-						}
-
-						}
-						break;
-
-					default:
-						if ( cnt34 >= 1 )
-							goto loop34;
-
-						if (state.backtracking>0) {state.failed=true; return retval;}
-						EarlyExitException eee34 = new EarlyExitException( 34, input );
-						throw eee34;
-					}
-					cnt34++;
-				}
-				loop34:
-					;
-
-
-				Match(input,EOB,Follow._EOB_in_block650); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-			 blockNestingLevel--;
-		}
-		return retval;
-	}
-	// $ANTLR end "block"
-
-	public class setBlock_return : TreeRuleReturnScope
-	{
-		public StringTemplate code=null;
-	}
-
-	// $ANTLR start "setBlock"
-	// Grammars\\CodeGenTreeWalker.g3:394:0: setBlock returns [StringTemplate code=null] : ^(s= BLOCK ( . )* ) ;
-	private CodeGenTreeWalker.setBlock_return setBlock(  )
-	{
-		CodeGenTreeWalker.setBlock_return retval = new CodeGenTreeWalker.setBlock_return();
-		retval.start = input.LT(1);
-
-		GrammarAST s=null;
-
-
-			StringTemplate setcode = null;
-			if ( state.backtracking == 0 )
-			{
-				if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL && grammar.BuildAST )
-				{
-					Rule r = grammar.GetRule(currentRuleName);
-					currentAltHasASTRewrite = r.HasRewrite(outerAltNum);
-					if ( currentAltHasASTRewrite )
-					{
-						r.TrackTokenReferenceInAlt(((GrammarAST)retval.Start), outerAltNum);
-					}
-				}
-			}
-
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:411:4: ( ^(s= BLOCK ( . )* ) )
-			// Grammars\\CodeGenTreeWalker.g3:411:4: ^(s= BLOCK ( . )* )
-			{
-			s=(GrammarAST)Match(input,BLOCK,Follow._BLOCK_in_setBlock682); if (state.failed) return retval;
-
-			if ( input.LA(1)==TokenTypes.Down )
-			{
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				// Grammars\\CodeGenTreeWalker.g3:411:14: ( . )*
-				for ( ; ; )
-				{
-					int alt36=2;
-					int LA36_0 = input.LA(1);
-
-					if ( ((LA36_0>=ACTION && LA36_0<=XDIGIT)) )
-					{
-						alt36=1;
-					}
-					else if ( (LA36_0==UP) )
-					{
-						alt36=2;
-					}
-
-
-					switch ( alt36 )
-					{
-					case 1:
-						// Grammars\\CodeGenTreeWalker.g3:411:0: .
-						{
-						MatchAny(input); if (state.failed) return retval;
-
-						}
-						break;
-
-					default:
-						goto loop36;
-					}
-				}
-
-				loop36:
-					;
-
-
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-			}
-			if ( state.backtracking == 0 )
-			{
-
-							int i = ((TokenWithIndex)s.Token).TokenIndex;
-							if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL )
-							{
-								setcode = GetTokenElementST("matchRuleBlockSet", "set", s, null, null);
-							}
-							else
-							{
-								setcode = GetTokenElementST("matchSet", "set", s, null, null);
-							}
-							setcode.SetAttribute("elementIndex", i);
-							if ( grammar.type!=GrammarType.Lexer )
-							{
-								generator.GenerateLocalFollow(s,"set",currentRuleName,i);
-							}
-							setcode.SetAttribute("s",
-								generator.GenSetExpr(templates,s.SetValue,1,false));
-							StringTemplate altcode=templates.GetInstanceOf("alt");
-							altcode.SetAttribute("elements.{el,line,pos}",
-												 setcode,
-												 s.Line,
-												 s.CharPositionInLine
-												);
-							altcode.SetAttribute("altNum", 1);
-							altcode.SetAttribute("outerAlt", blockNestingLevel==RULE_BLOCK_NESTING_LEVEL);
-							if ( !currentAltHasASTRewrite && grammar.BuildAST )
-							{
-								altcode.SetAttribute("autoAST", true);
-							}
-							altcode.SetAttribute("treeLevel", rewriteTreeNestingLevel);
-							retval.code = altcode;
-
-			}
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "setBlock"
-
-
-	// $ANTLR start "setAlternative"
-	// Grammars\\CodeGenTreeWalker.g3:446:0: setAlternative : ^( ALT ( setElement )+ EOA ) ;
-	private void setAlternative(  )
-	{
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:447:4: ( ^( ALT ( setElement )+ EOA ) )
-			// Grammars\\CodeGenTreeWalker.g3:447:4: ^( ALT ( setElement )+ EOA )
-			{
-			Match(input,ALT,Follow._ALT_in_setAlternative702); if (state.failed) return ;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return ;
-			// Grammars\\CodeGenTreeWalker.g3:447:10: ( setElement )+
-			int cnt37=0;
-			for ( ; ; )
-			{
-				int alt37=2;
-				int LA37_0 = input.LA(1);
-
-				if ( ((LA37_0>=CHAR_LITERAL && LA37_0<=CHAR_RANGE)||LA37_0==STRING_LITERAL||LA37_0==TOKEN_REF) )
-				{
-					alt37=1;
-				}
-
-
-				switch ( alt37 )
-				{
-				case 1:
-					// Grammars\\CodeGenTreeWalker.g3:447:0: setElement
-					{
-					PushFollow(Follow._setElement_in_setAlternative704);
-					setElement();
-
-					state._fsp--;
-					if (state.failed) return ;
-
-					}
-					break;
-
-				default:
-					if ( cnt37 >= 1 )
-						goto loop37;
-
-					if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee37 = new EarlyExitException( 37, input );
-					throw eee37;
-				}
-				cnt37++;
-			}
-			loop37:
-				;
-
-
-			Match(input,EOA,Follow._EOA_in_setAlternative707); if (state.failed) return ;
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "setAlternative"
-
-
-	// $ANTLR start "exceptionGroup"
-	// Grammars\\CodeGenTreeWalker.g3:450:0: exceptionGroup[StringTemplate ruleST] : ( ( exceptionHandler[$ruleST] )+ ( finallyClause[$ruleST] )? | finallyClause[$ruleST] );
-	private void exceptionGroup( StringTemplate ruleST )
-	{
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:451:4: ( ( exceptionHandler[$ruleST] )+ ( finallyClause[$ruleST] )? | finallyClause[$ruleST] )
-			int alt40=2;
-			int LA40_0 = input.LA(1);
-
-			if ( (LA40_0==CATCH) )
-			{
-				alt40=1;
-			}
-			else if ( (LA40_0==FINALLY) )
-			{
-				alt40=2;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				NoViableAltException nvae = new NoViableAltException("", 40, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt40 )
-			{
-			case 1:
-				// Grammars\\CodeGenTreeWalker.g3:451:4: ( exceptionHandler[$ruleST] )+ ( finallyClause[$ruleST] )?
-				{
-				// Grammars\\CodeGenTreeWalker.g3:451:4: ( exceptionHandler[$ruleST] )+
-				int cnt38=0;
-				for ( ; ; )
-				{
-					int alt38=2;
-					int LA38_0 = input.LA(1);
-
-					if ( (LA38_0==CATCH) )
-					{
-						alt38=1;
-					}
-
-
-					switch ( alt38 )
-					{
-					case 1:
-						// Grammars\\CodeGenTreeWalker.g3:451:6: exceptionHandler[$ruleST]
-						{
-						PushFollow(Follow._exceptionHandler_in_exceptionGroup722);
-						exceptionHandler(ruleST);
-
-						state._fsp--;
-						if (state.failed) return ;
-
-						}
-						break;
-
-					default:
-						if ( cnt38 >= 1 )
-							goto loop38;
-
-						if (state.backtracking>0) {state.failed=true; return ;}
-						EarlyExitException eee38 = new EarlyExitException( 38, input );
-						throw eee38;
-					}
-					cnt38++;
-				}
-				loop38:
-					;
-
-
-				// Grammars\\CodeGenTreeWalker.g3:451:35: ( finallyClause[$ruleST] )?
-				int alt39=2;
-				int LA39_0 = input.LA(1);
-
-				if ( (LA39_0==FINALLY) )
-				{
-					alt39=1;
-				}
-				switch ( alt39 )
-				{
-				case 1:
-					// Grammars\\CodeGenTreeWalker.g3:451:36: finallyClause[$ruleST]
-					{
-					PushFollow(Follow._finallyClause_in_exceptionGroup729);
-					finallyClause(ruleST);
-
-					state._fsp--;
-					if (state.failed) return ;
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-			case 2:
-				// Grammars\\CodeGenTreeWalker.g3:452:4: finallyClause[$ruleST]
-				{
-				PushFollow(Follow._finallyClause_in_exceptionGroup737);
-				finallyClause(ruleST);
-
-				state._fsp--;
-				if (state.failed) return ;
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "exceptionGroup"
-
-
-	// $ANTLR start "exceptionHandler"
-	// Grammars\\CodeGenTreeWalker.g3:455:0: exceptionHandler[StringTemplate ruleST] : ^( 'catch' ARG_ACTION ACTION ) ;
-	private void exceptionHandler( StringTemplate ruleST )
-	{
-		GrammarAST ACTION2=null;
-		GrammarAST ARG_ACTION3=null;
-
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:456:4: ( ^( 'catch' ARG_ACTION ACTION ) )
-			// Grammars\\CodeGenTreeWalker.g3:456:4: ^( 'catch' ARG_ACTION ACTION )
-			{
-			Match(input,CATCH,Follow._CATCH_in_exceptionHandler751); if (state.failed) return ;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return ;
-			ARG_ACTION3=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_exceptionHandler753); if (state.failed) return ;
-			ACTION2=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_exceptionHandler755); if (state.failed) return ;
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return ;
-			if ( state.backtracking == 0 )
-			{
-
-							List chunks = generator.TranslateAction(currentRuleName,ACTION2);
-							ruleST.SetAttribute("exceptions.{decl,action}",(ARG_ACTION3!=null?ARG_ACTION3.Text:null),chunks);
-
-			}
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "exceptionHandler"
-
-
-	// $ANTLR start "finallyClause"
-	// Grammars\\CodeGenTreeWalker.g3:463:0: finallyClause[StringTemplate ruleST] : ^( 'finally' ACTION ) ;
-	private void finallyClause( StringTemplate ruleST )
-	{
-		GrammarAST ACTION4=null;
-
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:464:4: ( ^( 'finally' ACTION ) )
-			// Grammars\\CodeGenTreeWalker.g3:464:4: ^( 'finally' ACTION )
-			{
-			Match(input,FINALLY,Follow._FINALLY_in_finallyClause773); if (state.failed) return ;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return ;
-			ACTION4=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_finallyClause775); if (state.failed) return ;
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return ;
-			if ( state.backtracking == 0 )
-			{
-
-							List chunks = generator.TranslateAction(currentRuleName,ACTION4);
-							ruleST.SetAttribute("finally",chunks);
-
-			}
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "finallyClause"
-
-	public class alternative_return : TreeRuleReturnScope
-	{
-		public StringTemplate code;
-	}
-
-	// $ANTLR start "alternative"
-	// Grammars\\CodeGenTreeWalker.g3:471:0: alternative returns [StringTemplate code] : ^(a= ALT (e= element[null,null] )+ EOA ) ;
-	private CodeGenTreeWalker.alternative_return alternative(  )
-	{
-		CodeGenTreeWalker.alternative_return retval = new CodeGenTreeWalker.alternative_return();
-		retval.start = input.LT(1);
-
-		GrammarAST a=null;
-		CodeGenTreeWalker.element_return e = default(CodeGenTreeWalker.element_return);
-
-
-			if ( state.backtracking == 0 )
-			{
-				retval.code = templates.GetInstanceOf("alt");
-				/*
-				// TODO: can we use Rule.altsWithRewrites???
-				if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL ) {
-					GrammarAST aRewriteNode = #alternative.findFirstType(REWRITE);
-					if ( grammar.buildAST() &&
-						 (aRewriteNode!=null||
-						 (#alternative.getNextSibling()!=null &&
-						  #alternative.getNextSibling().getType()==REWRITE)) )
-					{
-						currentAltHasASTRewrite = true;
-					}
-					else {
-						currentAltHasASTRewrite = false;
-					}
-				}
-				*/
-				if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL && grammar.BuildAST )
-				{
-					Rule r = grammar.GetRule(currentRuleName);
-					currentAltHasASTRewrite = r.HasRewrite(outerAltNum);
-				}
-				string description = grammar.GrammarTreeToString(((GrammarAST)retval.Start), false);
-				description = generator.target.GetTargetStringLiteralFromString(description);
-				retval.code.SetAttribute("description", description);
-				retval.code.SetAttribute("treeLevel", rewriteTreeNestingLevel);
-				if ( !currentAltHasASTRewrite && grammar.BuildAST )
-				{
-					retval.code.SetAttribute("autoAST", true);
-				}
-			}
-
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:508:4: ( ^(a= ALT (e= element[null,null] )+ EOA ) )
-			// Grammars\\CodeGenTreeWalker.g3:508:4: ^(a= ALT (e= element[null,null] )+ EOA )
-			{
-			a=(GrammarAST)Match(input,ALT,Follow._ALT_in_alternative804); if (state.failed) return retval;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-			// Grammars\\CodeGenTreeWalker.g3:509:4: (e= element[null,null] )+
-			int cnt41=0;
-			for ( ; ; )
-			{
-				int alt41=2;
-				int LA41_0 = input.LA(1);
-
-				if ( (LA41_0==ACTION||(LA41_0>=ASSIGN && LA41_0<=BLOCK)||(LA41_0>=CHAR_LITERAL && LA41_0<=CHAR_RANGE)||LA41_0==CLOSURE||LA41_0==DOT||LA41_0==EPSILON||LA41_0==FORCED_ACTION||LA41_0==GATED_SEMPRED||LA41_0==NOT||LA41_0==OPTIONAL||(LA41_0>=PLUS_ASSIGN && LA41_0<=POSITIVE_CLOSURE)||LA41_0==ROOT||LA41_0==RULE_REF||LA41_0==SEMPRED||(LA41_0>=STRING_LITERAL && LA41_0<=SYNPRED)||LA41_0==TOKEN_REF||LA41_0==TREE_BEGIN||LA41_0==WILDCARD) )
-				{
-					alt41=1;
-				}
-
-
-				switch ( alt41 )
-				{
-				case 1:
-					// Grammars\\CodeGenTreeWalker.g3:510:5: e= element[null,null]
-					{
-					PushFollow(Follow._element_in_alternative817);
-					e=element(null, null);
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 )
-					{
-
-											if ( e!=null )
-											{
-												retval.code.SetAttribute("elements.{el,line,pos}",
-																  (e!=null?e.code:default(StringTemplate)),
-																  (e!=null?((GrammarAST)e.Start):null).Line,
-																  (e!=null?((GrammarAST)e.Start):null).CharPositionInLine
-																 );
-											}
-
-					}
-
-					}
-					break;
-
-				default:
-					if ( cnt41 >= 1 )
-						goto loop41;
-
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					EarlyExitException eee41 = new EarlyExitException( 41, input );
-					throw eee41;
-				}
-				cnt41++;
-			}
-			loop41:
-				;
-
-
-			Match(input,EOA,Follow._EOA_in_alternative835); if (state.failed) return retval;
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "alternative"
-
-	public class element_return : TreeRuleReturnScope
-	{
-		public StringTemplate code=null;
-	}
-
-	// $ANTLR start "element"
-	// Grammars\\CodeGenTreeWalker.g3:526:0: element[GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null] options {k=1; } : ( ^( ROOT e= element[label,$ROOT] ) | ^( BANG e= element[label,$BANG] ) | ^(n= NOT notElement[$n, $label, $astSuffix] ) | ^( ASSIGN alabel= ID e= element[$alabel,$astSuffix] ) | ^( PLUS_ASSIGN label2= ID e= element[$label2,$astSuffix] ) | ^( CHAR_RANGE a= CHAR_LITERAL b= CHAR_LITERAL ) |=> ebnf | atom[null, $label, $astSuffix] | tree_ | element_action | (sp= SEMPRED |sp= GATED_SEMPRED ) | SYN_SEMPRED | ^( SYNPRED ( . )* ) | ^( BACKTRACK_SEMPRED ( . )* ) | EPSILON );
-	private CodeGenTreeWalker.element_return element( GrammarAST label, GrammarAST astSuffix )
-	{
-		CodeGenTreeWalker.element_return retval = new CodeGenTreeWalker.element_return();
-		retval.start = input.LT(1);
-
-		GrammarAST n=null;
-		GrammarAST alabel=null;
-		GrammarAST label2=null;
-		GrammarAST a=null;
-		GrammarAST b=null;
-		GrammarAST sp=null;
-		GrammarAST ROOT5=null;
-		GrammarAST BANG6=null;
-		CodeGenTreeWalker.element_return e = default(CodeGenTreeWalker.element_return);
-		StringTemplate notElement7 = default(StringTemplate);
-		CodeGenTreeWalker.ebnf_return ebnf8 = default(CodeGenTreeWalker.ebnf_return);
-		CodeGenTreeWalker.atom_return atom9 = default(CodeGenTreeWalker.atom_return);
-		CodeGenTreeWalker.tree__return tree_10 = default(CodeGenTreeWalker.tree__return);
-		CodeGenTreeWalker.element_action_return element_action11 = default(CodeGenTreeWalker.element_action_return);
-
-
-			IIntSet elements=null;
-			GrammarAST ast = null;
-
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:533:4: ( ^( ROOT e= element[label,$ROOT] ) | ^( BANG e= element[label,$BANG] ) | ^(n= NOT notElement[$n, $label, $astSuffix] ) | ^( ASSIGN alabel= ID e= element[$alabel,$astSuffix] ) | ^( PLUS_ASSIGN label2= ID e= element[$label2,$astSuffix] ) | ^( CHAR_RANGE a= CHAR_LITERAL b= CHAR_LITERAL ) |=> ebnf | atom[null, $label, $astSuffix] | tree_ | element_action | (sp= SEMPRED |sp= GATED_SEMPRED ) | SYN_SEMPRED | ^( SYNPRED ( . )* ) | ^( BACKTRACK_SEMPRED ( . )* ) | EPSILON )
-			int alt45=15;
-			alt45 = dfa45.Predict(input);
-			switch ( alt45 )
-			{
-			case 1:
-				// Grammars\\CodeGenTreeWalker.g3:533:4: ^( ROOT e= element[label,$ROOT] )
-				{
-				ROOT5=(GrammarAST)Match(input,ROOT,Follow._ROOT_in_element870); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				PushFollow(Follow._element_in_element874);
-				e=element(label, ROOT5);
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					 retval.code = (e!=null?e.code:default(StringTemplate));
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\CodeGenTreeWalker.g3:536:4: ^( BANG e= element[label,$BANG] )
-				{
-				BANG6=(GrammarAST)Match(input,BANG,Follow._BANG_in_element887); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				PushFollow(Follow._element_in_element891);
-				e=element(label, BANG6);
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					 retval.code = (e!=null?e.code:default(StringTemplate));
-				}
-
-				}
-				break;
-			case 3:
-				// Grammars\\CodeGenTreeWalker.g3:539:4: ^(n= NOT notElement[$n, $label, $astSuffix] )
-				{
-				n=(GrammarAST)Match(input,NOT,Follow._NOT_in_element907); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				PushFollow(Follow._notElement_in_element909);
-				notElement7=notElement(n, label, astSuffix);
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					 retval.code = notElement7;
-				}
-
-				}
-				break;
-			case 4:
-				// Grammars\\CodeGenTreeWalker.g3:542:4: ^( ASSIGN alabel= ID e= element[$alabel,$astSuffix] )
-				{
-				Match(input,ASSIGN,Follow._ASSIGN_in_element924); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				alabel=(GrammarAST)Match(input,ID,Follow._ID_in_element928); if (state.failed) return retval;
-				PushFollow(Follow._element_in_element932);
-				e=element(alabel, astSuffix);
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					 retval.code = (e!=null?e.code:default(StringTemplate));
-				}
-
-				}
-				break;
-			case 5:
-				// Grammars\\CodeGenTreeWalker.g3:545:4: ^( PLUS_ASSIGN label2= ID e= element[$label2,$astSuffix] )
-				{
-				Match(input,PLUS_ASSIGN,Follow._PLUS_ASSIGN_in_element947); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				label2=(GrammarAST)Match(input,ID,Follow._ID_in_element951); if (state.failed) return retval;
-				PushFollow(Follow._element_in_element955);
-				e=element(label2, astSuffix);
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					 retval.code = (e!=null?e.code:default(StringTemplate));
-				}
-
-				}
-				break;
-			case 6:
-				// Grammars\\CodeGenTreeWalker.g3:548:4: ^( CHAR_RANGE a= CHAR_LITERAL b= CHAR_LITERAL )
-				{
-				Match(input,CHAR_RANGE,Follow._CHAR_RANGE_in_element969); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				a=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_element973); if (state.failed) return retval;
-				b=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_element977); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-
-								retval.code = templates.GetInstanceOf("charRangeRef");
-								string low = generator.target.GetTargetCharLiteralFromANTLRCharLiteral(generator,(a!=null?a.Text:null));
-								string high = generator.target.GetTargetCharLiteralFromANTLRCharLiteral(generator,(b!=null?b.Text:null));
-								retval.code.SetAttribute("a", low);
-								retval.code.SetAttribute("b", high);
-								if ( label!=null )
-								{
-									retval.code.SetAttribute("label", label.Text);
-								}
-
-				}
-
-				}
-				break;
-			case 7:
-				// Grammars\\CodeGenTreeWalker.g3:561:4: => ebnf
-				{
-
-				PushFollow(Follow._ebnf_in_element1006);
-				ebnf8=ebnf();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					 retval.code = (ebnf8!=null?ebnf8.code:default(StringTemplate));
-				}
-
-				}
-				break;
-			case 8:
-				// Grammars\\CodeGenTreeWalker.g3:564:4: atom[null, $label, $astSuffix]
-				{
-				PushFollow(Follow._atom_in_element1016);
-				atom9=atom(null, label, astSuffix);
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					 retval.code = (atom9!=null?atom9.code:default(StringTemplate));
-				}
-
-				}
-				break;
-			case 9:
-				// Grammars\\CodeGenTreeWalker.g3:567:4: tree_
-				{
-				PushFollow(Follow._tree__in_element1027);
-				tree_10=tree_();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					 retval.code = (tree_10!=null?tree_10.code:default(StringTemplate));
-				}
-
-				}
-				break;
-			case 10:
-				// Grammars\\CodeGenTreeWalker.g3:570:4: element_action
-				{
-				PushFollow(Follow._element_action_in_element1037);
-				element_action11=element_action();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					 retval.code = (element_action11!=null?element_action11.code:default(StringTemplate));
-				}
-
-				}
-				break;
-			case 11:
-				// Grammars\\CodeGenTreeWalker.g3:573:6: (sp= SEMPRED |sp= GATED_SEMPRED )
-				{
-				// Grammars\\CodeGenTreeWalker.g3:573:6: (sp= SEMPRED |sp= GATED_SEMPRED )
-				int alt42=2;
-				int LA42_0 = input.LA(1);
-
-				if ( (LA42_0==SEMPRED) )
-				{
-					alt42=1;
-				}
-				else if ( (LA42_0==GATED_SEMPRED) )
-				{
-					alt42=2;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 42, 0, input);
-
-					throw nvae;
-				}
-				switch ( alt42 )
-				{
-				case 1:
-					// Grammars\\CodeGenTreeWalker.g3:573:7: sp= SEMPRED
-					{
-					sp=(GrammarAST)Match(input,SEMPRED,Follow._SEMPRED_in_element1052); if (state.failed) return retval;
-
-					}
-					break;
-				case 2:
-					// Grammars\\CodeGenTreeWalker.g3:573:18: sp= GATED_SEMPRED
-					{
-					sp=(GrammarAST)Match(input,GATED_SEMPRED,Follow._GATED_SEMPRED_in_element1056); if (state.failed) return retval;
-
-					}
-					break;
-
-				}
-
-				if ( state.backtracking == 0 )
-				{
-
-								retval.code = templates.GetInstanceOf("validateSemanticPredicate");
-								retval.code.SetAttribute("pred", generator.TranslateAction(currentRuleName,sp));
-								string description = generator.target.GetTargetStringLiteralFromString((sp!=null?sp.Text:null));
-								retval.code.SetAttribute("description", description);
-
-				}
-
-				}
-				break;
-			case 12:
-				// Grammars\\CodeGenTreeWalker.g3:581:4: SYN_SEMPRED
-				{
-				Match(input,SYN_SEMPRED,Follow._SYN_SEMPRED_in_element1067); if (state.failed) return retval;
-
-				}
-				break;
-			case 13:
-				// Grammars\\CodeGenTreeWalker.g3:583:4: ^( SYNPRED ( . )* )
-				{
-				Match(input,SYNPRED,Follow._SYNPRED_in_element1075); if (state.failed) return retval;
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-					// Grammars\\CodeGenTreeWalker.g3:583:14: ( . )*
-					for ( ; ; )
-					{
-						int alt43=2;
-						int LA43_0 = input.LA(1);
-
-						if ( ((LA43_0>=ACTION && LA43_0<=XDIGIT)) )
-						{
-							alt43=1;
-						}
-						else if ( (LA43_0==UP) )
-						{
-							alt43=2;
-						}
-
-
-						switch ( alt43 )
-						{
-						case 1:
-							// Grammars\\CodeGenTreeWalker.g3:583:0: .
-							{
-							MatchAny(input); if (state.failed) return retval;
-
-							}
-							break;
-
-						default:
-							goto loop43;
-						}
-					}
-
-					loop43:
-						;
-
-
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				}
-
-				}
-				break;
-			case 14:
-				// Grammars\\CodeGenTreeWalker.g3:585:4: ^( BACKTRACK_SEMPRED ( . )* )
-				{
-				Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_element1086); if (state.failed) return retval;
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-					// Grammars\\CodeGenTreeWalker.g3:585:24: ( . )*
-					for ( ; ; )
-					{
-						int alt44=2;
-						int LA44_0 = input.LA(1);
-
-						if ( ((LA44_0>=ACTION && LA44_0<=XDIGIT)) )
-						{
-							alt44=1;
-						}
-						else if ( (LA44_0==UP) )
-						{
-							alt44=2;
-						}
-
-
-						switch ( alt44 )
-						{
-						case 1:
-							// Grammars\\CodeGenTreeWalker.g3:585:0: .
-							{
-							MatchAny(input); if (state.failed) return retval;
-
-							}
-							break;
-
-						default:
-							goto loop44;
-						}
-					}
-
-					loop44:
-						;
-
-
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				}
-
-				}
-				break;
-			case 15:
-				// Grammars\\CodeGenTreeWalker.g3:587:6: EPSILON
-				{
-				Match(input,EPSILON,Follow._EPSILON_in_element1098); if (state.failed) return retval;
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "element"
-
-	public class element_action_return : TreeRuleReturnScope
-	{
-		public StringTemplate code=null;
-	}
-
-	// $ANTLR start "element_action"
-	// Grammars\\CodeGenTreeWalker.g3:590:0: element_action returns [StringTemplate code=null] : (act= ACTION |act2= FORCED_ACTION );
-	private CodeGenTreeWalker.element_action_return element_action(  )
-	{
-		CodeGenTreeWalker.element_action_return retval = new CodeGenTreeWalker.element_action_return();
-		retval.start = input.LT(1);
-
-		GrammarAST act=null;
-		GrammarAST act2=null;
-
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:591:4: (act= ACTION |act2= FORCED_ACTION )
-			int alt46=2;
-			int LA46_0 = input.LA(1);
-
-			if ( (LA46_0==ACTION) )
-			{
-				alt46=1;
-			}
-			else if ( (LA46_0==FORCED_ACTION) )
-			{
-				alt46=2;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return retval;}
-				NoViableAltException nvae = new NoViableAltException("", 46, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt46 )
-			{
-			case 1:
-				// Grammars\\CodeGenTreeWalker.g3:591:4: act= ACTION
-				{
-				act=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_element_action1115); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-
-								retval.code = templates.GetInstanceOf("execAction");
-								retval.code.SetAttribute("action", generator.TranslateAction(currentRuleName,act));
-
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\CodeGenTreeWalker.g3:596:4: act2= FORCED_ACTION
-				{
-				act2=(GrammarAST)Match(input,FORCED_ACTION,Follow._FORCED_ACTION_in_element_action1126); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-
-								retval.code = templates.GetInstanceOf("execForcedAction");
-								retval.code.SetAttribute("action", generator.TranslateAction(currentRuleName,act2));
-
-				}
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "element_action"
-
-
-	// $ANTLR start "notElement"
-	// Grammars\\CodeGenTreeWalker.g3:603:0: notElement[GrammarAST n, GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null] : (assign_c= CHAR_LITERAL |assign_s= STRING_LITERAL |assign_t= TOKEN_REF | ^(assign_st= BLOCK ( . )* ) ) ;
-	private StringTemplate notElement( GrammarAST n, GrammarAST label, GrammarAST astSuffix )
-	{
-		StringTemplate code = null;
-
-		GrammarAST assign_c=null;
-		GrammarAST assign_s=null;
-		GrammarAST assign_t=null;
-		GrammarAST assign_st=null;
-
-
-			IIntSet elements=null;
-			string labelText = null;
-			if ( label!=null )
-			{
-				labelText = label.Text;
-			}
-
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:613:4: ( (assign_c= CHAR_LITERAL |assign_s= STRING_LITERAL |assign_t= TOKEN_REF | ^(assign_st= BLOCK ( . )* ) ) )
-			// Grammars\\CodeGenTreeWalker.g3:613:4: (assign_c= CHAR_LITERAL |assign_s= STRING_LITERAL |assign_t= TOKEN_REF | ^(assign_st= BLOCK ( . )* ) )
-			{
-			// Grammars\\CodeGenTreeWalker.g3:613:4: (assign_c= CHAR_LITERAL |assign_s= STRING_LITERAL |assign_t= TOKEN_REF | ^(assign_st= BLOCK ( . )* ) )
-			int alt48=4;
-			switch ( input.LA(1) )
-			{
-			case CHAR_LITERAL:
-				{
-				alt48=1;
-				}
-				break;
-			case STRING_LITERAL:
-				{
-				alt48=2;
-				}
-				break;
-			case TOKEN_REF:
-				{
-				alt48=3;
-				}
-				break;
-			case BLOCK:
-				{
-				alt48=4;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return code;}
-					NoViableAltException nvae = new NoViableAltException("", 48, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt48 )
-			{
-			case 1:
-				// Grammars\\CodeGenTreeWalker.g3:613:6: assign_c= CHAR_LITERAL
-				{
-				assign_c=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_notElement1155); if (state.failed) return code;
-				if ( state.backtracking == 0 )
-				{
-
-									int ttype=0;
-									if ( grammar.type==GrammarType.Lexer )
-									{
-										ttype = Grammar.GetCharValueFromGrammarCharLiteral((assign_c!=null?assign_c.Text:null));
-									}
-									else
-									{
-										ttype = grammar.GetTokenType((assign_c!=null?assign_c.Text:null));
-									}
-									elements = grammar.Complement(ttype);
-
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\CodeGenTreeWalker.g3:626:5: assign_s= STRING_LITERAL
-				{
-				assign_s=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_notElement1168); if (state.failed) return code;
-				if ( state.backtracking == 0 )
-				{
-
-									int ttype=0;
-									if ( grammar.type==GrammarType.Lexer )
-									{
-										// TODO: error!
-									}
-									else
-									{
-										ttype = grammar.GetTokenType((assign_s!=null?assign_s.Text:null));
-									}
-									elements = grammar.Complement(ttype);
-
-				}
-
-				}
-				break;
-			case 3:
-				// Grammars\\CodeGenTreeWalker.g3:639:5: assign_t= TOKEN_REF
-				{
-				assign_t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_notElement1181); if (state.failed) return code;
-				if ( state.backtracking == 0 )
-				{
-
-									int ttype = grammar.GetTokenType((assign_t!=null?assign_t.Text:null));
-									elements = grammar.Complement(ttype);
-
-				}
-
-				}
-				break;
-			case 4:
-				// Grammars\\CodeGenTreeWalker.g3:644:5: ^(assign_st= BLOCK ( . )* )
-				{
-				assign_st=(GrammarAST)Match(input,BLOCK,Follow._BLOCK_in_notElement1195); if (state.failed) return code;
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null); if (state.failed) return code;
-					// Grammars\\CodeGenTreeWalker.g3:644:23: ( . )*
-					for ( ; ; )
-					{
-						int alt47=2;
-						int LA47_0 = input.LA(1);
-
-						if ( ((LA47_0>=ACTION && LA47_0<=XDIGIT)) )
-						{
-							alt47=1;
-						}
-						else if ( (LA47_0==UP) )
-						{
-							alt47=2;
-						}
-
-
-						switch ( alt47 )
-						{
-						case 1:
-							// Grammars\\CodeGenTreeWalker.g3:644:0: .
-							{
-							MatchAny(input); if (state.failed) return code;
-
-							}
-							break;
-
-						default:
-							goto loop47;
-						}
-					}
-
-					loop47:
-						;
-
-
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return code;
-				}
-				if ( state.backtracking == 0 )
-				{
-
-									elements = assign_st.SetValue;
-									elements = grammar.Complement(elements);
-
-				}
-
-				}
-				break;
-
-			}
-
-			if ( state.backtracking == 0 )
-			{
-
-							code = GetTokenElementST("matchSet",
-													 "set",
-													 (GrammarAST)n.GetChild(0),
-													 astSuffix,
-													 labelText);
-							code.SetAttribute("s",generator.GenSetExpr(templates,elements,1,false));
-							int i = ((TokenWithIndex)n.Token).TokenIndex;
-							code.SetAttribute("elementIndex", i);
-							if ( grammar.type!=GrammarType.Lexer )
-							{
-								generator.GenerateLocalFollow(n,"set",currentRuleName,i);
-							}
-
-			}
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return code;
-	}
-	// $ANTLR end "notElement"
-
-	public class ebnf_return : TreeRuleReturnScope
-	{
-		public StringTemplate code=null;
-	}
-
-	// $ANTLR start "ebnf"
-	// Grammars\\CodeGenTreeWalker.g3:666:0: ebnf returns [StringTemplate code=null] : (blk= block[\"block\", dfa] | ^( OPTIONAL blk= block[\"optionalBlock\", dfa] ) | ^( CLOSURE blk= block[\"closureBlock\", dfa] ) | ^( POSITIVE_CLOSURE blk= block[\"positiveClosureBlock\", dfa] ) ) ;
-	private CodeGenTreeWalker.ebnf_return ebnf(  )
-	{
-		CodeGenTreeWalker.ebnf_return retval = new CodeGenTreeWalker.ebnf_return();
-		retval.start = input.LT(1);
-
-		CodeGenTreeWalker.block_return blk = default(CodeGenTreeWalker.block_return);
-
-
-			Antlr3.Analysis.DFA dfa=null;
-			GrammarAST b = (GrammarAST)((GrammarAST)retval.Start).GetChild(0);
-			GrammarAST eob = (GrammarAST)b.LastChild; // loops will use EOB DFA
-
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:673:4: ( (blk= block[\"block\", dfa] | ^( OPTIONAL blk= block[\"optionalBlock\", dfa] ) | ^( CLOSURE blk= block[\"closureBlock\", dfa] ) | ^( POSITIVE_CLOSURE blk= block[\"positiveClosureBlock\", dfa] ) ) )
-			// Grammars\\CodeGenTreeWalker.g3:673:4: (blk= block[\"block\", dfa] | ^( OPTIONAL blk= block[\"optionalBlock\", dfa] ) | ^( CLOSURE blk= block[\"closureBlock\", dfa] ) | ^( POSITIVE_CLOSURE blk= block[\"positiveClosureBlock\", dfa] ) )
-			{
-			// Grammars\\CodeGenTreeWalker.g3:673:4: (blk= block[\"block\", dfa] | ^( OPTIONAL blk= block[\"optionalBlock\", dfa] ) | ^( CLOSURE blk= block[\"closureBlock\", dfa] ) | ^( POSITIVE_CLOSURE blk= block[\"positiveClosureBlock\", dfa] ) )
-			int alt49=4;
-			switch ( input.LA(1) )
-			{
-			case BLOCK:
-				{
-				alt49=1;
-				}
-				break;
-			case OPTIONAL:
-				{
-				alt49=2;
-				}
-				break;
-			case CLOSURE:
-				{
-				alt49=3;
-				}
-				break;
-			case POSITIVE_CLOSURE:
-				{
-				alt49=4;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 49, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt49 )
-			{
-			case 1:
-				// Grammars\\CodeGenTreeWalker.g3:673:6: blk= block[\"block\", dfa]
-				{
-				if ( state.backtracking == 0 )
-				{
-					 dfa = ((GrammarAST)retval.Start).LookaheadDFA;
-				}
-				PushFollow(Follow._block_in_ebnf1241);
-				blk=block("block", dfa);
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					 retval.code = (blk!=null?blk.code:default(StringTemplate));
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\CodeGenTreeWalker.g3:676:5: ^( OPTIONAL blk= block[\"optionalBlock\", dfa] )
-				{
-				if ( state.backtracking == 0 )
-				{
-					 dfa = ((GrammarAST)retval.Start).LookaheadDFA;
-				}
-				Match(input,OPTIONAL,Follow._OPTIONAL_in_ebnf1260); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				PushFollow(Follow._block_in_ebnf1264);
-				blk=block("optionalBlock", dfa);
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					 retval.code = (blk!=null?blk.code:default(StringTemplate));
-				}
-
-				}
-				break;
-			case 3:
-				// Grammars\\CodeGenTreeWalker.g3:679:5: ^( CLOSURE blk= block[\"closureBlock\", dfa] )
-				{
-				if ( state.backtracking == 0 )
-				{
-					 dfa = eob.LookaheadDFA;
-				}
-				Match(input,CLOSURE,Follow._CLOSURE_in_ebnf1285); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				PushFollow(Follow._block_in_ebnf1289);
-				blk=block("closureBlock", dfa);
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					 retval.code = (blk!=null?blk.code:default(StringTemplate));
-				}
-
-				}
-				break;
-			case 4:
-				// Grammars\\CodeGenTreeWalker.g3:682:5: ^( POSITIVE_CLOSURE blk= block[\"positiveClosureBlock\", dfa] )
-				{
-				if ( state.backtracking == 0 )
-				{
-					 dfa = eob.LookaheadDFA;
-				}
-				Match(input,POSITIVE_CLOSURE,Follow._POSITIVE_CLOSURE_in_ebnf1310); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				PushFollow(Follow._block_in_ebnf1314);
-				blk=block("positiveClosureBlock", dfa);
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					 retval.code = (blk!=null?blk.code:default(StringTemplate));
-				}
-
-				}
-				break;
-
-			}
-
-			if ( state.backtracking == 0 )
-			{
-
-							string description = grammar.GrammarTreeToString(((GrammarAST)retval.Start), false);
-							description = generator.target.GetTargetStringLiteralFromString(description);
-							retval.code.SetAttribute("description", description);
-
-			}
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "ebnf"
-
-	public class tree__return : TreeRuleReturnScope
-	{
-		public StringTemplate code;
-	}
-
-	// $ANTLR start "tree_"
-	// Grammars\\CodeGenTreeWalker.g3:693:0: tree_ returns [StringTemplate code] : ^( TREE_BEGIN el= element[null,rootSuffix] (=>act= element_action )* (el= element[null,null] )* ) ;
-	private CodeGenTreeWalker.tree__return tree_(  )
-	{
-		CodeGenTreeWalker.tree__return retval = new CodeGenTreeWalker.tree__return();
-		retval.start = input.LT(1);
-
-		CodeGenTreeWalker.element_return el = default(CodeGenTreeWalker.element_return);
-		CodeGenTreeWalker.element_action_return act = default(CodeGenTreeWalker.element_action_return);
-
-
-			rewriteTreeNestingLevel++;
-			GrammarAST rootSuffix = null;
-			if ( state.backtracking == 0 )
-			{
-				retval.code = templates.GetInstanceOf("tree");
-				NFAState afterDOWN = (NFAState)((GrammarAST)retval.Start).NFATreeDownState.GetTransition(0).target;
-				LookaheadSet s = grammar.Look(afterDOWN);
-				if ( s.Member(Label.UP) ) {
-					// nullable child list if we can see the UP as the next token
-					// we need an "if ( input.LA(1)==Token.DOWN )" gate around
-					// the child list.
-					retval.code.SetAttribute("nullableChildList", "true");
-				}
-				retval.code.SetAttribute("enclosingTreeLevel", rewriteTreeNestingLevel-1);
-				retval.code.SetAttribute("treeLevel", rewriteTreeNestingLevel);
-				Rule r = grammar.GetRule(currentRuleName);
-				if ( grammar.BuildAST && !r.HasRewrite(outerAltNum) ) {
-					rootSuffix = new GrammarAST(ROOT,"ROOT");
-				}
-			}
-
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:717:4: ( ^( TREE_BEGIN el= element[null,rootSuffix] (=>act= element_action )* (el= element[null,null] )* ) )
-			// Grammars\\CodeGenTreeWalker.g3:717:4: ^( TREE_BEGIN el= element[null,rootSuffix] (=>act= element_action )* (el= element[null,null] )* )
-			{
-			Match(input,TREE_BEGIN,Follow._TREE_BEGIN_in_tree_1352); if (state.failed) return retval;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-			PushFollow(Follow._element_in_tree_1359);
-			el=element(null, rootSuffix);
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 )
-			{
-
-								retval.code.SetAttribute("root.{el,line,pos}",
-												  (el!=null?el.code:default(StringTemplate)),
-												  (el!=null?((GrammarAST)el.Start):null).Line,
-												  (el!=null?((GrammarAST)el.Start):null).CharPositionInLine
-												  );
-
-			}
-			// Grammars\\CodeGenTreeWalker.g3:729:4: (=>act= element_action )*
-			for ( ; ; )
-			{
-				int alt50=2;
-				int LA50_0 = input.LA(1);
-
-				if ( (LA50_0==ACTION) )
-				{
-					int LA50_2 = input.LA(2);
-
-					if ( (EvaluatePredicate(synpred2_CodeGenTreeWalker_fragment)) )
-					{
-						alt50=1;
-					}
-
-
-				}
-				else if ( (LA50_0==FORCED_ACTION) )
-				{
-					int LA50_3 = input.LA(2);
-
-					if ( (EvaluatePredicate(synpred2_CodeGenTreeWalker_fragment)) )
-					{
-						alt50=1;
-					}
-
-
-				}
-
-
-				switch ( alt50 )
-				{
-				case 1:
-					// Grammars\\CodeGenTreeWalker.g3:729:6: =>act= element_action
-					{
-
-					PushFollow(Follow._element_action_in_tree_1396);
-					act=element_action();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 )
-					{
-
-											retval.code.SetAttribute("actionsAfterRoot.{el,line,pos}",
-															  (act!=null?act.code:default(StringTemplate)),
-															  (act!=null?((GrammarAST)act.Start):null).Line,
-															  (act!=null?((GrammarAST)act.Start):null).CharPositionInLine
-															);
-
-					}
-
-					}
-					break;
-
-				default:
-					goto loop50;
-				}
-			}
-
-			loop50:
-				;
-
-
-			// Grammars\\CodeGenTreeWalker.g3:739:4: (el= element[null,null] )*
-			for ( ; ; )
-			{
-				int alt51=2;
-				int LA51_0 = input.LA(1);
-
-				if ( (LA51_0==ACTION||(LA51_0>=ASSIGN && LA51_0<=BLOCK)||(LA51_0>=CHAR_LITERAL && LA51_0<=CHAR_RANGE)||LA51_0==CLOSURE||LA51_0==DOT||LA51_0==EPSILON||LA51_0==FORCED_ACTION||LA51_0==GATED_SEMPRED||LA51_0==NOT||LA51_0==OPTIONAL||(LA51_0>=PLUS_ASSIGN && LA51_0<=POSITIVE_CLOSURE)||LA51_0==ROOT||LA51_0==RULE_REF||LA51_0==SEMPRED||(LA51_0>=STRING_LITERAL && LA51_0<=SYNPRED)||LA51_0==TOKEN_REF||LA51_0==TREE_BEGIN||LA51_0==WILDCARD) )
-				{
-					alt51=1;
-				}
-
-
-				switch ( alt51 )
-				{
-				case 1:
-					// Grammars\\CodeGenTreeWalker.g3:739:7: el= element[null,null]
-					{
-					PushFollow(Follow._element_in_tree_1418);
-					el=element(null, null);
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 )
-					{
-
-										 retval.code.SetAttribute("children.{el,line,pos}",
-														  (el!=null?el.code:default(StringTemplate)),
-														  (el!=null?((GrammarAST)el.Start):null).Line,
-														  (el!=null?((GrammarAST)el.Start):null).CharPositionInLine
-														  );
-
-					}
-
-					}
-					break;
-
-				default:
-					goto loop51;
-				}
-			}
-
-			loop51:
-				;
-
-
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-			 rewriteTreeNestingLevel--;
-		}
-		return retval;
-	}
-	// $ANTLR end "tree_"
-
-	public class atom_return : TreeRuleReturnScope
-	{
-		public StringTemplate code=null;
-	}
-
-	// $ANTLR start "atom"
-	// Grammars\\CodeGenTreeWalker.g3:752:0: atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null] : ( ^(r= RULE_REF (rarg= ARG_ACTION )? ) | ^(t= TOKEN_REF (targ= ARG_ACTION )? ) |c= CHAR_LITERAL |s= STRING_LITERAL |w= WILDCARD | ^( DOT ID a= atom[$ID, label, astSuffix] ) | set[label,astSuffix] );
-	private CodeGenTreeWalker.atom_return atom( GrammarAST scope, GrammarAST label, GrammarAST astSuffix )
-	{
-		CodeGenTreeWalker.atom_return retval = new CodeGenTreeWalker.atom_return();
-		retval.start = input.LT(1);
-
-		GrammarAST r=null;
-		GrammarAST rarg=null;
-		GrammarAST t=null;
-		GrammarAST targ=null;
-		GrammarAST c=null;
-		GrammarAST s=null;
-		GrammarAST w=null;
-		GrammarAST ID12=null;
-		CodeGenTreeWalker.atom_return a = default(CodeGenTreeWalker.atom_return);
-		StringTemplate set13 = default(StringTemplate);
-
-
-			string labelText=null;
-			if ( state.backtracking == 0 )
-			{
-				if ( label!=null )
-				{
-					labelText = label.Text;
-				}
-				if ( grammar.type!=GrammarType.Lexer &&
-					 (((GrammarAST)retval.Start).Type==RULE_REF||((GrammarAST)retval.Start).Type==TOKEN_REF||
-					  ((GrammarAST)retval.Start).Type==CHAR_LITERAL||((GrammarAST)retval.Start).Type==STRING_LITERAL) )
-				{
-					Rule encRule = grammar.GetRule(((GrammarAST)((GrammarAST)retval.Start)).enclosingRuleName);
-					if ( encRule!=null && encRule.HasRewrite(outerAltNum) && astSuffix!=null )
-					{
-						ErrorManager.GrammarError(ErrorManager.MSG_AST_OP_IN_ALT_WITH_REWRITE,
-												  grammar,
-												  ((GrammarAST)((GrammarAST)retval.Start)).Token,
-												  ((GrammarAST)((GrammarAST)retval.Start)).enclosingRuleName,
-												  outerAltNum);
-						astSuffix = null;
-					}
-				}
-			}
-
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:780:6: ( ^(r= RULE_REF (rarg= ARG_ACTION )? ) | ^(t= TOKEN_REF (targ= ARG_ACTION )? ) |c= CHAR_LITERAL |s= STRING_LITERAL |w= WILDCARD | ^( DOT ID a= atom[$ID, label, astSuffix] ) | set[label,astSuffix] )
-			int alt54=7;
-			switch ( input.LA(1) )
-			{
-			case RULE_REF:
-				{
-				alt54=1;
-				}
-				break;
-			case TOKEN_REF:
-				{
-				alt54=2;
-				}
-				break;
-			case CHAR_LITERAL:
-				{
-				alt54=3;
-				}
-				break;
-			case STRING_LITERAL:
-				{
-				alt54=4;
-				}
-				break;
-			case WILDCARD:
-				{
-				alt54=5;
-				}
-				break;
-			case DOT:
-				{
-				alt54=6;
-				}
-				break;
-			case BLOCK:
-				{
-				alt54=7;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 54, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt54 )
-			{
-			case 1:
-				// Grammars\\CodeGenTreeWalker.g3:780:6: ^(r= RULE_REF (rarg= ARG_ACTION )? )
-				{
-				r=(GrammarAST)Match(input,RULE_REF,Follow._RULE_REF_in_atom1469); if (state.failed) return retval;
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-					// Grammars\\CodeGenTreeWalker.g3:780:20: (rarg= ARG_ACTION )?
-					int alt52=2;
-					int LA52_0 = input.LA(1);
-
-					if ( (LA52_0==ARG_ACTION) )
-					{
-						alt52=1;
-					}
-					switch ( alt52 )
-					{
-					case 1:
-						// Grammars\\CodeGenTreeWalker.g3:780:21: rarg= ARG_ACTION
-						{
-						rarg=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1474); if (state.failed) return retval;
-
-						}
-						break;
-
-					}
-
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				}
-				if ( state.backtracking == 0 )
-				{
-
-								grammar.CheckRuleReference(scope, r, rarg, currentRuleName);
-								string scopeName = null;
-								if ( scope!=null ) {
-									scopeName = scope.Text;
-								}
-								Rule rdef = grammar.GetRule(scopeName, (r!=null?r.Text:null));
-								// don't insert label=r() if label.attr not used, no ret value, ...
-								if ( !rdef.HasReturnValue ) {
-									labelText = null;
-								}
-								retval.code = GetRuleElementST("ruleRef", (r!=null?r.Text:null), r, astSuffix, labelText);
-								retval.code.SetAttribute("rule", rdef);
-								if ( scope!=null ) { // scoped rule ref
-									Grammar scopeG = grammar.composite.GetGrammar(scope.Text);
-									retval.code.SetAttribute("scope", scopeG);
-								}
-								else if ( rdef.grammar != this.grammar ) { // nonlocal
-									// if rule definition is not in this grammar, it's nonlocal
-									IList<Grammar> rdefDelegates = rdef.grammar.GetDelegates();
-									if ( rdefDelegates.Contains(this.grammar) ) {
-										retval.code.SetAttribute("scope", rdef.grammar);
-									}
-									else {
-										// defining grammar is not a delegate, scope all the
-										// back to root, which has delegate methods for all
-										// rules.  Don't use scope if we are root.
-										if ( this.grammar != rdef.grammar.composite.delegateGrammarTreeRoot.grammar ) {
-											retval.code.SetAttribute("scope",
-															  rdef.grammar.composite.delegateGrammarTreeRoot.grammar);
-										}
-									}
-								}
-
-								if ( rarg!=null ) {
-									List args = generator.TranslateAction(currentRuleName,rarg);
-									retval.code.SetAttribute("args", args);
-								}
-								int i = ((TokenWithIndex)r.Token).TokenIndex;
-								retval.code.SetAttribute("elementIndex", i);
-								generator.GenerateLocalFollow(r,(r!=null?r.Text:null),currentRuleName,i);
-								r.code = retval.code;
-
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\CodeGenTreeWalker.g3:825:4: ^(t= TOKEN_REF (targ= ARG_ACTION )? )
-				{
-				t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_atom1492); if (state.failed) return retval;
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-					// Grammars\\CodeGenTreeWalker.g3:825:19: (targ= ARG_ACTION )?
-					int alt53=2;
-					int LA53_0 = input.LA(1);
-
-					if ( (LA53_0==ARG_ACTION) )
-					{
-						alt53=1;
-					}
-					switch ( alt53 )
-					{
-					case 1:
-						// Grammars\\CodeGenTreeWalker.g3:825:20: targ= ARG_ACTION
-						{
-						targ=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1497); if (state.failed) return retval;
-
-						}
-						break;
-
-					}
-
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				}
-				if ( state.backtracking == 0 )
-				{
-
-								if ( currentAltHasASTRewrite && t.terminalOptions!=null &&
-									t.terminalOptions[Grammar.defaultTokenOption]!=null )
-								{
-									ErrorManager.GrammarError(ErrorManager.MSG_HETERO_ILLEGAL_IN_REWRITE_ALT,
-															grammar,
-															((GrammarAST)(t)).Token,
-															(t!=null?t.Text:null));
-								}
-								grammar.CheckRuleReference(scope, t, targ, currentRuleName);
-								if ( grammar.type==GrammarType.Lexer )
-								{
-									if ( grammar.GetTokenType((t!=null?t.Text:null))==Label.EOF )
-									{
-										retval.code = templates.GetInstanceOf("lexerMatchEOF");
-									}
-									else
-									{
-										retval.code = templates.GetInstanceOf("lexerRuleRef");
-										if ( IsListLabel(labelText) )
-										{
-											retval.code = templates.GetInstanceOf("lexerRuleRefAndListLabel");
-										}
-										string scopeName = null;
-										if ( scope!=null )
-										{
-											scopeName = scope.Text;
-										}
-										Rule rdef2 = grammar.GetRule(scopeName, (t!=null?t.Text:null));
-										retval.code.SetAttribute("rule", rdef2);
-										if ( scope!=null )
-										{ // scoped rule ref
-											Grammar scopeG = grammar.composite.GetGrammar(scope.Text);
-											retval.code.SetAttribute("scope", scopeG);
-										}
-										else if ( rdef2.grammar != this.grammar )
-										{ // nonlocal
-											// if rule definition is not in this grammar, it's nonlocal
-											retval.code.SetAttribute("scope", rdef2.grammar);
-										}
-										if ( targ!=null )
-										{
-											List args = generator.TranslateAction(currentRuleName,targ);
-											retval.code.SetAttribute("args", args);
-										}
-									}
-									int i = ((TokenWithIndex)t.Token).TokenIndex;
-									retval.code.SetAttribute("elementIndex", i);
-									if ( label!=null )
-										retval.code.SetAttribute("label", labelText);
-								}
-								else
-								{
-									retval.code = GetTokenElementST("tokenRef", (t!=null?t.Text:null), t, astSuffix, labelText);
-									string tokenLabel =
-										generator.GetTokenTypeAsTargetLabel(grammar.GetTokenType(t.Text));
-									retval.code.SetAttribute("token",tokenLabel);
-									if ( !currentAltHasASTRewrite && t.terminalOptions!=null )
-									{
-										retval.code.SetAttribute("hetero",t.terminalOptions[Grammar.defaultTokenOption]);
-									}
-									int i = ((TokenWithIndex)t.Token).TokenIndex;
-									retval.code.SetAttribute("elementIndex", i);
-									generator.GenerateLocalFollow(t,tokenLabel,currentRuleName,i);
-								}
-								t.code = retval.code;
-
-				}
-
-				}
-				break;
-			case 3:
-				// Grammars\\CodeGenTreeWalker.g3:894:4: c= CHAR_LITERAL
-				{
-				c=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_atom1513); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-
-								if ( grammar.type==GrammarType.Lexer )
-								{
-									retval.code = templates.GetInstanceOf("charRef");
-									retval.code.SetAttribute("char",
-									   generator.target.GetTargetCharLiteralFromANTLRCharLiteral(generator,(c!=null?c.Text:null)));
-									if ( label!=null )
-									{
-										retval.code.SetAttribute("label", labelText);
-									}
-								}
-								else { // else it's a token type reference
-									retval.code = GetTokenElementST("tokenRef", "char_literal", c, astSuffix, labelText);
-									string tokenLabel = generator.GetTokenTypeAsTargetLabel(grammar.GetTokenType((c!=null?c.Text:null)));
-									retval.code.SetAttribute("token",tokenLabel);
-									if ( c.terminalOptions!=null ) {
-										retval.code.SetAttribute("hetero",c.terminalOptions[Grammar.defaultTokenOption]);
-									}
-									int i = ((TokenWithIndex)c.Token).TokenIndex;
-									retval.code.SetAttribute("elementIndex", i);
-									generator.GenerateLocalFollow(c,tokenLabel,currentRuleName,i);
-								}
-
-				}
-
-				}
-				break;
-			case 4:
-				// Grammars\\CodeGenTreeWalker.g3:919:4: s= STRING_LITERAL
-				{
-				s=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_atom1526); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-
-								if ( grammar.type==GrammarType.Lexer )
-								{
-									retval.code = templates.GetInstanceOf("lexerStringRef");
-									retval.code.SetAttribute("string",
-										generator.target.GetTargetStringLiteralFromANTLRStringLiteral(generator,(s!=null?s.Text:null)));
-									if ( label!=null )
-									{
-										retval.code.SetAttribute("label", labelText);
-									}
-								}
-								else
-								{ // else it's a token type reference
-									retval.code = GetTokenElementST("tokenRef", "string_literal", s, astSuffix, labelText);
-									string tokenLabel =
-										generator.GetTokenTypeAsTargetLabel(grammar.GetTokenType((s!=null?s.Text:null)));
-									retval.code.SetAttribute("token",tokenLabel);
-									if ( s.terminalOptions!=null )
-									{
-										retval.code.SetAttribute("hetero",s.terminalOptions[Grammar.defaultTokenOption]);
-									}
-									int i = ((TokenWithIndex)s.Token).TokenIndex;
-									retval.code.SetAttribute("elementIndex", i);
-									generator.GenerateLocalFollow(s,tokenLabel,currentRuleName,i);
-								}
-
-				}
-
-				}
-				break;
-			case 5:
-				// Grammars\\CodeGenTreeWalker.g3:947:4: w= WILDCARD
-				{
-				w=(GrammarAST)Match(input,WILDCARD,Follow._WILDCARD_in_atom1538); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-
-								retval.code = GetWildcardST(w,astSuffix,labelText);
-								retval.code.SetAttribute("elementIndex", ((TokenWithIndex)w.Token).TokenIndex);
-
-				}
-
-				}
-				break;
-			case 6:
-				// Grammars\\CodeGenTreeWalker.g3:953:4: ^( DOT ID a= atom[$ID, label, astSuffix] )
-				{
-				Match(input,DOT,Follow._DOT_in_atom1549); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				ID12=(GrammarAST)Match(input,ID,Follow._ID_in_atom1551); if (state.failed) return retval;
-				PushFollow(Follow._atom_in_atom1555);
-				a=atom(ID12, label, astSuffix);
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					 retval.code = (a!=null?a.code:default(StringTemplate));
-				}
-
-				}
-				break;
-			case 7:
-				// Grammars\\CodeGenTreeWalker.g3:956:4: set[label,astSuffix]
-				{
-				PushFollow(Follow._set_in_atom1568);
-				set13=set(label, astSuffix);
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					 retval.code = set13;
-				}
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "atom"
-
-
-	// $ANTLR start "ast_suffix"
-	// Grammars\\CodeGenTreeWalker.g3:960:0: ast_suffix : ( ROOT | BANG );
-	private void ast_suffix(  )
-	{
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:961:4: ( ROOT | BANG )
-			// Grammars\\CodeGenTreeWalker.g3:
-			{
-			if ( input.LA(1)==BANG||input.LA(1)==ROOT )
-			{
-				input.Consume();
-				state.errorRecovery=false;state.failed=false;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				MismatchedSetException mse = new MismatchedSetException(null,input);
-				throw mse;
-			}
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "ast_suffix"
-
-
-	// $ANTLR start "set"
-	// Grammars\\CodeGenTreeWalker.g3:965:0: set[GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null] : ^(s= BLOCK ( . )* ) ;
-	private StringTemplate set( GrammarAST label, GrammarAST astSuffix )
-	{
-		StringTemplate code = null;
-
-		GrammarAST s=null;
-
-
-			string labelText=null;
-			if ( label!=null )
-			{
-				labelText = label.Text;
-			}
-
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:974:4: ( ^(s= BLOCK ( . )* ) )
-			// Grammars\\CodeGenTreeWalker.g3:974:4: ^(s= BLOCK ( . )* )
-			{
-			s=(GrammarAST)Match(input,BLOCK,Follow._BLOCK_in_set1613); if (state.failed) return code;
-
-			if ( input.LA(1)==TokenTypes.Down )
-			{
-				Match(input, TokenTypes.Down, null); if (state.failed) return code;
-				// Grammars\\CodeGenTreeWalker.g3:974:14: ( . )*
-				for ( ; ; )
-				{
-					int alt55=2;
-					int LA55_0 = input.LA(1);
-
-					if ( ((LA55_0>=ACTION && LA55_0<=XDIGIT)) )
-					{
-						alt55=1;
-					}
-					else if ( (LA55_0==UP) )
-					{
-						alt55=2;
-					}
-
-
-					switch ( alt55 )
-					{
-					case 1:
-						// Grammars\\CodeGenTreeWalker.g3:974:0: .
-						{
-						MatchAny(input); if (state.failed) return code;
-
-						}
-						break;
-
-					default:
-						goto loop55;
-					}
-				}
-
-				loop55:
-					;
-
-
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return code;
-			}
-			if ( state.backtracking == 0 )
-			{
-
-							code = GetTokenElementST("matchSet", "set", s, astSuffix, labelText);
-							int i = ((TokenWithIndex)s.Token).TokenIndex;
-							code.SetAttribute("elementIndex", i);
-							if ( grammar.type!=GrammarType.Lexer )
-							{
-								generator.GenerateLocalFollow(s,"set",currentRuleName,i);
-							}
-							code.SetAttribute("s", generator.GenSetExpr(templates,s.SetValue,1,false));
-
-			}
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return code;
-	}
-	// $ANTLR end "set"
-
-
-	// $ANTLR start "setElement"
-	// Grammars\\CodeGenTreeWalker.g3:987:0: setElement : ( CHAR_LITERAL | TOKEN_REF | STRING_LITERAL | ^( CHAR_RANGE CHAR_LITERAL CHAR_LITERAL ) );
-	private void setElement(  )
-	{
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:988:4: ( CHAR_LITERAL | TOKEN_REF | STRING_LITERAL | ^( CHAR_RANGE CHAR_LITERAL CHAR_LITERAL ) )
-			int alt56=4;
-			switch ( input.LA(1) )
-			{
-			case CHAR_LITERAL:
-				{
-				alt56=1;
-				}
-				break;
-			case TOKEN_REF:
-				{
-				alt56=2;
-				}
-				break;
-			case STRING_LITERAL:
-				{
-				alt56=3;
-				}
-				break;
-			case CHAR_RANGE:
-				{
-				alt56=4;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					NoViableAltException nvae = new NoViableAltException("", 56, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt56 )
-			{
-			case 1:
-				// Grammars\\CodeGenTreeWalker.g3:988:4: CHAR_LITERAL
-				{
-				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_setElement1633); if (state.failed) return ;
-
-				}
-				break;
-			case 2:
-				// Grammars\\CodeGenTreeWalker.g3:989:4: TOKEN_REF
-				{
-				Match(input,TOKEN_REF,Follow._TOKEN_REF_in_setElement1638); if (state.failed) return ;
-
-				}
-				break;
-			case 3:
-				// Grammars\\CodeGenTreeWalker.g3:990:4: STRING_LITERAL
-				{
-				Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_setElement1643); if (state.failed) return ;
-
-				}
-				break;
-			case 4:
-				// Grammars\\CodeGenTreeWalker.g3:991:4: ^( CHAR_RANGE CHAR_LITERAL CHAR_LITERAL )
-				{
-				Match(input,CHAR_RANGE,Follow._CHAR_RANGE_in_setElement1649); if (state.failed) return ;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return ;
-				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_setElement1651); if (state.failed) return ;
-				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_setElement1653); if (state.failed) return ;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "setElement"
-
-	public class rewrite_return : TreeRuleReturnScope
-	{
-		public StringTemplate code=null;
-	}
-
-	// $ANTLR start "rewrite"
-	// Grammars\\CodeGenTreeWalker.g3:996:0: rewrite returns [StringTemplate code=null] : ( ^(r= REWRITE (pred= SEMPRED )? alt= rewrite_alternative ) )* ;
-	private CodeGenTreeWalker.rewrite_return rewrite(  )
-	{
-		CodeGenTreeWalker.rewrite_return retval = new CodeGenTreeWalker.rewrite_return();
-		retval.start = input.LT(1);
-
-		GrammarAST r=null;
-		GrammarAST pred=null;
-		StringTemplate alt = default(StringTemplate);
-
-
-			if ( state.backtracking == 0 )
-			{
-				if ( ((GrammarAST)retval.Start).Type==REWRITE )
-				{
-					if ( generator.grammar.BuildTemplate )
-					{
-						retval.code = templates.GetInstanceOf("rewriteTemplate");
-					}
-					else
-					{
-						retval.code = templates.GetInstanceOf("rewriteCode");
-						retval.code.SetAttribute("treeLevel", OUTER_REWRITE_NESTING_LEVEL);
-						retval.code.SetAttribute("rewriteBlockLevel", OUTER_REWRITE_NESTING_LEVEL);
-						retval.code.SetAttribute("referencedElementsDeep",
-										  GetTokenTypesAsTargetLabels(((GrammarAST)retval.Start).rewriteRefsDeep));
-						HashSet<string> tokenLabels =
-							grammar.GetLabels(((GrammarAST)retval.Start).rewriteRefsDeep, LabelType.Token);
-						HashSet<string> tokenListLabels =
-							grammar.GetLabels(((GrammarAST)retval.Start).rewriteRefsDeep, LabelType.TokenList);
-						HashSet<string> ruleLabels =
-							grammar.GetLabels(((GrammarAST)retval.Start).rewriteRefsDeep, LabelType.Rule);
-						HashSet<string> ruleListLabels =
-							grammar.GetLabels(((GrammarAST)retval.Start).rewriteRefsDeep, LabelType.RuleList);
-						HashSet<string> wildcardLabels =
-							grammar.GetLabels(((GrammarAST)retval.Start).rewriteRefsDeep, LabelType.WildcardTree);
-						HashSet<string> wildcardListLabels =
-							grammar.GetLabels(((GrammarAST)retval.Start).rewriteRefsDeep, LabelType.WildcardTreeList);
-						// just in case they ref r for "previous value", make a stream
-						// from retval.tree
-						StringTemplate retvalST = templates.GetInstanceOf("prevRuleRootRef");
-						ruleLabels.Add(retvalST.ToString());
-						retval.code.SetAttribute("referencedTokenLabels", tokenLabels);
-						retval.code.SetAttribute("referencedTokenListLabels", tokenListLabels);
-						retval.code.SetAttribute("referencedRuleLabels", ruleLabels);
-						retval.code.SetAttribute("referencedRuleListLabels", ruleListLabels);
-						retval.code.SetAttribute("referencedWildcardLabels", wildcardLabels);
-						retval.code.SetAttribute("referencedWildcardListLabels", wildcardListLabels);
-					}
-				}
-				else
-				{
-						retval.code = templates.GetInstanceOf("noRewrite");
-						retval.code.SetAttribute("treeLevel", OUTER_REWRITE_NESTING_LEVEL);
-						retval.code.SetAttribute("rewriteBlockLevel", OUTER_REWRITE_NESTING_LEVEL);
-				}
-			}
-
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:1046:4: ( ( ^(r= REWRITE (pred= SEMPRED )? alt= rewrite_alternative ) )* )
-			// Grammars\\CodeGenTreeWalker.g3:1046:4: ( ^(r= REWRITE (pred= SEMPRED )? alt= rewrite_alternative ) )*
-			{
-			// Grammars\\CodeGenTreeWalker.g3:1046:4: ( ^(r= REWRITE (pred= SEMPRED )? alt= rewrite_alternative ) )*
-			for ( ; ; )
-			{
-				int alt58=2;
-				int LA58_0 = input.LA(1);
-
-				if ( (LA58_0==REWRITE) )
-				{
-					alt58=1;
-				}
-
-
-				switch ( alt58 )
-				{
-				case 1:
-					// Grammars\\CodeGenTreeWalker.g3:1047:4: ^(r= REWRITE (pred= SEMPRED )? alt= rewrite_alternative )
-					{
-					if ( state.backtracking == 0 )
-					{
-						rewriteRuleRefs = new HashSet<object>();
-					}
-					r=(GrammarAST)Match(input,REWRITE,Follow._REWRITE_in_rewrite1690); if (state.failed) return retval;
-
-					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-					// Grammars\\CodeGenTreeWalker.g3:1048:17: (pred= SEMPRED )?
-					int alt57=2;
-					int LA57_0 = input.LA(1);
-
-					if ( (LA57_0==SEMPRED) )
-					{
-						alt57=1;
-					}
-					switch ( alt57 )
-					{
-					case 1:
-						// Grammars\\CodeGenTreeWalker.g3:1048:18: pred= SEMPRED
-						{
-						pred=(GrammarAST)Match(input,SEMPRED,Follow._SEMPRED_in_rewrite1695); if (state.failed) return retval;
-
-						}
-						break;
-
-					}
-
-					PushFollow(Follow._rewrite_alternative_in_rewrite1701);
-					alt=rewrite_alternative();
-
-					state._fsp--;
-					if (state.failed) return retval;
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-					if ( state.backtracking == 0 )
-					{
-
-										rewriteBlockNestingLevel = OUTER_REWRITE_NESTING_LEVEL;
-										List predChunks = null;
-										if ( pred!=null )
-										{
-											//predText = #pred.getText();
-											predChunks = generator.TranslateAction(currentRuleName,pred);
-										}
-										string description =
-											grammar.GrammarTreeToString(r,false);
-										description = generator.target.GetTargetStringLiteralFromString(description);
-										retval.code.SetAttribute("alts.{pred,alt,description}",
-														  predChunks,
-														  alt,
-														  description);
-										pred=null;
-
-					}
-
-					}
-					break;
-
-				default:
-					goto loop58;
-				}
-			}
-
-			loop58:
-				;
-
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "rewrite"
-
-
-	// $ANTLR start "rewrite_block"
-	// Grammars\\CodeGenTreeWalker.g3:1069:0: rewrite_block[string blockTemplateName] returns [StringTemplate code=null] : ^( BLOCK alt= rewrite_alternative EOB ) ;
-	private StringTemplate rewrite_block( string blockTemplateName )
-	{
-		StringTemplate code = null;
-
-		GrammarAST BLOCK14=null;
-		StringTemplate alt = default(StringTemplate);
-
-
-			rewriteBlockNestingLevel++;
-			StringTemplate save_currentBlockST = currentBlockST;
-			if ( state.backtracking == 0 )
-			{
-				code = templates.GetInstanceOf(blockTemplateName);
-				currentBlockST = code;
-				code.SetAttribute("rewriteBlockLevel", rewriteBlockNestingLevel);
-			}
-
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:1081:4: ( ^( BLOCK alt= rewrite_alternative EOB ) )
-			// Grammars\\CodeGenTreeWalker.g3:1081:4: ^( BLOCK alt= rewrite_alternative EOB )
-			{
-			BLOCK14=(GrammarAST)Match(input,BLOCK,Follow._BLOCK_in_rewrite_block1736); if (state.failed) return code;
-
-			if ( state.backtracking == 0 )
-			{
-
-								currentBlockST.SetAttribute("referencedElementsDeep",
-									GetTokenTypesAsTargetLabels(BLOCK14.rewriteRefsDeep));
-								currentBlockST.SetAttribute("referencedElements",
-									GetTokenTypesAsTargetLabels(BLOCK14.rewriteRefsShallow));
-
-			}
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return code;
-			PushFollow(Follow._rewrite_alternative_in_rewrite_block1748);
-			alt=rewrite_alternative();
-
-			state._fsp--;
-			if (state.failed) return code;
-			Match(input,EOB,Follow._EOB_in_rewrite_block1753); if (state.failed) return code;
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return code;
-			if ( state.backtracking == 0 )
-			{
-
-							code.SetAttribute("alt", alt);
-
-			}
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-			 rewriteBlockNestingLevel--; currentBlockST = save_currentBlockST;
-		}
-		return code;
-	}
-	// $ANTLR end "rewrite_block"
-
-
-	// $ANTLR start "rewrite_alternative"
-	// Grammars\\CodeGenTreeWalker.g3:1097:0: rewrite_alternative returns [StringTemplate code=null] : ({...}? ^(a= ALT ( (el= rewrite_element )+ | EPSILON ) EOA ) |{...}? rewrite_template | ETC );
-	private StringTemplate rewrite_alternative(  )
-	{
-		StringTemplate code = null;
-
-		GrammarAST a=null;
-		CodeGenTreeWalker.rewrite_element_return el = default(CodeGenTreeWalker.rewrite_element_return);
-		StringTemplate rewrite_template15 = default(StringTemplate);
-
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:1098:4: ({...}? ^(a= ALT ( (el= rewrite_element )+ | EPSILON ) EOA ) |{...}? rewrite_template | ETC )
-			int alt61=3;
-			switch ( input.LA(1) )
-			{
-			case ALT:
-				{
-				int LA61_1 = input.LA(2);
-
-				if ( (LA61_1==DOWN) )
-				{
-					int LA61_4 = input.LA(3);
-
-					if ( (LA61_4==EPSILON) )
-					{
-						int LA61_5 = input.LA(4);
-
-						if ( (LA61_5==EOA) )
-						{
-							int LA61_7 = input.LA(5);
-
-							if ( (LA61_7==UP) )
-							{
-								int LA61_8 = input.LA(6);
-
-								if ( ((generator.grammar.BuildAST)) )
-								{
-									alt61=1;
-								}
-								else if ( ((generator.grammar.BuildTemplate)) )
-								{
-									alt61=2;
-								}
-								else
-								{
-									if (state.backtracking>0) {state.failed=true; return code;}
-									NoViableAltException nvae = new NoViableAltException("", 61, 8, input);
-
-									throw nvae;
-								}
-							}
-							else
-							{
-								if (state.backtracking>0) {state.failed=true; return code;}
-								NoViableAltException nvae = new NoViableAltException("", 61, 7, input);
-
-								throw nvae;
-							}
-						}
-						else
-						{
-							if (state.backtracking>0) {state.failed=true; return code;}
-							NoViableAltException nvae = new NoViableAltException("", 61, 5, input);
-
-							throw nvae;
-						}
-					}
-					else if ( (LA61_4==ACTION||LA61_4==CHAR_LITERAL||LA61_4==CLOSURE||LA61_4==LABEL||LA61_4==OPTIONAL||LA61_4==POSITIVE_CLOSURE||LA61_4==RULE_REF||LA61_4==STRING_LITERAL||LA61_4==TOKEN_REF||LA61_4==TREE_BEGIN) )
-					{
-						alt61=1;
-					}
-					else
-					{
-						if (state.backtracking>0) {state.failed=true; return code;}
-						NoViableAltException nvae = new NoViableAltException("", 61, 4, input);
-
-						throw nvae;
-					}
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return code;}
-					NoViableAltException nvae = new NoViableAltException("", 61, 1, input);
-
-					throw nvae;
-				}
-				}
-				break;
-			case ACTION:
-			case TEMPLATE:
-				{
-				alt61=2;
-				}
-				break;
-			case ETC:
-				{
-				alt61=3;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return code;}
-					NoViableAltException nvae = new NoViableAltException("", 61, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt61 )
-			{
-			case 1:
-				// Grammars\\CodeGenTreeWalker.g3:1098:4: {...}? ^(a= ALT ( (el= rewrite_element )+ | EPSILON ) EOA )
-				{
-				if ( !((generator.grammar.BuildAST)) )
-				{
-					if (state.backtracking>0) {state.failed=true; return code;}
-					throw new FailedPredicateException(input, "rewrite_alternative", "generator.grammar.BuildAST");
-				}
-				a=(GrammarAST)Match(input,ALT,Follow._ALT_in_rewrite_alternative1788); if (state.failed) return code;
-
-				if ( state.backtracking == 0 )
-				{
-					code =templates.GetInstanceOf("rewriteElementList");
-				}
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return code;
-				// Grammars\\CodeGenTreeWalker.g3:1100:4: ( (el= rewrite_element )+ | EPSILON )
-				int alt60=2;
-				int LA60_0 = input.LA(1);
-
-				if ( (LA60_0==ACTION||LA60_0==CHAR_LITERAL||LA60_0==CLOSURE||LA60_0==LABEL||LA60_0==OPTIONAL||LA60_0==POSITIVE_CLOSURE||LA60_0==RULE_REF||LA60_0==STRING_LITERAL||LA60_0==TOKEN_REF||LA60_0==TREE_BEGIN) )
-				{
-					alt60=1;
-				}
-				else if ( (LA60_0==EPSILON) )
-				{
-					alt60=2;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return code;}
-					NoViableAltException nvae = new NoViableAltException("", 60, 0, input);
-
-					throw nvae;
-				}
-				switch ( alt60 )
-				{
-				case 1:
-					// Grammars\\CodeGenTreeWalker.g3:1100:6: (el= rewrite_element )+
-					{
-					// Grammars\\CodeGenTreeWalker.g3:1100:6: (el= rewrite_element )+
-					int cnt59=0;
-					for ( ; ; )
-					{
-						int alt59=2;
-						int LA59_0 = input.LA(1);
-
-						if ( (LA59_0==ACTION||LA59_0==CHAR_LITERAL||LA59_0==CLOSURE||LA59_0==LABEL||LA59_0==OPTIONAL||LA59_0==POSITIVE_CLOSURE||LA59_0==RULE_REF||LA59_0==STRING_LITERAL||LA59_0==TOKEN_REF||LA59_0==TREE_BEGIN) )
-						{
-							alt59=1;
-						}
-
-
-						switch ( alt59 )
-						{
-						case 1:
-							// Grammars\\CodeGenTreeWalker.g3:1101:6: el= rewrite_element
-							{
-							PushFollow(Follow._rewrite_element_in_rewrite_alternative1806);
-							el=rewrite_element();
-
-							state._fsp--;
-							if (state.failed) return code;
-							if ( state.backtracking == 0 )
-							{
-								code.SetAttribute("elements.{el,line,pos}",
-																		(el!=null?el.code:default(StringTemplate)),
-																		(el!=null?((GrammarAST)el.Start):null).Line,
-																		(el!=null?((GrammarAST)el.Start):null).CharPositionInLine
-																		);
-
-							}
-
-							}
-							break;
-
-						default:
-							if ( cnt59 >= 1 )
-								goto loop59;
-
-							if (state.backtracking>0) {state.failed=true; return code;}
-							EarlyExitException eee59 = new EarlyExitException( 59, input );
-							throw eee59;
-						}
-						cnt59++;
-					}
-					loop59:
-						;
-
-
-
-					}
-					break;
-				case 2:
-					// Grammars\\CodeGenTreeWalker.g3:1109:6: EPSILON
-					{
-					Match(input,EPSILON,Follow._EPSILON_in_rewrite_alternative1827); if (state.failed) return code;
-					if ( state.backtracking == 0 )
-					{
-						code.SetAttribute("elements.{el,line,pos}",
-														   templates.GetInstanceOf("rewriteEmptyAlt"),
-														   a.Line,
-														   a.CharPositionInLine
-														   );
-
-					}
-
-					}
-					break;
-
-				}
-
-				Match(input,EOA,Follow._EOA_in_rewrite_alternative1843); if (state.failed) return code;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return code;
-
-				}
-				break;
-			case 2:
-				// Grammars\\CodeGenTreeWalker.g3:1120:4: {...}? rewrite_template
-				{
-				if ( !((generator.grammar.BuildTemplate)) )
-				{
-					if (state.backtracking>0) {state.failed=true; return code;}
-					throw new FailedPredicateException(input, "rewrite_alternative", "generator.grammar.BuildTemplate");
-				}
-				PushFollow(Follow._rewrite_template_in_rewrite_alternative1856);
-				rewrite_template15=rewrite_template();
-
-				state._fsp--;
-				if (state.failed) return code;
-				if ( state.backtracking == 0 )
-				{
-					 code = rewrite_template15;
-				}
-
-				}
-				break;
-			case 3:
-				// Grammars\\CodeGenTreeWalker.g3:1124:3: ETC
-				{
-				Match(input,ETC,Follow._ETC_in_rewrite_alternative1869); if (state.failed) return code;
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return code;
-	}
-	// $ANTLR end "rewrite_alternative"
-
-	public class rewrite_element_return : TreeRuleReturnScope
-	{
-		public StringTemplate code=null;
-	}
-
-	// $ANTLR start "rewrite_element"
-	// Grammars\\CodeGenTreeWalker.g3:1127:0: rewrite_element returns [StringTemplate code=null] : ( rewrite_atom[false] | rewrite_ebnf | rewrite_tree );
-	private CodeGenTreeWalker.rewrite_element_return rewrite_element(  )
-	{
-		CodeGenTreeWalker.rewrite_element_return retval = new CodeGenTreeWalker.rewrite_element_return();
-		retval.start = input.LT(1);
-
-		CodeGenTreeWalker.rewrite_atom_return rewrite_atom16 = default(CodeGenTreeWalker.rewrite_atom_return);
-		CodeGenTreeWalker.rewrite_ebnf_return rewrite_ebnf17 = default(CodeGenTreeWalker.rewrite_ebnf_return);
-		CodeGenTreeWalker.rewrite_tree_return rewrite_tree18 = default(CodeGenTreeWalker.rewrite_tree_return);
-
-
-			IIntSet elements=null;
-			GrammarAST ast = null;
-
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:1133:4: ( rewrite_atom[false] | rewrite_ebnf | rewrite_tree )
-			int alt62=3;
-			switch ( input.LA(1) )
-			{
-			case ACTION:
-			case CHAR_LITERAL:
-			case LABEL:
-			case RULE_REF:
-			case STRING_LITERAL:
-			case TOKEN_REF:
-				{
-				alt62=1;
-				}
-				break;
-			case CLOSURE:
-			case OPTIONAL:
-			case POSITIVE_CLOSURE:
-				{
-				alt62=2;
-				}
-				break;
-			case TREE_BEGIN:
-				{
-				alt62=3;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 62, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt62 )
-			{
-			case 1:
-				// Grammars\\CodeGenTreeWalker.g3:1133:4: rewrite_atom[false]
-				{
-				PushFollow(Follow._rewrite_atom_in_rewrite_element1889);
-				rewrite_atom16=rewrite_atom(false);
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					 retval.code = (rewrite_atom16!=null?rewrite_atom16.code:default(StringTemplate));
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\CodeGenTreeWalker.g3:1135:4: rewrite_ebnf
-				{
-				PushFollow(Follow._rewrite_ebnf_in_rewrite_element1899);
-				rewrite_ebnf17=rewrite_ebnf();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					 retval.code = (rewrite_ebnf17!=null?rewrite_ebnf17.code:default(StringTemplate));
-				}
-
-				}
-				break;
-			case 3:
-				// Grammars\\CodeGenTreeWalker.g3:1137:4: rewrite_tree
-				{
-				PushFollow(Follow._rewrite_tree_in_rewrite_element1908);
-				rewrite_tree18=rewrite_tree();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					 retval.code = (rewrite_tree18!=null?rewrite_tree18.code:default(StringTemplate));
-				}
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "rewrite_element"
-
-	public class rewrite_ebnf_return : TreeRuleReturnScope
-	{
-		public StringTemplate code=null;
-	}
-
-	// $ANTLR start "rewrite_ebnf"
-	// Grammars\\CodeGenTreeWalker.g3:1141:0: rewrite_ebnf returns [StringTemplate code=null] : ( ^( OPTIONAL rewrite_block[\"rewriteOptionalBlock\"] ) | ^( CLOSURE rewrite_block[\"rewriteClosureBlock\"] ) | ^( POSITIVE_CLOSURE rewrite_block[\"rewritePositiveClosureBlock\"] ) );
-	private CodeGenTreeWalker.rewrite_ebnf_return rewrite_ebnf(  )
-	{
-		CodeGenTreeWalker.rewrite_ebnf_return retval = new CodeGenTreeWalker.rewrite_ebnf_return();
-		retval.start = input.LT(1);
-
-		StringTemplate rewrite_block19 = default(StringTemplate);
-		StringTemplate rewrite_block20 = default(StringTemplate);
-		StringTemplate rewrite_block21 = default(StringTemplate);
-
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:1142:4: ( ^( OPTIONAL rewrite_block[\"rewriteOptionalBlock\"] ) | ^( CLOSURE rewrite_block[\"rewriteClosureBlock\"] ) | ^( POSITIVE_CLOSURE rewrite_block[\"rewritePositiveClosureBlock\"] ) )
-			int alt63=3;
-			switch ( input.LA(1) )
-			{
-			case OPTIONAL:
-				{
-				alt63=1;
-				}
-				break;
-			case CLOSURE:
-				{
-				alt63=2;
-				}
-				break;
-			case POSITIVE_CLOSURE:
-				{
-				alt63=3;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 63, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt63 )
-			{
-			case 1:
-				// Grammars\\CodeGenTreeWalker.g3:1142:4: ^( OPTIONAL rewrite_block[\"rewriteOptionalBlock\"] )
-				{
-				Match(input,OPTIONAL,Follow._OPTIONAL_in_rewrite_ebnf1929); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				PushFollow(Follow._rewrite_block_in_rewrite_ebnf1931);
-				rewrite_block19=rewrite_block("rewriteOptionalBlock");
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					 retval.code = rewrite_block19;
-				}
-				if ( state.backtracking == 0 )
-				{
-
-								string description = grammar.GrammarTreeToString(((GrammarAST)retval.Start), false);
-								description = generator.target.GetTargetStringLiteralFromString(description);
-								retval.code.SetAttribute("description", description);
-
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\CodeGenTreeWalker.g3:1149:4: ^( CLOSURE rewrite_block[\"rewriteClosureBlock\"] )
-				{
-				Match(input,CLOSURE,Follow._CLOSURE_in_rewrite_ebnf1949); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				PushFollow(Follow._rewrite_block_in_rewrite_ebnf1951);
-				rewrite_block20=rewrite_block("rewriteClosureBlock");
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					 retval.code = rewrite_block20;
-				}
-				if ( state.backtracking == 0 )
-				{
-
-								string description = grammar.GrammarTreeToString(((GrammarAST)retval.Start), false);
-								description = generator.target.GetTargetStringLiteralFromString(description);
-								retval.code.SetAttribute("description", description);
-
-				}
-
-				}
-				break;
-			case 3:
-				// Grammars\\CodeGenTreeWalker.g3:1156:4: ^( POSITIVE_CLOSURE rewrite_block[\"rewritePositiveClosureBlock\"] )
-				{
-				Match(input,POSITIVE_CLOSURE,Follow._POSITIVE_CLOSURE_in_rewrite_ebnf1969); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				PushFollow(Follow._rewrite_block_in_rewrite_ebnf1971);
-				rewrite_block21=rewrite_block("rewritePositiveClosureBlock");
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					 retval.code = rewrite_block21;
-				}
-				if ( state.backtracking == 0 )
-				{
-
-								string description = grammar.GrammarTreeToString(((GrammarAST)retval.Start), false);
-								description = generator.target.GetTargetStringLiteralFromString(description);
-								retval.code.SetAttribute("description", description);
-
-				}
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "rewrite_ebnf"
-
-	public class rewrite_tree_return : TreeRuleReturnScope
-	{
-		public StringTemplate code;
-	}
-
-	// $ANTLR start "rewrite_tree"
-	// Grammars\\CodeGenTreeWalker.g3:1165:0: rewrite_tree returns [StringTemplate code] : ^( TREE_BEGIN r= rewrite_atom[true] (el= rewrite_element )* ) ;
-	private CodeGenTreeWalker.rewrite_tree_return rewrite_tree(  )
-	{
-		CodeGenTreeWalker.rewrite_tree_return retval = new CodeGenTreeWalker.rewrite_tree_return();
-		retval.start = input.LT(1);
-
-		CodeGenTreeWalker.rewrite_atom_return r = default(CodeGenTreeWalker.rewrite_atom_return);
-		CodeGenTreeWalker.rewrite_element_return el = default(CodeGenTreeWalker.rewrite_element_return);
-
-
-			rewriteTreeNestingLevel++;
-			if ( state.backtracking == 0 )
-			{
-				retval.code = templates.GetInstanceOf("rewriteTree");
-				retval.code.SetAttribute("treeLevel", rewriteTreeNestingLevel);
-				retval.code.SetAttribute("enclosingTreeLevel", rewriteTreeNestingLevel-1);
-			}
-
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:1176:4: ( ^( TREE_BEGIN r= rewrite_atom[true] (el= rewrite_element )* ) )
-			// Grammars\\CodeGenTreeWalker.g3:1176:4: ^( TREE_BEGIN r= rewrite_atom[true] (el= rewrite_element )* )
-			{
-			Match(input,TREE_BEGIN,Follow._TREE_BEGIN_in_rewrite_tree2004); if (state.failed) return retval;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-			PushFollow(Follow._rewrite_atom_in_rewrite_tree2011);
-			r=rewrite_atom(true);
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 )
-			{
-
-								retval.code.SetAttribute("root.{el,line,pos}",
-												   (r!=null?r.code:default(StringTemplate)),
-												   (r!=null?((GrammarAST)r.Start):null).Line,
-												   (r!=null?((GrammarAST)r.Start):null).CharPositionInLine
-												  );
-
-			}
-			// Grammars\\CodeGenTreeWalker.g3:1185:4: (el= rewrite_element )*
-			for ( ; ; )
-			{
-				int alt64=2;
-				int LA64_0 = input.LA(1);
-
-				if ( (LA64_0==ACTION||LA64_0==CHAR_LITERAL||LA64_0==CLOSURE||LA64_0==LABEL||LA64_0==OPTIONAL||LA64_0==POSITIVE_CLOSURE||LA64_0==RULE_REF||LA64_0==STRING_LITERAL||LA64_0==TOKEN_REF||LA64_0==TREE_BEGIN) )
-				{
-					alt64=1;
-				}
-
-
-				switch ( alt64 )
-				{
-				case 1:
-					// Grammars\\CodeGenTreeWalker.g3:1186:6: el= rewrite_element
-					{
-					PushFollow(Follow._rewrite_element_in_rewrite_tree2031);
-					el=rewrite_element();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 )
-					{
-
-										retval.code.SetAttribute("children.{el,line,pos}",
-															(el!=null?el.code:default(StringTemplate)),
-															(el!=null?((GrammarAST)el.Start):null).Line,
-															(el!=null?((GrammarAST)el.Start):null).CharPositionInLine
-															);
-
-					}
-
-					}
-					break;
-
-				default:
-					goto loop64;
-				}
-			}
-
-			loop64:
-				;
-
-
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-			if ( state.backtracking == 0 )
-			{
-
-							string description = grammar.GrammarTreeToString(((GrammarAST)retval.Start), false);
-							description = generator.target.GetTargetStringLiteralFromString(description);
-							retval.code.SetAttribute("description", description);
-
-			}
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-			 rewriteTreeNestingLevel--;
-		}
-		return retval;
-	}
-	// $ANTLR end "rewrite_tree"
-
-	public class rewrite_atom_return : TreeRuleReturnScope
-	{
-		public StringTemplate code=null;
-	}
-
-	// $ANTLR start "rewrite_atom"
-	// Grammars\\CodeGenTreeWalker.g3:1204:0: rewrite_atom[bool isRoot] returns [StringTemplate code=null] : (r= RULE_REF | ( ^(tk= TOKEN_REF (arg= ARG_ACTION )? ) |cl= CHAR_LITERAL |sl= STRING_LITERAL ) | LABEL | ACTION );
-	private CodeGenTreeWalker.rewrite_atom_return rewrite_atom( bool isRoot )
-	{
-		CodeGenTreeWalker.rewrite_atom_return retval = new CodeGenTreeWalker.rewrite_atom_return();
-		retval.start = input.LT(1);
-
-		GrammarAST r=null;
-		GrammarAST tk=null;
-		GrammarAST arg=null;
-		GrammarAST cl=null;
-		GrammarAST sl=null;
-		GrammarAST LABEL22=null;
-		GrammarAST ACTION23=null;
-
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:1205:6: (r= RULE_REF | ( ^(tk= TOKEN_REF (arg= ARG_ACTION )? ) |cl= CHAR_LITERAL |sl= STRING_LITERAL ) | LABEL | ACTION )
-			int alt67=4;
-			switch ( input.LA(1) )
-			{
-			case RULE_REF:
-				{
-				alt67=1;
-				}
-				break;
-			case CHAR_LITERAL:
-			case STRING_LITERAL:
-			case TOKEN_REF:
-				{
-				alt67=2;
-				}
-				break;
-			case LABEL:
-				{
-				alt67=3;
-				}
-				break;
-			case ACTION:
-				{
-				alt67=4;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 67, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt67 )
-			{
-			case 1:
-				// Grammars\\CodeGenTreeWalker.g3:1205:6: r= RULE_REF
-				{
-				r=(GrammarAST)Match(input,RULE_REF,Follow._RULE_REF_in_rewrite_atom2076); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-
-								string ruleRefName = (r!=null?r.Text:null);
-								string stName = "rewriteRuleRef";
-								if ( isRoot )
-								{
-									stName += "Root";
-								}
-								retval.code = templates.GetInstanceOf(stName);
-								retval.code.SetAttribute("rule", ruleRefName);
-								if ( grammar.GetRule(ruleRefName)==null )
-								{
-									ErrorManager.GrammarError(ErrorManager.MSG_UNDEFINED_RULE_REF,
-															  grammar,
-															  ((GrammarAST)(r)).Token,
-															  ruleRefName);
-									retval.code = new StringTemplate(); // blank; no code gen
-								}
-								else if ( grammar.GetRule(currentRuleName)
-											 .GetRuleRefsInAlt(ruleRefName,outerAltNum)==null )
-								{
-									ErrorManager.GrammarError(ErrorManager.MSG_REWRITE_ELEMENT_NOT_PRESENT_ON_LHS,
-															  grammar,
-															  ((GrammarAST)(r)).Token,
-															  ruleRefName);
-									retval.code = new StringTemplate(); // blank; no code gen
-								}
-								else
-								{
-									// track all rule refs as we must copy 2nd ref to rule and beyond
-									if ( !rewriteRuleRefs.Contains(ruleRefName) )
-									{
-										rewriteRuleRefs.Add(ruleRefName);
-									}
-								}
-
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\CodeGenTreeWalker.g3:1243:3: ( ^(tk= TOKEN_REF (arg= ARG_ACTION )? ) |cl= CHAR_LITERAL |sl= STRING_LITERAL )
-				{
-				// Grammars\\CodeGenTreeWalker.g3:1243:3: ( ^(tk= TOKEN_REF (arg= ARG_ACTION )? ) |cl= CHAR_LITERAL |sl= STRING_LITERAL )
-				int alt66=3;
-				switch ( input.LA(1) )
-				{
-				case TOKEN_REF:
-					{
-					alt66=1;
-					}
-					break;
-				case CHAR_LITERAL:
-					{
-					alt66=2;
-					}
-					break;
-				case STRING_LITERAL:
-					{
-					alt66=3;
-					}
-					break;
-				default:
-					{
-						if (state.backtracking>0) {state.failed=true; return retval;}
-						NoViableAltException nvae = new NoViableAltException("", 66, 0, input);
-
-						throw nvae;
-					}
-				}
-
-				switch ( alt66 )
-				{
-				case 1:
-					// Grammars\\CodeGenTreeWalker.g3:1243:5: ^(tk= TOKEN_REF (arg= ARG_ACTION )? )
-					{
-					tk=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_rewrite_atom2093); if (state.failed) return retval;
-
-					if ( input.LA(1)==TokenTypes.Down )
-					{
-						Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-						// Grammars\\CodeGenTreeWalker.g3:1243:20: (arg= ARG_ACTION )?
-						int alt65=2;
-						int LA65_0 = input.LA(1);
-
-						if ( (LA65_0==ARG_ACTION) )
-						{
-							alt65=1;
-						}
-						switch ( alt65 )
-						{
-						case 1:
-							// Grammars\\CodeGenTreeWalker.g3:1243:21: arg= ARG_ACTION
-							{
-							arg=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rewrite_atom2098); if (state.failed) return retval;
-
-							}
-							break;
-
-						}
-
-
-						Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-					}
-
-					}
-					break;
-				case 2:
-					// Grammars\\CodeGenTreeWalker.g3:1244:5: cl= CHAR_LITERAL
-					{
-					cl=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_rewrite_atom2109); if (state.failed) return retval;
-
-					}
-					break;
-				case 3:
-					// Grammars\\CodeGenTreeWalker.g3:1245:5: sl= STRING_LITERAL
-					{
-					sl=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_rewrite_atom2117); if (state.failed) return retval;
-
-					}
-					break;
-
-				}
-
-				if ( state.backtracking == 0 )
-				{
-
-								GrammarAST term = (tk) ?? (cl) ?? (sl);
-								string tokenName = ((GrammarAST)retval.Start).Token.Text;
-								string stName = "rewriteTokenRef";
-								Rule rule = grammar.GetRule(currentRuleName);
-								ICollection<string> tokenRefsInAlt = rule.GetTokenRefsInAlt(outerAltNum);
-								bool createNewNode = !tokenRefsInAlt.Contains(tokenName) || arg!=null;
-								object hetero = null;
-								if ( term.terminalOptions!=null )
-								{
-									hetero = term.terminalOptions[Grammar.defaultTokenOption];
-								}
-								if ( createNewNode )
-								{
-									stName = "rewriteImaginaryTokenRef";
-								}
-								if ( isRoot )
-								{
-									stName += "Root";
-								}
-								retval.code = templates.GetInstanceOf(stName);
-								retval.code.SetAttribute("hetero", hetero);
-								if ( arg!=null )
-								{
-									List args = generator.TranslateAction(currentRuleName,arg);
-									retval.code.SetAttribute("args", args);
-								}
-								retval.code.SetAttribute("elementIndex", ((TokenWithIndex)((GrammarAST)retval.Start).Token).TokenIndex);
-								int ttype = grammar.GetTokenType(tokenName);
-								string tok = generator.GetTokenTypeAsTargetLabel(ttype);
-								retval.code.SetAttribute("token", tok);
-								if ( grammar.GetTokenType(tokenName)==Label.INVALID )
-								{
-									ErrorManager.GrammarError(ErrorManager.MSG_UNDEFINED_TOKEN_REF_IN_REWRITE,
-															  grammar,
-															  ((GrammarAST)(((GrammarAST)retval.Start))).Token,
-															  tokenName);
-									retval.code = new StringTemplate(); // blank; no code gen
-								}
-
-				}
-
-				}
-				break;
-			case 3:
-				// Grammars\\CodeGenTreeWalker.g3:1288:4: LABEL
-				{
-				LABEL22=(GrammarAST)Match(input,LABEL,Follow._LABEL_in_rewrite_atom2131); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-
-								string labelName = (LABEL22!=null?LABEL22.Text:null);
-								Rule rule = grammar.GetRule(currentRuleName);
-								Grammar.LabelElementPair pair = rule.GetLabel(labelName);
-								if ( labelName.Equals(currentRuleName) )
-								{
-									// special case; ref to old value via $ rule
-									if ( rule.HasRewrite(outerAltNum) &&
-										 rule.GetRuleRefsInAlt(outerAltNum).Contains(labelName) )
-									{
-										ErrorManager.GrammarError(ErrorManager.MSG_RULE_REF_AMBIG_WITH_RULE_IN_ALT,
-																  grammar,
-																  ((GrammarAST)(LABEL22)).Token,
-																  labelName);
-									}
-									StringTemplate labelST = templates.GetInstanceOf("prevRuleRootRef");
-									retval.code = templates.GetInstanceOf("rewriteRuleLabelRef"+(isRoot?"Root":""));
-									retval.code.SetAttribute("label", labelST);
-								}
-								else if ( pair==null )
-								{
-									ErrorManager.GrammarError(ErrorManager.MSG_UNDEFINED_LABEL_REF_IN_REWRITE,
-															  grammar,
-															  ((GrammarAST)(LABEL22)).Token,
-															  labelName);
-									retval.code = new StringTemplate();
-								}
-								else
-								{
-									string stName = null;
-									switch ( pair.type )
-									{
-									case LabelType.Token :
-										stName = "rewriteTokenLabelRef";
-										break;
-									case LabelType.WildcardTree :
-										stName = "rewriteWildcardLabelRef";
-										break;
-									case LabelType.WildcardTreeList:
-										stName = "rewriteRuleListLabelRef"; // acts like rule ref list for ref
-										break;
-									case LabelType.Rule :
-										stName = "rewriteRuleLabelRef";
-										break;
-									case LabelType.TokenList :
-										stName = "rewriteTokenListLabelRef";
-										break;
-									case LabelType.RuleList :
-										stName = "rewriteRuleListLabelRef";
-										break;
-									}
-									if ( isRoot )
-									{
-										stName += "Root";
-									}
-									retval.code = templates.GetInstanceOf(stName);
-									retval.code.SetAttribute("label", labelName);
-								}
-
-				}
-
-				}
-				break;
-			case 4:
-				// Grammars\\CodeGenTreeWalker.g3:1349:4: ACTION
-				{
-				ACTION23=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_rewrite_atom2141); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-
-								// actions in rewrite rules yield a tree object
-								string actText = (ACTION23!=null?ACTION23.Text:null);
-								List chunks = generator.TranslateAction(currentRuleName,ACTION23);
-								retval.code = templates.GetInstanceOf("rewriteNodeAction"+(isRoot?"Root":""));
-								retval.code.SetAttribute("action", chunks);
-
-				}
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "rewrite_atom"
-
-
-	// $ANTLR start "rewrite_template"
-	// Grammars\\CodeGenTreeWalker.g3:1360:0: public rewrite_template returns [StringTemplate code=null] : ( ^( ALT EPSILON EOA ) | ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? ) |act= ACTION );
-	public StringTemplate rewrite_template(  )
-	{
-		StringTemplate code = null;
-
-		GrammarAST id=null;
-		GrammarAST ind=null;
-		GrammarAST arg=null;
-		GrammarAST a=null;
-		GrammarAST act=null;
-		GrammarAST DOUBLE_QUOTE_STRING_LITERAL24=null;
-		GrammarAST DOUBLE_ANGLE_STRING_LITERAL25=null;
-
-		try
-		{
-			// Grammars\\CodeGenTreeWalker.g3:1361:4: ( ^( ALT EPSILON EOA ) | ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? ) |act= ACTION )
-			int alt71=3;
-			switch ( input.LA(1) )
-			{
-			case ALT:
-				{
-				alt71=1;
-				}
-				break;
-			case TEMPLATE:
-				{
-				alt71=2;
-				}
-				break;
-			case ACTION:
-				{
-				alt71=3;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return code;}
-					NoViableAltException nvae = new NoViableAltException("", 71, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt71 )
-			{
-			case 1:
-				// Grammars\\CodeGenTreeWalker.g3:1361:4: ^( ALT EPSILON EOA )
-				{
-				Match(input,ALT,Follow._ALT_in_rewrite_template2164); if (state.failed) return code;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return code;
-				Match(input,EPSILON,Follow._EPSILON_in_rewrite_template2166); if (state.failed) return code;
-				Match(input,EOA,Follow._EOA_in_rewrite_template2168); if (state.failed) return code;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return code;
-				if ( state.backtracking == 0 )
-				{
-					code =templates.GetInstanceOf("rewriteEmptyTemplate");
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\CodeGenTreeWalker.g3:1362:4: ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? )
-				{
-				Match(input,TEMPLATE,Follow._TEMPLATE_in_rewrite_template2179); if (state.failed) return code;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return code;
-				// Grammars\\CodeGenTreeWalker.g3:1362:16: (id= ID |ind= ACTION )
-				int alt68=2;
-				int LA68_0 = input.LA(1);
-
-				if ( (LA68_0==ID) )
-				{
-					alt68=1;
-				}
-				else if ( (LA68_0==ACTION) )
-				{
-					alt68=2;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return code;}
-					NoViableAltException nvae = new NoViableAltException("", 68, 0, input);
-
-					throw nvae;
-				}
-				switch ( alt68 )
-				{
-				case 1:
-					// Grammars\\CodeGenTreeWalker.g3:1362:17: id= ID
-					{
-					id=(GrammarAST)Match(input,ID,Follow._ID_in_rewrite_template2184); if (state.failed) return code;
-
-					}
-					break;
-				case 2:
-					// Grammars\\CodeGenTreeWalker.g3:1362:23: ind= ACTION
-					{
-					ind=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_rewrite_template2188); if (state.failed) return code;
-
-					}
-					break;
-
-				}
-
-				if ( state.backtracking == 0 )
-				{
-
-									if ( id!=null && (id!=null?id.Text:null).Equals("template") )
-									{
-											code = templates.GetInstanceOf("rewriteInlineTemplate");
-									}
-									else if ( id!=null )
-									{
-											code = templates.GetInstanceOf("rewriteExternalTemplate");
-											code.SetAttribute("name", (id!=null?id.Text:null));
-									}
-									else if ( ind!=null )
-									{ // must be %({expr})(args)
-										code = templates.GetInstanceOf("rewriteIndirectTemplate");
-										List chunks=generator.TranslateAction(currentRuleName,ind);
-										code.SetAttribute("expr", chunks);
-									}
-
-				}
-				Match(input,ARGLIST,Follow._ARGLIST_in_rewrite_template2201); if (state.failed) return code;
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null); if (state.failed) return code;
-					// Grammars\\CodeGenTreeWalker.g3:1381:5: ( ^( ARG arg= ID a= ACTION ) )*
-					for ( ; ; )
-					{
-						int alt69=2;
-						int LA69_0 = input.LA(1);
-
-						if ( (LA69_0==ARG) )
-						{
-							alt69=1;
-						}
-
-
-						switch ( alt69 )
-						{
-						case 1:
-							// Grammars\\CodeGenTreeWalker.g3:1381:7: ^( ARG arg= ID a= ACTION )
-							{
-							Match(input,ARG,Follow._ARG_in_rewrite_template2211); if (state.failed) return code;
-
-							Match(input, TokenTypes.Down, null); if (state.failed) return code;
-							arg=(GrammarAST)Match(input,ID,Follow._ID_in_rewrite_template2215); if (state.failed) return code;
-							a=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_rewrite_template2219); if (state.failed) return code;
-							if ( state.backtracking == 0 )
-							{
-
-														// must set alt num here rather than in define.g
-														// because actions like %foo(name={$ID.text}) aren't
-														// broken up yet into trees.
-														a.outerAltNum = this.outerAltNum;
-														List chunks = generator.TranslateAction(currentRuleName,a);
-														code.SetAttribute("args.{name,value}", (arg!=null?arg.Text:null), chunks);
-
-							}
-
-							Match(input, TokenTypes.Up, null); if (state.failed) return code;
-
-							}
-							break;
-
-						default:
-							goto loop69;
-						}
-					}
-
-					loop69:
-						;
-
-
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return code;
-				}
-				// Grammars\\CodeGenTreeWalker.g3:1393:4: ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )?
-				int alt70=3;
-				int LA70_0 = input.LA(1);
-
-				if ( (LA70_0==DOUBLE_QUOTE_STRING_LITERAL) )
-				{
-					alt70=1;
-				}
-				else if ( (LA70_0==DOUBLE_ANGLE_STRING_LITERAL) )
-				{
-					alt70=2;
-				}
-				switch ( alt70 )
-				{
-				case 1:
-					// Grammars\\CodeGenTreeWalker.g3:1393:6: DOUBLE_QUOTE_STRING_LITERAL
-					{
-					DOUBLE_QUOTE_STRING_LITERAL24=(GrammarAST)Match(input,DOUBLE_QUOTE_STRING_LITERAL,Follow._DOUBLE_QUOTE_STRING_LITERAL_in_rewrite_template2252); if (state.failed) return code;
-					if ( state.backtracking == 0 )
-					{
-
-											string sl = (DOUBLE_QUOTE_STRING_LITERAL24!=null?DOUBLE_QUOTE_STRING_LITERAL24.Text:null);
-											string t = sl.Substring( 1, sl.Length - 2 ); // strip quotes
-											t = generator.target.GetTargetStringLiteralFromString(t);
-											code.SetAttribute("template",t);
-
-					}
-
-					}
-					break;
-				case 2:
-					// Grammars\\CodeGenTreeWalker.g3:1400:6: DOUBLE_ANGLE_STRING_LITERAL
-					{
-					DOUBLE_ANGLE_STRING_LITERAL25=(GrammarAST)Match(input,DOUBLE_ANGLE_STRING_LITERAL,Follow._DOUBLE_ANGLE_STRING_LITERAL_in_rewrite_template2265); if (state.failed) return code;
-					if ( state.backtracking == 0 )
-					{
-
-											string sl = (DOUBLE_ANGLE_STRING_LITERAL25!=null?DOUBLE_ANGLE_STRING_LITERAL25.Text:null);
-											string t = sl.Substring( 2, sl.Length - 4 ); // strip double angle quotes
-											t = generator.target.GetTargetStringLiteralFromString(t);
-											code.SetAttribute("template",t);
-
-					}
-
-					}
-					break;
-
-				}
-
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return code;
-
-				}
-				break;
-			case 3:
-				// Grammars\\CodeGenTreeWalker.g3:1410:4: act= ACTION
-				{
-				act=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_rewrite_template2289); if (state.failed) return code;
-				if ( state.backtracking == 0 )
-				{
-
-								// set alt num for same reason as ARGLIST above
-								act.outerAltNum = this.outerAltNum;
-								code =templates.GetInstanceOf("rewriteAction");
-								code.SetAttribute("action",
-												  generator.TranslateAction(currentRuleName,act));
-
-				}
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return code;
-	}
-	// $ANTLR end "rewrite_template"
-
-	// $ANTLR start synpred1_CodeGenTreeWalker
-	public void synpred1_CodeGenTreeWalker_fragment()
-	{
-		// Grammars\\CodeGenTreeWalker.g3:561:4: ({...}? ( BLOCK | OPTIONAL | CLOSURE | POSITIVE_CLOSURE ) )
-		// Grammars\\CodeGenTreeWalker.g3:561:5: {...}? ( BLOCK | OPTIONAL | CLOSURE | POSITIVE_CLOSURE )
-		{
-		if ( !((((GrammarAST)input.LT(1)).SetValue==null)) )
-		{
-			if (state.backtracking>0) {state.failed=true; return ;}
-			throw new FailedPredicateException(input, "synpred1_CodeGenTreeWalker", "((GrammarAST)input.LT(1)).SetValue==null");
-		}
-		if ( input.LA(1)==BLOCK||input.LA(1)==CLOSURE||input.LA(1)==OPTIONAL||input.LA(1)==POSITIVE_CLOSURE )
-		{
-			input.Consume();
-			state.errorRecovery=false;state.failed=false;
-		}
-		else
-		{
-			if (state.backtracking>0) {state.failed=true; return ;}
-			MismatchedSetException mse = new MismatchedSetException(null,input);
-			throw mse;
-		}
-
-
-		}
-	}
-	// $ANTLR end synpred1_CodeGenTreeWalker
-
-	// $ANTLR start synpred2_CodeGenTreeWalker
-	public void synpred2_CodeGenTreeWalker_fragment()
-	{
-		// Grammars\\CodeGenTreeWalker.g3:729:6: ( element_action )
-		// Grammars\\CodeGenTreeWalker.g3:729:7: element_action
-		{
-		PushFollow(Follow._element_action_in_synpred2_CodeGenTreeWalker1385);
-		element_action();
-
-		state._fsp--;
-		if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred2_CodeGenTreeWalker
-	#endregion Rules
-
-	#region Synpreds
-	bool EvaluatePredicate( System.Action fragment )
-	{
-		state.backtracking++;
-		int start = input.Mark();
-		try
-		{
-			fragment();
-		}
-		catch ( RecognitionException re )
-		{
-			System.Console.Error.WriteLine("impossible: "+re);
-		}
-		bool success = !state.failed;
-		input.Rewind(start);
-		state.backtracking--;
-		state.failed=false;
-		return success;
-	}
-	#endregion Synpreds
-
-
-	#region DFA
-	DFA45 dfa45;
-
-	protected override void InitDFAs()
-	{
-		base.InitDFAs();
-		dfa45 = new DFA45( this, new SpecialStateTransitionHandler( specialStateTransition45 ) );
-	}
-
-	class DFA45 : DFA
-	{
-
-		const string DFA45_eotS =
-			"\x1A\xFFFF";
-		const string DFA45_eofS =
-			"\x1A\xFFFF";
-		const string DFA45_minS =
-			"\x1\x4\x6\xFFFF\x1\x0\x12\xFFFF";
-		const string DFA45_maxS =
-			"\x1\x5F\x6\xFFFF\x1\x0\x12\xFFFF";
-		const string DFA45_acceptS =
-			"\x1\xFFFF\x1\x1\x1\x2\x1\x3\x1\x4\x1\x5\x1\x6\x1\xFFFF\x3\x7\x1\x8\x5"+
-			"\xFFFF\x1\x9\x1\xA\x1\xFFFF\x1\xB\x1\xFFFF\x1\xC\x1\xD\x1\xE\x1\xF";
-		const string DFA45_specialS =
-			"\x1\x0\x6\xFFFF\x1\x1\x12\xFFFF}>";
-		static readonly string[] DFA45_transitionS =
-			{
-				"\x1\x12\x8\xFFFF\x1\x4\x1\x18\x1\x2\x1\x7\x1\xFFFF\x1\xB\x1\x6\x1\xFFFF"+
-				"\x1\x9\x7\xFFFF\x1\xB\x5\xFFFF\x1\x19\x3\xFFFF\x1\x12\x1\xFFFF\x1\x14"+
-				"\xD\xFFFF\x1\x3\x1\xFFFF\x1\x8\x5\xFFFF\x1\x5\x1\xA\x9\xFFFF\x1\x1\x2"+
-				"\xFFFF\x1\xB\x2\xFFFF\x1\x14\x4\xFFFF\x1\xB\x1\x16\x1\x17\x2\xFFFF\x1"+
-				"\xB\x2\xFFFF\x1\x11\x1\xFFFF\x1\xB",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"\x1\xFFFF",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				""
-			};
-
-		static readonly short[] DFA45_eot = DFA.UnpackEncodedString(DFA45_eotS);
-		static readonly short[] DFA45_eof = DFA.UnpackEncodedString(DFA45_eofS);
-		static readonly char[] DFA45_min = DFA.UnpackEncodedStringToUnsignedChars(DFA45_minS);
-		static readonly char[] DFA45_max = DFA.UnpackEncodedStringToUnsignedChars(DFA45_maxS);
-		static readonly short[] DFA45_accept = DFA.UnpackEncodedString(DFA45_acceptS);
-		static readonly short[] DFA45_special = DFA.UnpackEncodedString(DFA45_specialS);
-		static readonly short[][] DFA45_transition;
-
-		static DFA45()
-		{
-			int numStates = DFA45_transitionS.Length;
-			DFA45_transition = new short[numStates][];
-			for ( int i=0; i < numStates; i++ )
-			{
-				DFA45_transition[i] = DFA.UnpackEncodedString(DFA45_transitionS[i]);
-			}
-		}
-
-		public DFA45( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
-			: base( specialStateTransition )	{
-			this.recognizer = recognizer;
-			this.decisionNumber = 45;
-			this.eot = DFA45_eot;
-			this.eof = DFA45_eof;
-			this.min = DFA45_min;
-			this.max = DFA45_max;
-			this.accept = DFA45_accept;
-			this.special = DFA45_special;
-			this.transition = DFA45_transition;
-		}
-		public override string GetDescription()
-		{
-			return "526:0: element[GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null] options {k=1; } : ( ^( ROOT e= element[label,$ROOT] ) | ^( BANG e= element[label,$BANG] ) | ^(n= NOT notElement[$n, $label, $astSuffix] ) | ^( ASSIGN alabel= ID e= element[$alabel,$astSuffix] ) | ^( PLUS_ASSIGN label2= ID e= element[$label2,$astSuffix] ) | ^( CHAR_RANGE a= CHAR_LITERAL b= CHAR_LITERAL ) |=> ebnf | atom[null, $label, $astSuffix] | tree_ | element_action | (sp= SEMPRED |sp= GATED_SEMPRED ) | SYN_SEMPRED | ^( SYNPRED ( . )* ) | ^( BACKTRACK_SEMPRED ( . )* ) | EPSILON );";
-		}
-	}
-
-	int specialStateTransition45( DFA dfa, int s, IIntStream _input )
-	{
-		ITreeNodeStream input = (ITreeNodeStream)_input;
-		int _s = s;
-		switch ( s )
-		{
-			case 0:
-				int LA45_0 = input.LA(1);
-
-
-				int index45_0 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (LA45_0==ROOT) ) {s = 1;}
-
-				else if ( (LA45_0==BANG) ) {s = 2;}
-
-				else if ( (LA45_0==NOT) ) {s = 3;}
-
-				else if ( (LA45_0==ASSIGN) ) {s = 4;}
-
-				else if ( (LA45_0==PLUS_ASSIGN) ) {s = 5;}
-
-				else if ( (LA45_0==CHAR_RANGE) ) {s = 6;}
-
-				else if ( (LA45_0==BLOCK) ) {s = 7;}
-
-				else if ( (LA45_0==OPTIONAL) && (EvaluatePredicate(synpred1_CodeGenTreeWalker_fragment))) {s = 8;}
-
-				else if ( (LA45_0==CLOSURE) && (EvaluatePredicate(synpred1_CodeGenTreeWalker_fragment))) {s = 9;}
-
-				else if ( (LA45_0==POSITIVE_CLOSURE) && (EvaluatePredicate(synpred1_CodeGenTreeWalker_fragment))) {s = 10;}
-
-				else if ( (LA45_0==CHAR_LITERAL||LA45_0==DOT||LA45_0==RULE_REF||LA45_0==STRING_LITERAL||LA45_0==TOKEN_REF||LA45_0==WILDCARD) ) {s = 11;}
-
-				else if ( (LA45_0==TREE_BEGIN) ) {s = 17;}
-
-				else if ( (LA45_0==ACTION||LA45_0==FORCED_ACTION) ) {s = 18;}
-
-				else if ( (LA45_0==GATED_SEMPRED||LA45_0==SEMPRED) ) {s = 20;}
-
-				else if ( (LA45_0==SYN_SEMPRED) ) {s = 22;}
-
-				else if ( (LA45_0==SYNPRED) ) {s = 23;}
-
-				else if ( (LA45_0==BACKTRACK_SEMPRED) ) {s = 24;}
-
-				else if ( (LA45_0==EPSILON) ) {s = 25;}
-
-
-				input.Seek(index45_0);
-				if ( s>=0 ) return s;
-				break;
-			case 1:
-				int LA45_7 = input.LA(1);
-
-
-				int index45_7 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (EvaluatePredicate(synpred1_CodeGenTreeWalker_fragment)) ) {s = 10;}
-
-				else if ( (true) ) {s = 11;}
-
-
-				input.Seek(index45_7);
-				if ( s>=0 ) return s;
-				break;
-		}
-		if (state.backtracking>0) {state.failed=true; return -1;}
-		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 45, _s, input);
-		dfa.Error(nvae);
-		throw nvae;
-	}
-
-	#endregion DFA
-
-	#region Follow sets
-	private static class Follow
-	{
-		public static readonly BitSet _LEXER_GRAMMAR_in_grammar_66 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _grammarSpec_in_grammar_68 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _PARSER_GRAMMAR_in_grammar_78 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _grammarSpec_in_grammar_80 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _TREE_GRAMMAR_in_grammar_90 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _grammarSpec_in_grammar_92 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _COMBINED_GRAMMAR_in_grammar_102 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _grammarSpec_in_grammar_104 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _SCOPE_in_attrScope123 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_attrScope125 = new BitSet(new ulong[]{0x210UL});
-		public static readonly BitSet _AMPERSAND_in_attrScope130 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ACTION_in_attrScope139 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ID_in_grammarSpec156 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
-		public static readonly BitSet _DOC_COMMENT_in_grammarSpec164 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
-		public static readonly BitSet _OPTIONS_in_grammarSpec185 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _IMPORT_in_grammarSpec199 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _TOKENS_in_grammarSpec213 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _attrScope_in_grammarSpec225 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
-		public static readonly BitSet _AMPERSAND_in_grammarSpec234 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _rules_in_grammarSpec245 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _rule_in_rules290 = new BitSet(new ulong[]{0x2UL,0x1000UL});
-		public static readonly BitSet _RULE_in_rules304 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _RULE_in_rule345 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_rule349 = new BitSet(new ulong[]{0x10000000400UL,0xEUL});
-		public static readonly BitSet _modifier_in_rule362 = new BitSet(new ulong[]{0x400UL});
-		public static readonly BitSet _ARG_in_rule370 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_ACTION_in_rule373 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _RET_in_rule382 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_ACTION_in_rule385 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _throwsSpec_in_rule394 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
-		public static readonly BitSet _OPTIONS_in_rule404 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ruleScopeSpec_in_rule417 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
-		public static readonly BitSet _AMPERSAND_in_rule427 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _block_in_rule441 = new BitSet(new ulong[]{0x4400020000UL});
-		public static readonly BitSet _exceptionGroup_in_rule454 = new BitSet(new ulong[]{0x400000000UL});
-		public static readonly BitSet _EOR_in_rule462 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _set_in_modifier485 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _THROWS_in_throwsSpec512 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_throwsSpec514 = new BitSet(new ulong[]{0x80000000008UL});
-		public static readonly BitSet _SCOPE_in_ruleScopeSpec529 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _AMPERSAND_in_ruleScopeSpec534 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ACTION_in_ruleScopeSpec544 = new BitSet(new ulong[]{0x80000000008UL});
-		public static readonly BitSet _ID_in_ruleScopeSpec550 = new BitSet(new ulong[]{0x80000000008UL});
-		public static readonly BitSet _setBlock_in_block591 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _BLOCK_in_block604 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _OPTIONS_in_block612 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _alternative_in_block629 = new BitSet(new ulong[]{0x200000100UL,0x200UL});
-		public static readonly BitSet _rewrite_in_block633 = new BitSet(new ulong[]{0x200000100UL,0x200UL});
-		public static readonly BitSet _EOB_in_block650 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _BLOCK_in_setBlock682 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ALT_in_setAlternative702 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _setElement_in_setAlternative704 = new BitSet(new ulong[]{0x1000C0000UL,0x4200000UL});
-		public static readonly BitSet _EOA_in_setAlternative707 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _exceptionHandler_in_exceptionGroup722 = new BitSet(new ulong[]{0x4000020002UL});
-		public static readonly BitSet _finallyClause_in_exceptionGroup729 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _finallyClause_in_exceptionGroup737 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _CATCH_in_exceptionHandler751 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_ACTION_in_exceptionHandler753 = new BitSet(new ulong[]{0x10UL});
-		public static readonly BitSet _ACTION_in_exceptionHandler755 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _FINALLY_in_finallyClause773 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ACTION_in_finallyClause775 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ALT_in_alternative804 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _element_in_alternative817 = new BitSet(new ulong[]{0x86800289202DE210UL,0xA4E16401UL});
-		public static readonly BitSet _EOA_in_alternative835 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ROOT_in_element870 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _element_in_element874 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _BANG_in_element887 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _element_in_element891 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _NOT_in_element907 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _notElement_in_element909 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ASSIGN_in_element924 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_element928 = new BitSet(new ulong[]{0x86800289202DE210UL,0xA4E16401UL});
-		public static readonly BitSet _element_in_element932 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _PLUS_ASSIGN_in_element947 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_element951 = new BitSet(new ulong[]{0x86800289202DE210UL,0xA4E16401UL});
-		public static readonly BitSet _element_in_element955 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _CHAR_RANGE_in_element969 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _CHAR_LITERAL_in_element973 = new BitSet(new ulong[]{0x40000UL});
-		public static readonly BitSet _CHAR_LITERAL_in_element977 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ebnf_in_element1006 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _atom_in_element1016 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _tree__in_element1027 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _element_action_in_element1037 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _SEMPRED_in_element1052 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _GATED_SEMPRED_in_element1056 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _SYN_SEMPRED_in_element1067 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _SYNPRED_in_element1075 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _BACKTRACK_SEMPRED_in_element1086 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _EPSILON_in_element1098 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ACTION_in_element_action1115 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _FORCED_ACTION_in_element_action1126 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _CHAR_LITERAL_in_notElement1155 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _STRING_LITERAL_in_notElement1168 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _TOKEN_REF_in_notElement1181 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _BLOCK_in_notElement1195 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _block_in_ebnf1241 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _OPTIONAL_in_ebnf1260 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _block_in_ebnf1264 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _CLOSURE_in_ebnf1285 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _block_in_ebnf1289 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _POSITIVE_CLOSURE_in_ebnf1310 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _block_in_ebnf1314 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _TREE_BEGIN_in_tree_1352 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _element_in_tree_1359 = new BitSet(new ulong[]{0x86800289202DE218UL,0xA4E16401UL});
-		public static readonly BitSet _element_action_in_tree_1396 = new BitSet(new ulong[]{0x86800289202DE218UL,0xA4E16401UL});
-		public static readonly BitSet _element_in_tree_1418 = new BitSet(new ulong[]{0x86800289202DE218UL,0xA4E16401UL});
-		public static readonly BitSet _RULE_REF_in_atom1469 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_ACTION_in_atom1474 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _TOKEN_REF_in_atom1492 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_ACTION_in_atom1497 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _CHAR_LITERAL_in_atom1513 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _STRING_LITERAL_in_atom1526 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _WILDCARD_in_atom1538 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _DOT_in_atom1549 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_atom1551 = new BitSet(new ulong[]{0x20050000UL,0x84202000UL});
-		public static readonly BitSet _atom_in_atom1555 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _set_in_atom1568 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _set_in_ast_suffix1584 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _BLOCK_in_set1613 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _CHAR_LITERAL_in_setElement1633 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _TOKEN_REF_in_setElement1638 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _STRING_LITERAL_in_setElement1643 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _CHAR_RANGE_in_setElement1649 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _CHAR_LITERAL_in_setElement1651 = new BitSet(new ulong[]{0x40000UL});
-		public static readonly BitSet _CHAR_LITERAL_in_setElement1653 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _REWRITE_in_rewrite1690 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _SEMPRED_in_rewrite1695 = new BitSet(new ulong[]{0x2000000110UL,0x1000000UL});
-		public static readonly BitSet _rewrite_alternative_in_rewrite1701 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _BLOCK_in_rewrite_block1736 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _rewrite_alternative_in_rewrite_block1748 = new BitSet(new ulong[]{0x200000000UL});
-		public static readonly BitSet _EOB_in_rewrite_block1753 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ALT_in_rewrite_alternative1788 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _rewrite_element_in_rewrite_alternative1806 = new BitSet(new ulong[]{0x201000100240010UL,0x24202001UL});
-		public static readonly BitSet _EPSILON_in_rewrite_alternative1827 = new BitSet(new ulong[]{0x100000000UL});
-		public static readonly BitSet _EOA_in_rewrite_alternative1843 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _rewrite_template_in_rewrite_alternative1856 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ETC_in_rewrite_alternative1869 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _rewrite_atom_in_rewrite_element1889 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _rewrite_ebnf_in_rewrite_element1899 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _rewrite_tree_in_rewrite_element1908 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _OPTIONAL_in_rewrite_ebnf1929 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _rewrite_block_in_rewrite_ebnf1931 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _CLOSURE_in_rewrite_ebnf1949 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _rewrite_block_in_rewrite_ebnf1951 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _POSITIVE_CLOSURE_in_rewrite_ebnf1969 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _rewrite_block_in_rewrite_ebnf1971 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _TREE_BEGIN_in_rewrite_tree2004 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _rewrite_atom_in_rewrite_tree2011 = new BitSet(new ulong[]{0x201000100240018UL,0x24202001UL});
-		public static readonly BitSet _rewrite_element_in_rewrite_tree2031 = new BitSet(new ulong[]{0x201000100240018UL,0x24202001UL});
-		public static readonly BitSet _RULE_REF_in_rewrite_atom2076 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _TOKEN_REF_in_rewrite_atom2093 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_ACTION_in_rewrite_atom2098 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _CHAR_LITERAL_in_rewrite_atom2109 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _STRING_LITERAL_in_rewrite_atom2117 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _LABEL_in_rewrite_atom2131 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ACTION_in_rewrite_atom2141 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ALT_in_rewrite_template2164 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _EPSILON_in_rewrite_template2166 = new BitSet(new ulong[]{0x100000000UL});
-		public static readonly BitSet _EOA_in_rewrite_template2168 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _TEMPLATE_in_rewrite_template2179 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_rewrite_template2184 = new BitSet(new ulong[]{0x1000UL});
-		public static readonly BitSet _ACTION_in_rewrite_template2188 = new BitSet(new ulong[]{0x1000UL});
-		public static readonly BitSet _ARGLIST_in_rewrite_template2201 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_in_rewrite_template2211 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_rewrite_template2215 = new BitSet(new ulong[]{0x10UL});
-		public static readonly BitSet _ACTION_in_rewrite_template2219 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _DOUBLE_QUOTE_STRING_LITERAL_in_rewrite_template2252 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _DOUBLE_ANGLE_STRING_LITERAL_in_rewrite_template2265 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ACTION_in_rewrite_template2289 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _set_in_synpred1_CodeGenTreeWalker991 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _element_action_in_synpred2_CodeGenTreeWalker1385 = new BitSet(new ulong[]{0x2UL});
-
-	}
-	#endregion Follow sets
-}
-
-} // namespace Antlr3.Grammars
diff --git a/Antlr3/Grammars/DefineGrammarItemsWalker.cs b/Antlr3/Grammars/DefineGrammarItemsWalker.cs
deleted file mode 100644
index 6328fc7..0000000
--- a/Antlr3/Grammars/DefineGrammarItemsWalker.cs
+++ /dev/null
@@ -1,4881 +0,0 @@
-// $ANTLR 3.1.2 Grammars\\DefineGrammarItemsWalker.g3 2009-09-30 13:28:45
-
-// The variable 'variable' is assigned but its value is never used.
-#pragma warning disable 219
-// Unreachable code detected.
-#pragma warning disable 162
-
-
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Grammar conversion to ANTLR v3 and C#:
- Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-	notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-	derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-using System;
-
-using Antlr3.Tool;
-#if DEBUG
-using Utils = Antlr3.Misc.Utils;
-#endif
-
-
-using System.Collections.Generic;
-using Antlr.Runtime;
-using Antlr.Runtime.Tree;
-using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;using Stack = System.Collections.Generic.Stack<object>;
-using List = System.Collections.IList;
-using ArrayList = System.Collections.Generic.List<object>;
-using Map = System.Collections.IDictionary;
-using HashMap = System.Collections.Generic.Dictionary<object, object>;
-namespace Antlr3.Grammars
-{
-[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.1.2")]
-[System.CLSCompliant(false)]
-public partial class DefineGrammarItemsWalker : TreeParser
-{
-	internal static readonly string[] tokenNames = new string[] {
-		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", "ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARG_ACTION", "ARGLIST", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", "CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", "COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", "DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", "EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", "GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", "LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", "NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", "OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", "RET", "RETURNS", "REWRITE", "ROOT", "RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", "SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYN_SEMPRED", "SYNPRED", "TEMPLATE", "THROWS", "TOKEN_REF", "TOKENS", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", "WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT"
-	};
-	public const int EOF=-1;
-	public const int ACTION=4;
-	public const int ACTION_CHAR_LITERAL=5;
-	public const int ACTION_ESC=6;
-	public const int ACTION_STRING_LITERAL=7;
-	public const int ALT=8;
-	public const int AMPERSAND=9;
-	public const int ARG=10;
-	public const int ARG_ACTION=11;
-	public const int ARGLIST=12;
-	public const int ASSIGN=13;
-	public const int BACKTRACK_SEMPRED=14;
-	public const int BANG=15;
-	public const int BLOCK=16;
-	public const int CATCH=17;
-	public const int CHAR_LITERAL=18;
-	public const int CHAR_RANGE=19;
-	public const int CLOSE_ELEMENT_OPTION=20;
-	public const int CLOSURE=21;
-	public const int COLON=22;
-	public const int COMBINED_GRAMMAR=23;
-	public const int COMMA=24;
-	public const int COMMENT=25;
-	public const int DIGIT=26;
-	public const int DOC_COMMENT=27;
-	public const int DOLLAR=28;
-	public const int DOT=29;
-	public const int DOUBLE_ANGLE_STRING_LITERAL=30;
-	public const int DOUBLE_QUOTE_STRING_LITERAL=31;
-	public const int EOA=32;
-	public const int EOB=33;
-	public const int EOR=34;
-	public const int EPSILON=35;
-	public const int ESC=36;
-	public const int ETC=37;
-	public const int FINALLY=38;
-	public const int FORCED_ACTION=39;
-	public const int FRAGMENT=40;
-	public const int GATED_SEMPRED=41;
-	public const int GRAMMAR=42;
-	public const int ID=43;
-	public const int IMPLIES=44;
-	public const int IMPORT=45;
-	public const int INITACTION=46;
-	public const int INT=47;
-	public const int LABEL=48;
-	public const int LEXER=49;
-	public const int LEXER_GRAMMAR=50;
-	public const int LPAREN=51;
-	public const int ML_COMMENT=52;
-	public const int NESTED_ACTION=53;
-	public const int NESTED_ARG_ACTION=54;
-	public const int NOT=55;
-	public const int OPEN_ELEMENT_OPTION=56;
-	public const int OPTIONAL=57;
-	public const int OPTIONS=58;
-	public const int OR=59;
-	public const int PARSER=60;
-	public const int PARSER_GRAMMAR=61;
-	public const int PLUS=62;
-	public const int PLUS_ASSIGN=63;
-	public const int POSITIVE_CLOSURE=64;
-	public const int PRIVATE=65;
-	public const int PROTECTED=66;
-	public const int PUBLIC=67;
-	public const int QUESTION=68;
-	public const int RANGE=69;
-	public const int RCURLY=70;
-	public const int RET=71;
-	public const int RETURNS=72;
-	public const int REWRITE=73;
-	public const int ROOT=74;
-	public const int RPAREN=75;
-	public const int RULE=76;
-	public const int RULE_REF=77;
-	public const int SCOPE=78;
-	public const int SEMI=79;
-	public const int SEMPRED=80;
-	public const int SL_COMMENT=81;
-	public const int SRC=82;
-	public const int STAR=83;
-	public const int STRAY_BRACKET=84;
-	public const int STRING_LITERAL=85;
-	public const int SYN_SEMPRED=86;
-	public const int SYNPRED=87;
-	public const int TEMPLATE=88;
-	public const int THROWS=89;
-	public const int TOKEN_REF=90;
-	public const int TOKENS=91;
-	public const int TREE=92;
-	public const int TREE_BEGIN=93;
-	public const int TREE_GRAMMAR=94;
-	public const int WILDCARD=95;
-	public const int WS=96;
-	public const int WS_LOOP=97;
-	public const int WS_OPT=98;
-	public const int XDIGIT=99;
-
-	// delegates
-	// delegators
-
-	protected class AttributeScopeActions_scope
-	{
-		public Dictionary<GrammarAST, GrammarAST> actions;
-	}
-	partial void AttributeScopeActions_scopeInit( AttributeScopeActions_scope scope );partial void AttributeScopeActions_scopeAfter( AttributeScopeActions_scope scope );protected Stack<AttributeScopeActions_scope> AttributeScopeActions_stack = new Stack<AttributeScopeActions_scope>();
-
-	public DefineGrammarItemsWalker( ITreeNodeStream input )
-		: this( input, new RecognizerSharedState() )
-	{
-	}
-	public DefineGrammarItemsWalker( ITreeNodeStream input, RecognizerSharedState state )
-		: base( input, state )
-	{
-	}
-
-
-	public override string[] TokenNames { get { return DefineGrammarItemsWalker.tokenNames; } }
-	public override string GrammarFileName { get { return "Grammars\\DefineGrammarItemsWalker.g3"; } }
-
-
-	#region Rules
-	public class grammar__return : TreeRuleReturnScope
-	{
-	}
-
-	// $ANTLR start "grammar_"
-	// Grammars\\DefineGrammarItemsWalker.g3:91:0: public grammar_[Grammar g] : ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) );
-	public DefineGrammarItemsWalker.grammar__return grammar_( Grammar g )
-	{
-		DefineGrammarItemsWalker.grammar__return retval = new DefineGrammarItemsWalker.grammar__return();
-		retval.start = input.LT(1);
-
-
-		grammar = g;
-		root = ((GrammarAST)retval.Start);
-
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:101:4: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
-			int alt1=4;
-			switch ( input.LA(1) )
-			{
-			case LEXER_GRAMMAR:
-				{
-				alt1=1;
-				}
-				break;
-			case PARSER_GRAMMAR:
-				{
-				alt1=2;
-				}
-				break;
-			case TREE_GRAMMAR:
-				{
-				alt1=3;
-				}
-				break;
-			case COMBINED_GRAMMAR:
-				{
-				alt1=4;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 1, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt1 )
-			{
-			case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:101:4: ^( LEXER_GRAMMAR grammarSpec )
-				{
-				Match(input,LEXER_GRAMMAR,Follow._LEXER_GRAMMAR_in_grammar_77); if (state.failed) return retval;
-
-				if ( state.backtracking == 0 )
-				{
-					grammar.type = GrammarType.Lexer;
-				}
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				PushFollow(Follow._grammarSpec_in_grammar_83);
-				grammarSpec();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-
-				}
-				break;
-			case 2:
-				// Grammars\\DefineGrammarItemsWalker.g3:102:4: ^( PARSER_GRAMMAR grammarSpec )
-				{
-				Match(input,PARSER_GRAMMAR,Follow._PARSER_GRAMMAR_in_grammar_92); if (state.failed) return retval;
-
-				if ( state.backtracking == 0 )
-				{
-					grammar.type = GrammarType.Parser;
-				}
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				PushFollow(Follow._grammarSpec_in_grammar_97);
-				grammarSpec();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-
-				}
-				break;
-			case 3:
-				// Grammars\\DefineGrammarItemsWalker.g3:103:4: ^( TREE_GRAMMAR grammarSpec )
-				{
-				Match(input,TREE_GRAMMAR,Follow._TREE_GRAMMAR_in_grammar_106); if (state.failed) return retval;
-
-				if ( state.backtracking == 0 )
-				{
-					grammar.type = GrammarType.TreeParser;
-				}
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				PushFollow(Follow._grammarSpec_in_grammar_111);
-				grammarSpec();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-
-				}
-				break;
-			case 4:
-				// Grammars\\DefineGrammarItemsWalker.g3:104:4: ^( COMBINED_GRAMMAR grammarSpec )
-				{
-				Match(input,COMBINED_GRAMMAR,Follow._COMBINED_GRAMMAR_in_grammar_120); if (state.failed) return retval;
-
-				if ( state.backtracking == 0 )
-				{
-					grammar.type = GrammarType.Combined;
-				}
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				PushFollow(Follow._grammarSpec_in_grammar_125);
-				grammarSpec();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-
-				}
-				break;
-
-			}
-			if ( state.backtracking == 0 )
-			{
-
-				Finish();
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "grammar_"
-
-
-	// $ANTLR start "attrScope"
-	// Grammars\\DefineGrammarItemsWalker.g3:107:0: attrScope : ^( 'scope' name= ID ( attrScopeAction )* attrs= ACTION ) ;
-	private void attrScope(  )
-	{
-		AttributeScopeActions_stack.Push(new AttributeScopeActions_scope());AttributeScopeActions_scopeInit(AttributeScopeActions_stack.Peek());
-
-		GrammarAST name=null;
-		GrammarAST attrs=null;
-
-
-			((AttributeScopeActions_scope)AttributeScopeActions_stack.Peek()).actions = new Dictionary<GrammarAST, GrammarAST>();
-
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:113:4: ( ^( 'scope' name= ID ( attrScopeAction )* attrs= ACTION ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:113:4: ^( 'scope' name= ID ( attrScopeAction )* attrs= ACTION )
-			{
-			Match(input,SCOPE,Follow._SCOPE_in_attrScope150); if (state.failed) return ;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return ;
-			name=(GrammarAST)Match(input,ID,Follow._ID_in_attrScope154); if (state.failed) return ;
-			// Grammars\\DefineGrammarItemsWalker.g3:113:23: ( attrScopeAction )*
-			for ( ; ; )
-			{
-				int alt2=2;
-				int LA2_0 = input.LA(1);
-
-				if ( (LA2_0==AMPERSAND) )
-				{
-					alt2=1;
-				}
-
-
-				switch ( alt2 )
-				{
-				case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:113:0: attrScopeAction
-					{
-					PushFollow(Follow._attrScopeAction_in_attrScope156);
-					attrScopeAction();
-
-					state._fsp--;
-					if (state.failed) return ;
-
-					}
-					break;
-
-				default:
-					goto loop2;
-				}
-			}
-
-			loop2:
-				;
-
-
-			attrs=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_attrScope161); if (state.failed) return ;
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return ;
-			if ( state.backtracking == 0 )
-			{
-
-							AttributeScope scope = grammar.DefineGlobalScope((name!=null?name.Text:null),attrs.token);
-							scope.isDynamicGlobalScope = true;
-							scope.AddAttributes((attrs!=null?attrs.Text:null), ';');
-							foreach ( var action in ((AttributeScopeActions_scope)AttributeScopeActions_stack.Peek()).actions )
-								scope.DefineNamedAction( action.Key, action.Value );
-
-			}
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-			AttributeScopeActions_scopeAfter(AttributeScopeActions_stack.Peek());AttributeScopeActions_stack.Pop();
-
-		}
-		return ;
-	}
-	// $ANTLR end "attrScope"
-
-
-	// $ANTLR start "attrScopeAction"
-	// Grammars\\DefineGrammarItemsWalker.g3:123:0: attrScopeAction : ^( AMPERSAND ID ACTION ) ;
-	private void attrScopeAction(  )
-	{
-		GrammarAST ID1=null;
-		GrammarAST ACTION2=null;
-
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:124:4: ( ^( AMPERSAND ID ACTION ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:124:4: ^( AMPERSAND ID ACTION )
-			{
-			Match(input,AMPERSAND,Follow._AMPERSAND_in_attrScopeAction179); if (state.failed) return ;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return ;
-			ID1=(GrammarAST)Match(input,ID,Follow._ID_in_attrScopeAction181); if (state.failed) return ;
-			ACTION2=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_attrScopeAction183); if (state.failed) return ;
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return ;
-			if ( state.backtracking == 0 )
-			{
-
-							((AttributeScopeActions_scope)AttributeScopeActions_stack.Peek()).actions.Add( ID1, ACTION2 );
-
-			}
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "attrScopeAction"
-
-
-	// $ANTLR start "grammarSpec"
-	// Grammars\\DefineGrammarItemsWalker.g3:130:0: grammarSpec : id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( actions )? rules ;
-	private void grammarSpec(  )
-	{
-		GrammarAST id=null;
-		GrammarAST cmt=null;
-
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:131:4: (id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( actions )? rules )
-			// Grammars\\DefineGrammarItemsWalker.g3:131:4: id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( actions )? rules
-			{
-			id=(GrammarAST)Match(input,ID,Follow._ID_in_grammarSpec201); if (state.failed) return ;
-			// Grammars\\DefineGrammarItemsWalker.g3:132:3: (cmt= DOC_COMMENT )?
-			int alt3=2;
-			int LA3_0 = input.LA(1);
-
-			if ( (LA3_0==DOC_COMMENT) )
-			{
-				alt3=1;
-			}
-			switch ( alt3 )
-			{
-			case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:132:4: cmt= DOC_COMMENT
-				{
-				cmt=(GrammarAST)Match(input,DOC_COMMENT,Follow._DOC_COMMENT_in_grammarSpec208); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-			// Grammars\\DefineGrammarItemsWalker.g3:133:3: ( optionsSpec )?
-			int alt4=2;
-			int LA4_0 = input.LA(1);
-
-			if ( (LA4_0==OPTIONS) )
-			{
-				alt4=1;
-			}
-			switch ( alt4 )
-			{
-			case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:133:5: optionsSpec
-				{
-				PushFollow(Follow._optionsSpec_in_grammarSpec216);
-				optionsSpec();
-
-				state._fsp--;
-				if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-			// Grammars\\DefineGrammarItemsWalker.g3:134:3: ( delegateGrammars )?
-			int alt5=2;
-			int LA5_0 = input.LA(1);
-
-			if ( (LA5_0==IMPORT) )
-			{
-				alt5=1;
-			}
-			switch ( alt5 )
-			{
-			case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:134:4: delegateGrammars
-				{
-				PushFollow(Follow._delegateGrammars_in_grammarSpec224);
-				delegateGrammars();
-
-				state._fsp--;
-				if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-			// Grammars\\DefineGrammarItemsWalker.g3:135:3: ( tokensSpec )?
-			int alt6=2;
-			int LA6_0 = input.LA(1);
-
-			if ( (LA6_0==TOKENS) )
-			{
-				alt6=1;
-			}
-			switch ( alt6 )
-			{
-			case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:135:4: tokensSpec
-				{
-				PushFollow(Follow._tokensSpec_in_grammarSpec231);
-				tokensSpec();
-
-				state._fsp--;
-				if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-			// Grammars\\DefineGrammarItemsWalker.g3:136:3: ( attrScope )*
-			for ( ; ; )
-			{
-				int alt7=2;
-				int LA7_0 = input.LA(1);
-
-				if ( (LA7_0==SCOPE) )
-				{
-					alt7=1;
-				}
-
-
-				switch ( alt7 )
-				{
-				case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:136:4: attrScope
-					{
-					PushFollow(Follow._attrScope_in_grammarSpec238);
-					attrScope();
-
-					state._fsp--;
-					if (state.failed) return ;
-
-					}
-					break;
-
-				default:
-					goto loop7;
-				}
-			}
-
-			loop7:
-				;
-
-
-			// Grammars\\DefineGrammarItemsWalker.g3:137:3: ( actions )?
-			int alt8=2;
-			int LA8_0 = input.LA(1);
-
-			if ( (LA8_0==AMPERSAND) )
-			{
-				alt8=1;
-			}
-			switch ( alt8 )
-			{
-			case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:137:4: actions
-				{
-				PushFollow(Follow._actions_in_grammarSpec245);
-				actions();
-
-				state._fsp--;
-				if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-			PushFollow(Follow._rules_in_grammarSpec251);
-			rules();
-
-			state._fsp--;
-			if (state.failed) return ;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "grammarSpec"
-
-
-	// $ANTLR start "actions"
-	// Grammars\\DefineGrammarItemsWalker.g3:141:0: actions : ( action )+ ;
-	private void actions(  )
-	{
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:142:4: ( ( action )+ )
-			// Grammars\\DefineGrammarItemsWalker.g3:142:4: ( action )+
-			{
-			// Grammars\\DefineGrammarItemsWalker.g3:142:4: ( action )+
-			int cnt9=0;
-			for ( ; ; )
-			{
-				int alt9=2;
-				int LA9_0 = input.LA(1);
-
-				if ( (LA9_0==AMPERSAND) )
-				{
-					alt9=1;
-				}
-
-
-				switch ( alt9 )
-				{
-				case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:142:6: action
-					{
-					PushFollow(Follow._action_in_actions264);
-					action();
-
-					state._fsp--;
-					if (state.failed) return ;
-
-					}
-					break;
-
-				default:
-					if ( cnt9 >= 1 )
-						goto loop9;
-
-					if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee9 = new EarlyExitException( 9, input );
-					throw eee9;
-				}
-				cnt9++;
-			}
-			loop9:
-				;
-
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "actions"
-
-
-	// $ANTLR start "action"
-	// Grammars\\DefineGrammarItemsWalker.g3:145:0: action : ^(amp= AMPERSAND id1= ID (id2= ID a1= ACTION |a2= ACTION ) ) ;
-	private void action(  )
-	{
-		GrammarAST amp=null;
-		GrammarAST id1=null;
-		GrammarAST id2=null;
-		GrammarAST a1=null;
-		GrammarAST a2=null;
-
-
-			string scope=null;
-			GrammarAST nameAST=null, actionAST=null;
-
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:151:4: ( ^(amp= AMPERSAND id1= ID (id2= ID a1= ACTION |a2= ACTION ) ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:151:4: ^(amp= AMPERSAND id1= ID (id2= ID a1= ACTION |a2= ACTION ) )
-			{
-			amp=(GrammarAST)Match(input,AMPERSAND,Follow._AMPERSAND_in_action286); if (state.failed) return ;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return ;
-			id1=(GrammarAST)Match(input,ID,Follow._ID_in_action290); if (state.failed) return ;
-			// Grammars\\DefineGrammarItemsWalker.g3:152:4: (id2= ID a1= ACTION |a2= ACTION )
-			int alt10=2;
-			int LA10_0 = input.LA(1);
-
-			if ( (LA10_0==ID) )
-			{
-				alt10=1;
-			}
-			else if ( (LA10_0==ACTION) )
-			{
-				alt10=2;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				NoViableAltException nvae = new NoViableAltException("", 10, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt10 )
-			{
-			case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:152:6: id2= ID a1= ACTION
-				{
-				id2=(GrammarAST)Match(input,ID,Follow._ID_in_action299); if (state.failed) return ;
-				a1=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_action303); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-					scope=(id1!=null?id1.Text:null); nameAST=id2; actionAST=a1;
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\DefineGrammarItemsWalker.g3:154:6: a2= ACTION
-				{
-				a2=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_action319); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-					scope=null; nameAST=id1; actionAST=a2;
-				}
-
-				}
-				break;
-
-			}
-
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return ;
-			if ( state.backtracking == 0 )
-			{
-
-						 grammar.DefineNamedAction(amp,scope,nameAST,actionAST);
-
-			}
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "action"
-
-
-	// $ANTLR start "optionsSpec"
-	// Grammars\\DefineGrammarItemsWalker.g3:163:0: optionsSpec : ^( OPTIONS ( . )* ) ;
-	private void optionsSpec(  )
-	{
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:164:4: ( ^( OPTIONS ( . )* ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:164:4: ^( OPTIONS ( . )* )
-			{
-			Match(input,OPTIONS,Follow._OPTIONS_in_optionsSpec353); if (state.failed) return ;
-
-			if ( input.LA(1)==TokenTypes.Down )
-			{
-				Match(input, TokenTypes.Down, null); if (state.failed) return ;
-				// Grammars\\DefineGrammarItemsWalker.g3:164:14: ( . )*
-				for ( ; ; )
-				{
-					int alt11=2;
-					int LA11_0 = input.LA(1);
-
-					if ( ((LA11_0>=ACTION && LA11_0<=XDIGIT)) )
-					{
-						alt11=1;
-					}
-					else if ( (LA11_0==UP) )
-					{
-						alt11=2;
-					}
-
-
-					switch ( alt11 )
-					{
-					case 1:
-						// Grammars\\DefineGrammarItemsWalker.g3:164:0: .
-						{
-						MatchAny(input); if (state.failed) return ;
-
-						}
-						break;
-
-					default:
-						goto loop11;
-					}
-				}
-
-				loop11:
-					;
-
-
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return ;
-			}
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "optionsSpec"
-
-
-	// $ANTLR start "delegateGrammars"
-	// Grammars\\DefineGrammarItemsWalker.g3:167:0: delegateGrammars : ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ ) ;
-	private void delegateGrammars(  )
-	{
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:168:4: ( ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:168:4: ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ )
-			{
-			Match(input,IMPORT,Follow._IMPORT_in_delegateGrammars370); if (state.failed) return ;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return ;
-			// Grammars\\DefineGrammarItemsWalker.g3:168:16: ( ^( ASSIGN ID ID ) | ID )+
-			int cnt12=0;
-			for ( ; ; )
-			{
-				int alt12=3;
-				int LA12_0 = input.LA(1);
-
-				if ( (LA12_0==ASSIGN) )
-				{
-					alt12=1;
-				}
-				else if ( (LA12_0==ID) )
-				{
-					alt12=2;
-				}
-
-
-				switch ( alt12 )
-				{
-				case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:168:18: ^( ASSIGN ID ID )
-					{
-					Match(input,ASSIGN,Follow._ASSIGN_in_delegateGrammars375); if (state.failed) return ;
-
-					Match(input, TokenTypes.Down, null); if (state.failed) return ;
-					Match(input,ID,Follow._ID_in_delegateGrammars377); if (state.failed) return ;
-					Match(input,ID,Follow._ID_in_delegateGrammars379); if (state.failed) return ;
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-					}
-					break;
-				case 2:
-					// Grammars\\DefineGrammarItemsWalker.g3:168:36: ID
-					{
-					Match(input,ID,Follow._ID_in_delegateGrammars384); if (state.failed) return ;
-
-					}
-					break;
-
-				default:
-					if ( cnt12 >= 1 )
-						goto loop12;
-
-					if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee12 = new EarlyExitException( 12, input );
-					throw eee12;
-				}
-				cnt12++;
-			}
-			loop12:
-				;
-
-
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "delegateGrammars"
-
-
-	// $ANTLR start "tokensSpec"
-	// Grammars\\DefineGrammarItemsWalker.g3:171:0: tokensSpec : ^( TOKENS ( tokenSpec )+ ) ;
-	private void tokensSpec(  )
-	{
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:172:4: ( ^( TOKENS ( tokenSpec )+ ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:172:4: ^( TOKENS ( tokenSpec )+ )
-			{
-			Match(input,TOKENS,Follow._TOKENS_in_tokensSpec402); if (state.failed) return ;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return ;
-			// Grammars\\DefineGrammarItemsWalker.g3:172:14: ( tokenSpec )+
-			int cnt13=0;
-			for ( ; ; )
-			{
-				int alt13=2;
-				int LA13_0 = input.LA(1);
-
-				if ( (LA13_0==ASSIGN||LA13_0==TOKEN_REF) )
-				{
-					alt13=1;
-				}
-
-
-				switch ( alt13 )
-				{
-				case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:172:16: tokenSpec
-					{
-					PushFollow(Follow._tokenSpec_in_tokensSpec406);
-					tokenSpec();
-
-					state._fsp--;
-					if (state.failed) return ;
-
-					}
-					break;
-
-				default:
-					if ( cnt13 >= 1 )
-						goto loop13;
-
-					if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee13 = new EarlyExitException( 13, input );
-					throw eee13;
-				}
-				cnt13++;
-			}
-			loop13:
-				;
-
-
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "tokensSpec"
-
-
-	// $ANTLR start "tokenSpec"
-	// Grammars\\DefineGrammarItemsWalker.g3:175:0: tokenSpec : (t= TOKEN_REF | ^( ASSIGN TOKEN_REF ( STRING_LITERAL | CHAR_LITERAL ) ) );
-	private void tokenSpec(  )
-	{
-		GrammarAST t=null;
-
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:176:4: (t= TOKEN_REF | ^( ASSIGN TOKEN_REF ( STRING_LITERAL | CHAR_LITERAL ) ) )
-			int alt14=2;
-			int LA14_0 = input.LA(1);
-
-			if ( (LA14_0==TOKEN_REF) )
-			{
-				alt14=1;
-			}
-			else if ( (LA14_0==ASSIGN) )
-			{
-				alt14=2;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				NoViableAltException nvae = new NoViableAltException("", 14, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt14 )
-			{
-			case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:176:4: t= TOKEN_REF
-				{
-				t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_tokenSpec424); if (state.failed) return ;
-
-				}
-				break;
-			case 2:
-				// Grammars\\DefineGrammarItemsWalker.g3:177:4: ^( ASSIGN TOKEN_REF ( STRING_LITERAL | CHAR_LITERAL ) )
-				{
-				Match(input,ASSIGN,Follow._ASSIGN_in_tokenSpec431); if (state.failed) return ;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return ;
-				Match(input,TOKEN_REF,Follow._TOKEN_REF_in_tokenSpec436); if (state.failed) return ;
-				if ( input.LA(1)==CHAR_LITERAL||input.LA(1)==STRING_LITERAL )
-				{
-					input.Consume();
-					state.errorRecovery=false;state.failed=false;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					MismatchedSetException mse = new MismatchedSetException(null,input);
-					throw mse;
-				}
-
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "tokenSpec"
-
-
-	// $ANTLR start "rules"
-	// Grammars\\DefineGrammarItemsWalker.g3:185:0: rules : ( rule )+ ;
-	private void rules(  )
-	{
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:186:4: ( ( rule )+ )
-			// Grammars\\DefineGrammarItemsWalker.g3:186:4: ( rule )+
-			{
-			// Grammars\\DefineGrammarItemsWalker.g3:186:4: ( rule )+
-			int cnt15=0;
-			for ( ; ; )
-			{
-				int alt15=2;
-				int LA15_0 = input.LA(1);
-
-				if ( (LA15_0==RULE) )
-				{
-					alt15=1;
-				}
-
-
-				switch ( alt15 )
-				{
-				case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:186:0: rule
-					{
-					PushFollow(Follow._rule_in_rules471);
-					rule();
-
-					state._fsp--;
-					if (state.failed) return ;
-
-					}
-					break;
-
-				default:
-					if ( cnt15 >= 1 )
-						goto loop15;
-
-					if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee15 = new EarlyExitException( 15, input );
-					throw eee15;
-				}
-				cnt15++;
-			}
-			loop15:
-				;
-
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "rules"
-
-	public class rule_return : TreeRuleReturnScope
-	{
-	}
-
-	// $ANTLR start "rule"
-	// Grammars\\DefineGrammarItemsWalker.g3:189:0: rule : ^( RULE id= ID ( modifier )? ^( ARG (args= ARG_ACTION )? ) ^( RET (ret= ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec[r] )? ( ruleAction[r] )* b= block ( exceptionGroup )? EOR ) ;
-	private DefineGrammarItemsWalker.rule_return rule(  )
-	{
-		DefineGrammarItemsWalker.rule_return retval = new DefineGrammarItemsWalker.rule_return();
-		retval.start = input.LT(1);
-
-		GrammarAST id=null;
-		GrammarAST args=null;
-		GrammarAST ret=null;
-		GrammarAST RULE3=null;
-		DefineGrammarItemsWalker.block_return b = default(DefineGrammarItemsWalker.block_return);
-		DefineGrammarItemsWalker.modifier_return modifier4 = default(DefineGrammarItemsWalker.modifier_return);
-		HashSet<string> throwsSpec5 = default(HashSet<string>);
-
-
-			string name=null;
-			IDictionary<string,object> opts=null;
-			Rule r = null;
-
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:196:5: ( ^( RULE id= ID ( modifier )? ^( ARG (args= ARG_ACTION )? ) ^( RET (ret= ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec[r] )? ( ruleAction[r] )* b= block ( exceptionGroup )? EOR ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:196:5: ^( RULE id= ID ( modifier )? ^( ARG (args= ARG_ACTION )? ) ^( RET (ret= ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec[r] )? ( ruleAction[r] )* b= block ( exceptionGroup )? EOR )
-			{
-			RULE3=(GrammarAST)Match(input,RULE,Follow._RULE_in_rule491); if (state.failed) return retval;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-			id=(GrammarAST)Match(input,ID,Follow._ID_in_rule495); if (state.failed) return retval;
-			if ( state.backtracking == 0 )
-			{
-				opts = RULE3.BlockOptions;
-			}
-			// Grammars\\DefineGrammarItemsWalker.g3:197:4: ( modifier )?
-			int alt16=2;
-			int LA16_0 = input.LA(1);
-
-			if ( (LA16_0==FRAGMENT||(LA16_0>=PRIVATE && LA16_0<=PUBLIC)) )
-			{
-				alt16=1;
-			}
-			switch ( alt16 )
-			{
-			case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:197:5: modifier
-				{
-				PushFollow(Follow._modifier_in_rule503);
-				modifier4=modifier();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				}
-				break;
-
-			}
-
-			Match(input,ARG,Follow._ARG_in_rule512); if (state.failed) return retval;
-
-			if ( input.LA(1)==TokenTypes.Down )
-			{
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				// Grammars\\DefineGrammarItemsWalker.g3:198:11: (args= ARG_ACTION )?
-				int alt17=2;
-				int LA17_0 = input.LA(1);
-
-				if ( (LA17_0==ARG_ACTION) )
-				{
-					alt17=1;
-				}
-				switch ( alt17 )
-				{
-				case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:198:12: args= ARG_ACTION
-					{
-					args=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule517); if (state.failed) return retval;
-
-					}
-					break;
-
-				}
-
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-			}
-			Match(input,RET,Follow._RET_in_rule528); if (state.failed) return retval;
-
-			if ( input.LA(1)==TokenTypes.Down )
-			{
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				// Grammars\\DefineGrammarItemsWalker.g3:199:11: (ret= ARG_ACTION )?
-				int alt18=2;
-				int LA18_0 = input.LA(1);
-
-				if ( (LA18_0==ARG_ACTION) )
-				{
-					alt18=1;
-				}
-				switch ( alt18 )
-				{
-				case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:199:12: ret= ARG_ACTION
-					{
-					ret=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule533); if (state.failed) return retval;
-
-					}
-					break;
-
-				}
-
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-			}
-			// Grammars\\DefineGrammarItemsWalker.g3:200:4: ( throwsSpec )?
-			int alt19=2;
-			int LA19_0 = input.LA(1);
-
-			if ( (LA19_0==THROWS) )
-			{
-				alt19=1;
-			}
-			switch ( alt19 )
-			{
-			case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:200:5: throwsSpec
-				{
-				PushFollow(Follow._throwsSpec_in_rule543);
-				throwsSpec5=throwsSpec();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				}
-				break;
-
-			}
-
-			// Grammars\\DefineGrammarItemsWalker.g3:201:4: ( optionsSpec )?
-			int alt20=2;
-			int LA20_0 = input.LA(1);
-
-			if ( (LA20_0==OPTIONS) )
-			{
-				alt20=1;
-			}
-			switch ( alt20 )
-			{
-			case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:201:5: optionsSpec
-				{
-				PushFollow(Follow._optionsSpec_in_rule551);
-				optionsSpec();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				}
-				break;
-
-			}
-
-			if ( state.backtracking == 0 )
-			{
-
-								name = (id!=null?id.Text:null);
-								currentRuleName = name;
-								if ( char.IsUpper(name[0]) && grammar.type==GrammarType.Combined )
-								{
-									// a merged grammar spec, track lexer rules and send to another grammar
-									grammar.DefineLexerRuleFoundInParser(id.token, ((GrammarAST)retval.Start));
-								}
-								else
-								{
-									int numAlts = CountAltsForRule(((GrammarAST)retval.Start));
-									grammar.DefineRule(id.Token, (modifier4!=null?modifier4.mod:default(string)), opts, ((GrammarAST)retval.Start), args, numAlts);
-									r = grammar.GetRule(name);
-									if ( args!=null )
-									{
-										r.parameterScope = grammar.CreateParameterScope(name,args.Token);
-										r.parameterScope.AddAttributes((args!=null?args.Text:null), ',');
-									}
-									if ( ret!=null )
-									{
-										r.returnScope = grammar.CreateReturnScope(name,ret.token);
-										r.returnScope.AddAttributes((ret!=null?ret.Text:null), ',');
-									}
-									if ( throwsSpec5 != null )
-									{
-										foreach ( string exception in throwsSpec5 )
-											r.throwsSpec.Add( exception );
-									}
-								}
-
-			}
-			// Grammars\\DefineGrammarItemsWalker.g3:232:4: ( ruleScopeSpec[r] )?
-			int alt21=2;
-			int LA21_0 = input.LA(1);
-
-			if ( (LA21_0==SCOPE) )
-			{
-				alt21=1;
-			}
-			switch ( alt21 )
-			{
-			case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:232:5: ruleScopeSpec[r]
-				{
-				PushFollow(Follow._ruleScopeSpec_in_rule564);
-				ruleScopeSpec(r);
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				}
-				break;
-
-			}
-
-			// Grammars\\DefineGrammarItemsWalker.g3:233:4: ( ruleAction[r] )*
-			for ( ; ; )
-			{
-				int alt22=2;
-				int LA22_0 = input.LA(1);
-
-				if ( (LA22_0==AMPERSAND) )
-				{
-					alt22=1;
-				}
-
-
-				switch ( alt22 )
-				{
-				case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:233:5: ruleAction[r]
-					{
-					PushFollow(Follow._ruleAction_in_rule573);
-					ruleAction(r);
-
-					state._fsp--;
-					if (state.failed) return retval;
-
-					}
-					break;
-
-				default:
-					goto loop22;
-				}
-			}
-
-			loop22:
-				;
-
-
-			if ( state.backtracking == 0 )
-			{
-				 this.blockLevel=0;
-			}
-			PushFollow(Follow._block_in_rule588);
-			b=block();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			// Grammars\\DefineGrammarItemsWalker.g3:236:4: ( exceptionGroup )?
-			int alt23=2;
-			int LA23_0 = input.LA(1);
-
-			if ( (LA23_0==CATCH||LA23_0==FINALLY) )
-			{
-				alt23=1;
-			}
-			switch ( alt23 )
-			{
-			case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:236:5: exceptionGroup
-				{
-				PushFollow(Follow._exceptionGroup_in_rule594);
-				exceptionGroup();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				}
-				break;
-
-			}
-
-			Match(input,EOR,Follow._EOR_in_rule601); if (state.failed) return retval;
-			if ( state.backtracking == 0 )
-			{
-
-								// copy rule options into the block AST, which is where
-								// the analysis will look for k option etc...
-								(b!=null?((GrammarAST)b.Start):null).BlockOptions = opts;
-
-			}
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "rule"
-
-
-	// $ANTLR start "ruleAction"
-	// Grammars\\DefineGrammarItemsWalker.g3:246:0: ruleAction[Rule r] : ^(amp= AMPERSAND id= ID a= ACTION ) ;
-	private void ruleAction( Rule r )
-	{
-		GrammarAST amp=null;
-		GrammarAST id=null;
-		GrammarAST a=null;
-
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:247:4: ( ^(amp= AMPERSAND id= ID a= ACTION ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:247:4: ^(amp= AMPERSAND id= ID a= ACTION )
-			{
-			amp=(GrammarAST)Match(input,AMPERSAND,Follow._AMPERSAND_in_ruleAction625); if (state.failed) return ;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return ;
-			id=(GrammarAST)Match(input,ID,Follow._ID_in_ruleAction629); if (state.failed) return ;
-			a=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_ruleAction633); if (state.failed) return ;
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return ;
-			if ( state.backtracking == 0 )
-			{
-				if (r!=null) r.DefineNamedAction(amp,id,a);
-			}
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "ruleAction"
-
-	public class modifier_return : TreeRuleReturnScope
-	{
-		public string mod;
-	}
-
-	// $ANTLR start "modifier"
-	// Grammars\\DefineGrammarItemsWalker.g3:250:0: modifier returns [string mod] : ( 'protected' | 'public' | 'private' | 'fragment' );
-	private DefineGrammarItemsWalker.modifier_return modifier(  )
-	{
-		DefineGrammarItemsWalker.modifier_return retval = new DefineGrammarItemsWalker.modifier_return();
-		retval.start = input.LT(1);
-
-
-			retval.mod = ((GrammarAST)retval.Start).Token.Text;
-
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:255:4: ( 'protected' | 'public' | 'private' | 'fragment' )
-			// Grammars\\DefineGrammarItemsWalker.g3:
-			{
-			if ( input.LA(1)==FRAGMENT||(input.LA(1)>=PRIVATE && input.LA(1)<=PUBLIC) )
-			{
-				input.Consume();
-				state.errorRecovery=false;state.failed=false;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return retval;}
-				MismatchedSetException mse = new MismatchedSetException(null,input);
-				throw mse;
-			}
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "modifier"
-
-
-	// $ANTLR start "throwsSpec"
-	// Grammars\\DefineGrammarItemsWalker.g3:261:0: throwsSpec returns [HashSet<string> exceptions] : ^( 'throws' ( ID )+ ) ;
-	private HashSet<string> throwsSpec(  )
-	{
-		HashSet<string> exceptions = default(HashSet<string>);
-
-		GrammarAST ID6=null;
-
-
-			exceptions = new HashSet<string>();
-
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:266:4: ( ^( 'throws' ( ID )+ ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:266:4: ^( 'throws' ( ID )+ )
-			{
-			Match(input,THROWS,Follow._THROWS_in_throwsSpec693); if (state.failed) return exceptions;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return exceptions;
-			// Grammars\\DefineGrammarItemsWalker.g3:266:15: ( ID )+
-			int cnt24=0;
-			for ( ; ; )
-			{
-				int alt24=2;
-				int LA24_0 = input.LA(1);
-
-				if ( (LA24_0==ID) )
-				{
-					alt24=1;
-				}
-
-
-				switch ( alt24 )
-				{
-				case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:266:16: ID
-					{
-					ID6=(GrammarAST)Match(input,ID,Follow._ID_in_throwsSpec696); if (state.failed) return exceptions;
-					if ( state.backtracking == 0 )
-					{
-						exceptions.Add((ID6!=null?ID6.Text:null));
-					}
-
-					}
-					break;
-
-				default:
-					if ( cnt24 >= 1 )
-						goto loop24;
-
-					if (state.backtracking>0) {state.failed=true; return exceptions;}
-					EarlyExitException eee24 = new EarlyExitException( 24, input );
-					throw eee24;
-				}
-				cnt24++;
-			}
-			loop24:
-				;
-
-
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return exceptions;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return exceptions;
-	}
-	// $ANTLR end "throwsSpec"
-
-
-	// $ANTLR start "ruleScopeSpec"
-	// Grammars\\DefineGrammarItemsWalker.g3:269:0: ruleScopeSpec[Rule r] : ^( 'scope' ( ( attrScopeAction )* attrs= ACTION )? (uses= ID )* ) ;
-	private void ruleScopeSpec( Rule r )
-	{
-		AttributeScopeActions_stack.Push(new AttributeScopeActions_scope());AttributeScopeActions_scopeInit(AttributeScopeActions_stack.Peek());
-
-		GrammarAST attrs=null;
-		GrammarAST uses=null;
-
-
-			((AttributeScopeActions_scope)AttributeScopeActions_stack.Peek()).actions = new Dictionary<GrammarAST, GrammarAST>();
-
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:275:4: ( ^( 'scope' ( ( attrScopeAction )* attrs= ACTION )? (uses= ID )* ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:275:4: ^( 'scope' ( ( attrScopeAction )* attrs= ACTION )? (uses= ID )* )
-			{
-			Match(input,SCOPE,Follow._SCOPE_in_ruleScopeSpec726); if (state.failed) return ;
-
-			if ( input.LA(1)==TokenTypes.Down )
-			{
-				Match(input, TokenTypes.Down, null); if (state.failed) return ;
-				// Grammars\\DefineGrammarItemsWalker.g3:276:4: ( ( attrScopeAction )* attrs= ACTION )?
-				int alt26=2;
-				int LA26_0 = input.LA(1);
-
-				if ( (LA26_0==ACTION||LA26_0==AMPERSAND) )
-				{
-					alt26=1;
-				}
-				switch ( alt26 )
-				{
-				case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:276:6: ( attrScopeAction )* attrs= ACTION
-					{
-					// Grammars\\DefineGrammarItemsWalker.g3:276:6: ( attrScopeAction )*
-					for ( ; ; )
-					{
-						int alt25=2;
-						int LA25_0 = input.LA(1);
-
-						if ( (LA25_0==AMPERSAND) )
-						{
-							alt25=1;
-						}
-
-
-						switch ( alt25 )
-						{
-						case 1:
-							// Grammars\\DefineGrammarItemsWalker.g3:276:0: attrScopeAction
-							{
-							PushFollow(Follow._attrScopeAction_in_ruleScopeSpec733);
-							attrScopeAction();
-
-							state._fsp--;
-							if (state.failed) return ;
-
-							}
-							break;
-
-						default:
-							goto loop25;
-						}
-					}
-
-					loop25:
-						;
-
-
-					attrs=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_ruleScopeSpec738); if (state.failed) return ;
-					if ( state.backtracking == 0 )
-					{
-
-											r.ruleScope = grammar.CreateRuleScope(r.name,attrs.token);
-											r.ruleScope.isDynamicRuleScope = true;
-											r.ruleScope.AddAttributes((attrs!=null?attrs.Text:null), ';');
-											foreach ( var action in ((AttributeScopeActions_scope)AttributeScopeActions_stack.Peek()).actions )
-												r.ruleScope.DefineNamedAction( action.Key, action.Value );
-
-					}
-
-					}
-					break;
-
-				}
-
-				// Grammars\\DefineGrammarItemsWalker.g3:285:4: (uses= ID )*
-				for ( ; ; )
-				{
-					int alt27=2;
-					int LA27_0 = input.LA(1);
-
-					if ( (LA27_0==ID) )
-					{
-						alt27=1;
-					}
-
-
-					switch ( alt27 )
-					{
-					case 1:
-						// Grammars\\DefineGrammarItemsWalker.g3:285:6: uses= ID
-						{
-						uses=(GrammarAST)Match(input,ID,Follow._ID_in_ruleScopeSpec759); if (state.failed) return ;
-						if ( state.backtracking == 0 )
-						{
-
-												if ( grammar.GetGlobalScope((uses!=null?uses.Text:null))==null ) {
-												ErrorManager.GrammarError(ErrorManager.MSG_UNKNOWN_DYNAMIC_SCOPE,
-												grammar,
-												uses.token,
-												(uses!=null?uses.Text:null));
-												}
-												else {
-												if ( r.useScopes==null ) {r.useScopes=new List<string>();}
-												r.useScopes.Add((uses!=null?uses.Text:null));
-												}
-
-						}
-
-						}
-						break;
-
-					default:
-						goto loop27;
-					}
-				}
-
-				loop27:
-					;
-
-
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return ;
-			}
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-			AttributeScopeActions_scopeAfter(AttributeScopeActions_stack.Peek());AttributeScopeActions_stack.Pop();
-
-		}
-		return ;
-	}
-	// $ANTLR end "ruleScopeSpec"
-
-	public class block_return : TreeRuleReturnScope
-	{
-	}
-
-	// $ANTLR start "block"
-	// Grammars\\DefineGrammarItemsWalker.g3:302:0: block : ^( BLOCK ( optionsSpec )? ( blockAction )* ( alternative rewrite )+ EOB ) ;
-	private DefineGrammarItemsWalker.block_return block(  )
-	{
-		DefineGrammarItemsWalker.block_return retval = new DefineGrammarItemsWalker.block_return();
-		retval.start = input.LT(1);
-
-
-			// must run during backtracking
-			this.blockLevel++;
-			if ( blockLevel == 1 )
-				this.outerAltNum=1;
-
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:310:4: ( ^( BLOCK ( optionsSpec )? ( blockAction )* ( alternative rewrite )+ EOB ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:310:4: ^( BLOCK ( optionsSpec )? ( blockAction )* ( alternative rewrite )+ EOB )
-			{
-			Match(input,BLOCK,Follow._BLOCK_in_block793); if (state.failed) return retval;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-			// Grammars\\DefineGrammarItemsWalker.g3:311:4: ( optionsSpec )?
-			int alt28=2;
-			int LA28_0 = input.LA(1);
-
-			if ( (LA28_0==OPTIONS) )
-			{
-				alt28=1;
-			}
-			switch ( alt28 )
-			{
-			case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:311:5: optionsSpec
-				{
-				PushFollow(Follow._optionsSpec_in_block799);
-				optionsSpec();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				}
-				break;
-
-			}
-
-			// Grammars\\DefineGrammarItemsWalker.g3:312:4: ( blockAction )*
-			for ( ; ; )
-			{
-				int alt29=2;
-				int LA29_0 = input.LA(1);
-
-				if ( (LA29_0==AMPERSAND) )
-				{
-					alt29=1;
-				}
-
-
-				switch ( alt29 )
-				{
-				case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:312:5: blockAction
-					{
-					PushFollow(Follow._blockAction_in_block807);
-					blockAction();
-
-					state._fsp--;
-					if (state.failed) return retval;
-
-					}
-					break;
-
-				default:
-					goto loop29;
-				}
-			}
-
-			loop29:
-				;
-
-
-			// Grammars\\DefineGrammarItemsWalker.g3:313:4: ( alternative rewrite )+
-			int cnt30=0;
-			for ( ; ; )
-			{
-				int alt30=2;
-				int LA30_0 = input.LA(1);
-
-				if ( (LA30_0==ALT) )
-				{
-					alt30=1;
-				}
-
-
-				switch ( alt30 )
-				{
-				case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:313:6: alternative rewrite
-					{
-					PushFollow(Follow._alternative_in_block816);
-					alternative();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					PushFollow(Follow._rewrite_in_block818);
-					rewrite();
-
-					state._fsp--;
-					if (state.failed) return retval;
-
-										if ( this.blockLevel == 1 )
-											this.outerAltNum++;
-
-
-					}
-					break;
-
-				default:
-					if ( cnt30 >= 1 )
-						goto loop30;
-
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					EarlyExitException eee30 = new EarlyExitException( 30, input );
-					throw eee30;
-				}
-				cnt30++;
-			}
-			loop30:
-				;
-
-
-			Match(input,EOB,Follow._EOB_in_block835); if (state.failed) return retval;
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-			 blockLevel--;
-		}
-		return retval;
-	}
-	// $ANTLR end "block"
-
-
-	// $ANTLR start "blockAction"
-	// Grammars\\DefineGrammarItemsWalker.g3:325:0: blockAction : ^(amp= AMPERSAND id= ID a= ACTION ) ;
-	private void blockAction(  )
-	{
-		GrammarAST amp=null;
-		GrammarAST id=null;
-		GrammarAST a=null;
-
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:326:4: ( ^(amp= AMPERSAND id= ID a= ACTION ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:326:4: ^(amp= AMPERSAND id= ID a= ACTION )
-			{
-			amp=(GrammarAST)Match(input,AMPERSAND,Follow._AMPERSAND_in_blockAction859); if (state.failed) return ;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return ;
-			id=(GrammarAST)Match(input,ID,Follow._ID_in_blockAction863); if (state.failed) return ;
-			a=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_blockAction867); if (state.failed) return ;
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "blockAction"
-
-	public class alternative_return : TreeRuleReturnScope
-	{
-	}
-
-	// $ANTLR start "alternative"
-	// Grammars\\DefineGrammarItemsWalker.g3:329:0: alternative : ^( ALT ( element )+ EOA ) ;
-	private DefineGrammarItemsWalker.alternative_return alternative(  )
-	{
-		DefineGrammarItemsWalker.alternative_return retval = new DefineGrammarItemsWalker.alternative_return();
-		retval.start = input.LT(1);
-
-
-			if ( state.backtracking == 0 )
-			{
-				if ( grammar.type!=GrammarType.Lexer && grammar.GetOption("output")!=null && blockLevel==1 )
-				{
-					GrammarAST aRewriteNode = ((GrammarAST)retval.Start).FindFirstType(REWRITE); // alt itself has rewrite?
-					GrammarAST rewriteAST = (GrammarAST)((GrammarAST)retval.Start).Parent.GetChild(((GrammarAST)retval.Start).ChildIndex + 1);
-					// we have a rewrite if alt uses it inside subrule or this alt has one
-					// but don't count -> ... rewrites, which mean "do default auto construction"
-					if ( aRewriteNode!=null||
-						 (rewriteAST!=null &&
-						  rewriteAST.Type==REWRITE &&
-						  rewriteAST.GetChild(0)!=null &&
-						  rewriteAST.GetChild(0).Type!=ETC) )
-					{
-						Rule r = grammar.GetRule(currentRuleName);
-						r.TrackAltsWithRewrites(((GrammarAST)retval.Start),this.outerAltNum);
-					}
-				}
-			}
-
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:352:4: ( ^( ALT ( element )+ EOA ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:352:4: ^( ALT ( element )+ EOA )
-			{
-			Match(input,ALT,Follow._ALT_in_alternative888); if (state.failed) return retval;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-			// Grammars\\DefineGrammarItemsWalker.g3:352:11: ( element )+
-			int cnt31=0;
-			for ( ; ; )
-			{
-				int alt31=2;
-				int LA31_0 = input.LA(1);
-
-				if ( (LA31_0==ACTION||(LA31_0>=ASSIGN && LA31_0<=BLOCK)||(LA31_0>=CHAR_LITERAL && LA31_0<=CHAR_RANGE)||LA31_0==CLOSURE||LA31_0==DOT||LA31_0==EPSILON||LA31_0==FORCED_ACTION||LA31_0==GATED_SEMPRED||LA31_0==NOT||LA31_0==OPTIONAL||(LA31_0>=PLUS_ASSIGN && LA31_0<=POSITIVE_CLOSURE)||LA31_0==RANGE||LA31_0==ROOT||LA31_0==RULE_REF||LA31_0==SEMPRED||(LA31_0>=STRING_LITERAL && LA31_0<=SYNPRED)||LA31_0==TOKEN_REF||LA31_0==TREE_BEGIN||LA31_0==WILDCARD) )
-				{
-					alt31=1;
-				}
-
-
-				switch ( alt31 )
-				{
-				case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:352:12: element
-					{
-					PushFollow(Follow._element_in_alternative891);
-					element();
-
-					state._fsp--;
-					if (state.failed) return retval;
-
-					}
-					break;
-
-				default:
-					if ( cnt31 >= 1 )
-						goto loop31;
-
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					EarlyExitException eee31 = new EarlyExitException( 31, input );
-					throw eee31;
-				}
-				cnt31++;
-			}
-			loop31:
-				;
-
-
-			Match(input,EOA,Follow._EOA_in_alternative895); if (state.failed) return retval;
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "alternative"
-
-
-	// $ANTLR start "exceptionGroup"
-	// Grammars\\DefineGrammarItemsWalker.g3:355:0: exceptionGroup : ( ( exceptionHandler )+ ( finallyClause )? | finallyClause );
-	private void exceptionGroup(  )
-	{
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:356:4: ( ( exceptionHandler )+ ( finallyClause )? | finallyClause )
-			int alt34=2;
-			int LA34_0 = input.LA(1);
-
-			if ( (LA34_0==CATCH) )
-			{
-				alt34=1;
-			}
-			else if ( (LA34_0==FINALLY) )
-			{
-				alt34=2;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				NoViableAltException nvae = new NoViableAltException("", 34, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt34 )
-			{
-			case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:356:4: ( exceptionHandler )+ ( finallyClause )?
-				{
-				// Grammars\\DefineGrammarItemsWalker.g3:356:4: ( exceptionHandler )+
-				int cnt32=0;
-				for ( ; ; )
-				{
-					int alt32=2;
-					int LA32_0 = input.LA(1);
-
-					if ( (LA32_0==CATCH) )
-					{
-						alt32=1;
-					}
-
-
-					switch ( alt32 )
-					{
-					case 1:
-						// Grammars\\DefineGrammarItemsWalker.g3:356:6: exceptionHandler
-						{
-						PushFollow(Follow._exceptionHandler_in_exceptionGroup910);
-						exceptionHandler();
-
-						state._fsp--;
-						if (state.failed) return ;
-
-						}
-						break;
-
-					default:
-						if ( cnt32 >= 1 )
-							goto loop32;
-
-						if (state.backtracking>0) {state.failed=true; return ;}
-						EarlyExitException eee32 = new EarlyExitException( 32, input );
-						throw eee32;
-					}
-					cnt32++;
-				}
-				loop32:
-					;
-
-
-				// Grammars\\DefineGrammarItemsWalker.g3:356:26: ( finallyClause )?
-				int alt33=2;
-				int LA33_0 = input.LA(1);
-
-				if ( (LA33_0==FINALLY) )
-				{
-					alt33=1;
-				}
-				switch ( alt33 )
-				{
-				case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:356:27: finallyClause
-					{
-					PushFollow(Follow._finallyClause_in_exceptionGroup916);
-					finallyClause();
-
-					state._fsp--;
-					if (state.failed) return ;
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-			case 2:
-				// Grammars\\DefineGrammarItemsWalker.g3:357:4: finallyClause
-				{
-				PushFollow(Follow._finallyClause_in_exceptionGroup923);
-				finallyClause();
-
-				state._fsp--;
-				if (state.failed) return ;
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "exceptionGroup"
-
-
-	// $ANTLR start "exceptionHandler"
-	// Grammars\\DefineGrammarItemsWalker.g3:360:0: exceptionHandler : ^( 'catch' ARG_ACTION ACTION ) ;
-	private void exceptionHandler(  )
-	{
-		GrammarAST ACTION7=null;
-
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:361:6: ( ^( 'catch' ARG_ACTION ACTION ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:361:6: ^( 'catch' ARG_ACTION ACTION )
-			{
-			Match(input,CATCH,Follow._CATCH_in_exceptionHandler937); if (state.failed) return ;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return ;
-			Match(input,ARG_ACTION,Follow._ARG_ACTION_in_exceptionHandler939); if (state.failed) return ;
-			ACTION7=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_exceptionHandler941); if (state.failed) return ;
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return ;
-			if ( state.backtracking == 0 )
-			{
-				TrackInlineAction(ACTION7);
-			}
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "exceptionHandler"
-
-
-	// $ANTLR start "finallyClause"
-	// Grammars\\DefineGrammarItemsWalker.g3:364:0: finallyClause : ^( 'finally' ACTION ) ;
-	private void finallyClause(  )
-	{
-		GrammarAST ACTION8=null;
-
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:365:7: ( ^( 'finally' ACTION ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:365:7: ^( 'finally' ACTION )
-			{
-			Match(input,FINALLY,Follow._FINALLY_in_finallyClause959); if (state.failed) return ;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return ;
-			ACTION8=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_finallyClause961); if (state.failed) return ;
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return ;
-			if ( state.backtracking == 0 )
-			{
-				TrackInlineAction(ACTION8);
-			}
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "finallyClause"
-
-	public class element_return : TreeRuleReturnScope
-	{
-	}
-
-	// $ANTLR start "element"
-	// Grammars\\DefineGrammarItemsWalker.g3:368:0: element : ( ^( ROOT element ) | ^( BANG element ) | atom[null] | ^( NOT element ) | ^( RANGE atom[null] atom[null] ) | ^( CHAR_RANGE atom[null] atom[null] ) | ^( ASSIGN id= ID el= element ) | ^( PLUS_ASSIGN id2= ID a2= element ) | ebnf | tree_ | ^( SYNPRED block ) |act= ACTION |act2= FORCED_ACTION | SEMPRED | SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) | GATED_SEMPRED | EPSILON );
-	private DefineGrammarItemsWalker.element_return element(  )
-	{
-		DefineGrammarItemsWalker.element_return retval = new DefineGrammarItemsWalker.element_return();
-		retval.start = input.LT(1);
-
-		GrammarAST id=null;
-		GrammarAST id2=null;
-		GrammarAST act=null;
-		GrammarAST act2=null;
-		GrammarAST SEMPRED9=null;
-		GrammarAST GATED_SEMPRED10=null;
-		DefineGrammarItemsWalker.element_return el = default(DefineGrammarItemsWalker.element_return);
-		DefineGrammarItemsWalker.element_return a2 = default(DefineGrammarItemsWalker.element_return);
-
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:369:6: ( ^( ROOT element ) | ^( BANG element ) | atom[null] | ^( NOT element ) | ^( RANGE atom[null] atom[null] ) | ^( CHAR_RANGE atom[null] atom[null] ) | ^( ASSIGN id= ID el= element ) | ^( PLUS_ASSIGN id2= ID a2= element ) | ebnf | tree_ | ^( SYNPRED block ) |act= ACTION |act2= FORCED_ACTION | SEMPRED | SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) | GATED_SEMPRED | EPSILON )
-			int alt36=18;
-			alt36 = dfa36.Predict(input);
-			switch ( alt36 )
-			{
-			case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:369:6: ^( ROOT element )
-				{
-				Match(input,ROOT,Follow._ROOT_in_element978); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				PushFollow(Follow._element_in_element980);
-				element();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-
-				}
-				break;
-			case 2:
-				// Grammars\\DefineGrammarItemsWalker.g3:370:6: ^( BANG element )
-				{
-				Match(input,BANG,Follow._BANG_in_element989); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				PushFollow(Follow._element_in_element991);
-				element();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-
-				}
-				break;
-			case 3:
-				// Grammars\\DefineGrammarItemsWalker.g3:371:6: atom[null]
-				{
-				PushFollow(Follow._atom_in_element999);
-				atom(null);
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				}
-				break;
-			case 4:
-				// Grammars\\DefineGrammarItemsWalker.g3:372:6: ^( NOT element )
-				{
-				Match(input,NOT,Follow._NOT_in_element1008); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				PushFollow(Follow._element_in_element1010);
-				element();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-
-				}
-				break;
-			case 5:
-				// Grammars\\DefineGrammarItemsWalker.g3:373:6: ^( RANGE atom[null] atom[null] )
-				{
-				Match(input,RANGE,Follow._RANGE_in_element1019); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				PushFollow(Follow._atom_in_element1021);
-				atom(null);
-
-				state._fsp--;
-				if (state.failed) return retval;
-				PushFollow(Follow._atom_in_element1024);
-				atom(null);
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-
-				}
-				break;
-			case 6:
-				// Grammars\\DefineGrammarItemsWalker.g3:374:6: ^( CHAR_RANGE atom[null] atom[null] )
-				{
-				Match(input,CHAR_RANGE,Follow._CHAR_RANGE_in_element1034); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				PushFollow(Follow._atom_in_element1036);
-				atom(null);
-
-				state._fsp--;
-				if (state.failed) return retval;
-				PushFollow(Follow._atom_in_element1039);
-				atom(null);
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-
-				}
-				break;
-			case 7:
-				// Grammars\\DefineGrammarItemsWalker.g3:375:4: ^( ASSIGN id= ID el= element )
-				{
-				Match(input,ASSIGN,Follow._ASSIGN_in_element1048); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				id=(GrammarAST)Match(input,ID,Follow._ID_in_element1052); if (state.failed) return retval;
-				PushFollow(Follow._element_in_element1056);
-				el=element();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-
-									GrammarAST e = (el!=null?((GrammarAST)el.Start):null);
-									if ( e.Type==ANTLRParser.ROOT || e.Type==ANTLRParser.BANG )
-									{
-										e = (GrammarAST)e.GetChild(0);
-									}
-									if ( e.Type==RULE_REF)
-									{
-										grammar.DefineRuleRefLabel(currentRuleName,id.token,e);
-									}
-									else if ( e.Type==WILDCARD && grammar.type==GrammarType.TreeParser )
-									{
-										grammar.DefineWildcardTreeLabel(currentRuleName,id.token,e);
-									}
-									else
-									{
-										grammar.DefineTokenRefLabel(currentRuleName,id.Token,e);
-									}
-
-				}
-
-				}
-				break;
-			case 8:
-				// Grammars\\DefineGrammarItemsWalker.g3:395:4: ^( PLUS_ASSIGN id2= ID a2= element )
-				{
-				Match(input,PLUS_ASSIGN,Follow._PLUS_ASSIGN_in_element1069); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				id2=(GrammarAST)Match(input,ID,Follow._ID_in_element1073); if (state.failed) return retval;
-				PushFollow(Follow._element_in_element1077);
-				a2=element();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-
-									GrammarAST a = (a2!=null?((GrammarAST)a2.Start):null);
-									if ( a.Type==ANTLRParser.ROOT || a.Type==ANTLRParser.BANG )
-									{
-										a = (GrammarAST)a.GetChild(0);
-									}
-									if ( a.Type==RULE_REF )
-									{
-										grammar.DefineRuleListLabel(currentRuleName,id2.Token,a);
-									}
-									else if ( a.Type == WILDCARD && grammar.type == GrammarType.TreeParser )
-									{
-										grammar.DefineWildcardTreeListLabel( currentRuleName, id2.token, a );
-									}
-									else
-									{
-										grammar.DefineTokenListLabel(currentRuleName,id2.Token,a);
-									}
-
-				}
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-
-				}
-				break;
-			case 9:
-				// Grammars\\DefineGrammarItemsWalker.g3:416:6: ebnf
-				{
-				PushFollow(Follow._ebnf_in_element1094);
-				ebnf();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				}
-				break;
-			case 10:
-				// Grammars\\DefineGrammarItemsWalker.g3:417:6: tree_
-				{
-				PushFollow(Follow._tree__in_element1101);
-				tree_();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				}
-				break;
-			case 11:
-				// Grammars\\DefineGrammarItemsWalker.g3:418:6: ^( SYNPRED block )
-				{
-				Match(input,SYNPRED,Follow._SYNPRED_in_element1110); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				PushFollow(Follow._block_in_element1112);
-				block();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-
-				}
-				break;
-			case 12:
-				// Grammars\\DefineGrammarItemsWalker.g3:419:6: act= ACTION
-				{
-				act=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_element1123); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-
-								act.outerAltNum = this.outerAltNum;
-								TrackInlineAction(act);
-
-				}
-
-				}
-				break;
-			case 13:
-				// Grammars\\DefineGrammarItemsWalker.g3:424:6: act2= FORCED_ACTION
-				{
-				act2=(GrammarAST)Match(input,FORCED_ACTION,Follow._FORCED_ACTION_in_element1136); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-
-								act2.outerAltNum = this.outerAltNum;
-								TrackInlineAction(act2);
-
-				}
-
-				}
-				break;
-			case 14:
-				// Grammars\\DefineGrammarItemsWalker.g3:429:6: SEMPRED
-				{
-				SEMPRED9=(GrammarAST)Match(input,SEMPRED,Follow._SEMPRED_in_element1147); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-
-								SEMPRED9.outerAltNum = this.outerAltNum;
-								TrackInlineAction(SEMPRED9);
-
-				}
-
-				}
-				break;
-			case 15:
-				// Grammars\\DefineGrammarItemsWalker.g3:434:6: SYN_SEMPRED
-				{
-				Match(input,SYN_SEMPRED,Follow._SYN_SEMPRED_in_element1158); if (state.failed) return retval;
-
-				}
-				break;
-			case 16:
-				// Grammars\\DefineGrammarItemsWalker.g3:435:6: ^( BACKTRACK_SEMPRED ( . )* )
-				{
-				Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_element1166); if (state.failed) return retval;
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-					// Grammars\\DefineGrammarItemsWalker.g3:435:26: ( . )*
-					for ( ; ; )
-					{
-						int alt35=2;
-						int LA35_0 = input.LA(1);
-
-						if ( ((LA35_0>=ACTION && LA35_0<=XDIGIT)) )
-						{
-							alt35=1;
-						}
-						else if ( (LA35_0==UP) )
-						{
-							alt35=2;
-						}
-
-
-						switch ( alt35 )
-						{
-						case 1:
-							// Grammars\\DefineGrammarItemsWalker.g3:435:0: .
-							{
-							MatchAny(input); if (state.failed) return retval;
-
-							}
-							break;
-
-						default:
-							goto loop35;
-						}
-					}
-
-					loop35:
-						;
-
-
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				}
-
-				}
-				break;
-			case 17:
-				// Grammars\\DefineGrammarItemsWalker.g3:436:6: GATED_SEMPRED
-				{
-				GATED_SEMPRED10=(GrammarAST)Match(input,GATED_SEMPRED,Follow._GATED_SEMPRED_in_element1177); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-
-								GATED_SEMPRED10.outerAltNum = this.outerAltNum;
-								TrackInlineAction(GATED_SEMPRED10);
-
-				}
-
-				}
-				break;
-			case 18:
-				// Grammars\\DefineGrammarItemsWalker.g3:441:6: EPSILON
-				{
-				Match(input,EPSILON,Follow._EPSILON_in_element1188); if (state.failed) return retval;
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "element"
-
-
-	// $ANTLR start "ebnf"
-	// Grammars\\DefineGrammarItemsWalker.g3:444:0: ebnf : (=> dotLoop | block | ^( OPTIONAL block ) | ^( CLOSURE block ) | ^( POSITIVE_CLOSURE block ) );
-	private void ebnf(  )
-	{
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:445:4: (=> dotLoop | block | ^( OPTIONAL block ) | ^( CLOSURE block ) | ^( POSITIVE_CLOSURE block ) )
-			int alt37=5;
-			alt37 = dfa37.Predict(input);
-			switch ( alt37 )
-			{
-			case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:445:4: => dotLoop
-				{
-
-				PushFollow(Follow._dotLoop_in_ebnf1206);
-				dotLoop();
-
-				state._fsp--;
-				if (state.failed) return ;
-
-				}
-				break;
-			case 2:
-				// Grammars\\DefineGrammarItemsWalker.g3:446:4: block
-				{
-				PushFollow(Follow._block_in_ebnf1212);
-				block();
-
-				state._fsp--;
-				if (state.failed) return ;
-
-				}
-				break;
-			case 3:
-				// Grammars\\DefineGrammarItemsWalker.g3:447:4: ^( OPTIONAL block )
-				{
-				Match(input,OPTIONAL,Follow._OPTIONAL_in_ebnf1219); if (state.failed) return ;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return ;
-				PushFollow(Follow._block_in_ebnf1221);
-				block();
-
-				state._fsp--;
-				if (state.failed) return ;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-				}
-				break;
-			case 4:
-				// Grammars\\DefineGrammarItemsWalker.g3:448:4: ^( CLOSURE block )
-				{
-				Match(input,CLOSURE,Follow._CLOSURE_in_ebnf1230); if (state.failed) return ;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return ;
-				PushFollow(Follow._block_in_ebnf1232);
-				block();
-
-				state._fsp--;
-				if (state.failed) return ;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-				}
-				break;
-			case 5:
-				// Grammars\\DefineGrammarItemsWalker.g3:449:4: ^( POSITIVE_CLOSURE block )
-				{
-				Match(input,POSITIVE_CLOSURE,Follow._POSITIVE_CLOSURE_in_ebnf1241); if (state.failed) return ;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return ;
-				PushFollow(Follow._block_in_ebnf1243);
-				block();
-
-				state._fsp--;
-				if (state.failed) return ;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "ebnf"
-
-	public class dotLoop_return : TreeRuleReturnScope
-	{
-	}
-
-	// $ANTLR start "dotLoop"
-	// Grammars\\DefineGrammarItemsWalker.g3:454:0: dotLoop : ( ^( CLOSURE dotBlock ) | ^( POSITIVE_CLOSURE dotBlock ) ) ;
-	private DefineGrammarItemsWalker.dotLoop_return dotLoop(  )
-	{
-		DefineGrammarItemsWalker.dotLoop_return retval = new DefineGrammarItemsWalker.dotLoop_return();
-		retval.start = input.LT(1);
-
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:455:4: ( ( ^( CLOSURE dotBlock ) | ^( POSITIVE_CLOSURE dotBlock ) ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:455:4: ( ^( CLOSURE dotBlock ) | ^( POSITIVE_CLOSURE dotBlock ) )
-			{
-			// Grammars\\DefineGrammarItemsWalker.g3:455:4: ( ^( CLOSURE dotBlock ) | ^( POSITIVE_CLOSURE dotBlock ) )
-			int alt38=2;
-			int LA38_0 = input.LA(1);
-
-			if ( (LA38_0==CLOSURE) )
-			{
-				alt38=1;
-			}
-			else if ( (LA38_0==POSITIVE_CLOSURE) )
-			{
-				alt38=2;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return retval;}
-				NoViableAltException nvae = new NoViableAltException("", 38, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt38 )
-			{
-			case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:455:6: ^( CLOSURE dotBlock )
-				{
-				Match(input,CLOSURE,Follow._CLOSURE_in_dotLoop1262); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				PushFollow(Follow._dotBlock_in_dotLoop1264);
-				dotBlock();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-
-				}
-				break;
-			case 2:
-				// Grammars\\DefineGrammarItemsWalker.g3:456:5: ^( POSITIVE_CLOSURE dotBlock )
-				{
-				Match(input,POSITIVE_CLOSURE,Follow._POSITIVE_CLOSURE_in_dotLoop1274); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				PushFollow(Follow._dotBlock_in_dotLoop1276);
-				dotBlock();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-
-				}
-				break;
-
-			}
-
-			if ( state.backtracking == 0 )
-			{
-
-							GrammarAST block = (GrammarAST)((GrammarAST)retval.Start).GetChild(0);
-							IDictionary<string, object> opts=new Dictionary<string, object>();
-							opts["greedy"] = "false";
-							if ( grammar.type!=GrammarType.Lexer )
-							{
-								// parser grammars assume k=1 for .* loops
-								// otherwise they (analysis?) look til EOF!
-								opts["k"] = 1;
-							}
-							block.SetOptions(grammar,opts);
-
-			}
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "dotLoop"
-
-
-	// $ANTLR start "dotBlock"
-	// Grammars\\DefineGrammarItemsWalker.g3:472:0: dotBlock : ^( BLOCK ^( ALT WILDCARD EOA ) EOB ) ;
-	private void dotBlock(  )
-	{
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:473:4: ( ^( BLOCK ^( ALT WILDCARD EOA ) EOB ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:473:4: ^( BLOCK ^( ALT WILDCARD EOA ) EOB )
-			{
-			Match(input,BLOCK,Follow._BLOCK_in_dotBlock1299); if (state.failed) return ;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return ;
-			Match(input,ALT,Follow._ALT_in_dotBlock1303); if (state.failed) return ;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return ;
-			Match(input,WILDCARD,Follow._WILDCARD_in_dotBlock1305); if (state.failed) return ;
-			Match(input,EOA,Follow._EOA_in_dotBlock1307); if (state.failed) return ;
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return ;
-			Match(input,EOB,Follow._EOB_in_dotBlock1311); if (state.failed) return ;
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "dotBlock"
-
-
-	// $ANTLR start "tree_"
-	// Grammars\\DefineGrammarItemsWalker.g3:476:0: tree_ : ^( TREE_BEGIN ( element )+ ) ;
-	private void tree_(  )
-	{
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:477:4: ( ^( TREE_BEGIN ( element )+ ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:477:4: ^( TREE_BEGIN ( element )+ )
-			{
-			Match(input,TREE_BEGIN,Follow._TREE_BEGIN_in_tree_1325); if (state.failed) return ;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return ;
-			// Grammars\\DefineGrammarItemsWalker.g3:477:17: ( element )+
-			int cnt39=0;
-			for ( ; ; )
-			{
-				int alt39=2;
-				int LA39_0 = input.LA(1);
-
-				if ( (LA39_0==ACTION||(LA39_0>=ASSIGN && LA39_0<=BLOCK)||(LA39_0>=CHAR_LITERAL && LA39_0<=CHAR_RANGE)||LA39_0==CLOSURE||LA39_0==DOT||LA39_0==EPSILON||LA39_0==FORCED_ACTION||LA39_0==GATED_SEMPRED||LA39_0==NOT||LA39_0==OPTIONAL||(LA39_0>=PLUS_ASSIGN && LA39_0<=POSITIVE_CLOSURE)||LA39_0==RANGE||LA39_0==ROOT||LA39_0==RULE_REF||LA39_0==SEMPRED||(LA39_0>=STRING_LITERAL && LA39_0<=SYNPRED)||LA39_0==TOKEN_REF||LA39_0==TREE_BEGIN||LA39_0==WILDCARD) )
-				{
-					alt39=1;
-				}
-
-
-				switch ( alt39 )
-				{
-				case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:477:0: element
-					{
-					PushFollow(Follow._element_in_tree_1327);
-					element();
-
-					state._fsp--;
-					if (state.failed) return ;
-
-					}
-					break;
-
-				default:
-					if ( cnt39 >= 1 )
-						goto loop39;
-
-					if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee39 = new EarlyExitException( 39, input );
-					throw eee39;
-				}
-				cnt39++;
-			}
-			loop39:
-				;
-
-
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "tree_"
-
-
-	// $ANTLR start "atom"
-	// Grammars\\DefineGrammarItemsWalker.g3:480:0: atom[GrammarAST scope_] : ( ^(rr= RULE_REF (rarg= ARG_ACTION )? ) | ^(t= TOKEN_REF (targ= ARG_ACTION )? ) |c= CHAR_LITERAL |s= STRING_LITERAL | WILDCARD | ^( DOT ID atom[$ID] ) );
-	private void atom( GrammarAST scope_ )
-	{
-		GrammarAST rr=null;
-		GrammarAST rarg=null;
-		GrammarAST t=null;
-		GrammarAST targ=null;
-		GrammarAST c=null;
-		GrammarAST s=null;
-		GrammarAST ID11=null;
-
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:481:4: ( ^(rr= RULE_REF (rarg= ARG_ACTION )? ) | ^(t= TOKEN_REF (targ= ARG_ACTION )? ) |c= CHAR_LITERAL |s= STRING_LITERAL | WILDCARD | ^( DOT ID atom[$ID] ) )
-			int alt42=6;
-			switch ( input.LA(1) )
-			{
-			case RULE_REF:
-				{
-				alt42=1;
-				}
-				break;
-			case TOKEN_REF:
-				{
-				alt42=2;
-				}
-				break;
-			case CHAR_LITERAL:
-				{
-				alt42=3;
-				}
-				break;
-			case STRING_LITERAL:
-				{
-				alt42=4;
-				}
-				break;
-			case WILDCARD:
-				{
-				alt42=5;
-				}
-				break;
-			case DOT:
-				{
-				alt42=6;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					NoViableAltException nvae = new NoViableAltException("", 42, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt42 )
-			{
-			case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:481:4: ^(rr= RULE_REF (rarg= ARG_ACTION )? )
-				{
-				rr=(GrammarAST)Match(input,RULE_REF,Follow._RULE_REF_in_atom1345); if (state.failed) return ;
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null); if (state.failed) return ;
-					// Grammars\\DefineGrammarItemsWalker.g3:481:19: (rarg= ARG_ACTION )?
-					int alt40=2;
-					int LA40_0 = input.LA(1);
-
-					if ( (LA40_0==ARG_ACTION) )
-					{
-						alt40=1;
-					}
-					switch ( alt40 )
-					{
-					case 1:
-						// Grammars\\DefineGrammarItemsWalker.g3:481:20: rarg= ARG_ACTION
-						{
-						rarg=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1350); if (state.failed) return ;
-
-						}
-						break;
-
-					}
-
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return ;
-				}
-				if ( state.backtracking == 0 )
-				{
-
-								grammar.AltReferencesRule( currentRuleName, scope_, rr, this.outerAltNum );
-								if ( rarg != null )
-								{
-									rarg.outerAltNum = this.outerAltNum;
-									TrackInlineAction(rarg);
-								}
-
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\DefineGrammarItemsWalker.g3:490:4: ^(t= TOKEN_REF (targ= ARG_ACTION )? )
-				{
-				t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_atom1367); if (state.failed) return ;
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null); if (state.failed) return ;
-					// Grammars\\DefineGrammarItemsWalker.g3:490:19: (targ= ARG_ACTION )?
-					int alt41=2;
-					int LA41_0 = input.LA(1);
-
-					if ( (LA41_0==ARG_ACTION) )
-					{
-						alt41=1;
-					}
-					switch ( alt41 )
-					{
-					case 1:
-						// Grammars\\DefineGrammarItemsWalker.g3:490:20: targ= ARG_ACTION
-						{
-						targ=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1372); if (state.failed) return ;
-
-						}
-						break;
-
-					}
-
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return ;
-				}
-				if ( state.backtracking == 0 )
-				{
-
-								if ( targ != null )
-								{
-									targ.outerAltNum = this.outerAltNum;
-									TrackInlineAction(targ);
-								}
-								if ( grammar.type == GrammarType.Lexer )
-								{
-									grammar.AltReferencesRule( currentRuleName, scope_, t, this.outerAltNum );
-								}
-								else
-								{
-									grammar.AltReferencesTokenID( currentRuleName, t, this.outerAltNum );
-								}
-
-				}
-
-				}
-				break;
-			case 3:
-				// Grammars\\DefineGrammarItemsWalker.g3:506:4: c= CHAR_LITERAL
-				{
-				c=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_atom1388); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-
-								if ( grammar.type != GrammarType.Lexer )
-								{
-									Rule rule = grammar.GetRule(currentRuleName);
-									if ( rule != null )
-										rule.TrackTokenReferenceInAlt(c, outerAltNum);
-								}
-
-				}
-
-				}
-				break;
-			case 4:
-				// Grammars\\DefineGrammarItemsWalker.g3:515:4: s= STRING_LITERAL
-				{
-				s=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_atom1399); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-
-								if ( grammar.type != GrammarType.Lexer )
-								{
-									Rule rule = grammar.GetRule(currentRuleName);
-									if ( rule!=null )
-										rule.TrackTokenReferenceInAlt(s, outerAltNum);
-								}
-
-				}
-
-				}
-				break;
-			case 5:
-				// Grammars\\DefineGrammarItemsWalker.g3:524:4: WILDCARD
-				{
-				Match(input,WILDCARD,Follow._WILDCARD_in_atom1409); if (state.failed) return ;
-
-				}
-				break;
-			case 6:
-				// Grammars\\DefineGrammarItemsWalker.g3:525:4: ^( DOT ID atom[$ID] )
-				{
-				Match(input,DOT,Follow._DOT_in_atom1415); if (state.failed) return ;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return ;
-				ID11=(GrammarAST)Match(input,ID,Follow._ID_in_atom1417); if (state.failed) return ;
-				PushFollow(Follow._atom_in_atom1419);
-				atom(ID11);
-
-				state._fsp--;
-				if (state.failed) return ;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "atom"
-
-
-	// $ANTLR start "ast_suffix"
-	// Grammars\\DefineGrammarItemsWalker.g3:528:0: ast_suffix : ( ROOT | BANG );
-	private void ast_suffix(  )
-	{
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:529:4: ( ROOT | BANG )
-			// Grammars\\DefineGrammarItemsWalker.g3:
-			{
-			if ( input.LA(1)==BANG||input.LA(1)==ROOT )
-			{
-				input.Consume();
-				state.errorRecovery=false;state.failed=false;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				MismatchedSetException mse = new MismatchedSetException(null,input);
-				throw mse;
-			}
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "ast_suffix"
-
-	public class rewrite_return : TreeRuleReturnScope
-	{
-	}
-
-	// $ANTLR start "rewrite"
-	// Grammars\\DefineGrammarItemsWalker.g3:533:0: rewrite : ( ^( REWRITE (pred= SEMPRED )? rewrite_alternative ) )* ;
-	private DefineGrammarItemsWalker.rewrite_return rewrite(  )
-	{
-		DefineGrammarItemsWalker.rewrite_return retval = new DefineGrammarItemsWalker.rewrite_return();
-		retval.start = input.LT(1);
-
-		GrammarAST pred=null;
-
-
-			currentRewriteRule = ((GrammarAST)retval.Start); // has to execute during backtracking
-			if ( state.backtracking == 0 )
-			{
-				if ( grammar.BuildAST )
-					((GrammarAST)retval.Start).rewriteRefsDeep = new HashSet<GrammarAST>();
-			}
-
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:543:4: ( ( ^( REWRITE (pred= SEMPRED )? rewrite_alternative ) )* )
-			// Grammars\\DefineGrammarItemsWalker.g3:543:4: ( ^( REWRITE (pred= SEMPRED )? rewrite_alternative ) )*
-			{
-			// Grammars\\DefineGrammarItemsWalker.g3:543:4: ( ^( REWRITE (pred= SEMPRED )? rewrite_alternative ) )*
-			for ( ; ; )
-			{
-				int alt44=2;
-				int LA44_0 = input.LA(1);
-
-				if ( (LA44_0==REWRITE) )
-				{
-					alt44=1;
-				}
-
-
-				switch ( alt44 )
-				{
-				case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:544:4: ^( REWRITE (pred= SEMPRED )? rewrite_alternative )
-					{
-					Match(input,REWRITE,Follow._REWRITE_in_rewrite1461); if (state.failed) return retval;
-
-					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-					// Grammars\\DefineGrammarItemsWalker.g3:544:15: (pred= SEMPRED )?
-					int alt43=2;
-					int LA43_0 = input.LA(1);
-
-					if ( (LA43_0==SEMPRED) )
-					{
-						alt43=1;
-					}
-					switch ( alt43 )
-					{
-					case 1:
-						// Grammars\\DefineGrammarItemsWalker.g3:544:16: pred= SEMPRED
-						{
-						pred=(GrammarAST)Match(input,SEMPRED,Follow._SEMPRED_in_rewrite1466); if (state.failed) return retval;
-
-						}
-						break;
-
-					}
-
-					PushFollow(Follow._rewrite_alternative_in_rewrite1470);
-					rewrite_alternative();
-
-					state._fsp--;
-					if (state.failed) return retval;
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-					if ( state.backtracking == 0 )
-					{
-
-										if ( pred != null )
-										{
-											pred.outerAltNum = this.outerAltNum;
-											TrackInlineAction(pred);
-										}
-
-					}
-
-					}
-					break;
-
-				default:
-					goto loop44;
-				}
-			}
-
-			loop44:
-				;
-
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "rewrite"
-
-	public class rewrite_block_return : TreeRuleReturnScope
-	{
-	}
-
-	// $ANTLR start "rewrite_block"
-	// Grammars\\DefineGrammarItemsWalker.g3:556:0: rewrite_block : ^( BLOCK rewrite_alternative EOB ) ;
-	private DefineGrammarItemsWalker.rewrite_block_return rewrite_block(  )
-	{
-		DefineGrammarItemsWalker.rewrite_block_return retval = new DefineGrammarItemsWalker.rewrite_block_return();
-		retval.start = input.LT(1);
-
-
-			GrammarAST enclosingBlock = currentRewriteBlock;
-			if ( state.backtracking == 0 )
-			{
-				// don't do if guessing
-				currentRewriteBlock=((GrammarAST)retval.Start); // pts to BLOCK node
-				currentRewriteBlock.rewriteRefsShallow = new HashSet<GrammarAST>();
-				currentRewriteBlock.rewriteRefsDeep = new HashSet<GrammarAST>();
-			}
-
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:568:6: ( ^( BLOCK rewrite_alternative EOB ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:568:6: ^( BLOCK rewrite_alternative EOB )
-			{
-			Match(input,BLOCK,Follow._BLOCK_in_rewrite_block1505); if (state.failed) return retval;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-			PushFollow(Follow._rewrite_alternative_in_rewrite_block1507);
-			rewrite_alternative();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			Match(input,EOB,Follow._EOB_in_rewrite_block1509); if (state.failed) return retval;
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-			if ( state.backtracking == 0 )
-			{
-
-							// copy the element refs in this block to the surrounding block
-							if ( enclosingBlock != null )
-							{
-								foreach ( var item in currentRewriteBlock.rewriteRefsShallow )
-									enclosingBlock.rewriteRefsDeep.Add( item );
-							}
-							//currentRewriteBlock = enclosingBlock; // restore old BLOCK ptr
-
-			}
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-			 currentRewriteBlock = enclosingBlock;
-		}
-		return retval;
-	}
-	// $ANTLR end "rewrite_block"
-
-
-	// $ANTLR start "rewrite_alternative"
-	// Grammars\\DefineGrammarItemsWalker.g3:582:0: rewrite_alternative : ({...}? => ^(a= ALT ( ( rewrite_element )+ | EPSILON ) EOA ) |{...}? => rewrite_template | ETC {...}?);
-	private void rewrite_alternative(  )
-	{
-		GrammarAST a=null;
-
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:583:4: ({...}? => ^(a= ALT ( ( rewrite_element )+ | EPSILON ) EOA ) |{...}? => rewrite_template | ETC {...}?)
-			int alt47=3;
-			int LA47_0 = input.LA(1);
-
-			if ( (LA47_0==ALT) && (((grammar.BuildAST)||(grammar.BuildTemplate))))
-			{
-				int LA47_1 = input.LA(2);
-
-				if ( (LA47_1==DOWN) && (((grammar.BuildAST)||(grammar.BuildTemplate))))
-				{
-					int LA47_4 = input.LA(3);
-
-					if ( (LA47_4==EPSILON) && (((grammar.BuildTemplate)||(grammar.BuildAST))))
-					{
-						int LA47_5 = input.LA(4);
-
-						if ( (LA47_5==EOA) && (((grammar.BuildTemplate)||(grammar.BuildAST))))
-						{
-							int LA47_7 = input.LA(5);
-
-							if ( (LA47_7==UP) && (((grammar.BuildTemplate)||(grammar.BuildAST))))
-							{
-								int LA47_8 = input.LA(6);
-
-								if ( ((grammar.BuildAST)) )
-								{
-									alt47=1;
-								}
-								else if ( ((grammar.BuildTemplate)) )
-								{
-									alt47=2;
-								}
-								else
-								{
-									if (state.backtracking>0) {state.failed=true; return ;}
-									NoViableAltException nvae = new NoViableAltException("", 47, 8, input);
-
-									throw nvae;
-								}
-							}
-							else
-							{
-								if (state.backtracking>0) {state.failed=true; return ;}
-								NoViableAltException nvae = new NoViableAltException("", 47, 7, input);
-
-								throw nvae;
-							}
-						}
-						else
-						{
-							if (state.backtracking>0) {state.failed=true; return ;}
-							NoViableAltException nvae = new NoViableAltException("", 47, 5, input);
-
-							throw nvae;
-						}
-					}
-					else if ( (LA47_4==ACTION||LA47_4==CHAR_LITERAL||LA47_4==CLOSURE||LA47_4==LABEL||LA47_4==OPTIONAL||LA47_4==POSITIVE_CLOSURE||LA47_4==RULE_REF||LA47_4==STRING_LITERAL||LA47_4==TOKEN_REF||LA47_4==TREE_BEGIN) && ((grammar.BuildAST)))
-					{
-						alt47=1;
-					}
-					else
-					{
-						if (state.backtracking>0) {state.failed=true; return ;}
-						NoViableAltException nvae = new NoViableAltException("", 47, 4, input);
-
-						throw nvae;
-					}
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					NoViableAltException nvae = new NoViableAltException("", 47, 1, input);
-
-					throw nvae;
-				}
-			}
-			else if ( (LA47_0==ACTION||LA47_0==TEMPLATE) && ((grammar.BuildTemplate)))
-			{
-				alt47=2;
-			}
-			else if ( (LA47_0==ETC) )
-			{
-				alt47=3;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				NoViableAltException nvae = new NoViableAltException("", 47, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt47 )
-			{
-			case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:583:4: {...}? => ^(a= ALT ( ( rewrite_element )+ | EPSILON ) EOA )
-				{
-				if ( !((grammar.BuildAST)) )
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					throw new FailedPredicateException(input, "rewrite_alternative", "grammar.BuildAST");
-				}
-				a=(GrammarAST)Match(input,ALT,Follow._ALT_in_rewrite_alternative1541); if (state.failed) return ;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return ;
-				// Grammars\\DefineGrammarItemsWalker.g3:583:36: ( ( rewrite_element )+ | EPSILON )
-				int alt46=2;
-				int LA46_0 = input.LA(1);
-
-				if ( (LA46_0==ACTION||LA46_0==CHAR_LITERAL||LA46_0==CLOSURE||LA46_0==LABEL||LA46_0==OPTIONAL||LA46_0==POSITIVE_CLOSURE||LA46_0==RULE_REF||LA46_0==STRING_LITERAL||LA46_0==TOKEN_REF||LA46_0==TREE_BEGIN) )
-				{
-					alt46=1;
-				}
-				else if ( (LA46_0==EPSILON) )
-				{
-					alt46=2;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					NoViableAltException nvae = new NoViableAltException("", 46, 0, input);
-
-					throw nvae;
-				}
-				switch ( alt46 )
-				{
-				case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:583:38: ( rewrite_element )+
-					{
-					// Grammars\\DefineGrammarItemsWalker.g3:583:38: ( rewrite_element )+
-					int cnt45=0;
-					for ( ; ; )
-					{
-						int alt45=2;
-						int LA45_0 = input.LA(1);
-
-						if ( (LA45_0==ACTION||LA45_0==CHAR_LITERAL||LA45_0==CLOSURE||LA45_0==LABEL||LA45_0==OPTIONAL||LA45_0==POSITIVE_CLOSURE||LA45_0==RULE_REF||LA45_0==STRING_LITERAL||LA45_0==TOKEN_REF||LA45_0==TREE_BEGIN) )
-						{
-							alt45=1;
-						}
-
-
-						switch ( alt45 )
-						{
-						case 1:
-							// Grammars\\DefineGrammarItemsWalker.g3:583:40: rewrite_element
-							{
-							PushFollow(Follow._rewrite_element_in_rewrite_alternative1547);
-							rewrite_element();
-
-							state._fsp--;
-							if (state.failed) return ;
-
-							}
-							break;
-
-						default:
-							if ( cnt45 >= 1 )
-								goto loop45;
-
-							if (state.backtracking>0) {state.failed=true; return ;}
-							EarlyExitException eee45 = new EarlyExitException( 45, input );
-							throw eee45;
-						}
-						cnt45++;
-					}
-					loop45:
-						;
-
-
-
-					}
-					break;
-				case 2:
-					// Grammars\\DefineGrammarItemsWalker.g3:583:61: EPSILON
-					{
-					Match(input,EPSILON,Follow._EPSILON_in_rewrite_alternative1554); if (state.failed) return ;
-
-					}
-					break;
-
-				}
-
-				Match(input,EOA,Follow._EOA_in_rewrite_alternative1558); if (state.failed) return ;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-				}
-				break;
-			case 2:
-				// Grammars\\DefineGrammarItemsWalker.g3:584:4: {...}? => rewrite_template
-				{
-				if ( !((grammar.BuildTemplate)) )
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					throw new FailedPredicateException(input, "rewrite_alternative", "grammar.BuildTemplate");
-				}
-				PushFollow(Follow._rewrite_template_in_rewrite_alternative1569);
-				rewrite_template();
-
-				state._fsp--;
-				if (state.failed) return ;
-
-				}
-				break;
-			case 3:
-				// Grammars\\DefineGrammarItemsWalker.g3:585:4: ETC {...}?
-				{
-				Match(input,ETC,Follow._ETC_in_rewrite_alternative1574); if (state.failed) return ;
-				if ( !((this.blockLevel==1)) )
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					throw new FailedPredicateException(input, "rewrite_alternative", "this.blockLevel==1");
-				}
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "rewrite_alternative"
-
-
-	// $ANTLR start "rewrite_element"
-	// Grammars\\DefineGrammarItemsWalker.g3:588:0: rewrite_element : ( rewrite_atom | rewrite_ebnf | rewrite_tree );
-	private void rewrite_element(  )
-	{
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:589:4: ( rewrite_atom | rewrite_ebnf | rewrite_tree )
-			int alt48=3;
-			switch ( input.LA(1) )
-			{
-			case ACTION:
-			case CHAR_LITERAL:
-			case LABEL:
-			case RULE_REF:
-			case STRING_LITERAL:
-			case TOKEN_REF:
-				{
-				alt48=1;
-				}
-				break;
-			case CLOSURE:
-			case OPTIONAL:
-			case POSITIVE_CLOSURE:
-				{
-				alt48=2;
-				}
-				break;
-			case TREE_BEGIN:
-				{
-				alt48=3;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					NoViableAltException nvae = new NoViableAltException("", 48, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt48 )
-			{
-			case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:589:4: rewrite_atom
-				{
-				PushFollow(Follow._rewrite_atom_in_rewrite_element1588);
-				rewrite_atom();
-
-				state._fsp--;
-				if (state.failed) return ;
-
-				}
-				break;
-			case 2:
-				// Grammars\\DefineGrammarItemsWalker.g3:590:4: rewrite_ebnf
-				{
-				PushFollow(Follow._rewrite_ebnf_in_rewrite_element1593);
-				rewrite_ebnf();
-
-				state._fsp--;
-				if (state.failed) return ;
-
-				}
-				break;
-			case 3:
-				// Grammars\\DefineGrammarItemsWalker.g3:591:4: rewrite_tree
-				{
-				PushFollow(Follow._rewrite_tree_in_rewrite_element1598);
-				rewrite_tree();
-
-				state._fsp--;
-				if (state.failed) return ;
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "rewrite_element"
-
-
-	// $ANTLR start "rewrite_ebnf"
-	// Grammars\\DefineGrammarItemsWalker.g3:594:0: rewrite_ebnf : ( ^( OPTIONAL rewrite_block ) | ^( CLOSURE rewrite_block ) | ^( POSITIVE_CLOSURE rewrite_block ) );
-	private void rewrite_ebnf(  )
-	{
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:595:4: ( ^( OPTIONAL rewrite_block ) | ^( CLOSURE rewrite_block ) | ^( POSITIVE_CLOSURE rewrite_block ) )
-			int alt49=3;
-			switch ( input.LA(1) )
-			{
-			case OPTIONAL:
-				{
-				alt49=1;
-				}
-				break;
-			case CLOSURE:
-				{
-				alt49=2;
-				}
-				break;
-			case POSITIVE_CLOSURE:
-				{
-				alt49=3;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					NoViableAltException nvae = new NoViableAltException("", 49, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt49 )
-			{
-			case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:595:4: ^( OPTIONAL rewrite_block )
-				{
-				Match(input,OPTIONAL,Follow._OPTIONAL_in_rewrite_ebnf1611); if (state.failed) return ;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return ;
-				PushFollow(Follow._rewrite_block_in_rewrite_ebnf1613);
-				rewrite_block();
-
-				state._fsp--;
-				if (state.failed) return ;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-				}
-				break;
-			case 2:
-				// Grammars\\DefineGrammarItemsWalker.g3:596:4: ^( CLOSURE rewrite_block )
-				{
-				Match(input,CLOSURE,Follow._CLOSURE_in_rewrite_ebnf1622); if (state.failed) return ;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return ;
-				PushFollow(Follow._rewrite_block_in_rewrite_ebnf1624);
-				rewrite_block();
-
-				state._fsp--;
-				if (state.failed) return ;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-				}
-				break;
-			case 3:
-				// Grammars\\DefineGrammarItemsWalker.g3:597:4: ^( POSITIVE_CLOSURE rewrite_block )
-				{
-				Match(input,POSITIVE_CLOSURE,Follow._POSITIVE_CLOSURE_in_rewrite_ebnf1633); if (state.failed) return ;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return ;
-				PushFollow(Follow._rewrite_block_in_rewrite_ebnf1635);
-				rewrite_block();
-
-				state._fsp--;
-				if (state.failed) return ;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "rewrite_ebnf"
-
-
-	// $ANTLR start "rewrite_tree"
-	// Grammars\\DefineGrammarItemsWalker.g3:600:0: rewrite_tree : ^( TREE_BEGIN rewrite_atom ( rewrite_element )* ) ;
-	private void rewrite_tree(  )
-	{
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:601:6: ( ^( TREE_BEGIN rewrite_atom ( rewrite_element )* ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:601:6: ^( TREE_BEGIN rewrite_atom ( rewrite_element )* )
-			{
-			Match(input,TREE_BEGIN,Follow._TREE_BEGIN_in_rewrite_tree1652); if (state.failed) return ;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return ;
-			PushFollow(Follow._rewrite_atom_in_rewrite_tree1654);
-			rewrite_atom();
-
-			state._fsp--;
-			if (state.failed) return ;
-			// Grammars\\DefineGrammarItemsWalker.g3:601:33: ( rewrite_element )*
-			for ( ; ; )
-			{
-				int alt50=2;
-				int LA50_0 = input.LA(1);
-
-				if ( (LA50_0==ACTION||LA50_0==CHAR_LITERAL||LA50_0==CLOSURE||LA50_0==LABEL||LA50_0==OPTIONAL||LA50_0==POSITIVE_CLOSURE||LA50_0==RULE_REF||LA50_0==STRING_LITERAL||LA50_0==TOKEN_REF||LA50_0==TREE_BEGIN) )
-				{
-					alt50=1;
-				}
-
-
-				switch ( alt50 )
-				{
-				case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:601:35: rewrite_element
-					{
-					PushFollow(Follow._rewrite_element_in_rewrite_tree1658);
-					rewrite_element();
-
-					state._fsp--;
-					if (state.failed) return ;
-
-					}
-					break;
-
-				default:
-					goto loop50;
-				}
-			}
-
-			loop50:
-				;
-
-
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "rewrite_tree"
-
-	public class rewrite_atom_return : TreeRuleReturnScope
-	{
-	}
-
-	// $ANTLR start "rewrite_atom"
-	// Grammars\\DefineGrammarItemsWalker.g3:604:0: rewrite_atom : ( RULE_REF | ( ^( TOKEN_REF ( ARG_ACTION )? ) | CHAR_LITERAL | STRING_LITERAL ) | LABEL | ACTION );
-	private DefineGrammarItemsWalker.rewrite_atom_return rewrite_atom(  )
-	{
-		DefineGrammarItemsWalker.rewrite_atom_return retval = new DefineGrammarItemsWalker.rewrite_atom_return();
-		retval.start = input.LT(1);
-
-		GrammarAST ARG_ACTION12=null;
-		GrammarAST ACTION13=null;
-
-
-			if ( state.backtracking == 0 )
-			{
-				Rule r = grammar.GetRule(currentRuleName);
-				var tokenRefsInAlt = r.GetTokenRefsInAlt(outerAltNum);
-				bool imaginary =
-					((GrammarAST)retval.Start).Type==TOKEN_REF &&
-					!tokenRefsInAlt.Contains(((GrammarAST)retval.Start).Text);
-				if ( !imaginary && grammar.BuildAST &&
-					 (((GrammarAST)retval.Start).Type==RULE_REF ||
-					  ((GrammarAST)retval.Start).Type==LABEL ||
-					  ((GrammarAST)retval.Start).Type==TOKEN_REF ||
-					  ((GrammarAST)retval.Start).Type==CHAR_LITERAL ||
-					  ((GrammarAST)retval.Start).Type==STRING_LITERAL) )
-				{
-					// track per block and for entire rewrite rule
-					if ( currentRewriteBlock!=null )
-					{
-						currentRewriteBlock.rewriteRefsShallow.Add(((GrammarAST)retval.Start));
-						currentRewriteBlock.rewriteRefsDeep.Add(((GrammarAST)retval.Start));
-					}
-					currentRewriteRule.rewriteRefsDeep.Add(((GrammarAST)retval.Start));
-				}
-			}
-
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:631:4: ( RULE_REF | ( ^( TOKEN_REF ( ARG_ACTION )? ) | CHAR_LITERAL | STRING_LITERAL ) | LABEL | ACTION )
-			int alt53=4;
-			switch ( input.LA(1) )
-			{
-			case RULE_REF:
-				{
-				alt53=1;
-				}
-				break;
-			case CHAR_LITERAL:
-			case STRING_LITERAL:
-			case TOKEN_REF:
-				{
-				alt53=2;
-				}
-				break;
-			case LABEL:
-				{
-				alt53=3;
-				}
-				break;
-			case ACTION:
-				{
-				alt53=4;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 53, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt53 )
-			{
-			case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:631:4: RULE_REF
-				{
-				Match(input,RULE_REF,Follow._RULE_REF_in_rewrite_atom1679); if (state.failed) return retval;
-
-				}
-				break;
-			case 2:
-				// Grammars\\DefineGrammarItemsWalker.g3:632:4: ( ^( TOKEN_REF ( ARG_ACTION )? ) | CHAR_LITERAL | STRING_LITERAL )
-				{
-				// Grammars\\DefineGrammarItemsWalker.g3:632:4: ( ^( TOKEN_REF ( ARG_ACTION )? ) | CHAR_LITERAL | STRING_LITERAL )
-				int alt52=3;
-				switch ( input.LA(1) )
-				{
-				case TOKEN_REF:
-					{
-					alt52=1;
-					}
-					break;
-				case CHAR_LITERAL:
-					{
-					alt52=2;
-					}
-					break;
-				case STRING_LITERAL:
-					{
-					alt52=3;
-					}
-					break;
-				default:
-					{
-						if (state.backtracking>0) {state.failed=true; return retval;}
-						NoViableAltException nvae = new NoViableAltException("", 52, 0, input);
-
-						throw nvae;
-					}
-				}
-
-				switch ( alt52 )
-				{
-				case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:632:6: ^( TOKEN_REF ( ARG_ACTION )? )
-					{
-					Match(input,TOKEN_REF,Follow._TOKEN_REF_in_rewrite_atom1689); if (state.failed) return retval;
-
-					if ( input.LA(1)==TokenTypes.Down )
-					{
-						Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-						// Grammars\\DefineGrammarItemsWalker.g3:633:5: ( ARG_ACTION )?
-						int alt51=2;
-						int LA51_0 = input.LA(1);
-
-						if ( (LA51_0==ARG_ACTION) )
-						{
-							alt51=1;
-						}
-						switch ( alt51 )
-						{
-						case 1:
-							// Grammars\\DefineGrammarItemsWalker.g3:633:7: ARG_ACTION
-							{
-							ARG_ACTION12=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rewrite_atom1697); if (state.failed) return retval;
-							if ( state.backtracking == 0 )
-							{
-
-														ARG_ACTION12.outerAltNum = this.outerAltNum;
-														TrackInlineAction(ARG_ACTION12);
-
-							}
-
-							}
-							break;
-
-						}
-
-
-						Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-					}
-
-					}
-					break;
-				case 2:
-					// Grammars\\DefineGrammarItemsWalker.g3:640:5: CHAR_LITERAL
-					{
-					Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_rewrite_atom1722); if (state.failed) return retval;
-
-					}
-					break;
-				case 3:
-					// Grammars\\DefineGrammarItemsWalker.g3:641:5: STRING_LITERAL
-					{
-					Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_rewrite_atom1728); if (state.failed) return retval;
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-			case 3:
-				// Grammars\\DefineGrammarItemsWalker.g3:643:4: LABEL
-				{
-				Match(input,LABEL,Follow._LABEL_in_rewrite_atom1737); if (state.failed) return retval;
-
-				}
-				break;
-			case 4:
-				// Grammars\\DefineGrammarItemsWalker.g3:644:4: ACTION
-				{
-				ACTION13=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_rewrite_atom1742); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-
-								ACTION13.outerAltNum = this.outerAltNum;
-								TrackInlineAction(ACTION13);
-
-				}
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "rewrite_atom"
-
-
-	// $ANTLR start "rewrite_template"
-	// Grammars\\DefineGrammarItemsWalker.g3:651:0: rewrite_template : ( ^( ALT EPSILON EOA ) | ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? ) |act= ACTION );
-	private void rewrite_template(  )
-	{
-		GrammarAST id=null;
-		GrammarAST ind=null;
-		GrammarAST arg=null;
-		GrammarAST a=null;
-		GrammarAST act=null;
-
-		try
-		{
-			// Grammars\\DefineGrammarItemsWalker.g3:652:4: ( ^( ALT EPSILON EOA ) | ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? ) |act= ACTION )
-			int alt57=3;
-			switch ( input.LA(1) )
-			{
-			case ALT:
-				{
-				alt57=1;
-				}
-				break;
-			case TEMPLATE:
-				{
-				alt57=2;
-				}
-				break;
-			case ACTION:
-				{
-				alt57=3;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					NoViableAltException nvae = new NoViableAltException("", 57, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt57 )
-			{
-			case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:652:4: ^( ALT EPSILON EOA )
-				{
-				Match(input,ALT,Follow._ALT_in_rewrite_template1759); if (state.failed) return ;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return ;
-				Match(input,EPSILON,Follow._EPSILON_in_rewrite_template1761); if (state.failed) return ;
-				Match(input,EOA,Follow._EOA_in_rewrite_template1763); if (state.failed) return ;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-				}
-				break;
-			case 2:
-				// Grammars\\DefineGrammarItemsWalker.g3:653:4: ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? )
-				{
-				Match(input,TEMPLATE,Follow._TEMPLATE_in_rewrite_template1772); if (state.failed) return ;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return ;
-				// Grammars\\DefineGrammarItemsWalker.g3:653:16: (id= ID |ind= ACTION )
-				int alt54=2;
-				int LA54_0 = input.LA(1);
-
-				if ( (LA54_0==ID) )
-				{
-					alt54=1;
-				}
-				else if ( (LA54_0==ACTION) )
-				{
-					alt54=2;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					NoViableAltException nvae = new NoViableAltException("", 54, 0, input);
-
-					throw nvae;
-				}
-				switch ( alt54 )
-				{
-				case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:653:17: id= ID
-					{
-					id=(GrammarAST)Match(input,ID,Follow._ID_in_rewrite_template1777); if (state.failed) return ;
-
-					}
-					break;
-				case 2:
-					// Grammars\\DefineGrammarItemsWalker.g3:653:23: ind= ACTION
-					{
-					ind=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_rewrite_template1781); if (state.failed) return ;
-
-					}
-					break;
-
-				}
-
-				Match(input,ARGLIST,Follow._ARGLIST_in_rewrite_template1789); if (state.failed) return ;
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null); if (state.failed) return ;
-					// Grammars\\DefineGrammarItemsWalker.g3:655:5: ( ^( ARG arg= ID a= ACTION ) )*
-					for ( ; ; )
-					{
-						int alt55=2;
-						int LA55_0 = input.LA(1);
-
-						if ( (LA55_0==ARG) )
-						{
-							alt55=1;
-						}
-
-
-						switch ( alt55 )
-						{
-						case 1:
-							// Grammars\\DefineGrammarItemsWalker.g3:655:7: ^( ARG arg= ID a= ACTION )
-							{
-							Match(input,ARG,Follow._ARG_in_rewrite_template1799); if (state.failed) return ;
-
-							Match(input, TokenTypes.Down, null); if (state.failed) return ;
-							arg=(GrammarAST)Match(input,ID,Follow._ID_in_rewrite_template1803); if (state.failed) return ;
-							a=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_rewrite_template1807); if (state.failed) return ;
-
-							Match(input, TokenTypes.Up, null); if (state.failed) return ;
-							if ( state.backtracking == 0 )
-							{
-
-														a.outerAltNum = this.outerAltNum;
-														TrackInlineAction(a);
-
-							}
-
-							}
-							break;
-
-						default:
-							goto loop55;
-						}
-					}
-
-					loop55:
-						;
-
-
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return ;
-				}
-				if ( state.backtracking == 0 )
-				{
-
-									if ( ind!=null )
-									{
-										ind.outerAltNum = this.outerAltNum;
-										TrackInlineAction(ind);
-									}
-
-				}
-				// Grammars\\DefineGrammarItemsWalker.g3:669:4: ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )?
-				int alt56=2;
-				int LA56_0 = input.LA(1);
-
-				if ( ((LA56_0>=DOUBLE_ANGLE_STRING_LITERAL && LA56_0<=DOUBLE_QUOTE_STRING_LITERAL)) )
-				{
-					alt56=1;
-				}
-				switch ( alt56 )
-				{
-				case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:
-					{
-					if ( (input.LA(1)>=DOUBLE_ANGLE_STRING_LITERAL && input.LA(1)<=DOUBLE_QUOTE_STRING_LITERAL) )
-					{
-						input.Consume();
-						state.errorRecovery=false;state.failed=false;
-					}
-					else
-					{
-						if (state.backtracking>0) {state.failed=true; return ;}
-						MismatchedSetException mse = new MismatchedSetException(null,input);
-						throw mse;
-					}
-
-
-					}
-					break;
-
-				}
-
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-				}
-				break;
-			case 3:
-				// Grammars\\DefineGrammarItemsWalker.g3:673:4: act= ACTION
-				{
-				act=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_rewrite_template1864); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-
-								act.outerAltNum = this.outerAltNum;
-								TrackInlineAction(act);
-
-				}
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "rewrite_template"
-
-	// $ANTLR start synpred1_DefineGrammarItemsWalker
-	public void synpred1_DefineGrammarItemsWalker_fragment()
-	{
-		// Grammars\\DefineGrammarItemsWalker.g3:445:4: ( dotLoop )
-		// Grammars\\DefineGrammarItemsWalker.g3:445:5: dotLoop
-		{
-		PushFollow(Follow._dotLoop_in_synpred1_DefineGrammarItemsWalker1201);
-		dotLoop();
-
-		state._fsp--;
-		if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred1_DefineGrammarItemsWalker
-	#endregion Rules
-
-	#region Synpreds
-	bool EvaluatePredicate( System.Action fragment )
-	{
-		state.backtracking++;
-		int start = input.Mark();
-		try
-		{
-			fragment();
-		}
-		catch ( RecognitionException re )
-		{
-			System.Console.Error.WriteLine("impossible: "+re);
-		}
-		bool success = !state.failed;
-		input.Rewind(start);
-		state.backtracking--;
-		state.failed=false;
-		return success;
-	}
-	#endregion Synpreds
-
-
-	#region DFA
-	DFA36 dfa36;
-	DFA37 dfa37;
-
-	protected override void InitDFAs()
-	{
-		base.InitDFAs();
-		dfa36 = new DFA36( this );
-		dfa37 = new DFA37( this, new SpecialStateTransitionHandler( specialStateTransition37 ) );
-	}
-
-	class DFA36 : DFA
-	{
-
-		const string DFA36_eotS =
-			"\x13\xFFFF";
-		const string DFA36_eofS =
-			"\x13\xFFFF";
-		const string DFA36_minS =
-			"\x1\x4\x12\xFFFF";
-		const string DFA36_maxS =
-			"\x1\x5F\x12\xFFFF";
-		const string DFA36_acceptS =
-			"\x1\xFFFF\x1\x1\x1\x2\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9\x1\xA"+
-			"\x1\xB\x1\xC\x1\xD\x1\xE\x1\xF\x1\x10\x1\x11\x1\x12";
-		const string DFA36_specialS =
-			"\x13\xFFFF}>";
-		static readonly string[] DFA36_transitionS =
-			{
-				"\x1\xC\x8\xFFFF\x1\x7\x1\x10\x1\x2\x1\x9\x1\xFFFF\x1\x3\x1\x6\x1\xFFFF"+
-				"\x1\x9\x7\xFFFF\x1\x3\x5\xFFFF\x1\x12\x3\xFFFF\x1\xD\x1\xFFFF\x1\x11"+
-				"\xD\xFFFF\x1\x4\x1\xFFFF\x1\x9\x5\xFFFF\x1\x8\x1\x9\x4\xFFFF\x1\x5\x4"+
-				"\xFFFF\x1\x1\x2\xFFFF\x1\x3\x2\xFFFF\x1\xE\x4\xFFFF\x1\x3\x1\xF\x1\xB"+
-				"\x2\xFFFF\x1\x3\x2\xFFFF\x1\xA\x1\xFFFF\x1\x3",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				""
-			};
-
-		static readonly short[] DFA36_eot = DFA.UnpackEncodedString(DFA36_eotS);
-		static readonly short[] DFA36_eof = DFA.UnpackEncodedString(DFA36_eofS);
-		static readonly char[] DFA36_min = DFA.UnpackEncodedStringToUnsignedChars(DFA36_minS);
-		static readonly char[] DFA36_max = DFA.UnpackEncodedStringToUnsignedChars(DFA36_maxS);
-		static readonly short[] DFA36_accept = DFA.UnpackEncodedString(DFA36_acceptS);
-		static readonly short[] DFA36_special = DFA.UnpackEncodedString(DFA36_specialS);
-		static readonly short[][] DFA36_transition;
-
-		static DFA36()
-		{
-			int numStates = DFA36_transitionS.Length;
-			DFA36_transition = new short[numStates][];
-			for ( int i=0; i < numStates; i++ )
-			{
-				DFA36_transition[i] = DFA.UnpackEncodedString(DFA36_transitionS[i]);
-			}
-		}
-
-		public DFA36( BaseRecognizer recognizer )
-		{
-			this.recognizer = recognizer;
-			this.decisionNumber = 36;
-			this.eot = DFA36_eot;
-			this.eof = DFA36_eof;
-			this.min = DFA36_min;
-			this.max = DFA36_max;
-			this.accept = DFA36_accept;
-			this.special = DFA36_special;
-			this.transition = DFA36_transition;
-		}
-		public override string GetDescription()
-		{
-			return "368:0: element : ( ^( ROOT element ) | ^( BANG element ) | atom[null] | ^( NOT element ) | ^( RANGE atom[null] atom[null] ) | ^( CHAR_RANGE atom[null] atom[null] ) | ^( ASSIGN id= ID el= element ) | ^( PLUS_ASSIGN id2= ID a2= element ) | ebnf | tree_ | ^( SYNPRED block ) |act= ACTION |act2= FORCED_ACTION | SEMPRED | SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) | GATED_SEMPRED | EPSILON );";
-		}
-	}
-
-	class DFA37 : DFA
-	{
-
-		const string DFA37_eotS =
-			"\x1E\xFFFF";
-		const string DFA37_eofS =
-			"\x1E\xFFFF";
-		const string DFA37_minS =
-			"\x1\x10\x2\x2\x2\xFFFF\x2\x10\x2\x2\x2\x8\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF"+
-			"\x4\x4\x2\x3\x2\x8\x4\x3\x2\x0\x1\xFFFF";
-		const string DFA37_maxS =
-			"\x1\x40\x2\x2\x2\xFFFF\x2\x10\x2\x2\x2\x3A\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF"+
-			"\x4\x5F\x2\x3\x2\x49\x4\x3\x2\x0\x1\xFFFF";
-		const string DFA37_acceptS =
-			"\x3\xFFFF\x1\x2\x1\x3\x7\xFFFF\x1\x4\x1\xFFFF\x1\x5\xE\xFFFF\x1\x1";
-		const string DFA37_specialS =
-			"\x1B\xFFFF\x1\x0\x1\x1\x1\xFFFF}>";
-		static readonly string[] DFA37_transitionS =
-			{
-				"\x1\x3\x4\xFFFF\x1\x1\x23\xFFFF\x1\x4\x6\xFFFF\x1\x2",
-				"\x1\x5",
-				"\x1\x6",
-				"",
-				"",
-				"\x1\x7",
-				"\x1\x8",
-				"\x1\x9",
-				"\x1\xA",
-				"\x1\xB\x1\xC\x30\xFFFF\x1\xC",
-				"\x1\xD\x1\xE\x30\xFFFF\x1\xE",
-				"\x1\xF",
-				"",
-				"\x1\x10",
-				"",
-				"\x1\xC\x8\xFFFF\x4\xC\x1\xFFFF\x2\xC\x1\xFFFF\x1\xC\x7\xFFFF\x1\xC\x5"+
-				"\xFFFF\x1\xC\x3\xFFFF\x1\xC\x1\xFFFF\x1\xC\xD\xFFFF\x1\xC\x1\xFFFF\x1"+
-				"\xC\x5\xFFFF\x2\xC\x4\xFFFF\x1\xC\x4\xFFFF\x1\xC\x2\xFFFF\x1\xC\x2\xFFFF"+
-				"\x1\xC\x4\xFFFF\x3\xC\x2\xFFFF\x1\xC\x2\xFFFF\x1\xC\x1\xFFFF\x1\x11",
-				"\x1\xE\x8\xFFFF\x4\xE\x1\xFFFF\x2\xE\x1\xFFFF\x1\xE\x7\xFFFF\x1\xE\x5"+
-				"\xFFFF\x1\xE\x3\xFFFF\x1\xE\x1\xFFFF\x1\xE\xD\xFFFF\x1\xE\x1\xFFFF\x1"+
-				"\xE\x5\xFFFF\x2\xE\x4\xFFFF\x1\xE\x4\xFFFF\x1\xE\x2\xFFFF\x1\xE\x2\xFFFF"+
-				"\x1\xE\x4\xFFFF\x3\xE\x2\xFFFF\x1\xE\x2\xFFFF\x1\xE\x1\xFFFF\x1\x12",
-				"\x1\xC\x8\xFFFF\x4\xC\x1\xFFFF\x2\xC\x1\xFFFF\x1\xC\x7\xFFFF\x1\xC\x2"+
-				"\xFFFF\x1\x13\x2\xFFFF\x1\xC\x3\xFFFF\x1\xC\x1\xFFFF\x1\xC\xD\xFFFF"+
-				"\x1\xC\x1\xFFFF\x1\xC\x5\xFFFF\x2\xC\x4\xFFFF\x1\xC\x4\xFFFF\x1\xC\x2"+
-				"\xFFFF\x1\xC\x2\xFFFF\x1\xC\x4\xFFFF\x3\xC\x2\xFFFF\x1\xC\x2\xFFFF\x1"+
-				"\xC\x1\xFFFF\x1\xC",
-				"\x1\xE\x8\xFFFF\x4\xE\x1\xFFFF\x2\xE\x1\xFFFF\x1\xE\x7\xFFFF\x1\xE\x2"+
-				"\xFFFF\x1\x14\x2\xFFFF\x1\xE\x3\xFFFF\x1\xE\x1\xFFFF\x1\xE\xD\xFFFF"+
-				"\x1\xE\x1\xFFFF\x1\xE\x5\xFFFF\x2\xE\x4\xFFFF\x1\xE\x4\xFFFF\x1\xE\x2"+
-				"\xFFFF\x1\xE\x2\xFFFF\x1\xE\x4\xFFFF\x3\xE\x2\xFFFF\x1\xE\x2\xFFFF\x1"+
-				"\xE\x1\xFFFF\x1\xE",
-				"\x1\x15",
-				"\x1\x16",
-				"\x1\xC\x18\xFFFF\x1\x17\x27\xFFFF\x1\xC",
-				"\x1\xE\x18\xFFFF\x1\x18\x27\xFFFF\x1\xE",
-				"\x1\x19",
-				"\x1\x1A",
-				"\x1\x1B",
-				"\x1\x1C",
-				"\x1\xFFFF",
-				"\x1\xFFFF",
-				""
-			};
-
-		static readonly short[] DFA37_eot = DFA.UnpackEncodedString(DFA37_eotS);
-		static readonly short[] DFA37_eof = DFA.UnpackEncodedString(DFA37_eofS);
-		static readonly char[] DFA37_min = DFA.UnpackEncodedStringToUnsignedChars(DFA37_minS);
-		static readonly char[] DFA37_max = DFA.UnpackEncodedStringToUnsignedChars(DFA37_maxS);
-		static readonly short[] DFA37_accept = DFA.UnpackEncodedString(DFA37_acceptS);
-		static readonly short[] DFA37_special = DFA.UnpackEncodedString(DFA37_specialS);
-		static readonly short[][] DFA37_transition;
-
-		static DFA37()
-		{
-			int numStates = DFA37_transitionS.Length;
-			DFA37_transition = new short[numStates][];
-			for ( int i=0; i < numStates; i++ )
-			{
-				DFA37_transition[i] = DFA.UnpackEncodedString(DFA37_transitionS[i]);
-			}
-		}
-
-		public DFA37( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
-			: base( specialStateTransition )	{
-			this.recognizer = recognizer;
-			this.decisionNumber = 37;
-			this.eot = DFA37_eot;
-			this.eof = DFA37_eof;
-			this.min = DFA37_min;
-			this.max = DFA37_max;
-			this.accept = DFA37_accept;
-			this.special = DFA37_special;
-			this.transition = DFA37_transition;
-		}
-		public override string GetDescription()
-		{
-			return "444:0: ebnf : (=> dotLoop | block | ^( OPTIONAL block ) | ^( CLOSURE block ) | ^( POSITIVE_CLOSURE block ) );";
-		}
-	}
-
-	int specialStateTransition37( DFA dfa, int s, IIntStream _input )
-	{
-		ITreeNodeStream input = (ITreeNodeStream)_input;
-		int _s = s;
-		switch ( s )
-		{
-			case 0:
-				int LA37_27 = input.LA(1);
-
-
-				int index37_27 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (EvaluatePredicate(synpred1_DefineGrammarItemsWalker_fragment)) ) {s = 29;}
-
-				else if ( (true) ) {s = 12;}
-
-
-				input.Seek(index37_27);
-				if ( s>=0 ) return s;
-				break;
-			case 1:
-				int LA37_28 = input.LA(1);
-
-
-				int index37_28 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (EvaluatePredicate(synpred1_DefineGrammarItemsWalker_fragment)) ) {s = 29;}
-
-				else if ( (true) ) {s = 14;}
-
-
-				input.Seek(index37_28);
-				if ( s>=0 ) return s;
-				break;
-		}
-		if (state.backtracking>0) {state.failed=true; return -1;}
-		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 37, _s, input);
-		dfa.Error(nvae);
-		throw nvae;
-	}
-
-	#endregion DFA
-
-	#region Follow sets
-	private static class Follow
-	{
-		public static readonly BitSet _LEXER_GRAMMAR_in_grammar_77 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _grammarSpec_in_grammar_83 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _PARSER_GRAMMAR_in_grammar_92 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _grammarSpec_in_grammar_97 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _TREE_GRAMMAR_in_grammar_106 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _grammarSpec_in_grammar_111 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _COMBINED_GRAMMAR_in_grammar_120 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _grammarSpec_in_grammar_125 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _SCOPE_in_attrScope150 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_attrScope154 = new BitSet(new ulong[]{0x210UL});
-		public static readonly BitSet _attrScopeAction_in_attrScope156 = new BitSet(new ulong[]{0x210UL});
-		public static readonly BitSet _ACTION_in_attrScope161 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _AMPERSAND_in_attrScopeAction179 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_attrScopeAction181 = new BitSet(new ulong[]{0x10UL});
-		public static readonly BitSet _ACTION_in_attrScopeAction183 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ID_in_grammarSpec201 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
-		public static readonly BitSet _DOC_COMMENT_in_grammarSpec208 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
-		public static readonly BitSet _optionsSpec_in_grammarSpec216 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
-		public static readonly BitSet _delegateGrammars_in_grammarSpec224 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
-		public static readonly BitSet _tokensSpec_in_grammarSpec231 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
-		public static readonly BitSet _attrScope_in_grammarSpec238 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
-		public static readonly BitSet _actions_in_grammarSpec245 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
-		public static readonly BitSet _rules_in_grammarSpec251 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _action_in_actions264 = new BitSet(new ulong[]{0x202UL});
-		public static readonly BitSet _AMPERSAND_in_action286 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_action290 = new BitSet(new ulong[]{0x80000000010UL});
-		public static readonly BitSet _ID_in_action299 = new BitSet(new ulong[]{0x10UL});
-		public static readonly BitSet _ACTION_in_action303 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ACTION_in_action319 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _OPTIONS_in_optionsSpec353 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _IMPORT_in_delegateGrammars370 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ASSIGN_in_delegateGrammars375 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_delegateGrammars377 = new BitSet(new ulong[]{0x80000000000UL});
-		public static readonly BitSet _ID_in_delegateGrammars379 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ID_in_delegateGrammars384 = new BitSet(new ulong[]{0x80000002008UL});
-		public static readonly BitSet _TOKENS_in_tokensSpec402 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _tokenSpec_in_tokensSpec406 = new BitSet(new ulong[]{0x2008UL,0x4000000UL});
-		public static readonly BitSet _TOKEN_REF_in_tokenSpec424 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ASSIGN_in_tokenSpec431 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _TOKEN_REF_in_tokenSpec436 = new BitSet(new ulong[]{0x40000UL,0x200000UL});
-		public static readonly BitSet _set_in_tokenSpec441 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _rule_in_rules471 = new BitSet(new ulong[]{0x400200008000202UL,0x8005000UL});
-		public static readonly BitSet _RULE_in_rule491 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_rule495 = new BitSet(new ulong[]{0x10000000400UL,0xEUL});
-		public static readonly BitSet _modifier_in_rule503 = new BitSet(new ulong[]{0x400UL});
-		public static readonly BitSet _ARG_in_rule512 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_ACTION_in_rule517 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _RET_in_rule528 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_ACTION_in_rule533 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _throwsSpec_in_rule543 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
-		public static readonly BitSet _optionsSpec_in_rule551 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
-		public static readonly BitSet _ruleScopeSpec_in_rule564 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
-		public static readonly BitSet _ruleAction_in_rule573 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
-		public static readonly BitSet _block_in_rule588 = new BitSet(new ulong[]{0x4400020000UL});
-		public static readonly BitSet _exceptionGroup_in_rule594 = new BitSet(new ulong[]{0x400000000UL});
-		public static readonly BitSet _EOR_in_rule601 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _AMPERSAND_in_ruleAction625 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_ruleAction629 = new BitSet(new ulong[]{0x10UL});
-		public static readonly BitSet _ACTION_in_ruleAction633 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _set_in_modifier657 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _THROWS_in_throwsSpec693 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_throwsSpec696 = new BitSet(new ulong[]{0x80000000008UL});
-		public static readonly BitSet _SCOPE_in_ruleScopeSpec726 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _attrScopeAction_in_ruleScopeSpec733 = new BitSet(new ulong[]{0x210UL});
-		public static readonly BitSet _ACTION_in_ruleScopeSpec738 = new BitSet(new ulong[]{0x80000000008UL});
-		public static readonly BitSet _ID_in_ruleScopeSpec759 = new BitSet(new ulong[]{0x80000000008UL});
-		public static readonly BitSet _BLOCK_in_block793 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _optionsSpec_in_block799 = new BitSet(new ulong[]{0x300UL});
-		public static readonly BitSet _blockAction_in_block807 = new BitSet(new ulong[]{0x300UL});
-		public static readonly BitSet _alternative_in_block816 = new BitSet(new ulong[]{0x200000300UL,0x200UL});
-		public static readonly BitSet _rewrite_in_block818 = new BitSet(new ulong[]{0x200000300UL});
-		public static readonly BitSet _EOB_in_block835 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _AMPERSAND_in_blockAction859 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_blockAction863 = new BitSet(new ulong[]{0x10UL});
-		public static readonly BitSet _ACTION_in_blockAction867 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ALT_in_alternative888 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _element_in_alternative891 = new BitSet(new ulong[]{0x86800289202DE210UL,0xA4E16421UL});
-		public static readonly BitSet _EOA_in_alternative895 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _exceptionHandler_in_exceptionGroup910 = new BitSet(new ulong[]{0x4000020002UL});
-		public static readonly BitSet _finallyClause_in_exceptionGroup916 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _finallyClause_in_exceptionGroup923 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _CATCH_in_exceptionHandler937 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_ACTION_in_exceptionHandler939 = new BitSet(new ulong[]{0x10UL});
-		public static readonly BitSet _ACTION_in_exceptionHandler941 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _FINALLY_in_finallyClause959 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ACTION_in_finallyClause961 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ROOT_in_element978 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _element_in_element980 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _BANG_in_element989 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _element_in_element991 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _atom_in_element999 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _NOT_in_element1008 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _element_in_element1010 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _RANGE_in_element1019 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _atom_in_element1021 = new BitSet(new ulong[]{0x20040000UL,0x84202000UL});
-		public static readonly BitSet _atom_in_element1024 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _CHAR_RANGE_in_element1034 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _atom_in_element1036 = new BitSet(new ulong[]{0x20040000UL,0x84202000UL});
-		public static readonly BitSet _atom_in_element1039 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ASSIGN_in_element1048 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_element1052 = new BitSet(new ulong[]{0x86800289202DE210UL,0xA4E16421UL});
-		public static readonly BitSet _element_in_element1056 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _PLUS_ASSIGN_in_element1069 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_element1073 = new BitSet(new ulong[]{0x86800289202DE210UL,0xA4E16421UL});
-		public static readonly BitSet _element_in_element1077 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ebnf_in_element1094 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _tree__in_element1101 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _SYNPRED_in_element1110 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _block_in_element1112 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ACTION_in_element1123 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _FORCED_ACTION_in_element1136 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _SEMPRED_in_element1147 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _SYN_SEMPRED_in_element1158 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _BACKTRACK_SEMPRED_in_element1166 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _GATED_SEMPRED_in_element1177 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _EPSILON_in_element1188 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _dotLoop_in_ebnf1206 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _block_in_ebnf1212 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _OPTIONAL_in_ebnf1219 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _block_in_ebnf1221 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _CLOSURE_in_ebnf1230 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _block_in_ebnf1232 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _POSITIVE_CLOSURE_in_ebnf1241 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _block_in_ebnf1243 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _CLOSURE_in_dotLoop1262 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _dotBlock_in_dotLoop1264 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _POSITIVE_CLOSURE_in_dotLoop1274 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _dotBlock_in_dotLoop1276 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _BLOCK_in_dotBlock1299 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ALT_in_dotBlock1303 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _WILDCARD_in_dotBlock1305 = new BitSet(new ulong[]{0x100000000UL});
-		public static readonly BitSet _EOA_in_dotBlock1307 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _EOB_in_dotBlock1311 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _TREE_BEGIN_in_tree_1325 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _element_in_tree_1327 = new BitSet(new ulong[]{0x86800289202DE218UL,0xA4E16421UL});
-		public static readonly BitSet _RULE_REF_in_atom1345 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_ACTION_in_atom1350 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _TOKEN_REF_in_atom1367 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_ACTION_in_atom1372 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _CHAR_LITERAL_in_atom1388 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _STRING_LITERAL_in_atom1399 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _WILDCARD_in_atom1409 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _DOT_in_atom1415 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_atom1417 = new BitSet(new ulong[]{0x20040000UL,0x84202000UL});
-		public static readonly BitSet _atom_in_atom1419 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _set_in_ast_suffix1433 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _REWRITE_in_rewrite1461 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _SEMPRED_in_rewrite1466 = new BitSet(new ulong[]{0x2000000110UL,0x1000000UL});
-		public static readonly BitSet _rewrite_alternative_in_rewrite1470 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _BLOCK_in_rewrite_block1505 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _rewrite_alternative_in_rewrite_block1507 = new BitSet(new ulong[]{0x200000000UL});
-		public static readonly BitSet _EOB_in_rewrite_block1509 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ALT_in_rewrite_alternative1541 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _rewrite_element_in_rewrite_alternative1547 = new BitSet(new ulong[]{0x201000100240010UL,0x24202001UL});
-		public static readonly BitSet _EPSILON_in_rewrite_alternative1554 = new BitSet(new ulong[]{0x100000000UL});
-		public static readonly BitSet _EOA_in_rewrite_alternative1558 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _rewrite_template_in_rewrite_alternative1569 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ETC_in_rewrite_alternative1574 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _rewrite_atom_in_rewrite_element1588 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _rewrite_ebnf_in_rewrite_element1593 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _rewrite_tree_in_rewrite_element1598 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _OPTIONAL_in_rewrite_ebnf1611 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _rewrite_block_in_rewrite_ebnf1613 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _CLOSURE_in_rewrite_ebnf1622 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _rewrite_block_in_rewrite_ebnf1624 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _POSITIVE_CLOSURE_in_rewrite_ebnf1633 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _rewrite_block_in_rewrite_ebnf1635 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _TREE_BEGIN_in_rewrite_tree1652 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _rewrite_atom_in_rewrite_tree1654 = new BitSet(new ulong[]{0x201000100240018UL,0x24202001UL});
-		public static readonly BitSet _rewrite_element_in_rewrite_tree1658 = new BitSet(new ulong[]{0x201000100240018UL,0x24202001UL});
-		public static readonly BitSet _RULE_REF_in_rewrite_atom1679 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _TOKEN_REF_in_rewrite_atom1689 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_ACTION_in_rewrite_atom1697 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _CHAR_LITERAL_in_rewrite_atom1722 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _STRING_LITERAL_in_rewrite_atom1728 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _LABEL_in_rewrite_atom1737 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ACTION_in_rewrite_atom1742 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ALT_in_rewrite_template1759 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _EPSILON_in_rewrite_template1761 = new BitSet(new ulong[]{0x100000000UL});
-		public static readonly BitSet _EOA_in_rewrite_template1763 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _TEMPLATE_in_rewrite_template1772 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_rewrite_template1777 = new BitSet(new ulong[]{0x1000UL});
-		public static readonly BitSet _ACTION_in_rewrite_template1781 = new BitSet(new ulong[]{0x1000UL});
-		public static readonly BitSet _ARGLIST_in_rewrite_template1789 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_in_rewrite_template1799 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_rewrite_template1803 = new BitSet(new ulong[]{0x10UL});
-		public static readonly BitSet _ACTION_in_rewrite_template1807 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _set_in_rewrite_template1838 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ACTION_in_rewrite_template1864 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _dotLoop_in_synpred1_DefineGrammarItemsWalker1201 = new BitSet(new ulong[]{0x2UL});
-
-	}
-	#endregion Follow sets
-}
-
-} // namespace Antlr3.Grammars
diff --git a/Antlr3/Grammars/TreeToNFAConverter.cs b/Antlr3/Grammars/TreeToNFAConverter.cs
deleted file mode 100644
index 283632a..0000000
--- a/Antlr3/Grammars/TreeToNFAConverter.cs
+++ /dev/null
@@ -1,5205 +0,0 @@
-// $ANTLR 3.1.2 Grammars\\TreeToNFAConverter.g3 2009-09-30 13:28:47
-
-// The variable 'variable' is assigned but its value is never used.
-#pragma warning disable 219
-// Unreachable code detected.
-#pragma warning disable 162
-
-
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Grammar conversion to ANTLR v3 and C#:
- Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-	notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-	derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-using Antlr3.Analysis;
-using Antlr3.Misc;
-using Antlr3.Tool;
-
-using BitSet = Antlr.Runtime.BitSet;
-using DFA = Antlr.Runtime.DFA;
-
-
-using System.Collections.Generic;
-using Antlr.Runtime;
-using Antlr.Runtime.Tree;
-using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;using Stack = System.Collections.Generic.Stack<object>;
-using List = System.Collections.IList;
-using ArrayList = System.Collections.Generic.List<object>;
-using Map = System.Collections.IDictionary;
-using HashMap = System.Collections.Generic.Dictionary<object, object>;
-namespace Antlr3.Grammars
-{
-/** Build an NFA from a tree representing an ANTLR grammar. */
-[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.1.2")]
-[System.CLSCompliant(false)]
-public partial class TreeToNFAConverter : TreeParser
-{
-	internal static readonly string[] tokenNames = new string[] {
-		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", "ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARG_ACTION", "ARGLIST", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", "CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", "COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", "DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", "EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", "GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", "LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", "NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", "OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", "RET", "RETURNS", "REWRITE", "ROOT", "RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", "SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYN_SEMPRED", "SYNPRED", "TEMPLATE", "THROWS", "TOKEN_REF", "TOKENS", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", "WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT"
-	};
-	public const int EOF=-1;
-	public const int ACTION=4;
-	public const int ACTION_CHAR_LITERAL=5;
-	public const int ACTION_ESC=6;
-	public const int ACTION_STRING_LITERAL=7;
-	public const int ALT=8;
-	public const int AMPERSAND=9;
-	public const int ARG=10;
-	public const int ARG_ACTION=11;
-	public const int ARGLIST=12;
-	public const int ASSIGN=13;
-	public const int BACKTRACK_SEMPRED=14;
-	public const int BANG=15;
-	public const int BLOCK=16;
-	public const int CATCH=17;
-	public const int CHAR_LITERAL=18;
-	public const int CHAR_RANGE=19;
-	public const int CLOSE_ELEMENT_OPTION=20;
-	public const int CLOSURE=21;
-	public const int COLON=22;
-	public const int COMBINED_GRAMMAR=23;
-	public const int COMMA=24;
-	public const int COMMENT=25;
-	public const int DIGIT=26;
-	public const int DOC_COMMENT=27;
-	public const int DOLLAR=28;
-	public const int DOT=29;
-	public const int DOUBLE_ANGLE_STRING_LITERAL=30;
-	public const int DOUBLE_QUOTE_STRING_LITERAL=31;
-	public const int EOA=32;
-	public const int EOB=33;
-	public const int EOR=34;
-	public const int EPSILON=35;
-	public const int ESC=36;
-	public const int ETC=37;
-	public const int FINALLY=38;
-	public const int FORCED_ACTION=39;
-	public const int FRAGMENT=40;
-	public const int GATED_SEMPRED=41;
-	public const int GRAMMAR=42;
-	public const int ID=43;
-	public const int IMPLIES=44;
-	public const int IMPORT=45;
-	public const int INITACTION=46;
-	public const int INT=47;
-	public const int LABEL=48;
-	public const int LEXER=49;
-	public const int LEXER_GRAMMAR=50;
-	public const int LPAREN=51;
-	public const int ML_COMMENT=52;
-	public const int NESTED_ACTION=53;
-	public const int NESTED_ARG_ACTION=54;
-	public const int NOT=55;
-	public const int OPEN_ELEMENT_OPTION=56;
-	public const int OPTIONAL=57;
-	public const int OPTIONS=58;
-	public const int OR=59;
-	public const int PARSER=60;
-	public const int PARSER_GRAMMAR=61;
-	public const int PLUS=62;
-	public const int PLUS_ASSIGN=63;
-	public const int POSITIVE_CLOSURE=64;
-	public const int PRIVATE=65;
-	public const int PROTECTED=66;
-	public const int PUBLIC=67;
-	public const int QUESTION=68;
-	public const int RANGE=69;
-	public const int RCURLY=70;
-	public const int RET=71;
-	public const int RETURNS=72;
-	public const int REWRITE=73;
-	public const int ROOT=74;
-	public const int RPAREN=75;
-	public const int RULE=76;
-	public const int RULE_REF=77;
-	public const int SCOPE=78;
-	public const int SEMI=79;
-	public const int SEMPRED=80;
-	public const int SL_COMMENT=81;
-	public const int SRC=82;
-	public const int STAR=83;
-	public const int STRAY_BRACKET=84;
-	public const int STRING_LITERAL=85;
-	public const int SYN_SEMPRED=86;
-	public const int SYNPRED=87;
-	public const int TEMPLATE=88;
-	public const int THROWS=89;
-	public const int TOKEN_REF=90;
-	public const int TOKENS=91;
-	public const int TREE=92;
-	public const int TREE_BEGIN=93;
-	public const int TREE_GRAMMAR=94;
-	public const int WILDCARD=95;
-	public const int WS=96;
-	public const int WS_LOOP=97;
-	public const int WS_OPT=98;
-	public const int XDIGIT=99;
-
-	// delegates
-	// delegators
-
-	public TreeToNFAConverter( ITreeNodeStream input )
-		: this( input, new RecognizerSharedState() )
-	{
-	}
-	public TreeToNFAConverter( ITreeNodeStream input, RecognizerSharedState state )
-		: base( input, state )
-	{
-	}
-
-
-	public override string[] TokenNames { get { return TreeToNFAConverter.tokenNames; } }
-	public override string GrammarFileName { get { return "Grammars\\TreeToNFAConverter.g3"; } }
-
-
-	#region Rules
-
-	// $ANTLR start "grammar_"
-	// Grammars\\TreeToNFAConverter.g3:88:0: public grammar_ : ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) ) ;
-	public void grammar_(  )
-	{
-		try
-		{
-			// Grammars\\TreeToNFAConverter.g3:93:4: ( ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) ) )
-			// Grammars\\TreeToNFAConverter.g3:93:4: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
-			{
-			// Grammars\\TreeToNFAConverter.g3:93:4: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
-			int alt1=4;
-			switch ( input.LA(1) )
-			{
-			case LEXER_GRAMMAR:
-				{
-				alt1=1;
-				}
-				break;
-			case PARSER_GRAMMAR:
-				{
-				alt1=2;
-				}
-				break;
-			case TREE_GRAMMAR:
-				{
-				alt1=3;
-				}
-				break;
-			case COMBINED_GRAMMAR:
-				{
-				alt1=4;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					NoViableAltException nvae = new NoViableAltException("", 1, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt1 )
-			{
-			case 1:
-				// Grammars\\TreeToNFAConverter.g3:93:6: ^( LEXER_GRAMMAR grammarSpec )
-				{
-				Match(input,LEXER_GRAMMAR,Follow._LEXER_GRAMMAR_in_grammar_67); if (state.failed) return ;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return ;
-				PushFollow(Follow._grammarSpec_in_grammar_69);
-				grammarSpec();
-
-				state._fsp--;
-				if (state.failed) return ;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-				}
-				break;
-			case 2:
-				// Grammars\\TreeToNFAConverter.g3:94:5: ^( PARSER_GRAMMAR grammarSpec )
-				{
-				Match(input,PARSER_GRAMMAR,Follow._PARSER_GRAMMAR_in_grammar_79); if (state.failed) return ;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return ;
-				PushFollow(Follow._grammarSpec_in_grammar_81);
-				grammarSpec();
-
-				state._fsp--;
-				if (state.failed) return ;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-				}
-				break;
-			case 3:
-				// Grammars\\TreeToNFAConverter.g3:95:5: ^( TREE_GRAMMAR grammarSpec )
-				{
-				Match(input,TREE_GRAMMAR,Follow._TREE_GRAMMAR_in_grammar_91); if (state.failed) return ;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return ;
-				PushFollow(Follow._grammarSpec_in_grammar_93);
-				grammarSpec();
-
-				state._fsp--;
-				if (state.failed) return ;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-				}
-				break;
-			case 4:
-				// Grammars\\TreeToNFAConverter.g3:96:5: ^( COMBINED_GRAMMAR grammarSpec )
-				{
-				Match(input,COMBINED_GRAMMAR,Follow._COMBINED_GRAMMAR_in_grammar_103); if (state.failed) return ;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return ;
-				PushFollow(Follow._grammarSpec_in_grammar_105);
-				grammarSpec();
-
-				state._fsp--;
-				if (state.failed) return ;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-
-			}
-
-			if ( state.backtracking == 0 )
-			{
-
-					Finish();
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "grammar_"
-
-
-	// $ANTLR start "attrScope"
-	// Grammars\\TreeToNFAConverter.g3:100:0: attrScope : ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION ) ;
-	private void attrScope(  )
-	{
-		try
-		{
-			// Grammars\\TreeToNFAConverter.g3:101:4: ( ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION ) )
-			// Grammars\\TreeToNFAConverter.g3:101:4: ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION )
-			{
-			Match(input,SCOPE,Follow._SCOPE_in_attrScope124); if (state.failed) return ;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return ;
-			Match(input,ID,Follow._ID_in_attrScope126); if (state.failed) return ;
-			// Grammars\\TreeToNFAConverter.g3:101:18: ( ^( AMPERSAND ( . )* ) )*
-			for ( ; ; )
-			{
-				int alt3=2;
-				int LA3_0 = input.LA(1);
-
-				if ( (LA3_0==AMPERSAND) )
-				{
-					alt3=1;
-				}
-
-
-				switch ( alt3 )
-				{
-				case 1:
-					// Grammars\\TreeToNFAConverter.g3:101:20: ^( AMPERSAND ( . )* )
-					{
-					Match(input,AMPERSAND,Follow._AMPERSAND_in_attrScope131); if (state.failed) return ;
-
-					if ( input.LA(1)==TokenTypes.Down )
-					{
-						Match(input, TokenTypes.Down, null); if (state.failed) return ;
-						// Grammars\\TreeToNFAConverter.g3:101:32: ( . )*
-						for ( ; ; )
-						{
-							int alt2=2;
-							int LA2_0 = input.LA(1);
-
-							if ( ((LA2_0>=ACTION && LA2_0<=XDIGIT)) )
-							{
-								alt2=1;
-							}
-							else if ( (LA2_0==UP) )
-							{
-								alt2=2;
-							}
-
-
-							switch ( alt2 )
-							{
-							case 1:
-								// Grammars\\TreeToNFAConverter.g3:101:0: .
-								{
-								MatchAny(input); if (state.failed) return ;
-
-								}
-								break;
-
-							default:
-								goto loop2;
-							}
-						}
-
-						loop2:
-							;
-
-
-
-						Match(input, TokenTypes.Up, null); if (state.failed) return ;
-					}
-
-					}
-					break;
-
-				default:
-					goto loop3;
-				}
-			}
-
-			loop3:
-				;
-
-
-			Match(input,ACTION,Follow._ACTION_in_attrScope140); if (state.failed) return ;
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "attrScope"
-
-
-	// $ANTLR start "grammarSpec"
-	// Grammars\\TreeToNFAConverter.g3:104:0: grammarSpec : ID (cmt= DOC_COMMENT )? ( ^( OPTIONS ( . )* ) )? ( ^( IMPORT ( . )* ) )? ( ^( TOKENS ( . )* ) )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules ;
-	private void grammarSpec(  )
-	{
-		GrammarAST cmt=null;
-
-		try
-		{
-			// Grammars\\TreeToNFAConverter.g3:105:4: ( ID (cmt= DOC_COMMENT )? ( ^( OPTIONS ( . )* ) )? ( ^( IMPORT ( . )* ) )? ( ^( TOKENS ( . )* ) )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules )
-			// Grammars\\TreeToNFAConverter.g3:105:4: ID (cmt= DOC_COMMENT )? ( ^( OPTIONS ( . )* ) )? ( ^( IMPORT ( . )* ) )? ( ^( TOKENS ( . )* ) )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules
-			{
-			Match(input,ID,Follow._ID_in_grammarSpec153); if (state.failed) return ;
-			// Grammars\\TreeToNFAConverter.g3:106:3: (cmt= DOC_COMMENT )?
-			int alt4=2;
-			int LA4_0 = input.LA(1);
-
-			if ( (LA4_0==DOC_COMMENT) )
-			{
-				alt4=1;
-			}
-			switch ( alt4 )
-			{
-			case 1:
-				// Grammars\\TreeToNFAConverter.g3:106:4: cmt= DOC_COMMENT
-				{
-				cmt=(GrammarAST)Match(input,DOC_COMMENT,Follow._DOC_COMMENT_in_grammarSpec160); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-
-			// Grammars\\TreeToNFAConverter.g3:107:3: ( ^( OPTIONS ( . )* ) )?
-			int alt6=2;
-			int LA6_0 = input.LA(1);
-
-			if ( (LA6_0==OPTIONS) )
-			{
-				alt6=1;
-			}
-			switch ( alt6 )
-			{
-			case 1:
-				// Grammars\\TreeToNFAConverter.g3:107:5: ^( OPTIONS ( . )* )
-				{
-				Match(input,OPTIONS,Follow._OPTIONS_in_grammarSpec169); if (state.failed) return ;
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null); if (state.failed) return ;
-					// Grammars\\TreeToNFAConverter.g3:107:15: ( . )*
-					for ( ; ; )
-					{
-						int alt5=2;
-						int LA5_0 = input.LA(1);
-
-						if ( ((LA5_0>=ACTION && LA5_0<=XDIGIT)) )
-						{
-							alt5=1;
-						}
-						else if ( (LA5_0==UP) )
-						{
-							alt5=2;
-						}
-
-
-						switch ( alt5 )
-						{
-						case 1:
-							// Grammars\\TreeToNFAConverter.g3:107:0: .
-							{
-							MatchAny(input); if (state.failed) return ;
-
-							}
-							break;
-
-						default:
-							goto loop5;
-						}
-					}
-
-					loop5:
-						;
-
-
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return ;
-				}
-
-				}
-				break;
-
-			}
-
-			// Grammars\\TreeToNFAConverter.g3:108:3: ( ^( IMPORT ( . )* ) )?
-			int alt8=2;
-			int LA8_0 = input.LA(1);
-
-			if ( (LA8_0==IMPORT) )
-			{
-				alt8=1;
-			}
-			switch ( alt8 )
-			{
-			case 1:
-				// Grammars\\TreeToNFAConverter.g3:108:5: ^( IMPORT ( . )* )
-				{
-				Match(input,IMPORT,Follow._IMPORT_in_grammarSpec183); if (state.failed) return ;
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null); if (state.failed) return ;
-					// Grammars\\TreeToNFAConverter.g3:108:14: ( . )*
-					for ( ; ; )
-					{
-						int alt7=2;
-						int LA7_0 = input.LA(1);
-
-						if ( ((LA7_0>=ACTION && LA7_0<=XDIGIT)) )
-						{
-							alt7=1;
-						}
-						else if ( (LA7_0==UP) )
-						{
-							alt7=2;
-						}
-
-
-						switch ( alt7 )
-						{
-						case 1:
-							// Grammars\\TreeToNFAConverter.g3:108:0: .
-							{
-							MatchAny(input); if (state.failed) return ;
-
-							}
-							break;
-
-						default:
-							goto loop7;
-						}
-					}
-
-					loop7:
-						;
-
-
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return ;
-				}
-
-				}
-				break;
-
-			}
-
-			// Grammars\\TreeToNFAConverter.g3:109:3: ( ^( TOKENS ( . )* ) )?
-			int alt10=2;
-			int LA10_0 = input.LA(1);
-
-			if ( (LA10_0==TOKENS) )
-			{
-				alt10=1;
-			}
-			switch ( alt10 )
-			{
-			case 1:
-				// Grammars\\TreeToNFAConverter.g3:109:5: ^( TOKENS ( . )* )
-				{
-				Match(input,TOKENS,Follow._TOKENS_in_grammarSpec197); if (state.failed) return ;
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null); if (state.failed) return ;
-					// Grammars\\TreeToNFAConverter.g3:109:14: ( . )*
-					for ( ; ; )
-					{
-						int alt9=2;
-						int LA9_0 = input.LA(1);
-
-						if ( ((LA9_0>=ACTION && LA9_0<=XDIGIT)) )
-						{
-							alt9=1;
-						}
-						else if ( (LA9_0==UP) )
-						{
-							alt9=2;
-						}
-
-
-						switch ( alt9 )
-						{
-						case 1:
-							// Grammars\\TreeToNFAConverter.g3:109:0: .
-							{
-							MatchAny(input); if (state.failed) return ;
-
-							}
-							break;
-
-						default:
-							goto loop9;
-						}
-					}
-
-					loop9:
-						;
-
-
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return ;
-				}
-
-				}
-				break;
-
-			}
-
-			// Grammars\\TreeToNFAConverter.g3:110:3: ( attrScope )*
-			for ( ; ; )
-			{
-				int alt11=2;
-				int LA11_0 = input.LA(1);
-
-				if ( (LA11_0==SCOPE) )
-				{
-					alt11=1;
-				}
-
-
-				switch ( alt11 )
-				{
-				case 1:
-					// Grammars\\TreeToNFAConverter.g3:110:4: attrScope
-					{
-					PushFollow(Follow._attrScope_in_grammarSpec209);
-					attrScope();
-
-					state._fsp--;
-					if (state.failed) return ;
-
-					}
-					break;
-
-				default:
-					goto loop11;
-				}
-			}
-
-			loop11:
-				;
-
-
-			// Grammars\\TreeToNFAConverter.g3:111:3: ( ^( AMPERSAND ( . )* ) )*
-			for ( ; ; )
-			{
-				int alt13=2;
-				int LA13_0 = input.LA(1);
-
-				if ( (LA13_0==AMPERSAND) )
-				{
-					alt13=1;
-				}
-
-
-				switch ( alt13 )
-				{
-				case 1:
-					// Grammars\\TreeToNFAConverter.g3:111:5: ^( AMPERSAND ( . )* )
-					{
-					Match(input,AMPERSAND,Follow._AMPERSAND_in_grammarSpec218); if (state.failed) return ;
-
-					if ( input.LA(1)==TokenTypes.Down )
-					{
-						Match(input, TokenTypes.Down, null); if (state.failed) return ;
-						// Grammars\\TreeToNFAConverter.g3:111:17: ( . )*
-						for ( ; ; )
-						{
-							int alt12=2;
-							int LA12_0 = input.LA(1);
-
-							if ( ((LA12_0>=ACTION && LA12_0<=XDIGIT)) )
-							{
-								alt12=1;
-							}
-							else if ( (LA12_0==UP) )
-							{
-								alt12=2;
-							}
-
-
-							switch ( alt12 )
-							{
-							case 1:
-								// Grammars\\TreeToNFAConverter.g3:111:0: .
-								{
-								MatchAny(input); if (state.failed) return ;
-
-								}
-								break;
-
-							default:
-								goto loop12;
-							}
-						}
-
-						loop12:
-							;
-
-
-
-						Match(input, TokenTypes.Up, null); if (state.failed) return ;
-					}
-
-					}
-					break;
-
-				default:
-					goto loop13;
-				}
-			}
-
-			loop13:
-				;
-
-
-			PushFollow(Follow._rules_in_grammarSpec230);
-			rules();
-
-			state._fsp--;
-			if (state.failed) return ;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "grammarSpec"
-
-
-	// $ANTLR start "rules"
-	// Grammars\\TreeToNFAConverter.g3:115:0: rules : ( rule )+ ;
-	private void rules(  )
-	{
-		try
-		{
-			// Grammars\\TreeToNFAConverter.g3:116:4: ( ( rule )+ )
-			// Grammars\\TreeToNFAConverter.g3:116:4: ( rule )+
-			{
-			// Grammars\\TreeToNFAConverter.g3:116:4: ( rule )+
-			int cnt14=0;
-			for ( ; ; )
-			{
-				int alt14=2;
-				int LA14_0 = input.LA(1);
-
-				if ( (LA14_0==RULE) )
-				{
-					alt14=1;
-				}
-
-
-				switch ( alt14 )
-				{
-				case 1:
-					// Grammars\\TreeToNFAConverter.g3:116:0: rule
-					{
-					PushFollow(Follow._rule_in_rules241);
-					rule();
-
-					state._fsp--;
-					if (state.failed) return ;
-
-					}
-					break;
-
-				default:
-					if ( cnt14 >= 1 )
-						goto loop14;
-
-					if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee14 = new EarlyExitException( 14, input );
-					throw eee14;
-				}
-				cnt14++;
-			}
-			loop14:
-				;
-
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "rules"
-
-	public class rule_return : TreeRuleReturnScope
-	{
-	}
-
-	// $ANTLR start "rule"
-	// Grammars\\TreeToNFAConverter.g3:119:0: rule : ^( RULE id= ID ( modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block ( exceptionGroup )? EOR ) ;
-	private TreeToNFAConverter.rule_return rule(  )
-	{
-		TreeToNFAConverter.rule_return retval = new TreeToNFAConverter.rule_return();
-		retval.start = input.LT(1);
-
-		GrammarAST id=null;
-		TreeToNFAConverter.block_return b = default(TreeToNFAConverter.block_return);
-
-		try
-		{
-			// Grammars\\TreeToNFAConverter.g3:120:4: ( ^( RULE id= ID ( modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block ( exceptionGroup )? EOR ) )
-			// Grammars\\TreeToNFAConverter.g3:120:4: ^( RULE id= ID ( modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block ( exceptionGroup )? EOR )
-			{
-			Match(input,RULE,Follow._RULE_in_rule255); if (state.failed) return retval;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-			id=(GrammarAST)Match(input,ID,Follow._ID_in_rule259); if (state.failed) return retval;
-			if ( state.backtracking == 0 )
-			{
-
-								currentRuleName = (id!=null?id.Text:null);
-								factory.CurrentRule = grammar.GetLocallyDefinedRule( currentRuleName );
-
-			}
-			// Grammars\\TreeToNFAConverter.g3:125:4: ( modifier )?
-			int alt15=2;
-			int LA15_0 = input.LA(1);
-
-			if ( (LA15_0==FRAGMENT||(LA15_0>=PRIVATE && LA15_0<=PUBLIC)) )
-			{
-				alt15=1;
-			}
-			switch ( alt15 )
-			{
-			case 1:
-				// Grammars\\TreeToNFAConverter.g3:125:5: modifier
-				{
-				PushFollow(Follow._modifier_in_rule270);
-				modifier();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				}
-				break;
-
-			}
-
-			Match(input,ARG,Follow._ARG_in_rule278); if (state.failed) return retval;
-
-			if ( input.LA(1)==TokenTypes.Down )
-			{
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				// Grammars\\TreeToNFAConverter.g3:126:10: ( ARG_ACTION )?
-				int alt16=2;
-				int LA16_0 = input.LA(1);
-
-				if ( (LA16_0==ARG_ACTION) )
-				{
-					alt16=1;
-				}
-				switch ( alt16 )
-				{
-				case 1:
-					// Grammars\\TreeToNFAConverter.g3:126:11: ARG_ACTION
-					{
-					Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule281); if (state.failed) return retval;
-
-					}
-					break;
-
-				}
-
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-			}
-			Match(input,RET,Follow._RET_in_rule290); if (state.failed) return retval;
-
-			if ( input.LA(1)==TokenTypes.Down )
-			{
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				// Grammars\\TreeToNFAConverter.g3:127:10: ( ARG_ACTION )?
-				int alt17=2;
-				int LA17_0 = input.LA(1);
-
-				if ( (LA17_0==ARG_ACTION) )
-				{
-					alt17=1;
-				}
-				switch ( alt17 )
-				{
-				case 1:
-					// Grammars\\TreeToNFAConverter.g3:127:11: ARG_ACTION
-					{
-					Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule293); if (state.failed) return retval;
-
-					}
-					break;
-
-				}
-
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-			}
-			// Grammars\\TreeToNFAConverter.g3:128:4: ( throwsSpec )?
-			int alt18=2;
-			int LA18_0 = input.LA(1);
-
-			if ( (LA18_0==THROWS) )
-			{
-				alt18=1;
-			}
-			switch ( alt18 )
-			{
-			case 1:
-				// Grammars\\TreeToNFAConverter.g3:128:5: throwsSpec
-				{
-				PushFollow(Follow._throwsSpec_in_rule302);
-				throwsSpec();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				}
-				break;
-
-			}
-
-			// Grammars\\TreeToNFAConverter.g3:129:4: ( ^( OPTIONS ( . )* ) )?
-			int alt20=2;
-			int LA20_0 = input.LA(1);
-
-			if ( (LA20_0==OPTIONS) )
-			{
-				alt20=1;
-			}
-			switch ( alt20 )
-			{
-			case 1:
-				// Grammars\\TreeToNFAConverter.g3:129:6: ^( OPTIONS ( . )* )
-				{
-				Match(input,OPTIONS,Follow._OPTIONS_in_rule312); if (state.failed) return retval;
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-					// Grammars\\TreeToNFAConverter.g3:129:16: ( . )*
-					for ( ; ; )
-					{
-						int alt19=2;
-						int LA19_0 = input.LA(1);
-
-						if ( ((LA19_0>=ACTION && LA19_0<=XDIGIT)) )
-						{
-							alt19=1;
-						}
-						else if ( (LA19_0==UP) )
-						{
-							alt19=2;
-						}
-
-
-						switch ( alt19 )
-						{
-						case 1:
-							// Grammars\\TreeToNFAConverter.g3:129:0: .
-							{
-							MatchAny(input); if (state.failed) return retval;
-
-							}
-							break;
-
-						default:
-							goto loop19;
-						}
-					}
-
-					loop19:
-						;
-
-
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				}
-
-				}
-				break;
-
-			}
-
-			// Grammars\\TreeToNFAConverter.g3:130:4: ( ruleScopeSpec )?
-			int alt21=2;
-			int LA21_0 = input.LA(1);
-
-			if ( (LA21_0==SCOPE) )
-			{
-				alt21=1;
-			}
-			switch ( alt21 )
-			{
-			case 1:
-				// Grammars\\TreeToNFAConverter.g3:130:6: ruleScopeSpec
-				{
-				PushFollow(Follow._ruleScopeSpec_in_rule326);
-				ruleScopeSpec();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				}
-				break;
-
-			}
-
-			// Grammars\\TreeToNFAConverter.g3:131:4: ( ^( AMPERSAND ( . )* ) )*
-			for ( ; ; )
-			{
-				int alt23=2;
-				int LA23_0 = input.LA(1);
-
-				if ( (LA23_0==AMPERSAND) )
-				{
-					alt23=1;
-				}
-
-
-				switch ( alt23 )
-				{
-				case 1:
-					// Grammars\\TreeToNFAConverter.g3:131:6: ^( AMPERSAND ( . )* )
-					{
-					Match(input,AMPERSAND,Follow._AMPERSAND_in_rule337); if (state.failed) return retval;
-
-					if ( input.LA(1)==TokenTypes.Down )
-					{
-						Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-						// Grammars\\TreeToNFAConverter.g3:131:18: ( . )*
-						for ( ; ; )
-						{
-							int alt22=2;
-							int LA22_0 = input.LA(1);
-
-							if ( ((LA22_0>=ACTION && LA22_0<=XDIGIT)) )
-							{
-								alt22=1;
-							}
-							else if ( (LA22_0==UP) )
-							{
-								alt22=2;
-							}
-
-
-							switch ( alt22 )
-							{
-							case 1:
-								// Grammars\\TreeToNFAConverter.g3:131:0: .
-								{
-								MatchAny(input); if (state.failed) return retval;
-
-								}
-								break;
-
-							default:
-								goto loop22;
-							}
-						}
-
-						loop22:
-							;
-
-
-
-						Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-					}
-
-					}
-					break;
-
-				default:
-					goto loop23;
-				}
-			}
-
-			loop23:
-				;
-
-
-			PushFollow(Follow._block_in_rule351);
-			b=block();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			// Grammars\\TreeToNFAConverter.g3:133:4: ( exceptionGroup )?
-			int alt24=2;
-			int LA24_0 = input.LA(1);
-
-			if ( (LA24_0==CATCH||LA24_0==FINALLY) )
-			{
-				alt24=1;
-			}
-			switch ( alt24 )
-			{
-			case 1:
-				// Grammars\\TreeToNFAConverter.g3:133:5: exceptionGroup
-				{
-				PushFollow(Follow._exceptionGroup_in_rule357);
-				exceptionGroup();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				}
-				break;
-
-			}
-
-			Match(input,EOR,Follow._EOR_in_rule364); if (state.failed) return retval;
-			if ( state.backtracking == 0 )
-			{
-
-								StateCluster g = (b!=null?b.g:default(StateCluster));
-								if ( (b!=null?((GrammarAST)b.Start):null).SetValue!=null )
-								{
-									// if block comes back as a set not BLOCK, make it
-									// a single ALT block
-									g = factory.BuildAlternativeBlockFromSet(g);
-								}
-								if ( char.IsLower(currentRuleName[0]) ||
-									 grammar.type==GrammarType.Lexer )
-								{
-									// attach start node to block for this rule
-									Rule thisR = grammar.GetLocallyDefinedRule(currentRuleName);
-									NFAState start = thisR.startState;
-									start.associatedASTNode = id;
-									start.AddTransition(new Transition(Label.EPSILON, g.left));
-
-									// track decision if > 1 alts
-									if ( grammar.GetNumberOfAltsForDecisionNFA(g.left)>1 )
-									{
-										g.left.Description = grammar.GrammarTreeToString(((GrammarAST)retval.Start),false);
-										g.left.SetDecisionASTNode((b!=null?((GrammarAST)b.Start):null));
-										int d = grammar.AssignDecisionNumber( g.left );
-										grammar.SetDecisionNFA( d, g.left );
-										grammar.SetDecisionBlockAST(d, (b!=null?((GrammarAST)b.Start):null));
-									}
-
-									// hook to end of rule node
-									NFAState end = thisR.stopState;
-									g.right.AddTransition(new Transition(Label.EPSILON,end));
-								}
-
-			}
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "rule"
-
-
-	// $ANTLR start "modifier"
-	// Grammars\\TreeToNFAConverter.g3:170:0: modifier : ( 'protected' | 'public' | 'private' | 'fragment' );
-	private void modifier(  )
-	{
-		try
-		{
-			// Grammars\\TreeToNFAConverter.g3:171:4: ( 'protected' | 'public' | 'private' | 'fragment' )
-			// Grammars\\TreeToNFAConverter.g3:
-			{
-			if ( input.LA(1)==FRAGMENT||(input.LA(1)>=PRIVATE && input.LA(1)<=PUBLIC) )
-			{
-				input.Consume();
-				state.errorRecovery=false;state.failed=false;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				MismatchedSetException mse = new MismatchedSetException(null,input);
-				throw mse;
-			}
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "modifier"
-
-
-	// $ANTLR start "throwsSpec"
-	// Grammars\\TreeToNFAConverter.g3:177:0: throwsSpec : ^( 'throws' ( ID )+ ) ;
-	private void throwsSpec(  )
-	{
-		try
-		{
-			// Grammars\\TreeToNFAConverter.g3:178:4: ( ^( 'throws' ( ID )+ ) )
-			// Grammars\\TreeToNFAConverter.g3:178:4: ^( 'throws' ( ID )+ )
-			{
-			Match(input,THROWS,Follow._THROWS_in_throwsSpec411); if (state.failed) return ;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return ;
-			// Grammars\\TreeToNFAConverter.g3:178:15: ( ID )+
-			int cnt25=0;
-			for ( ; ; )
-			{
-				int alt25=2;
-				int LA25_0 = input.LA(1);
-
-				if ( (LA25_0==ID) )
-				{
-					alt25=1;
-				}
-
-
-				switch ( alt25 )
-				{
-				case 1:
-					// Grammars\\TreeToNFAConverter.g3:178:0: ID
-					{
-					Match(input,ID,Follow._ID_in_throwsSpec413); if (state.failed) return ;
-
-					}
-					break;
-
-				default:
-					if ( cnt25 >= 1 )
-						goto loop25;
-
-					if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee25 = new EarlyExitException( 25, input );
-					throw eee25;
-				}
-				cnt25++;
-			}
-			loop25:
-				;
-
-
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "throwsSpec"
-
-
-	// $ANTLR start "ruleScopeSpec"
-	// Grammars\\TreeToNFAConverter.g3:181:0: ruleScopeSpec : ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* ) ;
-	private void ruleScopeSpec(  )
-	{
-		try
-		{
-			// Grammars\\TreeToNFAConverter.g3:182:4: ( ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* ) )
-			// Grammars\\TreeToNFAConverter.g3:182:4: ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* )
-			{
-			Match(input,SCOPE,Follow._SCOPE_in_ruleScopeSpec428); if (state.failed) return ;
-
-			if ( input.LA(1)==TokenTypes.Down )
-			{
-				Match(input, TokenTypes.Down, null); if (state.failed) return ;
-				// Grammars\\TreeToNFAConverter.g3:182:15: ( ^( AMPERSAND ( . )* ) )*
-				for ( ; ; )
-				{
-					int alt27=2;
-					int LA27_0 = input.LA(1);
-
-					if ( (LA27_0==AMPERSAND) )
-					{
-						alt27=1;
-					}
-
-
-					switch ( alt27 )
-					{
-					case 1:
-						// Grammars\\TreeToNFAConverter.g3:182:17: ^( AMPERSAND ( . )* )
-						{
-						Match(input,AMPERSAND,Follow._AMPERSAND_in_ruleScopeSpec433); if (state.failed) return ;
-
-						if ( input.LA(1)==TokenTypes.Down )
-						{
-							Match(input, TokenTypes.Down, null); if (state.failed) return ;
-							// Grammars\\TreeToNFAConverter.g3:182:29: ( . )*
-							for ( ; ; )
-							{
-								int alt26=2;
-								int LA26_0 = input.LA(1);
-
-								if ( ((LA26_0>=ACTION && LA26_0<=XDIGIT)) )
-								{
-									alt26=1;
-								}
-								else if ( (LA26_0==UP) )
-								{
-									alt26=2;
-								}
-
-
-								switch ( alt26 )
-								{
-								case 1:
-									// Grammars\\TreeToNFAConverter.g3:182:0: .
-									{
-									MatchAny(input); if (state.failed) return ;
-
-									}
-									break;
-
-								default:
-									goto loop26;
-								}
-							}
-
-							loop26:
-								;
-
-
-
-							Match(input, TokenTypes.Up, null); if (state.failed) return ;
-						}
-
-						}
-						break;
-
-					default:
-						goto loop27;
-					}
-				}
-
-				loop27:
-					;
-
-
-				// Grammars\\TreeToNFAConverter.g3:182:36: ( ACTION )?
-				int alt28=2;
-				int LA28_0 = input.LA(1);
-
-				if ( (LA28_0==ACTION) )
-				{
-					alt28=1;
-				}
-				switch ( alt28 )
-				{
-				case 1:
-					// Grammars\\TreeToNFAConverter.g3:182:37: ACTION
-					{
-					Match(input,ACTION,Follow._ACTION_in_ruleScopeSpec443); if (state.failed) return ;
-
-					}
-					break;
-
-				}
-
-				// Grammars\\TreeToNFAConverter.g3:182:46: ( ID )*
-				for ( ; ; )
-				{
-					int alt29=2;
-					int LA29_0 = input.LA(1);
-
-					if ( (LA29_0==ID) )
-					{
-						alt29=1;
-					}
-
-
-					switch ( alt29 )
-					{
-					case 1:
-						// Grammars\\TreeToNFAConverter.g3:182:48: ID
-						{
-						Match(input,ID,Follow._ID_in_ruleScopeSpec449); if (state.failed) return ;
-
-						}
-						break;
-
-					default:
-						goto loop29;
-					}
-				}
-
-				loop29:
-					;
-
-
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return ;
-			}
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "ruleScopeSpec"
-
-	public class block_return : TreeRuleReturnScope
-	{
-		public StateCluster g = null;
-	}
-
-	// $ANTLR start "block"
-	// Grammars\\TreeToNFAConverter.g3:185:0: block returns [StateCluster g = null] : ({...}? => set | ^( BLOCK ( ^( OPTIONS ( . )* ) )? (a= alternative rewrite )+ EOB ) );
-	private TreeToNFAConverter.block_return block(  )
-	{
-		TreeToNFAConverter.block_return retval = new TreeToNFAConverter.block_return();
-		retval.start = input.LT(1);
-
-		StateCluster a = default(StateCluster);
-		TreeToNFAConverter.set_return set1 = default(TreeToNFAConverter.set_return);
-
-
-			List<StateCluster> alts = new List<StateCluster>();
-			this.blockLevel++;
-			if ( this.blockLevel==1 )
-				this.outerAltNum=1;
-
-		try
-		{
-			// Grammars\\TreeToNFAConverter.g3:193:4: ({...}? => set | ^( BLOCK ( ^( OPTIONS ( . )* ) )? (a= alternative rewrite )+ EOB ) )
-			int alt33=2;
-			int LA33_0 = input.LA(1);
-
-			if ( (LA33_0==BLOCK) )
-			{
-				int LA33_1 = input.LA(2);
-
-				if ( ((grammar.IsValidSet(this,((GrammarAST)retval.Start)) &&
-						 !currentRuleName.Equals(Grammar.ArtificialTokensRuleName))) )
-				{
-					alt33=1;
-				}
-				else if ( (true) )
-				{
-					alt33=2;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 33, 1, input);
-
-					throw nvae;
-				}
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return retval;}
-				NoViableAltException nvae = new NoViableAltException("", 33, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt33 )
-			{
-			case 1:
-				// Grammars\\TreeToNFAConverter.g3:193:4: {...}? => set
-				{
-				if ( !((grammar.IsValidSet(this,((GrammarAST)retval.Start)) &&
-						 !currentRuleName.Equals(Grammar.ArtificialTokensRuleName))) )
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					throw new FailedPredicateException(input, "block", "grammar.IsValidSet(this,$start) &&\r\n\t\t !currentRuleName.Equals(Grammar.ArtificialTokensRuleName)");
-				}
-				PushFollow(Follow._set_in_block480);
-				set1=set();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					retval.g = (set1!=null?set1.g:default(StateCluster));
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\TreeToNFAConverter.g3:197:4: ^( BLOCK ( ^( OPTIONS ( . )* ) )? (a= alternative rewrite )+ EOB )
-				{
-				Match(input,BLOCK,Follow._BLOCK_in_block490); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				// Grammars\\TreeToNFAConverter.g3:197:13: ( ^( OPTIONS ( . )* ) )?
-				int alt31=2;
-				int LA31_0 = input.LA(1);
-
-				if ( (LA31_0==OPTIONS) )
-				{
-					alt31=1;
-				}
-				switch ( alt31 )
-				{
-				case 1:
-					// Grammars\\TreeToNFAConverter.g3:197:15: ^( OPTIONS ( . )* )
-					{
-					Match(input,OPTIONS,Follow._OPTIONS_in_block495); if (state.failed) return retval;
-
-					if ( input.LA(1)==TokenTypes.Down )
-					{
-						Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-						// Grammars\\TreeToNFAConverter.g3:197:25: ( . )*
-						for ( ; ; )
-						{
-							int alt30=2;
-							int LA30_0 = input.LA(1);
-
-							if ( ((LA30_0>=ACTION && LA30_0<=XDIGIT)) )
-							{
-								alt30=1;
-							}
-							else if ( (LA30_0==UP) )
-							{
-								alt30=2;
-							}
-
-
-							switch ( alt30 )
-							{
-							case 1:
-								// Grammars\\TreeToNFAConverter.g3:197:0: .
-								{
-								MatchAny(input); if (state.failed) return retval;
-
-								}
-								break;
-
-							default:
-								goto loop30;
-							}
-						}
-
-						loop30:
-							;
-
-
-
-						Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-					}
-
-					}
-					break;
-
-				}
-
-				// Grammars\\TreeToNFAConverter.g3:198:4: (a= alternative rewrite )+
-				int cnt32=0;
-				for ( ; ; )
-				{
-					int alt32=2;
-					int LA32_0 = input.LA(1);
-
-					if ( (LA32_0==ALT) )
-					{
-						alt32=1;
-					}
-
-
-					switch ( alt32 )
-					{
-					case 1:
-						// Grammars\\TreeToNFAConverter.g3:198:6: a= alternative rewrite
-						{
-						PushFollow(Follow._alternative_in_block511);
-						a=alternative();
-
-						state._fsp--;
-						if (state.failed) return retval;
-						PushFollow(Follow._rewrite_in_block513);
-						rewrite();
-
-						state._fsp--;
-						if (state.failed) return retval;
-						if ( state.backtracking == 0 )
-						{
-
-												alts.Add(a);
-
-						}
-
-											if ( blockLevel == 1 )
-												outerAltNum++;
-
-
-						}
-						break;
-
-					default:
-						if ( cnt32 >= 1 )
-							goto loop32;
-
-						if (state.backtracking>0) {state.failed=true; return retval;}
-						EarlyExitException eee32 = new EarlyExitException( 32, input );
-						throw eee32;
-					}
-					cnt32++;
-				}
-				loop32:
-					;
-
-
-				Match(input,EOB,Follow._EOB_in_block536); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					retval.g = factory.BuildAlternativeBlock(alts);
-				}
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-			 blockLevel--;
-		}
-		return retval;
-	}
-	// $ANTLR end "block"
-
-
-	// $ANTLR start "alternative"
-	// Grammars\\TreeToNFAConverter.g3:213:0: alternative returns [StateCluster g=null] : ^( ALT (e= element )+ EOA ) ;
-	private StateCluster alternative(  )
-	{
-		StateCluster g = null;
-
-		TreeToNFAConverter.element_return e = default(TreeToNFAConverter.element_return);
-
-		try
-		{
-			// Grammars\\TreeToNFAConverter.g3:214:4: ( ^( ALT (e= element )+ EOA ) )
-			// Grammars\\TreeToNFAConverter.g3:214:4: ^( ALT (e= element )+ EOA )
-			{
-			Match(input,ALT,Follow._ALT_in_alternative565); if (state.failed) return g;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return g;
-			// Grammars\\TreeToNFAConverter.g3:214:11: (e= element )+
-			int cnt34=0;
-			for ( ; ; )
-			{
-				int alt34=2;
-				int LA34_0 = input.LA(1);
-
-				if ( (LA34_0==ACTION||(LA34_0>=ASSIGN && LA34_0<=BLOCK)||(LA34_0>=CHAR_LITERAL && LA34_0<=CHAR_RANGE)||LA34_0==CLOSURE||LA34_0==DOT||LA34_0==EPSILON||LA34_0==FORCED_ACTION||LA34_0==GATED_SEMPRED||LA34_0==NOT||LA34_0==OPTIONAL||(LA34_0>=PLUS_ASSIGN && LA34_0<=POSITIVE_CLOSURE)||LA34_0==RANGE||LA34_0==ROOT||LA34_0==RULE_REF||LA34_0==SEMPRED||(LA34_0>=STRING_LITERAL && LA34_0<=SYNPRED)||LA34_0==TOKEN_REF||LA34_0==TREE_BEGIN||LA34_0==WILDCARD) )
-				{
-					alt34=1;
-				}
-
-
-				switch ( alt34 )
-				{
-				case 1:
-					// Grammars\\TreeToNFAConverter.g3:214:12: e= element
-					{
-					PushFollow(Follow._element_in_alternative570);
-					e=element();
-
-					state._fsp--;
-					if (state.failed) return g;
-					if ( state.backtracking == 0 )
-					{
-						g = factory.BuildAB(g,(e!=null?e.g:default(StateCluster)));
-					}
-
-					}
-					break;
-
-				default:
-					if ( cnt34 >= 1 )
-						goto loop34;
-
-					if (state.backtracking>0) {state.failed=true; return g;}
-					EarlyExitException eee34 = new EarlyExitException( 34, input );
-					throw eee34;
-				}
-				cnt34++;
-			}
-			loop34:
-				;
-
-
-			Match(input,EOA,Follow._EOA_in_alternative577); if (state.failed) return g;
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return g;
-			if ( state.backtracking == 0 )
-			{
-
-							if (g==null) { // if alt was a list of actions or whatever
-								g = factory.BuildEpsilon();
-							}
-							else {
-								factory.OptimizeAlternative(g);
-							}
-
-			}
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return g;
-	}
-	// $ANTLR end "alternative"
-
-
-	// $ANTLR start "exceptionGroup"
-	// Grammars\\TreeToNFAConverter.g3:225:0: exceptionGroup : ( ( exceptionHandler )+ ( finallyClause )? | finallyClause );
-	private void exceptionGroup(  )
-	{
-		try
-		{
-			// Grammars\\TreeToNFAConverter.g3:226:4: ( ( exceptionHandler )+ ( finallyClause )? | finallyClause )
-			int alt37=2;
-			int LA37_0 = input.LA(1);
-
-			if ( (LA37_0==CATCH) )
-			{
-				alt37=1;
-			}
-			else if ( (LA37_0==FINALLY) )
-			{
-				alt37=2;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				NoViableAltException nvae = new NoViableAltException("", 37, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt37 )
-			{
-			case 1:
-				// Grammars\\TreeToNFAConverter.g3:226:4: ( exceptionHandler )+ ( finallyClause )?
-				{
-				// Grammars\\TreeToNFAConverter.g3:226:4: ( exceptionHandler )+
-				int cnt35=0;
-				for ( ; ; )
-				{
-					int alt35=2;
-					int LA35_0 = input.LA(1);
-
-					if ( (LA35_0==CATCH) )
-					{
-						alt35=1;
-					}
-
-
-					switch ( alt35 )
-					{
-					case 1:
-						// Grammars\\TreeToNFAConverter.g3:226:6: exceptionHandler
-						{
-						PushFollow(Follow._exceptionHandler_in_exceptionGroup596);
-						exceptionHandler();
-
-						state._fsp--;
-						if (state.failed) return ;
-
-						}
-						break;
-
-					default:
-						if ( cnt35 >= 1 )
-							goto loop35;
-
-						if (state.backtracking>0) {state.failed=true; return ;}
-						EarlyExitException eee35 = new EarlyExitException( 35, input );
-						throw eee35;
-					}
-					cnt35++;
-				}
-				loop35:
-					;
-
-
-				// Grammars\\TreeToNFAConverter.g3:226:26: ( finallyClause )?
-				int alt36=2;
-				int LA36_0 = input.LA(1);
-
-				if ( (LA36_0==FINALLY) )
-				{
-					alt36=1;
-				}
-				switch ( alt36 )
-				{
-				case 1:
-					// Grammars\\TreeToNFAConverter.g3:226:27: finallyClause
-					{
-					PushFollow(Follow._finallyClause_in_exceptionGroup602);
-					finallyClause();
-
-					state._fsp--;
-					if (state.failed) return ;
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-			case 2:
-				// Grammars\\TreeToNFAConverter.g3:227:4: finallyClause
-				{
-				PushFollow(Follow._finallyClause_in_exceptionGroup609);
-				finallyClause();
-
-				state._fsp--;
-				if (state.failed) return ;
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "exceptionGroup"
-
-
-	// $ANTLR start "exceptionHandler"
-	// Grammars\\TreeToNFAConverter.g3:230:0: exceptionHandler : ^( 'catch' ARG_ACTION ACTION ) ;
-	private void exceptionHandler(  )
-	{
-		try
-		{
-			// Grammars\\TreeToNFAConverter.g3:231:7: ( ^( 'catch' ARG_ACTION ACTION ) )
-			// Grammars\\TreeToNFAConverter.g3:231:7: ^( 'catch' ARG_ACTION ACTION )
-			{
-			Match(input,CATCH,Follow._CATCH_in_exceptionHandler624); if (state.failed) return ;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return ;
-			Match(input,ARG_ACTION,Follow._ARG_ACTION_in_exceptionHandler626); if (state.failed) return ;
-			Match(input,ACTION,Follow._ACTION_in_exceptionHandler628); if (state.failed) return ;
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "exceptionHandler"
-
-
-	// $ANTLR start "finallyClause"
-	// Grammars\\TreeToNFAConverter.g3:234:0: finallyClause : ^( 'finally' ACTION ) ;
-	private void finallyClause(  )
-	{
-		try
-		{
-			// Grammars\\TreeToNFAConverter.g3:235:7: ( ^( 'finally' ACTION ) )
-			// Grammars\\TreeToNFAConverter.g3:235:7: ^( 'finally' ACTION )
-			{
-			Match(input,FINALLY,Follow._FINALLY_in_finallyClause644); if (state.failed) return ;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return ;
-			Match(input,ACTION,Follow._ACTION_in_finallyClause646); if (state.failed) return ;
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "finallyClause"
-
-	public class rewrite_return : TreeRuleReturnScope
-	{
-	}
-
-	// $ANTLR start "rewrite"
-	// Grammars\\TreeToNFAConverter.g3:238:0: rewrite : ( ^( REWRITE ( . )* ) )* ;
-	private TreeToNFAConverter.rewrite_return rewrite(  )
-	{
-		TreeToNFAConverter.rewrite_return retval = new TreeToNFAConverter.rewrite_return();
-		retval.start = input.LT(1);
-
-		try
-		{
-			// Grammars\\TreeToNFAConverter.g3:239:4: ( ( ^( REWRITE ( . )* ) )* )
-			// Grammars\\TreeToNFAConverter.g3:239:4: ( ^( REWRITE ( . )* ) )*
-			{
-			// Grammars\\TreeToNFAConverter.g3:239:4: ( ^( REWRITE ( . )* ) )*
-			for ( ; ; )
-			{
-				int alt39=2;
-				int LA39_0 = input.LA(1);
-
-				if ( (LA39_0==REWRITE) )
-				{
-					alt39=1;
-				}
-
-
-				switch ( alt39 )
-				{
-				case 1:
-					// Grammars\\TreeToNFAConverter.g3:240:4: ^( REWRITE ( . )* )
-					{
-					if ( state.backtracking == 0 )
-					{
-
-										if ( grammar.GetOption("output")==null )
-										{
-											ErrorManager.GrammarError(ErrorManager.MSG_REWRITE_OR_OP_WITH_NO_OUTPUT_OPTION,
-																	  grammar, ((GrammarAST)retval.Start).Token, currentRuleName);
-										}
-
-					}
-					Match(input,REWRITE,Follow._REWRITE_in_rewrite669); if (state.failed) return retval;
-
-					if ( input.LA(1)==TokenTypes.Down )
-					{
-						Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-						// Grammars\\TreeToNFAConverter.g3:247:14: ( . )*
-						for ( ; ; )
-						{
-							int alt38=2;
-							int LA38_0 = input.LA(1);
-
-							if ( ((LA38_0>=ACTION && LA38_0<=XDIGIT)) )
-							{
-								alt38=1;
-							}
-							else if ( (LA38_0==UP) )
-							{
-								alt38=2;
-							}
-
-
-							switch ( alt38 )
-							{
-							case 1:
-								// Grammars\\TreeToNFAConverter.g3:247:0: .
-								{
-								MatchAny(input); if (state.failed) return retval;
-
-								}
-								break;
-
-							default:
-								goto loop38;
-							}
-						}
-
-						loop38:
-							;
-
-
-
-						Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-					}
-
-					}
-					break;
-
-				default:
-					goto loop39;
-				}
-			}
-
-			loop39:
-				;
-
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "rewrite"
-
-	public class element_return : TreeRuleReturnScope
-	{
-		public StateCluster g=null;
-	}
-
-	// $ANTLR start "element"
-	// Grammars\\TreeToNFAConverter.g3:251:0: element returns [StateCluster g=null] : ( ^( ROOT e= element ) | ^( BANG e= element ) | ^( ASSIGN ID e= element ) | ^( PLUS_ASSIGN ID e= element ) | ^( RANGE a= atom[null] b= atom[null] ) | ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL ) | atom_or_notatom | ebnf | tree_ | ^( SYNPRED block ) | ACTION | FORCED_ACTION |pred= SEMPRED |spred= SYN_SEMPRED | ^(bpred= BACKTRACK_SEMPRED ( . )* ) |gpred= GATED_SEMPRED | EPSILON );
-	private TreeToNFAConverter.element_return element(  )
-	{
-		TreeToNFAConverter.element_return retval = new TreeToNFAConverter.element_return();
-		retval.start = input.LT(1);
-
-		GrammarAST c1=null;
-		GrammarAST c2=null;
-		GrammarAST pred=null;
-		GrammarAST spred=null;
-		GrammarAST bpred=null;
-		GrammarAST gpred=null;
-		GrammarAST ACTION5=null;
-		GrammarAST FORCED_ACTION6=null;
-		TreeToNFAConverter.element_return e = default(TreeToNFAConverter.element_return);
-		TreeToNFAConverter.atom_return a = default(TreeToNFAConverter.atom_return);
-		TreeToNFAConverter.atom_return b = default(TreeToNFAConverter.atom_return);
-		StateCluster atom_or_notatom2 = default(StateCluster);
-		TreeToNFAConverter.ebnf_return ebnf3 = default(TreeToNFAConverter.ebnf_return);
-		TreeToNFAConverter.tree__return tree_4 = default(TreeToNFAConverter.tree__return);
-
-		try
-		{
-			// Grammars\\TreeToNFAConverter.g3:252:6: ( ^( ROOT e= element ) | ^( BANG e= element ) | ^( ASSIGN ID e= element ) | ^( PLUS_ASSIGN ID e= element ) | ^( RANGE a= atom[null] b= atom[null] ) | ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL ) | atom_or_notatom | ebnf | tree_ | ^( SYNPRED block ) | ACTION | FORCED_ACTION |pred= SEMPRED |spred= SYN_SEMPRED | ^(bpred= BACKTRACK_SEMPRED ( . )* ) |gpred= GATED_SEMPRED | EPSILON )
-			int alt41=17;
-			alt41 = dfa41.Predict(input);
-			switch ( alt41 )
-			{
-			case 1:
-				// Grammars\\TreeToNFAConverter.g3:252:6: ^( ROOT e= element )
-				{
-				Match(input,ROOT,Follow._ROOT_in_element696); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				PushFollow(Follow._element_in_element700);
-				e=element();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					retval.g = (e!=null?e.g:default(StateCluster));
-				}
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-
-				}
-				break;
-			case 2:
-				// Grammars\\TreeToNFAConverter.g3:253:6: ^( BANG e= element )
-				{
-				Match(input,BANG,Follow._BANG_in_element711); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				PushFollow(Follow._element_in_element715);
-				e=element();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					retval.g = (e!=null?e.g:default(StateCluster));
-				}
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-
-				}
-				break;
-			case 3:
-				// Grammars\\TreeToNFAConverter.g3:254:4: ^( ASSIGN ID e= element )
-				{
-				Match(input,ASSIGN,Follow._ASSIGN_in_element724); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				Match(input,ID,Follow._ID_in_element726); if (state.failed) return retval;
-				PushFollow(Follow._element_in_element730);
-				e=element();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					retval.g = (e!=null?e.g:default(StateCluster));
-				}
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-
-				}
-				break;
-			case 4:
-				// Grammars\\TreeToNFAConverter.g3:255:4: ^( PLUS_ASSIGN ID e= element )
-				{
-				Match(input,PLUS_ASSIGN,Follow._PLUS_ASSIGN_in_element739); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				Match(input,ID,Follow._ID_in_element741); if (state.failed) return retval;
-				PushFollow(Follow._element_in_element745);
-				e=element();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					retval.g = (e!=null?e.g:default(StateCluster));
-				}
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-
-				}
-				break;
-			case 5:
-				// Grammars\\TreeToNFAConverter.g3:256:6: ^( RANGE a= atom[null] b= atom[null] )
-				{
-				Match(input,RANGE,Follow._RANGE_in_element756); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				PushFollow(Follow._atom_in_element760);
-				a=atom(null);
-
-				state._fsp--;
-				if (state.failed) return retval;
-				PushFollow(Follow._atom_in_element765);
-				b=atom(null);
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					retval.g = factory.BuildRange(grammar.GetTokenType((a!=null?(input.TokenStream.ToString(
-					  input.TreeAdaptor.GetTokenStartIndex(a.Start),
-					  input.TreeAdaptor.GetTokenStopIndex(a.Start))):null)),
-													 grammar.GetTokenType((b!=null?(input.TokenStream.ToString(
-					  input.TreeAdaptor.GetTokenStartIndex(b.Start),
-					  input.TreeAdaptor.GetTokenStopIndex(b.Start))):null)));
-				}
-
-				}
-				break;
-			case 6:
-				// Grammars\\TreeToNFAConverter.g3:259:6: ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL )
-				{
-				Match(input,CHAR_RANGE,Follow._CHAR_RANGE_in_element779); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				c1=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_element783); if (state.failed) return retval;
-				c2=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_element787); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-
-							if ( grammar.type==GrammarType.Lexer ) {
-								retval.g = factory.BuildCharRange((c1!=null?c1.Text:null), (c2!=null?c2.Text:null));
-							}
-
-				}
-
-				}
-				break;
-			case 7:
-				// Grammars\\TreeToNFAConverter.g3:265:6: atom_or_notatom
-				{
-				PushFollow(Follow._atom_or_notatom_in_element799);
-				atom_or_notatom2=atom_or_notatom();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					retval.g = atom_or_notatom2;
-				}
-
-				}
-				break;
-			case 8:
-				// Grammars\\TreeToNFAConverter.g3:266:6: ebnf
-				{
-				PushFollow(Follow._ebnf_in_element808);
-				ebnf3=ebnf();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					retval.g = (ebnf3!=null?ebnf3.g:default(StateCluster));
-				}
-
-				}
-				break;
-			case 9:
-				// Grammars\\TreeToNFAConverter.g3:267:6: tree_
-				{
-				PushFollow(Follow._tree__in_element817);
-				tree_4=tree_();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					retval.g = (tree_4!=null?tree_4.g:default(StateCluster));
-				}
-
-				}
-				break;
-			case 10:
-				// Grammars\\TreeToNFAConverter.g3:268:6: ^( SYNPRED block )
-				{
-				Match(input,SYNPRED,Follow._SYNPRED_in_element828); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				PushFollow(Follow._block_in_element830);
-				block();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-
-				}
-				break;
-			case 11:
-				// Grammars\\TreeToNFAConverter.g3:269:6: ACTION
-				{
-				ACTION5=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_element839); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					retval.g = factory.BuildAction(ACTION5);
-				}
-
-				}
-				break;
-			case 12:
-				// Grammars\\TreeToNFAConverter.g3:270:6: FORCED_ACTION
-				{
-				FORCED_ACTION6=(GrammarAST)Match(input,FORCED_ACTION,Follow._FORCED_ACTION_in_element848); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					retval.g = factory.BuildAction(FORCED_ACTION6);
-				}
-
-				}
-				break;
-			case 13:
-				// Grammars\\TreeToNFAConverter.g3:271:6: pred= SEMPRED
-				{
-				pred=(GrammarAST)Match(input,SEMPRED,Follow._SEMPRED_in_element859); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					retval.g = factory.BuildSemanticPredicate(pred);
-				}
-
-				}
-				break;
-			case 14:
-				// Grammars\\TreeToNFAConverter.g3:272:6: spred= SYN_SEMPRED
-				{
-				spred=(GrammarAST)Match(input,SYN_SEMPRED,Follow._SYN_SEMPRED_in_element870); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					retval.g = factory.BuildSemanticPredicate(spred);
-				}
-
-				}
-				break;
-			case 15:
-				// Grammars\\TreeToNFAConverter.g3:273:6: ^(bpred= BACKTRACK_SEMPRED ( . )* )
-				{
-				bpred=(GrammarAST)Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_element882); if (state.failed) return retval;
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-					// Grammars\\TreeToNFAConverter.g3:273:32: ( . )*
-					for ( ; ; )
-					{
-						int alt40=2;
-						int LA40_0 = input.LA(1);
-
-						if ( ((LA40_0>=ACTION && LA40_0<=XDIGIT)) )
-						{
-							alt40=1;
-						}
-						else if ( (LA40_0==UP) )
-						{
-							alt40=2;
-						}
-
-
-						switch ( alt40 )
-						{
-						case 1:
-							// Grammars\\TreeToNFAConverter.g3:273:0: .
-							{
-							MatchAny(input); if (state.failed) return retval;
-
-							}
-							break;
-
-						default:
-							goto loop40;
-						}
-					}
-
-					loop40:
-						;
-
-
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				}
-				if ( state.backtracking == 0 )
-				{
-					retval.g = factory.BuildSemanticPredicate(bpred);
-				}
-
-				}
-				break;
-			case 16:
-				// Grammars\\TreeToNFAConverter.g3:274:6: gpred= GATED_SEMPRED
-				{
-				gpred=(GrammarAST)Match(input,GATED_SEMPRED,Follow._GATED_SEMPRED_in_element897); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					retval.g = factory.BuildSemanticPredicate(gpred);
-				}
-
-				}
-				break;
-			case 17:
-				// Grammars\\TreeToNFAConverter.g3:275:6: EPSILON
-				{
-				Match(input,EPSILON,Follow._EPSILON_in_element906); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					retval.g = factory.BuildEpsilon();
-				}
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "element"
-
-	public class ebnf_return : TreeRuleReturnScope
-	{
-		public StateCluster g=null;
-	}
-
-	// $ANTLR start "ebnf"
-	// Grammars\\TreeToNFAConverter.g3:278:0: ebnf returns [StateCluster g=null] : ({...}? => set |b= block | ^( OPTIONAL b= block ) | ^( CLOSURE b= block ) | ^( POSITIVE_CLOSURE b= block ) );
-	private TreeToNFAConverter.ebnf_return ebnf(  )
-	{
-		TreeToNFAConverter.ebnf_return retval = new TreeToNFAConverter.ebnf_return();
-		retval.start = input.LT(1);
-
-		TreeToNFAConverter.block_return b = default(TreeToNFAConverter.block_return);
-		TreeToNFAConverter.set_return set7 = default(TreeToNFAConverter.set_return);
-
-
-			GrammarAST blk = ((GrammarAST)retval.Start);
-			if ( blk.Type!=BLOCK ) {
-				blk = (GrammarAST)blk.GetChild(0);
-			}
-			GrammarAST eob = blk.LastChild;
-
-		try
-		{
-			// Grammars\\TreeToNFAConverter.g3:287:4: ({...}? => set |b= block | ^( OPTIONAL b= block ) | ^( CLOSURE b= block ) | ^( POSITIVE_CLOSURE b= block ) )
-			int alt42=5;
-			switch ( input.LA(1) )
-			{
-			case BLOCK:
-				{
-				int LA42_1 = input.LA(2);
-
-				if ( ((grammar.IsValidSet(this,((GrammarAST)retval.Start)))) )
-				{
-					alt42=1;
-				}
-				else if ( (true) )
-				{
-					alt42=2;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 42, 1, input);
-
-					throw nvae;
-				}
-				}
-				break;
-			case OPTIONAL:
-				{
-				alt42=3;
-				}
-				break;
-			case CLOSURE:
-				{
-				alt42=4;
-				}
-				break;
-			case POSITIVE_CLOSURE:
-				{
-				alt42=5;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 42, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt42 )
-			{
-			case 1:
-				// Grammars\\TreeToNFAConverter.g3:287:4: {...}? => set
-				{
-				if ( !((grammar.IsValidSet(this,((GrammarAST)retval.Start)))) )
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					throw new FailedPredicateException(input, "ebnf", "grammar.IsValidSet(this,$start)");
-				}
-				PushFollow(Follow._set_in_ebnf932);
-				set7=set();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					retval.g = (set7!=null?set7.g:default(StateCluster));
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\TreeToNFAConverter.g3:289:4: b= block
-				{
-				PushFollow(Follow._block_in_ebnf942);
-				b=block();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-
-								// track decision if > 1 alts
-								if ( grammar.GetNumberOfAltsForDecisionNFA((b!=null?b.g:default(StateCluster)).left)>1 )
-								{
-									(b!=null?b.g:default(StateCluster)).left.Description = grammar.GrammarTreeToString(blk,false);
-									(b!=null?b.g:default(StateCluster)).left.SetDecisionASTNode(blk);
-									int d = grammar.AssignDecisionNumber( (b!=null?b.g:default(StateCluster)).left );
-									grammar.SetDecisionNFA( d, (b!=null?b.g:default(StateCluster)).left );
-									grammar.SetDecisionBlockAST(d, blk);
-								}
-								retval.g = (b!=null?b.g:default(StateCluster));
-
-				}
-
-				}
-				break;
-			case 3:
-				// Grammars\\TreeToNFAConverter.g3:302:4: ^( OPTIONAL b= block )
-				{
-				Match(input,OPTIONAL,Follow._OPTIONAL_in_ebnf953); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				PushFollow(Follow._block_in_ebnf957);
-				b=block();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-
-								StateCluster bg = (b!=null?b.g:default(StateCluster));
-								if ( blk.SetValue!=null )
-								{
-									// if block comes back SET not BLOCK, make it
-									// a single ALT block
-									bg = factory.BuildAlternativeBlockFromSet(bg);
-								}
-								retval.g = factory.BuildAoptional(bg);
-								retval.g.left.Description = grammar.GrammarTreeToString(((GrammarAST)retval.Start),false);
-								// there is always at least one alt even if block has just 1 alt
-								int d = grammar.AssignDecisionNumber( retval.g.left );
-								grammar.SetDecisionNFA(d, retval.g.left);
-								grammar.SetDecisionBlockAST(d, blk);
-								retval.g.left.SetDecisionASTNode(((GrammarAST)retval.Start));
-
-				}
-
-				}
-				break;
-			case 4:
-				// Grammars\\TreeToNFAConverter.g3:319:4: ^( CLOSURE b= block )
-				{
-				Match(input,CLOSURE,Follow._CLOSURE_in_ebnf970); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				PushFollow(Follow._block_in_ebnf974);
-				b=block();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-
-								StateCluster bg = (b!=null?b.g:default(StateCluster));
-								if ( blk.SetValue!=null )
-								{
-									bg = factory.BuildAlternativeBlockFromSet(bg);
-								}
-								retval.g = factory.BuildAstar(bg);
-								// track the loop back / exit decision point
-								bg.right.Description = "()* loopback of "+grammar.GrammarTreeToString(((GrammarAST)retval.Start),false);
-								int d = grammar.AssignDecisionNumber( bg.right );
-								grammar.SetDecisionNFA(d, bg.right);
-								grammar.SetDecisionBlockAST(d, blk);
-								bg.right.SetDecisionASTNode(eob);
-								// make block entry state also have same decision for interpreting grammar
-								NFAState altBlockState = (NFAState)retval.g.left.GetTransition(0).target;
-								altBlockState.SetDecisionASTNode(((GrammarAST)retval.Start));
-								altBlockState.DecisionNumber = d;
-								retval.g.left.DecisionNumber = d; // this is the bypass decision (2 alts)
-								retval.g.left.SetDecisionASTNode(((GrammarAST)retval.Start));
-
-				}
-
-				}
-				break;
-			case 5:
-				// Grammars\\TreeToNFAConverter.g3:340:4: ^( POSITIVE_CLOSURE b= block )
-				{
-				Match(input,POSITIVE_CLOSURE,Follow._POSITIVE_CLOSURE_in_ebnf987); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				PushFollow(Follow._block_in_ebnf991);
-				b=block();
-
-				state._fsp--;
-				if (state.failed) return retval;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-
-								StateCluster bg = (b!=null?b.g:default(StateCluster));
-								if ( blk.SetValue!=null )
-								{
-									bg = factory.BuildAlternativeBlockFromSet(bg);
-								}
-								retval.g = factory.BuildAplus(bg);
-								// don't make a decision on left edge, can reuse loop end decision
-								// track the loop back / exit decision point
-								bg.right.Description = "()+ loopback of "+grammar.GrammarTreeToString(((GrammarAST)retval.Start),false);
-								int d = grammar.AssignDecisionNumber( bg.right );
-								grammar.SetDecisionNFA(d, bg.right);
-								grammar.SetDecisionBlockAST(d, blk);
-								bg.right.SetDecisionASTNode(eob);
-								// make block entry state also have same decision for interpreting grammar
-								NFAState altBlockState = (NFAState)retval.g.left.GetTransition(0).target;
-								altBlockState.SetDecisionASTNode(((GrammarAST)retval.Start));
-								altBlockState.DecisionNumber = d;
-
-				}
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "ebnf"
-
-	public class tree__return : TreeRuleReturnScope
-	{
-		public StateCluster g=null;
-	}
-
-	// $ANTLR start "tree_"
-	// Grammars\\TreeToNFAConverter.g3:362:0: tree_ returns [StateCluster g=null] : ^( TREE_BEGIN e= element (e= element )* ) ;
-	private TreeToNFAConverter.tree__return tree_(  )
-	{
-		TreeToNFAConverter.tree__return retval = new TreeToNFAConverter.tree__return();
-		retval.start = input.LT(1);
-
-		TreeToNFAConverter.element_return e = default(TreeToNFAConverter.element_return);
-
-
-			StateCluster down=null, up=null;
-
-		try
-		{
-			// Grammars\\TreeToNFAConverter.g3:367:4: ( ^( TREE_BEGIN e= element (e= element )* ) )
-			// Grammars\\TreeToNFAConverter.g3:367:4: ^( TREE_BEGIN e= element (e= element )* )
-			{
-			Match(input,TREE_BEGIN,Follow._TREE_BEGIN_in_tree_1019); if (state.failed) return retval;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-			PushFollow(Follow._element_in_tree_1026);
-			e=element();
-
-			state._fsp--;
-			if (state.failed) return retval;
-			if ( state.backtracking == 0 )
-			{
-				 retval.g = (e!=null?e.g:default(StateCluster));
-			}
-			if ( state.backtracking == 0 )
-			{
-
-								down = factory.BuildAtom(Label.DOWN, (e!=null?((GrammarAST)e.Start):null));
-								// TODO set following states for imaginary nodes?
-								//el.followingNFAState = down.right;
-								retval.g = factory.BuildAB(retval.g,down);
-
-			}
-			// Grammars\\TreeToNFAConverter.g3:375:4: (e= element )*
-			for ( ; ; )
-			{
-				int alt43=2;
-				int LA43_0 = input.LA(1);
-
-				if ( (LA43_0==ACTION||(LA43_0>=ASSIGN && LA43_0<=BLOCK)||(LA43_0>=CHAR_LITERAL && LA43_0<=CHAR_RANGE)||LA43_0==CLOSURE||LA43_0==DOT||LA43_0==EPSILON||LA43_0==FORCED_ACTION||LA43_0==GATED_SEMPRED||LA43_0==NOT||LA43_0==OPTIONAL||(LA43_0>=PLUS_ASSIGN && LA43_0<=POSITIVE_CLOSURE)||LA43_0==RANGE||LA43_0==ROOT||LA43_0==RULE_REF||LA43_0==SEMPRED||(LA43_0>=STRING_LITERAL && LA43_0<=SYNPRED)||LA43_0==TOKEN_REF||LA43_0==TREE_BEGIN||LA43_0==WILDCARD) )
-				{
-					alt43=1;
-				}
-
-
-				switch ( alt43 )
-				{
-				case 1:
-					// Grammars\\TreeToNFAConverter.g3:375:6: e= element
-					{
-					PushFollow(Follow._element_in_tree_1042);
-					e=element();
-
-					state._fsp--;
-					if (state.failed) return retval;
-					if ( state.backtracking == 0 )
-					{
-						retval.g = factory.BuildAB(retval.g,(e!=null?e.g:default(StateCluster)));
-					}
-
-					}
-					break;
-
-				default:
-					goto loop43;
-				}
-			}
-
-			loop43:
-				;
-
-
-			if ( state.backtracking == 0 )
-			{
-
-								up = factory.BuildAtom(Label.UP, (e!=null?((GrammarAST)e.Start):null));
-								//el.followingNFAState = up.right;
-								retval.g = factory.BuildAB(retval.g,up);
-								// tree roots point at right edge of DOWN for LOOK computation later
-								((GrammarAST)retval.Start).NFATreeDownState = down.left;
-
-			}
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "tree_"
-
-
-	// $ANTLR start "atom_or_notatom"
-	// Grammars\\TreeToNFAConverter.g3:386:0: atom_or_notatom returns [StateCluster g=null] : ( atom[null] | ^(n= NOT (c= CHAR_LITERAL (ast1= ast_suffix )? |t= TOKEN_REF (ast3= ast_suffix )? | set ) ) );
-	private StateCluster atom_or_notatom(  )
-	{
-		StateCluster g = null;
-
-		GrammarAST n=null;
-		GrammarAST c=null;
-		GrammarAST t=null;
-		TreeToNFAConverter.set_return set9 = default(TreeToNFAConverter.set_return);
-		TreeToNFAConverter.atom_return atom8 = default(TreeToNFAConverter.atom_return);
-
-		try
-		{
-			// Grammars\\TreeToNFAConverter.g3:387:4: ( atom[null] | ^(n= NOT (c= CHAR_LITERAL (ast1= ast_suffix )? |t= TOKEN_REF (ast3= ast_suffix )? | set ) ) )
-			int alt47=2;
-			int LA47_0 = input.LA(1);
-
-			if ( (LA47_0==CHAR_LITERAL||LA47_0==DOT||LA47_0==RULE_REF||LA47_0==STRING_LITERAL||LA47_0==TOKEN_REF||LA47_0==WILDCARD) )
-			{
-				alt47=1;
-			}
-			else if ( (LA47_0==NOT) )
-			{
-				alt47=2;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return g;}
-				NoViableAltException nvae = new NoViableAltException("", 47, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt47 )
-			{
-			case 1:
-				// Grammars\\TreeToNFAConverter.g3:387:4: atom[null]
-				{
-				PushFollow(Follow._atom_in_atom_or_notatom1071);
-				atom8=atom(null);
-
-				state._fsp--;
-				if (state.failed) return g;
-				if ( state.backtracking == 0 )
-				{
-					g = (atom8!=null?atom8.g:default(StateCluster));
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\TreeToNFAConverter.g3:388:4: ^(n= NOT (c= CHAR_LITERAL (ast1= ast_suffix )? |t= TOKEN_REF (ast3= ast_suffix )? | set ) )
-				{
-				n=(GrammarAST)Match(input,NOT,Follow._NOT_in_atom_or_notatom1083); if (state.failed) return g;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return g;
-				// Grammars\\TreeToNFAConverter.g3:389:4: (c= CHAR_LITERAL (ast1= ast_suffix )? |t= TOKEN_REF (ast3= ast_suffix )? | set )
-				int alt46=3;
-				switch ( input.LA(1) )
-				{
-				case CHAR_LITERAL:
-					{
-					alt46=1;
-					}
-					break;
-				case TOKEN_REF:
-					{
-					alt46=2;
-					}
-					break;
-				case BLOCK:
-					{
-					alt46=3;
-					}
-					break;
-				default:
-					{
-						if (state.backtracking>0) {state.failed=true; return g;}
-						NoViableAltException nvae = new NoViableAltException("", 46, 0, input);
-
-						throw nvae;
-					}
-				}
-
-				switch ( alt46 )
-				{
-				case 1:
-					// Grammars\\TreeToNFAConverter.g3:389:6: c= CHAR_LITERAL (ast1= ast_suffix )?
-					{
-					c=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_atom_or_notatom1092); if (state.failed) return g;
-					// Grammars\\TreeToNFAConverter.g3:389:21: (ast1= ast_suffix )?
-					int alt44=2;
-					int LA44_0 = input.LA(1);
-
-					if ( (LA44_0==BANG||LA44_0==ROOT) )
-					{
-						alt44=1;
-					}
-					switch ( alt44 )
-					{
-					case 1:
-						// Grammars\\TreeToNFAConverter.g3:389:22: ast1= ast_suffix
-						{
-						PushFollow(Follow._ast_suffix_in_atom_or_notatom1097);
-						ast_suffix();
-
-						state._fsp--;
-						if (state.failed) return g;
-
-						}
-						break;
-
-					}
-
-					if ( state.backtracking == 0 )
-					{
-
-											int ttype=0;
-											if ( grammar.type==GrammarType.Lexer )
-											{
-												ttype = Grammar.GetCharValueFromGrammarCharLiteral((c!=null?c.Text:null));
-											}
-											else
-											{
-												ttype = grammar.GetTokenType((c!=null?c.Text:null));
-											}
-											IIntSet notAtom = grammar.Complement(ttype);
-											if ( notAtom.IsNil )
-											{
-												ErrorManager.GrammarError(
-													ErrorManager.MSG_EMPTY_COMPLEMENT,
-													grammar,
-													c.Token,
-													(c!=null?c.Text:null));
-											}
-											g =factory.BuildSet(notAtom,n);
-
-					}
-
-					}
-					break;
-				case 2:
-					// Grammars\\TreeToNFAConverter.g3:411:6: t= TOKEN_REF (ast3= ast_suffix )?
-					{
-					t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_atom_or_notatom1114); if (state.failed) return g;
-					// Grammars\\TreeToNFAConverter.g3:411:18: (ast3= ast_suffix )?
-					int alt45=2;
-					int LA45_0 = input.LA(1);
-
-					if ( (LA45_0==BANG||LA45_0==ROOT) )
-					{
-						alt45=1;
-					}
-					switch ( alt45 )
-					{
-					case 1:
-						// Grammars\\TreeToNFAConverter.g3:411:19: ast3= ast_suffix
-						{
-						PushFollow(Follow._ast_suffix_in_atom_or_notatom1119);
-						ast_suffix();
-
-						state._fsp--;
-						if (state.failed) return g;
-
-						}
-						break;
-
-					}
-
-					if ( state.backtracking == 0 )
-					{
-
-											int ttype=0;
-											IIntSet notAtom = null;
-											if ( grammar.type==GrammarType.Lexer )
-											{
-												notAtom = grammar.GetSetFromRule(this,(t!=null?t.Text:null));
-												if ( notAtom==null )
-												{
-													ErrorManager.GrammarError(
-														ErrorManager.MSG_RULE_INVALID_SET,
-														grammar,
-														t.Token,
-														(t!=null?t.Text:null));
-												}
-												else
-												{
-													notAtom = grammar.Complement(notAtom);
-												}
-											}
-											else
-											{
-												ttype = grammar.GetTokenType((t!=null?t.Text:null));
-												notAtom = grammar.Complement(ttype);
-											}
-											if ( notAtom==null || notAtom.IsNil )
-											{
-												ErrorManager.GrammarError(
-													ErrorManager.MSG_EMPTY_COMPLEMENT,
-													grammar,
-													t.Token,
-													(t!=null?t.Text:null));
-											}
-											g =factory.BuildSet(notAtom,n);
-
-					}
-
-					}
-					break;
-				case 3:
-					// Grammars\\TreeToNFAConverter.g3:446:6: set
-					{
-					PushFollow(Follow._set_in_atom_or_notatom1134);
-					set9=set();
-
-					state._fsp--;
-					if (state.failed) return g;
-					if ( state.backtracking == 0 )
-					{
-						g = (set9!=null?set9.g:default(StateCluster));
-					}
-					if ( state.backtracking == 0 )
-					{
-
-											GrammarAST stNode = (GrammarAST)n.GetChild(0);
-											//IIntSet notSet = grammar.Complement(stNode.SetValue);
-											// let code generator complement the sets
-											IIntSet s = stNode.SetValue;
-											stNode.SetValue = s;
-											// let code gen do the complement again; here we compute
-											// for NFA construction
-											s = grammar.Complement(s);
-											if ( s.IsNil )
-											{
-												ErrorManager.GrammarError(
-													ErrorManager.MSG_EMPTY_COMPLEMENT,
-													grammar,
-													n.Token);
-											}
-											g =factory.BuildSet(s,n);
-
-					}
-
-					}
-					break;
-
-				}
-
-				if ( state.backtracking == 0 )
-				{
-					n.followingNFAState = g.right;
-				}
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return g;
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return g;
-	}
-	// $ANTLR end "atom_or_notatom"
-
-	public class atom_return : TreeRuleReturnScope
-	{
-		public StateCluster g=null;
-	}
-
-	// $ANTLR start "atom"
-	// Grammars\\TreeToNFAConverter.g3:470:0: atom[string scopeName] returns [StateCluster g=null] : ( ^(r= RULE_REF (rarg= ARG_ACTION )? (as1= ast_suffix )? ) | ^(t= TOKEN_REF (targ= ARG_ACTION )? (as2= ast_suffix )? ) | ^(c= CHAR_LITERAL (as3= ast_suffix )? ) | ^(s= STRING_LITERAL (as4= ast_suffix )? ) | ^(w= WILDCARD (as5= ast_suffix )? ) | ^( DOT scope_= ID a= atom[$scope_.text] ) );
-	private TreeToNFAConverter.atom_return atom( string scopeName )
-	{
-		TreeToNFAConverter.atom_return retval = new TreeToNFAConverter.atom_return();
-		retval.start = input.LT(1);
-
-		GrammarAST r=null;
-		GrammarAST rarg=null;
-		GrammarAST t=null;
-		GrammarAST targ=null;
-		GrammarAST c=null;
-		GrammarAST s=null;
-		GrammarAST w=null;
-		GrammarAST scope_=null;
-		TreeToNFAConverter.atom_return a = default(TreeToNFAConverter.atom_return);
-
-		try
-		{
-			// Grammars\\TreeToNFAConverter.g3:471:4: ( ^(r= RULE_REF (rarg= ARG_ACTION )? (as1= ast_suffix )? ) | ^(t= TOKEN_REF (targ= ARG_ACTION )? (as2= ast_suffix )? ) | ^(c= CHAR_LITERAL (as3= ast_suffix )? ) | ^(s= STRING_LITERAL (as4= ast_suffix )? ) | ^(w= WILDCARD (as5= ast_suffix )? ) | ^( DOT scope_= ID a= atom[$scope_.text] ) )
-			int alt55=6;
-			switch ( input.LA(1) )
-			{
-			case RULE_REF:
-				{
-				alt55=1;
-				}
-				break;
-			case TOKEN_REF:
-				{
-				alt55=2;
-				}
-				break;
-			case CHAR_LITERAL:
-				{
-				alt55=3;
-				}
-				break;
-			case STRING_LITERAL:
-				{
-				alt55=4;
-				}
-				break;
-			case WILDCARD:
-				{
-				alt55=5;
-				}
-				break;
-			case DOT:
-				{
-				alt55=6;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					NoViableAltException nvae = new NoViableAltException("", 55, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt55 )
-			{
-			case 1:
-				// Grammars\\TreeToNFAConverter.g3:471:4: ^(r= RULE_REF (rarg= ARG_ACTION )? (as1= ast_suffix )? )
-				{
-				r=(GrammarAST)Match(input,RULE_REF,Follow._RULE_REF_in_atom1176); if (state.failed) return retval;
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-					// Grammars\\TreeToNFAConverter.g3:471:18: (rarg= ARG_ACTION )?
-					int alt48=2;
-					int LA48_0 = input.LA(1);
-
-					if ( (LA48_0==ARG_ACTION) )
-					{
-						alt48=1;
-					}
-					switch ( alt48 )
-					{
-					case 1:
-						// Grammars\\TreeToNFAConverter.g3:471:19: rarg= ARG_ACTION
-						{
-						rarg=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1181); if (state.failed) return retval;
-
-						}
-						break;
-
-					}
-
-					// Grammars\\TreeToNFAConverter.g3:471:37: (as1= ast_suffix )?
-					int alt49=2;
-					int LA49_0 = input.LA(1);
-
-					if ( (LA49_0==BANG||LA49_0==ROOT) )
-					{
-						alt49=1;
-					}
-					switch ( alt49 )
-					{
-					case 1:
-						// Grammars\\TreeToNFAConverter.g3:471:38: as1= ast_suffix
-						{
-						PushFollow(Follow._ast_suffix_in_atom1188);
-						ast_suffix();
-
-						state._fsp--;
-						if (state.failed) return retval;
-
-						}
-						break;
-
-					}
-
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				}
-				if ( state.backtracking == 0 )
-				{
-
-								NFAState start = grammar.GetRuleStartState(scopeName,(r!=null?r.Text:null));
-								if ( start!=null )
-								{
-									Rule rr = grammar.GetRule(scopeName,(r!=null?r.Text:null));
-									retval.g = factory.BuildRuleRef(rr, start);
-									r.followingNFAState = retval.g.right;
-									r._nfaStartState = retval.g.left;
-									if ( retval.g.left.GetTransition(0) is RuleClosureTransition
-										&& grammar.type!=GrammarType.Lexer )
-									{
-										AddFollowTransition((r!=null?r.Text:null), retval.g.right);
-									}
-									// else rule ref got inlined to a set
-								}
-
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\TreeToNFAConverter.g3:489:4: ^(t= TOKEN_REF (targ= ARG_ACTION )? (as2= ast_suffix )? )
-				{
-				t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_atom1206); if (state.failed) return retval;
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-					// Grammars\\TreeToNFAConverter.g3:489:20: (targ= ARG_ACTION )?
-					int alt50=2;
-					int LA50_0 = input.LA(1);
-
-					if ( (LA50_0==ARG_ACTION) )
-					{
-						alt50=1;
-					}
-					switch ( alt50 )
-					{
-					case 1:
-						// Grammars\\TreeToNFAConverter.g3:489:21: targ= ARG_ACTION
-						{
-						targ=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1212); if (state.failed) return retval;
-
-						}
-						break;
-
-					}
-
-					// Grammars\\TreeToNFAConverter.g3:489:39: (as2= ast_suffix )?
-					int alt51=2;
-					int LA51_0 = input.LA(1);
-
-					if ( (LA51_0==BANG||LA51_0==ROOT) )
-					{
-						alt51=1;
-					}
-					switch ( alt51 )
-					{
-					case 1:
-						// Grammars\\TreeToNFAConverter.g3:489:40: as2= ast_suffix
-						{
-						PushFollow(Follow._ast_suffix_in_atom1219);
-						ast_suffix();
-
-						state._fsp--;
-						if (state.failed) return retval;
-
-						}
-						break;
-
-					}
-
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				}
-				if ( state.backtracking == 0 )
-				{
-
-								if ( grammar.type==GrammarType.Lexer )
-								{
-									NFAState start = grammar.GetRuleStartState(scopeName,(t!=null?t.Text:null));
-									if ( start!=null )
-									{
-										Rule rr = grammar.GetRule(scopeName,t.Text);
-										retval.g = factory.BuildRuleRef(rr, start);
-										t._nfaStartState = retval.g.left;
-										// don't add FOLLOW transitions in the lexer;
-										// only exact context should be used.
-									}
-								}
-								else
-								{
-									retval.g = factory.BuildAtom(t);
-									t.followingNFAState = retval.g.right;
-								}
-
-				}
-
-				}
-				break;
-			case 3:
-				// Grammars\\TreeToNFAConverter.g3:510:4: ^(c= CHAR_LITERAL (as3= ast_suffix )? )
-				{
-				c=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_atom1237); if (state.failed) return retval;
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-					// Grammars\\TreeToNFAConverter.g3:510:23: (as3= ast_suffix )?
-					int alt52=2;
-					int LA52_0 = input.LA(1);
-
-					if ( (LA52_0==BANG||LA52_0==ROOT) )
-					{
-						alt52=1;
-					}
-					switch ( alt52 )
-					{
-					case 1:
-						// Grammars\\TreeToNFAConverter.g3:510:24: as3= ast_suffix
-						{
-						PushFollow(Follow._ast_suffix_in_atom1243);
-						ast_suffix();
-
-						state._fsp--;
-						if (state.failed) return retval;
-
-						}
-						break;
-
-					}
-
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				}
-				if ( state.backtracking == 0 )
-				{
-
-								if ( grammar.type==GrammarType.Lexer )
-								{
-									retval.g = factory.BuildCharLiteralAtom(c);
-								}
-								else
-								{
-									retval.g = factory.BuildAtom(c);
-									c.followingNFAState = retval.g.right;
-								}
-
-				}
-
-				}
-				break;
-			case 4:
-				// Grammars\\TreeToNFAConverter.g3:523:4: ^(s= STRING_LITERAL (as4= ast_suffix )? )
-				{
-				s=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_atom1261); if (state.failed) return retval;
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-					// Grammars\\TreeToNFAConverter.g3:523:25: (as4= ast_suffix )?
-					int alt53=2;
-					int LA53_0 = input.LA(1);
-
-					if ( (LA53_0==BANG||LA53_0==ROOT) )
-					{
-						alt53=1;
-					}
-					switch ( alt53 )
-					{
-					case 1:
-						// Grammars\\TreeToNFAConverter.g3:523:26: as4= ast_suffix
-						{
-						PushFollow(Follow._ast_suffix_in_atom1267);
-						ast_suffix();
-
-						state._fsp--;
-						if (state.failed) return retval;
-
-						}
-						break;
-
-					}
-
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				}
-				if ( state.backtracking == 0 )
-				{
-
-								if ( grammar.type==GrammarType.Lexer )
-								{
-									retval.g = factory.BuildStringLiteralAtom(s);
-								}
-								else
-								{
-									retval.g = factory.BuildAtom(s);
-									s.followingNFAState = retval.g.right;
-								}
-
-				}
-
-				}
-				break;
-			case 5:
-				// Grammars\\TreeToNFAConverter.g3:536:4: ^(w= WILDCARD (as5= ast_suffix )? )
-				{
-				w=(GrammarAST)Match(input,WILDCARD,Follow._WILDCARD_in_atom1285); if (state.failed) return retval;
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-					// Grammars\\TreeToNFAConverter.g3:536:18: (as5= ast_suffix )?
-					int alt54=2;
-					int LA54_0 = input.LA(1);
-
-					if ( (LA54_0==BANG||LA54_0==ROOT) )
-					{
-						alt54=1;
-					}
-					switch ( alt54 )
-					{
-					case 1:
-						// Grammars\\TreeToNFAConverter.g3:536:19: as5= ast_suffix
-						{
-						PushFollow(Follow._ast_suffix_in_atom1290);
-						ast_suffix();
-
-						state._fsp--;
-						if (state.failed) return retval;
-
-						}
-						break;
-
-					}
-
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-				}
-				if ( state.backtracking == 0 )
-				{
-
-									if ( nfa.grammar.type == GrammarType.TreeParser
-										&& (w.ChildIndex > 0 || w.Parent.GetChild(1).Type == EOA) )
-									{
-										retval.g = factory.BuildWildcardTree( w );
-									}
-									else
-									{
-										retval.g = factory.BuildWildcard( w );
-									}
-
-				}
-
-				}
-				break;
-			case 6:
-				// Grammars\\TreeToNFAConverter.g3:549:4: ^( DOT scope_= ID a= atom[$scope_.text] )
-				{
-				Match(input,DOT,Follow._DOT_in_atom1307); if (state.failed) return retval;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-				scope_=(GrammarAST)Match(input,ID,Follow._ID_in_atom1311); if (state.failed) return retval;
-				PushFollow(Follow._atom_in_atom1315);
-				a=atom((scope_!=null?scope_.Text:null));
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 )
-				{
-					retval.g = (a!=null?a.g:default(StateCluster));
-				}
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "atom"
-
-
-	// $ANTLR start "ast_suffix"
-	// Grammars\\TreeToNFAConverter.g3:552:0: ast_suffix : ( ROOT | BANG );
-	private void ast_suffix(  )
-	{
-		try
-		{
-			// Grammars\\TreeToNFAConverter.g3:553:4: ( ROOT | BANG )
-			// Grammars\\TreeToNFAConverter.g3:
-			{
-			if ( input.LA(1)==BANG||input.LA(1)==ROOT )
-			{
-				input.Consume();
-				state.errorRecovery=false;state.failed=false;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				MismatchedSetException mse = new MismatchedSetException(null,input);
-				throw mse;
-			}
-
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "ast_suffix"
-
-	public class set_return : TreeRuleReturnScope
-	{
-		public StateCluster g=null;
-	}
-
-	// $ANTLR start "set"
-	// Grammars\\TreeToNFAConverter.g3:557:0: set returns [StateCluster g=null] : ^(b= BLOCK ( ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? setElement[elements] EOA ) )+ EOB ) ;
-	private TreeToNFAConverter.set_return set(  )
-	{
-		TreeToNFAConverter.set_return retval = new TreeToNFAConverter.set_return();
-		retval.start = input.LT(1);
-
-		GrammarAST b=null;
-
-
-			IIntSet elements=new IntervalSet();
-			if ( state.backtracking == 0 )
-				((GrammarAST)retval.Start).SetValue = elements; // track set for use by code gen
-
-		try
-		{
-			// Grammars\\TreeToNFAConverter.g3:564:4: ( ^(b= BLOCK ( ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? setElement[elements] EOA ) )+ EOB ) )
-			// Grammars\\TreeToNFAConverter.g3:564:4: ^(b= BLOCK ( ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? setElement[elements] EOA ) )+ EOB )
-			{
-			b=(GrammarAST)Match(input,BLOCK,Follow._BLOCK_in_set1361); if (state.failed) return retval;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-			// Grammars\\TreeToNFAConverter.g3:565:6: ( ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? setElement[elements] EOA ) )+
-			int cnt58=0;
-			for ( ; ; )
-			{
-				int alt58=2;
-				int LA58_0 = input.LA(1);
-
-				if ( (LA58_0==ALT) )
-				{
-					alt58=1;
-				}
-
-
-				switch ( alt58 )
-				{
-				case 1:
-					// Grammars\\TreeToNFAConverter.g3:565:7: ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? setElement[elements] EOA )
-					{
-					Match(input,ALT,Follow._ALT_in_set1370); if (state.failed) return retval;
-
-					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-					// Grammars\\TreeToNFAConverter.g3:565:13: ( ^( BACKTRACK_SEMPRED ( . )* ) )?
-					int alt57=2;
-					int LA57_0 = input.LA(1);
-
-					if ( (LA57_0==BACKTRACK_SEMPRED) )
-					{
-						alt57=1;
-					}
-					switch ( alt57 )
-					{
-					case 1:
-						// Grammars\\TreeToNFAConverter.g3:565:15: ^( BACKTRACK_SEMPRED ( . )* )
-						{
-						Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_set1375); if (state.failed) return retval;
-
-						if ( input.LA(1)==TokenTypes.Down )
-						{
-							Match(input, TokenTypes.Down, null); if (state.failed) return retval;
-							// Grammars\\TreeToNFAConverter.g3:565:35: ( . )*
-							for ( ; ; )
-							{
-								int alt56=2;
-								int LA56_0 = input.LA(1);
-
-								if ( ((LA56_0>=ACTION && LA56_0<=XDIGIT)) )
-								{
-									alt56=1;
-								}
-								else if ( (LA56_0==UP) )
-								{
-									alt56=2;
-								}
-
-
-								switch ( alt56 )
-								{
-								case 1:
-									// Grammars\\TreeToNFAConverter.g3:565:0: .
-									{
-									MatchAny(input); if (state.failed) return retval;
-
-									}
-									break;
-
-								default:
-									goto loop56;
-								}
-							}
-
-							loop56:
-								;
-
-
-
-							Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-						}
-
-						}
-						break;
-
-					}
-
-					PushFollow(Follow._setElement_in_set1384);
-					setElement(elements);
-
-					state._fsp--;
-					if (state.failed) return retval;
-					Match(input,EOA,Follow._EOA_in_set1387); if (state.failed) return retval;
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-
-					}
-					break;
-
-				default:
-					if ( cnt58 >= 1 )
-						goto loop58;
-
-					if (state.backtracking>0) {state.failed=true; return retval;}
-					EarlyExitException eee58 = new EarlyExitException( 58, input );
-					throw eee58;
-				}
-				cnt58++;
-			}
-			loop58:
-				;
-
-
-			Match(input,EOB,Follow._EOB_in_set1397); if (state.failed) return retval;
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return retval;
-			if ( state.backtracking == 0 )
-			{
-
-						retval.g = factory.BuildSet(elements,b);
-						b.followingNFAState = retval.g.right;
-						b.SetValue = elements; // track set value of this block
-
-			}
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return retval;
-	}
-	// $ANTLR end "set"
-
-
-	// $ANTLR start "setRule"
-	// Grammars\\TreeToNFAConverter.g3:576:0: setRule returns [IIntSet elements=new IntervalSet()] : ^( RULE id= ID ( modifier )? ARG RET ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ^( BLOCK ( ^( OPTIONS ( . )* ) )? ( ^( ALT ( BACKTRACK_SEMPRED )? setElement[elements] EOA ) )+ EOB ) ( exceptionGroup )? EOR ) ;
-	private IIntSet setRule(  )
-	{
-		IIntSet elements = new IntervalSet();
-
-		GrammarAST id=null;
-
-
-			IIntSet s=null;
-
-		try
-		{
-			// Grammars\\TreeToNFAConverter.g3:581:4: ( ^( RULE id= ID ( modifier )? ARG RET ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ^( BLOCK ( ^( OPTIONS ( . )* ) )? ( ^( ALT ( BACKTRACK_SEMPRED )? setElement[elements] EOA ) )+ EOB ) ( exceptionGroup )? EOR ) )
-			// Grammars\\TreeToNFAConverter.g3:581:4: ^( RULE id= ID ( modifier )? ARG RET ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ^( BLOCK ( ^( OPTIONS ( . )* ) )? ( ^( ALT ( BACKTRACK_SEMPRED )? setElement[elements] EOA ) )+ EOB ) ( exceptionGroup )? EOR )
-			{
-			Match(input,RULE,Follow._RULE_in_setRule1431); if (state.failed) return elements;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return elements;
-			id=(GrammarAST)Match(input,ID,Follow._ID_in_setRule1435); if (state.failed) return elements;
-			// Grammars\\TreeToNFAConverter.g3:581:18: ( modifier )?
-			int alt59=2;
-			int LA59_0 = input.LA(1);
-
-			if ( (LA59_0==FRAGMENT||(LA59_0>=PRIVATE && LA59_0<=PUBLIC)) )
-			{
-				alt59=1;
-			}
-			switch ( alt59 )
-			{
-			case 1:
-				// Grammars\\TreeToNFAConverter.g3:581:19: modifier
-				{
-				PushFollow(Follow._modifier_in_setRule1438);
-				modifier();
-
-				state._fsp--;
-				if (state.failed) return elements;
-
-				}
-				break;
-
-			}
-
-			Match(input,ARG,Follow._ARG_in_setRule1442); if (state.failed) return elements;
-			Match(input,RET,Follow._RET_in_setRule1444); if (state.failed) return elements;
-			// Grammars\\TreeToNFAConverter.g3:581:38: ( ^( OPTIONS ( . )* ) )?
-			int alt61=2;
-			int LA61_0 = input.LA(1);
-
-			if ( (LA61_0==OPTIONS) )
-			{
-				alt61=1;
-			}
-			switch ( alt61 )
-			{
-			case 1:
-				// Grammars\\TreeToNFAConverter.g3:581:40: ^( OPTIONS ( . )* )
-				{
-				Match(input,OPTIONS,Follow._OPTIONS_in_setRule1449); if (state.failed) return elements;
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null); if (state.failed) return elements;
-					// Grammars\\TreeToNFAConverter.g3:581:50: ( . )*
-					for ( ; ; )
-					{
-						int alt60=2;
-						int LA60_0 = input.LA(1);
-
-						if ( ((LA60_0>=ACTION && LA60_0<=XDIGIT)) )
-						{
-							alt60=1;
-						}
-						else if ( (LA60_0==UP) )
-						{
-							alt60=2;
-						}
-
-
-						switch ( alt60 )
-						{
-						case 1:
-							// Grammars\\TreeToNFAConverter.g3:581:0: .
-							{
-							MatchAny(input); if (state.failed) return elements;
-
-							}
-							break;
-
-						default:
-							goto loop60;
-						}
-					}
-
-					loop60:
-						;
-
-
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return elements;
-				}
-
-				}
-				break;
-
-			}
-
-			// Grammars\\TreeToNFAConverter.g3:581:57: ( ruleScopeSpec )?
-			int alt62=2;
-			int LA62_0 = input.LA(1);
-
-			if ( (LA62_0==SCOPE) )
-			{
-				alt62=1;
-			}
-			switch ( alt62 )
-			{
-			case 1:
-				// Grammars\\TreeToNFAConverter.g3:581:59: ruleScopeSpec
-				{
-				PushFollow(Follow._ruleScopeSpec_in_setRule1460);
-				ruleScopeSpec();
-
-				state._fsp--;
-				if (state.failed) return elements;
-
-				}
-				break;
-
-			}
-
-			// Grammars\\TreeToNFAConverter.g3:582:4: ( ^( AMPERSAND ( . )* ) )*
-			for ( ; ; )
-			{
-				int alt64=2;
-				int LA64_0 = input.LA(1);
-
-				if ( (LA64_0==AMPERSAND) )
-				{
-					alt64=1;
-				}
-
-
-				switch ( alt64 )
-				{
-				case 1:
-					// Grammars\\TreeToNFAConverter.g3:582:6: ^( AMPERSAND ( . )* )
-					{
-					Match(input,AMPERSAND,Follow._AMPERSAND_in_setRule1471); if (state.failed) return elements;
-
-					if ( input.LA(1)==TokenTypes.Down )
-					{
-						Match(input, TokenTypes.Down, null); if (state.failed) return elements;
-						// Grammars\\TreeToNFAConverter.g3:582:18: ( . )*
-						for ( ; ; )
-						{
-							int alt63=2;
-							int LA63_0 = input.LA(1);
-
-							if ( ((LA63_0>=ACTION && LA63_0<=XDIGIT)) )
-							{
-								alt63=1;
-							}
-							else if ( (LA63_0==UP) )
-							{
-								alt63=2;
-							}
-
-
-							switch ( alt63 )
-							{
-							case 1:
-								// Grammars\\TreeToNFAConverter.g3:582:0: .
-								{
-								MatchAny(input); if (state.failed) return elements;
-
-								}
-								break;
-
-							default:
-								goto loop63;
-							}
-						}
-
-						loop63:
-							;
-
-
-
-						Match(input, TokenTypes.Up, null); if (state.failed) return elements;
-					}
-
-					}
-					break;
-
-				default:
-					goto loop64;
-				}
-			}
-
-			loop64:
-				;
-
-
-			Match(input,BLOCK,Follow._BLOCK_in_setRule1485); if (state.failed) return elements;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return elements;
-			// Grammars\\TreeToNFAConverter.g3:583:13: ( ^( OPTIONS ( . )* ) )?
-			int alt66=2;
-			int LA66_0 = input.LA(1);
-
-			if ( (LA66_0==OPTIONS) )
-			{
-				alt66=1;
-			}
-			switch ( alt66 )
-			{
-			case 1:
-				// Grammars\\TreeToNFAConverter.g3:583:15: ^( OPTIONS ( . )* )
-				{
-				Match(input,OPTIONS,Follow._OPTIONS_in_setRule1490); if (state.failed) return elements;
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null); if (state.failed) return elements;
-					// Grammars\\TreeToNFAConverter.g3:583:25: ( . )*
-					for ( ; ; )
-					{
-						int alt65=2;
-						int LA65_0 = input.LA(1);
-
-						if ( ((LA65_0>=ACTION && LA65_0<=XDIGIT)) )
-						{
-							alt65=1;
-						}
-						else if ( (LA65_0==UP) )
-						{
-							alt65=2;
-						}
-
-
-						switch ( alt65 )
-						{
-						case 1:
-							// Grammars\\TreeToNFAConverter.g3:583:0: .
-							{
-							MatchAny(input); if (state.failed) return elements;
-
-							}
-							break;
-
-						default:
-							goto loop65;
-						}
-					}
-
-					loop65:
-						;
-
-
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return elements;
-				}
-
-				}
-				break;
-
-			}
-
-			// Grammars\\TreeToNFAConverter.g3:584:7: ( ^( ALT ( BACKTRACK_SEMPRED )? setElement[elements] EOA ) )+
-			int cnt68=0;
-			for ( ; ; )
-			{
-				int alt68=2;
-				int LA68_0 = input.LA(1);
-
-				if ( (LA68_0==ALT) )
-				{
-					alt68=1;
-				}
-
-
-				switch ( alt68 )
-				{
-				case 1:
-					// Grammars\\TreeToNFAConverter.g3:584:9: ^( ALT ( BACKTRACK_SEMPRED )? setElement[elements] EOA )
-					{
-					Match(input,ALT,Follow._ALT_in_setRule1508); if (state.failed) return elements;
-
-					Match(input, TokenTypes.Down, null); if (state.failed) return elements;
-					// Grammars\\TreeToNFAConverter.g3:584:15: ( BACKTRACK_SEMPRED )?
-					int alt67=2;
-					int LA67_0 = input.LA(1);
-
-					if ( (LA67_0==BACKTRACK_SEMPRED) )
-					{
-						alt67=1;
-					}
-					switch ( alt67 )
-					{
-					case 1:
-						// Grammars\\TreeToNFAConverter.g3:584:16: BACKTRACK_SEMPRED
-						{
-						Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_setRule1511); if (state.failed) return elements;
-
-						}
-						break;
-
-					}
-
-					PushFollow(Follow._setElement_in_setRule1515);
-					setElement(elements);
-
-					state._fsp--;
-					if (state.failed) return elements;
-					Match(input,EOA,Follow._EOA_in_setRule1518); if (state.failed) return elements;
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return elements;
-
-					}
-					break;
-
-				default:
-					if ( cnt68 >= 1 )
-						goto loop68;
-
-					if (state.backtracking>0) {state.failed=true; return elements;}
-					EarlyExitException eee68 = new EarlyExitException( 68, input );
-					throw eee68;
-				}
-				cnt68++;
-			}
-			loop68:
-				;
-
-
-			Match(input,EOB,Follow._EOB_in_setRule1530); if (state.failed) return elements;
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return elements;
-			// Grammars\\TreeToNFAConverter.g3:587:4: ( exceptionGroup )?
-			int alt69=2;
-			int LA69_0 = input.LA(1);
-
-			if ( (LA69_0==CATCH||LA69_0==FINALLY) )
-			{
-				alt69=1;
-			}
-			switch ( alt69 )
-			{
-			case 1:
-				// Grammars\\TreeToNFAConverter.g3:587:5: exceptionGroup
-				{
-				PushFollow(Follow._exceptionGroup_in_setRule1542);
-				exceptionGroup();
-
-				state._fsp--;
-				if (state.failed) return elements;
-
-				}
-				break;
-
-			}
-
-			Match(input,EOR,Follow._EOR_in_setRule1549); if (state.failed) return elements;
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return elements;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			 throw re;
-		}
-		finally
-		{
-		}
-		return elements;
-	}
-	// $ANTLR end "setRule"
-
-
-	// $ANTLR start "setElement"
-	// Grammars\\TreeToNFAConverter.g3:593:0: setElement[IIntSet elements] : (c= CHAR_LITERAL |t= TOKEN_REF |s= STRING_LITERAL | ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL ) |gset= set | ^( NOT setElement[ns] ) );
-	private void setElement( IIntSet elements )
-	{
-		GrammarAST c=null;
-		GrammarAST t=null;
-		GrammarAST s=null;
-		GrammarAST c1=null;
-		GrammarAST c2=null;
-		TreeToNFAConverter.set_return gset = default(TreeToNFAConverter.set_return);
-
-
-			int ttype;
-			IIntSet ns=null;
-
-		try
-		{
-			// Grammars\\TreeToNFAConverter.g3:599:4: (c= CHAR_LITERAL |t= TOKEN_REF |s= STRING_LITERAL | ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL ) |gset= set | ^( NOT setElement[ns] ) )
-			int alt70=6;
-			switch ( input.LA(1) )
-			{
-			case CHAR_LITERAL:
-				{
-				alt70=1;
-				}
-				break;
-			case TOKEN_REF:
-				{
-				alt70=2;
-				}
-				break;
-			case STRING_LITERAL:
-				{
-				alt70=3;
-				}
-				break;
-			case CHAR_RANGE:
-				{
-				alt70=4;
-				}
-				break;
-			case BLOCK:
-				{
-				alt70=5;
-				}
-				break;
-			case NOT:
-				{
-				alt70=6;
-				}
-				break;
-			default:
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					NoViableAltException nvae = new NoViableAltException("", 70, 0, input);
-
-					throw nvae;
-				}
-			}
-
-			switch ( alt70 )
-			{
-			case 1:
-				// Grammars\\TreeToNFAConverter.g3:599:4: c= CHAR_LITERAL
-				{
-				c=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_setElement1578); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-
-								if ( grammar.type==GrammarType.Lexer )
-								{
-									ttype = Grammar.GetCharValueFromGrammarCharLiteral((c!=null?c.Text:null));
-								}
-								else
-								{
-									ttype = grammar.GetTokenType((c!=null?c.Text:null));
-								}
-								if ( elements.Contains(ttype) )
-								{
-									ErrorManager.GrammarError(
-										ErrorManager.MSG_DUPLICATE_SET_ENTRY,
-										grammar,
-										c.Token,
-										(c!=null?c.Text:null));
-								}
-								elements.Add(ttype);
-
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\TreeToNFAConverter.g3:619:4: t= TOKEN_REF
-				{
-				t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_setElement1589); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-
-								if ( grammar.type==GrammarType.Lexer )
-								{
-									// recursively will invoke this rule to match elements in target rule ref
-									IIntSet ruleSet = grammar.GetSetFromRule(this,(t!=null?t.Text:null));
-									if ( ruleSet==null )
-									{
-										ErrorManager.GrammarError(
-											ErrorManager.MSG_RULE_INVALID_SET,
-											grammar,
-											t.Token,
-											(t!=null?t.Text:null));
-									}
-									else
-									{
-										elements.AddAll(ruleSet);
-									}
-								}
-								else
-								{
-									ttype = grammar.GetTokenType((t!=null?t.Text:null));
-									if ( elements.Contains(ttype) )
-									{
-										ErrorManager.GrammarError(
-											ErrorManager.MSG_DUPLICATE_SET_ENTRY,
-											grammar,
-											t.Token,
-											(t!=null?t.Text:null));
-									}
-									elements.Add(ttype);
-								}
-
-				}
-
-				}
-				break;
-			case 3:
-				// Grammars\\TreeToNFAConverter.g3:653:4: s= STRING_LITERAL
-				{
-				s=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_setElement1601); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-
-								ttype = grammar.GetTokenType((s!=null?s.Text:null));
-								if ( elements.Contains(ttype) )
-								{
-									ErrorManager.GrammarError(
-										ErrorManager.MSG_DUPLICATE_SET_ENTRY,
-										grammar,
-										s.Token,
-										(s!=null?s.Text:null));
-								}
-								elements.Add(ttype);
-
-				}
-
-				}
-				break;
-			case 4:
-				// Grammars\\TreeToNFAConverter.g3:666:4: ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL )
-				{
-				Match(input,CHAR_RANGE,Follow._CHAR_RANGE_in_setElement1611); if (state.failed) return ;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return ;
-				c1=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_setElement1615); if (state.failed) return ;
-				c2=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_setElement1619); if (state.failed) return ;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-
-								if ( grammar.type==GrammarType.Lexer )
-								{
-									int a = Grammar.GetCharValueFromGrammarCharLiteral((c1!=null?c1.Text:null));
-									int b = Grammar.GetCharValueFromGrammarCharLiteral((c2!=null?c2.Text:null));
-									elements.AddAll(IntervalSet.Of(a,b));
-								}
-
-				}
-
-				}
-				break;
-			case 5:
-				// Grammars\\TreeToNFAConverter.g3:676:4: gset= set
-				{
-				PushFollow(Follow._set_in_setElement1632);
-				gset=set();
-
-				state._fsp--;
-				if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-
-								Transition setTrans = (gset!=null?gset.g:default(StateCluster)).left.GetTransition(0);
-								elements.AddAll(setTrans.label.Set);
-
-				}
-
-				}
-				break;
-			case 6:
-				// Grammars\\TreeToNFAConverter.g3:682:4: ^( NOT setElement[ns] )
-				{
-				Match(input,NOT,Follow._NOT_in_setElement1644); if (state.failed) return ;
-
-				if ( state.backtracking == 0 )
-				{
-					ns=new IntervalSet();
-				}
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return ;
-				PushFollow(Follow._setElement_in_setElement1651);
-				setElement(ns);
-
-				state._fsp--;
-				if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-
-									IIntSet not = grammar.Complement(ns);
-									elements.AddAll(not);
-
-				}
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return ;
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			ReportError(re);
-			Recover(input,re);
-		}
-		finally
-		{
-		}
-		return ;
-	}
-	// $ANTLR end "setElement"
-
-
-	// $ANTLR start "testBlockAsSet"
-	// Grammars\\TreeToNFAConverter.g3:698:0: testBlockAsSet returns [int alts=0] options {backtrack=true; } : ^( BLOCK ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+ EOB ) ;
-	private int testBlockAsSet(  )
-	{
-		int alts = 0;
-
-		int testSetElement10 = default(int);
-
-
-			inTest++;
-
-		try
-		{
-			// Grammars\\TreeToNFAConverter.g3:704:4: ( ^( BLOCK ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+ EOB ) )
-			// Grammars\\TreeToNFAConverter.g3:704:4: ^( BLOCK ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+ EOB )
-			{
-			Match(input,BLOCK,Follow._BLOCK_in_testBlockAsSet1696); if (state.failed) return alts;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return alts;
-			// Grammars\\TreeToNFAConverter.g3:705:4: ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+
-			int cnt72=0;
-			for ( ; ; )
-			{
-				int alt72=2;
-				int LA72_0 = input.LA(1);
-
-				if ( (LA72_0==ALT) )
-				{
-					alt72=1;
-				}
-
-
-				switch ( alt72 )
-				{
-				case 1:
-					// Grammars\\TreeToNFAConverter.g3:705:6: ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA )
-					{
-					Match(input,ALT,Follow._ALT_in_testBlockAsSet1704); if (state.failed) return alts;
-
-					Match(input, TokenTypes.Down, null); if (state.failed) return alts;
-					// Grammars\\TreeToNFAConverter.g3:705:12: ( BACKTRACK_SEMPRED )?
-					int alt71=2;
-					int LA71_0 = input.LA(1);
-
-					if ( (LA71_0==BACKTRACK_SEMPRED) )
-					{
-						alt71=1;
-					}
-					switch ( alt71 )
-					{
-					case 1:
-						// Grammars\\TreeToNFAConverter.g3:705:13: BACKTRACK_SEMPRED
-						{
-						Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_testBlockAsSet1707); if (state.failed) return alts;
-
-						}
-						break;
-
-					}
-
-					PushFollow(Follow._testSetElement_in_testBlockAsSet1711);
-					testSetElement10=testSetElement();
-
-					state._fsp--;
-					if (state.failed) return alts;
-					alts += testSetElement10;
-					Match(input,EOA,Follow._EOA_in_testBlockAsSet1715); if (state.failed) return alts;
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return alts;
-
-					}
-					break;
-
-				default:
-					if ( cnt72 >= 1 )
-						goto loop72;
-
-					if (state.backtracking>0) {state.failed=true; return alts;}
-					EarlyExitException eee72 = new EarlyExitException( 72, input );
-					throw eee72;
-				}
-				cnt72++;
-			}
-			loop72:
-				;
-
-
-			Match(input,EOB,Follow._EOB_in_testBlockAsSet1727); if (state.failed) return alts;
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return alts;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			 throw re;
-		}
-		finally
-		{
-			 inTest--;
-		}
-		return alts;
-	}
-	// $ANTLR end "testBlockAsSet"
-
-
-	// $ANTLR start "testSetRule"
-	// Grammars\\TreeToNFAConverter.g3:713:0: testSetRule returns [int alts=0] : ^( RULE id= ID ( modifier )? ARG RET ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ^( BLOCK ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+ EOB ) ( exceptionGroup )? EOR ) ;
-	private int testSetRule(  )
-	{
-		int alts = 0;
-
-		GrammarAST id=null;
-		int testSetElement11 = default(int);
-
-
-			inTest++;
-
-		try
-		{
-			// Grammars\\TreeToNFAConverter.g3:718:4: ( ^( RULE id= ID ( modifier )? ARG RET ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ^( BLOCK ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+ EOB ) ( exceptionGroup )? EOR ) )
-			// Grammars\\TreeToNFAConverter.g3:718:4: ^( RULE id= ID ( modifier )? ARG RET ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ^( BLOCK ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+ EOB ) ( exceptionGroup )? EOR )
-			{
-			Match(input,RULE,Follow._RULE_in_testSetRule1762); if (state.failed) return alts;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return alts;
-			id=(GrammarAST)Match(input,ID,Follow._ID_in_testSetRule1766); if (state.failed) return alts;
-			// Grammars\\TreeToNFAConverter.g3:718:18: ( modifier )?
-			int alt73=2;
-			int LA73_0 = input.LA(1);
-
-			if ( (LA73_0==FRAGMENT||(LA73_0>=PRIVATE && LA73_0<=PUBLIC)) )
-			{
-				alt73=1;
-			}
-			switch ( alt73 )
-			{
-			case 1:
-				// Grammars\\TreeToNFAConverter.g3:718:19: modifier
-				{
-				PushFollow(Follow._modifier_in_testSetRule1769);
-				modifier();
-
-				state._fsp--;
-				if (state.failed) return alts;
-
-				}
-				break;
-
-			}
-
-			Match(input,ARG,Follow._ARG_in_testSetRule1773); if (state.failed) return alts;
-			Match(input,RET,Follow._RET_in_testSetRule1775); if (state.failed) return alts;
-			// Grammars\\TreeToNFAConverter.g3:718:38: ( ^( OPTIONS ( . )* ) )?
-			int alt75=2;
-			int LA75_0 = input.LA(1);
-
-			if ( (LA75_0==OPTIONS) )
-			{
-				alt75=1;
-			}
-			switch ( alt75 )
-			{
-			case 1:
-				// Grammars\\TreeToNFAConverter.g3:718:40: ^( OPTIONS ( . )* )
-				{
-				Match(input,OPTIONS,Follow._OPTIONS_in_testSetRule1780); if (state.failed) return alts;
-
-				if ( input.LA(1)==TokenTypes.Down )
-				{
-					Match(input, TokenTypes.Down, null); if (state.failed) return alts;
-					// Grammars\\TreeToNFAConverter.g3:718:50: ( . )*
-					for ( ; ; )
-					{
-						int alt74=2;
-						int LA74_0 = input.LA(1);
-
-						if ( ((LA74_0>=ACTION && LA74_0<=XDIGIT)) )
-						{
-							alt74=1;
-						}
-						else if ( (LA74_0==UP) )
-						{
-							alt74=2;
-						}
-
-
-						switch ( alt74 )
-						{
-						case 1:
-							// Grammars\\TreeToNFAConverter.g3:718:0: .
-							{
-							MatchAny(input); if (state.failed) return alts;
-
-							}
-							break;
-
-						default:
-							goto loop74;
-						}
-					}
-
-					loop74:
-						;
-
-
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return alts;
-				}
-
-				}
-				break;
-
-			}
-
-			// Grammars\\TreeToNFAConverter.g3:718:57: ( ruleScopeSpec )?
-			int alt76=2;
-			int LA76_0 = input.LA(1);
-
-			if ( (LA76_0==SCOPE) )
-			{
-				alt76=1;
-			}
-			switch ( alt76 )
-			{
-			case 1:
-				// Grammars\\TreeToNFAConverter.g3:718:59: ruleScopeSpec
-				{
-				PushFollow(Follow._ruleScopeSpec_in_testSetRule1791);
-				ruleScopeSpec();
-
-				state._fsp--;
-				if (state.failed) return alts;
-
-				}
-				break;
-
-			}
-
-			// Grammars\\TreeToNFAConverter.g3:719:4: ( ^( AMPERSAND ( . )* ) )*
-			for ( ; ; )
-			{
-				int alt78=2;
-				int LA78_0 = input.LA(1);
-
-				if ( (LA78_0==AMPERSAND) )
-				{
-					alt78=1;
-				}
-
-
-				switch ( alt78 )
-				{
-				case 1:
-					// Grammars\\TreeToNFAConverter.g3:719:6: ^( AMPERSAND ( . )* )
-					{
-					Match(input,AMPERSAND,Follow._AMPERSAND_in_testSetRule1802); if (state.failed) return alts;
-
-					if ( input.LA(1)==TokenTypes.Down )
-					{
-						Match(input, TokenTypes.Down, null); if (state.failed) return alts;
-						// Grammars\\TreeToNFAConverter.g3:719:18: ( . )*
-						for ( ; ; )
-						{
-							int alt77=2;
-							int LA77_0 = input.LA(1);
-
-							if ( ((LA77_0>=ACTION && LA77_0<=XDIGIT)) )
-							{
-								alt77=1;
-							}
-							else if ( (LA77_0==UP) )
-							{
-								alt77=2;
-							}
-
-
-							switch ( alt77 )
-							{
-							case 1:
-								// Grammars\\TreeToNFAConverter.g3:719:0: .
-								{
-								MatchAny(input); if (state.failed) return alts;
-
-								}
-								break;
-
-							default:
-								goto loop77;
-							}
-						}
-
-						loop77:
-							;
-
-
-
-						Match(input, TokenTypes.Up, null); if (state.failed) return alts;
-					}
-
-					}
-					break;
-
-				default:
-					goto loop78;
-				}
-			}
-
-			loop78:
-				;
-
-
-			Match(input,BLOCK,Follow._BLOCK_in_testSetRule1816); if (state.failed) return alts;
-
-			Match(input, TokenTypes.Down, null); if (state.failed) return alts;
-			// Grammars\\TreeToNFAConverter.g3:721:5: ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+
-			int cnt80=0;
-			for ( ; ; )
-			{
-				int alt80=2;
-				int LA80_0 = input.LA(1);
-
-				if ( (LA80_0==ALT) )
-				{
-					alt80=1;
-				}
-
-
-				switch ( alt80 )
-				{
-				case 1:
-					// Grammars\\TreeToNFAConverter.g3:721:7: ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA )
-					{
-					Match(input,ALT,Follow._ALT_in_testSetRule1825); if (state.failed) return alts;
-
-					Match(input, TokenTypes.Down, null); if (state.failed) return alts;
-					// Grammars\\TreeToNFAConverter.g3:721:13: ( BACKTRACK_SEMPRED )?
-					int alt79=2;
-					int LA79_0 = input.LA(1);
-
-					if ( (LA79_0==BACKTRACK_SEMPRED) )
-					{
-						alt79=1;
-					}
-					switch ( alt79 )
-					{
-					case 1:
-						// Grammars\\TreeToNFAConverter.g3:721:14: BACKTRACK_SEMPRED
-						{
-						Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_testSetRule1828); if (state.failed) return alts;
-
-						}
-						break;
-
-					}
-
-					PushFollow(Follow._testSetElement_in_testSetRule1832);
-					testSetElement11=testSetElement();
-
-					state._fsp--;
-					if (state.failed) return alts;
-					alts += testSetElement11;
-					Match(input,EOA,Follow._EOA_in_testSetRule1836); if (state.failed) return alts;
-
-					Match(input, TokenTypes.Up, null); if (state.failed) return alts;
-
-					}
-					break;
-
-				default:
-					if ( cnt80 >= 1 )
-						goto loop80;
-
-					if (state.backtracking>0) {state.failed=true; return alts;}
-					EarlyExitException eee80 = new EarlyExitException( 80, input );
-					throw eee80;
-				}
-				cnt80++;
-			}
-			loop80:
-				;
-
-
-			Match(input,EOB,Follow._EOB_in_testSetRule1850); if (state.failed) return alts;
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return alts;
-			// Grammars\\TreeToNFAConverter.g3:725:4: ( exceptionGroup )?
-			int alt81=2;
-			int LA81_0 = input.LA(1);
-
-			if ( (LA81_0==CATCH||LA81_0==FINALLY) )
-			{
-				alt81=1;
-			}
-			switch ( alt81 )
-			{
-			case 1:
-				// Grammars\\TreeToNFAConverter.g3:725:5: exceptionGroup
-				{
-				PushFollow(Follow._exceptionGroup_in_testSetRule1861);
-				exceptionGroup();
-
-				state._fsp--;
-				if (state.failed) return alts;
-
-				}
-				break;
-
-			}
-
-			Match(input,EOR,Follow._EOR_in_testSetRule1868); if (state.failed) return alts;
-
-			Match(input, TokenTypes.Up, null); if (state.failed) return alts;
-
-			}
-
-		}
-		catch ( RecognitionException re )
-		{
-			 throw re;
-		}
-		finally
-		{
-			 inTest--;
-		}
-		return alts;
-	}
-	// $ANTLR end "testSetRule"
-
-
-	// $ANTLR start "testSetElement"
-	// Grammars\\TreeToNFAConverter.g3:733:0: testSetElement returns [int alts=1] : (c= CHAR_LITERAL |t= TOKEN_REF |{...}? =>s= STRING_LITERAL | ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL ) | testBlockAsSet | ^( NOT tse= testSetElement ) );
-	private int testSetElement(  )
-	{
-		int alts = 1;
-
-		GrammarAST c=null;
-		GrammarAST t=null;
-		GrammarAST s=null;
-		GrammarAST c1=null;
-		GrammarAST c2=null;
-		int tse = default(int);
-		int testBlockAsSet12 = default(int);
-
-		try
-		{
-			// Grammars\\TreeToNFAConverter.g3:734:4: (c= CHAR_LITERAL |t= TOKEN_REF |{...}? =>s= STRING_LITERAL | ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL ) | testBlockAsSet | ^( NOT tse= testSetElement ) )
-			int alt82=6;
-			int LA82_0 = input.LA(1);
-
-			if ( (LA82_0==CHAR_LITERAL) )
-			{
-				alt82=1;
-			}
-			else if ( (LA82_0==TOKEN_REF) )
-			{
-				alt82=2;
-			}
-			else if ( (LA82_0==STRING_LITERAL) && ((grammar.type!=GrammarType.Lexer)))
-			{
-				alt82=3;
-			}
-			else if ( (LA82_0==CHAR_RANGE) )
-			{
-				alt82=4;
-			}
-			else if ( (LA82_0==BLOCK) )
-			{
-				alt82=5;
-			}
-			else if ( (LA82_0==NOT) )
-			{
-				alt82=6;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return alts;}
-				NoViableAltException nvae = new NoViableAltException("", 82, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt82 )
-			{
-			case 1:
-				// Grammars\\TreeToNFAConverter.g3:734:4: c= CHAR_LITERAL
-				{
-				c=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_testSetElement1900); if (state.failed) return alts;
-
-				}
-				break;
-			case 2:
-				// Grammars\\TreeToNFAConverter.g3:735:4: t= TOKEN_REF
-				{
-				t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_testSetElement1907); if (state.failed) return alts;
-
-							if ( grammar.type==GrammarType.Lexer )
-							{
-								Rule rule = grammar.GetRule((t!=null?t.Text:null));
-								if ( rule==null )
-								{
-									//throw new RecognitionException("invalid rule");
-									throw new RecognitionException();
-								}
-								// recursively will invoke this rule to match elements in target rule ref
-								alts += TestSetRule(rule.tree);
-							}
-
-
-				}
-				break;
-			case 3:
-				// Grammars\\TreeToNFAConverter.g3:749:6: {...}? =>s= STRING_LITERAL
-				{
-				if ( !((grammar.type!=GrammarType.Lexer)) )
-				{
-					if (state.backtracking>0) {state.failed=true; return alts;}
-					throw new FailedPredicateException(input, "testSetElement", "grammar.type!=GrammarType.Lexer");
-				}
-				s=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_testSetElement1924); if (state.failed) return alts;
-
-				}
-				break;
-			case 4:
-				// Grammars\\TreeToNFAConverter.g3:750:4: ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL )
-				{
-				Match(input,CHAR_RANGE,Follow._CHAR_RANGE_in_testSetElement1930); if (state.failed) return alts;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return alts;
-				c1=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_testSetElement1934); if (state.failed) return alts;
-				c2=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_testSetElement1938); if (state.failed) return alts;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return alts;
-				 alts = IntervalSet.Of( Grammar.GetCharValueFromGrammarCharLiteral((c1!=null?c1.Text:null)), Grammar.GetCharValueFromGrammarCharLiteral((c2!=null?c2.Text:null)) ).Count;
-
-				}
-				break;
-			case 5:
-				// Grammars\\TreeToNFAConverter.g3:752:6: testBlockAsSet
-				{
-				PushFollow(Follow._testBlockAsSet_in_testSetElement1950);
-				testBlockAsSet12=testBlockAsSet();
-
-				state._fsp--;
-				if (state.failed) return alts;
-				 alts = testBlockAsSet12;
-
-				}
-				break;
-			case 6:
-				// Grammars\\TreeToNFAConverter.g3:754:6: ^( NOT tse= testSetElement )
-				{
-				Match(input,NOT,Follow._NOT_in_testSetElement1963); if (state.failed) return alts;
-
-				Match(input, TokenTypes.Down, null); if (state.failed) return alts;
-				PushFollow(Follow._testSetElement_in_testSetElement1967);
-				tse=testSetElement();
-
-				state._fsp--;
-				if (state.failed) return alts;
-
-				Match(input, TokenTypes.Up, null); if (state.failed) return alts;
-				 alts = grammar.TokenTypes.Count - tse;
-
-				}
-				break;
-
-			}
-		}
-		catch ( RecognitionException re )
-		{
-			 throw re;
-		}
-		finally
-		{
-		}
-		return alts;
-	}
-	// $ANTLR end "testSetElement"
-	#endregion Rules
-
-
-	#region DFA
-	DFA41 dfa41;
-
-	protected override void InitDFAs()
-	{
-		base.InitDFAs();
-		dfa41 = new DFA41( this );
-	}
-
-	class DFA41 : DFA
-	{
-
-		const string DFA41_eotS =
-			"\x12\xFFFF";
-		const string DFA41_eofS =
-			"\x12\xFFFF";
-		const string DFA41_minS =
-			"\x1\x4\x11\xFFFF";
-		const string DFA41_maxS =
-			"\x1\x5F\x11\xFFFF";
-		const string DFA41_acceptS =
-			"\x1\xFFFF\x1\x1\x1\x2\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9\x1\xA"+
-			"\x1\xB\x1\xC\x1\xD\x1\xE\x1\xF\x1\x10\x1\x11";
-		const string DFA41_specialS =
-			"\x12\xFFFF}>";
-		static readonly string[] DFA41_transitionS =
-			{
-				"\x1\xB\x8\xFFFF\x1\x3\x1\xF\x1\x2\x1\x8\x1\xFFFF\x1\x7\x1\x6\x1\xFFFF"+
-				"\x1\x8\x7\xFFFF\x1\x7\x5\xFFFF\x1\x11\x3\xFFFF\x1\xC\x1\xFFFF\x1\x10"+
-				"\xD\xFFFF\x1\x7\x1\xFFFF\x1\x8\x5\xFFFF\x1\x4\x1\x8\x4\xFFFF\x1\x5\x4"+
-				"\xFFFF\x1\x1\x2\xFFFF\x1\x7\x2\xFFFF\x1\xD\x4\xFFFF\x1\x7\x1\xE\x1\xA"+
-				"\x2\xFFFF\x1\x7\x2\xFFFF\x1\x9\x1\xFFFF\x1\x7",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				""
-			};
-
-		static readonly short[] DFA41_eot = DFA.UnpackEncodedString(DFA41_eotS);
-		static readonly short[] DFA41_eof = DFA.UnpackEncodedString(DFA41_eofS);
-		static readonly char[] DFA41_min = DFA.UnpackEncodedStringToUnsignedChars(DFA41_minS);
-		static readonly char[] DFA41_max = DFA.UnpackEncodedStringToUnsignedChars(DFA41_maxS);
-		static readonly short[] DFA41_accept = DFA.UnpackEncodedString(DFA41_acceptS);
-		static readonly short[] DFA41_special = DFA.UnpackEncodedString(DFA41_specialS);
-		static readonly short[][] DFA41_transition;
-
-		static DFA41()
-		{
-			int numStates = DFA41_transitionS.Length;
-			DFA41_transition = new short[numStates][];
-			for ( int i=0; i < numStates; i++ )
-			{
-				DFA41_transition[i] = DFA.UnpackEncodedString(DFA41_transitionS[i]);
-			}
-		}
-
-		public DFA41( BaseRecognizer recognizer )
-		{
-			this.recognizer = recognizer;
-			this.decisionNumber = 41;
-			this.eot = DFA41_eot;
-			this.eof = DFA41_eof;
-			this.min = DFA41_min;
-			this.max = DFA41_max;
-			this.accept = DFA41_accept;
-			this.special = DFA41_special;
-			this.transition = DFA41_transition;
-		}
-		public override string GetDescription()
-		{
-			return "251:0: element returns [StateCluster g=null] : ( ^( ROOT e= element ) | ^( BANG e= element ) | ^( ASSIGN ID e= element ) | ^( PLUS_ASSIGN ID e= element ) | ^( RANGE a= atom[null] b= atom[null] ) | ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL ) | atom_or_notatom | ebnf | tree_ | ^( SYNPRED block ) | ACTION | FORCED_ACTION |pred= SEMPRED |spred= SYN_SEMPRED | ^(bpred= BACKTRACK_SEMPRED ( . )* ) |gpred= GATED_SEMPRED | EPSILON );";
-		}
-	}
-
-
-	#endregion DFA
-
-	#region Follow sets
-	private static class Follow
-	{
-		public static readonly BitSet _LEXER_GRAMMAR_in_grammar_67 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _grammarSpec_in_grammar_69 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _PARSER_GRAMMAR_in_grammar_79 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _grammarSpec_in_grammar_81 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _TREE_GRAMMAR_in_grammar_91 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _grammarSpec_in_grammar_93 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _COMBINED_GRAMMAR_in_grammar_103 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _grammarSpec_in_grammar_105 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _SCOPE_in_attrScope124 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_attrScope126 = new BitSet(new ulong[]{0x210UL});
-		public static readonly BitSet _AMPERSAND_in_attrScope131 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ACTION_in_attrScope140 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ID_in_grammarSpec153 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
-		public static readonly BitSet _DOC_COMMENT_in_grammarSpec160 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
-		public static readonly BitSet _OPTIONS_in_grammarSpec169 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _IMPORT_in_grammarSpec183 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _TOKENS_in_grammarSpec197 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _attrScope_in_grammarSpec209 = new BitSet(new ulong[]{0x400200008000200UL,0x8005000UL});
-		public static readonly BitSet _AMPERSAND_in_grammarSpec218 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _rules_in_grammarSpec230 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _rule_in_rules241 = new BitSet(new ulong[]{0x400200008000202UL,0x8005000UL});
-		public static readonly BitSet _RULE_in_rule255 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_rule259 = new BitSet(new ulong[]{0x10000000400UL,0xEUL});
-		public static readonly BitSet _modifier_in_rule270 = new BitSet(new ulong[]{0x400UL});
-		public static readonly BitSet _ARG_in_rule278 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_ACTION_in_rule281 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _RET_in_rule290 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_ACTION_in_rule293 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _throwsSpec_in_rule302 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
-		public static readonly BitSet _OPTIONS_in_rule312 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ruleScopeSpec_in_rule326 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
-		public static readonly BitSet _AMPERSAND_in_rule337 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _block_in_rule351 = new BitSet(new ulong[]{0x4400020000UL});
-		public static readonly BitSet _exceptionGroup_in_rule357 = new BitSet(new ulong[]{0x400000000UL});
-		public static readonly BitSet _EOR_in_rule364 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _set_in_modifier384 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _THROWS_in_throwsSpec411 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_throwsSpec413 = new BitSet(new ulong[]{0x80000000008UL});
-		public static readonly BitSet _SCOPE_in_ruleScopeSpec428 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _AMPERSAND_in_ruleScopeSpec433 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ACTION_in_ruleScopeSpec443 = new BitSet(new ulong[]{0x80000000008UL});
-		public static readonly BitSet _ID_in_ruleScopeSpec449 = new BitSet(new ulong[]{0x80000000008UL});
-		public static readonly BitSet _set_in_block480 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _BLOCK_in_block490 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _OPTIONS_in_block495 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _alternative_in_block511 = new BitSet(new ulong[]{0x200000100UL,0x200UL});
-		public static readonly BitSet _rewrite_in_block513 = new BitSet(new ulong[]{0x200000100UL,0x200UL});
-		public static readonly BitSet _EOB_in_block536 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ALT_in_alternative565 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _element_in_alternative570 = new BitSet(new ulong[]{0x86800289202DE210UL,0xA4E16421UL});
-		public static readonly BitSet _EOA_in_alternative577 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _exceptionHandler_in_exceptionGroup596 = new BitSet(new ulong[]{0x4000020002UL});
-		public static readonly BitSet _finallyClause_in_exceptionGroup602 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _finallyClause_in_exceptionGroup609 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _CATCH_in_exceptionHandler624 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_ACTION_in_exceptionHandler626 = new BitSet(new ulong[]{0x10UL});
-		public static readonly BitSet _ACTION_in_exceptionHandler628 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _FINALLY_in_finallyClause644 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ACTION_in_finallyClause646 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _REWRITE_in_rewrite669 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ROOT_in_element696 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _element_in_element700 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _BANG_in_element711 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _element_in_element715 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ASSIGN_in_element724 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_element726 = new BitSet(new ulong[]{0x86800289202DE210UL,0xA4E16421UL});
-		public static readonly BitSet _element_in_element730 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _PLUS_ASSIGN_in_element739 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_element741 = new BitSet(new ulong[]{0x86800289202DE210UL,0xA4E16421UL});
-		public static readonly BitSet _element_in_element745 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _RANGE_in_element756 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _atom_in_element760 = new BitSet(new ulong[]{0x20040000UL,0x84202000UL});
-		public static readonly BitSet _atom_in_element765 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _CHAR_RANGE_in_element779 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _CHAR_LITERAL_in_element783 = new BitSet(new ulong[]{0x40000UL});
-		public static readonly BitSet _CHAR_LITERAL_in_element787 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _atom_or_notatom_in_element799 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ebnf_in_element808 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _tree__in_element817 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _SYNPRED_in_element828 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _block_in_element830 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _ACTION_in_element839 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _FORCED_ACTION_in_element848 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _SEMPRED_in_element859 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _SYN_SEMPRED_in_element870 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _BACKTRACK_SEMPRED_in_element882 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _GATED_SEMPRED_in_element897 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _EPSILON_in_element906 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _set_in_ebnf932 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _block_in_ebnf942 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _OPTIONAL_in_ebnf953 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _block_in_ebnf957 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _CLOSURE_in_ebnf970 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _block_in_ebnf974 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _POSITIVE_CLOSURE_in_ebnf987 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _block_in_ebnf991 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _TREE_BEGIN_in_tree_1019 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _element_in_tree_1026 = new BitSet(new ulong[]{0x86800289202DE218UL,0xA4E16421UL});
-		public static readonly BitSet _element_in_tree_1042 = new BitSet(new ulong[]{0x86800289202DE218UL,0xA4E16421UL});
-		public static readonly BitSet _atom_in_atom_or_notatom1071 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _NOT_in_atom_or_notatom1083 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _CHAR_LITERAL_in_atom_or_notatom1092 = new BitSet(new ulong[]{0x8008UL,0x400UL});
-		public static readonly BitSet _ast_suffix_in_atom_or_notatom1097 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _TOKEN_REF_in_atom_or_notatom1114 = new BitSet(new ulong[]{0x8008UL,0x400UL});
-		public static readonly BitSet _ast_suffix_in_atom_or_notatom1119 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _set_in_atom_or_notatom1134 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _RULE_REF_in_atom1176 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_ACTION_in_atom1181 = new BitSet(new ulong[]{0x8008UL,0x400UL});
-		public static readonly BitSet _ast_suffix_in_atom1188 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _TOKEN_REF_in_atom1206 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ARG_ACTION_in_atom1212 = new BitSet(new ulong[]{0x8008UL,0x400UL});
-		public static readonly BitSet _ast_suffix_in_atom1219 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _CHAR_LITERAL_in_atom1237 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ast_suffix_in_atom1243 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _STRING_LITERAL_in_atom1261 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ast_suffix_in_atom1267 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _WILDCARD_in_atom1285 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ast_suffix_in_atom1290 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _DOT_in_atom1307 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_atom1311 = new BitSet(new ulong[]{0x20040000UL,0x84202000UL});
-		public static readonly BitSet _atom_in_atom1315 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _set_in_ast_suffix1332 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _BLOCK_in_set1361 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ALT_in_set1370 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _BACKTRACK_SEMPRED_in_set1375 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _setElement_in_set1384 = new BitSet(new ulong[]{0x100000000UL});
-		public static readonly BitSet _EOA_in_set1387 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _EOB_in_set1397 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _RULE_in_setRule1431 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_setRule1435 = new BitSet(new ulong[]{0x10000000400UL,0xEUL});
-		public static readonly BitSet _modifier_in_setRule1438 = new BitSet(new ulong[]{0x400UL});
-		public static readonly BitSet _ARG_in_setRule1442 = new BitSet(new ulong[]{0x0UL,0x80UL});
-		public static readonly BitSet _RET_in_setRule1444 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
-		public static readonly BitSet _OPTIONS_in_setRule1449 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ruleScopeSpec_in_setRule1460 = new BitSet(new ulong[]{0x10200UL});
-		public static readonly BitSet _AMPERSAND_in_setRule1471 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _BLOCK_in_setRule1485 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _OPTIONS_in_setRule1490 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ALT_in_setRule1508 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _BACKTRACK_SEMPRED_in_setRule1511 = new BitSet(new ulong[]{0x800000000D0000UL,0x4200000UL});
-		public static readonly BitSet _setElement_in_setRule1515 = new BitSet(new ulong[]{0x100000000UL});
-		public static readonly BitSet _EOA_in_setRule1518 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _EOB_in_setRule1530 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _exceptionGroup_in_setRule1542 = new BitSet(new ulong[]{0x400000000UL});
-		public static readonly BitSet _EOR_in_setRule1549 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _CHAR_LITERAL_in_setElement1578 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _TOKEN_REF_in_setElement1589 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _STRING_LITERAL_in_setElement1601 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _CHAR_RANGE_in_setElement1611 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _CHAR_LITERAL_in_setElement1615 = new BitSet(new ulong[]{0x40000UL});
-		public static readonly BitSet _CHAR_LITERAL_in_setElement1619 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _set_in_setElement1632 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _NOT_in_setElement1644 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _setElement_in_setElement1651 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _BLOCK_in_testBlockAsSet1696 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ALT_in_testBlockAsSet1704 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _BACKTRACK_SEMPRED_in_testBlockAsSet1707 = new BitSet(new ulong[]{0x800000000D0000UL,0x4200000UL});
-		public static readonly BitSet _testSetElement_in_testBlockAsSet1711 = new BitSet(new ulong[]{0x100000000UL});
-		public static readonly BitSet _EOA_in_testBlockAsSet1715 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _EOB_in_testBlockAsSet1727 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _RULE_in_testSetRule1762 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ID_in_testSetRule1766 = new BitSet(new ulong[]{0x10000000400UL,0xEUL});
-		public static readonly BitSet _modifier_in_testSetRule1769 = new BitSet(new ulong[]{0x400UL});
-		public static readonly BitSet _ARG_in_testSetRule1773 = new BitSet(new ulong[]{0x0UL,0x80UL});
-		public static readonly BitSet _RET_in_testSetRule1775 = new BitSet(new ulong[]{0x400000000010200UL,0x4000UL});
-		public static readonly BitSet _OPTIONS_in_testSetRule1780 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ruleScopeSpec_in_testSetRule1791 = new BitSet(new ulong[]{0x10200UL});
-		public static readonly BitSet _AMPERSAND_in_testSetRule1802 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _BLOCK_in_testSetRule1816 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _ALT_in_testSetRule1825 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _BACKTRACK_SEMPRED_in_testSetRule1828 = new BitSet(new ulong[]{0x800000000D0000UL,0x4200000UL});
-		public static readonly BitSet _testSetElement_in_testSetRule1832 = new BitSet(new ulong[]{0x100000000UL});
-		public static readonly BitSet _EOA_in_testSetRule1836 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _EOB_in_testSetRule1850 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _exceptionGroup_in_testSetRule1861 = new BitSet(new ulong[]{0x400000000UL});
-		public static readonly BitSet _EOR_in_testSetRule1868 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _CHAR_LITERAL_in_testSetElement1900 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _TOKEN_REF_in_testSetElement1907 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _STRING_LITERAL_in_testSetElement1924 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _CHAR_RANGE_in_testSetElement1930 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _CHAR_LITERAL_in_testSetElement1934 = new BitSet(new ulong[]{0x40000UL});
-		public static readonly BitSet _CHAR_LITERAL_in_testSetElement1938 = new BitSet(new ulong[]{0x8UL});
-		public static readonly BitSet _testBlockAsSet_in_testSetElement1950 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _NOT_in_testSetElement1963 = new BitSet(new ulong[]{0x4UL});
-		public static readonly BitSet _testSetElement_in_testSetElement1967 = new BitSet(new ulong[]{0x8UL});
-
-	}
-	#endregion Follow sets
-}
-
-} // namespace Antlr3.Grammars
diff --git a/AntlrBuildTask/Antlr3.targets b/AntlrBuildTask/Antlr3.targets
new file mode 100644
index 0000000..a9dedd7
--- /dev/null
+++ b/AntlrBuildTask/Antlr3.targets
@@ -0,0 +1,138 @@
+<!--
+   [The "BSD licence"]
+   Copyright (c) 2009 Sam Harwell
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+   3. The name of the author may not be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+-->
+<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <BuildSystem>MSBuild</BuildSystem>
+    <TaskVersion>3.2.0.0</TaskVersion>
+    <TaskKeyToken>eb42632606e9261f</TaskKeyToken>
+    <AntlrBuildTaskAssemblyName Condition="'$(AntlrBuildTaskAssemblyName)'==''">AntlrBuildTask, Version=$(TaskVersion), Culture=neutral, PublicKeyToken=$(TaskKeyToken)</AntlrBuildTaskAssemblyName>
+  </PropertyGroup>
+
+  <PropertyGroup>
+    <LoadTimeSensitiveTargets>
+      $(LoadTimeSensitiveTargets);
+      AntlrCompile;
+    </LoadTimeSensitiveTargets>
+    <LoadTimeSensitiveProperties>
+      $(LoadTimeSensitiveProperties);
+      AntlrCompileDependsOn;
+    </LoadTimeSensitiveProperties>
+
+
+    <PrepareResourcesDependsOn>
+      AntlrCompile;
+      $(PrepareResourcesDependsOn)
+    </PrepareResourcesDependsOn>
+  </PropertyGroup>
+
+  <PropertyGroup>
+    <AntlrBuildTaskLocation Condition="'$(AntlrBuildTaskPath)'==''">$(MSBuildBinPath)</AntlrBuildTaskLocation>
+    <AntlrBuildTaskLocation Condition="'$(AntlrBuildTaskPath)'!=''">$(AntlrBuildTaskPath)</AntlrBuildTaskLocation>
+    <AntlrToolLocation Condition="'$(AntlrToolPath)'==''">$(MSBuildBinPath)\Antlr3\Antlr3.exe</AntlrToolLocation>
+    <AntlrToolLocation Condition="'$(AntlrToolPath)'!=''">$(AntlrToolPath)</AntlrToolLocation>
+  </PropertyGroup>
+
+  <PropertyGroup>
+    <AntlrGenCodeFileNames Condition="'$(AntlrGenCodeFileNames)'==''">$(MSBuildProjectFile).AntlrGeneratedCodeFileListAbsolute.txt</AntlrGenCodeFileNames>
+  </PropertyGroup>
+
+  <UsingTask Condition="'$(AntlrBuildTaskPath)'==''" TaskName="Antlr3.Build.Tasks.AntlrClassGenerationTask" AssemblyName="$(AntlrBuildTaskAssemblyName)" />
+  <UsingTask Condition="'$(AntlrBuildTaskPath)'!=''" TaskName="Antlr3.Build.Tasks.AntlrClassGenerationTask" AssemblyFile="$(AntlrBuildTaskPath)\AntlrBuildTask.dll" />
+
+  <PropertyGroup>
+    <PrepareResourcesDependsOn>
+      AntlrCompile;
+      AntlrCompileAddFilesGenerated;
+      $(PrepareResourcesDependsOn)
+    </PrepareResourcesDependsOn>
+  </PropertyGroup>
+
+  <PropertyGroup>
+    <AntlrCompileDependsOn>
+      AntlrCompileReadGeneratedFileList
+    </AntlrCompileDependsOn>
+  </PropertyGroup>
+
+  <ItemGroup Condition="'$(BuildingInsideVisualStudio)'=='true'">
+    <AvailableItemName Include="Antlr3" />
+  </ItemGroup>
+
+  <Target Name="AntlrCompileReadGeneratedFileList">
+
+    <ReadLinesFromFile File="$(IntermediateOutputPath)$(AntlrGenCodeFileNames)">
+      <Output TaskParameter="Lines" ItemName="AntlrOutputCodeFilesList"/>
+    </ReadLinesFromFile>
+  </Target>
+
+  <Target Name="AntlrCompile"
+          DependsOnTargets="$(AntlrCompileDependsOn)"
+          Condition="'@(Antlr3)' != ''"
+          Inputs="@(Antlr3)"
+          Outputs="@(AntlrOutputCodeFilesList);
+                  $(IntermediateOutputPath)$(AntlrGenCodeFileNames);">
+
+    <ItemGroup>
+      <AntlrGeneratedCodeFiles Remove="@(AntlrGeneratedCodeFiles)" />
+    </ItemGroup>
+
+    <AntlrClassGenerationTask
+      AntlrToolPath="$(AntlrToolLocation)"
+      BuildTaskPath="$(AntlrBuildTaskLocation)"
+      OutputPath="$(IntermediateOutputPath)"
+      Language="$(Language)"
+      SourceCodeFiles="@(Antlr3)">
+
+      <Output ItemName="AntlrGeneratedCodeFiles" TaskParameter="GeneratedCodeFiles" />
+    </AntlrClassGenerationTask>
+
+    <WriteLinesToFile
+      File="$(IntermediateOutputPath)$(AntlrGenCodeFileNames)"
+      Lines="@(AntlrGeneratedCodeFiles)"
+      Overwrite="true"/>
+  </Target>
+
+  <Target Name="AntlrCompileAddFilesGenerated"
+          DependsOnTargets="AntlrCompile"
+          Condition="'@(Antlr3)' != ''">
+
+    <ItemGroup>
+      <AntlrGeneratedCodeFiles Condition="'@(AntlrGeneratedCodeFiles)' == ''"
+                               Include="@(AntlrOutputCodeFilesList)" />
+    </ItemGroup>
+
+    <ItemGroup>
+      <FileWrites Include="@(AntlrGeneratedCodeFiles);
+                           $(IntermediateOutputPath)$(AntlrGenCodeFileNames);" />
+    </ItemGroup>
+
+    <ItemGroup>
+      <Compile Include="@(AntlrGeneratedCodeFiles)" />
+    </ItemGroup>
+
+  </Target>
+</Project>
diff --git a/AntlrBuildTask/AntlrBuildTask.csproj b/AntlrBuildTask/AntlrBuildTask.csproj
new file mode 100644
index 0000000..08b5e4a
--- /dev/null
+++ b/AntlrBuildTask/AntlrBuildTask.csproj
@@ -0,0 +1,71 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{60F8B554-5C53-4DE2-B868-A0BFEF4EF80E}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>AntlrBuildTask</RootNamespace>
+    <AssemblyName>AntlrBuildTask</AssemblyName>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <SignAssembly>true</SignAssembly>
+    <AssemblyOriginatorKeyFile>..\Antlr3\Key.snk</AssemblyOriginatorKeyFile>
+    <SccProjectName>Perforce Project</SccProjectName>
+    <SccLocalPath>..\..\..</SccLocalPath>
+    <SccAuxPath>
+    </SccAuxPath>
+    <SccProvider>MSSCCI:Perforce SCM</SccProvider>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>bin\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>bin\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="Microsoft.Build.Engine" />
+    <Reference Include="Microsoft.Build.Framework" />
+    <Reference Include="Microsoft.Build.Utilities.v3.5">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="AntlrClassGenerationTask.cs" />
+    <Compile Include="AntlrClassGenerationTaskInternal.cs" />
+    <Compile Include="BuildMessage.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="..\Antlr3\Key.snk">
+      <Link>Key.snk</Link>
+    </None>
+    <None Include="Antlr3.targets" />
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
\ No newline at end of file
diff --git a/AntlrBuildTask/AntlrBuildTask.csproj.vspscc b/AntlrBuildTask/AntlrBuildTask.csproj.vspscc
new file mode 100644
index 0000000..87a63ba
--- /dev/null
+++ b/AntlrBuildTask/AntlrBuildTask.csproj.vspscc
@@ -0,0 +1,10 @@
+""
+{
+"FILE_VERSION" = "9237"
+"ENLISTMENT_CHOICE" = "NEVER"
+"PROJECT_FILE_RELATIVE_PATH" = "relative:antlrcs\\main\\AntlrBuildTask"
+"NUMBER_OF_EXCLUDED_FILES" = "0"
+"ORIGINAL_PROJECT_FILE_PATH" = ""
+"NUMBER_OF_NESTED_PROJECTS" = "0"
+"SOURCE_CONTROL_SETTINGS_PROVIDER" = "PROJECT"
+}
diff --git a/AntlrBuildTask/AntlrClassGenerationTask.cs b/AntlrBuildTask/AntlrClassGenerationTask.cs
new file mode 100644
index 0000000..d544510
--- /dev/null
+++ b/AntlrBuildTask/AntlrClassGenerationTask.cs
@@ -0,0 +1,222 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Build.Tasks
+{
+    using System;
+    using System.Collections.Generic;
+    using System.Linq;
+    using System.Reflection;
+    using System.Security;
+    using System.Security.Policy;
+    using System.Threading;
+    using Microsoft.Build.Framework;
+    using Microsoft.Build.Utilities;
+
+    public class AntlrClassGenerationTask
+        : Task
+    {
+        private const string DefaultGeneratedSourceExtension = "g";
+        private List<ITaskItem> _generatedCodeFiles = new List<ITaskItem>();
+
+        public AntlrClassGenerationTask()
+        {
+            this.GeneratedSourceExtension = DefaultGeneratedSourceExtension;
+        }
+
+        [Required]
+        public string AntlrToolPath
+        {
+            get;
+            set;
+        }
+
+        [Required]
+        public string OutputPath
+        {
+            get;
+            set;
+        }
+
+        [Required]
+        public string Language
+        {
+            get;
+            set;
+        }
+
+        public string BuildTaskPath
+        {
+            get;
+            set;
+        }
+
+        public ITaskItem[] SourceCodeFiles
+        {
+            get;
+            set;
+        }
+
+        public string GeneratedSourceExtension
+        {
+            get;
+            set;
+        }
+
+        public string RootNamespace
+        {
+            get;
+            set;
+        }
+
+        [Output]
+        public ITaskItem[] GeneratedCodeFiles
+        {
+            get
+            {
+                return this._generatedCodeFiles.ToArray();
+            }
+            set
+            {
+                this._generatedCodeFiles = new List<ITaskItem>(value);
+            }
+        }
+
+        public override bool Execute()
+        {
+            AppDomain domain = null;
+            bool success;
+
+            try
+            {
+                AppDomainSetup info = new AppDomainSetup
+                {
+                    ApplicationBase = BuildTaskPath,
+                    LoaderOptimization = LoaderOptimization.MultiDomainHost,
+                    ShadowCopyFiles = "true"
+                };
+
+                string friendlyName = "AntlrClassGenerationDomain_" + Guid.NewGuid();
+                domain = AppDomain.CreateDomain(friendlyName, AppDomain.CurrentDomain.Evidence, info, new NamedPermissionSet("FullTrust"), new StrongName[0]);
+                AntlrClassGenerationTaskInternal wrapper = CreateBuildTaskWrapper(domain);
+                success = wrapper.Execute();
+
+                if (success)
+                {
+                    _generatedCodeFiles.AddRange(wrapper.GeneratedCodeFiles.Select(file => (ITaskItem)new TaskItem(file)));
+                }
+                else
+                {
+                    foreach (BuildMessage message in wrapper.BuildMessages)
+                    {
+                        ProcessBuildMessage(message);
+                    }
+                }
+            }
+            catch (Exception exception)
+            {
+                if (IsFatalException(exception))
+                    throw;
+
+                ProcessExceptionAsBuildMessage(exception);
+                success = false;
+            }
+            finally
+            {
+                if (domain != null)
+                    AppDomain.Unload(domain);
+            }
+
+            return success;
+        }
+
+        private void ProcessExceptionAsBuildMessage(Exception exception)
+        {
+            ProcessBuildMessage(new BuildMessage(exception.Message));
+        }
+
+        private void ProcessBuildMessage(BuildMessage message)
+        {
+            string logMessage;
+            string errorCode;
+            errorCode = Log.ExtractMessageCode(message.Message, out logMessage);
+            if (string.IsNullOrEmpty(errorCode))
+            {
+                errorCode = "AC1000";
+                logMessage = "Unknown build error: " + message.Message;
+            }
+
+            string subcategory = null;
+            string helpKeyword = null;
+            this.Log.LogError(subcategory, errorCode, helpKeyword, message.FileName, message.LineNumber, message.ColumnNumber, 0, 0, logMessage, null);
+        }
+
+        private AntlrClassGenerationTaskInternal CreateBuildTaskWrapper(AppDomain domain)
+        {
+            AntlrClassGenerationTaskInternal wrapper = (AntlrClassGenerationTaskInternal)domain.CreateInstanceAndUnwrap(Assembly.GetExecutingAssembly().FullName, typeof(AntlrClassGenerationTaskInternal).FullName);
+
+            IList<string> sourceCodeFiles = null;
+            if (this.SourceCodeFiles != null)
+            {
+                sourceCodeFiles = new List<string>(SourceCodeFiles.Length);
+                foreach (ITaskItem taskItem in SourceCodeFiles)
+                    sourceCodeFiles.Add(taskItem.ItemSpec);
+            }
+
+            wrapper.AntlrToolPath = AntlrToolPath;
+            wrapper.SourceCodeFiles = sourceCodeFiles;
+            wrapper.Language = Language;
+            wrapper.OutputPath = OutputPath;
+            wrapper.RootNamespace = RootNamespace;
+            wrapper.GeneratedSourceExtension = GeneratedSourceExtension;
+            return wrapper;
+        }
+
+        private static bool IsFatalException(Exception exception)
+        {
+            while (exception != null)
+            {
+                if ((exception is OutOfMemoryException)
+                    || (exception is InsufficientMemoryException)
+                    || (exception is ThreadAbortException))
+                {
+                    return true;
+                }
+
+                if (!(exception is TypeInitializationException) && !(exception is TargetInvocationException))
+                {
+                    break;
+                }
+
+                exception = exception.InnerException;
+            }
+
+            return false;
+        }
+    }
+}
diff --git a/AntlrBuildTask/AntlrClassGenerationTaskInternal.cs b/AntlrBuildTask/AntlrClassGenerationTaskInternal.cs
new file mode 100644
index 0000000..e0fd22a
--- /dev/null
+++ b/AntlrBuildTask/AntlrClassGenerationTaskInternal.cs
@@ -0,0 +1,182 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Build.Tasks
+{
+    using System;
+    using System.Collections.Generic;
+    using System.Diagnostics;
+    using System.IO;
+    using System.Linq;
+    using System.Reflection;
+    using System.Text;
+
+    internal class AntlrClassGenerationTaskInternal : MarshalByRefObject
+    {
+        private List<string> _generatedCodeFiles = new List<string>();
+        private IList<string> _sourceCodeFiles = new List<string>();
+        private List<BuildMessage> _buildMessages = new List<BuildMessage>();
+
+        public IList<string> GeneratedCodeFiles
+        {
+            get
+            {
+                return this._generatedCodeFiles;
+            }
+        }
+
+        public string AntlrToolPath
+        {
+            get;
+            set;
+        }
+
+        public string GeneratedSourceExtension
+        {
+            get;
+            set;
+        }
+
+        public string Language
+        {
+            get;
+            set;
+        }
+
+        public string OutputPath
+        {
+            get;
+            set;
+        }
+
+        public string RootNamespace
+        {
+            get;
+            set;
+        }
+
+        public IList<string> SourceCodeFiles
+        {
+            get
+            {
+                return this._sourceCodeFiles;
+            }
+            set
+            {
+                this._sourceCodeFiles = value;
+            }
+        }
+
+        public IList<BuildMessage> BuildMessages
+        {
+            get
+            {
+                return _buildMessages;
+            }
+        }
+
+        public bool Execute()
+        {
+            try
+            {
+                Assembly antlrAssembly = Assembly.LoadFrom(AntlrToolPath);
+                Type antlrToolType = antlrAssembly.GetType("Antlr3.AntlrTool");
+                Type errorManagerType = antlrAssembly.GetType("Antlr3.Tool.ErrorManager");
+                object tool = Activator.CreateInstance(antlrAssembly.GetType("Antlr3.AntlrTool"), new object[] { Path.GetDirectoryName(AntlrToolPath) });
+
+                Action process = (Action)Delegate.CreateDelegate(typeof(Action), tool, antlrToolType.GetMethod("Process"));
+                Action<string[]> ProcessArgs = (Action<string[]>)Delegate.CreateDelegate(typeof(Action<string[]>), tool, antlrToolType.GetMethod("ProcessArgs"));
+                Func<IList<string>> GetGeneratedFiles = (Func<IList<string>>)Delegate.CreateDelegate(typeof(Func<IList<string>>), tool, antlrToolType.GetProperty("GeneratedFiles").GetGetMethod());
+
+                Func<int> GetNumErrors = (Func<int>)Delegate.CreateDelegate(typeof(Func<int>), errorManagerType.GetMethod("GetNumErrors"));
+                Action<TraceListener> SetTraceListener = (Action<TraceListener>)Delegate.CreateDelegate(typeof(Action<TraceListener>), errorManagerType.GetProperty("ExternalListener").GetSetMethod());
+
+                TimeSpan conversionTimeout = TimeSpan.FromSeconds(10);
+
+                List<string> args =
+                    new List<string>()
+                {
+                    "-Xconversiontimeout", ((int)conversionTimeout.TotalMilliseconds).ToString(),
+                    "-fo", OutputPath,
+                    "-message-format", "vs2005"
+                };
+
+                args.AddRange(SourceCodeFiles);
+
+                LoggingTraceListener traceListener = new LoggingTraceListener(_buildMessages);
+                SetTraceListener(traceListener);
+                ProcessArgs(args.ToArray());
+                process();
+                _generatedCodeFiles.AddRange(GetGeneratedFiles().Where(file => Path.GetExtension(file).Equals(".cs", StringComparison.OrdinalIgnoreCase)));
+
+                int errorCount = GetNumErrors();
+                if (errorCount > 0)
+                    _buildMessages.Add(new BuildMessage(errorCount + " errors occurred."));
+
+                return errorCount == 0;
+            }
+            catch (Exception e)
+            {
+                _buildMessages.Add(new BuildMessage(e.Message));
+                throw;
+            }
+        }
+
+        private class LoggingTraceListener : TraceListener
+        {
+            private readonly ICollection<BuildMessage> _buildMessages;
+            private StringBuilder _currentLine;
+
+            public LoggingTraceListener(IList<BuildMessage> buildMessages)
+            {
+                _buildMessages = buildMessages;
+                _currentLine = new StringBuilder();
+            }
+
+            public override void Write(string message)
+            {
+                _currentLine.Append(message);
+            }
+
+            public override void WriteLine(string message)
+            {
+                if (_currentLine.Length > 0)
+                {
+                    _buildMessages.Add(new BuildMessage(_currentLine.ToString(), null, 0, 0));
+                    _currentLine.Length = 0;
+                }
+
+                if (!string.IsNullOrEmpty(message))
+                {
+                    Write(message);
+                    WriteLine(null);
+                }
+            }
+        }
+    }
+}
diff --git a/AntlrBuildTask/BuildMessage.cs b/AntlrBuildTask/BuildMessage.cs
new file mode 100644
index 0000000..f45299c
--- /dev/null
+++ b/AntlrBuildTask/BuildMessage.cs
@@ -0,0 +1,74 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Build.Tasks
+{
+    using System;
+
+    [Serializable]
+    internal struct BuildMessage
+    {
+        public BuildMessage(string message)
+            : this(message, null, 0, 0)
+        {
+        }
+
+        public BuildMessage(string message, string fileName, int lineNumber, int columnNumber)
+            : this()
+        {
+            Message = message;
+            FileName = fileName;
+            LineNumber = lineNumber;
+            ColumnNumber = columnNumber;
+        }
+
+        public string Message
+        {
+            get;
+            set;
+        }
+
+        public string FileName
+        {
+            get;
+            set;
+        }
+
+        public int LineNumber
+        {
+            get;
+            set;
+        }
+
+        public int ColumnNumber
+        {
+            get;
+            set;
+        }
+    }
+}
diff --git a/AntlrBuildTask/Properties/AssemblyInfo.cs b/AntlrBuildTask/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..360f26b
--- /dev/null
+++ b/AntlrBuildTask/Properties/AssemblyInfo.cs
@@ -0,0 +1,67 @@
+/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System.Reflection;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("AntlrBuildTask")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("Pixel Mine, Inc.")]
+[assembly: AssemblyProduct("AntlrBuildTask")]
+[assembly: AssemblyCopyright("Copyright  Pixel Mine 2009")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible
+// to COM components.  If you need to access a type in this assembly from
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("2028affe-3dfd-4164-9faf-2959ec04f7f7")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("3.2.0.0")]
+[assembly: AssemblyFileVersion("3.2.0.0")]
diff --git a/bin/Bootstrap/Antlr3.Runtime.Debug.dll b/bin/Bootstrap/Antlr3.Runtime.Debug.dll
index 8e51599..a3650c2 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.Debug.dll and b/bin/Bootstrap/Antlr3.Runtime.Debug.dll differ
diff --git a/bin/Bootstrap/Antlr3.Runtime.Debug.pdb b/bin/Bootstrap/Antlr3.Runtime.Debug.pdb
index 29b9997..48f721c 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.Debug.pdb and b/bin/Bootstrap/Antlr3.Runtime.Debug.pdb differ
diff --git a/bin/Bootstrap/Antlr3.Runtime.dll b/bin/Bootstrap/Antlr3.Runtime.dll
index 44bb288..3bc843f 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.dll and b/bin/Bootstrap/Antlr3.Runtime.dll differ
diff --git a/bin/Bootstrap/Antlr3.Runtime.pdb b/bin/Bootstrap/Antlr3.Runtime.pdb
index 92096e8..138680b 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.pdb and b/bin/Bootstrap/Antlr3.Runtime.pdb differ
diff --git a/bin/Bootstrap/Antlr3.StringTemplate.dll b/bin/Bootstrap/Antlr3.StringTemplate.dll
index 97f5ada..6263ccc 100644
Binary files a/bin/Bootstrap/Antlr3.StringTemplate.dll and b/bin/Bootstrap/Antlr3.StringTemplate.dll differ
diff --git a/bin/Bootstrap/Antlr3.StringTemplate.pdb b/bin/Bootstrap/Antlr3.StringTemplate.pdb
index 842554f..639ff9d 100644
Binary files a/bin/Bootstrap/Antlr3.StringTemplate.pdb and b/bin/Bootstrap/Antlr3.StringTemplate.pdb differ
diff --git a/bin/Bootstrap/Antlr3.exe b/bin/Bootstrap/Antlr3.exe
index 745bb6d..fc7937e 100755
Binary files a/bin/Bootstrap/Antlr3.exe and b/bin/Bootstrap/Antlr3.exe differ
diff --git a/bin/Bootstrap/Antlr3.pdb b/bin/Bootstrap/Antlr3.pdb
index cac13e1..532667d 100644
Binary files a/bin/Bootstrap/Antlr3.pdb and b/bin/Bootstrap/Antlr3.pdb differ
diff --git a/bin/Bootstrap/Antlr3.targets b/bin/Bootstrap/Antlr3.targets
new file mode 100644
index 0000000..a9dedd7
--- /dev/null
+++ b/bin/Bootstrap/Antlr3.targets
@@ -0,0 +1,138 @@
+<!--
+   [The "BSD licence"]
+   Copyright (c) 2009 Sam Harwell
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+   3. The name of the author may not be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+-->
+<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <BuildSystem>MSBuild</BuildSystem>
+    <TaskVersion>3.2.0.0</TaskVersion>
+    <TaskKeyToken>eb42632606e9261f</TaskKeyToken>
+    <AntlrBuildTaskAssemblyName Condition="'$(AntlrBuildTaskAssemblyName)'==''">AntlrBuildTask, Version=$(TaskVersion), Culture=neutral, PublicKeyToken=$(TaskKeyToken)</AntlrBuildTaskAssemblyName>
+  </PropertyGroup>
+
+  <PropertyGroup>
+    <LoadTimeSensitiveTargets>
+      $(LoadTimeSensitiveTargets);
+      AntlrCompile;
+    </LoadTimeSensitiveTargets>
+    <LoadTimeSensitiveProperties>
+      $(LoadTimeSensitiveProperties);
+      AntlrCompileDependsOn;
+    </LoadTimeSensitiveProperties>
+
+
+    <PrepareResourcesDependsOn>
+      AntlrCompile;
+      $(PrepareResourcesDependsOn)
+    </PrepareResourcesDependsOn>
+  </PropertyGroup>
+
+  <PropertyGroup>
+    <AntlrBuildTaskLocation Condition="'$(AntlrBuildTaskPath)'==''">$(MSBuildBinPath)</AntlrBuildTaskLocation>
+    <AntlrBuildTaskLocation Condition="'$(AntlrBuildTaskPath)'!=''">$(AntlrBuildTaskPath)</AntlrBuildTaskLocation>
+    <AntlrToolLocation Condition="'$(AntlrToolPath)'==''">$(MSBuildBinPath)\Antlr3\Antlr3.exe</AntlrToolLocation>
+    <AntlrToolLocation Condition="'$(AntlrToolPath)'!=''">$(AntlrToolPath)</AntlrToolLocation>
+  </PropertyGroup>
+
+  <PropertyGroup>
+    <AntlrGenCodeFileNames Condition="'$(AntlrGenCodeFileNames)'==''">$(MSBuildProjectFile).AntlrGeneratedCodeFileListAbsolute.txt</AntlrGenCodeFileNames>
+  </PropertyGroup>
+
+  <UsingTask Condition="'$(AntlrBuildTaskPath)'==''" TaskName="Antlr3.Build.Tasks.AntlrClassGenerationTask" AssemblyName="$(AntlrBuildTaskAssemblyName)" />
+  <UsingTask Condition="'$(AntlrBuildTaskPath)'!=''" TaskName="Antlr3.Build.Tasks.AntlrClassGenerationTask" AssemblyFile="$(AntlrBuildTaskPath)\AntlrBuildTask.dll" />
+
+  <PropertyGroup>
+    <PrepareResourcesDependsOn>
+      AntlrCompile;
+      AntlrCompileAddFilesGenerated;
+      $(PrepareResourcesDependsOn)
+    </PrepareResourcesDependsOn>
+  </PropertyGroup>
+
+  <PropertyGroup>
+    <AntlrCompileDependsOn>
+      AntlrCompileReadGeneratedFileList
+    </AntlrCompileDependsOn>
+  </PropertyGroup>
+
+  <ItemGroup Condition="'$(BuildingInsideVisualStudio)'=='true'">
+    <AvailableItemName Include="Antlr3" />
+  </ItemGroup>
+
+  <Target Name="AntlrCompileReadGeneratedFileList">
+
+    <ReadLinesFromFile File="$(IntermediateOutputPath)$(AntlrGenCodeFileNames)">
+      <Output TaskParameter="Lines" ItemName="AntlrOutputCodeFilesList"/>
+    </ReadLinesFromFile>
+  </Target>
+
+  <Target Name="AntlrCompile"
+          DependsOnTargets="$(AntlrCompileDependsOn)"
+          Condition="'@(Antlr3)' != ''"
+          Inputs="@(Antlr3)"
+          Outputs="@(AntlrOutputCodeFilesList);
+                  $(IntermediateOutputPath)$(AntlrGenCodeFileNames);">
+
+    <ItemGroup>
+      <AntlrGeneratedCodeFiles Remove="@(AntlrGeneratedCodeFiles)" />
+    </ItemGroup>
+
+    <AntlrClassGenerationTask
+      AntlrToolPath="$(AntlrToolLocation)"
+      BuildTaskPath="$(AntlrBuildTaskLocation)"
+      OutputPath="$(IntermediateOutputPath)"
+      Language="$(Language)"
+      SourceCodeFiles="@(Antlr3)">
+
+      <Output ItemName="AntlrGeneratedCodeFiles" TaskParameter="GeneratedCodeFiles" />
+    </AntlrClassGenerationTask>
+
+    <WriteLinesToFile
+      File="$(IntermediateOutputPath)$(AntlrGenCodeFileNames)"
+      Lines="@(AntlrGeneratedCodeFiles)"
+      Overwrite="true"/>
+  </Target>
+
+  <Target Name="AntlrCompileAddFilesGenerated"
+          DependsOnTargets="AntlrCompile"
+          Condition="'@(Antlr3)' != ''">
+
+    <ItemGroup>
+      <AntlrGeneratedCodeFiles Condition="'@(AntlrGeneratedCodeFiles)' == ''"
+                               Include="@(AntlrOutputCodeFilesList)" />
+    </ItemGroup>
+
+    <ItemGroup>
+      <FileWrites Include="@(AntlrGeneratedCodeFiles);
+                           $(IntermediateOutputPath)$(AntlrGenCodeFileNames);" />
+    </ItemGroup>
+
+    <ItemGroup>
+      <Compile Include="@(AntlrGeneratedCodeFiles)" />
+    </ItemGroup>
+
+  </Target>
+</Project>
diff --git a/bin/Bootstrap/AntlrBuildTask.dll b/bin/Bootstrap/AntlrBuildTask.dll
new file mode 100644
index 0000000..a0a9c0c
Binary files /dev/null and b/bin/Bootstrap/AntlrBuildTask.dll differ
diff --git a/bin/Bootstrap/AntlrBuildTask.pdb b/bin/Bootstrap/AntlrBuildTask.pdb
new file mode 100644
index 0000000..1d5aed9
Binary files /dev/null and b/bin/Bootstrap/AntlrBuildTask.pdb differ
diff --git a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll
index 4d92265..a4ffc98 100644
Binary files a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll and b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll differ
diff --git a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.pdb b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.pdb
index f5c98d1..ce60556 100644
Binary files a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.pdb and b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.pdb differ

