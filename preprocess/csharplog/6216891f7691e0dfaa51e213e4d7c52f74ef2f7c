commit 6216891f7691e0dfaa51e213e4d7c52f74ef2f7c
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Wed Dec 9 19:37:30 2009 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Wed Dec 9 19:37:30 2009 -0800

C# Port:
* Initial ST4 port (synced to CL 6389)

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 6465]

diff --git a/Antlr3.Test/Antlr3.Test.csproj b/Antlr3.Test/Antlr3.Test.csproj
index 49dee8e..0797975 100644
--- a/Antlr3.Test/Antlr3.Test.csproj
+++ b/Antlr3.Test/Antlr3.Test.csproj
@@ -45,6 +45,24 @@
<Compile Include="JavaRuntimeTestHarness.cs" />
<Compile Include="Properties\AssemblyInfo.cs" />
<Compile Include="RuntimeTestHarness.cs" />
+    <Compile Include="ST4\ErrorBuffer.cs" />
+    <Compile Include="ST4\StringTemplateTestBase.cs" />
+    <Compile Include="ST4\TestCompiler.cs" />
+    <Compile Include="ST4\TestCoreBasics.cs" />
+    <Compile Include="ST4\TestDictionaries.cs" />
+    <Compile Include="ST4\TestDollarDelimiters.cs" />
+    <Compile Include="ST4\TestFunctions.cs" />
+    <Compile Include="ST4\TestGroups.cs" />
+    <Compile Include="ST4\TestGroupSyntax.cs" />
+    <Compile Include="ST4\TestIndentation.cs" />
+    <Compile Include="ST4\TestIndirectionAndEarlyEvaluation.cs" />
+    <Compile Include="ST4\TestLexer.cs" />
+    <Compile Include="ST4\TestLists.cs" />
+    <Compile Include="ST4\TestNullAndEmptyValues.cs" />
+    <Compile Include="ST4\TestOptions.cs" />
+    <Compile Include="ST4\TestSubtemplates.cs" />
+    <Compile Include="ST4\TestSyntaxErrors.cs" />
+    <Compile Include="ST4\TestWhitespace.cs" />
<Compile Include="StringTemplateTests.cs" />
<Compile Include="TestASTConstruction.cs" />
<Compile Include="TestAttributes.cs" />
@@ -121,6 +139,10 @@
<Name>Antlr3</Name>
<Private>True</Private>
</ProjectReference>
+    <ProjectReference Include="..\StringTemplate4\StringTemplate4.csproj">
+      <Project>{BBE5D9E6-2F4C-46EF-8CDB-17F886A36837}</Project>
+      <Name>StringTemplate4</Name>
+    </ProjectReference>
</ItemGroup>
<Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
<!-- To modify your build process, add your task inside one of the targets below and uncomment it.
diff --git a/Antlr3.Test/ST4/ErrorBuffer.cs b/Antlr3.Test/ST4/ErrorBuffer.cs
new file mode 100644
index 0000000..5c108ca
--- /dev/null
+++ b/Antlr3.Test/ST4/ErrorBuffer.cs
@@ -0,0 +1,60 @@
+﻿namespace AntlrUnitTests.ST4
+{
+    using StringTemplate;
+    using Exception = System.Exception;
+    using StringBuilder = System.Text.StringBuilder;
+    using StringWriter = System.IO.StringWriter;
+
+    public class ErrorBuffer : ITemplateErrorListener
+    {
+        StringBuilder errorOutput = new StringBuilder(500);
+        int n = 0;
+
+        public void Error(string msg)
+        {
+            Error(msg, null);
+        }
+
+        public void Error(string msg, Exception e)
+        {
+            n++;
+            if (n > 1)
+            {
+                errorOutput.Append('\n');
+            }
+            if (e != null)
+            {
+                StringWriter duh = new StringWriter();
+                duh.WriteLine(e.StackTrace);
+                errorOutput.Append(msg + ": " + duh.ToString());
+            }
+            else
+            {
+                errorOutput.Append(msg);
+            }
+        }
+
+        public void Warning(string msg)
+        {
+            n++;
+            errorOutput.Append(msg);
+        }
+
+        public override bool Equals(object o)
+        {
+            string me = ToString();
+            string them = o.ToString();
+            return me.Equals(them);
+        }
+
+        public override int GetHashCode()
+        {
+            return ToString().GetHashCode();
+        }
+
+        public override string ToString()
+        {
+            return errorOutput.ToString();
+        }
+    }
+}
diff --git a/Antlr3.Test/ST4/StringTemplateTestBase.cs b/Antlr3.Test/ST4/StringTemplateTestBase.cs
new file mode 100644
index 0000000..dc8ef74
--- /dev/null
+++ b/Antlr3.Test/ST4/StringTemplateTestBase.cs
@@ -0,0 +1,99 @@
+﻿namespace AntlrUnitTests.ST4
+{
+    using Console = System.Console;
+    using Directory = System.IO.Directory;
+    using Environment = System.Environment;
+    using File = System.IO.File;
+    using IOException = System.IO.IOException;
+    using Path = System.IO.Path;
+    using Random = System.Random;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+
+    public abstract class StringTemplateTestBase
+    {
+        public static readonly string tmpdir = Path.GetTempPath();
+        public static readonly string newline = Environment.NewLine;
+
+        private Random random = new Random();
+
+        public TestContext TestContext
+        {
+            get;
+            private set;
+        }
+
+        [ClassInitialize]
+        public void ClassSetUp(TestContext testContext)
+        {
+            TestContext = testContext;
+        }
+
+        public void WriteFile(string dir, string fileName, string content)
+        {
+            try
+            {
+                string f = Path.Combine(dir, fileName);
+                if (!Directory.Exists(Path.GetDirectoryName(f)))
+                    Directory.CreateDirectory(Path.GetDirectoryName(f));
+
+                File.WriteAllText(f, content);
+            }
+            catch (IOException ioe)
+            {
+                TestContext.WriteLine("can't write file");
+                TestContext.WriteLine(ioe.StackTrace);
+            }
+        }
+
+        public class User
+        {
+            public int id;
+            public string name;
+
+            public User(int id, string name)
+            {
+                this.id = id;
+                this.name = name;
+            }
+
+            public string Name
+            {
+                get
+                {
+                    return name;
+                }
+            }
+        }
+
+        public class HashableUser : User
+        {
+            public HashableUser(int id, string name)
+                : base(id, name)
+            {
+            }
+
+            public override int GetHashCode()
+            {
+                return id;
+            }
+
+            public override bool Equals(object o)
+            {
+                if (o is HashableUser)
+                {
+                    HashableUser hu = (HashableUser)o;
+                    return this.id == hu.id && this.name.Equals(hu.name);
+                }
+
+                return false;
+            }
+        }
+
+        protected string GetRandomDir()
+        {
+            string randomDir = Path.Combine(tmpdir, "dir" + random.Next(100000));
+            Directory.CreateDirectory(randomDir);
+            return randomDir;
+        }
+    }
+}
diff --git a/Antlr3.Test/ST4/TestCompiler.cs b/Antlr3.Test/ST4/TestCompiler.cs
new file mode 100644
index 0000000..a5acaa4
--- /dev/null
+++ b/Antlr3.Test/ST4/TestCompiler.cs
@@ -0,0 +1,304 @@
+﻿namespace AntlrUnitTests.ST4
+{
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using StringTemplate;
+
+    [TestClass]
+    public class TestCompiler : StringTemplateTestBase
+    {
+        [TestInitialize]
+        public void setUp()
+        {
+            Compiler.subtemplateCount = 0;
+        }
+
+        [TestMethod]
+        public void TestAttr()
+        {
+            string template = "hi <name>";
+            CompiledTemplate code = new Compiler().Compile(template);
+            string asmExpected =
+                "load_str 0, " +
+                "write, " +
+                "load_attr 1, " +
+                "write";
+            string asmResult = code.Instructions();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[hi , name]";
+            string stringsResult = Arrays.toString(code.strings);
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestInclude()
+        {
+            string template = "hi <foo()>";
+            CompiledTemplate code = new Compiler().Compile(template);
+            string asmExpected =
+                "load_str 0, write, new 1, write";
+            string asmResult = code.Instructions();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[hi , foo]";
+            string stringsResult = Arrays.toString(code.strings);
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestProp()
+        {
+            string template = "hi <a.b>";
+            CompiledTemplate code = new Compiler().Compile(template);
+            string asmExpected =
+                "load_str 0, write, load_attr 1, load_prop 2, write";
+            string asmResult = code.Instructions();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[hi , a, b]";
+            string stringsResult = Arrays.toString(code.strings);
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestProp2()
+        {
+            string template = "<u.id>: <u.name>";
+            CompiledTemplate code = new Compiler().Compile(template);
+            string asmExpected =
+                "load_attr 0, load_prop 1, write, load_str 2, write, " +
+                "load_attr 0, load_prop 3, write";
+            string asmResult = code.Instructions();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[u, id, : , name]";
+            string stringsResult = Arrays.toString(code.strings);
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestMap()
+        {
+            string template = "hi <name:bold>";
+            CompiledTemplate code = new Compiler().Compile(template);
+            string asmExpected =
+                "load_str 0, write, load_attr 1, load_str 2, map, write";
+            string asmResult = code.Instructions();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[hi , name, bold]";
+            string stringsResult = Arrays.toString(code.strings);
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestRepeatedMap()
+        {
+            string template = "hi <name:bold:italics>";
+            CompiledTemplate code = new Compiler().Compile(template);
+            string asmExpected =
+                "load_str 0, " +
+                "write, " +
+                "load_attr 1, " +
+                "load_str 2, " +
+                "map, " +
+                "load_str 3, " +
+                "map, " +
+                "write";
+            string asmResult = code.Instructions();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[hi , name, bold, italics]";
+            string stringsResult = Arrays.toString(code.strings);
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestRotMap()
+        {
+            string template = "hi <name:bold,italics>";
+            CompiledTemplate code = new Compiler().Compile(template);
+            string asmExpected =
+                "load_str 0, write, load_attr 1, load_str 2, load_str 3, rot_map 2, write";
+            string asmResult = code.Instructions();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[hi , name, bold, italics]";
+            string stringsResult = Arrays.toString(code.strings);
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestAnonMap()
+        {
+            string template = "hi <name:{n | <n>}>";
+            CompiledTemplate code = new Compiler().Compile(template);
+            string asmExpected =
+                "load_str 0, write, load_attr 1, load_str 2, map, write";
+            string asmResult = code.Instructions();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[hi , name, _sub1]";
+            string stringsResult = Arrays.toString(code.strings);
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestIf()
+        {
+            string template = "go: <if(name)>hi, foo<endif>";
+            CompiledTemplate code = new Compiler().Compile(template);
+            string asmExpected =
+                "load_str 0, write, load_attr 1, brf 14, load_str 2, write";
+            string asmResult = code.Instructions();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[go: , name, hi, foo]";
+            string stringsResult = Arrays.toString(code.strings);
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestIfElse()
+        {
+            string template = "go: <if(name)>hi, foo<else>bye<endif>";
+            CompiledTemplate code = new Compiler().Compile(template);
+            string asmExpected =
+                "load_str 0, " +
+                "write, " +
+                "load_attr 1, " +
+                "brf 17, " +
+                "load_str 2, " +
+                "write, " +
+                "br 21, " +
+                "load_str 3, " +
+                "write";
+            string asmResult = code.Instructions();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[go: , name, hi, foo, bye]";
+            string stringsResult = Arrays.toString(code.strings);
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestElseIf()
+        {
+            string template = "go: <if(name)>hi, foo<elseif(user)>a user<endif>";
+            CompiledTemplate code = new Compiler().Compile(template);
+            string asmExpected =
+                "load_str 0, " +
+                "write, " +
+                "load_attr 1, " +
+                "brf 17, " +
+                "load_str 2, " +
+                "write, " +
+                "br 27, " +
+                "load_attr 3, " +
+                "brf 27, " +
+                "load_str 4, " +
+                "write";
+            string asmResult = code.Instructions();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[go: , name, hi, foo, user, a user]";
+            string stringsResult = Arrays.toString(code.strings);
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestElseIfElse()
+        {
+            string template = "go: <if(name)>hi, foo<elseif(user)>a user<else>bye<endif>";
+            CompiledTemplate code = new Compiler().Compile(template);
+            string asmExpected =
+                "load_str 0, " +
+                "write, " +
+                "load_attr 1, " +
+                "brf 17, " +
+                "load_str 2, " +
+                "write, " +
+                "br 34, " +
+                "load_attr 3, " +
+                "brf 30, " +
+                "load_str 4, " +
+                "write, " +
+                "br 34, " +
+                "load_str 5, " +
+                "write";
+            string asmResult = code.Instructions();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[go: , name, hi, foo, user, a user, bye]";
+            string stringsResult = Arrays.toString(code.strings);
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestOption()
+        {
+            string template = "hi <name; separator=\"x\">";
+            CompiledTemplate code = new Compiler().Compile(template);
+            string asmExpected =
+                "load_str 0, write, load_attr 1, options, load_str 2, store_option 3, write_opt";
+            string asmResult = code.Instructions();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[hi , name, x]";
+            string stringsResult = Arrays.toString(code.strings);
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestOptionAsTemplate()
+        {
+            string template = "hi <name; separator={, }>";
+            CompiledTemplate code = new Compiler().Compile(template);
+            string asmExpected =
+                "load_str 0, write, load_attr 1, options, new 2, store_option 3, write_opt";
+            string asmResult = code.Instructions();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[hi , name, _sub1]";
+            string stringsResult = Arrays.toString(code.strings);
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestOptions()
+        {
+            string template = "hi <name; anchor, wrap=foo(), separator=\", \">";
+            CompiledTemplate code = new Compiler().Compile(template);
+            string asmExpected =
+                "load_str 0, write, load_attr 1, options, load_str 2, " +
+                "store_option 0, new 3, store_option 4, load_str 4, " +
+                "store_option 3, write_opt";
+            string stringsExpected = // the ", , ," is the ", " separator string
+                "[hi , name, true, foo, , ]";
+            string stringsResult = Arrays.toString(code.strings);
+            Assert.AreEqual(stringsExpected, stringsResult);
+            string asmResult = code.Instructions();
+            Assert.AreEqual(asmExpected, asmResult);
+        }
+
+        [TestMethod]
+        public void TestEmptyList()
+        {
+            string template = "<[]>";
+            CompiledTemplate code = new Compiler().Compile(template);
+            string asmExpected = "list, write";
+            string asmResult = code.Instructions();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[]";
+            string stringsResult = Arrays.toString(code.strings);
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        [TestMethod]
+        public void TestList()
+        {
+            string template = "<[a,b]>";
+            CompiledTemplate code = new Compiler().Compile(template);
+            string asmExpected = "list, load_attr 0, add, load_attr 1, add, write";
+            string asmResult = code.Instructions();
+            Assert.AreEqual(asmExpected, asmResult);
+            string stringsExpected = "[a, b]";
+            string stringsResult = Arrays.toString(code.strings);
+            Assert.AreEqual(stringsExpected, stringsResult);
+        }
+
+        private static class Arrays
+        {
+            public static string toString(string[] array)
+            {
+                return "[" + string.Join(", ", array) + "]";
+            }
+        }
+    }
+}
diff --git a/Antlr3.Test/ST4/TestCoreBasics.cs b/Antlr3.Test/ST4/TestCoreBasics.cs
new file mode 100644
index 0000000..9a7ba31
--- /dev/null
+++ b/Antlr3.Test/ST4/TestCoreBasics.cs
@@ -0,0 +1,479 @@
+﻿namespace AntlrUnitTests.ST4
+{
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using ArrayList = System.Collections.ArrayList;
+    using StringTemplate;
+    using StringWriter = System.IO.StringWriter;
+
+    [TestClass]
+    public class TestCoreBasics : StringTemplateTestBase
+    {
+        [TestMethod]
+        public void TestNullAttr()
+        {
+            string template = "hi <name>!";
+            Template st = new Template(template);
+            string expected =
+                "hi !";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestAttr()
+        {
+            string template = "hi <name>!";
+            Template st = new Template(template);
+            st.Add("name", "Ter");
+            string expected = "hi Ter!";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestMultiAttr()
+        {
+            string template = "hi <name>!";
+            Template st = new Template(template);
+            st.Add("name", "Ter");
+            st.Add("name", "Tom");
+            string expected =
+                "hi TerTom!";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestAttrIsList()
+        {
+            string template = "hi <name>!";
+            Template st = new Template(template);
+            var names = new ArrayList() { "Ter", "Tom" };
+            st.Add("name", names);
+            st.Add("name", "Sumana"); // shouldn't alter my version of names list!
+            string expected =
+                "hi TerTomSumana!";  // ST sees 3 names
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+
+            Assert.IsTrue(names.Count == 2); // my names list is still just 2
+        }
+
+        [TestMethod]
+        public void TestAttrIsArray()
+        {
+            string template = "hi <name>!";
+            Template st = new Template(template);
+            string[] names = new string[] { "Ter", "Tom" };
+            st.Add("name", names);
+            st.Add("name", "Sumana"); // shouldn't alter my version of names list!
+            string expected =
+                "hi TerTomSumana!";  // ST sees 3 names
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestProp()
+        {
+            string template = "<u.id>: <u.name>";
+            Template st = new Template(template);
+            st.Add("u", new User(1, "parrt"));
+            string expected = "1: parrt";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestInclude()
+        {
+            string template = "load <box()>;";
+            Template st = new Template(template);
+            st.code.nativeGroup.DefineTemplate("box",
+                                    "kewl" + newline +
+                                    "daddy"
+                                    );
+            st.Add("name", "Ter");
+            string expected =
+                "load kewl" + newline +
+                "daddy;";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestIncludeWithArg()
+        {
+            string template = "load <box(x=\"arg\")>;";
+            Template st = new Template(template);
+            st.code.nativeGroup.DefineTemplate("box", "kewl <x> daddy");
+            st.Add("name", "Ter");
+            string expected = "load kewl arg daddy;";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestIncludeWithSingleUnnamedArg()
+        {
+            string template = "load <box(\"arg\")>;";
+            Template st = new Template(template);
+            st.code.nativeGroup.DefineTemplate("box", new string[] { "x" }, "kewl <x> daddy");
+            st.Add("name", "Ter");
+            string expected = "load kewl arg daddy;";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestIncludeWithArg2()
+        {
+            string template = "load <box(x=\"arg\", y=foo())>;";
+            Template st = new Template(template);
+            st.code.nativeGroup.DefineTemplate("box", "kewl <x> <y> daddy");
+            st.code.nativeGroup.DefineTemplate("foo", "blech");
+            st.Add("name", "Ter");
+            string expected = "load kewl arg blech daddy;";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestIncludeWithNestedArgs()
+        {
+            string template = "load <box(y=foo(x=\"arg\"))>;";
+            Template st = new Template(template);
+            st.code.nativeGroup.DefineTemplate("box", "kewl <y> daddy");
+            st.code.nativeGroup.DefineTemplate("foo", "blech <x>");
+            st.Add("name", "Ter");
+            string expected = "load kewl blech arg daddy;";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestDefineTemplate()
+        {
+            TemplateGroup group = new TemplateGroup();
+            group.DefineTemplate("inc", "<it>+1");
+            group.DefineTemplate("test", "hi <name>!");
+            Template st = group.GetInstanceOf("test");
+            st.Add("name", "Ter");
+            st.Add("name", "Tom");
+            st.Add("name", "Sumana");
+            string expected =
+                "hi TerTomSumana!";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestMap()
+        {
+            TemplateGroup group = new TemplateGroup();
+            group.DefineTemplate("inc", "[<it>]");
+            group.DefineTemplate("test", "hi <name:inc>!");
+            Template st = group.GetInstanceOf("test");
+            st.Add("name", "Ter");
+            st.Add("name", "Tom");
+            st.Add("name", "Sumana");
+            string expected =
+                "hi [Ter][Tom][Sumana]!";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestParallelMap()
+        {
+            TemplateGroup group = new TemplateGroup();
+            group.DefineTemplate("test", "hi <names,phones:{n,p | <n>:<p>;}>");
+            Template st = group.GetInstanceOf("test");
+            st.Add("names", "Ter");
+            st.Add("names", "Tom");
+            st.Add("names", "Sumana");
+            st.Add("phones", "x5001");
+            st.Add("phones", "x5002");
+            st.Add("phones", "x5003");
+            string expected =
+                "hi Ter:x5001;Tom:x5002;Sumana:x5003;";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestParallelMapWith3Versus2Elements()
+        {
+            TemplateGroup group = new TemplateGroup();
+            group.DefineTemplate("test", "hi <names,phones:{n,p | <n>:<p>;}>");
+            Template st = group.GetInstanceOf("test");
+            st.Add("names", "Ter");
+            st.Add("names", "Tom");
+            st.Add("names", "Sumana");
+            st.Add("phones", "x5001");
+            st.Add("phones", "x5002");
+            string expected =
+                "hi Ter:x5001;Tom:x5002;Sumana:;";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestMapIndexes()
+        {
+            TemplateGroup group = new TemplateGroup();
+            group.DefineTemplate("inc", "<i>:<it>");
+            group.DefineTemplate("test", "<name:inc; separator=\", \">");
+            Template st = group.GetInstanceOf("test");
+            st.Add("name", "Ter");
+            st.Add("name", "Tom");
+            st.Add("name", null); // don't count this one
+            st.Add("name", "Sumana");
+            string expected =
+                "1:Ter, 2:Tom, 3:Sumana";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestMapSingleValue()
+        {
+            TemplateGroup group = new TemplateGroup();
+            group.DefineTemplate("a", "[<it>]");
+            group.DefineTemplate("test", "hi <name:a>!");
+            Template st = group.GetInstanceOf("test");
+            st.Add("name", "Ter");
+            string expected = "hi [Ter]!";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestRepeatedMap()
+        {
+            TemplateGroup group = new TemplateGroup();
+            group.DefineTemplate("a", "[<it>]");
+            group.DefineTemplate("b", "(<it>)");
+            group.DefineTemplate("test", "hi <name:a:b>!");
+            Template st = group.GetInstanceOf("test");
+            st.Add("name", "Ter");
+            st.Add("name", "Tom");
+            st.Add("name", "Sumana");
+            string expected =
+                "hi ([Ter])([Tom])([Sumana])!";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestRoundRobinMap()
+        {
+            TemplateGroup group = new TemplateGroup();
+            group.DefineTemplate("a", "[<it>]");
+            group.DefineTemplate("b", "(<it>)");
+            group.DefineTemplate("test", "hi <name:a,b>!");
+            Template st = group.GetInstanceOf("test");
+            st.Add("name", "Ter");
+            st.Add("name", "Tom");
+            st.Add("name", "Sumana");
+            string expected =
+                "hi [Ter](Tom)[Sumana]!";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestTrueCond()
+        {
+            string template = "<if(name)>works<endif>";
+            Template st = new Template(template);
+            st.Add("name", "Ter");
+            string expected = "works";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestFalseCond()
+        {
+            string template = "<if(name)>works<endif>";
+            Template st = new Template(template);
+            string expected = "";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestNotTrueCond()
+        {
+            string template = "<if(!name)>works<endif>";
+            Template st = new Template(template);
+            st.Add("name", "Ter");
+            string expected = "";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestNotFalseCond()
+        {
+            string template = "<if(!name)>works<endif>";
+            Template st = new Template(template);
+            string expected = "works";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestTrueCondWithElse()
+        {
+            string template = "<if(name)>works<else>fail<endif>";
+            Template st = new Template(template);
+            st.Add("name", "Ter");
+            string expected = "works";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestFalseCondWithElse()
+        {
+            string template = "<if(name)>fail<else>works<endif>";
+            Template st = new Template(template);
+            string expected = "works";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestElseIf()
+        {
+            string template = "<if(name)>fail<elseif(id)>works<else>fail<endif>";
+            Template st = new Template(template);
+            st.Add("id", "2DF3DF");
+            string expected = "works";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestElseIfNoElseAllFalse()
+        {
+            string template = "<if(name)>fail<elseif(id)>fail<endif>";
+            Template st = new Template(template);
+            string expected = "";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestElseIfAllExprFalse()
+        {
+            string template = "<if(name)>fail<elseif(id)>fail<else>works<endif>";
+            Template st = new Template(template);
+            string expected = "works";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestOr()
+        {
+            string template = "<if(name||notThere)>works<else>fail<endif>";
+            Template st = new Template(template);
+            st.Add("name", "Ter");
+            string expected = "works";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestAnd()
+        {
+            string template = "<if(name&&notThere)>fail<else>works<endif>";
+            Template st = new Template(template);
+            st.Add("name", "Ter");
+            string expected = "works";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestAndNot()
+        {
+            string template = "<if(name&&!notThere)>works<else>fail<endif>";
+            Template st = new Template(template);
+            st.Add("name", "Ter");
+            string expected = "works";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestITDoesntPropagate()
+        {
+            TemplateGroup group = new TemplateGroup();
+            group.DefineTemplate("foo", "<it>");   // <it> not visible
+            string template = "<names:{<foo()>}>"; // <it> visible only to {...} here
+            group.DefineTemplate("test", template);
+            Template st = group.GetInstanceOf("test");
+            st.Add("names", "Ter");
+            st.Add("names", "Tom");
+            string expected = "";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestCharLiterals()
+        {
+            Template st = new Template(
+                    "Foo <\\n><\\n><\\t> bar\n"
+                    );
+            StringWriter sw = new StringWriter();
+            st.Write(new AutoIndentWriter(sw, "\n")); // force \n as newline
+            string result = sw.ToString();
+            string expecting = "Foo \n\n\t bar\n";     // expect \n in output
+            Assert.AreEqual(expecting, result);
+
+            st = new Template(
+                    "Foo <\\n><\\t> bar" + newline);
+            sw = new StringWriter();
+            st.Write(new AutoIndentWriter(sw, "\n")); // force \n as newline
+            expecting = "Foo \n\t bar\n";     // expect \n in output
+            result = sw.ToString();
+            Assert.AreEqual(expecting, result);
+
+            st = new Template(
+                    "Foo<\\ >bar<\\n>");
+            sw = new StringWriter();
+            st.Write(new AutoIndentWriter(sw, "\n")); // force \n as newline
+            result = sw.ToString();
+            expecting = "Foo bar\n"; // forced \n
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestUnicodeLiterals()
+        {
+            Template st = new Template(
+                    "Foo <\\uFEA5><\\n><\\u00C2> bar\n"
+                    );
+            string expecting = "Foo \ufea5" + newline + "\u00C2 bar" + newline;
+            string result = st.Render();
+            Assert.AreEqual(expecting, result);
+
+            st = new Template(
+                    "Foo <\\uFEA5><\\n><\\u00C2> bar" + newline);
+            expecting = "Foo \ufea5" + newline + "\u00C2 bar" + newline;
+            result = st.Render();
+            Assert.AreEqual(expecting, result);
+
+            st = new Template(
+                    "Foo<\\ >bar<\\n>");
+            expecting = "Foo bar" + newline;
+            result = st.Render();
+            Assert.AreEqual(expecting, result);
+        }
+    }
+}
diff --git a/Antlr3.Test/ST4/TestDictionaries.cs b/Antlr3.Test/ST4/TestDictionaries.cs
new file mode 100644
index 0000000..95063be
--- /dev/null
+++ b/Antlr3.Test/ST4/TestDictionaries.cs
@@ -0,0 +1,265 @@
+﻿namespace AntlrUnitTests.ST4
+{
+    using System.Collections.Generic;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using StringTemplate;
+    using Path = System.IO.Path;
+
+    [TestClass]
+    public class TestDictionaries : StringTemplateTestBase
+    {
+        [TestMethod]
+        public void TestDict()
+        {
+            string templates =
+                    "typeInit ::= [\"int\":\"0\", \"float\":\"0.0\"] " + newline +
+                    "var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
+                    ;
+            WriteFile(tmpdir, "test.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "test.stg"));
+            Template st = group.GetInstanceOf("var");
+            st.Add("type", "int");
+            st.Add("name", "x");
+            string expecting = "int x = 0;";
+            string result = st.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDictValuesAreTemplates()
+        {
+            string templates =
+                    "typeInit ::= [\"int\":{0<w>}, \"float\":{0.0<w>}] " + newline +
+                    "var(type,w,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
+                    ;
+            WriteFile(tmpdir, "test.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "test.stg"));
+            Template st = group.GetInstanceOf("var");
+            st.Add("w", "L");
+            st.Add("type", "int");
+            st.Add("name", "x");
+            string expecting = "int x = 0L;";
+            string result = st.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDictKeyLookupViaTemplate()
+        {
+            // Make sure we try rendering stuff to string if not found as regular object
+            string templates =
+                    "typeInit ::= [\"int\":{0<w>}, \"float\":{0.0<w>}] " + newline +
+                    "var(type,w,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
+                    ;
+            WriteFile(tmpdir, "test.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "test.stg"));
+            Template st = group.GetInstanceOf("var");
+            st.Add("w", "L");
+            st.Add("type", new Template("int"));
+            st.Add("name", "x");
+            string expecting = "int x = 0L;";
+            string result = st.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDictKeyLookupAsNonToStringableObject()
+        {
+            // Make sure we try rendering stuff to string if not found as regular object
+            string templates =
+                    "foo(m,k) ::= \"<m.(k)>\"" + newline
+                    ;
+            WriteFile(tmpdir, "test.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "test.stg"));
+            Template st = group.GetInstanceOf("foo");
+            IDictionary<HashableUser, string> m = new Dictionary<HashableUser, string>();
+            m[new HashableUser(99, "parrt")] = "first";
+            m[new HashableUser(172036, "tombu")] = "second";
+            m[new HashableUser(391, "sriram")] = "third";
+            st.Add("m", m);
+            st.Add("k", new HashableUser(172036, "tombu"));
+            string expecting = "second";
+            string result = st.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDictMissingDefaultValueIsEmpty()
+        {
+            string templates =
+                    "typeInit ::= [\"int\":\"0\", \"float\":\"0.0\"] " + newline +
+                    "var(type,w,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
+                    ;
+            WriteFile(tmpdir, "test.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "test.stg"));
+            Template st = group.GetInstanceOf("var");
+            st.Add("w", "L");
+            st.Add("type", "double"); // double not in typeInit map
+            st.Add("name", "x");
+            string expecting = "double x = ;"; // weird, but tests default value is key
+            string result = st.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDictHiddenByFormalArg()
+        {
+            string templates =
+                    "typeInit ::= [\"int\":\"0\", \"float\":\"0.0\"] " + newline +
+                    "var(typeInit,type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
+                    ;
+            WriteFile(tmpdir, "test.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "test.stg"));
+            Template st = group.GetInstanceOf("var");
+            st.Add("type", "int");
+            st.Add("name", "x");
+            string expecting = "int x = ;";
+            string result = st.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDictEmptyValueAndAngleBracketStrings()
+        {
+            string templates =
+                    "typeInit ::= [\"int\":\"0\", \"float\":, \"double\":<<0.0L>>] " + newline +
+                    "var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
+                    ;
+            WriteFile(tmpdir, "test.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "test.stg"));
+            Template st = group.GetInstanceOf("var");
+            st.Add("type", "float");
+            st.Add("name", "x");
+            string expecting = "float x = ;";
+            string result = st.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDictDefaultValue()
+        {
+            string templates =
+                    "typeInit ::= [\"int\":\"0\", default:\"null\"] " + newline +
+                    "var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
+                    ;
+            WriteFile(tmpdir, "test.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "test.stg"));
+            Template st = group.GetInstanceOf("var");
+            st.Add("type", "UserRecord");
+            st.Add("name", "x");
+            string expecting = "UserRecord x = null;";
+            string result = st.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDictEmptyDefaultValue()
+        {
+            string templates =
+                    "typeInit ::= [\"int\":\"0\", default:] " + newline +
+                    "var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
+                    ;
+            WriteFile(tmpdir, "test.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "test.stg"));
+            Template st = group.GetInstanceOf("var");
+            st.Add("type", "UserRecord");
+            st.Add("name", "x");
+            string expecting = "UserRecord x = ;";
+            string result = st.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDictDefaultValueIsKey()
+        {
+            string templates =
+                    "typeInit ::= [\"int\":\"0\", default:key] " + newline +
+                    "var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
+                    ;
+            WriteFile(tmpdir, "test.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "test.stg"));
+            Template st = group.GetInstanceOf("var");
+            st.Add("type", "UserRecord");
+            st.Add("name", "x");
+            string expecting = "UserRecord x = UserRecord;";
+            string result = st.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        /**
+         * Test that a map can have only the default entry.
+         */
+        [TestMethod]
+        public void TestDictDefaultStringAsKey()
+        {
+            string templates =
+                    "typeInit ::= [\"default\":\"foo\"] " + newline +
+                    "var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
+                    ;
+            WriteFile(tmpdir, "test.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "test.stg"));
+            Template st = group.GetInstanceOf("var");
+            st.Add("type", "default");
+            st.Add("name", "x");
+            string expecting = "default x = foo;";
+            string result = st.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        /**
+         * Test that a map can return a <b>string</b> with the word: default.
+         */
+        [TestMethod]
+        public void TestDictDefaultIsDefaultString()
+        {
+            string templates =
+                    "map ::= [default: \"default\"] " + newline +
+                    "t() ::= << <map.(\"1\")> >>" + newline
+                    ;
+            WriteFile(tmpdir, "test.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "test.stg"));
+            Template st = group.GetInstanceOf("t");
+            string expecting = " default ";
+            string result = st.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDictViaEnclosingTemplates()
+        {
+            string templates =
+                    "typeInit ::= [\"int\":\"0\", \"float\":\"0.0\"] " + newline +
+                    "intermediate(type,name) ::= \"<var(...)>\"" + newline +
+                    "var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
+                    ;
+            WriteFile(tmpdir, "test.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "test.stg"));
+            Template st = group.GetInstanceOf("intermediate");
+            st.Add("type", "int");
+            st.Add("name", "x");
+            string expecting = "int x = 0;";
+            string result = st.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestDictViaEnclosingTemplates2()
+        {
+            string templates =
+                    "typeInit ::= [\"int\":\"0\", \"float\":\"0.0\"] " + newline +
+                    "intermediate(stuff) ::= \"<stuff>\"" + newline +
+                    "var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
+                    ;
+            WriteFile(tmpdir, "test.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "test.stg"));
+            Template interm = group.GetInstanceOf("intermediate");
+            Template var = group.GetInstanceOf("var");
+            var.Add("type", "int");
+            var.Add("name", "x");
+            interm.Add("stuff", var);
+            string expecting = "int x = 0;";
+            string result = interm.Render();
+            Assert.AreEqual(expecting, result);
+        }
+    }
+}
diff --git a/Antlr3.Test/ST4/TestDollarDelimiters.cs b/Antlr3.Test/ST4/TestDollarDelimiters.cs
new file mode 100644
index 0000000..b882977
--- /dev/null
+++ b/Antlr3.Test/ST4/TestDollarDelimiters.cs
@@ -0,0 +1,79 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace AntlrUnitTests.ST4
+{
+    public class TestDollarDelimiters : StringTemplateTestBase
+    {
+        /*
+        @Test public void testSimpleAttr() throws Exception {
+            String template = "hi $name$";
+            List<Chunk> chunks = new Chunkifier(template, '$', '$').chunkify();
+            String expected = "[1:0..2:hi , 1:4..7:name]";
+            String result = chunks.toString();
+            assertEquals(expected, result);
+        }
+
+        @Test public void testString() throws Exception {
+            String template = "hi $foo(a=\"$\")$";
+            List<Chunk> chunks = new Chunkifier(template, '$', '$').chunkify();
+            String expected = "[1:0..2:hi , 1:4..13:foo(a=\"$\")]";
+            String result = chunks.toString();
+            assertEquals(expected, result);
+        }
+
+        @Test public void testEscInString() throws Exception {
+            String template = "hi $foo(a=\"$\\\"\")$";
+            List<Chunk> chunks = new Chunkifier(template, '$', '$').chunkify();
+            String expected = "[1:0..2:hi , 1:4..15:foo(a=\"$\\\"\")]";
+            String result = chunks.toString();
+            assertEquals(expected, result);
+        }
+
+        @Test public void testSubtemplate() throws Exception {
+            String template = "hi $names:{n | $n$}$";
+            List<Chunk> chunks = new Chunkifier(template, '$', '$').chunkify();
+            String expected = "[1:0..2:hi , 1:4..18:names:{n | $n$}]";
+            String result = chunks.toString();
+            assertEquals(expected, result);
+        }
+
+        @Test public void testNestedSubtemplate() throws Exception {
+            String template = "hi $names:{n | $n:{$it$}$}$";
+            List<Chunk> chunks = new Chunkifier(template, '$', '$').chunkify();
+            String expected = "[1:0..2:hi , 1:4..25:names:{n | $n:{$it$}$}]";
+            String result = chunks.toString();
+            assertEquals(expected, result);
+        }
+        */
+    }
+}
diff --git a/Antlr3.Test/ST4/TestFunctions.cs b/Antlr3.Test/ST4/TestFunctions.cs
new file mode 100644
index 0000000..8a97432
--- /dev/null
+++ b/Antlr3.Test/ST4/TestFunctions.cs
@@ -0,0 +1,403 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace AntlrUnitTests.ST4
+{
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using StringTemplate;
+    using ArrayList = System.Collections.ArrayList;
+    using Hashtable = System.Collections.Hashtable;
+    using IDictionary = System.Collections.IDictionary;
+    using Path = System.IO.Path;
+
+    [TestClass]
+    public class TestFunctions : StringTemplateTestBase
+    {
+        [TestMethod]
+        public void TestFirst()
+        {
+            string template = "<first(names)>";
+            Template st = new Template(template);
+            var names = new ArrayList() { "Ter", "Tom" };
+            st.Add("names", names);
+            string expected = "Ter";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestLength()
+        {
+            string template = "<length(names)>";
+            Template st = new Template(template);
+            var names = new ArrayList() { "Ter", "Tom" };
+            st.Add("names", names);
+            string expected = "2";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestFirstOp()
+        {
+            Template e = new Template(
+                    "<first(names)>"
+                );
+            e.Add("names", "Ter");
+            e.Add("names", "Tom");
+            e.Add("names", "Sriram");
+            string expecting = "Ter";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestTruncOp()
+        {
+            Template e = new Template(
+                    "<trunc(names); separator=\", \">"
+                );
+            e.Add("names", "Ter");
+            e.Add("names", "Tom");
+            e.Add("names", "Sriram");
+            string expecting = "Ter, Tom";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestRestOp()
+        {
+            Template e = new Template(
+                    "<rest(names); separator=\", \">"
+                );
+            e.Add("names", "Ter");
+            e.Add("names", "Tom");
+            e.Add("names", "Sriram");
+            string expecting = "Tom, Sriram";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestRestOpEmptyList()
+        {
+            Template e = new Template(
+                    "<rest(names); separator=\", \">"
+                );
+            e.Add("names", new ArrayList());
+            string expecting = "";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestReUseOfRestResult()
+        {
+            string templates =
+                "a(names) ::= \"<b(rest(names))>\"" + newline +
+                "b(x) ::= \"<x>, <x>\"" + newline
+                ;
+            WriteFile(tmpdir, "t.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
+            Template e = group.GetInstanceOf("a");
+            var names = new ArrayList();
+            names.Add("Ter");
+            names.Add("Tom");
+            e.Add("names", names);
+            string expecting = "Tom, Tom";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestLastOp()
+        {
+            Template e = new Template(
+                    "<last(names)>"
+                );
+            e.Add("names", "Ter");
+            e.Add("names", "Tom");
+            e.Add("names", "Sriram");
+            string expecting = "Sriram";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestCombinedOp()
+        {
+            // replace first of yours with first of mine
+            Template e = new Template(
+                    "<[first(mine),rest(yours)]; separator=\", \">"
+                );
+            e.Add("mine", "1");
+            e.Add("mine", "2");
+            e.Add("mine", "3");
+            e.Add("yours", "a");
+            e.Add("yours", "b");
+            string expecting = "1, b";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestCatListAndSingleAttribute()
+        {
+            // replace first of yours with first of mine
+            Template e = new Template(
+                    "<[mine,yours]; separator=\", \">"
+                );
+            e.Add("mine", "1");
+            e.Add("mine", "2");
+            e.Add("mine", "3");
+            e.Add("yours", "a");
+            string expecting = "1, 2, 3, a";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestReUseOfCat()
+        {
+            string templates =
+                "a(mine,yours) ::= \"<b([mine,yours])>\"" + newline +
+                "b(x) ::= \"<x>, <x>\"" + newline
+                ;
+            WriteFile(tmpdir, "t.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
+            Template e = group.GetInstanceOf("a");
+            var mine = new ArrayList();
+            mine.Add("Ter");
+            mine.Add("Tom");
+            e.Add("mine", mine);
+            var yours = new ArrayList();
+            yours.Add("Foo");
+            e.Add("yours", yours);
+            string expecting = "TerTomFoo, TerTomFoo";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestCatListAndEmptyAttributes()
+        {
+            // + is overloaded to be cat strings and cat lists so the
+            // two operands (from left to right) determine which way it
+            // goes.  In this case, x+mine is a list so everything from their
+            // to the right becomes list cat.
+            Template e = new Template(
+                    "<[x,mine,y,yours,z]; separator=\", \">"
+                );
+            e.Add("mine", "1");
+            e.Add("mine", "2");
+            e.Add("mine", "3");
+            e.Add("yours", "a");
+            string expecting = "1, 2, 3, a";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestNestedOp()
+        {
+            Template e = new Template(
+                    "<first(rest(names))>" // gets 2nd element
+                );
+            e.Add("names", "Ter");
+            e.Add("names", "Tom");
+            e.Add("names", "Sriram");
+            string expecting = "Tom";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestFirstWithOneAttributeOp()
+        {
+            Template e = new Template(
+                    "<first(names)>"
+                );
+            e.Add("names", "Ter");
+            string expecting = "Ter";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestLastWithOneAttributeOp()
+        {
+            Template e = new Template(
+                    "<last(names)>"
+                );
+            e.Add("names", "Ter");
+            string expecting = "Ter";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestLastWithLengthOneListAttributeOp()
+        {
+            Template e = new Template(
+                    "<last(names)>"
+                );
+            e.Add("names", new ArrayList() { "Ter" });
+            string expecting = "Ter";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestRestWithOneAttributeOp()
+        {
+            Template e = new Template(
+                    "<rest(names)>"
+                );
+            e.Add("names", "Ter");
+            string expecting = "";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestRestWithLengthOneListAttributeOp()
+        {
+            Template e = new Template(
+                    "<rest(names)>"
+                );
+            e.Add("names", new ArrayList() { "Ter" });
+            string expecting = "";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestRepeatedRestOp()
+        {
+            Template e = new Template(
+                    "<rest(names)>, <rest(names)>" // gets 2nd element
+                );
+            e.Add("names", "Ter");
+            e.Add("names", "Tom");
+            string expecting = "Tom, Tom";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestIncomingLists()
+        {
+            Template e = new Template(
+                    "<rest(names)>, <rest(names)>" // gets 2nd element
+                );
+            e.Add("names", "Ter");
+            e.Add("names", "Tom");
+            string expecting = "Tom, Tom";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestFirstWithCatAttribute()
+        {
+            Template e = new Template(
+                    "<first([names,phones])>"
+                );
+            e.Add("names", "Ter");
+            e.Add("names", "Tom");
+            e.Add("phones", "1");
+            e.Add("phones", "2");
+            string expecting = "Ter";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestFirstWithListOfMaps()
+        {
+            Template e = new Template(
+                    "<first(maps).Ter>"
+                );
+            IDictionary m1 = new Hashtable();
+            IDictionary m2 = new Hashtable();
+            m1["Ter"] = "x5707";
+            e.Add("maps", m1);
+            m2["Tom"] = "x5332";
+            e.Add("maps", m2);
+            string expecting = "x5707";
+            Assert.AreEqual(expecting, e.Render());
+
+            var list = new ArrayList() { m1, m2 };
+            e.Add("maps", list);
+            expecting = "x5707";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestFirstWithListOfMaps2()
+        {
+            Template e = new Template(
+                    "<first(maps):{ m | <m>!}>"
+                );
+            IDictionary m1 = new Hashtable();
+            IDictionary m2 = new Hashtable();
+            m1["Ter"] = "x5707";
+            e.Add("maps", m1);
+            m2["Tom"] = "x5332";
+            e.Add("maps", m2);
+            string expecting = "x5707!";
+            Assert.AreEqual(expecting, e.Render());
+            var list = new ArrayList() { m1, m2 };
+            e.Add("maps", list);
+            expecting = "x5707!";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestTrim()
+        {
+            Template e = new Template(
+                    "<trim(name)>"
+                );
+            e.Add("name", " Ter  \n");
+            string expecting = "Ter";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestStrlen()
+        {
+            Template e = new Template(
+                    "<strlen(name)>"
+                );
+            e.Add("name", "012345");
+            string expecting = "6";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestReverse()
+        {
+            Template e = new Template(
+                    "<reverse(names); separator=\", \">"
+                );
+            e.Add("names", "Ter");
+            e.Add("names", "Tom");
+            e.Add("names", "Sriram");
+            string expecting = "Sriram, Tom, Ter";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+    }
+}
diff --git a/Antlr3.Test/ST4/TestGroupSyntax.cs b/Antlr3.Test/ST4/TestGroupSyntax.cs
new file mode 100644
index 0000000..ce0d816
--- /dev/null
+++ b/Antlr3.Test/ST4/TestGroupSyntax.cs
@@ -0,0 +1,180 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace AntlrUnitTests.ST4
+{
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using Path = System.IO.Path;
+    using STGroup = StringTemplate.TemplateGroup;
+    using STGroupFile = StringTemplate.TemplateGroupFile;
+    using String = System.String;
+
+    [TestClass]
+    public class TestGroupSyntax : StringTemplateTestBase
+    {
+        [TestMethod]
+        public void TestSimpleGroup()
+        {
+            String templates =
+                "t() ::= <<foo>>" + newline;
+
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            String expected =
+                "t() ::= <<" + newline +
+                "foo" + newline +
+                ">>" + newline;
+            String result = group.Show();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestMultiTemplates()
+        {
+            String templates =
+                "ta() ::= \"[<it>]\"" + newline +
+                "duh() ::= <<hi there>>" + newline +
+                "wow() ::= <<last>>" + newline;
+
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            String expected =
+                "ta() ::= <<" + newline +
+                "[<it>]" + newline +
+                ">>" + newline +
+                "duh() ::= <<" + newline +
+                "hi there" + newline +
+                ">>" + newline +
+                "wow() ::= <<" + newline +
+                "last" + newline +
+                ">>" + newline;
+            String result = group.Show();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSingleTemplateWithArgs()
+        {
+            String templates =
+                "t(a,b) ::= \"[<a>]\"" + newline;
+
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            String expected =
+                "t(a,b) ::= <<" + newline +
+                "[<a>]" + newline +
+                ">>" + newline;
+            String result = group.Show();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestDefaultValues()
+        {
+            String templates =
+                "t(a={def1},b=\"def2\") ::= \"[<a>]\"" + newline;
+
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            String expected =
+                "t(a={def1},b=\"def2\") ::= <<" + newline +
+                "[<a>]" + newline +
+                ">>" + newline;
+            String result = group.Show();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestDefaultValueTemplateWithArg()
+        {
+            String templates =
+                "t(a={x | 2*<x>}) ::= \"[<a>]\"" + newline;
+
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            String expected =
+                "t(a={x | 2*<x>}) ::= <<" + newline +
+                "[<a>]" + newline +
+                ">>" + newline;
+            String result = group.Show();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestNestedTemplateInGroupFile()
+        {
+            String templates =
+                "t(a) ::= \"<a:{x | <x:{<it>}>}>\"" + newline;
+
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            String expected =
+                "t(a) ::= <<\n" +
+                "<a:{x | <x:{<it>}>}>\n" +
+                ">>" + newline;
+            String result = group.Show();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestNestedDefaultValueTemplate()
+        {
+            String templates =
+                "t(a={x | <x:{<it>}>}) ::= \"ick\"" + newline;
+
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            String expected =
+                "t(a={x | <x:{<it>}>}) ::= <<\n" +
+                "ick\n" +
+                ">>" + newline;
+            String result = group.Show();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestNestedDefaultValueTemplateWithEscapes()
+        {
+            String templates =
+                "t(a={x | \\< <x:{<it>\\}}>}) ::= \"[<a>]\"" + newline;
+
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            String expected =
+                "t(a={x | \\< <x:{<it>\\}}>}) ::= <<" + newline +
+                "[<a>]" + newline +
+                ">>" + newline;
+            String result = group.Show();
+            Assert.AreEqual(expected, result);
+        }
+    }
+}
diff --git a/Antlr3.Test/ST4/TestGroups.cs b/Antlr3.Test/ST4/TestGroups.cs
new file mode 100644
index 0000000..7a93518
--- /dev/null
+++ b/Antlr3.Test/ST4/TestGroups.cs
@@ -0,0 +1,281 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace AntlrUnitTests.ST4
+{
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using ArgumentException = System.ArgumentException;
+    using Path = System.IO.Path;
+    using ST = StringTemplate.Template;
+    using STGroup = StringTemplate.TemplateGroup;
+    using STGroupDir = StringTemplate.TemplateGroupDirectory;
+    using STGroupFile = StringTemplate.TemplateGroupFile;
+    using String = System.String;
+
+    [TestClass]
+    public class TestGroups : StringTemplateTestBase
+    {
+        [TestMethod]
+        public void TestSimpleGroup()
+        {
+            String dir = GetRandomDir();
+            String a =
+                "a(x) ::= <<" + newline +
+                "foo" + newline +
+                ">>" + newline;
+            WriteFile(dir, "a.st", a);
+            STGroup group = new STGroupDir(dir);
+            ST st = group.GetInstanceOf("a");
+            String expected = "foo" + newline;
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestGroupWithTwoTemplates()
+        {
+            String dir = GetRandomDir();
+            String a =
+                "a(x) ::= <<" + newline +
+                "foo" + newline +
+                ">>" + newline;
+            WriteFile(dir, "a.st", a);
+            String b =
+                "b() ::= \"bar\"" + newline;
+            WriteFile(dir, "b.st", b);
+            STGroup group = new STGroupDir(dir);
+            ST st1 = group.GetInstanceOf("a");
+            ST st2 = group.GetInstanceOf("b");
+            String expected = "foo" + newline + "bar";
+            String result = st1.Render() + st2.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSubdir()
+        {
+            // /randomdir/a and /randomdir/subdir/b
+            String dir = GetRandomDir();
+            String a =
+                "a(x) ::= <<" + newline +
+                "foo" + newline +
+                ">>" + newline;
+            WriteFile(dir, "a.st", a);
+            String b =
+                "b() ::= \"bar\"" + newline;
+            WriteFile(Path.Combine(dir, "subdir"), "b.st", b);
+            STGroup group = new STGroupDir(dir);
+            ST st1 = group.GetInstanceOf("a");
+            ST st2 = group.GetInstanceOf("subdir/b");
+            String expected = "foo" + newline + "bar";
+            String result = st1.Render() + st2.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestGroupFileInDir()
+        {
+            // /randomdir/a and /randomdir/group.stg with b and c templates
+            String dir = GetRandomDir();
+            String a =
+                "a(x) ::= <<\n" +
+                "foo\n" +
+                ">>\n";
+            WriteFile(dir, "a.st", a);
+            String groupFile =
+                "b() ::= \"bar\"\n" +
+                "c() ::= \"duh\"\n";
+            WriteFile(dir, "group.stg", groupFile);
+            STGroup group = new STGroupDir(dir);
+            ST st1 = group.GetInstanceOf("a");
+            ST st2 = group.GetInstanceOf("group/b");
+            ST st3 = group.GetInstanceOf("group/c");
+            String expected = "foo" + newline + "barduh";
+            String result = st1.Render() + st2.Render() + st3.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSubSubdir()
+        {
+            // /randomdir/a and /randomdir/subdir/b
+            String dir = GetRandomDir();
+            String a =
+                "a(x) ::= <<" + newline +
+                "foo" + newline +
+                ">>" + newline;
+            WriteFile(dir, "a.st", a);
+            String b =
+                "b() ::= \"bar\"" + newline;
+            WriteFile(Path.Combine(Path.Combine(dir, "sub1"), "sub2"), "b.st", b);
+            STGroup group = new STGroupDir(dir);
+            ST st1 = group.GetInstanceOf("a");
+            ST st2 = group.GetInstanceOf("sub1/sub2/b");
+            String expected = "foo" + newline + "bar";
+            String result = st1.Render() + st2.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestGroupFileInSubDir()
+        {
+            // /randomdir/a and /randomdir/group.stg with b and c templates
+            String dir = GetRandomDir();
+            String a =
+                "a(x) ::= <<\n" +
+                "foo\n" +
+                ">>\n";
+            WriteFile(dir, "a.st", a);
+            String groupFile =
+                "b() ::= \"bar\"\n" +
+                "c() ::= \"duh\"\n";
+            WriteFile(dir, Path.Combine("subdir", "group.stg"), groupFile);
+            STGroup group = new STGroupDir(dir);
+            ST st1 = group.GetInstanceOf("a");
+            ST st2 = group.GetInstanceOf("subdir/group/b");
+            ST st3 = group.GetInstanceOf("subdir/group/c");
+            String expected = "foo" + newline + "barduh";
+            String result = st1.Render() + st2.Render() + st3.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestAttemptToAccessTemplateUnderGroupFile()
+        {
+            String dir = GetRandomDir();
+            String groupFile =
+                "a() ::= \"bar\"\n";
+            WriteFile(dir, "group.stg", groupFile);
+            STGroup group = new STGroupFile(Path.Combine(dir, "group.stg"));
+            String error = null;
+            try
+            {
+                group.GetInstanceOf("sub/b"); // can't have sub under group file
+            }
+            catch (ArgumentException iae)
+            {
+                error = iae.Message;
+            }
+            String expected = "can't use relative template name sub/b";
+            String result = error;
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestAttemptToUseWrongGroupFileNameFromRoot()
+        {
+            String dir = GetRandomDir();
+            String groupFile =
+                "a() ::= \"bar\"\n";
+            WriteFile(dir, "group.stg", groupFile);
+            STGroup group = new STGroupFile(Path.Combine(dir, "group.stg"));
+            String error = null;
+            try
+            {
+                group.GetInstanceOf("/sub/a"); // can't have sub under group file
+            }
+            catch (ArgumentException iae)
+            {
+                error = iae.Message;
+            }
+            String expected = "name must be of form /group/templatename: /sub/a";
+            String result = error;
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestAttemptToGoTooDeepUsingGroupFileNameFromRoot()
+        {
+            String dir = GetRandomDir();
+            String groupFile =
+                "a() ::= \"bar\"\n";
+            WriteFile(dir, "group.stg", groupFile);
+            STGroup group = new STGroupFile(Path.Combine(dir, "group.stg"));
+            String error = null;
+            try
+            {
+                group.GetInstanceOf("/gropu/b/b"); // can't have sub under group file
+            }
+            catch (ArgumentException iae)
+            {
+                error = iae.Message;
+            }
+            String expected = "name must be of form /group/templatename: /gropu/b/b";
+            String result = error;
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestAttemptToAccessDirWithSameNameAsTemplate()
+        {
+            String dir = GetRandomDir();
+            String a =
+                "a(x) ::= <<foo>>\n";
+            WriteFile(dir, "a.st", a);
+            STGroup group = new STGroupDir(dir);
+            String error = null;
+            try
+            {
+                group.GetInstanceOf("a/b"); // 'a' is a template
+            }
+            catch (ArgumentException iae)
+            {
+                error = iae.Message;
+            }
+            String expected = "a is a template not a dir or group file";
+            String result = error;
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestAttemptToAccessSubDirWithWrongRootName()
+        {
+            String dir = GetRandomDir();
+            String a =
+                "a(x) ::= <<foo>>\n";
+            WriteFile(dir + "/subdir", "a.st", a);
+            STGroup group = new STGroupDir(Path.Combine(dir, "subdir"));
+            String error = null;
+            try
+            {
+                group.GetInstanceOf("/x/b"); // name is subdir not x
+            }
+            catch (ArgumentException iae)
+            {
+                error = iae.Message;
+            }
+            String expected = "x doesn't match directory name subdir";
+            String result = error;
+            Assert.AreEqual(expected, result);
+        }
+    }
+}
diff --git a/Antlr3.Test/ST4/TestIndentation.cs b/Antlr3.Test/ST4/TestIndentation.cs
new file mode 100644
index 0000000..30bbcaa
--- /dev/null
+++ b/Antlr3.Test/ST4/TestIndentation.cs
@@ -0,0 +1,318 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace AntlrUnitTests.ST4
+{
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using StringTemplate;
+    using Path = System.IO.Path;
+    using STErrorListener = StringTemplate.ITemplateErrorListener;
+    using STGroup = StringTemplate.TemplateGroup;
+    using STGroupFile = StringTemplate.TemplateGroupFile;
+    using String = System.String;
+
+    [TestClass]
+    public class TestIndentation : StringTemplateTestBase
+    {
+        [TestMethod]
+        public void TestSimpleIndentOfAttributeList()
+        {
+            String templates =
+                    "list(names) ::= <<" +
+                    "  <names; separator=\"\\n\">" + newline +
+                    ">>" + newline;
+
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            STErrorListener errors = new ErrorBuffer();
+            group.SetErrorListener(errors);
+            Template t = group.GetInstanceOf("list");
+            t.Add("names", "Terence");
+            t.Add("names", "Jim");
+            t.Add("names", "Sriram");
+            String expecting =
+                    "  Terence" + newline +
+                    "  Jim" + newline +
+                    "  Sriram" + newline;
+            Assert.AreEqual(expecting, t.Render());
+        }
+
+        [TestMethod]
+        public void TestIndentOfMultilineAttributes()
+        {
+            String templates =
+                    "list(names) ::= <<" +
+                    "  <names; separator=\"\n\">" + newline +
+                    ">>" + newline;
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            STErrorListener errors = new ErrorBuffer();
+            group.SetErrorListener(errors);
+            Template t = group.GetInstanceOf("list");
+            t.Add("names", "Terence\nis\na\nmaniac");
+            t.Add("names", "Jim");
+            t.Add("names", "Sriram\nis\ncool");
+            String expecting =
+                    "  Terence" + newline +
+                    "  is" + newline +
+                    "  a" + newline +
+                    "  maniac" + newline +
+                    "  Jim" + newline +
+                    "  Sriram" + newline +
+                    "  is" + newline +
+                    "  cool" + newline;
+            Assert.AreEqual(expecting, t.Render());
+        }
+
+        [TestMethod]
+        public void TestIndentOfMultipleBlankLines()
+        {
+            String templates =
+                    "list(names) ::= <<" +
+                    "  <names>" + newline +
+                    ">>" + newline;
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            STErrorListener errors = new ErrorBuffer();
+            group.SetErrorListener(errors);
+            Template t = group.GetInstanceOf("list");
+            t.Add("names", "Terence\n\nis a maniac");
+            String expecting =
+                    "  Terence" + newline +
+                    "" + newline + // no indent on blank line
+                    "  is a maniac" + newline;
+            Assert.AreEqual(expecting, t.Render());
+        }
+
+        [TestMethod]
+        public void TestIndentBetweenLeftJustifiedLiterals()
+        {
+            String templates =
+                    "list(names) ::= <<" +
+                    "Before:" + newline +
+                    "  <names; separator=\"\\n\">" + newline +
+                    "after" + newline +
+                    ">>" + newline;
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            STErrorListener errors = new ErrorBuffer();
+            group.SetErrorListener(errors);
+            Template t = group.GetInstanceOf("list");
+            t.Add("names", "Terence");
+            t.Add("names", "Jim");
+            t.Add("names", "Sriram");
+            String expecting =
+                    "Before:" + newline +
+                    "  Terence" + newline +
+                    "  Jim" + newline +
+                    "  Sriram" + newline +
+                    "after" + newline;
+            Assert.AreEqual(expecting, t.Render());
+        }
+
+        [TestMethod]
+        public void TestNestedIndent()
+        {
+            String templates =
+                    "method(name,stats) ::= <<" +
+                    "void <name>() {" + newline +
+                    "\t<stats; separator=\"\\n\">" + newline +
+                    "}" + newline +
+                    ">>" + newline +
+                    "ifstat(expr,stats) ::= <<" + newline +
+                    "if (<expr>) {" + newline +
+                    "  <stats; separator=\"\\n\">" + newline +
+                    "}" +
+                    ">>" + newline +
+                    "assign(lhs,expr) ::= <<<lhs>=<expr>;>>" + newline
+                    ;
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            STErrorListener errors = new ErrorBuffer();
+            group.SetErrorListener(errors);
+
+            Template t = group.GetInstanceOf("method");
+            t.Add("name", "foo");
+            Template s1 = group.GetInstanceOf("assign");
+            s1.Add("lhs", "x");
+            s1.Add("expr", "0");
+            Template s2 = group.GetInstanceOf("ifstat");
+            s2.Add("expr", "x>0");
+            Template s2a = group.GetInstanceOf("assign");
+            s2a.Add("lhs", "y");
+            s2a.Add("expr", "x+y");
+            Template s2b = group.GetInstanceOf("assign");
+            s2b.Add("lhs", "z");
+            s2b.Add("expr", "4");
+            s2.Add("stats", s2a);
+            s2.Add("stats", s2b);
+            t.Add("stats", s1);
+            t.Add("stats", s2);
+            String expecting =
+                    "void foo() {" + newline +
+                    "\tx=0;" + newline +
+                    "\tif (x>0) {" + newline +
+                    "\t  y=x+y;" + newline +
+                    "\t  z=4;" + newline +
+                    "\t}" + newline +
+                    "}" + newline;
+            Assert.AreEqual(expecting, t.Render());
+        }
+
+        [TestMethod]
+        public void TestIndentedIFWithValueExpr()
+        {
+            STGroup group =
+                    new STGroup();
+            STErrorListener errors = new ErrorBuffer();
+            group.SetErrorListener(errors);
+            Template t = new Template(group,
+                "begin" + newline +
+                "    <if(x)>foo<endif>" + newline +
+                "end" + newline);
+            t.Add("x", "x");
+            String expecting = "begin" + newline + "    foo" + newline + "end" + newline;
+            String result = t.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestIFWithIndentOnMultipleLines()
+        {
+            STGroup group =
+                    new STGroup();
+            STErrorListener errors = new ErrorBuffer();
+            group.SetErrorListener(errors);
+            Template t = new Template(group,
+                "begin" + newline +
+                "   <if(x)>" + newline +
+                "   foo" + newline +
+                "   <else>" + newline +
+                "   bar" + newline +
+                "   <endif>" + newline +
+                "end" + newline);
+            String expecting = "begin" + newline + "   bar" + newline + "end" + newline;
+            String result = t.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestIFWithIndentAndExprOnMultipleLines()
+        {
+            STGroup group =
+                    new STGroup();
+            STErrorListener errors = new ErrorBuffer();
+            group.SetErrorListener(errors);
+            Template t = new Template(group,
+                "begin" + newline +
+                "   <if(x)>" + newline +
+                "   <x>" + newline +
+                "   <else>" + newline +
+                "   <y>" + newline +
+                "   <endif>" + newline +
+                "end" + newline);
+            t.Add("y", "y");
+            String expecting = "begin" + newline + "   y" + newline + "end" + newline;
+            String result = t.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestIFWithIndentAndExprWithIndentOnMultipleLines()
+        {
+            STGroup group =
+                    new STGroup();
+            STErrorListener errors = new ErrorBuffer();
+            group.SetErrorListener(errors);
+            Template t = new Template(group,
+                "begin" + newline +
+                "   <if(x)>" + newline +
+                "     <x>" + newline +
+                "   <else>" + newline +
+                "     <y>" + newline +
+                "   <endif>" + newline +
+                "end" + newline);
+            t.Add("y", "y");
+            String expecting = "begin" + newline + "     y" + newline + "end" + newline;
+            String result = t.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestNestedIFWithIndentOnMultipleLines()
+        {
+            STGroup group =
+                    new STGroup();
+            STErrorListener errors = new ErrorBuffer();
+            group.SetErrorListener(errors);
+            Template t = new Template(group,
+                "begin" + newline +
+                "   <if(x)>" + newline +
+                "      <if(y)>" + newline +
+                "      foo" + newline +
+                "      <endif>" + newline +
+                "   <else>" + newline +
+                "      <if(z)>" + newline +
+                "      foo" + newline +
+                "      <endif>" + newline +
+                "   <endif>" + newline +
+                "end" + newline);
+            t.Add("x", "x");
+            t.Add("y", "y");
+            String expecting = "begin" + newline + "      foo" + newline + "end" + newline; // no indent
+            String result = t.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestIFInSubtemplate()
+        {
+            STGroup group = new STGroup();
+            STErrorListener errors = new ErrorBuffer();
+            group.SetErrorListener(errors);
+            Template t = new Template(group,
+                "<names:{n |" + newline +
+                "   <if(x)>" + newline +
+                "   <x>" + newline +
+                "   <else>" + newline +
+                "   <y>" + newline +
+                "   <endif>" + newline +
+                "}>" + newline);
+            t.Add("names", "Ter");
+            t.Add("y", "y");
+            String expecting = "   y" + newline + newline;
+            String result = t.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+    }
+}
diff --git a/Antlr3.Test/ST4/TestIndirectionAndEarlyEvaluation.cs b/Antlr3.Test/ST4/TestIndirectionAndEarlyEvaluation.cs
new file mode 100644
index 0000000..3bcea7e
--- /dev/null
+++ b/Antlr3.Test/ST4/TestIndirectionAndEarlyEvaluation.cs
@@ -0,0 +1,126 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace AntlrUnitTests.ST4
+{
+    using System.Collections.Generic;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using ST = StringTemplate.Template;
+    using STGroup = StringTemplate.TemplateGroup;
+    using String = System.String;
+
+    [TestClass]
+    public class TestIndirectionAndEarlyEvaluation : StringTemplateTestBase
+    {
+        [TestMethod]
+        public void TestEarlyEval()
+        {
+            String template = "<(name)>";
+            ST st = new ST(template);
+            st.Add("name", "Ter");
+            String expected = "Ter";
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestIndirectTemplateInclude()
+        {
+            STGroup group = new STGroup();
+            group.DefineTemplate("foo", "bar");
+            String template = "<(name)()>";
+            group.DefineTemplate("test", template);
+            ST st = group.GetInstanceOf("test");
+            st.Add("name", "foo");
+            String expected = "bar";
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestIndirectTemplateIncludeViaTemplate()
+        {
+            STGroup group = new STGroup();
+            group.DefineTemplate("foo", "bar");
+            group.DefineTemplate("tname", "foo");
+            String template = "<(tname())()>";
+            group.DefineTemplate("test", template);
+            ST st = group.GetInstanceOf("test");
+            String expected = "bar";
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestIndirectProp()
+        {
+            String template = "<u.(propname)>: <u.name>";
+            ST st = new ST(template);
+            st.Add("u", new TestCoreBasics.User(1, "parrt"));
+            st.Add("propname", "id");
+            String expected = "1: parrt";
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestIndirectMap()
+        {
+            STGroup group = new STGroup();
+            group.DefineTemplate("a", "[<it>]");
+            group.DefineTemplate("test", "hi <names:(templateName)>!");
+            ST st = group.GetInstanceOf("test");
+            st.Add("names", "Ter");
+            st.Add("names", "Tom");
+            st.Add("names", "Sumana");
+            st.Add("templateName", "a");
+            String expected =
+                "hi [Ter][Tom][Sumana]!";
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestNonStringDictLookup()
+        {
+            String template = "<m.(intkey)>";
+            ST st = new ST(template);
+            IDictionary<int, string> m = new Dictionary<int, String>();
+            m[36] = "foo";
+            st.Add("m", m);
+            st.Add("intkey", 36);
+            String expected = "foo";
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+    }
+}
diff --git a/Antlr3.Test/ST4/TestLexer.cs b/Antlr3.Test/ST4/TestLexer.cs
new file mode 100644
index 0000000..4f74679
--- /dev/null
+++ b/Antlr3.Test/ST4/TestLexer.cs
@@ -0,0 +1,254 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace AntlrUnitTests.ST4
+{
+    using Antlr.Runtime;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using StringTemplate;
+
+    using StringBuilder = System.Text.StringBuilder;
+
+    [TestClass]
+    public class TestLexer : StringTemplateTestBase
+    {
+        public void Check(string template, string expected)
+        {
+            TemplateLexer lexer = new TemplateLexer(new ANTLRStringStream(template));
+            CommonTokenStream tokens = new CommonTokenStream(lexer);
+            StringBuilder buf = new StringBuilder();
+            buf.Append("[");
+            int i = 1;
+            IToken t = tokens.LT(i);
+            while (t.Type != CharStreamConstants.EndOfFile)
+            {
+                if (i > 1)
+                    buf.Append(", ");
+                buf.Append(t);
+                i++;
+                t = tokens.LT(i);
+            }
+            buf.Append("]");
+            string result = buf.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestOneExpr()
+        {
+            string template = "<name>";
+            string expected = "[[@0,0:0='<',<LDELIM>,1:0], [@1,1:4='name',<ID>,1:1], " +
+                              "[@2,5:5='>',<RDELIM>,1:5]]";
+            Check(template, expected);
+        }
+
+        [TestMethod]
+        public void TestOneExprSurrounded()
+        {
+            string template = "hi <name> mom";
+            string expected = "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='<',<LDELIM>,1:3], " +
+                              "[@2,4:7='name',<ID>,1:4], [@3,8:8='>',<RDELIM>,1:8], " +
+                              "[@4,9:12=' mom',<TEXT>,1:9]]";
+            Check(template, expected);
+        }
+
+        [TestMethod]
+        public void TestEscDelim()
+        {
+            string template = "hi \\<name>";
+            string expected = "[[@0,0:0='hi <name>',<TEXT>,1:0]]";
+            Check(template, expected);
+        }
+
+        [TestMethod]
+        public void TestEscDelimHasCorrectStartChar()
+        {
+            string template = "<a>\\<dog";
+            string expected =
+                "[[@0,0:0='<',<LDELIM>,1:0], [@1,1:1='a',<ID>,1:1], [@2,2:2='>',<RDELIM>,1:2], " +
+                "[@3,3:0='<dog',<TEXT>,1:3]]";
+            Check(template, expected);
+        }
+
+        [TestMethod]
+        public void TestEscChar()
+        {
+            string template = "hi \\x";
+            string expected = "[[@0,0:4='hi \\x',<TEXT>,1:0]]";
+            Check(template, expected);
+        }
+
+        [TestMethod]
+        public void TestString()
+        {
+            string template = "hi <foo(a=\">\")>";
+            string expected = "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='<',<LDELIM>,1:3], " +
+                              "[@2,4:6='foo',<ID>,1:4], [@3,7:7='(',<LPAREN>,1:7], " +
+                              "[@4,8:8='a',<ID>,1:8], [@5,9:9='=',<EQUALS>,1:9], " +
+                              "[@6,10:12='\">\"',<STRING>,1:10], [@7,13:13=')',<RPAREN>,1:13], " +
+                              "[@8,14:14='>',<RDELIM>,1:14]]";
+            Check(template, expected);
+        }
+
+        [TestMethod]
+        public void TestEscInString()
+        {
+            string template = "hi <foo(a=\">\\\"\")>";
+            string expected =
+                "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='<',<LDELIM>,1:3], [@2,4:6='foo',<ID>,1:4], " +
+                "[@3,7:7='(',<LPAREN>,1:7], [@4,8:8='a',<ID>,1:8], [@5,9:9='=',<EQUALS>,1:9], " +
+                "[@6,10:0='\">\"\"',<STRING>,1:10], [@7,15:15=')',<RPAREN>,1:15], " +
+                "[@8,16:16='>',<RDELIM>,1:16]]";
+            Check(template, expected);
+        }
+
+        [TestMethod]
+        public void TestSubtemplate()
+        {
+            string template = "hi <names:{n | <n>}>";
+            string expected =
+                "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='<',<LDELIM>,1:3], [@2,4:8='names',<ID>,1:4], [@3,9:9=':',<COLON>,1:9], [@4,10:10='{',<LCURLY>,1:10], [@5,11:11='n',<ID>,1:11], [@6,13:13='|',<PIPE>,1:13], [@7,15:15='<',<LDELIM>,1:15], [@8,16:16='n',<ID>,1:16], [@9,17:17='>',<RDELIM>,1:17], [@10,18:18='}',<RCURLY>,1:18], [@11,19:19='>',<RDELIM>,1:19]]";
+            Check(template, expected);
+        }
+
+        [TestMethod]
+        public void TestSubtemplateNoArg()
+        {
+            string template = "hi <names:{ <it>}>";
+            string expected =
+                "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='<',<LDELIM>,1:3], " +
+                    "[@2,4:8='names',<ID>,1:4], [@3,9:9=':',<COLON>,1:9], " +
+                    "[@4,10:10='{',<LCURLY>,1:10], [@5,11:11=' ',<TEXT>,1:11], " +
+                    "[@6,12:12='<',<LDELIM>,1:12], [@7,13:14='it',<ID>,1:13], " +
+                    "[@8,15:15='>',<RDELIM>,1:15], [@9,16:16='}',<RCURLY>,1:16], " +
+                    "[@10,17:17='>',<RDELIM>,1:17]]";
+            Check(template, expected);
+        }
+
+        [TestMethod]
+        public void TestSubtemplateMultiArgs()
+        {
+            string template = "hi <names:{x,y | <x><y>}>"; // semantically bogus
+            string expected =
+                "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='<',<LDELIM>,1:3], [@2,4:8='names',<ID>,1:4], [@3,9:9=':',<COLON>,1:9], [@4,10:10='{',<LCURLY>,1:10], [@5,11:11='x',<ID>,1:11], [@6,12:12=',',<COMMA>,1:12], [@7,13:13='y',<ID>,1:13], [@8,15:15='|',<PIPE>,1:15], [@9,17:17='<',<LDELIM>,1:17], [@10,18:18='x',<ID>,1:18], [@11,19:19='>',<RDELIM>,1:19], [@12,20:20='<',<LDELIM>,1:20], [@13,21:21='y',<ID>,1:21], [@14,22:22='>',<RDELIM>,1:22], [@15,23:23='}',<RCURLY>,1:23], [@16,24:24='>',<RDELIM>,1:24]]";
+            Check(template, expected);
+        }
+
+        [TestMethod]
+        public void TestNestedSubtemplate()
+        {
+            string template = "hi <names:{n | <n:{<it>}>}>";
+            string expected =
+                "[[@0,0:2='hi ',<TEXT>,1:0], [@1,3:3='<',<LDELIM>,1:3], [@2,4:8='names',<ID>,1:4], [@3,9:9=':',<COLON>,1:9], [@4,10:10='{',<LCURLY>,1:10], [@5,11:11='n',<ID>,1:11], [@6,13:13='|',<PIPE>,1:13], [@7,15:15='<',<LDELIM>,1:15], [@8,16:16='n',<ID>,1:16], [@9,17:17=':',<COLON>,1:17], [@10,18:18='{',<LCURLY>,1:18], [@11,19:19='<',<LDELIM>,1:19], [@12,20:21='it',<ID>,1:20], [@13,22:22='>',<RDELIM>,1:22], [@14,23:23='}',<RCURLY>,1:23], [@15,24:24='>',<RDELIM>,1:24], [@16,25:25='}',<RCURLY>,1:25], [@17,26:26='>',<RDELIM>,1:26]]";
+            Check(template, expected);
+        }
+
+        [TestMethod]
+        public void TestNestedList()
+        {
+            string template =
+                "*<[names, [\"foo\",\"bar\"]:{<it>!},phones]; separator=\", \">*";
+            string expected =
+                "[[@0,0:0='*',<TEXT>,1:0], [@1,1:1='<',<LDELIM>,1:1], [@2,2:2='[',<LBRACK>,1:2], " +
+                "[@3,3:7='names',<ID>,1:3], [@4,8:8=',',<COMMA>,1:8], [@5,9:10=' [',<LBRACK>,1:9], " +
+                "[@6,11:15='\"foo\"',<STRING>,1:11], [@7,16:16=',',<COMMA>,1:16], " +
+                "[@8,17:21='\"bar\"',<STRING>,1:17], [@9,22:22=']',<RBRACK>,1:22], " +
+                "[@10,23:23=':',<COLON>,1:23], [@11,24:24='{',<LCURLY>,1:24], " +
+                "[@12,25:25='<',<LDELIM>,1:25], [@13,26:27='it',<ID>,1:26], " +
+                "[@14,28:28='>',<RDELIM>,1:28], [@15,29:29='!',<TEXT>,1:29], " +
+                "[@16,30:30='}',<RCURLY>,1:30], [@17,31:31=',',<COMMA>,1:31], " +
+                "[@18,32:37='phones',<ID>,1:32], [@19,38:38=']',<RBRACK>,1:38], " +
+                "[@20,39:39=';',<SEMI>,1:39], [@21,41:49='separator',<ID>,1:41], " +
+                "[@22,50:50='=',<EQUALS>,1:50], [@23,51:54='\", \"',<STRING>,1:51], " +
+                "[@24,55:55='>',<RDELIM>,1:55], [@25,56:56='*',<TEXT>,1:56]]";
+            Check(template, expected);
+        }
+
+        [TestMethod]
+        public void TestIF()
+        {
+            string template = "<if(!name)>works<endif>";
+            string expected =
+                "[[@0,0:0='<',<LDELIM>,1:0], [@1,1:2='if',<IF>,1:1], [@2,3:3='(',<LPAREN>,1:3], " +
+                "[@3,4:4='!',<BANG>,1:4], [@4,5:8='name',<ID>,1:5], [@5,9:9=')',<RPAREN>,1:9], " +
+                "[@6,10:10='>',<RDELIM>,1:10], [@7,11:15='works',<TEXT>,1:11], " +
+                "[@8,16:16='<',<LDELIM>,1:16], [@9,17:21='endif',<ENDIF>,1:17], " +
+                "[@10,22:22='>',<RDELIM>,1:22]]";
+            Check(template, expected);
+        }
+
+        [TestMethod]
+        public void TestIFNot()
+        {
+            string template = "<if(!name)>works<endif>";
+            string expected =
+                "[[@0,0:0='<',<LDELIM>,1:0], [@1,1:2='if',<IF>,1:1], [@2,3:3='(',<LPAREN>,1:3], " +
+                "[@3,4:4='!',<BANG>,1:4], [@4,5:8='name',<ID>,1:5], [@5,9:9=')',<RPAREN>,1:9], " +
+                "[@6,10:10='>',<RDELIM>,1:10], [@7,11:15='works',<TEXT>,1:11], " +
+                "[@8,16:16='<',<LDELIM>,1:16], [@9,17:21='endif',<ENDIF>,1:17], " +
+                "[@10,22:22='>',<RDELIM>,1:22]]";
+            Check(template, expected);
+        }
+
+        [TestMethod]
+        public void TestIFELSE()
+        {
+            string template = "<if(name)>works<else>fail<endif>";
+            string expected =
+                "[[@0,0:0='<',<LDELIM>,1:0], [@1,1:2='if',<IF>,1:1], [@2,3:3='(',<LPAREN>,1:3], " +
+                "[@3,4:7='name',<ID>,1:4], [@4,8:8=')',<RPAREN>,1:8], [@5,9:9='>',<RDELIM>,1:9], " +
+                "[@6,10:14='works',<TEXT>,1:10], [@7,15:15='<',<LDELIM>,1:15], " +
+                "[@8,16:19='else',<ELSE>,1:16], [@9,20:20='>',<RDELIM>,1:20], " +
+                "[@10,21:24='fail',<TEXT>,1:21], [@11,25:25='<',<LDELIM>,1:25], " +
+                "[@12,26:30='endif',<ENDIF>,1:26], [@13,31:31='>',<RDELIM>,1:31]]";
+            Check(template, expected);
+        }
+
+        [TestMethod]
+        public void TestELSEIF()
+        {
+            string template = "<if(name)>fail<elseif(id)>works<else>fail<endif>";
+            string expected =
+                "[[@0,0:0='<',<LDELIM>,1:0], [@1,1:2='if',<IF>,1:1], [@2,3:3='(',<LPAREN>,1:3], " +
+                "[@3,4:7='name',<ID>,1:4], [@4,8:8=')',<RPAREN>,1:8], [@5,9:9='>',<RDELIM>,1:9], " +
+                "[@6,10:13='fail',<TEXT>,1:10], [@7,14:14='<',<LDELIM>,1:14], " +
+                "[@8,15:20='elseif',<ELSEIF>,1:15], [@9,21:21='(',<LPAREN>,1:21], " +
+                "[@10,22:23='id',<ID>,1:22], [@11,24:24=')',<RPAREN>,1:24], " +
+                "[@12,25:25='>',<RDELIM>,1:25], [@13,26:30='works',<TEXT>,1:26], " +
+                "[@14,31:31='<',<LDELIM>,1:31], [@15,32:35='else',<ELSE>,1:32], " +
+                "[@16,36:36='>',<RDELIM>,1:36], [@17,37:40='fail',<TEXT>,1:37], " +
+                "[@18,41:41='<',<LDELIM>,1:41], [@19,42:46='endif',<ENDIF>,1:42], " +
+                "[@20,47:47='>',<RDELIM>,1:47]]";
+            Check(template, expected);
+        }
+    }
+}
diff --git a/Antlr3.Test/ST4/TestLists.cs b/Antlr3.Test/ST4/TestLists.cs
new file mode 100644
index 0000000..32a9216
--- /dev/null
+++ b/Antlr3.Test/ST4/TestLists.cs
@@ -0,0 +1,228 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace AntlrUnitTests.ST4
+{
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using ArrayList = System.Collections.ArrayList;
+    using ST = StringTemplate.Template;
+    using STErrorListener = StringTemplate.ITemplateErrorListener;
+    using STGroup = StringTemplate.TemplateGroup;
+    using STGroupFile = StringTemplate.TemplateGroupFile;
+    using String = System.String;
+
+    [TestClass]
+    public class TestLists : StringTemplateTestBase
+    {
+        [TestMethod]
+        public void TestJustCat()
+        {
+            ST e = new ST(
+                    "<[names,phones]>"
+                );
+            e.Add("names", "Ter");
+            e.Add("names", "Tom");
+            e.Add("phones", "1");
+            e.Add("phones", "2");
+            String expecting = "TerTom12";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestCat2Attributes()
+        {
+            ST e = new ST(
+                    "<[names,phones]; separator=\", \">"
+                );
+            e.Add("names", "Ter");
+            e.Add("names", "Tom");
+            e.Add("phones", "1");
+            e.Add("phones", "2");
+            String expecting = "Ter, Tom, 1, 2";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestCat2AttributesWithApply()
+        {
+            ST e = new ST(
+                    "<[names,phones]:{a|<a>.}>"
+                );
+            e.Add("names", "Ter");
+            e.Add("names", "Tom");
+            e.Add("phones", "1");
+            e.Add("phones", "2");
+            String expecting = "Ter.Tom.1.2.";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestCat3Attributes()
+        {
+            ST e = new ST(
+                    "<[names,phones,salaries]; separator=\", \">"
+                );
+            e.Add("names", "Ter");
+            e.Add("names", "Tom");
+            e.Add("phones", "1");
+            e.Add("phones", "2");
+            e.Add("salaries", "big");
+            e.Add("salaries", "huge");
+            String expecting = "Ter, Tom, 1, 2, big, huge";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestCatWithTemplateApplicationAsElement()
+        {
+            ST e = new ST(
+                    "<[names:{<it>!},phones]; separator=\", \">"
+                );
+            e.Add("names", "Ter");
+            e.Add("names", "Tom");
+            e.Add("phones", "1");
+            e.Add("phones", "2");
+            String expecting = "Ter!, Tom!, 1, 2";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestCatWithIFAsElement()
+        {
+            ST e = new ST(
+                    "<[{<if(names)>doh<endif>},phones]; separator=\", \">"
+                );
+            e.Add("names", "Ter");
+            e.Add("names", "Tom");
+            e.Add("phones", "1");
+            e.Add("phones", "2");
+            String expecting = "doh, 1, 2";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestCatWithNullTemplateApplicationAsElement()
+        {
+            ST e = new ST(
+                    "<[names:{<it>!},\"foo\"]:{x}; separator=\", \">"
+                );
+            e.Add("phones", "1");
+            e.Add("phones", "2");
+            String expecting = "x";  // only one since template application gives nothing
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestCatWithNestedTemplateApplicationAsElement()
+        {
+            ST e = new ST(
+                    "<[names, [\"foo\",\"bar\"]:{<it>!},phones]; separator=\", \">"
+                );
+            e.Add("names", "Ter");
+            e.Add("names", "Tom");
+            e.Add("phones", "1");
+            e.Add("phones", "2");
+            String expecting = "Ter, Tom, foo!, bar!, 1, 2";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        public void TestListAsTemplateArgument()
+        {
+            String templates =
+                    "test(names,phones) ::= \"<foo([names,phones])>\"" + newline +
+                    "foo(items) ::= \"<items:{a | *<a>*}>\"" + newline
+                    ;
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            ST e = group.GetInstanceOf("test");
+            e.Add("names", "Ter");
+            e.Add("names", "Tom");
+            e.Add("phones", "1");
+            e.Add("phones", "2");
+            String expecting = "*Ter**Tom**1**2*";
+            String result = e.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestNullListGetsNoOutput()
+        {
+            STGroup group =
+                    new STGroup();
+            STErrorListener errors = new ErrorBuffer();
+            group.SetErrorListener(errors);
+            ST t = new ST(group,
+                "begin\n" +
+                "$users:{name: $it$}; separator=\", \"$\n" +
+                "end\n");
+            //t.setAttribute("users", new Duh());
+            String expecting = "begin\nend\n";
+            String result = t.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestEmptyListGetsNoOutput()
+        {
+            STGroup group =
+                    new STGroup();
+            STErrorListener errors = new ErrorBuffer();
+            group.SetErrorListener(errors);
+            ST t = new ST(group,
+                "begin\n" +
+                "$users:{name: $it$}; separator=\", \"$\n" +
+                "end\n");
+            t.Add("users", new ArrayList());
+            String expecting = "begin\nend\n";
+            String result = t.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestEmptyListNoIteratorGetsNoOutput()
+        {
+            STGroup group =
+                    new STGroup();
+            STErrorListener errors = new ErrorBuffer();
+            group.SetErrorListener(errors);
+            ST t = new ST(group,
+                "begin\n" +
+                "$users; separator=\", \"$\n" +
+                "end\n");
+            t.Add("users", new ArrayList());
+            String expecting = "begin\nend\n";
+            String result = t.Render();
+            Assert.AreEqual(expecting, result);
+        }
+    }
+}
diff --git a/Antlr3.Test/ST4/TestNullAndEmptyValues.cs b/Antlr3.Test/ST4/TestNullAndEmptyValues.cs
new file mode 100644
index 0000000..b8cd76a
--- /dev/null
+++ b/Antlr3.Test/ST4/TestNullAndEmptyValues.cs
@@ -0,0 +1,154 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace AntlrUnitTests.ST4
+{
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using ArrayList = System.Collections.ArrayList;
+    using ST = StringTemplate.Template;
+    using STErrorListener = StringTemplate.ITemplateErrorListener;
+    using STGroup = StringTemplate.TemplateGroup;
+    using String = System.String;
+
+    [TestClass]
+    public class TestNullAndEmptyValues : StringTemplateTestBase
+    {
+        [TestMethod]
+        public void TestSeparatorWithNullFirstValue()
+        {
+            STGroup group = new STGroup();
+            group.DefineTemplate("test", "hi <name; separator=\", \">!");
+            ST st = group.GetInstanceOf("test");
+            st.Add("name", null); // null is added to list, but ignored in iteration
+            st.Add("name", "Tom");
+            st.Add("name", "Sumana");
+            String expected = "hi Tom, Sumana!";
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSeparatorWithNull2ndValue()
+        {
+            STGroup group = new STGroup();
+            group.DefineTemplate("test", "hi <name; separator=\", \">!");
+            ST st = group.GetInstanceOf("test");
+            st.Add("name", "Ter");
+            st.Add("name", null);
+            st.Add("name", "Sumana");
+            String expected = "hi Ter, Sumana!";
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSeparatorWithNullLastValue()
+        {
+            STGroup group = new STGroup();
+            group.DefineTemplate("test", "hi <name; separator=\", \">!");
+            ST st = group.GetInstanceOf("test");
+            st.Add("name", "Ter");
+            st.Add("name", "Tom");
+            st.Add("name", null);
+            String expected = "hi Ter, Tom!";
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSeparatorWithTwoNullValuesInRow()
+        {
+            STGroup group = new STGroup();
+            group.DefineTemplate("test", "hi <name; separator=\", \">!");
+            ST st = group.GetInstanceOf("test");
+            st.Add("name", "Ter");
+            st.Add("name", "Tom");
+            st.Add("name", null);
+            st.Add("name", null);
+            st.Add("name", "Sri");
+            String expected = "hi Ter, Tom, Sri!";
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSizeZeroButNonNullListGetsNoOutput()
+        {
+            STGroup group = new STGroup();
+            STErrorListener errors = new ErrorBuffer();
+            group.SetErrorListener(errors);
+            group.DefineTemplate("test",
+                "begin\n" +
+                "<users>\n" +
+                "end\n");
+            ST t = group.GetInstanceOf("test");
+            t.Add("users", null);
+            String expecting = "begin\nend" + newline;
+            String result = t.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestNullListGetsNoOutput()
+        {
+            STGroup group = new STGroup();
+            STErrorListener errors = new ErrorBuffer();
+            group.SetErrorListener(errors);
+            group.DefineTemplate("test",
+                "begin\n" +
+                "<users:{name: <it>}; separator=\", \">\n" +
+                "end\n");
+            ST t = group.GetInstanceOf("test");
+            //t.setAttribute("users", new Duh());
+            String expecting = "begin\nend" + newline;
+            String result = t.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestEmptyListGetsNoOutput()
+        {
+            STGroup group = new STGroup();
+            STErrorListener errors = new ErrorBuffer();
+            group.SetErrorListener(errors);
+            group.DefineTemplate("test",
+                "begin\n" +
+                "<users:{name: <it>}; separator=\", \">\n" +
+                "end\n");
+            ST t = group.GetInstanceOf("test");
+            t.Add("users", new ArrayList());
+            String expecting = "begin\nend" + newline;
+            String result = t.Render();
+            Assert.AreEqual(expecting, result);
+        }
+    }
+}
diff --git a/Antlr3.Test/ST4/TestOptions.cs b/Antlr3.Test/ST4/TestOptions.cs
new file mode 100644
index 0000000..e7df321
--- /dev/null
+++ b/Antlr3.Test/ST4/TestOptions.cs
@@ -0,0 +1,167 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace AntlrUnitTests.ST4
+{
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using ST = StringTemplate.Template;
+    using STGroup = StringTemplate.TemplateGroup;
+    using String = System.String;
+
+    [TestClass]
+    public class TestOptions : StringTemplateTestBase
+    {
+        [TestMethod]
+        public void TestSeparator()
+        {
+            STGroup group = new STGroup();
+            group.DefineTemplate("test", "hi <name; separator=\", \">!");
+            ST st = group.GetInstanceOf("test");
+            st.Add("name", "Ter");
+            st.Add("name", "Tom");
+            st.Add("name", "Sumana");
+            String expected = "hi Ter, Tom, Sumana!";
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestAttrSeparator()
+        {
+            STGroup group = new STGroup();
+            group.DefineTemplate("test", "hi <name; separator=sep>!");
+            ST st = group.GetInstanceOf("test");
+            st.Add("sep", ", ");
+            st.Add("name", "Ter");
+            st.Add("name", "Tom");
+            st.Add("name", "Sumana");
+            String expected = "hi Ter, Tom, Sumana!";
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestIncludeSeparator()
+        {
+            STGroup group = new STGroup();
+            group.DefineTemplate("foo", "|");
+            group.DefineTemplate("test", "hi <name; separator=foo()>!");
+            ST st = group.GetInstanceOf("test");
+            st.Add("sep", ", ");
+            st.Add("name", "Ter");
+            st.Add("name", "Tom");
+            st.Add("name", "Sumana");
+            String expected = "hi Ter|Tom|Sumana!";
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSubtemplateSeparator()
+        {
+            STGroup group = new STGroup();
+            group.DefineTemplate("test", "hi <name; separator={<sep> _}>!");
+            ST st = group.GetInstanceOf("test");
+            st.Add("sep", ",");
+            st.Add("name", "Ter");
+            st.Add("name", "Tom");
+            st.Add("name", "Sumana");
+            String expected = "hi Ter, _Tom, _Sumana!";
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSeparatorWithNullFirstValueAndNullOption()
+        {
+            STGroup group = new STGroup();
+            group.DefineTemplate("test", "hi <name; null=\"n/a\", separator=\", \">!");
+            ST st = group.GetInstanceOf("test");
+            st.Add("name", null);
+            st.Add("name", "Tom");
+            st.Add("name", "Sumana");
+            String expected = "hi n/a, Tom, Sumana!";
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSeparatorWithNull2ndValueAndNullOption()
+        {
+            STGroup group = new STGroup();
+            group.DefineTemplate("test", "hi <name; null=\"n/a\", separator=\", \">!");
+            ST st = group.GetInstanceOf("test");
+            st.Add("name", "Ter");
+            st.Add("name", null);
+            st.Add("name", "Sumana");
+            String expected = "hi Ter, n/a, Sumana!";
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestNullValueAndNullOption()
+        {
+            STGroup group = new STGroup();
+            group.DefineTemplate("test", "<name; null=\"n/a\">");
+            ST st = group.GetInstanceOf("test");
+            st.Add("name", null);
+            String expected = "n/a";
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestMissingValueAndNullOption()
+        {
+            STGroup group = new STGroup();
+            group.DefineTemplate("test", "<name; null=\"n/a\">");
+            ST st = group.GetInstanceOf("test");
+            String expected = "n/a";
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestOptionDoesntApplyToNestedTemplate()
+        {
+            STGroup group = new STGroup();
+            group.DefineTemplate("foo", "<zippo>");
+            group.DefineTemplate("test", "<foo(); null=\"n/a\">");
+            ST st = group.GetInstanceOf("test");
+            st.Add("zippo", null);
+            String expected = "";
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+    }
+}
diff --git a/Antlr3.Test/ST4/TestSubtemplates.cs b/Antlr3.Test/ST4/TestSubtemplates.cs
new file mode 100644
index 0000000..4dce4dc
--- /dev/null
+++ b/Antlr3.Test/ST4/TestSubtemplates.cs
@@ -0,0 +1,111 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace AntlrUnitTests.ST4
+{
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using ST = StringTemplate.Template;
+    using STGroup = StringTemplate.TemplateGroup;
+    using String = System.String;
+
+    [TestClass]
+    public class TestSubtemplates : StringTemplateTestBase
+    {
+        [TestMethod]
+        public void TestSimpleIteration()
+        {
+            STGroup group = new STGroup();
+            group.DefineTemplate("test", "<names:{<it>}>!");
+            ST st = group.GetInstanceOf("test");
+            st.Add("names", "Ter");
+            st.Add("names", "Tom");
+            st.Add("names", "Sumana");
+            String expected = "TerTomSumana!";
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestSimpleIterationWithArg()
+        {
+            STGroup group = new STGroup();
+            group.DefineTemplate("test", "<names:{n | <n>}>!");
+            ST st = group.GetInstanceOf("test");
+            st.Add("names", "Ter");
+            st.Add("names", "Tom");
+            st.Add("names", "Sumana");
+            String expected = "TerTomSumana!";
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void Test_it_NotDefinedWithArg()
+        {
+            STGroup group = new STGroup();
+            group.DefineTemplate("test", "<names:{n | <it>}>!");
+            ST st = group.GetInstanceOf("test");
+            st.Add("names", "Ter");
+            st.Add("names", "Tom");
+            st.Add("names", "Sumana");
+            String expected = "!";
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void Test_it_NotDefinedWithArgSingleValue()
+        {
+            STGroup group = new STGroup();
+            group.DefineTemplate("test", "<names:{n | <it>}>!");
+            ST st = group.GetInstanceOf("test");
+            st.Add("names", "Ter");
+            String expected = "!";
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestNestedIterationWithArg()
+        {
+            STGroup group = new STGroup();
+            group.DefineTemplate("test", "<users:{u | <u.id:{id | <id>=}><u.name>}>!");
+            ST st = group.GetInstanceOf("test");
+            st.Add("users", new TestCoreBasics.User(1, "parrt"));
+            st.Add("users", new TestCoreBasics.User(2, "tombu"));
+            st.Add("users", new TestCoreBasics.User(3, "sri"));
+            String expected = "1=parrt2=tombu3=sri!";
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+    }
+}
diff --git a/Antlr3.Test/ST4/TestSyntaxErrors.cs b/Antlr3.Test/ST4/TestSyntaxErrors.cs
new file mode 100644
index 0000000..5f65d0c
--- /dev/null
+++ b/Antlr3.Test/ST4/TestSyntaxErrors.cs
@@ -0,0 +1,136 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace AntlrUnitTests.ST4
+{
+    using Antlr.Runtime;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using StringTemplate;
+
+    using Path = System.IO.Path;
+    using String = System.String;
+
+    [TestClass]
+    public class TestSyntaxErrors : StringTemplateTestBase
+    {
+        [TestMethod]
+        public void TestEmptyExpr()
+        {
+            string template = " <> ";
+            TemplateGroup group = new TemplateGroup();
+            string result = null;
+            try
+            {
+                group.DefineTemplate("test", template);
+            }
+            catch (TemplateException se)
+            {
+                RecognitionException re = (RecognitionException)se.InnerException;
+                result = 1 + ":" + re.charPositionInLine + ": " + se.Message;
+            }
+            string expected = "1:1: mismatched input '<' expecting EOF";
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestWeirdChar()
+        {
+            string template = "   <*>";
+            TemplateGroup group = new TemplateGroup();
+            string result = null;
+            try
+            {
+                group.DefineTemplate("test", template);
+            }
+            catch (TemplateException se)
+            {
+                RecognitionException re = (RecognitionException)se.InnerException;
+                result = 1 + ":" + re.charPositionInLine + ": " + se.Message;
+            }
+            string expected = "1:4: invalid character: *";
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestValidButOutOfPlaceChar()
+        {
+            String templates =
+                "group t;\n" +
+                "foo() ::= <<hi <.> mom>>\n";
+            WriteFile(tmpdir, "t.stg", templates);
+
+            ITemplateErrorListener errors = new ErrorBuffer();
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
+            group.listener = errors;
+            group.Load(); // force load
+            string expected = "2:15: mismatched input '<' expecting EOF";
+            string result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestValidButOutOfPlaceCharOnDifferentLine()
+        {
+            String templates =
+                "group t;\n" +
+                    "foo() ::= \"hi <\n" +
+                    ".> mom\"\n";
+            WriteFile(tmpdir, "t.stg", templates);
+
+            ITemplateErrorListener errors = new ErrorBuffer();
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
+            group.listener = errors;
+            group.Load(); // force load
+            string expected = "2:14: mismatched input '<' expecting EOF"; // TODO: terrible err message
+            string result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestErrorInNestedTemplate()
+        {
+            String templates =
+                "group t;\n" +
+                "foo() ::= \"hi <name:{[<aaa.bb!>]}> mom\"\n";
+            WriteFile(tmpdir, "t.stg", templates);
+
+            TemplateGroup group = null;
+            ITemplateErrorListener errors = new ErrorBuffer();
+            group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
+            group.listener = errors;
+            group.Load(); // force load
+            string expected = "2:29: no viable alternative at input '!'";
+            string result = errors.ToString();
+            Assert.AreEqual(expected, result);
+        }
+    }
+}
diff --git a/Antlr3.Test/ST4/TestWhitespace.cs b/Antlr3.Test/ST4/TestWhitespace.cs
new file mode 100644
index 0000000..17f9d2d
--- /dev/null
+++ b/Antlr3.Test/ST4/TestWhitespace.cs
@@ -0,0 +1,365 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace AntlrUnitTests.ST4
+{
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using StringTemplate;
+    using ST = StringTemplate.Template;
+    using STErrorListener = StringTemplate.ITemplateErrorListener;
+    using STGroup = StringTemplate.TemplateGroup;
+    using String = System.String;
+    using StringWriter = System.IO.StringWriter;
+
+    [TestClass]
+    public class TestWhitespace : StringTemplateTestBase
+    {
+        [TestMethod]
+        public void TestTrimmedSubtemplates()
+        {
+            STGroup group = new STGroup();
+            group.DefineTemplate("test", "<names:{n | <n>}>!");
+            ST st = group.GetInstanceOf("test");
+            st.Add("names", "Ter");
+            st.Add("names", "Tom");
+            st.Add("names", "Sumana");
+            String expected = "TerTomSumana!";
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestTrimJustOneWSInSubtemplates()
+        {
+            STGroup group = new STGroup();
+            group.DefineTemplate("test", "<names:{n |  <n> }>!");
+            ST st = group.GetInstanceOf("test");
+            st.Add("names", "Ter");
+            st.Add("names", "Tom");
+            st.Add("names", "Sumana");
+            String expected = " Ter  Tom  Sumana !";
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestTrimNewlineInSubtemplates()
+        {
+            STGroup group = new STGroup();
+            group.DefineTemplate("test", "<names:{n |\n" +
+                                         "<n>}>!");
+            ST st = group.GetInstanceOf("test");
+            st.Add("names", "Ter");
+            st.Add("names", "Tom");
+            st.Add("names", "Sumana");
+            String expected = "TerTomSumana!";
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestLeaveNewlineOnEndInSubtemplates()
+        {
+            STGroup group = new STGroup();
+            group.DefineTemplate("test", "<names:{n |\n" +
+                                         "<n>\n" +
+                                         "}>!");
+            ST st = group.GetInstanceOf("test");
+            st.Add("names", "Ter");
+            st.Add("names", "Tom");
+            st.Add("names", "Sumana");
+            String expected = "Ter" + newline + "Tom" + newline + "Sumana" + newline + "!";
+            String result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestEmptyExprAsFirstLineGetsNoOutput()
+        {
+            STGroup group =
+                    new STGroup();
+            STErrorListener errors = new ErrorBuffer();
+            group.SetErrorListener(errors);
+            ST t = new ST(group,
+                "<users>\n" +
+                "end\n");
+            String expecting = "end" + newline;
+            String result = t.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestEmptyLineWithIndent()
+        {
+            STGroup group =
+                    new STGroup();
+            STErrorListener errors = new ErrorBuffer();
+            group.SetErrorListener(errors);
+            ST t = new ST(group,
+                "begin\n" +
+                "    \n" +
+                "end\n");
+            String expecting = "begin" + newline + newline + "end" + newline;
+            String result = t.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestSizeZeroOnLineByItselfGetsNoOutput()
+        {
+            STGroup group =
+                    new STGroup();
+            STErrorListener errors = new ErrorBuffer();
+            group.SetErrorListener(errors);
+            ST t = new ST(group,
+                "begin\n" +
+                "<name>\n" +
+                "<users>\n" +
+                "<users>\n" +
+                "end\n");
+            String expecting = "begin" + newline + "end" + newline;
+            String result = t.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestSizeZeroOnLineWithIndentGetsNoOutput()
+        {
+            STGroup group =
+                    new STGroup();
+            STErrorListener errors = new ErrorBuffer();
+            group.SetErrorListener(errors);
+            ST t = new ST(group,
+                "begin\n" +
+                "  <name>\n" +
+                "	<users>\n" +
+                "	<users>\n" +
+                "end\n");
+            String expecting = "begin" + newline + "end" + newline;
+            String result = t.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestSizeZeroOnLineWithMultipleExpr()
+        {
+            STGroup group =
+                    new STGroup();
+            STErrorListener errors = new ErrorBuffer();
+            group.SetErrorListener(errors);
+            ST t = new ST(group,
+                "begin\n" +
+                "  <name>\n" +
+                "	<users><users>\n" +
+                "end\n");
+            String expecting = "begin" + newline + "end" + newline;
+            String result = t.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestIFExpr()
+        {
+            STGroup group =
+                    new STGroup();
+            STErrorListener errors = new ErrorBuffer();
+            group.SetErrorListener(errors);
+            ST t = new ST(group,
+                "begin\n" +
+                "<if(x)><endif>\n" +
+                "end\n");
+            String expecting = "begin"+newline+"end"+newline;
+            String result = t.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestIndentedIFExpr()
+        {
+            STGroup group =
+                    new STGroup();
+            STErrorListener errors = new ErrorBuffer();
+            group.SetErrorListener(errors);
+            ST t = new ST(group,
+                "begin\n" +
+                "    <if(x)><endif>\n" +
+                "end\n");
+            String expecting = "begin" + newline + "end" + newline;
+            String result = t.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestIFElseExpr()
+        {
+            STGroup group =
+                    new STGroup();
+            STErrorListener errors = new ErrorBuffer();
+            group.SetErrorListener(errors);
+            ST t = new ST(group,
+                "begin\n" +
+                "<if(users)><else><endif>\n" +
+                "end\n");
+            String expecting = "begin" + newline + "end" + newline;
+            String result = t.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestIFOnMultipleLines()
+        {
+            STGroup group =
+                    new STGroup();
+            STErrorListener errors = new ErrorBuffer();
+            group.SetErrorListener(errors);
+            ST t = new ST(group,
+                "begin\n" +
+                "<if(users)>\n" +
+                "foo\n" +
+                "<else>\n" +
+                "bar\n" +
+                "<endif>\n" +
+                "end\n");
+            String expecting = "begin"+newline+"bar"+newline+"end"+newline;
+            String result = t.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestNestedIFOnMultipleLines()
+        {
+            STGroup group =
+                    new STGroup();
+            STErrorListener errors = new ErrorBuffer();
+            group.SetErrorListener(errors);
+            ST t = new ST(group,
+                "begin\n" +
+                "<if(x)>\n" +
+                "<if(y)>\n" +
+                "foo\n" +
+                "<else>\n" +
+                "bar\n" +
+                "<endif>\n" +
+                "<endif>\n" +
+                "end\n");
+            t.Add("x", "x");
+            String expecting = "begin"+newline+"bar"+newline+"end"+newline;
+            String result = t.Render();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestLineBreak()
+        {
+            ST st = new ST(
+                    "Foo <\\\\>" + newline +
+                    "  \t  bar" + newline
+                    );
+            StringWriter sw = new StringWriter();
+            st.Write(new AutoIndentWriter(sw, "\n")); // force \n as newline
+            String result = sw.ToString();
+            String expecting = "Foo bar\n";     // expect \n in output
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestLineBreak2()
+        {
+            ST st = new ST(
+                    "Foo <\\\\>       " + newline +
+                    "  \t  bar" + newline
+                    );
+            StringWriter sw = new StringWriter();
+            st.Write(new AutoIndentWriter(sw, "\n")); // force \n as newline
+            String result = sw.ToString();
+            String expecting = "Foo bar\n";
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestLineBreakNoWhiteSpace()
+        {
+            ST st = new ST(
+                    "Foo <\\\\>" + newline +
+                    "bar\n"
+                    );
+            StringWriter sw = new StringWriter();
+            st.Write(new AutoIndentWriter(sw, "\n")); // force \n as newline
+            String result = sw.ToString();
+            String expecting = "Foo bar\n";
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestNewlineNormalizationInTemplateString()
+        {
+            ST st = new ST(
+                    "Foo\r\n" +
+                    "Bar\n"
+                    );
+            StringWriter sw = new StringWriter();
+            st.Write(new AutoIndentWriter(sw, "\n")); // force \n as newline
+            String result = sw.ToString();
+            String expecting = "Foo\nBar\n";     // expect \n in output
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestNewlineNormalizationInTemplateStringPC()
+        {
+            ST st = new ST(
+                    "Foo\r\n" +
+                    "Bar\n"
+                    );
+            StringWriter sw = new StringWriter();
+            st.Write(new AutoIndentWriter(sw, "\r\n")); // force \r\n as newline
+            String result = sw.ToString();
+            String expecting = "Foo\r\nBar\r\n";     // expect \r\n in output
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestNewlineNormalizationInAttribute()
+        {
+            ST st = new ST(
+                    "Foo\r\n" +
+                    "<name>\n"
+                    );
+            st.Add("name", "a\nb\r\nc");
+            StringWriter sw = new StringWriter();
+            st.Write(new AutoIndentWriter(sw, "\n")); // force \n as newline
+            String result = sw.ToString();
+            String expecting = "Foo\na\nb\nc\n";     // expect \n in output
+            Assert.AreEqual(expecting, result);
+        }
+    }
+}
diff --git a/Antlr3.sln b/Antlr3.sln
index becff67..e59c8f7 100644
--- a/Antlr3.sln
+++ b/Antlr3.sln
@@ -63,12 +63,14 @@ Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Antlr3.Runtime.Test", "..\.
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AntlrBuildTask", "AntlrBuildTask\AntlrBuildTask.csproj", "{60F8B554-5C53-4DE2-B868-A0BFEF4EF80E}"
EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "StringTemplate4", "StringTemplate4\StringTemplate4.csproj", "{BBE5D9E6-2F4C-46EF-8CDB-17F886A36837}"
+EndProject
Global
GlobalSection(TestCaseManagementSettings) = postSolution
CategoryFile = Antlr3.vsmdi
EndGlobalSection
GlobalSection(SourceCodeControl) = preSolution
-		SccNumberOfProjects = 21
+		SccNumberOfProjects = 22
SccProjectName0 = Perforce\u0020Project
SccLocalPath0 = ..\\..
SccProvider0 = MSSCCI:Perforce\u0020SCM
@@ -145,6 +147,9 @@ Global
SccProjectUniqueName20 = AntlrBuildTask\\AntlrBuildTask.csproj
SccLocalPath20 = ..\\..
SccProjectFilePathRelativizedFromConnection20 = antlrcs\\main\\AntlrBuildTask\\
+		SccProjectUniqueName21 = StringTemplate4\\StringTemplate4.csproj
+		SccLocalPath21 = ..\\..
+		SccProjectFilePathRelativizedFromConnection21 = antlrcs\\main\\StringTemplate4\\
EndGlobalSection
GlobalSection(SolutionConfigurationPlatforms) = preSolution
Debug|Any CPU = Debug|Any CPU
@@ -230,6 +235,10 @@ Global
{60F8B554-5C53-4DE2-B868-A0BFEF4EF80E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
{60F8B554-5C53-4DE2-B868-A0BFEF4EF80E}.Release|Any CPU.ActiveCfg = Release|Any CPU
{60F8B554-5C53-4DE2-B868-A0BFEF4EF80E}.Release|Any CPU.Build.0 = Release|Any CPU
+		{BBE5D9E6-2F4C-46EF-8CDB-17F886A36837}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{BBE5D9E6-2F4C-46EF-8CDB-17F886A36837}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{BBE5D9E6-2F4C-46EF-8CDB-17F886A36837}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{BBE5D9E6-2F4C-46EF-8CDB-17F886A36837}.Release|Any CPU.Build.0 = Release|Any CPU
EndGlobalSection
GlobalSection(SolutionProperties) = preSolution
HideSolutionNode = FALSE
diff --git a/Antlr3.vsmdi b/Antlr3.vsmdi
index bdc5224..959d3bc 100644
--- a/Antlr3.vsmdi
+++ b/Antlr3.vsmdi
@@ -350,6 +350,7 @@
<TestLinks>
<TestLink id="4678f76b-0eca-2cb7-3208-05a34196451b" name="TestAStarBOrAStarC" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="ff009252-a909-8550-bb44-381b94f3eff9" name="TestComplement" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="dfeb59c3-0e3e-be7e-6d66-1a67121d35b1" name="TestimmediateTailRecursion" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="10f173fa-6c37-47c1-3e35-35b7cf99b424" name="TestComplementChar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="6e865920-f5b9-45bf-86c7-6b89dae57183" name="TestRecursionOverflow2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="44685767-9a93-6e81-3f42-ff7d91ac488f" name="TestAStar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
@@ -385,22 +386,21 @@
<TestLink id="28120725-1276-a6d9-a6e3-b16ec65fd318" name="TestAB_or_AC" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="69aeab9e-5d26-f785-e805-562ec73df1d4" name="TestAPlusGreedyWhenNonDeterministic" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="eddf4857-faf6-597c-8ede-709fb6488d18" name="TestCycleInsideRuleDoesNotForceInfiniteRecursion" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="dfeb59c3-0e3e-be7e-6d66-1a67121d35b1" name="TestimmediateTailRecursion" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="52271c68-1f0f-277e-932f-1ea65dce0f4d" name="TestAutoBacktrackResolvesRecursionInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="46ceefad-be1e-171c-7b9f-e47d0e84c62d" name="TestResolveLL1ByChoosingFirst" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="a5e14519-fd5f-797b-ad31-de6f8c7e78a0" name="TestAOrBPlusOrAPlus" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="59f52c78-5960-f222-f0e3-42d6c7a6d5ef" name="TestSynPredResolvesRecursion2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="98c0d731-d794-2eaa-a0d1-a993346c42c6" name="TestNoStartRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="23a6aad4-28d2-be53-eb00-c7c76b93e112" name="TestOptionalAltAndBypass" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="d84835ea-a5d0-4e1b-bf71-a587239253f3" name="TestResolveLL2ByChoosingFirst" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="470182e5-ac58-5fdd-603e-5b30799489dc" name="TestWildcardPlusK1AndNonGreedyByDefaultInParser" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="8928c090-a789-0cd3-792c-b830b4ad062b" name="TestCyclicTableCreation" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="46ceefad-be1e-171c-7b9f-e47d0e84c62d" name="TestResolveLL1ByChoosingFirst" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="d03de438-4c68-b9b3-29ee-d5b0dded3f14" name="TestLeftRecursionInMultipleCycles" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="2bb21a9c-5d10-1a29-8b4b-32393a753df7" name="TestComplementToken" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="52271c68-1f0f-277e-932f-1ea65dce0f4d" name="TestAutoBacktrackResolvesRecursionInLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="afe0c7ed-8849-a156-6221-104d90fd5cbd" name="TestWildcardInTreeGrammar2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="4ee0264d-a4d3-edcc-0180-fddf5ba4d087" name="TestFollowReturnsToLoopReenteringSameRule" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="75e1aaf6-0436-e38d-6afb-4f2c09cabfd4" name="TestSelfRecursionAmbigAlts" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="62e542c9-e845-77a4-9077-24431cfae7d3" name="TestAStarBOrAPlusC" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="edc367d6-7e85-b302-fafb-1a04828d3438" name="TestAStar_immediateTailRecursion2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="23a6aad4-28d2-be53-eb00-c7c76b93e112" name="TestOptionalAltAndBypass" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="18f58e86-d1b6-84b1-f34b-aa712b4aab33" name="TestIndirectRecursionLoop" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="ffb8afda-9f67-e647-91e3-7e494d42970b" name="TestTokensRuleAltsDoNotCollapse" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="b001abc1-5a7e-24ae-58a4-036a1abbcd86" name="TestIndirectRecursionLoop2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
@@ -409,7 +409,7 @@
<TestLink id="c808ada3-7835-86cf-b1ff-180655b1407a" name="TestifThenElseChecksStackSuffixConflict" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="8033fac3-3583-af76-afd4-1ff21810e9b5" name="TestComplementCharSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="2a53561f-0627-67ec-9a09-4336347f893f" name="TestIndirectRecursionAmbigAlts" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="afe0c7ed-8849-a156-6221-104d90fd5cbd" name="TestWildcardInTreeGrammar2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="edc367d6-7e85-b302-fafb-1a04828d3438" name="TestAStar_immediateTailRecursion2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="7281d05d-5871-4b28-c09f-e15f5def6822" name="TestAB_or_AC_k2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="c8c2848e-6a66-1dc5-1fb7-1ebf6c6946fe" name="TestselfRecurseNonDet2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="7689bc04-7779-600e-ba02-26af3ce74e54" name="TestAPlusNonGreedyWhenDeterministic" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
@@ -989,308 +989,323 @@
</TestList>
<TestList name="StringTemplate" id="f5f852b3-d8bb-4b03-bbb1-b9184f36badc" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
<TestLinks>
-      <TestLink id="1429e05c-8f33-8acb-543c-3b54e356fb21" name="TestAngleBracketsWithGroupFile" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0e40fe7a-160c-53ac-e4d2-629b58a77794" name="TestNoDotsInAttributeNames" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5857e209-7452-7f2f-bf58-aad9a0a21c4a" name="TestElseIfClauseAngleBrackets" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="bd744a9a-9c7a-60c1-66b2-c2138c55aad8" name="TestDefaultArgumentAsTemplate2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="95ecf7c0-820b-953a-88bc-b4b1707f8a1a" name="TestApplyAnonymousTemplateToMultiValuedAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0cca0749-d905-b00d-edb6-7414545e579e" name="TestMultiLevelInheritance" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e32880cf-0ed3-afc2-1de3-06d97ea18279" name="TestEmptyIteratedValueGetsSeparator" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a9c71eca-2007-73da-d1b5-ba0847ad8b3c" name="TestChangingAttrValueRepeatedTemplateApplicationToVector" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="45ca614d-da04-db29-8e50-36688df5c925" name="TestStripOpOfSingleAlt" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e4a7a2c8-9293-2ece-821f-0de5db73d898" name="TestSoleFormalTemplateArgumentInMultiApply" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d05ebb71-321e-c897-3bc5-201799a16169" name="TestRestOpEmptyList" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c4e35019-44a4-8027-12b1-b029dc7b726f" name="TestElseIfClauseAndElse" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b555c6a5-546c-25e8-e3ae-aac466add421" name="TestReUseOfRestResult" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c021b968-b9a5-cac6-78a9-f9d437703abf" name="TestNullIndirectTemplateApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4444e888-11e5-18dd-ca7f-dd500680a28a" name="TestCannotFindInterfaceFile" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0d313f6e-6d2d-7d3b-f776-e0a45d71cbb7" name="TestUnicodeLiterals" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="51643f13-8f84-493e-703e-2b8887edf319" name="TestIFCondWithParensDollarDelimsTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a46646c2-93fc-8a96-960a-4b726279e182" name="TestEmptyListNoIteratorGetsNoOutput" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e6e18a17-daf3-a1ba-64e5-339b3b2de911" name="TestLineBreakNoWhiteSpaceDollar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1192c9df-1c93-10b5-f05a-fe1d8206d7e2" name="TestRegionRefWithDefInConditional" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d4959251-9d72-f88f-6142-0085686cab54" name="TestComplicatedSeparatorExpr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1036a13b-e95e-df51-c9fe-07666e6242e1" name="TestJustCat" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="738cbe6c-bf93-b177-0249-9d11a0dc1f51" name="TestLineBreakDollar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="27e7e7e9-12ae-b8a9-efbf-9a21ad900341" name="TestMapViaEnclosingTemplates2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c2f33561-6e25-32d6-ce55-3af54a96997a" name="TestStripOpOfListWithNulls" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="04c9f0ea-2cbb-5c67-1375-23cec5b98d87" name="TestSuperReferenceInIfClause" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="483db2c4-b830-2542-59d4-3edcc4a01f3f" name="TestTemplateArgumentEvaluatedInSurroundingContext" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="af0c6ab6-f1d1-bf9c-4144-3936b3b46b30" name="TestHashMapPropertyFetch" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3ced3a2c-6120-cab7-f46e-93e09a4991ca" name="TestRegionOverrideRefSuperImplicitRegion" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="10d8ef6e-7bc6-eb2c-1de7-64b503d13a4e" name="TestMultiDirGroupLoading" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="694f000c-5fb7-33f8-bf65-52ea13f73f92" name="TestEmptyStringAndEmptyAnonTemplateAsParameterUsingAngleBracketLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9d913d03-4d17-cade-7892-d9660ab1fe52" name="TestArgumentContext" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="67c65aad-667c-e9ee-d234-91b8f641af44" name="TestRendererWithFormatAndSeparatorAndNull" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b004928a-6dd8-8f0d-44e5-5d8ada3205b7" name="TestLineBreakNoWhiteSpace" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4801a924-a9e7-adfd-3afa-9c6b1c2a55cc" name="TestRendererForGroup" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="adf88771-bf7b-c919-057a-b50c2687593d" name="TestLineBreak2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c97bb1fe-5c48-983f-8519-b7ca437ae7a8" name="TestSimpleIndentOfAttributeList" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="443e83b2-f67c-b678-33fa-68df8822fe43" name="TestEscapeEscape" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b3be3fe3-488c-8c74-397e-bfd1571f0f84" name="TestElseClause" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="70e55fc7-1a2f-4259-6af4-a2bd53f12aa1" name="TestImplicitRegionRedefError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="d22703c4-36fe-e74c-a276-c205624d9517" name="TestMapEmptyValueAndAngleBracketStrings" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="46c85b35-3efc-91c6-f122-92c3e7d3fcea" name="TestEmbeddedRegionRef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="cc61811d-b9ae-2e07-0a62-e55662d0e2a0" name="TestMultipleRefsToListAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="631b91f4-26cf-e556-330c-f90615535fd4" name="TestListAsTemplateArgument" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="ab496999-28ef-76c1-46c8-55d48c735bfa" name="TestEmbeddedRegionRefAngleBrackets" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="cee342a7-b038-5ed3-900f-6c49761ad185" name="TestAngleBracketsNoGroup" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a569e026-43cb-0948-8053-6dbdb46f9c28" name="TestDefaultArgumentImplicitlySet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="f5735b8b-fe94-0781-d293-2f93b1db9b72" name="TestApplyTemplateWithSingleFormalArgs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="67f65178-38cb-28d1-331e-c666d434a3a7" name="TestSizeZeroOnLineWithIndentGetsNoOutput" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="1751873f-8ce2-a033-c222-89cc58156464" name="TestTemplateRedef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="c67c491e-ea54-feeb-f310-a82c470d90fc" name="TestEmptyIteratedConditionalWithElseValueGetsSeparator" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="83c1f357-60c6-665c-5e75-d48f971ffe05" name="TestChangingAttrValueTemplateApplicationToVector" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="35a1504e-e452-5273-839f-5a6a51fc0887" name="TestEscapesOutsideExpressions" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="928ab338-fb07-90c1-8f11-3f60fc826e67" name="TestNestedIF" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5869adb1-b072-82ce-52fb-1b13c2935211" name="TestFortranLineWrap" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e0f6648c-8c62-43aa-95ba-8a36755dcc34" name="TestEmbeddedRegionRefWithNewlinesAngleBrackets" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="3a2c2890-7cee-c526-5ec2-f857df1a5959" name="TestParallelAttributeIterationWithSingletons" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="e4fb9edf-432a-9c5d-c6db-e272ecc4255f" name="TestSingleValuedAttributes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="8ce7fd07-d4e3-1e43-6a12-fd49d7668086" name="TestMapValuesAreTemplates" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="4a32f30a-220a-7343-4046-fee4a1ce7006" name="TestCatWithTemplateApplicationAsElement" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="a922fbdf-9eb6-d0b2-ac7c-abdb0c788068" name="TestMissingInheritedAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="c4e35019-44a4-8027-12b1-b029dc7b726f" name="TestElseIfClauseAndElse" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="4b6bcdf0-9bff-e7e6-9ece-943feb13cebe" name="TestRendererForST" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="77dd6188-175c-cb70-edf0-29b0f0e0d092" name="TestLineWrapWithDiffAnchor" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="5ef6e900-d281-e909-9452-583abb04d15e" name="TestIndentBetweenLeftJustifiedLiterals" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="d8f8ad81-26c4-6434-ada1-ee281d9b70ef" name="TestComputedPropertyName" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="9678c103-5000-a8ee-6f10-e4c2e79713b8" name="TestNullListGetsNoOutput" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="48cacd73-7a54-a727-f0e3-a0e316f991a6" name="TestLazyEvalOfSuperInApplySuperTemplateRef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="0f61ae2a-8f5a-0eb4-74ee-f3e51bd21a6f" name="TestGroupExtendsSuperGroupWithAngleBrackets" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="9ee8a781-7ff5-a372-91de-15801fd31576" name="TestNestedIndent" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="10d8ef6e-7bc6-eb2c-1de7-64b503d13a4e" name="TestMultiDirGroupLoading" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="7bf7f0f9-4e80-afa6-5fc4-8ee820fcc148" name="TestSingleExprTemplateArgumentError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="483db2c4-b830-2542-59d4-3edcc4a01f3f" name="TestTemplateArgumentEvaluatedInSurroundingContext" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="eef8e6a4-cee6-ebc9-4cfc-195a925d7910" name="TestEmbeddedComments" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="2574e754-8a62-a696-5a41-91cfa1331ca7" name="TestApplyTemplateToSingleValuedAttributeWithDefaultAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="f7c21c2f-6a54-1301-c0d4-989a04927eb9" name="TestNoDotsInTemplateNames" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="a89031af-01c2-2f51-5b31-f990ca048bdc" name="TestCatWithIFAsElement" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="d6cb5cf1-a9f7-b619-411a-3165f23692d8" name="TestTemplateNameExpression" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="149c6f4d-d751-5fe1-1039-0aa44cec3b26" name="TestMissingEndRegionError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="a8441696-c95e-89b1-20c3-9c7941149f03" name="TestCatListAndEmptyAttributes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="b555c6a5-546c-25e8-e3ae-aac466add421" name="TestReUseOfRestResult" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="74402ff1-4349-e950-e5e5-5f83780b10ff" name="TestMapKeysWithIntegerType" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="5440f694-f01d-12fd-bc58-948498cf096c" name="TestIFConditionWithTemplateApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="0419b0ae-66ac-ef6b-71d7-80b472446750" name="TestParenthesizedExpression" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="097c5d6f-a5d2-79a3-1fa5-1efabee363c0" name="TestIFBoolean" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="925dc2de-f248-47b6-dbbc-75397ea5f2e7" name="TestAnonTemplateArgs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="70b3ed25-62a0-1804-70ec-247ad34e0078" name="TestSizeZeroOnLineByItselfGetsNoOutput" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b29aecbd-473b-51c8-a42d-26ba15632c4e" name="TestUndefinedDefaultAttributeReference" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="cc61811d-b9ae-2e07-0a62-e55662d0e2a0" name="TestMultipleRefsToListAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="919c992f-9b4e-a30f-47cf-c60b2071ccd5" name="TestLengthOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e4fb9edf-432a-9c5d-c6db-e272ecc4255f" name="TestSingleValuedAttributes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ab6d943d-7382-f7c2-3ddc-2d26ba9d9405" name="TestCatListAndSingleAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6a77e947-a01d-4dc2-af73-73e6b3b48477" name="TestApplyAnonymousTemplateToAggregateAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f1a6a0f1-900f-d420-dd46-9729b5c2381c" name="TestIndex0VarWithMultipleExprs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="bf6b2f46-3908-961f-e5e7-3517a59063e7" name="TestArgumentsAsTemplatesDefaultDelimiters" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="1316fede-446f-0add-4fb8-b9e968752433" name="TestTemplateAlias" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="34b3dc9c-a559-0da2-22f2-3b4889ee0528" name="TestLengthOpSingleValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="9baa2cc2-3507-0c5b-8255-37f2bf5bedae" name="TestIncomingLists" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="edda67dd-9e59-58d5-c255-291ed7e8364c" name="TestMapDefaultValueIsKey" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="267b43b4-c413-0202-4460-e75bddd643f0" name="TestNullTemplateApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="aaa39864-e027-7e59-3b03-672d32119a9a" name="TestMultipleAdditions" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="161a5028-d3ca-64ce-f245-c987a3402767" name="TestMultiValuedAttributeWithSeparator" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="c5ae5510-0c02-7e11-d466-51c1cedd1bfd" name="TestDoNotInheritAttributesThroughFormalArgs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="7163ed86-68bc-8c17-3708-9eccaad0fa5d" name="TestIncomingListsAreNotModified" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="5c36232e-2025-f9bc-2d25-0664b178b9ac" name="TestNestedIndentedExpr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="22dd3353-436b-1711-37f4-168926c0227b" name="TestInheritArgumentFromRecursiveTemplateApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="2a6a36fb-2e47-23de-8c49-ddf948e4cb10" name="TestRepeatedApplicationOfTemplateToSingleValuedAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="a981d7a7-cc3b-2290-49ff-089b51174505" name="TestMapViaEnclosingTemplates" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="3e65262d-4c3d-7d51-d2be-ca2ece434589" name="TestStringLiteralAsAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="e4a7a2c8-9293-2ece-821f-0de5db73d898" name="TestSoleFormalTemplateArgumentInMultiApply" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="6cc5e0c3-84f5-a0a6-8081-0db7a6c6dff1" name="TestNonNullButEmptyIteratorTestsFalse" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="ce7eb8db-d1a9-7840-ff77-dba38a8cacc8" name="TestMapEmptyDefaultValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="9d913d03-4d17-cade-7892-d9660ab1fe52" name="TestArgumentContext" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="ce468e69-fe0e-9261-b8a7-a75c9f098e74" name="TestAlternativeWriter" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="c868fd80-d85b-0e3d-188d-396e6e12a0fc" name="TestApplyRepeatedAnonymousTemplateWithForeignTemplateRefToMultiValuedAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="4f48ef54-ab9e-3b19-2de9-b045ad9fa796" name="TestLastWithOneAttributeOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="6fe66374-8f72-d284-d1ba-1178e9910605" name="TestLengthOpPrimitive" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="aef0b15d-9df1-1923-b714-c655ca706b5e" name="TestParallelAttributeIterationWithMismatchArgListSizes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="d4959251-9d72-f88f-6142-0085686cab54" name="TestComplicatedSeparatorExpr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="79818e0c-e3c9-0a63-2f71-7dce5a4d9672" name="TestFormalArgumentAssignmentInApply" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="1fdeebe9-53e0-103a-b4d4-9c73da34fac4" name="TestEmptyListGetsNoOutput" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="964dcd2f-b572-3c4e-4b54-0576c281c4ce" name="TestCombinedOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="1ad0248b-14c8-e974-0ebd-3f14d84b44bf" name="TestGroupSatisfiesSingleInterface" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="dd425c91-b461-ccc9-6b91-e7e9fbb89a9e" name="TestDumpMapAndSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="38ff7db0-94cb-604a-3371-f405b9b058b2" name="TestRendererWithFormat" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="4d3bf45c-3b92-4b79-bd5e-e37be6694fc7" name="TestNullIndirectTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="0a4bb10a-a089-201b-d895-3f320c471b11" name="TestMapKeyLookupViaTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="329c12ab-fbd5-c2dc-8cad-fda287fe0e7e" name="TestTemplateGetPropertyGetsAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="d5356540-edc4-7ff8-30d5-cf49b1db2f6c" name="TestMapDefaultIsDefaultString" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5440f694-f01d-12fd-bc58-948498cf096c" name="TestIFConditionWithTemplateApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="31f910b6-4436-1801-c3b5-687ce99500a4" name="TestMapValues" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="c4c84799-6f36-2c1c-5a30-4327eda77e4b" name="TestLineWrapCharAfterWrapIsNewline" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="1aba3dcf-8f20-4d77-d34d-08751792b3e5" name="TestCat3Attributes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="43f2d35d-e529-4199-c152-418ce87dcb77" name="TestObjectPropertyReference" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="52ed7d57-599a-6fff-74a2-4a9c0dd42a06" name="TestApplyAnonymousTemplateToSingleValuedAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4300735f-dd2a-2c2e-f877-f0264bf5e78c" name="TestNestedAnonymousTemplatesAgain" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0ca549c4-bd22-bb1f-261b-98cffb1acd33" name="TestSuperTemplateRef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="47c8b938-dae1-ae21-09f3-ce047342a082" name="TestIncomingListsAreNotModified2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="256b263e-8c2c-034e-6ebc-08a73e488af1" name="TestNullValueInListNoNullOption" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="32dd044c-12f4-c9ce-8d91-9058c24886b8" name="TestAnonTemplateArgs2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b54469aa-62ce-0a0a-4a2e-ba93b6652d9b" name="TestMismatchedInterfaceTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9a0b0dd3-6e05-78af-3650-ed05964de683" name="TestParallelAttributeIterationWithDifferentSizes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a981d7a7-cc3b-2290-49ff-089b51174505" name="TestMapViaEnclosingTemplates" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5f67f7cf-a999-fbc5-b515-62278e984002" name="TestApplyAnonymousTemplateToArrayAndMapProperty" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="4b179b23-fe3a-f60e-6eed-ebc6dfebb9e1" name="TestAnonymousTemplateAccessToEnclosingAttributes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="13856f52-70e4-a8ac-61e2-a5548f2da699" name="TestTemplateApplicationAsRHSOfAssignment" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="86d36f29-feb6-4a20-0885-4ac8cc6340c4" name="TestApplyTemplateWithNoFormalArgs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4e5ad2a7-eac1-a49b-0696-9849ffa42dc3" name="TestStringCatenationOpOnArg" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="cbf09b31-1f2d-e8ed-3b58-15843c6f5d90" name="TestEmbeddedMultiLineIF" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0be859fa-8613-db49-1a2e-67b1789f47e3" name="TestNestedIFTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="157142d0-d910-63d3-66d0-f1fef9add2ff" name="TestListOfIntArrays" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ade58a1e-9ad3-7d77-9ad2-5e95065e0760" name="TestLineWrapAnchored" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f7c21c2f-6a54-1301-c0d4-989a04927eb9" name="TestNoDotsInTemplateNames" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2bab381c-c2a0-f2e5-8ecc-05f961570e9d" name="TestCat2AttributesWithApply" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="47934c2b-7483-4be6-f2bd-bbfd3c5d74ec" name="TestLastWithLengthOneListAttributeOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="e0e8a0f2-9f19-4b59-3cd1-e94ec3c31088" name="TestNullValueInListWithTemplateApply" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="c021b968-b9a5-cac6-78a9-f9d437703abf" name="TestNullIndirectTemplateApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="9696e50b-9e52-3dba-8710-85cf11f9d9f6" name="TestEscapes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9d56a24a-d656-6ab0-a7f2-eef8a7168861" name="TestApplyTemplateNameTemplateEval" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="75d13121-37ec-b175-a552-f4765c3c3685" name="TestRendererWithFormatAndList" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="465c3cad-256e-7d9c-6257-8d38b3a07251" name="TestIndexVar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="4105c938-02b3-7318-a132-697817798eb9" name="TestEmptyGroupTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="a0924cba-d4f2-5d96-8d6b-5a414cdfcefa" name="TestWhiteSpaceAtEndOfTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="3ca99b12-a84a-950f-6502-05ae73c658be" name="TestInvokeIndirectTemplateWithSingleFormalArgs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="691feccd-341a-f324-6e65-df6d1eb32123" name="TestParallelAttributeIterationWithMissingArgs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="533b3a12-a8aa-8aa6-c3af-d1413ac7ca25" name="TestNullSingleValueInListWithTemplateApply" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="b33492b7-2c96-5fe1-49ae-0cd5a946a058" name="TestCatWithNestedTemplateApplicationAsElement" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="b3aab89d-19f2-2d07-2c0e-8cb27868e8fb" name="TestRegionRefWithDefAngleBrackets" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="5b45445b-7207-a01f-9573-31ac431dabff" name="TestIndirectTemplateWithArgsApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="8ff45b62-6c96-985c-4755-cc81d673d79a" name="TestOverrideThroughConditional" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="0b904660-91db-cf1b-e6a9-25138fff3570" name="TestComplicatedInheritance" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="256b263e-8c2c-034e-6ebc-08a73e488af1" name="TestNullValueInListNoNullOption" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="5cddaaa1-8fc1-c15b-1755-635072532681" name="TestElseIfClause" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="dcaa0fea-0222-0465-d575-35a6109e1aed" name="TestReUseOfCat" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="8b569889-e592-e96c-14c2-0a1a23a3efc1" name="TestMapHiddenByFormalArg" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="5053bace-5b38-aeb5-6ed7-11e60ebcfb3e" name="TestIndexVarWithMultipleExprs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="8cb85f0d-3414-e336-6106-ce55664eae10" name="TestRestOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="c669ee0c-f106-2f02-eff4-87c41738c4fc" name="TestCharLiterals" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="2b3eaace-a9b2-0537-1caa-911c9386dae9" name="TestPassThroughAttributes2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="4e5ad2a7-eac1-a49b-0696-9849ffa42dc3" name="TestStringCatenationOpOnArg" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="4c88aeb3-8a3b-2375-3bc3-ba2b9fa3e2a9" name="Test16BitUnicodeChar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="b226efec-7007-04cc-3971-66e34b952825" name="TestNonPublicPropertyAccess" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="b7331a9f-474b-5e41-e936-33df48846e1e" name="TestRepeatedApplicationOfTemplateToMultiValuedAttributeWithSeparator" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="1192c9df-1c93-10b5-f05a-fe1d8206d7e2" name="TestRegionRefWithDefInConditional" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ce7eb8db-d1a9-7840-ff77-dba38a8cacc8" name="TestMapEmptyDefaultValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c868fd80-d85b-0e3d-188d-396e6e12a0fc" name="TestApplyRepeatedAnonymousTemplateWithForeignTemplateRefToMultiValuedAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1d5f200b-7472-967a-34fc-ef3f09208c5a" name="TestMultiValuedAttributeWithAnonymousTemplateUsingIndexVariableI" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8ebebf4d-f80c-5292-5a9c-7a392fff7c3d" name="TestSetButNotRefd" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="43f2d35d-e529-4199-c152-418ce87dcb77" name="TestObjectPropertyReference" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="267b43b4-c413-0202-4460-e75bddd643f0" name="TestNullTemplateApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4d39d3a0-dfb1-4738-8822-426318270f74" name="TestDefaultArgumentManuallySet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0b470a08-80a8-c680-aca5-1d03d8ca0582" name="TestInterfaceFileFormat" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="f2dd8fa5-3bcc-b702-8245-50dd958f50ae" name="TestNewlineNormalizationInTemplateStringPC" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="ab945285-5733-5fdc-5d6c-5f69a5492e4f" name="TestEmptyStringAndEmptyAnonTemplateAsParameterUsingDollarLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="250b81e1-0f27-15dc-9699-41b3e8fef9d7" name="TestAnonTemplateOnLeftOfApply" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="afdd665a-7b19-fb41-14cc-ca2e56cb7e2a" name="TestLengthOpOfStrippedListWithNulls" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="9d56a24a-d656-6ab0-a7f2-eef8a7168861" name="TestApplyTemplateNameTemplateEval" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="3507b32b-85bd-7340-a16d-e949e52fa290" name="TestIndentBeyondLineWidth" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="c2f33561-6e25-32d6-ce55-3af54a96997a" name="TestStripOpOfListWithNulls" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="92102684-25a7-a225-7d8f-f68cff24f10c" name="TestHashMapPropertyFetchEmbeddedStringTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="ee95beeb-c729-40a7-3527-db3303487b72" name="TestApplyAnonymousTemplateToMapAndSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="dd248781-7888-dab5-faad-bf0ad0cbff00" name="TestNullValueInList" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="70b3ed25-62a0-1804-70ec-247ad34e0078" name="TestSizeZeroOnLineByItselfGetsNoOutput" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="45ca614d-da04-db29-8e50-36688df5c925" name="TestStripOpOfSingleAlt" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="3a69f99a-2dbb-423c-bd05-5baecad4c50a" name="TestRendererWithFormatAndSeparator" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="4f472302-32bf-ea13-3c13-0d767d36f1d1" name="TestRepeatedRestOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="ab6d943d-7382-f7c2-3ddc-2d26ba9d9405" name="TestCatListAndSingleAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="02128320-6ac5-4e22-6fa1-d6f3da55ae40" name="TestEmbeddedCommentsAngleBracketed" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="b29aecbd-473b-51c8-a42d-26ba15632c4e" name="TestUndefinedDefaultAttributeReference" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="51643f13-8f84-493e-703e-2b8887edf319" name="TestIFCondWithParensDollarDelimsTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="e5022a58-86aa-7910-5fae-f58e974e663c" name="TestRegionOverride" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="ade58a1e-9ad3-7d77-9ad2-5e95065e0760" name="TestLineWrapAnchored" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="2ba3eb7f-26c5-991b-01af-f244ebf57a70" name="TestRecursion" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="443e83b2-f67c-b678-33fa-68df8822fe43" name="TestEscapeEscape" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="95ecf7c0-820b-953a-88bc-b4b1707f8a1a" name="TestApplyAnonymousTemplateToMultiValuedAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="ce0f83ae-b6ca-e5bf-e7a7-86ea1c6bcdf1" name="TestCat2Attributes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="a476faff-8e37-cb1d-5a02-b60d5df51626" name="TestFirstOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="2bad7fda-1062-3485-6a7a-9fda8e018831" name="TestSingleValueWrap" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="20989214-9031-a9f8-60d8-2a4b5a07715a" name="TestEscapeEscapeNestedAngle" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="243a05c4-8989-433b-8f28-757fa684d625" name="TestExpressionAsRHSOfAssignment" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="11d12ffd-a7ed-e580-16c5-10d7a8f995af" name="TestFirstWithOneAttributeOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="071e78bf-f23e-6bf9-cd8f-8c0b821be6b6" name="TestEmptyExprAsFirstLineGetsNoOutput" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="b3be3fe3-488c-8c74-397e-bfd1571f0f84" name="TestElseClause" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="cbf09b31-1f2d-e8ed-3b58-15843c6f5d90" name="TestEmbeddedMultiLineIF" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="fbb9f06e-4ed4-6f5a-123e-60b0c1bcbd9b" name="TestImmediateTemplateAsAttributeLoop" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="27e7e7e9-12ae-b8a9-efbf-9a21ad900341" name="TestMapViaEnclosingTemplates2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="47c8b938-dae1-ae21-09f3-ce047342a082" name="TestIncomingListsAreNotModified2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="e4ca4742-742a-ce8f-80d2-3c7d4718b07d" name="TestOverrideInheritance" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="e782a001-9335-8b49-bcdc-542646bc3bb4" name="TestEmptyIteratedConditionalValueGetsSeparator" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="e0f6648c-8c62-43aa-95ba-8a36755dcc34" name="TestEmbeddedRegionRefWithNewlinesAngleBrackets" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="2c507847-8169-53fb-1357-f4a85afa74a9" name="TestNullOptionHasEmptyNullValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="2d5f0383-4043-4a3f-60de-252947c624f1" name="TestListOfEmbeddedTemplateSeesEnclosingAttributes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="e32880cf-0ed3-afc2-1de3-06d97ea18279" name="TestEmptyIteratedValueGetsSeparator" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="4b4f34bf-7676-70ac-9131-6c5ece69ae77" name="TestLengthOpOfStrippedListWithNullsFrontAndBack" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="05ca07ca-aec6-1e3b-ed72-3030b165b2fb" name="TestRegionOverrideRefSuperRegion" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="73271f08-f68e-51b9-dbb3-0807a70a031f" name="TestTruncOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="54230e0c-daa3-7059-3a21-abeb80009840" name="TestSimpleInheritance" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="d06266d0-7733-e1ee-d987-7286bc49f686" name="TestRestWithOneAttributeOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="ee0f7ff9-3d7a-c304-0e2b-32a134dd1223" name="TestParallelAttributeIterationWithDifferentSizesTemplateRefInsideToo" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="2d0da3dd-8a0a-676e-5a7f-b3d5746d2d5b" name="TestIndex0Var" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="57834834-e7dd-eb16-499e-1c24d2c0de6a" name="TestEscapedTemplateDelimiters" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="b54469aa-62ce-0a0a-4a2e-ba93b6652d9b" name="TestMismatchedInterfaceTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="2b9f7786-8950-cbf9-3c9e-c92a92fa8035" name="TestDefaultArgumentAsTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="1d70c2d6-3982-5823-3adc-87dc117f917f" name="TestLengthOpNull" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="694f000c-5fb7-33f8-bf65-52ea13f73f92" name="TestEmptyStringAndEmptyAnonTemplateAsParameterUsingAngleBracketLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f7c7b455-75f9-a11e-0f76-b6058ac8e452" name="TestSingleExprTemplateArgument" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="14f693ae-6c1f-7535-1a1b-91403b3b80a8" name="TestSuperRegionRefError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="43b6155b-695f-15eb-ed3a-ae06eac53b93" name="TestGroupFileFormat" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1751873f-8ce2-a033-c222-89cc58156464" name="TestTemplateRedef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c4c9fb8b-d75f-a3f1-6807-113648432512" name="TestComplicatedIndirectTemplateApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ce0f83ae-b6ca-e5bf-e7a7-86ea1c6bcdf1" name="TestCat2Attributes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5d8e1c40-859f-debc-b37e-8b81d09badda" name="TestNullOptionSingleNullValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f8aba869-af5d-23c5-a9e2-c0ec9c630f4b" name="TestMap" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7bf7f0f9-4e80-afa6-5fc4-8ee820fcc148" name="TestSingleExprTemplateArgumentError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="9c248572-d7c0-d49e-c56d-dd2f13e00b08" name="TestGroupExtendsSuperGroup" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="e6232613-8db1-056c-2f92-e66985b7f482" name="TestRegionRef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="4300735f-dd2a-2c2e-f877-f0264bf5e78c" name="TestNestedAnonymousTemplatesAgain" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="8fee7b2a-9264-fc2b-054a-7a02d1e78372" name="TestPassThroughAttributes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="6a77e947-a01d-4dc2-af73-73e6b3b48477" name="TestApplyAnonymousTemplateToAggregateAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="833ba687-53e9-f9a6-4f45-6ff9f6916d7c" name="TestUnknownRegionDefError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="844505ec-5b80-2cdd-e80a-5e0b2211af69" name="TestNestedWithIndentAndTrackStartOfExpr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="4881272a-52d7-0980-7f58-244e944a35ab" name="TestLineWrapEdgeCase" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="0be859fa-8613-db49-1a2e-67b1789f47e3" name="TestNestedIFTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="d23e20b4-74ca-7088-68de-8516a694f6a2" name="TestNullSingleValueWithTemplateApply" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="6b489eb6-c3da-e2aa-17c2-9396643c89ee" name="TestLengthOpWithMap" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="757fc18c-d65c-dfdb-0237-3ea49e801835" name="TestListLiteralWithEmptyElements" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="5f67f7cf-a999-fbc5-b515-62278e984002" name="TestApplyAnonymousTemplateToArrayAndMapProperty" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="2bab381c-c2a0-f2e5-8ecc-05f961570e9d" name="TestCat2AttributesWithApply" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="1dc8b826-d5dc-df42-f3a5-38d33f122cbf" name="TestMapMissingDefaultValueIsEmpty" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="67c65aad-667c-e9ee-d234-91b8f641af44" name="TestRendererWithFormatAndSeparatorAndNull" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="5be7d853-a933-a454-e09d-b2b8770569fa" name="TestNewlineNormalizationInTemplateString" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="943804f7-7dc8-ea47-471e-2cc814862d4c" name="TestCollectionAttributes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="c4c9fb8b-d75f-a3f1-6807-113648432512" name="TestComplicatedIndirectTemplateApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="f1a6a0f1-900f-d420-dd46-9729b5c2381c" name="TestIndex0VarWithMultipleExprs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ce468e69-fe0e-9261-b8a7-a75c9f098e74" name="TestAlternativeWriter" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8ff45b62-6c96-985c-4755-cc81d673d79a" name="TestOverrideThroughConditional" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1aba3dcf-8f20-4d77-d34d-08751792b3e5" name="TestCat3Attributes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5e1ccf03-3f15-8bc4-f85b-cadc5b044a49" name="TestFirstWithCatAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="dec05f46-1133-5e06-afcc-54727d2de8fa" name="TestAnonTemplateWithArgHasNoITArg" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="96b0f408-1310-1766-b8df-e8633d03edca" name="TestDoNotUseDefaultArgument" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="243a05c4-8989-433b-8f28-757fa684d625" name="TestExpressionAsRHSOfAssignment" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4775aa30-de07-fbec-a539-34281b6a4696" name="TestSingleExprTemplateArgumentInApply" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ba2bf6af-553f-0241-3ffc-52c54e71f2ee" name="TestAttributeRefButtedUpAgainstEndifAndWhitespace" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d22703c4-36fe-e74c-a276-c205624d9517" name="TestMapEmptyValueAndAngleBracketStrings" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7163ed86-68bc-8c17-3708-9eccaad0fa5d" name="TestIncomingListsAreNotModified" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a970d0e7-1b59-9997-fcb8-10677ac4ce45" name="TestStringCatenationOpOnArgWithEqualsInString" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8dc95758-39d5-4081-72bd-d3706e472666" name="TestSizeZeroButNonNullListGetsNoOutput" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="ef3969bd-8c2f-1ba3-66fa-a2a4837cc834" name="TestMapDefaultValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="4bb829e0-d03e-a757-d584-b444bff03543" name="TestRegionRefAngleBrackets" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="10bc0ffc-5548-6be4-fb76-aad2b8bf320b" name="TestMapDefaultStringAsKey" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="97921ecd-863e-5aa2-03ab-8c637a327788" name="TestNestedAnonymousTemplates" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="a970d0e7-1b59-9997-fcb8-10677ac4ce45" name="TestStringCatenationOpOnArgWithEqualsInString" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="57deddf3-95b9-1eb3-6923-0662ccd362af" name="TestIndentOfMultilineAttributes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="04c9f0ea-2cbb-5c67-1375-23cec5b98d87" name="TestSuperReferenceInIfClause" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="9c81357e-089d-1b9b-5958-5a6d0376b008" name="TestNewlineNormalizationInAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="96b0f408-1310-1766-b8df-e8633d03edca" name="TestDoNotUseDefaultArgument" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="14f693ae-6c1f-7535-1a1b-91403b3b80a8" name="TestSuperRegionRefError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="7a920609-3def-0da1-6b02-d5418e3257c0" name="TestLastOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="8dec30e2-8893-cd6c-d0f8-4796be2169b5" name="TestEmbeddedRegionRedefError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="2e96a90a-2b23-2da1-cdf8-bc8d9b67e5d4" name="TestFormalArgumentAssignment" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="d3242c5a-ecff-32f6-9420-0f38cfed35b5" name="TestDeliberateRecursiveTemplateApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="ca6958f1-c4a9-f425-5ffd-d007df4873f9" name="TestLineWrapForAnonTemplateAnchored" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="aded18b6-aeae-edc9-3abb-3dc63b448595" name="TestLengthOpOfListWithNulls" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="c259730c-3aef-8d4f-1829-abbcfdd2927b" name="TestOverriddenRenderer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="5857e209-7452-7f2f-bf58-aad9a0a21c4a" name="TestElseIfClauseAngleBrackets" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="212391ae-3588-2620-c372-28b9f4535a4a" name="TestNoGroupLoader" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="2e7c7cdb-9905-d568-bbd2-ef215f849489" name="TestApplyTemplateToSingleValuedAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="21d28793-27eb-a41c-c494-21caa0a80527" name="TestAlternatingTemplateApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="f4b13414-9c10-2fca-dcf3-bbc9e547c4ed" name="TestLineWrapLastCharIsNewline" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="0a3162b0-40b8-0b94-bd7e-6e5de38e0317" name="TestIFCondWithParensTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="b9d92187-f0a3-5c71-f6f2-1259ffe5e6f9" name="TestIncomingArraysAreOk" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="bd744a9a-9c7a-60c1-66b2-c2138c55aad8" name="TestDefaultArgumentAsTemplate2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="c0113798-3953-f36a-8afe-801c24cae17b" name="Test3LevelSuperRef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="ae855ebd-043e-eadd-9108-e9bdcc6f21aa" name="TestElseIfClause2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3e65262d-4c3d-7d51-d2be-ca2ece434589" name="TestStringLiteralAsAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="aded18b6-aeae-edc9-3abb-3dc63b448595" name="TestLengthOpOfListWithNulls" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8ce7fd07-d4e3-1e43-6a12-fd49d7668086" name="TestMapValuesAreTemplates" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="79818e0c-e3c9-0a63-2f71-7dce5a4d9672" name="TestFormalArgumentAssignmentInApply" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="dd425c91-b461-ccc9-6b91-e7e9fbb89a9e" name="TestDumpMapAndSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2bad7fda-1062-3485-6a7a-9fda8e018831" name="TestSingleValueWrap" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="aef0b15d-9df1-1923-b714-c655ca706b5e" name="TestParallelAttributeIterationWithMismatchArgListSizes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4a72ff89-d2a8-0df4-8e4d-b66c512fa9d6" name="TestTemplatePolymorphism" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e0e8a0f2-9f19-4b59-3cd1-e94ec3c31088" name="TestNullValueInListWithTemplateApply" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6fe66374-8f72-d284-d1ba-1178e9910605" name="TestLengthOpPrimitive" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="fc342ba6-ff8c-1baa-9121-fe8e63b11b10" name="TestMissingEndRegionErrorAngleBrackets" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="964dcd2f-b572-3c4e-4b54-0576c281c4ce" name="TestCombinedOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ee95beeb-c729-40a7-3527-db3303487b72" name="TestApplyAnonymousTemplateToMapAndSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="250b81e1-0f27-15dc-9699-41b3e8fef9d7" name="TestAnonTemplateOnLeftOfApply" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="dcaa0fea-0222-0465-d575-35a6109e1aed" name="TestReUseOfCat" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="428abed9-a441-4412-265c-3dc3517ba6e4" name="TestUndefinedArgumentAssignmentInApply" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4b4f34bf-7676-70ac-9131-6c5ece69ae77" name="TestLengthOpOfStrippedListWithNullsFrontAndBack" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="87d04b4d-9d96-b7f4-e22a-974dbdc5f5fd" name="TestIndentedExpr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4ced359c-e8d4-db82-2074-ecd036a2e072" name="TestApplyingTemplateFromDiskWithPrecompiledIF" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0d70a6f5-7452-6804-5962-c5e2358fb606" name="Test8BitEuroChars" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="8c99dc10-305a-9192-f055-fca054f7b0b4" name="TestImplicitOverriddenRegionRedefError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="0d313f6e-6d2d-7d3b-f776-e0a45d71cbb7" name="TestUnicodeLiterals" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4c88aeb3-8a3b-2375-3bc3-ba2b9fa3e2a9" name="Test16BitUnicodeChar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2d5f0383-4043-4a3f-60de-252947c624f1" name="TestListOfEmbeddedTemplateSeesEnclosingAttributes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d6cb5cf1-a9f7-b619-411a-3165f23692d8" name="TestTemplateNameExpression" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7e60946b-cb95-deae-b24f-18b96f43e4fa" name="TestSimpleAutoIndent" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="37116ca3-8f6d-e51d-0d43-c93310de4dba" name="TestLineWrap" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a89031af-01c2-2f51-5b31-f990ca048bdc" name="TestCatWithIFAsElement" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a922fbdf-9eb6-d0b2-ac7c-abdb0c788068" name="TestMissingInheritedAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="35a1504e-e452-5273-839f-5a6a51fc0887" name="TestEscapesOutsideExpressions" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="15503b07-90e5-150e-1fac-f5b7efba0b65" name="TestSubtemplatesAnchorToo" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="097c5d6f-a5d2-79a3-1fa5-1efabee363c0" name="TestIFBoolean" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2a6a36fb-2e47-23de-8c49-ddf948e4cb10" name="TestRepeatedApplicationOfTemplateToSingleValuedAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="63916867-335d-1261-05b2-a6d63ab3883a" name="TestMissingInterfaceTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2b9f7786-8950-cbf9-3c9e-c92a92fa8035" name="TestDefaultArgumentAsTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="631b91f4-26cf-e556-330c-f90615535fd4" name="TestListAsTemplateArgument" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a8441696-c95e-89b1-20c3-9c7941149f03" name="TestCatListAndEmptyAttributes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c669ee0c-f106-2f02-eff4-87c41738c4fc" name="TestCharLiterals" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6676345c-c826-a7c5-c536-f00419b30e33" name="TestRegionRefWithImplicitDefInConditional" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5be7d853-a933-a454-e09d-b2b8770569fa" name="TestNewlineNormalizationInTemplateString" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6cc5e0c3-84f5-a0a6-8081-0db7a6c6dff1" name="TestNonNullButEmptyIteratorTestsFalse" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="eef8e6a4-cee6-ebc9-4cfc-195a925d7910" name="TestEmbeddedComments" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="149c6f4d-d751-5fe1-1039-0aa44cec3b26" name="TestMissingEndRegionError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="928ab338-fb07-90c1-8f11-3f60fc826e67" name="TestNestedIF" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e5022a58-86aa-7910-5fae-f58e974e663c" name="TestRegionOverride" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="22dd3353-436b-1711-37f4-168926c0227b" name="TestInheritArgumentFromRecursiveTemplateApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="844505ec-5b80-2cdd-e80a-5e0b2211af69" name="TestNestedWithIndentAndTrackStartOfExpr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="fb038d4a-c919-d59a-1599-77526002ea11" name="TestStringCatenationOnSingleValuedAttributeViaTemplateLiteral" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="fb9c3a91-e055-b248-8058-774635212306" name="TestReUseOfStripResult" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ab945285-5733-5fdc-5d6c-5f69a5492e4f" name="TestEmptyStringAndEmptyAnonTemplateAsParameterUsingDollarLexer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="05ca07ca-aec6-1e3b-ed72-3030b165b2fb" name="TestRegionOverrideRefSuperRegion" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="83c1f357-60c6-665c-5e75-d48f971ffe05" name="TestChangingAttrValueTemplateApplicationToVector" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="ad2d0887-2e56-8843-9595-92cf8f6dd276" name="TestLineWrapForAnonTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="0e40fe7a-160c-53ac-e4d2-629b58a77794" name="TestNoDotsInAttributeNames" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="fc342ba6-ff8c-1baa-9121-fe8e63b11b10" name="TestMissingEndRegionErrorAngleBrackets" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="f9a345d7-799f-d72f-8154-2af80d30a62d" name="TestExprInParens" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="52ed7d57-599a-6fff-74a2-4a9c0dd42a06" name="TestApplyAnonymousTemplateToSingleValuedAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="8ebebf4d-f80c-5292-5a9c-7a392fff7c3d" name="TestSetButNotRefd" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3ca99b12-a84a-950f-6502-05ae73c658be" name="TestInvokeIndirectTemplateWithSingleFormalArgs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3507b32b-85bd-7340-a16d-e949e52fa290" name="TestIndentBeyondLineWidth" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1d70c2d6-3982-5823-3adc-87dc117f917f" name="TestLengthOpNull" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="61b5db70-d8cc-1470-b37c-ea660c46e9c4" name="TestLineBreakDollar2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f23b09cd-4550-eedd-6d44-fef66a588383" name="TestParallelAttributeIterationWithNullValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="a2e481eb-2d75-8952-c787-604eed023296" name="TestTemplateParameterDecls" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="c3c59071-877a-34e3-c436-4006b05c73c6" name="TestIFTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="0ca549c4-bd22-bb1f-261b-98cffb1acd33" name="TestSuperTemplateRef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="f7c7b455-75f9-a11e-0f76-b6058ac8e452" name="TestSingleExprTemplateArgument" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="13ebfc90-2464-9f8f-1a22-2f86d3463083" name="TestDefaultArgument2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="919c992f-9b4e-a30f-47cf-c60b2071ccd5" name="TestLengthOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="dec05f46-1133-5e06-afcc-54727d2de8fa" name="TestAnonTemplateWithArgHasNoITArg" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="9a0b0dd3-6e05-78af-3650-ed05964de683" name="TestParallelAttributeIterationWithDifferentSizes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="86d36f29-feb6-4a20-0885-4ac8cc6340c4" name="TestApplyTemplateWithNoFormalArgs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="197a6bc7-8a27-ba13-89be-3ac61a9c5112" name="TestIndentOfMultipleBlankLines" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="1d5f200b-7472-967a-34fc-ef3f09208c5a" name="TestMultiValuedAttributeWithAnonymousTemplateUsingIndexVariableI" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="ac731860-1873-3d56-dd2c-d379a9dd6b31" name="TestStripOpOfListOfListsWithNulls" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="15503b07-90e5-150e-1fac-f5b7efba0b65" name="TestSubtemplatesAnchorToo" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="32dd044c-12f4-c9ce-8d91-9058c24886b8" name="TestAnonTemplateArgs2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="f8aba869-af5d-23c5-a9e2-c0ec9c630f4b" name="TestMap" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="7e60946b-cb95-deae-b24f-18b96f43e4fa" name="TestSimpleAutoIndent" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="8819bef6-80b4-55a8-ae24-9d8598bfb1bb" name="TestUndefinedAttributeReference" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="10ea1f1c-f002-3ca7-3ad8-1bb0bbc62c8e" name="TestLineWrapWithNormalizedNewlines" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4881272a-52d7-0980-7f58-244e944a35ab" name="TestLineWrapEdgeCase" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f9a345d7-799f-d72f-8154-2af80d30a62d" name="TestExprInParens" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0ab5d1f3-1a48-15ce-f7ec-09892d91aa78" name="TestLineWrapInNestedExpr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="74402ff1-4349-e950-e5e5-5f83780b10ff" name="TestMapKeysWithIntegerType" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="833ba687-53e9-f9a6-4f45-6ff9f6916d7c" name="TestUnknownRegionDefError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2fcc3c7e-67c5-ce2f-55f3-479dae04182e" name="TestLineBreak" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ca6958f1-c4a9-f425-5ffd-d007df4873f9" name="TestLineWrapForAnonTemplateAnchored" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="73271f08-f68e-51b9-dbb3-0807a70a031f" name="TestTruncOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="02128320-6ac5-4e22-6fa1-d6f3da55ae40" name="TestEmbeddedCommentsAngleBracketed" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0b904660-91db-cf1b-e6a9-25138fff3570" name="TestComplicatedInheritance" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="266706f8-c10d-098a-1819-7c98baeca8ca" name="TestFirstWithListOfMaps" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d5356540-edc4-7ff8-30d5-cf49b1db2f6c" name="TestMapDefaultIsDefaultString" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="afdd665a-7b19-fb41-14cc-ca2e56cb7e2a" name="TestLengthOpOfStrippedListWithNulls" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a055bddb-4395-9d9f-7175-f7c79c93931c" name="TestDefaultArgsWhenNotInvoked" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="67f65178-38cb-28d1-331e-c666d434a3a7" name="TestSizeZeroOnLineWithIndentGetsNoOutput" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="6d8bc4c1-abd1-515d-cd43-2dc489eb7e67" name="TestNullOptionSingleNullValueInList" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="da61aa5a-5cce-16bb-ea63-d8517ae40fe8" name="TestDefaultArgument" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="a46646c2-93fc-8a96-960a-4b726279e182" name="TestEmptyListNoIteratorGetsNoOutput" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="fb038d4a-c919-d59a-1599-77526002ea11" name="TestStringCatenationOnSingleValuedAttributeViaTemplateLiteral" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="5e1ccf03-3f15-8bc4-f85b-cadc5b044a49" name="TestFirstWithCatAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="a446aafa-acca-edbd-8f20-5b7a14a41c56" name="TestMissingEndDelimiter" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="3d078d2f-efb6-5fac-9cdd-f7cd385ad5c0" name="TestRestWithLengthOneListAttributeOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="454d0876-4cf3-f774-b65b-911e499fd00a" name="TestMapKeys" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d23e20b4-74ca-7088-68de-8516a694f6a2" name="TestNullSingleValueWithTemplateApply" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1429e05c-8f33-8acb-543c-3b54e356fb21" name="TestAngleBracketsWithGroupFile" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c259730c-3aef-8d4f-1829-abbcfdd2927b" name="TestOverriddenRenderer" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d06266d0-7733-e1ee-d987-7286bc49f686" name="TestRestWithOneAttributeOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1ad0248b-14c8-e974-0ebd-3f14d84b44bf" name="TestGroupSatisfiesSingleInterface" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1316fede-446f-0add-4fb8-b9e968752433" name="TestTemplateAlias" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8819bef6-80b4-55a8-ae24-9d8598bfb1bb" name="TestUndefinedAttributeReference" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a476faff-8e37-cb1d-5a02-b60d5df51626" name="TestFirstOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9678c103-5000-a8ee-6f10-e4c2e79713b8" name="TestNullListGetsNoOutput" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d0901ffa-9fae-84d5-36e2-e3cdc4153535" name="TestDefaultArgumentImplicitlySet2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="97921ecd-863e-5aa2-03ab-8c637a327788" name="TestNestedAnonymousTemplates" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="97be06d7-a77a-ab06-46cc-c421bcff632e" name="TestDefaultArgumentInParensToEvalEarly" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8dec30e2-8893-cd6c-d0f8-4796be2169b5" name="TestEmbeddedRegionRedefError" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4b6bcdf0-9bff-e7e6-9ece-943feb13cebe" name="TestRendererForST" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0419b0ae-66ac-ef6b-71d7-80b472446750" name="TestParenthesizedExpression" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7a920609-3def-0da1-6b02-d5418e3257c0" name="TestLastOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="943804f7-7dc8-ea47-471e-2cc814862d4c" name="TestCollectionAttributes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="92102684-25a7-a225-7d8f-f68cff24f10c" name="TestHashMapPropertyFetchEmbeddedStringTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9ee8a781-7ff5-a372-91de-15801fd31576" name="TestNestedIndent" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7e0bc3e2-04bb-5d7d-ef47-7b94689b1dc6" name="TestNullValueInListWithTemplateApplyNullFirstValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1fdeebe9-53e0-103a-b4d4-9c73da34fac4" name="TestEmptyListGetsNoOutput" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="48cacd73-7a54-a727-f0e3-a0e316f991a6" name="TestLazyEvalOfSuperInApplySuperTemplateRef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f217257c-d872-4003-3d51-4074e541cbf1" name="TestRepeatedIteratedAttrFromArg" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="161a5028-d3ca-64ce-f245-c987a3402767" name="TestMultiValuedAttributeWithSeparator" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="20989214-9031-a9f8-60d8-2a4b5a07715a" name="TestEscapeEscapeNestedAngle" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4d3bf45c-3b92-4b79-bd5e-e37be6694fc7" name="TestNullIndirectTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2d0da3dd-8a0a-676e-5a7f-b3d5746d2d5b" name="TestIndex0Var" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f6052295-fc31-35d3-176c-2f8e2dfda847" name="TestRegionOverrideRefSuperRegion3Levels" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2b3eaace-a9b2-0537-1caa-911c9386dae9" name="TestPassThroughAttributes2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="1d53a0a8-3cfb-d55e-db56-9902e36c01e4" name="TestMissingOptionalInterfaceTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5b45445b-7207-a01f-9573-31ac431dabff" name="TestIndirectTemplateWithArgsApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8cb85f0d-3414-e336-6106-ce55664eae10" name="TestRestOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9c81357e-089d-1b9b-5958-5a6d0376b008" name="TestNewlineNormalizationInAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5cddaaa1-8fc1-c15b-1755-635072532681" name="TestElseIfClause" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="621dc32c-648f-5bec-4f2e-cf53562a0bd0" name="TestUndefinedArgumentAssignment" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="858bf68b-c8ca-9a4d-3989-5513441e94f2" name="TestTemplateApplicationAsOptionValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9696e50b-9e52-3dba-8710-85cf11f9d9f6" name="TestEscapes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="34b3dc9c-a559-0da2-22f2-3b4889ee0528" name="TestLengthOpSingleValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4105c938-02b3-7318-a132-697817798eb9" name="TestEmptyGroupTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="3e1641b4-06ac-ae2b-2551-abbbc095af98" name="TestFindTemplateInCLASSPATH" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="a4cbd45c-445a-93d1-bd0d-d6a9404b3ab3" name="TestParallelAttributeIteration" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="af0c6ab6-f1d1-bf9c-4144-3936b3b46b30" name="TestHashMapPropertyFetch" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="5d8e1c40-859f-debc-b37e-8b81d09badda" name="TestNullOptionSingleNullValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="4ced359c-e8d4-db82-2074-ecd036a2e072" name="TestApplyingTemplateFromDiskWithPrecompiledIF" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="157142d0-d910-63d3-66d0-f1fef9add2ff" name="TestListOfIntArrays" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="6676345c-c826-a7c5-c536-f00419b30e33" name="TestRegionRefWithImplicitDefInConditional" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="0cca0749-d905-b00d-edb6-7414545e579e" name="TestMultiLevelInheritance" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="ba2bf6af-553f-0241-3ffc-52c54e71f2ee" name="TestAttributeRefButtedUpAgainstEndifAndWhitespace" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="6333032c-25d9-4497-f015-5d9ecd3d81ae" name="TestEmbeddedRendererSeesEnclosing" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="0d70a6f5-7452-6804-5962-c5e2358fb606" name="Test8BitEuroChars" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="4801a924-a9e7-adfd-3afa-9c6b1c2a55cc" name="TestRendererForGroup" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="266706f8-c10d-098a-1819-7c98baeca8ca" name="TestFirstWithListOfMaps" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="37116ca3-8f6d-e51d-0d43-c93310de4dba" name="TestLineWrap" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="a1493dcb-6617-e844-560b-f9032cf95b61" name="TestApplySuperTemplateRef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="0b470a08-80a8-c680-aca5-1d03d8ca0582" name="TestInterfaceFileFormat" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="4775aa30-de07-fbec-a539-34281b6a4696" name="TestSingleExprTemplateArgumentInApply" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="c97bb1fe-5c48-983f-8519-b7ca437ae7a8" name="TestSimpleIndentOfAttributeList" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="1036a13b-e95e-df51-c9fe-07666e6242e1" name="TestJustCat" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="7e0bc3e2-04bb-5d7d-ef47-7b94689b1dc6" name="TestNullValueInListWithTemplateApplyNullFirstValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="8dbe4c75-1799-c60a-df22-961aaaeaea04" name="TestParameterAndAttributeScoping" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="147d2f91-a897-aee1-809e-1c35dccc6709" name="TestLineDoesNotWrapDueToLiteral" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="25280a52-1aac-d2b7-c101-624db74c912f" name="TestParallelAttributeIterationHasI" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="aaa39864-e027-7e59-3b03-672d32119a9a" name="TestMultipleAdditions" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2574e754-8a62-a696-5a41-91cfa1331ca7" name="TestApplyTemplateToSingleValuedAttributeWithDefaultAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="1b59210a-f614-837c-21b4-c22a81dbb203" name="TestLineWrapForAnonTemplateComplicatedWrap" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="428abed9-a441-4412-265c-3dc3517ba6e4" name="TestUndefinedArgumentAssignmentInApply" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="63916867-335d-1261-05b2-a6d63ab3883a" name="TestMissingInterfaceTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="43b6155b-695f-15eb-ed3a-ae06eac53b93" name="TestGroupFileFormat" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8b569889-e592-e96c-14c2-0a1a23a3efc1" name="TestMapHiddenByFormalArg" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c3c59071-877a-34e3-c436-4006b05c73c6" name="TestIFTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4f48ef54-ab9e-3b19-2de9-b045ad9fa796" name="TestLastWithOneAttributeOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="329c12ab-fbd5-c2dc-8cad-fda287fe0e7e" name="TestTemplateGetPropertyGetsAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8dbe4c75-1799-c60a-df22-961aaaeaea04" name="TestParameterAndAttributeScoping" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e6232613-8db1-056c-2f92-e66985b7f482" name="TestRegionRef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="fbb9f06e-4ed4-6f5a-123e-60b0c1bcbd9b" name="TestImmediateTemplateAsAttributeLoop" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="155124f5-7cf4-0220-209a-961dfaa8d0d2" name="TestCatWithNullTemplateApplicationAsElement" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ab496999-28ef-76c1-46c8-55d48c735bfa" name="TestEmbeddedRegionRefAngleBrackets" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a0924cba-d4f2-5d96-8d6b-5a414cdfcefa" name="TestWhiteSpaceAtEndOfTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="212391ae-3588-2620-c372-28b9f4535a4a" name="TestNoGroupLoader" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="4460f2ff-81f1-53d5-7521-3715705174e1" name="TestArgEvaluationContext" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="f217257c-d872-4003-3d51-4074e541cbf1" name="TestRepeatedIteratedAttrFromArg" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="babfe618-007d-b5c2-98ae-a8c6287e3956" name="TestIndirectTemplateApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="fce7c8b6-1453-40f6-a2d9-b980f947a5a7" name="TestApplyTemplateNameExpression" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="57834834-e7dd-eb16-499e-1c24d2c0de6a" name="TestEscapedTemplateDelimiters" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="dd248781-7888-dab5-faad-bf0ad0cbff00" name="TestNullValueInList" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4f472302-32bf-ea13-3c13-0d767d36f1d1" name="TestRepeatedRestOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2ba3eb7f-26c5-991b-01af-f244ebf57a70" name="TestRecursion" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="10ea1f1c-f002-3ca7-3ad8-1bb0bbc62c8e" name="TestLineWrapWithNormalizedNewlines" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ee0f7ff9-3d7a-c304-0e2b-32a134dd1223" name="TestParallelAttributeIterationWithDifferentSizesTemplateRefInsideToo" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6333032c-25d9-4497-f015-5d9ecd3d81ae" name="TestEmbeddedRendererSeesEnclosing" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f4b13414-9c10-2fca-dcf3-bbc9e547c4ed" name="TestLineWrapLastCharIsNewline" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8fee7b2a-9264-fc2b-054a-7a02d1e78372" name="TestPassThroughAttributes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0a4bb10a-a089-201b-d895-3f320c471b11" name="TestMapKeyLookupViaTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1e34e569-da63-f98a-279d-eb62f8336713" name="TestArgumentsAsTemplates" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="e4ca4742-742a-ce8f-80d2-3c7d4718b07d" name="TestOverrideInheritance" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b3aab89d-19f2-2d07-2c0e-8cb27868e8fb" name="TestRegionRefWithDefAngleBrackets" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d8f8ad81-26c4-6434-ada1-ee281d9b70ef" name="TestComputedPropertyName" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d3242c5a-ecff-32f6-9420-0f38cfed35b5" name="TestDeliberateRecursiveTemplateApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c4c84799-6f36-2c1c-5a30-4327eda77e4b" name="TestLineWrapCharAfterWrapIsNewline" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b9d92187-f0a3-5c71-f6f2-1259ffe5e6f9" name="TestIncomingArraysAreOk" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="925dc2de-f248-47b6-dbbc-75397ea5f2e7" name="TestAnonTemplateArgs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="454d0876-4cf3-f774-b65b-911e499fd00a" name="TestMapKeys" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="691feccd-341a-f324-6e65-df6d1eb32123" name="TestParallelAttributeIterationWithMissingArgs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="be90ab80-fd0b-3923-540d-be7c9b70da1e" name="TestDateTimeFormatting" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5c36232e-2025-f9bc-2d25-0664b178b9ac" name="TestNestedIndentedExpr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="57deddf3-95b9-1eb3-6923-0662ccd362af" name="TestIndentOfMultilineAttributes" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3b65d607-cbcc-5f74-b144-7cd384697e40" name="TestBackslash" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a446aafa-acca-edbd-8f20-5b7a14a41c56" name="TestMissingEndDelimiter" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="4a32f30a-220a-7343-4046-fee4a1ce7006" name="TestCatWithTemplateApplicationAsElement" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="13ebfc90-2464-9f8f-1a22-2f86d3463083" name="TestDefaultArgument2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="10bc0ffc-5548-6be4-fb76-aad2b8bf320b" name="TestMapDefaultStringAsKey" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="21d28793-27eb-a41c-c494-21caa0a80527" name="TestAlternatingTemplateApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="b8e0cb54-9199-5afe-4e00-071d76e71c46" name="TestLengthOpWithSet" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="3ced3a2c-6120-cab7-f46e-93e09a4991ca" name="TestRegionOverrideRefSuperImplicitRegion" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="f23b09cd-4550-eedd-6d44-fef66a588383" name="TestParallelAttributeIterationWithNullValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="fb9c3a91-e055-b248-8058-774635212306" name="TestReUseOfStripResult" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="4444e888-11e5-18dd-ca7f-dd500680a28a" name="TestCannotFindInterfaceFile" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="0ab5d1f3-1a48-15ce-f7ec-09892d91aa78" name="TestLineWrapInNestedExpr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="d05ebb71-321e-c897-3bc5-201799a16169" name="TestRestOpEmptyList" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3a69f99a-2dbb-423c-bd05-5baecad4c50a" name="TestRendererWithFormatAndSeparator" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b7331a9f-474b-5e41-e936-33df48846e1e" name="TestRepeatedApplicationOfTemplateToMultiValuedAttributeWithSeparator" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c5ae5510-0c02-7e11-d466-51c1cedd1bfd" name="TestDoNotInheritAttributesThroughFormalArgs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3d078d2f-efb6-5fac-9cdd-f7cd385ad5c0" name="TestRestWithLengthOneListAttributeOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a4cbd45c-445a-93d1-bd0d-d6a9404b3ab3" name="TestParallelAttributeIteration" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="11d12ffd-a7ed-e580-16c5-10d7a8f995af" name="TestFirstWithOneAttributeOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="757fc18c-d65c-dfdb-0237-3ea49e801835" name="TestListLiteralWithEmptyElements" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7fa290c3-80e6-fb1e-a971-93acc401075a" name="TestMissingIteratedConditionalValueGetsNoSeparator2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6b489eb6-c3da-e2aa-17c2-9396643c89ee" name="TestLengthOpWithMap" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="cee342a7-b038-5ed3-900f-6c49761ad185" name="TestAngleBracketsNoGroup" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="54230e0c-daa3-7059-3a21-abeb80009840" name="TestSimpleInheritance" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="465c3cad-256e-7d9c-6257-8d38b3a07251" name="TestIndexVar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="edda67dd-9e59-58d5-c255-291ed7e8364c" name="TestMapDefaultValueIsKey" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="5053bace-5b38-aeb5-6ed7-11e60ebcfb3e" name="TestIndexVarWithMultipleExprs" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="11a84016-83c2-f9a3-4f54-23f2d7aea8dc" name="TestNullTemplateToMultiValuedApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="a9c71eca-2007-73da-d1b5-ba0847ad8b3c" name="TestChangingAttrValueRepeatedTemplateApplicationToVector" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="77dd6188-175c-cb70-edf0-29b0f0e0d092" name="TestLineWrapWithDiffAnchor" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="155124f5-7cf4-0220-209a-961dfaa8d0d2" name="TestCatWithNullTemplateApplicationAsElement" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="87d04b4d-9d96-b7f4-e22a-974dbdc5f5fd" name="TestIndentedExpr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="1e34e569-da63-f98a-279d-eb62f8336713" name="TestArgumentsAsTemplates" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="5869adb1-b072-82ce-52fb-1b13c2935211" name="TestFortranLineWrap" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="b33492b7-2c96-5fe1-49ae-0cd5a946a058" name="TestCatWithNestedTemplateApplicationAsElement" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9baa2cc2-3507-0c5b-8255-37f2bf5bedae" name="TestIncomingLists" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ac731860-1873-3d56-dd2c-d379a9dd6b31" name="TestStripOpOfListOfListsWithNulls" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="6e7e1492-2c92-9f42-fd6e-cb014f7ea9b2" name="TestBackslash2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="533b3a12-a8aa-8aa6-c3af-d1413ac7ca25" name="TestNullSingleValueInListWithTemplateApply" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="c787665f-8ec3-7ca4-9ded-3acca1bb0244" name="TestStripOpOfNull" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="babfe618-007d-b5c2-98ae-a8c6287e3956" name="TestIndirectTemplateApplication" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="8dc95758-39d5-4081-72bd-d3706e472666" name="TestSizeZeroButNonNullListGetsNoOutput" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="4a72ff89-d2a8-0df4-8e4d-b66c512fa9d6" name="TestTemplatePolymorphism" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="858bf68b-c8ca-9a4d-3989-5513441e94f2" name="TestTemplateApplicationAsOptionValue" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="fce7c8b6-1453-40f6-a2d9-b980f947a5a7" name="TestApplyTemplateNameExpression" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="621dc32c-648f-5bec-4f2e-cf53562a0bd0" name="TestUndefinedArgumentAssignment" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="a055bddb-4395-9d9f-7175-f7c79c93931c" name="TestDefaultArgsWhenNotInvoked" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2e96a90a-2b23-2da1-cdf8-bc8d9b67e5d4" name="TestFormalArgumentAssignment" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="50988fd0-4520-f8de-3093-f642b920e9fd" name="TestMissingIteratedConditionalValueGetsNoSeparator" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0f61ae2a-8f5a-0eb4-74ee-f3e51bd21a6f" name="TestGroupExtendsSuperGroupWithAngleBrackets" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3e2634b3-762f-f3e3-790c-62536df0939d" name="TestMissingIteratedDoubleConditionalValueGetsNoSeparator" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="46c85b35-3efc-91c6-f122-92c3e7d3fcea" name="TestEmbeddedRegionRef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="2e7c7cdb-9905-d568-bbd2-ef215f849489" name="TestApplyTemplateToSingleValuedAttribute" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1dc8b826-d5dc-df42-f3a5-38d33f122cbf" name="TestMapMissingDefaultValueIsEmpty" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="147d2f91-a897-aee1-809e-1c35dccc6709" name="TestLineDoesNotWrapDueToLiteral" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a1493dcb-6617-e844-560b-f9032cf95b61" name="TestApplySuperTemplateRef" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0a3162b0-40b8-0b94-bd7e-6e5de38e0317" name="TestIFCondWithParensTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="da61aa5a-5cce-16bb-ea63-d8517ae40fe8" name="TestDefaultArgument" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="38ff7db0-94cb-604a-3371-f405b9b058b2" name="TestRendererWithFormat" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="25280a52-1aac-d2b7-c101-624db74c912f" name="TestParallelAttributeIterationHasI" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="59a0974c-a88d-2c43-a7ea-cf26fb29c7bf" name="TestIteratedConditionalWithEmptyElseValueGetsSeparator" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="ae855ebd-043e-eadd-9108-e9bdcc6f21aa" name="TestElseIfClause2" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="13856f52-70e4-a8ac-61e2-a5548f2da699" name="TestTemplateApplicationAsRHSOfAssignment" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="071e78bf-f23e-6bf9-cd8f-8c0b821be6b6" name="TestEmptyExprAsFirstLineGetsNoOutput" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
<TestLink id="c9c5b11a-7a30-077c-e712-8773a1ad20dd" name="TestNestedOp" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
-      <TestLink id="f6052295-fc31-35d3-176c-2f8e2dfda847" name="TestRegionOverrideRefSuperRegion3Levels" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
</TestLinks>
</TestList>
<TestList name="Sets" id="f79900aa-8296-4e3b-8fcb-0d69c0ab01ee" parentListId="8c43106b-9dc1-4907-a29f-aa66a61bf5b6">
diff --git a/AntlrTestConfig.testrunconfig b/AntlrTestConfig.testrunconfig
index 32801b7..62bb815 100644
--- a/AntlrTestConfig.testrunconfig
+++ b/AntlrTestConfig.testrunconfig
@@ -1,10 +1,10 @@
﻿<?xml version="1.0" encoding="UTF-8"?>
<TestRunConfiguration name="AntlrTestConfig" id="ffdb4029-8f84-4bbb-9829-cc1e67c5715e" xmlns="http://microsoft.com/schemas/VisualStudio/TeamTest/2006">
<Description>This is a default test run configuration for a local test run.</Description>
-  <Deployment>
+  <Deployment enabled="false">
+    <DeploymentItem filename="bin\Debug\Targets\" />
<DeploymentItem filename="..\antlr\main\tool\src\main\resources\org\antlr\" />
</Deployment>
-  <Scripts setupScript=".\SetupTestRun.bat" cleanupScript=".\CleanupTestRun.bat" />
<TestTypeSpecific>
<WebTestRunConfiguration testTypeId="4e7599fa-5ecb-43e9-a887-cd63cf72d207">
<Browser name="Internet Explorer 7.0">
diff --git a/StringTemplate4/AutoIndentWriter.cs b/StringTemplate4/AutoIndentWriter.cs
new file mode 100644
index 0000000..0a0db49
--- /dev/null
+++ b/StringTemplate4/AutoIndentWriter.cs
@@ -0,0 +1,276 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    using System.Collections.Generic;
+    using Array = System.Array;
+    using Environment = System.Environment;
+    using StringBuilder = System.Text.StringBuilder;
+    using TextWriter = System.IO.TextWriter;
+
+    public class AutoIndentWriter : ITemplateWriter
+    {
+        public static readonly int NoWrap = -1;
+
+        /** stack of indents; use List as it's much faster than Stack. Grows
+         *  from 0..n-1.
+         */
+        protected IList<string> indents = new List<string>();
+
+        /** Stack of integer anchors (char positions in line); avoid Integer
+         *  creation overhead.
+         */
+        protected int[] anchors = new int[10];
+        protected int anchors_sp = -1;
+
+        /** \n or \r\n? */
+        protected string newline;
+
+        protected TextWriter @out = null;
+        protected bool atStartOfLine = true;
+
+        /** Track char position in the line (later we can think about tabs).
+         *  Indexed from 0.  We want to keep charPosition <= lineWidth.
+         *  This is the position we are *about* to write not the position
+         *  last written to.
+         */
+        protected int charPosition = 0;
+        protected int lineWidth = NoWrap;
+
+        protected int charPositionOfStartOfExpr = 0;
+
+        public AutoIndentWriter(TextWriter @out, string newline)
+        {
+            this.@out = @out;
+            indents.Add(null); // s oftart with no indent
+            this.newline = newline;
+        }
+
+        public AutoIndentWriter(TextWriter @out)
+            : this(@out, Environment.NewLine)
+        {
+        }
+
+        public virtual void SetLineWidth(int lineWidth)
+        {
+            this.lineWidth = lineWidth;
+        }
+
+        /** Push even blank (null) indents as they are like scopes; must
+         *  be able to pop them back off stack.
+         *
+         *  To deal with combined anchors and indentation, force indents to
+         *  include any current anchor point.  If current anchor is beyond
+         *  current indent width, add the difference to the indent to be added.
+         *
+         *  This prevents a check later to deal with anchors when starting new line.
+         */
+        public virtual void PushIndentation(string indent)
+        {
+            int lastAnchor = 0;
+            int indentWidth = GetIndentationWidth();
+            // If current anchor is beyond current indent width, add in difference
+            if (anchors_sp >= 0 && anchors[anchors_sp] > indentWidth)
+            {
+                lastAnchor = anchors[anchors_sp];
+                StringBuilder buf = GetIndentString(lastAnchor - indentWidth);
+                if (indent != null)
+                    buf.Append(indent); // don't add if null
+                indents.Add(buf.ToString());
+                return;
+            }
+            indents.Add(indent);
+        }
+
+        public virtual string PopIndentation()
+        {
+            var result = indents[indents.Count - 1];
+            indents.RemoveAt(indents.Count - 1);
+            return result;
+        }
+
+        public virtual void PushAnchorPoint()
+        {
+            if ((anchors_sp + 1) >= anchors.Length)
+            {
+                int[] a = new int[anchors.Length * 2];
+                Array.Copy(anchors, 0, a, 0, anchors.Length - 1);
+                anchors = a;
+            }
+            anchors_sp++;
+            anchors[anchors_sp] = charPosition;
+        }
+
+        public virtual void PopAnchorPoint()
+        {
+            anchors_sp--;
+        }
+
+        public virtual int GetIndentationWidth()
+        {
+            int n = 0;
+            for (int i = 0; i < indents.Count; i++)
+            {
+                string ind = indents[i];
+                if (ind != null)
+                {
+                    n += ind.Length;
+                }
+            }
+            return n;
+        }
+
+        /** Write out a string literal or attribute expression or expression element.*/
+        public virtual int Write(string str)
+        {
+            int n = 0;
+            for (int i = 0; i < str.Length; i++)
+            {
+                char c = str[i];
+                // found \n or \r\n newline?
+                if (c == '\r' || c == '\n')
+                {
+                    atStartOfLine = true;
+                    charPosition = -1; // set so the write below sets to 0
+                    n += newline.Length;
+                    @out.Write(newline);
+                    charPosition += n; // wrote n more char
+                    // skip an extra char upon \r\n
+                    if ((c == '\r' && (i + 1) < str.Length && str[i + 1] == '\n'))
+                    {
+                        i++; // loop iteration i++ takes care of skipping 2nd char
+                    }
+                    continue;
+                }
+                // normal character
+                // check to see if we are at the start of a line; need indent if so
+                if (atStartOfLine)
+                {
+                    n += Indent();
+                    atStartOfLine = false;
+                }
+                n++;
+                @out.Write(c);
+                charPosition++;
+            }
+            return n;
+        }
+
+        public virtual int WriteSeparator(string str)
+        {
+            return Write(str);
+        }
+
+        /** Write out a string literal or attribute expression or expression element.
+         *
+         *  If doing line wrap, then check wrap before emitting this str.  If
+         *  at or beyond desired line width then emit a \n and any indentation
+         *  before spitting out this str.
+         */
+        public virtual int Write(string str, string wrap)
+        {
+            int n = WriteWrapSeparator(wrap);
+            return n + Write(str);
+        }
+
+        public virtual int WriteWrapSeparator(string wrap)
+        {
+            int n = 0;
+            // if want wrap and not already at start of line (last char was \n)
+            // and we have hit or exceeded the threshold
+            if (lineWidth != NoWrap && wrap != null && !atStartOfLine &&
+                 charPosition >= lineWidth)
+            {
+                // ok to wrap
+                // Walk wrap string and look for A\nB.  Spit out A\n
+                // then spit indent or anchor, whichever is larger
+                // then spit out B.
+                for (int i = 0; i < wrap.Length; i++)
+                {
+                    char c = wrap[i];
+                    if (c == '\n')
+                    {
+                        n++;
+                        @out.Write(c);
+                        charPosition = 0;
+                        n += Indent();
+                        // continue writing any chars out
+                    }
+                    else
+                    {  // write A or B part
+                        n++;
+                        @out.Write(c);
+                        charPosition++;
+                    }
+                }
+            }
+            return n;
+        }
+
+        public virtual int Indent()
+        {
+            int n = 0;
+            for (int i = 0; i < indents.Count; i++)
+            {
+                string ind = indents[i];
+                if (ind != null)
+                {
+                    n += ind.Length;
+                    @out.Write(ind);
+                }
+            }
+            charPosition += n;
+            return n;
+        }
+
+        public virtual int Indent(int spaces)
+        {
+            for (int i = 1; i <= spaces; i++)
+            {
+                @out.Write(' ');
+            }
+            charPosition += spaces;
+            return spaces;
+        }
+
+        protected virtual StringBuilder GetIndentString(int spaces)
+        {
+            StringBuilder buf = new StringBuilder();
+            for (int i = 1; i <= spaces; i++)
+            {
+                buf.Append(' ');
+            }
+            return buf;
+        }
+    }
+}
diff --git a/StringTemplate4/BlankTemplate.cs b/StringTemplate4/BlankTemplate.cs
new file mode 100644
index 0000000..865b784
--- /dev/null
+++ b/StringTemplate4/BlankTemplate.cs
@@ -0,0 +1,75 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    public class BlankTemplate : Template
+    {
+        public BlankTemplate()
+        {
+            code = new CompiledTemplate();
+        }
+
+        public BlankTemplate(string template)
+            : this()
+        {
+        }
+
+        public override void Add(string name, object value)
+        {
+        }
+
+        protected internal override void RawSetAttribute(string name, object value)
+        {
+        }
+
+        public override object GetAttribute(string name)
+        {
+            return null;
+        }
+
+        public override string GetEnclosingInstanceStackString()
+        {
+            return null;
+        }
+
+        public override int Write(ITemplateWriter @out)
+        {
+            return 0;
+        }
+
+        public override string Render()
+        {
+            return string.Empty;
+        }
+    }
+}
diff --git a/StringTemplate4/Bytecode.cs b/StringTemplate4/Bytecode.cs
new file mode 100644
index 0000000..7f45b11
--- /dev/null
+++ b/StringTemplate4/Bytecode.cs
@@ -0,0 +1,166 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    public class Bytecode
+    {
+        public const int OPND_SIZE_IN_BYTES = 2;
+        public const int STRING = 1;
+        public const int ADDR = 2;
+        public const int INT = 3;
+
+        public class Instruction
+        {
+            internal string name; // E.g., "load_str", "new"
+            internal int[] type = new int[3];
+            internal int n = 0;
+
+            public Instruction(string name)
+                : this(name, 0, 0, 0)
+            {
+                n = 0;
+            }
+
+            public Instruction(string name, int a)
+                : this(name, a, 0, 0)
+            {
+                n = 1;
+            }
+
+            public Instruction(string name, int a, int b)
+                : this(name, a, b, 0)
+            {
+                n = 2;
+            }
+
+            public Instruction(string name, int a, int b, int c)
+            {
+                this.name = name;
+                type[0] = a;
+                type[1] = b;
+                type[2] = c;
+                n = 3;
+            }
+        }
+
+        // INSTRUCTION BYTECODES (byte is signed; use a short to keep 0..255)
+        public const short INSTR_LOAD_STR = 1;
+        public const short INSTR_LOAD_ATTR = 2;
+        public const short INSTR_LOAD_LOCAL = 3; // load stuff like it, i, i0
+        public const short INSTR_LOAD_PROP = 4;
+        public const short INSTR_LOAD_PROP_IND = 5;
+        public const short INSTR_STORE_ATTR = 6;
+        public const short INSTR_STORE_SOLE_ARG = 7;
+        public const short INSTR_SET_PASS_THRU = 8;
+        public const short INSTR_STORE_OPTION = 9;
+        public const short INSTR_NEW = 10;  // create new template instance
+        public const short INSTR_NEW_IND = 11;  // create new template instance using value on stack
+        public const short INSTR_WRITE = 12;
+        public const short INSTR_WRITE_OPT = 13;
+        public const short INSTR_MAP = 14;  // <a:b()>, <a:b():c()>, <a:{...}>
+        public const short INSTR_ROT_MAP = 15;  // <a:b(),c()>
+        public const short INSTR_PAR_MAP = 16;  // <names,phones:{n,p | ...}>
+        public const short INSTR_BR = 17;
+        public const short INSTR_BRF = 18;
+        public const short INSTR_OPTIONS = 19;  // push options block
+        public const short INSTR_LIST = 20;
+        public const short INSTR_ADD = 21;
+        public const short INSTR_TOSTR = 22;
+        // Predefined functions
+        public const short INSTR_NOOP = 23; // do nothing
+        public const short INSTR_FIRST = 24;
+        public const short INSTR_LAST = 25;
+        public const short INSTR_REST = 26;
+        public const short INSTR_TRUNC = 27;
+        public const short INSTR_STRIP = 28;
+        public const short INSTR_TRIM = 29;
+        public const short INSTR_LENGTH = 30;
+        public const short INSTR_STRLEN = 31;
+        public const short INSTR_REVERSE = 32;
+
+        public const short INSTR_NOT = 33;
+        public const short INSTR_OR = 34;
+        public const short INSTR_AND = 35;
+
+        public const short INSTR_INDENT = 36;
+        public const short INSTR_DEDENT = 37;
+        public const short INSTR_NEWLINE = 38;
+
+        /** Used for assembly/disassembly; describes instruction set */
+        // START: instr
+        public static Instruction[] instructions =
+            new Instruction[]
+            {
+                null, // <INVALID>
+                new Instruction("load_str",STRING), // index is the opcode
+                new Instruction("load_attr",STRING),
+                new Instruction("load_local",STRING),
+                new Instruction("load_prop",STRING),
+                new Instruction("load_prop_ind"),
+                new Instruction("store_attr",STRING),
+                new Instruction("store_sole_arg"),
+                new Instruction("set_pass_thru"),
+                new Instruction("store_option",INT),
+                new Instruction("new",STRING),
+                new Instruction("new_ind"),
+                new Instruction("write"),
+                new Instruction("write_opt"),
+                new Instruction("map"),
+                new Instruction("rot_map", INT),
+                new Instruction("par_map", INT),
+                new Instruction("br", ADDR),
+                new Instruction("brf", ADDR),
+                new Instruction("options"),
+                new Instruction("list"),
+                new Instruction("add"),
+                new Instruction("tostr"),
+                new Instruction("noop"),
+                new Instruction("first"),
+                new Instruction("last"),
+                new Instruction("rest"),
+                new Instruction("trunc"),
+                new Instruction("strip"),
+                new Instruction("trim"),
+                new Instruction("length"),
+                new Instruction("strlen"),
+                new Instruction("reverse"),
+                new Instruction("not"),
+                new Instruction("or"),
+                new Instruction("and"),
+                new Instruction("indent", STRING),
+                new Instruction("dedent"),
+                new Instruction("newline")
+            };
+        // END: instr
+    }
+}
diff --git a/StringTemplate4/BytecodeDisassembler.cs b/StringTemplate4/BytecodeDisassembler.cs
new file mode 100644
index 0000000..13d9178
--- /dev/null
+++ b/StringTemplate4/BytecodeDisassembler.cs
@@ -0,0 +1,199 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    using System.Collections.Generic;
+    using ArgumentException = System.ArgumentException;
+    using StringBuilder = System.Text.StringBuilder;
+
+    public class BytecodeDisassembler
+    {
+        // TODO: make disassembler point at compiledST code?
+        byte[] code;
+        int codeSize;
+        protected object[] strings;
+        Bytecode def;
+
+        public BytecodeDisassembler(byte[] code,
+                                    int codeSize,
+                                    string[] strings)
+        {
+            this.code = code;
+            this.codeSize = codeSize;
+            this.strings = strings;
+        }
+
+        public virtual string Instructions()
+        {
+            StringBuilder buf = new StringBuilder();
+            int ip = 0;
+            while (ip < codeSize)
+            {
+                if (ip > 0)
+                    buf.Append(", ");
+                int opcode = code[ip];
+                Bytecode.Instruction I = Bytecode.instructions[opcode];
+                buf.Append(I.name);
+                ip++;
+                for (int opnd = 0; opnd < I.n; opnd++)
+                {
+                    buf.Append(' ');
+                    buf.Append(GetShort(code, ip));
+                    ip += Bytecode.OPND_SIZE_IN_BYTES;
+                }
+            }
+            return buf.ToString();
+        }
+
+        public virtual string Disassemble()
+        {
+            StringBuilder buf = new StringBuilder();
+            int i = 0;
+            while (i < codeSize)
+            {
+                i = DisassembleInstruction(buf, i);
+                buf.Append('\n');
+            }
+            return buf.ToString();
+        }
+
+        public virtual int DisassembleInstruction(StringBuilder buf, int ip)
+        {
+            int opcode = code[ip];
+            if (ip >= codeSize)
+            {
+                throw new ArgumentException("ip out of range: " + ip);
+            }
+            Bytecode.Instruction I =
+                Bytecode.instructions[opcode];
+            if (I == null)
+            {
+                throw new ArgumentException("no such instruction " + opcode +
+                    " at address " + ip);
+            }
+            string instrName = I.name;
+            buf.Append(string.Format("%04d:\t%-14s", ip, instrName));
+            ip++;
+            if (I.n == 0)
+            {
+                buf.Append(string.Format("  "));
+                return ip;
+            }
+            List<string> operands = new List<string>();
+            for (int i = 0; i < I.n; i++)
+            {
+                int opnd = GetShort(code, ip);
+                ip += Bytecode.OPND_SIZE_IN_BYTES;
+                switch (I.type[i])
+                {
+                case Bytecode.STRING:
+                    operands.Add(ShowConstPoolOperand(opnd));
+                    break;
+                case Bytecode.ADDR:
+                case Bytecode.INT:
+                    operands.Add(opnd.ToString());
+                    break;
+                default:
+                    operands.Add(opnd.ToString());
+                    break;
+                }
+            }
+            for (int i = 0; i < operands.Count; i++)
+            {
+                string s = operands[i];
+                if (i > 0)
+                    buf.Append(", ");
+                buf.Append(s);
+            }
+            return ip;
+        }
+
+        private string ShowConstPoolOperand(int poolIndex)
+        {
+            StringBuilder buf = new StringBuilder();
+            buf.Append("#");
+            buf.Append(poolIndex);
+            string s = "<bad string index>";
+            if (poolIndex < strings.Length)
+            {
+                if (strings[poolIndex] == null)
+                    s = "null";
+                else
+                {
+                    s = strings[poolIndex].ToString();
+                    if (strings[poolIndex] is string)
+                    {
+                        s = s.Replace("\n", "\\\\n");
+                        s = s.Replace("\r", "\\\\r");
+                        s = s.Replace("\t", "\\\\t");
+                        s = '"' + s + '"';
+                    }
+                }
+            }
+            buf.Append(":");
+            buf.Append(s);
+            return buf.ToString();
+        }
+
+        public static int GetShort(byte[] memory, int index)
+        {
+            int b1 = memory[index++] & 0xFF; // mask off sign-extended bits
+            int b2 = memory[index++] & 0xFF;
+            int word = b1 << (8 * 1) | b2;
+            return word;
+        }
+
+        public virtual string Strings()
+        {
+            StringBuilder buf = new StringBuilder();
+            int addr = 0;
+            foreach (object o in strings)
+            {
+                if (o is string)
+                {
+                    string s = (string)o;
+                    s = s.Replace("\n", "\\\\n");
+                    s = s.Replace("\r", "\\\\r");
+                    s = s.Replace("\t", "\\\\t");
+                    buf.Append(string.Format("%04d: \"%s\"\n", addr, s));
+                }
+                else
+                {
+                    buf.Append(string.Format("%04d: %s\n", addr, o));
+                }
+                addr++;
+            }
+            return buf.ToString();
+        }
+    }
+}
diff --git a/StringTemplate4/CompiledTemplate.cs b/StringTemplate4/CompiledTemplate.cs
new file mode 100644
index 0000000..a9b8a7e
--- /dev/null
+++ b/StringTemplate4/CompiledTemplate.cs
@@ -0,0 +1,75 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    using System.Collections.Generic;
+    using Console = System.Console;
+
+    public class CompiledTemplate
+    {
+        protected internal string name;
+
+        /** The original, immutable pattern (not really used again after
+         *  initial "compilation"). Useful for debugging.
+         */
+        protected internal string template;
+
+        protected internal IDictionary<string, FormalArgument> formalArguments;
+
+        internal List<CompiledTemplate> compiledSubtemplates;
+
+        /** The group that holds this ST definition.  We use it to initiate
+         *  interpretation via ST.toString().  From there, it becomes field 'group'
+         *  in interpreter and is fixed until rendering completes.
+         */
+        public TemplateGroup nativeGroup = TemplateGroup.defaultGroup;
+
+        public string[] strings;
+        public byte[] instrs;        // byte-addressable code memory.
+        public int codeSize;
+
+        public virtual string Instructions()
+        {
+            var disassembler = new BytecodeDisassembler(instrs, codeSize, strings);
+            return disassembler.Instructions();
+        }
+
+        public virtual void Dump()
+        {
+            var disassembler = new BytecodeDisassembler(instrs, codeSize, strings);
+            Console.WriteLine(disassembler.Disassemble());
+            Console.WriteLine("Strings:");
+            Console.WriteLine(disassembler.Strings());
+        }
+    }
+}
diff --git a/StringTemplate4/Compiler.cs b/StringTemplate4/Compiler.cs
new file mode 100644
index 0000000..50236b4
--- /dev/null
+++ b/StringTemplate4/Compiler.cs
@@ -0,0 +1,235 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    using System.Collections.Generic;
+    using Antlr.Runtime;
+    using Array = System.Array;
+    using Console = System.Console;
+    using IList = System.Collections.IList;
+    using Math = System.Math;
+
+    public class Compiler : ICodeGenerator
+    {
+        public static readonly string ATTR_NAME_REGEX = "[a-zA-Z/][a-zA-Z0-9_/]*";
+        /** Given a template of length n, how much code will result?
+         *  For now, let's assume n/5. Later, we can test in practice.
+         */
+        public static readonly double CODE_SIZE_FACTOR = 5.0;
+        public static readonly int SUBTEMPLATE_INITIAL_CODE_SIZE = 15;
+
+        public static readonly IDictionary<string, int> supportedOptions =
+            new Dictionary<string, int>()
+        {
+            {        "anchor",       Interpreter.OPTION_ANCHOR},
+            {        "format",       Interpreter.OPTION_FORMAT},
+            {        "null",         Interpreter.OPTION_NULL},
+            {       "separator",    Interpreter.OPTION_SEPARATOR},
+            {"wrap",         Interpreter.OPTION_WRAP}
+        };
+
+        public static readonly int NUM_OPTIONS = supportedOptions.Count;
+
+        public static readonly IDictionary<string, string> defaultOptionValues =
+            new Dictionary<string, string>()
+        {
+            {"anchor", "true"},
+            {"wrap",   "\n"}
+        };
+
+        public static IDictionary<string, short> funcs =
+            new Dictionary<string, short>()
+        {
+            {"first", Bytecode.INSTR_FIRST},
+            {"last", Bytecode.INSTR_LAST},
+            {"rest", Bytecode.INSTR_REST},
+            {"trunc", Bytecode.INSTR_TRUNC},
+            {"strip", Bytecode.INSTR_STRIP},
+            {"trim", Bytecode.INSTR_TRIM},
+            {"length", Bytecode.INSTR_LENGTH},
+            {"strlen", Bytecode.INSTR_STRLEN},
+            {"reverse", Bytecode.INSTR_REVERSE}
+        };
+
+        StringTable strings = new StringTable();
+        byte[] instrs;
+        int ip = 0;
+        CompiledTemplate code = new CompiledTemplate();
+
+        public static int subtemplateCount = 0; // public for testing access
+
+        public Compiler()
+        {
+        }
+
+        public CompiledTemplate Compile(string template)
+        {
+            return Compile(template, '<', '>');
+        }
+
+        public CompiledTemplate Compile(string template,
+                                  char delimiterStartChar,
+                                  char delimiterStopChar)
+        {
+            int initialSize = Math.Max(5, (int)(template.Length / CODE_SIZE_FACTOR));
+            instrs = new byte[initialSize];
+            code.template = template;
+
+            TemplateLexer lexer =
+                new TemplateLexer(new ANTLRStringStream(template), delimiterStartChar, delimiterStopChar);
+            //CommonTokenStream tokens = new CommonTokenStream(lexer);
+            CommonTokenStream tokens = new CommonTokenStream(lexer);
+            TemplateParser parser = new TemplateParser(tokens, this);
+            try
+            {
+                parser.templateAndEOF(); // parse, trigger compile actions for single expr
+            }
+            catch (RecognitionException re)
+            {
+                string msg = parser.GetErrorMessage(re, parser.TokenNames);
+                Console.Error.WriteLine(re.StackTrace);
+                throw new TemplateRecognitionException(msg, re);
+            }
+
+            if (strings != null)
+                code.strings = strings.ToArray();
+            code.instrs = instrs;
+            code.codeSize = ip;
+            return code;
+        }
+
+        public CompiledTemplate Compile(ITokenStream tokens, RecognizerSharedState state)
+        {
+            instrs = new byte[SUBTEMPLATE_INITIAL_CODE_SIZE];
+            TemplateParser parser = new TemplateParser(tokens, state, this);
+            try
+            {
+                parser.template(); // parse, trigger compile actions for single expr
+            }
+            catch (RecognitionException re)
+            {
+                string msg = parser.GetErrorMessage(re, parser.TokenNames);
+                Console.Error.WriteLine(re.StackTrace);
+                throw new TemplateRecognitionException(msg, re);
+            }
+
+            if (strings != null)
+                code.strings = strings.ToArray();
+            code.instrs = instrs;
+            code.codeSize = ip;
+            return code;
+        }
+
+        public int DefineString(string s)
+        {
+            return strings.Add(s);
+        }
+
+        // CodeGenerator interface impl.
+
+        public void Emit(short opcode)
+        {
+            EnsureCapacity();
+            instrs[ip++] = (byte)opcode;
+        }
+
+        public void Emit(short opcode, int arg)
+        {
+            EnsureCapacity();
+            instrs[ip++] = (byte)opcode;
+            WriteShort(instrs, ip, (short)arg);
+            ip += 2;
+        }
+
+        public void Emit(short opcode, string s)
+        {
+            int i = DefineString(s);
+            Emit(opcode, i);
+        }
+
+        public void Write(int addr, short value)
+        {
+            WriteShort(instrs, addr, value);
+        }
+
+        public int Address()
+        {
+            return ip;
+        }
+
+        public string CompileAnonTemplate(ITokenStream input,
+                                   IList ids,
+                                   RecognizerSharedState state)
+        {
+            subtemplateCount++;
+            string name = "_sub" + subtemplateCount;
+            Compiler c = new Compiler();
+            CompiledTemplate sub = c.Compile(input, state);
+            sub.name = name;
+            if (ids != null)
+            {
+                sub.formalArguments = new Dictionary<string, FormalArgument>();
+                foreach (IToken arg in ids)
+                {
+                    string argName = arg.Text;
+                    sub.formalArguments[argName] = new FormalArgument(argName);
+                }
+            }
+            if (code.compiledSubtemplates == null)
+            {
+                code.compiledSubtemplates = new List<CompiledTemplate>();
+            }
+            code.compiledSubtemplates.Add(sub);
+            return name;
+        }
+
+        protected void EnsureCapacity()
+        {
+            if ((ip + 3) >= instrs.Length)
+            { // ensure room for full instruction
+                byte[] c = new byte[instrs.Length * 2];
+                Array.Copy(instrs, 0, c, 0, instrs.Length);
+                instrs = c;
+            }
+        }
+
+        /** Write value at index into a byte array highest to lowest byte,
+         *  left to right.
+         */
+        public static void WriteShort(byte[] memory, int index, short value)
+        {
+            memory[index + 0] = (byte)((value >> (8 * 1)) & 0xFF);
+            memory[index + 1] = (byte)(value & 0xFF);
+        }
+    }
+}
diff --git a/StringTemplate4/ErrorTolerance.cs b/StringTemplate4/ErrorTolerance.cs
new file mode 100644
index 0000000..e5a6235
--- /dev/null
+++ b/StringTemplate4/ErrorTolerance.cs
@@ -0,0 +1,61 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    public class ErrorTolerance
+    {
+        // bit set values telling ST what to care about
+        public static readonly int DETECT_ADD_ATTR = 1;
+        public static readonly int DETECT_UNKNOWN_PROPERTY = 2;
+        public static readonly int DETECT_UNKNOWN_ATTRIBUTE = 4;
+        public static readonly int DETECT_MALFORMED_TEMPLATE_NAME = 8;
+        public static readonly int DETECT_UNKNOWN_TEMPLATE = 16;
+
+        public static readonly int DEFAULT_TOLERANCE = DETECT_ADD_ATTR;
+
+        public int detect = DEFAULT_TOLERANCE;
+
+        public bool Detects(int x)
+        {
+            return (detect & x) != 0;
+        }
+        public void Detect(int x)
+        {
+            detect |= x;
+        }
+        public void Ignore(int x)
+        {
+            detect &= ~x;
+        }
+    }
+}
diff --git a/StringTemplate4/FormalArgument.cs b/StringTemplate4/FormalArgument.cs
new file mode 100644
index 0000000..3734b58
--- /dev/null
+++ b/StringTemplate4/FormalArgument.cs
@@ -0,0 +1,119 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    public class FormalArgument
+    {
+        // the following represent bit positions emulating a cardinality bitset.
+        public static readonly int OPTIONAL = 1;     // a?
+        public static readonly int REQUIRED = 2;     // a
+        public static readonly int ZERO_OR_MORE = 4; // a*
+        public static readonly int ONE_OR_MORE = 8;  // a+
+
+        public static readonly string[] suffixes = {
+        null,
+        "?",
+        "",
+        null,
+        "*",
+        null,
+        null,
+        null,
+        "+"
+    };
+
+        public string name;
+        //protected int cardinality = REQUIRED;
+
+        /** If they specified name="value", store the template here */
+        public string defaultValue;
+        public CompiledTemplate compiledDefaultValue;
+
+        public FormalArgument(string name)
+        {
+            this.name = name;
+        }
+
+        public FormalArgument(string name, string defaultValue)
+        {
+            this.name = name;
+            this.defaultValue = defaultValue;
+        }
+
+        /*
+        public static String getCardinalityName(int cardinality) {
+            switch (cardinality) {
+                case OPTIONAL : return "optional";
+                case REQUIRED : return "exactly one";
+                case ZERO_OR_MORE : return "zero-or-more";
+                case ONE_OR_MORE : return "one-or-more";
+                default : return "unknown";
+            }
+        }
+        */
+
+        public override int GetHashCode()
+        {
+            return name.GetHashCode() + defaultValue.GetHashCode();
+        }
+
+        public override bool Equals(object o)
+        {
+            if (o == null || !(o is FormalArgument))
+            {
+                return false;
+            }
+            FormalArgument other = (FormalArgument)o;
+            if (!this.name.Equals(other.name))
+            {
+                return false;
+            }
+            // only check if there is a default value; that's all
+            if ((this.defaultValue != null && other.defaultValue == null) ||
+                 (this.defaultValue == null && other.defaultValue != null))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        public override string ToString()
+        {
+            if (defaultValue != null)
+            {
+                return name + "=" + defaultValue;
+            }
+            return name;
+        }
+    }
+}
diff --git a/StringTemplate4/Group.g3 b/StringTemplate4/Group.g3
new file mode 100644
index 0000000..03bf696
--- /dev/null
+++ b/StringTemplate4/Group.g3
@@ -0,0 +1,216 @@
+﻿/*
+ [The "BSD licence"]
+ Copyright (c) 2003-2009 Terence Parr
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+    notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+    derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/** Match a group of template definitions beginning
+ *  with a group name declaration.  Templates are enclosed
+ *  in double-quotes or <<...>> quotes for multi-line templates.
+ *  Template names have arg lists that indicate the cardinality
+ *  of the attribute: present, optional, zero-or-more, one-or-more.
+ *  Here is a sample group file:
+
+	group nfa;
+
+	// an NFA has edges and states
+	nfa(states,edges) ::= <<
+	digraph NFA {
+	rankdir=LR;
+	<states; separator="\\n">
+	<edges; separator="\\n">
+	}
+	>>
+
+	state(name) ::= "node [shape = circle]; <name>;"
+
+ */
+grammar Group;
+
+options {
+	language=CSharp3;
+}
+
+@lexer::namespace{StringTemplate}
+@parser::namespace{StringTemplate}
+
+@header
+{
+using Console = System.Console;
+}
+
+public
+group[TemplateGroup group]
+@init {
+this._group = $group;
+GroupLexer lexer = (GroupLexer)input.TokenSource;
+lexer._group = $group;
+}
+	:	//'group' name=ID {$group.name = $name.text;}
+		//( ':' s=ID {$group.supergroup = $s.text;} )?
+	    //';'
+	    ( templateDef | dictDef )+
+    ;
+
+public
+templateDef
+@init {
+    string template=null;
+    int n=0; // num char to strip from left, right of template def
+}
+	:	(	'@' ID '.' region=ID
+		|	name=ID
+		)
+	    '(' formalArgs? ')' '::='
+	    {IToken templateToken = input.LT(1);}
+	    (	STRING     {template=$STRING.text; n=1;}
+	    |	BIGSTRING  {template=$BIGSTRING.text; n=2;}
+	    )
+	    {
+	    template = Misc.Strip(template, n);
+   		if ( templateToken.Type==BIGSTRING ) {
+   			template = Misc.TrimOneStartingWS(template);
+   		}
+	    try {
+		    this._group.DefineTemplate($name.text, $formalArgs.args, template);
+		}
+        catch (TemplateRecognitionException e) {
+        	RecognitionException re = (RecognitionException)e.InnerException;
+        	int charPosition =
+        		re.charPositionInLine+templateToken.CharPositionInLine+n;
+	        this._group.listener.Error(templateToken.Line+":"+
+                    	  		 charPosition+
+	                             ": "+e.Message, null);
+        }
+	    }
+	|   alias=ID '::=' target=ID
+	;
+
+formalArgs returns[IDictionary<string,FormalArgument> args]
+@init {$args = new Dictionary<string,FormalArgument>();}
+    :	formalArg[$args] ( ',' formalArg[$args] )*
+	;
+
+formalArg[IDictionary<string,FormalArgument> args]
+@init {string defvalue = null;}
+	:	ID
+		(	'=' STRING				{defvalue = $STRING.text;}
+		|	'=' ANONYMOUS_TEMPLATE	{defvalue = $ANONYMOUS_TEMPLATE.text;}
+		)?
+		{$args[$ID.text] = new FormalArgument($ID.text, defvalue);}
+    ;
+
+/*
+suffix returns [int cardinality=FormalArgument.REQUIRED]
+    :   OPTIONAL
+    |   STAR
+    |   PLUS
+	|
+    ;
+    */
+
+dictDef
+	:	ID '::=' dict
+        {
+        if ( this._group.dictionaries.ContainsKey($ID.text) ) {
+            Console.Error.WriteLine("redefinition of map: "+$ID.text);
+        }
+        else if ( this._group.templates.ContainsKey($ID.text) ) {
+            Console.Error.WriteLine("redefinition of template as map: "+$ID.text);
+        }
+        else {
+            this._group.DefineDictionary($ID.text, $dict.mapping);
+        }
+        }
+	;
+
+dict returns [IDictionary<string, object> mapping]
+@init {mapping=new Dictionary<string, object>();}
+	:   '[' dictPairs[mapping] ']'
+	;
+
+dictPairs[IDictionary<string, object> mapping]
+    :	keyValuePair[mapping]
+    	(',' keyValuePair[mapping])* (',' defaultValuePair[mapping])?
+    |	defaultValuePair[mapping]
+    ;
+
+defaultValuePair[IDictionary<string,object> mapping]
+	:	'default' ':' keyValue {mapping[TemplateGroup.DEFAULT_KEY] = $keyValue.value;}
+	;
+
+keyValuePair[IDictionary<string,object> mapping]
+	:	STRING ':' keyValue {mapping[Misc.Strip($STRING.text, 1)] = $keyValue.value;}
+	;
+
+keyValue returns [object value]
+	:	BIGSTRING			{$value = new Template(this._group, Misc.Strip($BIGSTRING.text,2));}
+	|	ANONYMOUS_TEMPLATE	{$value = new Template(this._group, Misc.Strip($ANONYMOUS_TEMPLATE.text,1));}
+	|	STRING				{$value = Misc.Strip($STRING.text, 1);}
+	|	{input.LT(1).Text.Equals("key")}?=> ID
+							{$value = TemplateGroup.DICT_KEY;}
+	|						{$value = null;}
+	;
+
+ID	:	('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'0'..'9'|'-'|'_')*
+	;
+
+STRING
+	:	'"' ( '\\' '"' | '\\' ~'"' | ~('\\'|'"') )* '"'
+	;
+
+BIGSTRING
+	:	'<<'
+		(	options {greedy=false;}
+		:	'\\' '>'  // \> escape
+		|	'\\' ~'>'
+		|	~'\\'
+		)*
+        '>>'
+	;
+
+ANONYMOUS_TEMPLATE
+    :	'{'
+    	{
+		TemplateLexer lexer =
+			new TemplateLexer(input, this._group.delimiterStartChar, this._group.delimiterStopChar);
+		lexer.subtemplateDepth = 1;
+		//CommonTokenStream tokens = new CommonTokenStream(lexer);
+		CommonTokenStream tokens = new CommonTokenStream(lexer);
+        TemplateParser parser = new TemplateParser(tokens, (ICodeGenerator)null);
+		parser.template();
+		}
+    	// don't match '}' here; subparser matches it to terminate
+    ;
+
+COMMENT
+    :   '/*' ( options {greedy=false;} : . )* '*/' {Skip();}
+    ;
+
+LINE_COMMENT
+    :	'//' ~('\n'|'\r')* '\r'? '\n' {Skip();}
+    ;
+
+WS  :	(' '|'\r'|'\t'|'\n') {Skip();} ;
diff --git a/StringTemplate4/GroupLexerHelper.cs b/StringTemplate4/GroupLexerHelper.cs
new file mode 100644
index 0000000..af29d5e
--- /dev/null
+++ b/StringTemplate4/GroupLexerHelper.cs
@@ -0,0 +1,39 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    partial class GroupLexer
+    {
+        protected internal TemplateGroup _group;
+    }
+}
diff --git a/StringTemplate4/GroupParserHelper.cs b/StringTemplate4/GroupParserHelper.cs
new file mode 100644
index 0000000..a26063f
--- /dev/null
+++ b/StringTemplate4/GroupParserHelper.cs
@@ -0,0 +1,39 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    partial class GroupParser
+    {
+        protected internal TemplateGroup _group;
+    }
+}
diff --git a/StringTemplate4/ICodeGenerator.cs b/StringTemplate4/ICodeGenerator.cs
new file mode 100644
index 0000000..19ac35b
--- /dev/null
+++ b/StringTemplate4/ICodeGenerator.cs
@@ -0,0 +1,50 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    using Antlr.Runtime;
+    using IList = System.Collections.IList;
+
+    public interface ICodeGenerator
+    {
+        void Emit(short opcode);
+        void Emit(short opcode, int arg);
+        void Emit(short opcode, string s);
+        void Write(int addr, short value);
+        /** Return address where next instruction will be written */
+        int Address();
+        string CompileAnonTemplate(ITokenStream input,
+                                   IList ids,
+                                   RecognizerSharedState state);
+    }
+}
diff --git a/StringTemplate4/ITemplateErrorListener.cs b/StringTemplate4/ITemplateErrorListener.cs
new file mode 100644
index 0000000..5ea675c
--- /dev/null
+++ b/StringTemplate4/ITemplateErrorListener.cs
@@ -0,0 +1,43 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    using Exception = System.Exception;
+
+    public interface ITemplateErrorListener
+    {
+        void Error(string message, Exception e);
+        void Error(string message);
+        void Warning(string message);
+    }
+}
diff --git a/StringTemplate4/ITemplateWriter.cs b/StringTemplate4/ITemplateWriter.cs
new file mode 100644
index 0000000..424eeb0
--- /dev/null
+++ b/StringTemplate4/ITemplateWriter.cs
@@ -0,0 +1,70 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    public interface ITemplateWriter
+    {
+        void PushIndentation(string indent);
+
+        string PopIndentation();
+
+        void PushAnchorPoint();
+
+        void PopAnchorPoint();
+
+        void SetLineWidth(int lineWidth);
+
+        /** Write the string and return how many actual chars were written.
+         *  With autoindentation and wrapping, more chars than length(str)
+         *  can be emitted.  No wrapping is done.
+         */
+        int Write(string str);
+
+        /** Same as write, but wrap lines using the indicated string as the
+         *  wrap character (such as "\n").
+         */
+        int Write(string str, string wrap);
+
+        /** Because we might need to wrap at a non-atomic string boundary
+         *  (such as when we wrap in between template applications
+         *   <data:{v|[<v>]}; wrap>) we need to expose the wrap string
+         *  writing just like for the separator.
+         */
+        int WriteWrapSeparator(string wrap);
+
+        /** Write a separator.  Same as write() except that a \n cannot
+         *  be inserted before emitting a separator.
+         */
+        int WriteSeparator(string str);
+    }
+}
diff --git a/StringTemplate4/Interpreter.cs b/StringTemplate4/Interpreter.cs
new file mode 100644
index 0000000..cefa816
--- /dev/null
+++ b/StringTemplate4/Interpreter.cs
@@ -0,0 +1,1058 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    using System.Collections.Generic;
+    using System.Linq;
+    using Array = System.Array;
+    using ArrayList = System.Collections.ArrayList;
+    using Console = System.Console;
+    using Environment = System.Environment;
+    using FieldInfo = System.Reflection.FieldInfo;
+    using ICollection = System.Collections.ICollection;
+    using IDictionary = System.Collections.IDictionary;
+    using IList = System.Collections.IList;
+    using IOException = System.IO.IOException;
+    using Iterator = System.Collections.IEnumerator;
+    using Math = System.Math;
+    using MethodInfo = System.Reflection.MethodInfo;
+    using StringBuilder = System.Text.StringBuilder;
+    using StringWriter = System.IO.StringWriter;
+    using Type = System.Type;
+
+    public class Interpreter
+    {
+        public static readonly int OPTION_ANCHOR = 0;
+        public static readonly int OPTION_FORMAT = 1;
+        public static readonly int OPTION_NULL = 2;
+        public static readonly int OPTION_SEPARATOR = 3;
+        public static readonly int OPTION_WRAP = 4;
+
+        public static readonly int DEFAULT_OPERAND_STACK_SIZE = 100;
+
+        public static readonly HashSet<string> predefinedAttributes =
+            new HashSet<string>()
+        {
+            "it",
+            "i",
+            "i0"
+        };
+
+        /** Operand stack, grows upwards */
+        object[] operands = new object[DEFAULT_OPERAND_STACK_SIZE];
+        int sp = -1;  // stack pointer register
+        int nw = 0;   // how many char written on this template line so far? ("number written" register)
+
+        /** Exec st with respect to this group. Once set in Template.toString(),
+         *  it should be fixed.  Template has group also.
+         */
+        TemplateGroup group;
+
+        public bool trace = false;
+
+        public Interpreter(TemplateGroup group)
+        {
+            this.group = group;
+        }
+
+        public int Exec(ITemplateWriter @out, Template self)
+        {
+            int prevOpcode = 0;
+            int n = 0; // how many char we write out
+            int nameIndex = 0;
+            int addr = 0;
+            string name = null;
+            object o = null, left = null, right = null;
+            Template st = null;
+            object[] options = null;
+            int ip = 0;
+            byte[] code = self.code.instrs;        // which code block are we executing
+            while (ip < self.code.codeSize)
+            {
+                if (trace)
+                    Trace(self, ip);
+                short opcode = code[ip];
+                ip++; //jump to next instruction or first byte of operand
+                switch (opcode)
+                {
+                case Bytecode.INSTR_LOAD_STR:
+                    int strIndex = GetShort(code, ip);
+                    ip += 2;
+                    operands[++sp] = self.code.strings[strIndex];
+                    break;
+                case Bytecode.INSTR_LOAD_ATTR:
+                    nameIndex = GetShort(code, ip);
+                    ip += 2;
+                    name = self.code.strings[nameIndex];
+                    operands[++sp] = self.GetAttribute(name);
+                    break;
+                case Bytecode.INSTR_LOAD_LOCAL:
+                    nameIndex = GetShort(code, ip);
+                    ip += 2;
+                    name = self.code.strings[nameIndex];
+                    if (self.attributes == null || !self.attributes.TryGetValue(name, out o))
+                        o = null;
+                    operands[++sp] = o;
+                    break;
+                case Bytecode.INSTR_LOAD_PROP:
+                    nameIndex = GetShort(code, ip);
+                    ip += 2;
+                    o = operands[sp--];
+                    name = self.code.strings[nameIndex];
+                    operands[++sp] = GetObjectProperty(self, o, name);
+                    break;
+                case Bytecode.INSTR_LOAD_PROP_IND:
+                    object propName = operands[sp--];
+                    o = operands[sp];
+                    operands[sp] = GetObjectProperty(self, o, propName);
+                    break;
+                case Bytecode.INSTR_NEW:
+                    nameIndex = GetShort(code, ip);
+                    ip += 2;
+                    name = self.code.strings[nameIndex];
+                    st = group.GetEmbeddedInstanceOf(self, name);
+                    if (st == null)
+                        Console.Error.WriteLine("no such template " + name);
+                    operands[++sp] = st;
+                    break;
+                case Bytecode.INSTR_NEW_IND:
+                    name = (string)operands[sp--];
+                    st = group.GetEmbeddedInstanceOf(self, name);
+                    if (st == null)
+                        Console.Error.WriteLine("no such template " + name);
+                    operands[++sp] = st;
+                    break;
+                case Bytecode.INSTR_STORE_ATTR:
+                    nameIndex = GetShort(code, ip);
+                    name = self.code.strings[nameIndex];
+                    ip += 2;
+                    o = operands[sp--];    // value to store
+                    st = (Template)operands[sp]; // store arg in Template on top of stack
+                    st.RawSetAttribute(name, o);
+                    break;
+                case Bytecode.INSTR_STORE_SOLE_ARG:
+                    // unnamed arg, set to sole arg (or first if multiple)
+                    o = operands[sp--];    // value to store
+                    st = (Template)operands[sp]; // store arg in Template on top of stack
+                    int nargs = 0;
+                    if (st.code.formalArguments != null)
+                    {
+                        nargs = st.code.formalArguments.Count;
+                    }
+                    if (nargs != 1)
+                    {
+                        Console.Error.WriteLine("arg mismatch; expecting 1, found " + nargs);
+                    }
+                    else
+                    {
+                        name = st.code.formalArguments.Keys.First();
+                        st.RawSetAttribute(name, o);
+                    }
+                    break;
+                case Bytecode.INSTR_SET_PASS_THRU:
+                    st = (Template)operands[sp]; // Template on top of stack
+                    st.passThroughAttributes = true;
+                    break;
+                case Bytecode.INSTR_STORE_OPTION:
+                    int optionIndex = GetShort(code, ip);
+                    ip += 2;
+                    o = operands[sp--];    // value to store
+                    options = (object[])operands[sp]; // get options
+                    options[optionIndex] = o; // store value into options on stack
+                    break;
+                case Bytecode.INSTR_WRITE:
+                    o = operands[sp--];
+                    nw = WriteObject(@out, self, o, null);
+                    n += nw;
+                    break;
+                case Bytecode.INSTR_WRITE_OPT:
+                    options = (object[])operands[sp--]; // get options
+                    o = operands[sp--];                 // get option to write
+                    nw = WriteObject(@out, self, o, options);
+                    n += nw;
+                    break;
+                case Bytecode.INSTR_MAP:
+                    name = (string)operands[sp--];
+                    o = operands[sp--];
+                    Map(self, o, name);
+                    break;
+                case Bytecode.INSTR_ROT_MAP:
+                    int nmaps = GetShort(code, ip);
+                    ip += 2;
+                    List<string> templates = new List<string>();
+                    for (int i = nmaps - 1; i >= 0; i--)
+                        templates.Add((string)operands[sp - i]);
+                    sp -= nmaps;
+                    o = operands[sp--];
+                    if (o != null)
+                        Rot_map(self, o, templates);
+                    break;
+                case Bytecode.INSTR_PAR_MAP:
+                    name = (string)operands[sp--];
+                    nmaps = GetShort(code, ip);
+                    ip += 2;
+                    List<object> exprs = new List<object>();
+                    for (int i = nmaps - 1; i >= 0; i--)
+                        exprs.Add(operands[sp - i]);
+                    sp -= nmaps;
+                    operands[++sp] = Par_map(self, exprs, name);
+                    break;
+                case Bytecode.INSTR_BR:
+                    ip = GetShort(code, ip);
+                    break;
+                case Bytecode.INSTR_BRF:
+                    addr = GetShort(code, ip);
+                    ip += 2;
+                    o = operands[sp--]; // <if(expr)>...<endif>
+                    if (!TestAttributeTrue(o))
+                        ip = addr; // jump
+                    break;
+                case Bytecode.INSTR_OPTIONS:
+                    operands[++sp] = new object[Compiler.NUM_OPTIONS];
+                    break;
+                case Bytecode.INSTR_LIST:
+                    operands[++sp] = new List<object>();
+                    break;
+                case Bytecode.INSTR_ADD:
+                    o = operands[sp--];             // pop value
+                    List<object> list = (List<object>)operands[sp]; // don't pop list
+                    AddToList(list, o);
+                    break;
+                case Bytecode.INSTR_TOSTR:
+                    // replace with string value; early eval
+                    operands[sp] = ToString(self, operands[sp]);
+                    break;
+                case Bytecode.INSTR_FIRST:
+                    operands[sp] = First(operands[sp]);
+                    break;
+                case Bytecode.INSTR_LAST:
+                    operands[sp] = Last(operands[sp]);
+                    break;
+                case Bytecode.INSTR_REST:
+                    operands[sp] = Rest(operands[sp]);
+                    break;
+                case Bytecode.INSTR_TRUNC:
+                    operands[sp] = Trunc(operands[sp]);
+                    break;
+                case Bytecode.INSTR_STRIP:
+                    operands[sp] = Strip(operands[sp]);
+                    break;
+                case Bytecode.INSTR_TRIM:
+                    o = operands[sp--];
+                    if (o.GetType() == typeof(string))
+                    {
+                        operands[++sp] = ((string)o).Trim();
+                    }
+                    else
+                        Console.Error.WriteLine("strlen(non string)");
+                    break;
+                case Bytecode.INSTR_LENGTH:
+                    operands[sp] = Length(operands[sp]);
+                    break;
+                case Bytecode.INSTR_STRLEN:
+                    o = operands[sp--];
+                    if (o.GetType() == typeof(string))
+                    {
+                        operands[++sp] = ((string)o).Length;
+                    }
+                    else
+                        Console.Error.WriteLine("strlen(non string)");
+                    break;
+                case Bytecode.INSTR_REVERSE:
+                    operands[sp] = Reverse(operands[sp]);
+                    break;
+                case Bytecode.INSTR_NOT:
+                    operands[sp] = !TestAttributeTrue(operands[sp]);
+                    break;
+                case Bytecode.INSTR_OR:
+                    right = operands[sp--];
+                    left = operands[sp--];
+                    operands[++sp] = TestAttributeTrue(left) || TestAttributeTrue(right);
+                    break;
+                case Bytecode.INSTR_AND:
+                    right = operands[sp--];
+                    left = operands[sp--];
+                    operands[++sp] = TestAttributeTrue(left) && TestAttributeTrue(right);
+                    break;
+                case Bytecode.INSTR_INDENT:
+                    strIndex = GetShort(code, ip);
+                    ip += 2;
+                    @out.PushIndentation(self.code.strings[strIndex]);
+                    break;
+                case Bytecode.INSTR_DEDENT:
+                    @out.PopIndentation();
+                    break;
+                case Bytecode.INSTR_NEWLINE:
+                    try
+                    {
+                        if (prevOpcode == Bytecode.INSTR_NEWLINE ||
+                             prevOpcode == Bytecode.INSTR_INDENT ||
+                             nw > 0)
+                        {
+                            @out.Write(Environment.NewLine);
+                        }
+                        nw = -1; // indicate nothing written but no WRITE yet
+                    }
+                    catch (IOException)
+                    {
+                        Console.Error.WriteLine("can't write newline");
+                    }
+                    break;
+                default:
+                    Console.Error.WriteLine("Invalid bytecode: " + opcode + " @ ip=" + (ip - 1));
+                    self.code.Dump();
+                    break;
+                }
+                prevOpcode = opcode;
+            }
+            return n;
+        }
+
+        protected int WriteObject(ITemplateWriter @out, Template self, object o, object[] options) {
+        // precompute all option values (render all the way to strings)
+        string[] optionStrings = null;
+        if ( options!=null ) {
+            optionStrings = new string[options.Length];
+            for (int i=0; i<Compiler.NUM_OPTIONS; i++) {
+                optionStrings[i] = ToString(self, options[i]);
+            }
+        }
+        return WriteObject(@out, self, o, optionStrings);
+    }
+
+        protected int WriteObject(ITemplateWriter @out, Template self, object o, string[] options)
+        {
+            int n = 0;
+            if (o == null)
+            {
+                if (options != null && options[OPTION_NULL] != null)
+                {
+                    try
+                    {
+                        n = @out.Write(options[OPTION_NULL]);
+                    }
+                    catch (IOException)
+                    {
+                        Console.Error.WriteLine("can't write " + o);
+                    }
+                }
+                return n;
+            }
+            if (o is Template)
+            {
+                ((Template)o).enclosingInstance = self;
+                n = Exec(@out, (Template)o);
+                return n;
+            }
+            o = ConvertAnythingIteratableToIterator(o); // normalize
+            try
+            {
+                if (o is Iterator)
+                    n = WriteIterator(@out, self, o, options);
+                else
+                    n = @out.Write(o.ToString());
+            }
+            catch (IOException)
+            {
+                Console.Error.WriteLine("can't write " + o);
+            }
+            return n;
+        }
+
+        protected int WriteIterator(ITemplateWriter @out, Template self, object o, string[] options)
+        {
+            if (o == null)
+                return 0;
+            int n = 0;
+            Iterator it = (Iterator)o;
+            string separator = null;
+            if (options != null)
+                separator = options[OPTION_SEPARATOR];
+            bool seenAValue = false;
+            int i = 0;
+            while (it.MoveNext())
+            {
+                object iterValue = it.Current;
+                // Emit separator if we're beyond first value
+                bool needSeparator = seenAValue &&
+                    separator != null &&            // we have a separator and
+                    (iterValue != null ||           // either we have a value
+                     options[OPTION_NULL] != null); // or no value but null option
+                if (needSeparator)
+                    n += @out.WriteSeparator(separator);
+                int nw = WriteObject(@out, self, iterValue, options);
+                if (nw > 0)
+                    seenAValue = true;
+                n += nw;
+                i++;
+            }
+            return n;
+        }
+
+        protected void Map(Template self, object attr, string name)
+        {
+            Rot_map(self, attr, new List<string>() { name });
+        }
+
+        // <names:a,b>
+        protected void Rot_map(Template self, object attr, List<string> templates)
+        {
+            if (attr == null)
+            {
+                operands[++sp] = null;
+                return;
+            }
+            attr = ConvertAnythingIteratableToIterator(attr);
+            if (attr is Iterator)
+            {
+                List<Template> mapped = new List<Template>();
+                Iterator iter = (Iterator)attr;
+                int i0 = 0;
+                int i = 1;
+                int ti = 0;
+                while (iter.MoveNext())
+                {
+                    object iterValue = iter.Current;
+                    if (iterValue == null)
+                        continue;
+                    int templateIndex = ti % templates.Count; // rotate through
+                    ti++;
+                    string name = templates[templateIndex];
+                    Template st = group.GetEmbeddedInstanceOf(self, name);
+                    SetSoleArgument(st, iterValue);
+                    st.RawSetAttribute("i0", i0);
+                    st.RawSetAttribute("i", i);
+                    mapped.Add(st);
+                    i0++;
+                    i++;
+                }
+                operands[++sp] = mapped;
+                //Console.WriteLine("mapped="+mapped);
+            }
+            else
+            { // if only single value, just apply first template to attribute
+                Template st = group.GetInstanceOf(templates[0]);
+                SetSoleArgument(st, attr);
+                st.RawSetAttribute("i0", 0);
+                st.RawSetAttribute("i", 1);
+                operands[++sp] = st;
+                //            map(self, attr, templates.get(1));
+            }
+        }
+
+        // <names,phones:{n,p | ...}>
+        protected Template.AttributeList Par_map(Template self, List<object> exprs, string template)
+        {
+            if (exprs == null || template == null || exprs.Count == 0)
+            {
+                return null; // do not apply if missing templates or empty values
+            }
+            // make everything iterable
+            for (int i = 0; i < exprs.Count; i++)
+            {
+                object attr = exprs[i];
+                if (attr != null)
+                    exprs[i] = ConvertAnythingToIterator(attr);
+            }
+
+            // ensure arguments line up
+            int numAttributes = exprs.Count;
+            CompiledTemplate code = group.LookupTemplate(template);
+            var formalArguments = code.formalArguments;
+            if (formalArguments == null || formalArguments.Count == 0)
+            {
+                group.listener.Error("missing formal arguments in anonymous" +
+                           " template in context " + self.GetEnclosingInstanceStackString(), null);
+                return null;
+            }
+
+            object[] formalArgumentNames = formalArguments.Keys.ToArray();
+            if (formalArgumentNames.Length != numAttributes)
+            {
+                group.listener.Error("number of arguments " + formalArguments.Keys +
+                           " mismatch between attribute list and anonymous" +
+                           " template in context " + self.GetEnclosingInstanceStackString(), null);
+                // truncate arg list to match smaller size
+                int shorterSize = Math.Min(formalArgumentNames.Length, numAttributes);
+                numAttributes = shorterSize;
+                object[] newFormalArgumentNames = new object[shorterSize];
+                Array.Copy(formalArgumentNames, 0,
+                                 newFormalArgumentNames, 0,
+                                 shorterSize);
+                formalArgumentNames = newFormalArgumentNames;
+            }
+
+            // keep walking while at least one attribute has values
+
+            {
+                Template.AttributeList results = new Template.AttributeList();
+                int i = 0; // iteration number from 0
+                while (true)
+                {
+                    // get a value for each attribute in list; put into Template instance
+                    int numEmpty = 0;
+                    Template embedded = group.GetEmbeddedInstanceOf(self, template);
+                    embedded.RawSetAttribute("i0", i);
+                    embedded.RawSetAttribute("i", i + 1);
+                    for (int a = 0; a < numAttributes; a++)
+                    {
+                        Iterator it = (Iterator)exprs[a];
+                        if (it != null && it.MoveNext())
+                        {
+                            string argName = (string)formalArgumentNames[a];
+                            object iteratedValue = it.Current;
+                            embedded.RawSetAttribute(argName, iteratedValue);
+                        }
+                        else
+                        {
+                            numEmpty++;
+                        }
+                    }
+                    if (numEmpty == numAttributes)
+                        break;
+                    results.Add(embedded);
+                    i++;
+                }
+                return results;
+            }
+
+            /*
+            if ( attr is Iterator ) {
+                List<Template> mapped = new ArrayList<Template>();
+                Iterator iter = (Iterator)attr;
+                int i0 = 0;
+                int i = 1;
+                int ti = 0;
+                while ( iter.hasNext() ) {
+                    object iterValue = iter.next();
+                    if ( iterValue == null ) continue;
+                    int templateIndex = ti % templates.size(); // rotate through
+                    ti++;
+                    string name = templates.get(templateIndex);
+                    Template st = group.getEmbeddedInstanceOf(self, name);
+                    for (FormalArgument arg : st.code.formalArguments.values()) {
+                        st.rawSetAttribute(arg.name, iterValue);
+                    }
+                    st.rawSetAttribute("i0", i0);
+                    st.rawSetAttribute("i", i);
+                    mapped.add(st);
+                    i0++;
+                    i++;
+                }
+                operands[++sp] = mapped;
+                //Console.WriteLine("mapped="+mapped);
+            }
+            else { // if only single value, just apply first template to attribute
+                Template st = group.getInstanceOf(templates.get(0));
+                setSoleArgument(st, attr);
+                st.rawSetAttribute("i0", 0);
+                st.rawSetAttribute("i", 1);
+                operands[++sp] = st;
+    //            map(self, attr, templates.get(1));
+            }
+            */
+        }
+
+        protected void SetSoleArgument(Template st, object attr)
+        {
+            if (st.code.formalArguments != null)
+            {
+                string arg = st.code.formalArguments.Keys.First();
+                st.RawSetAttribute(arg, attr);
+            }
+            else
+            {
+                st.RawSetAttribute("it", attr);
+            }
+        }
+
+        protected void AddToList(List<object> list, object o)
+        {
+            if (o == null)
+                return; // [a,b,c] lists ignore null values
+            o = Interpreter.ConvertAnythingIteratableToIterator(o);
+            if (o is Iterator)
+            {
+                // copy of elements into our temp list
+                Iterator it = (Iterator)o;
+                while (it.MoveNext())
+                    list.Add(it.Current);
+            }
+            else
+            {
+                list.Add(o);
+            }
+        }
+
+        /** Return the first attribute if multiple valued or the attribute
+         *  itself if single-valued.  Used in <names:first()>
+         */
+        public object First(object v)
+        {
+            if (v == null)
+                return null;
+            object r = v;
+            v = ConvertAnythingIteratableToIterator(v);
+            if (v is Iterator)
+            {
+                Iterator it = (Iterator)v;
+                if (it.MoveNext())
+                {
+                    r = it.Current;
+                }
+            }
+            return r;
+        }
+
+        /** Return the last attribute if multiple valued or the attribute
+         *  itself if single-valued. Unless it's a list or array, this is pretty
+         *  slow as it iterates until the last element.
+         */
+        public object Last(object v)
+        {
+            if (v == null)
+                return null;
+            if (v is IList)
+                return ((IList)v)[((IList)v).Count - 1];
+            else if (v.GetType().IsArray)
+            {
+                object[] elems = (object[])v;
+                return elems[elems.Length - 1];
+            }
+            object last = v;
+            v = ConvertAnythingIteratableToIterator(v);
+            if (v is Iterator)
+            {
+                Iterator it = (Iterator)v;
+                while (it.MoveNext())
+                {
+                    last = it.Current;
+                }
+            }
+            return last;
+        }
+
+        /** Return everything but the first attribute if multiple valued
+         *  or null if single-valued.
+         */
+        public object Rest(object v)
+        {
+            if (v == null)
+                return null;
+            if (v is IList)
+            { // optimize list case
+                IList elems = (IList)v;
+                if (elems.Count <= 1)
+                    return null;
+                return elems.Cast<object>().Skip(1);
+            }
+            object theRest = v; // else iterate and copy
+            v = ConvertAnythingIteratableToIterator(v);
+            if (v is Iterator)
+            {
+                IList a = new ArrayList();
+                Iterator it = (Iterator)v;
+                if (!it.MoveNext())
+                    return null; // if not even one value return null
+                //it.Current; // ignore first value
+                while (it.MoveNext())
+                {
+                    object o = it.Current;
+                    if (o != null)
+                        a.Add(o);
+                }
+                return a;
+            }
+            else
+            {
+                theRest = null;  // rest of single-valued attribute is null
+            }
+            return theRest;
+        }
+
+        /** Return all but the last element.  trunc(x)=null if x is single-valued. */
+        public object Trunc(object v)
+        {
+            if (v == null)
+                return null;
+            if (v is IList)
+            {
+                // optimize list case
+                IList elems = (IList)v;
+                if (elems.Count <= 1)
+                    return null;
+                return elems.Cast<object>().Take(elems.Count - 1);
+            }
+            v = ConvertAnythingIteratableToIterator(v);
+            if (v is Iterator)
+            {
+                IList a = new ArrayList();
+                Iterator it = (Iterator)v;
+                if (it.MoveNext())
+                {
+                    object previous = it.Current;
+                    while (it.MoveNext())
+                    {
+                        a.Add(previous);
+                        previous = it.Current;
+                    }
+                }
+                return a;
+            }
+            return null; // trunc(x)==null when x single-valued attribute
+        }
+
+        /** Return a new list w/o null values. */
+        public object Strip(object v)
+        {
+            if (v == null)
+                return null;
+            v = ConvertAnythingIteratableToIterator(v);
+            if (v is Iterator)
+            {
+                IList a = new ArrayList();
+                Iterator it = (Iterator)v;
+                while (it.MoveNext())
+                {
+                    object o = (object)it.Current;
+                    if (o != null)
+                        a.Add(o);
+                }
+                return a;
+            }
+            return v; // strip(x)==x when x single-valued attribute
+        }
+
+        /** Return a list with the same elements as v but in reverse order. null
+         *  values are NOT stripped out. use reverse(strip(v)) to do that.
+         */
+        public object Reverse(object v)
+        {
+            if (v == null)
+                return null;
+            v = ConvertAnythingIteratableToIterator(v);
+            if (v is Iterator)
+            {
+                IList a = new List<object>();
+                Iterator it = (Iterator)v;
+                while (it.MoveNext())
+                    a.Insert(0, it.Current);
+                return a;
+            }
+            return v;
+        }
+
+        /** Return the length of a mult-valued attribute or 1 if it is a
+         *  single attribute. If attribute is null return 0.
+         *  Special case several common collections and primitive arrays for
+         *  speed. This method by Kay Roepke from v3.
+         */
+        public object Length(object v)
+        {
+            if (v == null)
+                return 0;
+            int i = 1;      // we have at least one of something. Iterator and arrays might be empty.
+            if (v is IDictionary)
+                i = ((IDictionary)v).Count;
+            else if (v is ICollection)
+                i = ((ICollection)v).Count;
+            else if (v is object[])
+                i = ((object[])v).Length;
+            else if (v is string[])
+                i = ((string[])v).Length;
+            else if (v is int[])
+                i = ((int[])v).Length;
+            else if (v is long[])
+                i = ((long[])v).Length;
+            else if (v is float[])
+                i = ((float[])v).Length;
+            else if (v is double[])
+                i = ((double[])v).Length;
+            else if (v is Iterator)
+            {
+                Iterator it = (Iterator)v;
+                i = 0;
+                while (it.MoveNext())
+                {
+                    i++;
+                }
+            }
+            return i;
+        }
+
+        public object Strlen(object v)
+        {
+            return null;
+        }
+
+        protected string ToString(Template self, object value)
+        {
+            if (value != null)
+            {
+                if (value.GetType() == typeof(string))
+                    return (string)value;
+                // if Template, make sure it evaluates with enclosing template as self
+                if (value.GetType() == typeof(Template))
+                    ((Template)value).enclosingInstance = self;
+                // if not string already, must evaluate it
+                StringWriter sw = new StringWriter();
+                WriteObject(new NoIndentWriter(sw), self, value, null);
+                return sw.ToString();
+            }
+            return null;
+        }
+
+        protected static object ConvertAnythingIteratableToIterator(object o)
+        {
+            Iterator iter = null;
+            if (o == null)
+                return null;
+            else if (o is IDictionary)
+                iter = ((IDictionary)o).Values.GetEnumerator();
+            if (o is ICollection)
+                iter = ((ICollection)o).GetEnumerator();
+            //else if (o.GetType().IsArray)
+            //    iter = new ArrayIterator(o);
+            else if (o is Iterator)
+                iter = (Iterator)o;
+            if (iter == null)
+                return o;
+            return iter;
+        }
+
+        protected static Iterator ConvertAnythingToIterator(object o)
+        {
+            o = ConvertAnythingIteratableToIterator(o);
+            if (o is Iterator)
+                return (Iterator)o;
+            IList singleton = new Template.AttributeList(1);
+            singleton.Add(o);
+            return singleton.GetEnumerator();
+        }
+
+        protected bool TestAttributeTrue(object a)
+        {
+            if (a == null)
+                return false;
+            if (a is bool)
+                return (bool)a;
+            if (a is ICollection)
+                return ((ICollection)a).Count > 0;
+            //if (a is IDictionary)
+            //    return ((IDictionary)a).Count > 0;
+            //if (a is Iterator)
+            //    return ((Iterator)a).hasNext();
+            return true; // any other non-null object, return true--it's present
+        }
+
+        protected object GetObjectProperty(Template self, object o, object property)
+        {
+            if (o == null || property == null)
+            {
+                // TODO: throw Ill arg if they want
+                return null;
+            }
+
+            object value = null;
+
+            if (o is IDictionary)
+            {
+                IDictionary map = (IDictionary)o;
+                if (property.ToString() == TemplateGroup.DICT_KEY)
+                    value = property;
+                else if (property.Equals("keys"))
+                    value = map.Keys;
+                else if (property.Equals("values"))
+                    value = map.Values;
+                else if (map.Contains(property))
+                    value = map[property];
+                else if (map.Contains(ToString(self, property)))
+                {
+                    // if we can't find the key, toString it
+                    value = map[ToString(self, property)];
+                }
+                else
+                    value = map[TemplateGroup.DEFAULT_KEY]; // not found, use default
+                if (property.ToString() == TemplateGroup.DICT_KEY)
+                {
+                    value = property;
+                }
+                return value;
+            }
+
+            var c = o.GetType();
+
+            // try getXXX and isXXX properties
+
+            // look up using reflection
+            string propertyName = (string)property;
+            string methodSuffix = char.ToUpperInvariant(propertyName[0]) +
+                propertyName.Substring(1);
+            MethodInfo m = GetMethod(c, "get" + methodSuffix);
+            if (m == null)
+            {
+                m = GetMethod(c, "is" + methodSuffix);
+            }
+            if (m != null)
+            {
+                // save to avoid lookup later
+                //self.getGroup().cacheClassProperty(c,propertyName,m);
+                try
+                {
+                    value = InvokeMethod(m, o, value);
+                }
+                catch
+                {
+                    Console.Error.WriteLine("Can't get property " + propertyName + " using method get/is" + methodSuffix +
+                        " from " + c.Name + " instance");
+                }
+            }
+            else
+            {
+                // try for a visible field
+                try
+                {
+                    FieldInfo f = c.GetField(propertyName);
+                    //self.getGroup().cacheClassProperty(c,propertyName,f);
+                    try
+                    {
+                        value = AccessField(f, o, value);
+                    }
+                    catch
+                    {
+                        Console.Error.WriteLine("Can't access property " + propertyName + " using method get/is" + methodSuffix +
+                            " or direct field access from " + c.Name + " instance");
+                    }
+                }
+                catch
+                {
+                    Console.Error.WriteLine("Class " + c.Name + " has no such attribute: " + propertyName +
+                        " in template context " + "PUT CALLSTACK HERE");
+                }
+            }
+
+            return value;
+        }
+
+        protected object AccessField(FieldInfo f, object o, object value)
+        {
+            value = f.GetValue(o);
+            return value;
+        }
+
+        protected object InvokeMethod(MethodInfo m, object o, object value)
+        {
+            value = m.Invoke(o, (object[])null);
+            return value;
+        }
+
+        protected MethodInfo GetMethod(Type c, string methodName)
+        {
+            MethodInfo m;
+            try
+            {
+                m = c.GetMethod(methodName, (Type[])null);
+            }
+            catch
+            {
+                m = null;
+            }
+            return m;
+        }
+
+        protected void Trace(Template self, int ip)
+        {
+            BytecodeDisassembler dis = new BytecodeDisassembler(self.code.instrs,
+                                                                self.code.instrs.Length,
+                                                                self.code.strings);
+            StringBuilder buf = new StringBuilder();
+            dis.DisassembleInstruction(buf, ip);
+            string name = self.name + ":";
+            if (self.name == Template.UnknownName)
+                name = "";
+            Console.Write(string.Format("{0:-40s}", name + buf));
+            Console.Write("\tstack=[");
+            for (int i = 0; i <= sp; i++)
+            {
+                object o = operands[i];
+                PrintForTrace(o);
+            }
+            Console.Write(" ], calls=");
+            Console.Write(self.GetEnclosingInstanceStackString());
+            Console.Write(", sp=" + sp + ", nw=" + nw);
+            Console.WriteLine();
+        }
+
+        protected void PrintForTrace(object o)
+        {
+            if (o is Template)
+            {
+                Console.Write(" " + ((Template)o).name + "()");
+                return;
+            }
+            o = ConvertAnythingIteratableToIterator(o);
+            if (o is Iterator)
+            {
+                Iterator it = (Iterator)o;
+                Console.Write(" [");
+                while (it.MoveNext())
+                {
+                    PrintForTrace(it.Current);
+                }
+                Console.Write(" ]");
+            }
+            else
+            {
+                Console.Write(" " + o);
+            }
+        }
+
+        public static int GetInt(byte[] memory, int index)
+        {
+            int b1 = memory[index++] & 0xFF; // mask off sign-extended bits
+            int b2 = memory[index++] & 0xFF;
+            int b3 = memory[index++] & 0xFF;
+            int b4 = memory[index++] & 0xFF;
+            int word = b1 << (8 * 3) | b2 << (8 * 2) | b3 << (8 * 1) | b4;
+            return word;
+        }
+
+        public static int GetShort(byte[] memory, int index)
+        {
+            int b1 = memory[index++] & 0xFF; // mask off sign-extended bits
+            int b2 = memory[index++] & 0xFF;
+            int word = b1 << (8 * 1) | b2;
+            return word;
+        }
+    }
+}
diff --git a/StringTemplate4/Misc.cs b/StringTemplate4/Misc.cs
new file mode 100644
index 0000000..c24aedb
--- /dev/null
+++ b/StringTemplate4/Misc.cs
@@ -0,0 +1,56 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    internal static class Misc
+    {
+        public static string Strip(string s, int n)
+        {
+            return s.Substring(n, s.Length - 2 * n);
+        }
+
+        public static string TrimOneStartingWS(string s)
+        {
+            // strip newline from front and back, but just one
+            if (s.StartsWith("\r\n"))
+                s = s.Substring(2);
+            else if (s.StartsWith("\n"))
+                s = s.Substring(1);
+            /*
+            if ( s.endsWith("\r\n") ) s = s.substring(0,s.length()-2);
+            else if ( s.endsWith("\n") ) s = s.substring(0,s.length()-1);
+             */
+            return s;
+        }
+    }
+}
diff --git a/StringTemplate4/NoIndentWriter.cs b/StringTemplate4/NoIndentWriter.cs
new file mode 100644
index 0000000..939a01d
--- /dev/null
+++ b/StringTemplate4/NoIndentWriter.cs
@@ -0,0 +1,50 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    using TextWriter = System.IO.TextWriter;
+
+    public class NoIndentWriter : AutoIndentWriter
+    {
+        public NoIndentWriter(TextWriter @out)
+            : base(@out)
+        {
+        }
+
+        public override int Write(string str)
+        {
+            @out.Write(str);
+            return str.Length;
+        }
+    }
+}
diff --git a/StringTemplate4/Properties/AssemblyInfo.cs b/StringTemplate4/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..839caa9
--- /dev/null
+++ b/StringTemplate4/Properties/AssemblyInfo.cs
@@ -0,0 +1,70 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+using System;
+
+// General Information about an assembly is controlled through the following
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("StringTemplate4")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("Sam Harwell")]
+[assembly: AssemblyProduct("StringTemplate4")]
+[assembly: AssemblyCopyright("Copyright © Sam Harwell 2009")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible
+// to COM components.  If you need to access a type in this assembly from
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+[assembly: CLSCompliant(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("9fefb7b5-1863-4c57-aae2-21d018c08bd0")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/StringTemplate4/StringTable.cs b/StringTemplate4/StringTable.cs
new file mode 100644
index 0000000..7b13278
--- /dev/null
+++ b/StringTemplate4/StringTable.cs
@@ -0,0 +1,64 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    using System.Collections.Generic;
+    using System.Linq;
+
+    public class StringTable
+    {
+        private readonly Dictionary<string, int> _table = new Dictionary<string, int>();
+        private int _i = -1;
+
+        public int Add(string s)
+        {
+            int i;
+            if (_table.TryGetValue(s, out i))
+                return i;
+
+            i = ++_i;
+            _table[s] = i;
+            return i;
+        }
+
+        public int GetIndex(string s)
+        {
+            return _table[s];
+        }
+
+        public string[] ToArray()
+        {
+            return _table.OrderBy(pair => pair.Value).Select(pair => pair.Key).ToArray();
+        }
+    }
+}
diff --git a/StringTemplate4/StringTemplate4.csproj b/StringTemplate4/StringTemplate4.csproj
new file mode 100644
index 0000000..59c0da4
--- /dev/null
+++ b/StringTemplate4/StringTemplate4.csproj
@@ -0,0 +1,103 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{BBE5D9E6-2F4C-46EF-8CDB-17F886A36837}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>StringTemplate</RootNamespace>
+    <AssemblyName>StringTemplate4</AssemblyName>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <SignAssembly>true</SignAssembly>
+    <AssemblyOriginatorKeyFile>..\Antlr3\Key.snk</AssemblyOriginatorKeyFile>
+    <SccProjectName>Perforce Project</SccProjectName>
+    <SccLocalPath>..\..\..</SccLocalPath>
+    <SccAuxPath>
+    </SccAuxPath>
+    <SccProvider>MSSCCI:Perforce SCM</SccProvider>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>bin\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>bin\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="AutoIndentWriter.cs" />
+    <Compile Include="BlankTemplate.cs" />
+    <Compile Include="Bytecode.cs" />
+    <Compile Include="BytecodeDisassembler.cs" />
+    <Compile Include="CompiledTemplate.cs" />
+    <Compile Include="Compiler.cs" />
+    <Compile Include="ErrorTolerance.cs" />
+    <Compile Include="FormalArgument.cs" />
+    <Compile Include="GroupLexerHelper.cs" />
+    <Compile Include="GroupParserHelper.cs" />
+    <Compile Include="ICodeGenerator.cs" />
+    <Compile Include="Interpreter.cs" />
+    <Compile Include="ITemplateErrorListener.cs" />
+    <Compile Include="ITemplateWriter.cs" />
+    <Compile Include="Misc.cs" />
+    <Compile Include="NoIndentWriter.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+    <Compile Include="StringTable.cs" />
+    <Compile Include="Template.cs" />
+    <Compile Include="TemplateException.cs" />
+    <Compile Include="TemplateGroup.cs" />
+    <Compile Include="TemplateGroupDirectory.cs" />
+    <Compile Include="TemplateGroupFile.cs" />
+    <Compile Include="TemplateLexer.cs" />
+    <Compile Include="TemplateParserHelper.cs" />
+    <Compile Include="TemplateRecognitionException.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="..\Antlr3\Key.snk">
+      <Link>Key.snk</Link>
+    </None>
+    <AntlrTokens Include="TemplateLexer.tokens" />
+    <Antlr3 Include="TemplateParser.g3" />
+    <Antlr3 Include="Group.g3" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\..\antlr\main\runtime\CSharp3\Sources\Antlr3.Runtime\Antlr3.Runtime.csproj">
+      <Project>{8FDC0A87-9005-4D5A-AB75-E55CEB575559}</Project>
+      <Name>Antlr3.Runtime</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <PropertyGroup>
+    <!-- Folder containing AntlrBuildTask.dll -->
+    <AntlrBuildTaskPath>$(SolutionDir)bin\Bootstrap</AntlrBuildTaskPath>
+    <!-- Path to the ANTLR Tool itself. -->
+    <AntlrToolPath>$(SolutionDir)bin\Bootstrap\Antlr3.exe</AntlrToolPath>
+  </PropertyGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <Import Project="$(SolutionDir)bin\Bootstrap\Antlr3.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
\ No newline at end of file
diff --git a/StringTemplate4/StringTemplate4.csproj.vspscc b/StringTemplate4/StringTemplate4.csproj.vspscc
new file mode 100644
index 0000000..52102f8
--- /dev/null
+++ b/StringTemplate4/StringTemplate4.csproj.vspscc
@@ -0,0 +1,10 @@
+﻿""
+{
+"FILE_VERSION" = "9237"
+"ENLISTMENT_CHOICE" = "NEVER"
+"PROJECT_FILE_RELATIVE_PATH" = "relative:antlrcs\\main\\StringTemplate4"
+"NUMBER_OF_EXCLUDED_FILES" = "0"
+"ORIGINAL_PROJECT_FILE_PATH" = ""
+"NUMBER_OF_NESTED_PROJECTS" = "0"
+"SOURCE_CONTROL_SETTINGS_PROVIDER" = "PROJECT"
+}
diff --git a/StringTemplate4/Template.cs b/StringTemplate4/Template.cs
new file mode 100644
index 0000000..b38ff7a
--- /dev/null
+++ b/StringTemplate4/Template.cs
@@ -0,0 +1,318 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    using System.Collections.Generic;
+    using ArgumentException = System.ArgumentException;
+    using ArrayList = System.Collections.ArrayList;
+    using Console = System.Console;
+    using Exception = System.Exception;
+    using IList = System.Collections.IList;
+    using IOException = System.IO.IOException;
+    using StringWriter = System.IO.StringWriter;
+
+    public class Template
+    {
+        public const string UnknownName = "unknown";
+        public string name = UnknownName;
+
+
+        /** The code to interpret; it pulls from attributes and this template's
+         *  group of templates to evaluate to string.
+         */
+        public CompiledTemplate code; // TODO: is this the right name?
+
+        public static readonly Template Blank = new BlankTemplate();
+
+        /** The group that holds this ST definition.  We use it to initiate
+         *  interpretation via ST.toString().  From there, it becomes group field
+         *  in interpreter and is fixed until rendering completes.
+         */
+        //public STGroup nativeGroup = STGroup.defaultGroup;
+
+        /** Map an attribute name to its value(s). */
+        internal IDictionary<string, object> attributes;
+
+        public class AddEvent
+        {
+            string name;
+            object value;
+            Exception source;
+            public AddEvent(string name, object value)
+            {
+                this.name = name;
+                this.value = value;
+                this.source = new Exception();
+            }
+        }
+
+        /** Track add attribute "events"; used for ST user-level debugging */
+        IList<AddEvent> addEvents;
+
+        /** Normally, formal parameters hide any attributes inherited from the
+         *  enclosing template with the same name.  This is normally what you
+         *  want, but makes it hard to invoke another template passing in all
+         *  the data.  Use notation now: <otherTemplate(...)> to say "pass in
+         *  all data".  Works great.  Can also say <otherTemplate(foo="xxx",...)>
+         */
+        protected internal bool passThroughAttributes = false;
+
+        /** Enclosing instance if I'm embedded within another template.
+         *  IF-subtemplates are considered embedded as well.
+         */
+        internal Template enclosingInstance; // who's your daddy?
+
+        /** Just an alias for ArrayList, but this way I can track whether a
+         *  list is something ST created or it's an incoming list.
+         */
+        public sealed class AttributeList : ArrayList
+        {
+            public AttributeList(int size)
+                : base(size)
+            {
+            }
+
+            public AttributeList()
+            {
+            }
+        }
+
+        public Template()
+        {
+        }
+
+        public Template(string template)
+        {
+            code = TemplateGroup.defaultGroup.DefineTemplate(UnknownName, template);
+            /*
+                    try {
+                        code = group.defineTemplate(UNKNOWN_NAME, template);
+                    }
+                    catch (STRecognitionException e) {
+                        int i = group.getCharPositionInLine(null, e);
+                        group.listener.error(e.msg, null);
+                    }
+                     */
+        }
+
+        public Template(TemplateGroup nativeGroup, string template)
+        {
+            code = nativeGroup.DefineTemplate(UnknownName, template);
+        }
+
+        public virtual void Add(string name, object value)
+        {
+            if (name == null)
+                return; // allow null value
+
+            if (name.IndexOf('.') >= 0)
+            {
+                throw new ArgumentException("cannot have '.' in attribute names");
+            }
+
+            if (code.nativeGroup.Detects(ErrorTolerance.DETECT_ADD_ATTR))
+            {
+                if (addEvents == null)
+                    addEvents = new List<AddEvent>();
+                addEvents.Add(new AddEvent(name, value));
+            }
+
+            if (value is Template)
+                ((Template)value).enclosingInstance = this;
+
+            object curvalue = null;
+            if (attributes == null || !attributes.ContainsKey(name))
+            { // new attribute
+                RawSetAttribute(name, value);
+                return;
+            }
+            if (attributes != null)
+                curvalue = attributes[name];
+
+            // attribute will be multi-valued for sure now
+            // convert current attribute to list if not already
+            // copy-on-write semantics; copy a list injected by user to add new value
+            AttributeList multi = ConvertToAttributeList(curvalue);
+            RawSetAttribute(name, multi); // replace with list
+
+            // now, add incoming value to multi-valued attribute
+            if (value is IList)
+            {
+                // flatten incoming list into existing list
+                multi.AddRange((IList)value);
+            }
+            else if (value != null && value.GetType().IsArray)
+            {
+                multi.AddRange((object[])value);
+            }
+            else
+            {
+                multi.Add(value);
+            }
+        }
+
+        protected internal virtual void RawSetAttribute(string name, object value)
+        {
+            if (attributes == null)
+                attributes = new Dictionary<string, object>();
+
+            attributes[name] = value;
+        }
+
+        /** Find an attr with dynamic scoping up enclosing ST chain.
+         *  If not found, look for a map.  So attributes sent in to a template
+         *  override dictionary names.
+         */
+        public virtual object GetAttribute(string name)
+        {
+            object o = null;
+            if (attributes != null)
+                attributes.TryGetValue(name, out o);
+
+            if (o != null)
+                return o;
+
+            if (code.formalArguments != null &&
+                 code.formalArguments.ContainsKey(name) &&  // no local value && it's a formal arg
+                 !passThroughAttributes)                 // but no ... in arg list
+            {
+                // if you've defined attribute as formal arg for this
+                // template and it has no value, do not look up the
+                // enclosing dynamic scopes.
+                return null;
+            }
+
+            Template p = this.enclosingInstance;
+            while (p != null)
+            {
+                if (p.attributes != null)
+                    p.attributes.TryGetValue(name, out o);
+                if (o != null)
+                    return o;
+                p = p.enclosingInstance;
+            }
+            if (code.formalArguments == null || !code.formalArguments.ContainsKey(name))
+            {
+                // if not hidden by formal args, return any dictionary
+                IDictionary<string, object> dictionary;
+                if (code.nativeGroup.dictionaries.TryGetValue(name, out dictionary))
+                    return dictionary;
+            }
+            return null;
+        }
+
+        protected static AttributeList ConvertToAttributeList(object curvalue)
+        {
+            AttributeList multi;
+            if (curvalue == null)
+            {
+                multi = new AttributeList(); // make list to hold multiple values
+                multi.Add(curvalue);         // add previous single-valued attribute
+            }
+            else if (curvalue.GetType() == typeof(AttributeList))
+            { // already a list made by ST
+                multi = (AttributeList)curvalue;
+            }
+            else if (curvalue is IList)
+            { // existing attribute is non-ST List
+                // must copy to an ST-managed list before adding new attribute
+                // (can't alter incoming attributes)
+                IList listAttr = (IList)curvalue;
+                multi = new AttributeList(listAttr.Count);
+                multi.AddRange(listAttr);
+            }
+            else if (curvalue.GetType().IsArray)
+            { // copy array to list
+                object[] a = (object[])curvalue;
+                multi = new AttributeList(a.Length);
+                multi.AddRange(a); // asList doesn't copy as far as I can tell
+            }
+            else
+            {
+                // curvalue nonlist and we want to add an attribute
+                // must convert curvalue existing to list
+                multi = new AttributeList(); // make list to hold multiple values
+                multi.Add(curvalue);         // add previous single-valued attribute
+            }
+            return multi;
+        }
+
+        /** If an instance of x is enclosed in a y which is in a z, return
+         *  a String of these instance names in order from topmost to lowest;
+         *  here that would be "[z y x]".
+         */
+        public virtual string GetEnclosingInstanceStackString()
+        {
+            var names = new LinkedList<string>();
+            Template p = this;
+            while (p != null)
+            {
+                string name = p.name;
+                names.AddFirst(name);
+                p = p.enclosingInstance;
+            }
+            return names.ToString().Replace(",", "");
+        }
+
+        public virtual int Write(ITemplateWriter @out)
+        {
+            Interpreter interp = new Interpreter(code.nativeGroup);
+            return interp.Exec(@out, this);
+        }
+
+        public virtual string Render()
+        {
+            StringWriter @out = new StringWriter();
+            ITemplateWriter wr = new AutoIndentWriter(@out);
+            try
+            {
+                Write(wr);
+                /*
+                System.err.println("template size = "+code.template.length()+
+                                   ", code size = "+code.instrs.length+", ratio = "+
+                                   ((float)code.instrs.length/code.template.length()));
+                                   */
+            }
+            catch (IOException)
+            {
+                Console.Error.WriteLine("Got IOException writing to writer");
+            }
+            return @out.ToString();
+        }
+
+        public override string ToString()
+        {
+            return name + "()";
+        }
+    }
+}
diff --git a/StringTemplate4/TemplateException.cs b/StringTemplate4/TemplateException.cs
new file mode 100644
index 0000000..037cadb
--- /dev/null
+++ b/StringTemplate4/TemplateException.cs
@@ -0,0 +1,54 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    using Exception = System.Exception;
+
+    public class TemplateException : Exception
+    {
+        public TemplateException()
+            : this("StringTemplate exception", null)
+        {
+        }
+
+        public TemplateException(Exception innerException)
+            : this("StringTemplate exception", innerException)
+        {
+        }
+
+        public TemplateException(string message, Exception innerException)
+            : base(message, innerException)
+        {
+        }
+    }
+}
diff --git a/StringTemplate4/TemplateGroup.cs b/StringTemplate4/TemplateGroup.cs
new file mode 100644
index 0000000..4f7574a
--- /dev/null
+++ b/StringTemplate4/TemplateGroup.cs
@@ -0,0 +1,293 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    using System.Collections.Generic;
+    using System.Linq;
+    using ArgumentException = System.ArgumentException;
+    using Console = System.Console;
+    using Encoding = System.Text.Encoding;
+    using Exception = System.Exception;
+    using StringBuilder = System.Text.StringBuilder;
+
+    public class TemplateGroup
+    {
+    /** When we use key as a value in a dictionary, this is how we signify. */
+    public static readonly string DICT_KEY = "key";
+    public static readonly string DEFAULT_KEY = "default";
+
+    private class DefaultErrorListenerImpl : ITemplateErrorListener
+    {
+        public void Error(string message, Exception e)
+        {
+            Console.Error.WriteLine(message);
+            if (e != null)
+                Console.Error.WriteLine(e.StackTrace);
+        }
+
+        public void Error(string message)
+        {
+            Error(message, null);
+        }
+
+        public void Warning(string message)
+        {
+            Console.WriteLine(message);
+        }
+    }
+
+    public static readonly ITemplateErrorListener DefaultErrorListener = new DefaultErrorListenerImpl();
+
+    /** The topmost group of templates in the template tree.
+     *  If null, implies this is the root
+     */
+    public TemplateGroup root;
+
+    /** Load files using what encoding? */
+    public Encoding encoding;
+
+    //public String supergroup;
+
+    public List<string> interfaces;
+
+    public char delimiterStartChar = '<'; // Use <expr> by default
+    public char delimiterStopChar = '>';
+
+    /** Maps template name to StringTemplate object */
+    protected internal IDictionary<string, CompiledTemplate> templates =
+        new Dictionary<string,CompiledTemplate>();
+
+    /** Maps dict names to HashMap objects.  This is the list of dictionaries
+     *  defined by the user like typeInitMap ::= ["int":"0"]
+     */
+    protected internal IDictionary<string, IDictionary<string,object>> dictionaries =
+        new Dictionary<string, IDictionary<string,object>>();
+
+    protected bool alreadyLoaded = false;
+
+    /** Where to report errors.  All string templates in this group
+     *  use this error handler by default.
+     */
+    public ITemplateErrorListener listener = DefaultErrorListener;
+
+	public static ErrorTolerance DEFAULT_ERROR_TOLERANCE = new ErrorTolerance();
+	public ErrorTolerance tolerance = DEFAULT_ERROR_TOLERANCE;
+
+	public static TemplateGroup defaultGroup = new TemplateGroup();
+
+    public TemplateGroup()
+    {
+    }
+
+    /*
+    public TemplateGroup(String name) {
+        this.name = name;
+    }
+    */
+
+    // TODO: for dirs, should this load everything in dir and below?
+    public virtual void Load()
+    {
+    } // nothing to do unless it's a group file
+
+    /** The primary means of getting an instance of a template from this
+     *  group.
+     */
+    public virtual Template GetInstanceOf(string name)
+    {
+        CompiledTemplate c = LookupTemplate(name);
+        if ( c!=null ) {
+            Template instanceST = CreateStringTemplate();
+            //instanceST.group = this;  leave it as nativeGroup
+            instanceST.name = name;
+            instanceST.code = c;
+            return instanceST;
+        }
+        return null;
+    }
+
+    public virtual Template GetEmbeddedInstanceOf(Template enclosingInstance, string name)
+    {
+        Template st = GetInstanceOf(name);
+        if ( st==null ) {
+            Console.Error.WriteLine("no such template: "+name);
+            return Template.Blank;
+        }
+        st.enclosingInstance = enclosingInstance;
+        return st;
+    }
+
+    public virtual CompiledTemplate LookupTemplate(string name)
+    {
+        CompiledTemplate template;
+        if (!templates.TryGetValue(name, out template))
+            return null;
+
+        return template;
+    }
+
+    // TODO: send in start/stop char or line/col so errors can be relative
+    public CompiledTemplate DefineTemplate(string name, string template) {
+        return DefineTemplate(name, (IDictionary<string,FormalArgument>)null, template);
+    }
+
+    public virtual CompiledTemplate DefineTemplate(string name,
+                                     List<string> args,
+                                     string template)
+    {
+        IDictionary<string,FormalArgument> margs =
+            new Dictionary<string,FormalArgument>();
+        foreach (string a in args) margs[a] = new FormalArgument(a);
+        return DefineTemplate(name, margs, template);
+    }
+
+    public virtual CompiledTemplate DefineTemplate(string name,
+                                     string[] args,
+                                     string template)
+    {
+        IDictionary<string,FormalArgument> margs =
+            new Dictionary<string,FormalArgument>();
+        foreach (string a in args) margs[a] = new FormalArgument(a);
+        return DefineTemplate(name, margs, template);
+    }
+
+	// can't trap recog errors here; don't know where in file template is defined
+    public virtual CompiledTemplate DefineTemplate(string name,
+                                     IDictionary<string,FormalArgument> args,
+                                     string template)
+    {
+        if ( name!=null && (name.Length==0 || name.IndexOf('.')>=0) ) {
+            throw new ArgumentException("cannot have '.' in template names");
+        }
+        Compiler c = new Compiler();
+		//template = Misc.trimOneStartingWS(template);
+		CompiledTemplate code = c.Compile(template);
+        code.name = name;
+        code.formalArguments = args;
+        code.nativeGroup = this;
+        templates[name] = code;
+        if ( args!=null ) { // compile any default args
+            foreach (string a in args.Keys) {
+                FormalArgument fa = args[a];
+                if ( fa.defaultValue!=null ) {
+                    Compiler c2 = new Compiler();
+                    fa.compiledDefaultValue = c2.Compile(template);
+                }
+            }
+        }
+        // define any anonymous subtemplates
+        DefineAnonSubtemplates(code);
+
+        return code;
+    }
+
+    public virtual void DefineAnonSubtemplates(CompiledTemplate code)
+    {
+        if ( code.compiledSubtemplates!=null ) {
+            foreach (CompiledTemplate sub in code.compiledSubtemplates) {
+                templates[sub.name] = sub;
+                DefineAnonSubtemplates(sub);
+            }
+        }
+    }
+
+    /** Define a map for this group; not thread safe...do not keep adding
+     *  these while you reference them.
+     */
+    public virtual void DefineDictionary(string name, IDictionary<string, object> mapping)
+    {
+        dictionaries[name] = mapping;
+    }
+
+    /** StringTemplate object factory; each group can have its own. */
+    public virtual Template CreateStringTemplate()
+    {
+        Template st = new Template();
+        return st;
+    }
+
+    public virtual string GetName()
+    {
+        return "<no name>;";
+    }
+
+    public override string ToString()
+    {
+        return Show();
+    }
+
+    public virtual string Show() {
+        StringBuilder buf = new StringBuilder();
+        //if ( supergroup!=null ) buf.append(" : "+supergroup);
+        foreach (string name in templates.Keys) {
+			if ( name.StartsWith("_") ) continue;
+            CompiledTemplate c = templates[name];
+            buf.Append(name);
+            buf.Append('(');
+            if ( c.formalArguments!=null ) {
+                buf.Append( string.Join(",", c.formalArguments.Values.Select(value => value.ToString()).ToArray()) );
+            }
+            buf.Append(')');
+            buf.AppendLine(" ::= <<");
+            buf.AppendLine(c.template);
+            buf.AppendLine(">>");
+        }
+        return buf.ToString();
+    }
+
+    public virtual void SetErrorListener(ITemplateErrorListener listener)
+    {
+        this.listener = listener;
+    }
+
+    public virtual void SetErrorTolerance(ErrorTolerance errors)
+    {
+        this.tolerance = errors;
+    }
+
+    public virtual bool Detects(int x)
+    {
+        return tolerance.Detects(x);
+    }
+
+    public virtual void Detect(int x)
+    {
+        tolerance.Detect(x);
+    }
+
+    public virtual void Ignore(int x)
+    {
+        tolerance.Ignore(x);
+    }
+    }
+}
diff --git a/StringTemplate4/TemplateGroupDirectory.cs b/StringTemplate4/TemplateGroupDirectory.cs
new file mode 100644
index 0000000..d3fae53
--- /dev/null
+++ b/StringTemplate4/TemplateGroupDirectory.cs
@@ -0,0 +1,162 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    using System.Linq;
+    using Antlr.Runtime;
+    using ArgumentException = System.ArgumentException;
+    using Directory = System.IO.Directory;
+    using Encoding = System.Text.Encoding;
+    using Exception = System.Exception;
+    using File = System.IO.File;
+    using Path = System.IO.Path;
+
+    public class TemplateGroupDirectory : TemplateGroup
+    {
+        public string dir;
+
+        public TemplateGroupDirectory(string dirName)
+        {
+            dir = dirName;
+            if (!Directory.Exists(dir))
+            {
+                throw new ArgumentException("No such directory: " + dirName);
+            }
+        }
+
+        public TemplateGroupDirectory(TemplateGroup root, string dirName)
+            : this(dirName)
+        {
+            this.root = root;
+        }
+
+        public TemplateGroupDirectory(TemplateGroup root, string dirName, Encoding encoding)
+            : this(root, dirName)
+        {
+            this.encoding = encoding;
+        }
+
+        public override CompiledTemplate LookupTemplate(string name)
+        {
+            if (name.Length > 0 && (name[0] == Path.DirectorySeparatorChar || name[0] == Path.AltDirectorySeparatorChar))
+            {
+                if (root != null)
+                    return root.LookupTemplate(name);
+                // strip '/' and try again; we're root
+                //return lookupTemplate(name.substring(1));
+                name = name.Substring(1);
+                string[] names = name.Split(new char[] { Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar });
+                if (!names[0].Equals(Path.GetFileName(dir)))
+                {
+                    throw new ArgumentException(names[0] + " doesn't match directory name " + Path.GetFileName(dir));
+                }
+            }
+            if (name.IndexOfAny(new char[] { Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar }) >= 0)
+                return LookupQualifiedTemplate(dir, name);
+
+            // else plain old template name, check if already here
+            CompiledTemplate code;
+            if (templates.TryGetValue(name, out code))
+                return code;
+
+            return LookupTemplateFile(name);
+        }
+
+        /** Look up template name with '/' anywhere but first char */
+        protected virtual CompiledTemplate LookupQualifiedTemplate(string dir, string name)
+        {
+            // TODO: slow to load a template!
+            string[] names = name.Split(new char[] { Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar });
+            string templateFile = Path.Combine(dir, names[0] + ".st");
+            if (templates.ContainsKey(names[0]) || File.Exists(templateFile))
+            {
+                throw new ArgumentException(names[0] + " is a template not a dir or group file");
+            }
+            // look for a directory or group file called names[0]
+            TemplateGroup sub = null;
+            string subF = Path.Combine(dir, names[0]);
+            if (Directory.Exists(subF))
+            {
+                sub = new TemplateGroupDirectory(root, Path.Combine( dir , names[0]));
+            }
+            else if (File.Exists(Path.Combine(dir, names[0] + ".stg")))
+            {
+                try
+                {
+                    sub = new TemplateGroupFile(Path.Combine(dir, names[0] + ".stg"));
+                }
+                catch (Exception e)
+                {
+                    listener.Error("can't load group file: " + names[0] + ".stg", e);
+                }
+            }
+            else
+            {
+                throw new ArgumentException("no such subgroup: " + names[0]);
+            }
+            string allButFirstName = string.Join(Path.DirectorySeparatorChar.ToString(), names.Skip(1).ToArray());
+            return sub.LookupTemplate(allButFirstName);
+        }
+
+        public virtual CompiledTemplate LookupTemplateFile(string name)
+        {
+            // not in templates list, load it from disk
+            string f = Path.Combine(dir, name + ".st");
+            if (!File.Exists(f))
+            { // TODO: add tolerance check here
+                throw new ArgumentException("no such template: " + name);
+            }
+            try
+            {
+                ANTLRFileStream fs = new ANTLRFileStream(f, encoding);
+                GroupLexer lexer = new GroupLexer(fs);
+                CommonTokenStream tokens = new CommonTokenStream(lexer);
+                GroupParser parser = new GroupParser(tokens);
+                parser._group = this;
+                parser.templateDef();
+                return templates[name];
+            }
+            catch (Exception e)
+            {
+                listener.Error("can't load template file: " + Path.Combine(f, name), e);
+            }
+            return null;
+        }
+
+        public override string GetName()
+        {
+            return Path.GetFileName(dir);
+        }
+
+    }
+}
diff --git a/StringTemplate4/TemplateGroupFile.cs b/StringTemplate4/TemplateGroupFile.cs
new file mode 100644
index 0000000..45b4aea
--- /dev/null
+++ b/StringTemplate4/TemplateGroupFile.cs
@@ -0,0 +1,130 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    using Antlr.Runtime;
+    using ArgumentException = System.ArgumentException;
+    using Encoding = System.Text.Encoding;
+    using Exception = System.Exception;
+    using Path = System.IO.Path;
+    using StringComparison = System.StringComparison;
+
+    public class TemplateGroupFile : TemplateGroup
+    {
+        public string fileName;
+        //public Encoding encoding;
+
+        public TemplateGroupFile(string fileName)
+        {
+            if (!Path.GetExtension(fileName).Equals(".stg", StringComparison.OrdinalIgnoreCase))
+            {
+                throw new ArgumentException("Group file names must end in .stg: " + fileName);
+            }
+            this.fileName = fileName;
+        }
+
+        public TemplateGroupFile(TemplateGroup root, string fileName)
+            : this(fileName)
+        {
+            this.root = root;
+        }
+
+        public TemplateGroupFile(TemplateGroup root, string fileName, Encoding encoding)
+            : this(root, fileName)
+        {
+            this.encoding = encoding;
+        }
+
+        public override string GetName()
+        {
+            return Path.GetFileName(fileName);
+        }
+
+        public override CompiledTemplate LookupTemplate(string name)
+        {
+            if (name.Length > 0 && (name[0] == Path.DirectorySeparatorChar || name[0] == Path.AltDirectorySeparatorChar))
+            {
+                if (root != null)
+                    return root.LookupTemplate(name);
+                // if no root, name must be "/groupfile/templatename"
+                string[] names = name.Split(new char[] { Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar });
+                string fname = Path.GetFileName(fileName);
+                string @base = fname.Substring(0, fname.LastIndexOf('.'));
+                if (names.Length > 2 || !names[0].Equals(@base))
+                {
+                    throw new ArgumentException("name must be of form /" + @base + "/templatename: " + name);
+                }
+            }
+            if (name.IndexOfAny(new char[] { Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar }) >= 0)
+            {
+                throw new ArgumentException("can't use relative template name " + name);
+            }
+
+            // else plain old template name
+            if (!alreadyLoaded)
+                Load();
+
+            CompiledTemplate template;
+            if (!templates.TryGetValue(name, out template))
+                return null;
+
+            return template;
+        }
+
+        public override void Load()
+        {
+            if (alreadyLoaded)
+                return;
+            try
+            {
+                ANTLRFileStream fs = new ANTLRFileStream(fileName, encoding);
+                GroupLexer lexer = new GroupLexer(fs);
+                CommonTokenStream tokens = new CommonTokenStream(lexer);
+                GroupParser parser = new GroupParser(tokens);
+                parser.group(this);
+                alreadyLoaded = true;
+            }
+            catch (Exception e)
+            {
+                listener.Error("can't load group file: " + fileName, e);
+            }
+        }
+
+        public override string Show()
+        {
+            if (!alreadyLoaded)
+                Load();
+            return base.Show();
+        }
+    }
+}
diff --git a/StringTemplate4/TemplateLexer.cs b/StringTemplate4/TemplateLexer.cs
new file mode 100644
index 0000000..28a89be
--- /dev/null
+++ b/StringTemplate4/TemplateLexer.cs
@@ -0,0 +1,626 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    using System.Collections.Generic;
+    using Antlr.Runtime;
+    using Console = System.Console;
+    using Exception = System.Exception;
+    using NumberStyles = System.Globalization.NumberStyles;
+    using StringBuilder = System.Text.StringBuilder;
+
+    public class TemplateLexer : ITokenSource
+    {
+        public const char EOF = unchecked((char)(-1));            // EOF char
+        public const int EOF_TYPE = CharStreamConstants.EndOfFile;  // EOF token type
+
+        public class TemplateToken : CommonToken
+        {
+            public TemplateToken(ICharStream input, int type, int channel, int start, int stop)
+                : base(input, type, channel, start, stop)
+            {
+            }
+
+            public TemplateToken(int type, string text)
+                : base(type, text)
+            {
+            }
+
+            public override string ToString()
+            {
+                string channelStr = "";
+                if (Channel > 0)
+                {
+                    channelStr = ",channel=" + Channel;
+                }
+                string txt = Text;
+                if (txt != null)
+                {
+                    txt = txt.Replace("\n", "\\\\n");
+                    txt = txt.Replace("\r", "\\\\r");
+                    txt = txt.Replace("\t", "\\\\t");
+                }
+                else
+                {
+                    txt = "<no text>";
+                }
+                return "[@" + TokenIndex + "," + StartIndex + ":" + StopIndex + "='" + txt + "',<" + TemplateParser.tokenNames[Type] + ">" + channelStr + "," + Line + ":" + CharPositionInLine + "]";
+            }
+        }
+
+        public static readonly IToken SKIP = new TemplateToken(-1, "<skip>");
+
+        // pasted from STParser
+        public const int RBRACK = 17;
+        public const int LBRACK = 16;
+        public const int ELSE = 5;
+        public const int ELLIPSIS = 11;
+        public const int LCURLY = 20;
+        public const int BANG = 10;
+        public const int EQUALS = 12;
+        public const int TEXT = 22;
+        public const int ID = 25;
+        public const int SEMI = 9;
+        public const int LPAREN = 14;
+        public const int IF = 4;
+        public const int ELSEIF = 6;
+        public const int COLON = 13;
+        public const int RPAREN = 15;
+        public const int WS = 27;
+        public const int COMMA = 18;
+        public const int RCURLY = 21;
+        public const int ENDIF = 7;
+        public const int RDELIM = 24;
+        public const int SUPER = 8;
+        public const int DOT = 19;
+        public const int LDELIM = 23;
+        public const int STRING = 26;
+        public const int PIPE = 28;
+        public const int OR = 29;
+        public const int AND = 30;
+        public const int INDENT = 31;
+        public const int NEWLINE = 32;
+
+        char delimiterStartChar = '<';
+        char delimiterStopChar = '>';
+
+        bool scanningInsideExpr = false;
+        internal int subtemplateDepth = 0; // start out *not* in a {...} subtemplate
+
+        ICharStream input;
+        char c;        // current character
+        int startCharIndex;
+        int startLine;
+        int startCharPositionInLine;
+
+        List<IToken> tokens = new List<IToken>();
+
+        public IToken NextToken()
+        {
+            if (tokens.Count > 0)
+            {
+                var result = tokens[0];
+                tokens.RemoveAt(0);
+                return result;
+            }
+            return _nextToken();
+        }
+
+        public TemplateLexer(ANTLRStringStream input)
+            : this(input, '<', '>')
+        {
+        }
+
+        public TemplateLexer(ICharStream input, char delimiterStartChar, char delimiterStopChar)
+        {
+            this.input = input;
+            c = (char)input.LA(1); // prime lookahead
+            this.delimiterStartChar = delimiterStartChar;
+            this.delimiterStopChar = delimiterStopChar;
+        }
+
+        /** Ensure x is next character on the input stream */
+        public void Match(char x)
+        {
+            if (c == x)
+                Consume();
+            else
+                throw new Exception("expecting " + x + "; found " + c);
+        }
+
+        protected void Consume()
+        {
+            input.Consume();
+            c = (char)input.LA(1);
+        }
+
+        public void Emit(IToken token)
+        {
+            tokens.Add(token);
+        }
+
+        public IToken _nextToken()
+        {
+            //System.out.println("nextToken: c="+(char)c+"@"+input.index());
+            while (true)
+            { // lets us avoid recursion when skipping stuff
+                startCharIndex = input.Index;
+                startLine = input.Line;
+                startCharPositionInLine = input.CharPositionInLine;
+
+                if (c == EOF)
+                    return NewToken(EOF_TYPE);
+                IToken t = null;
+                if (scanningInsideExpr)
+                    t = Inside();
+                else
+                    t = Outside();
+                if (t != SKIP)
+                    return t;
+            }
+        }
+
+        protected IToken Outside()
+        {
+            if (input.CharPositionInLine == 0 && (c == ' ' || c == '\t'))
+            {
+                while (c == ' ' || c == '\t')
+                    Consume(); // scarf indent
+                return NewToken(INDENT);
+            }
+            if (c == delimiterStartChar)
+            {
+                Consume();
+                if (c == '!')
+                {
+                    mCOMMENT();
+                    return SKIP;
+                }
+                if (c == '\\')
+                    return ESCAPE(); // <\\> <\uFFFF> <\n> etc...
+                scanningInsideExpr = true;
+                return NewToken(LDELIM);
+            }
+            if (c == '\r')
+            {
+                Consume();
+                Consume();
+                return NewToken(NEWLINE);
+            }
+            if (c == '\n')
+            {
+                Consume();
+                return NewToken(NEWLINE);
+            }
+            if (c == '}' && subtemplateDepth > 0)
+            {
+                scanningInsideExpr = true;
+                subtemplateDepth--;
+                Consume();
+                return NewTokenFromPreviousChar(RCURLY);
+            }
+            return mTEXT();
+        }
+
+        protected IToken Inside()
+        {
+            while (true)
+            {
+                switch (c)
+                {
+                case ' ':
+                case '\t':
+                case '\n':
+                case '\r':
+                    Consume();
+                    continue;
+                case '.':
+                    Consume();
+                    if (input.LA(1) == '.' && input.LA(2) == '.')
+                    {
+                        Consume();
+                        Match('.');
+                        return NewToken(ELLIPSIS);
+                    }
+                    return NewToken(DOT);
+                case ',':
+                    Consume();
+                    return NewToken(COMMA);
+                case ':':
+                    Consume();
+                    return NewToken(COLON);
+                case ';':
+                    Consume();
+                    return NewToken(SEMI);
+                case '(':
+                    Consume();
+                    return NewToken(LPAREN);
+                case ')':
+                    Consume();
+                    return NewToken(RPAREN);
+                case '[':
+                    Consume();
+                    return NewToken(LBRACK);
+                case ']':
+                    Consume();
+                    return NewToken(RBRACK);
+                case '=':
+                    Consume();
+                    return NewToken(EQUALS);
+                case '!':
+                    Consume();
+                    return NewToken(BANG);
+                case '"':
+                    return mSTRING();
+                case '&':
+                    Consume();
+                    Match('&');
+                    return NewToken(AND); // &&
+                case '|':
+                    Consume();
+                    Match('|');
+                    return NewToken(OR); // ||
+                case '{':
+                    return SubTemplate();
+                default:
+                    if (c == delimiterStopChar)
+                    {
+                        Consume();
+                        scanningInsideExpr = false;
+                        return NewToken(RDELIM);
+                    }
+                    if (IsIDStartLetter(c))
+                    {
+                        IToken id = mID();
+                        string name = id.Text;
+                        if (name.Equals("if"))
+                            return NewToken(IF);
+                        else if (name.Equals("endif"))
+                            return NewToken(ENDIF);
+                        else if (name.Equals("else"))
+                            return NewToken(ELSE);
+                        else if (name.Equals("elseif"))
+                            return NewToken(ELSEIF);
+                        else if (name.Equals("super"))
+                            return NewToken(SUPER);
+                        return id;
+                    }
+                    RecognitionException re = new NoViableAltException("", 0, 0, input);
+                    if (c == EOF)
+                    {
+                        throw new TemplateRecognitionException("EOF inside ST expression", re);
+                    }
+                    throw new TemplateRecognitionException("invalid character: " + c, re);
+                }
+            }
+        }
+
+        private IToken SubTemplate()
+        {
+            // look for "{ args ID (',' ID)* '|' ..."
+            subtemplateDepth++;
+            int m = input.Mark();
+            int curlyStartChar = startCharIndex;
+            int curlyLine = startLine;
+            int curlyPos = startCharPositionInLine;
+            List<IToken> argTokens = new List<IToken>();
+            Consume();
+            IToken curly = NewTokenFromPreviousChar(LCURLY);
+            mWS();
+            argTokens.Add(mID());
+            mWS();
+            while (c == ',')
+            {
+                Consume();
+                argTokens.Add(NewTokenFromPreviousChar(COMMA));
+                mWS();
+                argTokens.Add(mID());
+                mWS();
+            }
+            mWS();
+            if (c == '|')
+            {
+                Consume();
+                argTokens.Add(NewTokenFromPreviousChar(PIPE));
+                if (IsWS(c))
+                    Consume(); // ignore a single whitespace after |
+                //System.out.println("matched args: "+argTokens);
+                foreach (IToken t in argTokens)
+                    Emit(t);
+                input.Release(m);
+                scanningInsideExpr = false;
+                startCharIndex = curlyStartChar; // reset state
+                startLine = curlyLine;
+                startCharPositionInLine = curlyPos;
+                return curly;
+            }
+            //System.out.println("no match rewind");
+            input.Rewind(m);
+            startCharIndex = curlyStartChar; // reset state
+            startLine = curlyLine;
+            startCharPositionInLine = curlyPos;
+            Consume();
+            scanningInsideExpr = false;
+            return curly;
+        }
+
+        private IToken ESCAPE()
+        {
+            Consume(); // kill \\
+            IToken t = null;
+            switch (c)
+            {
+            case '\\':
+                mLINEBREAK();
+                return SKIP;
+            case 'n':
+                t = NewToken(TEXT, "\n", input.CharPositionInLine - 2);
+                break;
+            case 't':
+                t = NewToken(TEXT, "\t", input.CharPositionInLine - 2);
+                break;
+            case ' ':
+                t = NewToken(TEXT, " ", input.CharPositionInLine - 2);
+                break;
+            case 'u':
+                t = UNICODE();
+                break;
+            default:
+                Console.Error.WriteLine("bad \\ char");
+                break;
+            }
+            Consume();
+            Match(delimiterStopChar);
+            return t;
+        }
+
+        private IToken UNICODE()
+        {
+            Consume();
+            char[] chars = new char[4];
+            if (!IsUnicodeLetter(c))
+                Console.Error.WriteLine("bad unicode char: " + c);
+            chars[0] = c;
+            Consume();
+            if (!IsUnicodeLetter(c))
+                Console.Error.WriteLine("bad unicode char: " + c);
+            chars[1] = c;
+            Consume();
+            if (!IsUnicodeLetter(c))
+                Console.Error.WriteLine("bad unicode char: " + c);
+            chars[2] = c;
+            Consume();
+            if (!IsUnicodeLetter(c))
+                Console.Error.WriteLine("bad unicode char: " + c);
+            chars[3] = c;
+            // ESCAPE kills final char and >
+            char uc = (char)int.Parse(new string(chars), NumberStyles.HexNumber);
+            return NewToken(TEXT, uc.ToString(), input.CharPositionInLine - 6);
+        }
+
+        private IToken mTEXT()
+        {
+            bool modifiedText = false;
+            StringBuilder buf = new StringBuilder();
+            while (c != EOF && c != delimiterStartChar)
+            {
+                if (c == '\r' || c == '\n')
+                    break;
+                if (c == '}' && subtemplateDepth > 0)
+                    break;
+                if (c == '\\')
+                {
+                    if (input.LA(2) == delimiterStartChar ||
+                         input.LA(2) == '}')
+                    {
+                        modifiedText = true;
+                        Consume(); // toss out \ char
+                        buf.Append(c);
+                        Consume();
+                    }
+                    else
+                    {
+                        Consume();
+                    }
+                    continue;
+                }
+                buf.Append(c);
+                Consume();
+            }
+            if (modifiedText)
+                return NewToken(TEXT, buf.ToString());
+            else
+                return NewToken(TEXT);
+        }
+
+        /** ID  :   ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'0'..'9'|'_'|'/')* ; */
+        private IToken mID()
+        {
+            // called from subTemplate; so keep resetting position during speculation
+            startCharIndex = input.Index;
+            startLine = input.Line;
+            startCharPositionInLine = input.CharPositionInLine;
+            Consume();
+            while (IsIDLetter(c))
+            {
+                Consume();
+            }
+            return NewToken(ID);
+        }
+
+        /** STRING : '"' ( '\\' '"' | '\\' ~'"' | ~('\\'|'"') )* '"' ; */
+        private IToken mSTRING()
+        {
+            //{setText(getText().substring(1, getText().length()-1));}
+            bool sawEscape = false;
+            StringBuilder buf = new StringBuilder();
+            buf.Append(c);
+            Consume();
+            while (c != '"')
+            {
+                if (c == '\\')
+                {
+                    sawEscape = true;
+                    Consume();
+                    switch (c)
+                    {
+                    case 'n':
+                        buf.Append('\n');
+                        break;
+                    case 'r':
+                        buf.Append('\r');
+                        break;
+                    case 't':
+                        buf.Append('\t');
+                        break;
+                    default:
+                        buf.Append(c);
+                        break;
+                    }
+                    Consume();
+                    continue;
+                }
+                buf.Append(c);
+                Consume();
+            }
+            buf.Append(c);
+            Consume();
+            if (sawEscape)
+                return NewToken(STRING, buf.ToString());
+            else
+                return NewToken(STRING);
+        }
+
+        private void mWS()
+        {
+            while (c == ' ' || c == '\t' || c == '\n' || c == '\r')
+                Consume();
+        }
+
+        private void mCOMMENT()
+        {
+            Match('!');
+            while (!(c == '!' && input.LA(2) == delimiterStopChar))
+                Consume();
+            Consume();
+            Consume(); // kill !>
+        }
+
+        private void mLINEBREAK()
+        {
+            Match('\\'); // only kill 2nd \ as outside() kills first one
+            Match(delimiterStopChar);
+            while (c == ' ' || c == '\t')
+                Consume(); // scarf WS after <\\>
+            if (c == '\r')
+                Consume();
+            Match('\n');
+            while (c == ' ' || c == '\t')
+                Consume(); // scarf any indent
+            return;
+        }
+
+        public static bool IsIDStartLetter(char c)
+        {
+            return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z';
+        }
+
+        public static bool IsIDLetter(char c)
+        {
+            return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c >= '0' && c <= '9';
+        }
+
+        public static bool IsWS(char c)
+        {
+            return c == ' ' || c == '\t' || c == '\n' || c == '\r';
+        }
+
+        public static bool IsUnicodeLetter(char c)
+        {
+            return c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F' || c >= '0' && c <= '9';
+        }
+
+        public IToken NewToken(int ttype)
+        {
+            TemplateToken t = new TemplateToken(input, ttype, Lexer.DefaultTokenChannel,
+                    startCharIndex, input.Index - 1);
+            t.Line = startLine;
+            t.CharPositionInLine = startCharPositionInLine;
+            return t;
+        }
+
+        public IToken NewTokenFromPreviousChar(int ttype)
+        {
+            TemplateToken t =
+                new TemplateToken(input, ttype, Lexer.DefaultTokenChannel,
+                    input.Index - 1, input.Index - 1);
+            t.StartIndex = input.Index - 1;
+            t.Line = input.Line;
+            t.CharPositionInLine = input.CharPositionInLine - 1;
+            return t;
+        }
+
+        public IToken NewToken(int ttype, string text, int pos)
+        {
+            TemplateToken t = new TemplateToken(ttype, text);
+            t.Line = input.Line;
+            t.CharPositionInLine = pos;
+            return t;
+        }
+
+        public IToken NewToken(int ttype, string text)
+        {
+            TemplateToken t = new TemplateToken(ttype, text);
+            t.StartIndex = startCharIndex;
+            t.Line = startLine;
+            t.CharPositionInLine = startCharPositionInLine;
+            return t;
+        }
+
+        public string SourceName
+        {
+            get
+            {
+                return "no idea";
+            }
+        }
+
+        public string[] TokenNames
+        {
+            get
+            {
+                return TemplateParser.tokenNames;
+            }
+        }
+    }
+}
diff --git a/StringTemplate4/TemplateLexer.tokens b/StringTemplate4/TemplateLexer.tokens
new file mode 100644
index 0000000..94b924c
--- /dev/null
+++ b/StringTemplate4/TemplateLexer.tokens
@@ -0,0 +1,50 @@
+RBRACK=17
+LBRACK=16
+ELSE=5
+ELLIPSIS=11
+LCURLY=20
+BANG=10
+EQUALS=12
+TEXT=22
+ID=25
+SEMI=9
+LPAREN=14
+IF=4
+ELSEIF=6
+COLON=13
+RPAREN=15
+WS=27
+COMMA=18
+RCURLY=21
+ENDIF=7
+RDELIM=24
+SUPER=8
+DOT=19
+LDELIM=23
+STRING=26
+PIPE=28
+OR=29
+AND=30
+INDENT=31
+NEWLINE=32
+'super'=8
+'|'=28
+'!'=10
+'}'=21
+'else'=5
+'if'=4
+'{'=20
+'...'=11
+'elseif'=6
+';'=9
+'='=12
+':'=13
+'('=14
+'['=16
+','=18
+'.'=19
+'endif'=7
+')'=15
+']'=17
+'||'=29
+'&&'=30
diff --git a/StringTemplate4/TemplateParser.g3 b/StringTemplate4/TemplateParser.g3
new file mode 100644
index 0000000..9d4d0c3
--- /dev/null
+++ b/StringTemplate4/TemplateParser.g3
@@ -0,0 +1,298 @@
+﻿/*
+ [The "BSD licence"]
+ Copyright (c) 2009 Terence Parr
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+    notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+    derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/** Recognize a single StringTemplate template text, expressions, and conditionals */
+parser grammar TemplateParser;
+
+options {
+	language=CSharp3;
+	tokenVocab=TemplateLexer;
+}
+
+@namespace{StringTemplate}
+
+@rulecatch {
+   catch (RecognitionException) { throw; }
+}
+
+public
+templateAndEOF
+	:	template EOF
+	;
+
+public
+template
+	:	(	options {backtrack=true; k=2;}
+		:	i=INDENT         {Indent($i.text);}
+			ifOnOneLine      {gen.Emit(Bytecode.INSTR_DEDENT);}
+		|	i=INDENT {PushIFIndentation($i.text);} ifOnMultiLines {PopIFIndentation();}
+		|	ifOnMultiLines
+		|	i=INDENT       	 {Indent($i.text);}
+			exprTag          {gen.Emit(Bytecode.INSTR_DEDENT);}
+		|	exprTag
+		|	i=INDENT         {Indent($i.text);}
+			text             {gen.Emit(Bytecode.INSTR_DEDENT);}
+		|	text
+		|	i=INDENT         {Indent($i.text);}
+		 	NEWLINE          {gen.Emit(Bytecode.INSTR_NEWLINE);}
+		 	                 {gen.Emit(Bytecode.INSTR_DEDENT);}
+		|	NEWLINE          {gen.Emit(Bytecode.INSTR_NEWLINE);}
+		)*
+	;
+
+text
+	:	TEXT
+		{
+		if ( $TEXT.text.Length>0 ) {
+			gen.Emit(Bytecode.INSTR_LOAD_STR, $TEXT.text);
+			gen.Emit(Bytecode.INSTR_WRITE);
+		}
+		}
+	;
+
+exprTag
+	:	LDELIM expr
+		(	';' exprOptions {gen.Emit(Bytecode.INSTR_WRITE_OPT);}
+		|	                {gen.Emit(Bytecode.INSTR_WRITE);}
+		)
+		RDELIM
+	;
+
+subtemplate returns [string name]
+	:	'{' ( ids+=ID (',' ids+=ID)* '|' )?
+		{{ // force exec even when backtracking
+		$name = gen.CompileAnonTemplate(input, $ids, state);
+        }}
+        '}'
+    ;
+
+/** The (...)* loop in rule template doesn't think '}' can follow it because
+ *  we call template in an action (via compileAnonTemplate).  To avoid
+ *  syntax errors upon '}' in rule templatee, we force '}' into FOLLOW set.
+ *  I hope to make ANTLR ignore FOLLOW set for (...)* in future.
+ */
+addRcurlyToFollowOfTemplateRule : template '}' ;
+
+ifOnMultiLines
+@init {
+    /** Tracks address of branch operand (in code block).  It's how
+     *  we backpatch forward references when generating code for IFs.
+     */
+    int prevBranchOperand = -1;
+    /** Branch instruction operands that are forward refs to end of IF.
+     *  We need to update them once we see the endif.
+     */
+    List<int> endRefs = new List<int>();
+}
+	:	LDELIM 'if' '(' conditional ')' RDELIM
+		{
+        prevBranchOperand = gen.Address()+1;
+        gen.Emit(Bytecode.INSTR_BRF, -1); // write placeholder as branch target
+		}
+		template
+		(	INDENT? LDELIM 'elseif'
+			{
+			endRefs.Add(gen.Address()+1);
+			gen.Emit(Bytecode.INSTR_BR, -1); // br end
+			// update previous branch instruction
+			gen.Write(prevBranchOperand, (short)gen.Address());
+			prevBranchOperand = -1;
+			}
+			'(' conditional ')' RDELIM
+			{
+        	prevBranchOperand = gen.Address()+1;
+        	gen.Emit(Bytecode.INSTR_BRF, -1); // write placeholder as branch target
+			}
+			template
+		)*
+		(	INDENT? LDELIM 'else' RDELIM
+			{
+			endRefs.Add(gen.Address()+1);
+			gen.Emit(Bytecode.INSTR_BR, -1); // br end
+			// update previous branch instruction
+			gen.Write(prevBranchOperand, (short)gen.Address());
+			prevBranchOperand = -1;
+			}
+			template
+		)?
+		INDENT? endif=LDELIM 'endif' RDELIM
+		( {true}? NEWLINE )? // kill \on for <endif> on line by itself
+		{
+		if ( prevBranchOperand>=0 ) {
+			gen.Write(prevBranchOperand, (short)gen.Address());
+		}
+        foreach (int opnd in endRefs) gen.Write(opnd, (short)gen.Address());
+		}
+	;
+
+// TODO: code dup but need to call elementsForIfOnOneLine not template inside :(
+ifOnOneLine
+@init {
+    /** Tracks address of branch operand (in code block).  It's how
+     *  we backpatch forward references when generating code for IFs.
+     */
+    int prevBranchOperand = -1;
+    /** Branch instruction operands that are forward refs to end of IF.
+     *  We need to update them once we see the endif.
+     */
+    List<int> endRefs = new List<int>();
+}
+	:	LDELIM 'if' '(' conditional ')' RDELIM
+		{
+        prevBranchOperand = gen.Address()+1;
+        gen.Emit(Bytecode.INSTR_BRF, -1); // write placeholder as branch target
+		}
+		elementsForIfOnOneLine*
+		(	LDELIM 'elseif'
+			{
+			endRefs.Add(gen.Address()+1);
+			gen.Emit(Bytecode.INSTR_BR, -1); // br end
+			// update previous branch instruction
+			gen.Write(prevBranchOperand, (short)gen.Address());
+			prevBranchOperand = -1;
+			}
+			'(' conditional ')' RDELIM
+			{
+        	prevBranchOperand = gen.Address()+1;
+        	gen.Emit(Bytecode.INSTR_BRF, -1); // write placeholder as branch target
+			}
+			elementsForIfOnOneLine*
+		)*
+		(	LDELIM 'else' RDELIM
+			{
+			endRefs.Add(gen.Address()+1);
+			gen.Emit(Bytecode.INSTR_BR, -1); // br end
+			// update previous branch instruction
+			gen.Write(prevBranchOperand, (short)gen.Address());
+			prevBranchOperand = -1;
+			}
+			elementsForIfOnOneLine*
+		)?
+		endif=LDELIM 'endif' RDELIM
+		{
+		if ( prevBranchOperand>=0 ) {
+			gen.Write(prevBranchOperand, (short)gen.Address());
+		}
+        foreach (int opnd in endRefs) gen.Write(opnd, (short)gen.Address());
+		}
+	;
+
+elementsForIfOnOneLine
+	:	exprTag
+	|	text
+	|	ifOnOneLine
+	;
+
+conditional
+	:	andConditional ('||' andConditional {gen.Emit(Bytecode.INSTR_OR);})*
+	;
+
+andConditional
+	:	notConditional ('&&' notConditional {gen.Emit(Bytecode.INSTR_AND);})*
+	;
+
+notConditional
+	:	'!' primary  {gen.Emit(Bytecode.INSTR_NOT);}
+	|	primary
+	;
+
+exprOptions
+	:	{gen.Emit(Bytecode.INSTR_OPTIONS);} option (',' option)*
+	;
+
+option
+	:	ID ( '=' exprNoComma | {DefaultOption($ID);} )
+		{SetOption($ID);}
+	;
+
+exprNoComma
+	:	memberExpr ( ':' templateRef {gen.Emit(Bytecode.INSTR_MAP);} )?
+	|	subtemplate {gen.Emit(Bytecode.INSTR_NEW, $subtemplate.name);}
+	;
+
+expr : mapExpr ;
+
+mapExpr
+@init {int nt=1, ne=1;}
+	:	memberExpr (c=',' memberExpr {ne++;} )*
+		(	':' templateRef
+			(	(',' templateRef {nt++;})+  {gen.Emit(Bytecode.INSTR_ROT_MAP, nt);}
+			|	{if ( $c!=null ) gen.Emit(Bytecode.INSTR_PAR_MAP, ne);
+				 else gen.Emit(Bytecode.INSTR_MAP);}
+			)
+		)*
+	;
+
+memberExpr
+	:	callExpr
+		(	'.' ID {gen.Emit(Bytecode.INSTR_LOAD_PROP, $ID.text);}
+		|	'.' '(' mapExpr ')' {gen.Emit(Bytecode.INSTR_LOAD_PROP_IND);}
+		)*
+	;
+
+callExpr
+options {k=2;} // prevent full LL(*) which fails, falling back on k=1; need k=2
+	:	{Compiler.funcs.ContainsKey(input.LT(1).Text)}?
+		ID '(' expr ')' {Func($ID);}
+	|	ID {gen.Emit(Bytecode.INSTR_NEW, $ID.text);} '(' args? ')'
+	|	primary
+	;
+
+primary
+	:	'super'
+	|	o=ID	  {RefAttr($o);}
+/*		(	'.' p=ID {gen.Emit(Bytecode.INSTR_LOAD_PROP, $p.text);}
+		|	'.' '(' mapExpr ')' {gen.Emit(Bytecode.INSTR_LOAD_PROP_IND);}
+		)*
+		*/
+	|	STRING    {gen.Emit(Bytecode.INSTR_LOAD_STR, Strip($STRING.text,1));}
+	|	list
+	|	'(' expr ')' {gen.Emit(Bytecode.INSTR_TOSTR);}
+		( {gen.Emit(Bytecode.INSTR_NEW_IND);} '(' args? ')' )? // indirect call
+	;
+
+args:	arg (',' arg)* ;
+
+arg :	ID '=' exprNoComma {gen.Emit(Bytecode.INSTR_STORE_ATTR, $ID.text);}
+	|	exprNoComma        {gen.Emit(Bytecode.INSTR_STORE_SOLE_ARG);}
+	|	elip='...'		   {gen.Emit(Bytecode.INSTR_SET_PASS_THRU);}
+	;
+
+templateRef
+	:	ID			{gen.Emit(Bytecode.INSTR_LOAD_STR, $ID.text);}
+	|	subtemplate {gen.Emit(Bytecode.INSTR_LOAD_STR, $subtemplate.name);}
+	|	'(' mapExpr ')' {gen.Emit(Bytecode.INSTR_TOSTR);}
+	;
+
+list:	{gen.Emit(Bytecode.INSTR_LIST);} '[' listElement (',' listElement)* ']'
+	|	{gen.Emit(Bytecode.INSTR_LIST);} '[' ']'
+	;
+
+listElement
+    :   exprNoComma {gen.Emit(Bytecode.INSTR_ADD);}
+    ;
diff --git a/StringTemplate4/TemplateParserHelper.cs b/StringTemplate4/TemplateParserHelper.cs
new file mode 100644
index 0000000..2990a8d
--- /dev/null
+++ b/StringTemplate4/TemplateParserHelper.cs
@@ -0,0 +1,173 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    using System.Collections.Generic;
+    using Antlr.Runtime;
+    using Console = System.Console;
+    using IList = System.Collections.IList;
+
+    partial class TemplateParser
+    {
+        List<string> IFindents = new List<string>();
+
+        ICodeGenerator gen = new CodeGenerator();
+
+        public TemplateParser(ITokenStream input, ICodeGenerator gen)
+            : this(input, new RecognizerSharedState(), gen)
+        {
+        }
+
+        public TemplateParser(ITokenStream input, RecognizerSharedState state, ICodeGenerator gen)
+            : base(null, null) // overcome bug in ANTLR 3.2
+        {
+            this.input = input;
+            this.state = state;
+            if (gen != null)
+                this.gen = gen;
+        }
+        protected override object RecoverFromMismatchedToken(IIntStream input, int ttype, BitSet follow)
+        {
+            throw new MismatchedTokenException(ttype, input);
+        }
+
+        public static string Strip(string s, int n)
+        {
+            return s.Substring(n, s.Length - 2 * n);
+        }
+
+        public void RefAttr(IToken id)
+        {
+            string name = id.Text;
+            if (Interpreter.predefinedAttributes.Contains(name))
+            {
+                gen.Emit(Bytecode.INSTR_LOAD_LOCAL, name);
+            }
+            else
+            {
+                gen.Emit(Bytecode.INSTR_LOAD_ATTR, name);
+            }
+        }
+
+        public void SetOption(IToken id)
+        {
+            int i;
+            if (!Compiler.supportedOptions.TryGetValue(id.Text, out i))
+            {
+                Console.Error.WriteLine("no such option: " + id.Text);
+                return;
+            }
+
+            gen.Emit(Bytecode.INSTR_STORE_OPTION, i);
+        }
+
+        public void DefaultOption(IToken id)
+        {
+            string v;
+            if (!Compiler.defaultOptionValues.TryGetValue(id.Text, out v))
+            {
+                Console.Error.WriteLine("no def value for " + id.Text);
+                return;
+            }
+
+            gen.Emit(Bytecode.INSTR_LOAD_STR, v);
+        }
+
+        public void Func(IToken id)
+        {
+            short funcBytecode;
+            if (!Compiler.funcs.TryGetValue(id.Text, out funcBytecode))
+            {
+                Console.Error.WriteLine("no such fun: " + id);
+                gen.Emit(Bytecode.INSTR_NOOP);
+                return;
+            }
+
+            gen.Emit(funcBytecode);
+        }
+
+        public void PushIFIndentation(string indent)
+        {
+            IFindents.Add(indent);
+        }
+
+        public string PopIFIndentation()
+        {
+            var result = IFindents[IFindents.Count - 1];
+            IFindents.RemoveAt(IFindents.Count - 1);
+            return result;
+        }
+
+        public void Indent(string indent)
+        {
+            /*
+                    if ( IFindents.size()>0 ) {
+                        String ifIndent = IFindents.get(IFindents.size()-1);
+                        if ( indent.startsWith(ifIndent) ) indent = indent.substring(ifIndent.length());
+                    }
+                    */
+            gen.Emit(Bytecode.INSTR_INDENT, indent);
+        }
+
+        private sealed class CodeGenerator : ICodeGenerator
+        {
+            public void Emit(short opcode)
+            {
+            }
+
+            public void Emit(short opcode, int arg)
+            {
+            }
+
+            public void Emit(short opcode, string s)
+            {
+            }
+
+            public void Write(int addr, short value)
+            {
+            }
+
+            public int Address()
+            {
+                return 0;
+            }
+
+            public string CompileAnonTemplate(ITokenStream input, IList ids, RecognizerSharedState state)
+            {
+                Compiler c = new Compiler();
+                c.Compile(input, state);
+                return null;
+            }
+        }
+    }
+}
diff --git a/StringTemplate4/TemplateRecognitionException.cs b/StringTemplate4/TemplateRecognitionException.cs
new file mode 100644
index 0000000..4fc3043
--- /dev/null
+++ b/StringTemplate4/TemplateRecognitionException.cs
@@ -0,0 +1,44 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    using Antlr.Runtime;
+
+    public class TemplateRecognitionException : TemplateException
+    {
+        public TemplateRecognitionException(string message, RecognitionException cause)
+            : base(message, cause)
+        {
+        }
+    }
+}

