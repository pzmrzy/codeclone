commit f4e0ba8ba680b8c5035d5bf3ed005c522cbbf8c2
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Sun Dec 13 19:46:43 2009 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Sun Dec 13 19:46:43 2009 -0800

C# Port:
* Merge CL6384

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 6496]

diff --git a/Antlr3.Test/Antlr3.Test.csproj b/Antlr3.Test/Antlr3.Test.csproj
index 8b4fe85..011d358 100644
--- a/Antlr3.Test/Antlr3.Test.csproj
+++ b/Antlr3.Test/Antlr3.Test.csproj
@@ -58,6 +58,7 @@
<Compile Include="ST4\TestIndentation.cs" />
<Compile Include="ST4\TestIndirectionAndEarlyEvaluation.cs" />
<Compile Include="ST4\TestLexer.cs" />
+    <Compile Include="ST4\TestLineWrap.cs" />
<Compile Include="ST4\TestLists.cs" />
<Compile Include="ST4\TestNullAndEmptyValues.cs" />
<Compile Include="ST4\TestOptions.cs" />
diff --git a/Antlr3.Test/ST4/TestLineWrap.cs b/Antlr3.Test/ST4/TestLineWrap.cs
new file mode 100644
index 0000000..440d051
--- /dev/null
+++ b/Antlr3.Test/ST4/TestLineWrap.cs
@@ -0,0 +1,440 @@
+ï»¿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace AntlrUnitTests.ST4
+{
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using ArrayList = System.Collections.ArrayList;
+    using ST = StringTemplate.Template;
+    using STErrorListener = StringTemplate.ITemplateErrorListener;
+    using STGroup = StringTemplate.TemplateGroup;
+    using STGroupFile = StringTemplate.TemplateGroupFile;
+    using String = System.String;
+    using StringTemplate;
+    using StringWriter = System.IO.StringWriter;
+    using Path = System.IO.Path;
+
+    [TestClass]
+    public class TestLineWrap : StringTemplateTestBase
+    {
+        [TestMethod]
+        public void TestLineWrap1()
+        {
+            String templates =
+                "array(values) ::= <<int[] a = { <values; wrap=\"\\n\", separator=\",\"> };>>" + newline;
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            ST a = group.GetInstanceOf("array");
+            a.Add("values",
+                           new int[] {3,9,20,2,1,4,6,32,5,6,77,888,2,1,6,32,5,6,77,
+						4,9,20,2,1,4,63,9,20,2,1,4,6,32,5,6,77,6,32,5,6,77,
+					    3,9,20,2,1,4,6,32,5,6,77,888,1,6,32,5});
+            String expecting =
+                "int[] a = { 3,9,20,2,1,4,6,32,5,6,77,888,\n" +
+                "2,1,6,32,5,6,77,4,9,20,2,1,4,63,9,20,2,1,\n" +
+                "4,6,32,5,6,77,6,32,5,6,77,3,9,20,2,1,4,6,\n" +
+                "32,5,6,77,888,1,6,32,5 };";
+            Assert.AreEqual(expecting, a.Render(40));
+        }
+
+        [TestMethod]
+        public void TestLineWrapWithNormalizedNewlines()
+        {
+            String templates =
+                    "array(values) ::= <<int[] a = { <values; wrap=\"\\r\\n\", separator=\",\"> };>>" + newline;
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+
+            ST a = group.GetInstanceOf("array");
+            a.Add("values",
+                           new int[] {3,9,20,2,1,4,6,32,5,6,77,888,2,1,6,32,5,6,77,
+						4,9,20,2,1,4,63,9,20,2,1,4,6,32,5,6,77,6,32,5,6,77,
+					    3,9,20,2,1,4,6,32,5,6,77,888,1,6,32,5});
+            String expecting =
+                "int[] a = { 3,9,20,2,1,4,6,32,5,6,77,888,\n" + // wrap is \r\n, normalize to \n
+                "2,1,6,32,5,6,77,4,9,20,2,1,4,63,9,20,2,1,\n" +
+                "4,6,32,5,6,77,6,32,5,6,77,3,9,20,2,1,4,6,\n" +
+                "32,5,6,77,888,1,6,32,5 };";
+
+            StringWriter sw = new StringWriter();
+            ITemplateWriter stw = new AutoIndentWriter(sw, "\n"); // force \n as newline
+            stw.SetLineWidth(40);
+            a.Write(stw);
+            String result = sw.ToString();
+            Assert.AreEqual(expecting, result);
+        }
+
+        [TestMethod]
+        public void TestLineWrapAnchored()
+        {
+            String templates =
+                    "array(values) ::= <<int[] a = { <values; anchor, wrap=\"\\n\", separator=\",\"> };>>" + newline;
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+
+            ST a = group.GetInstanceOf("array");
+            a.Add("values",
+                           new int[] {3,9,20,2,1,4,6,32,5,6,77,888,2,1,6,32,5,6,77,
+						4,9,20,2,1,4,63,9,20,2,1,4,6,32,5,6,77,6,32,5,6,77,
+					    3,9,20,2,1,4,6,32,5,6,77,888,1,6,32,5});
+            String expecting =
+                "int[] a = { 3,9,20,2,1,4,6,32,5,6,77,888," + newline +
+                "            2,1,6,32,5,6,77,4,9,20,2,1,4," + newline +
+                "            63,9,20,2,1,4,6,32,5,6,77,6," + newline +
+                "            32,5,6,77,3,9,20,2,1,4,6,32," + newline +
+                "            5,6,77,888,1,6,32,5 };";
+            Assert.AreEqual(expecting, a.Render(40));
+        }
+
+        [TestMethod]
+        public void TestSubtemplatesAnchorToo()
+        {
+            String templates =
+                    "array(values) ::= <<{ <values; anchor, separator=\", \"> }>>" + newline;
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+
+            ST x = new ST(group, "<\\n>{ <stuff; anchor, separator=\",\\n\"> }<\\n>");
+            x.Add("stuff", "1");
+            x.Add("stuff", "2");
+            x.Add("stuff", "3");
+            ST a = group.GetInstanceOf("array");
+            a.Add("values", new ArrayList() { "a", x, "b" });
+            String expecting =
+                "{ a, \n" +
+                "  { 1,\n" +
+                "    2,\n" +
+                "    3 }\n" +
+                "  , b }";
+            Assert.AreEqual(expecting, a.Render(40));
+        }
+
+        [TestMethod]
+        public void TestFortranLineWrap()
+        {
+            String templates =
+                    "func(args) ::= <<       FUNCTION line( <args; wrap=\"\\n      c\", separator=\",\"> )>>" + newline;
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST a = group.GetInstanceOf("func");
+            a.Add("args",
+                           new String[] { "a", "b", "c", "d", "e", "f" });
+            String expecting =
+                "       FUNCTION line( a,b,c,d,\n" +
+                "      ce,f )";
+            Assert.AreEqual(expecting, a.Render(30));
+        }
+
+        [TestMethod]
+        public void TestLineWrapWithDiffAnchor()
+        {
+            String templates =
+                    "array(values) ::= <<int[] a = { <{1,9,2,<values; wrap, separator=\",\">}; anchor> };>>" + newline;
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST a = group.GetInstanceOf("array");
+            a.Add("values",
+                           new int[] {3,9,20,2,1,4,6,32,5,6,77,888,2,1,6,32,5,6,77,
+						4,9,20,2,1,4,63,9,20,2,1,4,6});
+            String expecting =
+                "int[] a = { 1,9,2,3,9,20,2,1,4,\n" +
+                "            6,32,5,6,77,888,2,\n" +
+                "            1,6,32,5,6,77,4,9,\n" +
+                "            20,2,1,4,63,9,20,2,\n" +
+                "            1,4,6 };";
+            Assert.AreEqual(expecting, a.Render(30));
+        }
+
+        [TestMethod]
+        public void TestLineWrapEdgeCase()
+        {
+            String templates =
+                    "duh(chars) ::= <<<chars; wrap=\"\\n\"\\>>>" + newline;
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST a = group.GetInstanceOf("duh");
+            a.Add("chars", new String[] { "a", "b", "c", "d", "e" });
+            // lineWidth==3 implies that we can have 3 characters at most
+            String expecting =
+                "abc\n" +
+                "de";
+            Assert.AreEqual(expecting, a.Render(3));
+        }
+
+        [TestMethod]
+        public void TestLineWrapLastCharIsNewline()
+        {
+            String templates =
+                    "duh(chars) ::= <<<chars; wrap=\"\\n\"\\>>>" + newline;
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+
+            ST a = group.GetInstanceOf("duh");
+            a.Add("chars", new String[] { "a", "b", "\n", "d", "e" });
+            // don't do \n if it's last element anyway
+            String expecting =
+                "ab\n" +
+                "de";
+            Assert.AreEqual(expecting, a.Render(3));
+        }
+
+        [TestMethod]
+        public void TestLineWrapCharAfterWrapIsNewline()
+        {
+            String templates =
+                    "duh(chars) ::= <<<chars; wrap=\"\\n\"\\>>>" + newline;
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST a = group.GetInstanceOf("duh");
+            a.Add("chars", new String[] { "a", "b", "c", "\n", "d", "e" });
+            // Once we wrap, we must dump chars as we see them.  A newline right
+            // after a wrap is just an "unfortunate" event.  People will expect
+            // a newline if it's in the data.
+            String expecting =
+                "abc\n" +
+                "\n" +
+                "de";
+            Assert.AreEqual(expecting, a.Render(3));
+        }
+
+        [TestMethod]
+        public void TestLineWrapForAnonTemplate()
+        {
+            String templates =
+                    "duh(data) ::= <<!<data:{v|[<v>]}; wrap>!>>" + newline;
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST a = group.GetInstanceOf("duh");
+            a.Add("data", new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 });
+            String expecting =
+                "![1][2][3]\n" + // width=9 is the 3 char; don't break til after ]
+                "[4][5][6]\n" +
+                "[7][8][9]!";
+            Assert.AreEqual(expecting, a.Render(9));
+        }
+
+        [TestMethod]
+        public void TestLineWrapForAnonTemplateAnchored()
+        {
+            String templates =
+                    "duh(data) ::= <<!<data:{v|[<v>]}; anchor, wrap>!>>" + newline;
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST a = group.GetInstanceOf("duh");
+            a.Add("data", new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 });
+            String expecting =
+                "![1][2][3]\n" +
+                " [4][5][6]\n" +
+                " [7][8][9]!";
+            Assert.AreEqual(expecting, a.Render(9));
+        }
+
+        [TestMethod]
+        public void TestLineWrapForAnonTemplateComplicatedWrap()
+        {
+            String templates =
+                    "top(s) ::= <<  <s>.>>" +
+                    "str(data) ::= <<!<data:{v|[<v>]}; wrap=\"!+\\n!\">!>>" + newline;
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST t = group.GetInstanceOf("top");
+            ST s = group.GetInstanceOf("str");
+            s.Add("data", new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 });
+            t.Add("s", s);
+            String expecting =
+                "  ![1][2]!+\n" +
+                "  ![3][4]!+\n" +
+                "  ![5][6]!+\n" +
+                "  ![7][8]!+\n" +
+                "  ![9]!.";
+            Assert.AreEqual(expecting, t.Render(9));
+        }
+
+        [TestMethod]
+        public void TestIndentBeyondLineWidth()
+        {
+            String templates =
+                    "duh(chars) ::= <<    <chars; wrap=\"\\n\"\\>>>" + newline;
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST a = group.GetInstanceOf("duh");
+            a.Add("chars", new String[] { "a", "b", "c", "d", "e" });
+            //
+            String expecting =
+                "    a\n" +
+                "    b\n" +
+                "    c\n" +
+                "    d\n" +
+                "    e";
+            Assert.AreEqual(expecting, a.Render(2));
+        }
+
+        [TestMethod]
+        public void TestIndentedExpr()
+        {
+            String templates =
+                    "duh(chars) ::= <<    <chars; wrap=\"\\n\"\\>>>" + newline;
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST a = group.GetInstanceOf("duh");
+            a.Add("chars", new String[] { "a", "b", "c", "d", "e" });
+            //
+            String expecting =
+                "    ab\n" +
+                "    cd\n" +
+                "    e";
+            // width=4 spaces + 2 char.
+            Assert.AreEqual(expecting, a.Render(6));
+        }
+
+        [TestMethod]
+        public void TestNestedIndentedExpr()
+        {
+            String templates =
+                    "top(d) ::= <<  <d>!>>" + newline +
+                    "duh(chars) ::= <<  <chars; wrap=\"\\n\"\\>>>" + newline;
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST top = group.GetInstanceOf("top");
+            ST duh = group.GetInstanceOf("duh");
+            duh.Add("chars", new String[] { "a", "b", "c", "d", "e" });
+            top.Add("d", duh);
+            String expecting =
+                "    ab\n" +
+                "    cd\n" +
+                "    e!";
+            // width=4 spaces + 2 char.
+            Assert.AreEqual(expecting, top.Render(6));
+        }
+
+        [TestMethod]
+        public void TestNestedWithIndentAndTrackStartOfExpr()
+        {
+            String templates =
+                    "top(d) ::= <<  <d>!>>" + newline +
+                    "duh(chars) ::= <<x: <chars; anchor, wrap=\"\\n\"\\>>>" + newline;
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST top = group.GetInstanceOf("top");
+            ST duh = group.GetInstanceOf("duh");
+            duh.Add("chars", new String[] { "a", "b", "c", "d", "e" });
+            top.Add("d", duh);
+            //
+            String expecting =
+                "  x: ab\n" +
+                "     cd\n" +
+                "     e!";
+            Assert.AreEqual(expecting, top.Render(7));
+        }
+
+        [TestMethod]
+        public void TestLineDoesNotWrapDueToLiteral()
+        {
+            String templates =
+                    "m(args,body) ::= <<[TestMethod] public voidfoo(<args; wrap=\"\\n\",separator=\", \">) throws Ick { <body> }>>" + newline;
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST a = group.GetInstanceOf("m");
+            a.Add("args",
+                           new String[] { "a", "b", "c" });
+            a.Add("body", "i=3;");
+            // make it wrap because of ") throws Ick { " literal
+            int n = "[TestMethod] public voidfoo(a, b, c".Length;
+            String expecting =
+                "[TestMethod] public voidfoo(a, b, c) throws Ick { i=3; }";
+            Assert.AreEqual(expecting, a.Render(n));
+        }
+
+        [TestMethod]
+        public void TestSingleValueWrap()
+        {
+            String templates =
+                    "m(args,body) ::= <<{ <body; anchor, wrap=\"\\n\"> }>>" + newline;
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST m = group.GetInstanceOf("m");
+            m.Add("body", "i=3;");
+            // make it wrap because of ") throws Ick { " literal
+            String expecting =
+                "{ \n" +
+                "  i=3; }";
+            Assert.AreEqual(expecting, m.Render(2));
+        }
+
+        [TestMethod]
+        public void TestLineWrapInNestedExpr()
+        {
+            String templates =
+                    "top(arrays) ::= <<Arrays: <arrays>done>>" + newline +
+                    "array(values) ::= <<int[] a = { <values; anchor, wrap=\"\\n\", separator=\",\"> };<\\n\\>>>" + newline;
+            WriteFile(tmpdir, "t.stg", templates);
+            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+
+            ST top = group.GetInstanceOf("top");
+            ST a = group.GetInstanceOf("array");
+            a.Add("values",
+                           new int[] {3,9,20,2,1,4,6,32,5,6,77,888,2,1,6,32,5,6,77,
+						4,9,20,2,1,4,63,9,20,2,1,4,6,32,5,6,77,6,32,5,6,77,
+					    3,9,20,2,1,4,6,32,5,6,77,888,1,6,32,5});
+            top.Add("arrays", a);
+            top.Add("arrays", a); // add twice
+            String expecting =
+                "Arrays: int[] a = { 3,9,20,2,1,4,6,32,5,\n" +
+                "                    6,77,888,2,1,6,32,5,\n" +
+                "                    6,77,4,9,20,2,1,4,63,\n" +
+                "                    9,20,2,1,4,6,32,5,6,\n" +
+                "                    77,6,32,5,6,77,3,9,20,\n" +
+                "                    2,1,4,6,32,5,6,77,888,\n" +
+                "                    1,6,32,5 };\n" +
+                "int[] a = { 3,9,20,2,1,4,6,32,5,6,77,888,\n" +
+                "            2,1,6,32,5,6,77,4,9,20,2,1,4,\n" +
+                "            63,9,20,2,1,4,6,32,5,6,77,6,\n" +
+                "            32,5,6,77,3,9,20,2,1,4,6,32,\n" +
+                "            5,6,77,888,1,6,32,5 };\n" +
+                "done";
+            Assert.AreEqual(expecting, top.Render(40));
+        }
+    }
+}
diff --git a/Antlr3.vsmdi b/Antlr3.vsmdi
index 73da0ff..f53af8b 100644
--- a/Antlr3.vsmdi
+++ b/Antlr3.vsmdi
@@ -1037,6 +1037,29 @@
<TestLink id="517581cb-2d7c-9911-403a-b8008c1fdb67" name="TestWeirdChar" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
</TestLinks>
</TestList>
+  <TestList name="Line Wrap" id="bb81620e-c56b-4ba8-901d-b75ab7c68b72" parentListId="4adbb104-d28d-4362-8420-a9fefe69c167">
+    <TestLinks>
+      <TestLink id="e18cc28d-4848-e703-e336-a2d092917d6c" name="TestIndentBeyondLineWidth" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a1b7c889-b134-4d2a-28a1-9b54c9552552" name="TestSingleValueWrap" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="d14ff063-802b-7489-3f7b-585c80c7bcc8" name="TestLineWrap1" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="cf9e0749-3899-20ce-c16b-c3c2360e0e27" name="TestLineWrapEdgeCase" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="64a9a02a-9f78-9cf6-4fd9-fa75081c3b6e" name="TestIndentedExpr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="a1c58c30-c523-5625-a58c-5e81763444af" name="TestLineWrapForAnonTemplateComplicatedWrap" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="9046797f-9d16-640f-82e5-8f24932b072e" name="TestLineWrapCharAfterWrapIsNewline" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="91d3d3a2-40eb-82c9-d38d-e38df56ff995" name="TestNestedIndentedExpr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="0ad09272-bc99-b656-55a0-ace572c20bdb" name="TestLineWrapLastCharIsNewline" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="71b3ac14-27de-a832-967f-448176c3df33" name="TestLineWrapInNestedExpr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="f89f2b27-5959-f27c-a9d1-b88883b08eeb" name="TestLineWrapWithDiffAnchor" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c89bc4c1-1e46-eae1-834b-e67db9f096b9" name="TestSubtemplatesAnchorToo" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="8b609b90-d3a1-d42a-6e66-7eb2fab5cfc1" name="TestLineDoesNotWrapDueToLiteral" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="3623795b-5fcd-25fa-8660-34143166eb65" name="TestFortranLineWrap" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="c9f4ee1b-26ab-bf37-330f-9e5c834efdef" name="TestLineWrapWithNormalizedNewlines" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="1e52c0fa-0f76-c04a-28aa-770e37cc5839" name="TestNestedWithIndentAndTrackStartOfExpr" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="71fcdb5d-4d1a-1fdf-5db1-f9ad732c5f82" name="TestLineWrapAnchored" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="aaadba17-2b86-96f4-edfb-227174742980" name="TestLineWrapForAnonTemplateAnchored" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+      <TestLink id="7139a7b3-cdda-7a94-0bef-acf1ce7b7698" name="TestLineWrapForAnonTemplate" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
+    </TestLinks>
+  </TestList>
<TestList name="Subtemplates" id="c068d150-8506-4339-a463-a78bf2ce4e9e" parentListId="4adbb104-d28d-4362-8420-a9fefe69c167">
<TestLinks>
<TestLink id="fe2e15cd-0628-da35-0597-0bba9a39812b" name="TestSimpleIterationWithArg" storage="antlr3.test\bin\debug\antlrunittests.dll" type="Microsoft.VisualStudio.TestTools.TestTypes.Unit.UnitTestElement, Microsoft.VisualStudio.QualityTools.Tips.UnitTest.ObjectModel,   PublicKeyToken=b03f5f7f11d50a3a" />
diff --git a/StringTemplate4/BlankTemplate.cs b/StringTemplate4/BlankTemplate.cs
index 50a7c1d..90ded38 100644
--- a/StringTemplate4/BlankTemplate.cs
+++ b/StringTemplate4/BlankTemplate.cs
@@ -69,7 +69,7 @@ namespace StringTemplate
return 0;
}

-        public override string Render(CultureInfo culture)
+        public override string Render(CultureInfo culture, int lineWidth)
{
return string.Empty;
}
diff --git a/StringTemplate4/Interpreter.cs b/StringTemplate4/Interpreter.cs
index d2a6d7a..067db24 100644
--- a/StringTemplate4/Interpreter.cs
+++ b/StringTemplate4/Interpreter.cs
@@ -393,24 +393,49 @@ namespace StringTemplate
return 0;
}
}
+
+            if (options != null && options[OPTION_ANCHOR] != null)
+                @out.PushAnchorPoint();
+
+            @out.PushIndentation(null);
+
if (o is Template)
{
((Template)o).enclosingInstance = self;
+                if (options != null && options[OPTION_WRAP] != null)
+                {
+                    // if we have a wrap string, then inform writer it might need to wrap
+                    try
+                    {
+                        @out.WriteWrapSeparator(options[OPTION_WRAP]);
+                    }
+                    catch (IOException)
+                    {
+                        group.listener.Error("Can't write wrap string");
+                    }
+                }
n = Exec(@out, (Template)o);
-                return n;
-            }
-            o = ConvertAnythingIteratableToIterator(o); // normalize
-            try
-            {
-                if (o is Iterator)
-                    n = WriteIterator(@out, self, o, options);
-                else
-                    n = WritePlainObject(@out, o, options);
}
-            catch (IOException)
+            else
{
-                Console.Error.WriteLine("can't write " + o);
+                o = ConvertAnythingIteratableToIterator(o); // normalize
+                try
+                {
+                    if (o is Iterator)
+                        n = WriteIterator(@out, self, o, options);
+                    else
+                        n = WritePlainObject(@out, o, options);
+                }
+                catch (IOException)
+                {
+                    Console.Error.WriteLine("can't write " + o);
+                }
}
+
+            if (options != null && options[OPTION_ANCHOR] != null)
+                @out.PopAnchorPoint();
+
+            @out.PopIndentation();
return n;
}

@@ -459,7 +484,14 @@ namespace StringTemplate
{
v = o.ToString();
}
-            return @out.Write(v);
+
+            int n = 0;
+            if (options != null && options[OPTION_WRAP] != null)
+                n = @out.Write(v, options[OPTION_WRAP]);
+            else
+                n = @out.Write(v);
+
+            return n;
}

protected void Map(Template self, object attr, string name)
diff --git a/StringTemplate4/Template.cs b/StringTemplate4/Template.cs
index 68cce8a..95ae9cf 100644
--- a/StringTemplate4/Template.cs
+++ b/StringTemplate4/Template.cs
@@ -305,10 +305,21 @@ namespace StringTemplate
return Render(CultureInfo.CurrentCulture);
}

-        public virtual string Render(CultureInfo culture)
+        public string Render(int lineWidth)
+        {
+            return Render(CultureInfo.CurrentCulture, lineWidth);
+        }
+
+        public string Render(CultureInfo culture)
+        {
+            return Render(culture, AutoIndentWriter.NoWrap);
+        }
+
+        public virtual string Render(CultureInfo culture, int lineWidth)
{
StringWriter @out = new StringWriter();
-            ITemplateWriter wr = new AutoIndentWriter(@out);
+            ITemplateWriter wr = groupThatCreatedThisInstance.GetStringTemplateWriter(@out);
+            wr.SetLineWidth(lineWidth);
try
{
Write(wr, culture);
diff --git a/StringTemplate4/TemplateGroup.cs b/StringTemplate4/TemplateGroup.cs
index 575e76b..887d3f1 100644
--- a/StringTemplate4/TemplateGroup.cs
+++ b/StringTemplate4/TemplateGroup.cs
@@ -43,6 +43,7 @@ namespace StringTemplate
using StringBuilder = System.Text.StringBuilder;
using Type = System.Type;
using Antlr.Runtime;
+    using TextWriter = System.IO.TextWriter;

/** A directory or directory tree of .st template files and/or group files.
*  Individual template files contain formal template definitions. In a sense,
@@ -332,7 +333,7 @@ namespace StringTemplate
}

/** Return "t" from "region__t__foo" */
-        public static string getUnMangledTemplateName(string mangledName)
+        public static string GetUnmangledTemplateName(string mangledName)
{
int start = "region__".Length;
int end = mangledName.LastIndexOf("__");
@@ -417,6 +418,11 @@ namespace StringTemplate
return st;
}

+        public ITemplateWriter GetStringTemplateWriter(TextWriter w)
+        {
+            return new AutoIndentWriter(w);
+        }
+
public override string ToString()
{
return Name;

