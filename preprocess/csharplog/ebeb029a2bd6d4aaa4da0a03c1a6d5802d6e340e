commit ebeb029a2bd6d4aaa4da0a03c1a6d5802d6e340e
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Thu Nov 25 09:27:42 2010 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Thu Nov 25 09:27:42 2010 -0800

(C# 3) Add DGML graph output option (pass -dgml to the tool with -nfa and/or -dfa)
Fix project references to Antlr3.targets

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 7190]

diff --git a/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj b/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj
index ccabe65..5a1c611 100644
--- a/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj
+++ b/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj
@@ -134,7 +134,7 @@
<AntlrToolPath>$(SolutionDir)bin\Bootstrap\Antlr3.exe</AntlrToolPath>
</PropertyGroup>
<Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
-  <Import Project="$(SolutionDir)bin\Bootstrap\Antlr3.targets" />
+  <Import Project="$(ProjectDir)..\bin\Bootstrap\Antlr3.targets" />
<!-- To modify your build process, add your task inside one of the targets below and uncomment it.
Other similar extension points exist, see Microsoft.Common.targets.
<Target Name="BeforeBuild">
diff --git a/Antlr3/Antlr3.csproj b/Antlr3/Antlr3.csproj
index dc47dba..ca08069 100644
--- a/Antlr3/Antlr3.csproj
+++ b/Antlr3/Antlr3.csproj
@@ -45,6 +45,10 @@
<Reference Include="System.Core">
<RequiredTargetFramework>3.5</RequiredTargetFramework>
</Reference>
+    <Reference Include="System.XML" />
+    <Reference Include="System.Xml.Linq">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
</ItemGroup>
<ItemGroup>
<Compile Include="Analysis\ActionLabel.cs" />
@@ -151,6 +155,7 @@
<Compile Include="Misc\IIntSet.cs" />
<Compile Include="Tool\AssignTokenTypesBehavior.cs" />
<Compile Include="Tool\BuildDependencyGenerator.cs" />
+    <Compile Include="Tool\DgmlGenerator.cs" />
<Compile Include="Tool\DOTGenerator.cs" />
<Compile Include="Tool\FASerializer.cs" />
<Compile Include="Tool\GrammarAnalysisAbortedMessage.cs" />
@@ -165,6 +170,7 @@
<Compile Include="Tool\GrammarType.cs" />
<Compile Include="Tool\GrammarUnreachableAltsMessage.cs" />
<Compile Include="Tool\IAntlrErrorListener.cs" />
+    <Compile Include="Tool\IGraphGenerator.cs" />
<Compile Include="Tool\Interpreter.cs" />
<Compile Include="Tool\LabelType.cs" />
<Compile Include="Tool\LeftRecursionCyclesMessage.cs" />
@@ -508,7 +514,7 @@
<AntlrToolPath>$(SolutionDir)bin\Bootstrap\Antlr3.exe</AntlrToolPath>
</PropertyGroup>
<Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
-  <Import Project="$(SolutionDir)bin\Bootstrap\Antlr3.targets" />
+  <Import Project="$(ProjectDir)..\bin\Bootstrap\Antlr3.targets" />
<!-- To modify your build process, add your task inside one of the targets below and uncomment it.
Other similar extension points exist, see Microsoft.Common.targets.
<Target Name="BeforeBuild">
diff --git a/Antlr3/AntlrTool.cs b/Antlr3/AntlrTool.cs
index 8269aa1..f0b4612 100644
--- a/Antlr3/AntlrTool.cs
+++ b/Antlr3/AntlrTool.cs
@@ -4,7 +4,7 @@
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2008-2010 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -35,7 +35,6 @@ namespace Antlr3
using System;
using System.Collections.Generic;
using System.Linq;
-    using Antlr.Runtime.JavaExtensions;
using Antlr3.Analysis;
using Antlr3.Codegen;
using Antlr3.Misc;
@@ -59,6 +58,7 @@ namespace Antlr3
private List<string> generatedFiles = new List<string>();
private bool generate_NFA_dot = false;
private bool generate_DFA_dot = false;
+        private bool _generateDgmlGraphs = false;
private string outputDirectory = ".";
private bool haveOutputDir = false;
private string inputDirectory;
@@ -235,6 +235,10 @@ namespace Antlr3
{
Generate_DFA_dot = true;
}
+                else if ( args[i] == "-dgml" )
+                {
+                    GenerateDgmlGraphs = true;
+                }
else if ( args[i] == "-debug" )
{
Debug = true;
@@ -788,21 +792,31 @@ namespace Antlr3
{
continue; // not there for some reason, ignore
}
-                DOTGenerator dotGenerator = new DOTGenerator( g );
-                string dot = dotGenerator.GetDOT( dfa.startState );
-                string dotFileName = g.name + "." + "dec-" + d;
+
+                IGraphGenerator generator;
+                if (GenerateDgmlGraphs)
+                {
+                    generator = new DgmlGenerator(g);
+                }
+                else
+                {
+                    generator = new DOTGenerator(g);
+                }
+
+                string graph = generator.GenerateGraph( dfa.startState );
+                string graphFileName = g.name + "." + "dec-" + d;
if ( g.implicitLexer )
{
-                    dotFileName = g.name + Grammar.grammarTypeToFileNameSuffix[(int)g.type] + "." + "dec-" + d;
+                    graphFileName = g.name + Grammar.grammarTypeToFileNameSuffix[(int)g.type] + "." + "dec-" + d;
}
try
{
-                    WriteDOTFile( g, dotFileName, dot );
+                    WriteGraphFile( g, graphFileName, graph, generator.FileExtension );
}
catch ( IOException ioe )
{
ErrorManager.Error( ErrorManager.MSG_CANNOT_GEN_DOT_FILE,
-                                       dotFileName,
+                                       graphFileName,
ioe );
}
}
@@ -810,18 +824,18 @@ namespace Antlr3

protected virtual void GenerateNFAs( Grammar g )
{
-            DOTGenerator dotGenerator = new DOTGenerator( g );
-            ICollection<Rule> rules = g.GetAllImportedRules();
-            rules.addAll( g.Rules );
+            IGraphGenerator generator = GenerateDgmlGraphs ? (IGraphGenerator)new DgmlGenerator(g) : new DOTGenerator(g);
+            HashSet<Rule> rules = g.GetAllImportedRules();
+            rules.UnionWith( g.Rules );

foreach ( Rule r in rules )
{
try
{
-                    string dot = dotGenerator.GetDOT( r.startState );
+                    string dot = generator.GenerateGraph( r.startState );
if ( dot != null )
{
-                        WriteDOTFile( g, r, dot );
+                        WriteGraphFile( g, r, dot, generator.FileExtension );
}
}
catch ( IOException ioe )
@@ -831,15 +845,15 @@ namespace Antlr3
}
}

-        protected virtual void WriteDOTFile( Grammar g, Rule r, string dot )
+        protected virtual void WriteGraphFile( Grammar g, Rule r, string graph, string formatExtension )
{
-            WriteDOTFile( g, r.grammar.name + "." + r.Name, dot );
+            WriteGraphFile( g, r.grammar.name + "." + r.Name, graph, formatExtension );
}

-        protected virtual void WriteDOTFile( Grammar g, string name, string dot )
+        protected virtual void WriteGraphFile( Grammar g, string name, string graph, string formatExtension )
{
-            TextWriter fw = GetOutputFile( g, name + ".dot" );
-            fw.Write( dot );
+            TextWriter fw = GetOutputFile( g, name + formatExtension );
+            fw.Write( graph );
fw.Close();
}

@@ -864,6 +878,7 @@ namespace Antlr3
Console.Error.WriteLine( "  -profile              generate a parser that computes profiling information" );
Console.Error.WriteLine( "  -nfa                  generate an NFA for each rule" );
Console.Error.WriteLine( "  -dfa                  generate a DFA for each decision point" );
+            Console.Error.WriteLine( "  -dgml                 generate graphs in DGML format." );
Console.Error.WriteLine( "  -message-format name  specify output style for messages" );
Console.Error.WriteLine( "  -verbose              generate ANTLR version and other information" );
Console.Error.WriteLine( "  -make                 only build if generated files older than grammar" );
@@ -1225,6 +1240,19 @@ namespace Antlr3
}
}

+        public virtual bool GenerateDgmlGraphs
+        {
+            get
+            {
+                return _generateDgmlGraphs;
+            }
+
+            set
+            {
+                _generateDgmlGraphs = value;
+            }
+        }
+
/**
* Return the Path to the base output directory, where ANTLR
* will generate all the output files for the current language target as
diff --git a/Antlr3/Tool/DOTGenerator.cs b/Antlr3/Tool/DOTGenerator.cs
index 55bf392..6c1413e 100644
--- a/Antlr3/Tool/DOTGenerator.cs
+++ b/Antlr3/Tool/DOTGenerator.cs
@@ -4,7 +4,7 @@
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2008-2010 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -35,7 +35,6 @@ namespace Antlr3.Tool
using System;
using System.Collections.Generic;
using System.Linq;
-    using Antlr.Runtime.JavaExtensions;
using Antlr3.Analysis;

using AngleBracketTemplateLexer = Antlr3.ST.Language.AngleBracketTemplateLexer;
@@ -47,7 +46,7 @@ namespace Antlr3.Tool
using StringTemplateGroup = Antlr3.ST.StringTemplateGroup;

/** The DOT (part of graphviz) generation aspect. */
-    public class DOTGenerator
+    public class DOTGenerator : IGraphGenerator
{
internal bool StripNonreducedStates = false;

@@ -76,17 +75,28 @@ namespace Antlr3.Tool
}

#region Properties
+
+        public string FileExtension
+        {
+            get
+            {
+                return ".dot";
+            }
+        }
+
public string ArrowheadType
{
get
{
return arrowhead;
}
+
set
{
arrowhead = value;
}
}
+
[CLSCompliant(false)]
public string RankDir
{
@@ -94,18 +104,20 @@ namespace Antlr3.Tool
{
return rankdir;
}
+
set
{
rankdir = value;
}
}
+
#endregion

/** Return a String containing a DOT description that, when displayed,
*  will show the incoming state machine visually.  All nodes reachable
*  from startState will be included.
*/
-        public virtual string GetDOT( State startState )
+        public virtual string GenerateGraph( State startState )
{
if ( startState == null )
{
diff --git a/Antlr3/Tool/DgmlGenerator.cs b/Antlr3/Tool/DgmlGenerator.cs
new file mode 100644
index 0000000..5f2991f
--- /dev/null
+++ b/Antlr3/Tool/DgmlGenerator.cs
@@ -0,0 +1,778 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2010 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using System;
+    using System.Collections.Generic;
+    using System.Linq;
+    using System.Xml.Linq;
+    using Antlr3.Analysis;
+
+    using StringBuilder = System.Text.StringBuilder;
+
+    public class DgmlGenerator : IGraphGenerator
+    {
+        private const string EpsilonLinkLabel = "ε";
+        private readonly Grammar _grammar;
+        private string _groupId;
+        private readonly Dictionary<State, XElement> _nodes = new Dictionary<State, XElement>();
+        private readonly Dictionary<KeyValuePair<State, Transition>, XElement> _links = new Dictionary<KeyValuePair<State, Transition>, XElement>();
+        private readonly List<XElement> _extraNodes = new List<XElement>();
+        private readonly List<XElement> _extraLinks = new List<XElement>();
+        private readonly HashSet<int> _markedStates = new HashSet<int>();
+        private readonly HashSet<int> _canSkipStates = new HashSet<int>();
+
+        public DgmlGenerator(Grammar grammar)
+        {
+            if (grammar == null)
+                throw new ArgumentNullException("grammar");
+
+            _grammar = grammar;
+        }
+
+        public string FileExtension
+        {
+            get
+            {
+                return ".dgml";
+            }
+        }
+
+        public bool GroupNodes
+        {
+            get;
+            set;
+        }
+
+        public bool StripNonreducedStates
+        {
+            get;
+            set;
+        }
+
+        public string GenerateGraph(State state)
+        {
+            _nodes.Clear();
+            _links.Clear();
+            _extraNodes.Clear();
+            _extraLinks.Clear();
+            _markedStates.Clear();
+            _canSkipStates.Clear();
+
+            DFAState dfaState = state as DFAState;
+            if (GroupNodes)
+            {
+                if (dfaState != null)
+                {
+                    _groupId = "decision_";
+                    _extraNodes.Add(new XElement(Elements.Node,
+                        new XAttribute(Attributes.Id, _groupId),
+                        new XAttribute(Attributes.Label, dfaState.stateNumber.ToString()),
+                        new XAttribute(Attributes.Group, "Collapsed")));
+                }
+                else
+                {
+                    NFAState nfaState = (NFAState)state;
+                    _groupId = "rule_" + nfaState.enclosingRule.Name;
+                    _extraNodes.Add(new XElement(Elements.Node,
+                        new XAttribute(Attributes.Id, _groupId),
+                        new XAttribute(Attributes.Label, nfaState.enclosingRule.Name),
+                        new XAttribute(Attributes.Group, "Collapsed")));
+                }
+            }
+
+            if (dfaState != null)
+            {
+                WalkCreatingDfaDgml(dfaState);
+            }
+            else
+            {
+                WalkRuleNfaCreatingDgml(state);
+                LocateVerboseStates(state);
+            }
+
+            XDocument document = new XDocument(
+                new XDeclaration("1.0", "utf-8", "yes"),
+                new XElement(Elements.DirectedGraph,
+                    new XAttribute(Attributes.GraphDirection, GraphDirection.TopToBottom),
+                    new XAttribute(Attributes.Layout, Layout.Sugiyama),
+                    GetNodes(),
+                    GetLinks(),
+                    GetCategories(),
+                    GetProperties(),
+                    GetStyles()));
+
+            return document.ToString();
+        }
+
+        private void WalkCreatingDfaDgml(DFAState dfaState)
+        {
+            if (!_markedStates.Add(dfaState.stateNumber))
+                return;
+
+            // first add this node
+            string nodeCategory;
+            if (dfaState.IsAcceptState)
+            {
+                nodeCategory = Categories.StopState;
+            }
+            else
+            {
+                nodeCategory = Categories.State;
+            }
+
+            XElement node = new XElement(Elements.Node,
+                new XAttribute(Attributes.Id, "state_" + dfaState.stateNumber),
+                new XAttribute(Attributes.Label, GetStateLabel(dfaState)),
+                new XAttribute(Attributes.Category, nodeCategory));
+
+            _nodes.Add(dfaState, node);
+            if (GroupNodes)
+                _extraLinks.Add(CreateContainmentLink(_groupId, "state_" + dfaState.stateNumber));
+
+            // make an edge for each transition
+            for (int i = 0; i < dfaState.NumberOfTransitions; i++)
+            {
+                Transition edge = dfaState.Transition(i);
+                if (StripNonreducedStates)
+                {
+                    DFAState target = edge.target as DFAState;
+                    // don't generate nodes for terminal states
+                    if (target != null && target.AcceptStateReachable != DFA.REACHABLE_YES)
+                        continue;
+                }
+
+                string edgeCategory = Categories.Edge;
+                XElement edgeElement = new XElement(Elements.Link,
+                    new XAttribute(Attributes.Source, "state_" + dfaState.stateNumber),
+                    new XAttribute(Attributes.Target, "state_" + edge.target.stateNumber),
+                    new XAttribute(Attributes.Category, edgeCategory),
+                    new XAttribute(Attributes.Label, GetEdgeLabel(edge)));
+
+                _links.Add(new KeyValuePair<State, Transition>(dfaState, edge), edgeElement);
+                WalkCreatingDfaDgml((DFAState)edge.Target);
+            }
+        }
+
+        private XElement CreateContainmentLink(string source, string target)
+        {
+            return new XElement(Elements.Link,
+                new XAttribute(Attributes.Source, source),
+                new XAttribute(Attributes.Target, target),
+                new XAttribute(Attributes.Category, Categories.Contains));
+        }
+
+        private void WalkRuleNfaCreatingDgml(State state)
+        {
+            if (!_markedStates.Add(state.stateNumber))
+                return;
+
+            NFAState nfaState = state as NFAState;
+
+            // create the node
+            string nodeCategory;
+            if (state.IsAcceptState)
+                nodeCategory = Categories.StopState;
+            else if (nfaState != null && nfaState.IsDecisionState)
+                nodeCategory = Categories.DecisionState;
+            else
+                nodeCategory = Categories.State;
+
+            XElement node = new XElement(Elements.Node,
+                new XAttribute(Attributes.Id, "state_" + state.stateNumber),
+                new XAttribute(Attributes.Label, GetStateLabel(state)),
+                new XAttribute(Attributes.Category, nodeCategory));
+
+            if (nfaState != null && nfaState.IsDecisionState)
+            {
+                string baseFileName = _grammar.name;
+                if (_grammar.implicitLexer)
+                    baseFileName += Grammar.grammarTypeToFileNameSuffix[(int)_grammar.type];
+
+                string decisionPath = string.Format("{0}.dec-{1}.dgml", baseFileName, nfaState.DecisionNumber);
+                node.Add(new XAttribute(Attributes.Reference, decisionPath));
+            }
+
+            _nodes.Add(state, node);
+            if (GroupNodes)
+                _extraLinks.Add(CreateContainmentLink(_groupId, "state_" + state.stateNumber));
+
+            // don't go past end of rule
+            if (state.IsAcceptState)
+                return;
+
+            // create links for each transition
+            for (int i = 0; i < state.NumberOfTransitions; i++)
+            {
+                Transition edge = state.GetTransition(i);
+                RuleClosureTransition rr = edge as RuleClosureTransition;
+                if (rr != null)
+                {
+                    string label;
+
+                    if (rr.rule.grammar != _grammar)
+                        label = string.Format("<{0}.{1}>", rr.rule.grammar.name, rr.rule.Name);
+                    else
+                        label = string.Format("<{0}>", rr.rule.Name);
+
+                    XElement link = new XElement(Elements.Link,
+                        new XAttribute(Attributes.Source, "state_" + state.stateNumber),
+                        new XAttribute(Attributes.Target, "state_" + rr.followState),
+                        new XAttribute(Attributes.Category, Categories.RuleClosureEdge),
+                        new XAttribute(Attributes.Label, label));
+
+                    _links.Add(new KeyValuePair<State, Transition>(state, edge), link);
+                    WalkRuleNfaCreatingDgml(rr.followState);
+                }
+                else
+                {
+                    string edgeCategory;
+
+                    if (edge.IsAction)
+                        edgeCategory = Categories.ActionEdge;
+                    else if (edge.IsEpsilon)
+                        edgeCategory = Categories.EpsilonEdge;
+                    else if (edge.Label.IsSet || edge.label.IsAtom)
+                        edgeCategory = Categories.AtomEdge;
+                    else
+                        edgeCategory = Categories.Edge;
+
+                    XElement link = new XElement(Elements.Link,
+                        new XAttribute(Attributes.Source, "state_" + state.stateNumber),
+                        new XAttribute(Attributes.Target, "state_" + edge.Target.stateNumber),
+                        new XAttribute(Attributes.Category, edgeCategory),
+                        new XAttribute(Attributes.Label, GetEdgeLabel(edge)));
+
+                    _links.Add(new KeyValuePair<State, Transition>(state, edge), link);
+                    WalkRuleNfaCreatingDgml(edge.Target);
+                }
+            }
+        }
+
+        private void LocateVerboseStates(State startState)
+        {
+            Dictionary<State, XElement> verboseNodes = _nodes.Where(IsVerboseNode).ToDictionary(i => i.Key, i => i.Value);
+            verboseNodes.Remove(startState);
+
+            foreach (var verboseNode in verboseNodes)
+            {
+                verboseNode.Value.Add(new XElement(Elements.Category,
+                    new XAttribute(Attributes.Ref, Categories.VerboseNode)));
+            }
+
+            Dictionary<State, List<State>> shortcuts = new Dictionary<State, List<State>>();
+            foreach (var link in _links)
+            {
+                State source = link.Key.Key;
+                State target = link.Key.Value.Target;
+                if (!verboseNodes.ContainsKey(source) && verboseNodes.ContainsKey(target))
+                {
+                    List<State> newTargets = new List<State>();
+                    Stack<State> remaining = new Stack<State>();
+                    remaining.Push(target);
+                    while (remaining.Count > 0)
+                    {
+                        State current = remaining.Pop();
+                        if (!verboseNodes.ContainsKey(current))
+                        {
+                            if (_nodes.ContainsKey(current))
+                                newTargets.Add(current);
+                        }
+                        else
+                        {
+                            for (int i = 0; i < current.NumberOfTransitions; i++)
+                            {
+                                remaining.Push(current.GetTransition(i).Target);
+                            }
+                        }
+                    }
+
+                    foreach (var newTarget in newTargets)
+                    {
+                        XElement newLink = new XElement(link.Value);
+                        newLink.Attribute(Attributes.Target).Remove();
+                        newLink.Add(new XAttribute(Attributes.Target, "state_" + newTarget.stateNumber));
+                        newLink.Add(new XElement(Elements.Category, new XAttribute(Attributes.Ref, Categories.OptimizedEdge)));
+
+                        _extraLinks.Add(newLink);
+                    }
+                }
+            }
+        }
+
+        private bool IsVerboseNode(KeyValuePair<State, XElement> node)
+        {
+            NFAState state = node.Key as NFAState;
+            if (state == null)
+                return false;
+
+            // Cannot skip first state
+            if (state.stateNumber == 0)
+                return false;
+
+            // Cannot skip accepted state
+            if (state.IsAcceptState)
+                return false;
+
+            // Cannot skip alternative state
+            if (state.DecisionNumber > 0)
+                return false;
+
+            // Cannot skip start of block state
+            if (state.endOfBlockStateNumber != State.INVALID_STATE_NUMBER)
+                return false;
+
+            // Cannot skip state with more than one incoming transition (often an end-of-alternative state)
+            if (NumberOfIncomingTransition(state) > 1)
+                return false;
+
+            return HasOneOrMoreEpsilonTransitionOnly(state);
+        }
+
+        private int NumberOfIncomingTransition(NFAState state)
+        {
+            return _links.Count(i => i.Key.Value.Target == state);
+        }
+
+        private static bool HasOneOrMoreEpsilonTransitionOnly(NFAState state)
+        {
+            for (int t = 0; t < state.NumberOfTransitions; t++)
+            {
+                Transition transition = state.transition[t];
+                if (!transition.IsEpsilon)
+                    return false;
+            }
+
+            return state.NumberOfTransitions > 0;
+        }
+
+        private string GetEdgeLabel(Transition edge)
+        {
+            string label = edge.label.ToString(_grammar);
+            label = string.Join(" ", label.Split(default(char[]), StringSplitOptions.RemoveEmptyEntries));
+            if (label.Equals(Label.EPSILON_STR))
+            {
+                label = EpsilonLinkLabel;
+            }
+            State target = edge.target;
+            if (!edge.IsSemanticPredicate && target is DFAState)
+            {
+                // look for gated predicates; don't add gated to simple sempred edges
+                SemanticContext preds =
+                    ((DFAState)target).GetGatedPredicatesInNFAConfigurations();
+                if (preds != null)
+                {
+                    string predsStr = "";
+                    predsStr = "&&{" +
+                        preds.GenExpr(_grammar.generator,
+                                      _grammar.generator.Templates, null).ToString()
+                        + "}?";
+                    label += predsStr;
+                }
+            }
+
+            if (label.Length > 43)
+                label = label.Substring(0, 40) + "...";
+
+            return label;
+        }
+
+        private string GetStateLabel(State state)
+        {
+            if (state == null)
+                return "null";
+
+            string stateLabel = state.stateNumber.ToString();
+            DFAState dfaState = state as DFAState;
+            NFAState nfaState = state as NFAState;
+            if (dfaState != null)
+            {
+                StringBuilder builder = new StringBuilder(250);
+                builder.Append('s');
+                builder.Append(state.stateNumber);
+                if (AntlrTool.internalOption_ShowNFAConfigsInDFA)
+                {
+                    if (dfaState.abortedDueToRecursionOverflow)
+                    {
+                        builder.AppendLine();
+                        builder.AppendLine("AbortedDueToRecursionOverflow");
+                    }
+
+                    var alts = dfaState.AltSet;
+                    if (alts != null)
+                    {
+                        builder.AppendLine();
+                        List<int> altList = alts.OrderBy(i => i).ToList();
+                        ICollection<NFAConfiguration> configurations = dfaState.nfaConfigurations;
+                        for (int i = 0; i < altList.Count; i++)
+                        {
+                            int alt = altList[i];
+                            if (i > 0)
+                                builder.AppendLine();
+                            builder.AppendFormat("alt{0}:", alt);
+                            // get a list of configs for just this alt
+                            // it will help us print better later
+                            List<NFAConfiguration> configsInAlt = new List<NFAConfiguration>();
+                            foreach (NFAConfiguration c in configurations)
+                            {
+                                if (c.alt != alt)
+                                    continue;
+
+                                configsInAlt.Add(c);
+                            }
+
+                            int n = 0;
+                            for (int cIndex = 0; cIndex < configsInAlt.Count; cIndex++)
+                            {
+                                NFAConfiguration c = configsInAlt[cIndex];
+                                n++;
+                                builder.Append(c.ToString(false));
+                                if ((cIndex + 1) < configsInAlt.Count)
+                                {
+                                    builder.Append(", ");
+                                }
+                                if (n % 5 == 0 && (configsInAlt.Count - cIndex) > 3)
+                                {
+                                    builder.Append("\\n");
+                                }
+                            }
+                        }
+                    }
+                }
+
+                if (dfaState.IsAcceptState)
+                {
+                    builder.Append("⇒" + dfaState.GetUniquelyPredictedAlt());
+                }
+
+                stateLabel = builder.ToString();
+            }
+            else if (nfaState != null)
+            {
+                if (nfaState.IsDecisionState)
+                    stateLabel += ",d=" + nfaState.DecisionNumber;
+
+                if (nfaState.endOfBlockStateNumber != State.INVALID_STATE_NUMBER)
+                    stateLabel += ",eob=" + nfaState.endOfBlockStateNumber;
+            }
+
+            return stateLabel;
+        }
+
+        private XElement GetNodes()
+        {
+            return new XElement(Elements.Nodes, _nodes.Values.Concat(_extraNodes));
+        }
+
+        private XElement GetLinks()
+        {
+            return new XElement(Elements.Links, _links.Values.Concat(_extraLinks));
+        }
+
+        private static XElement GetCategories()
+        {
+            return new XElement(Elements.Categories,
+                new XElement(Elements.Category,
+                    new XAttribute(Attributes.Id, Categories.GrammarRule),
+                    new XAttribute(Attributes.FontFamily, "Consolas")),
+                new XElement(Elements.Category,
+                    new XAttribute(Attributes.Id, Categories.LexerIdentifier),
+                    new XAttribute(Attributes.BasedOn, Categories.LexerRule),
+                    new XAttribute(Attributes.Foreground, Colors.Blue)),
+                new XElement(Elements.Category,
+                    new XAttribute(Attributes.Id, Categories.LexerLiteral),
+                    new XAttribute(Attributes.BasedOn, Categories.LexerRule),
+                    new XAttribute(Attributes.Foreground, Colors.DarkGreen)),
+                new XElement(Elements.Category,
+                    new XAttribute(Attributes.Id, Categories.LexerRule),
+                    new XAttribute(Attributes.BasedOn, Categories.GrammarRule),
+                    new XAttribute(Attributes.NodeRadius, 0)),
+                new XElement(Elements.Category,
+                    new XAttribute(Attributes.Id, Categories.ParserRule),
+                    new XAttribute(Attributes.BasedOn, Categories.GrammarRule),
+                    new XAttribute(Attributes.Foreground, Colors.Purple)),
+                new XElement(Elements.Category,
+                    new XAttribute(Attributes.Id, Categories.State)),
+                new XElement(Elements.Category,
+                    new XAttribute(Attributes.Id, Categories.DecisionState),
+                    new XAttribute(Attributes.BasedOn, Categories.State)),
+                new XElement(Elements.Category,
+                    new XAttribute(Attributes.Id, Categories.StopState),
+                    new XAttribute(Attributes.BasedOn, Categories.State)),
+                new XElement(Elements.Category,
+                    new XAttribute(Attributes.Id, Categories.Edge)),
+                new XElement(Elements.Category,
+                    new XAttribute(Attributes.Id, Categories.ActionEdge),
+                    new XAttribute(Attributes.BasedOn, Categories.Edge),
+                    new XAttribute(Attributes.FontFamily, "Consolas")),
+                new XElement(Elements.Category,
+                    new XAttribute(Attributes.Id, Categories.EpsilonEdge),
+                    new XAttribute(Attributes.FontFamily, "Times New Roman"),
+                    new XAttribute(Attributes.FontStyle, "Italic")),
+                new XElement(Elements.Category,
+                    new XAttribute(Attributes.Id, Categories.RuleClosureEdge),
+                    new XAttribute(Attributes.BasedOn, Categories.Edge)),
+                new XElement(Elements.Category,
+                    new XAttribute(Attributes.Id, Categories.AtomEdge),
+                    new XAttribute(Attributes.BasedOn, Categories.Edge)),
+                new XElement(Elements.Category,
+                    new XAttribute(Attributes.Id, Categories.OptimizedEdge),
+                    new XAttribute(Attributes.Stroke, Colors.Red),
+                    new XAttribute(Attributes.Visibility, "Collapsed")),
+                new XElement(Elements.Category,
+                    new XAttribute(Attributes.Id, Categories.VerboseNode)),
+                new XElement(Elements.Category,
+                    new XAttribute(Attributes.Id, Categories.Contains),
+                    new XAttribute(Attributes.IsContainment, true),
+                    new XAttribute(Attributes.Label, Categories.Contains),
+                    new XAttribute(Attributes.CanBeDataDriven, false),
+                    new XAttribute(Attributes.CanLinkedNodesBeDataDriven, true),
+                    new XAttribute(Attributes.IncomingActionLabel, "Contained By"),
+                    new XAttribute(Attributes.OutgoingActionLabel, "Contains")));
+        }
+
+        private static XElement GetProperties()
+        {
+            return new XElement(Elements.Properties,
+                new XElement(Elements.Property,
+                    new XAttribute(Attributes.Id, Attributes.FontFamily),
+                    new XAttribute(Attributes.DataType, "System.Windows.Media.FontFamily")),
+                new XElement(Elements.Property,
+                    new XAttribute(Attributes.Id, Attributes.Foreground),
+                    new XAttribute(Attributes.Label, "Foreground"),
+                    new XAttribute(Attributes.Description, "The foreground color"),
+                    new XAttribute(Attributes.DataType, "System.Windows.Media.Brush")),
+                new XElement(Elements.Property,
+                    new XAttribute(Attributes.Id, Attributes.GraphDirection),
+                    new XAttribute(Attributes.DataType, "Microsoft.VisualStudio.Progression.Layout.GraphDirection")),
+                new XElement(Elements.Property,
+                    new XAttribute(Attributes.Id, Attributes.Label),
+                    new XAttribute(Attributes.Label, "Label"),
+                    new XAttribute(Attributes.Description, "Displayable label of an Annotatable object"),
+                    new XAttribute(Attributes.DataType, "System.String")),
+                new XElement(Elements.Property,
+                    new XAttribute(Attributes.Id, Attributes.Layout),
+                    new XAttribute(Attributes.DataType, "System.String")),
+                new XElement(Elements.Property,
+                    new XAttribute(Attributes.Id, Attributes.NodeRadius),
+                    new XAttribute(Attributes.DataType, "System.Double")),
+                new XElement(Elements.Property,
+                    new XAttribute(Attributes.Id, Attributes.Shape),
+                    new XAttribute(Attributes.DataType, "System.String")));
+        }
+
+        private static XElement GetStyles()
+        {
+            return new XElement(Elements.Styles,
+                new XElement(Elements.Style,
+                    new XAttribute(Attributes.TargetType, "Node"),
+                    new XAttribute(Attributes.GroupLabel, "Verbose State"),
+                    new XAttribute(Attributes.ValueLabel, "Verbose State"),
+                    new XElement(Elements.Condition,
+                        new XAttribute(Attributes.Expression, string.Format("HasCategory('{0}')", Categories.VerboseNode))),
+                    new XElement(Elements.Setter,
+                        new XAttribute(Attributes.Property, Attributes.Background),
+                        new XAttribute(Attributes.Value, Colors.LightYellow))),
+                new XElement(Elements.Style,
+                    new XAttribute(Attributes.TargetType, "Node"),
+                    new XAttribute(Attributes.GroupLabel, "Stop State"),
+                    new XAttribute(Attributes.ValueLabel, "Stop State"),
+                    new XElement(Elements.Condition,
+                        new XAttribute(Attributes.Expression, string.Format("HasCategory('{0}')", Categories.StopState))),
+                    new XElement(Elements.Setter,
+                        new XAttribute(Attributes.Property, Attributes.Stroke),
+                        new XAttribute(Attributes.Value, Colors.Black)),
+                    new XElement(Elements.Setter,
+                        new XAttribute(Attributes.Property, Attributes.StrokeThickness),
+                        new XAttribute(Attributes.Value, 2))),
+                new XElement(Elements.Style,
+                    new XAttribute(Attributes.TargetType, "Node"),
+                    new XAttribute(Attributes.GroupLabel, "Decision State"),
+                    new XAttribute(Attributes.ValueLabel, "Decision State"),
+                    new XElement(Elements.Condition,
+                        new XAttribute(Attributes.Expression, string.Format("HasCategory('{0}')", Categories.DecisionState))),
+                    new XElement(Elements.Setter,
+                        new XAttribute(Attributes.Property, Attributes.Stroke),
+                        new XAttribute(Attributes.Value, Colors.Black)),
+                    new XElement(Elements.Setter,
+                        new XAttribute(Attributes.Property, Attributes.StrokeThickness),
+                        new XAttribute(Attributes.Value, 1)),
+                    new XElement(Elements.Setter,
+                        new XAttribute(Attributes.Property, Attributes.StrokeDashArray),
+                        new XAttribute(Attributes.Value, "2,2"))),
+                new XElement(Elements.Style,
+                    new XAttribute(Attributes.TargetType, "Link"),
+                    new XAttribute(Attributes.GroupLabel, "Epsilon Edge"),
+                    new XAttribute(Attributes.ValueLabel, "Epsilon Edge"),
+                    new XElement(Elements.Condition,
+                        new XAttribute(Attributes.Expression, string.Format("HasCategory('{0}')", Categories.EpsilonEdge))),
+                    new XElement(Elements.Setter,
+                        new XAttribute(Attributes.Property, Attributes.StrokeDashArray),
+                        new XAttribute(Attributes.Value, "2,2"))),
+                new XElement(Elements.Style,
+                    new XAttribute(Attributes.TargetType, "Link"),
+                    new XAttribute(Attributes.GroupLabel, "Rule Closure Edge"),
+                    new XAttribute(Attributes.ValueLabel, "Rule Closure Edge"),
+                    new XElement(Elements.Condition,
+                        new XAttribute(Attributes.Expression, string.Format("HasCategory('{0}')", Categories.RuleClosureEdge))),
+                    new XElement(Elements.Setter,
+                        new XAttribute(Attributes.Property, Attributes.Stroke),
+                        new XAttribute(Attributes.Value, Colors.Purple)),
+                    new XElement(Elements.Setter,
+                        new XAttribute(Attributes.Property, Attributes.FontFamily),
+                        new XAttribute(Attributes.Value, "Consolas"))),
+                new XElement(Elements.Style,
+                    new XAttribute(Attributes.TargetType, "Link"),
+                    new XAttribute(Attributes.GroupLabel, "Atom Edge"),
+                    new XAttribute(Attributes.ValueLabel, "Atom Edge"),
+                    new XElement(Elements.Condition,
+                        new XAttribute(Attributes.Expression, string.Format("HasCategory('{0}')", Categories.AtomEdge))),
+                    new XElement(Elements.Setter,
+                        new XAttribute(Attributes.Property, Attributes.Stroke),
+                        new XAttribute(Attributes.Value, Colors.DarkBlue)),
+                    new XElement(Elements.Setter,
+                        new XAttribute(Attributes.Property, Attributes.FontFamily),
+                        new XAttribute(Attributes.Value, "Consolas"))));
+
+        }
+
+        private static class GraphDirection
+        {
+            public const string LeftToRight = "LeftToRight";
+            public const string TopToBottom = "TopToBottom";
+            public const string RightToLeft = "TopToBottom";
+            public const string BottomToTop = "BottomToTop";
+        }
+
+        private static class Layout
+        {
+            public const string None = "None";
+            public const string Sugiyama = "Sugiyama";
+            public const string ForceDirected = "ForceDirected";
+            public const string DependencyMatrix = "DependencyMatrix";
+        }
+
+        private static class Elements
+        {
+            private static readonly XNamespace ns = "http://schemas.microsoft.com/vs/2009/dgml";
+            public static readonly XName DirectedGraph = ns + "DirectedGraph";
+            public static readonly XName Nodes = ns + "Nodes";
+            public static readonly XName Node = ns + "Node";
+            public static readonly XName Links = ns + "Links";
+            public static readonly XName Link = ns + "Link";
+            public static readonly XName Categories = ns + "Categories";
+            public static readonly XName Category = ns + "Category";
+            public static readonly XName Properties = ns + "Properties";
+            public static readonly XName Property = ns + "Property";
+            public static readonly XName Styles = ns + "Styles";
+            public static readonly XName Style = ns + "Style";
+            public static readonly XName Condition = ns + "Condition";
+            public static readonly XName Setter = ns + "Setter";
+        }
+
+        private static class Attributes
+        {
+            public const string Id = "Id";
+            public const string GraphDirection = "GraphDirection";
+            public const string Layout = "Layout";
+            public const string FontFamily = "FontFamily";
+            public const string BasedOn = "BasedOn";
+            public const string Background = "Background";
+            public const string Foreground = "Foreground";
+            public const string NodeRadius = "NodeRadius";
+            public const string DataType = "DataType";
+            public const string Label = "Label";
+            public const string Source = "Source";
+            public const string Target = "Target";
+            public const string Category = "Category";
+            public const string Shape = "Shape";
+            public const string Description = "Description";
+            public const string FontStyle = "FontStyle";
+            public const string Ref = "Ref";
+            public const string Stroke = "Stroke";
+            public const string StrokeThickness = "StrokeThickness";
+            public const string StrokeDashArray = "StrokeDashArray";
+            public const string Visibility = "Visibility";
+            public const string Expression = "Expression";
+            public const string Property = "Property";
+            public const string Value = "Value";
+            public const string TargetType = "TargetType";
+            public const string GroupLabel = "GroupLabel";
+            public const string ValueLabel = "ValueLabel";
+            public const string Reference = "Reference";
+            public const string IsContainment = "IsContainment";
+            public const string CanBeDataDriven = "CanBeDataDriven";
+            public const string CanLinkedNodesBeDataDriven = "CanLinkedNodesBeDataDriven";
+            public const string IncomingActionLabel = "IncomingActionLabel";
+            public const string OutgoingActionLabel = "OutgoingActionLabel";
+            public const string Group = "Group";
+        }
+
+        private static class Categories
+        {
+            public const string GrammarRule = "GrammarRule";
+            public const string LexerIdentifier = "LexerIdentifier";
+            public const string LexerLiteral = "LexerLiteral";
+            public const string LexerRule = "LexerRule";
+            public const string ParserRule = "ParserRule";
+            public const string OptimizedEdge = "OptimizedEdge";
+            public const string VerboseNode = "VerboseNode";
+            public const string EpsilonEdge = "EpsilonEdge";
+            public const string ActionEdge = "ActionEdge";
+            public const string RuleClosureEdge = "RuleClosureEdge";
+            public const string AtomEdge = "AtomEdge";
+            public const string Edge = "Edge";
+            public const string State = "State";
+            public const string DecisionState = "DecisionState";
+            public const string StopState = "StopState";
+            public const string Contains = "Contains";
+        }
+
+        private static class Colors
+        {
+            public const string DarkBlue = "DarkBlue";
+            public const string DarkGreen = "#FF008000";
+            public const string Purple = "#FF800080";
+            public const string Blue = "#FF00008B";
+            public const string Red = "#FFFF0000";
+            public const string Black = "#FF000000";
+            public const string LightYellow = "LightYellow";
+        }
+
+        private static class Shapes
+        {
+            public const string None = "None";
+            public const string Rectangle = "Rectangle";
+        }
+    }
+}
diff --git a/Antlr3/Tool/IGraphGenerator.cs b/Antlr3/Tool/IGraphGenerator.cs
new file mode 100644
index 0000000..7431fa6
--- /dev/null
+++ b/Antlr3/Tool/IGraphGenerator.cs
@@ -0,0 +1,46 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2010 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr3.Tool
+{
+    using Antlr3.Analysis;
+
+    public interface IGraphGenerator
+    {
+        string FileExtension
+        {
+            get;
+        }
+
+        string GenerateGraph(State state);
+    }
+}

