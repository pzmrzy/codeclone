commit 90567d6f7322b203bbd8a3fd061726a209c10c10
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Thu Feb 3 10:30:08 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Thu Feb 3 10:30:08 2011 -0800

(C# 3) Support for @name identifier syntax, use @id in generated code for rules with names matching C# identifiers

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 7618]

diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp3/Antlr3.Targets.CSharp3.csproj b/Antlr3.Targets/Antlr3.Targets.CSharp3/Antlr3.Targets.CSharp3.csproj
index 43f2a74..e3e86bb 100644
--- a/Antlr3.Targets/Antlr3.Targets.CSharp3/Antlr3.Targets.CSharp3.csproj
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp3/Antlr3.Targets.CSharp3.csproj
@@ -50,6 +50,11 @@
<Compile Include="Properties\AssemblyInfo.cs" />
</ItemGroup>
<ItemGroup>
+    <ProjectReference Include="..\..\Antlr3.StringTemplate\Antlr3.StringTemplate.csproj">
+      <Project>{B5910BE2-DE21-4AA9-95C1-486F42B9E794}</Project>
+      <Name>Antlr3.StringTemplate</Name>
+      <Private>False</Private>
+    </ProjectReference>
<ProjectReference Include="..\..\Antlr3\Antlr3.csproj">
<Project>{2AB8CAED-C046-4F05-8B18-6948100D2FE7}</Project>
<Name>Antlr3</Name>
diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp3/CSharp3Target.cs b/Antlr3.Targets/Antlr3.Targets.CSharp3/CSharp3Target.cs
index 9150583..53d860a 100644
--- a/Antlr3.Targets/Antlr3.Targets.CSharp3/CSharp3Target.cs
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp3/CSharp3Target.cs
@@ -31,11 +31,44 @@
*/
namespace Antlr3.Targets
{
-    using CLSCompliant = System.CLSCompliantAttribute;
+    using System.Collections.Generic;
+
+    using ArgumentException = System.ArgumentException;
+    using ArgumentNullException = System.ArgumentNullException;
+    using CLSCompliantAttribute = System.CLSCompliantAttribute;
+    using CodeGenerator = Antlr3.Codegen.CodeGenerator;
+    using CultureInfo = System.Globalization.CultureInfo;
+    using Grammar = Antlr3.Tool.Grammar;
+    using IAttributeRenderer = Antlr3.ST.IAttributeRenderer;
+    using StringTemplate = Antlr3.ST.StringTemplate;
using Target = Antlr3.Codegen.Target;

public class CSharp3Target : Target
{
+        private static readonly HashSet<string> _languageKeywords = new HashSet<string>()
+            {
+                "abstract", "event", "new", "struct",
+                "as", "explicit", "null", "switch",
+                "base", "extern", "object", "this",
+                "bool", "false", "operator", "throw",
+                "break", "finally", "out", "true",
+                "byte", "fixed", "override", "try",
+                "case", "float", "params", "typeof",
+                "catch", "for", "private", "uint",
+                "char", "foreach", "protected", "ulong",
+                "checked", "goto", "public", "unchecked",
+                "class", "if", "readonly", "unsafe",
+                "const", "implicit", "ref", "ushort",
+                "continue", "in", "return", "using",
+                "decimal", "int", "sbyte", "virtual",
+                "default", "interface", "sealed", "volatile",
+                "delegate", "internal", "short", "void",
+                "do", "is", "sizeof", "while",
+                "double", "lock", "stackalloc",
+                "else", "long", "static",
+                "enum", "namespace", "string",
+            };
+
public override string EncodeIntAsCharEscape( int v )
{
return "\\x" + v.ToString( "X" );
@@ -46,5 +79,53 @@ namespace Antlr3.Targets
{
return "0x" + word.ToString( "X" );
}
+
+        protected override void GenRecognizerFile(AntlrTool tool, CodeGenerator generator, Grammar grammar, StringTemplate outputFileST)
+        {
+            generator.Templates.RegisterRenderer(typeof(string), new StringRenderer());
+            base.GenRecognizerFile(tool, generator, grammar, outputFileST);
+        }
+
+        public class StringRenderer : IAttributeRenderer
+        {
+            public string ToString(string value)
+            {
+                return value;
+            }
+
+            public string ToString(string value, string formatName)
+            {
+                if (string.IsNullOrEmpty(value))
+                    return value;
+
+                switch (formatName)
+                {
+                case "id":
+                    if (_languageKeywords.Contains(value))
+                        return "@" + value;
+
+                    return value;
+
+                case "cap":
+                    return char.ToUpper(value[0], CultureInfo.CurrentCulture) + value.Substring(1);
+
+                default:
+                    throw new ArgumentException(string.Format("Unsupported format name: '{0}'", formatName), "formatName");
+                }
+            }
+
+            string IAttributeRenderer.ToString(object o)
+            {
+                return (string)o;
+            }
+
+            string IAttributeRenderer.ToString(object o, string formatName)
+            {
+                if (formatName == null)
+                    throw new ArgumentNullException("formatName");
+
+                return ToString((string)o, formatName);
+            }
+        }
}
}
diff --git a/Antlr3/Grammars/ActionTranslator.g3 b/Antlr3/Grammars/ActionTranslator.g3
index 1bc3dfe..a1d6620 100644
--- a/Antlr3/Grammars/ActionTranslator.g3
+++ b/Antlr3/Grammars/ActionTranslator.g3
@@ -751,7 +751,7 @@ TEXT

fragment
ID
-	:	('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*
+	:	'@'? ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*
;

fragment
diff --git a/Antlr3/Tool/Attribute.cs b/Antlr3/Tool/Attribute.cs
index 5846c19..0dee06c 100644
--- a/Antlr3/Tool/Attribute.cs
+++ b/Antlr3/Tool/Attribute.cs
@@ -106,13 +106,13 @@ namespace Antlr3.Tool
for ( int i = rightEdgeOfDeclarator; i >= 0; i-- )
{
// if we haven't found the end yet, keep going
-                if ( !inID && char.IsLetterOrDigit( decl[i] ) )
+                if ( !inID && (char.IsLetterOrDigit( decl[i] ) || decl[i] == '_' || decl[i] == '@') )
{
inID = true;
}
else if ( inID &&
!( char.IsLetterOrDigit( decl[i] ) ||
-                           decl[i] == '_' ) )
+                           decl[i] == '_' || decl[i] == '@' ) )
{
start = i + 1;
break;
@@ -132,7 +132,7 @@ namespace Antlr3.Tool
{
// if we haven't found the end yet, keep going
if ( !( char.IsLetterOrDigit( decl[i] ) ||
-                    decl[i] == '_' ) )
+                    decl[i] == '_' || decl[i] == '@' ) )
{
stop = i;
break;

