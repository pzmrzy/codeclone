commit 92a75d43dbcf05185ba3f57f65c80873d6f0b2f4
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Thu Jan 20 09:27:20 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Thu Jan 20 09:27:20 2011 -0800

(C# 3) Fix build errors

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 7462]

diff --git a/Antlr3.StringTemplate/Language/ASTExpr.cs b/Antlr3.StringTemplate/Language/ASTExpr.cs
index 4db2a71..4b3a9e2 100644
--- a/Antlr3.StringTemplate/Language/ASTExpr.cs
+++ b/Antlr3.StringTemplate/Language/ASTExpr.cs
@@ -917,7 +917,7 @@ namespace Antlr3.ST.Language

IEnumerable enumerable = a as IEnumerable;
if ( enumerable != null )
-                return enumerable.GetEnumerator().MoveNext();
+                return enumerable.Cast<object>().Any();

Iterator iterator = a as Iterator;
if ( iterator != null )
diff --git a/Antlr3.StringTemplate/Language/ActionEvaluator.g3 b/Antlr3.StringTemplate/Language/ActionEvaluator.g3
index f26d6a9..9af129a 100644
--- a/Antlr3.StringTemplate/Language/ActionEvaluator.g3
+++ b/Antlr3.StringTemplate/Language/ActionEvaluator.g3
@@ -75,7 +75,7 @@ options
using System.Linq;
using Antlr.Runtime.JavaExtensions;

-using Map = System.Collections.IDictionary;
+using IDictionary = System.Collections.IDictionary;
using Set = System.Collections.Generic.HashSet<object>;
using StringWriter = System.IO.StringWriter;
using Vector = System.Collections.Generic.List<object>;
@@ -91,7 +91,7 @@ action returns [int numCharsWritten=0]
expr returns [object value]
@init
{
-	Map argumentContext=null;
+	IDictionary argumentContext=null;
$value = null;
}
:	^(PLUS a=expr b=expr {$value = chunk.Add($a.value,$b.value);})
@@ -117,7 +117,7 @@ expr returns [object value]
list returns [object value=null]
@init
{
-	List elements = new ArrayList();
+	List<object> elements = new List<object>();
}
:	^(	LIST
(	expr
@@ -129,7 +129,7 @@ list returns [object value=null]
}
|	NOTHING
{
-					List nullSingleton = new ArrayList( new object[] {null} );
+					List<object> nullSingleton = new List<object>( new object[] {null} );
elements.Add(nullSingleton.iterator()); // add a blank
}
)+
@@ -168,7 +168,7 @@ templateApplication returns [object value]
@init
{
var templatesToApply = new System.Collections.Generic.List<StringTemplate>();
-	List attributes = new ArrayList();
+	List<object> attributes = new List<object>();
}
:	^(	APPLY a=expr
(template[templatesToApply])+
@@ -205,7 +205,7 @@ singleFunctionArg returns [object value=null]
template[System.Collections.Generic.List<StringTemplate> templatesToApply]
@init
{
-	Map argumentContext = null;
+	IDictionary argumentContext = null;
}
:	^(	TEMPLATE
(	ID args=. // don't eval argList now; must re-eval each iteration
@@ -320,7 +320,7 @@ argList[StringTemplate embedded, System.Collections.Generic.Dictionary<string, o
|	singleTemplateArg[$embedded,$argumentContext]
;

-singleTemplateArg[StringTemplate embedded, Map argumentContext]
+singleTemplateArg[StringTemplate embedded, IDictionary argumentContext]
:	^( SINGLEVALUEARG e=expr )
{
if ( $e.value!=null )
@@ -360,7 +360,7 @@ singleTemplateArg[StringTemplate embedded, Map argumentContext]
}
;

-argumentAssignment[StringTemplate embedded, Map argumentContext]
+argumentAssignment[StringTemplate embedded, IDictionary argumentContext]
:	^( ASSIGN arg=ID expr )
{
if ( $expr.value != null )
@@ -906,7 +906,7 @@ listFunctional returns [System.Func<ASTExpr,StringTemplate,IStringTemplateWriter
|	NOTHING
{
#if COMPILE_EXPRESSIONS
-					elements.Add( (chunk,self,writer) => new ArrayList( new object[] { null } ).iterator() );
+					elements.Add( (chunk,self,writer) => new List<object>( new object[] { null } ).iterator() );
#endif
}
)+
@@ -961,7 +961,7 @@ templateCompiled[System.Reflection.Emit.ILGenerator gen]
templateFunctional[List<System.Func<ASTExpr,StringTemplate,IStringTemplateWriter,StringTemplate>> templateApplicators]
@init
{
-	Map argumentContext = null;
+	IDictionary argumentContext = null;
}
:	^(	TEMPLATE
(	ID args=. // don't eval argList now; must re-eval each iteration
diff --git a/Antlr3.StringTemplate/Language/Group.g3 b/Antlr3.StringTemplate/Language/Group.g3
index 2f57f9f..db611ff 100644
--- a/Antlr3.StringTemplate/Language/Group.g3
+++ b/Antlr3.StringTemplate/Language/Group.g3
@@ -113,7 +113,7 @@ KWDEFAULT = 'default';
*/

using HashMap = System.Collections.Hashtable;
-using Map = System.Collections.IDictionary;
+using IDictionary = System.Collections.IDictionary;
}

@lexer::namespace {Antlr3.ST.Language}
@@ -138,7 +138,7 @@ this._group = g;
template[StringTemplateGroup g]
@init
{
-	Map formalArgs = null;
+	IDictionary formalArgs = null;
StringTemplate st = null;
bool ignore = false;
string templateName=null;
@@ -254,22 +254,22 @@ mapdef[StringTemplateGroup g]
}
;

-map returns [Map mapping=new HashMap()]
+map returns [IDictionary mapping=new HashMap()]
:   LBRACK mapPairs[mapping] RBRACK
;

-mapPairs [Map mapping]
+mapPairs [IDictionary mapping]
:	keyValuePair[mapping] (COMMA keyValuePair[mapping])*
(COMMA defaultValuePair[mapping])?
|	defaultValuePair[mapping]
;

-defaultValuePair[Map mapping]
+defaultValuePair[IDictionary mapping]
:	'default' COLON v=keyValue
{mapping[ASTExpr.DefaultMapValueName] = $v.value;}
;

-keyValuePair[Map mapping]
+keyValuePair[IDictionary mapping]
:	key=STRING COLON v=keyValue {mapping[$key.text] = $v.value;}
;

diff --git a/Antlr3/Grammars/ANTLR.g3 b/Antlr3/Grammars/ANTLR.g3
index fe30dfe..7626672 100644
--- a/Antlr3/Grammars/ANTLR.g3
+++ b/Antlr3/Grammars/ANTLR.g3
@@ -183,6 +183,7 @@ using Grammar = Antlr3.Tool.Grammar;
using GrammarAST = Antlr3.Tool.GrammarAST;
using GrammarType = Antlr3.Tool.GrammarType;
using IntSet = Antlr3.Misc.IIntSet;
+using IDictionary = System.Collections.IDictionary;
using Rule = Antlr3.Tool.Rule;
using RuleType = Antlr3.Tool.RuleType;
using StringBuffer = System.Text.StringBuilder;
@@ -383,7 +384,7 @@ block
@init
{
GrammarAST save = currentBlockAST;
-	Map opts=null;
+	IDictionary opts=null;
}
:	(	lp=LPAREN
-> BLOCK[$lp,"BLOCK"]
diff --git a/Antlr3/Grammars/ANTLRTreePrinterHelper.cs b/Antlr3/Grammars/ANTLRTreePrinterHelper.cs
index a6ade19..fc8642b 100644
--- a/Antlr3/Grammars/ANTLRTreePrinterHelper.cs
+++ b/Antlr3/Grammars/ANTLRTreePrinterHelper.cs
@@ -45,7 +45,7 @@ namespace Antlr3.Grammars
protected bool showActions;
protected StringBuilder buf = new StringBuilder( 300 );

-        public ANTLRTreePrinter.block_return Block( GrammarAST t, bool forceParens )
+        private ANTLRTreePrinter.block_return Block( GrammarAST t, bool forceParens )
{
ANTLRTreePrinter other = new ANTLRTreePrinter(new CommonTreeNodeStream(t));
other.buf = buf;
diff --git a/Antlr3/Grammars/ActionTranslator.g3 b/Antlr3/Grammars/ActionTranslator.g3
index f736cee..1bc3dfe 100644
--- a/Antlr3/Grammars/ActionTranslator.g3
+++ b/Antlr3/Grammars/ActionTranslator.g3
@@ -496,7 +496,7 @@ LOCAL_ATTR
/**	$x::y	the only way to access the attributes within a dynamic scope
* 			regardless of whether or not you are in the defining rule.
*
- * 			scope Symbols { List names; }
+ * 			scope Symbols { List&lt;object&gt; names; }
* 			r
* 			scope {int i;}
* 			scope Symbols;
diff --git a/Antlr3/Grammars/AssignTokenTypesWalker.g3 b/Antlr3/Grammars/AssignTokenTypesWalker.g3
index be43fbb..e09db7a 100644
--- a/Antlr3/Grammars/AssignTokenTypesWalker.g3
+++ b/Antlr3/Grammars/AssignTokenTypesWalker.g3
@@ -131,8 +131,7 @@ using Antlr3.Tool;

using BitSet = Antlr.Runtime.BitSet;
using DFA = Antlr.Runtime.DFA;
-using HashMap = System.Collections.Generic.Dictionary<object, object>;
-using Map = System.Collections.IDictionary;
+using IDictionary = System.Collections.IDictionary;
}

public
@@ -164,11 +163,11 @@ attrScope
:	^( 'scope' ID ( ^(AMPERSAND .*) )* ACTION )
;

-optionsSpec returns [Map opts=new HashMap()]
+optionsSpec returns [IDictionary opts = new Dictionary<object, object>()]
:	^( OPTIONS (option[$opts])+ )
;

-option[Map opts]
+option[IDictionary opts]
:	^( ASSIGN ID optionValue )
{
string key = $ID.text;
diff --git a/Antlr3/Grammars/CodeGenTreeWalker.g3 b/Antlr3/Grammars/CodeGenTreeWalker.g3
index b40cf97..d46879a 100644
--- a/Antlr3/Grammars/CodeGenTreeWalker.g3
+++ b/Antlr3/Grammars/CodeGenTreeWalker.g3
@@ -86,6 +86,7 @@ using Antlr3.Tool;

using BitSet = Antlr.Runtime.BitSet;
using DFA = Antlr.Runtime.DFA;
+using IList = System.Collections.IList;
using StringTemplate = Antlr3.ST.StringTemplate;
using StringTemplateGroup = Antlr3.ST.StringTemplateGroup;
using TokenWithIndex = Antlr.Runtime.CommonToken;
@@ -455,7 +456,7 @@ exceptionGroup[StringTemplate ruleST]
exceptionHandler[StringTemplate ruleST]
:	^('catch' ARG_ACTION ACTION)
{
-			List chunks = generator.TranslateAction(currentRuleName,$ACTION);
+			IList chunks = generator.TranslateAction(currentRuleName,$ACTION);
$ruleST.SetAttribute("exceptions.{decl,action}",$ARG_ACTION.text,chunks);
}
;
@@ -463,7 +464,7 @@ exceptionHandler[StringTemplate ruleST]
finallyClause[StringTemplate ruleST]
:	^('finally' ACTION)
{
-			List chunks = generator.TranslateAction(currentRuleName,$ACTION);
+			IList chunks = generator.TranslateAction(currentRuleName,$ACTION);
$ruleST.SetAttribute("finally",chunks);
}
;
@@ -813,7 +814,7 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
}

if ( $rarg!=null ) {
-				List args = generator.TranslateAction(currentRuleName,$rarg);
+				IList args = generator.TranslateAction(currentRuleName,$rarg);
$code.SetAttribute("args", args);
}
int i = ((TokenWithIndex)r.Token).TokenIndex;
@@ -865,7 +866,7 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
}
if ( $targ!=null )
{
-						List args = generator.TranslateAction(currentRuleName,$targ);
+						IList args = generator.TranslateAction(currentRuleName,$targ);
$code.SetAttribute("args", args);
}
}
@@ -1050,7 +1051,7 @@ rewrite returns [StringTemplate code=null]
^( r=REWRITE (pred=SEMPRED)? alt=rewrite_alternative )
{
rewriteBlockNestingLevel = OUTER_REWRITE_NESTING_LEVEL;
-				List predChunks = null;
+				IList predChunks = null;
if ( $pred!=null )
{
//predText = #pred.getText();
@@ -1265,7 +1266,7 @@ rewrite_atom[bool isRoot] returns [StringTemplate code=null]
$code.SetAttribute("terminalOptions",term.terminalOptions);
if ( $arg!=null )
{
-				List args = generator.TranslateAction(currentRuleName,$arg);
+				IList args = generator.TranslateAction(currentRuleName,$arg);
$code.SetAttribute("args", args);
}
$code.SetAttribute("elementIndex", ((TokenWithIndex)$start.Token).TokenIndex);
@@ -1347,7 +1348,7 @@ rewrite_atom[bool isRoot] returns [StringTemplate code=null]
{
// actions in rewrite rules yield a tree object
string actText = $ACTION.text;
-			List chunks = generator.TranslateAction(currentRuleName,$ACTION);
+			IList chunks = generator.TranslateAction(currentRuleName,$ACTION);
$code = templates.GetInstanceOf("rewriteNodeAction"+(isRoot?"Root":""));
$code.SetAttribute("action", chunks);
}
@@ -1370,7 +1371,7 @@ rewrite_template returns [StringTemplate code=null]
else if ( $ind!=null )
{ // must be \%({expr})(args)
$code = templates.GetInstanceOf("rewriteIndirectTemplate");
-					List chunks=generator.TranslateAction(currentRuleName,$ind);
+					IList chunks=generator.TranslateAction(currentRuleName,$ind);
$code.SetAttribute("expr", chunks);
}
}
@@ -1381,7 +1382,7 @@ rewrite_template returns [StringTemplate code=null]
// because actions like \%foo(name={\$ID.text}) aren't
// broken up yet into trees.
$a.outerAltNum = this.outerAltNum;
-						List chunks = generator.TranslateAction(currentRuleName,$a);
+						IList chunks = generator.TranslateAction(currentRuleName,$a);
$code.SetAttribute("args.{name,value}", $arg.text, chunks);
}
)

