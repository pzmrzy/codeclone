commit a530a908a409c0a9a5f7e62f94915aae5e593b21
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Wed Apr 13 13:29:45 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Wed Apr 13 13:29:45 2011 -0800

(C# 3) Encapsulate fields
System.Boolean always renders as "true" or "false"

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 8197]

diff --git a/Antlr3/Codegen/CodeGenerator.cs b/Antlr3/Codegen/CodeGenerator.cs
index d587aa8..33d4617 100644
--- a/Antlr3/Codegen/CodeGenerator.cs
+++ b/Antlr3/Codegen/CodeGenerator.cs
@@ -579,7 +579,7 @@ namespace Antlr3.Codegen
headerFileST = new StringTemplate( templates, string.Empty );
// it normally sees this from outputFile
headerFileST.Add("cyclicDFAs", null);
-                headerFileST.impl.name = "dummy-header-file";
+                headerFileST.impl.Name = "dummy-header-file";
}

bool filterMode = grammar.GetOption( "filter" ) != null &&
@@ -1071,7 +1071,7 @@ namespace Antlr3.Codegen
if ( iset.Intervals == null || iset.Intervals.Count == 0 )
{
StringTemplate emptyST = new StringTemplate( templates, "" );
-                emptyST.impl.name = "empty-set-expr";
+                emptyST.impl.Name = "empty-set-expr";
return emptyST;
}
string testSTName = "lookaheadTest";
@@ -1176,7 +1176,7 @@ namespace Antlr3.Codegen
// "define" literals arg
vocabFileST.Add("literals", null);
vocabFileST.Add("tokens", null);
-            vocabFileST.impl.name = "vocab-file";
+            vocabFileST.impl.Name = "vocab-file";
// make constants for the token names
foreach ( string tokenID in grammar.TokenIDs )
{
diff --git a/Antlr3/Tool/Rule.cs b/Antlr3/Tool/Rule.cs
index 14b5472..84525d7 100644
--- a/Antlr3/Tool/Rule.cs
+++ b/Antlr3/Tool/Rule.cs
@@ -288,11 +288,19 @@ namespace Antlr3.Tool
}
}

+        /** If a rule has no user-defined return values and nobody references
+         *  it's start/stop (predefined attributes), then there is no need to
+         *  define a struct; otherwise for now we assume a struct.  A rule also
+         *  has multiple return values if you are building trees or templates.
+         */
public bool HasMultipleReturnValues
{
get
{
-                return GetHasMultipleReturnValues();
+                return _referencedPredefinedRuleAttributes
+                    || Grammar.BuildAST
+                    || Grammar.BuildTemplate
+                    || (ReturnScope != null && ReturnScope.Attributes.Count > 1);
}
}

@@ -300,7 +308,10 @@ namespace Antlr3.Tool
{
get
{
-                return GetHasReturnValue();
+                return _referencedPredefinedRuleAttributes
+                    || Grammar.BuildAST
+                    || Grammar.BuildTemplate
+                    || (ReturnScope != null && ReturnScope.Attributes.Count > 0);
}
}

@@ -308,7 +319,8 @@ namespace Antlr3.Tool
{
get
{
-                return GetHasSingleReturnValue();
+                return !(_referencedPredefinedRuleAttributes || Grammar.BuildAST || Grammar.BuildTemplate)
+                    && (ReturnScope != null && ReturnScope.Attributes.Count == 1);
}
}

@@ -947,35 +959,6 @@ namespace Antlr3.Tool
return labelName;
}

-        /** If a rule has no user-defined return values and nobody references
-         *  it's start/stop (predefined attributes), then there is no need to
-         *  define a struct; otherwise for now we assume a struct.  A rule also
-         *  has multiple return values if you are building trees or templates.
-         */
-        public virtual bool GetHasMultipleReturnValues()
-        {
-            return
-                _referencedPredefinedRuleAttributes || Grammar.BuildAST ||
-                Grammar.BuildTemplate ||
-                ( ReturnScope != null && ReturnScope.Attributes.Count > 1 );
-        }
-
-        public virtual bool GetHasSingleReturnValue()
-        {
-            return
-                !( _referencedPredefinedRuleAttributes || Grammar.BuildAST ||
-                  Grammar.BuildTemplate ) &&
-                                           ( ReturnScope != null && ReturnScope.Attributes.Count == 1 );
-        }
-
-        public virtual bool GetHasReturnValue()
-        {
-            return
-                _referencedPredefinedRuleAttributes || Grammar.BuildAST ||
-                Grammar.BuildTemplate ||
-                ( ReturnScope != null && ReturnScope.Attributes.Count > 0 );
-        }
-
public virtual string GetSingleValueReturnType()
{
if ( ReturnScope != null && ReturnScope.Attributes.Count == 1 )
diff --git a/Antlr4.StringTemplate.Visualizer/Extensions/ListExtensions.cs b/Antlr4.StringTemplate.Visualizer/Extensions/ListExtensions.cs
index b20a684..789dc13 100644
--- a/Antlr4.StringTemplate.Visualizer/Extensions/ListExtensions.cs
+++ b/Antlr4.StringTemplate.Visualizer/Extensions/ListExtensions.cs
@@ -167,7 +167,7 @@ namespace Antlr4.StringTemplate.Visualizer.Extensions
if (_template.impl == null)
return _template.ToString();

-                return _template.impl.template;
+                return _template.impl.Template;
}
}
}
diff --git a/Antlr4.StringTemplate.Visualizer/TemplateVisualizerFrame.xaml.cs b/Antlr4.StringTemplate.Visualizer/TemplateVisualizerFrame.xaml.cs
index 5794a92..a208cf4 100644
--- a/Antlr4.StringTemplate.Visualizer/TemplateVisualizerFrame.xaml.cs
+++ b/Antlr4.StringTemplate.Visualizer/TemplateVisualizerFrame.xaml.cs
@@ -125,8 +125,8 @@ namespace Antlr4.StringTemplate.Visualizer
if (node == null)
return;

-            IToken a = _currentFrame.Template.impl.tokens.Get(node.TokenStartIndex);
-            IToken b = _currentFrame.Template.impl.tokens.Get(node.TokenStopIndex);
+            IToken a = _currentFrame.Template.impl.Tokens.Get(node.TokenStartIndex);
+            IToken b = _currentFrame.Template.impl.Tokens.Get(node.TokenStopIndex);
if (a == null || b == null)
return;

@@ -220,11 +220,11 @@ namespace Antlr4.StringTemplate.Visualizer
UpdateStack();
UpdateAttributes();
viewModel.Bytecode = _currentFrame.Template.impl.Disassemble();
-            TemplateTextBox.Document = new FlowDocument(new Paragraph(new Run(_currentFrame.Template.impl.template)
+            TemplateTextBox.Document = new FlowDocument(new Paragraph(new Run(_currentFrame.Template.impl.Template)
{
FontFamily = new FontFamily("Consolas")
}));
-            viewModel.Ast = _currentFrame.Template.impl.ast;
+            viewModel.Ast = _currentFrame.Template.impl.Ast;

#region new stuff

diff --git a/Antlr4.StringTemplate/Compiler/BytecodeDisassembler.cs b/Antlr4.StringTemplate/Compiler/BytecodeDisassembler.cs
index b2e50a0..411ed80 100644
--- a/Antlr4.StringTemplate/Compiler/BytecodeDisassembler.cs
+++ b/Antlr4.StringTemplate/Compiler/BytecodeDisassembler.cs
@@ -197,7 +197,7 @@ namespace Antlr4.StringTemplate.Compiler
{
if (interval != null)
{
-                    string chunk = code.template.Substring(interval.Start, interval.Length);
+                    string chunk = code.Template.Substring(interval.Start, interval.Length);
buf.AppendLine(string.Format("{0:0000}: {1}\t\"{2}\"", addr, interval, chunk));
}
addr++;
diff --git a/Antlr4.StringTemplate/Compiler/CodeGenerator.g3 b/Antlr4.StringTemplate/Compiler/CodeGenerator.g3
index 5bb7088..a70f39b 100644
--- a/Antlr4.StringTemplate/Compiler/CodeGenerator.g3
+++ b/Antlr4.StringTemplate/Compiler/CodeGenerator.g3
@@ -60,7 +60,7 @@ scope {
$impl.AddArgument(new FormalArgument("i"));
$impl.AddArgument(new FormalArgument("i0"));
}
-	$impl.template = _template; // always forget the entire template; char indexes are relative to it
+	$impl.Template = _template; // always forget the entire template; char indexes are relative to it
}
:	chunk
{ // finish off the CompiledTemplate result
@@ -109,9 +109,9 @@ region[CommonTree indent] returns [string name]
template[$name,null]
{
CompiledTemplate sub = $template.impl;
-	        sub.isRegion = true;
-	        sub.regionDefType = Template.RegionType.Embedded;
-			sub.templateDefStartToken = $ID.Token;
+	        sub.IsRegion = true;
+	        sub.RegionDefType = Template.RegionType.Embedded;
+			sub.TemplateDefStartToken = $ID.Token;
outermostImpl.AddImplicitlyDefinedTemplate(sub);
emit2($start, Bytecode.INSTR_NEW, $region.name, 0);
emit($start, Bytecode.INSTR_WRITE);
@@ -130,11 +130,11 @@ subtemplate returns [string name, int nargs]
template[$name,args]
{
CompiledTemplate sub = $template.impl;
-			sub.isAnonSubtemplate = true;
-			sub.templateDefStartToken = $SUBTEMPLATE.Token;
-			sub.ast = $SUBTEMPLATE;
-			sub.ast.SetUnknownTokenBoundaries();
-			sub.tokens = input.TokenStream;
+			sub.IsAnonSubtemplate = true;
+			sub.TemplateDefStartToken = $SUBTEMPLATE.Token;
+			sub.Ast = $SUBTEMPLATE;
+			sub.Ast.SetUnknownTokenBoundaries();
+			sub.Tokens = input.TokenStream;
outermostImpl.AddImplicitlyDefinedTemplate(sub);
}
)
@@ -274,10 +274,10 @@ includeExpr
|	^(INCLUDE_REGION ID)		{
CompiledTemplate impl =
TemplateCompiler.DefineBlankRegion(outermostImpl, $ID.Token);
-									emit2($INCLUDE_REGION,Bytecode.INSTR_NEW,impl.name,0);
+									emit2($INCLUDE_REGION,Bytecode.INSTR_NEW,impl.Name,0);
}
|	^(INCLUDE_SUPER_REGION ID)	{
-									string mangled = TemplateGroup.GetMangledRegionName(outermostImpl.name, $ID.Text);
+									string mangled = TemplateGroup.GetMangledRegionName(outermostImpl.Name, $ID.Text);
emit2($INCLUDE_SUPER_REGION,Bytecode.INSTR_SUPER_NEW,mangled,0);
}
|	primary
diff --git a/Antlr4.StringTemplate/Compiler/CompilationState.cs b/Antlr4.StringTemplate/Compiler/CompilationState.cs
index a51416c..2512f3e 100644
--- a/Antlr4.StringTemplate/Compiler/CompilationState.cs
+++ b/Antlr4.StringTemplate/Compiler/CompilationState.cs
@@ -61,7 +61,7 @@ namespace Antlr4.StringTemplate.Compiler
{
this.errMgr = errMgr;
this.tokens = tokens;
-            impl.name = name;
+            impl.Name = name;
}

public virtual int DefineString(string s)
diff --git a/Antlr4.StringTemplate/Compiler/CompiledTemplate.cs b/Antlr4.StringTemplate/Compiler/CompiledTemplate.cs
index c95a8d5..e79b480 100644
--- a/Antlr4.StringTemplate/Compiler/CompiledTemplate.cs
+++ b/Antlr4.StringTemplate/Compiler/CompiledTemplate.cs
@@ -48,29 +48,29 @@ namespace Antlr4.StringTemplate.Compiler
*/
public class CompiledTemplate
{
-        public string name;
+        private string _name;

/** The original, immutable pattern (not really used again after
*  initial "compilation"). Useful for debugging.  Even for
*  subtemplates, this is entire overall template.
*/
-        public string template;
+        private string _template;

/** The token that begins template definition; could be &lt;@r&gt; of region. */
-        public IToken templateDefStartToken;
+        private IToken _templateDefStartToken;

/** Overall token stream for template (debug only) */
-        public ITokenStream tokens;
+        private ITokenStream _tokens;

/** How do we interpret syntax of template? (debug only) */
-        public CommonTree ast;
+        private CommonTree _ast;

-        private List<FormalArgument> formalArguments;
+        private List<FormalArgument> _formalArguments;

-        public bool hasFormalArgs;
+        private bool _hasFormalArgs;

/** A list of all regions and subtemplates */
-        public List<CompiledTemplate> implicitlyDefinedTemplates;
+        private List<CompiledTemplate> implicitlyDefinedTemplates;

private int _numberOfArgsWithDefaultValues;

@@ -83,7 +83,7 @@ namespace Antlr4.StringTemplate.Compiler
/** Does this template come from a &lt;@region&gt;...&lt;@end&gt; embedded in
*  another template?
*/
-        public bool isRegion;
+        private bool isRegion;

/** If someone refs &lt;@r()&gt; in template t, an implicit
*
@@ -93,9 +93,9 @@ namespace Antlr4.StringTemplate.Compiler
*  own.  We need to prevent more than one manual def though.  Between
*  this var and isEmbeddedRegion we can determine these cases.
*/
-        public Template.RegionType regionDefType;
+        private Template.RegionType regionDefType;

-        public bool isAnonSubtemplate; // {...}
+        private bool isAnonSubtemplate; // {...}

public string[] strings;     // string operands of instructions
public byte[] instrs;        // byte-addressable code memory.
@@ -106,20 +106,111 @@ namespace Antlr4.StringTemplate.Compiler
{
instrs = new byte[TemplateCompiler.InitialCodeSize];
sourceMap = new Interval[TemplateCompiler.InitialCodeSize];
-            template = string.Empty;
+            _template = string.Empty;
+        }
+
+        public string Name
+        {
+            get
+            {
+                return _name;
+            }
+
+            set
+            {
+                _name = value;
+            }
+        }
+
+        public string Template
+        {
+            get
+            {
+                return _template;
+            }
+
+            set
+            {
+                _template = value;
+            }
+        }
+
+        public IToken TemplateDefStartToken
+        {
+            get
+            {
+                return _templateDefStartToken;
+            }
+
+            set
+            {
+                _templateDefStartToken = value;
+            }
+        }
+
+        public ITokenStream Tokens
+        {
+            get
+            {
+                return _tokens;
+            }
+
+            set
+            {
+                _tokens = value;
+            }
+        }
+
+        public CommonTree Ast
+        {
+            get
+            {
+                return _ast;
+            }
+
+            set
+            {
+                _ast = value;
+            }
}

public List<FormalArgument> FormalArguments
{
get
{
-                return formalArguments;
+                return _formalArguments;
}

set
{
-                formalArguments = value;
-                _numberOfArgsWithDefaultValues = (formalArguments != null) ? formalArguments.Count(i => i.DefaultValueToken != null) : 0;
+                _formalArguments = value;
+                _numberOfArgsWithDefaultValues = (_formalArguments != null) ? _formalArguments.Count(i => i.DefaultValueToken != null) : 0;
+            }
+        }
+
+        public bool HasFormalArgs
+        {
+            get
+            {
+                return _hasFormalArgs;
+            }
+
+            set
+            {
+                _hasFormalArgs = value;
+            }
+        }
+
+        public List<CompiledTemplate> ImplicitlyDefinedTemplates
+        {
+            get
+            {
+                return implicitlyDefinedTemplates;
+            }
+
+            set
+            {
+                implicitlyDefinedTemplates = value;
}
}

@@ -136,12 +227,51 @@ namespace Antlr4.StringTemplate.Compiler
}
}

+        public bool IsRegion
+        {
+            get
+            {
+                return isRegion;
+            }
+
+            set
+            {
+                isRegion = value;
+            }
+        }
+
+        public Template.RegionType RegionDefType
+        {
+            get
+            {
+                return regionDefType;
+            }
+
+            set
+            {
+                regionDefType = value;
+            }
+        }
+
+        public bool IsAnonSubtemplate
+        {
+            get
+            {
+                return isAnonSubtemplate;
+            }
+
+            set
+            {
+                isAnonSubtemplate = value;
+            }
+        }
+
public virtual string TemplateSource
{
get
{
Interval r = TemplateRange;
-                return template.Substring(r.Start, r.End - r.Start);
+                return Template.Substring(r.Start, r.End - r.Start);
}
}

@@ -149,7 +279,7 @@ namespace Antlr4.StringTemplate.Compiler
{
get
{
-                if (isAnonSubtemplate)
+                if (IsAnonSubtemplate)
{
Interval start = sourceMap[0];
Interval stop = null;
@@ -166,7 +296,7 @@ namespace Antlr4.StringTemplate.Compiler
return Interval.FromBounds(start.Start, stop.End);
}

-                return new Interval(0, template.Length);
+                return new Interval(0, Template.Length);
}
}

@@ -190,10 +320,10 @@ namespace Antlr4.StringTemplate.Compiler

public virtual void AddImplicitlyDefinedTemplate(CompiledTemplate sub)
{
-            if (implicitlyDefinedTemplates == null)
-                implicitlyDefinedTemplates = new List<CompiledTemplate>();
+            if (ImplicitlyDefinedTemplates == null)
+                ImplicitlyDefinedTemplates = new List<CompiledTemplate>();

-            implicitlyDefinedTemplates.Add(sub);
+            ImplicitlyDefinedTemplates.Add(sub);
}

public virtual void DefineArgumentDefaultValueTemplates(TemplateGroup group)
@@ -211,7 +341,7 @@ namespace Antlr4.StringTemplate.Compiler
TemplateCompiler c2 = new TemplateCompiler(group);
string defArgTemplate = Utility.Strip(fa.DefaultValueToken.Text, 1);
fa.CompiledDefaultValue = c2.Compile(group.FileName, argSTname, null, defArgTemplate, fa.DefaultValueToken);
-                        fa.CompiledDefaultValue.name = argSTname;
+                        fa.CompiledDefaultValue.Name = argSTname;
fa.CompiledDefaultValue.DefineImplicitlyDefinedTemplates(group);
}
else if (fa.DefaultValueToken.Type == GroupParser.STRING)
@@ -229,7 +359,7 @@ namespace Antlr4.StringTemplate.Compiler

public virtual void DefineFormalArguments(IEnumerable<FormalArgument> args)
{
-            hasFormalArgs = true; // even if no args; it's formally defined
+            HasFormalArgs = true; // even if no args; it's formally defined
if (args == null)
{
FormalArguments = null;
@@ -255,11 +385,11 @@ namespace Antlr4.StringTemplate.Compiler

public virtual void DefineImplicitlyDefinedTemplates(TemplateGroup group)
{
-            if (implicitlyDefinedTemplates != null)
+            if (ImplicitlyDefinedTemplates != null)
{
-                foreach (CompiledTemplate sub in implicitlyDefinedTemplates)
+                foreach (CompiledTemplate sub in ImplicitlyDefinedTemplates)
{
-                    group.RawDefineTemplate(sub.name, sub, sub.templateDefStartToken);
+                    group.RawDefineTemplate(sub.Name, sub, sub.TemplateDefStartToken);
sub.DefineImplicitlyDefinedTemplates(group);
}
}
diff --git a/Antlr4.StringTemplate/Compiler/TemplateCompiler.cs b/Antlr4.StringTemplate/Compiler/TemplateCompiler.cs
index ac4b333..2fe55a7 100644
--- a/Antlr4.StringTemplate/Compiler/TemplateCompiler.cs
+++ b/Antlr4.StringTemplate/Compiler/TemplateCompiler.cs
@@ -126,7 +126,7 @@ namespace Antlr4.StringTemplate.Compiler
public virtual CompiledTemplate Compile(string template)
{
CompiledTemplate code = Compile(null, null, null, template, null);
-            code.hasFormalArgs = false;
+            code.HasFormalArgs = false;
return code;
}

@@ -134,7 +134,7 @@ namespace Antlr4.StringTemplate.Compiler
public virtual CompiledTemplate Compile(string name, string template)
{
CompiledTemplate code = Compile(null, name, null, template, null);
-            code.hasFormalArgs = false;
+            code.HasFormalArgs = false;
return code;
}

@@ -183,10 +183,10 @@ namespace Antlr4.StringTemplate.Compiler
{
impl2 = gen.template(name, args);
impl2.NativeGroup = Group;
-                impl2.template = template;
-                impl2.ast = r.Tree;
-                impl2.ast.SetUnknownTokenBoundaries();
-                impl2.tokens = tokens;
+                impl2.Template = template;
+                impl2.Ast = r.Tree;
+                impl2.Ast.SetUnknownTokenBoundaries();
+                impl2.Tokens = tokens;
}
catch (RecognitionException re)
{
@@ -203,13 +203,13 @@ namespace Antlr4.StringTemplate.Compiler
if (nameToken == null)
throw new ArgumentNullException("nameToken");

-            string outermostTemplateName = outermostImpl.name;
+            string outermostTemplateName = outermostImpl.Name;
string mangled = TemplateGroup.GetMangledRegionName(outermostTemplateName, nameToken.Text);
CompiledTemplate blank = new CompiledTemplate();
-            blank.isRegion = true;
-            blank.templateDefStartToken = nameToken;
-            blank.regionDefType = Template.RegionType.Implicit;
-            blank.name = mangled;
+            blank.IsRegion = true;
+            blank.TemplateDefStartToken = nameToken;
+            blank.RegionDefType = Template.RegionType.Implicit;
+            blank.Name = mangled;
outermostImpl.AddImplicitlyDefinedTemplate(blank);
return blank;
}
diff --git a/Antlr4.StringTemplate/Debug/EvalExprEvent.cs b/Antlr4.StringTemplate/Debug/EvalExprEvent.cs
index 966491e..86b87d3 100644
--- a/Antlr4.StringTemplate/Debug/EvalExprEvent.cs
+++ b/Antlr4.StringTemplate/Debug/EvalExprEvent.cs
@@ -45,7 +45,7 @@ namespace Antlr4.StringTemplate.Debug
{
this._sourceInterval = sourceInterval;
if (_sourceInterval != null)
-                expr = frame.Template.impl.template.Substring(_sourceInterval.Start, _sourceInterval.Length);
+                expr = frame.Template.impl.Template.Substring(_sourceInterval.Start, _sourceInterval.Length);
}

public Interval SourceInterval
diff --git a/Antlr4.StringTemplate/Interpreter.cs b/Antlr4.StringTemplate/Interpreter.cs
index bd7b266..58ed690 100644
--- a/Antlr4.StringTemplate/Interpreter.cs
+++ b/Antlr4.StringTemplate/Interpreter.cs
@@ -658,7 +658,7 @@ namespace Antlr4.StringTemplate
current_ip,
ErrorType.ARGUMENT_COUNT_MISMATCH,
nargs,
-                                    st.impl.name,
+                                    st.impl.Name,
nformalArgs);
}

@@ -683,7 +683,7 @@ namespace Antlr4.StringTemplate
nformalArgs = st.impl.FormalArguments.Count;
int firstArg = sp - (nargs - 1);
int numToStore = Math.Min(nargs, nformalArgs);
-            if (st.impl.isAnonSubtemplate)
+            if (st.impl.IsAnonSubtemplate)
nformalArgs -= predefinedAnonSubtemplateAttributes.Count;

if (nargs < (nformalArgs - st.impl.NumberOfArgsWithDefaultValues) ||
@@ -693,7 +693,7 @@ namespace Antlr4.StringTemplate
current_ip,
ErrorType.ARGUMENT_COUNT_MISMATCH,
nargs,
-                                    st.impl.name,
+                                    st.impl.Name,
nformalArgs);
}

@@ -870,11 +870,22 @@ namespace Antlr4.StringTemplate
if (options != null)
formatString = options[(int)RenderOption.Format];
IAttributeRenderer r = group.GetAttributeRenderer(o.GetType());
+
string v;
if (r != null)
+            {
v = r.ToString(o, formatString, culture);
+            }
else
-                v = o.ToString();
+            {
+                if (o is bool)
+                    v = (bool)o ? "true" : "false";
+                else if (o is bool? && ((bool?)o).HasValue)
+                    v = ((bool?)o).Value ? "true" : "false";
+                else
+                    v = o.ToString();
+            }
+
int n;
if (options != null && options[(int)RenderOption.Wrap] != null)
{
@@ -884,6 +895,7 @@ namespace Antlr4.StringTemplate
{
n = @out.Write(v);
}
+
return n;
}

@@ -920,7 +932,7 @@ namespace Antlr4.StringTemplate
if (st != null)
{
SetFirstArgument(frame, st, attr);
-                    if (st.impl.isAnonSubtemplate)
+                    if (st.impl.IsAnonSubtemplate)
{
st.RawSetAttribute("i0", 0);
st.RawSetAttribute("i", 1);
@@ -955,7 +967,7 @@ namespace Antlr4.StringTemplate
Template proto = prototypes[templateIndex];
Template st = group.CreateStringTemplateInternally(proto);
SetFirstArgument(frame, st, iterValue);
-                if (st.impl.isAnonSubtemplate)
+                if (st.impl.IsAnonSubtemplate)
{
st.RawSetAttribute("i0", i0);
st.RawSetAttribute("i", i);
@@ -991,7 +1003,7 @@ namespace Antlr4.StringTemplate
int numExprs = exprs.Count;
CompiledTemplate code = prototype.impl;
List<FormalArgument> formalArguments = code.FormalArguments;
-            if (!code.hasFormalArgs || formalArguments == null)
+            if (!code.HasFormalArgs || formalArguments == null)
{
_errorManager.RuntimeError(frame, current_ip, ErrorType.MISSING_FORMAL_ARGUMENTS);
return null;
@@ -1052,7 +1064,7 @@ namespace Antlr4.StringTemplate
{
if (st.impl.FormalArguments == null)
{
-                _errorManager.RuntimeError(frame, current_ip, ErrorType.ARGUMENT_COUNT_MISMATCH, 1, st.impl.name, 0);
+                _errorManager.RuntimeError(frame, current_ip, ErrorType.ARGUMENT_COUNT_MISMATCH, 1, st.impl.Name, 0);
return;
}

@@ -1472,8 +1484,8 @@ namespace Antlr4.StringTemplate
BytecodeDisassembler dis = new BytecodeDisassembler(self.impl);
StringBuilder buf = new StringBuilder();
dis.DisassembleInstruction(buf, ip);
-            string name = self.impl.name + ":";
-            if (self.impl.name == Template.UnknownName)
+            string name = self.impl.Name + ":";
+            if (self.impl.Name == Template.UnknownName)
name = string.Empty;

tr.Append(string.Format("{0,-40}", name + buf));
@@ -1503,7 +1515,7 @@ namespace Antlr4.StringTemplate
if (((Template)o).impl == null)
tr.Append("bad-template()");
else
-                    tr.Append(" " + ((Template)o).impl.name + "()");
+                    tr.Append(" " + ((Template)o).impl.Name + "()");
return;
}
o = ConvertAnythingIteratableToIterator(frame, o);
diff --git a/Antlr4.StringTemplate/Misc/TemplateRuntimeMessage.cs b/Antlr4.StringTemplate/Misc/TemplateRuntimeMessage.cs
index f448862..a82ae2a 100644
--- a/Antlr4.StringTemplate/Misc/TemplateRuntimeMessage.cs
+++ b/Antlr4.StringTemplate/Misc/TemplateRuntimeMessage.cs
@@ -107,7 +107,7 @@ namespace Antlr4.StringTemplate.Misc

// get left edge and get line/col
int i = interval.Start;
-            Coordinate loc = Utility.GetLineCharPosition(Self.impl.template, i);
+            Coordinate loc = Utility.GetLineCharPosition(Self.impl.Template, i);
return loc.ToString();
}

diff --git a/Antlr4.StringTemplate/Template.cs b/Antlr4.StringTemplate/Template.cs
index ed149bf..ed09441 100644
--- a/Antlr4.StringTemplate/Template.cs
+++ b/Antlr4.StringTemplate/Template.cs
@@ -165,8 +165,8 @@ namespace Antlr4.StringTemplate
groupThatCreatedThisInstance = group;
impl = groupThatCreatedThisInstance.Compile(group.FileName, null,
null, template, null);
-            impl.hasFormalArgs = false;
-            impl.name = UnknownName;
+            impl.HasFormalArgs = false;
+            impl.Name = UnknownName;
impl.DefineImplicitlyDefinedTemplates(groupThatCreatedThisInstance);
}

@@ -250,7 +250,7 @@ namespace Antlr4.StringTemplate
}

FormalArgument arg = null;
-            if (impl.hasFormalArgs)
+            if (impl.HasFormalArgs)
{
arg = impl.TryGetFormalArgument(name);
if (arg == null)
@@ -349,7 +349,7 @@ namespace Antlr4.StringTemplate
{
if (impl.FormalArguments == null)
{
-                if (impl.hasFormalArgs)
+                if (impl.HasFormalArgs)
throw new ArgumentException("no such attribute: " + name);

return;
@@ -471,7 +471,7 @@ namespace Antlr4.StringTemplate
{
get
{
-                return impl.name;
+                return impl.Name;
}
}

@@ -479,7 +479,7 @@ namespace Antlr4.StringTemplate
{
get
{
-                return impl.isAnonSubtemplate;
+                return impl.IsAnonSubtemplate;
}
}

@@ -603,7 +603,7 @@ namespace Antlr4.StringTemplate
args = string.Join(",", impl.FormalArguments.Select(i => i.Name).ToArray());

string name = Name;
-            if (this.impl.isRegion)
+            if (this.impl.IsRegion)
name = "@" + TemplateGroup.GetUnmangledTemplateName(name);

return string.Format("{0}({1})", name, args);
diff --git a/Antlr4.StringTemplate/TemplateGroup.cs b/Antlr4.StringTemplate/TemplateGroup.cs
index d1fcef7..c35f17a 100644
--- a/Antlr4.StringTemplate/TemplateGroup.cs
+++ b/Antlr4.StringTemplate/TemplateGroup.cs
@@ -296,8 +296,8 @@ namespace Antlr4.StringTemplate
CompiledTemplate impl = Compile(FileName, null, null, template, templateToken);
Template st = CreateStringTemplateInternally(impl);
st.Group = this;
-            st.impl.hasFormalArgs = false;
-            st.impl.name = Template.UnknownName;
+            st.impl.HasFormalArgs = false;
+            st.impl.Name = Template.UnknownName;
st.impl.DefineImplicitlyDefinedTemplates(this);
return st;
}
@@ -429,7 +429,7 @@ namespace Antlr4.StringTemplate
template = Utility.TrimOneTrailingNewline(template);
// compile, passing in templateName as enclosing name for any embedded regions
CompiledTemplate code = Compile(FileName, templateName, args, template, templateToken);
-            code.name = templateName;
+            code.Name = templateName;
RawDefineTemplate(templateName, code, nameT);
code.DefineArgumentDefaultValueTemplates(this);
code.DefineImplicitlyDefinedTemplates(this); // define any anonymous subtemplates
@@ -468,10 +468,10 @@ namespace Antlr4.StringTemplate
return new CompiledTemplate();
}

-            code.name = mangled;
-            code.isRegion = true;
-            code.regionDefType = Template.RegionType.Explicit;
-            code.templateDefStartToken = regionT;
+            code.Name = mangled;
+            code.IsRegion = true;
+            code.RegionDefType = Template.RegionType.Explicit;
+            code.TemplateDefStartToken = regionT;

RawDefineTemplate(mangled, code, regionT);
code.DefineArgumentDefaultValueTemplates(this);
@@ -511,20 +511,20 @@ namespace Antlr4.StringTemplate
templates.TryGetValue(name, out prev);
if (prev != null)
{
-                if (!prev.isRegion)
+                if (!prev.IsRegion)
{
ErrorManager.CompiletimeError(ErrorType.TEMPLATE_REDEFINITION, null, defT);
return;
}

-                if (prev.isRegion)
+                if (prev.IsRegion)
{
-                    if (code.regionDefType != Template.RegionType.Implicit && prev.regionDefType == Template.RegionType.Embedded)
+                    if (code.RegionDefType != Template.RegionType.Implicit && prev.RegionDefType == Template.RegionType.Embedded)
{
ErrorManager.CompiletimeError(ErrorType.EMBEDDED_REGION_REDEFINITION, null, defT, GetUnmangledTemplateName(name));
return;
}
-                    else if (code.regionDefType == Template.RegionType.Implicit && prev.regionDefType == Template.RegionType.Explicit)
+                    else if (code.RegionDefType == Template.RegionType.Implicit && prev.RegionDefType == Template.RegionType.Explicit)
{
ErrorManager.CompiletimeError(ErrorType.REGION_REDEFINITION, null, defT, GetUnmangledTemplateName(name));
return;
@@ -533,7 +533,7 @@ namespace Antlr4.StringTemplate
}

code.NativeGroup = this;
-            code.templateDefStartToken = defT;
+            code.TemplateDefStartToken = defT;
templates[name] = code;
}

@@ -766,7 +766,7 @@ namespace Antlr4.StringTemplate
{
string name = n;
CompiledTemplate c = templates[name];
-                if (c.isAnonSubtemplate || c == NotFoundTemplate)
+                if (c.IsAnonSubtemplate || c == NotFoundTemplate)
continue;

int slash = name.LastIndexOf('/');
@@ -778,7 +778,7 @@ namespace Antlr4.StringTemplate

buf.Append(')');
buf.Append(" ::= <<" + Environment.NewLine);
-                buf.Append(c.template + Environment.NewLine);
+                buf.Append(c.Template + Environment.NewLine);
buf.Append(">>" + Environment.NewLine);
}

diff --git a/Antlr4.Test.StringTemplate/TestOptions.cs b/Antlr4.Test.StringTemplate/TestOptions.cs
index de8a4a9..6703ee3 100644
--- a/Antlr4.Test.StringTemplate/TestOptions.cs
+++ b/Antlr4.Test.StringTemplate/TestOptions.cs
@@ -61,7 +61,7 @@ namespace Antlr4.Test.StringTemplate
TemplateGroup group = new TemplateGroup();
group.DefineTemplate("test", "hi <name; separator= \", \">!", new string[] { "name" });
Template st = group.GetInstanceOf("test");
-            Console.WriteLine(st.impl.ast.ToStringTree());
+            Console.WriteLine(st.impl.Ast.ToStringTree());
st.Add("name", "Ter");
st.Add("name", "Tom");
st.Add("name", "Sumana");

