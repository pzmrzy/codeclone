commit 2440e5d3c384b533f3215372971edcebbb7dafd3
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Tue Mar 17 07:32:38 2009 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Tue Mar 17 07:32:38 2009 -0800

C# Port:
* Use DynamicMethod in StringTemplate to cache property accessors and constructor calls

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 5900]

diff --git a/Antlr3.StringTemplate/Language/ASTExpr.cs b/Antlr3.StringTemplate/Language/ASTExpr.cs
index e17ee13..a6ccfad 100644
--- a/Antlr3.StringTemplate/Language/ASTExpr.cs
+++ b/Antlr3.StringTemplate/Language/ASTExpr.cs
@@ -93,7 +93,7 @@ namespace Antlr3.ST.Language
"wrap"
};

-        static readonly Dictionary<Type, Dictionary<string, MemberInfo>> _memberAccessors = new Dictionary<Type, Dictionary<string, MemberInfo>>();
+        static readonly Dictionary<Type, Dictionary<string, Func<object, object>>> _memberAccessors = new Dictionary<Type, Dictionary<string, Func<object, object>>>();

protected internal ITree exprTree = null;

@@ -504,22 +504,22 @@ namespace Antlr3.ST.Language
}

[MethodImpl( MethodImplOptions.Synchronized )]
-        static MemberInfo FindMember( Type type, string name )
+        static Func<object, object> FindMember( Type type, string name )
{
if ( type == null || name == null )
throw new ArgumentNullException();

-            Dictionary<string, MemberInfo> members;
-            MemberInfo member = null;
+            Dictionary<string, Func<object, object>> members;
+            Func<object, object> accessor = null;

if ( _memberAccessors.TryGetValue( type, out members ) )
{
-                if ( members.TryGetValue( name, out member ) )
-                    return member;
+                if ( members.TryGetValue( name, out accessor ) )
+                    return accessor;
}
else
{
-                members = new Dictionary<string, MemberInfo>();
+                members = new Dictionary<string, Func<object, object>>();
_memberAccessors[type] = members;
}

@@ -527,37 +527,79 @@ namespace Antlr3.ST.Language
string methodSuffix = char.ToUpperInvariant( name[0] ) + name.Substring( 1 );

// BEGIN ADDED FOR C#
-            if ( member == null )
+            MethodInfo method = null;
+            if ( method == null )
{
System.Reflection.PropertyInfo p = type.GetProperty( methodSuffix );
if ( p != null )
-                    member = p.GetGetMethod();
+                    method = p.GetGetMethod();
}
-            if ( member == null )
+            if ( method == null )
{
-                member = GetMethod( type, "Get" + methodSuffix );
+                method = GetMethod( type, "Get" + methodSuffix );
}
-            if ( member == null )
+            if ( method == null )
{
-                member = GetMethod( type, "Is" + methodSuffix );
+                method = GetMethod( type, "Is" + methodSuffix );
}
// END ADDED
-            if ( member == null )
+            if ( method == null )
{
-                member = GetMethod( type, "get" + methodSuffix );
+                method = GetMethod( type, "get" + methodSuffix );
}
-            if ( member == null )
+            if ( method == null )
{
-                member = GetMethod( type, "is" + methodSuffix );
+                method = GetMethod( type, "is" + methodSuffix );
}
-            if ( member == null )
+
+            if ( method != null )
+            {
+                accessor = BuildAccessor( method );
+            }
+            else
{
// try for a visible field
-                member = type.GetField( name );
+                FieldInfo field = type.GetField( name );
+                if ( field != null )
+                    accessor = BuildAccessor( field );
}

-            members[name] = member;
-            return member;
+            members[name] = accessor;
+            return accessor;
+        }
+
+        static Func<object, object> BuildAccessor( MethodInfo method )
+        {
+            System.Reflection.Emit.DynamicMethod dm = new System.Reflection.Emit.DynamicMethod( method.DeclaringType.Name + method.Name + "Accessor", typeof( object ), new Type[] { typeof( object ) }, method.DeclaringType );
+            var gen = dm.GetILGenerator();
+            gen.Emit( System.Reflection.Emit.OpCodes.Ldarg_0 );
+            gen.Emit( System.Reflection.Emit.OpCodes.Castclass, method.DeclaringType );
+
+            if ( method.IsVirtual && !method.IsFinal )
+                gen.EmitCall( System.Reflection.Emit.OpCodes.Callvirt, method, null );
+            else
+                gen.EmitCall( System.Reflection.Emit.OpCodes.Call, method, null );
+
+            if ( method.ReturnType.IsValueType )
+                gen.Emit( System.Reflection.Emit.OpCodes.Box, method.ReturnType );
+
+            gen.Emit( System.Reflection.Emit.OpCodes.Ret );
+            return (Func<object, object>)dm.CreateDelegate( typeof( Func<object, object> ) );
+        }
+
+        static Func<object, object> BuildAccessor( FieldInfo field )
+        {
+            System.Reflection.Emit.DynamicMethod dm = new System.Reflection.Emit.DynamicMethod( field.DeclaringType.Name + field.Name + "Accessor", typeof( object ), new Type[] { typeof( object ) }, field.DeclaringType );
+            var gen = dm.GetILGenerator();
+            gen.Emit( System.Reflection.Emit.OpCodes.Ldarg_0 );
+            gen.Emit( System.Reflection.Emit.OpCodes.Castclass, field.DeclaringType );
+            gen.Emit( System.Reflection.Emit.OpCodes.Ldfld, field );
+
+            if ( field.FieldType.IsValueType )
+                gen.Emit( System.Reflection.Emit.OpCodes.Box, field.FieldType );
+
+            gen.Emit( System.Reflection.Emit.OpCodes.Ret );
+            return (Func<object, object>)dm.CreateDelegate( typeof( Func<object, object> ) );
}

protected virtual object RawGetObjectProperty( StringTemplate self, object o, object property )
@@ -624,84 +666,29 @@ namespace Antlr3.ST.Language
return value;
}

-            // try getXXX and isXXX properties
-
-            // check cache
-            /*
-            Member cachedMember =
-                self.getGroup().getCachedClassProperty(c,propertyName);
-            if ( cachedMember!=null ) {
-                try {
-                    if ( cachedMember is Method ) {
-                        m = (Method)cachedMember;
-                        value = invokeMethod(m, o, value);
-                    }
-                    else {
-                        // must be a field
-                        Field f = (Field)cachedMember;
-                        value = accessField(f, o, value);
-                    }
-                }
-                catch (Exception e) {
-                    self.error("Can't get property "+propertyName+
-                        " from "+c.getName()+" instance", e);
-                }
-                return value;
-            }
-            */
-
string propertyName = (string)property;
-            MemberInfo member = FindMember( c, propertyName );
-            MethodInfo method = member as MethodInfo;
-            if ( method != null )
+            var accessor = FindMember( c, propertyName );
+            if ( accessor != null )
{
try
{
-                    value = InvokeMethod( method, o, value );
+                    value = accessor( o );
}
catch ( Exception e )
{
-                    self.Error( "Can't get property " + propertyName + " using method get/is" + propertyName +
-                        " from " + c.Name + " instance", e );
+                    self.Error( "Can't access property " + propertyName + " using method get/is" + propertyName +
+                        " or direct field access from " + c.Name + " instance", e );
}
}
else
{
-                FieldInfo field = member as FieldInfo;
-                if ( field != null )
-                {
-                    try
-                    {
-                        value = AccessField( field, o, value );
-                    }
-                    catch ( FieldAccessException iae )
-                    {
-                        self.Error( "Can't access property " + propertyName + " using method get/is" + propertyName +
-                            " or direct field access from " + c.Name + " instance", iae );
-                    }
-                }
-                else
-                {
-                    self.Error( "Class " + c.Name + " has no such attribute: " + propertyName +
-                        " in template context " + self.GetEnclosingInstanceStackString(), null );
-                }
+                self.Error( "Class " + c.Name + " has no such attribute: " + propertyName +
+                    " in template context " + self.GetEnclosingInstanceStackString(), null );
}

return value;
}

-        protected static object AccessField( FieldInfo f, object o, object value )
-        {
-            value = f.GetValue( o );
-            return value;
-        }
-
-        protected static object InvokeMethod( MethodInfo m, object o, object value )
-        {
-            value = m.Invoke( o, null );
-            return value;
-        }
-
protected static MethodInfo GetMethod( Type c, string methodName )
{
// we want a getter method
diff --git a/Antlr3.StringTemplate/StringTemplate.cs b/Antlr3.StringTemplate/StringTemplate.cs
index aa190ad..896bbe3 100644
--- a/Antlr3.StringTemplate/StringTemplate.cs
+++ b/Antlr3.StringTemplate/StringTemplate.cs
@@ -1228,18 +1228,7 @@ namespace Antlr3.ST
// The default is DefaultTemplateLexer.
// The only constraint is that you use an ANTLR lexer
// so I can use the special ChunkToken.
-                Type lexerClass = _group.TemplateLexerClass;
-                ConstructorInfo ctor =
-                        lexerClass.GetConstructor(
-                            new Type[] { typeof( StringTemplate ), typeof( TextReader ) }
-                        );
-                Lexer chunkStream =
-                        (Lexer)ctor.Invoke(
-                            new object[] { this, new StringReader( _pattern ) }
-                        );
-                //chunkStream.setTokenObjectClass("org.antlr.stringtemplate.language.ChunkToken");
-                //ITokenStream tokenStream = new CommonTokenStream(chunkStream);
-                //System.Diagnostics.Debug.Assert( tokenStream.LT( 1 ) is ChunkToken );
+                Lexer chunkStream = _group.CreateLexer( this, new StringReader( _pattern ) );
TemplateParser chunkifier = new TemplateParser( new CommonTokenStream( chunkStream ) );
chunkifier.template( this );
//System.out.println("chunks="+chunks);
@@ -1262,16 +1251,13 @@ namespace Antlr3.ST

public virtual ASTExpr ParseAction( string action )
{
-            //System.out.println("parse action "+action);
-            ActionLexer lexer = new ActionLexer( new Antlr.Runtime.ANTLRStringStream( action.ToString() ) );
-            ActionParser parser =
-                new ActionParser( lexer, this );
-            //parser.setASTNodeClass("org.antlr.stringtemplate.language.StringTemplateAST");
-            //lexer.setTokenObjectClass("org.antlr.stringtemplate.language.StringTemplateToken");
+            //Console.Out.WriteLine( "parse action " + action );
+            ActionLexer lexer = new ActionLexer( new Antlr.Runtime.ANTLRStringStream( action ) );
+            ActionParser parser = new ActionParser( lexer, this );
ASTExpr a = null;
try
{
-                ActionParser.action_return result = parser.action();
+                var result = parser.action();
IDictionary<string, object> options = result.opts;
ITree tree = (ITree)result.Tree;
if ( tree != null )
@@ -1288,15 +1274,8 @@ namespace Antlr3.ST
}
catch ( RecognitionException re )
{
-                Error( "Can't parse chunk: " + action.ToString(), re );
+                Error( "Can't parse chunk: " + action, re );
}
-            //catch (TokenStreamException tse) {
-            //    error("Can't parse chunk: "+action.toString(), tse);
-            //}
-            //catch ( Exception e )
-            //{
-            //    throw new NotImplementedException("Specific exception may need handling", e);
-            //}

return a;
}
diff --git a/Antlr3.StringTemplate/StringTemplateGroup.cs b/Antlr3.StringTemplate/StringTemplateGroup.cs
index 4034869..a3a08b6 100644
--- a/Antlr3.StringTemplate/StringTemplateGroup.cs
+++ b/Antlr3.StringTemplate/StringTemplateGroup.cs
@@ -98,7 +98,8 @@ namespace Antlr3.ST
Dictionary<string, IDictionary> _maps = new Dictionary<string, IDictionary>();

/** <summary>How to pull apart a template into chunks?</summary> */
-        Type _templateLexerClass = null;
+        Type _templateLexerClass;
+        Func<StringTemplate, TextReader, Antlr.Runtime.Lexer> _templateLexerClassCtor;

/** <summary>
*  You can set the lexer once if you know all of your groups use the
@@ -106,7 +107,9 @@ namespace Antlr3.ST
*  then it is used as an override.
*  </summary>
*/
-        static Type _defaultTemplateLexerClass = typeof( DefaultTemplateLexer );
+        static Type _defaultTemplateLexerClass;
+        static Func<StringTemplate, TextReader, Antlr.Runtime.Lexer> _defaultTemplateLexerClassCtor;
+        static readonly Dictionary<Type, Func<StringTemplate, TextReader, Antlr.Runtime.Lexer>> _ctors = new Dictionary<Type, Func<StringTemplate, TextReader, Antlr.Runtime.Lexer>>();

/** <summary>
*  Under what directory should I look for templates?  If null,
@@ -266,6 +269,11 @@ namespace Antlr3.ST
*/
Encoding _fileCharEncoding = Encoding.Default;

+        static StringTemplateGroup()
+        {
+            RegisterDefaultLexer( typeof( DefaultTemplateLexer ) );
+        }
+
/** <summary>
*  Create a group manager for some templates, all of which are
*  at or below the indicated directory.
@@ -292,7 +300,7 @@ namespace Antlr3.ST
this._rootAssembly = rootAssembly;
_lastCheckedDisk = DateTime.Now;
_nameToGroupMap[name] = this;
-            this._templateLexerClass = lexer;
+            TemplateLexerClass = lexer;
}

/** <summary>
@@ -363,7 +371,7 @@ namespace Antlr3.ST
{
lexer = typeof( AngleBracketTemplateLexer );
}
-            this._templateLexerClass = lexer;
+            TemplateLexerClass = lexer;
if ( errors != null )
{ // always have to have a listener
this._listener = errors;
@@ -472,6 +480,11 @@ namespace Antlr3.ST
}
return _defaultTemplateLexerClass;
}
+            private set
+            {
+                _templateLexerClass = value;
+                _templateLexerClassCtor = BuildLexerCtor( value );
+            }
}

public ICollection<StringTemplate> Templates
@@ -484,6 +497,40 @@ namespace Antlr3.ST

#endregion

+        [MethodImpl( MethodImplOptions.Synchronized )]
+        static Func<StringTemplate, TextReader, Antlr.Runtime.Lexer> BuildLexerCtor( Type lexerType )
+        {
+            if ( lexerType == null )
+                return null;
+
+            Func<StringTemplate, TextReader, Antlr.Runtime.Lexer> result;
+            if ( !_ctors.TryGetValue( lexerType, out result ) )
+            {
+                ConstructorInfo ctor = lexerType.GetConstructor( new Type[] { typeof( StringTemplate ), typeof( TextReader ) } );
+
+                System.Reflection.Emit.DynamicMethod dm = new System.Reflection.Emit.DynamicMethod( lexerType.Name + "Ctor", typeof( Antlr.Runtime.Lexer ), new Type[] { typeof( StringTemplate ), typeof( TextReader ) } );
+                var gen = dm.GetILGenerator();
+                gen.Emit( System.Reflection.Emit.OpCodes.Ldarg_0 );
+                gen.Emit( System.Reflection.Emit.OpCodes.Ldarg_1 );
+                gen.Emit( System.Reflection.Emit.OpCodes.Newobj, ctor );
+                gen.Emit( System.Reflection.Emit.OpCodes.Ret );
+                result = (Func<StringTemplate, TextReader, Antlr.Runtime.Lexer>)dm.CreateDelegate( typeof( Func<StringTemplate, TextReader, Antlr.Runtime.Lexer> ) );
+                _ctors[lexerType] = result;
+            }
+
+            return result;
+        }
+
+        public Antlr.Runtime.Lexer CreateLexer( StringTemplate template, TextReader reader )
+        {
+            if ( _templateLexerClassCtor != null )
+            {
+                return _templateLexerClassCtor( template, reader );
+            }
+
+            return _defaultTemplateLexerClassCtor( template, reader );
+        }
+
[Obsolete]
public Type GetTemplateLexerClass()
{
@@ -1310,6 +1357,7 @@ namespace Antlr3.ST
public static void RegisterDefaultLexer( Type lexerClass )
{
_defaultTemplateLexerClass = lexerClass;
+            _defaultTemplateLexerClassCtor = BuildLexerCtor( lexerClass );
}

public static void RegisterGroupLoader( IStringTemplateGroupLoader loader )

