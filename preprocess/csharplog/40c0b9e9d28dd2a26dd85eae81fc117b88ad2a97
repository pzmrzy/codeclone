commit 40c0b9e9d28dd2a26dd85eae81fc117b88ad2a97
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Thu Nov 25 09:23:27 2010 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Thu Nov 25 09:23:27 2010 -0800

(C# 3) Merge CL7158

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 7185]

diff --git a/Antlr3.Test/TestCompositeGrammars.cs b/Antlr3.Test/TestCompositeGrammars.cs
index 1ea1e74..8e34645 100644
--- a/Antlr3.Test/TestCompositeGrammars.cs
+++ b/Antlr3.Test/TestCompositeGrammars.cs
@@ -903,5 +903,64 @@ namespace AntlrUnitTests
assertEquals( "unexpected errors: " + equeue, 0, equeue.errors.Count );
}

+        [TestMethod]
+        public void TestNestedComposite()
+        {
+            // Wasn't compiling. http://www.antlr.org/jira/browse/ANTLR-438
+            ErrorQueue equeue = new ErrorQueue();
+            ErrorManager.SetErrorListener(equeue);
+            string gstr =
+                "lexer grammar L;\n" +
+                "T1: '1';\n" +
+                "T2: '2';\n" +
+                "T3: '3';\n" +
+                "T4: '4';\n";
+            mkdir(tmpdir);
+            writeFile(tmpdir, "L.g", gstr);
+            gstr =
+                "parser grammar G1;\n" +
+                "s: a | b;\n" +
+                "a: T1;\n" +
+                "b: T2;\n";
+            mkdir(tmpdir);
+            writeFile(tmpdir, "G1.g", gstr);
+
+            gstr =
+                "parser grammar G2;\n" +
+                "import G1;\n" +
+                "a: T3;\n";
+            mkdir(tmpdir);
+            writeFile(tmpdir, "G2.g", gstr);
+            string G3str =
+                "grammar G3;\n" +
+                "import G2;\n" +
+                "b: T4;\n";
+            mkdir(tmpdir);
+            writeFile(tmpdir, "G3.g", G3str);
+
+            AntlrTool antlr = newTool(new string[] { "-lib", tmpdir });
+            CompositeGrammar composite = new CompositeGrammar();
+            Grammar g = new Grammar(antlr, tmpdir + "/G3.g", composite);
+            composite.SetDelegationRoot(g);
+            g.ParseAndBuildAST();
+            g.composite.AssignTokenTypes();
+            g.composite.DefineGrammarSymbols();
+
+            string expectedTokenIDToTypeMap = "[T1=4, T2=5, T3=6, T4=7]";
+            string expectedStringLiteralToTypeMap = "{}";
+            string expectedTypeToTokenList = "[T1, T2, T3, T4]";
+
+            Assert.AreEqual(expectedTokenIDToTypeMap, realElements(g.composite.tokenIDToTypeMap).ToElementString());
+            Assert.AreEqual(expectedStringLiteralToTypeMap, g.composite.stringLiteralToTypeMap.ToElementString());
+            Assert.AreEqual(expectedTypeToTokenList, realElements(g.composite.typeToTokenList).ToElementString());
+
+            Assert.AreEqual(0, equeue.errors.Count, "unexpected errors: " + equeue);
+
+            bool ok =
+                rawGenerateAndBuildRecognizer("G3.g", G3str, "G3Parser", null, false);
+            bool expecting = true; // should be ok
+            assertEquals(expecting, ok);
+        }
+
}
}
diff --git a/Antlr3/Tool/CompositeGrammar.cs b/Antlr3/Tool/CompositeGrammar.cs
index 8b70013..6b21186 100644
--- a/Antlr3/Tool/CompositeGrammar.cs
+++ b/Antlr3/Tool/CompositeGrammar.cs
@@ -327,8 +327,8 @@ namespace Antlr3.Tool
HashSet<string> ruleNames = new HashSet<string>();
HashSet<Rule> rules = new HashSet<Rule>();
CompositeGrammarTree subtreeRoot = delegateGrammarTreeRoot.FindNode( g );
-            IList<Grammar> grammars = subtreeRoot.GetPostOrderedGrammarList();
-            // walk all grammars
+            IList<Grammar> grammars = subtreeRoot.GetPreOrderedGrammarList();
+            // walk all grammars preorder, priority given to grammar listed first.
foreach ( Grammar grammar in grammars )
{
// for each rule in grammar, add to rules if no rule with that
diff --git a/Antlr3/Tool/CompositeGrammarTree.cs b/Antlr3/Tool/CompositeGrammarTree.cs
index da94a3d..dbcae6e 100644
--- a/Antlr3/Tool/CompositeGrammarTree.cs
+++ b/Antlr3/Tool/CompositeGrammarTree.cs
@@ -149,7 +149,7 @@ namespace Antlr3.Tool
grammars.Add( this.grammar );
}

-        /** Return a postorder list of grammars; root is last in list */
+        /** Return a preorder list of grammars; root is first in list */
public IList<Grammar> GetPreOrderedGrammarList()
{
IList<Grammar> grammars = new List<Grammar>();
@@ -163,7 +163,7 @@ namespace Antlr3.Tool
for ( int i = 0; children != null && i < children.Count; i++ )
{
CompositeGrammarTree child = children[i];
-                child.GetPostOrderedGrammarListCore( grammars );
+                child.GetPreOrderedGrammarListCore( grammars );
}
}


