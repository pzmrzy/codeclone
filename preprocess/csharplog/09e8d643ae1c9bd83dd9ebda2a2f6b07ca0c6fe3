commit 09e8d643ae1c9bd83dd9ebda2a2f6b07ca0c6fe3
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Sun Nov 21 09:00:59 2010 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Sun Nov 21 09:00:59 2010 -0800

Updated bootstrap binaries

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 7096]

diff --git a/bin/Bootstrap/Antlr3.Runtime.Debug.dll b/bin/Bootstrap/Antlr3.Runtime.Debug.dll
index 0af7cd1..3bb18fd 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.Debug.dll and b/bin/Bootstrap/Antlr3.Runtime.Debug.dll differ
diff --git a/bin/Bootstrap/Antlr3.Runtime.Debug.pdb b/bin/Bootstrap/Antlr3.Runtime.Debug.pdb
index 6295181..2992643 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.Debug.pdb and b/bin/Bootstrap/Antlr3.Runtime.Debug.pdb differ
diff --git a/bin/Bootstrap/Antlr3.Runtime.dll b/bin/Bootstrap/Antlr3.Runtime.dll
index 4ff354c..96aa60b 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.dll and b/bin/Bootstrap/Antlr3.Runtime.dll differ
diff --git a/bin/Bootstrap/Antlr3.Runtime.pdb b/bin/Bootstrap/Antlr3.Runtime.pdb
index 5a4a118..5b87c04 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.pdb and b/bin/Bootstrap/Antlr3.Runtime.pdb differ
diff --git a/bin/Bootstrap/Antlr3.StringTemplate.dll b/bin/Bootstrap/Antlr3.StringTemplate.dll
index 976be61..f9ef025 100644
Binary files a/bin/Bootstrap/Antlr3.StringTemplate.dll and b/bin/Bootstrap/Antlr3.StringTemplate.dll differ
diff --git a/bin/Bootstrap/Antlr3.StringTemplate.pdb b/bin/Bootstrap/Antlr3.StringTemplate.pdb
index 8b4a69c..58555d8 100644
Binary files a/bin/Bootstrap/Antlr3.StringTemplate.pdb and b/bin/Bootstrap/Antlr3.StringTemplate.pdb differ
diff --git a/bin/Bootstrap/Antlr3.exe b/bin/Bootstrap/Antlr3.exe
index 472148f..42c1073 100755
Binary files a/bin/Bootstrap/Antlr3.exe and b/bin/Bootstrap/Antlr3.exe differ
diff --git a/bin/Bootstrap/Antlr3.pdb b/bin/Bootstrap/Antlr3.pdb
index 22c9859..c830c9e 100644
Binary files a/bin/Bootstrap/Antlr3.pdb and b/bin/Bootstrap/Antlr3.pdb differ
diff --git a/bin/Bootstrap/AntlrBuildTask.dll b/bin/Bootstrap/AntlrBuildTask.dll
index eba5cae..1348847 100644
Binary files a/bin/Bootstrap/AntlrBuildTask.dll and b/bin/Bootstrap/AntlrBuildTask.dll differ
diff --git a/bin/Bootstrap/AntlrBuildTask.pdb b/bin/Bootstrap/AntlrBuildTask.pdb
index 28c70bc..d910bd4 100644
Binary files a/bin/Bootstrap/AntlrBuildTask.pdb and b/bin/Bootstrap/AntlrBuildTask.pdb differ
diff --git a/bin/Bootstrap/Codegen/Templates/ANTLRCore.sti b/bin/Bootstrap/Codegen/Templates/ANTLRCore.sti
index e4e5a15..308ba6c 100644
--- a/bin/Bootstrap/Codegen/Templates/ANTLRCore.sti
+++ b/bin/Bootstrap/Codegen/Templates/ANTLRCore.sti
@@ -146,7 +146,7 @@ matchSet(s,label,elementIndex,postmatchCode);
matchSetAndListLabel(s,label,elementIndex,postmatchCode);

/** Match a string literal */
-lexerStringRef(string,label);
+lexerStringRef(string,label,elementIndex);

wildcard(label,elementIndex);

diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg
index a3678f1..553944f 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg
@@ -46,16 +46,17 @@ using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;<\n>

parserCtorBody() ::= <<
<super.parserCtorBody()>
-InitializeTreeAdaptor();
-if ( TreeAdaptor == null )
-	TreeAdaptor = new CommonTreeAdaptor();
+ITreeAdaptor treeAdaptor = null;
+CreateTreeAdaptor(ref treeAdaptor);
+TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
>>

/** Add an adaptor property that knows how to build trees */
parserMembers() ::= <<
// Implement this function in your helper file to use a custom tree adaptor
-partial void InitializeTreeAdaptor();
-ITreeAdaptor adaptor;
+partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);
+
+private ITreeAdaptor adaptor;

public ITreeAdaptor TreeAdaptor
{
@@ -320,6 +321,7 @@ rewriteElementList(elements) ::= "<elements:rewriteElement()>"

rewriteElement(e) ::= <<
<@pregen()>
+DebugLocation(<e.line>, <e.pos>);
<e.el>
>>

diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTDbg.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTDbg.stg
index 06f5875..67ed356 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTDbg.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTDbg.stg
@@ -97,4 +97,4 @@ TreeAdaptor = adap;<\n>
<endif>
>>

-@rewriteElement.pregen() ::= "dbg.Location( <e.line>, <e.pos> );"
+//@rewriteElement.pregen() ::= "dbg.Location( <e.line>, <e.pos> );"
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg
index 7487954..d9066cd 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg
@@ -57,7 +57,7 @@ noRewrite(rewriteBlockLevel, treeLevel) ::= <<
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
<if(rewriteMode)>
retval.tree = (<ASTLabelType>)_first_0;
-if ( adaptor.GetParent(retval.tree)!=null && adaptor.IsNil( adaptor.getParent(retval.tree) ) )
+if (adaptor.GetParent(retval.tree)!=null && adaptor.IsNil(adaptor.GetParent(retval.tree)))
retval.tree = (<ASTLabelType>)adaptor.GetParent(retval.tree);
<endif>
<if(backtracking)>}<endif>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
index b6ecd4e..647432c 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
@@ -107,11 +107,16 @@ public partial class <grammar.recognizerName> : <@superClassName><superClass><@e
{g|public <g.recognizerName> <g:delegateName()>;}; separator="\n">
<last(grammar.delegators):{g|public <g.recognizerName> gParent;}>

-	public <grammar.recognizerName>() {}<! needed by subclasses !>
+	public <grammar.recognizerName>()<! needed by subclasses !>
+	{
+		OnCreated();
+	}
+
public <grammar.recognizerName>(ICharStream input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}> )
: this(input, new RecognizerSharedState()<grammar.delegators:{g|, <g:delegateName()>}>)
{
}
+
public <grammar.recognizerName>(ICharStream input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
: base(input, state)
{
@@ -125,6 +130,8 @@ public partial class <grammar.recognizerName> : <@superClassName><superClass><@e
<grammar.delegators:
{g|this.<g:delegateName()> = <g:delegateName()>;}; separator="\n">
<last(grammar.delegators):{g|gParent = <g:delegateName()>;}>
+
+		OnCreated();
}
public override string GrammarFileName { get { return "<fileName>"; } }

@@ -150,6 +157,11 @@ public partial class <grammar.recognizerName> : <@superClassName><superClass><@e
<if(filterMode)>
<filteringNextToken()>
<endif>
+
+	partial void OnCreated();
+	partial void EnterRule(string ruleName, int ruleIndex);
+	partial void LeaveRule(string ruleName, int ruleIndex);
+
<rules; separator="\n\n">

<insertLexerSynpreds(synpreds)>
@@ -280,6 +292,8 @@ public <grammar.recognizerName>(<inputStreamType> input, RecognizerSharedState s
{g|<g:delegateName()> = new <g.recognizerName>(input, state<trunc(g.delegators):{p|, <p:delegateName()>}>, this);}; separator="\n">
<grammar.indirectDelegates:{g | <g:delegateName()> = <g.delegator:delegateName()>.<g:delegateName()>;}; separator="\n">
<last(grammar.delegators):{g|gParent = <g:delegateName()>;}>
+
+	OnCreated();
}
<@end>

@@ -288,6 +302,10 @@ public <grammar.recognizerName>(<inputStreamType> input, RecognizerSharedState s

<members>

+	partial void OnCreated();
+	partial void EnterRule(string ruleName, int ruleIndex);
+	partial void LeaveRule(string ruleName, int ruleIndex);
+
#region Rules
<rules; separator="\n\n">
#endregion Rules
@@ -365,23 +383,26 @@ treeParser(grammar, name, scopes, tokens, tokenNames, globalAction, rules,
*/
synpredRule(ruleName, ruleDescriptor, block, description, nakedBlock) ::=
<<
+partial void Enter<ruleName>_fragment();
+partial void Leave<ruleName>_fragment();
+
// $ANTLR start <ruleName>
public <!final !>void <ruleName>_fragment(<ruleDescriptor.parameterScope:parameterScope(scope=it)>)
{
<ruleLabelDefs()>
-<if(trace)>
-	traceIn("<ruleName>_fragment", <ruleDescriptor.index>);
+	Enter<ruleName>_fragment();
+	EnterRule("<ruleName>_fragment", <ruleDescriptor.index>);
+	TraceIn("<ruleName>_fragment", <ruleDescriptor.index>);
try
{
<block>
}
finally
{
-		traceOut("<ruleName>_fragment", <ruleDescriptor.index>);
+		TraceOut("<ruleName>_fragment", <ruleDescriptor.index>);
+		LeaveRule("<ruleName>_fragment", <ruleDescriptor.index>);
+		Leave<ruleName>_fragment();
}
-<else>
-	<block>
-<endif>
}
// $ANTLR end <ruleName>
>>
@@ -395,8 +416,10 @@ insertSynpreds(synpreds) ::= <<
#region Synpreds
private bool EvaluatePredicate(System.Action fragment)
{
+	bool success = false;
state.backtracking++;
<@start()>
+	try { DebugBeginBacktrack(state.backtracking);
int start = input.Mark();
try
{
@@ -406,8 +429,9 @@ private bool EvaluatePredicate(System.Action fragment)
{
System.Console.Error.WriteLine("impossible: "+re);
}
-	bool success = !state.failed;
+	success = !state.failed;
input.Rewind(start);
+	} finally { DebugEndBacktrack(state.backtracking, success); }
<@stop()>
state.backtracking--;
state.failed=false;
@@ -440,15 +464,23 @@ rule(ruleName,ruleDescriptor,block,emptyRule,description,exceptions,finally,memo
<ruleAttributeScope(scope=ruleDescriptor.ruleScope)>
<returnScope(scope=ruleDescriptor.returnScope)>

+partial void Enter<ruleName>();
+partial void Leave<ruleName>();
+
// $ANTLR start "<ruleName>"
// <fileName>:<description>
+[GrammarRule("<ruleName>")]
<csharpVisibilityMap.(ruleDescriptor.modifier)> <returnType()> <ruleName>(<ruleDescriptor.parameterScope:parameterScope(scope=it)>)
{
-	<if(trace)>traceIn("<ruleName>", <ruleDescriptor.index>);<endif>
+	Enter<ruleName>();
+	EnterRule("<ruleName>", <ruleDescriptor.index>);
+	TraceIn("<ruleName>", <ruleDescriptor.index>);
<ruleScopeSetUp()>
<ruleDeclarations()>
<ruleLabelDefs()>
<ruleDescriptor.actions.init>
+	try { DebugEnterRule(GrammarFileName, "<ruleName>");
+	DebugLocation(<ruleDescriptor.tree.line>, <ruleDescriptor.EORNode.charPositionInLine>);
<@preamble()>
try
{
@@ -475,11 +507,15 @@ rule(ruleName,ruleDescriptor,block,emptyRule,description,exceptions,finally,memo
<endif>
finally
{
-		<if(trace)>traceOut("<ruleName>", <ruleDescriptor.index>);<endif>
+		TraceOut("<ruleName>", <ruleDescriptor.index>);
+		LeaveRule("<ruleName>", <ruleDescriptor.index>);
+		Leave<ruleName>();
<memoize()>
<ruleScopeCleanUp()>
<finally>
}
+	DebugLocation(<ruleDescriptor.EORNode.line>, <ruleDescriptor.EORNode.charPositionInLine>);
+	} finally { DebugExitRule(GrammarFileName, "<ruleName>"); }
<@postamble()>
<returnFromRule()><\n>
}
@@ -575,10 +611,16 @@ if (state.backtracking > 0) { Memoize(input, <ruleDescriptor.index>, <ruleDescri
*  fragment rules.
*/
lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) ::= <<
+partial void Enter<ruleName>();
+partial void Leave<ruleName>();
+
// $ANTLR start "<ruleName>"
+[GrammarRule("<ruleName>")]
<csharpVisibilityMap.(ruleDescriptor.modifier)> void m<ruleName>(<ruleDescriptor.parameterScope:parameterScope(scope=it)>)
{
-	<if(trace)>traceIn("<ruleName>", <ruleDescriptor.index>);<endif>
+	Enter<ruleName>();
+	EnterRule("<ruleName>", <ruleDescriptor.index>);
+	TraceIn("<ruleName>", <ruleDescriptor.index>);
<ruleScopeSetUp()>
<ruleDeclarations()>
try
@@ -603,7 +645,9 @@ lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) ::= <<
}
finally
{
-		<if(trace)>traceOut("<ruleName>", <ruleDescriptor.index>);<endif>
+		TraceOut("<ruleName>", <ruleDescriptor.index>);
+		LeaveRule("<ruleName>", <ruleDescriptor.index>);
+		Leave<ruleName>();
<ruleScopeCleanUp()>
<memoize()>
}
@@ -629,13 +673,17 @@ block(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,max
int alt<decisionNumber>=<maxAlt>;
<decls>
<@predecision()>
+try { DebugEnterSubRule(<decisionNumber>);
+try { DebugEnterDecision(<decisionNumber>, false);
<decision>
+} finally { DebugExitDecision(<decisionNumber>); }
<@postdecision()>
<@prebranch()>
switch (alt<decisionNumber>)
{
<alts:altSwitchCase()>
}
+} finally { DebugExitSubRule(<decisionNumber>); }
<@postbranch()>
>>

@@ -645,7 +693,9 @@ ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK
int alt<decisionNumber>=<maxAlt>;
<decls>
<@predecision()>
+try { DebugEnterDecision(<decisionNumber>, false);
<decision>
+} finally { DebugExitDecision(<decisionNumber>); }
<@postdecision()>
switch (alt<decisionNumber>)
{
@@ -657,6 +707,7 @@ ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNu
// <fileName>:<description>
<decls>
<@prealt()>
+DebugEnterAlt(1);
<alts>
<@postalt()>
>>
@@ -666,6 +717,7 @@ blockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber
// <fileName>:<description>
<decls>
<@prealt()>
+DebugEnterAlt(1);
<alts>
<@postalt()>
>>
@@ -676,11 +728,14 @@ positiveClosureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decision
int cnt<decisionNumber>=0;
<decls>
<@preloop()>
+try { DebugEnterSubRule(<decisionNumber>);
while (true)
{
int alt<decisionNumber>=<maxAlt>;
<@predecision()>
+	try { DebugEnterDecision(<decisionNumber>, false);
<decision>
+	} finally { DebugExitDecision(<decisionNumber>); }
<@postdecision()>
switch (alt<decisionNumber>)
{
@@ -691,6 +746,7 @@ while (true)

<ruleBacktrackFailure()>
EarlyExitException eee<decisionNumber> = new EarlyExitException( <decisionNumber>, input );
+		DebugRecognitionException(eee<decisionNumber>);
<@earlyExitException()>
throw eee<decisionNumber>;
}
@@ -699,6 +755,7 @@ while (true)
loop<decisionNumber>:
;

+} finally { DebugExitSubRule(<decisionNumber>); }
<@postloop()>
>>

@@ -709,11 +766,14 @@ closureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,m
// <fileName>:<description>
<decls>
<@preloop()>
+try { DebugEnterSubRule(<decisionNumber>);
while (true)
{
int alt<decisionNumber>=<maxAlt>;
<@predecision()>
+	try { DebugEnterDecision(<decisionNumber>, false);
<decision>
+	} finally { DebugExitDecision(<decisionNumber>); }
<@postdecision()>
switch ( alt<decisionNumber> )
{
@@ -726,6 +786,7 @@ while (true)
loop<decisionNumber>:
;

+} finally { DebugExitSubRule(<decisionNumber>); }
<@postloop()>
>>

@@ -745,6 +806,7 @@ optionalBlockSingleAlt ::= block
altSwitchCase() ::= <<
case <i>:
<@prealt()>
+	DebugEnterAlt(<i>);
<it>
break;<\n>
>>
@@ -770,6 +832,7 @@ noRewrite(rewriteBlockLevel, treeLevel) ::= ""
/** Dump the elements one per line */
element() ::= <<
<@prematch()>
+DebugLocation(<it.line>, <it.pos>);
<it.el><\n>
>>

@@ -827,6 +890,7 @@ else
{
<ruleBacktrackFailure()>
MismatchedSetException mse = new MismatchedSetException(null,input);
+	DebugRecognitionException(mse);
<@mismatchedSetException()>
<if(LEXER)>
Recover(mse);
@@ -864,7 +928,7 @@ matchSetAndListLabel(s,label,elementIndex,postmatchCode) ::= <<
>>

/** Match a string literal */
-lexerStringRef(string,label) ::= <<
+lexerStringRef(string,label,elementIndex) ::= <<
<if(label)>
int <label>Start = CharIndex;
Match(<string>); <checkRuleBacktrackFailure()>
@@ -1005,6 +1069,7 @@ else
<else>
<ruleBacktrackFailure()>
NoViableAltException nvae = new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input);<\n>
+	DebugRecognitionException(nvae);
<@noViableAltException()>
throw nvae;<\n>
<endif>
@@ -1073,6 +1138,7 @@ default:
{
<ruleBacktrackFailure()>
NoViableAltException nvae = new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input);<\n>
+		DebugRecognitionException(nvae);
<@noViableAltException()>
throw nvae;
}<\n>
@@ -1114,7 +1180,15 @@ dfaEdgeSwitch(labels, targetState) ::= <<
*  The <name> attribute is inherited via the parser, lexer, ...
*/
dfaDecision(decisionNumber,description) ::= <<
-alt<decisionNumber> = dfa<decisionNumber>.Predict(input);
+try
+{
+	alt<decisionNumber> = dfa<decisionNumber>.Predict(input);
+}
+catch (NoViableAltException nvae)
+{
+	DebugRecognitionException(nvae);
+	throw;
+}
>>

/* Dump DFA tables as run-length-encoded Strings of octal values.
@@ -1182,7 +1256,11 @@ private class DFA<dfa.decisionNumber> : DFA
{
return "<dfa.description>";
}
-	<@errorMethod()>
+
+	public override void Error(NoViableAltException nvae)
+	{
+		DebugRecognitionException(nvae);
+	}
}<\n>
<if(dfa.specialStateSTs)>
private int SpecialStateTransition<dfa.decisionNumber>(DFA dfa, int s, IIntStream _input)<! throws NoViableAltException!>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/Dbg.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/Dbg.stg
index 00249f4..336385a 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/Dbg.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/Dbg.stg
@@ -66,15 +66,15 @@ public static readonly string[] ruleNames =
<ctorForDelegateGrammar()>
<endif>
<if(profile)>
-public virtual bool AlreadyParsedRule( IIntStream input, int ruleIndex )
+public override bool AlreadyParsedRule( IIntStream input, int ruleIndex )
{
((Profiler)dbg).ExamineRuleMemoization(input, ruleIndex, <grammar.composite.rootGrammar.recognizerName>.ruleNames[ruleIndex]);
-	return super.AlreadyParsedRule(input, ruleIndex);
+	return base.AlreadyParsedRule(input, ruleIndex);
}<\n>
-public virtual void Memoize( IIntStream input, int ruleIndex, int ruleStartIndex )
+public override void Memoize( IIntStream input, int ruleIndex, int ruleStartIndex )
{
((Profiler)dbg).Memoize(input, ruleIndex, ruleStartIndex, <grammar.composite.rootGrammar.recognizerName>.ruleNames[ruleIndex]);
-	super.Memoize(input, ruleIndex, ruleStartIndex);
+	base.Memoize(input, ruleIndex, ruleStartIndex);
}<\n>
<endif>
protected virtual bool EvalPredicate( bool result, string predicate )
@@ -164,136 +164,149 @@ catch ( IOException ioe )

@genericParser.superClassName() ::= "Debug<@super.superClassName()>"

+/*
+ * Much of the following rules were merged into CSharp3.stg.
+ */
+
@rule.preamble() ::= <<
-try
-{
-	dbg.EnterRule( GrammarFileName, "<ruleName>" );
-	if ( RuleLevel == 0 )
-	{
-		dbg.Commence();
-	}
-	IncRuleLevel();
-	dbg.Location( <ruleDescriptor.tree.line>, <ruleDescriptor.tree.charPositionInLine> );<\n>
+if (RuleLevel == 0)
+	DebugListener.Commence();
+IncRuleLevel();
>>
+//@rule.preamble() ::= <<
+//try
+//{
+//	dbg.EnterRule( GrammarFileName, "<ruleName>" );
+//	if ( RuleLevel == 0 )
+//	{
+//		dbg.Commence();
+//	}
+//	IncRuleLevel();
+//	dbg.Location( <ruleDescriptor.tree.line>, <ruleDescriptor.tree.charPositionInLine> );<\n>
+//>>

@rule.postamble() ::= <<
-dbg.Location(<ruleDescriptor.EORNode.line>, <ruleDescriptor.EORNode.charPositionInLine>);<\n>
-}
-finally
-{
-	dbg.ExitRule( GrammarFileName, "<ruleName>" );
-	DecRuleLevel();
-	if ( RuleLevel == 0 )
-	{
-		dbg.Terminate();
-	}
-}<\n>
+DecRuleLevel();
+if (RuleLevel == 0)
+	DebugListener.Terminate();
>>
-
-@insertSynpreds.start() ::= "dbg.BeginBacktrack( state.backtracking );"
-
-@insertSynpreds.stop() ::= "dbg.EndBacktrack( state.backtracking, success );"
+//@rule.postamble() ::= <<
+//dbg.Location(<ruleDescriptor.EORNode.line>, <ruleDescriptor.EORNode.charPositionInLine>);<\n>
+//}
+//finally
+//{
+//	dbg.ExitRule( GrammarFileName, "<ruleName>" );
+//	DecRuleLevel();
+//	if ( RuleLevel == 0 )
+//	{
+//		dbg.Terminate();
+//	}
+//}<\n>
+//>>
+
+//@insertSynpreds.start() ::= "dbg.BeginBacktrack( state.backtracking );"
+//@insertSynpreds.stop() ::= "dbg.EndBacktrack( state.backtracking, success );"

// Common debug event triggers used by region overrides below

-enterSubRule() ::= <<
-try
-{
-	dbg.EnterSubRule( <decisionNumber> );<\n>
->>
-
-exitSubRule() ::= <<
-}
-finally
-{
-	dbg.ExitSubRule( <decisionNumber> );
-}<\n>
->>
-
-enterDecision() ::= <<
-try
-{
-	dbg.EnterDecision( <decisionNumber> );<\n>
->>
-
-exitDecision() ::= <<
-}
-finally
-{
-	dbg.ExitDecision( <decisionNumber> );
-}<\n>
->>
-
-enterAlt(n) ::= "dbg.EnterAlt( <n> );<\n>"
+//enterSubRule() ::= <<
+//try
+//{
+//	dbg.EnterSubRule( <decisionNumber> );<\n>
+//>>
+
+//exitSubRule() ::= <<
+//}
+//finally
+//{
+//	dbg.ExitSubRule( <decisionNumber> );
+//}<\n>
+//>>
+
+//enterDecision() ::= <<
+//try
+//{
+//	dbg.EnterDecision( <decisionNumber> );<\n>
+//>>
+
+//exitDecision() ::= <<
+//}
+//finally
+//{
+//	dbg.ExitDecision( <decisionNumber> );
+//}<\n>
+//>>
+
+//enterAlt(n) ::= "dbg.EnterAlt( <n> );<\n>"

// Region overrides that tell various constructs to add debugging triggers

-@block.predecision() ::= "<enterSubRule()><enterDecision()>"
+//@block.predecision() ::= "<enterSubRule()><enterDecision()>"

-@block.postdecision() ::= "<exitDecision()>"
+//@block.postdecision() ::= "<exitDecision()>"

-@block.postbranch() ::= "<exitSubRule()>"
+//@block.postbranch() ::= "<exitSubRule()>"

-@ruleBlock.predecision() ::= "<enterDecision()>"
+//@ruleBlock.predecision() ::= "<enterDecision()>"

-@ruleBlock.postdecision() ::= "<exitDecision()>"
+//@ruleBlock.postdecision() ::= "<exitDecision()>"

-@ruleBlockSingleAlt.prealt() ::= "<enterAlt(n=\"1\")>"
+//@ruleBlockSingleAlt.prealt() ::= "<enterAlt(n=\"1\")>"

-@blockSingleAlt.prealt() ::= "<enterAlt(n=\"1\")>"
+//@blockSingleAlt.prealt() ::= "<enterAlt(n=\"1\")>"

-@positiveClosureBlock.preloop() ::= "<enterSubRule()>"
+//@positiveClosureBlock.preloop() ::= "<enterSubRule()>"

-@positiveClosureBlock.postloop() ::= "<exitSubRule()>"
+//@positiveClosureBlock.postloop() ::= "<exitSubRule()>"

-@positiveClosureBlock.predecision() ::= "<enterDecision()>"
+//@positiveClosureBlock.predecision() ::= "<enterDecision()>"

-@positiveClosureBlock.postdecision() ::= "<exitDecision()>"
+//@positiveClosureBlock.postdecision() ::= "<exitDecision()>"

-@positiveClosureBlock.earlyExitException() ::=
-	"dbg.RecognitionException( eee<decisionNumber> );<\n>"
+//@positiveClosureBlock.earlyExitException() ::=
+//	"dbg.RecognitionException( eee<decisionNumber> );<\n>"

-@closureBlock.preloop() ::= "<enterSubRule()>"
+//@closureBlock.preloop() ::= "<enterSubRule()>"

-@closureBlock.postloop() ::= "<exitSubRule()>"
+//@closureBlock.postloop() ::= "<exitSubRule()>"

-@closureBlock.predecision() ::= "<enterDecision()>"
+//@closureBlock.predecision() ::= "<enterDecision()>"

-@closureBlock.postdecision() ::= "<exitDecision()>"
+//@closureBlock.postdecision() ::= "<exitDecision()>"

-@altSwitchCase.prealt() ::= "<enterAlt(n=i)>"
+//@altSwitchCase.prealt() ::= "<enterAlt(n=i)>"

-@element.prematch() ::=
-	"dbg.Location( <it.line>, <it.pos> );"
+//@element.prematch() ::=
+//	"dbg.Location( <it.line>, <it.pos> );"

-@matchSet.mismatchedSetException() ::=
-	"dbg.RecognitionException( mse );"
+//@matchSet.mismatchedSetException() ::=
+//	"dbg.RecognitionException( mse );"

-@dfaState.noViableAltException() ::= "dbg.RecognitionException( nvae );"
+//@dfaState.noViableAltException() ::= "dbg.RecognitionException( nvae );"

-@dfaStateSwitch.noViableAltException() ::= "dbg.RecognitionException( nvae );"
+//@dfaStateSwitch.noViableAltException() ::= "dbg.RecognitionException( nvae );"

-dfaDecision(decisionNumber,description) ::= <<
-try
-{
-	isCyclicDecision = true;
-	<super.dfaDecision(...)>
-}
-catch ( NoViableAltException nvae )
-{
-	dbg.RecognitionException( nvae );
-	throw nvae;
-}
->>
+//dfaDecision(decisionNumber,description) ::= <<
+//try
+//{
+//	isCyclicDecision = true;
+//	<super.dfaDecision(...)>
+//}
+//catch ( NoViableAltException nvae )
+//{
+//	dbg.RecognitionException( nvae );
+//	throw nvae;
+//}
+//>>

-@cyclicDFA.errorMethod() ::= <<
-public override void Error( NoViableAltException nvae )
-{
-	((DebugParser)recognizer).dbg.RecognitionException( nvae );
-}
->>
+//@cyclicDFA.errorMethod() ::= <<
+//public override void Error( NoViableAltException nvae )
+//{
+//	((DebugParser)recognizer).dbg.RecognitionException( nvae );
+//}
+//>>

/** Force predicate validation to trigger an event */
evalPredicate(pred,description) ::= <<
-EvalPredicate( <pred>, "<description>" )
+EvalPredicate(<pred>, "<description>")
>>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/ST.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/ST.stg
index 1453d76..9f84f5c 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/ST.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/ST.stg
@@ -43,8 +43,8 @@ using Antlr3.ST.Language;
/** Add this to each rule's return value struct */
@returnScope.ruleReturnMembers() ::= <<
public StringTemplate st;
-public object getTemplate() { return st; }
-public override string ToString() { return (st==null) ? null : st.ToString(); }
+public object Template { get { return st; } }
+public override string ToString() { return (st==null) ? string.Empty : st.ToString(); }
>>

@genericParser.members() ::= <<
@@ -56,20 +56,6 @@ public StringTemplateGroup TemplateLib
get { return templateLib; }
set { templateLib = value; }
}
-
-///** allows convenient multi-value initialization:
-// *  "new STAttrMap().put(...).put(...)"
-// */
-//public static class STAttrMap extends HashMap {
-//  public STAttrMap put(String attrName, object value) {
-//    super.put(attrName, value);
-//    return this;
-//  }
-//  public STAttrMap put(String attrName, int value) {
-//    super.put(attrName, new Integer(value));
-//    return this;
-//  }
-//}
>>

/** x+=rule when output=template */
@@ -95,12 +81,12 @@ if ( <actions.(actionScope).synpredgate> )

replaceTextInLine() ::= <<
<if(TREE_PARSER)>
-((TokenRewriteStream)input.TokenStream).replace(
+((TokenRewriteStream)input.TokenStream).Replace(
input.TreeAdaptor.GetTokenStartIndex(retval.start),
input.TreeAdaptor.GetTokenStopIndex(retval.start),
retval.st );
<else>
-((TokenRewriteStream)input).replace(
+((TokenRewriteStream)input).Replace(
((IToken)retval.start).TokenIndex,
input.LT(-1).TokenIndex,
retval.st );
@@ -132,14 +118,14 @@ null;
*  template.
*/
rewriteExternalTemplate(name,args) ::= <<
-templateLib.getInstanceOf("<name>"<if(args)>,
+templateLib.GetInstanceOf("<name>"<if(args)>,
new STAttrMap()<args:{a | .put("<a.name>", <a.value>)}>
<endif>)
>>

/** expr is a string expression that says what template to load */
rewriteIndirectTemplate(expr,args) ::= <<
-templateLib.getInstanceOf(<expr><if(args)>,
+templateLib.GetInstanceOf(<expr><if(args)>,
new STAttrMap()<args:{a | .put("<a.name>", <a.value>)}>
<endif>)
>>
@@ -158,7 +144,7 @@ rewriteAction(action) ::= <<

/** An action has %st.attrName=expr; or %{st}.attrName=expr; */
actionSetAttribute(st,attrName,expr) ::= <<
-(<st>).setAttribute("<attrName>",<expr>);
+(<st>).SetAttribute("<attrName>",<expr>);
>>

/** Translate %{stringExpr} */
diff --git a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll
index af4cdd4..b650bd2 100644
Binary files a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll and b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll differ
diff --git a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.pdb b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.pdb
index 652d0ed..95cccc6 100644
Binary files a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.pdb and b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.pdb differ

